E_FAIL;
    }

  SAFERELEASE(piows);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CSession::_InitRequestObject(void)
{
  DEBUG_ENTER((
    DBG_REQUEST,
    rt_hresult,
    "CSession::_InitRequestObject",
    "this=%#x",
    this
    ));

  HRESULT          hr    = S_OK;
  WSABUF*          pwb   = NULL;
  IObjectWithSite* piows = NULL;

  // terminate previous request object, if there is one
  SAFETERMINATE(m_requestobj);
  m_requestobj = NULL;

  m_socketobj->GetRecvBuffer(&pwb);
  
    if( SUCCEEDED(REQUESTOBJ::Create(pwb->buf, m_socketobj->GetBytesReceived(), &m_requestobj)) )
    {
      m_requestobj->QueryInterface(
                      IID_IObjectWithSite,
                      (void**) &piows
                      );
      
      piows->SetSite(dynamic_cast<ISession*>(this));
    }
    else
    {
      DEBUG_TRACE(SESSION, ("failed to create request object"));
      hr = E_FAIL;
    }

  SAFERELEASE(piows);

  DEBUG_LEAVE(hr);
  return hr;
}


BOOL
CSession::_SetNextServerState(SERVERSTATE state)
{
  SERVERSTATE s_current = m_socketobj->GetServerState();
  SERVERSTATE s_new;

  if( state == SS_SOCKET_DISCONNECTED )
  {
    m_socketobj->SetServerState(state);
    return TRUE;
  }

  if( s_current == state )
  {
    switch( state )
    {
      case SS_START_STATE :
        {
          s_new = SS_SOCKET_CONNECTED;          
        }
        break;

      case SS_SOCKET_CONNECTED :
        {
          s_new = SS_REQUEST_PENDING;          
        }
        break;

      case SS_REQUEST_PENDING :
        {
          s_new = SS_REQUEST_COMPLETE;          
        }
        break;

      case SS_REQUEST_COMPLETE :
        {
          s_new = SS_RESPONSE_PENDING;          
        }
        break;

      case SS_RESPONSE_PENDING :
        {
          s_new = SS_RESPONSE_COMPLETE;
        }
        break;

      case SS_RESPONSE_COMPLETE :
        {
          s_new = SS_REQUEST_PENDING;          
        }
        break;
    }

    m_socketobj->SetServerState(s_new);
    return TRUE;
  }

  return FALSE;
}


HRESULT
CSession::_InitScriptEngine(void)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::_InitScriptEngine",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  hr = m_pas->AddNamedItem(
         g_wszSessionObjectName,
         SCRIPTITEM_ISPERSISTENT | SCRIPTITEM_ISVISIBLE
         );

    if( FAILED(hr) )
      goto quit;

  hr = m_pas->AddNamedItem(
         g_wszRuntimeObjectName,
         SCRIPTITEM_ISPERSISTENT | SCRIPTITEM_ISVISIBLE | SCRIPTITEM_GLOBALMEMBERS
         );

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CSession::_LoadScript(void)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::_LoadScript",
    "this=%#x",
    this
    ));

  HRESULT             hr         = S_OK;
  LPWSTR              scriptpath = NULL;
  IActiveScriptParse* parse      = NULL;
  IW3SpoofFile*       pw3sf      = NULL;
  EXCEPINFO           excepinfo;
  NEWVARIANT(scriptdata);
  
  hr = m_pw3s->GetScriptPath(m_wszClient, &scriptpath);

    if( FAILED(hr) )
      goto quit;

  if( SUCCEEDED(FILEOBJ::Create(&pw3sf)) )
  {
    BSTR path = __widetobstr(scriptpath);
    NEWVARIANT(mode);

    V_VT(&mode)  = VT_UI4;
    V_UI4(&mode) = OPEN_EXISTING;

    if( SUCCEEDED(pw3sf->Open(path, mode, NULL)) )
    {
      if( FAILED(pw3sf->ReadAll(&scriptdata)) )
      {
        hr = E_FAIL;
      }

      pw3sf->Close();
    }
    else
    {
      hr = E_FAIL;
    }

    SysFreeString(path);
    VariantClear(&mode);
  }
  
    if( FAILED(hr) )
      goto quit;

  hr = m_pas->QueryInterface(IID_IActiveScriptParse, (void**) &parse);

    if( FAILED(hr) )
      goto quit;

  hr = parse->ParseScriptText(
               V_BSTR(&scriptdata),
               NULL,
               NULL,
               NULL,
               (DWORD) this,
               0,
               SCRIPTTEXT_ISPERSISTENT | SCRIPTTEXT_ISVISIBLE,
               NULL,
               &excepinfo
               );
  
    if( FAILED(hr) )
      goto quit;

  hr = m_pas->SetScriptState(SCRIPTSTATE_STARTED);

    if( FAILED(hr) )
    {
      DEBUG_TRACE(SESSION, ("error starting script engine, probably a script error: %s", MapHResultToString(hr)));
      goto quit;
    }

quit:

  SAFERELEASE(pw3sf);
  SAFERELEASE(parse);
  VariantClear(&scriptdata);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CSession::_LoadScriptDispids(void)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "_LoadScriptDispids",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  SAFERELEASE(m_psd);

  hr = m_pas->GetScriptDispatch(NULL, &m_psd);

    if( FAILED(hr) )
    {
      DEBUG_TRACE(SESSION, ("error getting script dispatch"));
      goto quit;
    }

  for(DWORD n=0; n<SCRIPTHANDLERS; n++)
  {
    hr = m_psd->GetIDsOfNames(
                  IID_NULL,
                  &g_arHandlerNames[n], 1,
                  m_lcid,
                  &m_arHandlerDispids[n]
                  );

    if( SUCCEEDED(hr) )
    {
      DEBUG_TRACE(SESSION, ("found %S handler", g_arHandlerNames[n]));
    }
  }

  // fix up the error code. since we made it this far, the only thing
  // to have gone wrong is that a handler wasn't found. spoof can run
  // with no handlers implemented so this isn't a bad thing to ignore.
  hr = S_OK;

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CSession::_SetScriptSite(BOOL bClone)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "_SetScriptSite",
    "this=%#x; bClone=%d",
    this,
    bClone
    ));

  HRESULT hr = S_OK;

  DEBUG_TRACE(SESSION, ("setting script site"));
  hr = m_pas->SetScriptSite(dynamic_cast<IActiveScriptSite*>(this));
    
  if( bClone )
  {
    DEBUG_TRACE(SESSION, ("starting cloned engine"));
    hr = m_pas->SetScriptState(SCRIPTSTATE_STARTED);
    hr = _LoadScriptDispids();
  }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CSession::_ResetScriptEngine(void)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "_ResetScriptEngine",
    "this=%#x",
    this
    ));

  HRESULT        hr  = S_OK;
  IActiveScript* pas = NULL;

  if( m_pas )
  {
    hr = m_pas->Clone(&pas);

    if( SUCCEEDED(hr) )
    {
      hr = m_pas->Close();

      if( SUCCEEDED(hr) )
      {
        SAFERELEASE(m_pas);
        m_pas            = pas;
        m_CurrentHandler = Global;
      }
    }
  }

  DEBUG_LEAVE(hr);
  return hr;
}


void
CSession::_SetObjectState(STATE state)
{
  if( m_objstate != ST_ERROR )
  {
    DEBUG_TRACE(SESSION, ("session object state now %s", MapStateToString(state)));
    m_objstate = state;
    m_pw3s->Notify(m_wszClientId, this, state);
  }
}


void
CSession::_SetKeepAlive(PIOCTX pioc)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_void,
    "_SetKeepAlive",
    "this=%#x; pioc=%#x",
    this,
    pioc
    ));

  LPSTR term = strstr(pioc->pwsa->buf, "\r\n\r\n");
  LPSTR tmp  = NULL;

  //
  // keep-alive decision is based on:
  //
  // if http/1.0 && connection: keep-alive then k-a.
  // if http/1.0 && !(connection: keep-alive) then !k-a.
  // if http/1.1 && connection: keep-alive then k-a.
  // if http/1.1 && connection: close then !k-a.
  // if http/1.1 && !(connection) then k-a.
  //

  if( term )
  {
    term[0] = '\0';
    tmp     = __strdup(pioc->pwsa->buf);
    term[0] = '\r';
    
    if( tmp )
    {
      _strlwr(tmp);

      if( strstr(tmp, "connection") )
      {
        m_bIsKeepAlive = strstr(tmp, "keep-alive") ? TRUE : FALSE;
      }
      else
      {
        m_bIsKeepAlive = strstr(tmp, "http/1.1") ? TRUE : FALSE;
      }
    }
  }

  DEBUG_TRACE(
    SESSION,
    ("session is %s", m_bIsKeepAlive ? "keep alive" : "not keep alive")
    );

  SAFEDELETEBUF(tmp);
  DEBUG_LEAVE(0);
}


void
CSession::_Lock(void)
{
  if( m_objstate != ST_CLOSED )
  {
    EnterCriticalSection(&m_lock);
    DEBUG_TRACE(SESSION, ("session [%#x] locked", this));
    return;
  }

  DEBUG_TRACE(SESSION, ("attempt to lock session in ST_CLOSED!!"));
}


void
CSession::_Unlock(void)
{
  if( m_objstate != ST_CLOSED )
  {
    DEBUG_TRACE(SESSION, ("session [%#x] unlocked", this));
    LeaveCriticalSection(&m_lock);
    return;
  }

  DEBUG_TRACE(SESSION, ("attempt to lock session in ST_CLOSED!!"));
}


//-----------------------------------------------------------------------------
// IUnknown
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CSession::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_REFCOUNT,
    rt_hresult,
    "CSession::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

  if( !((m_objstate >= ST_OPENING) && (m_objstate <= ST_CLOSING)) )
  {
    *ppv = NULL;
    hr   = E_FAIL;
    goto quit;
  }

    if(
      IsEqualIID(riid, IID_IUnknown) ||
      IsEqualIID(riid, IID_IDispatch) ||
      IsEqualIID(riid, IID_ISession)
      )
    {
      *ppv = static_cast<ISession*>(this);
    }
    else if( IsEqualIID(riid, IID_IProvideClassInfo) )
    {
      *ppv = static_cast<IProvideClassInfo*>(this);
    }
    else if( IsEqualIID(riid, IID_IActiveScriptSite) )
    {
      *ppv = static_cast<IActiveScriptSite*>(this);
    }
    else
    {
      *ppv = NULL;
      hr   = E_NOINTERFACE;
    }

  if( SUCCEEDED(hr) )
  {
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


ULONG
__stdcall
CSession::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("CSession", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
CSession::Release(void)
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("CSession", m_cRefs);

  if( m_cRefs == 0 )
  {
    DEBUG_FINALRELEASE("CSession");
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IProvideClassInfo
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CSession::GetClassInfo(ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::GetClassInfo",
    "this=%#x; ppti=%#x",
    this,
    ppti
    ));

  HRESULT hr = S_OK;

    if( ppti )
    {
      hr = GetTypeInfoFromName(g_wszSessionObjectName, m_ptl, ppti);
    }
    else
    {
      hr = E_POINTER;
    }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\om\socket\socket.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Socket.cxx

Abstract:

    Implements the Socket object.
    
Author:

    Paul M Midgen (pmidge) 23-October-2000


Revision History:

    23-October-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

LPWSTR g_wszSocketObjectName = L"socket";


//-----------------------------------------------------------------------------
// CSocket methods
//-----------------------------------------------------------------------------
CSocket::CSocket():
  m_cRefs(1),
  m_socket(INVALID_SOCKET),
  m_local(NULL),
  m_remote(NULL),
  m_rcvd(NULL),
  m_sent(NULL),
  m_pSite(NULL),
  m_wszClientId(NULL),
  m_serverstate(SS_START_STATE),
  m_objstate(ST_CREATED)
{
  DEBUG_TRACE(SOCKET, ("CSocket created: %#x", this));
}


CSocket::~CSocket()
{
  DEBUG_TRACE(SOCKET, ("CSocket deleted: %#x", this));
  DEBUG_ASSERT((m_objstate == ST_CLOSED));
}


HRESULT
CSocket::Create(PIOCTX pioc, PSOCKETOBJ* ppsocketobj)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::Create",
    "pioc=%#x; ppsocketobj=%#x",
    pioc,
    ppsocketobj
    ));

  HRESULT    hr  = S_OK;
  PSOCKETOBJ pso = NULL;

  if( !pioc )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !ppsocketobj )
  {
    hr = E_POINTER;
    goto quit;
  }
  
  if( pso = new SOCKETOBJ )
  {
    if( SUCCEEDED(pso->_Initialize(pioc)) )
    {
      *ppsocketobj = pso;
    }
    else
    {
      delete pso;
      *ppsocketobj = NULL;
      hr           = E_FAIL;
    }
  }
  else
  {
    hr = E_OUTOFMEMORY;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CSocket::_Initialize(PIOCTX pioc)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::_Initialize",
    "this=%#x; pioc=%#x",
    this,
    pioc
    ));

  HRESULT hr = S_OK;

  m_socket      = pioc->socket;
  m_local       = pioc->local;
  m_remote      = pioc->remote;
  m_wszClientId = __wstrdup(pioc->clientid);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CSocket::Terminate(void)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::Terminate",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  _SetObjectState(ST_CLOSING);

    if( m_socket != INVALID_SOCKET )
    {
      shutdown(m_socket, SD_SEND);
      closesocket(m_socket);
    }

    SAFERELEASE(m_pSite);

    if( m_sent )
    {
      m_sent->FreeWSABuffer();
      m_sent->Release();
      m_sent = NULL;
    }

    if( m_rcvd )
    {
      m_rcvd->FreeWSABuffer();
      m_rcvd->Release();
      m_rcvd = NULL;
    }

    SAFEDELETEBUF(m_local->name);
    SAFEDELETEBUF(m_local->addr);
    SAFEDELETEBUF(m_remote->name);
    SAFEDELETEBUF(m_remote->addr);
    SAFEDELETE(m_local);
    SAFEDELETE(m_remote);
    SAFEDELETEBUF(m_wszClientId);

  _SetObjectState(ST_CLOSED);

  Release();

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CSocket::Run(PIOCTX pioc)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::Run",
    "this=%#x; pioc=%#x",
    this,
    pioc
    ));

  HRESULT hr = S_OK;

  DEBUG_TRACE(
    SOCKET,
    ("processing %s in server state %s", MapIOTYPEToString(pioc->Type()), MapStateToString(m_serverstate))
    );

    switch( m_serverstate )
    {
      case SS_REQUEST_PENDING :
        {
          hr = _Recv(pioc);
        }
        break;

      case SS_RESPONSE_PENDING :
        {
          hr = _Send(pioc);
        }
        break;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CSocket::_Send(PIOCTX pioc)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::_Send",
    "this=%#x; pioc=%#x",
    this,
    pioc
    ));

  HRESULT hr  = S_OK;
  DWORD   ret = ERROR_SUCCESS;

  if( m_objstate != ST_OPEN )
  {
    hr = E_UNEXPECTED;
    goto quit;
  }

  if( pioc->Type() != IOCT_SEND )
  {
    DEBUG_TRACE(SOCKET, ("io context has incorrect type, send aborted! [%s]", MapIOTYPEToString(pioc->Type())));
    hr = E_UNEXPECTED;
    goto quit;
  }

  if( m_serverstate == SS_SOCKET_CONNECTED || m_serverstate == SS_REQUEST_PENDING )
  {
    if( !_Flush() )
    {
      DEBUG_TRACE(SOCKET, ("network error detected during socket flush"));
      hr = E_FAIL;
      goto quit;
    }
  }

  DEBUG_DATA_DUMP(
    SOCKET,
    ("sending data", (LPBYTE) pioc->pwsa->buf, pioc->pwsa->len)
    );

  ret = WSASend(
          m_socket,
          pioc->pwsa, 1,
          &pioc->bytes,
          pioc->flags,
          &pioc->overlapped,
          NULL
          );

  if( ret == SOCKET_ERROR )
  {
    hr = _TestWinsockError();

    switch( hr )
    {
      case E_PENDING :
        {
          DEBUG_TRACE(SOCKET, ("send completing async"));
        }
        break;

      default :
        {
          DEBUG_TRACE(SOCKET, ("unrecoverable socket error occurred"));
          SetServerState(SS_SOCKET_DISCONNECTED);
        }
    }
  }
  else
  {
    DEBUG_TRACE(SOCKET, ("sent %d bytes", pioc->bytes));
  }

quit:

  if( SUCCEEDED(hr) || hr == E_PENDING )
  {
    if( m_sent )
    {
      m_sent->FreeWSABuffer();
      SAFERELEASE(m_sent);
    }

    m_sent = pioc;
    m_sent->AddRef();
  }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CSocket::_Recv(PIOCTX pioc)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::_Recv",
    "this=%#x; pioc=%#x",
    this,
    pioc
    ));

  HRESULT hr  = S_OK;
  DWORD   ret = ERROR_SUCCESS;

  if( m_objstate != ST_OPEN || m_serverstate == SS_SOCKET_DISCONNECTED )
  {
    hr = E_UNEXPECTED;
    goto quit;
  }

  if( pioc->Type() != IOCT_RECV )
  {
    DEBUG_TRACE(SOCKET, ("io context has incorrect type, recv aborted! [%s]", MapIOTYPEToString(pioc->Type())));
    hr = E_UNEXPECTED;
    goto quit;
  }

  if( !pioc->AllocateWSABuffer(4096, NULL) )
  {
    hr = E_OUTOFMEMORY;
    goto quit;
  }

retry:

  ret = WSARecv(
          m_socket,
          pioc->pwsa, 1,
          &pioc->bytes,
          &pioc->flags,
          &pioc->overlapped,
          NULL
          );

  if( ret == SOCKET_ERROR )
  {
    hr = _TestWinsockError();

    switch( hr )
    {
      case E_PENDING :
        {
          DEBUG_TRACE(SOCKET, ("recv completing async"));
        }
        break;

      case E_OUTOFMEMORY :
        {
          if( _ResizeBuffer(pioc, pioc->bufsize*2) )
          {
            goto retry;
          }
          else
          {
            DEBUG_TRACE(SOCKET, ("error resizing receive buffer"));
          }
        }
        break;

      default :
        {
          DEBUG_TRACE(SOCKET, ("unrecoverable socket error occurred"));
          SetServerState(SS_SOCKET_DISCONNECTED);
        }
    }
  }
  else
  {
    if( pioc->bytes == 0 )
    {
      DEBUG_TRACE(SOCKET, ("detected socket close"));
      SetServerState(SS_SOCKET_DISCONNECTED);
      hr = E_FAIL;
    }
    else
    {
      DEBUG_DATA_DUMP(
        SOCKET,
        ("received data", (LPBYTE) pioc->pwsa->buf, pioc->bytes)
        );
    }

    DEBUG_TRACE(SOCKET, ("received %d bytes", pioc->bytes));
  }
      
quit:

  if( SUCCEEDED(hr) || hr == E_PENDING )
  {
    if( m_rcvd )
    {
      m_rcvd->FreeWSABuffer();
      SAFERELEASE(m_rcvd);
    }

    m_rcvd = pioc;
    m_rcvd->AddRef();
  }

  DEBUG_LEAVE(hr);
  return hr;
}


BOOL
CSocket::_Flush(void)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_bool,
    "CSocket::_Flush",
    "this=%#x",
    this
    ));

  BOOL   bContinue = TRUE;
  DWORD  ret       = ERROR_SUCCESS;
  PIOCTX pioc      = new IOCTX(IOCT_DUMMY, INVALID_SOCKET);

  if( !pioc || !pioc->AllocateWSABuffer(4096, NULL) )
  {
    bContinue = FALSE;
    goto quit;
  }

retry:

  ret = recv(m_socket, pioc->pwsa->buf, pioc->pwsa->len, 0);

  if( ret == SOCKET_ERROR )
  {
    switch( _TestWinsockError() )
    {
      case E_OUTOFMEMORY :
        {
          if( _ResizeBuffer(pioc, pioc->bufsize*2) )
          {
            goto retry;
          }
          else
          {
            DEBUG_TRACE(SOCKET, ("error resizing flush buffer"));
            bContinue = FALSE;
          }
        }
        break;

      default :
        {
          DEBUG_TRACE(SOCKET, ("unrecoverable socket error occurred"));
          bContinue = FALSE;
          SetServerState(SS_SOCKET_DISCONNECTED);
        }
    }
  }

  if( bContinue )
  {
    DEBUG_TRACE(SOCKET, ("flushed %d bytes", pioc->bytes));
  }

quit:

  pioc->FreeWSABuffer();
  SAFERELEASE(pioc);

  DEBUG_LEAVE(bContinue);
  return bContinue;
}


HRESULT
CSocket::_TestWinsockError(void)
{
  HRESULT hr    = S_OK;
  DWORD   error = WSAGetLastError();

  switch( error )
  {
    case WSA_IO_PENDING :
      {
        hr = E_PENDING;
      }
      break;

    case WSAEMSGSIZE :
      {
        hr = E_OUTOFMEMORY;
      }
      break;

    default :
      {
        DEBUG_TRACE(SOCKET, ("socket error: %d [%s]", error, MapErrorToString(error)));
        hr = E_FAIL;
      }
  }

  return hr;
}


BOOL
CSocket::_ResizeBuffer(PIOCTX pioc, DWORD len)
{
  DEBUG_TRACE(
    SOCKET,
    ("resizing buffer %#x from %#x to %#x bytes", pioc->pwsa->buf, pioc->pwsa->len, len)
    );

  return pioc->ResizeWSABuffer(len);
}


SERVERSTATE
CSocket::GetServerState(void)
{
  return m_serverstate;
}


void
CSocket::SetServerState(SERVERSTATE ss)
{
  DEBUG_TRACE(SOCKET, ("new server state %s", MapStateToString(ss)));
  m_serverstate = ss;
}


void
CSocket::GetSendBuffer(WSABUF** ppwb)
{
  *ppwb = m_sent ? m_sent->pwsa : NULL;
}


void
CSocket::GetRecvBuffer(WSABUF** ppwb)
{
  *ppwb = m_rcvd ? m_rcvd->pwsa : NULL;
}


DWORD
CSocket::GetBytesSent(void)
{
  if( m_sent )
  {
    return m_sent->bytes;
  }
  else
  {
    return 0;
  }
}


DWORD
CSocket::GetBytesReceived(void)
{
  if( m_rcvd )
  {
    return m_rcvd->bytes;
  }
  else
  {
    return 0;
  }
}


void
CSocket::_SetObjectState(STATE state)
{
  if( m_objstate != ST_ERROR )
  {
    DEBUG_TRACE(SOCKET, ("socket object state now %s", MapStateToString(state)));
    m_objstate = state;
  }
}


//-----------------------------------------------------------------------------
// IUnknown
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CSocket::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_REFCOUNT,
    rt_hresult,
    "CSocket::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

    if(
      IsEqualIID(riid, IID_IUnknown) ||
      IsEqualIID(riid, IID_IDispatch) ||
      IsEqualIID(riid, IID_ISocket)
      )
    {
      *ppv = static_cast<ISocket*>(this);
    }
    else if( IsEqualIID(riid, IID_IObjectWithSite) )
    {
      *ppv = static_cast<IObjectWithSite*>(this);
    }
    else
    {
      *ppv = NULL;
      hr   = E_NOINTERFACE;
    }

  if( SUCCEEDED(hr) )
  {
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


ULONG
__stdcall
CSocket::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("CSocket", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
CSocket::Release(void)
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("CSocket", m_cRefs);

  if( m_cRefs == 0 )
  {
    DEBUG_FINALRELEASE("CSocket");
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IProvideClassInfo
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CSocket::GetClassInfo(ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::GetClassInfo",
    "this=%#x; ppti=%#x",
    this,
    ppti
    ));

  HRESULT            hr   = S_OK;
  IActiveScriptSite* pias = NULL;

    if( ppti )
    {
      hr = m_pSite->QueryInterface(IID_IActiveScriptSite, (void**) &pias);

      if( SUCCEEDED(hr) )
      {
        hr = pias->GetItemInfo(
                     g_wszSocketObjectName,
                     SCRIPTINFO_ITYPEINFO,
                     NULL,
                     ppti
                     );
      }
    }
    else
    {
      hr = E_POINTER;
    }

  SAFERELEASE(pias);

  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// IObjectWithSite
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CSocket::SetSite(IUnknown* pUnkSite)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::SetSite",
    "this=%#x; pUnkSite=%#x",
    this,
    pUnkSite
    ));

  HRESULT hr = S_OK;

    if( !pUnkSite )
    {
      hr = E_POINTER;
    }
    else
    {
      SAFERELEASE(m_pSite);

      m_pSite = pUnkSite;
      m_pSite->AddRef();
      _SetObjectState(ST_OPEN);
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSocket::GetSite(REFIID riid, void** ppvSite)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::GetSite",
    "this=%#x; riid=%s; ppvSite=%#x",
    this,
    MapIIDToString(riid),
    ppvSite
    ));

  HRESULT hr = S_OK;

    if( !ppvSite )
    {
      hr = E_POINTER;
    }
    else
    {
      hr = m_pSite->QueryInterface(riid, ppvSite);
    }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\om\socket\methods.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    methods.cxx

Abstract:

    Implements methods part of the Socket object's dual interface.
    
Author:

    Paul M Midgen (pmidge) 24-October-2000


Revision History:

    24-October-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

HRESULT
__stdcall
CSocket::Send(VARIANT Data)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::Send",
    "this=%#x",
    this
    ));

  HRESULT hr   = S_OK;
  DWORD   ret  = 0L;
  PIOCTX  pioc = new IOCTX(IOCT_SEND, INVALID_SOCKET);

  if( m_serverstate == SS_SOCKET_DISCONNECTED )
  {
    DEBUG_TRACE(SOCKET, ("ERROR! Attempt to send after socket disconnect!"));
    hr = E_UNEXPECTED;
    goto quit;
  }

  if( !pioc )
  {
    hr = E_OUTOFMEMORY;
    goto quit;
  }

  if( !__isempty(Data) )
  {
    if( !pioc->AllocateWSABuffer(0, NULL) )
    {
      hr = E_OUTOFMEMORY;
      goto quit;
    }

    pioc->clientid = m_wszClientId;

    hr = ProcessVariant(
           &Data,
           (LPBYTE*) &pioc->pwsa->buf,
           &pioc->pwsa->len,
           NULL
           );

      if( FAILED(hr) )
      {
        DEBUG_TRACE(SOCKET, ("failed to convert input to sendable data"));
        goto quit;
      }

    // we want this call to appear to complete synchronously
    pioc->DisableIoCompletion();

    hr = _Send(pioc);

    if( hr == E_PENDING )
    {
      DWORD flags = 0L;

      ret = WSAGetOverlappedResult(
              m_socket,
              &pioc->overlapped,
              &pioc->bytes,
              TRUE,
              &flags
              );

      hr = ret ? S_OK : E_FAIL;
    }

    if( SUCCEEDED(hr) )
    {
      SetServerState(SS_RESPONSE_COMPLETE);
    }
    else
    {
      if( _TestWinsockError() == E_FAIL )
      {
        DEBUG_TRACE(SOCKET, ("detected socket close"));
        SetServerState(SS_SOCKET_DISCONNECTED);
      }
    }
  }

quit:

  SAFERELEASE(pioc);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSocket::Recv(VARIANT *Data)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::Recv",
    "this=%#x",
    this
    ));

  HRESULT    hr   = S_OK;
  BOOL       ret  = TRUE;
  PIOCTX     pioc = new IOCTX(IOCT_RECV, INVALID_SOCKET);
  SAFEARRAY* psa  = NULL;

  if( (m_serverstate == SS_REQUEST_COMPLETE || m_serverstate == SS_RESPONSE_PENDING) )
  {
    DEBUG_TRACE(SOCKET, ("ERROR! Attempt to receive in invalid state!"));
    hr = E_UNEXPECTED;
    goto quit;
  }

  if( m_serverstate == SS_SOCKET_DISCONNECTED )
  {
    DEBUG_TRACE(SOCKET, ("ERROR! Attempt to receive after socket disconnect!"));
    hr = E_UNEXPECTED;
    goto quit;
  }

  // we want this call to appear to complete synchronously
  pioc->DisableIoCompletion();

  hr = _Recv(pioc);

  if( hr == E_PENDING )
  {
    DWORD flags = 0L;

    ret = WSAGetOverlappedResult(
            m_socket,
            &pioc->overlapped,
            &pioc->bytes,
            TRUE,
            &flags
            );

    hr = ret ? S_OK : E_FAIL;
  }

  if( SUCCEEDED(hr) )
  {
    psa = SafeArrayCreateVector(VT_UI1, 1, pioc->bytes);

    if( psa )
    {
      memcpy(
        (LPBYTE) psa->pvData,
        pioc->pwsa->buf,
        pioc->bytes
        );

      V_VT(Data)    = VT_ARRAY | VT_UI1;
      V_ARRAY(Data) = psa;

      SetServerState(SS_REQUEST_COMPLETE);
    }
    else
    {
      DEBUG_TRACE(SOCKET, ("ERROR! Failed to create safearray!"));
      hr = E_FAIL;
    }
  }
  else
  {
    if( _TestWinsockError() == E_FAIL )
    {
      DEBUG_TRACE(SOCKET, ("detected socket close"));
      SetServerState(SS_SOCKET_DISCONNECTED);
    }
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSocket::Close(VARIANT Method)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::Close",
    "this=%#x",
    this
    ));

  HRESULT hr   = S_OK;
  BOOL    mode = Method.boolVal;

    if( !mode )
    {
      struct linger _linger = {1, 0};

      setsockopt(
        m_socket,
        SOL_SOCKET, SO_LINGER,
        (char*) &_linger, sizeof(struct linger)
        );
    }
    else
    {
      shutdown(m_socket, SD_SEND);
    }
  
    closesocket(m_socket);

    m_socket = INVALID_SOCKET;

    SetServerState(SS_SOCKET_DISCONNECTED);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSocket::Resolve(BSTR Host, BSTR *Address)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::Resolve",
    "this=%#x",
    this
    ));

  HRESULT  hr   = S_OK;
  LPSTR    host = NULL;
  HOSTENT* ph   = NULL;
  in_addr  in   = {0};

  host = __widetoansi(Host);

  DEBUG_TRACE(SOCKET, ("resolving hostname \"%s\"", host));
  ph   = gethostbyname(host);

    if( ph )
    {
      in.s_addr = *((ULONG*) ph->h_addr_list[0]);
      DEBUG_TRACE(SOCKET, ("ip address: %s", inet_ntoa(in)));
      *Address  = __ansitobstr(inet_ntoa(in));
    }
    else
    {
      DEBUG_TRACE(SOCKET, ("resolution failed"));
      *Address = NULL;
    }

  SAFEDELETEBUF(host);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT 
__stdcall
CSocket::get_Parent(IDispatch** ppdisp)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::get_Parent",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( !ppdisp )
    {
      hr = E_POINTER;
    }
    else
    {
      hr = m_pSite->QueryInterface(IID_IDispatch, (void**) ppdisp);
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSocket::get_LocalName(BSTR *Name)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::get_LocalName",
    "this=%#x",
    this
    ));

  HRESULT hr  = S_OK;
  LPWSTR  wsz = NULL;

    if( !Name )
    {
      hr = E_POINTER;
    }
    else
    {
      wsz   = __ansitowide(m_local->name);
      *Name = SysAllocString(wsz);
    }

  SAFEDELETEBUF(wsz);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSocket::get_LocalAddress(BSTR *Address)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::get_LocalAddress",
    "this=%#x",
    this
    ));

  HRESULT hr  = S_OK;
  LPWSTR  wsz = NULL;

    if( !Address )
    {
      hr = E_POINTER;
    }
    else
    {
      wsz      = __ansitowide(m_local->addr);
      *Address = SysAllocString(wsz);
    }

  SAFEDELETEBUF(wsz);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSocket::get_LocalPort(VARIANT *Port)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::get_LocalPort",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( !Port )
    {
      hr = E_POINTER;
    }
    else
    {
      V_VT(Port)  = VT_UI2;
      V_UI2(Port) = m_local->port;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSocket::get_RemoteName(BSTR *Name)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::get_RemoteName",
    "this=%#x",
    this
    ));

  HRESULT hr  = S_OK;
  LPWSTR  wsz = NULL;

    if( !Name )
    {
      hr = E_POINTER;
    }
    else
    {
      wsz   = __ansitowide(m_remote->name);
      *Name = SysAllocString(wsz);
    }

  SAFEDELETEBUF(wsz);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSocket::get_RemoteAddress(BSTR *Address)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::get_RemoteAddress",
    "this=%#x",
    this
    ));

  HRESULT hr  = S_OK;
  LPWSTR  wsz = NULL;

    if( !Address )
    {
      hr = E_POINTER;
    }
    else
    {
      wsz      = __ansitowide(m_remote->addr);
      *Address = SysAllocString(wsz);
    }

  SAFEDELETEBUF(wsz);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSocket::get_RemotePort(VARIANT *Port)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::get_RemotePort",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( !Port )
    {
      hr = E_POINTER;
    }
    else
    {
      V_VT(Port)  = VT_UI2;
      V_UI2(Port) = m_remote->port;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSocket::get_Option(BSTR Option, VARIANT *Value)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::get_Option",
    "this=%#x",
    this
    ));

  HRESULT hr = E_NOTIMPL;
  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSocket::put_Option(BSTR Option, VARIANT Value)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::put_Option",
    "this=%#x",
    this
    ));

  HRESULT hr = E_NOTIMPL;
  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\om\session\scriptsite.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    scriptsite.cxx

Abstract:

    Implements the IActiveScriptSite interface for the session object.
    
Author:

    Paul M Midgen (pmidge) 10-October-2000


Revision History:

    10-October-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

extern LPWSTR g_wszRuntimeObjectName;

//-----------------------------------------------------------------------------
// IActiveScriptSite
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CSession::GetLCID(LCID* plcid)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::GetLCID",
    "this=%#x; plcid=%#x",
    this,
    plcid
    ));

  HRESULT hr = S_OK;

    if( !plcid )
    {
      hr = E_POINTER;
    }
    else
    {
      *plcid = MAKELCID(
                MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                SORT_DEFAULT
                );
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSession::GetItemInfo(LPCOLESTR pstrName, DWORD dwReturnMask, IUnknown** ppunk, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::GetItemInfo",
    "this=%#x; name=%S; retmask=%#x; ppunk=%#x; ppti=%#x",
    this,
    pstrName,
    dwReturnMask,
    ppunk,
    ppti
    ));

  HRESULT hr = S_OK;

  if( !pstrName )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

    if( dwReturnMask & SCRIPTINFO_IUNKNOWN )
    {
      if( !_wcsicmp(pstrName, g_wszRuntimeObjectName) )
      {
        IW3SpoofRuntime* pw3srt = NULL;

          if( SUCCEEDED(m_pw3s->GetRuntime(&pw3srt)) )
          {
            hr = pw3srt->QueryInterface(IID_IUnknown, (void**) ppunk);
          }
          else
          {
            hr     = E_FAIL;
            *ppunk = NULL;
          }

        SAFERELEASE(pw3srt);
      }
      else
      {
        hr = QueryInterface(IID_IUnknown, (void**) ppunk);
      }
    }
    else if( dwReturnMask & SCRIPTINFO_ITYPEINFO )
    {
      hr = GetTypeInfoFromName(pstrName, m_ptl, ppti);

      if( FAILED(hr) )
      {
        *ppti = NULL;
      }
    }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSession::GetDocVersionString(BSTR* pbstrVersion)
{
  DEBUG_TRACE(SESSION, ("NOTIMPL: IActiveScriptSite::GetDocVersionString()"));
  return E_NOTIMPL;
}


HRESULT
__stdcall
CSession::OnScriptTerminate(const VARIANT* pvarResult, const EXCEPINFO* pei)
{
  DEBUG_TRACE(SESSION, ("NOTIMPL: IActiveScriptSite::OnScriptTerminate()"));
  return E_NOTIMPL;
}


HRESULT
__stdcall
CSession::OnStateChange(SCRIPTSTATE ss)
{
  DEBUG_TRACE(SESSION, ("new script state %s", MapStateToString(ss)));
  return S_OK;
}


HRESULT
__stdcall
CSession::OnScriptError(IActiveScriptError* piase)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::OnScriptError",
    "this=%#x; piase=%#x",
    this,
    piase
    ));
  
  HRESULT   hr     = S_OK;
  DWORD     n      = 0L;
  DWORD     cookie = 0L;
  ULONG     line   = 0L;
  LONG      pos    = 0L;
  BSTR      bstr   = SysAllocStringLen(NULL, 256);
  WCHAR*    tmp    = NULL;
  EXCEPINFO ex;

    if( FAILED(piase->GetSourceLineText(&bstr)) )
    {
      SysFreeString(bstr);
      bstr = SysAllocString(L"source not available");
    }
    else
    {
      for(wcstok(bstr, L"\n"); n<line; n++)
      {
        tmp = wcstok(NULL, L"\n");
      }
    }

    piase->GetExceptionInfo(&ex);
    piase->GetSourcePosition(&cookie, &line, &pos);

    ++line;

    DEBUG_TRACE(SESSION, ("********* SCRIPT ERROR *********"));
    DEBUG_TRACE(SESSION, (" session: %x", cookie));
    DEBUG_TRACE(SESSION, (" line # : %d", line));
    DEBUG_TRACE(SESSION, (" char # : %d", pos));
    DEBUG_TRACE(SESSION, (" source : %S", ex.bstrSource));
    DEBUG_TRACE(SESSION, (" error  : %S", ex.bstrDescription));
    DEBUG_TRACE(SESSION, (" hresult: 0x%0.8X [%s]", ex.scode, MapHResultToString(ex.scode)));
    DEBUG_TRACE(SESSION, (" code   : %S", tmp ? tmp : bstr));
    DEBUG_TRACE(SESSION, ("********************************"));

    if( m_socketobj )
    {
      WCHAR*   buf    = new WCHAR[4096];
      LPWSTR   script = NULL;
      ISocket* ps     = NULL;

      m_pw3s->GetScriptPath(m_wszClient, &script);

      wsprintfW(
        buf,
        L"HTTP/1.1 500 Server Error\r\nContent-Type: text/html\r\nConnection: close\r\n\r\n" \
        L"<HTML><BODY style=\"font-family:courier new;\">\r\n" \
        L"<B>W3Spoof Script Error</B>\r\n" \
        L"<XMP>\r\n" \
        L"session: %#x\r\n" \
        L"handler: %S\r\n" \
        L"client : %s\r\n" \
        L"file   : %s\r\n" \
        L"error  : %s (%s)\r\n" \
        L"hresult: 0x%0.8X [%S]\r\n" \
        L"line # : %d\r\n" \
        L"char # : %d\r\n" \
        L"code   : %s\r\n" \
        L"</XMP>\r\n" \
        L"</BODY></HTML>",
        cookie,
        MapScriptDispidToString(m_CurrentHandler),
        m_wszClientId,
        script,
        ex.bstrSource,
        ex.bstrDescription,
        ex.scode,
        MapHResultToString(ex.scode),
        line,
        pos,
        tmp ? tmp : bstr
        );

      NEWVARIANT(error);

      V_VT(&error)   = VT_BSTR;
      V_BSTR(&error) = __widetobstr(buf);

      m_socketobj->QueryInterface(IID_ISocket, (void**) &ps);

      ps->Send(error);

      VariantClear(&error);
      SAFERELEASE(ps);
      SAFEDELETEBUF(buf);
    }    

  SysFreeString(bstr);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSession::OnEnterScript(void)
{
  DEBUG_TRACE(SESSION, ("****** ENTER %s HANDLER ******", MapScriptDispidToString(m_CurrentHandler)));
  return E_NOTIMPL;
}


HRESULT
__stdcall
CSession::OnLeaveScript(void)
{
  DEBUG_TRACE(SESSION, ("****** LEAVE %s HANDLER ******", MapScriptDispidToString(m_CurrentHandler)));
  return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\om\w3srt\guids.c ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    guids.c

Abstract:

    GUIDs for the w3spoof runtime objects.
    
Author:

    Paul M Midgen (pmidge) 06-November-2000

Revision History:

    06-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long  x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifdef __cplusplus
extern "C" {
#endif

// {B38C33BD-1623-4138-9DAB-7F81EBEB1A3D}
const IID IID_IW3SpoofRuntime = 
{
  0xb38c33bd,
  0x1623,
  0x4138,
  { 0x9d, 0xab, 0x7f, 0x81, 0xeb, 0xeb, 0x1a, 0x3d }
};


// {D128BB46-2C79-4432-91D9-5F5FCF240C83}
const IID IID_IW3SpoofFile = 
{
  0xd128bb46,
  0x2c79,
  0x4432,
  { 0x91, 0xd9, 0x5f, 0x5f, 0xcf, 0x24, 0xc, 0x83 }
};

// {B4560FD1-1EED-4d48-AAF1-88626F0A7EC4}
const IID IID_IW3SpoofPropertyBag = 
{
  0xb4560fd1,
  0x1eed,
  0x4d48,
  { 0xaa, 0xf1, 0x88, 0x62, 0x6f, 0xa, 0x7e, 0xc4 }
};

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\om\url\methods.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    methods.cxx

Abstract:

    Implements methods part of the Url object's dual interface.
    
Author:

    Paul M Midgen (pmidge) 10-November-2000


Revision History:

    10-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

HRESULT
__stdcall
CUrl::get_Parent(IDispatch **ppdisp)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::get_Parent",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( m_pSite )
    {
      hr = m_pSite->QueryInterface(IID_IDispatch, (void**) ppdisp);
    }
    else
    {
      hr = E_UNEXPECTED;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::get_Encoding(BSTR *Encoding)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::get_Encoding",
    "this=%#x",
    this
    ));

  HRESULT hr = E_NOTIMPL;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::get_Scheme(BSTR *Scheme)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::get_Scheme",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( Scheme )
    {
      *Scheme = __widetobstr(m_wszScheme);
    }
    else
    {
      hr = E_POINTER;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::put_Scheme(BSTR Scheme)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::put_Scheme",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( !m_bReadOnly )
    {
      SAFEDELETEBUF(m_wszScheme);

      m_wszScheme = __wstrdup(Scheme);
    }
    else
    {
      hr = E_ACCESSDENIED;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::get_Server(BSTR *Server)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::get_Server",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( Server )
    {
      *Server = __widetobstr(m_wszServer);
    }
    else
    {
      hr = E_POINTER;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::put_Server(BSTR Server)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::put_Server",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( !m_bReadOnly )
    {
      SAFEDELETEBUF(m_wszServer);

      m_wszServer = __wstrdup(Server);
    }
    else
    {
      hr = E_ACCESSDENIED;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::get_Port(VARIANT *Port)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::get_Port",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( Port )
    {
      V_UI2(Port) = m_usPort;
    }
    else
    {
      hr = E_POINTER;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::put_Port(VARIANT Port)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::put_Port",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( !m_bReadOnly )
    {
      m_usPort = V_UI2(&Port);
    }
    else
    {
      hr = E_ACCESSDENIED;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::get_Path(BSTR *Path)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::get_Path",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( Path )
    {
      *Path = __widetobstr(m_wszPath);
    }
    else
    {
      hr = E_POINTER;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::put_Path(BSTR Path)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::put_Path",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( !m_bReadOnly )
    {
      SAFEDELETEBUF(m_wszPath);

      m_wszPath = __wstrdup(Path);
    }
    else
    {
      hr = E_ACCESSDENIED;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::get_Resource(BSTR *Resource)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::get_Resource",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( Resource )
    {
      *Resource = __widetobstr(m_wszResource);
    }
    else
    {
      hr = E_POINTER;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::put_Resource(BSTR Resource)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::put_Resource",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( !m_bReadOnly )
    {
      SAFEDELETEBUF(m_wszResource);

      m_wszResource = __wstrdup(Resource);
    }
    else
    {
      hr = E_ACCESSDENIED;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::get_Query(BSTR *Query)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::get_Query",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( Query )
    {
      *Query = __widetobstr(m_wszQuery);
    }
    else
    {
      hr = E_POINTER;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::put_Query(BSTR Query)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::put_Query",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( !m_bReadOnly )
    {
      SAFEDELETEBUF(m_wszQuery);

      m_wszQuery = __wstrdup(Query);
    }
    else
    {
      hr = E_ACCESSDENIED;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::get_Fragment(BSTR *Fragment)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::get_Fragment",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( Fragment )
    {
      *Fragment = __widetobstr(m_wszFragment);
    }
    else
    {
      hr = E_POINTER;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::put_Fragment(BSTR Fragment)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::put_Fragment",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( !m_bReadOnly )
    {
      SAFEDELETEBUF(m_wszFragment);

      m_wszFragment = __wstrdup(Fragment);
    }
    else
    {
      hr = E_ACCESSDENIED;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::Escape(BSTR *Url)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::Escape",
    "this=%#x",
    this
    ));

  HRESULT hr = E_NOTIMPL;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::Unescape(BSTR *Url)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::Unescape",
    "this=%#x",
    this
    ));

  HRESULT hr = E_NOTIMPL;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::Set(BSTR Url)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::Set",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( !m_bReadOnly )
    {
      LPSTR szUrl;

      _Cleanup();

      szUrl = __widetoansi(Url);
      hr    = _Initialize(szUrl, FALSE);

      SAFEDELETEBUF(szUrl);
    }
    else
    {
      hr = E_ACCESSDENIED;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::Get(BSTR* Url)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::Get",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( Url )
    {
      *Url = __widetobstr(m_wszUrl);
    }
    else
    {
      hr = E_POINTER;
    }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\om\w3srt\propertybag.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    propertybag.cxx

Abstract:

    Implements the propertybag runtime object.
    
Author:

    Paul M Midgen (pmidge) 06-November-2000


Revision History:

    06-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
DISPIDTABLEENTRY g_PropertyBagDisptable[] =
{
  0x00003b7b,   DISPID_PROPERTYBAG_GET,      L"get",
  0x00003f5f,   DISPID_PROPERTYBAG_SET,      L"set",
  0x00043afe,   DISPID_PROPERTYBAG_EXPIRES,  L"expires",
  0x00010803,   DISPID_PROPERTYBAG_FLUSH,    L"flush"
};

DWORD g_cPropertyBagDisptable = (sizeof(g_PropertyBagDisptable) / sizeof(DISPIDTABLEENTRY));


//-----------------------------------------------------------------------------
// CW3SPropertyBag
//-----------------------------------------------------------------------------
CW3SPropertyBag::CW3SPropertyBag():
  m_cRefs(1),
  m_name(NULL),
  m_stale(FALSE),
  m_expiry(0),
  m_created(0),
  m_propertybag(NULL)
{
  DEBUG_TRACE(RUNTIME, ("CW3SPropertyBag created: %#x"));
}


CW3SPropertyBag::~CW3SPropertyBag()
{
  DEBUG_TRACE(RUNTIME, ("CW3SPropertyBag deleted: %#x"));
}


HRESULT
CW3SPropertyBag::Create(LPWSTR name, PPROPERTYBAG* ppbag)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SPropertyBag::Create",
    "name=%S; ppbag=%#x",
    name,
    ppbag
    ));

  HRESULT      hr   = S_OK;
  PPROPERTYBAG pbag = NULL;

    if( !ppbag )
    {
      hr = E_POINTER;
    }
    else
    {
      if( pbag = new PROPERTYBAG )
      {
        if( SUCCEEDED(pbag->_Initialize(name)) )
        {
          *ppbag = pbag;
        }
        else
        {
          DEBUG_TRACE(RUNTIME, ("failed to create propertybag"));
          delete pbag;
          *ppbag = NULL;
          hr     = E_FAIL;
        }
      }
      else
      {
        hr = E_OUTOFMEMORY;
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CW3SPropertyBag::_Initialize(LPWSTR name)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SPropertyBag::_Initialize",
    "this=%#x; name=%S",
    this,
    name
    ));

  HRESULT hr = S_OK;

    m_expiry      = 3600000;
    m_created     = GetTickCount();
    m_name        = __wstrdup(name);
    m_propertybag = new STRINGMAP;

    m_propertybag->SetClearFunction(VariantKiller);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CW3SPropertyBag::Terminate(void)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SPropertyBag::Terminate",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    m_propertybag->Clear();

    SAFEDELETE(m_propertybag);
    SAFEDELETEBUF(m_name);

    Release();

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CW3SPropertyBag::GetBagName(LPWSTR* ppwsz)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SPropertyBag::GetBagName",
    "this=%#x; ppwsz=%#x",
    this,
    ppwsz
    ));

  HRESULT hr = S_OK;
  
    if( !ppwsz )
    {
      hr = E_POINTER;
    }
    else
    {
      *ppwsz = __wstrdup(m_name);
    }

  DEBUG_LEAVE(hr);
  return hr;
}


void
CW3SPropertyBag::_Reset(void)
{
  m_created = GetTickCount();
  DEBUG_TRACE(RUNTIME, ("creation time reset to %d msec", m_created));
}


BOOL
CW3SPropertyBag::_IsStale(void)
{
  DWORD now = GetTickCount();
  BOOL  ret = FALSE;

  if( m_created + m_expiry < now )
  {
    DEBUG_TRACE(RUNTIME, ("property bag is stale, flushing"));
    Flush();
    _Reset();
    ret = TRUE;
  }
  else
  {
    DEBUG_TRACE(
      RUNTIME,
      ("property bag valid for another %d msec", m_created+m_expiry-now)
      );
  }

  return ret;
}

//-----------------------------------------------------------------------------
// IUnknown
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CW3SPropertyBag::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SPropertyBag::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

    if(
      IsEqualIID(riid, IID_IUnknown)  ||
      IsEqualIID(riid, IID_IDispatch) ||
      IsEqualIID(riid, IID_IW3SpoofPropertyBag)
      )
    {
      *ppv = static_cast<IW3SpoofPropertyBag*>(this);
    }
    else
    {
      *ppv = NULL;
      hr   = E_NOINTERFACE;
    }

  if( SUCCEEDED(hr) )
  {
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


ULONG
__stdcall
CW3SPropertyBag::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("CW3SPropertyBag", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
CW3SPropertyBag::Release(void)
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("CW3SPropertyBag", m_cRefs);

  if( m_cRefs == 0 )
  {
    DEBUG_FINALRELEASE("CW3SPropertyBag");
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IDispatch
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CW3SPropertyBag::GetTypeInfoCount(UINT* pctinfo)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SPropertyBag::GetTypeInfoCount",
    "this=%#x; pctinfo=%#x",
    this,
    pctinfo
    ));

  HRESULT hr = E_NOTIMPL;

    if( pctinfo )
    {
      *pctinfo = 0;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SPropertyBag::GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SPropertyBag::GetTypeInfo",
    "this=%#x; index=%#x; lcid=%#x; ppti=%#x",
    this,
    index,
    lcid,
    ppti
    ));

  HRESULT hr = E_NOTIMPL;

    if( ppti )
    {
      *ppti = NULL;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SPropertyBag::GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SPropertyBag::GetIDsOfNames",
    "this=%#x; riid=%s; arNames=%#x; cNames=%d; lcid=%#x; arDispId=%#x",
    this,
    MapIIDToString(riid),
    arNames,
    cNames,
    lcid,
    arDispId
    ));

  HRESULT hr = S_OK;
  UINT    n  = 0L;

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  while( n < cNames )
  {
    arDispId[n] = GetDispidFromName(g_PropertyBagDisptable, g_cPropertyBagDisptable, arNames[n]);
    ++n;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SPropertyBag::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SPropertyBag::Invoke",
    "this=%#x; dispid=%s; riid=%s; lcid=%#x; flags=%#x; pdp=%#x; pvr=%#x; pei=%#x; pae=%#x",
    this,
    MapDispidToString(dispid),
    MapIIDToString(riid),
    lcid,
    flags,
    pdp, pvr,
    pei, pae
    ));

  HRESULT hr = S_OK;

  // make sure there aren't any bits set we don't understand
  if( flags & ~(DISPATCH_METHOD | DISPATCH_PROPERTYGET | DISPATCH_PROPERTYPUT) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = DISP_E_UNKNOWNINTERFACE;
    goto quit;
  }

  if( !pdp )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( pae )
  {
    *pae = 0;
  }

  if( pvr )
  {
    VariantInit(pvr);
  }

  switch( dispid )
  {
    case DISPID_PROPERTYBAG_GET :
      {
        NEWVARIANT(name);

        if( pdp->cArgs == 1 )
        {
          if( pvr )
          {
            DispGetParam(pdp, 0, VT_BSTR, &name, pae);

              hr = Get(V_BSTR(&name), pvr);

            VariantClear(&name);
          }
          else
          {
            hr = DISP_E_PARAMNOTOPTIONAL;
          }
        }
        else
        {
          hr = DISP_E_BADPARAMCOUNT;
        }
      }
      break;

    case DISPID_PROPERTYBAG_SET :
      {
        NEWVARIANT(name);
        NEWVARIANT(value);

        if( pdp->cArgs == 2 )
        {
          hr = VariantCopy(&value, &pdp->rgvarg[0]);
        }
        
        DispGetParam(pdp, 0, VT_BSTR, &name, pae);
        
          hr = Set(V_BSTR(&name), value);

        VariantClear(&name);
        VariantClear(&value);
      }
      break;

    case DISPID_PROPERTYBAG_EXPIRES :
      {
        if( flags & DISPATCH_PROPERTYGET )
        {
          V_VT(pvr) = VT_UI4;
          hr        = get_Expires(pvr);
        }
        else if( flags & DISPATCH_PROPERTYPUT || flags & DISPATCH_METHOD )
        {
          NEWVARIANT(expiry);

          hr = DispGetParam(pdp, 0, VT_UI4, &expiry, pae);

            if( SUCCEEDED(hr) )
            {
              hr = put_Expires(expiry);
            }

          VariantClear(&expiry);
        }
      }
      break;

    case DISPID_PROPERTYBAG_FLUSH :
      {
        Flush();
      }
      break;

    default :
    {
      hr = DISP_E_MEMBERNOTFOUND;
    }
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// IW3SpoofPropertyBag
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CW3SPropertyBag::Get(BSTR Name, VARIANT* Value)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SPropertyBag::Get",
    "this=%#x; name=%S",
    this,
    Name
    ));

  HRESULT  hr  = S_OK;
  VARIANT* pvr = NULL;

  _IsStale();

    if( !Name )
    {
      hr = E_INVALIDARG;
    }
    else
    {
      if( m_propertybag->Get(Name, (void**) &pvr) == ERROR_SUCCESS )
      {
        hr = VariantCopy(Value, pvr);

        //
        // TODO: debug logging function that accepts Name & pvr
        //       and outputs useful information (name, type, data, etc.)
        //
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SPropertyBag::Set(BSTR Name, VARIANT Value)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SPropertyBag::Set",
    "this=%#x; name=%S",
    this,
    Name
    ));

  HRESULT  hr  = S_OK;
  VARIANT* pvr = NULL;

  _IsStale();

    if( !Name )
    {
      hr = E_INVALIDARG;
    }
    else
    {
      if( !__isempty(Value) )
      {
        pvr = new VARIANT;
        VariantInit(pvr);

        hr = VariantCopy(pvr, &Value);

        if( SUCCEEDED(hr) )
        {
          //
          // TODO: debug logging function that accepts Name & pvr
          //       and outputs useful information (name, type, data, etc.)
          //
          m_propertybag->Insert(Name, (void*) pvr);
        }
      }
      else
      {
        DEBUG_TRACE(RUNTIME, ("removing property \"%S\"", Name));
        m_propertybag->Delete(Name, NULL);
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SPropertyBag::get_Expires(VARIANT* Expiry)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SPropertyBag::get_Expires",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    V_UI4(Expiry) = m_expiry;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SPropertyBag::put_Expires(VARIANT Expiry)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SPropertyBag::put_Expires",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    m_expiry = V_UI4(&Expiry);
    DEBUG_TRACE(RUNTIME, ("property bag will expire in %d msec", m_expiry));
    _Reset();

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SPropertyBag::Flush(void)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SPropertyBag::Flush",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    m_propertybag->Clear();
    DEBUG_TRACE(RUNTIME, ("property bag has been flushed"));

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\om\url\dispatch.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dispatch.cxx

Abstract:

    Implements the IDispatch interface for the Url object.
    
Author:

    Paul M Midgen (pmidge) 10-November-2000


Revision History:

    10-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
DISPIDTABLEENTRY g_UrlDisptable[] =
{
  0x00021b1c,   DISPID_URL_PARENT,      L"parent",
  0x00082181,   DISPID_URL_ENCODING,    L"encoding",
  0x00021d6b,   DISPID_URL_SCHEME,      L"scheme",
  0x00022ba1,   DISPID_URL_SERVER,      L"server",
  0x000087f5,   DISPID_URL_PORT,        L"port",
  0x000082c3,   DISPID_URL_PATH,        L"path",
  0x0008aae1,   DISPID_URL_RESOURCE,    L"resource",
  0x000117c9,   DISPID_URL_QUERY,       L"query",
  0x000835fa,   DISPID_URL_FRAGMENT,    L"fragment",
  0x00020a65,   DISPID_URL_ESCAPE,      L"escape",
  0x0008c90f,   DISPID_URL_UNESCAPE,    L"unescape",
  0x00003f5f,   DISPID_URL_SET,         L"set",
  0x00003b7b,   DISPID_URL_GET,         L"get"
};

DWORD g_cUrlDisptable = (sizeof(g_UrlDisptable) / sizeof(DISPIDTABLEENTRY));

//-----------------------------------------------------------------------------
// IDispatch
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CUrl::GetTypeInfoCount(UINT* pctinfo)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CUrl::GetTypeInfoCount",
    "this=%#x; pctinfo=%#x",
    this,
    pctinfo
    ));

  HRESULT hr = S_OK;

    if( !pctinfo )
    {
      hr = E_POINTER;
    }
    else
    {
      *pctinfo = 1;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CUrl::GetTypeInfo",
    "this=%#x; index=%#x; lcid=%#x; ppti=%#x",
    this,
    index,
    lcid,
    ppti
    ));

  HRESULT hr   = S_OK;

  if( !ppti )
  {
    hr = E_POINTER;
  }
  else
  {
    if( index != 0 )
    {
      hr    = DISP_E_BADINDEX;
      *ppti = NULL;
    }
    else
    {
      hr = GetClassInfo(ppti);
    }
  }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CUrl::GetIDsOfNames",
    "this=%#x; riid=%s; arNames=%#x; cNames=%d; lcid=%#x; arDispId=%#x",
    this,
    MapIIDToString(riid),
    arNames,
    cNames,
    lcid,
    arDispId
    ));

  HRESULT hr = S_OK;
  UINT    n  = 0L;

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  while( n < cNames )
  {
    arDispId[n] = GetDispidFromName(g_UrlDisptable, g_cUrlDisptable, arNames[n]);
    ++n;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CUrl::Invoke",
    "this=%#x; dispid=%s; riid=%s; lcid=%#x; flags=%#x; pdp=%#x; pvr=%#x; pei=%#x; pae=%#x",
    this,
    MapDispidToString(dispid),
    MapIIDToString(riid),
    lcid,
    flags,
    pdp, pvr,
    pei, pae
    ));

  HRESULT hr = S_OK;

  hr = ValidateDispatchArgs(riid, pdp, pvr, pae);

    if( FAILED(hr) )
      goto quit;

  switch( dispid )
  {
    case DISPID_URL_PARENT :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          V_VT(pvr) = VT_DISPATCH;
          hr        = get_Parent(&V_DISPATCH(pvr));
        }
      }
      break;

    case DISPID_URL_ENCODING :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          V_VT(pvr) = VT_BSTR;
          hr        = get_Encoding(&V_BSTR(pvr));
        }
      }
      break;

    case DISPID_URL_SCHEME :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          if( flags & DISPATCH_PROPERTYPUT )
          {
            hr = ValidateArgCount(pdp, 1, FALSE, 0);

            if( SUCCEEDED(hr) )
            {
              hr = put_Scheme(
                     V_BSTR(&pdp->rgvarg[0])
                     );
            }
          }

          if( (flags & DISPATCH_PROPERTYGET) && SUCCEEDED(hr) )
          {
            V_VT(pvr) = VT_BSTR;
            hr        = get_Scheme(
                          &V_BSTR(pvr)
                          );
          }
        }
      }
      break;

    case DISPID_URL_SERVER :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          if( flags & DISPATCH_PROPERTYPUT )
          {
            hr = ValidateArgCount(pdp, 1, FALSE, 0);

            if( SUCCEEDED(hr) )
            {
              hr = put_Server(
                     V_BSTR(&pdp->rgvarg[0])
                     );
            }
          }

          if( (flags & DISPATCH_PROPERTYGET) && SUCCEEDED(hr) )
          {
            V_VT(pvr) = VT_BSTR;
            hr        = get_Server(
                          &V_BSTR(pvr)
                          );
          }
        }
      }
      break;

    case DISPID_URL_PORT :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          if( flags & DISPATCH_PROPERTYPUT )
          {
            hr = ValidateArgCount(pdp, 1, FALSE, 0);

            if( SUCCEEDED(hr) )
            {
              hr = put_Port(pdp->rgvarg[0]);
            }
          }

          if( (flags & DISPATCH_PROPERTYGET) && SUCCEEDED(hr) )
          {
            V_VT(pvr) = VT_UI2;
            hr        = get_Port(pvr);
          }
        }
      }
      break;

    case DISPID_URL_PATH :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          if( flags & DISPATCH_PROPERTYPUT )
          {
            hr = ValidateArgCount(pdp, 1, FALSE, 0);

            if( SUCCEEDED(hr) )
            {
              hr = put_Path(
                     V_BSTR(&pdp->rgvarg[0])
                     );
            }
          }

          if( (flags & DISPATCH_PROPERTYGET) && SUCCEEDED(hr) )
          {
            V_VT(pvr) = VT_BSTR;
            hr        = get_Path(
                          &V_BSTR(pvr)
                          );
          }
        }
      }
      break;

    case DISPID_URL_RESOURCE :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          if( flags & DISPATCH_PROPERTYPUT )
          {
            hr = ValidateArgCount(pdp, 1, FALSE, 0);

            if( SUCCEEDED(hr) )
            {
              hr = put_Resource(
                     V_BSTR(&pdp->rgvarg[0])
                     );
            }
          }

          if( (flags & DISPATCH_PROPERTYGET) && SUCCEEDED(hr) )
          {
            V_VT(pvr) = VT_BSTR;
            hr        = get_Resource(
                          &V_BSTR(pvr)
                          );
          }
        }
      }
      break;

    case DISPID_URL_QUERY :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          if( flags & DISPATCH_PROPERTYPUT )
          {
            hr = ValidateArgCount(pdp, 1, FALSE, 0);

            if( SUCCEEDED(hr) )
            {
              hr = put_Query(
                     V_BSTR(&pdp->rgvarg[0])
                     );
            }
          }

          if( (flags & DISPATCH_PROPERTYGET) && SUCCEEDED(hr) )
          {
            V_VT(pvr) = VT_BSTR;
            hr        = get_Query(
                          &V_BSTR(pvr)
                          );
          }
        }
      }
      break;

    case DISPID_URL_FRAGMENT :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          if( flags & DISPATCH_PROPERTYPUT )
          {
            hr = ValidateArgCount(pdp, 1, FALSE, 0);

            if( SUCCEEDED(hr) )
            {
              hr = put_Fragment(
                     V_BSTR(&pdp->rgvarg[0])
                     );
            }
          }

          if( (flags & DISPATCH_PROPERTYGET) && SUCCEEDED(hr) )
          {
            V_VT(pvr) = VT_BSTR;
            hr        = get_Fragment(
                          &V_BSTR(pvr)
                          );
          }
        }
      }
      break;

    case DISPID_URL_GET :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 0, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            if( pvr )
            {
              V_VT(pvr) = VT_BSTR;
              hr        = Get(&V_BSTR(pvr));
            }
          }
        }
      }
      break;

    case DISPID_URL_SET :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = Set(
                   V_BSTR(&pdp->rgvarg[0])
                   );
          }
        }
      }
      break;

    case DISPID_URL_ESCAPE :
    case DISPID_URL_UNESCAPE :
      {
        hr = E_NOTIMPL;
      }
      break;

    default : hr = DISP_E_MEMBERNOTFOUND;
  }

quit:

  if( FAILED(hr) )
  {
    hr = HandleDispatchError(L"url object", pei, hr);
  }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\om\url\url.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    url.cxx

Abstract:

    Implements the Url object.
    
Author:

    Paul M Midgen (pmidge) 10-November-2000


Revision History:

    10-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

LPWSTR g_wszUrlObjectName = L"url";

//-----------------------------------------------------------------------------
// CUrl methods
//-----------------------------------------------------------------------------
CUrl::CUrl():
  m_cRefs(1),
  m_pSite(NULL),
  m_pti(NULL),
  m_bReadOnly(FALSE),
  m_szOriginalUrl(NULL),
  m_szUnescapedUrl(NULL),
  m_bEscaped(FALSE),
  m_wszUrl(NULL),
  m_wszScheme(NULL),
  m_usPort(0),
  m_wszServer(NULL),
  m_wszPath(NULL),
  m_wszResource(NULL),
  m_wszQuery(NULL),
  m_wszFragment(NULL)
{
  DEBUG_TRACE(URL, ("CUrl [%#x] created", this));
}


CUrl::~CUrl()
{
  DEBUG_TRACE(URL, ("CUrl [%#x] deleted", this));
}


HRESULT
CUrl::Create(CHAR* url, BOOL bReadOnly, PURLOBJ* ppurl)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::Create",
    "url=%s; bReadOnly=%d; ppurl=%#x",
    url,
    bReadOnly,
    ppurl
    ));

  HRESULT hr  = S_OK;
  PURLOBJ puo = NULL;

  if( !url )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !ppurl )
  {
    hr = E_POINTER;
    goto quit;
  }
  
  if( puo = new URLOBJ )
  {
    if( SUCCEEDED(puo->_Initialize(url, bReadOnly)) )
    {
      *ppurl = puo;
    }
    else
    {
      delete puo;
      *ppurl = NULL;
      hr     = E_FAIL;
    }
  }
  else
  {
    hr = E_OUTOFMEMORY;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CUrl::_Initialize(CHAR* url, BOOL bReadOnly)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::_Initialize",
    "this=%#x; bReadOnly=%d; url=%s",
    this,
    bReadOnly,
    url
    ));

  HRESULT hr       = S_OK;
  BOOL    bCracked = FALSE;
  URLCOMP uc;

  if( !url )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  m_bReadOnly      = bReadOnly;
  m_szOriginalUrl  = __strdup(url);
  m_szUnescapedUrl = __unescape(url);  
  m_wszUrl         = __ansitowide(m_szUnescapedUrl);

  uc.dwStructSize      = sizeof(URLCOMP);
  uc.lpszScheme        = NULL;
  uc.dwSchemeLength    = -1;
  uc.nScheme           = INTERNET_SCHEME_UNKNOWN;
  uc.lpszHostName      = NULL;
  uc.dwHostNameLength  = -1;
  uc.nPort             = 0;
  uc.lpszUrlPath       = NULL;
  uc.dwUrlPathLength   = -1;
  uc.lpszExtraInfo     = NULL;
  uc.dwExtraInfoLength = -1;
  uc.lpszUserName      = NULL;
  uc.dwUserNameLength  = 0L;
  uc.lpszPassword      = NULL;
  uc.dwPasswordLength  = 0L;

  bCracked = WinHttpCrackUrl(
               m_wszUrl,
               wcslen(m_wszUrl),
               0,
               &uc
               );

  if( bCracked && (uc.nScheme != INTERNET_SCHEME_UNKNOWN) )
  {
    WCHAR* token = NULL;
    WCHAR* tmp   = NULL;

    // duplicate the scheme and hostname fields
    m_wszScheme   = __wstrndup(uc.lpszScheme, uc.dwSchemeLength);
    m_wszServer   = __wstrndup(uc.lpszHostName, uc.dwHostNameLength);

    // split out and duplicate the path and resource fields
    tmp           = __wstrndup(uc.lpszUrlPath, uc.dwUrlPathLength);
    token         = wcsrchr(tmp, L'/')+1;

    m_wszPath     = __wstrndup(
                      tmp,
                      (uc.dwUrlPathLength - wcslen(token))
                      );

    m_wszResource = __wstrndup(
                      (tmp + wcslen(m_wszPath)),
                      wcslen(token)
                      );

    SAFEDELETEBUF(tmp);

    // duplicate the query string field
    m_wszQuery    = __wstrndup(uc.lpszExtraInfo, uc.dwExtraInfoLength);
    m_wszFragment = NULL;

    // set the requested server port
    m_usPort      = uc.nPort;
  }
  else
  {
    DEBUG_TRACE(URL, ("WinHttpCrackUrl failed with %s", MapErrorToString(GetLastError())));

    CHAR* token  = NULL;
    CHAR* tmpurl = __unescape(url);

      // snag the extra info
      token = strrchr(tmpurl, '?');

      if( token )
      {
        m_wszQuery = __ansitowide(token);
        *token     = '\0';
      }

      // snag the resource
      token = strrchr(tmpurl, '/')+1;

      if( token )
      {
        m_wszResource = __ansitowide(token);
        *token        = '\0';
      }

      // snag the path
      m_wszPath = __ansitowide(tmpurl);

    SAFEDELETEBUF(tmpurl);
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


void
CUrl::_Cleanup(void)
{
  DEBUG_TRACE(URL, ("CUrl [%#x] cleaning up", this));

  m_bEscaped = FALSE;

  SAFEDELETEBUF(m_szOriginalUrl);
  SAFEDELETEBUF(m_szUnescapedUrl);
  SAFEDELETEBUF(m_wszUrl);
  SAFEDELETEBUF(m_wszScheme);
  SAFEDELETEBUF(m_wszServer);
  SAFEDELETEBUF(m_wszPath);
  SAFEDELETEBUF(m_wszResource);
  SAFEDELETEBUF(m_wszQuery);
  SAFEDELETEBUF(m_wszFragment);
}


void
CUrl::Terminate(void)
{
  DEBUG_TRACE(URL, ("CUrl [%#x] terminating", this));

  m_bReadOnly = FALSE;
  SAFERELEASE(m_pSite);
  Release();
}


//-----------------------------------------------------------------------------
// IUnknown
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CUrl::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_REFCOUNT,
    rt_hresult,
    "CUrl::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

    if(
      IsEqualIID(riid, IID_IUnknown)  ||
      IsEqualIID(riid, IID_IDispatch) ||
      IsEqualIID(riid, IID_IUrl)
      )
    {
      *ppv = static_cast<IUrl*>(this);
    }
    else if( IsEqualIID(riid, IID_IProvideClassInfo) )
    {
      *ppv = static_cast<IProvideClassInfo*>(this);
    }
    else if( IsEqualIID(riid, IID_IObjectWithSite) )
    {
      *ppv = static_cast<IObjectWithSite*>(this);
    }
    else
    {
      *ppv = NULL;
      hr   = E_NOINTERFACE;
    }

  if( SUCCEEDED(hr) )
  {
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


ULONG
__stdcall
CUrl::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("CUrl", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
CUrl::Release(void)
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("CUrl", m_cRefs);

  if( m_cRefs == 0 )
  {
    DEBUG_FINALRELEASE("CUrl");
    _Cleanup();
    SAFERELEASE(m_pti);
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IProvideClassInfo
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CUrl::GetClassInfo(ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::GetClassInfo",
    "this=%#x; ppti=%#x",
    this,
    ppti
    ));

  HRESULT hr = S_OK;

    if( ppti )
    {
      m_pti->AddRef();
      *ppti = m_pti;
    }
    else
    {
      hr = E_POINTER;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// IObjectWithSite
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CUrl::SetSite(IUnknown* pUnkSite)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::SetSite",
    "this=%#x; pUnkSite=%#x",
    this,
    pUnkSite
    ));

  HRESULT            hr         = S_OK;
  IActiveScriptSite* pias       = NULL;
  IObjectWithSite*   pcontainer = NULL;

    if( !pUnkSite )
    {
      hr = E_INVALIDARG;
    }
    else
    {
      SAFERELEASE(m_pSite);
      SAFERELEASE(m_pti);

      m_pSite = pUnkSite;
      m_pSite->AddRef();

      hr = m_pSite->QueryInterface(IID_IObjectWithSite, (void**) &pcontainer);

      if( SUCCEEDED(hr) )
      {
        hr = pcontainer->GetSite(IID_IActiveScriptSite, (void**) &pias);

        if( SUCCEEDED(hr) )
        {
          hr = pias->GetItemInfo(
                       g_wszUrlObjectName,
                       SCRIPTINFO_ITYPEINFO,
                       NULL,
                       &m_pti
                       );
        }
      }
    }

  SAFERELEASE(pcontainer);
  SAFERELEASE(pias);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::GetSite(REFIID riid, void** ppvSite)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::GetSite",
    "this=%#x; riid=%s; ppvSite=%#x",
    this,
    MapIIDToString(riid),
    ppvSite
    ));

  HRESULT hr = S_OK;

    if( !ppvSite )
    {
      hr = E_POINTER;
    }
    else
    {
      if( m_pSite )
      {
        hr = m_pSite->QueryInterface(riid, ppvSite);
      }
      else
      {
        hr = E_FAIL;
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\om\w3srt\file.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    file.cxx

Abstract:

    Implements the File runtime object.
    
Author:

    Paul M Midgen (pmidge) 17-November-2000


Revision History:

    17-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
DISPIDTABLEENTRY g_FileDisptable[] =
{
  0x00008504,   DISPID_FILE_OPEN,               L"open",
  0x00010203,   DISPID_FILE_CLOSE,              L"close",
  0x00011d77,   DISPID_FILE_WRITE,              L"write",
  0x0011fe1f,   DISPID_FILE_WRITELINE,          L"writeline",
  0x023daf9a,   DISPID_FILE_WRITEBLANKLINE,     L"writeblankline",
  0x000081e5,   DISPID_FILE_READ,               L"read",
  0x00043138,   DISPID_FILE_READALL,            L"readall",
  0x0021188d,   DISPID_FILE_ATTRIBUTES,         L"attributes",
  0x00008804,   DISPID_FILE_SIZE,               L"size",
  0x00008c34,   DISPID_FILE_TYPE,               L"type",
  0x07f2b274,   DISPID_FILE_DATELASTMODIFIED,   L"datelastmodified"
};


DWORD g_cFileDisptable = (sizeof(g_FileDisptable) / sizeof(DISPIDTABLEENTRY));


//-----------------------------------------------------------------------------
// CW3SFile
//-----------------------------------------------------------------------------
CW3SFile::CW3SFile():
  m_cRefs(0),
  m_bFileOpened(FALSE),
  m_bReadOnly(FALSE),
  m_bAsciiData(FALSE),
  m_bHttpResponseCached(FALSE),
  m_hFile(INVALID_HANDLE_VALUE),
  m_pWHR(NULL),
  m_cHttpBytesRead(0)
{
  DEBUG_TRACE(RUNTIME, ("CW3SFile [%#x] created", this));
}


CW3SFile::~CW3SFile()
{
  DEBUG_TRACE(RUNTIME, ("CW3SFile [%#x] deleted", this));
}


HRESULT
CW3SFile::Create(IW3SpoofFile** ppw3sf)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SFile::Create",
    "ppw3sf=%#x",
    ppw3sf
    ));

  HRESULT  hr  = S_OK;
  PFILEOBJ pfo = NULL;

    if( !ppw3sf )
    {
      hr = E_POINTER;
    }
    else
    {
      if( pfo = new FILEOBJ )
      {
        hr = pfo->QueryInterface(IID_IW3SpoofFile, (void**) ppw3sf);
      }
      else
      {
        hr = E_OUTOFMEMORY;
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


void
CW3SFile::_Cleanup(void)
{
  DEBUG_TRACE(RUNTIME, ("CW3SFile [%#x] cleaning up", this));

  SAFECLOSE(m_hFile);
  SAFERELEASE(m_pWHR);
  VariantClear(&m_vHttpResponse);

  m_cHttpBytesRead      = 0L;
  m_bFileOpened         = FALSE;
  m_bReadOnly           = FALSE;
  m_bAsciiData          = FALSE;
  m_bHttpResponseCached = FALSE;
}


BOOL
CW3SFile::_CacheHttpResponse(void)
{
  BOOL bSuccess = FALSE;

  if( SUCCEEDED(m_pWHR->get_ResponseBody(&m_vHttpResponse)) )
  {
    if( __isempty(m_vHttpResponse) )
    {
      VariantClear(&m_vHttpResponse);
    }
    else
    {
      bSuccess = TRUE;
    }

    V_VT(&m_vHttpResponse) = bSuccess ? (VT_ARRAY | VT_UI1) : VT_NULL;
  }

  return bSuccess;
}


//-----------------------------------------------------------------------------
// IW3SpoofFile
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CW3SFile::Open(BSTR Filename, VARIANT Mode, VARIANT* Success)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SFile::Open",
    "this=%#x; Filename=%S; Mode=%#x",
    this,
    Filename,
    V_UI4(&Mode)
    ));

  HRESULT hr = S_OK;

  if( !Filename )
  {
    hr = E_INVALIDARG;
    goto quit;
  }
    
    if( m_bFileOpened )
    {
      _Cleanup();
    }

    if( __PathIsUNC(Filename) )
    {
      DEBUG_TRACE(RUNTIME, ("attempting to open %S as a UNC path", Filename));

      m_bFileOpened = GetFile(
                        Filename,
                        &m_hFile,
                        NULL,
                        V_UI4(&Mode),
                        &m_bReadOnly
                        );

      if( m_bFileOpened )
      {
        GetFileInformationByHandle(m_hFile, &m_bhfi);
      }
    }
    else if( __PathIsURL(Filename) )
    {
      DEBUG_TRACE(RUNTIME, ("attempting to open %S as an HTTP URL", Filename));

      m_bFileOpened = GetFile(
                        Filename,
                        NULL,
                        &m_pWHR,
                        V_UI4(&Mode),
                        &m_bReadOnly
                        );
    }
    else
    {
      // might be a local path
      m_bFileOpened = GetFile(
                        Filename,
                        &m_hFile,
                        NULL,
                        V_UI4(&Mode),
                        &m_bReadOnly
                        );

      if( m_bFileOpened )
      {
        GetFileInformationByHandle(m_hFile, &m_bhfi);
      }
      else
      {
        DEBUG_TRACE(RUNTIME, ("path/file type could not be determined"));
        hr = E_FAIL;
        goto quit;
      }
    }

  if( m_bFileOpened )
  {
    NEWVARIANT(type);

    hr = Type(&type);

    if( SUCCEEDED(hr) )
    {
      if( wcsstr(V_BSTR(&type), L"text") )
      {
        m_bAsciiData = TRUE;
      }
    }

    VariantClear(&type);
  }

  // check if the automation client wants status
  if( Success )
  {
    V_VT(Success)   = VT_BOOL;
    V_BOOL(Success) = m_bFileOpened ? TRUE : FALSE;
    hr              = S_OK;
  }
  else
  {
    hr = m_bFileOpened ? S_OK : E_FAIL;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SFile::Close(void)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SFile::Close",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    _Cleanup();

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SFile::Write(VARIANT Data, VARIANT* Success)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SFile::Write",
    "this=%#x",
    this
    ));

  HRESULT hr       = S_OK;
  BOOL    bSuccess = FALSE;
  LPBYTE  pbyte    = NULL;
  DWORD   len      = 0L;
  DWORD   bytes    = 0L;

  if( !m_bFileOpened )
  {
    hr = E_UNEXPECTED;
    goto quit;
  }

  if( m_bReadOnly )
  {
    hr = E_ACCESSDENIED;
    goto quit;
  }

    if( m_pWHR )
    {
      DEBUG_TRACE(RUNTIME, ("attempt to write to HTTP resource denied"));
      hr = E_FAIL;
    }
    else
    {
      if( !__isempty(Data) )
      {
        hr = ProcessVariant(&Data, &pbyte, &len, NULL);

        if( SUCCEEDED(hr) )
        {
          //DEBUG_DATA_DUMP(RUNTIME, ("writing data", pbyte, len));

          bSuccess = WriteFile(
                       m_hFile,
                       (LPVOID) pbyte,
                       len,
                       &bytes,
                       NULL
                       );

          if( !bSuccess || (bytes != len) )
          {
            DEBUG_TRACE(RUNTIME, ("error writing to file: %s", MapErrorToString(GetLastError())));
            hr = E_FAIL;
          }
          else
          {
            DEBUG_TRACE(RUNTIME, ("write of %d bytes succeeded", bytes));
          }
        }
        else
        {
          DEBUG_TRACE(RUNTIME, ("could not convert input in usable data"));
          hr = E_FAIL;
        }
      }
    }

  if( Success )
  {
    V_VT(Success)   = VT_BOOL;
    V_BOOL(Success) = bSuccess ? TRUE : FALSE;
    hr              = S_OK;
  }
  else
  {
    hr = bSuccess ? TRUE : FALSE;
  }

  SAFEDELETEBUF(pbyte);

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SFile::WriteLine(BSTR Line, VARIANT* Success)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SFile::WriteLine",
    "this=%#x",
    this
    ));

  HRESULT hr  = S_OK;
  DWORD   len = 0L;

  if( !Line )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !m_bFileOpened )
  {
    hr = E_UNEXPECTED;
    goto quit;
  }
  
  NEWVARIANT(data);

    len           = SysStringLen(Line);
    V_BSTR(&data) = SysAllocStringLen(Line,  len + 2);
    V_VT(&data)   = VT_BSTR;

    wcscat(
      (V_BSTR(&data) + len),
      L"\r\n"
      );

      hr = Write(data, Success);

  VariantClear(&data);

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SFile::WriteBlankLine(VARIANT* Success)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SFile::WriteBlankLine",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  if( !m_bFileOpened )
  {
    hr = E_UNEXPECTED;
    goto quit;
  }

  NEWVARIANT(data);

    V_VT(&data)   = VT_BSTR;
    V_BSTR(&data) = SysAllocString(L"\r\n");

      hr = Write(data, Success);

  VariantClear(&data);

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SFile::Read(VARIANT Bytes, VARIANT* Data)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SFile::Read",
    "this=%#x",
    this
    ));

  HRESULT hr    = S_OK;
  LPBYTE  pbuf  = NULL;
  DWORD   bytes = 0L;

  if( !Data )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !m_bFileOpened )
  {
    hr = E_UNEXPECTED;
    goto quit;
  }

  bytes = V_UI4(&Bytes);
  pbuf  = new BYTE[bytes];

    if( m_pWHR )
    {
      LPBYTE pbyte = NULL;

      if( !m_bHttpResponseCached )
      {
        m_bHttpResponseCached = _CacheHttpResponse();
      }

      SafeArrayAccessData(V_ARRAY(&m_vHttpResponse), (void**) &pbyte);

        memcpy(
          pbuf,
          pbyte + m_cHttpBytesRead,
          bytes
          );

      SafeArrayUnaccessData(V_ARRAY(&m_vHttpResponse));

      m_cHttpBytesRead += bytes;
    }
    else
    {
      ReadFile(m_hFile, pbuf, V_UI4(&Bytes), &bytes, NULL);
    }

    //DEBUG_DATA_DUMP(RUNTIME, ("bytes read", pbuf, bytes % 1000000));

    if( m_bAsciiData )
    {
      int flags = IS_TEXT_UNICODE_ODD_LENGTH | IS_TEXT_UNICODE_NULL_BYTES;

      if( IsTextUnicode((LPVOID) pbuf, bytes, &flags) )
      {
        LPWSTR wsz = NULL;

        wsz          = __wstrndup((LPWSTR) pbuf, bytes);
        V_BSTR(Data) = __widetobstr(wsz);

        SAFEDELETEBUF(wsz);
      }
      else
      {
        LPSTR sz = NULL;

        sz           = __strndup((LPSTR) pbuf, bytes);
        V_BSTR(Data) = __ansitobstr(sz);

        SAFEDELETEBUF(sz);
      }
      
      V_VT(Data) = VT_BSTR;
    }
    else
    {
      SAFEARRAY* psa = NULL;

      psa = SafeArrayCreateVector(VT_UI1, 1, bytes);

      if( psa )
      {
        memcpy((LPBYTE) psa->pvData, pbuf, bytes);

        V_VT(Data)    = VT_ARRAY | VT_UI1;
        V_ARRAY(Data) = psa;
      }
      else
      {
        hr = E_FAIL;
      }
    }

  SAFEDELETEBUF(pbuf);

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SFile::ReadAll(VARIANT* Data)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SFile::ReadAll",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  if( !Data )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !m_bFileOpened )
  {
    hr = E_UNEXPECTED;
    goto quit;
  }

  NEWVARIANT(size);

    if( SUCCEEDED(Size(&size)) )
    {
      hr = Read(size, Data);

      if( !m_pWHR )
      {
        SetFilePointer(m_hFile, 0L, NULL, FILE_BEGIN);
      }
    }
    else
    {
      hr = E_FAIL;
    }

  VariantClear(&size);
  
quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SFile::Attributes(VARIANT* Attributes)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SFile::Attributes",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  if( !Attributes )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !m_bFileOpened )
  {
    hr = E_UNEXPECTED;
    goto quit;
  }

  if( m_pWHR )
  {
    V_UI4(Attributes) = 0;
  }
  else
  {
    V_UI4(Attributes) = m_bhfi.dwFileAttributes;
  }

  DEBUG_TRACE(RUNTIME, ("file attributes are %0.8x", V_UI4(Attributes)));

  V_VT(Attributes) = VT_UI4;

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SFile::Size(VARIANT* Size)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SFile::Size",
    "this=%#x",
    this
    ));

  HRESULT hr   = S_OK;
  DWORD   size = 0L;

  if( !m_bFileOpened )
  {
    hr = E_UNEXPECTED;
    goto quit;
  }

    if( m_pWHR )
    {
      BSTR   contentlen = SysAllocString(L"content-length");
      BSTR   val        = NULL;
      WCHAR* stop       = L"\0";

      //
      // BUGBUG: the if() block below works around buggyness in WinHttpRequest.
      //         i will have to modify it at some point once the WHR bugs are
      //         fixed.
      //

      hr = m_pWHR->GetResponseHeader(contentlen, &val);

      if( SUCCEEDED(hr) && (val[0] != 0x00) )
      {
        size = wcstoul(val, &stop, 10);
      }
      else
      {
        if( _CacheHttpResponse() )
        {
          SafeArrayGetUBound(V_ARRAY(&m_vHttpResponse), 1, (long*) &size);
        }
        else
        {
          DEBUG_TRACE(RUNTIME, ("failed to determine content-length"));
          hr = E_FAIL;
        }
      }

      SAFEDELETEBSTR(contentlen);
      SAFEDELETEBSTR(val);
    }
    else
    {
      //
      // BUGBUG: it's possible we're dealing with a really large file, and we'll
      //         incorrectly represent the file size to interface clients.
      //
      size = m_bhfi.nFileSizeLow;
    }

  DEBUG_TRACE(RUNTIME, ("file size is %d bytes", size));

  V_VT(Size)  = VT_UI4;
  V_UI4(Size) = size;

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SFile::Type(VARIANT* Type)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SFile::Type",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  if( !Type )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !m_bFileOpened )
  {
    hr = E_UNEXPECTED;
    goto quit;
  }

    //
    // for URL returns the content-type, for UNC returns binary or text
    // if type cannot be determined, returns "unknown"
    //

    if( m_pWHR )
    {
      BSTR contenttype = SysAllocString(L"content-type");

      hr = m_pWHR->GetResponseHeader(contenttype, &V_BSTR(Type));

      SAFEDELETEBSTR(contenttype);
    }
    else
    {
      BOOL  bFoundNonTextChar = FALSE;
      DWORD bytes             = 0L;
      BYTE  taste[16];

      if( ReadFile(m_hFile, (LPVOID) taste, 16, &bytes, NULL) )
      {
        if( !(bytes < 16) )
        {
          for(DWORD n=0; n<bytes; n++)
          {
            if( !((taste[n] >= 32) && (taste[n] <= 127)) )
            {
              bFoundNonTextChar = TRUE;
              break;
            }
          }

          V_BSTR(Type) = SysAllocString(
                           bFoundNonTextChar ? L"binary" : L"text"
                           );
        }
        else
        {
          DEBUG_TRACE(RUNTIME, ("nondeterministic data sample, type unknown"));
          hr = E_FAIL;
        }

        // reset the file pointer
        SetFilePointer(m_hFile, 0, NULL, FILE_BEGIN);
      }
      else
      {
        DEBUG_TRACE(RUNTIME, ("read error occurred, couldn\'t determine file type"));
        hr = E_FAIL;
      }
    }

  if( FAILED(hr) )
  {
    V_BSTR(Type) = SysAllocString(L"unknown");
    hr           = S_OK;
  }

  DEBUG_TRACE(RUNTIME, ("file type is %S", V_BSTR(Type)));

  V_VT(Type) = VT_BSTR;

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SFile::DateLastModified(VARIANT* Date)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SFile::DateLastModified",
    "this=%#x",
    this
    ));

  HRESULT    hr = S_OK;
  SYSTEMTIME st;

  if( !Date )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !m_bFileOpened )
  {
    hr = E_UNEXPECTED;
    goto quit;
  }

    //
    // this function differs in behavior from others in that if an error
    // is encountered, we don't generate a script error (except for invalidarg).
    // we return a null date instead.
    //

    if( m_pWHR )
    {
      BSTR lastmodified = SysAllocString(L"last-modified");

        hr = m_pWHR->GetResponseHeader(lastmodified, &V_BSTR(Date));

        if( FAILED(hr) || (V_VT(Date) == VT_EMPTY) )
        {
          V_VT(Date) = VT_NULL;
          hr         = S_OK;
        }
        else
        {
          V_VT(Date) = VT_BSTR;
        }

      SAFEDELETEBSTR(lastmodified);
    }
    else
    {
      if( FileTimeToSystemTime(&m_bhfi.ftLastWriteTime, &st) )
      {
        if( !SystemTimeToVariantTime(&st, &V_DATE(Date)) )
        {
          DEBUG_TRACE(RUNTIME, ("error converting system time to variant"));
          hr = E_FAIL;
        }
      }
      else
      {
        DEBUG_TRACE(RUNTIME, ("error converting last-write time to system time"));
        hr = E_FAIL;
      }

      if( FAILED(hr) )
      {
        V_VT(Date) = VT_NULL;
        hr         = S_OK;
      }
      else
      {
        V_VT(Date) = VT_DATE;
      }
    }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// IUnknown
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CW3SFile::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_REFCOUNT,
    rt_hresult,
    "CW3SFile::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

    if(
      IsEqualIID(riid, IID_IUnknown)  ||
      IsEqualIID(riid, IID_IDispatch) ||
      IsEqualIID(riid, IID_IW3SpoofFile)
      )
    {
      *ppv = static_cast<IW3SpoofFile*>(this);
    }
    else
    {
      *ppv = NULL;
      hr   = E_NOINTERFACE;
    }

  if( SUCCEEDED(hr) )
  {
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


ULONG
__stdcall
CW3SFile::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("CW3SFile", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
CW3SFile::Release(void)
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("CW3SFile", m_cRefs);

  if( m_cRefs == 0 )
  {
    DEBUG_FINALRELEASE("CW3SFile");
    _Cleanup();    
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IDispatch
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CW3SFile::GetTypeInfoCount(UINT* pctinfo)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CW3SFile::GetTypeInfoCount",
    "this=%#x; pctinfo=%#x",
    this,
    pctinfo
    ));

  HRESULT hr = E_NOTIMPL;

    if( pctinfo )
    {
      *pctinfo = 0;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SFile::GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CW3SFile::GetTypeInfo",
    "this=%#x; index=%#x; lcid=%#x; ppti=%#x",
    this,
    index,
    lcid,
    ppti
    ));

  HRESULT hr = E_NOTIMPL;

    if( ppti )
    {
      *ppti = NULL;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SFile::GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CW3SFile::GetIDsOfNames",
    "this=%#x; riid=%s; arNames=%#x; cNames=%d; lcid=%#x; arDispId=%#x",
    this,
    MapIIDToString(riid),
    arNames,
    cNames,
    lcid,
    arDispId
    ));

  HRESULT hr = S_OK;
  UINT    n  = 0L;

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  while( n < cNames )
  {
    arDispId[n] = GetDispidFromName(g_FileDisptable, g_cFileDisptable, arNames[n]);
    ++n;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SFile::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CW3SFile::Invoke",
    "this=%#x; dispid=%s; riid=%s; lcid=%#x; flags=%#x; pdp=%#x; pvr=%#x; pei=%#x; pae=%#x",
    this,
    MapDispidToString(dispid),
    MapIIDToString(riid),
    lcid,
    flags,
    pdp, pvr,
    pei, pae
    ));

  HRESULT hr = S_OK;

  hr = ValidateDispatchArgs(riid, pdp, pvr, pae);

    if( FAILED(hr) )
      goto quit;

  switch( dispid )
  {
    case DISPID_FILE_OPEN :
      {
        NEWVARIANT(filename);
        NEWVARIANT(mode);

        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, TRUE, 1);

          if( SUCCEEDED(hr) )
          {
            hr = DispGetParam(pdp, 0, VT_BSTR, &filename, pae);
            
            if( SUCCEEDED(hr) )
            {
              if( FAILED(DispGetParam(pdp, 1, VT_UI4, &mode, pae)) )
              {
                V_VT(&mode)  = VT_UI4;
                V_UI4(&mode) = OPEN_EXISTING;
              }

              hr = Open(V_BSTR(&filename), mode, pvr);
            }
          }
        }

        VariantClear(&mode);
        VariantClear(&filename);
      }
      break;

    case DISPID_FILE_CLOSE :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 0, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = Close();
          }
        }
      }
      break;

    case DISPID_FILE_WRITE :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = Write(pdp->rgvarg[0], pvr);
          }
        }
      }
      break;

    case DISPID_FILE_WRITELINE :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = WriteLine(V_BSTR(&pdp->rgvarg[0]), pvr);
          }
        }
      }
      break;

    case DISPID_FILE_WRITEBLANKLINE :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 0, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = WriteBlankLine(pvr);
          }
        }
      }
      break;

    case DISPID_FILE_READ :
      {
        NEWVARIANT(bytes);

        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = DispGetParam(pdp, 0, VT_UI4, &bytes, pae);

            if( SUCCEEDED(hr) )
            {
              hr = Read(bytes, pvr);
            }
          }
        }
        
        VariantClear(&bytes);
      }
      break;

    case DISPID_FILE_READALL :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 0, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = ReadAll(pvr);
          }
        }
      }
      break;

    case DISPID_FILE_ATTRIBUTES :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = Attributes(pvr);
        }
      }
      break;

    case DISPID_FILE_SIZE :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = Size(pvr);
        }
      }
      break;

    case DISPID_FILE_TYPE :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = Type(pvr);
        }
      }
      break;

    case DISPID_FILE_DATELASTMODIFIED :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = DateLastModified(pvr);
        }
      }
      break;

    default : hr = DISP_E_MEMBERNOTFOUND;
  }

quit:

  if( FAILED(hr) )
  {
    hr = HandleDispatchError(L"file object", pei, hr);
  }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\om\w3srt\w3srtobj.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    w3srtobj.cxx

Abstract:

    Implements the w3spoof runtime object.
    
Author:

    Paul M Midgen (pmidge) 06-November-2000


Revision History:

    06-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

LPWSTR g_wszRuntimeObjectName = L"w3srt";

//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
DISPIDTABLEENTRY g_RuntimeDisptable[] =
{
  0x00041557, DISPID_RUNTIME_GETFILE, L"getfile"
};

DWORD g_cRuntimeDisptable = (sizeof(g_RuntimeDisptable) / sizeof(DISPIDTABLEENTRY));

//-----------------------------------------------------------------------------
// CW3SRuntime
//-----------------------------------------------------------------------------
CW3SRuntime::CW3SRuntime():
  m_cRefs(1),
  m_propertybags(NULL)
{
  DEBUG_TRACE(RUNTIME, ("CW3SRuntime created: %#x", this));
}


CW3SRuntime::~CW3SRuntime()
{
  DEBUG_TRACE(RUNTIME, ("CW3SRuntime deleted: %#x", this));
}


HRESULT
CW3SRuntime::Create(PRUNTIME* pprt)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SRuntime::Create",
    "pprt=%#x",
    pprt
    ));

  HRESULT  hr  = S_OK;
  PRUNTIME prt = NULL;

    if( !pprt )
    {
      hr = E_POINTER;
    }
    else
    {
      if( prt = new RUNTIME )
      {
        if( SUCCEEDED(prt->_Initialize()) )
        {
          *pprt = prt;
        }
        else
        {
          DEBUG_TRACE(RUNTIME, ("failed to initialize runtime"));
          delete prt;
          *pprt = NULL;
          hr    = E_FAIL;
        }
      }
      else
      {
        hr = E_OUTOFMEMORY;
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CW3SRuntime::_Initialize(void)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SRuntime::_Initialize",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    m_propertybags = new STRINGMAP;

      if( m_propertybags )
      {
        m_propertybags->SetClearFunction(PropertyBagKiller);
      }
      else
      {
        DEBUG_TRACE(RUNTIME, ("failed to create propertybag bag"));
        hr = E_FAIL;
      }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CW3SRuntime::Terminate(void)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SRuntime::Terminate",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    m_propertybags->Clear();
    SAFEDELETE(m_propertybags);

    Release();

  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// IUnknown
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CW3SRuntime::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_REFCOUNT,
    rt_hresult,
    "CW3SRuntime::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

    if( IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IW3SpoofRuntime) )
    {
      *ppv = static_cast<IW3SpoofRuntime*>(this);
    }
    else if( IsEqualIID(riid, IID_IDispatch) )
    {
      *ppv = static_cast<IDispatch*>(this);
    }
    else
    {
      *ppv = NULL;
      hr   = E_NOINTERFACE;
    }

  if( SUCCEEDED(hr) )
  {
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


ULONG
__stdcall
CW3SRuntime::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("CW3SRuntime", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
CW3SRuntime::Release(void)
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("CW3SRuntime", m_cRefs);

  if( m_cRefs == 0 )
  {
    DEBUG_FINALRELEASE("CW3SRuntime");
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IDispatch
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CW3SRuntime::GetTypeInfoCount(UINT* pctinfo)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CW3SRuntime::GetTypeInfoCount",
    "this=%#x; pctinfo=%#x",
    this,
    pctinfo
    ));

  HRESULT hr = E_NOTIMPL;

    if( pctinfo )
    {
      *pctinfo = 0;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SRuntime::GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CW3SRuntime::GetTypeInfo",
    "this=%#x; index=%#x; lcid=%#x; ppti=%#x",
    this,
    index,
    lcid,
    ppti
    ));

  HRESULT hr = E_NOTIMPL;

    if( ppti )
    {
      *ppti = NULL;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SRuntime::GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CW3SRuntime::GetIDsOfNames",
    "this=%#x; riid=%s; arNames=%#x; cNames=%d; lcid=%#x; arDispId=%#x",
    this,
    MapIIDToString(riid),
    arNames,
    cNames,
    lcid,
    arDispId
    ));

  HRESULT hr = S_OK;
  UINT    n  = 0L;

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  while( n < cNames )
  {
    arDispId[n] = GetDispidFromName(g_RuntimeDisptable, g_cRuntimeDisptable, arNames[n]);
    ++n;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SRuntime::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CW3SRuntime::Invoke",
    "this=%#x; dispid=%s; riid=%s; lcid=%#x; flags=%#x; pdp=%#x; pvr=%#x; pei=%#x; pae=%#x",
    this,
    MapDispidToString(dispid),
    MapIIDToString(riid),
    lcid,
    flags,
    pdp, pvr,
    pei, pae
    ));

  HRESULT hr = S_OK;

  // make sure there aren't any bits set we don't understand
  if( flags & ~(DISPATCH_METHOD | DISPATCH_PROPERTYGET | DISPATCH_PROPERTYPUT) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = DISP_E_UNKNOWNINTERFACE;
    goto quit;
  }

  if( !pdp )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( pae )
  {
    *pae = 0;
  }

  if( pvr )
  {
    VariantInit(pvr);
  }

  switch( dispid )
  {
    case DISPID_RUNTIME_GETFILE :
      {
        if( pvr )
        {
          V_VT(pvr) = VT_DISPATCH;
          hr        = GetFile(&V_DISPATCH(pvr));
        }
      }
      break;

    default :
      {
        hr = DISP_E_MEMBERNOTFOUND;
      }
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// IW3SpoofRuntime
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CW3SRuntime::GetFile(IDispatch** ppdisp)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SRuntime::GetFile",
    "this=%#x; ppdisp=%#x",
    this,
    ppdisp
    ));

  HRESULT       hr    = S_OK;
  IW3SpoofFile* pw3sf = NULL;

    if( !ppdisp )
    {
      hr = E_POINTER;
    }
    else
    {
      if( SUCCEEDED(FILEOBJ::Create(&pw3sf)) )
      {
        hr = pw3sf->QueryInterface(IID_IDispatch, (void**) ppdisp);
      }
    }

  SAFERELEASE(pw3sf);
  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SRuntime::GetPropertyBag(BSTR Name, IW3SpoofPropertyBag** ppbag)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SRuntime::GetPropertyBag",
    "this=%#x; name=%S; ppbag=%#x",
    this,
    Name,
    ppbag
    ));

  HRESULT      hr      = S_OK;
  PPROPERTYBAG pbagobj = NULL;

    if( m_propertybags->Get(Name, (void**) &pbagobj) != ERROR_SUCCESS )
    {
      DEBUG_TRACE(RUNTIME, ("no existing property bag, creating new one"));

      if( SUCCEEDED(PROPERTYBAG::Create(Name, &pbagobj)) )
      {
        m_propertybags->Insert(Name, (void*) pbagobj);
      }
      else
      {
        DEBUG_TRACE(RUNTIME, ("failed to create new property bag"));
        *ppbag = NULL;
        hr     = E_FAIL;
        goto quit;
      }
    }

    DEBUG_TRACE(RUNTIME, ("retrieving property bag"));
    hr = pbagobj->QueryInterface(IID_IW3SpoofPropertyBag, (void**) ppbag);

quit:

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\w3scon\w3scon.cxx ===
#include "common.h"
#include <windowsx.h>
#include <stdio.h>
#include "w3scon.h"

CW3SpoofUI* g_pw3sui      = NULL;
LPCWSTR     g_wszShowUI   = L"ShowUI";
LPCWSTR     g_wszNIFText1 = L"W3Spoof is running.";

//-----------------------------------------------------------------------------
// Program entry
//-----------------------------------------------------------------------------
int
WINAPI
WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow)
{
  HRESULT                hr  = S_OK;
  IW3SpoofClientSupport* pcs = NULL;

  CoInitialize(NULL);

  hr = CoCreateInstance(
         CLSID_W3Spoof,
         NULL,
         CLSCTX_LOCAL_SERVER,
         IID_IW3SpoofClientSupport,
         (void**) &pcs
         );

  if( SUCCEEDED(hr) )
  {
    hr = CW3SpoofUI::Create(&g_pw3sui, hInstance, pcs);

    if( SUCCEEDED(hr) )
    {
      g_pw3sui->Run();
    }
  
    g_pw3sui->Terminate();
  }

  if( pcs )
    pcs->Release();

  CoUninitialize();

  return 0L;
}


//-----------------------------------------------------------------------------
// CW3SpoofUI methods
//-----------------------------------------------------------------------------
CW3SpoofUI::CW3SpoofUI()
{
  m_hInst = NULL;
  m_hWnd  = NULL;
  m_cRefs = 1L;
  m_hIcon = NULL;
}


CW3SpoofUI::~CW3SpoofUI()
{
}


HRESULT
CW3SpoofUI::Create(CW3SpoofUI** ppw3sui, HINSTANCE hInst, IW3SpoofClientSupport* pcs)
{
  HRESULT hr = S_OK;

  if( !ppw3sui )
  {
    hr = E_INVALIDARG;
  }
  else
  {
    *ppw3sui = new CW3SpoofUI;

    if( !(*ppw3sui) )
    {
      hr = E_OUTOFMEMORY;
    }
    else
    {
      hr = (*ppw3sui)->Initialize(hInst, pcs);
    }
  }

  return hr;
}


HRESULT
CW3SpoofUI::Initialize(HINSTANCE hInst, IW3SpoofClientSupport* pcs)
{
  LPDWORD pdw   = NULL;
  HRESULT hr    = S_OK;
  IConnectionPointContainer* pCPC = NULL;

  if( !hInst )
  {
    hr = E_INVALIDARG;
    goto quit;
  }
  else
  {
    m_hInst = hInst;
  }

  //
  // load our friendly icon and if successful create the ui
  //
  m_hIcon = (HICON) LoadImage(m_hInst, L"IDI_W3SPOOF", IMAGE_ICON, 16, 16, 0);

  if( m_hIcon )
  {
    hr = _CreateUI();
  }
  else
  {
    hr = E_FAIL;
    goto quit;
  }

  //
  // sink the IW3SpoofEvents interface.
  //
  hr = pcs->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC);
  
  if( SUCCEEDED(hr) )
  {
    hr = pCPC->FindConnectionPoint(IID_IW3SpoofEvents, &m_pCP);

      if( SUCCEEDED(hr) )
      {
        pCPC->Release();
      }
      else
      {
        goto quit;
      }

    hr = m_pCP->Advise(static_cast<IUnknown*>(this), &m_dwCookie);
  }
  
quit:

  return hr;
}


HRESULT
CW3SpoofUI::Terminate(void)
{
  HRESULT hr = S_OK;

    if( m_pCP )
      m_pCP->Unadvise(m_dwCookie);

    SAFERELEASE(m_pCP);

    _DestroyTrayIcon();

    //
    // the ui object is created with a refcount of 1. this release will
    // drop the refcount to 0 and cause the object to be deleted.
    //
    Release();

  return hr;
}


HRESULT
CW3SpoofUI::Run()
{
  HRESULT hr = S_OK;
  MSG     msg;

    while( GetMessage(&msg, NULL, 0, 0) )   
    {
      TranslateMessage(&msg);
      DispatchMessage(&msg);
    }
  
  return hr;
}


HRESULT
CW3SpoofUI::_CreateUI(void)
{
  HRESULT    hr    = S_OK;
  DWORD      dwRet = ERROR_SUCCESS;
  WNDCLASSEX wc    = {0};

    wc.cbSize        = sizeof(wc);
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;

    wc.hInstance     = m_hInst;
    wc.lpfnWndProc   = WndProc;
    wc.lpszMenuName  = NULL;
    wc.lpszClassName = L"w3spoof_main";

    wc.style         = CS_HREDRAW | CS_VREDRAW;
    wc.hIcon         = m_hIcon;
    wc.hIconSm       = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);

    RegisterClassEx(&wc);

    m_hWnd = CreateWindow(
               wc.lpszClassName,
               L"w3spoof",
               WS_OVERLAPPEDWINDOW,
               CW_USEDEFAULT,
               CW_USEDEFAULT,
               600,
               600,
               NULL,
               NULL,
               wc.hInstance,
               NULL
               );

    if( m_hWnd )
    {
      hr = _CreateTrayIcon();
    }
    else
    {
      hr = E_FAIL;
      goto quit;
    }
    
    ShowWindow(m_hWnd, SW_SHOWNORMAL);
    UpdateWindow(m_hWnd);

quit:

  return hr;
}


HRESULT
CW3SpoofUI::_CreateTrayIcon(void)
{
  HRESULT        hr    = S_OK;
  NOTIFYICONDATA nid   = {0};

  nid.cbSize           = sizeof(NOTIFYICONDATA);
  nid.hWnd             = m_hWnd;
  nid.uID              = SHELLMESSAGE_W3SICON;
  nid.uCallbackMessage = nid.uID;
  nid.uFlags           = NIF_ICON | NIF_MESSAGE | NIF_TIP;
  nid.hIcon            = m_hIcon;

  wsprintf(nid.szTip, L"%s", g_wszNIFText1);

  if( !Shell_NotifyIcon(NIM_ADD, &nid) )
  {
    hr = E_FAIL;
  }

  return hr;
}


HRESULT
CW3SpoofUI::_UpdateTrayIcon(void)
{
  //
  // TODO: implementation
  //

  return S_OK;
}


HRESULT
CW3SpoofUI::_DestroyTrayIcon(void)
{
  HRESULT        hr    = S_OK;
  NOTIFYICONDATA nid   = {0};

  nid.cbSize           = sizeof(NOTIFYICONDATA);
  nid.hWnd             = m_hWnd;
  nid.uID              = SHELLMESSAGE_W3SICON;
  nid.uCallbackMessage = nid.uID;

  if( !Shell_NotifyIcon(NIM_DELETE, &nid) )
  {
    hr = E_FAIL;
  }

  DestroyIcon(m_hIcon);
  return hr;
}


void
CW3SpoofUI::_WriteText(const WCHAR* format, ...)
{
  int        ret       = 0;
  int        offset    = 0;
  WCHAR*     timestamp = new WCHAR[256];
  WCHAR*     buffer    = new WCHAR[1024];
  va_list    arg_list;
  SYSTEMTIME st;
 
  GetLocalTime(&st);

  wsprintf(
    timestamp,
    L"%0.2d:%0.2d:%0.2d.%0.3d",
    st.wHour,
    st.wMinute,
    st.wSecond,
    st.wMilliseconds
    );

    offset = wsprintf(buffer, L"[%s] ", timestamp);

    va_start(arg_list, format);

      _vsnwprintf(
        (buffer + offset),
        (1024 - wcslen(timestamp)),
        format,
        arg_list
        );

    va_end(arg_list);

    do
    {
      if( (ret = ListBox_AddString(m_listbox, buffer)) == LB_ERR )
      {
        ListBox_DeleteString(m_listbox, 0);
      }
      else
      {
        ListBox_SetCurSel(m_listbox, ret);
      }
    }
    while( ret == LB_ERR );

  SAFEDELETEBUF(timestamp);
  SAFEDELETEBUF(buffer);
}


//-----------------------------------------------------------------------------
// IUnknown
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CW3SpoofUI::QueryInterface(REFIID riid, void** ppv)
{
  HRESULT hr = S_OK;

  if( !ppv )
  {
    hr = E_POINTER;
  }
  else
  {
    if( IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IW3SpoofEvents))
    {
      *ppv = static_cast<IW3SpoofEvents*>(this);
    }
    else
    {
      *ppv = NULL;
      hr   = E_NOINTERFACE;
    }

    if( SUCCEEDED(hr) )
      reinterpret_cast<IUnknown*>(*ppv)->AddRef();
  }

  return hr;
}


ULONG
__stdcall
CW3SpoofUI::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
CW3SpoofUI::Release(void)
{
  InterlockedDecrement(&m_cRefs);

  if( m_cRefs == 0 )
  {
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IW3SpoofEvents methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CW3SpoofUI::OnSessionOpen(LPWSTR clientid)
{
  _WriteText(
    L"client %s session is open",
    clientid
    );

  return S_OK;
}


HRESULT
__stdcall
CW3SpoofUI::OnSessionStateChange(LPWSTR clientid, STATE state)
{
  return S_OK;
}


HRESULT
__stdcall
CW3SpoofUI::OnSessionClose(LPWSTR clientid)
{
  _WriteText(
    L"client %s session is closed",
    clientid
    );

  return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\w3scon\wndproc.cxx ===
#include "common.h"
#include "w3scon.h"

extern CW3SpoofUI* g_pw3sui;

LRESULT
CALLBACK
WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
  return g_pw3sui->_WndProc(hwnd, msg, wParam, lParam);
}


LRESULT
CW3SpoofUI::_WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
  DWORD   ret = 0;
  RECT    rect;
  LOGFONT logfont;

  switch( msg )
  {
    case WM_CREATE :
      {
        InitCommonControls();
    
        GetClientRect(hwnd, &rect);

        m_listbox = CreateWindowEx(
                      WS_EX_CLIENTEDGE,
                      L"listbox",
                      NULL,                         
                      WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL | \
                      WS_BORDER | LBS_NOSEL | LBS_NOINTEGRALHEIGHT,
                      rect.left, rect.top, rect.right, rect.bottom,
                      hwnd,
                      NULL,
                      (HINSTANCE) GetWindowLong(hwnd, GWL_HINSTANCE),
                      NULL
                      );
        
        GetObject(
          GetStockObject(ANSI_FIXED_FONT),
          sizeof(LOGFONT),
          (LPVOID) &logfont
          );

        m_font = CreateFontIndirect(&logfont);
        PostMessage(m_listbox, WM_SETFONT, (WPARAM) m_font, 0);
      }
      break;

    case SHELLMESSAGE_W3SICON :
      {
      }
      break;

    case WM_SIZE :
      {
        GetClientRect(hwnd, &rect);

        MoveWindow(
          m_listbox,
          rect.left, rect.top,
          rect.right, rect.bottom,
          FALSE
          );

        InvalidateRect(hwnd, &rect, TRUE);
      }
      break;

    case WM_DESTROY :
      {
        DeleteObject(m_font);
        PostQuitMessage(0);
      }
      break;

    default : return DefWindowProc(hwnd, msg, wParam, lParam);
  }

  return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\w3scon\w3scon.h ===
#ifndef _W3SUI_H_
#define _W3SUI_H_

class CW3SpoofUI : public IW3SpoofEvents
{
  public:
    //
    // IUnknown and IW3SpoofEvents
    //
    HRESULT __stdcall QueryInterface(REFIID riid, void** ppv);
    ULONG   __stdcall AddRef(void);
    ULONG   __stdcall Release(void);

    HRESULT __stdcall OnSessionOpen(LPWSTR clientid);
    HRESULT __stdcall OnSessionStateChange(LPWSTR clientid, STATE state);
    HRESULT __stdcall OnSessionClose(LPWSTR clientid);

    //
    // object methods 
    //
    CW3SpoofUI();
   ~CW3SpoofUI();

    static HRESULT Create(CW3SpoofUI** ppw3sui, HINSTANCE hInst, IW3SpoofClientSupport* pcs);

    HRESULT Initialize(HINSTANCE hInst, IW3SpoofClientSupport* pcs);
    HRESULT Terminate(void);
    HRESULT Run(void);

    friend LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

  protected:
    LRESULT _WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

  private:
    HRESULT _CreateUI(void);
    HRESULT _CreateTrayIcon(void);
    HRESULT _UpdateTrayIcon(void);
    HRESULT _DestroyTrayIcon(void);
    void  _WriteText(const WCHAR* format, ...);

    HINSTANCE         m_hInst;
    HWND              m_hWnd;
    HWND              m_listbox;
    HFONT             m_font;
    HICON             m_hIcon;
    IConnectionPoint* m_pCP;
    DWORD             m_dwCookie;
    LONG              m_cRefs;
};

#endif /* _W3SUI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\w3sobj\ioctx.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ioctx.cxx

Abstract:

    Implements the IO Context object.
    
Author:

    Paul M Midgen (pmidge) 08-February-2001


Revision History:

    08-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

IOCTX::IOCTX(IOTYPE iot, SOCKET s):
  clientid(NULL),
  local(NULL),
  remote(NULL),
  session(NULL),
  socket(s),
  sockbuf(NULL),
  bytes(0),
  flags(0),
  bufsize(0),
  error(0),
  _iot(iot),
  _cRefs(1)
{
  pthis = this;
  memset(&overlapped, 0, sizeof(OVERLAPPED));

  if( _iot == IOCT_CONNECT )
  {
    sockbuf = new BYTE[((sizeof(SOCKADDR_IN)+16)*2)];
  }
}

IOCTX::~IOCTX()
{
  if( _iot == IOCT_CONNECT )
  {
    SAFEDELETE(sockbuf);
    SAFEDELETEBUF(clientid);
  }
  
  SAFECLOSE(overlapped.hEvent);
}

void
IOCTX::AddRef(void)
{
  InterlockedIncrement(&_cRefs);
}

void
IOCTX::Release(void)
{
  InterlockedDecrement(&_cRefs);
  
  if( _cRefs == 0 )
  {
    delete this;
  }
  
  return;
}

IOTYPE
IOCTX::Type(void)
{
  return _iot;
}

BOOL
IOCTX::AllocateWSABuffer(DWORD size, LPVOID pv)
{
  if( !(pwsa = new WSABUF) )
  {
    return FALSE;
  }

  if( size != 0 )
  {
    bufsize = size;

    if( pv )
    {
      pwsa->buf = (CHAR*) pv;
      pwsa->len = size;
    }
    else
    {
      if( !(pwsa->buf = new CHAR[size]) )
      {
        return FALSE;
      }
    
      pwsa->len = (_iot == IOCT_SEND) ? 0 : size;
    }
  }

  return TRUE;
}

void
IOCTX::FreeWSABuffer(void)
{
  SAFEDELETEBUF(pwsa->buf);
  SAFEDELETE(pwsa);
  bufsize = 0;
}

BOOL
IOCTX::ResizeWSABuffer(DWORD size)
{
  SAFEDELETEBUF(pwsa->buf);

  if( !(pwsa->buf = new CHAR[size]) )
  {
    return FALSE;
  }

  bufsize   = size;  
  pwsa->len = (_iot == IOCT_SEND) ? 0 : size;

  return TRUE;
}

void
IOCTX::DisableIoCompletion(void)
{
  overlapped.hEvent =
    (HANDLE) ((ULONG_PTR) CreateEvent(NULL, TRUE, FALSE, NULL) | 0x00000001);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\w3scon\w3scon.inc ===
!IF 0

Copyright (c) 1994  Microsoft Corporation

Module Name:

    w3scon.inc

Abstract:

    Common makefile contents for w3scon project

!ENDIF

!IFNDEF SDKINC
SDKINC=$(SDK_INC_PATH)
!ENDIF

!IFDEF LIBDIR
!ERROR LIBDIR already defined - choose new name
!ENDIF

LIBDIR=$(_OBJ_DIR)
W3SPOOFINC=..\inc

#
# if TARGETPATH is not defined (in the paths that build libraries) then this
# is the default target path
#
!IFNDEF TARGETPATH
TARGETPATH=$(LIBDIR)
TARGETTYPE=LIBRARY
!ENDIF

#
# what it is that we're building
#
MAJORCOMP=w3scon

USE_NOLIBS=1
#USE_LIBCMT=0
NO_NTDLL=1
#NO_BINPLACE=1
#BINPLACE_PLACEFILE=..\binplace.txt

#
# Linker flags
#
WIN32_WINNT_VERSION=0x0500
#WIN32_WIN95_VERSION=0x0400

#
# compiler warning flags
#
MSC_WARNING_LEVEL=/W3 /WX

#
# compiler definitions
#
C_DEFINES=$(C_DEFINES) -DWIN32

#CLEANINF = cleaninf.exe $(CLEANINF_FLAGS)

#
# Set debugging level
#
!IF "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail" && "$(NTDEBUG)" != "ntsdnodbg"
C_DEFINES=$(C_DEFINES) -D_DEBUG
!ENDIF

!IF "$(__FULL_DEBUG__)" != "" && "$(__RELEASE_DEBUG__)" == ""
C_DEFINES=$(C_DEFINES) -D__FULL_DEBUG__
!IF "$(__DBG_TO_CONSOLE__)" == "1"
C_DEFINES=$(C_DEFINES) -D__DBG_TO_CONSOLE__
!ENDIF
!ENDIF

!IF "$(__RELEASE_DEBUG__)" != "" && "$(__FULL_DEBUG__)" == ""
C_DEFINES=$(C_DEFINES) -D__RELEASE_DEBUG__
!ENDIF


!IFNDEF W3SPOOF_PCH
PRECOMPILED_OPTION=/Fp..\inc\$(_OBJ_DIR)\*\common.pch /Yucommon.h
PRECOMPILED_CXX=1
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\w3sobj\dispatch.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dispatch.cxx

Abstract:

    Implements the IDispatch interface for the W3Spoof object.
    
Author:

    Paul M Midgen (pmidge) 18-January-2001


Revision History:

    18-January-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
DISPIDTABLEENTRY g_W3SpoofDisptable[] =
{
  0x021fca0d,   DISPID_W3SPOOF_REGISTERCLIENT,  L"registerclient",
  0x008a2dce,   DISPID_W3SPOOF_REVOKECLIENT,    L"revokeclient"
};

DWORD  g_cW3SpoofDisptable    = (sizeof(g_W3SpoofDisptable) / sizeof(DISPIDTABLEENTRY));
LPWSTR g_wszW3SpoofObjectName = L"w3spoof";

//-----------------------------------------------------------------------------
// IDispatch
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CW3Spoof::GetTypeInfoCount(UINT* pctinfo)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CW3Spoof::GetTypeInfoCount",
    "this=%#x; pctinfo=%#x",
    this,
    pctinfo
    ));

  HRESULT hr = S_OK;

    if( !pctinfo )
    {
      hr = E_POINTER;
    }
    else
    {
      *pctinfo = 1;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3Spoof::GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CW3Spoof::GetTypeInfo",
    "this=%#x; index=%#x; lcid=%#x; ppti=%#x",
    this,
    index,
    lcid,
    ppti
    ));

  HRESULT hr = S_OK;

  if( !ppti )
  {
    hr = E_POINTER;
  }
  else
  {
    if( index != 0 )
    {
      hr    = DISP_E_BADINDEX;
      *ppti = NULL;
    }
    else
    {
      hr = GetTypeInfoFromName(g_wszW3SpoofObjectName, m_ptl, ppti);
    }
  }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3Spoof::GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CW3Spoof::GetIDsOfNames",
    "this=%#x; riid=%s; arNames=%#x; cNames=%d; lcid=%#x; arDispId=%#x",
    this,
    MapIIDToString(riid),
    arNames,
    cNames,
    lcid,
    arDispId
    ));

  HRESULT hr = S_OK;
  UINT    n  = 0L;

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  while( n < cNames )
  {
    arDispId[n] = GetDispidFromName(g_W3SpoofDisptable, g_cW3SpoofDisptable, arNames[n]);
    ++n;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3Spoof::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CW3Spoof::Invoke",
    "this=%#x; dispid=%s; riid=%s; lcid=%#x; flags=%#x; pdp=%#x; pvr=%#x; pei=%#x; pae=%#x",
    this,
    MapDispidToString(dispid),
    MapIIDToString(riid),
    lcid,
    flags,
    pdp, pvr,
    pei, pae
    ));

  HRESULT hr = S_OK;

  hr = ValidateDispatchArgs(riid, pdp, pvr, pae);

    if( FAILED(hr) )
      goto quit;

  switch( dispid )
  {
    case DISPID_W3SPOOF_REGISTERCLIENT :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 2, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = RegisterClient(
                   V_BSTR(&pdp->rgvarg[1]),
                   V_BSTR(&pdp->rgvarg[0])
                   );
          }
        }
      }
      break;

    case DISPID_W3SPOOF_REVOKECLIENT :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = RevokeClient(
                   V_BSTR(&pdp->rgvarg[0])
                   );
          }
        }
      }
      break;

    default : hr = DISP_E_MEMBERNOTFOUND;
  }

quit:

  if( FAILED(hr) )
  {
    hr = HandleDispatchError(L"w3spoof object", pei, hr);
  }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\w3sobj\factory.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    factory.cpp

Abstract:

    W3Spoof class factory implementation. Also implements component
    registration and runtime registration for the local server.
    
Author:

    Paul M Midgen (pmidge) 17-July-2000


Revision History:

    17-July-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

LPCWSTR g_wszRegistered = L"Registered";
LPCWSTR g_wszAdvPackDll = L"advpack.dll";

// advapi doesn't speak unicode
LPCSTR g_szRegSection   = "reg";
LPCSTR g_szUnRegSection = "unreg";

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  CFactory::CFactory()

  WHAT    : W3Spoof class factory constructor. Writes the COM server entries
            to the registry and registers itself with COM as the W3Spoof
            class factory.

  ARGS    : fEmbedded - when the server starts and creates the class factory,
                        it passes this flag in, letting us know if the server
                        is running embedded or not. if we're embedded, we
                        don't want to pop ui, so we store this value and
                        use it when creating W3Spoof objects.

  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
CFactory::CFactory()
{
  DEBUG_ENTER((
    DBG_FACTORY,
    rt_void,
    "CFactory::CFactory",
    "this=%#x",
    this
    ));

  LPDWORD pdw   = NULL;
  BOOL    bRet  = FALSE;
  DWORD   dwRet = ERROR_SUCCESS;

  m_pw3s     = NULL;
  m_dwCookie = 0L;
  m_cRefs    = 1;
  m_cLocks   = 0L;

  //
  // component registration check
  //
  // if the regkey exists but is 0 (someone wants to force us to reregister)
  // or if the regkey doesn't exist (new install or someone nuked the regkey)
  // then we register ourselves as a COM server.
  //
  bRet = GetRegValue(g_wszRegistered, REG_DWORD, (void**)&pdw);

  if( (bRet && (*pdw == 0)) || !bRet )
  {
    _RegisterServer(TRUE);
  }

  delete pdw;

  //
  // create a single instance (singleton) of CW3Spoof to
  // be used by all callers and grab an IUnknown* for the
  // factory object so it controls the singleton's lifetime.
  //
  CW3Spoof::Create(&m_pw3s);

  DEBUG_ASSERT((m_pw3s != NULL));

  _RegisterClassFactory(TRUE);

  DEBUG_LEAVE(0);
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  CFactory::~CFactory()

  WHAT    : W3Spoof class factory destructor. Cleans up.
  ARGS    : none.
  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
CFactory::~CFactory()
{
  DEBUG_ENTER((
    DBG_FACTORY,
    rt_void,
    "CFactory::~CFactory",
    "this=%#x",
    this
    ));

  DEBUG_TRACE(FACTORY, ("refcount=%d; locks=%d", m_cRefs, m_cLocks));
  DEBUG_LEAVE(0);
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  CFactory::Create()

  WHAT    : Creates the class factory.
  ARGS    : none.
  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
HRESULT
CFactory::Create(CFactory** ppCF)
{
  DEBUG_ENTER((
    DBG_FACTORY,
    rt_hresult,
    "CFactory::Create",
    "ppCF=%#x",
    ppCF
    ));

  HRESULT hr = S_OK;

  *ppCF = new CFactory;

  if( !(*ppCF) )
  {
    hr = E_OUTOFMEMORY;
  }

  DEBUG_LEAVE(hr);
  return hr;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  CFactory::Terminate()

  WHAT    : Terminates the class factory.
  ARGS    : none.
  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
HRESULT
CFactory::Terminate(void)
{
  DEBUG_ENTER((
    DBG_FACTORY,
    rt_hresult,
    "CFactory::Terminate",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  _RegisterClassFactory(FALSE);

  if( m_pw3s )
    m_pw3s->Terminate();

  SAFERELEASE(m_pw3s);
  Release();

  DEBUG_LEAVE(hr);
  return hr;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  CFactory::QueryInterface()

  WHAT    : IUnknown member implementation.

  ARGS    : riid - IID wanted by caller
            ppv  - pointer to return interface through

  RETURNS : S_OK          - the caller got the interface they wanted.
            E_NOINTERFACE - they didn't.
            E_INVALIDARG  - the supplied a bogus return pointer.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
HRESULT
__stdcall
CFactory::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_FACTORY,
    rt_hresult,
    "CFactory::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

  if( !ppv )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory) )
  {
    *ppv = static_cast<IClassFactory*>(this);
  }
  else
  {
    *ppv = NULL;
    hr   = E_NOINTERFACE;
  }

  if( SUCCEEDED(hr) )
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();

quit:

  DEBUG_LEAVE(hr);
  return hr;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  CFactory::AddRef()

  WHAT    : IUnknown member implementation.
  ARGS    : none.
  RETURNS : nothing of consequence.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
ULONG
__stdcall
CFactory::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("CFactory", m_cRefs);
  return m_cRefs;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  CFactory::Release()

  WHAT    : IUnknown member implementation.
  ARGS    : none.
  RETURNS : nothing of consequence.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
ULONG
__stdcall
CFactory::Release(void)
{

  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("CFactory", m_cRefs);

    if( m_cRefs == 0 )
    {
      DEBUG_FINALRELEASE("CFactory");
      delete this;
      return 0;
    }

  return m_cRefs;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  CFactory::CreateInstance()

  WHAT    : IClassFactory member implementation.

  ARGS    : pContainer - an object attempting to aggregate this class
                         will supply its IUnknown pointer through this
                         parameter.

            riid       - interface caller wants.
            ppv        - pointer to return interface through.

  RETURNS : S_OK                  - caller got what they wanted.
            E_INVALIDARG          - caller supplied bogus return pointer.
            CLASS_E_NOAGGREGATION - caller tried to aggregate.
            E_NOINTERFACE         - caller asked for unsupported interface.
            E_OUTOFMEMORY         - couldn't allocate object.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
HRESULT
__stdcall
CFactory::CreateInstance(IUnknown* pContainer, REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_FACTORY,
    rt_hresult,
    "CFactory::CreateInstance",
    "this=%#x; pContainer=%#x; riid=%s; ppv=%#x",
    this,
    pContainer,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

  if( !ppv )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( pContainer )
  {
    *ppv = NULL;
    hr   = CLASS_E_NOAGGREGATION;
    goto quit;
  }

  if( m_pw3s )
  {
    hr = m_pw3s->QueryInterface(riid, ppv);
  }
  else
  {
    hr = E_OUTOFMEMORY;
    goto quit;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  CFactory::LockServer()

  WHAT    : IClassFactory member implementation.

  ARGS    : fLock - apply or remove a lock.
  RETURNS : S_OK  - always.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
HRESULT
__stdcall
CFactory::LockServer(BOOL fLock)
{
  DEBUG_ENTER((
    DBG_FACTORY,
    rt_hresult,
    "CFactory::LockServer",
    "this=%#x; fLock=%d",
    this,
    fLock
    ));

  HRESULT hr = S_OK;

    fLock ? InterlockedIncrement(&m_cLocks) : InterlockedDecrement(&m_cLocks);
    DEBUG_TRACE(REFCOUNT, ("factory locks=%d", m_cLocks));

  DEBUG_LEAVE(hr);
  return hr;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  CFactory::Activate()

  WHAT    : Allows COM to use the class factory, which is registered in
            suspended mode.

  ARGS    : none.

  RETURNS : S_OK  - class factory was resumed..
            other - error describes reason for failure.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
HRESULT
CFactory::Activate(void)
{
  DEBUG_ENTER((
    DBG_FACTORY,
    rt_hresult,
    "CFactory::Activate",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    hr = CoResumeClassObjects();

  DEBUG_LEAVE(hr);
  return hr;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  CFactory::_RegisterServer()

  WHAT    : Self-registration routine.

  ARGS    : fMode  - if true, registers the component. if false...

  RETURNS : S_OK   - registration succeeded.
            E_FAIL - registration failed.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
HRESULT
CFactory::_RegisterServer(BOOL fMode)
{
  DEBUG_ENTER((
    DBG_FACTORY,
    rt_hresult,
    "CFactory::_RegisterServer",
    "this=%#x; fMode=%s",
    this,
    fMode ? "reg" : "unreg"
    ));

  HRESULT    hr      = S_OK;
  HINSTANCE  advpack = NULL;
  REGINSTALL pfnri   = NULL;

  advpack = LoadLibrary(g_wszAdvPackDll);

    if( !advpack )
    {
      DEBUG_TRACE(
        FACTORY,
        ("couldn't load advpack.dll: %s", MapErrorToString(GetLastError()))
        );

      hr = E_FAIL;
      goto quit;
    }

  DEBUG_TRACE(FACTORY, ("loaded advpack.dll"));
  pfnri = (REGINSTALL) GetProcAddress(advpack, achREGINSTALL);

    if( !pfnri )
    {
      DEBUG_TRACE(
        FACTORY,
        ("couldn't get RegInstall pointer: %s", MapErrorToString(GetLastError()))
        );

      hr = E_FAIL;
      goto quit;
    }

  DEBUG_TRACE(FACTORY, ("calling reginstall to %s", (fMode ? "reg" : "unreg")));
  hr = pfnri(
        GetModuleHandle(NULL),
        fMode ? g_szRegSection : g_szUnRegSection,
        NULL
        );

  if( SUCCEEDED(hr) )
  {
    DWORD dw = 1;

    SetRegValue(g_wszRegistered, REG_DWORD, (void*)&dw, sizeof(DWORD));
  }

  DEBUG_TRACE(FACTORY, ("unloading advpack.dll"));
  FreeLibrary(advpack);

  hr = _RegisterTypeLibrary(fMode);

quit:

  DEBUG_LEAVE(hr);
  return hr;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  CFactory::_RegisterClassFactory()

  WHAT    : Class factory registration routine.

  ARGS    : fMode - if true, register, if false...

  RETURNS : S_OK   - success
            E_FAIL - failure

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
HRESULT
CFactory::_RegisterClassFactory(BOOL fMode)
{
  DEBUG_ENTER((
    DBG_FACTORY,
    rt_hresult,
    "CFactory::_RegisterClassFactory",
    "this=%#x; fMode=%s",
    this,
    fMode ? "reg" : "unreg"
    ));

  HRESULT hr = S_OK;

    if( fMode )
    {
      hr = CoRegisterClassObject(
            CLSID_W3Spoof,
            static_cast<IUnknown*>(this),
            CLSCTX_LOCAL_SERVER,
            REGCLS_MULTI_SEPARATE | REGCLS_SUSPENDED,
            &m_dwCookie
            );
    }
    else
    {
      hr = CoRevokeClassObject(m_dwCookie);
    }

  DEBUG_LEAVE(hr);
  return hr;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  CFactory::_RegisterTypeLibrary()

  WHAT    : TypeLib registration routine.

  ARGS    : fMode - if true, register, if false...

  RETURNS : S_OK   - success
            E_FAIL - failure

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
HRESULT
CFactory::_RegisterTypeLibrary(BOOL fMode)
{
  DEBUG_ENTER((
    DBG_FACTORY,
    rt_hresult,
    "CFactory::_RegisterTypeLibrary",
    "this=%#x; fMode=%s",
    this,
    fMode ? "reg" : "unreg"
    ));

  ITypeLib* ptl  = NULL;
  TLIBATTR* pta  = NULL;
  WCHAR*    pbuf = NULL;
  HRESULT   hr   = S_OK;

  if( (pbuf = new WCHAR[MAX_PATH]) )
  {
    GetModuleFileName(NULL, pbuf, MAX_PATH);
  }
  else
  {
    hr = E_OUTOFMEMORY;
    goto quit;
  }

  hr = LoadTypeLib(pbuf, &ptl);

  if( SUCCEEDED(hr) )
  {
    if( fMode )
    {
      hr = RegisterTypeLib(ptl, pbuf, NULL);
    }
    else
    {
      hr = ptl->GetLibAttr(&pta);

        if( SUCCEEDED(hr) )
        {
          hr = UnRegisterTypeLib(
                pta->guid,
                pta->wMajorVerNum,
                pta->wMinorVerNum,
                pta->lcid,
                pta->syskind
                );

          ptl->ReleaseTLibAttr(pta);
        }
        else
        {
          goto quit;
        }
    }
    
    ptl->Release();
  }

quit:

  delete [] pbuf;

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\w3sobj\iunknown.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    iunknown.cxx

Abstract:

    Implements the W3Spoof object's IUnknown & IExternalConnection interfaces.
    
Author:

    Paul M Midgen (pmidge) 08-January-2001


Revision History:

    08-January-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

//-----------------------------------------------------------------------------
// IUnknown
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CW3Spoof::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_REFCOUNT,
    rt_hresult,
    "CW3Spoof::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

  if( m_state != ST_OPEN )
  {
    DEBUG_TRACE(W3SOBJ, ("invalid state!"));

    *ppv = NULL;
    hr   = E_FAIL;
    goto quit;
  }
  else
  {
    if(
      IsEqualIID(riid, IID_IUnknown) ||
      IsEqualIID(riid, IID_IW3Spoof) ||
      IsEqualIID(riid, IID_IConfig)
      )
    {
      *ppv = static_cast<IW3Spoof*>(this);
    }
    else if( IsEqualIID(riid, IID_IDispatch) )
    {
      *ppv = static_cast<IDispatch*>(this);
    }
    else if( IsEqualIID(riid, IID_IThreadPool) )
    {
      *ppv = static_cast<IThreadPool*>(this);
    }
    else if( IsEqualIID(riid, IID_IW3SpoofClientSupport) )
    {
      *ppv = static_cast<IW3SpoofClientSupport*>(this);
    }
    else if( IsEqualIID(riid, IID_IExternalConnection) )
    {
      *ppv = static_cast<IExternalConnection*>(this);
    }
    else if( IsEqualIID(riid, IID_IConnectionPointContainer) )
    {
      *ppv = static_cast<IConnectionPointContainer*>(this);
    }
    else
    {
      *ppv = NULL;
      hr   = E_NOINTERFACE;
    }

    if( SUCCEEDED(hr) )
      reinterpret_cast<IUnknown*>(*ppv)->AddRef();
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


ULONG
__stdcall
CW3Spoof::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("CW3Spoof", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
CW3Spoof::Release(void)
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("CW3Spoof", m_cRefs);

    if( m_cRefs == 0 )
    {
      DEBUG_FINALRELEASE("CW3Spoof");
      delete this;
      return 0;
    }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IExternalConnection
//-----------------------------------------------------------------------------
DWORD
__stdcall
CW3Spoof::AddConnection(DWORD type, DWORD reserved)
{
  DWORD ret = 0L;

    if( type & EXTCONN_STRONG )
    {
      ret = (DWORD) InterlockedIncrement(&m_cExtRefs);
    }

  DEBUG_TRACE(W3SOBJ, ("external refcount: %d", m_cExtRefs));
  return ret;
}


DWORD
__stdcall
CW3Spoof::ReleaseConnection(DWORD type, DWORD reserved, BOOL bCloseIfLast)
{
  DWORD ret = 0L;

    if( type & EXTCONN_STRONG )
    {
      ret = (DWORD) InterlockedDecrement(&m_cExtRefs);

      if( (ret == 0) && bCloseIfLast )
      {
        SetEvent(m_evtServerUnload);
      }
    }

  DEBUG_TRACE(W3SOBJ, ("external refcount: %d", m_cExtRefs));
  return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\w3sobj\ithreadpool.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ithreadpool.cxx

Abstract:

    Implements the W3Spoof object's IThreadPool interface.
    
Author:

    Paul M Midgen (pmidge) 08-February-2001


Revision History:

    08-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

BOOL
CW3Spoof::_InitializeThreads(void)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_bool,
    "CW3Spoof::_InitializeThreads",
    "this=%#x",
    this
    ));

  BOOL        bStatus = FALSE;
  DWORD       error   = 0L;
  SOCKADDR_IN local   = {0};

  m_hIOCP = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, m_dwMaxActiveThreads);

    if( !m_hIOCP )
    {
      DEBUG_TRACE(
        W3SOBJ,
        ("error creating completion port: %s", MapErrorToString(GetLastError()))
        );
      
      goto quit;
    }

  m_sListen = socket(AF_INET, SOCK_STREAM, 0);

    if( m_sListen == INVALID_SOCKET )
    {
      DEBUG_TRACE(
        W3SOBJ,
        ("error creating listen socket: %s", MapErrorToString(WSAGetLastError()))
        );

      goto quit;
    }

  local.sin_family      = AF_INET;
  local.sin_addr.s_addr = htonl(INADDR_ANY);
  local.sin_port        = htons(m_usServerPort);

  error = bind(m_sListen, (PSOCKADDR) &local, sizeof(local));

    if( error == SOCKET_ERROR )
    {        
      DEBUG_TRACE(W3SOBJ, ("error binding listen socket: %s", MapErrorToString(WSAGetLastError())));
      goto quit;
    }

  error = listen(m_sListen, SOMAXCONN);

    if( error == SOCKET_ERROR )
    {
      DEBUG_TRACE(W3SOBJ, ("error listening: %s", MapErrorToString(WSAGetLastError())));
      goto quit;
    }
    
  CreateIoCompletionPort((HANDLE) m_sListen, m_hIOCP, CK_NEW_CONNECTION, m_dwMaxActiveThreads);

  m_arThreads = new HANDLE[m_dwPoolSize];

    if( !m_arThreads )
    {
      DEBUG_TRACE(W3SOBJ, ("error allocating thread handles: %s", MapErrorToString(GetLastError())));
      goto quit;
    }

  for(DWORD n=0; n < m_dwPoolSize; n++)
  {
    m_arThreads[n] = CreateThread(
                       NULL, 0,
                       ThreadFunc, (LPVOID) (static_cast<IThreadPool*>(this)),
                       0, NULL
                       );

    if( !m_arThreads[n] )
    {
      DEBUG_TRACE(W3SOBJ, ("error creating thread %d: %s", n, MapErrorToString(GetLastError())));
      goto quit;
    }
  }

  bStatus = TRUE;

quit:

  DEBUG_LEAVE(bStatus);
  return bStatus;
}


void
CW3Spoof::_TerminateThreads(void)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_void,
    "CW3Spoof::_TerminateThreads",
    "this=%#x",
    this
    ));

  //
  // BUGBUG: this could generate *_OPERATION_ABORTED results, need to keep this in mind
  //         in case there are weird state issues handling aborted io ops. should be no
  //         problem... but you never know.
  //
  SAFECLOSESOCKET(m_sListen);

  for(DWORD n=0; n < m_dwPoolSize; n++)
  {
    PostQueuedCompletionStatus(m_hIOCP, 0L, CK_CANCEL_IO, NULL);
  }

  WaitForMultipleObjects(m_dwPoolSize, m_arThreads, TRUE, INFINITE);

  for(DWORD n=0; n < m_dwPoolSize; n++)
  {
    SAFECLOSE(m_arThreads[n]);
  }

  SAFEDELETEBUF(m_arThreads);
  SAFECLOSE(m_hIOCP);

  DEBUG_LEAVE(0);
}


DWORD
CW3Spoof::_QueueAccept(void)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_dword,
    "CW3Spoof::_QueueAccept",
    "this=%#x",
    this
    ));

  DWORD ret = ERROR_IO_PENDING;

  if( 0 == InterlockedCompareExchange(&m_PendingAccepts, 0, 0) )
  {
    // available pending accepts has dropped to 0, close
    // the accept queue.
    m_AcceptQueueStatus = 0;
  }
  else
  {
    if( m_AcceptQueueStatus )
    {
      BOOL   bAccepted = TRUE;
      PIOCTX pioc      = NULL;

      InterlockedDecrement(&m_PendingAccepts);

      pioc = new IOCTX(IOCT_CONNECT, socket(AF_INET, SOCK_STREAM, 0));

      if( pioc && pioc->sockbuf )
      {
        bAccepted = AcceptEx(
                      m_sListen,
                      pioc->socket,
                      (LPVOID) pioc->sockbuf,
                      0L,
                      sizeof(SOCKADDR_IN)+16,
                      sizeof(SOCKADDR_IN)+16,
                      NULL,
                      &pioc->overlapped
                      );

        if( !bAccepted )
        {
          ret = WSAGetLastError();
        }
      }
      else
      {
        ret = ERROR_OUTOFMEMORY;
      }
    }
    else
    {
      ret = ERROR_SUCCESS;
      DEBUG_TRACE(W3SOBJ, ("queue is closed"));
    }
  }

  DEBUG_LEAVE(ret);
  return ret;
}


BOOL
CW3Spoof::_CompleteAccept(PIOCTX pioc)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_bool,
    "CW3Spoof::_CompleteAccept",
    "this=%#x; pioc=%#x",
    this, pioc
    ));

  BOOL bStatus = FALSE;

  if( pioc->socket != INVALID_SOCKET )
  {
    DWORD  mode           = 1L;
    struct linger _linger = {1, 2};

    setsockopt(
      pioc->socket,
      SOL_SOCKET, SO_UPDATE_ACCEPT_CONTEXT,
      (char*) &m_sListen, sizeof(m_sListen)
      );

    setsockopt(
      pioc->socket,
      SOL_SOCKET, SO_LINGER,
      (char*) &_linger, sizeof(struct linger)
      );

    setsockopt(
      pioc->socket,
      IPPROTO_TCP, TCP_NODELAY,
      (char*) &mode, sizeof(DWORD)
      );

    ParseSocketInfo(pioc);

    bStatus = SUCCEEDED(Register(pioc->socket)) ? TRUE : FALSE;
  }

  // increment available pending accepts and check to see if the queue
  // can be reopened
  InterlockedIncrement(&m_PendingAccepts);

  if( m_MaxQueuedAccepts ==
      InterlockedCompareExchange(&m_PendingAccepts, m_MaxQueuedAccepts, m_MaxQueuedAccepts)
    )
  {
    m_AcceptQueueStatus = 1;
  }

  DEBUG_LEAVE(bStatus);
  return bStatus;
}


BOOL
CW3Spoof::_DisconnectSocket(PIOCTX pioc, BOOL fNBGC)
{
  if( pioc->socket != INVALID_SOCKET )
  {
    if( fNBGC )
    {
      shutdown(pioc->socket, SD_SEND);
    }
    else
    {
      struct linger _linger = {1, 0};

      setsockopt(
        pioc->socket,
        SOL_SOCKET, SO_LINGER,
        (char*) &_linger, sizeof(struct linger)
        );
    }

    closesocket(pioc->socket);
    pioc->socket = INVALID_SOCKET;

    return TRUE;
  }

  return FALSE;
}


HRESULT
__stdcall
CW3Spoof::GetStatus(PIOCTX* ppioc, LPBOOL pbQuit)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3Spoof::GetStatus",
    "this=%#x; ppioc=%#x; pbQuit=%#x",
    this,
    ppioc,
    pbQuit
    ));

  HRESULT      hr      = S_OK;
  DWORD        error   = ERROR_SUCCESS;
  DWORD        comp    = 0L;
  DWORD        bytes   = 0L;
  LPOVERLAPPED lpo     = NULL;

  _QueueAccept();

  if( GetQueuedCompletionStatus(m_hIOCP, &bytes, &comp, &lpo, INFINITE) )
  {
    switch( comp )
    {
      case CK_NEW_CONNECTION :
        {
          DEBUG_TRACE(W3SOBJ, ("status: new connection"));

          *ppioc  = GETIOCTX(lpo);
          *pbQuit = FALSE;

          if( (*ppioc) && _CompleteAccept(*ppioc) )
          {
            IW3Spoof* pw3s = NULL;

            hr = QueryInterface(IID_IW3Spoof, (void**) &pw3s);

            if( SUCCEEDED(hr) )
            {
              hr = SESSIONOBJ::Create(*ppioc, pw3s);
              SAFERELEASE(pw3s);
            }
          }
          else
          {
            SAFERELEASE((*ppioc));
            hr = E_FAIL;
          }

          if( FAILED(hr) )
          {
            break;
          }
        }

      case CK_NORMAL :
        {
          DEBUG_TRACE(W3SOBJ, ("status: normal"));

          *ppioc          = GETIOCTX(lpo);
          (*ppioc)->bytes = bytes;
          *pbQuit         = FALSE;
          hr              = S_OK;
        }
        break;

      case CK_CANCEL_IO :
        {
          DEBUG_TRACE(W3SOBJ, ("status: cancel io"));

          m_AcceptQueueStatus = 0;
          CancelIo((HANDLE) m_sListen);

          //
          // BUGBUG: temporary hack to get all threads to call CancelIo().
          //         i need to figure out a better way.
          //
          // P.S. this works because it puts the thread in a non-alertable state,
          //      which causes the completion port code to wake up another thread.
          //
          Sleep(100);

          PostQueuedCompletionStatus(m_hIOCP, 0L, CK_TERMINATE_THREAD, NULL);
          
          *ppioc  = NULL;
          *pbQuit = FALSE;
          hr      = E_FAIL;
        }
        break;

      case CK_TERMINATE_THREAD :
        {
          DEBUG_TRACE(W3SOBJ, ("status: terminate thread"));

          *ppioc  = NULL;
          *pbQuit = TRUE;
          hr      = E_FAIL;
        }
        break;
    }
  }
  else
  {
    error = GetLastError();

    switch( error )
    {
      case ERROR_NETNAME_DELETED :
        {
          *ppioc = GETIOCTX(lpo);

          //
          // happens when a client closes a keep-alive connection on which
          // we have a receive pending. if there's a session associated with
          // this IO, we defer error handling to the session fsm.
          //
          if( (*ppioc)->clientid && SUCCEEDED(m_sessionmap->Get((*ppioc)->clientid, (void**) &(*ppioc)->session)) )
          {
            (*ppioc)->error = error;
            hr              = S_OK;
          }
          else
          {
            _DisconnectSocket(*ppioc, TRUE);
            SAFERELEASE((*ppioc));
            hr = E_FAIL;
          }
        }
        break;

      case ERROR_OPERATION_ABORTED :
        {
          *ppioc = GETIOCTX(lpo);

          //
          // happens when CancelIo() or closesocket() are called and there are
          // pending overlapped operations. if there's a session associated with
          // the IOCTX, we defer error handling to the session fsm.
          //
          if( (*ppioc)->clientid && SUCCEEDED(m_sessionmap->Get((*ppioc)->clientid, (void**) &(*ppioc)->session)) )
          {
            (*ppioc)->error = error;
            hr              = S_OK;
          }
          else
          {
            _DisconnectSocket(*ppioc, FALSE);
            SAFERELEASE((*ppioc));
            hr = E_FAIL;
          }
        }
        break;

      default :
        {
          DEBUG_TRACE(W3SOBJ, ("unhandled error - %s", MapErrorToString(error)));
        }
        break;
    }
  }
  
  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3Spoof::GetSession(LPWSTR clientid, PSESSIONOBJ* ppso)
{
  HRESULT hr = S_OK;

  hr = m_sessionmap->Get(clientid, (void**) ppso);

  return hr;
}


HRESULT
__stdcall
CW3Spoof::Register(SOCKET s)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3Spoof::Register",
    "this=%#x; s=%#x",
    this,
    s
    ));

  HRESULT hr = S_OK;
  HANDLE  ret = NULL;
  
  ret = CreateIoCompletionPort(
          (HANDLE) s, m_hIOCP,
          CK_NORMAL, m_dwMaxActiveThreads
          );

  if( !ret )
  {
    DEBUG_TRACE(W3SOBJ, ("failed to associate socket!"));
    hr = E_FAIL;
  }

  DEBUG_LEAVE(hr);
  return hr;
}


DWORD
WINAPI
ThreadFunc(LPVOID lpv)
{
  DEBUG_ENTER((
    DBG_WORKER,
    rt_hresult,
    "worker",
    "lpv=%#x",
    lpv
    ));

  HRESULT      hr    = S_OK;
  BOOL         bQuit = FALSE;
  PIOCTX       pioc  = NULL;
  IThreadPool* ptp   = (IThreadPool*) lpv;
  PSESSIONOBJ  pso   = NULL;

    while( !bQuit )
    {
      if( SUCCEEDED(ptp->GetStatus(&pioc, &bQuit)) )
      {
        if( (pso = pioc->session) || SUCCEEDED(ptp->GetSession(pioc->clientid, &pso)) )
        {
          pso->Run(pioc);
        }
        
        SAFERELEASE(pioc);
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\w3sobj\iw3spoof.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    iw3spoof.cxx

Abstract:

    Implements the W3Spoof object's IW3Spoof interface.
    
Author:

    Paul M Midgen (pmidge) 08-February-2001


Revision History:

    08-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"


HRESULT
__stdcall
CW3Spoof::GetRuntime(IW3SpoofRuntime** pprt)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3Spoof::GetRuntime",
    "this=%#x; pprt=%#x",
    this,
    pprt
    ));

  HRESULT hr = S_OK;

    if( !pprt )
    {
      hr = E_POINTER;
    }
    else
    {
      *pprt = NULL;

      if( m_prt )
      {
        hr = m_prt->QueryInterface(IID_IW3SpoofRuntime, (void**) pprt);
        DEBUG_TRACE(W3SOBJ, ("returning IW3SpoofRuntime instance %#x", *pprt));
      }
      else
      {
        hr = E_FAIL;
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3Spoof::GetTypeLibrary(ITypeLib** pptl)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3Spoof::GetTypeLibrary",
    "this=%#x; pptl=%#x",
    this,
    pptl
    ));

  HRESULT hr = S_OK;

    if( !pptl )
    {
      hr = E_POINTER;
    }
    else
    {
      *pptl = NULL;

      if( m_ptl )
      {
        hr = m_ptl->QueryInterface(IID_ITypeLib, (void**) pptl);
        DEBUG_TRACE(W3SOBJ, ("returning ITypeLib instance %#x", *pptl));
      }
      else
      {
        hr = E_FAIL;
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3Spoof::GetScriptEngine(IActiveScript** ppas)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3Spoof::GetScriptEngine",
    "this=%#x; ppas=%#x",
    this,
    ppas
    ));

  HRESULT hr = S_OK;

    if( !ppas )
    {
      hr = E_POINTER;
    }
    else
    {
      *ppas = NULL;

      if( m_pas )
      {
        hr = m_pas->QueryInterface(IID_IActiveScript, (void**) ppas);
        DEBUG_TRACE(W3SOBJ, ("returning IActiveScript instance %#x", *ppas));
      }
      else
      {
        hr = E_FAIL;
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3Spoof::GetScriptPath(LPWSTR client, LPWSTR* path)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3Spoof::GetScriptPath",
    "this=%#x; client=%S; path=%#x",
    this,
    client,
    path
    ));

  HRESULT hr = S_OK;

  if( !path )
  {
    hr = E_POINTER;
    goto quit;
  }

  if( !client )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( m_clientmap && (m_clientmap->Get(client, (void**) path) != ERROR_SUCCESS) )
  {
    *path = L"default.js";
  }

  DEBUG_TRACE(W3SOBJ, ("script path is %S", *path));

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3Spoof::Notify(LPWSTR clientid, PSESSIONOBJ pso, STATE state)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3Spoof::Notify",
    "this=%#x; clientid=%S; pso=%#x; state=%s",
    this,
    clientid,
    pso,
    MapStateToString(state)
    ));

  HRESULT hr = S_OK;

    //
    // states not directly handled:
    //
    // ST_CREATED
    // ST_OPENING
    // ST_CLOSING
    //

    switch( state )
    {
      case ST_OPEN :
        {
          DEBUG_TRACE(W3SOBJ, ("registering session object"));

          m_CP.FireOnSessionOpen(clientid);
          hr = m_sessionmap->Insert(clientid, (void*) pso);
        }
        break;

      case ST_CLOSED :
        {
          DEBUG_TRACE(W3SOBJ, ("unregistering session object"));

          m_CP.FireOnSessionClose(clientid);
          m_sessionmap->Delete(clientid, NULL);
        }
        break;

      case ST_ERROR :
        {
          m_CP.FireOnSessionStateChange(clientid, state);
          m_sessionmap->Delete(clientid, NULL);
        }
        break;

      default :
        {
          m_CP.FireOnSessionStateChange(clientid, state);
        }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3Spoof::WaitForUnload(void)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3Spoof::WaitForUnload",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  WaitForSingleObject(m_evtServerUnload, INFINITE);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3Spoof::Terminate(void)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3Spoof::Terminate",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  _SetState(ST_CLOSING);

    _TerminateThreads();

    SAFETERMINATE(m_prt);
    SAFERELEASE(m_ptl);
    SAFERELEASE(m_pas);
    SAFEDELETE(m_clientmap);
    SAFEDELETE(m_sessionmap);
    SAFECLOSE(m_evtServerUnload);

  _SetState(ST_CLOSED);

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\w3sobj\w3sobj.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    w3spoof.cpp

Abstract:

    Implements the W3Spoof application object and the following interfaces:
    
      IConfig
      IConnectionPointContainer
      IConnectionPoint (via contained CW3SpoofEventsCP object)
    
Author:

    Paul M Midgen (pmidge) 07-June-2000


Revision History:

    07-June-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

LPCWSTR g_wszPoolSize      = L"MaxPoolSize";
LPCWSTR g_wszActiveThreads = L"MaxActiveThreads";
LPCWSTR g_wszServerPort    = L"ServerPort";

//-----------------------------------------------------------------------------
// CW3Spoof methods
//-----------------------------------------------------------------------------
CW3Spoof::CW3Spoof():
  m_cRefs(0),
  m_cExtRefs(0),
  m_evtServerUnload(INVALID_HANDLE_VALUE),
  m_prt(NULL),
  m_ptl(NULL),
  m_clientmap(NULL),
  m_sessionmap(NULL),
  m_dwPoolSize(0),
  m_dwMaxActiveThreads(0),
  m_usServerPort(8080),
  m_arThreads(NULL),
  m_sListen(INVALID_SOCKET),
  m_hIOCP(NULL),
  m_AcceptQueueStatus(1),
  m_MaxQueuedAccepts(10),
  m_PendingAccepts(10)
{
  DEBUG_TRACE(W3SOBJ, ("CW3Spoof created: %#x", this));
  _SetState(ST_OPENING);
}


CW3Spoof::~CW3Spoof()
{
  DEBUG_TRACE(W3SOBJ, ("CW3Spoof deleted: %#x", this));
}


HRESULT
CW3Spoof::Create(IW3Spoof** ppw3s)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3Spoof::Create",
    "ppw3s=%#x",
    ppw3s
    ));

  HRESULT   hr   = E_FAIL;
  CW3Spoof* pw3s = NULL;

  if( pw3s = new CW3Spoof )
  {
    if( pw3s->_Initialize() != ERROR_SUCCESS )
    {
      DEBUG_TRACE(W3SOBJ, ("object initialization failed"));
      delete pw3s;
      goto quit;
    }
  }
  else
  {
    DEBUG_TRACE(W3SOBJ, ("failed to allocate object: %s", GetLastError()));
    *ppw3s = NULL;
    goto quit;
  }

  hr = pw3s->QueryInterface(IID_IW3Spoof, (void**) ppw3s);

    if( FAILED(hr) )
    {
      *ppw3s = NULL;
      delete pw3s;
    }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


DWORD
CW3Spoof::_Initialize(void)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_dword,
    "CW3Spoof::_Initialize",
    "this=%#x",
    this
    ));

  DWORD               dwRet = ERROR_SUCCESS;
  HRESULT             hr    = S_OK;
  WCHAR*              buf   = NULL;
  CLSID               clsid = {0};
  SYSTEM_INFO         si    = {0};
  IActiveScriptParse* parse = NULL;

  if( m_state != ST_OPENING )
  {
    dwRet = ERROR_INVALID_STATE;
    goto quit;
  }

  GetSystemInfo(&si);

  m_dwPoolSize         = si.dwNumberOfProcessors;
  m_dwMaxActiveThreads = si.dwNumberOfProcessors;

  _LoadRegDefaults();

  m_CP.SetSite(dynamic_cast<IW3Spoof*>(this));

  if( !_InitializeThreads() )
  {
    dwRet = ERROR_FAILURE;
    DEBUG_TRACE(W3SOBJ, ("error creating worker threads"));
    goto quit;
  }

  m_clientmap = new STRINGMAP;

    if( m_clientmap )
    {
      m_clientmap->SetClearFunction(BSTRKiller);
    }
    else
    {
      dwRet = ERROR_OUTOFMEMORY;
      goto quit;
    }

  m_sessionmap = new STRINGMAP;
  buf          = new WCHAR[MAX_PATH];

    if( !(m_sessionmap && buf) )
    {
      dwRet = ERROR_OUTOFMEMORY;
      goto quit;
    }

  GetModuleFileName(NULL, buf, MAX_PATH);

    hr = LoadTypeLib(buf, &m_ptl);

    if( FAILED(hr) )
    {
      dwRet = ERROR_FAILURE;
      DEBUG_TRACE(W3SOBJ, ("failed to load type library - %s", MapHResultToString(hr)));
    }

  if( FAILED(RUNTIME::Create(&m_prt)) )
  {
    dwRet = ERROR_FAILURE;
    DEBUG_TRACE(W3SOBJ, ("failed to create runtime"));
    goto quit;
  }

  if( GetJScriptCLSID(&clsid) )
  {
    hr = CoCreateInstance(
           clsid,
           NULL,
           CLSCTX_ALL,
           IID_IActiveScript,
           (void**) &m_pas
           );

    if( FAILED(hr) )
    {
      dwRet = ERROR_FAILURE;
      DEBUG_TRACE(W3SOBJ, ("error cocreating script engine - %s", MapHResultToString(hr)));
    }
    else
    {
      hr = m_pas->QueryInterface(IID_IActiveScriptParse, (void**) &parse);

        if( FAILED(hr) )
          goto quit;

      hr = parse->InitNew();
    }
  }
  else
  {
    DEBUG_TRACE(W3SOBJ, ("ERROR! Couldn't find the JScript CLSID."));
    dwRet = ERROR_FAILURE;
    goto quit;
  }

  m_evtServerUnload = CreateEvent(NULL, TRUE, FALSE, NULL);

quit:

  _SetState(
    (dwRet == ERROR_SUCCESS) ? ST_OPEN : ST_ERROR
    );

  SAFEDELETEBUF(buf);
  SAFERELEASE(parse);

  DEBUG_LEAVE(dwRet);
  return dwRet;
}


void
CW3Spoof::_LoadRegDefaults(void)
{
  LPDWORD pdw = NULL;

  if( GetRegValue(g_wszPoolSize, REG_DWORD, (void**) &pdw) )
  {
    m_dwPoolSize = *pdw;
    DEBUG_TRACE(W3SOBJ, ("pool size: %d", m_dwPoolSize));
    delete pdw;
  }

  if( GetRegValue(g_wszActiveThreads, REG_DWORD, (void**) &pdw) )
  {
    m_dwMaxActiveThreads = *pdw;
    DEBUG_TRACE(W3SOBJ, ("max active threads: %d", m_dwMaxActiveThreads));
    delete pdw;
  }

  if( GetRegValue(g_wszServerPort, REG_DWORD, (void**) &pdw) )
  {
    m_usServerPort = (USHORT) *pdw;
    DEBUG_TRACE(W3SOBJ, ("server port: %d", m_usServerPort));
    delete pdw;
  }
}


void
CW3Spoof::_SetState(STATE st)
{
  DEBUG_TRACE(W3SOBJ, ("w3sobj state: %s", MapStateToString(st)));
  m_state = st;
}


//-----------------------------------------------------------------------------
// IConfig
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CW3Spoof::SetOption(DWORD dwOption, LPDWORD lpdwValue)
{
  return E_NOTIMPL;
}


HRESULT
__stdcall
CW3Spoof::GetOption(DWORD dwOption, LPDWORD lpdwValue)
{
  return E_NOTIMPL;
}


//-----------------------------------------------------------------------------
// IConnectionPointContainer
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CW3Spoof::EnumConnectionPoints(IEnumConnectionPoints** ppEnum)
{
  return E_NOTIMPL;
}


HRESULT
__stdcall
CW3Spoof::FindConnectionPoint(REFIID riid, IConnectionPoint** ppCP)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3Spoof::FindConnectionPoint",
    "this=%#x; riid=%s; ppCP=%#x",
    this,
    MapIIDToString(riid),
    ppCP
    ));

  HRESULT hr = S_OK;

  if( !ppCP )
  {
    hr = E_POINTER;
    goto quit;
  }

  if( IsEqualIID(riid, IID_IW3SpoofEvents) )
  {
    hr = m_CP.QueryInterface(IID_IConnectionPoint, (void**) ppCP);
  }
  else
  {
    *ppCP = NULL;
    hr    = CONNECT_E_NOCONNECTION;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// IConnectionPoint
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CW3Spoof::CW3SpoofEventsCP::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_REFCOUNT,
    rt_hresult,
    "CW3SpoofEventsCP::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

    if( IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IConnectionPoint) )
    {
      *ppv = static_cast<IConnectionPoint*>(this);
    }
    else
    {
      *ppv = NULL;
      hr   = E_NOINTERFACE;
    }

    if( SUCCEEDED(hr) )
      reinterpret_cast<IUnknown*>(*ppv)->AddRef();

  DEBUG_LEAVE(hr);
  return hr;
}


ULONG
__stdcall
CW3Spoof::CW3SpoofEventsCP::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("CW3SpoofEventsCP", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
CW3Spoof::CW3SpoofEventsCP::Release(void)
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("CW3SpoofEventsCP", m_cRefs);
  return m_cRefs;
}


HRESULT
__stdcall
CW3Spoof::CW3SpoofEventsCP::GetConnectionInterface(IID* pIID)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3SpoofEventsCP::GetConnectionInterface",
    "this=%#x; pIID=%s",
    this,
    MapIIDToString((const IID&)pIID)
    ));

  HRESULT hr = S_OK;

    if( !pIID )
    {
      hr = E_POINTER;
    }
    else
    {
      *pIID = IID_IW3SpoofEvents;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3Spoof::CW3SpoofEventsCP::GetConnectionPointContainer(IConnectionPointContainer** ppCPC)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3SpoofEventsCP::GetConnectionPointContainer",
    "this=%#x; ppCPC=%#x",
    this,
    ppCPC
    ));

  HRESULT hr = S_OK;

    if( !ppCPC )
    {
      hr = E_POINTER;
    }
    else
    {
      hr = m_pSite->QueryInterface(IID_IConnectionPointContainer, (void**) ppCPC);
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3Spoof::CW3SpoofEventsCP::Advise(IUnknown* punkSink, LPDWORD pdwCookie)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3SpoofEventsCP::Advise",
    "this=%#x; punkSink=%#x; pdwCookie=%#x",
    this,
    punkSink,
    pdwCookie
    ));

  HRESULT hr = S_OK;

  if( !punkSink || !pdwCookie )
  {
    hr = E_POINTER;
    goto quit;
  }

  if( m_cConnections != 0 )
  {
    hr = CONNECT_E_ADVISELIMIT;
    goto quit;
  }

    hr = punkSink->QueryInterface(IID_IW3SpoofEvents, (void**) &m_pSink);

    if( SUCCEEDED(hr) )
    {
      *pdwCookie = m_dwCookie = 1L;
      ++m_cConnections;
    }
    else
    {
      *pdwCookie = 0L;
      m_pSink    = NULL;
      hr         = CONNECT_E_CANNOTCONNECT;
    }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3Spoof::CW3SpoofEventsCP::Unadvise(DWORD dwCookie)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3SpoofEventsCP::Unadvise",
    "this=%#x; dwCookie=%d",
    this,
    dwCookie
    ));

  HRESULT hr = S_OK;

    if( dwCookie != 1L )
    {
      hr = CONNECT_E_NOCONNECTION;
    }
    else
    {
      m_pSink->Release();
      m_pSink    = NULL;
      m_dwCookie = 0L;
      --m_cConnections;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3Spoof::CW3SpoofEventsCP::EnumConnections(IEnumConnections** ppEnum)
{
  return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\whttptst\inc\mem.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 1999  Microsoft Corporation

Module Name:

    mem.h

Abstract:

    Internal memory allocation/deallocation routines.
    
Author:

    Paul M Midgen (pmidge) 01-June-2000


Revision History:

    01-June-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef __MEM_H__
#define __MEM_H__

#include "common.h"

void  _InitMem(void);

void* __cdecl operator new(size_t size);
void  __cdecl operator delete(void* pv);

#endif /* __MEM_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\w3spoof\w3sobj\methods.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    methods.cxx

Abstract:

    Implements the W3Spoof object's IW3SpoofClientSupport interface.
    
Author:

    Paul M Midgen (pmidge) 08-January-2001


Revision History:

    08-January-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"


HRESULT
__stdcall
CW3Spoof::RegisterClient(BSTR Client, BSTR ScriptPath)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3Spoof::RegisterClient",
    "this=%#x; Client=%S; ScriptPath=%.32S",
    this,
    Client,
    ScriptPath
    ));

  HRESULT hr  = S_OK;
  DWORD   ret = ERROR_SUCCESS;

  if( !Client || !ScriptPath )
  {
    hr = E_INVALIDARG;
  }
  else
  {    
    ret = m_clientmap->Insert(
                         Client,
                         (void*) __widetobstr(ScriptPath)
                         );

    //
    // if Insert() returns ERROR_DUP_NAME, don't increase the external
    // refcount.
    //
    if( ret == ERROR_SUCCESS )
    {
      AddConnection(EXTCONN_STRONG, 0L);
    }
    else if( ret == ERROR_OUTOFMEMORY )
    {
      hr = E_OUTOFMEMORY;
    }
  }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3Spoof::RevokeClient(BSTR Client)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3Spoof::RevokeClient",
    "this=%#x; Client=%S",
    this,
    Client
    ));

  HRESULT hr = S_OK;

    if( ERROR_SUCCESS != m_clientmap->Delete(Client, NULL) )
    {
      hr = E_FAIL;
    }
    else
    {
      ReleaseConnection(EXTCONN_STRONG, 0L, TRUE);
    }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\whttptst\inc\pch.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 1999  Microsoft Corporation

Module Name:

    pch.cxx

Abstract:

    Need this so the precompiled header will, umm, compile.
    
Author:

    Paul M Midgen (pmidge) 24-July-2000


Revision History:

    24-July-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

void foobar(void);

void foobar(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\whttptst\dll\dllentry.cxx ===
#include "common.h"

HINSTANCE  g_hGlobalDllInstance = NULL;
PHANDLEMAP g_pGlobalHandleMap   = NULL;
LPCWSTR    g_wszAdvPackDll      = L"advpack.dll";
LPCSTR     g_szInstallSection   = "install";
LPCSTR     g_szUninstallSection = "uninstall";

HRESULT RegisterServer(BOOL fMode);
HRESULT RegisterTypeLibrary(BOOL fMode);

//-----------------------------------------------------------------------------
// DLL Entry Point
//-----------------------------------------------------------------------------
BOOL
WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID pvReserved)
{
  BOOL bRet = TRUE;

  DEBUG_TRACE(
    DLL,
    ("dllmain: %s", MapDllReasonToString(dwReason))
    );

  switch( dwReason )
  {
    case DLL_PROCESS_ATTACH :
      {
        DEBUG_INITIALIZE();
        
        g_hGlobalDllInstance = hInstance;
        g_pGlobalHandleMap   = new HANDLEMAP;

        if( g_pGlobalHandleMap )
        {
          g_pGlobalHandleMap->SetClearFunction(ScriptCallbackKiller);
        }
        else
        {
          bRet = FALSE;
        }
      }
      break;

    case DLL_PROCESS_DETACH:
      {
        SAFEDELETE(g_pGlobalHandleMap);
        _GetRootKey(FALSE);
        DEBUG_TERMINATE();
      }
      break;

    case DLL_THREAD_DETACH:
      break;

    case DLL_THREAD_ATTACH:
      break;
  }
  
  return bRet;
}


//-----------------------------------------------------------------------------
// COM Entry Points
//-----------------------------------------------------------------------------
STDAPI
DllRegisterServer(void)
{
  return RegisterServer(TRUE);
}


STDAPI
DllUnregisterServer(void)
{
  return RegisterServer(FALSE);
}


STDAPI
DllGetClassObject(REFIID clsid, REFIID riid, void** ppv)
{
  return CLSFACTORY::Create(clsid, riid, ppv);
}


//-----------------------------------------------------------------------------
// SelfRegistration helper routines
//-----------------------------------------------------------------------------
HRESULT
RegisterServer(BOOL fMode)
{
  DEBUG_ENTER((
    DBG_DLL,
    rt_hresult,
    "RegisterServer",
    "fMode=%s",    
    fMode ? g_szInstallSection : g_szUninstallSection
    ));

  HRESULT    hr      = S_OK;
  HINSTANCE  advpack = NULL;
  REGINSTALL pfnri   = NULL;

  advpack = LoadLibrary(g_wszAdvPackDll);

    if( !advpack )
    {
      DEBUG_TRACE(
        DLL,
        ("couldn't load advpack.dll: %s", MapErrorToString(GetLastError()))
        );

      hr = E_FAIL;
      goto quit;
    }

  pfnri = (REGINSTALL) GetProcAddress(advpack, achREGINSTALL);

    if( !pfnri )
    {
      DEBUG_TRACE(
        DLL,
        ("couldn't get RegInstall pointer: %s", MapErrorToString(GetLastError()))
        );

      hr = E_FAIL;
      goto quit;
    }

  hr = pfnri(
        g_hGlobalDllInstance,
        fMode ? g_szInstallSection : g_szUninstallSection,
        NULL
        );

  FreeLibrary(advpack);

  hr = RegisterTypeLibrary(fMode);

quit:

  DEBUG_LEAVE(hr);
  return hr;
}

HRESULT
RegisterTypeLibrary(BOOL fMode)
{
  DEBUG_ENTER((
    DBG_FACTORY,
    rt_hresult,
    "RegisterTypeLibrary",
    "fMode=%s",    
    fMode ? g_szInstallSection : g_szUninstallSection
    ));

  ITypeLib* ptl  = NULL;
  TLIBATTR* pta  = NULL;
  WCHAR*    pbuf = NULL;
  HRESULT   hr   = S_OK;

  if( (pbuf = new WCHAR[MAX_PATH]) )
  {
    GetModuleFileName(g_hGlobalDllInstance, pbuf, MAX_PATH);
  }
  else
  {
    hr = E_OUTOFMEMORY;
    goto quit;
  }

  hr = LoadTypeLib(pbuf, &ptl);

  if( SUCCEEDED(hr) )
  {
    if( fMode )
    {
      hr = RegisterTypeLib(ptl, pbuf, NULL);
    }
    else
    {
      hr = ptl->GetLibAttr(&pta);

        if( SUCCEEDED(hr) )
        {
          hr = UnRegisterTypeLib(
                pta->guid,
                pta->wMajorVerNum,
                pta->wMinorVerNum,
                pta->lcid,
                pta->syskind
                );

          ptl->ReleaseTLibAttr(pta);
        }
        else
        {
          goto quit;
        }
    }
    
    ptl->Release();
  }

quit:

  SAFEDELETEBUF(pbuf);

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\whttptst\inc\registry.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    registry.h

Abstract:

    Registry functions
    
Author:

    Paul M Midgen (pmidge) 23-May-2000


Revision History:

    23-May-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef _REGISTRY_H_
#define _REGISTRY_H_

#include "common.h"

HKEY _GetRootKey(BOOL fOpen);

BOOL SetRegValue(LPCWSTR wszValueName, DWORD dwType, LPVOID pvData, DWORD dwSize);
BOOL GetRegValue(LPCWSTR wszValueName, DWORD dwType, LPVOID* ppvData);

#endif /* _REGISTRY_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\whttptst\whttptst.inc ===
!IF 0

Copyright (c) 1994  Microsoft Corporation

!ENDIF

!IFNDEF SDKINC
SDKINC=$(SDK_INC_PATH)
!ENDIF

!IFDEF LIBDIR
!ERROR LIBDIR already defined - choose new name
!ENDIF

ROOT=$(SDXROOT)\inetcore\winhttp\tools\whttptst
LIBDIR=$(ROOT)\obj
WHTTPTSTINC=$(ROOT)\inc

#
# if TARGETPATH is not defined (in the paths that build libraries) then this
# is the default target path
#
!IFNDEF TARGETPATH
TARGETPATH=$(LIBDIR)
TARGETTYPE=LIBRARY
!ENDIF

#
# what it is that we're building
#
MAJORCOMP=whttptst

USE_NOLIBS=1
#USE_LIBCMT=0
NO_NTDLL=1
#NO_BINPLACE=0
#BINPLACE_PLACEFILE=..\binplace.txt

#
# Linker flags
#
WIN32_WINNT_VERSION=0x0500
#WIN32_WIN95_VERSION=0x0400

#
# compiler warning flags
#
MSC_WARNING_LEVEL=/W3 /WX

#
# enable exception handling
#
USE_NATIVE_EH=1

#
# compiler definitions
#
C_DEFINES=$(C_DEFINES) -DWIN32

CLEANINF = cleaninf.exe $(CLEANINF_FLAGS)

#
# Set debugging level
#
!IF "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail" && "$(NTDEBUG)" != "ntsdnodbg"
C_DEFINES=$(C_DEFINES) -D_DEBUG
!ENDIF

!IF "$(__FULL_DEBUG__)" != ""
C_DEFINES=$(C_DEFINES) -D__FULL_DEBUG__
!ENDIF

!IFNDEF BUILD_PCH
PRECOMPILED_OPTION=/Fp$(ROOT)\inc\$(_OBJ_DIR)\*\common.pch /Yucommon.h
PRECOMPILED_CXX=1
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\whttptst\inc\common.h ===
#ifndef _COMMON_H_
#define _COMMON_H_

#define _WIN32_WINNT 0x0500
#define _UNICODE
#define UNICODE

//
// OS includes
//

#if defined(__cplusplus)
extern "C" {
#endif

#include <windows.h>
#include <shellapi.h>
#include <advpub.h>
#include <oleauto.h>
#include <objbase.h>
#include <ocidl.h>
#include <olectl.h>
#include <winhttp.h>

#if defined(__cplusplus)
}
#endif


//
// app includes
//

#pragma warning( disable : 4100 ) // unreferenced formal parameter

#include "registry.h"
#include "mem.h"
#include "dispids.h"
#include "resources.h"
#include "debug.h"
#include "whttptst.h" // generated
#include "hashtable.h"
#include "utils.h"


//
// class declarations
//
typedef class CHashTable<HINTERNET> _HANDLEMAP;
typedef class CHandleMap  HANDLEMAP;
typedef class CHandleMap* PHANDLEMAP;

void ScriptCallbackKiller(LPVOID* ppv);

class CHandleMap : public _HANDLEMAP
{
  public:
    CHandleMap() : _HANDLEMAP(10) {}
   ~CHandleMap() {}

    void GetHashAndBucket(HINTERNET id, LPDWORD lpHash, LPDWORD lpBucket);
};

typedef class ClassFactory  CLSFACTORY;
typedef class ClassFactory* PCLSFACTORY;

class ClassFactory : public IClassFactory
{
  public:
    DECLAREIUNKNOWN();
    DECLAREICLASSFACTORY();

    ClassFactory();
   ~ClassFactory();

    static HRESULT Create(REFIID clsid, REFIID riid, void** ppv);

  private:
    LONG m_cRefs;
    LONG m_cLocks;
};

void WinHttpCallback(
       HINTERNET hInternet,
       DWORD_PTR dwContext,
       DWORD     dwInternetStatus,
       LPVOID    lpvStatusInformation,
       DWORD     dwStatusInformationLength
       );

typedef class WinHttpTest  WHTTPTST;
typedef class WinHttpTest* PWHTTPTST;

class WinHttpTest : public IWinHttpTest,
                    public IProvideClassInfo
{
  public:
    DECLAREIUNKNOWN();
    DECLAREIDISPATCH();

    //
    // IWinHttpTest
    //
    HRESULT __stdcall WinHttpOpen(
                        VARIANT UserAgent,
                        VARIANT AccessType,
                        VARIANT ProxyName,
                        VARIANT ProxyBypass,
                        VARIANT Flags, 
                        VARIANT *OpenHandle
                        );
        
    HRESULT __stdcall WinHttpConnect(
                        VARIANT OpenHandle,
                        VARIANT ServerName,
                        VARIANT ServerPort,
                        VARIANT Reserved,
                        VARIANT *ConnectHandle
                        );
        
    HRESULT __stdcall WinHttpOpenRequest(
                        VARIANT ConnectHandle,
                        VARIANT Verb,
                        VARIANT ObjectName,
                        VARIANT Version,
                        VARIANT Referrer,
                        VARIANT AcceptTypes,
                        VARIANT Flags,
                        VARIANT *RequestHandle
                        );
        
    HRESULT __stdcall WinHttpSendRequest(
                        VARIANT RequestHandle,
                        VARIANT Headers,
                        VARIANT HeadersLength,
                        VARIANT OptionalData,
                        VARIANT OptionalLength,
                        VARIANT TotalLength,
                        VARIANT Context,
                        VARIANT *Success
                        );
        
    HRESULT __stdcall WinHttpReceiveResponse(
                        VARIANT RequestHandle,
                        VARIANT Reserved,
                        VARIANT *Success
                        );

    HRESULT __stdcall WinHttpCloseHandle(
                        VARIANT InternetHandle,
                        VARIANT *Success
                        );

    HRESULT __stdcall WinHttpReadData(
                        VARIANT RequestHandle,
                        VARIANT BufferObject,
                        VARIANT *Success
                        );

    HRESULT __stdcall WinHttpWriteData(
                        VARIANT RequestHandle,
                        VARIANT BufferObject,
                        VARIANT *Success
                        );

    HRESULT __stdcall WinHttpQueryDataAvailable(
                        VARIANT RequestHandle,
                        VARIANT boNumberOfBytesAvailable,
                        VARIANT *Success
                        );

    HRESULT __stdcall WinHttpQueryOption(
                        VARIANT InternetHandle,
                        VARIANT Option,
                        VARIANT BufferObject,
                        VARIANT *Success
                        );

    HRESULT __stdcall WinHttpSetOption(
                        VARIANT InternetHandle,
                        VARIANT Option,
                        VARIANT BufferObject,
                        VARIANT *Success
                        );

    HRESULT __stdcall WinHttpSetTimeouts(
                        VARIANT InternetHandle,
                        VARIANT ResolveTimeout,
                        VARIANT ConnectTimeout,
                        VARIANT SendTimeout,
                        VARIANT ReceiveTimeout,
                        VARIANT *Success
                        );
        
    HRESULT __stdcall WinHttpAddRequestHeaders(
                        VARIANT RequestHandle,
                        VARIANT Headers,
                        VARIANT HeadersLength,
                        VARIANT Modifiers,
                        VARIANT *Success
                        );
        
    HRESULT __stdcall WinHttpSetCredentials(
                        VARIANT RequestHandle,
                        VARIANT AuthTargets,
                        VARIANT AuthScheme,
                        VARIANT UserName,
                        VARIANT Password,
                        VARIANT AuthParams,
                        VARIANT *Success
                        );
        
    HRESULT __stdcall WinHttpQueryAuthSchemes(
                        VARIANT RequestHandle,
                        VARIANT SupportedSchemes,
                        VARIANT PreferredSchemes,
                        VARIANT AuthTarget,
                        VARIANT *Success
                        );
        
    HRESULT __stdcall WinHttpQueryHeaders(
                        VARIANT RequestHandle,
                        VARIANT InfoLevel,
                        VARIANT HeaderName,
                        VARIANT HeaderValue,
                        VARIANT HeaderValueLength,
                        VARIANT *Success
                        );
        
    HRESULT __stdcall WinHttpTimeFromSystemTime(
                        VARIANT SystemTime,
                        VARIANT boHttpTime,
                        VARIANT *Success
                        );

    HRESULT __stdcall WinHttpTimeToSystemTime(
                        VARIANT boHttpTime,
                        VARIANT SystemTime,
                        VARIANT *Success
                        );
        
    HRESULT __stdcall WinHttpCrackUrl(
                        VARIANT Url,
                        VARIANT UrlLength,
                        VARIANT Flags,
                        VARIANT UrlComponents,
                        VARIANT *Success
                        );
        
    HRESULT __stdcall WinHttpCreateUrl(
                        VARIANT UrlComponents,
                        VARIANT Flags,
                        VARIANT BufferObject,
                        VARIANT *Success
                        );

    HRESULT __stdcall WinHttpSetStatusCallback(
                        VARIANT InternetHandle,
                        VARIANT CallbackFunction,
                        VARIANT NotificationFlags,
                        VARIANT Reserved,
                        VARIANT *RetVal
                        );
        
    HRESULT __stdcall HelperGetBufferObject(
                        VARIANT Size,
                        VARIANT Type,
                        VARIANT Flags,
                        VARIANT *BufferObject
                        );
        
    HRESULT __stdcall HelperGetUrlComponents(
                        VARIANT Flags,
                        VARIANT *UrlComponents
                        );
        
    HRESULT __stdcall HelperGetSystemTime(
                        VARIANT Flags,
                        VARIANT *SystemTime
                        );
        
    HRESULT __stdcall HelperGetLastError(
                        VARIANT *Win32ErrorCode
                        );
    
    DECLAREIPROVIDECLASSINFO();

    public:
      WinHttpTest();
     ~WinHttpTest();

      static HRESULT Create(REFIID riid, void** ppv);

    private:
      HRESULT    _Initialize(void);
      HRESULT    _SetErrorCode(DWORD error);

      HRESULT    _WinHttpOpen(
                    LPCWSTR  pwszUserAgent,
                    DWORD    dwAccessType,
                    LPCWSTR  pwszProxyName,
                    LPCWSTR  pwszProxyBypass,
                    DWORD    dwFlags,
                    VARIANT* retval
                    );
      
      HRESULT    _WinHttpConnect(
                    HINTERNET     hSession,
                    LPCWSTR       pwszServerName,
                    INTERNET_PORT nServerPort,
                    DWORD         dwReserved,
                    VARIANT*      retval
                    );

      HRESULT    _WinHttpOpenRequest(
                    HINTERNET hConnect,
                    LPCWSTR   pwszVerb,
                    LPCWSTR   pwszObjectName,
                    LPCWSTR   pwszVersion,
                    LPCWSTR   pwszReferrer,
                    LPCWSTR*  ppwszAcceptTypes,
                    DWORD     dwFlags,
                    VARIANT*  retval
                    );

      HRESULT    _WinHttpSendRequest(
                    HINTERNET hRequest,
                    LPCWSTR   pwszHeaders,
                    DWORD     dwHeadersLength,
                    LPVOID    lpOptional,
                    DWORD     dwOptionalLength,
                    DWORD     dwTotalLength,
                    DWORD_PTR dwContext,
                    VARIANT*  retval
                    );

      HRESULT    _WinHttpCloseHandle(
                    HINTERNET hInternet,
                    VARIANT*  retval
                    );

      HRESULT    _WinHttpSetStatusCallback(
                    HINTERNET               hInternet,
                    WINHTTP_STATUS_CALLBACK lpfnCallback,
                    DWORD                   dwNotificationFlags,
                    DWORD_PTR               dwReserved,
                    VARIANT*                retval
                    );

    private:
      LONG                m_cRefs;
      ITypeInfo*          m_pti;
      IWHTWin32ErrorCode* m_pw32ec;
};


typedef class WHTUrlComponents  WHTURLCMP;
typedef class WHTUrlComponents* PWHTURLCMP;

class WHTUrlComponents : public IWHTUrlComponents,
                         public IProvideClassInfo
{
  public:
    DECLAREIUNKNOWN();
    DECLAREIDISPATCH();

    //
    // IWHTUrlComponents
    //
    HRESULT __stdcall get_StructSize(
                        VARIANT *Value
                        );
        
    HRESULT __stdcall put_StructSize(
                        VARIANT Value
                        );
        
    HRESULT __stdcall get_Scheme(
                        VARIANT *Value
                        );
        
    HRESULT __stdcall put_Scheme(
                        VARIANT Value
                        );
        
    HRESULT __stdcall get_SchemeLength(
                        VARIANT *Length
                        );
        
    HRESULT __stdcall put_SchemeLength(
                        VARIANT Length
                        );
        
    HRESULT __stdcall get_SchemeId(
                        VARIANT *Value
                        );
        
    HRESULT __stdcall put_SchemeId(
                        VARIANT Value
                        );
        
    HRESULT __stdcall get_HostName(
                        VARIANT *Value
                        );
        
    HRESULT __stdcall put_HostName(
                        VARIANT Value
                        );
        
    HRESULT __stdcall get_HostNameLength(
                        VARIANT *Length
                        );
        
    HRESULT __stdcall put_HostNameLength(
                        VARIANT Length
                        );
        
    HRESULT __stdcall get_Port(
                        VARIANT *Value
                        );
        
    HRESULT __stdcall put_Port(
                        VARIANT Value
                        );
        
    HRESULT __stdcall get_UserName(
                        VARIANT *Value
                        );
        
    HRESULT __stdcall put_UserName(
                        VARIANT Value
                        );
        
    HRESULT __stdcall get_UserNameLength(
                        VARIANT *Value
                        );
        
    HRESULT __stdcall put_UserNameLength(
                        VARIANT Value
                        );
        
    HRESULT __stdcall get_Password(
                        VARIANT *Value
                        );
        
    HRESULT __stdcall put_Password(
                        VARIANT Value
                        );
        
    HRESULT __stdcall get_PasswordLength(
                        VARIANT *Length
                        );
        
    HRESULT __stdcall put_PasswordLength(
                        VARIANT Length
                        );
        
    HRESULT __stdcall get_UrlPath(
                        VARIANT *Value
                        );
        
    HRESULT __stdcall put_UrlPath(
                        VARIANT Value
                        );
        
    HRESULT __stdcall get_UrlPathLength(
                        VARIANT *Length
                        );
        
    HRESULT __stdcall put_UrlPathLength(
                        VARIANT Length
                        );
        
    HRESULT __stdcall get_ExtraInfo(
                        VARIANT *Value
                        );
        
    HRESULT __stdcall put_ExtraInfo(
                        VARIANT Value
                        );
        
    HRESULT __stdcall get_ExtraInfoLength(
                        VARIANT *Length
                        );
        
    HRESULT __stdcall put_ExtraInfoLength(
                        VARIANT Length
                        );

    DECLAREIPROVIDECLASSINFO();

  public:
    WHTUrlComponents();
   ~WHTUrlComponents();

    static HRESULT Create(MEMSETFLAG mf, IWHTUrlComponents** ppwuc);

  private:
    HRESULT         _Initialize(MEMSETFLAG mf);
    LONG            m_cRefs;
    ITypeInfo*      m_pti;
    URL_COMPONENTSW m_uc;
};


typedef class WHTWin32ErrorCode  WHTERROR;
typedef class WHTWin32ErrorCode* PWHTERROR;

class WHTWin32ErrorCode : public IWHTWin32ErrorCode,
                          public IProvideClassInfo
{
  public:
    DECLAREIUNKNOWN();
    DECLAREIDISPATCH();

    HRESULT __stdcall get_ErrorCode(
                        VARIANT *ErrorCode
                        );

    HRESULT __stdcall get_ErrorString(
                        VARIANT *ErrorString
                        );

    HRESULT __stdcall get_IsException(
                        VARIANT *IsException
                        );

    DECLAREIPROVIDECLASSINFO();

  public:
    WHTWin32ErrorCode(DWORD error);
   ~WHTWin32ErrorCode();

    static HRESULT Create(DWORD error, IWHTWin32ErrorCode** ppwec);

  private:
    HRESULT    _Initialize(void);
    BOOL       _IsException(int e);
    LONG       m_cRefs;
    ITypeInfo* m_pti;
    DWORD      m_error;
    BOOL       m_bIsException;
};

#endif /* _COMMON_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\whttptst\inc\debug.h ===
#ifndef __DEBUG_H__
#define __DEBUG_H__

#include "common.h"

//
// always build this stuff.
//
#define CASE_OF(constant) case constant: return # constant
#define CASE_OF_MUTATE(val, name) case val: return # name
#define CASE_IID(riid, iid) if(IsEqualIID(riid, iid)) return # iid

LPSTR MapDispidToString(DISPID dispid);
LPSTR MapErrorToString(int error);
LPSTR MapHResultToString(HRESULT hr);
LPSTR MapIIDToString(REFIID riid);
LPSTR MapVariantTypeToString(VARIANT* pvar);
LPSTR MapPointerTypeToString(POINTER pointer);
LPSTR MapDataTypeToString(TYPE type);
LPSTR MapWinHttpAccessType(DWORD type);
LPSTR MapWinHttpIOMode(DWORD mode);
LPSTR MapWinHttpHandleType(HINTERNET hInternet);
LPSTR MapMemsetFlagToString(MEMSETFLAG mf);
LPSTR MapCallbackFlagToString(DWORD flag);

int DebugDataDumpFormat(LPSTR buffer, LPBYTE data, DWORD len);

#ifdef _DEBUG

//
// manifests
//

#if defined(__DBG_TO_CONSOLE__)
#define OUTPUT_FLAGS DBG_TO_DEBUGGER
#else
#define OUTPUT_FLAGS DBG_TO_FILE
#endif

#if defined(__FULL_DEBUG__)
#define DEBUG_DEFAULT_FLAGS ( \
                             DBG_DLL          \
                           | DBG_INITIALIZE   \
                           | DBG_WHTTPTST     \
                           | DBG_WHTERROR     \
                           | DBG_WHTURLCMP    \
                           | DBG_REGISTRY     \
                           | DBG_MEM          \
                           | DBG_REFCOUNT     \
                           | DBG_FACTORY      \
                           | DBG_UTILS        \
                           | DBG_DISPATCH     \
                           | DBG_HELPER       \
                           | DBG_THREAD_INFO  \
                           | DBG_CALL_INFO    \
                           | DBG_CALL_DEPTH   \
                           | DBG_TIMESTAMP    \
                           | DBG_NEST_CALLS   \
                           | OUTPUT_FLAGS)
#else
#define DEBUG_DEFAULT_FLAGS ( \
                             DBG_WHTTPTST     \
                           | DBG_TYPE         \
                           | DBG_HELPER       \
                           | DBG_WHTURLCMP    \
                           | DBG_THREAD_INFO  \
                           | DBG_CALL_INFO    \
                           | DBG_CALL_DEPTH   \
                           | DBG_TIMESTAMP    \
                           | DBG_NEST_CALLS   \
                           | OUTPUT_FLAGS)
#endif

// category flags
#define DBG_DLL           0x00000001
#define DBG_WHTTPTST      0x00000002
#define DBG_REGISTRY      0x00000004
#define DBG_MEM           0x00000008
#define DBG_REFCOUNT      0x00000010
#define DBG_FACTORY       0x00000020
#define DBG_UTILS         0x00000040
#define DBG_DISPATCH      0x00000080
#define DBG_HELPER        0x00000100
#define DBG_TYPE          0x00000200
#define DBG_WHTERROR      0x00000400
#define DBG_INITIALIZE    0x00000800
#define DBG_WHTURLCMP     0x00001000

// control flags
#define DBG_THROWDBGALERT 0x00800000
#define DBG_THREAD_INFO   0x01000000
#define DBG_CALL_DEPTH    0x02000000 // remove
#define DBG_TIMESTAMP     0x04000000
#define DBG_NEST_CALLS    0x08000000
#define DBG_TO_FILE       0x10000000
#define DBG_TO_DEBUGGER   0x20000000
#define DBG_CALL_INFO     0x40000000
#define DBG_NO_DEBUG      0x80000000

//
// types
//

typedef struct _memusage
{
  CRITICAL_SECTION lock;
  DWORD            total;
  MEMORYSTATUS     status;
}
MEMUSAGE, *PMEMUSAGE;

typedef enum _rettype
{
  rt_void,
  rt_bool,
  rt_dword,
  rt_hresult,
  rt_string
}
RETTYPE, *LPRETTYPE;

typedef struct _callinfo
{
  struct _callinfo* next;
  struct _callinfo* last;
  DWORD             category;
  LPCSTR            fname;
  RETTYPE           rettype;
}
CALLINFO, *LPCALLINFO;

typedef struct _threadinfo
{
  DWORD      threadid;
  DWORD      threadcat;
  DWORD      depth;
  LPCALLINFO stack;
}
THREADINFO, *LPTHREADINFO;

//
// prototypes
//

void DebugInitialize(void);
void DebugTerminate(void);

void DebugMemInitialize(void);
void DebugMemTerminate(void);
void DebugMemAlloc(void* pv);
void DebugMemFree(void* pv);

void DebugEnter(int category, RETTYPE rt, LPCSTR function, const char* format, ...);
void DebugLeave(int retval);
void DebugTrace(const char* format, ...);
void DebugAssert(LPSTR condition, LPSTR file, int line);

void DebugDataDump(LPSTR title, LPBYTE data, DWORD len);

void DebugThrowDbgAlert(void);

void AcquireDebugFileLock(void);
void ReleaseDebugFileLock(void);

LPTHREADINFO GetThreadInfo(void);

LPCALLINFO   SetCallInfo(LPTHREADINFO pti, DWORD category, RETTYPE rt, LPCSTR function);
LPCALLINFO   GetCallInfo(LPTHREADINFO pti);
void         DeleteCallInfo(LPCALLINFO pci);

LPSTR        FormatCallReturnString(LPCALLINFO pci, int retval);
LPSTR        MapCategoryToString(int category);
LPSTR        MapDllReasonToString(int reason);

void  _debugout(LPTHREADINFO pti, BOOL fRaw, BOOL fTrace, const char* format, ...);
char* _gettimestamp(void);
char* _getwhitespace(int spaces);
BOOL  _opendebugfile(void);
void  _closedebugfile(void);

//
// macros
//
#define DEBUG_INITIALIZE() DebugInitialize()
#define DEBUG_TERMINATE()  DebugTerminate()

#define DEBUG_ENTER(parameters) \
              DebugEnter parameters

#define DEBUG_LEAVE(retval) \
              DebugLeave(retval)

#define DEBUG_ALLOC(block) \
              DebugMemAlloc(block)

#define DEBUG_FREE(block) \
              DebugMemFree(block)

extern DWORD g_dwDebugFlags;

#define DEBUG_TRACE(category, parameters) \
              if( DBG_##category & g_dwDebugFlags ) \
                DebugTrace parameters

#define DEBUG_DATA_DUMP(category, parameters) \
              if(DBG_##category & g_dwDebugFlags ) \
                DebugDataDump parameters

#define DEBUG_ADDREF(objname, refcount) \
              if( DBG_REFCOUNT & g_dwDebugFlags ) \
                DebugTrace("%s [%#x] addref: %d", objname, this, refcount)

#define DEBUG_RELEASE(objname, refcount) \
              if( DBG_REFCOUNT & g_dwDebugFlags ) \
                DebugTrace("%s [%#x] release: %d", objname, this, refcount)

#define DEBUG_FINALRELEASE(objname) \
              if( DBG_REFCOUNT & g_dwDebugFlags ) \
                DebugTrace("%s [%#x] final release!", objname, this)

#define DEBUG_DUMPWSOCKSTATS(wsd) \
              if( DBG_APP & g_dwDebugFlags ) \
                DebugTrace(\
                  "%s (v%d.%d in use) is %s",\
                  wsd.szDescription,\
                  (wsd.wVersion & 0x00FF),\
                  ((wsd.wVersion & 0xFF00) >> 8),\
                  wsd.szSystemStatus)


#define DEBUG_ASSERT(condition) \
          if( !(condition) ) \
            DebugAssert(#condition, __FILE__, __LINE__)

#else

// we will get rebuked for the bogus 
// arglists in the debug macros
#pragma warning( disable : 4002 )
#pragma warning( disable : 4003 )

#define DEBUG_ASSERT(x, y, z)
#define DEBUG_INITIALIZE()
#define DEBUG_TERMINATE()
#define DEBUG_ALLOC(x)
#define DEBUG_FREE(x)
#define DEBUG_ENTER(x)
#define DEBUG_LEAVE(x)
#define DEBUG_TRACE(x)
#define DEBUG_ADDREF(x)
#define DEBUG_RELEASE(x)
#define DEBUG_FINALRELEASE(x)
#define DEBUG_DUMPWSOCKSTATS(x)
#define DEBUG_DATA_DUMP(X)

#endif /* _DEBUG */
#endif /* __DEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\whttptst\inc\resources.h ===
#ifndef __RESOURCES_H__
#define __RESOURCES_H__

#define ERROR_FAILURE            0xFFFFF666

#define DECLAREIUNKNOWN() \
    HRESULT __stdcall QueryInterface(REFIID riid, void** ppv); \
    ULONG   __stdcall AddRef(void); \
    ULONG   __stdcall Release(void); 

#define DECLAREICLASSFACTORY() \
    HRESULT __stdcall CreateInstance(IUnknown* outer, REFIID riid, void** ppv); \
    HRESULT __stdcall LockServer(BOOL lock);

#define DECLAREIDISPATCH() \
    HRESULT __stdcall GetTypeInfoCount(UINT* pctinfo);  \
    HRESULT __stdcall GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti); \
    HRESULT __stdcall GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId); \
    HRESULT __stdcall Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae);

#define DECLAREIPROVIDECLASSINFO() \
  HRESULT __stdcall GetClassInfo(ITypeInfo** ppti);

#define DECLAREIOBJECTWITHSITE() \
    HRESULT __stdcall SetSite(IUnknown* pUnkSite); \
    HRESULT __stdcall GetSite(REFIID riid, void** ppvSite);

#define SAFECLOSE(x) if((x!=INVALID_HANDLE_VALUE) && (x!=NULL)) { CloseHandle(x); x=NULL; }
#define SAFEDELETE(x) if(x) { delete x; x=NULL; }
#define SAFEDELETEBUF(x) if(DWORD(x)) {delete [] x; x=NULL;}
#define SAFERELEASE(x) if(x) { x->Release(); x=NULL; }
#define SAFEDELETEBSTR(x) if(x) { SysFreeString(x); x=NULL; }
#define VALIDDISPID(x) ((x!=DISPID_UNKNOWN) ? TRUE : FALSE)
#define NEWVARIANT(x) VARIANT x; VariantInit(&x);

#define TF(x) (x?"TRUE":"FALSE")
#define VTF(x) (V_BOOL(x)?"TRUE":"FALSE")

typedef CRITICAL_SECTION             CRITSEC;
typedef LPCRITICAL_SECTION           PCRITSEC;
typedef BY_HANDLE_FILE_INFORMATION   BHFI;
typedef LPBY_HANDLE_FILE_INFORMATION LPBHFI;

typedef struct _dispidtableentry
{
  DWORD  hash;
  DISPID dispid;
  LPWSTR name;
}
DISPIDTABLEENTRY, *PDISPIDTABLEENTRY;

typedef enum _tagType
{
  TYPE_LPWSTR=0,
  TYPE_LPLPWSTR,
  TYPE_LPSTR,
  TYPE_LPLPSTR,
  TYPE_DWORD,
  TYPE_LPDWORD
}
TYPE, *PTYPE;

typedef enum _tagPointer
{
  NULL_PTR=0,
  BAD_PTR,
  FREE_PTR,
  UNINIT_PTR,
  NEGONE_PTR
}
POINTER, *PPOINTER;

typedef enum _tagMemsetFlag
{
  INIT_NULL=0,
  INIT_SMILEY,
  INIT_HEXFF,
  INIT_GARBAGE
}
MEMSETFLAG, *PMEMSETFLAG;

#endif /* __RESOURCES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\whttptst\inc\hashtable.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    hashtable.cxx

Abstract:

    Simple hash table implementation.


Author:

    Paul M Midgen (pmidge) 14-August-2000


Revision History:

    14-August-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include <common.h>

/*++===========================================================================

    An array is separated into N buckets that     +---+
    each contain a pointer to a binary search     | 0 |------> O
    tree. The tree's nodes are indexed by a       +---+       / \
    DWORD identifier to enable speedy traversals. | 1 |      O   O
    The array buckets are indexed by the values   +---+     / \   \
    generated by the hashing function supplied    | 2 |    O   O   O
    by a derived class.                           +---+        
                                                  | N |

    Clients derive a class from the hashtable ADT and specialize it for a 
    given data type. Any data type can be used. The only function the client
    must implement is the GetHashAndBucket function, and their class must
    provide the number of buckets the ADT needs to support. This is usually
    some number that is modulo'd against the generated hashes to yield the
    bucket number.

===========================================================================--*/

#define HT_COMPARE_LARGER  0x00000001
#define HT_COMPARE_SMALLER 0x00000002
#define HT_COMPARE_EQUAL   0x00000003

#define HT_TREE_ROOT       0x00000004
#define HT_TREE_RHSUBTREE  0x00000005
#define HT_TREE_LHSUBTREE  0x00000006

typedef struct _NODE
{
  DWORD  hash;
  DWORD  bucket;
  LPVOID data;
  _NODE* parent;
  _NODE* rh_child;
  _NODE* lh_child;
  BOOL   isLeft;
}
NODE, *PNODE;

typedef VOID (*PFNCLEARFUNC)(LPVOID* ppv);

template <class T> class CHashTable
{
  public:
    CHashTable(DWORD buckets)
    {
      pfnClear  = NULL;
      cBuckets  = buckets;
      arBuckets = new PNODE[buckets];
      InitializeCriticalSection(&csTable);
    }

   ~CHashTable()
    {
      SAFEDELETEBUF(arBuckets);
      DeleteCriticalSection(&csTable);
    }

    virtual void GetHashAndBucket(T id, LPDWORD lpHash, LPDWORD lpBucket) =0;

    DWORD Insert(T id, LPVOID pv);
    DWORD Get(T id, LPVOID* ppv);
    DWORD Delete(T id, LPVOID* ppv);

    void  Clear(void);
    void  SetClearFunction(PFNCLEARFUNC pfn) { pfnClear = pfn; }

  private:
    void  _Get(DWORD hash, PNODE& proot, PNODE& pnode);
    DWORD _Insert(PNODE& proot, PNODE pnew);
    void  _Remove(DWORD hash, PNODE& proot, PNODE& pnode);

    PNODE _NewNode(T id, LPVOID pv);
    DWORD _CompareNodes(DWORD hash_target, DWORD hash_tree);

    BOOL  _HasChildren(PNODE pnode);
    void  _PostTraverseAndDelete(PNODE proot);
    void  _Lock(void)   { EnterCriticalSection(&csTable); }
    void  _Unlock(void) { LeaveCriticalSection(&csTable); }

    PNODE*       arBuckets;
    DWORD        cBuckets;
    CRITSEC      csTable;
    PFNCLEARFUNC pfnClear;
};

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

template <class T> DWORD CHashTable<T>::Insert(T id, LPVOID pv)
{
  DWORD ret = ERROR_SUCCESS;
  PNODE pn  = _NewNode(id, pv);

  _Lock();

    if( pn )
    {
      ret = _Insert(arBuckets[pn->bucket], pn);
    }
    else
    {
      ret = ERROR_OUTOFMEMORY;
    }

  _Unlock();

  return ret;
}

template <class T> DWORD CHashTable<T>::Get(T id, LPVOID* ppv)
{
  DWORD ret    = ERROR_SUCCESS;
  DWORD hash   = 0L;
  DWORD bucket = 0L;
  PNODE pnode  = NULL;

  GetHashAndBucket(id, &hash, &bucket);

  _Lock();

    _Get(hash, arBuckets[bucket], pnode);

    if( pnode )
    {
      *ppv = (void*) pnode->data;
    }
    else
    {
      *ppv = NULL;
      ret  = ERROR_NOT_FOUND;
    }

  _Unlock();

  return ret;
}

template <class T> DWORD CHashTable<T>::Delete(T id, LPVOID* ppv)
{
  DWORD ret   = ERROR_SUCCESS;
  DWORD hash   = 0L;
  DWORD bucket = 0L;
  PNODE pnode = NULL;

  GetHashAndBucket(id, &hash, &bucket);

  _Lock();

    _Remove(hash, arBuckets[bucket], pnode);

    if( pnode )
    {
      if( ppv )
      {
        *ppv = pnode->data;
      }
      else
      {
        if( pfnClear )
        {
          pfnClear(&pnode->data);
        }
      }

      delete pnode;
    }
    else
    {
      ret = ERROR_NOT_FOUND;

      if( ppv )
      {
        *ppv = NULL;
      }
    }

  _Unlock();

  return ret;
}

template <class T> void CHashTable<T>::Clear(void)
{
  _Lock();

    for(DWORD n=0; n < cBuckets; n++)
    {
      if( arBuckets[n] )
      {
        _PostTraverseAndDelete(arBuckets[n]);
        arBuckets[n] = NULL;
      }
    }

  _Unlock();
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

template <class T> DWORD CHashTable<T>::_Insert(PNODE& proot, PNODE pnew)
{
  DWORD ret = ERROR_SUCCESS;

  if( pnew )
  {
    if( !proot )
    {
      proot = pnew;
    }
    else
    {
      switch( _CompareNodes(pnew->hash, proot->hash) )
      {
        case HT_COMPARE_SMALLER :
          {
            pnew->isLeft = TRUE;
            pnew->parent = proot;
            ret = _Insert(proot->lh_child, pnew);
          }
          break;

        case HT_COMPARE_LARGER :
          {
            pnew->isLeft = FALSE;
            pnew->parent = proot;
            ret = _Insert(proot->rh_child, pnew);
          }
          break;

        case HT_COMPARE_EQUAL :
          {
            if( pfnClear )
            {
              pfnClear(&proot->data);
            }

            ret         = ERROR_DUP_NAME;
            proot->data = pnew->data;
            delete pnew;
          }
          break;
      }
    }
  }

  return ret;
}

template <class T> void CHashTable<T>::_Get(DWORD hash, PNODE& proot, PNODE& pnode)
{
  if( proot )
  {
    switch( _CompareNodes(hash, proot->hash) )
    {
      case HT_COMPARE_SMALLER :
        {
          _Get(hash, proot->lh_child, pnode);
        }
        break;

      case HT_COMPARE_LARGER :
        {
          _Get(hash, proot->rh_child, pnode);
        }
        break;

      case HT_COMPARE_EQUAL :
        {
          pnode = proot;
        }
        break;
    }
  }
  else
  {
    pnode = NULL;
  }
}

template <class T> void CHashTable<T>::_Remove(DWORD hash, PNODE& proot, PNODE& pnode)
{
  if( proot )
  {
    switch( _CompareNodes(hash, proot->hash) )
    {
      case HT_COMPARE_SMALLER :
        {
          _Remove(hash, proot->lh_child, pnode);
        }
        break;

      case HT_COMPARE_LARGER :
        {
          _Remove(hash, proot->rh_child, pnode);
        }
        break;

      case HT_COMPARE_EQUAL :
        {
          pnode = proot;

          //
          // if proot has no parent it is the tree's root node
          //
          //   - if it has children, promote the left child to root
          //     and insert the right child in the new tree. after
          //     inserting, make sure the new root has no parent.
          //
          //   - if it has no children the tree is empty, set the root
          //     to null
          //

          if( !proot->parent )
          {
            if( _HasChildren(proot) )
            {
              proot = proot->lh_child;
              _Insert(proot, pnode->rh_child);
              proot->parent = NULL;
            }
            else
            {
              proot = NULL;
            }
          }
          else
          {
            if( proot->isLeft )
            {
              proot->parent->lh_child = NULL;
            }
            else
            {
              proot->parent->rh_child = NULL;
            }

            _Insert(pnode->parent, pnode->lh_child);
            _Insert(pnode->parent, pnode->rh_child);
          }
        }
        break;
    }
  }
  else
  {
    pnode = NULL;
  }
}

template <class T> void CHashTable<T>::_PostTraverseAndDelete(PNODE proot)
{
  if( proot )
  {
    _PostTraverseAndDelete(proot->lh_child);
    _PostTraverseAndDelete(proot->rh_child);

    if( pfnClear )
    {
      pfnClear(&proot->data);
    }

    delete proot;
    proot = NULL;
  }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

template <class T> DWORD CHashTable<T>::_CompareNodes(DWORD hash_target, DWORD hash_tree)
{
  if( hash_target == hash_tree )
  {
    return HT_COMPARE_EQUAL;
  }
  else if( hash_target < hash_tree )
  {
    return HT_COMPARE_SMALLER;
  }
  else
  {
    return HT_COMPARE_LARGER;
  }
}

template <class T> PNODE CHashTable<T>::_NewNode(T id, LPVOID pv)
{
  PNODE pn = new NODE;

  if( pn )
  {
    GetHashAndBucket(id, &pn->hash, &pn->bucket);
    pn->data = pv;
  }

  return pn;
}

template <class T> BOOL CHashTable<T>::_HasChildren(PNODE pnode)
{
  if( pnode )
  {
    return (pnode->lh_child || pnode->rh_child);
  }
  else
  {
    return FALSE;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\whttptst\inc\utils.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 1999  Microsoft Corporation

Module Name:

    utils.h

Abstract:

    Utility functions.
    
Author:

    Paul M Midgen (pmidge) 12-January-2001


Revision History:

    12-January-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef _UTILS_H_
#define _UTILS_H_

#define CALLBACK_HANDLE_MAP   0x00
#define CALLBACK_HANDLE_UNMAP 0x01
#define CALLBACK_HANDLE_GET   0x02

// exception handling
int exception_filter(PEXCEPTION_POINTERS pep);

// file retrieval
HANDLE  __OpenFile(LPCWSTR path, DWORD mode, BOOL* bReadOnly);

// general utility
HRESULT ManageCallbackForHandle(HINTERNET hInet, IDispatch** ppCallback, DWORD dwAction);
HRESULT GetTypeInfoFromName(LPCOLESTR name, ITypeLib* ptl, ITypeInfo** ppti);
DISPID  GetDispidFromName(PDISPIDTABLEENTRY pdt, DWORD cEntries, LPWSTR name);
HRESULT HandleDispatchError(LPWSTR id, EXCEPINFO* pei, HRESULT hr);
void    AddRichErrorInfo(EXCEPINFO* pei, LPWSTR source, LPWSTR description, HRESULT error);
DWORD   GetHash(LPWSTR name);
DWORD   GetHash(LPSTR name);
HRESULT ValidateDispatchArgs(REFIID riid, DISPPARAMS* pdp, VARIANT* pvr, UINT* pae);
HRESULT ValidateInvokeFlags(WORD flags, WORD accesstype, BOOL bNotMethod);
HRESULT ValidateArgCount(DISPPARAMS* pdp, DWORD needed, BOOL bHasOptionalArgs, DWORD optional);

// type manipulation
HRESULT   ProcessWideStringParam(LPWSTR name, VARIANT* pvar, LPWSTR* ppwsz);
HRESULT   ProcessWideMultiStringParam(LPWSTR name, VARIANT* pvar, LPWSTR** pppwsz);
HRESULT   ProcessBufferParam(LPWSTR name, VARIANT* pvar, LPVOID* ppv, LPBOOL pbDidAlloc);
HRESULT   InvalidatePointer(POINTER pointer, void** ppv);
DWORD_PTR GetBadPointer(void);
DWORD_PTR GetFreedPointer(void);
void      MemsetByFlag(LPVOID pv, DWORD size, MEMSETFLAG mf);

// string handling
char*  __strndup(const char* src, int len);
char*  __strdup(const char* src);
WCHAR* __wstrndup(const WCHAR* src, int len);
WCHAR* __wstrdup(const WCHAR* src);
CHAR*  __widetoansi(const WCHAR* pwsz);
WCHAR* __ansitowide(const char* psz);
BOOL   __isempty(VARIANT var);
BSTR   __ansitobstr(LPCSTR src);
BSTR   __widetobstr(LPCWSTR wsrc);
char*  __unescape(char* str);

#endif /* _UTILS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\whttptst\inc\dispids.h ===
#ifndef __DISPIDS_H__
#define __DISPIDS_H__

#define DISPID_WINHTTPTEST_BASE                    0x00000100
#define DISPID_WINHTTPTEST_HELPER_BASE             0x00000200
#define DISPID_WIN32ERRORCODE_BASE                 0x00000300
#define DISPID_BUFFEROBJECT_BASE                   0x00000400
#define DISPID_URLCOMPONENTS_BASE                  0x00000500
#define DISPID_SYSTEMTIME_BASE                     0x00000600

#define DISPID_WINHTTPTEST_OPEN                    (DISPID_WINHTTPTEST_BASE)
#define DISPID_WINHTTPTEST_CONNECT                 (DISPID_WINHTTPTEST_BASE + 1)
#define DISPID_WINHTTPTEST_OPENREQUEST             (DISPID_WINHTTPTEST_BASE + 2)
#define DISPID_WINHTTPTEST_SENDREQUEST             (DISPID_WINHTTPTEST_BASE + 3)
#define DISPID_WINHTTPTEST_RECEIVERESPONSE         (DISPID_WINHTTPTEST_BASE + 4)
#define DISPID_WINHTTPTEST_CLOSEHANDLE             (DISPID_WINHTTPTEST_BASE + 5)
#define DISPID_WINHTTPTEST_READDATA                (DISPID_WINHTTPTEST_BASE + 6)
#define DISPID_WINHTTPTEST_WRITEDATA               (DISPID_WINHTTPTEST_BASE + 7)
#define DISPID_WINHTTPTEST_QUERYDATAAVAILABLE      (DISPID_WINHTTPTEST_BASE + 8)
#define DISPID_WINHTTPTEST_QUERYOPTION             (DISPID_WINHTTPTEST_BASE + 9)
#define DISPID_WINHTTPTEST_SETOPTION               (DISPID_WINHTTPTEST_BASE + 10)
#define DISPID_WINHTTPTEST_SETTIMEOUTS             (DISPID_WINHTTPTEST_BASE + 11)
#define DISPID_WINHTTPTEST_ADDREQUESTHEADERS       (DISPID_WINHTTPTEST_BASE + 12)
#define DISPID_WINHTTPTEST_SETCREDENTIALS          (DISPID_WINHTTPTEST_BASE + 13)
#define DISPID_WINHTTPTEST_QUERYAUTHSCHEMES        (DISPID_WINHTTPTEST_BASE + 14)
#define DISPID_WINHTTPTEST_QUERYHEADERS            (DISPID_WINHTTPTEST_BASE + 15)
#define DISPID_WINHTTPTEST_TIMEFROMSYSTEMTIME      (DISPID_WINHTTPTEST_BASE + 16)
#define DISPID_WINHTTPTEST_TIMETOSYSTEMTIME        (DISPID_WINHTTPTEST_BASE + 17)
#define DISPID_WINHTTPTEST_CRACKURL                (DISPID_WINHTTPTEST_BASE + 18)
#define DISPID_WINHTTPTEST_CREATEURL               (DISPID_WINHTTPTEST_BASE + 19)
#define DISPID_WINHTTPTEST_SETSTATUSCALLBACK       (DISPID_WINHTTPTEST_BASE + 20)

#define DISPID_WINHTTPTEST_HELPER_GETBUFFEROBJECT  (DISPID_WINHTTPTEST_HELPER_BASE)
#define DISPID_WINHTTPTEST_HELPER_GETURLCOMPONENTS (DISPID_WINHTTPTEST_HELPER_BASE + 1)
#define DISPID_WINHTTPTEST_HELPER_GETSYSTEMTIME    (DISPID_WINHTTPTEST_HELPER_BASE + 2)
#define DISPID_WINHTTPTEST_HELPER_GETLASTERROR     (DISPID_WINHTTPTEST_HELPER_BASE + 3)

#define DISPID_WIN32ERRORCODE_ERRORCODE            (DISPID_WIN32ERRORCODE_BASE + 1)
#define DISPID_WIN32ERRORCODE_ERRORSTRING          (DISPID_WIN32ERRORCODE_BASE + 2)
#define DISPID_WIN32ERRORCODE_ISEXCEPTION          (DISPID_WIN32ERRORCODE_BASE + 3)

#define DISPID_BUFFEROBJECT_SIZE                   (DISPID_BUFFEROBJECT_BASE)
#define DISPID_BUFFEROBJECT_TYPE                   (DISPID_BUFFEROBJECT_BASE + 1)
#define DISPID_BUFFEROBJECT_BYTESTRANSFERRED       (DISPID_BUFFEROBJECT_BASE + 2)
#define DISPID_BUFFEROBJECT_FLAGS                  (DISPID_BUFFEROBJECT_BASE + 3)

#define DISPID_URLCOMPONENTS_STRUCTSIZE            (DISPID_URLCOMPONENTS_BASE)
#define DISPID_URLCOMPONENTS_SCHEME                (DISPID_URLCOMPONENTS_BASE + 1)
#define DISPID_URLCOMPONENTS_SCHEMELENGTH          (DISPID_URLCOMPONENTS_BASE + 2)
#define DISPID_URLCOMPONENTS_SCHEMEID              (DISPID_URLCOMPONENTS_BASE + 3)
#define DISPID_URLCOMPONENTS_HOSTNAME              (DISPID_URLCOMPONENTS_BASE + 4)
#define DISPID_URLCOMPONENTS_HOSTNAMELENGTH        (DISPID_URLCOMPONENTS_BASE + 5)
#define DISPID_URLCOMPONENTS_PORT                  (DISPID_URLCOMPONENTS_BASE + 6)
#define DISPID_URLCOMPONENTS_USERNAME              (DISPID_URLCOMPONENTS_BASE + 7)
#define DISPID_URLCOMPONENTS_USERNAMELENGTH        (DISPID_URLCOMPONENTS_BASE + 8)
#define DISPID_URLCOMPONENTS_PASSWORD              (DISPID_URLCOMPONENTS_BASE + 9)
#define DISPID_URLCOMPONENTS_PASSWORDLENGTH        (DISPID_URLCOMPONENTS_BASE + 10)
#define DISPID_URLCOMPONENTS_URLPATH               (DISPID_URLCOMPONENTS_BASE + 11)
#define DISPID_URLCOMPONENTS_URLPATHLENGTH         (DISPID_URLCOMPONENTS_BASE + 12)
#define DISPID_URLCOMPONENTS_EXTRAINFO             (DISPID_URLCOMPONENTS_BASE + 13)
#define DISPID_URLCOMPONENTS_EXTRAINFOLENGTH       (DISPID_URLCOMPONENTS_BASE + 14)

#define DISPID_SYSTEMTIME_YEAR                     (DISPID_SYSTEMTIME_BASE)
#define DISPID_SYSTEMTIME_MONTH                    (DISPID_SYSTEMTIME_BASE + 1)
#define DISPID_SYSTEMTIME_DAYOFWEEK                (DISPID_SYSTEMTIME_BASE + 2)
#define DISPID_SYSTEMTIME_DAY                      (DISPID_SYSTEMTIME_BASE + 3)
#define DISPID_SYSTEMTIME_HOUR                     (DISPID_SYSTEMTIME_BASE + 4)
#define DISPID_SYSTEMTIME_MINUTE                   (DISPID_SYSTEMTIME_BASE + 5)
#define DISPID_SYSTEMTIME_SECOND                   (DISPID_SYSTEMTIME_BASE + 6)
#define DISPID_SYSTEMTIME_MSEC                     (DISPID_SYSTEMTIME_BASE + 7)

#endif /* __DISPIDS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\whttptst\src\urlcmp\methods.cxx ===
#include "common.h"

//-----------------------------------------------------------------------------
// IWHTUrlComponents methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
WHTUrlComponents::get_StructSize(VARIANT *Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}

        
HRESULT
__stdcall
WHTUrlComponents::put_StructSize(VARIANT Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::get_Scheme(VARIANT *Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}
        

HRESULT
__stdcall
WHTUrlComponents::put_Scheme(VARIANT Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::get_SchemeLength(VARIANT *Length)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}

 
HRESULT
__stdcall
WHTUrlComponents::put_SchemeLength(VARIANT Length)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::get_SchemeId(VARIANT *Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::put_SchemeId(VARIANT Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}

        
HRESULT
__stdcall
WHTUrlComponents::get_HostName(VARIANT *Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::put_HostName(VARIANT Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::get_HostNameLength(VARIANT *Length)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::put_HostNameLength(VARIANT Length)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::get_Port(VARIANT *Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}

        
HRESULT
__stdcall
WHTUrlComponents::put_Port(VARIANT Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::get_UserName(VARIANT *Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::put_UserName(VARIANT Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::get_UserNameLength(VARIANT *Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::put_UserNameLength(VARIANT Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::get_Password(VARIANT *Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::put_Password(VARIANT Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::get_PasswordLength(VARIANT *Length)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::put_PasswordLength(VARIANT Length)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::get_UrlPath(VARIANT *Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::put_UrlPath(VARIANT Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::get_UrlPathLength(VARIANT *Length)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::put_UrlPathLength(VARIANT Length)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::get_ExtraInfo(VARIANT *Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::put_ExtraInfo(VARIANT Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::get_ExtraInfoLength(VARIANT *Length)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::put_ExtraInfoLength(VARIANT Length)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\whttptst\src\urlcmp\dispatch.cxx ===
#include "common.h"


//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
DISPIDTABLEENTRY g_WHTUrlComponentsDisptable[] =
{
  0x0023e96f,   DISPID_URLCOMPONENTS_STRUCTSIZE,       L"structsize",
  0x00021d6b,   DISPID_URLCOMPONENTS_SCHEME,           L"scheme",
  0x00875a9b,   DISPID_URLCOMPONENTS_SCHEMELENGTH,     L"schemelength",
  0x000879f7,   DISPID_URLCOMPONENTS_SCHEMEID,         L"schemeid",
  0x000876d5,   DISPID_URLCOMPONENTS_HOSTNAME,         L"hostname",
  0x021c16c1,   DISPID_URLCOMPONENTS_HOSTNAMELENGTH,   L"hostnamelength",
  0x000087f5,   DISPID_URLCOMPONENTS_PORT,             L"port",
  0x0008e77b,   DISPID_URLCOMPONENTS_USERNAME,         L"username",
  0x023836ed,   DISPID_URLCOMPONENTS_USERNAMELENGTH,   L"usernamelength",
  0x00088a79,   DISPID_URLCOMPONENTS_PASSWORD,         L"password",
  0x0220f469,   DISPID_URLCOMPONENTS_PASSWORDLENGTH,   L"passwordlength",
  0x000477be,   DISPID_URLCOMPONENTS_URLPATH,          L"urlpath",
  0x011d165c,   DISPID_URLCOMPONENTS_URLPATHLENGTH,    L"urlpathlength",
  0x0010fe0f,   DISPID_URLCOMPONENTS_EXTRAINFO,        L"extrainfo",
  0x043cf541,   DISPID_URLCOMPONENTS_EXTRAINFOLENGTH,  L"extrainfolength"
};

DWORD g_cWHTUrlComponentsDisptable = (sizeof(g_WHTUrlComponentsDisptable) / sizeof(DISPIDTABLEENTRY));


//-----------------------------------------------------------------------------
// IDispatch
//-----------------------------------------------------------------------------
HRESULT
__stdcall
WHTUrlComponents::GetTypeInfoCount(UINT* pctinfo)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "WHTUrlComponents::GetTypeInfoCount",
    "this=%#x; pctinfo=%#x",
    this,
    pctinfo
    ));

  HRESULT hr = S_OK;

    if( !pctinfo )
    {
      hr = E_POINTER;
    }
    else
    {
      *pctinfo = 1;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "WHTUrlComponents::GetTypeInfo",
    "this=%#x; index=%#x; lcid=%#x; ppti=%#x",
    this,
    index,
    lcid,
    ppti
    ));

  HRESULT hr   = S_OK;

  if( !ppti )
  {
    hr = E_POINTER;
  }
  else
  {
    if( index != 0 )
    {
      hr    = DISP_E_BADINDEX;
      *ppti = NULL;
    }
    else
    {
      hr = GetClassInfo(ppti);
    }
  }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "WHTUrlComponents::GetIDsOfNames",
    "this=%#x; riid=%s; arNames=%#x; cNames=%d; lcid=%#x; arDispId=%#x",
    this,
    MapIIDToString(riid),
    arNames,
    cNames,
    lcid,
    arDispId
    ));

  HRESULT hr = S_OK;
  UINT    n  = 0L;

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  while( n < cNames )
  {
    arDispId[n] = GetDispidFromName(g_WHTUrlComponentsDisptable, g_cWHTUrlComponentsDisptable, arNames[n]);
    ++n;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "WHTUrlComponents::Invoke",
    "this=%#x; dispid=%s; riid=%s; lcid=%#x; flags=%#x; pdp=%#x; pvr=%#x; pei=%#x; pae=%#x",
    this,
    MapDispidToString(dispid),
    MapIIDToString(riid),
    lcid,
    flags,
    pdp, pvr,
    pei, pae
    ));

  HRESULT hr = S_OK;

  hr = ValidateDispatchArgs(riid, pdp, pvr, pae);

    if( FAILED(hr) )
      goto quit;

  switch( dispid )
  {
    case DISPID_VALUE :
    default : hr = DISP_E_MEMBERNOTFOUND;
  }

quit:

  if( FAILED(hr) )
  {
    hr = HandleDispatchError(L"WHTUrlComponents", pei, hr);
  }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\whttptst\src\urlcmp\urlcmp.cxx ===
#include "common.h"

extern HINSTANCE g_hGlobalDllInstance;
LPCWSTR          g_wszWHTUrlComponentsObjectName = L"WHTUrlComponents";

//-----------------------------------------------------------------------------
// WHTUrlComponents methods
//-----------------------------------------------------------------------------
WHTUrlComponents::WHTUrlComponents():
  m_cRefs(0),
  m_pti(NULL)
{
  DEBUG_TRACE(WHTERROR, ("WHTUrlComponents [%#x] created", this));
}


WHTUrlComponents::~WHTUrlComponents()
{
  SAFERELEASE(m_pti);
  DEBUG_TRACE(WHTERROR, ("WHTUrlComponents [%#x] deleted", this));
}


HRESULT
WHTUrlComponents::Create(MEMSETFLAG mf, IWHTUrlComponents** ppwuc)
{
  DEBUG_ENTER((
    DBG_INITIALIZE,
    rt_hresult,
    "WHTUrlComponents::Create",
    "mf=%s; ppwuc=%#x",
    MapMemsetFlagToString(mf),
    ppwuc
    ));

  HRESULT    hr     = S_OK;
  PWHTURLCMP pwhtuc = NULL;

  if( ppwuc )
  {
    pwhtuc = new WHTURLCMP;

    if( pwhtuc )
    {
      hr = pwhtuc->_Initialize(mf);

      if( SUCCEEDED(hr) )
      {
        hr = pwhtuc->QueryInterface(IID_IWHTUrlComponents, (void**) ppwuc);
      }
    }
    else
    {
      hr = E_OUTOFMEMORY;
    }
  }
  else
  {
    hr = E_POINTER;
  }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
WHTUrlComponents::_Initialize(MEMSETFLAG mf)
{
  DEBUG_ENTER((
    DBG_INITIALIZE,
    rt_hresult,
    "WHTUrlComponents::_Initialize",
    "this=%#x; mf=%s",
    this,
    MapMemsetFlagToString(mf)
    ));

  HRESULT   hr  = S_OK;
  WCHAR*    buf = NULL;
  ITypeLib* ptl = NULL;

  buf = new WCHAR[MAX_PATH];

    if( buf )
    {
      if( GetModuleFileName(g_hGlobalDllInstance, buf, MAX_PATH) )
      {
        hr = LoadTypeLib(buf, &ptl);

        if( SUCCEEDED(hr) )
        {
          hr = GetTypeInfoFromName(g_wszWHTUrlComponentsObjectName, ptl, &m_pti);

          if( SUCCEEDED(hr) )
          {
            MemsetByFlag(
              (void*) &m_uc,
              sizeof(URL_COMPONENTSW),
              mf
              );
            
            m_uc.dwStructSize = sizeof(URL_COMPONENTSW);
          }
        }
      }
      else
      {
        hr = E_FAIL;
      }
    }
    else
    {
      hr = E_OUTOFMEMORY;
    }

  SAFERELEASE(ptl);
  SAFEDELETEBUF(buf);

  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// IUnknown methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
WHTUrlComponents::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_REFCOUNT,
    rt_hresult,
    "WHTUrlComponents::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

    if( ppv )
    {
      if(
        IsEqualIID(riid, IID_IUnknown)           ||
        IsEqualIID(riid, IID_IDispatch)          ||
        IsEqualIID(riid, IID_IWHTUrlComponents)
        )
      {
        *ppv = static_cast<IWHTUrlComponents*>(this);
      }
      else if( IsEqualIID(riid, IID_IProvideClassInfo) )
      {
        *ppv = static_cast<IProvideClassInfo*>(this);
      }
      else
      {
        *ppv = NULL;
        hr   = E_NOINTERFACE;
      }
    }
    else
    {
      hr = E_POINTER;
    }

    if( SUCCEEDED(hr) )
    {
      DEBUG_TRACE(REFCOUNT, ("returning %s pointer", MapIIDToString(riid)));
      reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    }

  DEBUG_LEAVE(hr);
  return hr;
}


ULONG
__stdcall
WHTUrlComponents::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("WHTUrlComponents", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
WHTUrlComponents::Release(void)
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("WHTUrlComponents", m_cRefs);

  if( m_cRefs == 0 )
  {
    DEBUG_FINALRELEASE("WHTUrlComponents");
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IProvideClassInfo methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
WHTUrlComponents::GetClassInfo(ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_WHTERROR,
    rt_hresult,
    "WHTUrlComponents::GetClassInfo",
    "this=%#x; ppti=%#x",
    this,
    ppti
    ));

  HRESULT hr = S_OK;

    if( ppti )
    {
      m_pti->AddRef();
      *ppti = m_pti;
    }
    else
    {
      hr = E_POINTER;
    }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\whttptst\script\whttptst_include.h ===
var EXCEPTION_ACCESS_VIOLATION    = 0xc0000005;
var EXCEPTION_STACK_OVERFLOW      = 0xc00000fd;
var EXCEPTION_INT_DIVIDE_BY_ZERO  = 0xc0000094;
var EXCEPTION_ILLEGAL_INSTRUCTION = 0xc000001d;

// from resources.h
var TYPE_LPWSTR   = 0;
var TYPE_LPLPWSTR = 1;
var TYPE_LPSTR    = 2;
var TYPE_LPLPSTR  = 3;
var TYPE_DWORD    = 4;
var TYPE_LPDWORD  = 5;

// pointer value flags
var NULL_PTR      = 0;
var BAD_PTR       = 1; 
var FREE_PTR      = 2;
var UNINIT_PTR    = 3;

// data init flags
var INIT_NULL     = 0;
var INIT_SMILEY   = 1;
var INIT_HEXFF    = 2;
var INIT_GARBAGE  = 3;

// from winhttp.h
var WINHTTP_ACCESS_TYPE_DEFAULT_PROXY = 0;
var WINHTTP_ACCESS_TYPE_NO_PROXY      = 1;
var WINHTTP_ACCESS_TYPE_NAMED_PROXY   = 3;
var WINHTTP_FLAG_SYNC                 = 0x00000000; // not in header
var WINHTTP_FLAG_ASYNC                = 0x10000000;

var WINHTTP_CALLBACK_STATUS_RESOLVING_NAME          = 0x00000001;
var WINHTTP_CALLBACK_STATUS_NAME_RESOLVED           = 0x00000002;
var WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER    = 0x00000004;
var WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER     = 0x00000008;
var WINHTTP_CALLBACK_STATUS_SENDING_REQUEST         = 0x00000010;
var WINHTTP_CALLBACK_STATUS_REQUEST_SENT            = 0x00000020;
var WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE      = 0x00000040;
var WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED       = 0x00000080;
var WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION      = 0x00000100;
var WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED       = 0x00000200;
var WINHTTP_CALLBACK_STATUS_HANDLE_CREATED          = 0x00000400;
var WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING          = 0x00000800;
var WINHTTP_CALLBACK_STATUS_DETECTING_PROXY         = 0x00001000;
var WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE        = 0x00002000;
var WINHTTP_CALLBACK_STATUS_REDIRECT                = 0x00004000;
var WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE   = 0x00008000;
var WINHTTP_CALLBACK_STATUS_SECURE_FAILURE          = 0x00010000;

var WINHTTP_CALLBACK_FLAG_RESOLVE_NAME              = (WINHTTP_CALLBACK_STATUS_RESOLVING_NAME | WINHTTP_CALLBACK_STATUS_NAME_RESOLVED);
var WINHTTP_CALLBACK_FLAG_CONNECT_TO_SERVER         = (WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER | WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER);
var WINHTTP_CALLBACK_FLAG_SEND_REQUEST              = (WINHTTP_CALLBACK_STATUS_SENDING_REQUEST | WINHTTP_CALLBACK_STATUS_REQUEST_SENT);
var WINHTTP_CALLBACK_FLAG_RECEIVE_RESPONSE          = (WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE | WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED);
var WINHTTP_CALLBACK_FLAG_CLOSE_CONNECTION          = (WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION | WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED);
var WINHTTP_CALLBACK_FLAG_HANDLES                   = (WINHTTP_CALLBACK_STATUS_HANDLE_CREATED | WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING);
var WINHTTP_CALLBACK_FLAG_DETECTING_PROXY           = WINHTTP_CALLBACK_STATUS_DETECTING_PROXY;
var WINHTTP_CALLBACK_FLAG_REQUEST_COMPLETE          = WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE;
var WINHTTP_CALLBACK_FLAG_REDIRECT                  = WINHTTP_CALLBACK_STATUS_REDIRECT;
var WINHTTP_CALLBACK_FLAG_INTERMEDIATE_RESPONSE     = WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE;
var WINHTTP_CALLBACK_FLAG_SECURE_FAILURE            = WINHTTP_CALLBACK_STATUS_SECURE_FAILURE;
var WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS         = 0x0000000a; // not the same as the header file, but script doesn't like 0xffffffff
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\whttptst\src\utils\debug.cxx ===
#include "common.h"


LPSTR
MapDllReasonToString(int reason)
{
  switch(reason)
  {
    CASE_OF(DLL_PROCESS_ATTACH);
    CASE_OF(DLL_PROCESS_DETACH);
    CASE_OF(DLL_THREAD_ATTACH);
    CASE_OF(DLL_THREAD_DETACH);
  
    default : return "?";
  }
}

LPSTR
MapIIDToString(REFIID riid)
{
  CASE_IID(riid, IID_NULL);
  CASE_IID(riid, IID_IUnknown);
  CASE_IID(riid, IID_IClassFactory);
  CASE_IID(riid, IID_IDispatch);
  CASE_IID(riid, IID_IConnectionPointContainer);
  CASE_IID(riid, IID_IConnectionPoint);
  CASE_IID(riid, IID_IMarshal);
  CASE_IID(riid, IID_IStdMarshalInfo);
  CASE_IID(riid, IID_IExternalConnection);
  CASE_IID(riid, IID_IObjectWithSite);
  CASE_IID(riid, IID_IProvideClassInfo);
  CASE_IID(riid, IID_IServiceProvider);

  CASE_IID(riid, IID_IWinHttpTest);
  CASE_IID(riid, IID_IWHTUrlComponents);
  CASE_IID(riid, IID_IWHTWin32ErrorCode);

  return "?";
}

LPSTR
MapHResultToString(HRESULT hr)
{
  switch(hr)
  {
    CASE_OF(S_OK);
    CASE_OF(E_NOINTERFACE);
    CASE_OF(E_POINTER);
    CASE_OF(E_UNEXPECTED);
    CASE_OF(E_INVALIDARG);
    CASE_OF(E_OUTOFMEMORY);
    CASE_OF(E_FAIL);
    CASE_OF(E_NOTIMPL);
    CASE_OF(E_PENDING);
    CASE_OF(E_ACCESSDENIED);
    CASE_OF(CLASS_E_NOAGGREGATION);
    CASE_OF(TYPE_E_IOERROR);
    CASE_OF(TYPE_E_REGISTRYACCESS);
    CASE_OF(TYPE_E_INVALIDSTATE);
    CASE_OF(TYPE_E_BUFFERTOOSMALL);
    CASE_OF(TYPE_E_FIELDNOTFOUND);
    CASE_OF(TYPE_E_ELEMENTNOTFOUND);
    CASE_OF(TYPE_E_AMBIGUOUSNAME);
    CASE_OF(TYPE_E_UNKNOWNLCID);
    CASE_OF(TYPE_E_BADMODULEKIND);
    CASE_OF(TYPE_E_CANTLOADLIBRARY);
    CASE_OF(TYPE_E_INCONSISTENTPROPFUNCS);
    CASE_OF(CONNECT_E_NOCONNECTION);
    CASE_OF(CONNECT_E_ADVISELIMIT);
    CASE_OF(CO_E_OBJNOTREG);
    CASE_OF(DISP_E_BADPARAMCOUNT);
    CASE_OF(DISP_E_BADVARTYPE);
    CASE_OF(DISP_E_EXCEPTION);
    CASE_OF(DISP_E_MEMBERNOTFOUND);
    CASE_OF(DISP_E_NONAMEDARGS);
    CASE_OF(DISP_E_OVERFLOW);
    CASE_OF(DISP_E_PARAMNOTFOUND);
    CASE_OF(DISP_E_TYPEMISMATCH);
    CASE_OF(DISP_E_UNKNOWNINTERFACE);
    CASE_OF(DISP_E_UNKNOWNLCID);
    CASE_OF(DISP_E_PARAMNOTOPTIONAL);
    CASE_OF(DISP_E_UNKNOWNNAME);

    default : return "?";
  }
}

LPSTR
MapErrorToString(int error)
{
  switch(error)
  {
    CASE_OF(ERROR_WINHTTP_OUT_OF_HANDLES);
    CASE_OF(ERROR_WINHTTP_TIMEOUT);
    CASE_OF(ERROR_WINHTTP_INTERNAL_ERROR);
    CASE_OF(ERROR_WINHTTP_INVALID_URL);
    CASE_OF(ERROR_WINHTTP_UNRECOGNIZED_SCHEME);
    CASE_OF(ERROR_WINHTTP_NAME_NOT_RESOLVED);
    CASE_OF(ERROR_WINHTTP_INVALID_OPTION);
    CASE_OF(ERROR_WINHTTP_OPTION_NOT_SETTABLE);
    CASE_OF(ERROR_WINHTTP_SHUTDOWN);
    CASE_OF(ERROR_WINHTTP_LOGIN_FAILURE);
    CASE_OF(ERROR_WINHTTP_OPERATION_CANCELLED);
    CASE_OF(ERROR_WINHTTP_INCORRECT_HANDLE_TYPE);
    CASE_OF(ERROR_WINHTTP_INCORRECT_HANDLE_STATE);
    CASE_OF(ERROR_WINHTTP_CANNOT_CONNECT);
    CASE_OF(ERROR_WINHTTP_CONNECTION_ERROR);
    CASE_OF(ERROR_WINHTTP_RESEND_REQUEST);
    CASE_OF(ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED);
    CASE_OF(ERROR_WINHTTP_HEADER_NOT_FOUND);
    CASE_OF(ERROR_WINHTTP_INVALID_SERVER_RESPONSE);
    CASE_OF(ERROR_WINHTTP_INVALID_QUERY_REQUEST);
    CASE_OF(ERROR_WINHTTP_HEADER_ALREADY_EXISTS);
    CASE_OF(ERROR_WINHTTP_REDIRECT_FAILED);
    CASE_OF(ERROR_WINHTTP_NOT_INITIALIZED);
    CASE_OF(ERROR_WINHTTP_SECURE_FAILURE);

    CASE_OF(ERROR_SUCCESS);
    CASE_OF(ERROR_INVALID_FUNCTION);
    CASE_OF(ERROR_FILE_NOT_FOUND);
    CASE_OF(ERROR_PATH_NOT_FOUND);
    CASE_OF(ERROR_TOO_MANY_OPEN_FILES);
    CASE_OF(ERROR_ACCESS_DENIED);
    CASE_OF(ERROR_INVALID_HANDLE);
    CASE_OF(ERROR_ARENA_TRASHED);
    CASE_OF(ERROR_NOT_ENOUGH_MEMORY);
    CASE_OF(ERROR_INVALID_BLOCK);
    CASE_OF(ERROR_BAD_ENVIRONMENT);
    CASE_OF(ERROR_BAD_FORMAT);
    CASE_OF(ERROR_INVALID_ACCESS);
    CASE_OF(ERROR_INVALID_DATA);
    CASE_OF(ERROR_OUTOFMEMORY);
    CASE_OF(ERROR_INVALID_DRIVE);
    CASE_OF(ERROR_CURRENT_DIRECTORY);
    CASE_OF(ERROR_NOT_SAME_DEVICE);
    CASE_OF(ERROR_NO_MORE_FILES);
    CASE_OF(ERROR_WRITE_PROTECT);
    CASE_OF(ERROR_BAD_UNIT);
    CASE_OF(ERROR_NOT_READY);
    CASE_OF(ERROR_BAD_COMMAND);
    CASE_OF(ERROR_CRC);
    CASE_OF(ERROR_BAD_LENGTH);
    CASE_OF(ERROR_SEEK);
    CASE_OF(ERROR_NOT_DOS_DISK);
    CASE_OF(ERROR_SECTOR_NOT_FOUND);
    CASE_OF(ERROR_OUT_OF_PAPER);
    CASE_OF(ERROR_WRITE_FAULT);
    CASE_OF(ERROR_READ_FAULT);
    CASE_OF(ERROR_GEN_FAILURE);
    CASE_OF(ERROR_SHARING_VIOLATION);
    CASE_OF(ERROR_LOCK_VIOLATION);
    CASE_OF(ERROR_WRONG_DISK);
    CASE_OF(ERROR_SHARING_BUFFER_EXCEEDED);
    CASE_OF(ERROR_HANDLE_EOF);
    CASE_OF(ERROR_HANDLE_DISK_FULL);
    CASE_OF(ERROR_NOT_SUPPORTED);
    CASE_OF(ERROR_REM_NOT_LIST);
    CASE_OF(ERROR_DUP_NAME);
    CASE_OF(ERROR_BAD_NETPATH);
    CASE_OF(ERROR_NETWORK_BUSY);
    CASE_OF(ERROR_DEV_NOT_EXIST);
    CASE_OF(ERROR_TOO_MANY_CMDS);
    CASE_OF(ERROR_ADAP_HDW_ERR);
    CASE_OF(ERROR_BAD_NET_RESP);
    CASE_OF(ERROR_UNEXP_NET_ERR);
    CASE_OF(ERROR_BAD_REM_ADAP);
    CASE_OF(ERROR_PRINTQ_FULL);
    CASE_OF(ERROR_NO_SPOOL_SPACE);
    CASE_OF(ERROR_PRINT_CANCELLED);
    CASE_OF(ERROR_NETNAME_DELETED);
    CASE_OF(ERROR_NETWORK_ACCESS_DENIED);
    CASE_OF(ERROR_BAD_DEV_TYPE);
    CASE_OF(ERROR_BAD_NET_NAME);
    CASE_OF(ERROR_TOO_MANY_NAMES);
    CASE_OF(ERROR_TOO_MANY_SESS);
    CASE_OF(ERROR_SHARING_PAUSED);
    CASE_OF(ERROR_REQ_NOT_ACCEP);
    CASE_OF(ERROR_REDIR_PAUSED);
    CASE_OF(ERROR_FILE_EXISTS);
    CASE_OF(ERROR_CANNOT_MAKE);
    CASE_OF(ERROR_FAIL_I24);
    CASE_OF(ERROR_OUT_OF_STRUCTURES);
    CASE_OF(ERROR_ALREADY_ASSIGNED);
    CASE_OF(ERROR_INVALID_PASSWORD);
    CASE_OF(ERROR_INVALID_PARAMETER);
    CASE_OF(ERROR_NET_WRITE_FAULT);
    CASE_OF(ERROR_NO_PROC_SLOTS);
    CASE_OF(ERROR_TOO_MANY_SEMAPHORES);
    CASE_OF(ERROR_EXCL_SEM_ALREADY_OWNED);
    CASE_OF(ERROR_SEM_IS_SET);
    CASE_OF(ERROR_TOO_MANY_SEM_REQUESTS);
    CASE_OF(ERROR_INVALID_AT_INTERRUPT_TIME);
    CASE_OF(ERROR_SEM_OWNER_DIED);
    CASE_OF(ERROR_SEM_USER_LIMIT);
    CASE_OF(ERROR_DISK_CHANGE);
    CASE_OF(ERROR_DRIVE_LOCKED);
    CASE_OF(ERROR_BROKEN_PIPE);
    CASE_OF(ERROR_OPEN_FAILED);
    CASE_OF(ERROR_BUFFER_OVERFLOW);
    CASE_OF(ERROR_DISK_FULL);
    CASE_OF(ERROR_NO_MORE_SEARCH_HANDLES);
    CASE_OF(ERROR_INVALID_TARGET_HANDLE);
    CASE_OF(ERROR_INVALID_CATEGORY);
    CASE_OF(ERROR_INVALID_VERIFY_SWITCH);
    CASE_OF(ERROR_BAD_DRIVER_LEVEL);
    CASE_OF(ERROR_CALL_NOT_IMPLEMENTED);
    CASE_OF(ERROR_SEM_TIMEOUT);
    CASE_OF(ERROR_INSUFFICIENT_BUFFER);
    CASE_OF(ERROR_INVALID_NAME);
    CASE_OF(ERROR_INVALID_LEVEL);
    CASE_OF(ERROR_NO_VOLUME_LABEL);
    CASE_OF(ERROR_MOD_NOT_FOUND);
    CASE_OF(ERROR_PROC_NOT_FOUND);
    CASE_OF(ERROR_WAIT_NO_CHILDREN);
    CASE_OF(ERROR_CHILD_NOT_COMPLETE);
    CASE_OF(ERROR_DIRECT_ACCESS_HANDLE);
    CASE_OF(ERROR_NEGATIVE_SEEK);
    CASE_OF(ERROR_SEEK_ON_DEVICE);
    CASE_OF(ERROR_DIR_NOT_ROOT);
    CASE_OF(ERROR_DIR_NOT_EMPTY);
    CASE_OF(ERROR_PATH_BUSY);
    CASE_OF(ERROR_SYSTEM_TRACE);
    CASE_OF(ERROR_INVALID_EVENT_COUNT);
    CASE_OF(ERROR_TOO_MANY_MUXWAITERS);
    CASE_OF(ERROR_INVALID_LIST_FORMAT);
    CASE_OF(ERROR_BAD_ARGUMENTS);
    CASE_OF(ERROR_BAD_PATHNAME);
    CASE_OF(ERROR_BUSY);
    CASE_OF(ERROR_CANCEL_VIOLATION);
    CASE_OF(ERROR_ALREADY_EXISTS);
    CASE_OF(ERROR_FILENAME_EXCED_RANGE);
    CASE_OF(ERROR_LOCKED);
    CASE_OF(ERROR_NESTING_NOT_ALLOWED);
    CASE_OF(ERROR_BAD_PIPE);
    CASE_OF(ERROR_PIPE_BUSY);
    CASE_OF(ERROR_NO_DATA);
    CASE_OF(ERROR_PIPE_NOT_CONNECTED);
    CASE_OF(ERROR_MORE_DATA);
    CASE_OF(ERROR_NO_MORE_ITEMS);
    CASE_OF(ERROR_NOT_OWNER);
    CASE_OF(ERROR_PARTIAL_COPY);
    CASE_OF(ERROR_MR_MID_NOT_FOUND);
    CASE_OF(ERROR_INVALID_ADDRESS);
    CASE_OF(ERROR_PIPE_CONNECTED);
    CASE_OF(ERROR_PIPE_LISTENING);
    CASE_OF(ERROR_OPERATION_ABORTED);
    CASE_OF(ERROR_IO_INCOMPLETE);
    CASE_OF(ERROR_IO_PENDING);
    CASE_OF(ERROR_NOACCESS);
    CASE_OF(ERROR_STACK_OVERFLOW);
    CASE_OF(ERROR_INVALID_FLAGS);
    CASE_OF(ERROR_NO_TOKEN);
    CASE_OF(ERROR_BADDB);
    CASE_OF(ERROR_BADKEY);
    CASE_OF(ERROR_CANTOPEN);
    CASE_OF(ERROR_CANTREAD);
    CASE_OF(ERROR_CANTWRITE);
    CASE_OF(ERROR_REGISTRY_RECOVERED);
    CASE_OF(ERROR_REGISTRY_CORRUPT);
    CASE_OF(ERROR_REGISTRY_IO_FAILED);
    CASE_OF(ERROR_NOT_REGISTRY_FILE);
    CASE_OF(ERROR_KEY_DELETED);
    CASE_OF(ERROR_CIRCULAR_DEPENDENCY);
    CASE_OF(ERROR_SERVICE_NOT_ACTIVE);
    CASE_OF(ERROR_DLL_INIT_FAILED);
    CASE_OF(ERROR_CANCELLED);
    CASE_OF(ERROR_BAD_USERNAME);
    CASE_OF(ERROR_LOGON_FAILURE);

    CASE_OF(WAIT_FAILED);
    CASE_OF(WAIT_TIMEOUT);
    CASE_OF(WAIT_IO_COMPLETION);

    CASE_OF(EXCEPTION_ACCESS_VIOLATION);
    CASE_OF(EXCEPTION_DATATYPE_MISALIGNMENT);
    CASE_OF(EXCEPTION_BREAKPOINT);
    CASE_OF(EXCEPTION_SINGLE_STEP);
    CASE_OF(EXCEPTION_ARRAY_BOUNDS_EXCEEDED);
    CASE_OF(EXCEPTION_FLT_DENORMAL_OPERAND);
    CASE_OF(EXCEPTION_FLT_DIVIDE_BY_ZERO);
    CASE_OF(EXCEPTION_FLT_INEXACT_RESULT);
    CASE_OF(EXCEPTION_FLT_INVALID_OPERATION);
    CASE_OF(EXCEPTION_FLT_OVERFLOW);
    CASE_OF(EXCEPTION_FLT_STACK_CHECK);
    CASE_OF(EXCEPTION_FLT_UNDERFLOW);
    CASE_OF(EXCEPTION_INT_DIVIDE_BY_ZERO);
    CASE_OF(EXCEPTION_INT_OVERFLOW);
    CASE_OF(EXCEPTION_PRIV_INSTRUCTION);
    CASE_OF(EXCEPTION_IN_PAGE_ERROR);
    CASE_OF(EXCEPTION_ILLEGAL_INSTRUCTION);
    CASE_OF(EXCEPTION_NONCONTINUABLE_EXCEPTION);
    CASE_OF(EXCEPTION_STACK_OVERFLOW);
    CASE_OF(EXCEPTION_INVALID_DISPOSITION);
    CASE_OF(EXCEPTION_GUARD_PAGE);
    CASE_OF(EXCEPTION_INVALID_HANDLE);

    CASE_OF(RPC_S_INVALID_STRING_BINDING);
    CASE_OF(RPC_S_WRONG_KIND_OF_BINDING);
    CASE_OF(RPC_S_INVALID_BINDING);
    CASE_OF(RPC_S_PROTSEQ_NOT_SUPPORTED);
    CASE_OF(RPC_S_INVALID_RPC_PROTSEQ);
    CASE_OF(RPC_S_INVALID_STRING_UUID);
    CASE_OF(RPC_S_INVALID_ENDPOINT_FORMAT);
    CASE_OF(RPC_S_INVALID_NET_ADDR);
    CASE_OF(RPC_S_NO_ENDPOINT_FOUND);
    CASE_OF(RPC_S_INVALID_TIMEOUT);
    CASE_OF(RPC_S_OBJECT_NOT_FOUND);
    CASE_OF(RPC_S_ALREADY_REGISTERED);
    CASE_OF(RPC_S_TYPE_ALREADY_REGISTERED);
    CASE_OF(RPC_S_ALREADY_LISTENING);
    CASE_OF(RPC_S_NO_PROTSEQS_REGISTERED);
    CASE_OF(RPC_S_NOT_LISTENING);
    CASE_OF(RPC_S_UNKNOWN_MGR_TYPE);
    CASE_OF(RPC_S_UNKNOWN_IF);
    CASE_OF(RPC_S_NO_BINDINGS);
    CASE_OF(RPC_S_NO_PROTSEQS);
    CASE_OF(RPC_S_CANT_CREATE_ENDPOINT);
    CASE_OF(RPC_S_OUT_OF_RESOURCES);
    CASE_OF(RPC_S_SERVER_UNAVAILABLE);
    CASE_OF(RPC_S_SERVER_TOO_BUSY);
    CASE_OF(RPC_S_INVALID_NETWORK_OPTIONS);
    CASE_OF(RPC_S_NO_CALL_ACTIVE);
    CASE_OF(RPC_S_CALL_FAILED);
    CASE_OF(RPC_S_CALL_FAILED_DNE);
    CASE_OF(RPC_S_PROTOCOL_ERROR);
    CASE_OF(RPC_S_UNSUPPORTED_TRANS_SYN);
    CASE_OF(RPC_S_UNSUPPORTED_TYPE);
    CASE_OF(RPC_S_INVALID_TAG);
    CASE_OF(RPC_S_INVALID_BOUND);
    CASE_OF(RPC_S_NO_ENTRY_NAME);
    CASE_OF(RPC_S_INVALID_NAME_SYNTAX);
    CASE_OF(RPC_S_UNSUPPORTED_NAME_SYNTAX);
    CASE_OF(RPC_S_UUID_NO_ADDRESS);
    CASE_OF(RPC_S_DUPLICATE_ENDPOINT);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_TYPE);
    CASE_OF(RPC_S_MAX_CALLS_TOO_SMALL);
    CASE_OF(RPC_S_STRING_TOO_LONG);
    CASE_OF(RPC_S_PROTSEQ_NOT_FOUND);
    CASE_OF(RPC_S_PROCNUM_OUT_OF_RANGE);
    CASE_OF(RPC_S_BINDING_HAS_NO_AUTH);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_SERVICE);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_LEVEL);
    CASE_OF(RPC_S_INVALID_AUTH_IDENTITY);
    CASE_OF(RPC_S_UNKNOWN_AUTHZ_SERVICE);
    CASE_OF(EPT_S_INVALID_ENTRY);
    CASE_OF(EPT_S_CANT_PERFORM_OP);
    CASE_OF(EPT_S_NOT_REGISTERED);
    CASE_OF(RPC_S_NOTHING_TO_EXPORT);
    CASE_OF(RPC_S_INCOMPLETE_NAME);
    CASE_OF(RPC_S_INVALID_VERS_OPTION);
    CASE_OF(RPC_S_NO_MORE_MEMBERS);
    CASE_OF(RPC_S_NOT_ALL_OBJS_UNEXPORTED);
    CASE_OF(RPC_S_INTERFACE_NOT_FOUND);
    CASE_OF(RPC_S_ENTRY_ALREADY_EXISTS);
    CASE_OF(RPC_S_ENTRY_NOT_FOUND);
    CASE_OF(RPC_S_NAME_SERVICE_UNAVAILABLE);
    CASE_OF(RPC_S_INVALID_NAF_ID);
    CASE_OF(RPC_S_CANNOT_SUPPORT);
    CASE_OF(RPC_S_NO_CONTEXT_AVAILABLE);
    CASE_OF(RPC_S_INTERNAL_ERROR);
    CASE_OF(RPC_S_ZERO_DIVIDE);
    CASE_OF(RPC_S_ADDRESS_ERROR);
    CASE_OF(RPC_S_FP_DIV_ZERO);
    CASE_OF(RPC_S_FP_UNDERFLOW);
    CASE_OF(RPC_S_FP_OVERFLOW);
    CASE_OF(RPC_X_NO_MORE_ENTRIES);
    CASE_OF(RPC_X_SS_CHAR_TRANS_OPEN_FAIL);
    CASE_OF(RPC_X_SS_CHAR_TRANS_SHORT_FILE);
    CASE_OF(RPC_X_SS_IN_NULL_CONTEXT);
    CASE_OF(RPC_X_SS_CONTEXT_DAMAGED);
    CASE_OF(RPC_X_SS_HANDLES_MISMATCH);
    CASE_OF(RPC_X_SS_CANNOT_GET_CALL_HANDLE);
    CASE_OF(RPC_X_NULL_REF_POINTER);
    CASE_OF(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
    CASE_OF(RPC_X_BYTE_COUNT_TOO_SMALL);
    CASE_OF(RPC_X_BAD_STUB_DATA);

    CASE_OF(WSAEINTR);
    CASE_OF(WSAEBADF);
    CASE_OF(WSAEACCES);
    CASE_OF(WSAEFAULT);
    CASE_OF(WSAEINVAL);
    CASE_OF(WSAEMFILE);
    CASE_OF(WSAEWOULDBLOCK);
    CASE_OF(WSAEINPROGRESS);
    CASE_OF(WSAEALREADY);
    CASE_OF(WSAENOTSOCK);
    CASE_OF(WSAEDESTADDRREQ);
    CASE_OF(WSAEMSGSIZE);
    CASE_OF(WSAEPROTOTYPE);
    CASE_OF(WSAENOPROTOOPT);
    CASE_OF(WSAEPROTONOSUPPORT);
    CASE_OF(WSAESOCKTNOSUPPORT);
    CASE_OF(WSAEOPNOTSUPP);
    CASE_OF(WSAEPFNOSUPPORT);
    CASE_OF(WSAEAFNOSUPPORT);
    CASE_OF(WSAEADDRINUSE);
    CASE_OF(WSAEADDRNOTAVAIL);
    CASE_OF(WSAENETDOWN);
    CASE_OF(WSAENETUNREACH);
    CASE_OF(WSAENETRESET);
    CASE_OF(WSAECONNABORTED);
    CASE_OF(WSAECONNRESET);
    CASE_OF(WSAENOBUFS);
    CASE_OF(WSAEISCONN);
    CASE_OF(WSAENOTCONN);
    CASE_OF(WSAESHUTDOWN);
    CASE_OF(WSAETOOMANYREFS);
    CASE_OF(WSAETIMEDOUT);
    CASE_OF(WSAECONNREFUSED);
    CASE_OF(WSAELOOP);
    CASE_OF(WSAENAMETOOLONG);
    CASE_OF(WSAEHOSTDOWN);
    CASE_OF(WSAEHOSTUNREACH);
    CASE_OF(WSAENOTEMPTY);
    CASE_OF(WSAEPROCLIM);
    CASE_OF(WSAEUSERS);
    CASE_OF(WSAEDQUOT);
    CASE_OF(WSAESTALE);
    CASE_OF(WSAEREMOTE);
    CASE_OF(WSAEDISCON);
    CASE_OF(WSASYSNOTREADY);
    CASE_OF(WSAVERNOTSUPPORTED);
    CASE_OF(WSANOTINITIALISED);
    CASE_OF(WSAHOST_NOT_FOUND);
    CASE_OF(WSATRY_AGAIN);
    CASE_OF(WSANO_RECOVERY);
    CASE_OF(WSANO_DATA);

    CASE_OF(ERROR_FAILURE);
    CASE_OF(ERROR_INVALID_STATE);

    default : return "?";
  }
}

LPSTR
MapDispidToString(DISPID dispid)
{
  switch(dispid)
  {
    // special dispids
    CASE_OF(DISPID_VALUE);
    CASE_OF(DISPID_NEWENUM);
    CASE_OF(DISPID_EVALUATE);
    CASE_OF(DISPID_PROPERTYPUT);
    CASE_OF(DISPID_CONSTRUCTOR);
    CASE_OF(DISPID_DESTRUCTOR);
    CASE_OF(DISPID_UNKNOWN);
    CASE_OF(DISPID_COLLECT);

    CASE_OF(DISPID_WINHTTPTEST_OPEN);
    CASE_OF(DISPID_WINHTTPTEST_CONNECT);
    CASE_OF(DISPID_WINHTTPTEST_OPENREQUEST);
    CASE_OF(DISPID_WINHTTPTEST_SENDREQUEST);
    CASE_OF(DISPID_WINHTTPTEST_RECEIVERESPONSE);
    CASE_OF(DISPID_WINHTTPTEST_CLOSEHANDLE);
    CASE_OF(DISPID_WINHTTPTEST_READDATA);
    CASE_OF(DISPID_WINHTTPTEST_WRITEDATA);
    CASE_OF(DISPID_WINHTTPTEST_QUERYDATAAVAILABLE);
    CASE_OF(DISPID_WINHTTPTEST_QUERYOPTION);
    CASE_OF(DISPID_WINHTTPTEST_SETOPTION);
    CASE_OF(DISPID_WINHTTPTEST_SETTIMEOUTS);
    CASE_OF(DISPID_WINHTTPTEST_ADDREQUESTHEADERS);
    CASE_OF(DISPID_WINHTTPTEST_SETCREDENTIALS);
    CASE_OF(DISPID_WINHTTPTEST_QUERYAUTHSCHEMES);
    CASE_OF(DISPID_WINHTTPTEST_QUERYHEADERS);
    CASE_OF(DISPID_WINHTTPTEST_TIMEFROMSYSTEMTIME);
    CASE_OF(DISPID_WINHTTPTEST_TIMETOSYSTEMTIME);
    CASE_OF(DISPID_WINHTTPTEST_CRACKURL);
    CASE_OF(DISPID_WINHTTPTEST_CREATEURL);
    CASE_OF(DISPID_WINHTTPTEST_SETSTATUSCALLBACK);
    CASE_OF(DISPID_WINHTTPTEST_HELPER_GETBUFFEROBJECT);
    CASE_OF(DISPID_WINHTTPTEST_HELPER_GETURLCOMPONENTS);
    CASE_OF(DISPID_WINHTTPTEST_HELPER_GETSYSTEMTIME);
    CASE_OF(DISPID_WINHTTPTEST_HELPER_GETLASTERROR);
    CASE_OF(DISPID_WIN32ERRORCODE_ERRORCODE);
    CASE_OF(DISPID_WIN32ERRORCODE_ERRORSTRING);
    CASE_OF(DISPID_WIN32ERRORCODE_ISEXCEPTION);
    CASE_OF(DISPID_BUFFEROBJECT_SIZE);
    CASE_OF(DISPID_BUFFEROBJECT_TYPE);
    CASE_OF(DISPID_BUFFEROBJECT_BYTESTRANSFERRED);
    CASE_OF(DISPID_BUFFEROBJECT_FLAGS);
    CASE_OF(DISPID_URLCOMPONENTS_STRUCTSIZE);
    CASE_OF(DISPID_URLCOMPONENTS_SCHEME);
    CASE_OF(DISPID_URLCOMPONENTS_SCHEMELENGTH);
    CASE_OF(DISPID_URLCOMPONENTS_SCHEMEID);
    CASE_OF(DISPID_URLCOMPONENTS_HOSTNAME);
    CASE_OF(DISPID_URLCOMPONENTS_HOSTNAMELENGTH);
    CASE_OF(DISPID_URLCOMPONENTS_PORT);
    CASE_OF(DISPID_URLCOMPONENTS_USERNAME);
    CASE_OF(DISPID_URLCOMPONENTS_USERNAMELENGTH);
    CASE_OF(DISPID_URLCOMPONENTS_PASSWORD);
    CASE_OF(DISPID_URLCOMPONENTS_PASSWORDLENGTH);
    CASE_OF(DISPID_URLCOMPONENTS_URLPATH);
    CASE_OF(DISPID_URLCOMPONENTS_URLPATHLENGTH);
    CASE_OF(DISPID_URLCOMPONENTS_EXTRAINFO);
    CASE_OF(DISPID_URLCOMPONENTS_EXTRAINFOLENGTH);
    CASE_OF(DISPID_SYSTEMTIME_YEAR);
    CASE_OF(DISPID_SYSTEMTIME_MONTH);
    CASE_OF(DISPID_SYSTEMTIME_DAYOFWEEK);
    CASE_OF(DISPID_SYSTEMTIME_DAY);
    CASE_OF(DISPID_SYSTEMTIME_HOUR);
    CASE_OF(DISPID_SYSTEMTIME_MINUTE);
    CASE_OF(DISPID_SYSTEMTIME_SECOND);
    CASE_OF(DISPID_SYSTEMTIME_MSEC);

    default : return "?";
  }
}

LPSTR
MapVariantTypeToString(VARIANT* pvar)
{
  if( pvar )
  {
    switch( V_VT(pvar) )
    {
      CASE_OF(VT_ARRAY | VT_UI1);
      CASE_OF(VT_EMPTY);
      CASE_OF(VT_NULL);
      CASE_OF(VT_I2);
      CASE_OF(VT_I4);
      CASE_OF(VT_R4);
      CASE_OF(VT_R8);
      CASE_OF(VT_CY);
      CASE_OF(VT_DATE);
      CASE_OF(VT_BSTR);
      CASE_OF(VT_DISPATCH);
      CASE_OF(VT_ERROR);
      CASE_OF(VT_BOOL);
      CASE_OF(VT_VARIANT);
      CASE_OF(VT_DECIMAL);
      CASE_OF(VT_RECORD);
      CASE_OF(VT_UNKNOWN);
      CASE_OF(VT_I1);
      CASE_OF(VT_UI1);
      CASE_OF(VT_UI2);
      CASE_OF(VT_UI4);
      CASE_OF(VT_INT);
      CASE_OF(VT_UINT);
      CASE_OF(VT_ARRAY);
      CASE_OF(VT_BYREF);

      default : return "?";
    }
  }
  else
  {
    return "null";
  }
}

LPSTR
MapDataTypeToString(TYPE type)
{
  switch( type )
  {
    CASE_OF(TYPE_LPWSTR);
    CASE_OF(TYPE_LPLPWSTR);
    CASE_OF(TYPE_LPSTR);
    CASE_OF(TYPE_LPLPSTR);
    CASE_OF(TYPE_DWORD);
    CASE_OF(TYPE_LPDWORD);

    default : return "?";
  }
}

LPSTR
MapPointerTypeToString(POINTER pointer)
{
  switch( pointer )
  {
    CASE_OF(NULL_PTR);
    CASE_OF(BAD_PTR);
    CASE_OF(FREE_PTR);
    CASE_OF(UNINIT_PTR);

    default : return "?";
  }
}

LPSTR
MapWinHttpAccessType(DWORD type)
{
  switch( type )
  {
    CASE_OF(WINHTTP_ACCESS_TYPE_DEFAULT_PROXY);
    CASE_OF(WINHTTP_ACCESS_TYPE_NO_PROXY);
    CASE_OF(WINHTTP_ACCESS_TYPE_NAMED_PROXY);

    default : return "?";
  }
}

LPSTR
MapWinHttpIOMode(DWORD mode)
{
  switch( mode )
  {
    CASE_OF_MUTATE(0, WINHTTP_FLAG_SYNC);
    CASE_OF(WINHTTP_FLAG_ASYNC);

    default : return "?";
  }
}

LPSTR
MapWinHttpHandleType(HINTERNET hInternet)
{
  DWORD type = 0L;
  DWORD size = sizeof(HINTERNET);

  WinHttpQueryOption(hInternet, WINHTTP_OPTION_HANDLE_TYPE, (void*) &type, &size);

  switch( type )
  {
    CASE_OF(WINHTTP_HANDLE_TYPE_SESSION);
    CASE_OF(WINHTTP_HANDLE_TYPE_CONNECT);
    CASE_OF(WINHTTP_HANDLE_TYPE_REQUEST);

    default : return "INVALID_HANDLE_VALUE";
  }
}

LPSTR
MapCallbackFlagToString(DWORD flag)
{
  switch( flag )
  {
    CASE_OF(WINHTTP_CALLBACK_STATUS_RESOLVING_NAME);
    CASE_OF(WINHTTP_CALLBACK_STATUS_NAME_RESOLVED);
    CASE_OF(WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER);
    CASE_OF(WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER);
    CASE_OF(WINHTTP_CALLBACK_STATUS_SENDING_REQUEST);
    CASE_OF(WINHTTP_CALLBACK_STATUS_REQUEST_SENT);
    CASE_OF(WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED);
    CASE_OF(WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION);
    CASE_OF(WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED);
    CASE_OF(WINHTTP_CALLBACK_STATUS_HANDLE_CREATED);
    CASE_OF(WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING);
    CASE_OF(WINHTTP_CALLBACK_STATUS_DETECTING_PROXY);
    CASE_OF(WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_REDIRECT);
    CASE_OF(WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_SECURE_FAILURE);

    default : return "?";
  }
}

LPSTR
MapMemsetFlagToString(MEMSETFLAG mf)
{
  switch( mf )
  {
    CASE_OF(INIT_NULL);
    CASE_OF(INIT_SMILEY);
    CASE_OF(INIT_HEXFF);
    CASE_OF(INIT_GARBAGE);

    default : return "?";
  }
}

#ifdef _DEBUG

#define DEBUG_DEFAULT_DBGFILE L"WHTTPTST.LOG"
#define DEBUG_LOGFILE_MUTEX   L"WHTTPTST_LogFile_Mutex"

//
// globals
//

DWORD    g_dwTlsIndex        = 0L;
DWORD    g_dwDebugFlags      = DBG_NO_DEBUG;
HANDLE   g_hDebugLogFile     = NULL;
HANDLE   g_mtxDebugLogFile   = NULL;
LPCWSTR  g_wszDebugFlags     = L"debugflags";
MEMUSAGE g_memusage          = {0};

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugInitialize()

  WHAT    : initializes the debugging support for the application. allocates
            thread-local storage and opens a log file if necessary.

            on failure, the function sets the DBG_NO_DEBUG flag so other
            debug functions won't do anything to get us in trouble.

  ARGS    : none
  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugInitialize( void )
{
  LPDWORD pdw   = NULL;

  DebugMemInitialize();

  if( GetRegValue(g_wszDebugFlags, REG_DWORD, (void**) &pdw) )
  {
    g_dwDebugFlags = *pdw;
    delete pdw;
  }
  else
  {
    g_dwDebugFlags = DEBUG_DEFAULT_FLAGS;
  }

  if( DBG_THROWDBGALERT & g_dwDebugFlags )
    DebugThrowDbgAlert();

  if( !(g_dwDebugFlags & DBG_NO_DEBUG) )
  {
    //
    // allocate a TLS slot or else we can't
    // do call tracing
    //

    if( (g_dwTlsIndex = TlsAlloc()) == 0xFFFFFFFF )
      goto no_debug;

    //
    // if logging to file is enabled, open the log file
    // and create a mutex for log dumps, disable debug
    // logging on error
    //

    if( g_dwDebugFlags & DBG_TO_FILE )
    {
      if(
        !( _opendebugfile() &&
           (g_mtxDebugLogFile = CreateMutex(NULL, FALSE, DEBUG_LOGFILE_MUTEX))
         )
        )
        goto no_debug;
    }

    //
    // print the log banner
    //

    char* time = _gettimestamp();

    _debugout(
      NULL,
      TRUE,
      FALSE,
      "\r\nDebug WHTTPTST.DLL started at %s with flags: %x\r\n\r\n",
      time,
      g_dwDebugFlags
      );

    delete [] time;
    return;
  }
  else
  {
    DebugMemTerminate();
  }

no_debug:
  g_dwDebugFlags = DBG_NO_DEBUG;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugTerminate()

  WHAT    : terminates debugging support for the application. 

  ARGS    : none
  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugTerminate( void )
{
  if( !(g_dwDebugFlags & DBG_NO_DEBUG) )
  {
    DebugMemTerminate();

    if( g_dwTlsIndex )
        TlsFree(g_dwTlsIndex);

    if( (g_dwDebugFlags & DBG_TO_FILE) && g_hDebugLogFile )
    {
      _closedebugfile();
      CloseHandle(g_mtxDebugLogFile);
      g_mtxDebugLogFile = NULL;
    }
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugMemInitialize()

  WHAT    : Initializes memory allocation tracking for the app.

  ARGS    : none.
  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugMemInitialize(void)
{
  InitializeCriticalSection(&g_memusage.lock);
  g_memusage.total = 0;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugMemTerminate()

  WHAT    : Terminates memory allocation tracking and prints the final line
            in the logfile indicating how many bytes of memory were unallocated
            at process termination.

  ARGS    : none.
  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugMemTerminate(void)
{
  if( g_dwDebugFlags & DBG_MEM )
    DebugTrace("*** unallocated memory: %d bytes", g_memusage.total);

  DeleteCriticalSection(&g_memusage.lock);
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugMemAlloc()

  WHAT    : Increments our allocation tracking value by the number of bytes
            a given allocation maps to on the process heap.

  ARGS    : pv - pointer to allocated memory.

  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugMemAlloc(void* pv)
{
  EnterCriticalSection(&g_memusage.lock);

    g_memusage.total += HeapSize(GetProcessHeap(), 0, pv);

  LeaveCriticalSection(&g_memusage.lock);
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugMemFree()

  WHAT    : Decrements our allocation tracking value by the number of bytes an
            allocation uses on the heap.

  ARGS    : pv - pointer to allocated memory.

  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugMemFree(void* pv)
{
  EnterCriticalSection(&g_memusage.lock);

    g_memusage.total -= HeapSize(GetProcessHeap(), 0, pv);    

  LeaveCriticalSection(&g_memusage.lock);
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugThrowDbgAlert()

  WHAT    : Throws an alert dialog displaying the process PID so a debugger
            can be attached.

  ARGS    : none.
  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugThrowDbgAlert(void)
{
  char buf[256];

  wsprintfA(
    buf,
    "pid=%d",
    GetCurrentProcessId()
    );

  MessageBoxA(NULL, buf, "Attach Debugger!", MB_OK | MB_ICONSTOP | MB_SERVICE_NOTIFICATION);
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugEnter()

  WHAT    : called on api entry. prints a log entry resembling the following:

              CalledFunctionName(param1=value, etc.)

  ARGS    : category - the debugging category for the logged function
            rt       - lets us know what type the function returns
            function - the logged function's name
            format   - user-supplied format string containing function args
            ...      - optional parameter list

  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugEnter(int category, RETTYPE rt, LPCSTR function, const char* format, ...)
{
  LPTHREADINFO pti = NULL;
  LPCALLINFO   pci = NULL;

  if( !(g_dwDebugFlags & DBG_NO_DEBUG) )
  {
    pti = GetThreadInfo();
    pci = SetCallInfo(pti, category, rt, function);

    if( g_dwDebugFlags & category )
    {
      char*   buffer = new char[1024];
      va_list arg_list;

      pti->depth++;

      if( buffer )
      {
        //
        // if the user passed an arglist & some values,
        // we'll plug it in to the function entry listing
        // in the log. otherwise we just print empty parens
        //

        if( format )
        {
          va_start(arg_list, format);
          wvsprintfA(buffer, format, arg_list);

            _debugout(pti, FALSE, FALSE, "%s(%s)", function, buffer);

          va_end(arg_list);
        }
        else
        {
          _debugout(pti, FALSE, FALSE, "%s()", function);
        }
    
        delete [] buffer;
      }
    }
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugLeave()

  WHAT    : prints a log entry for the logged function displaying the return
            value.
            
  ARGS    : retval - the value the logged function will return
  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugLeave(int retval)
{
  LPTHREADINFO pti = NULL;
  LPCALLINFO   pci = NULL;

  if( !(g_dwDebugFlags & DBG_NO_DEBUG) )
  {
    pti = GetThreadInfo();
    pci = GetCallInfo(pti);

    if( g_dwDebugFlags & pci->category )
    {
      char* buffer = FormatCallReturnString(pci, retval);

      _debugout(pti, FALSE, FALSE, buffer);
      pti->depth--;
      delete [] buffer;
    }

    DeleteCallInfo(pci);
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugTrace()

  WHAT    : prints a generic output line with the usual timestamp & thread id,
            etc.

  ARGS    : format - user-supplied format string
            ...    - optional parameter list

  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugTrace(const char* format, ...)
{
  va_list arg_list;
  char    buf[1024];

  if( !(g_dwDebugFlags & DBG_NO_DEBUG) )
  {
    va_start(arg_list, format);

      wvsprintfA(buf, format, arg_list);
      _debugout(GetThreadInfo(), FALSE, TRUE, buf);

    va_end(arg_list);
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugAssert()

  WHAT    : logs asserts to the selected outputs but doesn't break execution.

  ARGS    : condition - the stringized failure condition.
            file      - the file containing the assert
            line      - the line of code that asserted

  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugAssert(LPSTR condition, LPSTR file, int line)
{
  LPTHREADINFO pti = GetThreadInfo();
  LPCALLINFO   pci = NULL;

  _debugout(
    pti,
    TRUE,
    FALSE,
    "\r\n\r\n\t*******************************************\r\n" \
    "\t ASSERTION FAILED: \"%s\"\r\n" \
    "\t  %s (line %d)\r\n",
    condition,
    file,
    line
    );

  for(pci = pti->stack; pci; pci = pci->next)
  {
    _debugout(pti, TRUE, FALSE, "\t   %s", pci->fname);
  }

  _debugout(pti, TRUE, FALSE, "\r\n\t*******************************************\r\n");
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugDataDump*()

  WHAT    : functions to dump a data buffer to the log file.

  ARGS    : title - a legend for the dump
            data  - the buffer
            len   - number of interesting bytes in the buffer

  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugDataDump(LPSTR title, LPBYTE data, DWORD len)
{
  DWORD n      = 0L;
  DWORD offset = 0L;
  CHAR* buf    = NULL;

  DebugTrace("%s (%#x bytes @ %#x)", title, len, data);

  buf = new CHAR[256];

    while( len )
    {
      n = DebugDataDumpFormat(buf, data, len);

      DebugTrace(buf);

      data += n;
      len  -= n;
    }

  delete [] buf;
}

int
DebugDataDumpFormat(LPSTR buffer, LPBYTE data, DWORD len)
{
  //
  // note - plagiarized from similar code in wininet.
  //

  static char spaces[] = "                                               ";

  DWORD n      = 0L;
  DWORD bytes  = 0L;
  DWORD offset = 0L;
  DWORD byte   = 0L;
  CHAR  ch;

  bytes  = min(len, 16);
  offset = wsprintfA(buffer, "%08x  ", data);

  for(n=0; n<bytes; n++)
  {
    byte    = data[n] & 0xFF;

    offset += wsprintfA(
                buffer+offset,
                ((n & 15) == 7 ? "%02.2x-" : "%02.2x "),
                byte                
                );
  }

  memcpy(buffer+offset, spaces, (16-bytes) * 3 + 2);
  offset += (16-bytes) * 3 + 2;

  for(n=0; n<bytes; n++)
  {
    ch = data[n];
    buffer[offset + n] =  (((ch < 32) || (ch > 127)) || ch == '%') ? '.' : ch;
  }

  buffer[offset + n] = '\0';

  return bytes;
}


/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  AcquireDebugFileLock()

  WHAT    : synchronizes access to the log file handle.

  ARGS    : none
  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
AcquireDebugFileLock(void)
{
  WaitForSingleObject(g_mtxDebugLogFile, INFINITE);
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  ReleaseDebugFileLock()

  WHAT    : releases a thread's lock on the log file handle

  ARGS    : none
  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
ReleaseDebugFileLock(void)
{
  ReleaseMutex(g_mtxDebugLogFile);
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  GetThreadInfo()

  WHAT    : extracts a THREADINFO struct from TLS. if one does not exist,
            this function allocates one and returns it.

  ARGS    : none
  RETURNS : pointer to a THREADINFO struct.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPTHREADINFO
GetThreadInfo(void)
{
  LPTHREADINFO pti = (LPTHREADINFO) TlsGetValue(g_dwTlsIndex);

    if( !pti )
    {
      pti = new THREADINFO;

      pti->threadid  = GetCurrentThreadId();
      pti->threadcat = 0;
      pti->depth     = 0;
      pti->stack     = NULL;

      TlsSetValue(g_dwTlsIndex, (LPVOID) pti);
    }

  return pti;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  SetCallInfo()

  WHAT    : allocates and pushes a CALLINFO struct onto the thread's internal
            call list.

  ARGS    : pti      - pointer to the thread's THREADINFO struct
            category - the debug category associated with the logged function
            rt       - return type used by the logged function
            function - the function name

  RETURNS : pointer to a newly allocated CALLINFO struct

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPCALLINFO
SetCallInfo(LPTHREADINFO pti, DWORD category, RETTYPE rt, LPCSTR function)
{
  LPCALLINFO pci   = NULL;
  LPCALLINFO plast = NULL;

  //
  // walk the call stack to the last item,
  // store the next-to-last position
  //

  for( pci = pti->stack; pci; pci = pci->next )
  {
    plast = pci;
  }

  if( !pci )
  {
    pci = new CALLINFO;

    //
    // if this is the first call on this thread, set the thread
    // category id. this makes logging more understandable by
    // remembering where a thread was first created and what it
    // was used for. the old method changed the caller id based
    // on the function category, which was dumb.
    //

    if( !pti->threadcat )
      pti->threadcat = category;

    pci->category = category;
    pci->fname    = function;
    pci->rettype  = rt;
    pci->last     = plast;
    pci->next     = NULL;

    //
    // if this is the first element, insert it
    // at the head of the list, otherwise
    // link up with the last element
    //

    if( !pti->stack )
    {
      pti->stack = pci;
    }
    else
    {
      plast->next = pci;
    }
  }

  return pci;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  GetCallInfo()

  WHAT    : retrieves the last THREADINFO struct from the threads call trace
            list.

  ARGS    : pti - pointer to the THREADINFO struct whose call list you want

  RETURNS : pointer to a CALLINFO struct

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPCALLINFO
GetCallInfo(LPTHREADINFO pti)
{
  LPCALLINFO pci = NULL;

  if( pti->stack )
  {
    for( pci = pti->stack; pci->next; pci = pci->next );
  }

  return pci;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DeleteCallInfo()

  WHAT    : pops the specified CALLINFO struct off the thread's call list and
            deletes it. if we just popped & deleted the last call record, then
            delete the thread's THREADINFO struct.

  ARGS    : pci - the CALLINFO struct you wish to delete

  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DeleteCallInfo(LPCALLINFO pci)
{
  LPTHREADINFO pti = GetThreadInfo();

  //
  // if the call record we're dealing with isn't the top of the stack
  // then fix up the stack pointers
  //
  // if the current call record is the last then delete the THREADINFO
  // for this thread and NULL the TLS value
  //

  if( pci->last )
  {
    pci->last->next = NULL;
  }
  else
  {
    delete pti;
    TlsSetValue(g_dwTlsIndex, NULL);
  }

  //
  // for all cases, free the call record
  //

  delete pci;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  FormatCallReturnString()

  WHAT    : examines the returning function's return type and formats a string
            containing the return value. in the case of known error codes, we
            include a string representation of the error (e.g. ERROR_SUCCESS).

  ARGS    : pci    - pointer to the CALLINFO struct for the returning function
            retval - the function's return value

  RETURNS : formatted character buffer

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPSTR
FormatCallReturnString(LPCALLINFO pci, int retval)
{
  char* buffer = new char[256];
  int   offset = 0;

  if( buffer )
  {
    offset = wsprintfA(
               buffer,
               "%s() returned ",
               pci->fname
               );

    switch( pci->rettype )
    {
      case rt_void :
        {
          wsprintfA(buffer+offset, "<void>");
        }
        break;

      case rt_bool :
        {
          wsprintfA(buffer+offset, "%s", (retval ? "TRUE" : "FALSE"));
        }
        break;

      case rt_dword :
        {
          wsprintfA(buffer+offset, "%d [%s]", retval, MapErrorToString(retval));
        }
        break;

      case rt_hresult :
        {
          wsprintfA(buffer+offset, "%x [%s]", retval, MapHResultToString(retval));
        }
        break;

      case rt_string :
        {
          wsprintfA(buffer+offset, "%.16s", (LPSTR)retval);
        }
        break;

      default:
        {
          wsprintfA(buffer+offset, "?");
        }
    }
  }

  return buffer;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  MapCategoryToString()

  WHAT    : maps a debug category to a string for the log file.

  ARGS    : category - the category id

  RETURNS : string representation of the category id

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPSTR
MapCategoryToString(int category)
{
  switch(category)
  {
    case DBG_DLL : return "dll";

    default : return "???";
  }
}


/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  _debugout()

  WHAT    : the debug output workhorse. sloppy as crap and i don't care.

  ARGS    : pti    - THREADINFO pointer
            fRaw   - skip debug info formatting
            fTrace - flag that causes us to do in-function indenting
            format - printf format string
            ...    - arglist

  RETURNS : nothing  

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
_debugout(LPTHREADINFO pti, BOOL fRaw, BOOL fTrace, const char* format, ...)
{
  int        offset = 0;
  char*      buffer = new char[2048];
  va_list    arg_list;

  if( !buffer )
    goto quit;

    //
    // check if the user wants verbose debug info
    //

    if( !fRaw )
    {
      if( DBG_TIMESTAMP & g_dwDebugFlags )
      {
        char* timestamp = _gettimestamp();

        offset = wsprintfA(buffer, "%s ", timestamp);
        delete [] timestamp;
      }

      if( DBG_THREAD_INFO & g_dwDebugFlags )
      {
        offset += wsprintfA(buffer+offset, "%0.8x:%0.3d ", pti->threadid, pti->depth);
      }

      if( DBG_CALL_INFO & g_dwDebugFlags )
      {
        //
        // 260500 pmidge
        // changed this to use the thread category id instead of the caller's id.
        //

        offset += wsprintfA(buffer+offset, "<%s> ", MapCategoryToString(pti->threadcat));
      }

      if( DBG_NEST_CALLS & g_dwDebugFlags )
      {
        char* whitespace = _getwhitespace(
                              (fTrace ? pti->depth+1 : pti->depth)
                              );

        offset += wsprintfA(buffer+offset, "%s", whitespace);
        delete [] whitespace;
      }
    }


    //
    // plug in caller's goo if present
    //

    if( format )
    {
      va_start(arg_list, format);
      
        offset += wvsprintfA(buffer+offset, format, arg_list);
        wsprintfA(buffer+offset, "\r\n");
      
      va_end(arg_list);
    }


    //
    // dump to selected outputs
    //

    //
    // BUGBUG: this app only runs on W2K, need to
    //         investigate WMI support
    //

    if( DBG_TO_FILE & g_dwDebugFlags )
    {
      DWORD dw = 0;
    
      AcquireDebugFileLock();

        WriteFile(
          g_hDebugLogFile,
          buffer,
          strlen(buffer),
          &dw,
          NULL
          );
      
      ReleaseDebugFileLock();
    }

    if( DBG_TO_DEBUGGER & g_dwDebugFlags )
      OutputDebugStringA(buffer);

quit:
  delete [] buffer;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  _gettimestamp( void )

  WHAT    : gets the current time, formats it, and returns it to the caller.
            the caller MUST free the return value when done.

  ARGS    : none
  RETURNS : pointer to formatted time string

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
char*
_gettimestamp( void )
{
  SYSTEMTIME st;
  char*      buffer = new char[256];
  
  if( buffer )
  {
    GetLocalTime(&st);

    wsprintfA(
      buffer,
      "%0.2d:%0.2d:%0.2d.%0.3d",
      st.wHour,
      st.wMinute,
      st.wSecond,
      st.wMilliseconds
      );
  }

  return buffer;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  _getwhitespace( int spaces )

  WHAT    : used to insert a number of spaces for indenting. caller must
            free return value.

  ARGS    : spaces - number of spaces to insert
  
  RETURNS : pointer to character buffer filled with spaces

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
char*
_getwhitespace(int spaces)
{
  char* buffer = new char[(spaces * 2) + 1];

  if( buffer )
  {
    memset(buffer, ' ', (spaces * 2));
    buffer[(spaces * 2)] = '\0';
  }

  return buffer;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  _opendebugfile( void )

  WHAT    : opens the debug log file. will stomp previous logs instead of
            appending.

  ARGS    : none

  RETURNS : true or false based on whether the file was opened.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
BOOL
_opendebugfile(void)
{
  WCHAR buf[MAX_PATH];

  if( !g_hDebugLogFile )
  {
    memset(buf, 0x00, (sizeof(WCHAR) * MAX_PATH));

    wsprintf(
      buf,
      L"whttptst_%0.8x.log",
      GetTickCount()
      );

    g_hDebugLogFile = CreateFile(
                        buf,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
  }
  
  return (g_hDebugLogFile ? TRUE : FALSE);
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  _closedebugfile( void )

  WHAT    : closes the debug log file.
  ARGS    : none
  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
_closedebugfile(void)
{
  SAFECLOSE(g_hDebugLogFile);
}

#endif /* _DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\whttptst\src\utils\mem.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 1999  Microsoft Corporation

Module Name:

    mem.cpp

Abstract:

    Replacements for operators new & delete.

    Routines implemented in this module:

      _InitMem()
      operator new
      operator delete

    These routines delegate to HeapAlloc/HeapFree, and party on the process
    heap. This helps overcome the problem of using general-purpose allocation
    functions as well as using new/delete to deal with C++ objects.
    
    Rudimentary allocation tracking is enabled in debug builds that
    allows us to see (via the last line in the log file) how much memory
    went unallocated at process termination. This doesn't take into account
    kernel, gdi, or user objects.

    Memory deallocation routines are "safe" in the sense that you can pass
    NULL pointers (invalid pointers aren't detected).

Author:

    Paul M Midgen (pmidge) 01-June-2000


Revision History:

    01-June-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

HANDLE g_hProcessHeap = NULL;

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  _InitMem()

  WHAT    : Sets the global process heap handle call this before any
            allocations occur or you'll fault. Pretty simple.

  ARGS    : none.
  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void _InitMem(void)
{
  g_hProcessHeap = GetProcessHeap();
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  operator new

  WHAT    : Replaces the global operator new. Same usage semantics. Allocates
            objects, makes implicit calls to their constructors.

  ARGS    : size - size in bytes of the object to be allocated. the compiler
                   pushes this argument on the stack automagically.

  RETURNS : void pointer to allocated memory.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void* __cdecl operator new(size_t size)
{
  void* pv = NULL;

  if( !g_hProcessHeap )
    _InitMem();
  
    pv = HeapAlloc(g_hProcessHeap, HEAP_ZERO_MEMORY, size);
    DEBUG_ALLOC(pv);

  return pv;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  operator delete

  WHAT    : Replaces the global operator delete. Same usage semantics. Deletes
            objects, makes implicit call to their destructors.

  ARGS    : pv - pointer to object to be freed. same compiler magic as with
                 operator new.

  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void __cdecl operator delete(void* pv)
{
  if( !g_hProcessHeap )
    _InitMem();

  if( pv )
  {
    DEBUG_FREE(pv);
    HeapFree(g_hProcessHeap, 0, pv);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\whttptst\src\utils\registry.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    registry.cpp

Abstract:

    Registry functions.
    
Author:

    Paul M Midgen (pmidge) 23-May-2000


Revision History:

    23-May-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

LPCWSTR g_wszAppRootKeyName = L"Software\\Microsoft\\WINHTTPTST";

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  GetRegValue()

  WHAT      : Reads the value of a REG_DWORD or REG_SZ registry value. The
              caller must free the value returned through ppvData.

  ARGS      : szValueName - the value to look up
              dwType      - can be REG_SZ or REG_DWORD
              ppvData     - address of a pointer to initialize to the data
                            read from the registry

  RETURNS   : True if the lookup succeeded, false if there was an error. The
              caller can call GetLastError() to determine the type of error.
              Possible values returned by GetLastError() are:

              ERROR_NOT_ENOUGH_MEMORY - failed to allocate storage for the
                                        requested key

              ERROR_INVALID_PARAMETER - unsupported type in dwType

              If registry lookups fail we set last error to the retcode
              from the registry api we called.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
BOOL
GetRegValue(LPCWSTR wszValueName, DWORD dwType, LPVOID* ppvData)
{
  BOOL   bStatus   = FALSE;
  DWORD  dwRet     = 0L;
  LPBYTE lpData    = NULL;
  DWORD  cbData    = 0L;
  HKEY   hkAppRoot = _GetRootKey(TRUE);

  switch( dwType )
  {
    case REG_DWORD :
      {
        cbData = sizeof(DWORD);
        lpData = new BYTE[cbData];

        if( !lpData )
        {
          SetLastError(ERROR_NOT_ENOUGH_MEMORY);
          goto quit;
        }
      }
      break;

    case REG_SZ :
      {
        // get required buffer size
        dwRet = RegQueryValueEx(
                  hkAppRoot, wszValueName, 0L,
                  &dwType, lpData, &cbData
                  );

          if( dwRet )
          {
            //DEBUG_TRACE(REGISTRY, ("requested key (%s) doesn't exist", szValueName));
            SetLastError(dwRet);
            goto quit;
          }

        lpData = new BYTE[cbData];

          if( !lpData )
          {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto quit;
          }
      }
      break;

    default :
      {
        DEBUG_TRACE(REGISTRY, ("requested type not supported"));
        SetLastError(ERROR_INVALID_PARAMETER);
        goto quit;
      }
      break;
  }

  //
  // do the lookup
  //
  dwRet = RegQueryValueEx(
            hkAppRoot, wszValueName, 0L,
            &dwType, lpData, &cbData
            );
    
    if( dwRet )
    {
      delete [] lpData;
      SetLastError(dwRet);
      goto quit;
    }

  bStatus  = TRUE;
  *ppvData = (LPVOID) lpData;

#ifdef _DEBUG
    if( bStatus )
    {
      switch( dwType )
      {
        case REG_DWORD :
          DEBUG_TRACE(REGISTRY, ("lpData: %d; cbData: %d", (DWORD)*lpData, cbData));
          break;

        case REG_SZ :
          DEBUG_TRACE(REGISTRY, ("lpdata: %s; cbData: %d", (LPSTR)lpData, cbData));
          break;
      }
    }
#endif

quit:

  return bStatus;
}


/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  SetRegValue()

  WHAT      : Writes a value under the application registry key.

  ARGS      : szValueName - the name of the regkey to write to
              dwType      - type of the regkey to write
              pvData      - regkey data
              dwSize      - bytecount of data to write

  RETURNS   : True if the write succeeded, false if otherwise.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
BOOL
SetRegValue(LPCWSTR wszValueName, DWORD dwType, LPVOID pvData, DWORD dwSize)
{
  BOOL  bStatus   = FALSE;
  DWORD dwRet     = 0L;
  HKEY  hkAppRoot = _GetRootKey(TRUE);

#ifdef _DEBUG
    switch( dwType )
    {
      case REG_DWORD :
        DEBUG_TRACE(REGISTRY, ("pvData: %d; dwSize: %d", (DWORD)*((LPDWORD)pvData), dwSize));
        break;

      case REG_SZ :
        DEBUG_TRACE(REGISTRY, ("pvData: %s; dwSize: %d", (LPSTR)pvData, dwSize));
        break;
    }
#endif

    if( !dwSize && pvData )
      dwSize = strlen((LPSTR)pvData);

    dwRet = RegSetValueEx(
              hkAppRoot, wszValueName, 0L,
              dwType, (LPBYTE)pvData, dwSize
              );

    if( dwRet != ERROR_SUCCESS )
      SetLastError(dwRet);
    else
      bStatus = TRUE;      

  return bStatus;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  _GetRootKey()

  WHAT      : Creates/opens the root key used by the app. Remembers the key
              handle across calls, and can be called to release the key handle.

  ARGS      : fOpen - if true, open the regkey, if false, close it.

  RETURNS   : regkey handle.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
HKEY _GetRootKey(BOOL fOpen)
{
  DWORD       disp = 0;
  DWORD       ret  = 0;
  static HKEY root = NULL;

  if( fOpen )
  {
    if( !root )
    {
      ret = RegCreateKeyEx(
              HKEY_CURRENT_USER,
              g_wszAppRootKeyName,
              0,
              NULL,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &root,
              &disp
              );
    }
  }
  else
  {
    if( root )
    {
      RegCloseKey(root);
      root = NULL;
    }
  }

  return root;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\whttptst\src\whterror\whterror.cxx ===
#include "common.h"

extern HINSTANCE g_hGlobalDllInstance;
LPCWSTR          g_wszWHTWin32ErrorCodeObjectName = L"WHTWin32ErrorCode";

//-----------------------------------------------------------------------------
// WHTWin32ErrorCode methods
//-----------------------------------------------------------------------------
WHTWin32ErrorCode::WHTWin32ErrorCode(DWORD error):
  m_cRefs(0),
  m_pti(NULL),
  m_error(error),
  m_bIsException(FALSE)
{
  DEBUG_TRACE(WHTERROR, ("WHTWin32ErrorCode [%#x] created", this));
}


WHTWin32ErrorCode::~WHTWin32ErrorCode()
{
  SAFERELEASE(m_pti);
  DEBUG_TRACE(WHTERROR, ("WHTWin32ErrorCode [%#x] deleted", this));
}


HRESULT
WHTWin32ErrorCode::Create(DWORD error, IWHTWin32ErrorCode** ppwec)
{
  DEBUG_ENTER((
    DBG_INITIALIZE,
    rt_hresult,
    "WHTWin32ErrorCode::Create",
    "error=%s; ppwec=%#x",
    MapErrorToString(error),
    ppwec
    ));

  HRESULT   hr      = S_OK;
  PWHTERROR pwhterr = NULL;

  if( ppwec )
  {
    pwhterr = new WHTERROR(error);

    if( pwhterr )
    {
      hr = pwhterr->_Initialize();

      if( SUCCEEDED(hr) )
      {
        hr = pwhterr->QueryInterface(IID_IWHTWin32ErrorCode, (void**) ppwec);
      }
    }
    else
    {
      hr = E_OUTOFMEMORY;
    }
  }
  else
  {
    hr = E_POINTER;
  }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
WHTWin32ErrorCode::_Initialize(void)
{
  DEBUG_ENTER((
    DBG_INITIALIZE,
    rt_hresult,
    "WHTWin32ErrorCode::_Initialize",
    "this=%#x",
    this
    ));

  HRESULT   hr  = S_OK;
  WCHAR*    buf = NULL;
  ITypeLib* ptl = NULL;

  buf = new WCHAR[MAX_PATH];

  if( buf )
  {
    if( GetModuleFileName(g_hGlobalDllInstance, buf, MAX_PATH) )
    {
      hr = LoadTypeLib(buf, &ptl);

      if( SUCCEEDED(hr) )
      {
        hr = GetTypeInfoFromName(g_wszWHTWin32ErrorCodeObjectName, ptl, &m_pti);
      }
    }
    else
    {
      hr = E_FAIL;
    }
  }

  SAFERELEASE(ptl);
  SAFEDELETEBUF(buf);

  m_bIsException = _IsException(m_error);

  DEBUG_LEAVE(hr);
  return hr;
}


BOOL
WHTWin32ErrorCode::_IsException(int e)
{
  switch( e )
  {
    case EXCEPTION_ACCESS_VIOLATION         :
    case EXCEPTION_DATATYPE_MISALIGNMENT    :
    case EXCEPTION_BREAKPOINT               :
    case EXCEPTION_SINGLE_STEP              :
    case EXCEPTION_ARRAY_BOUNDS_EXCEEDED    :
    case EXCEPTION_FLT_DENORMAL_OPERAND     :
    case EXCEPTION_FLT_DIVIDE_BY_ZERO       :
    case EXCEPTION_FLT_INEXACT_RESULT       :
    case EXCEPTION_FLT_INVALID_OPERATION    :
    case EXCEPTION_FLT_OVERFLOW             :
    case EXCEPTION_FLT_STACK_CHECK          :
    case EXCEPTION_FLT_UNDERFLOW            :
    case EXCEPTION_INT_DIVIDE_BY_ZERO       :
    case EXCEPTION_INT_OVERFLOW             :
    case EXCEPTION_PRIV_INSTRUCTION         :
    case EXCEPTION_IN_PAGE_ERROR            :
    case EXCEPTION_ILLEGAL_INSTRUCTION      :
    case EXCEPTION_NONCONTINUABLE_EXCEPTION :
    case EXCEPTION_STACK_OVERFLOW           :
    case EXCEPTION_INVALID_DISPOSITION      :
    case EXCEPTION_GUARD_PAGE               :
    case EXCEPTION_INVALID_HANDLE           : return TRUE;

    default : return FALSE;
  }
}


//-----------------------------------------------------------------------------
// IUnknown methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
WHTWin32ErrorCode::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_REFCOUNT,
    rt_hresult,
    "WHTWin32ErrorCode::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

    if( ppv )
    {
      if(
        IsEqualIID(riid, IID_IUnknown)           ||
        IsEqualIID(riid, IID_IDispatch)          ||
        IsEqualIID(riid, IID_IWHTWin32ErrorCode)
        )
      {
        *ppv = static_cast<IWHTWin32ErrorCode*>(this);
      }
      else if( IsEqualIID(riid, IID_IProvideClassInfo) )
      {
        *ppv = static_cast<IProvideClassInfo*>(this);
      }
      else
      {
        *ppv = NULL;
        hr   = E_NOINTERFACE;
      }
    }
    else
    {
      hr = E_POINTER;
    }

    if( SUCCEEDED(hr) )
    {
      DEBUG_TRACE(REFCOUNT, ("returning %s pointer", MapIIDToString(riid)));
      reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    }

  DEBUG_LEAVE(hr);
  return hr;
}


ULONG
__stdcall
WHTWin32ErrorCode::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("WHTWin32ErrorCode", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
WHTWin32ErrorCode::Release(void)
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("WHTWin32ErrorCode", m_cRefs);

  if( m_cRefs == 0 )
  {
    DEBUG_FINALRELEASE("WHTWin32ErrorCode");
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IProvideClassInfo methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
WHTWin32ErrorCode::GetClassInfo(ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_WHTERROR,
    rt_hresult,
    "WHTWin32ErrorCode::GetClassInfo",
    "this=%#x; ppti=%#x",
    this,
    ppti
    ));

  HRESULT hr = S_OK;

    if( ppti )
    {
      m_pti->AddRef();
      *ppti = m_pti;
    }
    else
    {
      hr = E_POINTER;
    }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\whttptst\src\whterror\methods.cxx ===
#include "common.h"

//-----------------------------------------------------------------------------
// IWHTWin32ErrorCode methods
//-----------------------------------------------------------------------------
HRESULT
WHTWin32ErrorCode::get_ErrorCode(VARIANT* ErrorCode)
{
  DEBUG_ENTER((
    DBG_WHTERROR,
    rt_hresult,
    "WHTWin32ErrorCode::get_ErrorCode",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( ErrorCode )
    {
      DEBUG_TRACE(WHTERROR, ("error code: %d [%#x]", m_error, m_error));

      V_VT(ErrorCode) = VT_I4;
      V_I4(ErrorCode) = m_error;
    }
    else
    {
      hr = E_INVALIDARG;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
WHTWin32ErrorCode::get_ErrorString(VARIANT* ErrorString)
{
  DEBUG_ENTER((
    DBG_WHTERROR,
    rt_hresult,
    "WHTWin32ErrorCode::get_ErrorString",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( ErrorString )
    {
      DEBUG_TRACE(WHTERROR, ("error string: %s", MapErrorToString(m_error)));
      
      V_VT(ErrorString)   = VT_BSTR;
      V_BSTR(ErrorString) = __ansitobstr(MapErrorToString(m_error));
    }
    else
    {
      hr = E_INVALIDARG;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
WHTWin32ErrorCode::get_IsException(VARIANT* IsException)
{
  DEBUG_ENTER((
    DBG_WHTERROR,
    rt_hresult,
    "WHTWin32ErrorCode::get_IsException",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( IsException )
    {
      DEBUG_TRACE(WHTERROR, ("isexception: %s", TF(m_bIsException)));
      
      V_VT(IsException)   = VT_BOOL;
      V_BOOL(IsException) = m_bIsException ? VARIANT_TRUE : VARIANT_FALSE;
    }
    else
    {
      hr = E_INVALIDARG;
    }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\whttptst\src\winhttptest\classfactory.cxx ===
#include "common.h"

//-----------------------------------------------------------------------------
// ClassFactory methods
//-----------------------------------------------------------------------------
ClassFactory::ClassFactory():
  m_cRefs(0),
  m_cLocks(0)
{
  DEBUG_TRACE(FACTORY, ("ClassFactory [%#x] created", this));
}


ClassFactory::~ClassFactory()
{
  DEBUG_TRACE(FACTORY, ("ClassFactory [%#x] deleted", this));
}


HRESULT
ClassFactory::Create(REFIID clsid, REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_FACTORY,
    rt_hresult,
    "ClassFactory::Create",
    "clsid=%s; riid=%s; ppv=%#x",
    MapIIDToString(clsid),
    MapIIDToString(riid),
    ppv
    ));

  HRESULT     hr  = S_OK;
  PCLSFACTORY pcf = NULL;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

  if( !IsEqualIID(clsid, CLSID_WinHttpTest) )
  {
    hr   = CLASS_E_CLASSNOTAVAILABLE;
    *ppv = NULL;
    goto quit;
  }

  if( pcf = new CLSFACTORY )
  {
    hr = pcf->QueryInterface(riid, ppv);

    if( FAILED(hr) )
    {
      delete pcf;
    }
  }
  else
  {
    hr = E_OUTOFMEMORY;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// IUnknown methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
ClassFactory::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_FACTORY,
    rt_hresult,
    "ClassFactory::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

    if( ppv )
    {
      if( IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory) )
      {
        *ppv = static_cast<IClassFactory*>(this);
      }
      else
      {
        *ppv = NULL;
        hr   = E_NOINTERFACE;
      }
    }
    else
    {
      hr = E_POINTER;
    }

    if( SUCCEEDED(hr) )
    {
      DEBUG_TRACE(FACTORY, ("returning %s pointer", MapIIDToString(riid)));
      reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    }

  DEBUG_LEAVE(hr);
  return hr;
}


ULONG
__stdcall
ClassFactory::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("ClassFactory", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
ClassFactory::Release(void)
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("ClassFactory", m_cRefs);

  if( (m_cRefs == 0) && (m_cLocks == 0) )
  {
    DEBUG_FINALRELEASE("ClassFactory");
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IClassFactory methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
ClassFactory::CreateInstance(IUnknown* outer, REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_FACTORY,
    rt_hresult,
    "ClassFactory::CreateInstance",
    "this=%#x; outer=%#x; riid=%s; ppv=%#x",
    this,
    outer,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

  if( outer )
  {
    hr   = CLASS_E_NOAGGREGATION;
    *ppv = NULL;
    goto quit;
  }

  hr = WHTTPTST::Create(riid, ppv);

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
ClassFactory::LockServer(BOOL lock)
{
  HRESULT hr = S_OK;

  lock ? InterlockedIncrement(&m_cLocks) : InterlockedDecrement(&m_cLocks);

  DEBUG_TRACE(FACTORY, ("lock count now: %d", m_cLocks));

  if( (m_cRefs == 0) && (m_cLocks == 0) )
  {
    DEBUG_TRACE(FACTORY, ("ClassFactory [%#x]: final lock released!", this));
    delete this;
    return hr;
  }

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\whttptst\src\utils\type.cxx ===
#include "common.h"

// private
LPWSTR* ConvertDelimitedStringToArray(LPWSTR pwsz, LPWSTR delim);

//-----------------------------------------------------------------------------
// Type manipulation routines
//-----------------------------------------------------------------------------
HRESULT
ProcessWideStringParam(LPWSTR name, VARIANT* pvar, LPWSTR* ppwsz)
{
  DEBUG_ENTER((
    DBG_TYPE,
    rt_hresult,
    "ProcessWideStringParam",
    "name=%S; pvar=%#x; ppwsz=%#x",
    name,
    pvar,
    ppwsz
    ));
  
  HRESULT hr   = S_OK;
  LPWSTR  pwsz = NULL;

  if( !ppwsz )
  {
    hr = E_POINTER;
    goto quit;
  }

  DEBUG_TRACE(
    TYPE,
    ("variant type is %s", MapVariantTypeToString(pvar))
    );

  switch( V_VT(pvar) )
  {
    case VT_BSTR :
      {
        *ppwsz = V_BSTR(pvar);

        DEBUG_DATA_DUMP(TYPE, ("wide string", (LPBYTE) *ppwsz, (sizeof(WCHAR)*wcslen(*ppwsz)) ));

      }
      break;

    case VT_I4 :
      {
        hr = InvalidatePointer((POINTER) V_UI4(pvar), (void**) ppwsz);
      }
      break;

    default : hr = E_INVALIDARG;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}

HRESULT
ProcessWideMultiStringParam(LPWSTR name, VARIANT* pvar, LPWSTR** pppwsz)
{
  DEBUG_ENTER((
    DBG_TYPE,
    rt_hresult,
    "ProcessWideMultiStringParam",
    "name=%S; pvar=%#x; pppwsz=%#x",
    name,
    pvar,
    pppwsz
    ));

  HRESULT hr = S_OK;

  DEBUG_TRACE(
    TYPE,
    ("variant type is %s", MapVariantTypeToString(pvar))
    );

  switch( V_VT(pvar) )
  {
    case VT_BSTR :
      {
        *pppwsz = ConvertDelimitedStringToArray(V_BSTR(pvar), L";");
      }
      break;

    case VT_I4 :
      {
        LPVOID pv = NULL;

        hr      = InvalidatePointer((POINTER) V_UI4(pvar), (void**) &pv);
        *pppwsz = (LPWSTR*) pv;
      }
      break;

    default : hr = E_INVALIDARG;
  }

  DEBUG_LEAVE(hr);
  return hr;
}

HRESULT
ProcessBufferParam(LPWSTR name, VARIANT* pvar, LPVOID* ppv, LPBOOL pbDidAlloc)
{
  DEBUG_ENTER((
    DBG_TYPE,
    rt_hresult,
    "ProcessBufferParam",
    "name=%S; pvar=%#x; ppv=%#x; pbDidAlloc=%#x",
    name,
    pvar,
    ppv,
    pbDidAlloc
    ));

  HRESULT hr = S_OK;

  DEBUG_TRACE(
    TYPE,
    ("variant type is %s", MapVariantTypeToString(pvar))
    );

  switch( V_VT(pvar) )
  {
    case VT_BSTR :
      {
        *ppv        = V_BSTR(pvar);
        *pbDidAlloc = FALSE;
      }
      break;

    case VT_DISPATCH :
      {
        //
        // TODO: do in conjunction with the BufferObject work.
        //

        *ppv        = NULL;
        *pbDidAlloc = FALSE;
      }
      break;

    case VT_I4 :
      {
        hr          = InvalidatePointer((POINTER) V_UI4(pvar), (void**) ppv);
        *pbDidAlloc = FALSE;
      }
      break;

    default : hr = E_INVALIDARG;
  }

  DEBUG_LEAVE(hr);
  return hr;
}

LPWSTR*
ConvertDelimitedStringToArray(LPWSTR pwsz, LPWSTR delim)
{
  LPWSTR* arTokens = NULL;
  LPWSTR  wszTmp   = pwsz;
  DWORD   tokens   = 0L;

  if( pwsz )
  {
    while( 1 )
    {
      if( *wszTmp == *delim )
      {
        ++tokens;
      }
      else if( *wszTmp == NULL )
      {
        tokens += 2; // account for the single-token case and add a slot for NULL delimiter
        break;
      }
    
      ++wszTmp;
    }

    arTokens = new LPWSTR[tokens];

    if( arTokens )
    {
      --tokens; // correct for the null delimiter
      wszTmp = wcstok(pwsz, delim);

      for(DWORD n=0; n<tokens; n++)
      {
        DEBUG_DATA_DUMP(TYPE, ("delimited-string token", (LPBYTE) wszTmp, (sizeof(WCHAR)*wcslen(wszTmp)) ));

        arTokens[n] = wszTmp;
        wszTmp      = wcstok(NULL, delim);
      }
    }
  }

  return arTokens;
}

// disable warning for use of uninitialized variable
#pragma warning( disable : 4700 )

HRESULT
InvalidatePointer(POINTER pointer, void** ppv)
{
  DEBUG_ENTER((
    DBG_TYPE,
    rt_hresult,
    "InvalidatePointer",
    "pointer=%s; ppv=%#x",
    MapPointerTypeToString(pointer),
    ppv
    ));
  
  HRESULT hr = S_OK;
  LPVOID  pv;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

  *ppv = NULL;

  switch( pointer )
  {
    case NULL_PTR   : break;
    case BAD_PTR    : *ppv = (LPVOID) GetBadPointer();   break;
    case FREE_PTR   : *ppv = (LPVOID) GetFreedPointer(); break;
    case UNINIT_PTR : *ppv = pv;                         break;
    case NEGONE_PTR : *ppv = (LPVOID) 0xFFFFFFFF;        break;

    default : hr = E_INVALIDARG;
  }

  DEBUG_TRACE(TYPE, ("returning pointer value 0x%0.8x", *ppv));

quit:

  DEBUG_LEAVE(hr);
  return hr;
}

#pragma warning( default : 4700 )

DWORD_PTR
GetBadPointer(void)
{
  SYSTEM_INFO si;

  GetSystemInfo(&si);
  return ((DWORD_PTR) si.lpMaximumApplicationAddress)+1;
}

DWORD_PTR
GetFreedPointer(void)
{
  LPBYTE pb = NULL;

  pb = new BYTE;
  delete pb;
  return (DWORD_PTR) pb;
}

void
MemsetByFlag(LPVOID pv, DWORD size, MEMSETFLAG mf)
{
  int ch = 0x00;

  switch( mf )
  {
    case INIT_SMILEY  : ch = 0x02; break;
    case INIT_HEXFF   : ch = 0xFF; break;
    case INIT_GARBAGE : return;

    case INIT_NULL    :
    default           : ch = 0x00;
  }

  memset(pv, ch, size);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\whttptst\src\whterror\dispatch.cxx ===
#include "common.h"


//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
DISPIDTABLEENTRY g_WHTWin32ErrorCodeDisptable[] =
{
  0x0010c129,   DISPID_WIN32ERRORCODE_ERRORCODE,    L"errorcode",
  0x0043266b,   DISPID_WIN32ERRORCODE_ERRORSTRING,  L"errorstring",
  0x004372a8,   DISPID_WIN32ERRORCODE_ISEXCEPTION,  L"isexception"
};

DWORD g_cWHTWin32ErrorCodeDisptable = (sizeof(g_WHTWin32ErrorCodeDisptable) / sizeof(DISPIDTABLEENTRY));


//-----------------------------------------------------------------------------
// IDispatch
//-----------------------------------------------------------------------------
HRESULT
__stdcall
WHTWin32ErrorCode::GetTypeInfoCount(UINT* pctinfo)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "WHTWin32ErrorCode::GetTypeInfoCount",
    "this=%#x; pctinfo=%#x",
    this,
    pctinfo
    ));

  HRESULT hr = S_OK;

    if( !pctinfo )
    {
      hr = E_POINTER;
    }
    else
    {
      *pctinfo = 1;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTWin32ErrorCode::GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "WHTWin32ErrorCode::GetTypeInfo",
    "this=%#x; index=%#x; lcid=%#x; ppti=%#x",
    this,
    index,
    lcid,
    ppti
    ));

  HRESULT hr   = S_OK;

  if( !ppti )
  {
    hr = E_POINTER;
  }
  else
  {
    if( index != 0 )
    {
      hr    = DISP_E_BADINDEX;
      *ppti = NULL;
    }
    else
    {
      hr = GetClassInfo(ppti);
    }
  }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTWin32ErrorCode::GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "WHTWin32ErrorCode::GetIDsOfNames",
    "this=%#x; riid=%s; arNames=%#x; cNames=%d; lcid=%#x; arDispId=%#x",
    this,
    MapIIDToString(riid),
    arNames,
    cNames,
    lcid,
    arDispId
    ));

  HRESULT hr = S_OK;
  UINT    n  = 0L;

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  while( n < cNames )
  {
    arDispId[n] = GetDispidFromName(g_WHTWin32ErrorCodeDisptable, g_cWHTWin32ErrorCodeDisptable, arNames[n]);
    ++n;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTWin32ErrorCode::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "WHTWin32ErrorCode::Invoke",
    "this=%#x; dispid=%s; riid=%s; lcid=%#x; flags=%#x; pdp=%#x; pvr=%#x; pei=%#x; pae=%#x",
    this,
    MapDispidToString(dispid),
    MapIIDToString(riid),
    lcid,
    flags,
    pdp, pvr,
    pei, pae
    ));

  HRESULT hr = S_OK;

  hr = ValidateDispatchArgs(riid, pdp, pvr, pae);

    if( FAILED(hr) )
      goto quit;

  switch( dispid )
  {
    case DISPID_WIN32ERRORCODE_ERRORCODE :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 0, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = get_ErrorCode(pvr);
          }
        }
      }
      break;

    case DISPID_WIN32ERRORCODE_ERRORSTRING :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 0, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = get_ErrorString(pvr);
          }
        }
      }
      break;

    case DISPID_WIN32ERRORCODE_ISEXCEPTION :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 0, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = get_IsException(pvr);
          }
        }
      }
      break;

    default : hr = DISP_E_MEMBERNOTFOUND;
  }

quit:

  if( FAILED(hr) )
  {
    hr = HandleDispatchError(L"WHTWin32ErrorCode", pei, hr);
  }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\whttptst\src\utils\utils.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    utils.cxx

Abstract:

    Utility functions.
    
Author:

    Paul M Midgen (pmidge) 12-October-2000


Revision History:

    12-October-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

extern PHANDLEMAP g_pGlobalHandleMap;

//-----------------------------------------------------------------------------
// exception handling
//-----------------------------------------------------------------------------
int exception_filter(PEXCEPTION_POINTERS pep)
{
  int e = pep->ExceptionRecord->ExceptionCode;

  DEBUG_TRACE(HELPER, ("*************** EXCEPTION CAUGHT ***************"));
  DEBUG_TRACE(HELPER, ("type: 0x%0.8x [%s]", e, MapErrorToString(e)));
  DEBUG_TRACE(HELPER, ("eip : 0x%0.8x", pep->ExceptionRecord->ExceptionAddress));

  if( pep->ExceptionRecord->ExceptionCode == EXCEPTION_ACCESS_VIOLATION )
  {
    DEBUG_TRACE(
      HELPER,
      ("mode: %s", pep->ExceptionRecord->ExceptionInformation[0] ? "write" : "read")
      );

    DEBUG_TRACE(
      HELPER,
      ("addr: 0x%0.8x", pep->ExceptionRecord->ExceptionInformation[1])
      );
  }

  DEBUG_TRACE(HELPER, ("************************************************"));

  return EXCEPTION_EXECUTE_HANDLER;
}

//-----------------------------------------------------------------------------
// file retrieval
//-----------------------------------------------------------------------------
HANDLE
__OpenFile(LPCWSTR path, DWORD mode, BOOL* bReadOnly)
{
  HANDLE hFile = INVALID_HANDLE_VALUE;
  DWORD  flags = GENERIC_READ | GENERIC_WRITE;

retry:

  hFile = CreateFile(
            path,
            flags,
            FILE_SHARE_READ,
            NULL,
            mode,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );

  if( hFile == INVALID_HANDLE_VALUE )
  {
    if( GetLastError() == ERROR_ACCESS_DENIED )
    {
      if( flags == (GENERIC_READ | GENERIC_WRITE) )
      {
        DEBUG_TRACE(UTILS, ("read/write open attempt failed, retrying for read-only access"));

        flags      = GENERIC_READ;
        *bReadOnly = TRUE;
        goto retry;
      }
    }

    DEBUG_TRACE(UTILS, ("error opening %S: %s", path, MapErrorToString(GetLastError())));
  }
  else
  {
    DEBUG_TRACE(UTILS, ("file opened"));
  }

  return hFile;
}

//-----------------------------------------------------------------------------
// general utility functions
//-----------------------------------------------------------------------------
HRESULT
ManageCallbackForHandle(HINTERNET hInet, IDispatch** ppCallback, DWORD dwAction)
{
  DEBUG_ENTER((
    DBG_HELPER,
    rt_hresult,
    "ManageCallbackForHandle",
    "hInet=%#x; ppCallback=%#x; dwAction=%#x",
    hInet,
    ppCallback,
    dwAction
    ));

  HRESULT hr    = S_OK;
  DWORD   error = ERROR_SUCCESS;

  if( !ppCallback && (dwAction != CALLBACK_HANDLE_UNMAP) )
  {
    hr = E_POINTER;
    goto quit;
  }

  DEBUG_TRACE(HELPER, ("handle %#x is a %s", hInet, MapWinHttpHandleType(hInet)));

    switch( dwAction )
    {
      case CALLBACK_HANDLE_MAP :
        {
          error = g_pGlobalHandleMap->Insert(hInet, (void*) *ppCallback);

          if( (error == ERROR_SUCCESS) || (error == ERROR_DUP_NAME) )
          {
            DEBUG_TRACE(HELPER, ("handle %#x mapped to callback %#x", hInet, *ppCallback));
            (*ppCallback)->AddRef();
          }
          else
          {
            DEBUG_TRACE(HELPER, ("failed to map handle"));
            hr = E_FAIL;
          }
        }
        break;

      case CALLBACK_HANDLE_UNMAP :
        {
          DEBUG_TRACE(HELPER, ("deleting callback mapping for handle %#x", hInet));
          g_pGlobalHandleMap->Delete(hInet, NULL);
        }
        break;

      case CALLBACK_HANDLE_GET :
        {
          if( g_pGlobalHandleMap->Get(hInet, (void**) ppCallback) != ERROR_SUCCESS )
          {
            DEBUG_TRACE(HELPER, ("no mapping found for handle"));

            *ppCallback = NULL;
            hr          = E_FAIL;
          }
        }
        break;

      default : hr = E_INVALIDARG;
    }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}

HRESULT
GetTypeInfoFromName(LPCOLESTR name, ITypeLib* ptl, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_UTILS,
    rt_hresult,
    "GetTypeInfoFromName",
    "name=%.16S; ptl=%#x; ppti=%#x",
    name,
    ptl,
    ppti
    ));

  HRESULT  hr     = S_OK;
  BOOL     bFound = FALSE;
  USHORT   cf     = 1L;
  ULONG    hash   = 0L;
  LONG     id     = 0L;
  LPOLESTR pstr   = NULL;

  if( !name || ! ptl )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !ppti )
  {
    hr = E_POINTER;
    goto quit;
  }

  *ppti = NULL;
  pstr  = __wstrdup(name);

    ptl->IsName(pstr, 0L, &bFound);

      if( !bFound )
      {
        hr = TYPE_E_ELEMENTNOTFOUND;
        goto quit;
      }

    hash = LHashValOfNameSys(
             SYS_WIN32,
             MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), SORT_DEFAULT),
             pstr
             );

    hr = ptl->FindName(pstr, hash, ppti, &id, &cf);

    DEBUG_TRACE(UTILS, ("find name: pti=%#x; cf=%d", *ppti, cf));

quit:

  SAFEDELETEBUF(pstr);

  DEBUG_LEAVE(hr);
  return hr;
}

DISPID
GetDispidFromName(PDISPIDTABLEENTRY pdt, DWORD cEntries, LPWSTR name)
{
  DWORD  n      = 0L;
  DWORD  hash   = GetHash(name);
  DISPID dispid = DISPID_UNKNOWN;

  while( n < cEntries )
  {
    if( pdt[n].hash != hash )
    {
      ++n;
    }
    else
    {
      dispid = pdt[n].dispid;
      break;
    }
  }

  DEBUG_TRACE(DISPATCH, ("hash %#x is %s", hash, MapDispidToString(dispid)));
  return dispid;
}

void
AddRichErrorInfo(EXCEPINFO* pei, LPWSTR source, LPWSTR description, HRESULT error)
{
  if( pei )
  {
    pei->bstrSource      = __widetobstr((source ? source : L"unknown source"));
    pei->bstrDescription = __widetobstr((description ? description : L"no description"));
    pei->scode           = error;
  }
}

DWORD
GetHash(LPWSTR name)
{
  DWORD hash   = 0L;
  DWORD n      = 0L;
  DWORD len    = 0L;
  LPSTR string = NULL;

  string = __widetoansi(name);

  if( string )
  {
    _strlwr(string);

    for(n=0, len=strlen(string); n<=len; n++)
    {
      hash += __toascii(string[len-n]) * ((10<<n)^n);
    }

    DEBUG_TRACE(DISPATCH, ("name=%s; hash=%#x", string, hash));
  }

  SAFEDELETEBUF(string);
  return hash;
}

DWORD
GetHash(LPSTR name)
{
  DWORD hash   = 0L;
  DWORD n      = 0L;
  DWORD len    = 0L;
  LPSTR string = NULL;

  string = __strdup(name);

  if( string )
  {
    _strlwr(string);

    for(n=0, len=strlen(string); n<=len; n++)
    {
      hash += __toascii(string[len-n]) * ((10<<n)^n);
    }

    DEBUG_TRACE(DISPATCH, ("name=%s; hash=%#x", string, hash));
  }

  SAFEDELETEBUF(string);
  return hash;
}

HRESULT
ValidateDispatchArgs(REFIID riid, DISPPARAMS* pdp, VARIANT* pvr, UINT* pae)
{
  HRESULT hr = S_OK;

    if( !IsEqualIID(riid, IID_NULL) )
    {
      hr = DISP_E_UNKNOWNINTERFACE;
      goto quit;
    }

    if( !pdp )
    {
      hr = E_INVALIDARG;
      goto quit;
    }

    if( pae )
    {
      *pae = 0;
    }

    if( pvr )
    {
      VariantInit(pvr);
    }

quit:

  return hr;
}

HRESULT
ValidateInvokeFlags(WORD flags, WORD accesstype, BOOL bMethod)
{
  HRESULT hr = S_OK;

    if( (flags & ~(DISPATCH_METHOD | DISPATCH_PROPERTYGET | DISPATCH_PROPERTYPUT)) )
    {
      hr = E_INVALIDARG;
    }
    else
    {
      if( !bMethod )
      {
        if( flags & DISPATCH_METHOD )
        {
          hr = E_NOINTERFACE;
        }
        else
        {
          if( (flags & DISPATCH_PROPERTYPUT) && !(accesstype & DISPATCH_PROPERTYPUT) )
          {
            hr = E_ACCESSDENIED;
          }
          else
          {
            if( !(flags & accesstype) )
            {
              hr = E_FAIL;
            }
          }
        }
      }
      else
      {
        if( flags & ~(DISPATCH_METHOD | DISPATCH_PROPERTYGET) )
        {
          hr = E_NOINTERFACE;
        }
      }
    }

  return hr;
}

HRESULT
ValidateArgCount(DISPPARAMS* pdp, DWORD needed, BOOL bHasOptionalArgs, DWORD optional)
{
  HRESULT hr = S_OK;

    if( bHasOptionalArgs )
    {
      if( (pdp->cArgs > needed+optional) || (pdp->cArgs < needed) )
      {
        hr = DISP_E_BADPARAMCOUNT;
      }
    }
    else
    {
      if( (!needed && pdp->cArgs) || (needed < pdp->cArgs) )
      {
        hr = DISP_E_BADPARAMCOUNT;
      }
      else
      {
        hr = (pdp->cArgs == needed) ? S_OK : DISP_E_PARAMNOTOPTIONAL;
      }
    }

  return hr;
}

HRESULT
HandleDispatchError(LPWSTR id, EXCEPINFO* pei, HRESULT hr)
{
  LPWSTR msg = NULL;

  switch( hr )
  {
    case E_POINTER      : msg = L"a return pointer parameter was missing";                         break;
    case E_ACCESSDENIED : msg = L"an attempt to modify a property failed because it is read-only"; break;
    case E_FAIL         : msg = L"an unhandled error occurred";                                    break;
    case E_INVALIDARG   : msg = L"an argument passed to a property or method was invalid";         break;
    case E_NOINTERFACE  : msg = L"a property or method was accessed incorrectly";                  break;
    default             : return hr;
  }

  AddRichErrorInfo(pei, id, msg, hr);

  return DISP_E_EXCEPTION;
}

//-----------------------------------------------------------------------------
// string & type manipulation
//-----------------------------------------------------------------------------
char*
__strdup(const char* src)
{
  int   n   = 0;
  char* dup = NULL;

  if( src )
  {
    n   = strlen(src)+1;
    dup = new char[n];
    strncpy(dup, src, n);
  }

  return dup;
}

char*
__strndup(const char* src, int len)
{
  char* dup = NULL;

  if( src )
  {
    dup      = new char[len+1];
    dup[len] = '\0';
    strncpy(dup, src, len);
  }

  return dup;
}

WCHAR*
__wstrdup(const WCHAR* src)
{
  int    n   = 0;
  WCHAR* dup = NULL;

  if( src )
  {
    n   = wcslen(src)+1;
    dup = new WCHAR[n];
    wcsncpy(dup, src, n);
  }

  return dup;
}

WCHAR*
__wstrndup(const WCHAR* src, int len)
{
  WCHAR* dup = NULL;

  if( src )
  {
    dup      = new WCHAR[len+1];
    dup[len] = L'\0';
    wcsncpy(dup, src, len);
  }

  return dup;
}

WCHAR*
__ansitowide(const char* psz)
{
  WCHAR* wide = NULL;
  int    len  = 0L;

  if( psz )
  {
    len  = strlen(psz);

    if( len )
    {
      ++len;
      wide = new WCHAR[len];

      MultiByteToWideChar(
        CP_ACP,
        0,
        psz,
        len,
        wide,
        len
        );
    }
  }

  return wide;
}

CHAR*
__widetoansi(const WCHAR* pwsz)
{
  CHAR* ansi = NULL;
  int   len  = 0L;
  BOOL  def  = FALSE;

  if( pwsz )
  {
    len  = wcslen(pwsz);

    if( len )
    {
      ++len;
      ansi = new CHAR[len];

      WideCharToMultiByte(
        CP_ACP,
        0,
        pwsz,
        len,
        ansi,
        len,
        "?",
        &def
        );
    }
  }

  return ansi;
}

BSTR
__ansitobstr(LPCSTR src)
{
  BSTR   ret = NULL;
  LPWSTR wsz = NULL;

  if( src )
  {
    wsz = __ansitowide(src);
    ret = SysAllocString(wsz);
    SAFEDELETEBUF(wsz);
  }

  return ret;
}

BSTR
__widetobstr(LPCWSTR wsrc)
{
  return (wsrc ? SysAllocString(wsrc) : NULL);
}

BOOL
__isempty(VARIANT var)
{
  BOOL isempty = FALSE;

  if(
      ((V_VT(&var) == VT_EMPTY) || (V_VT(&var) == VT_NULL) || (V_VT(&var) == VT_ERROR)) ||
      ((V_VT(&var) == VT_BSTR) && (SysStringLen(V_BSTR(&var)) == 0))
    )
  {
    isempty = TRUE;
  }

  return isempty;
}

// private
char hex2char(char* hex)
{
  register char digit;
  
    digit  = (hex[0] >= 'A' ? ((hex[0] & 0xdf) - 'A')+10 : (hex[0] - '0'));
    digit *= 16;
    digit += (hex[1] >= 'A' ? ((hex[1] & 0xdf) - 'A')+10 : (hex[1] - '0'));

  return(digit);
}

char*
__unescape(char* str)
{
  register int x;
  register int y;
  char*        str2;

  str2 = __strdup(str);

  if( str2 )
  {    
    for(x=0, y=0; str2[y]; ++x, ++y)
    {
      if((str2[x] = str2[y]) == '%')
      {
        str2[x] = hex2char(&str2[y+1]);
        y += 2;
      }
    }
    
    str2[x] = '\0';
  }

  return str2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\whttptst\src\winhttptest\dispatch.cxx ===
#include "common.h"

//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
DISPIDTABLEENTRY g_WinHttpTestDisptable[] =
{
  0x0046cf6d,   DISPID_WINHTTPTEST_OPEN,                    L"winhttpopen",
  0x0235c801,   DISPID_WINHTTPTEST_CONNECT,                 L"winhttpconnect",
  0x235df173,   DISPID_WINHTTPTEST_OPENREQUEST,             L"winhttpopenrequest",
  0x235dc932,   DISPID_WINHTTPTEST_SENDREQUEST,             L"winhttpsendrequest",
  0x35c58a48,   DISPID_WINHTTPTEST_RECEIVERESPONSE,         L"winhttpreceiveresponse",
  0x235a3600,   DISPID_WINHTTPTEST_CLOSEHANDLE,             L"winhttpclosehandle",
  0x046ba62e,   DISPID_WINHTTPTEST_READDATA,                L"winhttpreaddata",
  0x08d85ebe,   DISPID_WINHTTPTEST_WRITEDATA,               L"winhttpwritedata",
  0xafa429a3,   DISPID_WINHTTPTEST_QUERYDATAAVAILABLE,      L"winhttpquerydataavailable",
  0x235fbc85,   DISPID_WINHTTPTEST_QUERYOPTION,             L"winhttpqueryoption",
  0x08d7d1ef,   DISPID_WINHTTPTEST_SETOPTION,               L"winhttpsetoption",
  0x235ebb0a,   DISPID_WINHTTPTEST_SETTIMEOUTS,             L"winhttpsettimeouts",
  0xd5d831c6,   DISPID_WINHTTPTEST_ADDREQUESTHEADERS,       L"winhttpaddrequestheaders",
  0x1aef45ab,   DISPID_WINHTTPTEST_SETCREDENTIALS,          L"winhttpsetcredentials",
  0x6bec0214,   DISPID_WINHTTPTEST_QUERYAUTHSCHEMES,        L"winhttpqueryauthschemes",
  0x46bee2b5,   DISPID_WINHTTPTEST_QUERYHEADERS,            L"winhttpqueryheaders",
  0xaf28b192,   DISPID_WINHTTPTEST_TIMEFROMSYSTEMTIME,      L"winhttptimefromsystemtime",
  0x6bd39d0c,   DISPID_WINHTTPTEST_TIMETOSYSTEMTIME,        L"winhttptimetosystemtime",
  0x046b5b57,   DISPID_WINHTTPTEST_CRACKURL,                L"winhttpcrackurl",
  0x08d6a4ba,   DISPID_WINHTTPTEST_CREATEURL,               L"winhttpcreateurl",
  0xd7a6f0d4,   DISPID_WINHTTPTEST_SETSTATUSCALLBACK,       L"winhttpsetstatuscallback",
  0x04129fd7,   DISPID_WINHTTPTEST_HELPER_GETBUFFEROBJECT,  L"getbufferobject",
  0x083d2b72,   DISPID_WINHTTPTEST_HELPER_GETURLCOMPONENTS, L"geturlcomponents",
  0x01087c3b,   DISPID_WINHTTPTEST_HELPER_GETSYSTEMTIME,    L"getsystemtime",
  0x0082cf2b,   DISPID_WINHTTPTEST_HELPER_GETLASTERROR,     L"getlasterror"
};

DWORD g_cWinHttpTestDisptable = (sizeof(g_WinHttpTestDisptable) / sizeof(DISPIDTABLEENTRY));

//-----------------------------------------------------------------------------
// IDispatch
//-----------------------------------------------------------------------------
HRESULT
__stdcall
WinHttpTest::GetTypeInfoCount(UINT* pctinfo)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "WinHttpTest::GetTypeInfoCount",
    "this=%#x; pctinfo=%#x",
    this,
    pctinfo
    ));

  HRESULT hr = S_OK;

    if( !pctinfo )
    {
      hr = E_POINTER;
    }
    else
    {
      *pctinfo = 1;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WinHttpTest::GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "WinHttpTest::GetTypeInfo",
    "this=%#x; index=%#x; lcid=%#x; ppti=%#x",
    this,
    index,
    lcid,
    ppti
    ));

  HRESULT hr   = S_OK;

  if( !ppti )
  {
    hr = E_POINTER;
  }
  else
  {
    if( index != 0 )
    {
      hr    = DISP_E_BADINDEX;
      *ppti = NULL;
    }
    else
    {
      hr = GetClassInfo(ppti);
    }
  }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WinHttpTest::GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "WinHttpTest::GetIDsOfNames",
    "this=%#x; riid=%s; arNames=%#x; cNames=%d; lcid=%#x; arDispId=%#x",
    this,
    MapIIDToString(riid),
    arNames,
    cNames,
    lcid,
    arDispId
    ));

  HRESULT hr = S_OK;
  UINT    n  = 0L;

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  while( n < cNames )
  {
    arDispId[n] = GetDispidFromName(g_WinHttpTestDisptable, g_cWinHttpTestDisptable, arNames[n]);
    ++n;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WinHttpTest::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "WinHttpTest::Invoke",
    "this=%#x; dispid=%s; riid=%s; lcid=%#x; flags=%#x; pdp=%#x; pvr=%#x; pei=%#x; pae=%#x",
    this,
    MapDispidToString(dispid),
    MapIIDToString(riid),
    lcid,
    flags,
    pdp, pvr,
    pei, pae
    ));

  HRESULT hr = S_OK;

  hr = ValidateDispatchArgs(riid, pdp, pvr, pae);

    if( FAILED(hr) )
      goto quit;

  switch( dispid )
  {
    case DISPID_WINHTTPTEST_OPEN :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 5, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = WinHttpOpen(
                   pdp->rgvarg[4],
                   pdp->rgvarg[3],
                   pdp->rgvarg[2],
                   pdp->rgvarg[1],
                   pdp->rgvarg[0],
                   pvr
                   );
          }
        }
      }
      break;

    case DISPID_WINHTTPTEST_CONNECT :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 4, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = WinHttpConnect(
                   pdp->rgvarg[3],
                   pdp->rgvarg[2],
                   pdp->rgvarg[1],
                   pdp->rgvarg[0],
                   pvr
                   );
          }
        }
      }
      break;

    case DISPID_WINHTTPTEST_OPENREQUEST :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 7, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = WinHttpOpenRequest(
                   pdp->rgvarg[6],
                   pdp->rgvarg[5],
                   pdp->rgvarg[4],
                   pdp->rgvarg[3],
                   pdp->rgvarg[2],
                   pdp->rgvarg[1],
                   pdp->rgvarg[0],
                   pvr
                   );
          }
        }
      }
      break;

    case DISPID_WINHTTPTEST_SENDREQUEST :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 7, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = WinHttpSendRequest(
                   pdp->rgvarg[6],
                   pdp->rgvarg[5],
                   pdp->rgvarg[4],
                   pdp->rgvarg[3],
                   pdp->rgvarg[2],
                   pdp->rgvarg[1],
                   pdp->rgvarg[0],
                   pvr
                   );
          }
        }
      }
      break;

    case DISPID_WINHTTPTEST_CLOSEHANDLE :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = WinHttpCloseHandle(
                   pdp->rgvarg[0],
                   pvr
                   );
          }
        }
      }
      break;

    case DISPID_WINHTTPTEST_SETSTATUSCALLBACK :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 4, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = WinHttpSetStatusCallback(
                   pdp->rgvarg[3],
                   pdp->rgvarg[2],
                   pdp->rgvarg[1],
                   pdp->rgvarg[0],
                   pvr
                   );
          }
        }
      }
      break;

    case DISPID_WINHTTPTEST_HELPER_GETURLCOMPONENTS :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = HelperGetUrlComponents(
                   pdp->rgvarg[0],
                   pvr
                   );
          }
        }
      }
      break;

    case DISPID_WINHTTPTEST_HELPER_GETLASTERROR :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 0, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = HelperGetLastError(pvr);
          }
        }
      }
      break;
    
    default : hr = DISP_E_MEMBERNOTFOUND;
  }

quit:

  if( FAILED(hr) )
  {
    hr = HandleDispatchError(L"WinHttpTest", pei, hr);
  }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\api\certcach.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    certcach.cxx

Abstract:

    Contains class implementation for certificate cache object.
    This object will hold various Certificate entries.

    Contents:
        SECURITY_CACHE_LIST_ENTRY::SECURITY_CACHE_LIST_ENTRY
        SECURITY_CACHE_LIST_ENTRY::~SECURITY_CACHE_LIST_ENTRY
        SECURITY_CACHE_LIST_ENTRY::AddRef
        SECURITY_CACHE_LIST_ENTRY::Release
        SECURITY_CACHE_LIST_ENTRY::Clear
        SECURITY_CACHE_LIST::Find
        SECURITY_CACHE_LIST::Add
        SECURITY_CACHE_LIST::ClearList

    TODO:  Add Cert validation.  What if Cert is given but different?

Author:

    Arthur L Bierer (arthurbi) 20-Apr-1996

Revision History:

    20-Apr-1996 arthurbi
        Created

--*/
#include <wininetp.h>

//
// private manifests
//

#define MAX_CERT_CACHE_CERTS    16

//
// private types
//

//
// SECURITY_CACHE_LIST_ENTRY member functions
//


SECURITY_CACHE_LIST_ENTRY::SECURITY_CACHE_LIST_ENTRY(
    IN LPSTR lpszHostName
    )

/*++

Routine Description:

    SECURITY_CACHE_LIST_ENTRY constructor. Create object; don't add it to list

Arguments:

    lpszHostName    - name of host for which this cache entry created

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "SECURITY_CACHE_LIST_ENTRY::SECURITY_CACHE_LIST_ENTRY",
                 "%q",
                 lpszHostName
                 ));

#if INET_DEBUG
    _List.Flink = _List.Blink = NULL;
#endif
    _cRef = 1;
    _fInCache = FALSE;
    _ServerName = lpszHostName;
    ZeroMemory(&_CertInfo, sizeof(_CertInfo));
    _dwSecurityFlags = 0;
    _dwStatusFlags = 0;
    _pCertContextArray = NULL;

#if INET_DEBUG
    m_Signature = 0x454c4353;   // 'SCLE'
#endif

    DEBUG_LEAVE(0);
}


SECURITY_CACHE_LIST_ENTRY::~SECURITY_CACHE_LIST_ENTRY()

/*++

Routine Description:

    SECURITY_CACHE_LIST_ENTRY destructor.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "~SECURITY_CACHE_LIST_ENTRY",
                 "{%#x [%q]}",
                 this,
                 _ServerName.StringAddress()
                 ));

    INET_ASSERT((_List.Flink == NULL) && (_List.Blink == NULL));

    Clear();

    DEBUG_LEAVE(0);
}


LONG
SECURITY_CACHE_LIST_ENTRY::AddRef(
    VOID
    )

/*++

Routine Description:

    Increment reference count of SECURITY_CACHE_LIST_ENTRY

Arguments:

    None.

Return Value:

    LONG    - reference count after increment

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Int,
                 "SECURITY_CACHE_LIST_ENTRY::AddRef",
                 "{%#x [%q, %d]}",
                 this,
                 _ServerName.StringAddress(),
                 _cRef
                 ));

    InterlockedIncrement(&_cRef);

    DEBUG_LEAVE(_cRef);

    return _cRef;
}


LONG
SECURITY_CACHE_LIST_ENTRY::Release(
    VOID
    )

/*++

Routine Description:

    Decrement reference count and destroy object if (<=) zero

Arguments:

    None.

Return Value:

    LONG    - reference count after decrement

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Int,
                 "SECURITY_CACHE_LIST_ENTRY::Release",
                 "{%q [%d]}",
                 _ServerName.StringAddress(),
                 _cRef
                 ));

    LONG cRet;

    if (0 >= (cRet = InterlockedDecrement(&_cRef))) {
        delete this;
    }

    DEBUG_LEAVE(cRet);

    return cRet;
}


VOID
SECURITY_CACHE_LIST_ENTRY::Clear()

/*++

Routine Description:

    Clear out SECURITY_CACHE_LIST_ENTRY

Arguments:

    Clear   -

Return Value:

    None.

--*/

{
    if (_CertInfo.pCertificate != NULL)
    {
        SAFE_WRAP_REVERT_USER_VOID(CertFreeCertificateContext, (_CertInfo.pCertificate));
        _CertInfo.pCertificate = NULL;
    }

    ZeroMemory(&_CertInfo, sizeof(_CertInfo));
    _CertInfo.dwSize = sizeof(_CertInfo);

    _dwSecurityFlags = 0;
    _dwStatusFlags = 0;
    _ServerName = NULL;
    if( _pCertContextArray )
    {
        delete _pCertContextArray;
        _pCertContextArray = NULL;
    }
}

//
// SECURITY_CACHE_LIST member functions
//


VOID
SECURITY_CACHE_LIST::ClearList(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "SECURITY_CACHE_LIST::ClearList",
                 NULL
                 ));

    if (!LockSerializedList(&_List))
    {
        DEBUG_PRINT(OBJECTS,
                    ERROR,
                    ("Failed to obtain lock -- SECURITY_CACHE_LIST potentially leaked\n"
                    ));
        goto quit;
    }

    while (!IsSerializedListEmpty(&_List)) {

        SECURITY_CACHE_LIST_ENTRY * CacheEntry;

        //
        // remove the PROXY_SERVER_LIST_ENTRY at the head of the serialized
        // list
        //

        LPVOID entry = SlDequeueHead(&_List);

        //
        // entry should not be NULL - IsSerializedListEmpty() told us we
        // could expect something
        //

        INET_ASSERT(entry != NULL);

        //
        // get the address of the object (should be the same as entry) and
        // delete it
        //

        CacheEntry = CONTAINING_RECORD(entry, SECURITY_CACHE_LIST_ENTRY, _List);

        DEBUG_PRINT(OBJECTS,
                    INFO,
                    ("releasing %q (%d)\n",
                    CacheEntry->_ServerName.StringAddress(),
                    CacheEntry->_cRef
                    ));

        CacheEntry->Release();
    }

    UnlockSerializedList(&_List);

quit:
    DEBUG_LEAVE(0);
}


DWORD
SECURITY_CACHE_LIST::Add(
    IN SECURITY_CACHE_LIST_ENTRY * entry
    )

/*++

Routine Description:

    Adds a CertInfo Structure to the list front of the list.

Arguments:

    lpszHost    - Hostname to add.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "SECURITY_CACHE_LIST::Add",
                 "%#x [%q, %d]",
                 entry,
                 entry ? entry->_ServerName.StringAddress() : "",
                 entry ? entry->_cRef : 0
                 ));

    DWORD error = ERROR_SUCCESS;

    INET_ASSERT(entry != NULL);

    if (entry != NULL) {
        if (LockSerializedList(&_List))
        {

            //
            // If we've grown too much, nuke the oldest one.
            //

            if (ElementsOnSerializedList(&_List) >= MAX_CERT_CACHE_CERTS) {

                SECURITY_CACHE_LIST_ENTRY *pOld;
                LPVOID old_entry = SlDequeueTail(&_List);

                INET_ASSERT(old_entry != NULL);

                pOld = CONTAINING_RECORD(old_entry, SECURITY_CACHE_LIST_ENTRY, _List);

                //
                // entry should not be NULL - IsSerializedListEmpty() told us we
                // could expect something
                //

                pOld->_fInCache = FALSE;

                //
                // Clean Our old object, and reinstatiate with a new name.
                //

                pOld->Release();
            }
            if (InsertAtHeadOfSerializedList(&_List, &entry->_List)) {
                entry->AddRef();
                entry->_fInCache = TRUE;
            }
            UnlockSerializedList(&_List);
        }
        else
            error = ERROR_NOT_ENOUGH_MEMORY;
    }

    DEBUG_LEAVE(error);

    return error;
}


SECURITY_CACHE_LIST_ENTRY *
SECURITY_CACHE_LIST::Find(
    IN LPSTR lpszHost
    )

/*++

Routine Description:

    Searches the linked list for the Cert, and returns
    the found entry, or NULL if not found.

Arguments:

    lpszHost    - Hostname to search on.

Return Value:

    CERT_CACHE_LIST_ENTRY *
        Success - Pointer to found entry.

        Failure - NULL, not found.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Pointer,
                 "SECURITY_CACHE_LIST::Find",
                 "%q",
                 lpszHost
                 ));

    SECURITY_CACHE_LIST_ENTRY * info = NULL;

    //
    // BUGBUG need to validate against Server Certifcate on every
    //  connection, this Find only validates by Hostname.
    //  What about DNS spoofing?  Won't we be hosed?
    //

    //
    // TODO if found, need to push to front of list.
    //

    if (LockSerializedList(&_List))
    {
        for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
            entry != (PLIST_ENTRY)SlSelf(&_List);
            entry = entry->Flink)
        {
            info = CONTAINING_RECORD(entry, SECURITY_CACHE_LIST_ENTRY, _List);

            //
            // check to see if they match.
            //

            if (info->_ServerName.Stricmp(lpszHost) == 0) {
                info->AddRef();
                break; // match.
            }
            info = NULL;
        }
        UnlockSerializedList(&_List);
    }

    DEBUG_LEAVE(info);

    return info;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\whttptst\src\winhttptest\helpers.cxx ===
#include "common.h"

//-----------------------------------------------------------------------------
// WinHttpTest helper functions
//-----------------------------------------------------------------------------
HRESULT
WinHttpTest::_WinHttpOpen(
  LPCWSTR  pwszUserAgent,
  DWORD    dwAccessType,
  LPCWSTR  pwszProxyName,
  LPCWSTR  pwszProxyBypass,
  DWORD    dwFlags,
  VARIANT* retval
  )
{
  DEBUG_ENTER((
    DBG_HELPER,
    rt_hresult,
    "WinHttpTest::_WinHttpOpen",
    "pwszUserAgent=%#x; dwAccessType=%s; pwszProxyName=%#x; pwszProxyBypass=%#x; dwFlags=%s",
    pwszUserAgent,
    MapWinHttpAccessType(dwAccessType),
    pwszProxyName,
    pwszProxyBypass,
    MapWinHttpIOMode(dwFlags)
    ));

  HRESULT   hr    = S_OK;
  DWORD     error = ERROR_SUCCESS;
  HINTERNET hOpen = NULL;
  
  __try
  {
    hOpen = ::WinHttpOpen(
                pwszUserAgent,
                dwAccessType,
                pwszProxyName,
                pwszProxyBypass,
                dwFlags
                );
    
    if( !hOpen )
    {
      error = GetLastError();
    }
  }
  __except(exception_filter(GetExceptionInformation()))
  {
    error = _exception_code();
    goto quit;
  }

  if( retval )
  {
    V_VT(retval) = VT_I4;
    V_I4(retval) = (DWORD) hOpen;
  }

quit:
  
  _SetErrorCode(error);

  DEBUG_TRACE(WHTTPTST, ("hOpen=%#x", hOpen));
  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
WinHttpTest::_WinHttpConnect(
  HINTERNET     hSession,
  LPCWSTR       pwszServerName,
  INTERNET_PORT nServerPort,
  DWORD         dwReserved,
  VARIANT*      retval
  )
{
  DEBUG_ENTER((
    DBG_HELPER,
    rt_hresult,
    "WinHttpTest::_WinHttpConnect",
    "hSession=%#x; pwszServerName=%#x; nServerPort=%d; dwReserved=%#x",
    hSession,
    pwszServerName,
    nServerPort,
    dwReserved
    ));

  HRESULT    hr        = S_OK;
  DWORD      error     = ERROR_SUCCESS;
  HINTERNET  hConnect  = NULL;
  IDispatch* pCallback = NULL;

  __try
  {
    hConnect = ::WinHttpConnect(
                   hSession,
                   pwszServerName,
                   nServerPort,
                   dwReserved
                   );

    if( !hConnect )
    {
      error = GetLastError();
    }
  }
  __except(exception_filter(GetExceptionInformation()))
  {
    error = _exception_code();
    goto quit;
  }

  if( retval )
  {
    V_VT(retval) = VT_I4;
    V_I4(retval) = (DWORD) hConnect;

    if( error == ERROR_SUCCESS )
    {
      // WinHTTP handles inherit their parent's callback function pointer. Since we're
      // thunking the callback from C to JavaScript, we need to simulate this inheritance
      // in the callback handle map.

      if( SUCCEEDED(ManageCallbackForHandle(hSession, &pCallback, CALLBACK_HANDLE_GET)) )
      {
        hr = ManageCallbackForHandle(hConnect, &pCallback, CALLBACK_HANDLE_MAP);
      }
    }
  }

quit:
  
  _SetErrorCode(error);
  
  DEBUG_TRACE(WHTTPTST, ("hConnect=%#x", hConnect));    
  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
WinHttpTest::_WinHttpOpenRequest(
  HINTERNET hConnect,
  LPCWSTR   pwszVerb,
  LPCWSTR   pwszObjectName,
  LPCWSTR   pwszVersion,
  LPCWSTR   pwszReferrer,
  LPCWSTR*  ppwszAcceptTypes,
  DWORD     dwFlags,
  VARIANT*  retval
  )
{
  DEBUG_ENTER((
    DBG_HELPER,
    rt_hresult,
    "WinHttpTest::_WinHttpOpenRequest",
    "hConnect=%#x; pwszVerb=%#x; pwszObjectName=%#x; pwszVersion=%#x; pwszReferrer=%#x; ppwszAcceptTypes=%#x; dwFlags=%#x",
    hConnect,
    pwszVerb,
    pwszObjectName,
    pwszVersion,
    pwszReferrer,
    ppwszAcceptTypes,
    dwFlags
    ));

  HRESULT    hr        = S_OK;
  DWORD      error     = ERROR_SUCCESS;
  HINTERNET  hRequest  = NULL;
  IDispatch* pCallback = NULL;

  __try
  {
    hRequest = ::WinHttpOpenRequest(
                   hConnect,
                   pwszVerb,
                   pwszObjectName,
                   pwszVersion,
                   pwszReferrer,
                   ppwszAcceptTypes,
                   dwFlags
                   );

    if( !hRequest )
    {
      error = GetLastError();
    }
  }
  __except(exception_filter(GetExceptionInformation()))
  {
    error = _exception_code();
    goto quit;
  }

  if( retval )
  {
    V_VT(retval) = VT_I4;
    V_I4(retval) = (DWORD) hRequest;

    if( error == ERROR_SUCCESS )
    {
      // WinHTTP handles inherit their parent's callback function pointer. Since we're
      // thunking the callback from C to JavaScript, we need to simulate this inheritance
      // in the callback handle map.

      if( SUCCEEDED(ManageCallbackForHandle(hConnect, &pCallback, CALLBACK_HANDLE_GET)) )
      {
        hr = ManageCallbackForHandle(hRequest, &pCallback, CALLBACK_HANDLE_MAP);
      }
    }
  }

quit:

  _SetErrorCode(error);

  DEBUG_TRACE(WHTTPTST, ("hRequest=%#x", hRequest));
  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
WinHttpTest::_WinHttpSendRequest(
  HINTERNET hRequest,
  LPCWSTR   pwszHeaders,
  DWORD     dwHeadersLength,
  LPVOID    lpOptional,
  DWORD     dwOptionalLength,
  DWORD     dwTotalLength,
  DWORD_PTR dwContext,
  VARIANT*  retval
  )
{
  DEBUG_ENTER((
    DBG_HELPER,
    rt_hresult,
    "WinHttpTest::_WinHttpSendRequest",
    "hRequest=%#x; pwszHeaders=%#x; dwHeadersLength=%#x; lpOptional=%#x; dwOptionalLength=%#x; dwTotalLength=%#x; dwContext=%#x",
    hRequest,
    pwszHeaders,
    dwHeadersLength,
    lpOptional,
    dwOptionalLength,
    dwTotalLength,
    dwContext    
    ));

  HRESULT hr    = S_OK;
  DWORD   error = ERROR_SUCCESS;
  BOOL    bRet  = NULL;

  __try
  {
    bRet = ::WinHttpSendRequest(
               hRequest,
               pwszHeaders,
               dwHeadersLength,
               lpOptional,
               dwOptionalLength,
               dwTotalLength,
               dwContext
               );

    if( !bRet )
    {
      error = GetLastError();
    }
  }
  __except(exception_filter(GetExceptionInformation()))
  {
    error = _exception_code();
    goto quit;
  }

  if( retval )
  {
    V_VT(retval)   = VT_BOOL;
    V_BOOL(retval) = bRet ? VARIANT_TRUE : VARIANT_FALSE;
  }

quit:

  _SetErrorCode(error);

  DEBUG_TRACE(WHTTPTST, ("bRet=%s", TF(bRet)));
  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
WinHttpTest::_WinHttpCloseHandle(
  HINTERNET hInternet,
  VARIANT*  retval
  )
{
  DEBUG_ENTER((
    DBG_HELPER,
    rt_hresult,
    "WinHttpTest::_WinHttpCloseHandle",
    "hInternet=%#x",
    hInternet
    ));

  HRESULT hr    = S_OK;
  DWORD   error = ERROR_SUCCESS;
  BOOL    bRet  = TRUE;

  __try
  {
    bRet = ::WinHttpCloseHandle(hInternet);

    if( !bRet )
    {
      error = GetLastError();
    }
  }
  __except(exception_filter(GetExceptionInformation()))
  {
    error = _exception_code();
    goto quit;
  }

  if( retval )
  {
    V_VT(retval)   = VT_BOOL;
    V_BOOL(retval) = bRet ? VARIANT_TRUE : VARIANT_FALSE;
  }

quit:

  // we don't care about success or failure, always unmap the
  // callback from the (now closed) internet handle
  ManageCallbackForHandle(hInternet, NULL, CALLBACK_HANDLE_UNMAP);

  _SetErrorCode(error);
        
  DEBUG_TRACE(WHTTPTST, ("bRet=%s", TF(bRet)));
  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
WinHttpTest::_WinHttpSetStatusCallback(
  HINTERNET               hInternet,
  WINHTTP_STATUS_CALLBACK lpfnCallback,
  DWORD                   dwNotificationFlags,
  DWORD_PTR               dwReserved,
  VARIANT*                retval
  )
{
  DEBUG_ENTER((
    DBG_HELPER,
    rt_hresult,
    "WinHttpTest::_WinHttpSetStatusCallback",
    "hInternet=%#x; lpfnCallback=%#x; dwNotificationFlags=%#x; dwReserved=%#x",
    hInternet,
    lpfnCallback,
    dwNotificationFlags,
    dwReserved
    ));

  HRESULT                 hr          = S_OK;
  DWORD                   error       = ERROR_SUCCESS;
  WINHTTP_STATUS_CALLBACK pfnPrevious = NULL;
  
  __try
  {
    pfnPrevious = ::WinHttpSetStatusCallback(
                      hInternet,
                      lpfnCallback,
                      dwNotificationFlags,
                      dwReserved
                      );

    if( pfnPrevious == WINHTTP_INVALID_STATUS_CALLBACK )
    {
      error = GetLastError();
    }
  }
  __except(exception_filter(GetExceptionInformation()))
  {
    error = _exception_code();
    goto quit;
  }

  if( retval )
  {
    V_VT(retval) = VT_I4;
    V_I4(retval) = (DWORD_PTR) pfnPrevious;
  }

quit:

  _SetErrorCode(error);

  DEBUG_TRACE(WHTTPTST, ("pfnPrevious=%#x [%s]", pfnPrevious, MapErrorToString((DWORD) pfnPrevious)));
  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\whttptst\src\winhttptest\methods.cxx ===
#include "common.h"

//-----------------------------------------------------------------------------
// IWinHttpTest methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
WinHttpTest::WinHttpOpen(
  VARIANT UserAgent,
  VARIANT AccessType,
  VARIANT ProxyName,
  VARIANT ProxyBypass,
  VARIANT Flags, 
  VARIANT *OpenHandle
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttpOpen",
    "this=%#x",
    this
    ));

  HRESULT hr              = S_OK;
  LPWSTR  pwszUserAgent   = NULL;
  LPWSTR  pwszProxyName   = NULL;
  LPWSTR  pwszProxyBypass = NULL;
  DWORD   dwAccessType    = 0L;
  DWORD   dwFlags         = 0L;

  hr = ProcessWideStringParam(L"UserAgent", &UserAgent, &pwszUserAgent);

    if( FAILED(hr) )
      goto quit;

  hr = ProcessWideStringParam(L"ProxyName", &ProxyName, &pwszProxyName);

    if( FAILED(hr) )
      goto quit;

  hr = ProcessWideStringParam(L"ProxyBypass", &ProxyBypass, &pwszProxyBypass);

    if( FAILED(hr) )
      goto quit;

  dwAccessType = V_I4(&AccessType);
  dwFlags      = V_I4(&Flags);

  hr = _WinHttpOpen(
          pwszUserAgent,
          dwAccessType,
          pwszProxyName,
          pwszProxyBypass,
          dwFlags,
          OpenHandle
          );

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WinHttpTest::WinHttpConnect(
  VARIANT OpenHandle,
  VARIANT ServerName,
  VARIANT ServerPort,
  VARIANT Reserved,
  VARIANT *ConnectHandle
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttpConnect",
    "this=%#x",
    this
    ));

  HRESULT       hr             = S_OK;
  HINTERNET     hOpen          = NULL;
  LPWSTR        pwszServerName = NULL;
  INTERNET_PORT nServerPort    = 0;
  DWORD         dwReserved     = 0L;

  hr = ProcessWideStringParam(L"ServerName", &ServerName, &pwszServerName);

    if( FAILED(hr) )
      goto quit;

  hOpen       = (HINTERNET) V_I4(&OpenHandle);
  nServerPort = (INTERNET_PORT) V_I4(&ServerPort);
  dwReserved  = V_I4(&Reserved);

  hr = _WinHttpConnect(
          hOpen,
          pwszServerName,
          nServerPort,
          dwReserved,
          ConnectHandle
          );

quit:

  DEBUG_LEAVE(hr);
  return hr;
}

        
HRESULT
__stdcall
WinHttpTest::WinHttpOpenRequest(
  VARIANT ConnectHandle,
  VARIANT Verb,
  VARIANT ObjectName,
  VARIANT Version,
  VARIANT Referrer,
  VARIANT AcceptTypes,
  VARIANT Flags,
  VARIANT *RequestHandle
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttpOpenRequest",
    "this=%#x",
    this
    ));

  HRESULT   hr                = S_OK;
  HINTERNET hConnect          = NULL;
  LPWSTR    pwszVerb          = NULL;
  LPWSTR    pwszObjectName    = NULL;
  LPWSTR    pwszVersion       = NULL;
  LPWSTR    pwszReferrer      = NULL;
  LPCWSTR*  ppwszAcceptTypes  = NULL;
  DWORD     dwFlags           = NULL;

  hr = ProcessWideStringParam(L"Verb", &Verb, &pwszVerb);

    if( FAILED(hr) )
      goto quit;

  hr = ProcessWideStringParam(L"ObjectName", &ObjectName, &pwszObjectName);

    if( FAILED(hr) )
      goto quit;

  hr = ProcessWideStringParam(L"Version", &Version, &pwszVersion);

    if( FAILED(hr) )
      goto quit;

  hr = ProcessWideStringParam(L"Referrer", &Referrer, &pwszReferrer);

    if( FAILED(hr) )
      goto quit;

  hr = ProcessWideMultiStringParam(L"AcceptTypes", &AcceptTypes, (LPWSTR**) &ppwszAcceptTypes);

    if( FAILED(hr) )
      goto quit;

  hConnect = (HINTERNET) V_I4(&ConnectHandle);
  dwFlags  = V_I4(&Flags);

  hr = _WinHttpOpenRequest(
          hConnect,
          pwszVerb,
          pwszObjectName,
          pwszVersion,
          pwszReferrer,
          ppwszAcceptTypes,
          dwFlags,
          RequestHandle
          );

quit:

  SAFEDELETEBUF(ppwszAcceptTypes);

  DEBUG_LEAVE(hr);
  return hr;
}

        
HRESULT
__stdcall
WinHttpTest::WinHttpSendRequest(
  VARIANT RequestHandle,
  VARIANT Headers,
  VARIANT HeadersLength,
  VARIANT OptionalData,
  VARIANT OptionalLength,
  VARIANT TotalLength,
  VARIANT Context,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttpSendRequest",
    "this=%#x",
    this
    ));

  HRESULT   hr               = S_OK;
  BOOL      bDidAlloc        = FALSE;
  HINTERNET hRequest         = NULL;
  LPCWSTR   pwszHeaders      = NULL;
  DWORD     dwHeadersLength  = 0L;
  LPVOID    lpOptional       = NULL;
  DWORD     dwOptionalLength = 0L;
  DWORD     dwTotalLength    = 0L;
  DWORD_PTR dwContext        = NULL;

  hr = ProcessWideStringParam(L"Headers", &Headers, (LPWSTR*) &pwszHeaders);

    if( FAILED(hr) )
      goto quit;

  hr = ProcessBufferParam(L"OptionalData", &OptionalData, &lpOptional, &bDidAlloc);

    if( FAILED(hr) )
      goto quit;

  hRequest         = (HINTERNET) V_I4(&RequestHandle);
  dwHeadersLength  = V_I4(&HeadersLength);
  dwOptionalLength = V_I4(&OptionalLength);
  dwTotalLength    = V_I4(&TotalLength);
  dwContext        = V_I4(&Context);

  hr = _WinHttpSendRequest(
          hRequest,
          pwszHeaders,
          dwHeadersLength,
          lpOptional,
          dwOptionalLength,
          dwTotalLength,
          dwContext,
          Success
          );

quit:

  if( bDidAlloc )
  {
    SAFEDELETEBUF(lpOptional);
  }

  DEBUG_LEAVE(hr);
  return hr;
}

        
HRESULT
__stdcall
WinHttpTest::WinHttpReceiveResponse(
  VARIANT RequestHandle,
  VARIANT Reserved,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WinHttpTest::WinHttpCloseHandle(
  VARIANT InternetHandle,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttpCloseHandle",
    "this=%#x",
    this
    ));

  HRESULT   hr        = S_OK;
  HINTERNET hInternet = NULL;
  
  hInternet = (HINTERNET) V_I4(&InternetHandle);

  hr = _WinHttpCloseHandle(
          hInternet,
          Success
          );

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WinHttpTest::WinHttpReadData(
  VARIANT RequestHandle,
  VARIANT BufferObject,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WinHttpTest::WinHttpWriteData(
  VARIANT RequestHandle,
  VARIANT BufferObject,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WinHttpTest::WinHttpQueryDataAvailable(
  VARIANT RequestHandle,
  VARIANT boNumberOfBytesAvailable,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WinHttpTest::WinHttpQueryOption(
  VARIANT InternetHandle,
  VARIANT Option,
  VARIANT BufferObject,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WinHttpTest::WinHttpSetOption(
  VARIANT InternetHandle,
  VARIANT Option,
  VARIANT BufferObject,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WinHttpTest::WinHttpSetTimeouts(
  VARIANT InternetHandle,
  VARIANT ResolveTimeout,
  VARIANT ConnectTimeout,
  VARIANT SendTimeout,
  VARIANT ReceiveTimeout,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WinHttpTest::WinHttpAddRequestHeaders(
  VARIANT RequestHandle,
  VARIANT Headers,
  VARIANT HeadersLength,
  VARIANT Modifiers,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}

        
HRESULT
__stdcall
WinHttpTest::WinHttpSetCredentials(
  VARIANT RequestHandle,
  VARIANT AuthTargets,
  VARIANT AuthScheme,
  VARIANT UserName,
  VARIANT Password,
  VARIANT AuthParams,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}

        
HRESULT
__stdcall
WinHttpTest::WinHttpQueryAuthSchemes(
  VARIANT RequestHandle,
  VARIANT SupportedSchemes,
  VARIANT PreferredSchemes,
  VARIANT AuthTarget,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}

        
HRESULT
__stdcall
WinHttpTest::WinHttpQueryHeaders(
  VARIANT RequestHandle,
  VARIANT InfoLevel,
  VARIANT HeaderName,
  VARIANT HeaderValue,
  VARIANT HeaderValueLength,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}

        
HRESULT
__stdcall
WinHttpTest::WinHttpTimeFromSystemTime(
  VARIANT SystemTime,
  VARIANT boHttpTime,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WinHttpTest::WinHttpTimeToSystemTime(
  VARIANT boHttpTime,
  VARIANT SystemTime,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}

        
HRESULT
__stdcall
WinHttpTest:: WinHttpCrackUrl(
  VARIANT Url,
  VARIANT UrlLength,
  VARIANT Flags,
  VARIANT UrlComponents,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}

        
HRESULT
__stdcall
WinHttpTest::WinHttpCreateUrl(
  VARIANT UrlComponents,
  VARIANT Flags,
  VARIANT BufferObject,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WinHttpTest::WinHttpSetStatusCallback(
  VARIANT InternetHandle,
  VARIANT CallbackFunction,
  VARIANT NotificationFlags,
  VARIANT Reserved,
  VARIANT *RetVal
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttpSetStatusCallback",
    "this=%#x",
    this
    ));

  HRESULT                 hr                  = S_OK;
  IDispatch*              pCallback           = NULL;
  HINTERNET               hInternet           = NULL;
  WINHTTP_STATUS_CALLBACK lpfnCallback        = NULL;
  DWORD                   dwNotificationFlags = 0L;
  DWORD                   dwReserved          = 0L;

  hInternet           = (HINTERNET) V_I4(&InternetHandle);
  dwNotificationFlags = V_UI4(&NotificationFlags);

  //
  // special case to deal with javascript not liking 0xFFFFFFFF
  //
  if( dwNotificationFlags == 0x0000000a )
  {
    dwNotificationFlags = WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS;
  }

  dwReserved          = V_I4(&Reserved);

  switch( V_VT(&CallbackFunction) )
  {
    case VT_DISPATCH :
      {
        pCallback = V_DISPATCH(&CallbackFunction);
        hr        = ManageCallbackForHandle(hInternet, &pCallback, CALLBACK_HANDLE_MAP);

        if( SUCCEEDED(hr) )
        {
          lpfnCallback = WinHttpCallback;
        }
      }
      break;

    case VT_I4 :
      {
        hr = InvalidatePointer(
               (POINTER) V_I4(&CallbackFunction),
               (void**) &lpfnCallback
               );
      }
      break;

    default : hr = E_INVALIDARG;
  }

  if( SUCCEEDED(hr) )
  {
    hr = _WinHttpSetStatusCallback(
            hInternet,
            lpfnCallback,
            dwNotificationFlags,
            dwReserved,
            RetVal
            );
  }

  DEBUG_LEAVE(hr);
  return hr;
}

        
HRESULT
__stdcall
WinHttpTest::HelperGetBufferObject(
  VARIANT Size,
  VARIANT Type,
  VARIANT Flags,
  VARIANT *BufferObject
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}

        
HRESULT
__stdcall
WinHttpTest::HelperGetUrlComponents(
  VARIANT Flags,
  VARIANT *UrlComponents
  )
{
  HRESULT            hr   = S_OK;
  IWHTUrlComponents* pwuc = NULL;

    if( UrlComponents )
    {
      hr = WHTURLCMP::Create((MEMSETFLAG) V_I4(&Flags), &pwuc);

      if( SUCCEEDED(hr) )
      {
        V_VT(UrlComponents)       = VT_DISPATCH;
        V_DISPATCH(UrlComponents) = pwuc;
      }
      else
      {
        V_VT(UrlComponents) = VT_NULL;
      }
    }
    else
    {
      hr = E_INVALIDARG;
    }

  return hr;
}

        
HRESULT
__stdcall
WinHttpTest::HelperGetSystemTime(
  VARIANT Flags,
  VARIANT *SystemTime
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WinHttpTest::HelperGetLastError(
  VARIANT *Win32ErrorCode
  )
{
  HRESULT hr = S_OK;

    if( Win32ErrorCode )
    {
      if( m_pw32ec )
      {
        m_pw32ec->AddRef();

        V_VT(Win32ErrorCode)       = VT_DISPATCH;
        V_DISPATCH(Win32ErrorCode) = m_pw32ec;
      }
      else
      {
        V_VT(Win32ErrorCode) = VT_NULL;
      }
    }
    else
    {
      hr = E_INVALIDARG;
    }

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\api\creds.cxx ===
/*++

Copyright (c) 1994-2000  Microsoft Corporation

Module Name:

    Creds.cxx

Abstract:

    Contains the Creds APIs

    Contents:
        WinHttpSetCredentialsA
        WinHttpSetCredentials
        WinHttpQueryAuthSchemes
        
Author:

    Biao Wang (biaow) 27-June-2000

Environment:

    Win32 user-mode DLL

Revision History:

    27-June-2000 biaow
        Created

--*/

#include <wininetp.h>

/*
BOOLAPI WinHttpQueryAuthParams(
    IN  HINTERNET   hRequest,        // HINTERNET handle returned by WinHttpOpenRequest   
    IN  DWORD       AuthScheme,
    OUT LPVOID*     pAuthParams      // Scheme-specific Advanced auth parameters
    )
{
    //BUG-BUG Verify parameters
    
    // biaow: to implement this fully
    *pAuthParams = 0;

    return TRUE;
}
*/

BOOLAPI WinHttpQueryAuthSchemes(
    
    IN  HINTERNET   hRequest,       // HINTERNET handle returned by HttpOpenRequest.   
    OUT LPDWORD     lpdwSupportedSchemes,// a bitmap of available Authentication Schemes
    OUT LPDWORD     lpdwPreferredScheme,  // WinHttp's preferred Authentication Method 
    OUT LPDWORD      pdwAuthTarget  
    )
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpQueryAuthSchemes",
                     "%#x, %#x, %#x",
                     hRequest,
                     lpdwSupportedSchemes,
                     lpdwPreferredScheme
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    HINTERNET hRequestMapped = NULL;
    BOOL fResult = FALSE;
    HINTERNET_HANDLE_TYPE HandleType;    

    dwErr = ::MapHandleToAddress(hRequest, (LPVOID *)&hRequestMapped, FALSE);
    
    if ((dwErr != ERROR_SUCCESS) || (hRequestMapped == NULL)) 
    {
        dwErr = ERROR_INVALID_HANDLE;
        goto cleanup;
    }

    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    if ((::RGetHandleType(hRequestMapped, &HandleType) != ERROR_SUCCESS) 
        || (HandleType != TypeHttpRequestHandle))
    {
        dwErr = ERROR_INVALID_HANDLE;
        goto cleanup;
    }
    
    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequestMapped;

    if (::IsBadWritePtr(lpdwSupportedSchemes, sizeof(DWORD)) 
        || ::IsBadWritePtr(lpdwPreferredScheme, sizeof(DWORD)) 
        || ::IsBadWritePtr(pdwAuthTarget, sizeof(DWORD)))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if ((!pRequest->_SupportedSchemes) || (!pRequest->_PreferredScheme))
    {
        dwErr = ERROR_INVALID_OPERATION;
        goto cleanup;
    }

    *lpdwSupportedSchemes = pRequest->_SupportedSchemes;
    *lpdwPreferredScheme = pRequest->_PreferredScheme;
    *pdwAuthTarget = pRequest->_AuthTarget;
    
    fResult = TRUE;

cleanup:

    if (hRequestMapped)
    {
        DereferenceObject(hRequestMapped);
    }

    if (dwErr!= ERROR_SUCCESS) 
    { 
        ::SetLastError(dwErr); 
        DEBUG_ERROR(HTTP, dwErr);
    }
    
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

BOOL WinHttpSetCredentialsA (
    
    IN HINTERNET   hRequest,        // HINTERNET handle returned by HttpOpenRequest.   
    
    
    IN DWORD       AuthTargets,      // Only WINHTTP_AUTH_TARGET_SERVER and 
                                    // WINHTTP_AUTH_TARGET_PROXY are supported
                                    // in this version and they are mutually 
                                    // exclusive 
    
    IN DWORD       AuthScheme,      // must be one of the supported Auth Schemes 
                                    // returned from HttpQueryAuthSchemes(), Apps 
                                    // should use the Preferred Scheme returned
    
    IN LPCSTR     pszUserName,     // 1) NULL if default creds is to be used, in 
                                    // which case pszPassword will be ignored
    
    IN LPCSTR     pszPassword,     // 1) "" == Blank Passowrd; 2)Parameter ignored 
                                    // if pszUserName is NULL; 3) Invalid to pass in 
                                    // NULL if pszUserName is not NULL
    IN LPVOID     pAuthParams
   
    )
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpSetCredentialsA",
                     "%#x, %#x, %#x, %q, %q, %q",
                     hRequest,
                     AuthTargets,
                     AuthScheme,
                     pAuthParams,
                     pszUserName,
                     pszPassword
                     ));
    
    // Note: we assume WinHttp will explose an Unicode only API, so this function
    // will not be called directly by Apps. If this assumption is no longer true 
    // in future revisions, we need to add more elaborate parameter validation here.

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    HINTERNET hRequestMapped = NULL;
    HTTP_REQUEST_HANDLE_OBJECT* pRequest;
    HINTERNET_HANDLE_TYPE HandleType;
    PSTR pszRealm = NULL;

    // validate API symantics

    if (pszUserName != NULL)
    {
        // in any case, it doesn't make sense (and therefore invalid) to pass 
        // in a blank("") User Name
        if (::strlen(pszUserName) == 0)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        else if (pszPassword == NULL)
        {
            // in any case, if an app passes in a UserName, it is invalid to
            // then pass in a NULL password (should use "" for blank passowrd)
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
    // biaow: is blank scheme OK?

    // if an app picks BASIC auth, it must also supply an UserName and password
    if ((AuthScheme == WINHTTP_AUTH_SCHEME_BASIC) && (pszUserName == NULL))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // default credentials (UserName/Password == NULL/NULL) are allowed only for 
    // NTLM/NEGOTIATE/PASSPORT auth
    if (pszUserName == NULL)
    {
        if ((AuthScheme != WINHTTP_AUTH_SCHEME_NTLM) 
            && (AuthScheme != WINHTTP_AUTH_SCHEME_NEGOTIATE)
            && (AuthScheme != WINHTTP_AUTH_SCHEME_PASSPORT))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }

    dwErr = ::MapHandleToAddress(hRequest, (LPVOID *)&hRequestMapped, FALSE);
    
    if ((dwErr != ERROR_SUCCESS) || (hRequestMapped == NULL)) {
        
        dwErr = ERROR_INVALID_HANDLE;
        goto cleanup;
    }

    if ((::RGetHandleType(hRequestMapped, &HandleType) != ERROR_SUCCESS) 
        || (HandleType != TypeHttpRequestHandle))
    {
        dwErr = ERROR_INVALID_HANDLE;
        goto cleanup;
    }

    pRequest = 
        reinterpret_cast<HTTP_REQUEST_HANDLE_OBJECT*>(hRequestMapped);

    if (AuthScheme == WINHTTP_AUTH_SCHEME_DIGEST)
    {
        if (pAuthParams)
        {
            pszRealm = NewString((PCSTR)pAuthParams);
        }
        else
        {
            pszRealm = pRequest->_pszRealm;
        }

        if (pszRealm == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }

    if (AuthTargets == WINHTTP_AUTH_TARGET_PROXY)
    {
        delete pRequest->_pProxyCreds;
        pRequest->_pProxyCreds = New WINHTTP_REQUEST_CREDENTIALS(AuthScheme, 
                                                              pszRealm, pszUserName, pszPassword);
        if (pRequest->_pProxyCreds == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }
    else 
    {
        delete pRequest->_pServerCreds;
        pRequest->_pServerCreds = New WINHTTP_REQUEST_CREDENTIALS(AuthScheme, 
                                                                  pszRealm, pszUserName, pszPassword);
        if (pRequest->_pServerCreds == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    pRequest->_PreferredScheme = 0x00000000;
    pRequest->_SupportedSchemes = 0x00000000;
    pRequest->_AuthTarget = 0x00000000;
    if (pRequest->_pszRealm)
    {
        FREE_MEMORY(pRequest->_pszRealm);
        pRequest->_pszRealm = NULL;
    }

    fResult = TRUE;

cleanup:

    if (hRequestMapped)
    {
        DereferenceObject(hRequestMapped);
    }

    if (dwErr!=ERROR_SUCCESS) 
    { 
        ::SetLastError(dwErr); 
        DEBUG_ERROR(HTTP, dwErr);
    }
    
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

BOOLAPI 
WinHttpSetCredentials(
    
    IN HINTERNET   hRequest,        // HINTERNET handle returned by HttpOpenRequest.   
    
    
    IN DWORD       AuthTargets,      // Only WINHTTP_AUTH_TARGET_SERVER and 
                                    // WINHTTP_AUTH_TARGET_PROXY are supported
                                    // in this version and they are mutually 
                                    // exclusive 
    
    IN DWORD       AuthScheme,      // must be one of the supported Auth Schemes 
                                    // returned from HttpQueryAuthSchemes(), Apps 
                                    // should use the Preferred Scheme returned
    
    IN LPCWSTR     pwszUserName,     // 1) NULL if default creds is to be used, in 
                                    // which case pszPassword will be ignored
    
    IN LPCWSTR     pwszPassword,     // 1) "" == Blank Passowrd; 2)Parameter ignored 
                                    // if pszUserName is NULL; 3) Invalid to pass in 
                                    // NULL if pszUserName is not NULL
    IN LPVOID      pAuthParams
   
    )
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpSetCredentials",
                     "%#x, %#x, %#x, %wq, %wq, %wq",
                     hRequest,
                     AuthTargets,
                     AuthScheme,
                     pAuthParams,
                     pwszUserName,
                     pwszPassword
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    LPCWSTR pwszRealm = NULL;
    MEMORYPACKET mpRealm, mpUserName, mpPassword;

    if (!hRequest)
    {
        dwErr = ERROR_INVALID_HANDLE;
        goto cleanup;
    }

    // make sure only one bit in AuthScheme is set
    if ((AuthScheme & (AuthScheme - 1)) != 0x00000000)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // make sure the input strings are valid
    if (pwszUserName 
        && ::IsBadStringPtrW(pwszUserName, INTERNET_MAX_USER_NAME_LENGTH))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    if (pwszPassword 
        && ::IsBadStringPtrW(pwszPassword, INTERNET_MAX_PASSWORD_LENGTH))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    if ((AuthScheme == WINHTTP_AUTH_SCHEME_DIGEST) && pAuthParams)
    {
        pwszRealm = (LPCWSTR)pAuthParams;
    }
    if (pwszRealm 
        && ::IsBadStringPtrW(pwszRealm, INTERNET_MAX_REALM_LENGTH))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // make sure AuthTargets are either Server or Proxy (not both)
    if ((AuthTargets != WINHTTP_AUTH_TARGET_SERVER) 
        && (AuthTargets != WINHTTP_AUTH_TARGET_PROXY))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // convert Unicode strings to Ansi
    
    if (pwszUserName)
    {
        ALLOC_MB(pwszUserName, 0, mpUserName);
        if (!mpUserName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pwszUserName, mpUserName);
    }
    if (pwszPassword)
    {
        ALLOC_MB(pwszPassword, 0, mpPassword);
        if (!mpPassword.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pwszPassword, mpPassword);
    }
    if (pwszRealm)
    {
        ALLOC_MB(pwszRealm, 0, mpRealm);
        if (!mpRealm.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pwszRealm, mpRealm);
    }

    fResult = ::WinHttpSetCredentialsA(hRequest, AuthTargets,
                                       AuthScheme, mpUserName.psStr, mpPassword.psStr, mpRealm.psStr);

cleanup:

    if (dwErr!=ERROR_SUCCESS) 
    { 
        ::SetLastError(dwErr); 
        DEBUG_ERROR(HTTP, dwErr);
    }
    
    DEBUG_LEAVE_API(fResult);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\api\cliauth.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cliauth.cxx

Abstract:

    Contains Schannel/SSPI specific code for handling Client Authenication
    multiplexed between several asynchronous requests using fibers

    Contents:
        CliAuthRefreshCredential
        CliAuthSelectCredential

Author:

    Arthur L Bierer (arthurbi) 13-Jun-1996

Environment:

    Win32 user-mode DLL

Revision History:

    13-Jun-1996 arthurbi
        Created, based on orginal code from a-petesk.

--*/

#include <wininetp.h>


extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsecapi.h>

}


CERT_CONTEXT_ARRAY::CERT_CONTEXT_ARRAY()
{
    _error           = ERROR_SUCCESS;
    _iSelected  = -1;
    _ppCertContexts    = (PCCERT_CONTEXT *)
                        ALLOCATE_MEMORY(LMEM_FIXED,
                            sizeof(PCERT_CONTEXT)* CERT_CONTEXT_ARRAY_ALLOC_UNIT);

    if ( _ppCertContexts == NULL ) {
        _error = GetLastError();
    }

    _cAlloced  = CERT_CONTEXT_ARRAY_ALLOC_UNIT;
    _cCertContexts     = 0;

    ClearCreds(_hCreds);
    _cs.Init();
}

void CERT_CONTEXT_ARRAY::Reset(void)
{
    if ( _ppCertContexts )
    {
        for ( DWORD i = 0; i < _cCertContexts; i++ )
        {
            INET_ASSERT(_ppCertContexts[i]);
            WRAP_REVERT_USER_VOID(CertFreeCertificateContext, (_ppCertContexts[i]));
        }
    }
    _cCertContexts = 0;
    
    // It is important that this Free is guarded by a try except.
    // These objects get freed up at dll unload time and there is a circular
    // dependency between winient and schannel which can cause schannel to 
    // get unloaded. If that is the case we could fault here.
    if (!IsCredClear(_hCreds))
    {
        SAFE_WRAP_REVERT_USER_VOID(g_FreeCredentialsHandle, (&_hCreds));
    }
}


CERT_CONTEXT_ARRAY::~CERT_CONTEXT_ARRAY()
{
    Reset();

    FREE_MEMORY(_ppCertContexts);
}

DWORD
CliAuthSelectCredential(
    IN PCtxtHandle        phContext,
    IN LPTSTR             pszPackageName,
    IN CERT_CONTEXT_ARRAY*  pCertContextArray,
    OUT PCredHandle       phCredential,
    IN LPDWORD            pdwStatus)

/*++

Routine Description:

    Uses a selected Certificate Chain to produce a Credential handle.

    The credential handle will be used by SCHANNEL to produce a valid Client
    Auth session with a server.

Arguments:

    phContext       - SSPI Context Handle

    pszPackageName  - Name of the SSPI package we're using.

    pSelectedCert   - Cert that User wishes us to use for Client Auth with this server.
                       (BUGBUG who should free this? )

    phCredential    - Outgoing SSPI Credential handle that we may generate
                    IMPORTANT: Do not free the credential handle returned by this function.
                    These have to be cached for the lifetime of the process so the user 
                    doesn't get prompted forthe password over and over. Unfortunately there is
                    no ref-counting mechanism on CredHandle's so callers of this function need to 
                    make sure they don't free the handle.

    pdwStatus       - Secure error status flag that's filled in if an error occurs.
                    Pointer is assumed to be valid.

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                        Caller should return ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED,
                        to its caller.  The appropriate Cert chain was generated,
                        and the User needs to select it using UI.

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY -
                        Out of Memory

                  ERROR_WINHTTP_SECURE_FAILURE -
                        Call Down to SSPI or WinTrust failed.

--*/

{

     SCHANNEL_CRED CredData = {SCHANNEL_CRED_VERSION,
                                     0,
                                     NULL,
                                     0,
                                     0,
                                     NULL,
                                     0,
                                     NULL,
                                     DEFAULT_SECURE_PROTOCOLS,
                                     0,
                                     0,
                                     0,
                                     SCH_CRED_MANUAL_CRED_VALIDATION |
                                     SCH_CRED_NO_DEFAULT_CREDS
                                     };
    SECURITY_STATUS scRet;


    DWORD           i;
    PCERT_BLOB      pBlob;
    DWORD           index;
    DWORD           error = ERROR_SUCCESS;
    PCCERT_CONTEXT  pCert;

    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CliAuthSelectCredential",
                 "%#x, %s, %x, %x",
                 phContext,
                 pszPackageName,
                 pCertContextArray,
                 phCredential
                 ));


    INET_ASSERT(phContext);
    INET_ASSERT(pCertContextArray);
    INET_ASSERT(pszPackageName);


    if (!pCertContextArray->LockCredHandle( ))
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    if ( pCertContextArray->GetArraySize() == 0 )
    {
        goto cleanup;
    }
    else
    {
        // First check and see if the Cert context already has a CredHandle associated with it.
        CredHandle hCreds = pCertContextArray->GetCredHandle( );

        if (!IsCredClear(hCreds))
        {
            *phCredential = hCreds;
            error = ERROR_SUCCESS;
            goto cleanup;
        }
    }

    pCert =         pCertContextArray->GetSelectedCertContext();


    //
    // Setup strucutres for AcquireCredentialsHandle call.
    //

    if ( pCert )
    {

        CredData.cCreds = 1;
        CredData.paCred = &pCert;
    }
    InternetReadRegistryDword("SecureProtocols",
                          (LPDWORD)&CredData.grbitEnabledProtocols
                          );

    WRAP_REVERT_USER(g_AcquireCredentialsHandle,
                     (NULL,
                      pszPackageName,
                      SECPKG_CRED_OUTBOUND,
                      NULL,
                      &CredData,
                      NULL,
                      NULL,
                      phCredential,
                      NULL),
                     scRet);

    error = MapInternetError((DWORD)scRet, pdwStatus);
    if (error == ERROR_SUCCESS)
    {
        pCertContextArray->SetCredHandle(*phCredential);
    }

cleanup:
    pCertContextArray->UnlockCredHandle();
    
quit:
    DEBUG_LEAVE(error);

    return error;
}


DWORD
CliAuthAcquireCertContexts(
    IN  PCtxtHandle        phContext,
    IN  LPTSTR             pszPackageName,
    OUT CERT_CONTEXT_ARRAY** ppCertContextArray,
    LPDWORD                pdwStatus
    )

/*++

Routine Description:

    Acquires a List of valid Certificate Chains for use in Client Authentication.

    Gathers an issuer list from the current context, and uses CAPI stored Certificates
    to build a list which will be selected from by the user at a later point.

Arguments:

    phContext       - SSPI Context Handle

    pszPackageName  - Name of the SSPI package we're using.

    phCredential    - Outgoing SSPI Credential handle that we may generate

    ppCertContextArray  - Outgoing List of Certifcate Contexts that can be selected
                        among to generate a Context.

    pdwStatus       - If failure is ERROR_WINHTTP_SECURE_FAILURE, this will
                      be filled in with the mapped flag for the error.

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                        Caller should return ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED,
                        to its caller.  The appropriate Cert chain was generated,
                        and the User needs to select it using UI.

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY -
                        Out of Memory

                  ERROR_WINHTTP_SECURE_FAILURE -
                        Call Down to SSPI or WinTrust failed.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CliAuthAcquireCertContexts",
                 "%#x, %s, %x",
                 phContext,
                 pszPackageName,
                 ppCertContextArray
                 ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    BOOL async;
    SECURITY_STATUS scRet;
    DWORD           cCerts;
    CERT_CHAIN_FIND_BY_ISSUER_PARA FindByIssuerPara;
    SecPkgContext_IssuerListInfoEx IssuerListInfo;
    PCCERT_CHAIN_CONTEXT pChainContext;
    PCCERT_CONTEXT pCertContext;
    DWORD error;

    if (lpThreadInfo != NULL) {
        async = _InternetGetAsync(lpThreadInfo);
        _InternetSetAsync(lpThreadInfo, FALSE);
    }

    INET_ASSERT(ppCertContextArray);


    INET_ASSERT(*ppCertContextArray == NULL );
    *ppCertContextArray = NULL;

    IssuerListInfo.cIssuers = 0;
    IssuerListInfo.aIssuers = NULL;

    if ( phContext == NULL )
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // Create our CertChain Array for keeping CertChains around
    //

    *ppCertContextArray = New CERT_CONTEXT_ARRAY();

    if ( *ppCertContextArray == NULL )
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    error = (*ppCertContextArray)->GetError();

    if ( error != ERROR_SUCCESS)
    {
        goto quit;
    }

    if (g_hMyCertStore == NULL)
    {
        // In middle-tier server scenarios, it's possible for the account
        // to not be configured with a store for client auth support.
        // If so, simply return an empty array to mimic no certs available.
        goto quit;
    }

    //
    // Attempt to find out whether we have any issuers
    //  from this connection that the Server might have
    //  told us about.
    //

    WRAP_REVERT_USER(g_QueryContextAttributes,
                     (phContext,
                      SECPKG_ATTR_ISSUER_LIST_EX,
                      &IssuerListInfo),
                     scRet);

    if(FAILED(scRet))
    {
        error = MapInternetError((DWORD) scRet, pdwStatus);
        goto quit;
    }

    cCerts = 0;

    if (g_CertFindChainInStore == NULL || g_CertFreeCertificateChain == NULL)
    {
        // We don't support client-auth unless we have the new crypto dlls
        error = ERROR_CALL_NOT_IMPLEMENTED;
        goto quit;
    }

    ZeroMemory(&FindByIssuerPara, sizeof(FindByIssuerPara));

    FindByIssuerPara.cbSize = sizeof(FindByIssuerPara);
    FindByIssuerPara.pszUsageIdentifier = szOID_PKIX_KP_CLIENT_AUTH;
    FindByIssuerPara.dwKeySpec = 0;
    FindByIssuerPara.cIssuer   = IssuerListInfo.cIssuers;
    FindByIssuerPara.rgIssuer  = IssuerListInfo.aIssuers;

    pChainContext = NULL;

    while (TRUE)
    {
        // Find a certificate chain.
        WRAP_REVERT_USER(g_CertFindChainInStore,
                         (g_hMyCertStore,
                          X509_ASN_ENCODING,
                          0,
                          CERT_CHAIN_FIND_BY_ISSUER,
                          &FindByIssuerPara,
                          pChainContext),
                         pChainContext);

        if (pChainContext == NULL)
            break;

        // Get pointer to leaf certificate context.
        pCertContext = pChainContext->rgpChain[0]->rgpElement[0]->pCertContext;

        // This could only happen if there is a bug in the crypto code. But we will deal with
        // that and continue looking in any case.
        if (pCertContext == NULL)
        {
            INET_ASSERT(FALSE);
            continue;
        }

        error = (*ppCertContextArray)->AddCertContext(pCertContext);

        if (error != ERROR_SUCCESS)
        {
            WRAP_REVERT_USER_VOID(g_CertFreeCertificateChain,(pChainContext));
            goto quit;
        }
    }

quit:

    if ( error != ERROR_SUCCESS &&
         *ppCertContextArray != NULL )
    {
        delete *ppCertContextArray;
        *ppCertContextArray = NULL;
    }

    if (IssuerListInfo.aIssuers != NULL)
    {
        WRAP_REVERT_USER_VOID(g_FreeContextBuffer, (IssuerListInfo.aIssuers));
    }

    if (lpThreadInfo != NULL) {
        _InternetSetAsync(lpThreadInfo, async);
    }

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\wininet.inc ===
!IF 0

Copyright (c) 1994  Microsoft Corporation

Module Name:

    wininet.inc

Abstract:

    Common makefile contents for wininet project

Author:

    Richard L Firth (rfirth) 10-Feb-1996

Revision History:

    10-Feb-1996 rfirth
        Created

!ENDIF

!IFNDEF SDKINC
SDKINC=$(SDK_INC_PATH)
!ENDIF

!IFDEF LIBDIR
!ERROR LIBDIR already defined - choose new name
!ENDIF

LIBDIR=..\lib\$(_OBJ_DIR)

#
# if TARGETPATH is not defined (in the paths that build libraries) then this
# is the default target path
#

!IFNDEF TARGETPATH
TARGETPATH=$(LIBDIR)
TARGETTYPE=LIBRARY
!ENDIF

#
# what it is that we're building
#

MAJORCOMP=winhttpx

USE_NOLIBS=1
USE_MSVCRT=1
NO_NTDLL=1

#
# compiler definitions
#

C_DEFINES=$(C_DEFINES) -D_WINHTTP_INTERNAL_  -DCOMPILING_ROCKALL_LIBRARY

# Get same version from NT or IE builds.
C_DEFINES=$(C_DEFINES)

!IFDEF USE_ICECAP
C_DEFINES=$(C_DEFINES) -DICECAP
!ENDIF

#
# Set debugging level
#

!IF "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail" && "$(NTDEBUG)" != "ntsdnodbg"
C_DEFINES=$(C_DEFINES) -DENABLE_DEBUG -DINET_DEBUG=1

#
# remove maximal diagnostics for customer debug version based on environment
# variable
#

!IF "$(FULL_DEBUG)" != ""
C_DEFINES=$(C_DEFINES) -DUSE_DEBUG_MEMORY
!ELSE
C_DEFINES=$(C_DEFINES) -DRETAIL_LOGGING
!IF "$(BUILD_PRODUCT)" != "NT"
C_DEFINES=$(C_DEFINES) -DDISABLE_ASSERTS
!ENDIF
!ENDIF

!ELSE IF "$(ALMOSTRETAIL)" != ""
C_DEFINES=$(C_DEFINES) -DENABLE_DEBUG
!ENDIF

!IF "$(WIN64)" == "0" && "$(FULL_DEBUG)"==""
C_DEFINES=$(C_DEFINES) -DUSE_ROCKALL
!ENDIF

#
# performance diagnostics
#

!IF "$(PERF_BUILD)" != ""
C_DEFINES=$(C_DEFINES) -DUSE_PERF_DIAG
!ENDIF

!if !defined(CLEANINF_FLAGS)
# Cleaninf flags
CLEANINF_FLAGS  = -w
!endif

#
# Linker flags
#

!if "$(BUILD_PRODUCT)" == "IE"
USE_WIN98OPT=1
!endif

# Cleaninf utility
CLEANINF        = cleaninf.exe $(CLEANINF_FLAGS)

#
# Do this to assure that we run on NT 4.0 and Win95, even with
# NT5/Memphis headers.
#

WIN32_WINNT_VERSION=0x0400
WIN32_WIN95_VERSION=0x0400

#
# compiler warning flags
#

MSC_WARNING_LEVEL=/W3 /WX

#
# precompiled header options
#

!IFNDEF WININET_PCH

PRECOMPILED_OPTION=/Fp..\inc\$(_OBJ_DIR)\*\wininetp.pch /Yuwininetp.h
PRECOMPILED_CXX=1

!ENDIF

CONDITIONAL_INCLUDES = \
        winwlm.h \
        macwin32.h \
        ia64inst.h \
        pshpck16.h \
        rpcerr.h \
        rpcmac.h \
        macname1.h \
        macpub.h \
        macapi.h \
        macname2.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\tools\whttptst\src\winhttptest\winhttptest.cxx ===
#include "common.h"

extern HINSTANCE  g_hGlobalDllInstance;
LPCWSTR           g_wszWinHttpTestObjectName = L"WinHttpTest";


//-----------------------------------------------------------------------------
// WinHttpTest methods
//-----------------------------------------------------------------------------
WinHttpTest::WinHttpTest():
  m_cRefs(0),
  m_pti(NULL),
  m_pw32ec(NULL)
{
  DEBUG_TRACE(WHTTPTST, ("WinHttpTest [%#x] created", this));
}


WinHttpTest::~WinHttpTest()
{
  SAFERELEASE(m_pti);
  SAFERELEASE(m_pw32ec);
  DEBUG_TRACE(WHTTPTST, ("WinHttpTest [%#x] deleted", this));
}


HRESULT
WinHttpTest::Create(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_INITIALIZE,
    rt_hresult,
    "WinHttpTest::Create",
    "riid=%s; ppv=%#x",
    MapIIDToString(riid),
    ppv
    ));

  HRESULT   hr   = S_OK;
  PWHTTPTST pwht = NULL;

    if( pwht = new WHTTPTST )
    {
      hr = pwht->_Initialize();

      if( SUCCEEDED(hr) )
      {
        hr = pwht->QueryInterface(riid, ppv);
      }
    }
    else
    {
      hr = E_OUTOFMEMORY;
    }

    if( FAILED(hr) )
    {
      SAFEDELETE(pwht);
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
WinHttpTest::_Initialize(void)
{
  DEBUG_ENTER((
    DBG_INITIALIZE,
    rt_hresult,
    "WinHttpTest::_Initialize",
    "this=%#x;",
    this
    ));

  HRESULT   hr  = S_OK;
  WCHAR*    buf = NULL;
  ITypeLib* ptl = NULL;

  buf = new WCHAR[MAX_PATH];

  if( buf )
  {
    if( GetModuleFileName(g_hGlobalDllInstance, buf, MAX_PATH) )
    {
      hr = LoadTypeLib(buf, &ptl);

      if( SUCCEEDED(hr) )
      {
        hr = GetTypeInfoFromName(g_wszWinHttpTestObjectName, ptl, &m_pti);
      }
    }
    else
    {
      hr = E_FAIL;
    }
  }

  SAFERELEASE(ptl);
  SAFEDELETEBUF(buf);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
WinHttpTest::_SetErrorCode(DWORD error)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::_SetErrorCode",
    "this=%#x; error=%s",
    this,
    MapErrorToString(error)
    ));

  HRESULT hr = S_OK;

  SAFERELEASE(m_pw32ec);

  hr = WHTERROR::Create(error, &m_pw32ec);

  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// IUnknown methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
WinHttpTest::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_REFCOUNT,
    rt_hresult,
    "WinHttpTest::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

    if( ppv )
    {
      if(
        IsEqualIID(riid, IID_IUnknown)     ||
        IsEqualIID(riid, IID_IDispatch)    ||
        IsEqualIID(riid, IID_IWinHttpTest)
        )
      {
        *ppv = static_cast<IWinHttpTest*>(this);
      }
      else if( IsEqualIID(riid, IID_IProvideClassInfo) )
      {
        *ppv = static_cast<IProvideClassInfo*>(this);
      }
      else
      {
        *ppv = NULL;
        hr   = E_NOINTERFACE;
      }
    }
    else
    {
      hr = E_POINTER;
    }

    if( SUCCEEDED(hr) )
    {
      DEBUG_TRACE(REFCOUNT, ("returning %s pointer", MapIIDToString(riid)));
      reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    }

  DEBUG_LEAVE(hr);
  return hr;
}


ULONG
__stdcall
WinHttpTest::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("WinHttpTest", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
WinHttpTest::Release(void)
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("WinHttpTest", m_cRefs);

  if( m_cRefs == 0 )
  {
    DEBUG_FINALRELEASE("WinHttpTest");
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IProvideClassInfo methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
WinHttpTest::GetClassInfo(ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::GetClassInfo",
    "this=%#x; ppti=%#x",
    this,
    ppti
    ));

  HRESULT hr = S_OK;

    if( ppti )
    {
      m_pti->AddRef();
      *ppti = m_pti;
    }
    else
    {
      hr = E_POINTER;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// WinHttpTest callback function
//-----------------------------------------------------------------------------
void
WinHttpCallback(
  HINTERNET hInternet,
  DWORD_PTR dwContext,
  DWORD     dwInternetStatus,
  LPVOID    lpvStatusInformation,
  DWORD     dwStatusInformationLength
  )
{
  DEBUG_ENTER((
    DBG_HELPER,
    rt_void,
    "WinHttpCallback",
    "hInternet=%#x; dwContext=%#x; dwInternetStatus=%d [%s]; lpvStatusInformation=%#x; dwStatusInformationLength=%#x",
    hInternet,
    dwContext,
    dwInternetStatus,
    MapCallbackFlagToString(dwInternetStatus),
    lpvStatusInformation,
    dwStatusInformationLength
    ));

  HRESULT    hr   = S_OK;
  IDispatch* pdc  = NULL;
  UINT       ae   = 0L;
  LCID       lcid = GetThreadLocale();
  DISPPARAMS dp;
  EXCEPINFO  ei;

  hr = ManageCallbackForHandle(hInternet, &pdc, CALLBACK_HANDLE_GET);
  
    if( FAILED(hr) )
      goto quit;

  memset((void*) &dp, 0x00, sizeof(DISPPARAMS));
  memset((void*) &ei, 0x00, sizeof(EXCEPINFO));

  dp.cArgs  = 5;
  dp.rgvarg = new VARIANT[dp.cArgs];

    if( !dp.rgvarg )
    {
      DEBUG_TRACE(HELPER, ("failed to allocate variant array!"));
      goto quit;
    }

  V_VT(&dp.rgvarg[4]) = VT_I4;
  V_I4(&dp.rgvarg[4]) = (DWORD) hInternet;

  V_VT(&dp.rgvarg[3]) = VT_I4;
  V_I4(&dp.rgvarg[3]) = dwContext;

  V_VT(&dp.rgvarg[2]) = VT_I4;
  V_I4(&dp.rgvarg[2]) = dwInternetStatus;

  V_VT(&dp.rgvarg[1]) = VT_I4;
  V_I4(&dp.rgvarg[1]) = (DWORD) lpvStatusInformation;

  V_VT(&dp.rgvarg[0]) = VT_I4;
  V_I4(&dp.rgvarg[0]) = dwStatusInformationLength;

  DEBUG_TRACE(HELPER, ("******** ENTER CALLBACK HANDLER ********"));

    hr = pdc->Invoke(
                DISPID_VALUE, IID_NULL,
                lcid, DISPATCH_METHOD,
                &dp, NULL, &ei, &ae
                );
  
  DEBUG_TRACE(HELPER, ("******** LEAVE CALLBACK HANDLER ********"));

quit:

  SAFEDELETEBUF(dp.rgvarg);
  DEBUG_LEAVE(0);
}


//-----------------------------------------------------------------------------
// HANDLEMAP hashtable support functions
//-----------------------------------------------------------------------------
void
CHandleMap::GetHashAndBucket(HINTERNET id, LPDWORD lpHash, LPDWORD lpBucket)
{
  DWORD hash = (DWORD) id;

  *lpHash   = hash;
  *lpBucket = hash % 10;
}

void
ScriptCallbackKiller(LPVOID* ppv)
{
  if( ppv )
  {
    ((IDispatch*) *ppv)->Release();
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\api\inetapiu.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    inetapiu.cxx

Abstract:

    Contains WinInet API utility & sub-API functions

    Contents:
        wInternetQueryDataAvailable

Author:

    Richard L Firth (rfirth) 16-Feb-1996

Environment:

    Win32 user-level

Revision History:

    16-Feb-1996 rfirth
        Created

--*/

#include <wininetp.h>

//
// functions
//


BOOL
wInternetQueryDataAvailable(
    IN LPVOID hFileMapped,
    OUT LPDWORD lpdwNumberOfBytesAvailable,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Part 2 of InternetQueryDataAvailabe. This function is called by the async
    worker thread in order to resume InternetQueryDataAvailable(), and by the
    app as the worker part of the API, post validation

    We can query available data for handle types that return data, either from
    a socket, or from a cache file:

        - HTTP request
        - FTP file
        - FTP find
        - FTP find HTML
        - gopher file
        - gopher find
        - gopher find HTML

Arguments:

    hFileMapped                 - the mapped HINTERNET

    lpdwNumberOfBytesAvailable  - where the number of bytes is returned

    dwFlags                     - flags controlling operation

    dwContext                   - context value for callbacks

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_INET,
                Bool,
                "wInternetQueryDataAvailable",
                "%#x, %#x, %#x, %#x",
                hFileMapped,
                lpdwNumberOfBytesAvailable,
                dwFlags,
                dwContext
                ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error;
    HINTERNET_HANDLE_TYPE handleType;

    INET_ASSERT(hFileMapped);

    //
    // as usual, grab the per-thread info block
    //

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    //
    // if this is the async worker thread then set the handle, and
    // last-error info in the per-thread data block before we go any further
    // (we already did this on the sync path)
    //

    if (lpThreadInfo->IsAsyncWorkerThread) {
        _InternetSetObjectHandle(lpThreadInfo,
                                 ((HANDLE_OBJECT *)hFileMapped)->GetPseudoHandle(),
                                 hFileMapped
                                 );
        _InternetClearLastError(lpThreadInfo);

        //
        // we should only be here in async mode if there was no data immediately
        // available
        //

        INET_ASSERT(!((INTERNET_HANDLE_OBJECT *)hFileMapped)->IsDataAvailable());

    }

    //
    // we copy the number of bytes available to a local variable first, and
    // only update the caller's variable if we succeed
    //

    DWORD bytesAvailable;

    //
    // get the current data available
    //

    error = ((HTTP_REQUEST_HANDLE_OBJECT *)hFileMapped)
                ->QueryDataAvailable(&bytesAvailable);

quit:

    BOOL success;

    if (error == ERROR_SUCCESS) {
        ((INTERNET_HANDLE_OBJECT *)hFileMapped)->SetAvailableDataLength(bytesAvailable);
        *lpdwNumberOfBytesAvailable = bytesAvailable;
        success = TRUE;

        DEBUG_PRINT(INET,
                    INFO,
                    ("%d bytes available\n",
                    bytesAvailable
                    ));

        DEBUG_PRINT_API(API,
                        INFO,
                        ("*lpdwNumberOfBytesAvailable (%#x) = %d\n",
                        lpdwNumberOfBytesAvailable,
                        bytesAvailable
                        ));

    } else {
        success = FALSE;

        DEBUG_ERROR(INET, error);

    }

    SetLastError(error);

    DEBUG_LEAVE(success);

    return success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\api\inetapia.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetapia.cxx

Abstract:

    Contains the ANSI and character-mode-independent Internet APIs

    Contents:
        WinHttpCloseHandle
        WinHttpReadData
        WinHttpWriteData
        WinHttpQueryDataAvailable
        
    
        WinHttpCrackUrlA
        WinHttpCreateUrlA
        InternetCanonicalizeUrlA
        InternetCombineUrlA
        InternetOpenA
        _InternetCloseHandle
        _InternetCloseHandleNoContext
        InternetConnectA
        InternetOpenUrlA
        ReadFile_End
        InternetQueryOptionA
        InternetSetOptionA
        InternetGetLastResponseInfoA
        (wInternetCloseConnectA)
        (CreateDeleteSocket)

Author:

    Richard L Firth (rfirth) 02-Mar-1995

Environment:

    Win32 user-mode DLL

Revision History:

    02-Mar-1995 rfirth
        Created

    07-Mar-1995 madana


--*/


#include <wininetp.h>
#include <perfdiag.hxx>

//  because wininet doesnt know IStream
#define NO_SHLWAPI_STREAM
#include <shlwapi.h>
#include <shlwapip.h>


//
// private manifests
//

//
// private prototypes
//

PRIVATE
DWORD
ReadFile_Fsm(
    IN CFsm_ReadFile * Fsm
    );

PRIVATE
DWORD
ReadFileEx_Fsm(
    IN CFsm_ReadFileEx * Fsm
    );

PRIVATE
VOID
ReadFile_End(
    IN BOOL bDeref,
    IN BOOL bSuccess,
    IN HINTERNET hFileMapped,
    IN DWORD dwBytesRead,
    IN LPVOID lpBuffer OPTIONAL,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead OPTIONAL
    );

PRIVATE
DWORD
QueryAvailable_Fsm(
    IN CFsm_QueryAvailable * Fsm
    );


PRIVATE
DWORD
wInternetCloseConnectA(
    IN HINTERNET lpConnectHandle,
    IN DWORD ServiceType
    );

PRIVATE
BOOL
InternetParseCommon(
    IN LPCTSTR lpszBaseUrl,
    IN LPCTSTR lpszRelativeUrl,
    OUT LPTSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );


//
// functions
//


INTERNETAPI
BOOL
WINAPI
WinHttpCrackUrlA(
    IN LPCSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN LPURL_COMPONENTSA lpUrlComponents
    )

/*++

Routine Description:

    Cracks an URL into its constituent parts. Optionally escapes the url-path.
    We assume that the user has supplied large enough buffers for the various
    URL parts

Arguments:

    lpszUrl         - pointer to URL to crack

    dwUrlLength     - 0 if lpszUrl is ASCIIZ string, else length of lpszUrl

    dwFlags         - flags controlling operation

    lpUrlComponents - pointer to URL_COMPONENTS

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpCrackUrlA",
                     "%q, %#x, %#x, %#x",
                     lpszUrl,
                     dwUrlLength,
                     dwFlags,
                     lpUrlComponents
                     ));

    DWORD error;

    //
    // validate parameters
    //
    if (!dwUrlLength)
        dwUrlLength = lstrlen(lpszUrl);

    //
    // get the individual components to return. If they reference a buffer then
    // check it for writeability
    //

    LPSTR lpUrl;
    LPSTR urlCopy;
    INTERNET_SCHEME schemeType;
    LPSTR schemeName;
    DWORD schemeNameLength;
    LPSTR hostName;
    DWORD hostNameLength;
    INTERNET_PORT nPort;
    LPSTR userName;
    DWORD userNameLength;
    LPSTR password;
    DWORD passwordLength;
    LPSTR urlPath;
    DWORD urlPathLength;
    LPSTR extraInfo;
    DWORD extraInfoLength;
    BOOL copyComponent;
    BOOL havePort;

    copyComponent = FALSE;

    schemeName = lpUrlComponents->lpszScheme;
    schemeNameLength = lpUrlComponents->dwSchemeLength;
    if ((schemeName != NULL) && (schemeNameLength != 0)) 
    {
        *schemeName = '\0';
        copyComponent = TRUE;
    }

    hostName = lpUrlComponents->lpszHostName;
    hostNameLength = lpUrlComponents->dwHostNameLength;
    if ((hostName != NULL) && (hostNameLength != 0)) 
    {
        *hostName = '\0';
        copyComponent = TRUE;
    }

    userName = lpUrlComponents->lpszUserName;
    userNameLength = lpUrlComponents->dwUserNameLength;
    if ((userName != NULL) && (userNameLength != 0)) 
    {
        *userName = '\0';
        copyComponent = TRUE;
    }

    password = lpUrlComponents->lpszPassword;
    passwordLength = lpUrlComponents->dwPasswordLength;
    if ((password != NULL) && (passwordLength != 0)) 
    {
        *password = '\0';
        copyComponent = TRUE;
    }

    urlPath = lpUrlComponents->lpszUrlPath;
    urlPathLength = lpUrlComponents->dwUrlPathLength;
    if ((urlPath != NULL) && (urlPathLength != 0)) 
    {
        *urlPath = '\0';
        copyComponent = TRUE;
    }

    extraInfo = lpUrlComponents->lpszExtraInfo;
    extraInfoLength = lpUrlComponents->dwExtraInfoLength;
    if ((extraInfo != NULL) && (extraInfoLength != 0)) 
    {
        *extraInfo = '\0';
        copyComponent = TRUE;
    }

    //
    // we can only escape or decode the URL if the caller has provided us with
    // buffers to write the escaped strings into
    //

    if (dwFlags & (ICU_ESCAPE | ICU_DECODE)) {
        if (!copyComponent) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }

        //
        // create a copy of the URL. CrackUrl() will modify this in situ. We
        // need to copy the results back to the user's buffer(s)
        //

        urlCopy = NewString((LPSTR)lpszUrl, dwUrlLength);
        if (urlCopy == NULL) {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }
        lpUrl = urlCopy;
    } else {
        lpUrl = (LPSTR)lpszUrl;
        urlCopy = NULL;
    }

    //
    // crack the URL into its constituent parts
    //

    error = CrackUrl(lpUrl,
                     dwUrlLength,
                     (dwFlags & ICU_ESCAPE) ? TRUE : FALSE,
                     &schemeType,
                     &schemeName,
                     &schemeNameLength,
                     &hostName,
                     &hostNameLength,
                     &nPort,
                     &userName,
                     &userNameLength,
                     &password,
                     &passwordLength,
                     &urlPath,
                     &urlPathLength,
                     extraInfoLength ? &extraInfo : NULL,
                     extraInfoLength ? &extraInfoLength : 0,
                     &havePort
                     );
    if (error != ERROR_SUCCESS) {
        goto crack_error;
    }

    BOOL copyFailure;

    copyFailure = FALSE;

    //
    // update the URL_COMPONENTS structure based on the results, and what was
    // asked for
    //

    if (lpUrlComponents->lpszScheme != NULL) {
        if (lpUrlComponents->dwSchemeLength > schemeNameLength) {
            memcpy((LPVOID)lpUrlComponents->lpszScheme,
                   (LPVOID)schemeName,
                   schemeNameLength
                   );
            lpUrlComponents->lpszScheme[schemeNameLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlace(lpUrlComponents->lpszScheme, 0);
            }
        } else {
            ++schemeNameLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwSchemeLength = schemeNameLength;
    } else if (lpUrlComponents->dwSchemeLength != 0) {
        lpUrlComponents->lpszScheme = schemeName;
        lpUrlComponents->dwSchemeLength = schemeNameLength;
    }

    if (lpUrlComponents->lpszHostName != NULL) {
        if (lpUrlComponents->dwHostNameLength > hostNameLength) {
            memcpy((LPVOID)lpUrlComponents->lpszHostName,
                   (LPVOID)hostName,
                   hostNameLength
                   );
            lpUrlComponents->lpszHostName[hostNameLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlace(lpUrlComponents->lpszHostName, 0);
            }
        } else {
            ++hostNameLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwHostNameLength = hostNameLength;
    } else if (lpUrlComponents->dwHostNameLength != 0) {
        lpUrlComponents->lpszHostName = hostName;
        lpUrlComponents->dwHostNameLength = hostNameLength;
    }

    if (lpUrlComponents->lpszUserName != NULL) {
        if (lpUrlComponents->dwUserNameLength > userNameLength) {
            memcpy((LPVOID)lpUrlComponents->lpszUserName,
                   (LPVOID)userName,
                   userNameLength
                   );
            lpUrlComponents->lpszUserName[userNameLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlace(lpUrlComponents->lpszUserName, 0);
            }
        } else {
            ++userNameLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwUserNameLength = userNameLength;
    } else if (lpUrlComponents->dwUserNameLength != 0) {
        lpUrlComponents->lpszUserName = userName;
        lpUrlComponents->dwUserNameLength = userNameLength;
    }

    if (lpUrlComponents->lpszPassword != NULL) {
        if (lpUrlComponents->dwPasswordLength > passwordLength) {
            memcpy((LPVOID)lpUrlComponents->lpszPassword,
                   (LPVOID)password,
                   passwordLength
                   );
            lpUrlComponents->lpszPassword[passwordLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlace(lpUrlComponents->lpszPassword, 0);
            }
        } else {
            ++passwordLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwPasswordLength = passwordLength;
    } else if (lpUrlComponents->dwPasswordLength != 0) {
        lpUrlComponents->lpszPassword = password;
        lpUrlComponents->dwPasswordLength = passwordLength;
    }

    if (lpUrlComponents->lpszUrlPath != NULL) {
        if (lpUrlComponents->dwUrlPathLength > urlPathLength) {
            memcpy((LPVOID)lpUrlComponents->lpszUrlPath,
                   (LPVOID)urlPath,
                   urlPathLength
                   );
            lpUrlComponents->lpszUrlPath[urlPathLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlace(lpUrlComponents->lpszUrlPath, 0);
            }
            lpUrlComponents->dwUrlPathLength = urlPathLength;
        } else {
            ++urlPathLength;
            copyFailure = TRUE;
            lpUrlComponents->dwUrlPathLength = urlPathLength;
        }
    } else if (lpUrlComponents->dwUrlPathLength != 0) {
        lpUrlComponents->lpszUrlPath = urlPath;
        lpUrlComponents->dwUrlPathLength = urlPathLength;
    }

    if (lpUrlComponents->lpszExtraInfo != NULL) {
        if (lpUrlComponents->dwExtraInfoLength > extraInfoLength) {
            memcpy((LPVOID)lpUrlComponents->lpszExtraInfo,
                   (LPVOID)extraInfo,
                   extraInfoLength
                   );
            lpUrlComponents->lpszExtraInfo[extraInfoLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlace(lpUrlComponents->lpszExtraInfo, 0);
            }
        } else {
            ++extraInfoLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwExtraInfoLength = extraInfoLength;
    } else if (lpUrlComponents->dwExtraInfoLength != 0) {
        lpUrlComponents->lpszExtraInfo = extraInfo;
        lpUrlComponents->dwExtraInfoLength = extraInfoLength;
    }

    //
    // we may have failed to copy one or more components because we didn't have
    // enough buffer space.
    //
    // N.B. Don't change error below here. If need be, move this test lower
    //

    if (copyFailure) {
        error = ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // copy the scheme type
    //

    lpUrlComponents->nScheme = schemeType;

    //
    // convert 0 port (not in URL) to default value for scheme
    //

    if (nPort == INTERNET_INVALID_PORT_NUMBER && !havePort) {
        switch (schemeType) {
        case INTERNET_SCHEME_HTTP:
            nPort = INTERNET_DEFAULT_HTTP_PORT;
            break;

        case INTERNET_SCHEME_HTTPS:
            nPort = INTERNET_DEFAULT_HTTPS_PORT;
            break;
        }
    }
    lpUrlComponents->nPort = nPort;

crack_error:

    if (urlCopy != NULL) {
        DEL_STRING(urlCopy);
    }

quit:
    BOOL success = (error==ERROR_SUCCESS);

    if (!success) {
        DEBUG_ERROR(API, error);
        SetLastError(error);
    }

    DEBUG_LEAVE_API(success);
    return success;
}


INTERNETAPI
BOOL
WINAPI
WinHttpCreateUrlA(
    IN LPURL_COMPONENTSA lpUrlComponents,
    IN DWORD dwFlags,
    OUT LPSTR lpszUrl OPTIONAL,
    IN OUT LPDWORD lpdwUrlLength
    )

/*++

Routine Description:

    Creates an URL from its constituent parts

Arguments:

    lpUrlComponents - pointer to URL_COMPONENTS structure containing pointers
                      and lengths of components of interest

    dwFlags         - flags controlling function:

                        ICU_ESCAPE  - the components contain characters that
                                      must be escaped in the output URL

    lpszUrl         - pointer to buffer where output URL will be written

    lpdwUrlLength   - IN: number of bytes in lpszUrl buffer
                      OUT: if success, number of characters in lpszUrl, else
                           number of bytes required for buffer

Return Value:

    BOOL
        Success - URL written to lpszUrl

        Failure - call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpCreateUrlA",
                     "%#x, %#x, %#x, %#x",
                     lpUrlComponents,
                     dwFlags,
                     lpszUrl,
                     lpdwUrlLength
                     ));

#if INET_DEBUG

    LPSTR lpszUrlOriginal = lpszUrl;

#endif

    DWORD error = ERROR_SUCCESS;
    LPSTR encodedUrlPath = NULL;
    LPSTR encodedExtraInfo = NULL;

    //
    // validate parameters
    //

    if (!ARGUMENT_PRESENT(lpszUrl)) {
        *lpdwUrlLength = 0;
    }

    //
    // allocate large buffers from heap
    //

    encodedUrlPath = (LPSTR)ALLOCATE_MEMORY(LMEM_FIXED, INTERNET_MAX_URL_LENGTH + 1);
    encodedExtraInfo = (LPSTR)ALLOCATE_MEMORY(LMEM_FIXED, INTERNET_MAX_URL_LENGTH + 1);
    if ((encodedUrlPath == NULL) || (encodedExtraInfo == NULL)) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // if we get an exception, we return ERROR_INVALID_PARAMETER
    //
    
    __try {

        //
        // get the individual components to copy
        //

        LPSTR schemeName;
        DWORD schemeNameLength;
        DWORD schemeFlags;
        LPSTR hostName;
        DWORD hostNameLength;
        INTERNET_PORT nPort;
        DWORD portLength;
        LPSTR userName;
        DWORD userNameLength;
        LPSTR password;
        DWORD passwordLength;
        LPSTR urlPath;
        DWORD urlPathLength;
        DWORD extraLength;
        DWORD encodedUrlPathLength;
        LPSTR extraInfo;
        DWORD extraInfoLength;
        DWORD encodedExtraInfoLength;
        LPSTR schemeSep;
        DWORD schemeSepLength;
        INTERNET_SCHEME schemeType;
        INTERNET_PORT defaultPort;

        //
        // if the scheme name is absent then we use the default
        //

        schemeName = lpUrlComponents->lpszScheme;
        schemeType = lpUrlComponents->nScheme;

        if (schemeName == NULL) {
            if (schemeType == INTERNET_SCHEME_DEFAULT){
                schemeName = DEFAULT_URL_SCHEME_NAME;
                schemeNameLength = sizeof(DEFAULT_URL_SCHEME_NAME) - 1;
            }
            else {
                schemeName = MapUrlScheme(schemeType, &schemeNameLength);
            }
        } else {
            schemeNameLength = lpUrlComponents->dwSchemeLength;
            if (schemeNameLength == 0) {
                schemeNameLength = lstrlen(schemeName);
            }
        }

        if (schemeNameLength == 0)
        {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }
        

        //
        // doesn't have to be a host name
        //

        hostName = lpUrlComponents->lpszHostName;
        portLength = 0;
        if (hostName != NULL) {
            hostNameLength = lpUrlComponents->dwHostNameLength;
            if (hostNameLength == 0) {
                hostNameLength = lstrlen(hostName);
            }

        //
        // if the port is default then we don't add it to the URL, else we need to
        // copy it as a string
        //
        // there won't be a port unless there's host.

            schemeType = MapUrlSchemeName(schemeName, schemeNameLength ? schemeNameLength : -1);
            switch (schemeType) {
            case INTERNET_SCHEME_HTTP:
                defaultPort = INTERNET_DEFAULT_HTTP_PORT;
                break;

            case INTERNET_SCHEME_HTTPS:
                defaultPort = INTERNET_DEFAULT_HTTPS_PORT;
                break;

            default:
                defaultPort = INTERNET_INVALID_PORT_NUMBER;
                break;
            }

            if (lpUrlComponents->nPort != defaultPort) {

                INTERNET_PORT divisor;

                nPort = lpUrlComponents->nPort;
                if (nPort) {
                    divisor = 10000;
                    portLength = 6; // max is 5 characters, plus 1 for ':'
                    while ((nPort / divisor) == 0) {
                        --portLength;
                        divisor /= 10;
                    }
                } else {
                    portLength = 2;         // port is ":0"
                }
            }
        } else {
            hostNameLength = 0;
        }


        //
        // doesn't have to be a user name
        //

        userName = lpUrlComponents->lpszUserName;
        if (userName != NULL) {
            userNameLength = lpUrlComponents->dwUserNameLength;
            if (userNameLength == 0) {
                userNameLength = lstrlen(userName);
            }
        } else {

            userNameLength = 0;
        }

        //
        // doesn't have to be a password
        //

        password = lpUrlComponents->lpszPassword;
        if (password != NULL) {
            passwordLength = lpUrlComponents->dwPasswordLength;
            if (passwordLength == 0) {
                passwordLength = lstrlen(password);
            }
        } else {

            passwordLength = 0;
        }

        //
        // but if there's a password without a user name, then its an error
        //

        if (password && !userName) {
            error = ERROR_INVALID_PARAMETER;
        } else {

            //
            // determine the scheme type for possible uses below
            //

            schemeFlags = 0;
            if (strnicmp(schemeName, "http", schemeNameLength) == 0) {
                schemeFlags = SCHEME_HTTP;
            } else if (strnicmp(schemeName, "ftp", schemeNameLength) == 0) {
                schemeFlags = SCHEME_FTP;
            } else if (strnicmp(schemeName, "gopher", schemeNameLength) == 0) {
                schemeFlags = SCHEME_GOPHER;
            }

            //
            // doesn't have to be an URL-path. Empty string is default
            //

            urlPath = lpUrlComponents->lpszUrlPath;
            if (urlPath != NULL) {
                urlPathLength = lpUrlComponents->dwUrlPathLength;
                if (urlPathLength == 0) {
                    urlPathLength = lstrlen(urlPath);
                }
                if ((*urlPath != '/') && (*urlPath != '\\')) {
                    extraLength = 1;
                } else {
                    extraLength = 0;
                }

                //
                // if requested, we will encode the URL-path
                //

                if (dwFlags & ICU_ESCAPE) {

                    //
                    // only encode the URL-path if it's a recognized scheme
                    //

                    if (schemeFlags != 0) {
                        encodedUrlPathLength = INTERNET_MAX_URL_LENGTH + 1;
                        error = EncodeUrlPath(NO_ENCODE_PATH_SEP,
                                              schemeFlags,
                                              urlPath,
                                              urlPathLength,
                                              &encodedUrlPath,
                                              &encodedUrlPathLength
                                              );
                        if (error == ERROR_SUCCESS) {
                            urlPath = encodedUrlPath;
                            urlPathLength = encodedUrlPathLength;
                        }
                    }
                }
            } else {
                urlPathLength = 0;
                extraLength = 0;
            }

            //
            // handle extra info if present
            //

            if (error == ERROR_SUCCESS) {
                extraInfo = lpUrlComponents->lpszExtraInfo;
                if (extraInfo != NULL) {
                    extraInfoLength = lpUrlComponents->dwExtraInfoLength;
                    if (extraInfoLength == 0) {
                        extraInfoLength = lstrlen(extraInfo);
                    }

                    //
                    // if requested, we will encode the extra info
                    //

                    if (dwFlags & ICU_ESCAPE) {

                        //
                        // only encode the extra info if it's a recognized scheme
                        //

                        if (schemeFlags != 0) {
                            encodedExtraInfoLength = INTERNET_MAX_URL_LENGTH + 1;
                            error = EncodeUrlPath(0,
                                                  schemeFlags,
                                                  extraInfo,
                                                  extraInfoLength,
                                                  &encodedExtraInfo,
                                                  &encodedExtraInfoLength
                                                  );
                            if (error == ERROR_SUCCESS) {
                                extraInfo = encodedExtraInfo;
                                extraInfoLength = encodedExtraInfoLength;
                            }
                        }
                    }
                } else {
                    extraInfoLength = 0;
                }
            }

            DWORD requiredSize;

            if (error == ERROR_SUCCESS) {

                //
                // Determine if we have a protocol scheme that requires slashes
                //

                if (DoesSchemeRequireSlashes(schemeName, schemeNameLength, (hostName != NULL))) {
                    schemeSep = "://";
                    schemeSepLength = sizeof("://") - 1;
                } else {
                    schemeSep = ":";
                    schemeSepLength = sizeof(":") - 1;
                }

                //
                // ensure we have enough buffer space
                //

                requiredSize = schemeNameLength
                             + schemeSepLength
                             + hostNameLength
                             + portLength
                             + (userName ? userNameLength + 1 : 0) // +1 for '@'
                             + (password ? passwordLength + 1 : 0) // +1 for ':'
                             + urlPathLength
                             + extraLength
                             + extraInfoLength
                             + 1                                // +1 for '\0'
                             ;

                //
                // if there is enough buffer, copy the URL
                //

                if (*lpdwUrlLength >= requiredSize) {
                    memcpy((LPVOID)lpszUrl, (LPVOID)schemeName, schemeNameLength);
                    lpszUrl += schemeNameLength;
                    memcpy((LPVOID)lpszUrl, (LPVOID)schemeSep, schemeSepLength);
                    lpszUrl += schemeSepLength;
                    if (userName) {
                        memcpy((LPVOID)lpszUrl, (LPVOID)userName, userNameLength);
                        lpszUrl += userNameLength;
                        if (password) {
                            *lpszUrl++ = ':';
                            memcpy((LPVOID)lpszUrl, (LPVOID)password, passwordLength);
                            lpszUrl += passwordLength;
                        }
                        *lpszUrl++ = '@';
                    }
                    if (hostName) {
                        memcpy((LPVOID)lpszUrl, (LPVOID)hostName, hostNameLength);
                        lpszUrl += hostNameLength;

                        // We won't attach a port unless there's a host to go with it.
                        if (portLength) {
                            lpszUrl += wsprintf(lpszUrl, ":%d", nPort & 0xffff);
                        }

                    }
                    if (urlPath) {

                        //
                        // Only do extraLength if we've actually copied something
                        // after the scheme.
                        //

                        if (extraLength != 0 && (userName || hostName || portLength)) {
                            *lpszUrl++ = '/';
                        } else if (extraLength != 0) {
                            --requiredSize;
                        }
                        memcpy((LPVOID)lpszUrl, (LPVOID)urlPath, urlPathLength);
                        lpszUrl += urlPathLength;
                    } else if (extraLength != 0) {
                        --requiredSize;
                    }
                    if (extraInfo) {
                        memcpy((LPVOID)lpszUrl, (LPVOID)extraInfo, extraInfoLength);
                        lpszUrl += extraInfoLength;
                    }

                    //
                    // terminate string
                    //

                    *lpszUrl = '\0';

                    //
                    // -1 for terminating '\0'
                    //

                    --requiredSize;
                } else {

                    //
                    // not enough buffer space - just return the required buffer length
                    //

                    error = ERROR_INSUFFICIENT_BUFFER;
                }
            }

            //
            // update returned parameters
            //

            *lpdwUrlLength = requiredSize;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        error = ERROR_INVALID_PARAMETER;
    }
    ENDEXCEPT
quit:

    //
    // clear up the buffers we allocated
    //


    if (encodedUrlPath != NULL) {
        FREE_MEMORY(encodedUrlPath);
    }
    if (encodedExtraInfo != NULL) {
        FREE_MEMORY(encodedExtraInfo);
    }

    BOOL success = (error==ERROR_SUCCESS);

    if (success) {

        DEBUG_PRINT_API(API,
                        INFO,
                        ("URL = %q\n",
                        lpszUrlOriginal
                        ));
    } else {

        DEBUG_ERROR(API, error);
        SetLastError(error);
    }

    DEBUG_LEAVE_API(success);
    return success;
}

//
//  ICUHrToWin32Error() is specifically for converting the return codes for
//  Url* APIs in shlwapi into win32 errors.
//  WARNING:  it should not be used for any other purpose.
//
DWORD
ICUHrToWin32Error(HRESULT hr)
{
    DWORD err = ERROR_INVALID_PARAMETER;
    switch(hr)
    {
    case E_OUTOFMEMORY:
        err = ERROR_NOT_ENOUGH_MEMORY;
        break;

    case E_POINTER:
        err = ERROR_INSUFFICIENT_BUFFER;
        break;

    case S_OK:
        err = ERROR_SUCCESS;
        break;

    default:
        break;
    }
    return err;
}


INTERNETAPI
BOOL
WINAPI
InternetCanonicalizeUrlA(
    IN LPCSTR lpszUrl,
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Combines a relative URL with a base URL to form a new full URL.

Arguments:

    lpszUrl             - pointer to URL to be canonicalize
    lpszBuffer          - pointer to buffer where new URL is written
    lpdwBufferLength    - size of buffer on entry, length of new URL on exit
    dwFlags             - flags controlling operation

Return Value:

    BOOL                - TRUE if successful, FALSE if not

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetCanonicalizeUrlA",
                     "%q, %#x, %#x [%d], %#x",
                     lpszUrl,
                     lpszBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0,
                     dwFlags
                     ));

    HRESULT hr ;
    BOOL bRet = TRUE;;

    INET_ASSERT(lpszUrl);
    INET_ASSERT(lpszBuffer);
    INET_ASSERT(lpdwBufferLength && (*lpdwBufferLength > 0));

    //
    //  the flags for the Url* APIs in shlwapi should be the same
    //  except that NO_ENCODE is on by default.  so we need to flip it
    //
    dwFlags ^= ICU_NO_ENCODE;

    // Check for invalid parameters

    if (!lpszUrl || !lpszBuffer || !lpdwBufferLength || *lpdwBufferLength == 0 || IsBadWritePtr(lpszBuffer, *lpdwBufferLength*sizeof(CHAR)))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = UrlCanonicalizeA(lpszUrl, lpszBuffer,
                    lpdwBufferLength, dwFlags | URL_WININET_COMPATIBILITY);
    }

    if(FAILED(hr))
    {
        DWORD dw = ICUHrToWin32Error(hr);

        bRet = FALSE;

        DEBUG_ERROR(API, dw);

        SetLastError(dw);
    }

    DEBUG_LEAVE_API(bRet);

    return bRet;
}


INTERNETAPI
BOOL
WINAPI
InternetCombineUrlA(
    IN LPCSTR lpszBaseUrl,
    IN LPCSTR lpszRelativeUrl,
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Combines a relative URL with a base URL to form a new full URL.

Arguments:

    lpszBaseUrl         - pointer to base URL
    lpszRelativeUrl     - pointer to relative URL
    lpszBuffer          - pointer to buffer where new URL is written
    lpdwBufferLength    - size of buffer on entry, length of new URL on exit
    dwFlags             - flags controlling operation

Return Value:

    BOOL                - TRUE if successful, FALSE if not

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetCombineUrlA",
                     "%q, %q, %#x, %#x [%d], %#x",
                     lpszBaseUrl,
                     lpszRelativeUrl,
                     lpszBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0,
                     dwFlags
                     ));

    HRESULT hr ;
    BOOL bRet;

    INET_ASSERT(lpszBaseUrl);
    INET_ASSERT(lpszRelativeUrl);
    INET_ASSERT(lpdwBufferLength);

    //
    //  the flags for the Url* APIs in shlwapi should be the same
    //  except that NO_ENCODE is on by default.  so we need to flip it
    //
    dwFlags ^= ICU_NO_ENCODE;

    // Check for invalid parameters

    if (!lpszBaseUrl || !lpszRelativeUrl || !lpdwBufferLength || (lpszBuffer && IsBadWritePtr(lpszBuffer, *lpdwBufferLength*sizeof(CHAR))))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = UrlCombineA(lpszBaseUrl, lpszRelativeUrl, lpszBuffer,
                    lpdwBufferLength, dwFlags | URL_WININET_COMPATIBILITY);
    }

    if(FAILED(hr))
    {
        DWORD dw = ICUHrToWin32Error(hr);

        bRet = FALSE;

        DEBUG_ERROR(API, dw);

        SetLastError(dw);
    }
    else
        bRet = TRUE;

    IF_DEBUG_CODE() {
        if (bRet) {
            DEBUG_PRINT_API(API,
                            INFO,
                            ("URL = %q\n",
                            lpszBuffer
                            ));
        }
    }

    DEBUG_LEAVE_API(bRet);

    return bRet;
}


INTERNETAPI
HINTERNET
WINAPI
InternetOpenA(
    IN LPCSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCSTR lpszProxy OPTIONAL,
    IN LPCSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Opens a root Internet handle from which all HINTERNET objects are derived

Arguments:

    lpszAgent       - name of the application making the request (arbitrary
                      identifying string). Used in "User-Agent" header when
                      communicating with HTTP servers, if the application does
                      not add a User-Agent header of its own

    dwAccessType    - type of access required. Can be

                        INTERNET_OPEN_TYPE_PRECONFIG
                            - Gets the configuration from the registry

                        INTERNET_OPEN_TYPE_DIRECT
                            - Requests are made directly to the nominated server

                        INTERNET_OPEN_TYPE_PROXY
                            - Requests are made via the nominated proxy

                        INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY
                            - Like Pre-Config, but prevents JavaScript, INS
                                and other auto-proxy types from being used.

    lpszProxy       - if INTERNET_OPEN_TYPE_PROXY, a list of proxy servers to
                      use

    lpszProxyBypass - if INTERNET_OPEN_TYPE_PROXY, a list of servers which we
                      will communicate with directly

    dwFlags         - flags to control the operation of this API or potentially
                      all APIs called on the handle generated by this API.
                      Currently supported are:

                        WINHTTP_FLAG_ASYNC - Not supported in WinHttpX v6.


Return Value:

    HINTERNET
        Success - handle of Internet object

        Failure - NULL. For more information, call GetLastError()

--*/

{
    PERF_INIT();

    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "InternetOpenA",
                     "%q, %s (%d), %q, %q, %#x",
                     lpszAgent,
                     InternetMapOpenType(dwAccessType),
                     dwAccessType,
                     lpszProxy,
                     lpszProxyBypass,
                     dwFlags
                     ));

    DWORD error;
    HINTERNET hInternet = NULL;

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }

    //
    // validate parameters
    //

    if (!
         (
              (dwAccessType == INTERNET_OPEN_TYPE_DIRECT)
           || (dwAccessType == INTERNET_OPEN_TYPE_PROXY)
           || (dwAccessType == INTERNET_OPEN_TYPE_PRECONFIG)
           || (dwAccessType == INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY)
           || (
                (dwAccessType == INTERNET_OPEN_TYPE_PROXY)
                &&
                    (
                       !ARGUMENT_PRESENT(lpszProxy)
                    || (*lpszProxy == '\0')

                    )
              )
           || (dwFlags & ~WINHTTP_OPEN_FLAGS_MASK)
         )
       )
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }


    INTERNET_HANDLE_OBJECT * lpInternet;

    lpInternet = New INTERNET_HANDLE_OBJECT(lpszAgent,
                                            dwAccessType,
                                            (LPSTR)lpszProxy,
                                            (LPSTR)lpszProxyBypass,
                                            dwFlags
                                            );
    if (lpInternet == NULL) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }
    error = lpInternet->GetStatus();
    if (error == ERROR_SUCCESS) {
        hInternet = (HINTERNET)lpInternet;

        //
        // success - don't return the object address, return the pseudo-handle
        // value we generated
        //

        hInternet = ((HANDLE_OBJECT *)hInternet)->GetPseudoHandle();
        
    } else {

        //
        // hack fix to stop InternetIndicateStatus (called from the handle
        // object destructor) blowing up if there is no handle object in the
        // thread info block. We can't call back anyway
        //

        LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

        if (lpThreadInfo) {

            //
            // BUGBUG - incorrect handle value
            //

            _InternetSetObjectHandle(lpThreadInfo, lpInternet, lpInternet);
        }

        //
        // we failed during initialization. Kill the handle using Dereference()
        // (in order to stop the debug version complaining about the reference
        // count not being 0. Invalidate for same reason)
        //

        lpInternet->Invalidate();
        lpInternet->Dereference();

        INET_ASSERT(hInternet == NULL);

    }

quit:

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(API, error);

        SetLastError(error);
    }

    DEBUG_LEAVE_API(hInternet);

    return hInternet;
}


INTERNETAPI
BOOL
WINAPI
WinHttpCloseHandle(
    IN HINTERNET hInternet
    )

/*++

Routine Description:

    Closes any open internet handle object

Arguments:

    hInternet   - handle of internet object to close

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. For more information call GetLastError()

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpCloseHandle",
                     "%#x",
                     hInternet
                     ));

    PERF_ENTER(InternetCloseHandle);

    DWORD error;
    BOOL success = FALSE;
    HINTERNET hInternetMapped = NULL;

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }

    //
    // map the handle. Don't invalidate it (_InternetCloseHandle() does this)
    //

    error = MapHandleToAddress(hInternet, (LPVOID *)&hInternetMapped, FALSE);
    if (error != ERROR_SUCCESS) {
        if (hInternetMapped == NULL) {

            //
            // the handle never existed or has been completely destroyed
            //

            DEBUG_PRINT(API,
                        ERROR,
                        ("Handle %#x is invalid\n",
                        hInternet
                        ));

            //
            // catch invalid handles - may help caller
            //

            DEBUG_BREAK(INVALID_HANDLES);

        } else {

            //
            // this handle is already being closed (it's invalidated). We only
            // need one InternetCloseHandle() operation to invalidate the handle.
            // All other threads will simply dereference the handle, and
            // eventually it will be destroyed
            //

            DereferenceObject((LPVOID)hInternetMapped);
        }
        goto quit;
    }

    //
    // the handle is not invalidated
    //

    HANDLE_OBJECT * pHandle;

    pHandle = (HANDLE_OBJECT *)hInternetMapped;

    DEBUG_PRINT(INET,
                INFO,
                ("handle %#x == %#x == %s\n",
                hInternet,
                hInternetMapped,
                InternetMapHandleType(pHandle->GetHandleType())
                ));

    //
    // clear the handle object last error variables
    //

    InternetClearLastError();

    //
    // decrement session count here rather than in destructor, since 
    // the session is ref-counted and there may still be outstanding
    // references from request/connect handles on async fsms.
    //
    if (pHandle->GetHandleType() == TypeInternetHandle)
    {
        InterlockedDecrement(&g_cSessionCount);
    }

    //
    // remove the reference added by MapHandleToAddress(), or the handle won't
    // be destroyed by _InternetCloseHandle()
    //

    DereferenceObject((LPVOID)hInternetMapped);

    //
    // use _InternetCloseHandle() to do the work
    //

    success = _InternetCloseHandle(hInternet);

quit:

    // SetLastError must be called after PERF_LEAVE !!!
    PERF_LEAVE(InternetCloseHandle);

    if (error != ERROR_SUCCESS) {
        DEBUG_ERROR(API, error);
        SetLastError(error);
    }

    DEBUG_LEAVE_API(success);

    return success;
}


BOOL
_InternetCloseHandle(
    IN HINTERNET hInternet
    )

/*++

Routine Description:

    Same as InternetCloseHandle() except does not clear out the last error text.
    Mainly for FTP

Arguments:

    hInternet   - handle of internet object to close

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. For more information call GetLastError()

--*/

{
    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "_InternetCloseHandle",
                 "%#x",
                 hInternet
                 ));

    DWORD error;
    BOOL success;
    HINTERNET hInternetMapped = NULL;
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo == NULL) {
        if (InDllCleanup) {
            error = ERROR_WINHTTP_SHUTDOWN;
        } else {

            INET_ASSERT(FALSE);

            error = ERROR_WINHTTP_INTERNAL_ERROR;
        }
        goto quit;
    }

    //
    // map the handle and invalidate it. This will cause any new requests with
    // the handle as a parameter to fail
    //

    error = MapHandleToAddress(hInternet, (LPVOID *)&hInternetMapped, TRUE);
    if (error != ERROR_SUCCESS) {
        if (hInternetMapped != NULL) {

            //
            // the handle is already being closed, or is already deleted
            //

            DereferenceObject((LPVOID)hInternetMapped);
        }

        //
        // since this is the only function that can invalidate a handle, if we
        // are here then the handle is just waiting for its refcount to go to
        // zero. We already removed the refcount we added above, so we're in
        // the clear
        //

        goto quit;
    }

    //
    // there may be an active socket operation. We close the socket to abort the
    // operation
    //

    ((INTERNET_HANDLE_OBJECT *)hInternetMapped)->AbortSocket();

    //
    // we need the parent handle - we will set this as the handle object being
    // processed by this thread. This is required for async worker threads (see
    // below)
    //

    HINTERNET hParent;
    HINTERNET hParentMapped;
    DWORD_PTR dwParentContext;

    hParentMapped = ((HANDLE_OBJECT *)hInternetMapped)->GetParent();
    if (hParentMapped != NULL) {
        hParent = ((HANDLE_OBJECT *)hParentMapped)->GetPseudoHandle();
        dwParentContext = ((HANDLE_OBJECT *)hParentMapped)->GetContext();
    }

    //
    // set the object handle in the per-thread data structure
    //

    _InternetSetObjectHandle(lpThreadInfo, hInternet, hInternetMapped);

    //
    // at this point, there should *always* be at least 2 references on the
    // handle - one added when the object was created, and one added by
    // MapHandleToAddress() above. If the object is still alive after the 2
    // dereferences, then it will be destroyed when the current owning thread
    // dereferences it
    //

    (void)DereferenceObject((LPVOID)hInternetMapped);
    error = DereferenceObject((LPVOID)hInternetMapped);

    //
    // now set the object to be the parent. This is necessary for e.g.
    // FtpGetFile() and async requests (where the async worker thread will make
    // an extra callback to deliver the results of the async request)
    //

    if (hParentMapped != NULL) {
        _InternetSetObjectHandle(lpThreadInfo, hParent, hParentMapped);
    }

    //
    // if the handle was still alive after dereferencing it then we will inform
    // the app that the close is pending
    //

quit:

    success = (error==ERROR_SUCCESS);
    if (!success) {
        SetLastError(error);
        DEBUG_ERROR(INET, error);
    }
    DEBUG_LEAVE(success);
    return success;
}


DWORD
_InternetCloseHandleNoContext(
    IN HINTERNET hInternet
    )

/*++

Routine Description:

    Same as _InternetCloseHandle() except does not change the per-thread info
    structure handle/context values

    BUGBUG - This should be handled via a parameter to _InternetCloseHandle(),
             but its close to shipping...

Arguments:

    hInternet   - handle of internet object to close

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE

--*/

{
    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "_InternetCloseHandleNoContext",
                 "%#x",
                 hInternet
                 ));

    DWORD error;
    HINTERNET hInternetMapped = NULL;

    //
    // map the handle and invalidate it. This will cause any new requests with
    // the handle as a parameter to fail
    //

    error = MapHandleToAddress(hInternet, (LPVOID *)&hInternetMapped, TRUE);
    if (error != ERROR_SUCCESS) {
        if (hInternetMapped != NULL) {

            //
            // the handle is already being closed, or is already deleted
            //

            DereferenceObject((LPVOID)hInternetMapped);
        }

        //
        // since this is the only function that can invalidate a handle, if we
        // are here then the handle is just waiting for its refcount to go to
        // zero. We already removed the refcount we added above, so we're in
        // the clear
        //

        goto quit;
    }

    //
    // there may be an active socket operation. We close the socket to abort the
    // operation
    //

    ((INTERNET_HANDLE_OBJECT *)hInternetMapped)->AbortSocket();

    //
    // at this point, there should *always* be at least 2 references on the
    // handle - one added when the object was created, and one added by
    // MapHandleToAddress() above. If the object is still alive after the 2
    // dereferences, then it will be destroyed when the current owning thread
    // dereferences it
    //

    (void)DereferenceObject((LPVOID)hInternetMapped);
    error = DereferenceObject((LPVOID)hInternetMapped);

quit:

    DEBUG_LEAVE(error);

    return error;
}



INTERNETAPI
HINTERNET
WINAPI
InternetConnectA(
    IN HINTERNET hInternet,
    IN LPCSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Opens a connection with a server, logging-on the user in the process.

Arguments:

    hInternet       - Internet handle, returned by InternetOpen()

    lpszServerName  - name of server with which to connect

    nServerPort     - port at which server listens

    dwFlags         - protocol-specific flags. The following are defined:
                        - INTERNET_FLAG_KEEP_CONNECTION (HTTP)
                        - WINHTTP_FLAG_SECURE (HTTP)

    dwContext       - application-supplied value used to identify this
                      request in callbacks

Return Value:

    HINTERNET
        Success - address of a new handle object

        Failure - NULL. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "InternetConnectA",
                     "%#x, %q, %d, %#08x, %#x",
                     hInternet,
                     lpszServerName,
                     nServerPort,
                     dwFlags,
                     dwContext
                     ));

    HINTERNET connectHandle = NULL;
    HINTERNET hInternetMapped = NULL;

    LPINTERNET_THREAD_INFO lpThreadInfo;

    INTERNET_CONNECT_HANDLE_OBJECT * pConnect = NULL;

    BOOL bIsWorker = FALSE;
    BOOL bNonNestedAsync = FALSE;
    BOOL isAsync;

    DWORD error = ERROR_SUCCESS;

    if (!GlobalDataInitialized) {
        error = ERROR_WINHTTP_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the per-thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();
    bIsWorker = lpThreadInfo->IsAsyncWorkerThread;
    bNonNestedAsync = bIsWorker && (lpThreadInfo->NestedRequests == 1);

    //
    // handle/refcount munging:
    //
    //  sync:
    //      map hInternet on input (+1 ref)
    //      generate connect handle (1 ref)
    //      if failure && !connect handle
    //          close connect handle (0 refs: delete)
    //      if success
    //          deref hInternet (-1 ref)
    //      else if going async
    //          ref connect handle (2 refs)
    //
    //  async:
    //      hInternet is mapped connect handle (2 refs)
    //      get real hInternet from connect handle parent (2 refs (e.g.))
    //      deref connect handle (1 ref)
    //      if failure
    //          close connect handle (0 refs: delete)
    //      deref open handle (-1 ref)
    //
    // N.B. the final deref of the *indicated* handle on async callback will
    // happen in the async code
    //

    if (bNonNestedAsync) {
        connectHandle = hInternet;
        hInternetMapped = ((HANDLE_OBJECT *)connectHandle)->GetParent();
        hInternet = ((HANDLE_OBJECT *)hInternetMapped)->GetPseudoHandle();
    } else {
        error = MapHandleToAddress(hInternet, (LPVOID *)&hInternetMapped, FALSE);
        if ((error != ERROR_SUCCESS) && (hInternetMapped == NULL)) {
            goto quit;
        }

        //
        // set the info and clear the last error info
        //

        _InternetSetObjectHandle(lpThreadInfo, hInternet, hInternetMapped);
        _InternetClearLastError(lpThreadInfo);

        //
        // quit now if the handle object is invalidated
        //

        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        //
        // validate the handle & discover sync/async
        //

        error = RIsHandleLocal(hInternetMapped,
                               NULL,
                               &isAsync,
                               TypeInternetHandle
                               );
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        //
        // we allow all valid flags to be passed in
        //

        if ((dwFlags & ~WINHTTP_CONNECT_FLAGS_MASK)
            || (lpszServerName == NULL)
            || (*lpszServerName == '\0')) 
        {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }
    }

    //
    // validate arguments if we're not in the async thread context, in which
    // case we did this when the original request was made
    //

    if (bNonNestedAsync)
    {
        pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)connectHandle;
    }
    else
    {
        //
        // app thread or in async worker thread but being called from another
        // async API, such as InternetOpenUrl()
        //

        INET_ASSERT(connectHandle == NULL);
        INET_ASSERT(error == ERROR_SUCCESS);
           
        error = RMakeInternetConnectObjectHandle(
                    hInternetMapped,
                    &connectHandle,
                    (LPSTR) lpszServerName,
                    nServerPort,
                    dwFlags,
                    dwContext
                    );
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        //
        // this new handle will be used in callbacks
        //

        _InternetSetObjectHandle(lpThreadInfo,
                                 ((HANDLE_OBJECT *)connectHandle)->GetPseudoHandle(),
                                 connectHandle
                                 );

        //
        // based on whether we have been asked to perform async I/O AND we are not
        // in an async worker thread context AND the request is to connect with an
        // FTP service (currently only FTP because this request performs network
        // I/O - gopher and HTTP just allocate & fill in memory) AND there is a
        // valid context value, we will queue the async request, or execute the
        // request synchronously
        //

        pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)connectHandle;
    }
    

    INET_ASSERT(error == ERROR_SUCCESS);

quit:

    _InternetDecNestingCount(1);


done:

    if (error == ERROR_SUCCESS) {

        //
        // success - return generated pseudo-handle
        //

        connectHandle = ((HANDLE_OBJECT *)connectHandle)->GetPseudoHandle();

    } else {
        if (bNonNestedAsync
            && (/*((HANDLE_OBJECT *)connectHandle)->Dereference()
                ||*/ ((HANDLE_OBJECT *)connectHandle)->IsInvalidated())) {
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
        }

        //
        // if we are not pending an async request but we created a handle object
        // then close it
        //

        if ((error != ERROR_IO_PENDING) && (connectHandle != NULL)) {

            //
            // use _InternetCloseHandle() to close the handle: it doesn't clear
            // out the last error text, so that an app can find out what the
            // server sent us in the event of an FTP login failure
            //


            if (bNonNestedAsync) {

                //
                // this handle deref'd at async completion
                //

                hInternetMapped = NULL;
            }
            else
            {
                _InternetCloseHandle(((HANDLE_OBJECT *)connectHandle)->GetPseudoHandle());
            }
        }
        connectHandle = NULL;
    }
    if (hInternetMapped != NULL) {
        DereferenceObject((LPVOID)hInternetMapped);
    }
    if (error != ERROR_SUCCESS) {
        DEBUG_ERROR(API, error);
        SetLastError(error);
    }
    DEBUG_LEAVE_API(connectHandle);
    return connectHandle;
}



INTERNETAPI
HINTERNET
WINAPI
InternetOpenUrlA(
    IN HINTERNET hInternet,
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    // this is dead code
    return FALSE;
}



INTERNETAPI
BOOL
WINAPI
WinHttpReadData(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    )

/*++

Routine Description:

    This functions reads the next block of data from the file object.

Arguments:

    hFile                   - handle returned from Open function

    lpBuffer                - pointer to caller's buffer

    dwNumberOfBytesToRead   - size of lpBuffer in BYTEs

    lpdwNumberOfBytesRead   - returned number of bytes read into lpBuffer

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpReadData",
                     "%#x, %#x, %d, %#x",
                     hFile,
                     lpBuffer,
                     dwNumberOfBytesToRead,
                     lpdwNumberOfBytesRead
                     ));

    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD nestingLevel = 0;
    DWORD error;
    BOOL success = FALSE;
    HINTERNET hFileMapped = NULL;
    DWORD bytesRead = 0;
    BOOL bEndRead = TRUE;

    if (!GlobalDataInitialized)
    {
        error = ERROR_WINHTTP_NOT_INITIALIZED;
        goto done;
    }

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL)
    {
        INET_ASSERT(FALSE);
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto done;
    }

    //INET_ASSERT(lpThreadInfo->Fsm == NULL);

    _InternetIncNestingCount();
    nestingLevel = 1;

    error = MapHandleToAddress(hFile, (LPVOID *)&hFileMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hFileMapped == NULL))
    {
        goto quit;
    }

    // set the handle, and last-error info in the per-thread data block
    // before we go any further. This allows us to return a status in the async
    // case, even if the handle has been closed

    if (!lpThreadInfo->IsAsyncWorkerThread)
    {
        PERF_LOG(PE_CLIENT_REQUEST_START,
                 AR_INTERNET_READ_FILE,
                 lpThreadInfo->ThreadId,
                 hFile
                 );
    }

    _InternetSetObjectHandle(lpThreadInfo, hFile, hFileMapped);
    _InternetClearLastError(lpThreadInfo);

    // if MapHandleToAddress() returned a non-NULL object address, but also an
    // error status, then the handle is being closed - quit
    if (error != ERROR_SUCCESS)
    {
        goto quit;
    }

    BOOL isAsync;
    error = RIsHandleLocal(hFileMapped, NULL, &isAsync, TypeHttpRequestHandle);
    if (error != ERROR_SUCCESS)
    {
        INET_ASSERT(FALSE);
        goto quit;
    }

    // validate parameters
    if (!lpThreadInfo->IsAsyncWorkerThread)
    {
        error = ProbeAndSetDword(lpdwNumberOfBytesRead, 0);
        if (error != ERROR_SUCCESS)
        {
            goto quit;
        }
        error = ProbeWriteBuffer(lpBuffer, dwNumberOfBytesToRead);
        if (error != ERROR_SUCCESS)
        {
            goto quit;
        }

        *lpdwNumberOfBytesRead = 0;

    } // end if (!lpThreadInfo->IsAsyncWorkerThread)


    INET_ASSERT(error == ERROR_SUCCESS);

    // just call the underlying API: return whatever it returns, and let it
    // handle setting the last error

    CFsm_ReadFile *pFsm;

    pFsm = New CFsm_ReadFile(lpBuffer,
                             dwNumberOfBytesToRead,
                             lpdwNumberOfBytesRead
                             );

    
    if (pFsm != NULL)
    {
        HTTP_REQUEST_HANDLE_OBJECT *pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hFileMapped;
        if (isAsync && !lpThreadInfo->IsAsyncWorkerThread)
        {
            error = DoAsyncFsm(pFsm, pRequest);
        }
        else
        {
            pFsm->SetPushPop(TRUE);
            pFsm->Push();
            error = DoFsm(pFsm);
        }
    }
    else
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    success = (error == ERROR_SUCCESS) ? TRUE : FALSE;
    bEndRead = FALSE;


quit:

    _InternetDecNestingCount(nestingLevel);;

    if (bEndRead)
    {
        //
        // if handleType is not HttpRequest or File then we are making this
        // request in the context of an uninterruptable async worker thread.
        // HTTP and file requests use the normal mechanism. In the case of non-
        // HTTP and file requests, we need to treat the request as if it were
        // sync and deref the handle
        //

        ReadFile_End(!lpThreadInfo->IsAsyncWorkerThread,
                     success,
                     hFileMapped,
                     bytesRead,
                     lpBuffer,
                     dwNumberOfBytesToRead,
                     lpdwNumberOfBytesRead
                     );
    }

    if (lpThreadInfo && !lpThreadInfo->IsAsyncWorkerThread)
    {

        PERF_LOG(PE_CLIENT_REQUEST_END,
                 AR_INTERNET_READ_FILE,
                 bytesRead,
                 lpThreadInfo->ThreadId,
                 hFile
                 );

    }

done:

    // if error is not ERROR_SUCCESS then this function returning the error,
    // otherwise the error has already been set by the API we called,
    // irrespective of the value of success
    if (error != ERROR_SUCCESS)
    {
        DEBUG_ERROR(API, error);
        SetLastError(error);
        success = FALSE;
    }

    DEBUG_LEAVE_API(success);
    return success;
}


PRIVATE
VOID
ReadFile_End(
    IN BOOL bDeref,
    IN BOOL bSuccess,
    IN HINTERNET hFileMapped,
    IN DWORD dwBytesRead,
    IN LPVOID lpBuffer OPTIONAL,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead OPTIONAL
    )

/*++

Routine Description:

    Common end-of-read processing:

        - update bytes read parameter
        - dump data if logging & API data requested
        - dereference handle if not async request

Arguments:

    bDeref                  - TRUE if handle should be dereferenced (should be
                              FALSE for async request)

    bSuccess                - TRUE if Read completed successfully

    hFileMapped             - mapped file handle

    dwBytesRead             - number of bytes read

    lpBuffer                - into this buffer

    dwNumberOfBytesToRead   - originally requested bytes to read

    lpdwNumberOfBytesRead   - where bytes read is stored

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_INET,
                 None,
                 "ReadFile_End",
                 "%B, %B, %#x, %d, %#x, %d, %#x",
                 bDeref,
                 bSuccess,
                 hFileMapped,
                 dwBytesRead,
                 lpBuffer,
                 dwNumberOfBytesToRead,
                 lpdwNumberOfBytesRead
                 ));

    if (bSuccess) {

        //
        // update the amount of immediate data available only if we succeeded
        //

        ((INTERNET_HANDLE_OBJECT *)hFileMapped)->ReduceAvailableDataLength(dwBytesRead);

        if (lpdwNumberOfBytesRead != NULL) {
            *lpdwNumberOfBytesRead = dwBytesRead;

            DEBUG_PRINT(API,
                        INFO,
                        ("*lpdwNumberOfBytesRead = %d\n",
                        *lpdwNumberOfBytesRead
                        ));

            //
            // dump API data only if requested
            //

            IF_DEBUG_CONTROL(DUMP_API_DATA) {
                DEBUG_DUMP_API(API,
                               "Received data:\n",
                               lpBuffer,
                               *lpdwNumberOfBytesRead
                               );
            }

        }
        if (dwBytesRead < dwNumberOfBytesToRead) {

            DEBUG_PRINT(API,
                        INFO,
                        ("(!) bytes read (%d) < bytes requested (%d)\n",
                        dwBytesRead,
                        dwNumberOfBytesToRead
                        ));

        }
    }

    //
    // if async request, handle will be deref'd after REQUEST_COMPLETE callback
    // is delivered
    //

    if (bDeref && (hFileMapped != NULL)) {
        DereferenceObject((LPVOID)hFileMapped);
    }

    PERF_LOG(PE_CLIENT_REQUEST_END,
             AR_INTERNET_READ_FILE,
             dwBytesRead,
             0,
             (!bDeref && hFileMapped) ? ((INTERNET_HANDLE_OBJECT *)hFileMapped)->GetPseudoHandle() : NULL
             );

    DEBUG_LEAVE(0);
}




DWORD
CFsm_ReadFile::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_ReadFile::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    CFsm_ReadFile * stateMachine = (CFsm_ReadFile *)Fsm;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = ReadFile_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
ReadFile_Fsm(
    IN CFsm_ReadFile * Fsm
    )
{
    DEBUG_ENTER((DBG_INET,
                 Dword,
                 "ReadFile_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_ReadFile & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if ((error == ERROR_SUCCESS) && (fsm.GetState() == FSM_STATE_INIT)) {
        error = HttpReadData(fsm.GetMappedHandle(),
                             fsm.m_lpBuffer,
                             fsm.m_dwNumberOfBytesToRead,
                             &fsm.m_dwBytesRead,
                             0
                             );
        if (error == ERROR_IO_PENDING) {
            goto quit;
        }
    }
    ReadFile_End(!fsm.GetThreadInfo()->IsAsyncWorkerThread,
                 (error == ERROR_SUCCESS) ? TRUE : FALSE,
                 fsm.GetMappedHandle(),
                 fsm.m_dwBytesRead,
                 fsm.m_lpBuffer,
                 fsm.m_dwNumberOfBytesToRead,
                 fsm.m_lpdwNumberOfBytesRead
                 );
    fsm.SetDone();

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_ReadFileEx::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_ReadFileEx::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    CFsm_ReadFileEx * stateMachine = (CFsm_ReadFileEx *)Fsm;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = ReadFileEx_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
ReadFileEx_Fsm(
    IN CFsm_ReadFileEx * Fsm
    )
{
    DEBUG_ENTER((DBG_INET,
                 Dword,
                 "ReadFileEx_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_ReadFileEx & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if ((error == ERROR_SUCCESS) && (fsm.GetState() == FSM_STATE_INIT)) {
        fsm.m_dwNumberOfBytesToRead = fsm.m_lpBuffersOut->dwBufferLength;
        error = HttpReadData(fsm.GetMappedHandle(),
                             fsm.m_lpBuffersOut->lpvBuffer,
                             fsm.m_dwNumberOfBytesToRead,
                             &fsm.m_dwBytesRead,
                             (fsm.m_dwFlags & IRF_NO_WAIT)
                               ? SF_NO_WAIT
                               : 0
                             );
        if (error == ERROR_IO_PENDING) {
            goto quit;
        }
    }

    //
    // if we are asynchronously completing a no-wait read then we don't update
    // any app parameters - we simply return the indication that we completed.
    // The app will then make another no-wait read to get the data
    //

    BOOL bNoOutput;

    bNoOutput = ((fsm.m_dwFlags & IRF_NO_WAIT)
                && fsm.GetThreadInfo()->IsAsyncWorkerThread)
                    ? TRUE
                    : FALSE;

    ReadFile_End(!fsm.GetThreadInfo()->IsAsyncWorkerThread,
                 (error == ERROR_SUCCESS) ? TRUE : FALSE,
                 fsm.GetMappedHandle(),
                 bNoOutput ? 0    : fsm.m_dwBytesRead,
                 bNoOutput ? NULL : fsm.m_lpBuffersOut->lpvBuffer,
                 bNoOutput ? 0    : fsm.m_dwNumberOfBytesToRead,
                 bNoOutput ? NULL : &fsm.m_lpBuffersOut->dwBufferLength
                 );
    fsm.SetDone();

quit:

    DEBUG_LEAVE(error);

    return error;
}



INTERNETAPI
BOOL
WINAPI
WinHttpWriteData(
    IN HINTERNET hFile,
    IN LPCVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten
    )

/*++

Routine Description:

    This function write next block of data to the internet file. Currently it
    supports the following protocol data:

        HttpWriteFile

Arguments:

    hFile                       - handle that was obtained by OpenFile Call

    lpBuffer                    - pointer to the data buffer

    dwNumberOfBytesToWrite      - number of bytes in the above buffer

    lpdwNumberOfBytesWritten    -  pointer to a DWORD where the number of bytes
                                   of data actually written is returned

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpWriteData",
                     "%#x, %#x, %d, %#x",
                     hFile,
                     lpBuffer,
                     dwNumberOfBytesToWrite,
                     lpdwNumberOfBytesWritten
                     ));

    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD nestingLevel = 0;
    DWORD error;
    BOOL success = FALSE;
    BOOL fNeedDeref = TRUE;
    HINTERNET hFileMapped = NULL;

    if (!GlobalDataInitialized)
    {
        error = ERROR_WINHTTP_NOT_INITIALIZED;
        goto done;
    }

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL)
    {

        INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    error = MapHandleToAddress(hFile, (LPVOID *)&hFileMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hFileMapped == NULL))
    {
        goto quit;
    }

    //
    // set the handle, and last-error info in the per-thread data block
    // before we go any further. This allows us to return a status in the async
    // case, even if the handle has been closed
    //

    _InternetSetObjectHandle(lpThreadInfo, hFile, hFileMapped);
    _InternetClearLastError(lpThreadInfo);

    //
    // if MapHandleToAddress() returned a non-NULL object address, but also an
    // error status, then the handle is being closed - quit
    //

    if (error != ERROR_SUCCESS)
    {
        goto quit;
    }

    // validate handle and its type
    BOOL isAsync;
    error = RIsHandleLocal(hFileMapped, NULL, &isAsync, TypeHttpRequestHandle);
    if (error != ERROR_SUCCESS)
    {
        INET_ASSERT(FALSE);
        goto quit;
    }

    //
    // validate parameters - write length cannot be 0
    //

    if (!lpThreadInfo->IsAsyncWorkerThread)
    {
        if (dwNumberOfBytesToWrite != 0)
        {
            error = ProbeReadBuffer((LPVOID)lpBuffer, dwNumberOfBytesToWrite);
            if (error == ERROR_SUCCESS)
            {
                error = ProbeAndSetDword(lpdwNumberOfBytesWritten, 0);
            }
        }
        else
        {
            error = ERROR_INVALID_PARAMETER;
        }         

        if (error != ERROR_SUCCESS)
        {
            goto quit;
        }
    }


    // # 62953
    // If the authentication state of the handle is Negotiate,
    // don't submit data to the server but return success.
    // ** Added test for NTLM or Negotiate - Adriaanc.
    //
    
    HTTP_REQUEST_HANDLE_OBJECT *pRequest;
    pRequest = (HTTP_REQUEST_HANDLE_OBJECT*) hFileMapped;

    if (pRequest->GetAuthState() == AUTHSTATE_NEGOTIATE)
    {
        *lpdwNumberOfBytesWritten = dwNumberOfBytesToWrite;
        error = ERROR_SUCCESS;
        success = TRUE;
        goto quit;
    }
        

    INET_ASSERT(error == ERROR_SUCCESS);

    CFsm_HttpWriteData *pFsm = New CFsm_HttpWriteData((LPVOID)lpBuffer,
                                                      dwNumberOfBytesToWrite,
                                                      lpdwNumberOfBytesWritten,
                                                      0,
                                                      pRequest
                                                      );

    if (pFsm != NULL)
    {
        HTTP_REQUEST_HANDLE_OBJECT *pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hFileMapped;
        if (isAsync && !lpThreadInfo->IsAsyncWorkerThread)
        {
            error = DoAsyncFsm(pFsm, pRequest);
        }
        else
        {
            pFsm->SetPushPop(TRUE);
            pFsm->Push();
            error = DoFsm(pFsm);
        }
    }
    else
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Don't Derefrence if we're going pending cause the FSM will do
    //  it for us.
    //

    if ( error == ERROR_IO_PENDING )
    {
        fNeedDeref = FALSE;
    }
    success = (error == ERROR_SUCCESS) ? TRUE : FALSE;

quit:

    if (hFileMapped != NULL && fNeedDeref)
    {
        DereferenceObject((LPVOID)hFileMapped);
    }

    _InternetDecNestingCount(nestingLevel);;

done:

    if (error != ERROR_SUCCESS)
    {
        DEBUG_ERROR(API, error);
        SetLastError(error);
    }

    DEBUG_LEAVE_API(success);

    return success;
}



INTERNETAPI
BOOL
WINAPI
WinHttpQueryDataAvailable(
    IN HINTERNET hFile,
    OUT LPDWORD lpdwNumberOfBytesAvailable
    )

/*++

Routine Description:

    Determines the amount of data currently available to be read on the handle

Arguments:

    hFile                       - handle of internet object

    lpdwNumberOfBytesAvailable  - pointer to returned bytes available

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpQueryDataAvailable",
                     "%#x, %#x, %#x",
                     hFile,
                     lpdwNumberOfBytesAvailable
                     ));

    BOOL success;
    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo = NULL;
    HINTERNET hFileMapped = NULL;
    BOOL bDeref = TRUE;

    if (!GlobalDataInitialized)
    {
        error = ERROR_WINHTTP_NOT_INITIALIZED;
        bDeref = FALSE;
        goto quit;
    }

    //
    // get the per-thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL)
    {

        INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    //INET_ASSERT(lpThreadInfo->Fsm == NULL);

    PERF_LOG(PE_CLIENT_REQUEST_START,
             AR_INTERNET_QUERY_DATA_AVAILABLE,
             lpThreadInfo->ThreadId,
             hFile
             );

    //
    // validate parameters
    //

    error = MapHandleToAddress(hFile, &hFileMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hFileMapped == NULL))
    {
        goto quit;
    }

    INET_ASSERT(hFileMapped);

    //
    // set the handle values in the per-thread info block (this API
    // can't return extended error info, so we don't care about it)
    //

    _InternetSetObjectHandle(lpThreadInfo, hFile, hFileMapped);

    //
    // if the handle is invalid, quit now
    //

    if (error != ERROR_SUCCESS)
    {
        goto quit;
    }

    //
    // validate rest of parameters
    //

    error = ProbeAndSetDword(lpdwNumberOfBytesAvailable, 0);
    if (error != ERROR_SUCCESS)
    {
        goto quit;
    }

    BOOL isAsync;
    error = RIsHandleLocal(hFileMapped, NULL, &isAsync, TypeHttpRequestHandle);
    if (error != ERROR_SUCCESS)
    {
        goto quit;
    }

    //
    // since the async worker thread doesn't come back through this API, the
    // following test is sufficient. Note that we only go async if there is
    // no data currently available on the handle
    //

    BOOL dataAvailable;
    dataAvailable = ((INTERNET_HANDLE_OBJECT *)hFileMapped)->IsDataAvailable();

    BOOL eof;
    eof = ((INTERNET_HANDLE_OBJECT *)hFileMapped)->IsEndOfFile();

    if (dataAvailable || eof)
    {

        DWORD available;

        available = ((INTERNET_HANDLE_OBJECT *)hFileMapped)->AvailableDataLength();

        DEBUG_PRINT(API,
                    INFO,
                    ("%d bytes are immediately available\n",
                    available
                    ));

        *lpdwNumberOfBytesAvailable = available;
        success = TRUE;
        goto finish;
    }

    INET_ASSERT(hFileMapped);

    //
    // sync path. wInternetQueryDataAvailable will set the last error code
    // if it fails
    //

    CFsm_QueryAvailable *pFsm;

    pFsm = New CFsm_QueryAvailable(lpdwNumberOfBytesAvailable,
                                   0,
                                   NULL
                                   );

    if (pFsm != NULL)
    {
        HTTP_REQUEST_HANDLE_OBJECT *pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hFileMapped;
        if (isAsync && !lpThreadInfo->IsAsyncWorkerThread)
        {
            error = DoAsyncFsm(pFsm, pRequest);
        }
        else
        {
            pFsm->SetPushPop(TRUE);
            pFsm->Push();
            error = DoFsm(pFsm);
        }
    }
    else
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (error == ERROR_SUCCESS)
    {
        success = TRUE;
    }
    else
    {
        if (error == ERROR_IO_PENDING)
        {
            bDeref = FALSE;
        }
        goto quit;
    }

finish:

    DEBUG_PRINT_API(API,
                    INFO,
                    ("*lpdwNumberOfBytesAvailable (%#x) = %d\n",
                    lpdwNumberOfBytesAvailable,
                    *lpdwNumberOfBytesAvailable
                    ));

    if (bDeref && (hFileMapped != NULL))
    {
        DereferenceObject((LPVOID)hFileMapped);
    }

    if (lpThreadInfo)
    {

        PERF_LOG(PE_CLIENT_REQUEST_END,
                 AR_INTERNET_QUERY_DATA_AVAILABLE,
                 *lpdwNumberOfBytesAvailable,
                 lpThreadInfo->ThreadId,
                 hFile
                 );

    }

    DEBUG_LEAVE_API(success);
    return success;

quit:

    DEBUG_ERROR(API, error);

    SetLastError(error);
    success = FALSE;

    goto finish;
}


DWORD
CFsm_QueryAvailable::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_QueryAvailable::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    CFsm_QueryAvailable * stateMachine = (CFsm_QueryAvailable *)Fsm;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = QueryAvailable_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
QueryAvailable_Fsm(
    IN CFsm_QueryAvailable * Fsm
    )
{
    DEBUG_ENTER((DBG_INET,
                 Dword,
                 "QueryAvailable_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_QueryAvailable & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)fsm.GetMappedHandle();

    if (fsm.GetState() == FSM_STATE_INIT) {
        error = pRequest->QueryDataAvailable(fsm.m_lpdwNumberOfBytesAvailable);
    }
    if (error == ERROR_SUCCESS) {
        pRequest->SetAvailableDataLength(*fsm.m_lpdwNumberOfBytesAvailable);

        DEBUG_PRINT(INET,
                    INFO,
                    ("%d bytes available\n",
                    *fsm.m_lpdwNumberOfBytesAvailable
                    ));

        fsm.SetApiData(*fsm.m_lpdwNumberOfBytesAvailable);
    }

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}



INTERNETAPI
BOOL
WINAPI
InternetGetLastResponseInfoA(
    OUT LPDWORD lpdwErrorCategory,
    IN LPSTR lpszBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    This function returns the per-thread last internet error description text
    or server response.

    If this function is successful, *lpdwBufferLength contains the string length
    of lpszBuffer.

    If this function returns a failure indication, *lpdwBufferLength contains
    the number of BYTEs required to hold the response text

Arguments:

    lpdwErrorCategory   - pointer to DWORD location where the error catagory is
                          returned

    lpszBuffer          - pointer to buffer where the error text is returned

    lpdwBufferLength    - IN: length of lpszBuffer
                          OUT: number of characters in lpszBuffer if successful
                          else size of buffer required to hold response text

Return Value:

    BOOL
        Success - TRUE
                    lpszBuffer contains the error text. The caller must check
                    *lpdwBufferLength: if 0 then there was no text to return

        Failure - FALSE
                    Call GetLastError() for more information

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetGetLastResponseInfoA",
                     "%#x, %#x, %#x [%d]",
                     lpdwErrorCategory,
                     lpszBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0
                     ));

    DWORD error;
    BOOL success;
    DWORD textLength;
    LPINTERNET_THREAD_INFO lpThreadInfo;

    //
    // validate parameters
    //

    if (IsBadWritePtr(lpdwErrorCategory, sizeof(*lpdwErrorCategory))
    || IsBadWritePtr(lpdwBufferLength, sizeof(*lpdwBufferLength))
    || (ARGUMENT_PRESENT(lpszBuffer)
        ? IsBadWritePtr(lpszBuffer, *lpdwBufferLength)
        : FALSE)) {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // if the buffer pointer is NULL then its the same as a zero-length buffer
    //

    if (!ARGUMENT_PRESENT(lpszBuffer)) {
        *lpdwBufferLength = 0;
    } else if (*lpdwBufferLength != 0) {
        *lpszBuffer = '\0';
    }

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        DEBUG_PRINT(INET,
                    ERROR,
                    ("failed to get INTERNET_THREAD_INFO\n"
                    ));

        INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    //
    // there may not be any error text for this thread - either no server
    // error/response has been received, or the error text has been cleared by
    // an intervening API
    //

    if (lpThreadInfo->hErrorText != NULL) {

        //
        // copy as much as we can fit in the user supplied buffer
        //

        textLength = lpThreadInfo->ErrorTextLength;
        if (*lpdwBufferLength) {

            LPBYTE errorText;

            errorText = (LPBYTE)LOCK_MEMORY(lpThreadInfo->hErrorText);
            if (errorText != NULL) {
                textLength = min(textLength, *lpdwBufferLength) - 1;
                memcpy(lpszBuffer, errorText, textLength);

                //
                // the error text should always be zero terminated, so the
                // calling app can treat it as a string
                //

                lpszBuffer[textLength] = '\0';

                UNLOCK_MEMORY(lpThreadInfo->hErrorText);

                if (textLength == lpThreadInfo->ErrorTextLength - 1) {
                    error = ERROR_SUCCESS;
                } else {

                    //
                    // returned length is amount of buffer required
                    //

                    textLength = lpThreadInfo->ErrorTextLength;
                    error = ERROR_INSUFFICIENT_BUFFER;
                }
            } else {

                DEBUG_PRINT(INET,
                            ERROR,
                            ("failed to lock hErrorText (%#x): %d\n",
                            lpThreadInfo->hErrorText,
                            GetLastError()
                            ));

                error = ERROR_WINHTTP_INTERNAL_ERROR;
            }
        } else {

            //
            // user's buffer is not large enough to hold the info. We'll
            // let them know the required length
            //

            error = ERROR_INSUFFICIENT_BUFFER;
        }
    } else {

        INET_ASSERT(lpThreadInfo->ErrorTextLength == 0);

        textLength = 0;
        error = ERROR_SUCCESS;
    }

    *lpdwErrorCategory = lpThreadInfo->ErrorNumber;
    *lpdwBufferLength = textLength;

    IF_DEBUG(ANY) {
        if ((error == ERROR_SUCCESS)
        || ((textLength != 0) && (lpszBuffer != NULL))) {

            DEBUG_DUMP_API(API,
                           "Last Response Info:\n",
                           lpszBuffer,
                           textLength
                           );

        }
    }

quit:
    success = (error == ERROR_SUCCESS);
    if (!success) {
        DEBUG_ERROR(API, error);
        SetLastError(error);
    }

    DEBUG_LEAVE_API(success);

    return success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\api\inetapiw.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetapiw.cxx

Abstract:

    Contains the wide-character Internet APIs

    Contents:
        WinHttpCrackUrl
        WinHttpCreateUrl
        WinHttpOpen
        WinHttpConnect
        WinHttpSetStatusCallback

Author:

    Richard L Firth (rfirth) 02-Mar-1995

Environment:

    Win32(s) user-mode DLL

Revision History:

    02-Mar-1995 rfirth
        Created

--*/

#include <wininetp.h>

//  because wininet doesnt know about IStream
#define NO_SHLWAPI_STREAM
#include <shlwapi.h>
#include <shlwapip.h>


// -- FixStrings ------

//  Used in WinHttpCrackUrlW only.
//  Either
//  (a) If we have an ansi string, AND a unicode buffer, convert from ansi to unicode
//  (b) If we have an ansi string, but NO unicode buffer, determine where the ansi string
//         occurs in the unicode URL, and point the component there.

VOID
FixStrings(    
    LPSTR& pszA, 
    DWORD cbA, 
    LPWSTR& pszW, 
    DWORD& ccW, 
    LPSTR pszUrlA, 
    LPCWSTR pszUrlW)
{
    if (!pszA)
        return;

    if (pszW) 
    {
        ccW = MultiByteToWideChar(CP_ACP, 0, pszA, cbA+1, pszW, ccW) - 1; 
    } 
    else 
    { 
        pszW = (LPWSTR)(pszUrlW + MultiByteToWideChar(CP_ACP, 0, 
                pszUrlA, (int) (pszA-pszUrlA), NULL, 0)); 
        ccW = MultiByteToWideChar(CP_ACP, 0, pszA, cbA, NULL, 0); 
    } 
}

//
// functions
//


INTERNETAPI
BOOL
WINAPI
WinHttpCrackUrl(
    IN LPCWSTR pszUrlW,
    IN DWORD dwUrlLengthW,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTSW pUCW
    )

/*++

Routine Description:

    Cracks an URL into its constituent parts. Optionally escapes the url-path.
    We assume that the user has supplied large enough buffers for the various
    URL parts

Arguments:

    pszUrl         - pointer to URL to crack

    dwUrlLength     - 0 if pszUrl is ASCIIZ string, else length of pszUrl

    dwFlags         - flags controlling operation

    lpUrlComponents - pointer to URL_COMPONENTS

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpCrackUrl",
                     "%wq, %#x, %#x, %#x",
                     pszUrlW,
                     dwUrlLengthW,
                     dwFlags,
                     pUCW
                     ));

    INET_ASSERT(pszUrlW);
    INET_ASSERT(pUCW);

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    BOOL fContinue;
    DWORD c;
    MEMORYPACKET mpUrlA, mpHostName, mpUserName, mpScheme, mpPassword, mpUrlPath, mpExtraInfo;
    URL_COMPONENTSA UCA;

    if (!pszUrlW
        || (dwUrlLengthW
            ? IsBadStringPtrW(pszUrlW,-1)
            : IsBadReadPtr(pszUrlW,dwUrlLengthW))
        || !pUCW
        || IsBadWritePtr(pUCW, sizeof(*pUCW))
        || (pUCW->dwStructSize != sizeof(*pUCW)) 
        || (dwFlags & ~(ICU_ESCAPE | ICU_DECODE)))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    UCA.dwStructSize = sizeof(URL_COMPONENTSA); 
    ALLOC_MB(pszUrlW, dwUrlLengthW, mpUrlA);
    if (!mpUrlA.psStr) {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
    }
    UNICODE_TO_ANSI(pszUrlW, mpUrlA);

    for (c=0; c<=5; c++) {
        LPWSTR pszWorker;
        DWORD ccLen;
        MEMORYPACKET* pmpWorker;
        
        switch(c)
        {
        case 0:
            pszWorker = pUCW->lpszScheme;
            ccLen = pUCW->dwSchemeLength;
            pmpWorker = &mpScheme;
            break;

        case 1:
            pszWorker = pUCW->lpszHostName;
            ccLen = pUCW->dwHostNameLength;
            pmpWorker = &mpHostName;
            break;

        case 2:
            pszWorker = pUCW->lpszUserName;
            ccLen = pUCW->dwUserNameLength;
            pmpWorker = &mpUserName;
            break;

        case 3:
            pszWorker = pUCW->lpszPassword;
            ccLen = pUCW->dwPasswordLength;
            pmpWorker = &mpPassword;
            break;

        case 4:
            pszWorker = pUCW->lpszUrlPath;
            ccLen = pUCW->dwUrlPathLength;
            pmpWorker = &mpUrlPath;
            break;

        case 5:
            pszWorker = pUCW->lpszExtraInfo;
            ccLen = pUCW->dwExtraInfoLength;
            pmpWorker = &mpExtraInfo;
            break;
        }

        if (pszWorker) 
        {
            if (pszWorker 
                && ccLen 
                && (ProbeWriteBuffer(pszWorker,ccLen) != ERROR_SUCCESS) )
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }
            ALLOC_MB(pszWorker,ccLen,(*pmpWorker)); 
            if (!pmpWorker->psStr) 
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
        } 
        else 
        { 
            pmpWorker->dwAlloc = ccLen; 
        }
    };

    REASSIGN_ALLOC(mpScheme,UCA.lpszScheme,UCA.dwSchemeLength);
    REASSIGN_ALLOC(mpHostName, UCA.lpszHostName,UCA.dwHostNameLength);
    REASSIGN_ALLOC(mpUserName, UCA.lpszUserName,UCA.dwUserNameLength);
    REASSIGN_ALLOC(mpPassword,UCA.lpszPassword,UCA.dwPasswordLength);
    REASSIGN_ALLOC(mpUrlPath,UCA.lpszUrlPath,UCA.dwUrlPathLength);
    REASSIGN_ALLOC(mpExtraInfo,UCA.lpszExtraInfo,UCA.dwExtraInfoLength);
                
    fResult = WinHttpCrackUrlA(mpUrlA.psStr, mpUrlA.dwSize, dwFlags, &UCA);
    if (fResult) {
        FixStrings(UCA.lpszScheme, UCA.dwSchemeLength, pUCW->lpszScheme, 
                    pUCW->dwSchemeLength, mpUrlA.psStr, pszUrlW);
        FixStrings(UCA.lpszHostName, UCA.dwHostNameLength, pUCW->lpszHostName, 
                    pUCW->dwHostNameLength, mpUrlA.psStr, pszUrlW);
        FixStrings(UCA.lpszUserName, UCA.dwUserNameLength, pUCW->lpszUserName, 
                    pUCW->dwUserNameLength, mpUrlA.psStr, pszUrlW);
        FixStrings(UCA.lpszPassword, UCA.dwPasswordLength, pUCW->lpszPassword, 
                    pUCW->dwPasswordLength, mpUrlA.psStr, pszUrlW);
        FixStrings(UCA.lpszUrlPath, UCA.dwUrlPathLength, pUCW->lpszUrlPath, 
                    pUCW->dwUrlPathLength, mpUrlA.psStr, pszUrlW);
        FixStrings(UCA.lpszExtraInfo, UCA.dwExtraInfoLength, pUCW->lpszExtraInfo, 
                    pUCW->dwExtraInfoLength, mpUrlA.psStr, pszUrlW);
        pUCW->nScheme = UCA.nScheme;
        pUCW->nPort = UCA.nPort;
        pUCW->dwStructSize = sizeof(URL_COMPONENTSW);
    }

cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI
BOOL
WINAPI
WinHttpCreateUrl(
    IN LPURL_COMPONENTSW pUCW,
    IN DWORD dwFlags,
    OUT LPWSTR pszUrlW,
    IN OUT LPDWORD pdwUrlLengthW
    )

/*++

Routine Description:

    Creates an URL from its constituent parts

Arguments:

Return Value:

    BOOL
        Success - URL written to pszUrl

        Failure - call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpCreateUrl",
                     "%#x, %#x, %#x, %#x",
                     pUCW,
                     dwFlags,
                     pszUrlW,
                     pdwUrlLengthW
                     ));

    INET_ASSERT(pszUrlW);
    INET_ASSERT(pUCW);

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpUrlA, mpHostName, mpUserName, mpScheme, mpPassword, mpUrlPath, mpExtraInfo;
    URL_COMPONENTSA UCA;

    if (!pdwUrlLengthW 
        || (pUCW==NULL)
        || IsBadWritePtr(pUCW, sizeof(*pUCW))
        || (pUCW->dwStructSize != sizeof(*pUCW))
        || (pszUrlW && IsBadWritePtr(pszUrlW, *pdwUrlLengthW*sizeof(WCHAR)))
        || (dwFlags & ~(ICU_ESCAPE)))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    if (pszUrlW)
    {
        ALLOC_MB(pszUrlW, *pdwUrlLengthW, mpUrlA);
        if (!mpUrlA.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }
    mpUrlA.dwSize = mpUrlA.dwAlloc;
    UCA.dwStructSize = sizeof(URL_COMPONENTSA);

    UCA.nScheme = pUCW->nScheme;
    UCA.nPort = pUCW->nPort;
    if (pUCW->lpszScheme)
    {
        if (pUCW->dwSchemeLength
            ? IsBadReadPtr(pUCW->lpszScheme, pUCW->dwSchemeLength)
            : IsBadStringPtrW(pUCW->lpszScheme, -1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(pUCW->lpszScheme, pUCW->dwSchemeLength, mpScheme);
        if (!mpScheme.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszScheme, mpScheme);
    }
    REASSIGN_SIZE(mpScheme, UCA.lpszScheme, UCA.dwSchemeLength);
    if (pUCW->lpszHostName)
    {
        if (pUCW->dwHostNameLength
            ? IsBadReadPtr(pUCW->lpszHostName, pUCW->dwHostNameLength)
            : IsBadStringPtrW(pUCW->lpszHostName, -1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(pUCW->lpszHostName, pUCW->dwHostNameLength, mpHostName);
        if (!mpHostName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszHostName, mpHostName);
    }
    REASSIGN_SIZE(mpHostName, UCA.lpszHostName, UCA.dwHostNameLength);
    if (pUCW->lpszUserName)
    {
        if (pUCW->dwUserNameLength
            ? IsBadReadPtr(pUCW->lpszUserName, pUCW->dwUserNameLength)
            : IsBadStringPtrW(pUCW->lpszUserName, -1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(pUCW->lpszUserName, pUCW->dwUserNameLength, mpUserName);
        if (!mpUserName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszUserName, mpUserName);
    }
    REASSIGN_SIZE(mpUserName, UCA.lpszUserName, UCA.dwUserNameLength);
    if (pUCW->lpszPassword)
    {
        if (pUCW->dwPasswordLength
            ? IsBadReadPtr(pUCW->lpszPassword, pUCW->dwPasswordLength)
            : IsBadStringPtrW(pUCW->lpszPassword, -1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(pUCW->lpszPassword, pUCW->dwPasswordLength, mpPassword);
        if (!mpPassword.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszPassword, mpPassword);
    }
    REASSIGN_SIZE(mpPassword, UCA.lpszPassword, UCA.dwPasswordLength);
    if (pUCW->lpszUrlPath)
    {
        if (pUCW->dwUrlPathLength
            ? IsBadReadPtr(pUCW->lpszUrlPath, pUCW->dwUrlPathLength)
            : IsBadStringPtrW(pUCW->lpszUrlPath, -1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(pUCW->lpszUrlPath, pUCW->dwUrlPathLength, mpUrlPath); 
        if (!mpUrlPath.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszUrlPath, mpUrlPath);
    }
    REASSIGN_SIZE(mpUrlPath, UCA.lpszUrlPath, UCA.dwUrlPathLength);
    if (pUCW->lpszExtraInfo)
    {
        if (pUCW->dwExtraInfoLength
            ? IsBadReadPtr(pUCW->lpszExtraInfo, pUCW->dwExtraInfoLength)
            : IsBadStringPtrW(pUCW->lpszExtraInfo, -1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(pUCW->lpszExtraInfo, pUCW->dwExtraInfoLength, mpExtraInfo);
        if (!mpExtraInfo.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszExtraInfo, mpExtraInfo);
    }
    REASSIGN_SIZE(mpExtraInfo, UCA.lpszExtraInfo, UCA.dwExtraInfoLength);
    fResult = WinHttpCreateUrlA(&UCA, dwFlags, mpUrlA.psStr, &mpUrlA.dwSize);
    if (fResult)
    {
        DWORD dwRet;

        fResult = FALSE;
        
        if (pszUrlW && *pdwUrlLengthW)
        {
            //On success, reduce length of terminating NULL widechar.
            dwRet = MultiByteToWideChar(CP_ACP, 0, mpUrlA.psStr, mpUrlA.dwSize+1, pszUrlW, *pdwUrlLengthW);
            
            if (dwRet)
            {
                *pdwUrlLengthW = dwRet-1;
                fResult = TRUE;
            }
        }
        
        //If no url or no length or failure in prev. call, use MBtoWC to calculate required length of buffer.
        //If a value is returned, then set ERROR_INSUFFICIENT_BUFFER as last error
        if (!fResult)
        {
            dwRet = MultiByteToWideChar(CP_ACP, 0, mpUrlA.psStr, mpUrlA.dwSize+1, pszUrlW, 0);
            
            if (dwRet)
            {
                dwErr = ERROR_INSUFFICIENT_BUFFER;
                *pdwUrlLengthW = dwRet;
                
            }
            else
            {
                dwErr = GetLastError();
                //Morph the error since we don't know what to initialize pdwUrlLengthW to
                if (dwErr == ERROR_INSUFFICIENT_BUFFER)
                {
                    dwErr = ERROR_INVALID_PARAMETER;
                }
            }
        }
    }
    else
    {
        *pdwUrlLengthW = mpUrlA.dwSize;
    }

cleanup:        
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }

    DEBUG_LEAVE_API(fResult);
    return fResult;
}


// implemented in inetapia.cxx
DWORD ICUHrToWin32Error(HRESULT);


INTERNETAPI
HINTERNET
WINAPI
WinHttpOpen(
    IN LPCWSTR pszAgentW,
    IN DWORD dwAccessType,
    IN LPCWSTR pszProxyW OPTIONAL,
    IN LPCWSTR pszProxyBypassW OPTIONAL,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    pszAgent       -

    dwAccessType    -

    pszProxy       -

    pszProxyBypass -

    dwFlags         -

Return Value:

    HINTERNET

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "WinHttpOpen",
                     "%wq, %s (%d), %wq, %wq, %#x",
                     pszAgentW,
                     InternetMapOpenType(dwAccessType),
                     dwAccessType,
                     pszProxyW,
                     pszProxyBypassW,
                     dwFlags
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    HINTERNET hInternet = NULL;
    MEMORYPACKET mpAgentA, mpProxyA, mpProxyBypassA;

    if (dwFlags &~ (WINHTTP_OPEN_FLAGS_MASK))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    if (pszAgentW)
    {
        if (IsBadStringPtrW(pszAgentW, -1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(pszAgentW,0,mpAgentA);
        if (!mpAgentA.psStr)
        {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
        }
        UNICODE_TO_ANSI(pszAgentW,mpAgentA);
    }

    if (dwAccessType & WINHTTP_ACCESS_TYPE_NAMED_PROXY)
    {
        if (pszProxyW)
        {
            if (IsBadStringPtrW(pszProxyW, -1) 
                || (*pszProxyW == L'\0'))
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }
            ALLOC_MB(pszProxyW,0,mpProxyA);
            if (!mpProxyA.psStr)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
            UNICODE_TO_ANSI(pszProxyW,mpProxyA);
        }
        if (pszProxyBypassW)
        {
            if (IsBadStringPtrW(pszProxyBypassW, -1))
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }
            ALLOC_MB(pszProxyBypassW,0,mpProxyBypassA);
            if (!mpProxyBypassA.psStr)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
            UNICODE_TO_ANSI(pszProxyBypassW,mpProxyBypassA);
        }
    }

    hInternet = InternetOpenA(mpAgentA.psStr, dwAccessType, mpProxyA.psStr, 
                                        mpProxyBypassA.psStr, dwFlags);

                                        
cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }

    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}


INTERNETAPI
HINTERNET
WINAPI
WinHttpConnect(
    IN HINTERNET hInternetSession,
    IN LPCWSTR pszServerNameW,
    IN INTERNET_PORT nServerPort,
    IN DWORD dwReserved
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hInternetSession    -
    pszServerName      -
    nServerPort         -
    pszUserName        -
    pszPassword        -
    dwService           -
    dwReserved             -

Return Value:

    HINTERNET

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "WinHttpConnect",
                     "%#x, %wq, %d, %#x",
                     hInternetSession,
                     pszServerNameW,
                     nServerPort,
                     dwReserved
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpServerNameA;
    HINTERNET hInternet = NULL;

    if (dwReserved)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    if (pszServerNameW)
    {
        if (IsBadStringPtrW(pszServerNameW,-1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        dwErr = ConvertUnicodeToMultiByte(pszServerNameW, 0/*CODEPAGE not used here*/, &mpServerNameA, 
                    WINHTTP_FLAG_VALID_HOSTNAME); 
        if (dwErr != ERROR_SUCCESS)
        {
            goto cleanup;
        }
    }
    else
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    hInternet = InternetConnectA
        (hInternetSession, mpServerNameA.psStr, nServerPort, dwReserved, NULL);

cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }

    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}


INTERNETAPI
WINHTTP_STATUS_CALLBACK
WINAPI
WinHttpSetStatusCallback(
    IN HINTERNET hInternet,
    IN WINHTTP_STATUS_CALLBACK lpfnInternetCallback,
    IN DWORD dwNotificationFlags,
    IN DWORD_PTR dwReserved
    )

/*++

Routine Description:

    Sets the status callback function for the DLL or the handle object

Arguments:

    hInternet               - handle of the object for which we wish to set the
                              status callback

    lpfnInternetCallback    - pointer to caller-supplied status function

Return Value:

    FARPROC
        Success - previous status callback function address

        Failure - INTERNET_INVALID_STATUS_CALLBACK. Call GetLastErrorInfo() for
                  more information:

                    ERROR_INVALID_PARAMETER
                        The callback function is invalid

                    ERROR_WINHTTP_INCORRECT_HANDLE_TYPE
                        Cannot set the callback on the supplied handle (probably
                        a NULL handle - per-process callbacks no longer
                        supported)

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Pointer,
                     "WinHttpSetStatusCallback",
                     "%#x, %#x, %#x",
                     hInternet,
                     lpfnInternetCallback,
                     dwNotificationFlags
                     ));
                 
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fIsUnicode = TRUE; //vestigial UNICODE indicator
    
    WINHTTP_STATUS_CALLBACK previousCallback = WINHTTP_INVALID_STATUS_CALLBACK;
    HINTERNET hObjectMapped = NULL;

    if (!GlobalDataInitialized) 
    {
        dwErr = GlobalDataInitialize();
        if (dwErr != ERROR_SUCCESS) 
        {
            goto cleanup;
        }
    }

    if (((lpfnInternetCallback != NULL) && IsBadCodePtr((FARPROC)lpfnInternetCallback))
        || (dwNotificationFlags == 0) || (dwReserved != 0))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    if (!hInternet)
    {
        dwErr = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        goto cleanup;
    }

    // map the handle
    dwErr = MapHandleToAddress(hInternet, (LPVOID *)&hObjectMapped, FALSE);
    if (dwErr != ERROR_SUCCESS)
    {
        goto cleanup;
    }
    
    // swap the new and previous handle object status callbacks, ONLY
    // if there are no pending requests on this handle
    previousCallback = lpfnInternetCallback;
    dwErr = RExchangeStatusCallback(hObjectMapped, &previousCallback, fIsUnicode, dwNotificationFlags);
    
cleanup:

    if (hObjectMapped != NULL) 
    {
        DereferenceObject((LPVOID)hObjectMapped);
    }

    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(API, dwErr);
    }
    
    DEBUG_LEAVE_API(previousCallback);
    return previousCallback;
}


// WinHttpPlatformCheck() API routines //////////////////////////////////////

static void ConvertVersionString(LPCSTR pszVersion, WORD rwVer[], CHAR ch)
{
    LPCSTR pszEnd;
    LPCSTR pszTemp;
    int    i; 

    for (i = 0; i < 4; i++)
        rwVer[i] = 0;

    pszEnd = pszVersion + lstrlen(pszVersion);
    pszTemp = pszVersion;

    for (i = 0; i < 4 && pszTemp < pszEnd; i++)
    {
        while (pszTemp < pszEnd && *pszTemp != ch)
        {
            rwVer[i] = rwVer[i] * 10 + (*pszTemp - '0');
            pszTemp++;
        }

        pszTemp++;
    }
}


const char c_gszRegActiveSetup[]        = "Software\\Microsoft\\Active Setup\\Installed Components\\";
const char c_gszInternetExplorerCLSID[] = "{89820200-ECBD-11cf-8B85-00AA005B4383}";

static void GetInstalledComponentVersion(LPCSTR szCLSID, DWORD *pdwMSVer, DWORD *pdwLSVer)
{
    HKEY    hKey;
    char    szKey[MAX_PATH];
    WORD    rgwVersion[4];
    DWORD   dwSize;
    
    *pdwMSVer = 0;
    *pdwLSVer = 0;

    // Build the registry path.
    lstrcpy(szKey, c_gszRegActiveSetup);
    lstrcat(szKey, szCLSID);
    
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(szKey);

        if ((RegQueryValueEx(hKey, "Version", NULL, NULL, (BYTE *)szKey, &dwSize) == ERROR_SUCCESS) &&
            (dwSize > 0))
        {
            ConvertVersionString(szKey, rgwVersion, ',');

            *pdwMSVer = (DWORD)rgwVersion[0] << 16;    // Make hi word of MS version
            *pdwMSVer += (DWORD)rgwVersion[1];         // Make lo word of MS version
            *pdwLSVer = (DWORD)rgwVersion[2] << 16;    // Make hi word of LS version
            *pdwLSVer += (DWORD)rgwVersion[3];         // Make lo word of LS version
        }

        RegCloseKey(hKey);
    }
}

static BOOL Is_IE_501_OrLaterInstalled()
{
    DWORD   dwMSVer;
    DWORD   dwLSVer;

    //
    // Find the IE version number. IE 5.01 has version number 5.00.2919.6300.
    // This will be returned from GetInstalledComponentVersion as two DWORDs,
    // like so:
    //      5.00   ->  0x00050000
    //   2919.6300 ->  0x0B67189C
    //

    GetInstalledComponentVersion(c_gszInternetExplorerCLSID, &dwMSVer, &dwLSVer);

    if (dwMSVer > 0x00050000)
        return TRUE;
    else if ((dwMSVer == 0x00050000) && (dwLSVer >= 0x0B67189C))
        return TRUE;

    return FALSE;
}

#if 0

#define REGSTR_CCS_CONTROL_WINDOWS  TEXT("SYSTEM\\CurrentControlSet\\Control\\WINDOWS")
#define CSDVERSION                  TEXT("CSDVersion")
#define SP6_VERSION                 0x0600

static BOOL Is_SP6_OrLater()
{
    BOOL    fSP6OrLater = FALSE;
    HKEY    hKey;
    DWORD   dwCSDVersion;
    DWORD   dwSize;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_CCS_CONTROL_WINDOWS, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwCSDVersion);

        if (RegQueryValueEx(hKey, CSDVERSION, NULL, NULL, (BYTE *)&dwCSDVersion, &dwSize) == ERROR_SUCCESS)
        {
            fSP6OrLater = (LOWORD(dwCSDVersion) >= SP6_VERSION);
        }
        RegCloseKey(hKey);
    }

    return fSP6OrLater;
}
#endif


INTERNETAPI
BOOL
WINAPI
WinHttpCheckPlatform(void)
{
    static BOOL _fCheckedPlatform = FALSE;
    static BOOL _fPlatformOk;


    if (!_fCheckedPlatform)
    {
        OSVERSIONINFO   osvi;
        BOOL            fPlatformOk = FALSE;

        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        
        if (GetVersionEx(&osvi))
        {
            // Allow only Win2K or NT-based platforms.
            if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT)
            {
                if (osvi.dwMajorVersion >= 5)
                {
                    // Ok on Win2K or later.
                    fPlatformOk = TRUE;
                }
                else if (osvi.dwMajorVersion == 4)
                {
                    // On NT4, we require IE 5.01 (or later).
                    fPlatformOk = Is_IE_501_OrLaterInstalled();
                }
            }
        }

        _fPlatformOk = fPlatformOk;

        InterlockedExchange((long *)&_fCheckedPlatform, TRUE);
    }

    return _fPlatformOk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\api\proxreg.cxx ===
#include "wininetp.h"

static const CHAR szRegPathConnections[] = REGSTR_PATH_INTERNET_SETTINGS "\\Connections";




// some winsock stacks fault if we do a gethostbyname(NULL).  If we come
// accross one of these, don't do any more autodetecting.
BOOL g_fGetHostByNameNULLFails = FALSE;

//
// IsConnectionMatch - a worker function to simply some logic elsewhere,
//  it just handles Connection Name Matching.
//

BOOL 
IsConnectionMatch(
    LPCSTR lpszConnection1,
    LPCSTR lpszConnection2)
{
    if ( lpszConnection1 == NULL && 
         lpszConnection2 == NULL) 
    {
        return TRUE;
    }

    if ( lpszConnection1 && lpszConnection2 &&
         stricmp(lpszConnection1, lpszConnection2) == 0 )
    {
        return TRUE;
    }

    return FALSE;
}

///////////////////////////////////////////////////////////////////////////
//
// CRegBlob implementation
//
///////////////////////////////////////////////////////////////////////////

CRegBlob::CRegBlob(
    BOOL fWrite
    )
{
    // initialize members
    _fWrite = fWrite;
    _fCommit = TRUE;
    _dwOffset = 0;
    _pBuffer = NULL;
    _dwBufferLimit = 0;
    _hkey = NULL;
}


CRegBlob::~CRegBlob(
    )
{
    Commit();

    if(_hkey)
        REGCLOSEKEY(_hkey);

    if(_pBuffer)
        FREE_FIXED_MEMORY(_pBuffer);

    // caller owns _pszValue pointer
}


DWORD
CRegBlob::Init(
    HKEY hBaseKey,
    LPCSTR pszSubKey,
    LPCSTR pszValue
    )
{
    long lRes;
    REGSAM  regsam = KEY_QUERY_VALUE;
    DWORD dwDisposition;

    // If we're writing, save reg value name and set access
    if(_fWrite)
    {
        _pszValue = pszValue;
        regsam = KEY_SET_VALUE;

        lRes = REGCREATEKEYEX(hBaseKey, pszSubKey, 0, "", 0,
                    regsam, NULL, &_hkey, &dwDisposition);
    }
    else
    {
        // If not writing, then use RegOpenKeyEx so we don't need
        // registry write permissions.
        lRes = REGOPENKEYEX(hBaseKey, pszSubKey, 0, regsam, &_hkey);
    }

    if(lRes != ERROR_SUCCESS)
    {
        return lRes;
    }

    // figure out buffer size
    _dwBufferLimit = BLOB_BUFF_GRANULARITY;
    if(FALSE == _fWrite)
    {
        // get size of registry blob
        lRes = RegQueryValueEx(_hkey, pszValue, NULL, NULL, NULL, &_dwBufferLimit);
        if(lRes != ERROR_SUCCESS)
        {
            // nothing there - make zero size buffer
            _dwBufferLimit = 0;
        }
    }

    // allocate buffer if necessary
    if(_dwBufferLimit)
    {
        _pBuffer = (BYTE *)ALLOCATE_FIXED_MEMORY(_dwBufferLimit);
        if(NULL == _pBuffer)
            return GetLastError();
    }

    // if we're reading, fill in buffer
    if(FALSE == _fWrite && _dwBufferLimit)
    {
        // read reg key
        DWORD dwSize = _dwBufferLimit;
        lRes = RegQueryValueEx(_hkey, pszValue, NULL, NULL, _pBuffer, &dwSize);
        if(lRes != ERROR_SUCCESS)
        {
            return lRes;
        }
    }

    // reset pointer to beginning of blob
    _dwOffset = 0;

    return 0;
}

DWORD
CRegBlob::Abandon(
    VOID
    )
{
    // don't commit changes when the time comes
    _fCommit = FALSE;

    return 0;
}

DWORD
CRegBlob::Commit(
    )
{
    long lres = 0;

    if(_fCommit && _fWrite && _pszValue && _pBuffer)
    {
        // save blob to reg key
        lres = RegSetValueEx(_hkey, _pszValue, 0, REG_BINARY, _pBuffer, _dwOffset);
    }

    return lres;
}


DWORD
CRegBlob::Encrpyt(
    )
{
    return 0;
}


DWORD
CRegBlob::Decrypt(
    )
{
    return 0;
}


DWORD
CRegBlob::WriteString(
    LPCSTR pszString
    )
{
    DWORD dwBytes, dwLen = 0;

    if(pszString)
    {
        dwLen = lstrlen(pszString);
    }

    dwBytes = WriteBytes(&dwLen, sizeof(DWORD));
    if(dwLen && dwBytes == sizeof(DWORD))
        dwBytes = WriteBytes(pszString, dwLen);

    return dwBytes;
}



DWORD
CRegBlob::ReadString(
    LPCSTR * ppszString
    )
{
    DWORD dwLen, dwBytes = 0;
    LPSTR lpszTemp = NULL;

    dwBytes = ReadBytes(&dwLen, sizeof(DWORD));
    if(dwBytes == sizeof(DWORD))
    {
        if(dwLen)
        {
            lpszTemp = (LPSTR)GlobalAlloc(GPTR, dwLen + 1);
            if(lpszTemp)
            {
                dwBytes = ReadBytes(lpszTemp, dwLen);
                lpszTemp[dwBytes] = 0;
            }
        }
    }

    *ppszString = lpszTemp;
    return dwBytes;
}


DWORD
CRegBlob::WriteBytes(
    LPCVOID pBytes,
    DWORD dwByteCount
    )
{
    BYTE * pNewBuffer;

    // can only do this on write blob
    if(FALSE == _fWrite)
        return 0;

    // grow buffer if necessary
    if(_dwBufferLimit - _dwOffset < dwByteCount)
    {
        DWORD dw = _dwBufferLimit + ((dwByteCount / BLOB_BUFF_GRANULARITY)+1)*BLOB_BUFF_GRANULARITY;
        pNewBuffer = (BYTE *)ALLOCATE_FIXED_MEMORY(dw);
        if(NULL == pNewBuffer)
        {
            // failed to get more memory
            return 0;
        }

        memset(pNewBuffer, 0, dw);
        memcpy(pNewBuffer, _pBuffer, _dwBufferLimit);
        FREE_FIXED_MEMORY(_pBuffer);
        _pBuffer = pNewBuffer;
        _dwBufferLimit = dw;
    }

    // copy callers data to buffer
    memcpy(_pBuffer + _dwOffset, pBytes, dwByteCount);
    _dwOffset += dwByteCount;

    // tell caller how much we wrote
    return dwByteCount;
}



DWORD
CRegBlob::ReadBytes(
    LPVOID pBytes,
    DWORD dwByteCount
    )
{
    DWORD   dwActual = _dwBufferLimit - _dwOffset;

    // can only do this on read blob
    if(_fWrite)
        return 0;

    // don't read past end of blob
    if(dwByteCount < dwActual)
        dwActual = dwByteCount;

    // copy bytes and increment offset
    if(dwActual > 0)
    {
        memcpy(pBytes, _pBuffer + _dwOffset, dwActual);
        _dwOffset += dwActual;
    }

    // tell caller how much we actually read
    return dwActual;
}


//
// Function Declarations
//


DWORD
LoadProxySettings()
/*
** Load global proxy info from registry.
** 
*/
{
    DWORD error;

    //
    // Get proxy struct for proxy object
    //
    INTERNET_PROXY_INFO_EX info;

    memset(&info, 0, sizeof(info));

    info.dwStructSize = sizeof(info);
    info.lpszConnectionName = NULL;

    //
    // Read LAN proxy settings and stuff them into the GlobalProxyInfo object.
    //
    error = ReadProxySettings(&info);

    if (error == ERROR_SUCCESS)
    {
        error = g_pGlobalProxyInfo->SetProxySettings(&info, FALSE);

        info.lpszConnectionName = NULL; // we don't allocate this field
        CleanProxyStruct(&info);
    }

    return error;
}



#define INTERNET_SETTINGS_KEY       "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"

HKEY
FindBaseProxyKey(
    VOID
    )
/*
** Determine whether proxy settings live in HKLM or HKCU
**
** WinHttpX is hard-coded to always use HKEY_LOCAL_MACHINE
** 
*/

{
    return HKEY_LOCAL_MACHINE;
}


DWORD
ReadProxySettings(
    LPINTERNET_PROXY_INFO_EX pInfo
    )

{
    CRegBlob r(FALSE);
    LPCSTR  pszConnectionName;
    LPCSTR  pszSavedConnectionName;
    DWORD   error = ERROR_SUCCESS;
    long    lRes;
    DWORD   i;
    HKEY    hBaseKey;

    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "ReadProxySettings",
                 "%#x",
                 pInfo
                 ));

    // verify pInfo
    if(NULL == pInfo || pInfo->dwStructSize != sizeof(INTERNET_PROXY_INFO_EX))
    {
        DEBUG_LEAVE(ERROR_INVALID_PARAMETER);
        return ERROR_INVALID_PARAMETER;
    }

    // figure out connection name  (NULL == 'network')
    pszConnectionName = pInfo->lpszConnectionName;
    pszSavedConnectionName = pInfo->lpszConnectionName;
    if(NULL == pszConnectionName || 0 == *pszConnectionName)
    {
        pszConnectionName = "WinHttpSettings";
    }

    // figure out base key
    hBaseKey = FindBaseProxyKey();

    // initialize structure
    memset(pInfo, 0, sizeof(*pInfo));
    pInfo->dwStructSize = sizeof(*pInfo);
    pInfo->lpszConnectionName = pszSavedConnectionName;
    pInfo->dwFlags = PROXY_TYPE_DIRECT;

    // init blob
    lRes = r.Init(hBaseKey, szRegPathConnections, pszConnectionName);
    if(lRes)
    {
        error = (lRes == ERROR_FILE_NOT_FOUND) ? ERROR_SUCCESS : lRes;
        goto quit;
    }

    // read fields from blob
    if(0 == r.ReadBytes(&pInfo->dwStructSize, sizeof(DWORD)) ||
         (pInfo->dwStructSize < sizeof(*pInfo)))
    {
        // blob didn't exist or in correct format - set default values
        pInfo->dwStructSize = sizeof(*pInfo);
    }
    else
    {
        // read the rest of the blob
        r.ReadBytes(&pInfo->dwCurrentSettingsVersion, sizeof(DWORD));
        r.ReadBytes(&pInfo->dwFlags, sizeof(DWORD));
        r.ReadString(&pInfo->lpszProxy);
        r.ReadString(&pInfo->lpszProxyBypass);
    }

    //
    // WinHttpX does not support proxy autodection or autoconfig URL's,
    // so make sure those PROXY_TYPE flags are turned off.
    //
    pInfo->dwFlags &= ~(PROXY_TYPE_AUTO_DETECT | PROXY_TYPE_AUTO_PROXY_URL);


    DEBUG_PRINT(DIALUP, INFO, ("conn=%s, vers=%u, flag=%X, prox=%s, by=%s\n", 
                    pszConnectionName,
                    pInfo->dwCurrentSettingsVersion,
                    pInfo->dwFlags,
                    (pInfo->lpszProxy ? pInfo->lpszProxy : "<none>"),
                    (pInfo->lpszProxyBypass ? pInfo->lpszProxyBypass : "<none>")
                    ));

quit:
    DEBUG_LEAVE(error);
    return error;
}


void
CleanProxyStruct(
    LPINTERNET_PROXY_INFO_EX pInfo
    )

{
    if(pInfo->lpszConnectionName)             GlobalFree((LPSTR) pInfo->lpszConnectionName);
    if(pInfo->lpszProxy)                      GlobalFree((LPSTR) pInfo->lpszProxy);
    if(pInfo->lpszProxyBypass)                GlobalFree((LPSTR) pInfo->lpszProxyBypass);
    memset(pInfo, 0, sizeof(INTERNET_PROXY_INFO_EX));
    pInfo->dwFlags = PROXY_TYPE_DIRECT;
}


DWORD
SetPerConnOptions(
    HINTERNET hInternet,
    BOOL fIsAutoProxyThread,
    LPINTERNET_PER_CONN_OPTION_LISTA pList
    )
{
    INTERNET_PROXY_INFO_EX  info;
    DWORD   i, dwError = ERROR_SUCCESS;
    BOOL fCommit = FALSE;
    LPSTR   pszCopy, pszNew;

    INET_ASSERT(fIsAutoProxyThread == FALSE);

    INET_ASSERT(hInternet != NULL);

    memset(&info, 0, sizeof(info));
    info.dwStructSize = sizeof(info);

    // loop through option list and set members
    for(i=0; i<pList->dwOptionCount; i++)
    {
        pszNew = NULL;

        switch(pList->pOptions[i].dwOption)
        {        
        case INTERNET_PER_CONN_PROXY_SERVER:
        case INTERNET_PER_CONN_PROXY_BYPASS:
            // make a copy of the string passed in for these guys
            pszCopy = pList->pOptions[i].Value.pszValue;
            if(pszCopy)
            {
                pszNew = (LPSTR)GlobalAlloc(GPTR, lstrlen(pszCopy) + 1);
                if(pszNew)
                {
                    lstrcpy(pszNew, pszCopy);
                }
                else
                {
                    dwError = ERROR_NOT_ENOUGH_MEMORY;
                    pList->dwOptionError = i;
                }
            }
            break;
        }

        if(dwError)
        {
            fCommit = FALSE;
            break;
        }

        switch(pList->pOptions[i].dwOption)
        {
        case INTERNET_PER_CONN_FLAGS:
            info.dwFlags = pList->pOptions[i].Value.dwValue;
            fCommit = TRUE;
            break;
        case INTERNET_PER_CONN_PROXY_SERVER:
            if(info.lpszProxy)
                GlobalFree((LPSTR)info.lpszProxy);
            info.lpszProxy = pszNew;
            fCommit = TRUE;
            break;
        case INTERNET_PER_CONN_PROXY_BYPASS:
            if(info.lpszProxyBypass)
                GlobalFree((LPSTR)info.lpszProxyBypass);
            info.lpszProxyBypass = pszNew;
            fCommit = TRUE;
            break;
        case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
        case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
        case INTERNET_PER_CONN_AUTOCONFIG_URL:
        case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
        case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_TIME:
        case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_URL:
        default:
            dwError = ERROR_INVALID_PARAMETER;
            pList->dwOptionError = i;
            break;
        }

        if(dwError)
        {
            fCommit = FALSE;
            break;
        }
    }

    if (fCommit && hInternet)
    {
        g_pGlobalProxyInfo->SetProxySettings(&info, TRUE);
    }

    return dwError;
}



DWORD
QueryPerConnOptions(
    HINTERNET hInternet,
    BOOL fIsAutoProxyThread,
    LPINTERNET_PER_CONN_OPTION_LISTA pList
    )
{
    INTERNET_PROXY_INFO_EX  info;
    LPCSTR   pszCopy;
    LPSTR    pszNew;
    DWORD    i, dwError = ERROR_SUCCESS;
    BOOL     fFreeCopy = FALSE;

    pList->dwOptionError = 0;

    memset(&info, 0, sizeof(info));
    info.dwStructSize = sizeof(info);
    info.lpszConnectionName = pList->pszConnection;

    if ( hInternet == NULL ) 
    {
#ifndef WININET_SERVER_CORE
        if ( ! fIsAutoProxyThread ||                          
             ! g_pGlobalProxyInfo->GetAutoProxyThreadSettings(&info) ||
             ! IsConnectionMatch(info.lpszConnectionName, pList->pszConnection)) 
        { 
            CheckForUpgrade();
            ReadProxySettings(&info);
            fFreeCopy = TRUE;
        }
#endif //!WININET_SERVER_CORE
    }
    else 
    {
        g_pGlobalProxyInfo->GetProxySettings(&info, FALSE);
    }

    // loop through option list and fill in members
    for(i=0; i<pList->dwOptionCount; i++)
    {
        pList->pOptions[i].Value.pszValue = NULL;
        pszCopy = NULL;

        switch(pList->pOptions[i].dwOption)
        {
        case INTERNET_PER_CONN_FLAGS:
            pList->pOptions[i].Value.dwValue = info.dwFlags;
            break;
        case INTERNET_PER_CONN_PROXY_SERVER:
            pszCopy = info.lpszProxy;
            break;
        case INTERNET_PER_CONN_PROXY_BYPASS:
            pszCopy = info.lpszProxyBypass;
            break;
        default:
            dwError = ERROR_INVALID_PARAMETER;
            pList->dwOptionError = i;
            break;
        }

        // if this is a string value, make a copy of the string for the
        // caller
        if(pszCopy)
        {
            // make a copy of the string and stick it in the option
            pszNew = (LPSTR)GlobalAlloc(GPTR, lstrlen(pszCopy) + 1);
            if(pszNew)
            {
                lstrcpy(pszNew, pszCopy);
                pList->pOptions[i].Value.pszValue = pszNew;
            }
            else
            {
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                pList->dwOptionError = i;
            }
        }

        if(dwError)
        {
            break;
        }
    }

    if (dwError)
    {
        // If an error has occurred, we should get rid of any strings that
        // we've allocated.
        for (i=0; i<pList->dwOptionError; i++)
        {
            switch(pList->pOptions[i].dwOption)
            {
            case INTERNET_PER_CONN_PROXY_SERVER:
            case INTERNET_PER_CONN_PROXY_BYPASS:
                if (pList->pOptions[i].Value.pszValue)
                {
                    GlobalFree(pList->pOptions[i].Value.pszValue);
                    pList->pOptions[i].Value.pszValue = NULL;
                }
                break;

            default:
                break;
            }
        }
    }

    if ( fFreeCopy ) {
        info.lpszConnectionName = NULL; // we don't allocate this field
        CleanProxyStruct(&info);
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\api\parseurl.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    parseurl.cxx

Abstract:

    Contains functions to parse the basic URLs - FTP, Gopher, HTTP.

    An URL parser simply acts as a macro: it must break out the protocol-specific
    information from the URL and initiate opening the identified resource: all
    this can be accomplished by calling the relevant Internet protocol APIs.

    Code in this module is based on RFC1738

    Contents:
        IsValidUrl
        DoesSchemeRequireSlashes
        ParseUrl
        CrackUrl
        EncodeUrlPath
        (HexCharToNumber)
        (NumberToHexChar)
        DecodeUrl
        DecodeUrlInSitu
        DecodeUrlStringInSitu
        GetUrlAddressInfo
        GetUrlAddress
        MapUrlSchemeName
        MapUrlScheme
        MapUrlSchemeToName

Author:

    Richard L Firth (rfirth) 26-Apr-1995

Environment:

    Win32(s) user-mode DLL

Revision History:

    26-Apr-1995
        Created

--*/

#include <wininetp.h>

//
// private manifests
//

#define RESERVED    SAFE

//
// private macros
//

//#define HEX_CHAR_TO_NUMBER(ch) \
//    ((ch <= '9') \
//        ? (ch - '0') \
//        : ((ch >= 'a') \
//            ? ((ch - 'a') + 10) \
//            : ((ch - 'A') + 10)))

#define NUMBER_TO_HEX_CHAR(n) \
    (((n) <= 9) ? ((char)(n) + '0') : (((char)(n) - 10) + 'A'))

#define IS_UNSAFE_URL_CHARACTER(Char, Scheme) \
    (((UCHAR)(Char) <= 0x20) || ((UCHAR)(Char) >= 0x7f) \
    || (SafetyList[(Char) - 0x21] & (UNSAFE | Scheme)))

#define IS_UNSAFE_URL_WIDECHARACTER(wChar, Scheme) \
    (((WCHAR)(wChar) <= 0x0020) || ((WCHAR)(wChar) >= 0x007f) \
    || (SafetyList[(wChar) - 0x0021] & (UNSAFE | Scheme)))

//
// private types
//

//
// private prototypes
//

PRIVATE
char
HexCharToNumber(
    IN char ch
    );

PRIVATE
char
NumberToHexChar(
    IN int Number
    );


//
// private data
//

//
// SafetyList - the list of characters above 0x20 and below 0x7f that are
// classified as safe, unsafe or scheme-specific. Safe characters do not need
// to be escaped for any URL scheme. Unsafe characters must be escaped for all
// URL schemes. Scheme-specific characters need only be escaped for the relevant
// scheme(s)
//

const
PRIVATE
UCHAR
SafetyList[] = {

    //
    // UNSAFE: 0x00..0x20
    //

    SAFE | HOSTNAME,                        // 0x21 (!)
    UNSAFE,                                 // 0x22 (")
    UNSAFE,                                 // 0x23 (#)
    SAFE | HOSTNAME,                        // 0x24 ($)
    UNSAFE,                                 // 0x25 (%)
    RESERVED | HOSTNAME,                    // 0x26 (&)
    SAFE | HOSTNAME,                        // 0x27 (')
    SAFE | HOSTNAME,                        // 0x28 (()
    SAFE | HOSTNAME,                        // 0x29 ())
    SAFE | HOSTNAME,                        // 0x2A (*)
    SCHEME_GOPHER | HOSTNAME,               // 0x2B (+)
    SAFE | HOSTNAME,                        // 0x2C (,)
    SAFE,                                   // 0x2D (-)
    SAFE,                                   // 0x2E (.)
    RESERVED | HOSTNAME,                    // 0x2F (/)
    SAFE,                                   // 0x30 (0)
    SAFE,                                   // 0x31 (1)
    SAFE,                                   // 0x32 (2)
    SAFE,                                   // 0x33 (3)
    SAFE,                                   // 0x34 (4)
    SAFE,                                   // 0x35 (5)
    SAFE,                                   // 0x36 (6)
    SAFE,                                   // 0x37 (7)
    SAFE,                                   // 0x38 (8)
    SAFE,                                   // 0x39 (9)
    RESERVED | HOSTNAME,                    // 0x3A (:)
    RESERVED | HOSTNAME,                    // 0x3B (;)
    UNSAFE,                                 // 0x3C (<)
    RESERVED | HOSTNAME,                    // 0x3D (=)
    UNSAFE,                                 // 0x3E (>)
    RESERVED | SCHEME_GOPHER | HOSTNAME,    // 0x3F (?)
    RESERVED | HOSTNAME,                    // 0x40 (@)
    SAFE,                                   // 0x41 (A)
    SAFE,                                   // 0x42 (B)
    SAFE,                                   // 0x43 (C)
    SAFE,                                   // 0x44 (D)
    SAFE,                                   // 0x45 (E)
    SAFE,                                   // 0x46 (F)
    SAFE,                                   // 0x47 (G)
    SAFE,                                   // 0x48 (H)
    SAFE,                                   // 0x49 (I)
    SAFE,                                   // 0x4A (J)
    SAFE,                                   // 0x4B (K)
    SAFE,                                   // 0x4C (L)
    SAFE,                                   // 0x4D (M)
    SAFE,                                   // 0x4E (N)
    SAFE,                                   // 0x4F (O)
    SAFE,                                   // 0x50 (P)
    SAFE,                                   // 0x51 (Q)
    SAFE,                                   // 0x42 (R)
    SAFE,                                   // 0x43 (S)
    SAFE,                                   // 0x44 (T)
    SAFE,                                   // 0x45 (U)
    SAFE,                                   // 0x46 (V)
    SAFE,                                   // 0x47 (W)
    SAFE,                                   // 0x48 (X)
    SAFE,                                   // 0x49 (Y)
    SAFE,                                   // 0x5A (Z)
    UNSAFE,                                 // 0x5B ([)
    UNSAFE,                                 // 0x5C (\)
    UNSAFE,                                 // 0x5D (])
    UNSAFE,                                 // 0x5E (^)
    SAFE,                                   // 0x5F (_)
    UNSAFE,                                 // 0x60 (`)
    SAFE,                                   // 0x61 (a)
    SAFE,                                   // 0x62 (b)
    SAFE,                                   // 0x63 (c)
    SAFE,                                   // 0x64 (d)
    SAFE,                                   // 0x65 (e)
    SAFE,                                   // 0x66 (f)
    SAFE,                                   // 0x67 (g)
    SAFE,                                   // 0x68 (h)
    SAFE,                                   // 0x69 (i)
    SAFE,                                   // 0x6A (j)
    SAFE,                                   // 0x6B (k)
    SAFE,                                   // 0x6C (l)
    SAFE,                                   // 0x6D (m)
    SAFE,                                   // 0x6E (n)
    SAFE,                                   // 0x6F (o)
    SAFE,                                   // 0x70 (p)
    SAFE,                                   // 0x71 (q)
    SAFE,                                   // 0x72 (r)
    SAFE,                                   // 0x73 (s)
    SAFE,                                   // 0x74 (t)
    SAFE,                                   // 0x75 (u)
    SAFE,                                   // 0x76 (v)
    SAFE,                                   // 0x77 (w)
    SAFE,                                   // 0x78 (x)
    SAFE,                                   // 0x79 (y)
    SAFE,                                   // 0x7A (z)
    UNSAFE,                                 // 0x7B ({)
    UNSAFE,                                 // 0x7C (|)
    UNSAFE,                                 // 0x7D (})
    UNSAFE                                  // 0x7E (~)

    //
    // UNSAFE: 0x7F..0xFF
    //

};

//
// UrlSchemeList - the list of schemes that we support
//

typedef struct {
    LPSTR SchemeName;
    DWORD SchemeLength;
    INTERNET_SCHEME SchemeType;
    DWORD SchemeFlags;
    BOOL NeedSlashes;
    DWORD OpenFlags;
} URL_SCHEME_INFO;


const
PRIVATE
URL_SCHEME_INFO
UrlSchemeList[] = {
    NULL,           0,  INTERNET_SCHEME_DEFAULT,    0,              FALSE,  0,
    "http",         4,  INTERNET_SCHEME_HTTP,       SCHEME_HTTP,    TRUE,   0,
    "https",        5,  INTERNET_SCHEME_HTTPS,      SCHEME_HTTP,    TRUE,   WINHTTP_FLAG_SECURE,
};

#define NUMBER_OF_URL_SCHEMES   ARRAY_ELEMENTS(UrlSchemeList)

BOOL ScanSchemes(LPTSTR pszToCheck, DWORD ccStr, PDWORD pwResult)
{
    for (DWORD i=0; i<NUMBER_OF_URL_SCHEMES; i++)
    {
        if ((UrlSchemeList[i].SchemeLength == ccStr)
            && (strnicmp(UrlSchemeList[i].SchemeName, pszToCheck, ccStr)==0))
        {
            *pwResult = i;
            return TRUE;
        }
    }
    return FALSE;
}

//
// functions
//


BOOL
IsValidUrl(
    IN LPCSTR lpszUrl
    )

/*++

Routine Description:

    Determines whether an URL has a valid format

Arguments:

    lpszUrl - pointer to URL to check.

    Assumes:    1. lpszUrl is non-NULL, non-empty string

Return Value:

    BOOL

--*/

{
    INET_ASSERT(lpszUrl != NULL);
    INET_ASSERT(*lpszUrl != '\0');

    while (*lpszUrl != '\0') {
        if (IS_UNSAFE_URL_CHARACTER(*lpszUrl, SCHEME_ANY)) {
            return FALSE;
        }
        ++lpszUrl;
    }
    return TRUE;
}


BOOL
DoesSchemeRequireSlashes(
    IN LPSTR lpszScheme,
    IN DWORD dwSchemeLength,
    IN BOOL bHasHostName
    )

/*++

Routine Description:

    Determines whether a protocol scheme requires slashes

Arguments:

    lpszScheme      - pointer to protocol scheme in question
                      (does not include ':' or slashes, just scheme name)

    dwUrlLength     - if not 0, string length of lpszScheme

Return Value:

    BOOL

--*/

{
    DWORD i;

    //
    // if dwSchemeLength is 0 then lpszUrl is ASCIIZ. Find its length
    //

    if (dwSchemeLength == 0) {
        dwSchemeLength = strlen(lpszScheme);
    }

    if (ScanSchemes(lpszScheme, dwSchemeLength, &i))
    {
        return UrlSchemeList[i].NeedSlashes;
    }
    return bHasHostName;
}


DWORD
CrackUrl(
    IN OUT LPSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN BOOL bEscape,
    OUT LPINTERNET_SCHEME lpSchemeType OPTIONAL,
    OUT LPSTR* lpszSchemeName OPTIONAL,
    OUT LPDWORD lpdwSchemeNameLength OPTIONAL,
    OUT LPSTR* lpszHostName OPTIONAL,
    OUT LPDWORD lpdwHostNameLength OPTIONAL,
    OUT LPINTERNET_PORT lpServerPort OPTIONAL,
    OUT LPSTR* lpszUserName OPTIONAL,
    OUT LPDWORD lpdwUserNameLength OPTIONAL,
    OUT LPSTR* lpszPassword OPTIONAL,
    OUT LPDWORD lpdwPasswordLength OPTIONAL,
    OUT LPSTR* lpszUrlPath OPTIONAL,
    OUT LPDWORD lpdwUrlPathLength OPTIONAL,
    OUT LPSTR* lpszExtraInfo OPTIONAL,
    OUT LPDWORD lpdwExtraInfoLength OPTIONAL,
    OUT LPBOOL pHavePort
    )

/*++

Routine Description:

    Cracks an URL into its constituent parts

    Assumes: 1. If one of the optional lpsz fields is present (e.g. lpszUserName)
                then the accompanying lpdw field must also be supplied

Arguments:

    lpszUrl                 - pointer to URL to crack. This buffer WILL BE
                              OVERWRITTEN if it contains escape sequences that
                              we will convert back to ANSI characters

    dwUrlLength             - if not 0, string length of lpszUrl

    bEscape                 - TRUE if we are to escape the url-path

    lpSchemeType            - returned scheme type - e.g. INTERNET_SCHEME_HTTP

    lpszSchemeName          - returned scheme name

    lpdwSchemeNameLength    - length of scheme name

    lpszHostName            - returned host name

    lpdwHostNameLength      - length of host name buffer

    lpServerPort            - returned server port if present in the URL, else 0

    lpszUserName            - returned user name if present

    lpdwUserNameLength      - length of user name buffer

    lpszPassword            - returned password if present

    lpdwPasswordLength      - length of password buffer

    lpszUrlPath             - returned, canonicalized URL path

    lpdwUrlPathLength       - length of url-path buffer

    lpszExtraInfo           - returned search string or intra-page link if present

    lpdwExtraInfoLength     - length of extra info buffer

    pHavePort               - returned boolean indicating whether port was specified

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_UNRECOGNIZED_SCHEME

--*/

{
    DWORD error;
    DWORD schemeLength;
    INTERNET_SCHEME schemeType;

    //
    // if dwUrlLength is 0 then lpszUrl is ASCIIZ. Find its length
    //

    if (dwUrlLength == 0) {
        dwUrlLength = strlen(lpszUrl);
    }

    //
    // get parser based on the protocol name
    //

    for (schemeLength = 0; lpszUrl[schemeLength] != ':'; ++schemeLength) {
        if ((dwUrlLength == 0) || (lpszUrl[schemeLength] == '\0')) {

            //
            // no ':' in URL? Bogus (dude)
            //

            error = ERROR_WINHTTP_UNRECOGNIZED_SCHEME;
            goto quit;
        }
        --dwUrlLength;
    }

    DWORD i;
    int skip;
    BOOL isGeneric;
    BOOL needSlashes;
    BOOL haveSlashes;

    isGeneric = FALSE;
    needSlashes = FALSE;
    haveSlashes = FALSE;

    schemeType = INTERNET_SCHEME_UNKNOWN;

    if (ScanSchemes(lpszUrl, schemeLength, &i))
    {
        schemeType = UrlSchemeList[i].SchemeType;
        needSlashes = UrlSchemeList[i].NeedSlashes;
    }
    else
    {
        error = ERROR_WINHTTP_UNRECOGNIZED_SCHEME;
        goto quit;
    }

    skip = 1;       // skip ':'

    if ((dwUrlLength > 3) && (memcmp(&lpszUrl[schemeLength], "://", 3) == 0)) {
        skip = 3;   // skip "://"
        haveSlashes = TRUE;
    }

    //
    // If we don't have slashes, make sure we don't need them.
    // If we have slashes, make sure they are required.
    //

    if ((!haveSlashes && !needSlashes) || (haveSlashes && needSlashes)) {
        if (ARGUMENT_PRESENT(lpSchemeType)) {
            *lpSchemeType = schemeType;
        }
        if (ARGUMENT_PRESENT(lpszSchemeName)) {
            *lpszSchemeName = lpszUrl;
            *lpdwSchemeNameLength = schemeLength;
        }
        lpszUrl += schemeLength + skip;
        dwUrlLength -= skip;

        if (isGeneric) {
            if (ARGUMENT_PRESENT(lpszUserName)) {
                *lpszUserName = NULL;
                *lpdwUserNameLength = 0;
            }
            if (ARGUMENT_PRESENT(lpszPassword)) {
                *lpszPassword = NULL;
                *lpdwPasswordLength = 0;
            }
            if (ARGUMENT_PRESENT(lpszHostName)) {
                *lpszHostName = NULL;
                *lpdwHostNameLength = 0;
            }
            if (ARGUMENT_PRESENT(lpServerPort)) {
                *lpServerPort = 0;
            }
            error = ERROR_SUCCESS;
        } else {
            error = GetUrlAddress(&lpszUrl,
                                  &dwUrlLength,
                                  lpszUserName,
                                  lpdwUserNameLength,
                                  lpszPassword,
                                  lpdwPasswordLength,
                                  lpszHostName,
                                  lpdwHostNameLength,
                                  lpServerPort,
                                  pHavePort
                                  );
        }
        if (bEscape && (error == ERROR_SUCCESS)) {
            error = DecodeUrlInSitu(lpszUrl, &dwUrlLength);
        }
        if ((error == ERROR_SUCCESS) && ARGUMENT_PRESENT(lpszExtraInfo)) {
            *lpdwExtraInfoLength = 0;
            for (i = 0; i < (int)dwUrlLength; i++) {
                if (lpszUrl[i] == '?' || lpszUrl[i] == '#') {
                    *lpszExtraInfo = &lpszUrl[i];
                    *lpdwExtraInfoLength = dwUrlLength - i;
                    dwUrlLength -= *lpdwExtraInfoLength;
                }
            }
        }
        if ((error == ERROR_SUCCESS) && ARGUMENT_PRESENT(lpszUrlPath)) {
            *lpszUrlPath = lpszUrl;
            *lpdwUrlPathLength = dwUrlLength;
        }
    } else {
        error = ERROR_WINHTTP_UNRECOGNIZED_SCHEME;
    }

quit:

    return error;
}

#define DEFAULT_REALLOC_SIZE 1024

DWORD
EncodeUrlPath(
    IN DWORD Flags,
    IN DWORD SchemeFlags,
    IN LPSTR UrlPath,
    IN DWORD UrlPathLength,
    OUT LPSTR* pEncodedUrlPath,
    IN OUT LPDWORD EncodedUrlPathLength
    )

/*++

Routine Description:

    Encodes an URL-path. That is, escapes the string. Creates a new URL-path in
    which all the 'unsafe' and reserved characters for this scheme have been
    converted to escape sequences

Arguments:

    Flags                   - controlling expansion

    SchemeFlags             - which scheme we are encoding for -
                              SCHEME_HTTP, etc.

    UrlPath                 - pointer to the unescaped string

    UrlPathLength           - length of Url

    EncodedUrlPath          - pointer to buffer where encoded URL will be
                              written

    EncodedUrlPathLength    - IN: size of EncodedUrlPath
                              OUT: number of bytes written to EncodedUrlPath

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    UrlPathLength not large enough to store encoded URL path

--*/

{
    DWORD error;
    DWORD len;

    len = *EncodedUrlPathLength;
    LPSTR EncodedUrlPath = *pEncodedUrlPath;
    UCHAR ch;

    while(ch = (UCHAR)*UrlPath++)
    {
        //
        // check whether this character is safe. For now, we encode all unsafe
        // and scheme-specific characters the same way (i.e. irrespective of
        // scheme)
        //
        // We are allowing '/' to be copied unmodified
        //

        if (len < 3) 
        {
            LPSTR pStr = (LPSTR)REALLOCATE_MEMORY(*pEncodedUrlPath, *EncodedUrlPathLength+DEFAULT_REALLOC_SIZE, LMEM_MOVEABLE);

            if (pStr)
            {
                EncodedUrlPath = pStr+*EncodedUrlPathLength-len;
                *pEncodedUrlPath = pStr;
                len += DEFAULT_REALLOC_SIZE;
                *EncodedUrlPathLength += DEFAULT_REALLOC_SIZE;
            }
            else
            {                
                goto error;
            }
        }
        
        if (IS_UNSAFE_URL_CHARACTER(ch, SchemeFlags)
        && !((ch == '/') && (Flags & NO_ENCODE_PATH_SEP))) 
        {
            *EncodedUrlPath++ = '%';
            //*EncodedUrlPath++ = NumberToHexChar((int)ch / 16);
            *EncodedUrlPath++ = NUMBER_TO_HEX_CHAR((int)ch / 16);
            //*EncodedUrlPath++ = NumberToHexChar((int)ch % 16);
            *EncodedUrlPath++ = NUMBER_TO_HEX_CHAR((int)ch % 16);
            len -= 2; // extra --len below
        } 
        else 
        {
            *EncodedUrlPath++ = (signed char)ch;
        }
        --len;
    }
    
    *EncodedUrlPath = '\0';
    *EncodedUrlPathLength -= len;
    error = ERROR_SUCCESS;

quit:
    return error;

error:
    error = ERROR_INSUFFICIENT_BUFFER;
    goto quit;
}


PRIVATE
char
HexCharToNumber(
    IN char ch
    )

/*++

Routine Description:

    Converts an ANSI character in the range '0'..'9' 'A'..'F' 'a'..'f' to its
    corresponding hexadecimal value (0..f)

Arguments:

    ch  - character to convert

Return Value:

    char
        hexadecimal value of ch, as an 8-bit (signed) character value

--*/

{
    return (ch <= '9') ? (ch - '0')
                       : ((ch >= 'a') ? ((ch - 'a') + 10) : ((ch - 'A') + 10));
}


PRIVATE
char
NumberToHexChar(
    IN int Number
    )

/*++

Routine Description:

    Converts a number in the range 0..15 to its ASCII character hex representation
    ('0'..'F')

Arguments:

    Number  - to convert

Return Value:

    char
        character in above range

--*/

{
    return (Number <= 9) ? (char)('0' + Number) : (char)('A' + (Number - 10));
}


DWORD
DecodeUrl(
    IN LPSTR Url,
    IN DWORD UrlLength,
    OUT LPSTR DecodedString,
    IN OUT LPDWORD DecodedLength
    )

/*++

Routine Description:

    Converts an URL string with embedded escape sequences (%xx) to a counted
    string

    It is safe to pass the same pointer for the string to convert, and the
    buffer for the converted results: if the current character is not escaped,
    it just gets overwritten, else the input pointer is moved ahead 2 characters
    further than the output pointer, which is benign

Arguments:

    Url             - pointer to URL string to convert

    UrlLength       - number of characters in UrlString

    DecodedString   - pointer to buffer that receives converted string

    DecodedLength   - IN: number of characters in buffer
                      OUT: number of characters converted

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_INVALID_URL
                    UrlString couldn't be converted

                  ERROR_INSUFFICIENT_BUFFER
                    ConvertedString isn't large enough to hold all the converted
                    UrlString

--*/

{
    DWORD bufferRemaining;

    bufferRemaining = *DecodedLength;
    while (UrlLength && bufferRemaining) {

        char ch;

        if (*Url == '%') {

            //
            // BUGBUG - would %00 ever appear in an URL?
            //

            ++Url;
            if (isxdigit(*Url)) {
                ch = HexCharToNumber(*Url++) << 4;
                if (isxdigit(*Url)) {
                    ch |= HexCharToNumber(*Url++);
                } else {
                    return ERROR_WINHTTP_INVALID_URL;
                }
            } else {
                return ERROR_WINHTTP_INVALID_URL;
            }
            UrlLength -= 3;
        } else {
            ch = *Url++;
            --UrlLength;
        }
        *DecodedString++ = ch;
        --bufferRemaining;
    }
    if (UrlLength == 0) {
        *DecodedLength -= bufferRemaining;
        return ERROR_SUCCESS;
    } else {
        return ERROR_INSUFFICIENT_BUFFER;
    }
}


DWORD
DecodeUrlInSitu(
    IN LPSTR BufferAddress,
    IN OUT LPDWORD BufferLength
    )

/*++

Routine Description:

    Decodes an URL string, if it contains escape sequences. The conversion is
    done in place, since we know that a string containing escapes is longer than
    the string with escape sequences (3 bytes) converted to characters (1 byte)

Arguments:

    BufferAddress   - pointer to the string to convert

    BufferLength    - IN: number of characters to convert
                      OUT: length of converted string

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_INVALID_URL
                  ERROR_INSUFFICIENT_BUFFER

--*/

{
    DWORD stringLength;

    stringLength = *BufferLength;
    if (memchr(BufferAddress, '%', stringLength)) {
        return DecodeUrl(BufferAddress,
                         stringLength,
                         BufferAddress,
                         BufferLength
                         );
    } else {

        //
        // no escape character in the string, just return success
        //

        return ERROR_SUCCESS;
    }
}


DWORD
DecodeUrlStringInSitu(
    IN LPSTR BufferAddress,
    IN OUT LPDWORD BufferLength
    )

/*++

Routine Description:

    Performs DecodeUrlInSitu() on a string and zero terminates it

    Assumes: 1. Even if no decoding is performed, *BufferLength is large enough
                to fit an extra '\0' character

Arguments:

    BufferAddress   - pointer to the string to convert

    BufferLength    - IN: number of characters to convert
                      OUT: length of converted string, excluding '\0'

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_INVALID_URL
                  ERROR_INSUFFICIENT_BUFFER

--*/

{
    DWORD error;

    error = DecodeUrlInSitu(BufferAddress, BufferLength);
    if (error == ERROR_SUCCESS) {
        BufferAddress[*BufferLength] = '\0';
    }
    return error;
}


DWORD
GetUrlAddressInfo(
    IN OUT LPSTR* Url,
    IN OUT LPDWORD UrlLength,
    OUT LPSTR* PartOne,
    OUT LPDWORD PartOneLength,
    OUT LPBOOL PartOneEscape,
    OUT LPSTR* PartTwo,
    OUT LPDWORD PartTwoLength,
    OUT LPBOOL PartTwoEscape
    )

/*++

Routine Description:

    Given a string of the form foo:bar, splits them into 2 counted strings about
    the ':' character. The address string may or may not contain a ':'.

    This function is intended to split into substrings the host:port and
    username:password strings commonly used in Internet address specifications
    and by association, in URLs

Arguments:

    Url             - pointer to pointer to string containing URL. On output
                      this is advanced past the address parts

    UrlLength       - pointer to length of URL in UrlString. On output this is
                      reduced by the number of characters parsed

    PartOne         - pointer which will receive first part of address string

    PartOneLength   - pointer which will receive length of first part of address
                      string

    PartOneEscape   - TRUE on output if PartOne contains escape sequences

    PartTwo         - pointer which will receive second part of address string

    PartTwoLength   - pointer which will receive length of second part of address
                      string

    PartOneEscape   - TRUE on output if PartTwo contains escape sequences

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_INVALID_URL

--*/

{
    LPSTR pString;
    LPSTR pColon;
    DWORD partLength;
    LPBOOL partEscape;
    DWORD length;

    //
    // parse out <host>[:<port>] or <name>[:<password>] (i.e. <part1>[:<part2>]
    //

    pString = *Url;
    pColon = NULL;
    partLength = 0;
    *PartOne = pString;
    *PartOneLength = 0;
    *PartOneEscape = FALSE;
    *PartTwoEscape = FALSE;
    partEscape = PartOneEscape;
    length = *UrlLength;
    while ((*pString != '/') && (*pString != '\0') && (length != 0)) {
        if (*pString == '%') {

            //
            // if there is a % in the string then it *must* (RFC 1738) be the
            // start of an escape sequence. This function just reports the
            // address of the substrings and their lengths; calling functions
            // must handle the escape sequences (i.e. it is their responsibility
            // to decide where to put the results)
            //

            *partEscape = TRUE;
        }
        if (*pString == ':') {
            if (pColon != NULL) {

                //
                // we don't expect more than 1 ':'
                //

                return ERROR_WINHTTP_INVALID_URL;
            }
            pColon = pString;
            *PartOneLength = partLength;
            if (partLength == 0) {
                *PartOne = NULL;
            }
            partLength = 0;
            partEscape = PartTwoEscape;
        } else {
            ++partLength;
        }
        ++pString;
        --length;
    }

    //
    // we either ended on the host (or user) name or the port number (or
    // password), one of which we don't know the length of
    //

    if (pColon == NULL) {
        *PartOneLength = partLength;
        *PartTwo = NULL;
        *PartTwoLength = 0;
        *PartTwoEscape = FALSE;
    } else {
        *PartTwoLength = partLength;
        *PartTwo = pColon + 1;

        //
        // in both the <user>:<password> and <host>:<port> cases, we cannot have
        // the second part without the first, although both parts being zero
        // length is OK (host name will be sorted out elsewhere, but (for now,
        // at least) I am allowing <>:<> for username:password, since I don't
        // see it expressly disallowed in the RFC. I may be revisiting this code
        // later...)
        //
        // N.B.: ftp://ftp.microsoft.com uses http://:0/-http-gw-internal-/menu.gif

//      if ((*PartOneLength == 0) && (partLength != 0)) {
//          return ERROR_WINHTTP_INVALID_URL;
//      }
    }

    //
    // update the URL pointer and length remaining
    //

    *Url = pString;
    *UrlLength = length;

    return ERROR_SUCCESS;
}


DWORD
GetUrlAddress(
    IN OUT LPSTR* lpszUrl,
    OUT LPDWORD lpdwUrlLength,
    OUT LPSTR* lpszUserName OPTIONAL,
    OUT LPDWORD lpdwUserNameLength OPTIONAL,
    OUT LPSTR* lpszPassword OPTIONAL,
    OUT LPDWORD lpdwPasswordLength OPTIONAL,
    OUT LPSTR* lpszHostName OPTIONAL,
    OUT LPDWORD lpdwHostNameLength OPTIONAL,
    OUT LPINTERNET_PORT lpPort OPTIONAL,
    OUT LPBOOL pHavePort
    )

/*++

Routine Description:

    This function extracts any and all parts of the address information for a
    generic URL. If any of the address parts contain escaped characters (%nn)
    then they are converted in situ

    The generic addressing format (RFC 1738) is:

        <user>:<password>@<host>:<port>

    The addressing information cannot contain a password without a user name,
    or a port without a host name
    NB: ftp://ftp.microsoft.com uses URL's that have a port without a host name!
    (e.g. http://:0/-http-gw-internal-/menu.gif)

    Although only the lpszUrl and lpdwUrlLength fields are required, the address
    parts will be checked for presence and completeness

    Assumes: 1. If one of the optional lpsz fields is present (e.g. lpszUserName)
                then the accompanying lpdw field must also be supplied

Arguments:

    lpszUrl             - IN: pointer to the URL to parse
                          OUT: URL remaining after address information

                          N.B. The url-path is NOT canonicalized (unescaped)
                          because it may contain protocol-specific information
                          which must be parsed out by the protocol-specific
                          parser

    lpdwUrlLength       - returned length of the remainder of the URL after the
                          address information

    lpszUserName        - returned pointer to the user name
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user names in the URL

    lpdwUserNameLength  - returned length of the user name part
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user names in the URL

    lpszPassword        - returned pointer to the password
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user passwords in the URL

    lpdwPasswordLength  - returned length of the password
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user passwords in the URL

    lpszHostName        - returned pointer to the host name
                          This parameter can be omitted by those protocol parsers
                          that do not require the host name info

    lpdwHostNameLength  - returned length of the host name
                          This parameter can be omitted by those protocol parsers
                          that do not require the host name info

    lpPort              - returned value of the port field
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user port number

    pHavePort           - returned boolean indicating whether a port was specified
                          in the URL or not.  This value is not returned if the
                          lpPort parameter is omitted.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_INVALID_URL
                    We could not parse some part of the address info, or we
                    found address info where the protocol parser didn't expect
                    any

                  ERROR_INSUFFICIENT_BUFFER
                    We could not convert an escaped string

--*/

{
    LPSTR pAt;
    DWORD urlLength;
    LPSTR pUrl;
    BOOL part1Escape;
    BOOL part2Escape;
    char portNumber[INTERNET_MAX_PORT_NUMBER_LENGTH + 1];
    DWORD portNumberLength;
    LPSTR pPortNumber;
    DWORD error;
    LPSTR hostName;
    DWORD hostNameLength;

    pUrl = *lpszUrl;
    urlLength = strlen(pUrl);

    //
    // check to see if there is an '@' separating user name & password. If we
    // see a '/' or get to the end of the string before we see the '@' then
    // there is no username:password part
    //

    pAt = NULL;
    for (DWORD i = 0; i < urlLength; ++i) {
        if (pUrl[i] == '/') {
            break;
        } else if (pUrl[i] == '@') {
            pAt = &pUrl[i];
            break;
        }
    }

    if (pAt != NULL) {

        DWORD addressPartLength;
        LPSTR userName;
        DWORD userNameLength;
        LPSTR password;
        DWORD passwordLength;

        addressPartLength = (DWORD) (pAt - pUrl);
        urlLength -= addressPartLength;
        error = GetUrlAddressInfo(&pUrl,
                                  &addressPartLength,
                                  &userName,
                                  &userNameLength,
                                  &part1Escape,
                                  &password,
                                  &passwordLength,
                                  &part2Escape
                                  );
        if (error != ERROR_SUCCESS) {
            return error;
        }

        //
        // ensure there is no address information unparsed before the '@'
        //

        INET_ASSERT(addressPartLength == 0);
        INET_ASSERT(pUrl == pAt);

        if (ARGUMENT_PRESENT(lpszUserName)) {

            INET_ASSERT(ARGUMENT_PRESENT(lpdwUserNameLength));

            //
            // convert the user name in situ
            //

            if (part1Escape) {

                INET_ASSERT(userName != NULL);
                INET_ASSERT(userNameLength != 0);

                error = DecodeUrlInSitu(userName, &userNameLength);
                if (error != ERROR_SUCCESS) {
                    return error;
                }
            }
            *lpszUserName = userName;
            *lpdwUserNameLength = userNameLength;
        }

        if (ARGUMENT_PRESENT(lpszPassword)) {

            //
            // convert the password in situ
            //

            if (part2Escape) {

                INET_ASSERT(userName != NULL);
                INET_ASSERT(userNameLength != 0);
                INET_ASSERT(password != NULL);
                INET_ASSERT(passwordLength != 0);

                error = DecodeUrlInSitu(password, &passwordLength);
                if (error != ERROR_SUCCESS) {
                    return error;
                }
            }
            *lpszPassword = password;
            *lpdwPasswordLength = passwordLength;
        }

        //
        // the URL pointer now points at the host:port fields (remember that
        // ExtractAddressParts() must have bumped pUrl up to the end of the
        // password field (if present) which ends at pAt)
        //

        ++pUrl;

        //
        // similarly, bump urlLength to account for the '@'
        //

        --urlLength;
    } else {

        //
        // no '@' therefore no username or password
        //

        if (ARGUMENT_PRESENT(lpszUserName)) {

            INET_ASSERT(ARGUMENT_PRESENT(lpdwUserNameLength));

            *lpszUserName = NULL;
            *lpdwUserNameLength = 0;
        }
        if (ARGUMENT_PRESENT(lpszPassword)) {

            INET_ASSERT(ARGUMENT_PRESENT(lpdwPasswordLength));

            *lpszPassword = NULL;
            *lpdwPasswordLength = 0;
        }
    }

    //
    // now get the host name and the optional port
    //

    pPortNumber = portNumber;
    portNumberLength = sizeof(portNumber);
    error = GetUrlAddressInfo(&pUrl,
                              &urlLength,
                              &hostName,
                              &hostNameLength,
                              &part1Escape,
                              &pPortNumber,
                              &portNumberLength,
                              &part2Escape
                              );
    if (error != ERROR_SUCCESS) {
        return error;
    }

    //
    // the URL address information MUST contain the host name
    //

//  if ((hostName == NULL) || (hostNameLength == 0)) {
//      return ERROR_WINHTTP_INVALID_URL;
//  }

    if (ARGUMENT_PRESENT(lpszHostName)) {

        INET_ASSERT(ARGUMENT_PRESENT(lpdwHostNameLength));

        //
        // if the host name contains escaped characters, convert them in situ
        //

        if (part1Escape) {
            error = DecodeUrlInSitu(hostName, &hostNameLength);
            if (error != ERROR_SUCCESS) {
                return error;
            }
        }
        *lpszHostName = hostName;
        *lpdwHostNameLength = hostNameLength;
    }

    //
    // if there is a port field, convert it if there are escaped characters,
    // check it for valid numeric characters, and convert it to a number
    //

    if (ARGUMENT_PRESENT(lpPort)) {
        if (portNumberLength != 0) {

            DWORD i;
            DWORD port;

            INET_ASSERT(pPortNumber != NULL);

            if (part2Escape) {
                error = DecodeUrlInSitu(pPortNumber, &portNumberLength);
                if (error != ERROR_SUCCESS) {
                    return error;
                }
            }

            //
            // ensure all characters in the port number buffer are numeric, and
            // calculate the port number at the same time
            //

            for (i = 0, port = 0; i < portNumberLength; ++i) {
                if (!isdigit(*pPortNumber)) {
                    return ERROR_WINHTTP_INVALID_URL;
                }
                port = port * 10 + (int)(*pPortNumber++ - '0');
                // We won't allow ports larger than 65535 ((2^16)-1)
                // We have to check this every time to make sure that someone
                // doesn't try to overflow a DWORD.
                if (port > 65535)
                {
                    return ERROR_WINHTTP_INVALID_URL;
                }
            }
            *lpPort = (INTERNET_PORT)port;
            if (ARGUMENT_PRESENT(pHavePort)) {
                *pHavePort = TRUE;
            }
        } else {
            *lpPort = INTERNET_INVALID_PORT_NUMBER;
            if (ARGUMENT_PRESENT(pHavePort)) {
                *pHavePort = FALSE;
            }
        }
    }

    //
    // update the URL pointer and the length of the url-path
    //

    *lpszUrl = pUrl;
    *lpdwUrlLength = urlLength;

    return ERROR_SUCCESS;
}


INTERNET_SCHEME
MapUrlSchemeName(
    IN LPSTR lpszSchemeName,
    IN DWORD dwSchemeNameLength
    )

/*++

Routine Description:

    Maps a scheme name/length to a scheme name type

Arguments:

    lpszSchemeName      - pointer to name of scheme to map

    dwSchemeNameLength  - length of scheme (if -1, lpszSchemeName is ASCIZ)

Return Value:

    INTERNET_SCHEME

--*/

{
    if (dwSchemeNameLength == (DWORD)-1) {
        dwSchemeNameLength = (DWORD)lstrlen(lpszSchemeName);
    }

    DWORD i;
    if (ScanSchemes(lpszSchemeName, dwSchemeNameLength, &i))
    {
        return UrlSchemeList[i].SchemeType;
    }
    return INTERNET_SCHEME_UNKNOWN;
}


LPSTR
MapUrlScheme(
    IN INTERNET_SCHEME Scheme,
    OUT LPDWORD lpdwSchemeNameLength
    )

/*++

Routine Description:

    Maps the enumerated scheme name type to the name

Arguments:

    Scheme                  - enumerated scheme type to map

    lpdwSchemeNameLength    - pointer to returned length of scheme name

Return Value:

    LPSTR   - pointer to scheme name or NULL

--*/

{
    if ((Scheme >= INTERNET_SCHEME_FIRST)
    && (Scheme <= INTERNET_SCHEME_LAST)) 
    {
        *lpdwSchemeNameLength = UrlSchemeList[Scheme].SchemeLength;
        return UrlSchemeList[Scheme].SchemeName;
    }
    *lpdwSchemeNameLength = 0;
    return NULL;
}


LPSTR
MapUrlSchemeToName(
    IN INTERNET_SCHEME Scheme
    )

/*++

Routine Description:

    Maps the enumerated scheme name type to the name

Arguments:

    Scheme  - enumerated scheme type to map

Return Value:

    LPSTR   - pointer to scheme name or NULL

--*/

{
    if ((Scheme >= INTERNET_SCHEME_FIRST)
    && (Scheme <= INTERNET_SCHEME_LAST)) {
        return UrlSchemeList[Scheme].SchemeName;
    }
    return NULL;
}

/*
 * ConvertUnicodeToMultiByte:
 *
 * dwFlags: WINHTTP_FLAG_NULL_CODEPAGE-> assumes correctly encoded string packaged into UTF8, no escaping done.
            WINHTTP_FLAG_VALID_HOSTNAME-> only for server name
                only the previous flag valid for server name passed in here.
                if both of these are not specified, then

            if dwCodePage is not INVALID, it'll be used to convert unicode string to ANSI.
            else UTF8 will be used.

            if ESCAPE && ESCAPE_PERCENT is specified, the ANSI url will be escaped (incl. %) else it will be escaped w/o
            escaping %s.
 */
 
DWORD
ConvertUnicodeToMultiByte(
    LPCWSTR lpszObjectName, 
    DWORD dwCodePage, 
    MEMORYPACKET* pmp, 
    DWORD dwFlags)
{
    DWORD dwError = ERROR_SUCCESS;
    LPSTR pStr;
    WCHAR wc;
    LPCWSTR pwStr;
    BOOL bStrip0s = TRUE;       
    DWORD dwUnicodeUrlSize;

//determine size of string and/or safe characters
    if ((dwFlags & WINHTTP_FLAG_NULL_CODEPAGE) ||
        (dwFlags & WINHTTP_FLAG_VALID_HOSTNAME))
    {
        if (dwFlags & WINHTTP_FLAG_VALID_HOSTNAME)
        {
            for (pwStr = lpszObjectName; wc = *pwStr; ++pwStr)
            {
                if (IS_UNSAFE_URL_WIDECHARACTER(wc, HOSTNAME))
                {
                    dwError = ERROR_WINHTTP_INVALID_URL;
                    goto done;
                }
            }
            pmp->dwAlloc = dwUnicodeUrlSize = (DWORD)(pwStr-lpszObjectName+1);
        }
        else
        {
            pmp->dwAlloc = dwUnicodeUrlSize = lstrlenW(lpszObjectName)+1;
        }
    }
    else 
    {
        DWORD dwUnsafeChars = 0;
        
        // optimization to check for unsafe characters, and optimize the common case.
        // calculate the length, and while parsing the string, check if there are unsafeChars
        for(pwStr = lpszObjectName; wc = *pwStr; ++pwStr)
        {
            if (IS_UNSAFE_URL_WIDECHARACTER(wc, 0))
                ++dwUnsafeChars;
        }
        dwUnicodeUrlSize = (DWORD)(pwStr-lpszObjectName+1);

        if (dwUnsafeChars == 0)
        {
            pmp->dwAlloc = dwUnicodeUrlSize;            
        }
        else
        {
            bStrip0s = FALSE;
        }
    }

//convert to MBCS
    if (bStrip0s)
    {
        INET_ASSERT(pmp->dwAlloc);
        
        pmp->psStr = (LPSTR)ALLOCATE_FIXED_MEMORY(pmp->dwAlloc);

        if (!pmp->psStr)
        {
            pmp->dwAlloc = 0;
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }
        pmp->dwSize = pmp->dwAlloc-1;
        
        for (pStr = pmp->psStr; wc = *lpszObjectName; ++lpszObjectName)
        {
            *(pStr)++ = (CHAR)wc;
        }
        *pStr = '\0';
    }
    else
    {
        // convert with WideCharToMultiByte()
        pmp->dwAlloc = WideCharToMultiByte(dwCodePage, 0, lpszObjectName, dwUnicodeUrlSize, NULL, 0, NULL, NULL);
        if (pmp->dwAlloc)
        {
            pmp->psStr = (LPSTR)ALLOCATE_FIXED_MEMORY(pmp->dwAlloc);

            if (!pmp->psStr)
            {
                pmp->dwAlloc = 0;
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                goto done;
            }
            pmp->dwSize = WideCharToMultiByte(dwCodePage, 0, lpszObjectName, dwUnicodeUrlSize, pmp->psStr, pmp->dwAlloc, NULL, NULL);

            if (!pmp->dwSize)
            {
                dwError = GetLastError();
                goto done;
            }
            else
                pmp->dwSize -= 1; 
        }
        else
        {
            dwError = GetLastError();
            goto done;
        }
    }

//escaping
    if (dwFlags & WINHTTP_FLAG_DEFAULT_ESCAPE)
    {
        INET_ASSERT (! (dwFlags & WINHTTP_FLAG_VALID_HOSTNAME));
        
        static CHAR* hexArray = "0123456789ABCDEF";
        UCHAR ch;
        DWORD dwUnsafeChars = 0;
        DWORD dwNewAlloc;
        LPSTR pDest, pNewStr;
        
        for(pStr = pmp->psStr; ch = *pStr; pStr = CharNextExA((WORD)dwCodePage, pStr, 0))
        {
            if (IS_UNSAFE_URL_CHARACTER(ch, SCHEME_HTTP))
                ++dwUnsafeChars;
            else if(ch == '?')
                break;
        }

        if (dwUnsafeChars == 0)
            goto done;


        dwNewAlloc = pmp->dwAlloc + dwUnsafeChars*2;
        pNewStr = pDest = (LPSTR)ALLOCATE_FIXED_MEMORY(dwNewAlloc);

        if (!pDest)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }

        BOOL bEscapePercent = (dwFlags & WINHTTP_FLAG_ESCAPE_PERCENT) ? TRUE : FALSE;

        BOOL bHitQuery = FALSE;
        LPSTR pNext;
        BOOL bLead;
        for (pStr = pmp->psStr; ch = *pStr;)
        {
            pNext = CharNextExA((WORD)dwCodePage, pStr, 0);
            bLead = TRUE;
            do
            {
                ch = *pStr;
                if (IS_UNSAFE_URL_CHARACTER(ch, SCHEME_HTTP)
                    && (!bLead || (ch != '%') || bEscapePercent) )
                {
                    *pDest++ = '%';
                    *pDest++ = hexArray[ch>>4];
                    *pDest++ = hexArray[ch & 0x0f];
                }
                else
                {
                    *pDest++ = ch;
                    if ((ch == '?') && bLead)
                    {
                        bHitQuery = TRUE;

                        ++pStr;
                        INET_ASSERT(pStr == pNext);

                        break;
                    }
                }
                bLead = FALSE;
            }
            while (++pStr != pNext);

            if (bHitQuery)
                break;
        }

        if (bHitQuery)
        {
            for ( ; ch = *pStr; pStr++)
            {
                *pDest++ = ch;
            }
        }
        *pDest = '\0';

        FREE_FIXED_MEMORY(pmp->psStr);
        pmp->psStr = pNewStr;
        pmp->dwSize = (DWORD)(pDest-pNewStr);
        pmp->dwAlloc = dwNewAlloc;
    }
     
done:
    if (pmp->psStr)
        pmp->dwAlloc = (pmp->dwAlloc > MP_MAX_STACK_USE) ? pmp->dwAlloc : MP_MAX_STACK_USE+1;// to force FREE in ~MEMORYPACKET
        
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\api\options.cxx ===
/*++

Copyright (c) 1994-98  Microsoft Corporation

Module Name:

    options.cxx

Abstract:

    Contains the Internet*Option APIs

    Contents:
        InternetQueryOptionA
        InternetSetOptionA
        WinHttpQueryOption
        WinHttpSetOption
        (FValidCacheHandleType)

Author:

    Richard L Firth (rfirth) 02-Mar-1995

Environment:

    Win32 user-mode DLL

Revision History:

    02-Mar-1995 rfirth
        Created

    07-Mar-1995 madana

    07-Jul-1998 Forked by akabir

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "msident.h"

//
// private macros
//

//
// IS_PER_THREAD_OPTION - options applicable to the thread (HINTERNET is NULL).
// Subset of IS_VALID_OPTION()
//

#define IS_PER_THREAD_OPTION(option) ((                     \
       ((option) == WINHTTP_OPTION_EXTENDED_ERROR)         \
    || ((option) == WINHTTP_OPTION_PER_CONNECTION_OPTION)  \
    ) ? TRUE : FALSE)

//
// IS_PER_PROCESS_OPTION - options applicable to the process (HINTERNET is NULL).
// Subset of IS_VALID_OPTION()
//

#define IS_PER_PROCESS_OPTION(option)                       \
    (( ((option) == WINHTTP_OPTION_GET_DEBUG_INFO)         \
    || ((option) == WINHTTP_OPTION_SET_DEBUG_INFO)         \
    || ((option) == WINHTTP_OPTION_GET_HANDLE_COUNT)       \
    || ((option) == WINHTTP_OPTION_PROXY)                  \
    || ((option) == WINHTTP_OPTION_VERSION)                \
    || ((option) == WINHTTP_OPTION_HTTP_VERSION)           \
    || ((option) == WINHTTP_OPTION_DIGEST_AUTH_UNLOAD)    \
    || ((option) == WINHTTP_OPTION_PER_CONNECTION_OPTION)  \
    || ((option) == WINHTTP_OPTION_WORKER_THREAD_COUNT) \
    ) ? TRUE : FALSE)

//
// IS_DEBUG_OPTION - the set of debug-specific options
//

#define IS_DEBUG_OPTION(option)                     \
    (( ((option) >= INTERNET_FIRST_DEBUG_OPTION)    \
    && ((option) <= INTERNET_LAST_DEBUG_OPTION)     \
    ) ? TRUE : FALSE)

//
// IS_VALID_OPTION - the set of known option values, for a HINTERNET, thread, or
// process. In the retail version, debug options are invalid
//

#if INET_DEBUG

#define IS_VALID_OPTION(option)             \
    (((((option) >= WINHTTP_FIRST_OPTION)  \
    && ((option) <= WINHTTP_LAST_OPTION_INTERNAL))  \
    || IS_DEBUG_OPTION(option)              \
    ) ? TRUE : FALSE)

#else

#define IS_VALID_OPTION(option)             \
    (((((option) >= WINHTTP_FIRST_OPTION)  \
    && ((option) <= WINHTTP_LAST_OPTION_INTERNAL))  \
    ) ? TRUE : FALSE)

#endif // INET_DEBUG

//
// private prototypes
//
PRIVATE
BOOL
FValidCacheHandleType(
    HINTERNET_HANDLE_TYPE   hType
    );

PRIVATE
VOID
InitIPCOList(LPINTERNET_PER_CONN_OPTION_LISTW plistW, LPINTERNET_PER_CONN_OPTION_LISTA plistA)
{
    plistA->dwSize = sizeof(INTERNET_PER_CONN_OPTION_LISTA);
    plistA->dwOptionCount = plistW->dwOptionCount;
    if (plistW->pszConnection && *plistW->pszConnection)
    {
        SHUnicodeToAnsi(plistW->pszConnection, plistA->pszConnection, RAS_MaxEntryName + 1);
    }
    else
    {
        plistA->pszConnection = NULL;
    }
}

//
// functions
//


INTERNETAPI
BOOL
WINAPI
InternetQueryOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns information about various handle-specific variables

Arguments:

    hInternet           - handle of object for which information will be
                          returned

    dwOption            - the handle-specific WINHTTP_OPTION to query

    lpBuffer            - pointer to a buffer which will receive results

    lpdwBufferLength    - IN: number of bytes available in lpBuffer
                          OUT: number of bytes returned in lpBuffer

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info:
                    ERROR_INVALID_HANDLE
                        hInternet does not identify a valid Internet handle
                        object

                    ERROR_WINHTTP_INTERNAL_ERROR
                        Shouldn't see this?

                    ERROR_INVALID_PARAMETER
                        One of the parameters was bad

                    ERROR_INSUFFICIENT_BUFFER
                        lpBuffer is not large enough to hold the requested
                        information; *lpdwBufferLength contains the number of
                        bytes needed

                    ERROR_WINHTTP_INCORRECT_HANDLE_TYPE
                        The handle is the wrong type for the requested option

                    ERROR_WINHTTP_INVALID_OPTION
                        The option is unrecognized

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetQueryOptionA",
                     "%#x, %s (%d), %#x, %#x [%d]",
                     hInternet,
                     InternetMapOption(dwOption),
                     dwOption,
                     lpBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength
                        ? (!IsBadReadPtr(lpdwBufferLength, sizeof(DWORD))
                            ? *lpdwBufferLength
                            : 0)
                        : 0
                     ));

    DWORD error;
    BOOL success;
    HINTERNET_HANDLE_TYPE handleType;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD requiredSize = 0;
    LPVOID lpSource;
    DWORD dwValue;
    DWORD_PTR dwPtrValue;
    HANDLE hValue;
    HINTERNET hObjectMapped = NULL;
    BOOL isString = FALSE;
    INTERNET_DIAGNOSTIC_SOCKET_INFO socketInfo;

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {
            goto done;
        }
    }

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto done;
    }

    //
    // validate parameters
    //

    INET_ASSERT(lpdwBufferLength);

    if (!ARGUMENT_PRESENT(lpBuffer)) {
        *lpdwBufferLength = 0;
    }

    //
    // validate the handle and get its type
    //

    HINTERNET hOriginal;

    hOriginal = hInternet;
    if (ARGUMENT_PRESENT(hInternet)) {

        //
        // map the handle
        //

        error = MapHandleToAddress(hInternet, (LPVOID *)&hObjectMapped, FALSE);
        if (error == ERROR_SUCCESS) {
            hInternet = hObjectMapped;
            error = RGetHandleType(hInternet, &handleType);
        }
    } else if (IS_PER_THREAD_OPTION(dwOption)) {

        //
        // this option updates the per-thread information block, so this is a
        // good point at which to get it
        //

        if (lpThreadInfo != NULL) {
            error = ERROR_SUCCESS;
        } else {

            DEBUG_PRINT(INET,
                        ERROR,
                        ("InternetGetThreadInfo() returns NULL\n"
                        ));

            //
            // we never expect this - ERROR_WINHTTP_SPANISH_INQUISITION
            //

            INET_ASSERT(FALSE);

            error = ERROR_WINHTTP_INTERNAL_ERROR;
        }
    } else if (IS_PER_PROCESS_OPTION(dwOption)) {
        error = ERROR_SUCCESS;
    } else {

        //
        // catch any invalid options for the NULL handle. If the option is valid
        // then it is incorrect for this handle type, otherwise its an invalid
        // option, period
        //

        error = IS_VALID_OPTION(dwOption)
                    ? ERROR_WINHTTP_INCORRECT_HANDLE_TYPE
                    : ERROR_WINHTTP_INVALID_OPTION
                    ;
    }

    //
    // if the option and handle combination is valid then query the option value
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    HTTP_REQUEST_HANDLE_OBJECT* pReq;

    switch (handleType)
    {
        case TypeHttpRequestHandle:
            pReq = (HTTP_REQUEST_HANDLE_OBJECT*) hInternet;
            break;

        case TypeInternetHandle:
            pReq = NULL;
            break;

        default:
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;           
            goto quit;
    }
   
   
    // New fast path for request handle options.

    if (dwOption > WINHTTP_OPTION_MASK)
    {
        dwOption &= WINHTTP_OPTION_MASK;
        if (dwOption > MAX_INTERNET_STRING_OPTION)
            error = ERROR_INVALID_PARAMETER;
        else if (!pReq)
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        else
        {
            lpSource = pReq->GetProp (dwOption);
            isString = TRUE;
            error = ERROR_SUCCESS;
        }
        goto quit;
    }

    switch (dwOption) {
    case WINHTTP_OPTION_CALLBACK:
        requiredSize = sizeof(WINHTTP_STATUS_CALLBACK);
        if (hInternet != NULL) {
            error = RGetStatusCallback(hInternet,
                                       (LPWINHTTP_STATUS_CALLBACK)&dwValue
                                       );
            lpSource = (LPVOID)&dwValue;
        } else {
            error = ERROR_INVALID_HANDLE;
        }
        break;

    case WINHTTP_OPTION_RESOLVE_TIMEOUT:
    case WINHTTP_OPTION_CONNECT_TIMEOUT:
    case WINHTTP_OPTION_CONNECT_RETRIES:
    case WINHTTP_OPTION_SEND_TIMEOUT:
    case WINHTTP_OPTION_RECEIVE_TIMEOUT:
        requiredSize = sizeof(DWORD);

        //
        // remember hInternet in the INTERNET_THREAD_INFO then call
        // GetTimeoutValue(). If hInternet refers to a valid Internet
        // object handle, then the relevant timeout value will be
        // returned from that, else we will return the global value
        // corresponding to the requested option
        //

        InternetSetObjectHandle(hOriginal, hInternet);
        dwValue = GetTimeoutValue(dwOption);
        lpSource = (LPVOID)&dwValue;
        break;

    case WINHTTP_OPTION_HANDLE_TYPE:

        requiredSize = sizeof(dwValue);
        switch (handleType)
        {
        case TypeInternetHandle:
            dwValue = WINHTTP_HANDLE_TYPE_SESSION;
            break;

        case TypeHttpConnectHandle:
            dwValue = WINHTTP_HANDLE_TYPE_CONNECT;
            break;

        case TypeHttpRequestHandle:
            dwValue = WINHTTP_HANDLE_TYPE_REQUEST;
            break;

        default:
            error = ERROR_WINHTTP_INTERNAL_ERROR;
            break;
        }
        lpSource = (LPVOID)&dwValue;
        break;

    case WINHTTP_OPTION_CONTEXT_VALUE:
        requiredSize = sizeof(DWORD_PTR);
        error = RGetContext(hInternet, &dwPtrValue);
        lpSource = (LPVOID)&dwPtrValue;
        break;

    case WINHTTP_OPTION_READ_BUFFER_SIZE:
    case WINHTTP_OPTION_WRITE_BUFFER_SIZE:
    
        if (pReq)
        {
            requiredSize = sizeof(DWORD);
            error = ERROR_SUCCESS;
            dwValue = pReq->GetBufferSize(dwOption);
            lpSource = (LPVOID)&dwValue;
        }
        else
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_PARENT_HANDLE:
        hInternet = ((HANDLE_OBJECT *)hInternet)->GetParent();
        if (hInternet != NULL) {
            hInternet = ((HANDLE_OBJECT *)hInternet)->GetPseudoHandle();
        }
        requiredSize = sizeof(hInternet);
        lpSource = (LPVOID)&hInternet;
        break;

    case WINHTTP_OPTION_EXTENDED_ERROR:
        requiredSize = sizeof(lpThreadInfo->dwMappedErrorCode);
        lpSource = (LPVOID)&lpThreadInfo->dwMappedErrorCode;
        break;
    
    case WINHTTP_OPTION_SECURITY_FLAGS:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;

            requiredSize = sizeof(dwValue);
            dwValue = 0;
            lpSource = (LPVOID)&dwValue;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;

            dwValue = lphHttpRqst->GetSecureFlags();

            DEBUG_PRINT(INET,
                        INFO,
                        ("SECURITY_FLAGS: %X\n",
                        dwValue
                        ));


            error = ERROR_SUCCESS;
        }

        break;

   
    case WINHTTP_OPTION_URL:

        //
        // return the URL associated with the request handle. This may be
        // different from the original URL due to redirections
        //

        if (pReq)
        {

            //
            // only these handle types (retrieved object handles) can have
            // associated URLs
            //

            lpSource = pReq->GetURL();
            isString = TRUE;

            INET_ASSERT(error == ERROR_SUCCESS);

        }
        else
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;


    case WINHTTP_OPTION_SECURITY_CONNECTION_INFO:
        //
        // Caller is expected to pass in an INTERNET_SECURITY_CONNECTION_INFO structure.

        if (handleType != TypeHttpRequestHandle) {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        } else if (*lpdwBufferLength < (DWORD)sizeof(INTERNET_SECURITY_CONNECTION_INFO)) {
            requiredSize = sizeof(INTERNET_SECURITY_CONNECTION_INFO);
            *lpdwBufferLength = requiredSize;
            error = ERROR_INSUFFICIENT_BUFFER;
        } else {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;
            LPINTERNET_SECURITY_CONNECTION_INFO lpSecConnInfo;
            INTERNET_SECURITY_INFO ciInfo;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *)hInternet;
            lpSecConnInfo = (LPINTERNET_SECURITY_CONNECTION_INFO)lpBuffer;
            requiredSize = sizeof(INTERNET_SECURITY_CONNECTION_INFO);

            if ((error = lphHttpRqst->GetSecurityInfo(&ciInfo)) == ERROR_SUCCESS) {
                // Set up that data members in the structure passed in.
                lpSecConnInfo->fSecure = TRUE;

                lpSecConnInfo->dwProtocol = ciInfo.dwProtocol;
                lpSecConnInfo->aiCipher = ciInfo.aiCipher;
                lpSecConnInfo->dwCipherStrength = ciInfo.dwCipherStrength;
                lpSecConnInfo->aiHash = ciInfo.aiHash;
                lpSecConnInfo->dwHashStrength = ciInfo.dwHashStrength;
                lpSecConnInfo->aiExch = ciInfo.aiExch;
                lpSecConnInfo->dwExchStrength = ciInfo.dwExchStrength;

                if (ciInfo.pCertificate)
                {
                    WRAP_REVERT_USER_VOID(CertFreeCertificateContext, (ciInfo.pCertificate));
                }

            } else if (error == ERROR_WINHTTP_INTERNAL_ERROR)  {
                // This implies we are not secure.
                error = ERROR_SUCCESS;
                lpSecConnInfo->fSecure = FALSE;
            }

            lpSecConnInfo->dwSize = requiredSize;
            *lpdwBufferLength = requiredSize;
        }

        goto quit;


    case WINHTTP_OPTION_SECURITY_CERTIFICATE_STRUCT:

        //
        // Allocates memory that caller is expected to free.
        //

        if (handleType != TypeHttpRequestHandle) {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        } else {
            LPTSTR szResult = NULL;
            DWORD cchNeedLen = 0;
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;
            INTERNET_SECURITY_INFO cInfo;
            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;
            requiredSize = sizeof(INTERNET_CERTIFICATE_INFO);

            if (ERROR_SUCCESS == lphHttpRqst->GetSecurityInfo(&cInfo))
            {
                error = ConvertSecurityInfoIntoCertInfoStruct(&cInfo, (LPINTERNET_CERTIFICATE_INFO)lpBuffer, lpdwBufferLength);
                if(cInfo.pCertificate)
                {
                    WRAP_REVERT_USER_VOID(CertFreeCertificateContext, (cInfo.pCertificate));
                }
                goto quit;
            }
            else
            {
                error = ERROR_INVALID_OPERATION;
            }
        }
        break;

    case WINHTTP_OPTION_SERVER_CERT_CONTEXT:
        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;
            INTERNET_SECURITY_INFO cInfo;
            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;
            requiredSize = sizeof(PCERT_CONTEXT);

            if (lpBuffer)
            {
                if (ERROR_SUCCESS == lphHttpRqst->GetSecurityInfo(&cInfo))
                {
                    // GetSecurityInfo calls CertDuplicateCertificateContext, so
                    // the client app should call CertFreeCertificateContext when
                    // finished in order to maintain the proper ref count.
                    *((PCCERT_CONTEXT *) lpBuffer) = cInfo.pCertificate;  
                }
                else
                {
                    error = ERROR_INVALID_OPERATION;
                }
            }
        }
        
    case WINHTTP_OPTION_SECURITY_KEY_BITNESS:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;
            INTERNET_SECURITY_INFO secInfo;

            requiredSize = sizeof(dwValue);
            dwValue = 0;
            lpSource = (LPVOID)&dwValue;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;
            if (ERROR_SUCCESS != lphHttpRqst->GetSecurityInfo(&secInfo)) {
                error = ERROR_INVALID_OPERATION;
            } else {
                dwValue = secInfo.dwCipherStrength;
                WRAP_REVERT_USER_VOID(CertFreeCertificateContext,
                                      (secInfo.pCertificate));

                INET_ASSERT (error == ERROR_SUCCESS);

                DEBUG_PRINT(INET,
                            INFO,
                            ("SECURITY_KEY_BITNESS: %X\n",
                            dwValue
                            ));

            }
        }

        break;


    case WINHTTP_OPTION_PROXY:
        if (!ARGUMENT_PRESENT(hInternet)) {

            error = g_pGlobalProxyInfo->GetProxyStringInfo(lpBuffer, lpdwBufferLength);
            requiredSize = *lpdwBufferLength;
            goto quit;

        } else if ((handleType == TypeInternetHandle) || (handleType == TypeHttpRequestHandle)) {

            //
            // GetProxyInfo() will return the data, or calculate the buffer
            // length required
            //

            error = ((INTERNET_HANDLE_BASE *)hInternet)->GetProxyStringInfo(
                lpBuffer,
                lpdwBufferLength
                );
            requiredSize = *lpdwBufferLength;
            goto quit;
        } else {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_VERSION:
        requiredSize = sizeof(InternetVersionInfo);
        lpSource = (LPVOID)&InternetVersionInfo;
        break;

    case WINHTTP_OPTION_USER_AGENT:
        if (handleType == TypeInternetHandle) {
            lpSource = ((INTERNET_HANDLE_OBJECT *)hInternet)->GetUserAgent();
            isString = TRUE;
        } else {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_REQUEST_PRIORITY:
        if (handleType == TypeHttpRequestHandle) {
            requiredSize = sizeof(dwValue);
            dwValue = ((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->GetPriority();
            lpSource = (LPVOID)&dwValue;
        } else {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_HTTP_VERSION:
        requiredSize = sizeof(HttpVersionInfo);
        lpSource = (LPVOID)&HttpVersionInfo;
        break;

    case WINHTTP_OPTION_DIAGNOSTIC_SOCKET_INFO:

        //
        // internal option
        //

        if (pReq) {
            requiredSize = sizeof(socketInfo);
            lpSource = (LPVOID)&socketInfo;

            socketInfo.Socket = pReq->GetSocket();
            socketInfo.SourcePort = pReq->GetSourcePort();
            socketInfo.DestPort = pReq->GetDestPort();
            socketInfo.Flags = (pReq->FromKeepAlivePool()
                                    ? IDSI_FLAG_KEEP_ALIVE : 0)
                                | (pReq->IsSecure()
                                    ? IDSI_FLAG_SECURE : 0)
                                | (pReq->IsRequestUsingProxy()
                                    ? IDSI_FLAG_PROXY : 0)
                                | (pReq->IsTunnel()
                                    ? IDSI_FLAG_TUNNEL : 0);
        } else {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_MAX_CONNS_PER_SERVER:
    case WINHTTP_OPTION_MAX_CONNS_PER_1_0_SERVER:
        if (hInternet)
        {
            if (handleType == TypeInternetHandle)
            {
                requiredSize = sizeof(dwValue);
                dwValue = 0;
                lpSource = (LPVOID)&dwValue;
                dwValue = ((INTERNET_HANDLE_OBJECT *)hInternet)->GetMaxConnectionsPerServer(dwOption);
            }
            else
                error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else
            error = ERROR_INVALID_OPERATION;
        break;

    case WINHTTP_OPTION_PER_CONNECTION_OPTION:
        {
            if (handleType != TypeInternetHandle) {
                hInternet = NULL;
            }

            error = QueryPerConnOptions(hInternet,
                                        FALSE,
                                        (LPINTERNET_PER_CONN_OPTION_LIST)lpBuffer);

            requiredSize = *lpdwBufferLength;
            goto quit;
        }

    case WINHTTP_OPTION_WORKER_THREAD_COUNT:
        
        requiredSize = sizeof(DWORD);
        dwValue = g_cNumIOCPThreads;
        lpSource = (LPVOID)&dwValue;
        break;
        
#if INET_DEBUG

    case WINHTTP_OPTION_GET_DEBUG_INFO:
        error = InternetGetDebugInfo((LPINTERNET_DEBUG_INFO)lpBuffer,
                                     lpdwBufferLength
                                     );

        //
        // everything updated, so quit without going through common buffer
        // processing
        //

        goto quit;
        break;

    case WINHTTP_OPTION_GET_HANDLE_COUNT:
        requiredSize = sizeof(DWORD);
        dwValue = InternetHandleCount();
        lpSource = (LPVOID)&dwValue;
        break;

#endif // INET_DEBUG

    default:
        requiredSize = 0;
        error = ERROR_INVALID_PARAMETER;
        break;
    }

    //
    // if we have a buffer and enough space, then copy the data
    //

    if (error == ERROR_SUCCESS) {

        //
        // if we are returning a string, calculate the amount of space
        // required to hold it
        //

        if (isString) {
            if (lpSource != NULL) {
                requiredSize = lstrlen((LPCSTR)lpSource) + 1;
            } else {

                //
                // option string is NULL: return an empty string
                //

                lpSource = "";
                requiredSize = 1;
            }
        }

        INET_ASSERT(lpSource != NULL);

        if ((*lpdwBufferLength >= requiredSize)
        && ARGUMENT_PRESENT(lpBuffer)) {
            memcpy(lpBuffer, lpSource, requiredSize);
            if (isString) {

                //
                // string copied successfully. Returned length is string
                // length, not buffer length, i.e. drop 1 for '\0'
                //

                --requiredSize;
            }
        } else {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
    }

quit:

    //
    // return the amount the app needs to supply, or the amount of data in the
    // buffer, depending on success/failure status
    //

    *lpdwBufferLength = requiredSize;

    if (hObjectMapped != NULL) {
        DereferenceObject((LPVOID)hObjectMapped);
    }

done:

    if (error == ERROR_SUCCESS) {
        success = TRUE;

        IF_DEBUG(API) {

            if (isString) {

                DEBUG_PRINT_API(API,
                                INFO,
                                ("returning %q (%d chars)\n",
                                lpBuffer,
                                requiredSize
                                ));

            } else {

                DEBUG_DUMP_API(API,
                               "option data:\n",
                               lpBuffer,
                               requiredSize
                               );

            }
        }
    } else {

        DEBUG_ERROR(API, error);

        IF_DEBUG(API) {

            if (error == ERROR_INSUFFICIENT_BUFFER) {

                DEBUG_PRINT_API(API,
                                INFO,
                                ("*lpdwBufferLength (%#x)= %d\n",
                                lpdwBufferLength,
                                *lpdwBufferLength
                                ));

            }
        }

        SetLastError(error);
        success = FALSE;
    }

    DEBUG_LEAVE_API(success);

    return success;
}


INTERNETAPI
BOOL
WINAPI
WinHttpQueryOption(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hInternet           -

    dwOption            -

    lpBuffer            -

    lpdwBufferLength    -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpQueryOption",
                     "%#x, %s (%d), %#x, %#x [%d]",
                     hInternet,
                     InternetMapOption(dwOption),
                     dwOption,
                     lpBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength
                        ? (!IsBadReadPtr(lpdwBufferLength, sizeof(DWORD))
                            ? *lpdwBufferLength
                            : 0)
                        : 0
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpBuffer;

    if (!lpdwBufferLength
        || IsBadWritePtr(lpdwBufferLength, sizeof(*lpdwBufferLength))
        || (lpBuffer && *lpdwBufferLength && IsBadWritePtr(lpBuffer, *lpdwBufferLength)) )
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    switch (dwOption)
    {
    case WINHTTP_OPTION_USERNAME:
    case WINHTTP_OPTION_PASSWORD:
    case WINHTTP_OPTION_URL:
    case WINHTTP_OPTION_USER_AGENT:
    case WINHTTP_OPTION_PROXY_USERNAME:
    case WINHTTP_OPTION_PROXY_PASSWORD:
        if (lpBuffer)
        {
            mpBuffer.dwAlloc = mpBuffer.dwSize = *lpdwBufferLength;
            mpBuffer.psStr = (LPSTR)ALLOC_BYTES(mpBuffer.dwAlloc*sizeof(CHAR));
            if (!mpBuffer.psStr)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        }
        fResult = InternetQueryOptionA(hInternet,
                                  dwOption,
                                  (LPVOID)mpBuffer.psStr,
                                  &mpBuffer.dwSize
                                 );
        if (fResult)
        {
            *lpdwBufferLength = sizeof(WCHAR) *
                MultiByteToWideChar(CP_ACP, 0, mpBuffer.psStr, mpBuffer.dwSize + 1, NULL, 0);
                
            if (*lpdwBufferLength <= mpBuffer.dwAlloc && lpBuffer)
            {
                MultiByteToWideChar(CP_ACP, 0, mpBuffer.psStr, mpBuffer.dwSize+1,
                        (LPWSTR)lpBuffer, *lpdwBufferLength);
                (*lpdwBufferLength)-=sizeof(WCHAR);
            }
            else
            {
                fResult = FALSE;
                dwErr = ERROR_INSUFFICIENT_BUFFER;
            }
        }
        else
        {
            if (GetLastError()==ERROR_INSUFFICIENT_BUFFER)
            {
                *lpdwBufferLength = mpBuffer.dwSize*sizeof(WCHAR);
            }
        }
        break;

    case WINHTTP_OPTION_PER_CONNECTION_OPTION:
        {
            if (!lpBuffer)
            {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

            INTERNET_PER_CONN_OPTION_LISTA listA;
            LPINTERNET_PER_CONN_OPTION_LISTW plistW = (LPINTERNET_PER_CONN_OPTION_LISTW)lpBuffer;
            CHAR szEntryA[RAS_MaxEntryName + 1];
            listA.pszConnection = szEntryA;
            
            InitIPCOList(plistW, &listA);
            listA.pOptions = (LPINTERNET_PER_CONN_OPTIONA)_alloca(sizeof(INTERNET_PER_CONN_OPTIONA)*listA.dwOptionCount);

            for (DWORD i=0; i<listA.dwOptionCount; i++)
            {
                listA.pOptions[i].dwOption = plistW->pOptions[i].dwOption;
                listA.pOptions[i].Value.pszValue = NULL;
                plistW->pOptions[i].Value.pszValue = NULL;
            }

            fResult = InternetQueryOptionA(hInternet,
                                  dwOption,
                                  (PVOID)&listA,
                                  lpdwBufferLength);

            // Now, convert from ansi to unicode

            if (fResult)
            {
                for (DWORD i=0; i<listA.dwOptionCount; i++)
                {
                    switch (listA.pOptions[i].dwOption)
                    {
                    case INTERNET_PER_CONN_FLAGS:
                    case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
                    case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
                        plistW->pOptions[i].Value.dwValue = listA.pOptions[i].Value.dwValue;
                        break;

                    case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_TIME:
                        plistW->pOptions[i].Value.ftValue = listA.pOptions[i].Value.ftValue;
                        break;
                    
                    case INTERNET_PER_CONN_PROXY_SERVER:
                    case INTERNET_PER_CONN_PROXY_BYPASS:
                    case INTERNET_PER_CONN_AUTOCONFIG_URL:
                    case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
                    case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_URL:
                        if (listA.pOptions[i].Value.pszValue && *listA.pOptions[i].Value.pszValue)
                        {
                            DWORD cc = MultiByteToWideChar(CP_ACP, 
                                                           0, 
                                                           listA.pOptions[i].Value.pszValue, 
                                                           -1,
                                                           NULL,
                                                           0);
                            plistW->pOptions[i].Value.pszValue = (PWSTR)GlobalAlloc(GPTR, cc*sizeof(WCHAR));
                            if (!plistW->pOptions[i].Value.pszValue)
                            {
                                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                                goto iopco_cleanup;
                            }
                            MultiByteToWideChar(CP_ACP, 
                                                0, 
                                                listA.pOptions[i].Value.pszValue, 
                                                -1,
                                                plistW->pOptions[i].Value.pszValue,
                                                cc);
                        }
                        break;

                    default:
                        INET_ASSERT(FALSE);
                        dwErr = ERROR_INVALID_PARAMETER;
                        goto iopco_cleanup;
                        break;
                    }
                }
            }
            else
            {
                plistW->dwOptionError = listA.dwOptionError;
            }
            
        iopco_cleanup:
            // Free all the allocated buffers
            for (i=0; i<listA.dwOptionCount; i++)
            {
                switch (listA.pOptions[i].dwOption)
                {
                case INTERNET_PER_CONN_PROXY_SERVER:
                case INTERNET_PER_CONN_PROXY_BYPASS:
                case INTERNET_PER_CONN_AUTOCONFIG_URL:
                case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
                case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_URL:
                    // These should have been converted from ansi to unicode
                    // and can be freed now
                    if (listA.pOptions[i].Value.pszValue)
                    {
                        GlobalFree(listA.pOptions[i].Value.pszValue);
                    }
                    // No point in passing back buffers in the event of an error
                    // condition
                    if (dwErr && plistW->pOptions[i].Value.pszValue)
                    {
                        GlobalFree(plistW->pOptions[i].Value.pszValue);
                    }
                    break;

                default:
                    // No need to do anything
                    break;
                }
            }
        }
        break;

    case WINHTTP_OPTION_PROXY:
        {
            WINHTTP_PROXY_INFOW * pInfo = (WINHTTP_PROXY_INFOW *) lpBuffer;
            
            union
            {
                WINHTTP_PROXY_INFOA InfoA;
                char                Buffer[1024];
            };

            char *  pBuffer;
            DWORD   dwBufferLen = sizeof(Buffer);
            bool    fFreeBuffer = false;

            if (IsBadWritePtr(pInfo, sizeof(WINHTTP_PROXY_INFOW)) ||
                (*lpdwBufferLength < sizeof(WINHTTP_PROXY_INFOW)))
            {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

            fResult = InternetQueryOptionA(hInternet, WINHTTP_OPTION_PROXY,
                            (void *) &Buffer,
                            &dwBufferLen);
            
            if (!fResult && (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
            {
                pBuffer = New char[dwBufferLen];

                if (pBuffer)
                {
                    fFreeBuffer = true;

                    fResult = InternetQueryOptionA(hInternet, WINHTTP_OPTION_PROXY,
                                    (void *) pBuffer,
                                    &dwBufferLen);
                }
                else
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }

            if (fResult)
            {
                pInfo->dwAccessType = InfoA.dwAccessType;
            
                dwErr = AsciiToWideChar_UsingGlobalAlloc(InfoA.lpszProxy,
                                &(pInfo->lpszProxy));

                if (dwErr == ERROR_SUCCESS)
                {
                    dwErr = AsciiToWideChar_UsingGlobalAlloc(InfoA.lpszProxyBypass,
                                    &(pInfo->lpszProxyBypass));

                    if ((dwErr != ERROR_SUCCESS) && (pInfo->lpszProxy != NULL))
                    {
                        GlobalFree(pInfo->lpszProxy);
                        pInfo->lpszProxy = NULL;
                    }
                }

                fResult = (dwErr == ERROR_SUCCESS);
            }

            if (fFreeBuffer)
            {
                delete [] pBuffer;
            }
        }
        break;

    default:
        fResult = InternetQueryOptionA(hInternet,
                                  dwOption,
                                  lpBuffer,
                                  lpdwBufferLength
                                 );
    }

cleanup:
    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI
BOOL
WINAPI
InternetSetOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Sets a handle-specific variable, or a per-thread variable

Arguments:

    hInternet           - handle of object for which information will be set,
                          or NULL if the option defines a per-thread variable

    dwOption            - the handle-specific WINHTTP_OPTION to set

    lpBuffer            - pointer to a buffer containing value to set

    dwBufferLength      - size of lpBuffer

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info:
                    ERROR_INVALID_HANDLE
                        hInternet does not identify a valid Internet handle
                        object

                    ERROR_WINHTTP_INTERNAL_ERROR
                        Shouldn't see this?

                    ERROR_INVALID_PARAMETER
                        One of the parameters was bad

                    ERROR_WINHTTP_INVALID_OPTION
                        The requested option cannot be set

                    ERROR_WINHTTP_OPTION_NOT_SETTABLE
                        Can't set this option, only query it

                    ERROR_INSUFFICIENT_BUFFER
                        The dwBufferLength parameter is incorrect for the
                        expected type of the option

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetSetOptionA",
                     "%#x, %s (%d), %#x [%#x], %d",
                     hInternet,
                     InternetMapOption(dwOption),
                     dwOption,
                     lpBuffer,
                     lpBuffer
                        ? (!IsBadReadPtr(lpBuffer, sizeof(DWORD))
                            ? *(LPDWORD)lpBuffer
                            : 0)
                        : 0,
                     dwBufferLength
                     ));

    DWORD error;
    BOOL success = TRUE;
    HINTERNET_HANDLE_TYPE handleType;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD requiredSize;
    HINTERNET hObjectMapped = NULL;

    INET_ASSERT(dwBufferLength != 0);

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {
            goto done;
        }
    }

    //
    // validate the handle and get its type
    //

    if (ARGUMENT_PRESENT(hInternet)) {

        //
        // map the handle
        //

        error = MapHandleToAddress(hInternet, (LPVOID *)&hObjectMapped, FALSE);
        if (error == ERROR_SUCCESS) {
            hInternet = hObjectMapped;
            error = RGetHandleType(hInternet, &handleType);
        }
    } else if (IS_PER_THREAD_OPTION(dwOption)) {

        //
        // this option updates the per-thread information block, so this is a
        // good point at which to get it
        //

        lpThreadInfo = InternetGetThreadInfo();
        if (lpThreadInfo != NULL) {
            error = ERROR_SUCCESS;
        } else {

            DEBUG_PRINT(INET,
                        ERROR,
                        ("InternetGetThreadInfo() returns NULL\n"
                        ));

            //
            // we never expect this - ERROR_WINHTTP_SPANISH_INQUISITION
            //

            INET_ASSERT(FALSE);

            error = ERROR_WINHTTP_INTERNAL_ERROR;
        }
    } else if (IS_PER_PROCESS_OPTION(dwOption)) {
        error = ERROR_SUCCESS;
    } else {

        //
        // catch any invalid options for the NULL handle. If the option is valid
        // then it is incorrect for this handle type, otherwise its an invalid
        // option, period
        //

        error = IS_VALID_OPTION(dwOption)
                    ? ERROR_WINHTTP_INCORRECT_HANDLE_TYPE
                    : ERROR_WINHTTP_INVALID_OPTION
                    ;
    }

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    HTTP_REQUEST_HANDLE_OBJECT *pReq;

    switch (handleType)
    {
        case TypeHttpRequestHandle:
            pReq = (HTTP_REQUEST_HANDLE_OBJECT*) hInternet;
            break;

        case TypeInternetHandle:
            pReq = NULL;
            break;

        default:
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;           
            goto quit;
    } 
    
    // New fast path for request handle options.

    if (dwOption > WINHTTP_OPTION_MASK)
    {
        dwOption &= WINHTTP_OPTION_MASK;
        if (dwOption > MAX_INTERNET_STRING_OPTION)
            error = ERROR_INVALID_PARAMETER;
        else if (!pReq)
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        else if (pReq->SetProp (dwOption, (LPSTR) lpBuffer))
            error = ERROR_SUCCESS;
        else
            error = ERROR_WINHTTP_INTERNAL_ERROR;
                
        goto quit;
    }

    //
    // if the option and handle combination is valid then set the option value
    //

    switch (dwOption) {
    case WINHTTP_OPTION_CALLBACK:
    case WINHTTP_OPTION_HANDLE_TYPE:
    
        // these options cannot be set by this function
        error = ERROR_WINHTTP_OPTION_NOT_SETTABLE;
        break;
        
    case WINHTTP_OPTION_RESOLVE_TIMEOUT:
    case WINHTTP_OPTION_CONNECT_TIMEOUT:
    case WINHTTP_OPTION_CONNECT_RETRIES:
    case WINHTTP_OPTION_SEND_TIMEOUT:
    case WINHTTP_OPTION_RECEIVE_TIMEOUT:
        requiredSize = sizeof(DWORD);
        if (dwBufferLength != requiredSize) 
        {
            error = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        // For WinHttp, these options are per-handle, not per-process.
        if (hInternet == NULL) 
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
            break;
        }

        // we have a non-NULL context handle: the app wants to set specific
        // protocol timeouts
        switch (handleType) 
        {
        case TypeInternetHandle:

            //only error possible is in allocing memory for OPTIONAL_PARAMS struct
            if (! ((INTERNET_HANDLE_OBJECT*)hObjectMapped)->SetTimeout(dwOption, *(LPDWORD)lpBuffer) )
            {    
                error = ERROR_NOT_ENOUGH_MEMORY;
            }
            break;
            
        case TypeHttpRequestHandle:

            // no errors possible here
            ((HTTP_REQUEST_HANDLE_OBJECT*)hObjectMapped)->SetTimeout(dwOption, *(LPDWORD)lpBuffer);
            break;

        default:

            // any other handle type (?) cannot have timeouts set for it
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
            break;
        }
        break;

    case WINHTTP_OPTION_CONTEXT_VALUE:

        //
        // BUGBUG - can't change context if async operation is pending
        //

        if (dwBufferLength == sizeof(LPVOID)) {
            error = RSetContext(hInternet, *((DWORD_PTR *) lpBuffer));
        } else {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        break;

    case WINHTTP_OPTION_READ_BUFFER_SIZE:
    case WINHTTP_OPTION_WRITE_BUFFER_SIZE:
        if (pReq)
        {
            if (dwBufferLength == sizeof(DWORD))
            {
                DWORD bufferSize;

                bufferSize = *(LPDWORD)lpBuffer;
                if (bufferSize > 0)
                {
                    pReq->SetBufferSize(dwOption, bufferSize);
                    error = ERROR_SUCCESS;
                }
                else  // the read/write buffer size cannot be set to 0
                {
                    error = ERROR_INVALID_PARAMETER;
                }
            }
            else
            {
                error = ERROR_INSUFFICIENT_BUFFER;
            }
        }
        else
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_CLIENT_CERT_CONTEXT:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else if (dwBufferLength < sizeof(CERT_CONTEXT))
        {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *pRequest =
                (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;
            CERT_CONTEXT_ARRAY* pArray = pRequest->GetCertContextArray();
            if (!pArray)
                error = ERROR_WINHTTP_NOT_INITIALIZED;
            else
            {
                pArray->Reset();
                pArray->AddCertContext((PCCERT_CONTEXT) lpBuffer);
                pArray->SelectCertContext(0);
                error = ERROR_SUCCESS;
            }
        }
        break;

    case WINHTTP_OPTION_SECURITY_FLAGS:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else if (dwBufferLength < sizeof(DWORD))
        {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;

            lphHttpRqst->SetSecureFlags(*(LPDWORD)lpBuffer);

            error = ERROR_SUCCESS;
        }

        break;

    case WINHTTP_OPTION_PROXY:
        if ((handleType == TypeInternetHandle) || (handleType == TypeHttpRequestHandle))
        {
            WINHTTP_PROXY_INFOA * lpInfo = (WINHTTP_PROXY_INFOA *) lpBuffer;

            //
            // validate parameters
            //

            if (dwBufferLength != sizeof(*lpInfo))
            {
                error = ERROR_INSUFFICIENT_BUFFER;
            }
            else if (!((lpInfo->dwAccessType == WINHTTP_ACCESS_TYPE_NO_PROXY)
                    || (lpInfo->dwAccessType == WINHTTP_ACCESS_TYPE_NAMED_PROXY))
            || ((lpInfo->dwAccessType == WINHTTP_ACCESS_TYPE_NAMED_PROXY)
                && ((lpInfo->lpszProxy == NULL) || (*lpInfo->lpszProxy == '\0'))))
            {
                error = ERROR_INVALID_PARAMETER;
            }
            else
            {
                error = ((INTERNET_HANDLE_BASE *)hInternet)->SetProxyInfo(
                            lpInfo->dwAccessType,
                            lpInfo->lpszProxy,
                            lpInfo->lpszProxyBypass
                            );
            }
        }
        else
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_USER_AGENT:
        if (*(LPSTR)lpBuffer == '\0') {
            error = ERROR_INSUFFICIENT_BUFFER;
        } else {
            if ((handleType == TypeInternetHandle) || (handleType == TypeHttpRequestHandle))
            {
                ((INTERNET_HANDLE_BASE *)hInternet)->SetUserAgent((LPSTR)lpBuffer);
            } else {
                error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
            }
        }
        break;
        
    case WINHTTP_OPTION_DIGEST_AUTH_UNLOAD:
        if (DIGEST_CTX::g_pFuncTbl)
        {
            DIGEST_CTX::Logoff();
            DIGEST_CTX::g_pFuncTbl = NULL;
        }            
        break;

    case WINHTTP_OPTION_REQUEST_PRIORITY:
        if (handleType == TypeHttpRequestHandle) {
            if (dwBufferLength == sizeof(LONG)) {
                ((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->
                    SetPriority(*(LPLONG)lpBuffer);
            } else {
                error = ERROR_INSUFFICIENT_BUFFER;
            }
        } else {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_HTTP_VERSION:
        if (dwBufferLength == sizeof(HTTP_VERSION_INFO)) {
            HttpVersionInfo = *(LPHTTP_VERSION_INFO)lpBuffer;
        } else {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        break;

    case WINHTTP_OPTION_DISABLE_FEATURE:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else if (dwBufferLength < sizeof(DWORD))
        {
            error = ERROR_INVALID_PARAMETER;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *pRequest =
                (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;
            DWORD dwDisable = *((LPDWORD) lpBuffer);
            
            if (dwDisable & WINHTTP_DISABLE_KEEP_ALIVE)
            {
                DWORD dwFlags = pRequest->GetOpenFlags();
                dwFlags &= ~INTERNET_FLAG_KEEP_CONNECTION;
                pRequest->SetOpenFlags (dwFlags);                
            }
            if (dwDisable & WINHTTP_DISABLE_REDIRECTS)
            {
                DWORD dwFlags = pRequest->GetOpenFlags();
                dwFlags |= INTERNET_FLAG_NO_AUTO_REDIRECT;
                pRequest->SetOpenFlags (dwFlags);                
            }
            if (dwDisable & WINHTTP_DISABLE_COOKIES)
            {
                DWORD dwFlags = pRequest->GetOpenFlags();
                dwFlags |= INTERNET_FLAG_NO_COOKIES;
                pRequest->SetOpenFlags (dwFlags);                
            }
            if (dwDisable & WINHTTP_DISABLE_AUTHENTICATION)
            {
                DWORD dwFlags = pRequest->GetOpenFlags();
                dwFlags |= INTERNET_FLAG_NO_AUTH;
                pRequest->SetOpenFlags (dwFlags);                
            }
            error = ERROR_SUCCESS;
        }
        break;
            
  
    case WINHTTP_OPTION_ENABLE_FEATURE:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else if (dwBufferLength < sizeof(DWORD))
        {
            error = ERROR_INVALID_PARAMETER;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *pRequest =
                (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;
            DWORD dwDisable = *((LPDWORD) lpBuffer);

            pRequest->SetEnableFlags(*((LPDWORD) lpBuffer));
            error = ERROR_SUCCESS;
        }
        break;
            
  
    case WINHTTP_OPTION_CODEPAGE:
        if ((hInternet == NULL) || (handleType == TypeHttpRequestHandle))
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else
        {
            if (dwBufferLength == sizeof(DWORD)) 
            {
                ((INTERNET_HANDLE_BASE *)hInternet)->SetCodePage(*(LPDWORD)lpBuffer);
            } 
            else 
            {
                error = ERROR_INSUFFICIENT_BUFFER;
            }
        } 
        break;

    case WINHTTP_OPTION_MAX_CONNS_PER_SERVER:
    case WINHTTP_OPTION_MAX_CONNS_PER_1_0_SERVER:
        if (handleType == TypeInternetHandle)
        {
            if (dwBufferLength == sizeof(DWORD))
            {
                ((INTERNET_HANDLE_OBJECT *)hInternet)->SetMaxConnectionsPerServer(dwOption, *(DWORD *)lpBuffer);
            }
            else
                error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        break;

    case WINHTTP_OPTION_PER_CONNECTION_OPTION:
        {
            if (handleType != TypeInternetHandle) {
                hInternet = NULL;
            }

            error = SetPerConnOptions(hInternet, 
                                      FALSE,
                                      (LPINTERNET_PER_CONN_OPTION_LIST)lpBuffer);
            break;
        }

    case WINHTTP_OPTION_AUTOLOGON_POLICY:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else if (dwBufferLength < sizeof(DWORD))
        {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;

            lphHttpRqst->SetSecurityLevel(*(LPDWORD)lpBuffer);

            error = ERROR_SUCCESS;
        }

        break;

    case WINHTTP_OPTION_WORKER_THREAD_COUNT:
        
        if (dwBufferLength < sizeof(DWORD))
        {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            if (!g_cNumIOCPThreads)
            {
                g_cNumIOCPThreads = *(LPDWORD)lpBuffer;
                error = ERROR_SUCCESS;
            }
            else
            {
                error = ERROR_WINHTTP_OPTION_NOT_SETTABLE;
            }
        }
        break;
        
#if INET_DEBUG
    case WINHTTP_OPTION_SET_DEBUG_INFO:
        error = InternetSetDebugInfo((LPINTERNET_DEBUG_INFO)lpBuffer,
                                     dwBufferLength
                                     );
        break;

#endif // INET_DEBUG

    default:

        //
        // this option is not recognized
        //

        error = ERROR_WINHTTP_INVALID_OPTION;
    }

quit:

    if (hObjectMapped != NULL) {
        DereferenceObject((LPVOID)hObjectMapped);
    }

done:

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(API, error);

        SetLastError(error);
        success = FALSE;
    }

    DEBUG_LEAVE_API(success);

    return success;
}

#define CHECK_MODIFY_TIMEOUT(nTimeout) \
{ \
    if (nTimeout <= 0) \
    { \
        if (nTimeout == 0) \
        { \
            nTimeout = (int)INFINITE; \
        } \
        else if (nTimeout < -1) \
        { \
            dwError = ERROR_INVALID_PARAMETER; \
            goto quit; \
        } \
    } \
}

INTERNETAPI
BOOL
WINAPI 
WinHttpSetTimeouts(    
    IN HINTERNET    hInternet,           // Session/Request handle.
    IN int        nResolveTimeout,
    IN int        nConnectTimeout,
    IN int        nSendTimeout,
    IN int        nReceiveTimeout
    )
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpSetTimeouts",
                     "%#x, %d, %d, %d, %d",
                     hInternet,
                     nResolveTimeout,
                     nConnectTimeout,
                     nSendTimeout,
                     nReceiveTimeout
                     ));

    DWORD dwError = ERROR_SUCCESS;
    BOOL bRetval = FALSE;
    HINTERNET_HANDLE_TYPE handleType;
    HINTERNET hObjectMapped = NULL;

    if (!hInternet)
    {
        dwError = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        goto quit;
    }

    CHECK_MODIFY_TIMEOUT(nResolveTimeout);
    CHECK_MODIFY_TIMEOUT(nConnectTimeout);
    CHECK_MODIFY_TIMEOUT(nSendTimeout);
    CHECK_MODIFY_TIMEOUT(nReceiveTimeout);
    
    dwError = MapHandleToAddress(hInternet, (LPVOID *)&hObjectMapped, FALSE);

    if (dwError != ERROR_SUCCESS)
    {
        goto quit;
    }
    
    dwError = RGetHandleType(hObjectMapped, &handleType);

    if (dwError != ERROR_SUCCESS)
    {
        goto quit;
    }

    switch(handleType)
    {
        case TypeInternetHandle:

            //only error possible is in allocing memory for OPTIONAL_PARAMS struct
            bRetval = ((INTERNET_HANDLE_OBJECT*)hObjectMapped)->SetTimeouts(
                nResolveTimeout, nConnectTimeout, nSendTimeout, nReceiveTimeout);
            if (!bRetval)
            {    
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }
            break;
            
        case TypeHttpRequestHandle:

            // no errors possible here
            bRetval = ((HTTP_REQUEST_HANDLE_OBJECT*)hObjectMapped)->SetTimeouts( 
                nResolveTimeout, nConnectTimeout, nSendTimeout, nReceiveTimeout);
            INET_ASSERT(bRetval);
            break;

        default:

            // any other handle type cannot have timeouts set for it
            dwError = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
            break;
    }
    
quit:

    if (hObjectMapped) 
    {
        DereferenceObject((LPVOID)hObjectMapped);
    }

    if (dwError != ERROR_SUCCESS) 
    { 
        ::SetLastError(dwError); 
        INET_ASSERT(!bRetval);
    }
    
    DEBUG_LEAVE_API(bRetval);
    return bRetval;
}


INTERNETAPI
BOOL
WINAPI
WinHttpSetOption(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hInternet       -

    dwOption        -

    lpBuffer        -

    dwBufferLength  -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpSetOption",
                     "%#x, %s (%d), %#x [%#x], %d",
                     hInternet,
                     InternetMapOption(dwOption),
                     dwOption,
                     lpBuffer,
                     lpBuffer
                        ? (!IsBadReadPtr(lpBuffer, sizeof(DWORD))
                            ? *(LPDWORD)lpBuffer
                            : 0)
                        : 0,
                     dwBufferLength
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpBuffer;
    BOOL fResult = FALSE;

    //
    // validate parameters
    //

    if ((dwBufferLength == 0) || IsBadReadPtr(lpBuffer, dwBufferLength)) 
    {
        switch (dwOption) 
        {
            //
            // these options don't require a buffer - don't fail request because
            // no buffer supplied
            //

            case WINHTTP_OPTION_DIGEST_AUTH_UNLOAD:
                if (dwBufferLength == 0)
                    break;
                break;

            default:
                dwErr = ERROR_INVALID_PARAMETER;
                goto cleanup;
        }
    }
    
    switch (dwOption)
    {
    case WINHTTP_OPTION_USERNAME:
    case WINHTTP_OPTION_PASSWORD:
    case WINHTTP_OPTION_URL:
    case WINHTTP_OPTION_USER_AGENT:
    case WINHTTP_OPTION_PROXY_USERNAME:
    case WINHTTP_OPTION_PROXY_PASSWORD:
        ALLOC_MB((LPWSTR)lpBuffer, dwBufferLength, mpBuffer);
        if (!mpBuffer.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI((LPWSTR)lpBuffer, mpBuffer);
        fResult = InternetSetOptionA(hInternet,
                                  dwOption,
                                  mpBuffer.psStr,
                                  mpBuffer.dwSize
                                 );
        break;

    case WINHTTP_OPTION_PER_CONNECTION_OPTION:
        {
            if (!lpBuffer)
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }

            INTERNET_PER_CONN_OPTION_LISTA listA;
            LPINTERNET_PER_CONN_OPTION_LISTW plistW = (LPINTERNET_PER_CONN_OPTION_LISTW)lpBuffer;
            CHAR szEntryA[RAS_MaxEntryName + 1];
            listA.pszConnection = szEntryA;
            
            InitIPCOList(plistW, &listA);
            listA.pOptions = (LPINTERNET_PER_CONN_OPTIONA)_alloca(sizeof(INTERNET_PER_CONN_OPTIONA)*listA.dwOptionCount);
            
            for (DWORD i=0; i<listA.dwOptionCount; i++)
            {
                listA.pOptions[i].dwOption = plistW->pOptions[i].dwOption;

                switch (listA.pOptions[i].dwOption)
                {
                case INTERNET_PER_CONN_FLAGS:
                case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
                case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
                    listA.pOptions[i].Value.dwValue = plistW->pOptions[i].Value.dwValue;
                    break;

                case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_TIME:
                    listA.pOptions[i].Value.ftValue = plistW->pOptions[i].Value.ftValue;
                    break;
                    
                case INTERNET_PER_CONN_PROXY_SERVER:
                case INTERNET_PER_CONN_PROXY_BYPASS:
                case INTERNET_PER_CONN_AUTOCONFIG_URL:
                case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
                case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_URL:
                    if (plistW->pOptions[i].Value.pszValue && *plistW->pOptions[i].Value.pszValue)
                    {
                        // ** WARNING ** NO UTF8 ENCODING HERE
                        DWORD cb = WideCharToMultiByte(CP_ACP, 
                                        0, 
                                        plistW->pOptions[i].Value.pszValue,
                                        -1,
                                        0, 
                                        0,
                                        NULL,
                                        NULL);
                        listA.pOptions[i].Value.pszValue = (PSTR)_alloca(cb);
                        WideCharToMultiByte(CP_ACP, 
                                        0, 
                                        plistW->pOptions[i].Value.pszValue,
                                        -1,
                                        listA.pOptions[i].Value.pszValue, 
                                        cb,
                                        NULL,
                                        NULL);
                    }
                    else
                    {
                        listA.pOptions[i].Value.pszValue = NULL; 
                    }
                    break;
                    
                default:
                    dwErr = ERROR_INVALID_PARAMETER;
                    goto cleanup;
                    break;
                }
            }
            fResult = InternetSetOptionA(hInternet,
                              dwOption,
                              (PVOID)&listA,
                              dwBufferLength);
            plistW->dwOptionError = listA.dwOptionError;
        }
        break;

    case WINHTTP_OPTION_PROXY:
        {
            WINHTTP_PROXY_INFOW * pInfo = (WINHTTP_PROXY_INFOW *) lpBuffer;
            WINHTTP_PROXY_INFOA   InfoA;

            if (IsBadReadPtr(pInfo, sizeof(WINHTTP_PROXY_INFOW)) || (dwBufferLength < sizeof(WINHTTP_PROXY_INFOW)))
            {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

            InfoA.dwAccessType = pInfo->dwAccessType;

            dwErr = WideCharToAscii(pInfo->lpszProxy, &InfoA.lpszProxy);

            if (dwErr == ERROR_SUCCESS)
            {
                dwErr = WideCharToAscii(pInfo->lpszProxyBypass, &InfoA.lpszProxyBypass);

                if (dwErr == ERROR_SUCCESS)
                {
                    fResult = InternetSetOptionA(hInternet, WINHTTP_OPTION_PROXY, &InfoA, sizeof(InfoA));

                    if (InfoA.lpszProxyBypass)
                    {
                        delete [] InfoA.lpszProxyBypass;
                    }
                }

                if (InfoA.lpszProxy)
                {
                    delete [] InfoA.lpszProxy;
                }
            }
        }
        break;

    default:
        fResult = InternetSetOptionA(hInternet,
                                  dwOption,
                                  lpBuffer,
                                  dwBufferLength
                                 );
    }

cleanup:
    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}



PRIVATE
BOOL
FValidCacheHandleType(
    HINTERNET_HANDLE_TYPE   hType
    )
{
    return ((hType != TypeInternetHandle)   &&
            (hType != TypeHttpConnectHandle));
}

#ifdef ENABLE_DEBUG

#define CASE_OF(constant)   case constant: return # constant

LPSTR
InternetMapOption(
    IN DWORD Option
    )

/*++

Routine Description:

    Convert WINHTTP_OPTION_ value to symbolic name

Arguments:

    Option  - to map

Return Value:

    LPSTR - pointer to symbolic name, or "?" if unknown

--*/

{
    switch (Option) {
    CASE_OF(WINHTTP_OPTION_CALLBACK);
    CASE_OF(WINHTTP_OPTION_RESOLVE_TIMEOUT);
    CASE_OF(WINHTTP_OPTION_CONNECT_TIMEOUT);
    CASE_OF(WINHTTP_OPTION_CONNECT_RETRIES);
    CASE_OF(WINHTTP_OPTION_SEND_TIMEOUT);
    CASE_OF(WINHTTP_OPTION_RECEIVE_TIMEOUT);
    CASE_OF(WINHTTP_OPTION_HANDLE_TYPE);
    CASE_OF(WINHTTP_OPTION_READ_BUFFER_SIZE);
    CASE_OF(WINHTTP_OPTION_WRITE_BUFFER_SIZE);
    CASE_OF(WINHTTP_OPTION_PARENT_HANDLE);
    CASE_OF(WINHTTP_OPTION_EXTENDED_ERROR);
    CASE_OF(WINHTTP_OPTION_USERNAME);
    CASE_OF(WINHTTP_OPTION_PASSWORD);
    CASE_OF(WINHTTP_OPTION_SECURITY_FLAGS);
    CASE_OF(WINHTTP_OPTION_SECURITY_CERTIFICATE_STRUCT);
    CASE_OF(WINHTTP_OPTION_URL);
    CASE_OF(WINHTTP_OPTION_SECURITY_KEY_BITNESS);
    CASE_OF(WINHTTP_OPTION_PROXY);
    CASE_OF(WINHTTP_OPTION_VERSION);
    CASE_OF(WINHTTP_OPTION_USER_AGENT);
    CASE_OF(WINHTTP_OPTION_PROXY_USERNAME);
    CASE_OF(WINHTTP_OPTION_PROXY_PASSWORD);
    CASE_OF(WINHTTP_OPTION_CONTEXT_VALUE);
    CASE_OF(WINHTTP_OPTION_CLIENT_CERT_CONTEXT);
    CASE_OF(WINHTTP_OPTION_REQUEST_PRIORITY);
    CASE_OF(WINHTTP_OPTION_HTTP_VERSION);
    CASE_OF(WINHTTP_OPTION_SECURITY_CONNECTION_INFO);
    CASE_OF(WINHTTP_OPTION_DIAGNOSTIC_SOCKET_INFO);
    CASE_OF(WINHTTP_OPTION_SERVER_CERT_CONTEXT);
    }
    return "?";
}

#endif // ENABLE_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\api\globals.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    globals.cxx

Abstract:

    Contains global data items for WININET.DLL and initialization function

    Contents:
        GlobalDllInitialize
        GlobalDllTerminate
        GlobalDataInitialize
        GlobalDataTerminate
        IsHttp1_1
        SetOfflineUserState
        GetWininetUserName
        ChangeGlobalSettings

Author:

    Richard L Firth (rfirth) 15-Jul-1995

Revision History:

    15-Jul-1995 rfirth
        Created

    07-Oct-1998 joshco
        updated minor version number 1->2

--*/

#include <wininetp.h>
#include <ntverp.h>
#include <schnlsp.h>
#include <persist.h>

//
// WinHttpX major & minor versions - allow to be defined externally
//

#if !defined(WINHTTPX_MAJOR_VERSION)
#define WINHTTPX_MAJOR_VERSION   5
#endif
#if !defined(WINHTTPX_MINOR_VERSION)
#define WINHTTPX_MINOR_VERSION   1
#endif

//
// external functions
//

#if INET_DEBUG

VOID
InitDebugSock(
    VOID
    );

#endif


//
// global DLL state data
//

GLOBAL HINSTANCE GlobalDllHandle = NULL;
GLOBAL DWORD GlobalPlatformType;
GLOBAL DWORD GlobalPlatformVersion5;
GLOBAL DWORD GlobalPlatformMillennium = FALSE;
GLOBAL BOOL GlobalDataInitialized = FALSE;

GLOBAL HANDLE g_hCompletionPort = NULL;
GLOBAL LPOVERLAPPED g_lpCustomOverlapped = NULL;
GLOBAL DWORD g_cNumIOCPThreads = 0;

#if INET_DEBUG
LONG g_cWSACompletions = 0;
LONG g_cCustomCompletions = 0;
#endif

//
// WinInet DLL version information (mainly for diagnostics)
//

#if !defined(VER_PRODUCTBUILD)
#define VER_PRODUCTBUILD    0
#endif

GLOBAL DWORD InternetBuildNumber = VER_PRODUCTBUILD;

//
// transport-based time-outs, etc.
//

#ifndef unix
GLOBAL const DWORD GlobalConnectTimeout = DEFAULT_CONNECT_TIMEOUT;
#else
GLOBAL const DWORD GlobalConnectTimeout = 1 * 60 * 1000;
#endif /* unix */
GLOBAL const DWORD GlobalResolveTimeout = DEFAULT_RESOLVE_TIMEOUT;
GLOBAL const DWORD GlobalConnectRetries = DEFAULT_CONNECT_RETRIES;
GLOBAL const DWORD GlobalSendTimeout = DEFAULT_SEND_TIMEOUT;
GLOBAL const DWORD GlobalReceiveTimeout = DEFAULT_RECEIVE_TIMEOUT;
GLOBAL const DWORD GlobalTransportPacketLength = DEFAULT_TRANSPORT_PACKET_LENGTH;
GLOBAL const DWORD GlobalKeepAliveSocketTimeout = DEFAULT_KEEP_ALIVE_TIMEOUT;
GLOBAL const DWORD GlobalSocketSendBufferLength = DEFAULT_SOCKET_SEND_BUFFER_LENGTH;
GLOBAL const DWORD GlobalSocketReceiveBufferLength = DEFAULT_SOCKET_RECEIVE_BUFFER_LENGTH;
GLOBAL const DWORD GlobalMaxHttpRedirects = DEFAULT_MAX_HTTP_REDIRECTS;
GLOBAL const DWORD GlobalConnectionInactiveTimeout = DEFAULT_CONNECTION_INACTIVE_TIMEOUT;
GLOBAL const DWORD GlobalServerInfoTimeout = DEFAULT_SERVER_INFO_TIMEOUT;

//
// switches
//

GLOBAL BOOL InDllCleanup = FALSE;
GLOBAL BOOL GlobalDynaUnload = FALSE;
GLOBAL BOOL GlobalDisableKeepAlive = FALSE;
GLOBAL BOOL GlobalEnableHttp1_1 = FALSE;
GLOBAL BOOL GlobalEnableProxyHttp1_1 = FALSE;

GLOBAL BOOL GlobalIsProcessExplorer = FALSE;
#ifndef UNIX
GLOBAL const BOOL GlobalEnableFortezza = TRUE;
#else /* for UNIX */
GLOBAL const BOOL GlobalEnableFortezza = FALSE;
#endif /* UNIX */

// SSL Switches  (petesk 7/24/97)
GLOBAL const DWORD GlobalSecureProtocols  = DEFAULT_SECURE_PROTOCOLS;

//
// AutoDetect Proxy Globals
//

GLOBAL LONG GlobalInternetOpenHandleCount = -1;
GLOBAL DWORD GlobalProxyVersionCount = 0;
GLOBAL BOOL GlobalAutoProxyInInit = FALSE;
GLOBAL BOOL GlobalAutoProxyCacheEnable = TRUE;
GLOBAL BOOL GlobalDisplayScriptDownloadFailureUI = FALSE;

//
//  Workaround for Novell's Client32
//

GLOBAL const BOOL fDontUseDNSLoadBalancing = FALSE;

//
// lists
//

GLOBAL SERIALIZED_LIST GlobalObjectList;

//
// SSL globals, for UI.  We need to know
//  whether its ok for us to pop up UI.
//
//

GLOBAL SECURITY_CACHE_LIST GlobalCertCache;

GLOBAL BOOL GlobalDisableNTLMPreAuth = FALSE;

//
// critical sections
//

GLOBAL CCritSec MlangCritSec;


// Mlang related data and functions.
PRIVATE HINSTANCE hInstMlang;
PRIVATE PFNINETMULTIBYTETOUNICODE pfnInetMultiByteToUnicode;
PRIVATE BOOL bFailedMlangLoad;  // So we don't try repeatedly if we fail once.
BOOL LoadMlang( );
BOOL UnloadMlang( );
#define MLANGDLLNAME    "mlang.dll"


//
// novell client32 (hack) "support"
//

GLOBAL BOOL GlobalRunningNovellClient32 = FALSE;
GLOBAL const BOOL GlobalNonBlockingClient32 = FALSE;

//
// proxy info
//

GLOBAL PROXY_INFO_GLOBAL * g_pGlobalProxyInfo;

//
// DLL version info
//

GLOBAL INTERNET_VERSION_INFO InternetVersionInfo = {
    WINHTTPX_MAJOR_VERSION,
    WINHTTPX_MINOR_VERSION
};

//
// HTTP version info - default 1.0
//

GLOBAL HTTP_VERSION_INFO HttpVersionInfo = {1, 0};


GLOBAL BOOL fCdromDialogActive = FALSE; // this needs to go

//
// The following globals are literal strings passed to winsock.
// Do NOT make them const, otherwise they end up in .text section,
// and web release of winsock2 has a bug where it locks and dirties
// send buffers, confusing the win95 vmm and resulting in code
// getting corrupted when it is paged back in.  -RajeevD
//

GLOBAL char gszAt[]   = "@";
GLOBAL char gszBang[] = "!";
GLOBAL char gszCRLF[] = "\r\n";


// cookie special casing
GLOBAL PTSTR GlobalSpecialDomains = NULL;
GLOBAL PTSTR *GlobalSDOffsets = NULL;

GLOBAL LONG g_cSessionCount=0;
GLOBAL CAsyncCount* g_pAsyncCount = NULL;

// implemented in ihttprequest\httprequest.cxx:
extern void CleanupWinHttpRequestGlobals();


//
// functions
//

BOOL AddEventSource(void)
{
    HKEY hKey; 
    DWORD dwData; 
    CHAR szBuf[80];
    DWORD dwDispo;
    // Add your source name as a subkey under the Application 
    // key in the EventLog registry key. 
 
    if (RegCreateKeyExA(HKEY_LOCAL_MACHINE, 
                        "SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\WinHttp5",
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE,
                        NULL,
                        &hKey,
                        &dwDispo) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    if (dwDispo == REG_OPENED_EXISTING_KEY)
    {
        RegCloseKey(hKey); 
        return TRUE;
    }
 
    // Set the name of the message file. 
 
    strcpy(szBuf, "%SystemRoot%\\System32\\WinHttp5.dll"); 
 
    // Add the name to the EventMessageFile subkey. 
 
    if (RegSetValueEx(hKey,             // subkey handle 
            "EventMessageFile",       // value name 
            0,                        // must be zero 
            REG_EXPAND_SZ,            // value type 
            (LPBYTE) szBuf,           // pointer to value data 
            strlen(szBuf) + 1) != ERROR_SUCCESS)       // length of value data
    {
        RegCloseKey(hKey); 
        return FALSE;
    }
 
    // Set the supported event types in the TypesSupported subkey. 
 
    dwData = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | 
        EVENTLOG_INFORMATION_TYPE; 
 
    if (RegSetValueEx(hKey,      // subkey handle 
            "TypesSupported",  // value name 
            0,                 // must be zero 
            REG_DWORD,         // value type 
            (LPBYTE) &dwData,  // pointer to value data 
            sizeof(DWORD)) != ERROR_SUCCESS)    // length of value data 
    {
        RegCloseKey(hKey); 
        return FALSE;
    }

    RegCloseKey(hKey);
    return TRUE;
} 

HANDLE g_hEventLog = 0;

BOOL InitializeEventLog(void)
{
    if (AddEventSource() == FALSE)
    {
        return FALSE;
    }

    g_hEventLog = ::RegisterEventSourceA(NULL, "WinHttp5");

    return g_hEventLog != NULL;
}

void TerminateEventLog(void)
{
    if (g_hEventLog)
    {
        ::DeregisterEventSource(g_hEventLog);
        g_hEventLog = NULL;
    }
}


#ifdef UNIX
extern "C"
#endif /* UNIX */
BOOL
GlobalDllInitialize(
    VOID
    )

/*++

Routine Description:

    The set of initializations - critical sections, etc. - that must be done at
    DLL_PROCESS_ATTACH

Arguments:

    None.

Return Value:

    TRUE, only FALSE when not enough memory to initialize globals

--*/

{
    BOOL fResult = FALSE;
    
    DEBUG_ENTER((DBG_GLOBAL,
                 None,
                 "GlobalDllInitialize",
                 NULL
                 ));

    InitializeEventLog();

    CLEAR_DEBUG_CRIT(szDebugBlankBuffer);

    if (MlangCritSec.Init() &&
        InitializeSerializedList(&GlobalObjectList) &&
        AuthOpen() &&
        IwinsockInitialize() &&
        SecurityInitialize()
        )
    {
        fResult = TRUE;
    }

    DEBUG_LEAVE(fResult);
    return fResult;
}


#ifdef UNIX
extern "C"
#endif /* UNIX */
VOID
GlobalDllTerminate(
    VOID
    )

/*++

Routine Description:

    Undoes the initializations of GlobalDllInitialize

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 None,
                 "GlobalDllTerminate",
                 NULL
                 ));

    //
    // only perform resource clean-up if this DLL is being unloaded due to a
    // FreeLibrary() call. Otherwise, we take the lazy way out and let the
    // system clean up after us
    //

    if (GlobalDynaUnload) {
        TerminateAsyncSupport(TRUE);
        IwinsockTerminate();
        HandleTerminate();
    }

    CHECK_SOCKETS();

    AuthClose();

    //
    //BUGBUG: we can't Terminate the list here because
    //        of a race condition from IE3
    //        (someone still holds the handle)
    //        but we don't want to leak the CritSec
    //        TerminateSerlizedList == DeleteCritSec + some Asserts
    //
    //TerminateSerializedList(&GlobalObjectList);
    GlobalObjectList.Lock.FreeLock();


    MlangCritSec.FreeLock();

    SecurityTerminate();

    TerminateEventLog();
    
    DEBUG_LEAVE(0);
}


DWORD
GlobalDataInitialize(
    VOID
    )

/*++

Routine Description:

    Loads any global data items from the registry

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 Dword,
                 "GlobalDataInitialize",
                 NULL
                 ));

    static BOOL Initializing = FALSE;
    static BOOL Initialized = FALSE;
    static DWORD error = ERROR_SUCCESS;
    
    //
    // only one thread initializes
    //

    if (InterlockedExchange((LPLONG)&Initializing, TRUE)) {
        while (!Initialized) {
            SleepEx(0, TRUE);
        }
        goto done;
    }
    
    //
    // create the global cert-cache and proxy lists
    //

    GlobalCertCache.Initialize();

    INET_ASSERT(g_pGlobalProxyInfo==NULL);
    g_pGlobalProxyInfo = New PROXY_INFO_GLOBAL();

    if (!g_pGlobalProxyInfo)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    g_pGlobalProxyInfo->InitializeProxySettings();

    //
    // Load proxy config settings from registry...
    //
    error = LoadProxySettings();

    if (error != ERROR_SUCCESS)
        goto quit;



    char buf[MAX_PATH + 1];

    if (GetModuleFileName(NULL, buf, sizeof(buf))) {
        LPSTR p = strrchr(buf, DIR_SEPARATOR_CHAR);
        p = p ? ++p : buf;

        DEBUG_PRINT(INET, INFO, ("process is %q\n", p));

        if (lstrcmpi(p, "EXPLORER.EXE") && lstrcmpi(p, "IEXPLORE.EXE")) {

            //
            // yet another app-hack: AOL's current browser can't understand
            // HTTP 1.1. When they do, they have to call InternetSetOption()
            // with WINHTTP_OPTION_HTTP_VERSION
            //

            if (!lstrcmpi(p, "WAOL.EXE")) {
                GlobalEnableHttp1_1 = FALSE;
            }
        } else {
            GlobalIsProcessExplorer = TRUE;
        }
    } else {

        DEBUG_PRINT(INET,
                    INFO,
                    ("GetModuleFileName() returns %d\n",
                    GetLastError()
                    ));

    }

    //
    // perform module/package-specific initialization
    //

    error = HandleInitialize();
    if (error != ERROR_SUCCESS) {
        goto quit;
    }
    
quit:

    //
    // finally, if EnableHttp1_1 was set to non-zero in the registry, enable
    // HTTP 1.1
    //

    if (GlobalEnableHttp1_1) {
        HttpVersionInfo.dwMajorVersion = 1;
        HttpVersionInfo.dwMinorVersion = 1;
    }

    if (error == ERROR_SUCCESS) {
        GlobalDataInitialized = TRUE;
    }

    //
    // irrespective of success or failure, we have attempted global data
    // initialization. If we failed then we assume its something fundamental
    // and fatal: we don't try again
    //

    Initialized = TRUE;

done:

    DEBUG_LEAVE(error);

    return error;
}



VOID
GlobalDataTerminate(
    VOID
    )

/*++

Routine Description:

    Undoes work of GlobalDataInitialize()

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 None,
                 "GlobalDataTerminate",
                 NULL
                 ));

    RIP(g_cSessionCount == 0);
#ifndef WININET_SERVER_CORE
    //
    // Release background task manager
    //
    UnloadBackgroundTaskMgr();
#endif

    AuthUnload();

    if (GlobalSpecialDomains)
    {
        delete [] GlobalSpecialDomains;
        delete [] GlobalSDOffsets;
    }
    
    //
    // terminate the global cert-cache and proxy lists
    //

    GlobalCertCache.Terminate();

    if (g_pGlobalProxyInfo)
    {
        g_pGlobalProxyInfo->TerminateProxySettings();
        delete g_pGlobalProxyInfo;
        g_pGlobalProxyInfo = NULL;
    }

    //
    // ServerInfo's in WinHttpX are per-session instead of global.
    // InternetCloseHandle on a session handles purging the server
    // info list.
    //
#ifndef WININET_SERVER_CORE
    PurgeServerInfoList(TRUE);
#endif

    UnloadMlang();
    UnloadSecurity();


    CleanupWinHttpRequestGlobals();

    GlobalDataInitialized = FALSE;

    DEBUG_LEAVE(0);
}


BOOL
IsHttp1_1(
    VOID
    )

/*++

Routine Description:

    Determine if we are using HTTP 1.1 or greater

Arguments:

    None.

Return Value:

    BOOL

--*/

{
    return (HttpVersionInfo.dwMajorVersion > 1)
            ? TRUE
            : (((HttpVersionInfo.dwMajorVersion == 1)
                && (HttpVersionInfo.dwMajorVersion >= 1))
                ? TRUE
                : FALSE);
}



VOID
ChangeGlobalSettings(
    VOID
    )

/*++

Routine Description:

    Changes global settings

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 None,
                 "ChangeGlobalSettings",
                 NULL
                 ));

#ifndef WININET_SERVER_CORE
    InternetReadRegistryDword("EnableHttp1_1",
                              (LPDWORD)&GlobalEnableHttp1_1
                              );

    InternetReadRegistryDword("ProxyHttp1.1",
                              (LPDWORD)&GlobalEnableProxyHttp1_1
                              );

    if (!g_pGlobalProxyInfo->IsModifiedInProcess())
    {
        FixProxySettingsForCurrentConnection(
            FALSE
            );
    }

#endif //!WININET_SERVER_CORE

    DEBUG_LEAVE(0);
}



// Loads Mlang.dll and get the entry point we are interested in.

BOOL LoadMlang( )
{
    if (!MlangCritSec.Lock())
        goto quit;

    if (hInstMlang == NULL && !bFailedMlangLoad)
    {
        INET_ASSERT(pfnInetMultiByteToUnicode == NULL);
        hInstMlang = LoadLibrary(MLANGDLLNAME);

        if (hInstMlang != NULL)
        {
            pfnInetMultiByteToUnicode = (PFNINETMULTIBYTETOUNICODE)GetProcAddress
                                            (hInstMlang,"ConvertINetMultiByteToUnicode");
            if (pfnInetMultiByteToUnicode == NULL)
            {
                INET_ASSERT(FALSE);
                FreeLibrary(hInstMlang);
                hInstMlang = NULL;
            }
        }
        else
        {
            INET_ASSERT(FALSE); // bad news if we can't load mlang.dll
        }

        if (pfnInetMultiByteToUnicode == NULL)
            bFailedMlangLoad = TRUE;
    }

    MlangCritSec.Unlock();

quit:
    return (pfnInetMultiByteToUnicode != NULL);
}

BOOL UnloadMlang( )
{
    if (!MlangCritSec.Lock())
        return FALSE;

    if (hInstMlang)
        FreeLibrary(hInstMlang);

    hInstMlang = NULL;
    pfnInetMultiByteToUnicode = NULL;
    bFailedMlangLoad = FALSE;

    MlangCritSec.Unlock();

    return TRUE;
}

PFNINETMULTIBYTETOUNICODE GetInetMultiByteToUnicode( )
{
    // We are checking for pfnInetMultiByteToUnicode without getting a crit section.
    // This works only because UnloadMlang is called at the Dll unload time.

    if (pfnInetMultiByteToUnicode == NULL)
    {
        LoadMlang( );
    }

    return pfnInetMultiByteToUnicode;
}

int cdecl _sprintf(char* buffer, char* format, va_list args);

void LOG_EVENT(DWORD dwEventType, char* format, ...)
{
    if (g_hEventLog == NULL)
    {
        return;
    }

    va_list args;
    int n;
    char *pBuffer = (char *) ALLOCATE_FIXED_MEMORY(1024);

    if (pBuffer == NULL)
        return;

    va_start(args, format);
    n = _sprintf(pBuffer, format, args);
    va_end(args);
    
    LPCSTR pszMessages[1];
    pszMessages[0] = &pBuffer[0];

    ::ReportEvent(g_hEventLog, 
                  (WORD)dwEventType,
                  0,
                  dwEventType,
                  NULL,
                  1,
                  0,
                  &pszMessages[0],
                  NULL);

    FREE_MEMORY(pBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\api\registry.cxx ===
/*++


Copyright (c) 1994  Microsoft Corporation

Module Name:

    registry.cxx

Abstract:

    Functions to read/write registry parameters

    Contents:
        OpenInternetSettingsKey
        CloseInternetSettingsKey
        InternetGetComputerName
        InternetDeleteRegistryValue
        InternetReadRegistryDword
        InternetWriteRegistryDword
        InternetReadRegistryString
        InternetWriteRegistryString
        InternetReadRegistryBinary
        (InternetReadRegistryDwordKey)
        (InternetReadRegistryStringKey)
        (InternetReadRegistryBinaryKey)
        (InternetGetPrivateProfileString)
        (ReadRegistryOemString)
        (WriteRegistryDword)
        ReadRegistryDword

Author:

    Richard L Firth (rfirth) 20-Mar-1995

Environment:

    Win32(s) user-level DLL

Revision History:

    20-Mar-1995 rfirth
        Created

--*/

#include <wininetp.h>

char vszDelimiters[] = ";, ";

//
// manifests
//

#define INTERNET_CLIENT_KEY         "Internet Settings"
#define SYSTEM_INI_FILE_NAME        "SYSTEM.INI"
#define NETWORK_SECTION_NAME        "Network"
#define COMPUTER_NAME_VALUE         "ComputerName"
#define PROFILE_INT_BUFFER_LENGTH   128

#define MIME_TO_FILE_EXTENSION_KEY  "MIME\\Database\\Content Type\\"
#define EXTENSION_VALUE             "Extension"

//
// macros
//

#define INTERNET_SETTINGS_KEY       "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"
#define INTERNET_CACHE_SETTINGS_KEY "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\5.0\\Cache"

//
// private prototypes
//

PRIVATE
DWORD
InternetReadRegistryDwordKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );

PRIVATE
DWORD
InternetReadRegistryStringKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPSTR ParameterValue,
    IN OUT LPDWORD ParameterLength
    );

//PRIVATE
//DWORD
//InternetReadRegistryBinaryKey(
//    IN HKEY ParameterKey,
//    IN LPCSTR ParameterName,
//    OUT LPBYTE ParameterValue,
//    IN OUT LPDWORD ParameterLength
//    );
//
//PRIVATE
//DWORD
//InternetGetPrivateProfileString(
//    IN LPSTR IniFileName,
//    IN LPSTR SectionName,
//    IN LPCSTR ParameterName,
//    OUT LPSTR ParameterValue,
//    IN OUT LPDWORD ParameterLength
//    );

PRIVATE
DWORD
ReadRegistryOemString(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    OUT LPSTR String,
    IN OUT LPDWORD Length
    );




PRIVATE
DWORD
WriteRegistryDword(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    );

//
// private data
//

PRIVATE HKEY hKeyInternetSettings = NULL;

//
// functions
//


DWORD
OpenInternetSettingsKey(
    VOID
    )

/*++

Routine Description:

    Opens registry key for Internet Settings branch

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "OpenInternetSettingsKey",
                 NULL
                 ));

    DWORD error = ERROR_SUCCESS;

    if (!GeneralInitCritSec.Lock())
    {
        goto quit;
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (hKeyInternetSettings == NULL) {

        DWORD dwDisposition;

        REGCREATEKEYEX(HKEY_LOCAL_MACHINE,
                       INTERNET_SETTINGS_KEY,
                       0,     // reserved
                       NULL,  // class
                       0,     // options
                       KEY_READ | KEY_WRITE,
                       NULL,  // security attributes
                       &hKeyInternetSettings,
                       &dwDisposition
                       );
    }

    GeneralInitCritSec.Unlock();

quit:
    DEBUG_LEAVE(error);

    return error;
}


DWORD
CloseInternetSettingsKey(
    VOID
    )

/*++

Routine Description:

    Closes Internet Settings registry key

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "CloseInternetSettingsKey",
                 NULL
                 ));

    DWORD error = ERROR_SUCCESS;

    if (hKeyInternetSettings != NULL) {
        error = REGCLOSEKEY(hKeyInternetSettings);
        hKeyInternetSettings = NULL;
    }

    DEBUG_LEAVE(error);

    return error;
}


PUBLIC
DWORD
InternetDeleteRegistryValue(
    IN LPSTR ParameterName
    )

/*++

Routine Description:

    Delets an entry from a the Internet Client registry key if the platform
    is NT/Win95.

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DWORD error;

    DEBUG_ENTER((DBG_REGISTRY,
                Dword,
                "InternetDeleteRegistryValue",
                "%q",
                ParameterName
                ));


    HKEY clientKey;

    //
    // open the registry key containing the Internet client values (this is
    // in the same place on NT and Win95)
    //

    error = REGOPENKEYEX(HKEY_CURRENT_USER,
                         INTERNET_SETTINGS_KEY,
                         0, // reserved
                         KEY_ALL_ACCESS,
                         &clientKey
                         );


    if (error == ERROR_SUCCESS) {

        error = RegDeleteValue(clientKey,
                               ParameterName
                               );

        REGCLOSEKEY(clientKey);
    }


    DEBUG_LEAVE(error);

    return error;
}




DWORD
InternetReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    Reads a single DWORD from a the Internet Client registry key if the platform
    is NT/Win95, else reads the value from SYSTEM.INI if we are running on Win32s

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - pointer to place to store retrieved value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetReadRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = InternetReadRegistryDwordKey(HKEY_LOCAL_MACHINE,
                                               ParameterName,
                                               ParameterValue
                                               );

    DEBUG_LEAVE(error);

    return error;
}

#ifdef WININET6

DWORD
InternetIDEWriteRegistryDword(
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    )

/*++

Routine Description:

    Writes a single DWORD from to the Internet Client registry key if the platform
    is NT/Win95, otherwise it fails.

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - value to store in registry.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetIDEWriteRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = GlobalIdentity 
                ? WriteIDRegDword(ParameterName, ParameterValue)
                : InternetWriteRegistryDword(ParameterName, ParameterValue);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
InternetIDEReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    If we're in an identity-mode, we'll read from the special location.
    Otherwise, read from the old location.

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - pointer to place to store retrieved value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetIDEReadRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = GlobalIdentity
                ? ReadIDRegDword(ParameterName, ParameterValue)
                : InternetReadRegistryDwordKey(HKEY_CURRENT_USER, ParameterName, ParameterValue);

    DEBUG_LEAVE(error);

    return error;
}
#endif


DWORD
InternetCacheReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    Reads a single DWORD from a the Internet Client registry key if the platform
    is NT/Win95, else reads the value from SYSTEM.INI if we are running on Win32s

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - pointer to place to store retrieved value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetCacheReadRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = ERROR_SUCCESS;
    HKEY clientKey;

    error = REGOPENKEYEX(HKEY_CURRENT_USER,
                         INTERNET_CACHE_SETTINGS_KEY,
                         0, // reserved
                         KEY_QUERY_VALUE,
                         &clientKey
                         );

    if (error == ERROR_SUCCESS) {
        error = ReadRegistryDword(clientKey,
                                  ParameterName,
                                  ParameterValue
                                  );
        REGCLOSEKEY(clientKey);
    }

    DEBUG_LEAVE(error);

    return error;
}



DWORD
InternetWriteRegistryDword(
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    )

/*++

Routine Description:

    Writes a single DWORD from to the Internet Client registry key if the platform
    is NT/Win95, otherwise it fails.

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - value to store in registry.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetWriteRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error;

    if (hKeyInternetSettings != NULL) {
        error = WriteRegistryDword(hKeyInternetSettings,
                                   ParameterName,
                                   ParameterValue
                                   );
    } else {
        error = ERROR_SUCCESS;
    }

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("InternetWriteRegistryDword(%q): value = %d (%#x)\n",
                ParameterName,
                ParameterValue,
                ParameterValue
                ));

    DEBUG_LEAVE(error);

    return error;
}



DWORD
InternetReadRegistryString(
    IN LPCSTR ParameterName,
    OUT LPSTR ParameterValue,
    IN OUT LPDWORD ParameterLength
    )

/*++

Routine Description:

    Reads a string from the Internet Client registry key on NT/Win95, or reads
    the corresponding value from SYSTEM.INI on a Win32s platform

Arguments:

    ParameterName   - name of value parameter within key (e.g. EmailName)

    ParameterValue  - pointer to string buffer for returned string

    ParameterLength - IN: number of bytes in ParameterValue
                      OUT: number of bytes in string (excluding trailing '\0')

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetReadRegistryString",
                 "%q, %x, %x [%d]",
                 ParameterName,
                 ParameterValue,
                 ParameterLength,
                 *ParameterLength
                 ));

    DWORD error = InternetReadRegistryStringKey(HKEY_CURRENT_USER,
                                                ParameterName,
                                                ParameterValue,
                                                ParameterLength
                                                );

    DEBUG_LEAVE(error);

    return error;
}

//
//DWORD
//InternetWriteRegistryString(
//    IN LPCSTR ParameterName,
//    IN LPSTR ParameterValue
//    )
//
///*++
//
//Routine Description:
//
//    Writes a string to the Internet Client registry key on NT/Win95, or writes
//    the corresponding value to SYSTEM.INI on Win32s platform
//
//Arguments:
//
//    ParameterName   - name of value parameter within key (e.g. EmailName)
//
//    ParameterValue  - pointer to string to write
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure -
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_REGISTRY,
//                 Dword,
//                 "InternetWriteRegistryString",
//                 "%.40q, %.80q",
//                 ParameterName,
//                 ParameterValue
//                 ));
//
//    DWORD error;
//
//    if (IsPlatformWin32s()) {
//
//        BOOL ok;
//
//        ok = WritePrivateProfileString(INTERNET_CLIENT_KEY,
//                                       ParameterName,
//                                       ParameterValue,
//                                       SYSTEM_INI_FILE_NAME
//                                       );
//        error = ok ? ERROR_SUCCESS : GetLastError();
//    } else {
//
//        //
//        // BUGBUG - currently, nothing needs to write to registry if NT or Win95
//        //
//
//        INET_ASSERT(FALSE);
//
//    }
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}
//
//
//DWORD
//InternetReadRegistryBinary(
//    IN LPCSTR ParameterName,
//    OUT LPBYTE ParameterValue,
//    IN OUT LPDWORD ParameterLength
//    )
//
///*++
//
//Routine Description:
//
//    Reads a binary value from the Internet Client registry key on NT/Win95, or
//    reads the corresponding value from SYSTEM.INI on a Win32s platform
//
//Arguments:
//
//    ParameterName   - name of value parameter within key (e.g. EmailName)
//
//    ParameterValue  - pointer to buffer for returned data
//
//    ParameterLength - IN: number of bytes in ParameterValue
//                      OUT: number of bytes in buffer, or required size
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - ERROR_PATH_NOT_FOUND
//                    The parameter wasn't found
//
//                  ERROR_MORE_DATA
//                    The buffer isn't large enough
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_REGISTRY,
//                 Dword,
//                 "InternetReadRegistryBinary",
//                 "%q, %#x, %#x [%d]",
//                 ParameterName,
//                 ParameterValue,
//                 ParameterLength,
//                 *ParameterLength
//                 ));
//
//    DWORD error;
//
//    error = InternetReadRegistryBinaryKey(HKEY_CURRENT_USER,
//                                          ParameterName,
//                                          ParameterValue,
//                                          ParameterLength
//                                          );
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}

//
// private functions
//


PUBLIC
DWORD
InternetReadRegistryDwordKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    Reads a single DWORD from a the Internet Client registry key if the platform
    is NT/Win95, else reads the value from SYSTEM.INI if we are running on Win32s.

    Does not modify the *ParameterValue if the registry variable cannot be read

Arguments:

    ParameterKey    - root registry key (e.g. HKEY_CURRENT_USER)

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - pointer to place to store retrieved value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetReadRegistryDwordKey",
                 "%s, %q, %x",
                 (ParameterKey == HKEY_LOCAL_MACHINE)
                    ? "HKEY_LOCAL_MACHINE"
                    : (ParameterKey == HKEY_CURRENT_USER)
                        ? "HKEY_CURRENT_USER"
                        : "???",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = ERROR_SUCCESS;
    HKEY clientKey = hKeyInternetSettings;

    if (ParameterKey != HKEY_CURRENT_USER) {
        error = REGOPENKEYEX(ParameterKey,
                             INTERNET_SETTINGS_KEY,
                             0, // reserved
                             KEY_QUERY_VALUE,
                             &clientKey
                             );
    } else if (clientKey == NULL) {
        error = ERROR_PATH_NOT_FOUND;
    }

    if (error == ERROR_SUCCESS) {
        error = ReadRegistryDword(clientKey,
                                  ParameterName,
                                  ParameterValue
                                  );
        if (clientKey != hKeyInternetSettings) {
            REGCLOSEKEY(clientKey);
        }
    }

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("InternetReadRegistryDwordKey(%q): value = %d (%#x)\n",
                ParameterName,
                *ParameterValue,
                *ParameterValue
                ));

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
InternetReadRegistryStringKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPSTR ParameterValue,
    IN OUT LPDWORD ParameterLength
    )

/*++

Routine Description:

    Reads a string from the Internet Client registry key on NT/Win95, or reads
    the corresponding value from SYSTEM.INI on a Win32s platform

Arguments:

    ParameterKey    - root registry key (e.g. HKEY_LOCAL_MACHINE)

    ParameterName   - name of value parameter within key (e.g. EmailName)

    ParameterValue  - pointer to string buffer for returned string

    ParameterLength - IN: number of bytes in ParameterValue
                      OUT: number of bytes in string (excluding trailing '\0')

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetReadRegistryStringKey",
                 "%s (%x), %q, %x, %x [%d]",
                 (ParameterKey == HKEY_LOCAL_MACHINE)
                    ? "HKEY_LOCAL_MACHINE"
                    : (ParameterKey == HKEY_CURRENT_USER)
                        ? "HKEY_CURRENT_USER"
                        : "???",
                 ParameterKey,
                 ParameterName,
                 ParameterValue,
                 ParameterLength,
                 *ParameterLength
                 ));

    //
    // zero-terminate the string
    //

    if (*ParameterLength > 0) {
        *ParameterValue = '\0';
    }

    DWORD error = ERROR_SUCCESS;
    HKEY clientKey = hKeyInternetSettings;

    if (ParameterKey != HKEY_CURRENT_USER) {
        error = REGOPENKEYEX(ParameterKey,
                             INTERNET_SETTINGS_KEY,
                             0, // reserved
                             KEY_QUERY_VALUE,
                             &clientKey
                             );
    } else if (clientKey == NULL) {
        error = ERROR_PATH_NOT_FOUND;
    }

    if (error == ERROR_SUCCESS) {
        error = ReadRegistryOemString(clientKey,
                                      ParameterName,
                                      ParameterValue,
                                      ParameterLength
                                      );
        if (clientKey != hKeyInternetSettings) {
            REGCLOSEKEY(clientKey);
        }
    }

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("InternetReadRegistryStringKey(%q): value = %q\n",
                ParameterName,
                ParameterValue
                ));

    DEBUG_LEAVE(error);

    return error;
}

//
//PRIVATE
//DWORD
//InternetReadRegistryBinaryKey(
//    IN HKEY ParameterKey,
//    IN LPCSTR ParameterName,
//    OUT LPBYTE ParameterValue,
//    IN OUT LPDWORD ParameterLength
//    )
//
///*++
//
//Routine Description:
//
//    Reads a binary value from the Internet Client registry key on NT/Win95, or
//    reads the corresponding value from SYSTEM.INI on a Win32s platform
//
//Arguments:
//
//    ParameterKey    - root registry key (e.g. HKEY_LOCAL_MACHINE)
//
//    ParameterName   - name of value parameter within key (e.g. EmailName)
//
//    ParameterValue  - pointer to buffer for returned data
//
//    ParameterLength - IN: number of bytes in ParameterValue
//                      OUT: number of bytes in buffer, or required size
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - ERROR_PATH_NOT_FOUND
//                    The parameter wasn't found
//
//                  ERROR_MORE_DATA
//                    The buffer isn't large enough
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_REGISTRY,
//                 Dword,
//                 "InternetReadRegistryBinaryKey",
//                 "%s (%x), %q, %#x, %#x [%d]",
//                 (ParameterKey == HKEY_LOCAL_MACHINE)
//                    ? "HKEY_LOCAL_MACHINE"
//                    : (ParameterKey == HKEY_CURRENT_USER)
//                        ? "HKEY_CURRENT_USER"
//                        : "???",
//                 ParameterKey,
//                 ParameterName,
//                 ParameterValue,
//                 ParameterLength,
//                 *ParameterLength
//                 ));
//
//    DWORD error;
//    HKEY clientKey;
//
//    //
//    // open the registry key containing the Internet client values (this is
//    // in the same place on NT and Win95)
//    //
//
//    error = REGOPENKEYEX(ParameterKey,
//                         INTERNET_SETTINGS_KEY,
//                         0, // reserved
//                         KEY_QUERY_VALUE,
//                         &clientKey
//                         );
//
//    if (error == ERROR_SUCCESS) {
//
//        DWORD valueType;
//
//        error = RegQueryValueEx(clientKey,
//                                ParameterName,
//                                NULL,   // reserved
//                                &valueType,
//                                ParameterValue,
//                                ParameterLength
//                                );
//        REGCLOSEKEY(clientKey);
//    }
//
//    DEBUG_PRINT(REGISTRY,
//                INFO,
//                ("InternetReadRegistryBinaryKey(%q): length = %d\n",
//                ParameterName,
//                *ParameterLength
//                ));
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}
//
//
//PRIVATE
//DWORD
//InternetGetPrivateProfileString(
//    IN LPSTR IniFileName,
//    IN LPSTR SectionName,
//    IN LPCSTR ParameterName,
//    OUT LPSTR ParameterValue,
//    IN OUT LPDWORD ParameterLength
//    )
//
///*++
//
//Routine Description:
//
//    Reads an string out of an INI file. Mainly just for Win32s
//
//Arguments:
//
//    IniFileName     - name of INI file to read
//
//    SectionName     - name of section in INI file to read
//
//    ParameterName   - name of entry in section to read
//
//    ParameterValue  - returned string
//
//    ParameterLength - IN: Length of ParameterValue
//                      OUT: Number of characters in ParameterValue, excluding
//                           terminating NUL
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - ERROR_PATH_NOT_FOUND
//                  ERROR_FILE_NOT_FOUND
//
//--*/
//
//{
//    DWORD error;
//    DWORD nChars;
//
//    nChars = GetPrivateProfileString(SectionName,
//                                     ParameterName,
//                                     "",                // lpszDefault
//                                     ParameterValue,
//                                     *ParameterLength,
//                                     IniFileName
//                                     );
//    if (nChars > 0) {
//        *ParameterLength = nChars;
//        error = ERROR_SUCCESS;
//    } else {
//        error = ERROR_PATH_NOT_FOUND;
//    }
//    return error;
//}


PRIVATE
DWORD
ReadRegistryOemString(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    OUT LPSTR String,
    IN OUT LPDWORD Length
    )

/*++

Routine Description:

    Reads a string out of the registry as an OEM string

Arguments:

    Key             - open registry key where to read value from

    ParameterName   - name of registry value to read

    String          - place to put it

    Length          - IN: length of String buffer in characters
                      OUT: length of String in characters, as if returned from
                      strlen()

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_FILE_NOT_FOUND
                    Couldn't find the parameter

                  ERROR_PATH_NOT_FOUND
                    Couldn't find the parameter
--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "ReadRegistryOemString",
                 "%#x, %q, %#x, %#x [%d]",
                 Key,
                 ParameterName,
                 String,
                 Length,
                 *Length
                 ));

    LONG error;
    DWORD valueType;
    LPSTR str;
    DWORD valueLength;

    //
    // first, get the length of the string
    //

    valueLength = *Length;
    error = RegQueryValueEx(Key,
                            ParameterName,
                            NULL, // reserved
                            &valueType,
                            (LPBYTE)String,
                            &valueLength
                            );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // we only support REG_SZ (single string) values in this function
    //

    if (valueType != REG_SZ) {
        error = ERROR_PATH_NOT_FOUND;
        goto quit;
    }

    //
    // if 1 or 0 chars returned then the string is empty
    //

    if (valueLength <= sizeof(char)) {
        error = ERROR_PATH_NOT_FOUND;
        goto quit;
    }

    //
    // convert the ANSI string to OEM character set in place. According to Win
    // help, this always succeeds
    //

    CharToOem(String, String);

    //
    // return the length as if returned from strlen() (i.e. drop the '\0')
    //

    *Length = valueLength - sizeof(char);

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("ReadRegistryOemString(%q) returning %q (%d chars)\n",
                ParameterName,
                String,
                *Length
                ));

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ReadRegistryDword(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    Reads a DWORD parameter from the registry

    Won't modify *ParameterValue unless a valid value is read from the registry

Arguments:

    Key             - handle of open registry key where parameter resides

    ParameterName   - name of DWORD parameter to read

    ParameterValue  - returned DWORD parameter read from registry

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND
                    One of the following occurred:
                        - the parameter is not in the specified registry key
                        - the parameter is the wrong type
                        - the parameter is the wrong size

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "ReadRegistryDword",
                 "%x, %q, %x",
                 Key,
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error;
    DWORD valueLength;
    DWORD valueType;
    DWORD value;

    valueLength = sizeof(*ParameterValue);
    error = (DWORD)RegQueryValueEx(Key,
                                   ParameterName,
                                   NULL, // reserved
                                   &valueType,
                                   (LPBYTE)&value,
                                   &valueLength
                                   );

    //
    // if the size or type aren't correct then return an error, else only if
    // success was returned do we modify *ParameterValue
    //

    if (error == ERROR_SUCCESS) {
        if (((valueType != REG_DWORD)
        && (valueType != REG_BINARY))
        || (valueLength != sizeof(DWORD))) {

            DEBUG_PRINT(REGISTRY,
                        ERROR,
                        ("valueType = %d, valueLength = %d\n",
                        valueType,
                        valueLength
                        ));

            error = ERROR_PATH_NOT_FOUND;
        } else {
            *ParameterValue = value;
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
WriteRegistryDword(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    )

/*++

Routine Description:

    Writes a DWORD parameter from the registry

    Will write ParameterValue to the key.

Arguments:

    Key             - handle of open registry key where parameter resides

    ParameterName   - name of DWORD parameter to write

    ParameterValue  - DWORD parameter to write from registry

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND
                    One of the following occurred:
                        - the parameter is not in the specified registry key
                        - the parameter is the wrong type
                        - the parameter is the wrong size

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "WriteRegistryDword",
                 "%x, %q, %x",
                 Key,
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error;
    DWORD valueLength;
    DWORD valueType;
    DWORD value;

    valueLength = sizeof(ParameterValue);
    valueType   = REG_DWORD;
    value       = ParameterValue;

    error = (DWORD)RegSetValueEx(Key,
                                 ParameterName,
                                 NULL, // reserved
                                 valueType,
                                 (LPBYTE)&value,
                                 valueLength
                                 );

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("added: valueType = %d, valueLength = %d\n",
                valueType,
                valueLength
                ));

    DEBUG_LEAVE(error);

    return error;
}

#if INET_DEBUG

typedef struct {
    LIST_ENTRY entry;
    HKEY hkey;
    char * file;
    int line;
    char name[1];
} DBGREGKEYINFO;

SERIALIZED_LIST DbgRegKeyList;

VOID DbgRegKey_Init(VOID) {
    InitializeSerializedList(&DbgRegKeyList);
}

VOID DbgRegKey_Terminate(VOID) {
    TerminateSerializedList(&DbgRegKeyList);
}

void regkey_add(const char * name, HKEY hkey, char * file, int line) {

    if (!name) {
        name = "";
    }

    int len = lstrlen(name);
    DBGREGKEYINFO * p = (DBGREGKEYINFO *)ALLOCATE_FIXED_MEMORY(sizeof(DBGREGKEYINFO) + len);

    if (p) {
//dprintf("Wininet.DbgRegKey: adding %q\n", name);
        memcpy(p->name, name, len + 1);
        p->line = line;
        p->file = file;
        p->hkey = hkey;
        InsertAtHeadOfSerializedList(&DbgRegKeyList, &p->entry);
    }
}

void regkey_remove(HKEY hkey) {
    if (LockSerializedList(&DbgRegKeyList))
    {

        DBGREGKEYINFO * p = (DBGREGKEYINFO *)HeadOfSerializedList(&DbgRegKeyList);

        while (p != (DBGREGKEYINFO *)SlSelf(&DbgRegKeyList)) {
            if (p->hkey == hkey) {
                RemoveFromSerializedList(&DbgRegKeyList, (PLIST_ENTRY)p);
//dprintf("Wininet.DbgRegKey: removing %q\n", p->name);
                FREE_MEMORY(p);
                break;
            }
            p = (DBGREGKEYINFO *)p->entry.Flink;
        }
        UnlockSerializedList(&DbgRegKeyList);
    }
}

char * regkey_name(HKEY hkey, const char * subname) {
    switch ((INT_PTR)hkey) {
    case (INT_PTR)HKEY_CLASSES_ROOT:
        return NEW_STRING("HKEY_CLASSES_ROOT");

    case (INT_PTR)HKEY_CURRENT_USER:
        return NEW_STRING("HKEY_CURRENT_USER");

    case (INT_PTR)HKEY_LOCAL_MACHINE:
        return NEW_STRING("HKEY_LOCAL_MACHINE");

    case (INT_PTR)HKEY_USERS:
        return NEW_STRING("HKEY_USERS");

    case (INT_PTR)HKEY_PERFORMANCE_DATA:
        return NEW_STRING("HKEY_PERFORMANCE_DATA");

    case (INT_PTR)HKEY_CURRENT_CONFIG:
        return NEW_STRING("HKEY_CURRENT_CONFIG");

    case (INT_PTR)HKEY_DYN_DATA:
        return NEW_STRING("HKEY_DYN_DATA");
    }

    char * name = NULL;

    if (LockSerializedList(&DbgRegKeyList))
    {
        DBGREGKEYINFO * p = (DBGREGKEYINFO *)HeadOfSerializedList(&DbgRegKeyList);

        while (p != (DBGREGKEYINFO *)SlSelf(&DbgRegKeyList)) {
            if (p->hkey == hkey) {

                int len = lstrlen(p->name);
                int slen = lstrlen(subname);

                name = (char *)ALLOCATE_FIXED_MEMORY(len + 1 + slen + 1);
                if (name) {
                    memcpy(name, p->name, len);
                    name[len] = '\\';
                    memcpy(name + len + 1, subname, slen + 1);
                }
                break;
            }
            p = (DBGREGKEYINFO *)p->entry.Flink;
        }
        UnlockSerializedList(&DbgRegKeyList);
    }

    return name;
}

void regkey_freename(char * name) {
    if (name) {
        FREE_MEMORY(name);
    }
}

LONG
DbgRegOpenKey(
    IN HKEY hKey,
    IN LPCTSTR lpszSubKey,
    OUT PHKEY phkResult,
    char * file,
    int line
    )
{
    char * keyname = regkey_name(hKey, lpszSubKey);
    LONG rc = RegOpenKey(hKey, lpszSubKey, phkResult);

    if (rc == 0) {
        regkey_add(keyname, *phkResult, file, line);
    }
    regkey_freename(keyname);
    return rc;
}

LONG
DbgRegOpenKeyEx(
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD ulOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult,
    char * file,
    int line
    )
{
    char * keyname = regkey_name(hKey, lpSubKey);
    LONG rc = RegOpenKeyEx(hKey, lpSubKey, ulOptions, samDesired, phkResult);

    if (rc == 0) {
        regkey_add(keyname, *phkResult, file, line);
    }
    regkey_freename(keyname);
    return rc;
}

LONG
DbgRegCreateKeyEx(
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD Reserved,
    IN LPSTR lpClass,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition,
    char * file,
    int line
    )
{
    char * keyname = regkey_name(hKey, lpSubKey);
    LONG rc = RegCreateKeyEx(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);

    if (rc == 0) {
        regkey_add(keyname, *phkResult, file, line);
    }
    regkey_freename(keyname);
    return rc;
}

LONG
DbgRegCloseKey(
    IN HKEY hKey
    )
{
    LONG rc = RegCloseKey(hKey);

    if (rc == 0) {
        regkey_remove(hKey);
    }
    return rc;
}

#endif // INET_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\auth\basic.cxx ===
#include <wininetp.h>
#include <splugin.hxx>
#include "htuu.h"

/*---------------------------------------------------------------------------
BASIC_CTX
---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------
    Constructor
---------------------------------------------------------------------------*/
BASIC_CTX::BASIC_CTX(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy, 
                    SPMData* pSPM, AUTH_CREDS* pCreds)
    : AUTHCTX(pSPM, pCreds)
{
    _fIsProxy = fIsProxy;
    _pRequest = pRequest;
}


/*---------------------------------------------------------------------------
    Destructor
---------------------------------------------------------------------------*/
BASIC_CTX::~BASIC_CTX()
{}


/*---------------------------------------------------------------------------
    PreAuthUser
---------------------------------------------------------------------------*/
DWORD BASIC_CTX::PreAuthUser(IN LPSTR pBuf, IN OUT LPDWORD pcbBuf)
{
    if (!_pCreds->lpszUser || !_pCreds->lpszPass)
        return ERROR_INVALID_PARAMETER;
            
    // Prefix the header value with the auth type.
    const static BYTE szBasic[] = "Basic ";

    #define BASIC_LEN sizeof(szBasic)-1

    memcpy (pBuf, szBasic, BASIC_LEN);
    pBuf += BASIC_LEN;

    DWORD cbUserLen = _pCreds->lpszUser ? strlen(_pCreds->lpszUser) : 0;
    DWORD cbPassLen = _pCreds->lpszPass ? strlen(_pCreds->lpszPass) : 0;
    
    // Generate rest of header value by uuencoding user:pass.
    DWORD cbMaxUserPathLen = cbUserLen + 1 + cbPassLen + 1 
        + 2;    // HTUU_encode() parse the buffer 3 bytes at a time; 
                // In the worst case we will be two bytes short, so add 2 here. 
                // longer buffer doesn't matter, HTUU_encode will adjust appropreiately.
    
    LPSTR pszUserPass = New CHAR[cbMaxUserPathLen];
    if (pszUserPass)
    {
        DWORD cbUserPass;
    
        cbUserPass = wsprintf(pszUserPass, "%s:%s", _pCreds->lpszUser, _pCreds->lpszPass);
        
        INET_ASSERT (cbUserPass < cbMaxUserPathLen);
    
        HTUU_encode ((PBYTE) pszUserPass, cbUserPass,
            pBuf, *pcbBuf);
    
        delete [] pszUserPass;
    
        *pcbBuf = BASIC_LEN + lstrlen (pBuf);
        
        _pvContext = (LPVOID) 1;
        return ERROR_SUCCESS;
    }
    else
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
}

/*---------------------------------------------------------------------------
    UpdateFromHeaders
---------------------------------------------------------------------------*/
DWORD BASIC_CTX::UpdateFromHeaders(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy)
{
    DWORD dwAuthIdx, cbRealm, dwError;
    LPSTR szRealm = NULL;
    
    // Get the associated header.
    if ((dwError = FindHdrIdxFromScheme(&dwAuthIdx)) != ERROR_SUCCESS)
        goto exit;

    // Get any realm.
    dwError = GetAuthHeaderData(pRequest, fIsProxy, "Realm", 
        &szRealm, &cbRealm, ALLOCATE_BUFFER, dwAuthIdx);

    // No realm is OK.
    if (dwError != ERROR_SUCCESS)
        szRealm = NULL;

    // If we already have a Creds, ensure that the realm matches. If not,
    // find or create a new one and set it in the auth context.
    if (_pCreds)
    {
        INET_ASSERT(_pCreds->lpszRealm);
        if (/*_pCreds->lpszRealm && */szRealm && lstrcmp(_pCreds->lpszRealm, szRealm))
        {
            // Realms don't match - create a new Creds entry, release the old.
            delete _pCreds;
            _pCreds = CreateCreds(pRequest, fIsProxy, _pSPMData, szRealm);
            INET_ASSERT(_pCreds->pSPM == _pSPMData);
        }
    }
    // If no password cache is set in the auth context,
    // find or create one and set it in the auth context.
    else
    {            
        // Find or create a password cache entry.
        _pCreds = CreateCreds(pRequest, fIsProxy, _pSPMData, szRealm);
        if (!_pCreds)
        {
            dwError = ERROR_WINHTTP_INTERNAL_ERROR;
            goto exit;
        }
        INET_ASSERT(_pCreds->pSPM == _pSPMData);
        // _pCreds->nLockCount++;
    }

    if (!_pCreds)
    {
        INET_ASSERT(FALSE);
        dwError = ERROR_WINHTTP_INTERNAL_ERROR;
        goto exit;
    }

    dwError = ERROR_SUCCESS;
        
    exit:

    if (szRealm)
        delete []szRealm;

    return dwError;
}


/*---------------------------------------------------------------------------
    PostAuthUser
---------------------------------------------------------------------------*/
DWORD BASIC_CTX::PostAuthUser()
{
    DWORD dwRet;

    if (! _pvContext && !_pRequest->GetCreds() 
        && _pCreds->lpszUser && _pCreds->lpszPass)
        dwRet = ERROR_WINHTTP_FORCE_RETRY;
    else
        dwRet = ERROR_WINHTTP_INCORRECT_PASSWORD;

    _pRequest->SetCreds(NULL);
    _pvContext = (LPVOID) 1;
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\api\sendapi.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    sendapi.cxx

Abstract:

    This file contains the implementation of the HttpSendRequestA API.

    Contents:
        WinHttpSendRequest
        HttpSendRequestA
        WinHttpReceiveResponse
        HttpWrapSendRequest

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

      29-Apr-97 rfirth
        Conversion to FSM

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

//
// private prototypes
//

PRIVATE
BOOL
HttpWrapSendRequest(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength,
    IN DWORD dwOptionalLengthTotal,
    IN AR_TYPE arRequest,
    IN DWORD_PTR dwContext=NULL
    );

//
// functions
//

INTERNETAPI
BOOL
WINAPI
HttpSendRequestA(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    )

/*++

Routine Description:

    Sends the specified request to the HTTP server.

Arguments:

    hRequest                - An open HTTP request handle returned by
                              HttpOpenRequest()

    lpszHeaders             - Additional headers to be appended to the request.
                              This may be NULL if there are no additional
                              headers to append

    dwHeadersLength         - The length (in characters) of the additional
                              headers. If this is -1L and lpszAdditional is
                              non-NULL, then lpszAdditional is assumed to be
                              zero terminated (ASCIIZ)

    lpOptionalData          - Any optional data to send immediately after the
                              request headers. This is typically used for POST
                              operations. This may be NULL if there is no
                              optional data to send

    dwOptionalDataLength    - The length (in BYTEs) of the optional data. This
                              may be zero if there is no optional data to send

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. For more information call GetLastError(). If the
                  request was async, then GetLastError() will return
                  ERROR_IO_PENDING which means that the operation initially
                  succeeded, and that the caller should wait for the status
                  callback to discover the final success/failure status

--*/

{
    DEBUG_ENTER_API((DBG_API,
                Bool,
                "HttpSendRequestA",
                "%#x, %.80q, %d, %#x, %d",
                hRequest,
                lpszHeaders,
                dwHeadersLength,
                lpOptional,
                dwOptionalLength
                ));


    BOOL fRet= HttpWrapSendRequest(
                hRequest,
                lpszHeaders,
                dwHeadersLength,
                lpOptional,
                dwOptionalLength,
                0,
                AR_HTTP_SEND_REQUEST
                );


    DEBUG_LEAVE_API(fRet);

    return fRet;
}

INTERNETAPI
BOOL
WINAPI
WinHttpSendRequest(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength,
    IN DWORD dwTotalLength,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Sends the specified request to the HTTP server.

Arguments:

    hRequest                - An open HTTP request handle returned by
                              HttpOpenRequest()

    lpszHeaders             - Additional headers to be appended to the request.
                              This may be NULL if there are no additional
                              headers to append

    dwHeadersLength         - The length (in characters) of the additional
                              headers. If this is -1L and lpszAdditional is
                              non-NULL, then lpszAdditional is assumed to be
                              zero terminated (ASCIIZ)

    lpOptionalData          - Any optional data to send immediately after the
                              request headers. This is typically used for POST
                              operations. This may be NULL if there is no
                              optional data to send

    dwOptionalDataLength    - The length (in BYTEs) of the optional data. This
                              may be zero if there is no optional data to send

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. For more information call GetLastError(). If the
                  request was async, then GetLastError() will return
                  ERROR_IO_PENDING which means that the operation initially
                  succeeded, and that the caller should wait for the status
                  callback to discover the final success/failure status

--*/

{
    DEBUG_ENTER_API((DBG_API,
                Bool,
                "WinHttpSendRequest",
                "%#x, %.80wq, %d, %#x, %d, %d, %x",
                hRequest,
                lpszHeaders,
                dwHeadersLength,
                lpOptional,
                dwOptionalLength,
                dwTotalLength,
                dwContext
                ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpHeaders;

    if (!hRequest)
    {
        dwErr = ERROR_INVALID_HANDLE;
        goto cleanup;
    }

    if (lpszHeaders && IsBadReadPtr(lpszHeaders, 1))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (dwHeadersLength == -1L)
    {
        dwHeadersLength = lpszHeaders ? lstrlenW(lpszHeaders) : 0;
    }

    if (lpszHeaders)
    {
        if ((dwHeadersLength == -1)
            ? IsBadStringPtrW(lpszHeaders, -1)
            : IsBadReadPtr(lpszHeaders, dwHeadersLength))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(lpszHeaders, dwHeadersLength, mpHeaders);
        if (!mpHeaders.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszHeaders, mpHeaders);
    }
    if (lpOptional 
        && dwOptionalLength
        && IsBadReadPtr(lpOptional, dwOptionalLength) )
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
            
    AR_TYPE ar;
    
    // Always require a WinHttpReceiveResponse to initiate
    // FSM_STATE_4 onwards in HTTP_REQUEST_HANDLE_OBJECT::HttpSendRequest_Start:
    if (dwOptionalLength <= dwTotalLength)
    {
        ar = AR_HTTP_BEGIN_SEND_REQUEST;
    }
    else
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    fResult = HttpWrapSendRequest(hRequest, mpHeaders.psStr, mpHeaders.dwSize,
                lpOptional, dwOptionalLength, dwTotalLength, ar, dwContext);
    // This calls SetLastError if fResult is FALSE.
    
cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(HTTP, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI
BOOL
WINAPI
WinHttpReceiveResponse(
    IN HINTERNET hRequest,
    IN LPVOID lpBuffersOut OPTIONAL
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hRequest        -
    lpBuffersOut    -
    dwFlags         -
    dwContext       -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpReceiveResponse",
                     "%#x, %#x",
                     hRequest,
                     lpBuffersOut
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;

    if (!hRequest)
    {
        dwErr = ERROR_INVALID_HANDLE;
    }
    else if (lpBuffersOut)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        fResult = HttpWrapSendRequest(hRequest, NULL, 0, NULL, 0, 0, AR_HTTP_END_SEND_REQUEST);
    }
    
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(HTTP, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


PRIVATE
BOOL
HttpWrapSendRequest(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength,
    IN DWORD dwOptionalLengthTotal,
    IN AR_TYPE arRequest,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Sends the specified request to the HTTP server.

Arguments:

    hRequest                - An open HTTP request handle returned by
                              HttpOpenRequest()

    lpszHeaders             - Additional headers to be appended to the request.
                              This may be NULL if there are no additional
                              headers to append

    dwHeadersLength         - The length (in characters) of the additional
                              headers. If this is -1L and lpszAdditional is
                              non-NULL, then lpszAdditional is assumed to be
                              zero terminated (ASCIIZ)

    lpOptionalData          - Any optional data to send immediately after the
                              request headers. This is typically used for POST
                              operations. This may be NULL if there is no
                              optional data to send

    dwOptionalDataLength    - The length (in BYTEs) of the optional data. This
                              may be zero if there is no optional data to send

    dwOptionalLengthTotal   - Total length need to be sent for File Upload.

    arRequest               - Which API the caller is making,
                                assumed to be HttpEndRequestA, HttpSendRequestExA, or
                                HttpSendRequestA

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. For more information call GetLastError(). If the
                  request was async, then GetLastError() will return
                  ERROR_IO_PENDING which means that the operation initially
                  succeeded, and that the caller should wait for the status
                  callback to discover the final success/failure status

Comments:

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Bool,
                 "HttpWrapSendRequest",
                 "%#x, %.80q, %d, %#x, %d, %d, %x",
                 hRequest,
                 lpszHeaders,
                 dwHeadersLength,
                 lpOptional,
                 dwOptionalLength,
                 dwOptionalLengthTotal,
                 dwContext
                 ));

    PERF_ENTER(HttpWrapSendRequest);

    DWORD error = ERROR_SUCCESS;
    HINTERNET hRequestMapped = NULL;
    BOOL bDeref = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_WINHTTP_NOT_INITIALIZED;
        goto done;
    }

    //
    // we will need the thread info for several items
    //

    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto done;
    }

    //
    // the only FSMs that can come before this one are InternetOpenUrl() or
    // HttpSendRequest() when we are performing nested send for https://
    // tunnelling through proxy
    //

    INET_ASSERT((lpThreadInfo->Fsm == NULL)
                || (lpThreadInfo->Fsm->GetType() == FSM_TYPE_PARSE_HTTP_URL)
                || (lpThreadInfo->Fsm->GetType() == FSM_TYPE_OPEN_PROXY_TUNNEL)
                );

    INET_ASSERT( arRequest == AR_HTTP_SEND_REQUEST ||
                 arRequest == AR_HTTP_BEGIN_SEND_REQUEST ||
                 arRequest == AR_HTTP_END_SEND_REQUEST );


    //
    // map the handle
    //
    error = MapHandleToAddress(hRequest, (LPVOID *)&hRequestMapped, FALSE);


    if ((error != ERROR_SUCCESS) && (hRequestMapped == NULL)) {
        goto quit;
    }

    //
    // Cast it to the object that we know. We are going to do caching
    // semantics with this
    //

    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequestMapped;

    //
    // set the context and handle info & reset the error variables,
    // but only if not for a ReceiveResponse call.
    //
    if (arRequest != AR_HTTP_END_SEND_REQUEST)
    {
        pRequest->SetContext(dwContext);
        INET_ASSERT( (INTERNET_CONNECT_HANDLE_OBJECT *)pRequest->GetParent() );

        ((INTERNET_CONNECT_HANDLE_OBJECT *)pRequest->GetParent())->SetContext(dwContext);

        // We need this information to special-case for Redirects and Auth because of RR FSM changes:
        pRequest->SetWriteRequired(dwOptionalLength < dwOptionalLengthTotal);
    }
    _InternetSetObjectHandle(lpThreadInfo, hRequest, hRequestMapped);
    _InternetClearLastError(lpThreadInfo);

    //
    // quit now if the handle was invalid
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // use RIsHandleLocal() to discover 4 things:
    //
    //  1. Handle is valid
    //  2. Handle is of expected type (HTTP Request in this case)
    //  3. Handle is local or remote
    //  4. Handle supports async I/O
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hRequestMapped,
                           &isLocal,
                           &isAsync,
                           TypeHttpRequestHandle
                           );

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    if (isAsync)
    {
        error = InitializeAsyncSupport();
        if (error != ERROR_SUCCESS)
        {
            goto quit;
        }
    }
    //
    // For SEND_REQUEST, and BEGIN_SEND_REQUEST, we need
    //  to do some basic initalization
    //

    if ( arRequest == AR_HTTP_SEND_REQUEST ||
         arRequest == AR_HTTP_BEGIN_SEND_REQUEST)
    {
        error = pRequest->InitBeginSendRequest(lpszHeaders,
                                       dwHeadersLength,
                                       &lpOptional,
                                       &dwOptionalLength,
                                       dwOptionalLengthTotal
                                       );

        if ( error != ERROR_SUCCESS)
        {
            goto quit;
        }

        // (Re)set flag to indicate WinHttpReceiveResponse needs to be called.
        pRequest->SetReceiveResponseState(FALSE);

        // ReceiveResponse FSM won't be exec'ed/queued until the client calls
        // WinHttpReceiveResponse to mark the end of writing additional data.
        pRequest->SetWriteDataNeeded(
                arRequest == AR_HTTP_BEGIN_SEND_REQUEST ? TRUE : FALSE);
    }
    else if (arRequest == AR_HTTP_END_SEND_REQUEST)
    {
        pRequest->SetReceiveResponseState(TRUE);

        // Previously this would be a case where WinHttpReceiveResponse did
        // not need to be called.  Now, in this case, simply return whether or
        // not we've reached the object data state.
        if (!pRequest->CheckWriteDataNeeded())
        {
            // Nothing needs to be queued, so let the original send request fsm
            // complete, if needed, and indicate the current state.
            if (!isAsync ||
                    ((pRequest->GetState() & 0x0F) >=
                     (HttpRequestStateObjectData & 0x0F)))
            {  
                error = ERROR_SUCCESS;
                goto quit;
            }
            else
            {
                // Async sendrequest is still pending, so there's no need to
                // create another fsm.  This call isn't async, so leave deref
                // set to TRUE.
                error = ERROR_IO_PENDING;
                goto quit;
            }
        }
    }


    //
    // send the request to the server. This may involve redirections and user
    // authentication
    //

    //error = DoFsm(New CFsm_HttpSendRequest(lpOptional, dwOptionalLength, pRequest, arRequest));
    //if (error == ERROR_IO_PENDING) {
    //    bDeref = FALSE;
    //}
    CFsm_HttpSendRequest * pFsm;

    pFsm = New CFsm_HttpSendRequest(lpOptional, dwOptionalLength, pRequest, arRequest);

    if (pFsm != NULL)
    {
        if (isAsync && !lpThreadInfo->IsAsyncWorkerThread)
        {
            error = DoAsyncFsm(pFsm, pRequest);
        }
        else
        {
            pFsm->SetPushPop(TRUE);
            pFsm->Push();
            error = DoFsm(pFsm);
        }
        if (error == ERROR_IO_PENDING)
        {
            bDeref = FALSE;
        }
    }
    else
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

quit:

    //
    // if we went async don't deref the handle
    //

    if (bDeref && (hRequestMapped != NULL)) {
        DereferenceObject((LPVOID)hRequestMapped);
    }

done:

    BOOL success = TRUE;

    // SetLastError must be called after PERF_LEAVE !!!
    PERF_LEAVE(HttpWrapSendRequest);

    if (error != ERROR_SUCCESS) {

        SetLastError(error);
        DEBUG_ERROR(HTTP, error);
        success = FALSE;
    }

    DEBUG_LEAVE(success);
    return success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\auth\auth.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    auth.h

Abstract:

    Private include file for 

Author:

    Rajeev Dujari (rajeevd) 28-Jul-97
    
Revision History:

--*/

//
// manifests
//
 
#define HTTP_AUTHORIZATION_SZ           "Authorization:"
#define HTTP_AUTHORIZATION_LEN          (sizeof(HTTP_AUTHORIZATION_SZ)-1)

#define HTTP_PROXY_AUTHORIZATION_SZ     "Proxy-Authorization:"
#define HTTP_PROXY_AUTHORIZATION_LEN    (sizeof(HTTP_PROXY_AUTHORIZATION_SZ)-1)


//
// prototypes - versions of spluginx.hxx for basic auth
//


void UrlZonesDetach (void);

//#ifdef __cplusplus
//extern "C" {
//#endif

extern DWORD g_cSspiContexts; // refcount of sspi contexts

DWORD SSPI_Unload();

DWORD_PTR SSPI_InitScheme (LPCSTR pszScheme);

//#ifdef __cplusplus
//} // end extern "C" {
//#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\api\thrdinfo.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    thrdinfo.cxx

Abstract:

    Functions to manipulate an INTERNET_THREAD_INFO

    Contents:
        InternetCreateThreadInfo
        InternetDestroyThreadInfo
        InternetTerminateThreadInfo
        InternetGetThreadInfo
        InternetSetThreadInfo
        InternetIndicateStatusAddress
        InternetIndicateStatusString
        InternetIndicateStatusNewHandle
        InternetIndicateStatus
        InternetSetLastError
        _InternetSetLastError
        InternetLockErrorText
        InternetUnlockErrorText
        InternetSetObjectHandle
        InternetGetObjectHandle
        InternetFreeThreadInfo

Author:

    Richard L Firth (rfirth) 16-Feb-1995

Environment:

    Win32 user-level DLL

Revision History:

    16-Feb-1995 rfirth
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

//
// manifests
//

#define BAD_TLS_INDEX   0xffffffff  // according to online win32 SDK documentation
#ifdef SPX_SUPPORT
#define GENERIC_SPX_NAME   "SPX Server"
#endif //SPX_SUPPORT
//
// macros
//

#ifdef ENABLE_DEBUG

#define InitializeInternetThreadInfo(lpThreadInfo) \
    InitializeListHead(&lpThreadInfo->List); \
    lpThreadInfo->Signature = INTERNET_THREAD_INFO_SIGNATURE; \
    lpThreadInfo->ThreadId = GetCurrentThreadId();

#else

#define InitializeInternetThreadInfo(threadInfo) \
    InitializeListHead(&lpThreadInfo->List); \
    lpThreadInfo->ThreadId = GetCurrentThreadId();

#endif // ENABLE_DEBUG

//
// private data
//

PRIVATE DWORD InternetTlsIndex = BAD_TLS_INDEX;
PRIVATE SERIALIZED_LIST ThreadInfoList;



LPINTERNET_THREAD_INFO
InternetCreateThreadInfo(
    IN BOOL SetTls
    )

/*++

Routine Description:

    Creates, initializes an INTERNET_THREAD_INFO. Optionally (allocates and)
    sets this thread's Internet TLS

    Assumes: 1. The first time this function is called is in the context of the
                process attach library call, so we allocate the TLS index once

Arguments:

    SetTls  - TRUE if we are to set the INTERNET_THREAD_INFO TLS for this thread

Return Value:

    LPINTERNET_THREAD_INFO
        Success - pointer to allocated INTERNET_THREAD_INFO structure which has
                  been set as this threads value in its InternetTlsIndex slot

        Failure - NULL

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo = NULL;
    BOOL ok = FALSE;

    if (InDllCleanup) {
        goto quit;
    }
    if (InternetTlsIndex == BAD_TLS_INDEX) {

        //
        // first time through, initialize serialized list
        //

        InitializeSerializedList(&ThreadInfoList);

        //
        // we assume that if we are allocating the TLS index, then this is the
        // one and only thread in this process that can call into this DLL
        // right now - i.e. this thread is loading the DLL
        //

        InternetTlsIndex = TlsAlloc();
    }
    if (InternetTlsIndex != BAD_TLS_INDEX) {
        lpThreadInfo = NEW(INTERNET_THREAD_INFO);
        if (lpThreadInfo != NULL) {
            InitializeInternetThreadInfo(lpThreadInfo);
            if (SetTls) {
                ok = TlsSetValue(InternetTlsIndex, (LPVOID)lpThreadInfo);
                if (!ok) {

                    DEBUG_PUT(("InternetCreateThreadInfo(): TlsSetValue(%d, %#x) returns %d\n",
                             InternetTlsIndex,
                             lpThreadInfo,
                             GetLastError()
                             ));

                    DEBUG_BREAK(THRDINFO);

                }
            } else {
                ok = TRUE;
            }
        } else {

            DEBUG_PUT(("InternetCreateThreadInfo(): NEW(INTERNET_THREAD_INFO) returned NULL\n"));

            DEBUG_BREAK(THRDINFO);

        }
    } else {

        DEBUG_PUT(("InternetCreateThreadInfo(): TlsAlloc() returns %#x, error %d\n",
                 BAD_TLS_INDEX,
                 GetLastError()
                 ));

        DEBUG_BREAK(THRDINFO);
    }
    if (ok) {
        if (!InsertAtHeadOfSerializedList(&ThreadInfoList, &lpThreadInfo->List)) {
            DEL(lpThreadInfo);
            lpThreadInfo = NULL;

            if (InternetTlsIndex != BAD_TLS_INDEX) {
                TlsFree(InternetTlsIndex);
                InternetTlsIndex = BAD_TLS_INDEX;
            }
        }
    } else {
        if (lpThreadInfo != NULL) {
            DEL(lpThreadInfo);
            lpThreadInfo = NULL;
        }
        if (InternetTlsIndex != BAD_TLS_INDEX) {
            TlsFree(InternetTlsIndex);
            InternetTlsIndex = BAD_TLS_INDEX;
        }
    }

quit:

    return lpThreadInfo;
}


VOID
InternetDestroyThreadInfo(
    VOID
    )

/*++

Routine Description:

    Cleans up the INTERNET_THREAD_INFO - deletes any memory it owns and deletes
    it

Arguments:

    None.

Return Value:

    None.

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;

    IF_DEBUG(NOTHING) {
        DEBUG_PUT(("InternetDestroyThreadInfo(): Thread %#x: Deleting INTERNET_THREAD_INFO\n",
                    GetCurrentThreadId()
                    ));
    }

    //
    // don't call InternetGetThreadInfo() - we don't need to create the
    // INTERNET_THREAD_INFO if it doesn't exist in this case
    //

    lpThreadInfo = (LPINTERNET_THREAD_INFO)TlsGetValue(InternetTlsIndex);
    if (lpThreadInfo != NULL) {

#if INET_DEBUG

        //
        // there shouldn't be anything in the debug record stack. On Win95, we
        // ignore this check if this is the async scheduler (nee worker) thread
        // AND there are entries in the debug record stack. The async thread
        // gets killed off before it has chance to DEBUG_LEAVE, then comes here,
        // causing this assert to be over-active
        //

        if (IsPlatformWin95() && lpThreadInfo->IsAsyncWorkerThread) {
            if (lpThreadInfo->CallDepth != 0) {

                DEBUG_PUT(("InternetDestroyThreadInfo(): "
                            "Thread %#x: "
                            "%d records in debug stack\n",
                            lpThreadInfo->CallDepth
                            ));
            }
        } else {

            INET_ASSERT(lpThreadInfo->Stack == NULL);

        }

#endif // INET_DEBUG

        InternetFreeThreadInfo(lpThreadInfo);

        INET_ASSERT(InternetTlsIndex != BAD_TLS_INDEX);

        TlsSetValue(InternetTlsIndex, NULL);
    } else {

        DEBUG_PUT(("InternetDestroyThreadInfo(): Thread %#x: no INTERNET_THREAD_INFO\n",
                    GetCurrentThreadId()
                    ));

    }
}


VOID
InternetFreeThreadInfo(
    IN LPINTERNET_THREAD_INFO lpThreadInfo
    )

/*++

Routine Description:

    Removes the INTERNET_THREAD_INFO from the list and frees all allocated
    blocks

Arguments:

    lpThreadInfo    - pointer to INTERNET_THREAD_INFO to remove and free

Return Value:

    None.

--*/

{
    if (RemoveFromSerializedList(&ThreadInfoList, &lpThreadInfo->List)) {

        if (lpThreadInfo->hErrorText != NULL) {
            FREE_MEMORY(lpThreadInfo->hErrorText);
        }

        //if (lpThreadInfo->lpResolverInfo != NULL) {
        //    if (lpThreadInfo->lpResolverInfo->DnrSocketHandle != NULL) {
        //        lpThreadInfo->lpResolverInfo->DnrSocketHandle->Dereference();
        //    }
        //    DEL(lpThreadInfo->lpResolverInfo);
        //}

        DEL(lpThreadInfo);
    }
}


VOID
InternetTerminateThreadInfo(
    VOID
    )

/*++

Routine Description:

    Destroy all INTERNET_THREAD_INFO structures and terminate the serialized
    list. This funciton called at process detach time.

    At DLL_PROCESS_DETACH time, there may be other threads in the process for
    which we created an INTERNET_THREAD_INFO that aren't going to get the chance
    to delete the structure, so we do it here.

    Code in this module assumes that it is impossible for a new thread to enter
    this DLL while we are terminating in DLL_PROCESS_DETACH

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // get rid of this thread's info structure. No more debug output after this!
    //

    InternetDestroyThreadInfo();

    //
    // get rid of the thread info structures left by other threads
    //

    if (LockSerializedList(&ThreadInfoList))
    {
        LPINTERNET_THREAD_INFO lpThreadInfo;

        while (lpThreadInfo = (LPINTERNET_THREAD_INFO)SlDequeueHead(&ThreadInfoList)) {

            //
            // already dequeued, no need to call InternetFreeThreadInfo()
            //

            FREE_MEMORY(lpThreadInfo);
        }

        UnlockSerializedList(&ThreadInfoList);
    }

    //
    // no more need for list
    //

    TerminateSerializedList(&ThreadInfoList);

    //
    // or TLS index
    //

    TlsFree(InternetTlsIndex);
    InternetTlsIndex = BAD_TLS_INDEX;
}


LPINTERNET_THREAD_INFO
InternetGetThreadInfo(
    VOID
    )

/*++

Routine Description:

    Gets the pointer to the INTERNET_THREAD_INFO for this thread and checks
    that it still looks good.

    If this thread does not have an INTERNET_THREAD_INFO then we create one,
    presuming that this is a new thread

Arguments:

    None.

Return Value:

    LPINTERNET_THREAD_INFO
        Success - pointer to INTERNET_THREAD_INFO block

        Failure - NULL

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo = NULL;
    DWORD lastError;

    //
    // this is pretty bad - TlsGetValue() can destroy the per-thread last error
    // variable if it returns NULL (to indicate that NULL was actually set, and
    // that NULL does not indicate an error). So we have to read it before it is
    // potentially destroyed, and reset it before we quit.
    //
    // We do this here because typically, other functions will be completely
    // unsuspecting of this behaviour, and it is better to fix it once here,
    // than in several dozen other places, even though it is slightly
    // inefficient
    //

    lastError = GetLastError();
    if (InternetTlsIndex != BAD_TLS_INDEX) {
        lpThreadInfo = (LPINTERNET_THREAD_INFO)TlsGetValue(InternetTlsIndex);
    }

    //
    // we may be in the process of creating the INTERNET_THREAD_INFO, in
    // which case its okay for this to be NULL. According to online SDK
    // documentation, a threads TLS value will be initialized to NULL
    //

    if (lpThreadInfo == NULL) {

        //
        // we presume this is a new thread. Create an INTERNET_THREAD_INFO
        //

        IF_DEBUG(NOTHING) {
            DEBUG_PUT(("InternetGetThreadInfo(): Thread %#x: Creating INTERNET_THREAD_INFO\n",
                      GetCurrentThreadId()
                      ));
        }

        lpThreadInfo = InternetCreateThreadInfo(TRUE);
    }
    if (lpThreadInfo != NULL) {

        INET_ASSERT(lpThreadInfo->Signature == INTERNET_THREAD_INFO_SIGNATURE);
        INET_ASSERT(lpThreadInfo->ThreadId == GetCurrentThreadId());

    } else {

        DEBUG_PUT(("InternetGetThreadInfo(): Failed to get/create INTERNET_THREAD_INFO\n"));

    }

    //
    // as above - reset the last error variable in case TlsGetValue() trashed it
    //

    SetLastError(lastError);

    //
    // actual success/failure indicated by non-NULL/NULL pointer resp.
    //

    return lpThreadInfo;
}


VOID
InternetSetThreadInfo(
    IN LPINTERNET_THREAD_INFO lpThreadInfo
    )

/*++

Routine Description:

    Sets lpThreadInfo as the current thread's INTERNET_THREAD_INFO. Used within
    fibers

Arguments:

    lpThreadInfo    - new INTERNET_THREAD_INFO to set

Return Value:

    None.

--*/

{
    if (InternetTlsIndex != BAD_TLS_INDEX) {
        if (!TlsSetValue(InternetTlsIndex, (LPVOID)lpThreadInfo)) {

            DEBUG_PUT(("InternetSetThreadInfo(): TlsSetValue(%d, %#x) returns %d\n",
                     InternetTlsIndex,
                     lpThreadInfo,
                     GetLastError()
                     ));

            INET_ASSERT(FALSE);

        }
    } else {

        DEBUG_PUT(("InternetSetThreadInfo(): InternetTlsIndex = %d\n",
                 InternetTlsIndex
                 ));

        INET_ASSERT(FALSE);
    }
}


DWORD
InternetIndicateStatusAddress(
    IN DWORD dwInternetStatus,
    IN LPSOCKADDR lpSockAddr,
    IN DWORD dwSockAddrLength
    )

/*++

Routine Description:

    Make a status callback to the app. The data is a network address that we
    need to convert to a string

Arguments:

    dwInternetStatus    - WINHTTP_CALLBACK_STATUS_ value

    lpSockAddr          - pointer to full socket address

    dwSockAddrLength    - length of lpSockAddr in bytes

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_OPERATION_CANCELLED
                    The app closed the object handle during the callback

--*/

{
    LPSTR lpAddress;

    INET_ASSERT(lpSockAddr != NULL);

    switch (lpSockAddr->sa_family) 
    {
    case AF_INET:
        lpAddress = _I_inet_ntoa(
                        ((struct sockaddr_in*)lpSockAddr)->sin_addr
                        );
        break;

    case AF_IPX:

        //
        // BUGBUG - this should be a call to WSAAddressToString, but that's not implemented yet
        //
#ifdef SPX_SUPPORT
        lpAddress = GENERIC_SPX_NAME;
#else
        lpAddress = NULL;
#endif //SPX_SUPPORT
        break;

    default:
        lpAddress = NULL;
        break;
    }
    // we don't want a client to mess around with a winsock-internal buffer
    return InternetIndicateStatusString(dwInternetStatus, lpAddress, TRUE/*bCopyBuffer*/);
}


DWORD
InternetIndicateStatusString(
    IN DWORD dwInternetStatus,
    IN LPSTR lpszStatusInfo OPTIONAL,
    IN BOOL  bCopyBuffer,
    IN BOOL  bConvertToUnicode
    )

/*++

Routine Description:

    Make a status callback to the app. The data is a string

Arguments:

    dwInternetStatus    - WINHTTP_CALLBACK_STATUS_ value

    lpszStatusInfo      - string status data

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_OPERATION_CANCELLED
                    The app closed the object handle during the callback

--*/

{
    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "InternetIndicateStatusString",
                "%d, %q",
                dwInternetStatus,
                lpszStatusInfo
                ));

    DWORD length;

    if (ARGUMENT_PRESENT(lpszStatusInfo)) 
    {
        length = strlen(lpszStatusInfo) + 1;
    } 
    else 
    {
        length = 0;
    }

    DWORD error;

    error = InternetIndicateStatus(dwInternetStatus, lpszStatusInfo, length, bCopyBuffer, bConvertToUnicode);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
InternetIndicateStatusNewHandle(
    IN LPVOID hInternetMapped
    )

/*++

Routine Description:

    Indicates to the app a new handle

Arguments:

    hInternetMapped - mapped address of new handle being indicated

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_OPERATION_CANCELLED
                    The app closed the either the new object handle or the
                    parent object handle during the callback

--*/

{
    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "InternetIndicateStatusNewHandle",
                "%#x",
                hInternetMapped
                ));

    HANDLE_OBJECT * hObject = (HANDLE_OBJECT *)hInternetMapped;

    //
    // reference the new request handle, in case the app closes it in the
    // callback. The new handle now has a reference count of 2
    //

    hObject->Reference();

    INET_ASSERT(hObject->ReferenceCount() == 2);

    //
    // we indicate the pseudo handle to the app
    //

    HINTERNET hInternet = hObject->GetPseudoHandle();

    DWORD error = InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_HANDLE_CREATED,
                                         (LPVOID)&hInternet,
                                         sizeof(hInternet)
                                         );

    //
    // dereference the new request handle. If this returns TRUE then the new
    // handle has been deleted (the app called InternetCloseHandle() against
    // it which dereferenced it to 1, and now we've dereferenced it to zero)
    //

    if (hObject->Dereference()) 
    {
        error = ERROR_WINHTTP_OPERATION_CANCELLED;
    } 
    else if (error == ERROR_WINHTTP_OPERATION_CANCELLED) 
    {

        //
        // the parent handle was deleted. Kill off the new handle too
        //

        BOOL ok;

        ok = hObject->Dereference();

        INET_ASSERT(ok);

    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
InternetIndicateStatus(
    IN DWORD dwStatus,
    IN LPVOID lpBuffer,
    IN DWORD dwLength,
    IN BOOL bCopyBuffer,
    IN BOOL bConvertToUnicode
    )

/*++

Routine Description:

    If the app has registered a callback function for the object that this
    thread is operating on, call it with the arguments supplied

Arguments:

    dwStatus    - WINHTTP_CALLBACK_STATUS_ value

    lpBuffer    - pointer to variable data buffer

    dwLength    - length of *lpBuffer in bytes

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_OPERATION_CANCELLED
                    The app closed the object handle during the callback

--*/

{
    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "InternetIndicateStatus",
                "%s, %#x, %d",
                InternetMapStatus(dwStatus),
                lpBuffer,
                dwLength
                ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error = ERROR_SUCCESS;

    //
    // the app can affect callback operation by specifying a zero context value
    // meaning no callbacks will be generated for this API
    //

    if (lpThreadInfo != NULL) 
    {

        INET_ASSERT(lpThreadInfo->hObject != NULL);
        INET_ASSERT(lpThreadInfo->hObjectMapped != NULL);

        //
        // if the context value in the thread info block is 0 then we use the
        // context from the handle object
        //

        DWORD_PTR context;

        context = ((INTERNET_HANDLE_BASE *)lpThreadInfo->hObjectMapped)->GetContext();

        WINHTTP_STATUS_CALLBACK appCallback;

        appCallback = ((INTERNET_HANDLE_BASE *)lpThreadInfo->hObjectMapped)->GetStatusCallback();

        IF_DEBUG(THRDINFO) 
        {
            switch (dwStatus) 
            {
                case WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE:
                case WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE:
                case WINHTTP_CALLBACK_STATUS_REQUEST_ERROR:
                    DEBUG_PRINT(THRDINFO,
                                INFO,
                                ("%s: dwResult = %#x, dwError = %d [%s]\n",
                                InternetMapStatus(dwStatus),
                                ((LPWINHTTP_ASYNC_RESULT)lpBuffer)->dwError,
                                InternetMapError(((LPWINHTTP_ASYNC_RESULT)lpBuffer)->dwError)
                                ));
                    break;
                case WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE:
                case WINHTTP_CALLBACK_STATUS_READ_COMPLETE:
                    DEBUG_PRINT(THRDINFO,
                                INFO,
                                ("%s: Buffer = %p, Number of bytes = %d\n",
                                InternetMapStatus(dwStatus),
                                lpBuffer,
                                dwLength
                                ));
                    break;
            }

        }

        if ((appCallback != NULL) &&
            (((INTERNET_HANDLE_BASE *)lpThreadInfo->hObjectMapped)->IsNotificationEnabled(dwStatus)) )
        {
            LPVOID pInfo; //reported thru callback
            DWORD infoLength; //reported thru callback
            BOOL isAsyncWorkerThread;
            BYTE buffer[256];

            //
            // we make a copy of the info to remove the app's opportunity to
            // change it. E.g. if we were about to resolve host name "foo" and
            // passed the pointer to our buffer containing "foo", the app could
            // change the name to "bar", changing the intended server
            //

            if (lpBuffer != NULL) 
            {
                if (bConvertToUnicode)
                {
                    INET_ASSERT( ((INTERNET_HANDLE_BASE *)lpThreadInfo->hObjectMapped)->IsUnicodeStatusCallback() );

                    INET_ASSERT(    
                        (dwStatus == WINHTTP_CALLBACK_STATUS_RESOLVING_NAME)        || 
                        (dwStatus == WINHTTP_CALLBACK_STATUS_NAME_RESOLVED)         ||
                        (dwStatus == WINHTTP_CALLBACK_STATUS_REDIRECT)              ||
                        (dwStatus == WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER)  ||
                        (dwStatus == WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER)
                        );
                        
                    infoLength = MultiByteToWideChar(CP_ACP, 0, (LPSTR)lpBuffer,
                                                                dwLength, NULL, 0);
                    if (infoLength == 0)
                    {
                        pInfo = NULL;
                                
                        DEBUG_PRINT(THRDINFO,
                                    ERROR,
                                    ("MultiByteToWideChar returned 0 for a %d-length MBCS string\n",
                                    dwLength
                                    ));
                    }
                    else if (infoLength <= sizeof(buffer)/sizeof(WCHAR))
                    {
                        pInfo = buffer;
                    }
                    else
                    {
                        pInfo = (LPVOID)ALLOCATE_FIXED_MEMORY(infoLength * sizeof(WCHAR));
                    }
                    
                    if (pInfo)
                    {
                        infoLength = MultiByteToWideChar(CP_ACP, 0, (LPSTR)lpBuffer, 
                                                                dwLength, (LPWSTR)pInfo, infoLength);
                        if (infoLength == 0)
                        {
                            //MBtoWC failed
                            if (pInfo != buffer)
                                FREE_FIXED_MEMORY(pInfo);
                            pInfo = NULL;
                                
                            DEBUG_PRINT(THRDINFO,
                                        ERROR,
                                        ("MultiByteToWideChar returned 0 for a %d-length MBCS string\n",
                                        dwLength
                                        ));
                        }
                    } //pInfo
                    else
                    {
                        infoLength = 0;

                        DEBUG_PRINT(THRDINFO,
                                    ERROR,
                                    ("MultiByteToWideChar() error OR Failed to allocate %d bytes for info\n",
                                    dwLength
                                    ));

                    } //pInfo == NULL
                } //bConvertToUnicode
                else if (bCopyBuffer)
                {
                    if (dwLength <= sizeof(buffer))
                        pInfo = buffer;
                    else
                        pInfo = (LPVOID)ALLOCATE_FIXED_MEMORY(dwLength);

                    if (pInfo)
                    {
                        memcpy(pInfo, lpBuffer, dwLength);
                        infoLength = dwLength;
                    }
                    else 
                    {
                        infoLength = 0;

                        DEBUG_PRINT(THRDINFO,
                                    ERROR,
                                    ("Failed to allocate %d bytes for info\n",
                                    dwLength
                                    ));

                    }
                } //bCopyBuffer
                else
                {
                    pInfo = lpBuffer;
                    infoLength = dwLength;

                    INET_ASSERT(dwLength);
                } //!bCopyBuffer && !bConvertToUnicode
            } //lpBuffer != NULL
            else 
            {
                pInfo = NULL;
                infoLength = 0;
            }

            //
            // we're about to call into the app. We may be in the context of an
            // async worker thread, and if the callback submits an async request
            // then we'll execute it synchronously. To avoid this, we will reset
            // the async worker thread indicator in the INTERNET_THREAD_INFO and
            // restore it when the app returns control to us. This way, if the
            // app makes an API request during the callback, on a handle that
            // has async I/O semantics, then we will simply queue it, and not
            // try to execute it synchronously
            //

            isAsyncWorkerThread = lpThreadInfo->IsAsyncWorkerThread;
            lpThreadInfo->IsAsyncWorkerThread = FALSE;

            BOOL bInCallback = lpThreadInfo->InCallback;

            lpThreadInfo->InCallback = TRUE;

            INET_ASSERT(!IsBadCodePtr((FARPROC)appCallback));

            DEBUG_ENTER((DBG_THRDINFO,
                         None,
                         "(*callback)",
                         "%#x, %#x, %s (%d), %#x [%#x], %d",
                         lpThreadInfo->hObject,
                         context,
                         InternetMapStatus(dwStatus),
                         dwStatus,
                         pInfo,
                         ((dwStatus == WINHTTP_CALLBACK_STATUS_HANDLE_CREATED)
                         || (dwStatus == WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING))
                            ? (DWORD_PTR)*(LPHINTERNET)pInfo
                            : (((dwStatus == WINHTTP_CALLBACK_STATUS_REQUEST_SENT)
                            || (dwStatus == WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED)
                            || (dwStatus == WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE))
                                ? *(LPDWORD)pInfo
                                : 0),
                         infoLength
                         ));

            PERF_LOG(PE_APP_CALLBACK_START,
                     dwStatus,
                     lpThreadInfo->ThreadId,
                     lpThreadInfo->hObject
                     );

            HINTERNET hObject = lpThreadInfo->hObject;
            LPVOID hObjectMapped = lpThreadInfo->hObjectMapped;

            appCallback(lpThreadInfo->hObject,
                        context,
                        dwStatus,
                        pInfo,
                        infoLength
                        );

            lpThreadInfo->hObject = hObject;
            lpThreadInfo->hObjectMapped = hObjectMapped;

            PERF_LOG(PE_APP_CALLBACK_END,
                     dwStatus,
                     lpThreadInfo->ThreadId,
                     lpThreadInfo->hObject
                     );

            DEBUG_LEAVE(0);

            lpThreadInfo->InCallback = bInCallback;
            lpThreadInfo->IsAsyncWorkerThread = isAsyncWorkerThread;

            //
            // free the buffer
            //

            // We should free the memory only if we have done an ALLOCATE_FIXED_MEMORY in this function:
            if (pInfo != NULL && pInfo != lpBuffer && pInfo != buffer) {
                FREE_FIXED_MEMORY(pInfo);
            }
        } else {

            DEBUG_PRINT(THRDINFO,
                        ERROR,
                        ("%#x: callback = %#x, context = %#x\n",
                        lpThreadInfo->hObject,
                        appCallback,
                        context
                        ));

            //
            // if we're completing a request then we shouldn't be here - it
            // means we lost the context or callback address somewhere along the
            // way
            //

            // don't need the ASSERTS below.
            // It could also mean something as benign as the notification not being enabled:
            /*
            INET_ASSERT(
                    dwStatus != WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE
                &&  dwStatus != WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE
                &&  dwStatus != WINHTTP_CALLBACK_STATUS_REQUEST_ERROR
                &&  dwStatus != WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE
                &&  dwStatus != WINHTTP_CALLBACK_STATUS_READ_COMPLETE
                );
            */

#ifdef DEBUG
            if ( 
                    dwStatus == WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE
                ||  dwStatus == WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE
                ||  dwStatus == WINHTTP_CALLBACK_STATUS_REQUEST_ERROR
                ||  dwStatus == WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE
                ||  dwStatus == WINHTTP_CALLBACK_STATUS_READ_COMPLETE
            )
            {
                INET_ASSERT(appCallback != NULL);
                /*
                    These are not valid asserts in winhttp.
                    Contexts don't control whether callbacks are made or not.
                 */
                //INET_ASSERT(context != NULL);
                //INET_ASSERT(_InternetGetContext(lpThreadInfo) != NULL);
            }
#endif


        }
        
        //
        // if the object is now invalid then the app closed the handle in
        // the callback, or from an external thread and the entire operation is cancelled
        // propagate this error back to calling code.
        //
        if (((HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->IsInvalidated()) 
        {
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
        }
    } else {

        //
        // this is catastrophic if the indication was async request completion
        //

        DEBUG_PUT(("InternetIndicateStatus(): no INTERNET_THREAD_INFO?\n"));

    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
InternetSetLastError(
    IN DWORD ErrorNumber,
    IN LPSTR ErrorText,
    IN DWORD ErrorTextLength,
    IN DWORD Flags
    )

/*++

Routine Description:

    Copies the error text to the per-thread error buffer (moveable memory)

Arguments:

    ErrorNumber     - protocol-specific error code

    ErrorText       - protocol-specific error text (from server). The buffer is
                      NOT zero-terminated

    ErrorTextLength - number of characters in ErrorText

    Flags           - Flags that control how this function operates:

                        SLE_APPEND          TRUE if ErrorText is to be appended
                                            to the text already in the buffer

                        SLE_ZERO_TERMINATE  TRUE if ErrorText must have a '\0'
                                            appended to it

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - Win32 error

--*/

{
    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "InternetSetLastError",
                "%d, %.80q, %d, %#x",
                ErrorNumber,
                ErrorText,
                ErrorTextLength,
                Flags
                ));

    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo != NULL) {
        error = _InternetSetLastError(lpThreadInfo,
                                      ErrorNumber,
                                      ErrorText,
                                      ErrorTextLength,
                                      Flags
                                      );
    } else {

        DEBUG_PUT(("InternetSetLastError(): no INTERNET_THREAD_INFO\n"));

        error = ERROR_WINHTTP_INTERNAL_ERROR;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
_InternetSetLastError(
    IN LPINTERNET_THREAD_INFO lpThreadInfo,
    IN DWORD ErrorNumber,
    IN LPSTR ErrorText,
    IN DWORD ErrorTextLength,
    IN DWORD Flags
    )

/*++

Routine Description:

    Sets or resets the last error text in an INTERNET_THREAD_INFO block

Arguments:

    lpThreadInfo    - pointer to INTERNET_THREAD_INFO

    ErrorNumber     - protocol-specific error code

    ErrorText       - protocol-specific error text (from server). The buffer is
                      NOT zero-terminated

    ErrorTextLength - number of characters in ErrorText

    Flags           - Flags that control how this function operates:

                        SLE_APPEND          TRUE if ErrorText is to be appended
                                            to the text already in the buffer

                        SLE_ZERO_TERMINATE  TRUE if ErrorText must have a '\0'
                                            appended to it

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - Win32 error

--*/

{
    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "_InternetSetLastError",
                "%#x, %d, %.80q, %d, %#x",
                lpThreadInfo,
                ErrorNumber,
                ErrorText,
                ErrorTextLength,
                Flags
                ));

    DWORD currentLength;
    DWORD newTextLength;
    DWORD error;

    newTextLength = ErrorTextLength;

    //
    // if we are appending text, then account for the '\0' currently at the end
    // of the buffer (if it exists)
    //

    if (Flags & SLE_APPEND) {
        currentLength = lpThreadInfo->ErrorTextLength;
        if (currentLength != 0) {
            --currentLength;
        }
        newTextLength += currentLength;
    }

    if (Flags & SLE_ZERO_TERMINATE) {
        ++newTextLength;
    }

    //
    // expect success (and why not?)
    //

    error = ERROR_SUCCESS;

    //
    // allocate, grow or shrink the buffer to fit. The buffer is moveable. If
    // the buffer is being shrunk to zero size then NULL will be returned as
    // the buffer handle from ResizeBuffer()
    //

    lpThreadInfo->hErrorText = ResizeBuffer(lpThreadInfo->hErrorText,
                                            newTextLength,
                                            FALSE
                                            );
    if (lpThreadInfo->hErrorText != NULL) {

        LPSTR lpErrorText;

        lpErrorText = (LPSTR)LOCK_MEMORY(lpThreadInfo->hErrorText);

        INET_ASSERT(lpErrorText != NULL);

        if (lpErrorText != NULL) {
            if (Flags & SLE_APPEND) {
                lpErrorText += currentLength;
            }
            memcpy(lpErrorText, ErrorText, ErrorTextLength);
            if (Flags & SLE_ZERO_TERMINATE) {
                lpErrorText[ErrorTextLength++] = '\0';
            }

            //
            // the text should always be zero-terminated. We expect this in
            // InternetGetLastResponseInfo()
            //

            INET_ASSERT(lpErrorText[ErrorTextLength - 1] == '\0');

            UNLOCK_MEMORY(lpThreadInfo->hErrorText);

        } else {

            //
            // real error occurred - failed to lock memory?
            //

            error = GetLastError();
        }
    } else {

        INET_ASSERT(newTextLength == 0);

        newTextLength = 0;
    }

    //
    // set the error code and text length
    //

    lpThreadInfo->ErrorTextLength = newTextLength;
    lpThreadInfo->ErrorNumber = ErrorNumber;

    DEBUG_LEAVE(error);

    return error;
}


LPSTR
InternetLockErrorText(
    VOID
    )

/*++

Routine Description:

    Returns a pointer to the locked per-thread error text buffer

Arguments:

    None.

Return Value:

    LPSTR
        Success - pointer to locked buffer

        Failure - NULL

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo != NULL) {

        HLOCAL lpErrorText;

        lpErrorText = lpThreadInfo->hErrorText;
        if (lpErrorText != (HLOCAL)NULL) {
            return (LPSTR)LOCK_MEMORY(lpErrorText);
        }
    }
    return NULL;
}

//
//VOID
//InternetUnlockErrorText(
//    VOID
//    )
//
///*++
//
//Routine Description:
//
//    Unlocks the per-thread error text buffer locked by InternetLockErrorText()
//
//Arguments:
//
//    None.
//
//Return Value:
//
//    None.
//
//--*/
//
//{
//    LPINTERNET_THREAD_INFO lpThreadInfo;
//
//    lpThreadInfo = InternetGetThreadInfo();
//
//    //
//    // assume that if we locked the error text, there must be an
//    // INTERNET_THREAD_INFO when we come to unlock it
//    //
//
//    INET_ASSERT(lpThreadInfo != NULL);
//
//    if (lpThreadInfo != NULL) {
//
//        HLOCAL hErrorText;
//
//        hErrorText = lpThreadInfo->hErrorText;
//
//        //
//        // similarly, there must be a handle to the error text buffer
//        //
//
//        INET_ASSERT(hErrorText != NULL);
//
//        if (hErrorText != (HLOCAL)NULL) {
//            UNLOCK_MEMORY(hErrorText);
//        }
//    }
//}


VOID
InternetSetObjectHandle(
    IN HINTERNET hInternet,
    IN HINTERNET hInternetMapped
    )

/*++

Routine Description:

    Sets the hObject field in the INTERNET_THREAD_INFO structure so we can get
    at the handle contents, even when we're in a function that does not take
    the hInternet as a parameter

Arguments:

    hInternet       - handle of object we may need info from

    hInternetMapped - mapped handle of object we may need info from

Return Value:

    None.

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo != NULL) {
        _InternetSetObjectHandle(lpThreadInfo, hInternet, hInternetMapped);
    }
}


HINTERNET
InternetGetObjectHandle(
    VOID
    )

/*++

Routine Description:

    Just returns the hObject value stored in our INTERNET_THREAD_INFO

Arguments:

    None.

Return Value:

    HINTERNET
        Success - non-NULL handle value

        Failure - NULL object handle (may not have been set)

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;
    HINTERNET hInternet;

    lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo != NULL) {
        hInternet = lpThreadInfo->hObject;
    } else {
        hInternet = NULL;
    }
    return hInternet;
}


HINTERNET
InternetGetMappedObjectHandle(
    VOID
    )

/*++

Routine Description:

    Just returns the hObjectMapped value stored in our INTERNET_THREAD_INFO

Arguments:

    None.

Return Value:

    HINTERNET
        Success - non-NULL handle value

        Failure - NULL object handle (may not have been set)

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;
    HINTERNET hInternet;

    lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo != NULL) {
        hInternet = lpThreadInfo->hObjectMapped;
    } else {
        hInternet = NULL;
    }
    return hInternet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\auth\digest.cxx ===
#include <wininetp.h>
#include <splugin.hxx>
#include <security.h>
#include "auth.h"

#define SSP_SPM_NT_DLL      "security.dll"

#define MAX_SILENT_RETRIES  3
#define OUTPUT_BUFFER_LEN   10000

#define HEADER_IDX          0
#define REALM_IDX           1
#define HOST_IDX            2
#define URL_IDX             3
#define METHOD_IDX          4
#define USER_IDX            5
#define PASS_IDX            6
#define NONCE_IDX           7
#define NC_IDX              8
#define HWND_IDX            9
#define NUM_BUFF            10

#define ISC_MODE_AUTH        0
#define ISC_MODE_PREAUTH     1
#define ISC_MODE_UI          2

struct DIGEST_PKG_DATA
{
    LPSTR szAppCtx;
    LPSTR szUserCtx;
};

/*-----------------------------------------------------------------------------
    DIGEST_CTX
-----------------------------------------------------------------------------*/

// Globals
PSecurityFunctionTable DIGEST_CTX::g_pFuncTbl = NULL;
CredHandle DIGEST_CTX::g_hCred;


/*---------------------------------------------------------------------------
DIGEST_CTX::GetFuncTbl
---------------------------------------------------------------------------*/
VOID DIGEST_CTX::GetFuncTbl()
{
    HINSTANCE hSecLib;
    INIT_SECURITY_INTERFACE addrProcISI = NULL;
    OSVERSIONINFO   VerInfo;

    VerInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

    GetVersionEx (&VerInfo);

    if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        hSecLib = LoadLibrary (SSP_SPM_NT_DLL);
    }
        
    addrProcISI = (INIT_SECURITY_INTERFACE) GetProcAddress(hSecLib, 
                    SECURITY_ENTRYPOINT_ANSI);       
        
    g_pFuncTbl = (*addrProcISI)();
}

/*---------------------------------------------------------------------------
DIGEST_CTX::GetRequestUri
---------------------------------------------------------------------------*/
LPSTR DIGEST_CTX::GetRequestUri()
{
    LPSTR szUrl;
    DWORD cbUrl;

    URL_COMPONENTS sUrl;        

    memset(&sUrl, 0, sizeof(sUrl));
    sUrl.dwStructSize = sizeof(sUrl);
    sUrl.dwHostNameLength = -1; 
    sUrl.dwUrlPathLength = -1; 
    sUrl.dwExtraInfoLength = -1; 

    szUrl = _pRequest->GetURL();

    // Generate request-uri
    if (WinHttpCrackUrlA(szUrl, strlen(szUrl), 0, &sUrl))
    {
        cbUrl = sUrl.dwUrlPathLength;
        szUrl = New CHAR[cbUrl+1];

        if (!szUrl)
        {
            // Alloc failure. Return NULL. We will
            // use _pRequest->GetURL instead.
            return NULL;
        }
    
        memcpy(szUrl, sUrl.lpszUrlPath, cbUrl);
        szUrl[cbUrl] = '\0';
    }
    else
    {
        // ICU failed. Return NULL which
        // will cause _pRequest->GetURL
        // to be used.
        return NULL;
    }

    return szUrl;
}


/*---------------------------------------------------------------------------
DIGEST_CTX::InitSecurityBuffers
---------------------------------------------------------------------------*/
VOID DIGEST_CTX::InitSecurityBuffers(LPSTR szOutBuf, DWORD cbOutBuf,
    LPDWORD pdwSecFlags, DWORD dwISCMode)
{
    // Input Buffer.    
    _SecBuffInDesc.cBuffers = NUM_BUFF;
    _SecBuffInDesc.pBuffers = _SecBuffIn;

    // Set Header
    _SecBuffIn[HEADER_IDX].pvBuffer     = _szData;
    _SecBuffIn[HEADER_IDX].cbBuffer     = _cbData;
    _SecBuffIn[HEADER_IDX].BufferType   = SECBUFFER_TOKEN;
    
    // If credentials are supplied will be set to
    // ISC_REQ_USE_SUPPLIED_CREDS.
    // If prompting for auth dialog will be set to
    // ISC_REQ_PROMPT_FOR_CREDS.
    *pdwSecFlags = 0;
    
    // Set realm if no header, otherwise NULL.
    if (_SecBuffIn[HEADER_IDX].pvBuffer)
    {
        _SecBuffIn[REALM_IDX].pvBuffer  = NULL;
        _SecBuffIn[REALM_IDX].cbBuffer  = 0;
    }
    else
    {
        // We are preauthenticating using the realm
        _SecBuffIn[REALM_IDX].pvBuffer = _pCreds->lpszRealm;
        _SecBuffIn[REALM_IDX].cbBuffer = strlen(_pCreds->lpszRealm);
    }
    
    // Host.
    _SecBuffIn[HOST_IDX].pvBuffer     = _pCreds->lpszHost;
    _SecBuffIn[HOST_IDX].cbBuffer     = strlen(_pCreds->lpszHost);
    _SecBuffIn[HOST_IDX].BufferType   = SECBUFFER_TOKEN;

    
    // Request URI.    
    if (!_szRequestUri)
    {
        _szRequestUri = GetRequestUri();
        if (_szRequestUri)
            _SecBuffIn[URL_IDX].pvBuffer     = _szRequestUri;
        else
            _SecBuffIn[URL_IDX].pvBuffer = _pRequest->GetURL();
    }

    _SecBuffIn[URL_IDX].cbBuffer     = strlen((LPSTR) _SecBuffIn[URL_IDX].pvBuffer);
    _SecBuffIn[URL_IDX].BufferType   = SECBUFFER_TOKEN;


    // HTTP method.
    _SecBuffIn[METHOD_IDX].cbBuffer = 
        MapHttpMethodType(_pRequest->GetMethodType(), (LPCSTR*) &_SecBuffIn[METHOD_IDX].pvBuffer);
    _SecBuffIn[METHOD_IDX].BufferType   = SECBUFFER_TOKEN;

    // User and pass might be provided from Creds entry. Use only if
    // we have a challenge header (we don't pre-auth using supplied creds).
    if (dwISCMode == ISC_MODE_AUTH && _pCreds->lpszUser && *_pCreds->lpszUser 
        && _pCreds->lpszPass && *_pCreds->lpszPass)
    {
        // User.
        _SecBuffIn[USER_IDX].pvBuffer     = _pCreds->lpszUser;
        _SecBuffIn[USER_IDX].cbBuffer     = strlen(_pCreds->lpszUser);
        _SecBuffIn[USER_IDX].BufferType   = SECBUFFER_TOKEN;

        // Pass.
        _SecBuffIn[PASS_IDX].pvBuffer     = _pCreds->lpszPass;
        _SecBuffIn[PASS_IDX].cbBuffer     = strlen(_pCreds->lpszPass);
        _SecBuffIn[PASS_IDX].BufferType   = SECBUFFER_TOKEN;
        *pdwSecFlags = ISC_REQ_USE_SUPPLIED_CREDS;
    }
    else
    {
        // User.
        _SecBuffIn[USER_IDX].pvBuffer     = NULL;  
        _SecBuffIn[USER_IDX].cbBuffer     = 0;
        _SecBuffIn[USER_IDX].BufferType   = SECBUFFER_TOKEN;

        // Pass.
        _SecBuffIn[PASS_IDX].pvBuffer     = NULL;
        _SecBuffIn[PASS_IDX].cbBuffer     = 0;
        _SecBuffIn[PASS_IDX].BufferType   = SECBUFFER_TOKEN;
    }

    if (dwISCMode == ISC_MODE_UI)
        *pdwSecFlags = ISC_REQ_PROMPT_FOR_CREDS;
        
    // Out Buffer.
    _SecBuffOutDesc.cBuffers    = 1;
    _SecBuffOutDesc.pBuffers    = _SecBuffOut;
    _SecBuffOut[0].pvBuffer     = szOutBuf;
    _SecBuffOut[0].cbBuffer     = cbOutBuf;
    _SecBuffOut[0].BufferType   = SECBUFFER_TOKEN;
}


/*---------------------------------------------------------------------------
    Constructor
---------------------------------------------------------------------------*/
DIGEST_CTX::DIGEST_CTX(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy,
                 SPMData *pSPM, AUTH_CREDS* pCreds)
    : AUTHCTX(pSPM, pCreds)
{
    SECURITY_STATUS ssResult;
    _fIsProxy = fIsProxy;
    _pRequest = pRequest;

    _szAlloc      = NULL;
    _szData       = NULL;
    _pvContext    = NULL;
    _szRequestUri = NULL;
    _cbData       = 0;
    _cbContext    = 0;
    _nRetries     = 0;
    
    
    // Zero out the security buffers and request context.
    memset(&_SecBuffInDesc,  0, sizeof(_SecBuffInDesc));
    memset(&_SecBuffOutDesc, 0, sizeof(_SecBuffInDesc));
    memset(_SecBuffIn,       0, sizeof(_SecBuffIn));
    memset(_SecBuffOut,      0, sizeof(_SecBuffOut));
    memset(&_hCtxt,          0, sizeof(_hCtxt));
        
    // Is this the first time that the digest SSPI package
    // is being called for this process.
    if (!g_pFuncTbl)
    {
        // Get the global SSPI dispatch table.
        GetFuncTbl();

        DIGEST_PKG_DATA             PkgData;
        SEC_WINNT_AUTH_IDENTITY_EXA SecIdExA;

        // Logon with szAppCtx = szUserCtx = NULL.
        PkgData.szAppCtx = PkgData.szUserCtx = NULL;
        memset(&SecIdExA, 0, sizeof(SEC_WINNT_AUTH_IDENTITY_EXA));

        SecIdExA.Version = sizeof(SEC_WINNT_AUTH_IDENTITY_EXA);
        SecIdExA.User = (unsigned char*) &PkgData;
        SecIdExA.UserLength = sizeof(DIGEST_PKG_DATA);
        
        // Get the global credentials handle.
        ssResult = (*(g_pFuncTbl->AcquireCredentialsHandleA))
            (NULL, "Digest", SECPKG_CRED_OUTBOUND, NULL, &SecIdExA, NULL, 0, &g_hCred, NULL);
    }
}


/*---------------------------------------------------------------------------
DIGEST_CTX::PromptForCreds
---------------------------------------------------------------------------*/
DWORD DIGEST_CTX::PromptForCreds(HWND hWnd)
{
    SECURITY_STATUS ssResult;
        
    // Prompt for the credentials.
    INET_ASSERT(_pvContext);
    _cbContext = OUTPUT_BUFFER_LEN;

    DWORD sf;
    InitSecurityBuffers((LPSTR) _pvContext, _cbContext, &sf, ISC_MODE_UI);

    _SecBuffIn[HWND_IDX].pvBuffer = &hWnd;
    _SecBuffIn[HWND_IDX].cbBuffer = sizeof(HWND);

    ssResult = (*(g_pFuncTbl->InitializeSecurityContextA))(&g_hCred, &_hCtxt, NULL, sf, 
        0, 0, &_SecBuffInDesc, 0, &_hCtxt, &_SecBuffOutDesc, NULL, NULL);

    _cbContext = _SecBuffOutDesc.pBuffers[0].cbBuffer;    

    if (ssResult == SEC_E_NO_CREDENTIALS)
        return ERROR_CANCELLED;

    return (DWORD) ssResult;
}


/*---------------------------------------------------------------------------
    Destructor
---------------------------------------------------------------------------*/
DIGEST_CTX::~DIGEST_CTX()
{
    if (_szAlloc)
        delete _szAlloc;

    if (_pvContext)
        delete _pvContext;

    if (_szRequestUri)
        delete _szRequestUri;
}


/*---------------------------------------------------------------------------
    PreAuthUser
---------------------------------------------------------------------------*/
DWORD DIGEST_CTX::PreAuthUser(OUT LPSTR pBuff, IN OUT LPDWORD pcbBuff)
{
    SECURITY_STATUS ssResult = SEC_E_OK;
    INET_ASSERT(_pSPMData == _pCreds->pSPM);

    if (AuthLock())
    {
        // If a response has been generated copy into output buffer.
        if (_cbContext)
        {
            memcpy(pBuff, _pvContext, _cbContext);
            *pcbBuff = _cbContext;
        }
        // Otherwise attempt to preauthenticate.
        else
        {
            // Call into the SSPI package.
            DWORD sf;
            InitSecurityBuffers(pBuff, *pcbBuff, &sf, ISC_MODE_PREAUTH);

            ssResult = (*(g_pFuncTbl->InitializeSecurityContext))(&g_hCred, NULL, NULL, sf, 
                0, 0, &_SecBuffInDesc, 0, &_hCtxt, &_SecBuffOutDesc, NULL, NULL);

            *pcbBuff = _SecBuffOut[0].cbBuffer;
        }

        AuthUnlock();
    }
            
    return (DWORD) ssResult;
}

/*---------------------------------------------------------------------------
    UpdateFromHeaders
---------------------------------------------------------------------------*/
DWORD DIGEST_CTX::UpdateFromHeaders(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy)
{
    if (!AuthLock())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    DWORD dwError, cbExtra, dwAuthIdx;
    LPSTR szAuthHeader, szExtra, szScheme;
    LPSTR szRealm; 
    DWORD cbRealm;
    
    // Get the associated header.
    if ((dwError = FindHdrIdxFromScheme(&dwAuthIdx)) != ERROR_SUCCESS)
        goto exit;

    // If this auth ctx does not have Creds then it has been
    // just been constructed in response to a 401.
    if (!_pCreds)
    {
        // Get any realm.
        dwError = GetAuthHeaderData(pRequest, fIsProxy, "Realm", 
            &szRealm, &cbRealm, ALLOCATE_BUFFER, dwAuthIdx);

        _pCreds = CreateCreds(pRequest, fIsProxy, _pSPMData, szRealm);
        
        if (pRequest->_pszRealm)
        {
            FREE_MEMORY(pRequest->_pszRealm);
        }
        pRequest->_pszRealm = szRealm;
        szRealm = NULL;

        if (_pCreds)
        {
            INET_ASSERT(_pCreds->pSPM == _pSPMData);
        }
        else
        {
            dwError = ERROR_WINHTTP_INTERNAL_ERROR;
            goto exit;
        }
    }

    // Updating the buffer - delete old one if necessary.
    if (_szAlloc)
    {
        delete _szAlloc;
        _szAlloc = _szData = NULL;
        _cbData = 0;
    }

    // Get the entire authentication header.
    dwError = GetAuthHeaderData(pRequest, fIsProxy, NULL,
        &_szAlloc, &_cbData, ALLOCATE_BUFFER, dwAuthIdx);
    
    if (dwError != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Point just past scheme
    _szData = _szAlloc;
    while (*_szData != ' ')
    {
        _szData++;
        _cbData--;
    }

    // The request will be retried.
    dwError = ERROR_SUCCESS;

exit:
    AuthUnlock();
    return dwError;
}



/*---------------------------------------------------------------------------
    PostAuthUser
---------------------------------------------------------------------------*/
DWORD DIGEST_CTX::PostAuthUser()
{
    if (!AuthLock())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    INET_ASSERT(_pSPMData == _pCreds->pSPM);

    DWORD dwError;
    SECURITY_STATUS ssResult;

    // Allocate an output buffer if not done so already.
    if (!_pvContext)
    {
        _pvContext = New CHAR[OUTPUT_BUFFER_LEN];
        if (!_pvContext)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
    }

    _cbContext = OUTPUT_BUFFER_LEN;


    if (_nRetries++ < MAX_SILENT_RETRIES)
    {
        // If we pre-authenticated, treat as second
        // or subsequent attempt. We depend on the
        // server correctly sending stale=FALSE (or no stale)
        // if the credentials sent during pre-auth were bad.
        // In this case the digest pkg will return SEC_E_NO_CREDENTIALS
        // and we will prompt for credentials.
        // BUGBUG - Use ApplyControlToken
        if (_nRetries == 1 && _pRequest->GetCreds())
        {
            // Increment num of retries to 2
            _nRetries++;

            // The dwLower member has to have the correct value
            // so that secur32.dll can route to correct provider.
            _hCtxt.dwLower = g_hCred.dwLower;
        }

        // Call into the SSPI package.

        DWORD sf;
        InitSecurityBuffers((LPSTR) _pvContext, _cbContext, &sf, ISC_MODE_AUTH);
        ssResult = (*(g_pFuncTbl->InitializeSecurityContext))
            (&g_hCred, (_nRetries == 1 ? NULL : &_hCtxt), NULL, sf, 
            0, 0, &_SecBuffInDesc, 0, &_hCtxt, &_SecBuffOutDesc, NULL, NULL);
        _cbContext = _SecBuffOutDesc.pBuffers[0].cbBuffer;
        
        switch(ssResult)
        {
            case SEC_E_OK:
            {
                dwError = ERROR_WINHTTP_FORCE_RETRY;
                break;
            }
            case SEC_E_NO_CREDENTIALS:
            {
                dwError = ERROR_WINHTTP_INCORRECT_PASSWORD;
                break;
            }
            default:
                dwError = ERROR_WINHTTP_LOGIN_FAILURE;
        }
    }
    else
    {
        _cbContext = 0;
        _nRetries = 0;
        dwError = ERROR_WINHTTP_INCORRECT_PASSWORD;
    }

exit:
    _pRequest->SetCreds(NULL);
    AuthUnlock();
    return dwError;
}

/*---------------------------------------------------------------------------
    Flush creds
---------------------------------------------------------------------------*/
VOID DIGEST_CTX::FlushCreds()
{
    DWORD ssResult;
    if (g_pFuncTbl)
    {
        DWORD sf = ISC_REQ_NULL_SESSION;
        ssResult = (*(g_pFuncTbl->InitializeSecurityContext))(&g_hCred, NULL, NULL, sf, 
            0, 0, NULL, 0, NULL, NULL, NULL, NULL);
    }
}

/*---------------------------------------------------------------------------
    Logoff
---------------------------------------------------------------------------*/
VOID DIGEST_CTX::Logoff()
{
    DWORD ssResult;
    if (g_pFuncTbl)
    {
        ssResult = (*(g_pFuncTbl->FreeCredentialsHandle))(&g_hCred);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\auth\htuu.h ===
/*
   This file was derived from the libwww code, version 2.15, from CERN.
   A number of modifications have been made by Spyglass.

   eric@spyglass.com
 */

/*                              ENCODING TO PRINTABLE CHARACTERS

   File module provides functions HTUU_encode() and HTUU_decode() which convert a buffer
   of bytes to/from RFC 1113 printable encoding format. This technique is similar to the
   familiar Unix uuencode format in that it maps 6 binary bits to one ASCII character (or
   more aptly, 3 binary bytes to 4 ASCII characters).  However, RFC 1113 does not use the
   same mapping to printable characters as uuencode.

	Ported to WinINet Plug In DLL by arthurbi Dec-23-1995

 */

#ifndef HTUU_H
#define HTUU_H

#ifdef __cplusplus
extern "C" {
#endif

int HTUU_encode(unsigned char *bufin,
				unsigned int nbytes,
				char *bufcoded,
                long outbufmax);

int HTUU_decode(char *bufcoded,
				unsigned char *bufplain,
				int outbufsize);

#ifdef __cplusplus
} // end extern "C"
#endif

#endif
/*

   End of file.  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\auth\htuu.c ===
/*
   This file was derived from the libwww code, version 2.15, from CERN.
   A number of modifications have been made by Spyglass.

   eric@spyglass.com

   This file was removed from LibWWW and placed into the
   Security Protocol Module.

   jeff@spyglass.com
 */

/* MODULE                           HTUU.c
   **           UUENCODE AND UUDECODE
   **
   ** ACKNOWLEDGEMENT:
   **   This code is taken from rpem distribution, and was originally
   **   written by Mark Riordan.
   **
   ** AUTHORS:
   **   MR  Mark Riordan    riordanmr@clvax1.cl.msu.edu
   **   AL  Ari Luotonen    luotonen@dxcern.cern.ch
   **
   ** HISTORY:
   **   Added as part of the WWW library and edited to conform
   **   with the WWW project coding standards by:   AL  5 Aug 1993
   **   Originally written by:              MR 12 Aug 1990
   **   Original header text:
   ** -------------------------------------------------------------
   **  File containing routines to convert a buffer
   **  of bytes to/from RFC 1113 printable encoding format.
   **
   **  This technique is similar to the familiar Unix uuencode
   **  format in that it maps 6 binary bits to one ASCII
   **  character (or more aptly, 3 binary bytes to 4 ASCII
   **  characters).  However, RFC 1113 does not use the same
   **  mapping to printable characters as uuencode.
   **
   **  Mark Riordan   12 August 1990 and 17 Feb 1991.
   **  This code is hereby placed in the public domain.
   ** -------------------------------------------------------------
   **
   ** BUGS:
   **
   **
 */


const static char six2pr[64] =
{
	'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
	'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
	'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
	'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
	'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'
};

static unsigned char pr2six[256];


/*--- function HTUU_encode -----------------------------------------------
 *
 *   Encode a single line of binary data to a standard format that
 *   uses only printing ASCII characters (but takes up 33% more bytes).
 *
 *    Entry    bufin    points to a buffer of bytes.  If nbytes is not
 *                      a multiple of three, then the byte just beyond
 *                      the last byte in the buffer must be 0.
 *             nbytes   is the number of bytes in that buffer.
 *                      This cannot be more than 48.
 *             bufcoded points to an output buffer.  Be sure that this
 *                      can hold at least 1 + (4*nbytes)/3 characters.
 *             outbufmax maximum size of the buffer bufcoded.
 *
 *    Exit     bufcoded contains the coded line.  The first 4*nbytes/3 bytes
 *                      contain printing ASCII characters representing
 *                      those binary bytes. This may include one or
 *                      two '=' characters used as padding at the end.
 *                      The last byte is a zero byte.
 *             Returns the number of ASCII characters in "bufcoded".
 */
int HTUU_encode(unsigned char *bufin, unsigned int nbytes, char *bufcoded,
                long outbufmax)
{
/* ENC is the basic 1 character encoding function to make a char printing */
#define ENC(c) six2pr[c]

	register char *outptr = bufcoded;
	unsigned int i;

	for (i = 0; i < nbytes; i += 3)
	{
        if ( (outptr - bufcoded + 4) > outbufmax )
            return (-1);

		*(outptr++) = ENC(*bufin >> 2);		/* c1 */
		*(outptr++) = ENC(((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017));		/*c2 */
		*(outptr++) = ENC(((bufin[1] << 2) & 074) | ((bufin[2] >> 6) & 03));	/*c3 */
		*(outptr++) = ENC(bufin[2] & 077);	/* c4 */

		bufin += 3;
	}

	/* If nbytes was not a multiple of 3, then we have encoded too
	 * many characters.  Adjust appropriately.
	 */
	if (i == nbytes + 1)
	{
		/* There were only 2 bytes in that last group */
		outptr[-1] = '=';
	}
	else if (i == nbytes + 2)
	{
		/* There was only 1 byte in that last group */
		outptr[-1] = '=';
		outptr[-2] = '=';
	}

    if ( (outptr - bufcoded) + 1 < outbufmax )
    	*outptr = '\0';

	return ((int)(outptr - bufcoded));
}


/*--- function HTUU_decode ------------------------------------------------
 *
 *  Decode an ASCII-encoded buffer back to its original binary form.
 *
 *    Entry    bufcoded    points to a uuencoded string.  It is 
 *                         terminated by any character not in
 *                         the printable character table six2pr, but
 *                         leading whitespace is stripped.
 *             bufplain    points to the output buffer; must be big
 *                         enough to hold the decoded string (generally
 *                         shorter than the encoded string) plus
 *                         as many as two extra bytes used during
 *                         the decoding process.
 *             outbufsize  is the maximum number of bytes that
 *                         can fit in bufplain.
 *
 *    Exit     Returns the number of binary bytes decoded.
 *             bufplain    contains these bytes.
 */
int HTUU_decode(char *bufcoded, unsigned char *bufplain, int outbufsize)
{
/* single character decode */
#define DEC(c) pr2six[(int)c]
#define MAXVAL 63

	static int first = 1;

	int nbytesdecoded, j;
	register char *bufin = bufcoded;
	register unsigned char *bufout = bufplain;
	register int nprbytes;

	/* If this is the first call, initialize the mapping table.
	 * This code should work even on non-ASCII machines.
	 */
	if (first)
	{
		first = 0;
		for (j = 0; j < 256; j++)
			pr2six[j] = MAXVAL + 1;

		for (j = 0; j < 64; j++)
			pr2six[(int) six2pr[j]] = (unsigned char) j;
#if 0
		pr2six['A'] = 0;
		pr2six['B'] = 1;
		pr2six['C'] = 2;
		pr2six['D'] = 3;
		pr2six['E'] = 4;
		pr2six['F'] = 5;
		pr2six['G'] = 6;
		pr2six['H'] = 7;
		pr2six['I'] = 8;
		pr2six['J'] = 9;
		pr2six['K'] = 10;
		pr2six['L'] = 11;
		pr2six['M'] = 12;
		pr2six['N'] = 13;
		pr2six['O'] = 14;
		pr2six['P'] = 15;
		pr2six['Q'] = 16;
		pr2six['R'] = 17;
		pr2six['S'] = 18;
		pr2six['T'] = 19;
		pr2six['U'] = 20;
		pr2six['V'] = 21;
		pr2six['W'] = 22;
		pr2six['X'] = 23;
		pr2six['Y'] = 24;
		pr2six['Z'] = 25;
		pr2six['a'] = 26;
		pr2six['b'] = 27;
		pr2six['c'] = 28;
		pr2six['d'] = 29;
		pr2six['e'] = 30;
		pr2six['f'] = 31;
		pr2six['g'] = 32;
		pr2six['h'] = 33;
		pr2six['i'] = 34;
		pr2six['j'] = 35;
		pr2six['k'] = 36;
		pr2six['l'] = 37;
		pr2six['m'] = 38;
		pr2six['n'] = 39;
		pr2six['o'] = 40;
		pr2six['p'] = 41;
		pr2six['q'] = 42;
		pr2six['r'] = 43;
		pr2six['s'] = 44;
		pr2six['t'] = 45;
		pr2six['u'] = 46;
		pr2six['v'] = 47;
		pr2six['w'] = 48;
		pr2six['x'] = 49;
		pr2six['y'] = 50;
		pr2six['z'] = 51;
		pr2six['0'] = 52;
		pr2six['1'] = 53;
		pr2six['2'] = 54;
		pr2six['3'] = 55;
		pr2six['4'] = 56;
		pr2six['5'] = 57;
		pr2six['6'] = 58;
		pr2six['7'] = 59;
		pr2six['8'] = 60;
		pr2six['9'] = 61;
		pr2six['+'] = 62;
		pr2six['/'] = 63;
#endif
	}

	/* Strip leading whitespace. */

	while (*bufcoded == ' ' || *bufcoded == '\t')
		bufcoded++;

	/* Figure out how many characters are in the input buffer.
	 * If this would decode into more bytes than would fit into
	 * the output buffer, adjust the number of input bytes downwards.
	 */
	bufin = bufcoded;
	while (pr2six[(int) *(bufin++)] <= MAXVAL) ;
	nprbytes = (int)(bufin - bufcoded) - 1;
	nbytesdecoded = ((nprbytes + 3) / 4) * 3;
	if (nbytesdecoded > outbufsize)
	{
		nprbytes = (outbufsize * 4) / 3;
	}

	bufin = bufcoded;

	while (nprbytes > 0)
	{
		*(bufout++) = (unsigned char) (DEC(*bufin) << 2 | DEC(bufin[1]) >> 4);
		*(bufout++) = (unsigned char) (DEC(bufin[1]) << 4 | DEC(bufin[2]) >> 2);
		*(bufout++) = (unsigned char) (DEC(bufin[2]) << 6 | DEC(bufin[3]));
		bufin += 4;
		nprbytes -= 4;
	}

	if (nprbytes & 03)
	{
		if (pr2six[(int) bufin[-2]] > MAXVAL)
		{
			nbytesdecoded -= 2;
		}
		else
		{
			nbytesdecoded -= 1;
		}
	}

	return (nbytesdecoded);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\auth\plug.cxx ===
#include <wininetp.h>
#include <splugin.hxx>
#include "auth.h"
#include "sspspm.h"
#include "winctxt.h"

extern SspData  *g_pSspData;
/*-----------------------------------------------------------------------------
    PLUG_CTX
-----------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    Load
---------------------------------------------------------------------------*/
DWORD PLUG_CTX::Load()
{
    INET_ASSERT(_pSPMData == _pCreds->pSPM);

    DWORD_PTR dwAuthCode = 0;

    dwAuthCode = SSPI_InitScheme (GetScheme());

    if (!dwAuthCode)
    {
        _pSPMData->eState = STATE_ERROR;
        return ERROR_WINHTTP_INTERNAL_ERROR;
    }

    _pSPMData->eState = STATE_LOADED;
    return ERROR_SUCCESS;
}


/*---------------------------------------------------------------------------
    ClearAuthUser
---------------------------------------------------------------------------*/
DWORD PLUG_CTX::ClearAuthUser(LPVOID *ppvContext, LPSTR szServer)
{
    if (GetState() == AUTHCTX::STATE_LOADED)
    {
        __try
        {
            UnloadAuthenticateUser(ppvContext, szServer, GetScheme());
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            DEBUG_PRINT(HTTP, ERROR,
                ("UnloadAuthenticateUser call down faulted\n"));
        }
        ENDEXCEPT
    }
    *ppvContext = 0;
    return ERROR_SUCCESS;
}

/*-----------------------------------------------------------------------------
    wQueryHeadersAlloc

Routine Description:

    Allocates a HTTP Header String, and queries the HTTP handle for it.

Arguments:

    hRequestMapped          - An open HTTP request handle
                               where headers can be quiered
    dwQuery                 - The Query Type to pass to HttpQueryHeaders
    lpdwQueryIndex          - The Index of the header to pass to HttpQueryHeaders,
                              make sure to inialize to 0.
    lppszOutStr             - On success, a pointer to Allocated string with header string,
    lpdwSize                - size of the string returned in lppszOutStr

Return Value:

    DWORD
    Success - ERROR_SUCCESS

    Failure - One of Several Error codes defined in winerror.h or wininet.w

Comments:

    On Error, lppszOutStr may still contain an allocated string that will need to be
    freed.
-----------------------------------------------------------------------------*/
DWORD PLUG_CTX::wQueryHeadersAlloc
(
    IN HINTERNET hRequestMapped,
    IN DWORD dwQuery,
    OUT LPDWORD lpdwQueryIndex,
    OUT LPSTR *lppszOutStr,
    OUT LPDWORD lpdwSize
)
{
    LPSTR lpszRawHeaderBuf = NULL;
    DWORD dwcbRawHeaderBuf = 0;
    DWORD error;
    DWORD length;
    HTTP_REQUEST_HANDLE_OBJECT * pHttpRequest;

    INET_ASSERT(lppszOutStr);
    INET_ASSERT(hRequestMapped);
    INET_ASSERT(lpdwSize);
    INET_ASSERT((dwQuery & HTTP_QUERY_HEADER_MASK) != HTTP_QUERY_CUSTOM);

    *lppszOutStr = NULL;
    error = ERROR_SUCCESS;
    pHttpRequest = (HTTP_REQUEST_HANDLE_OBJECT *) hRequestMapped;

    // Attempt to determine whether our header is there.
    length = 0;
    if (pHttpRequest->QueryInfo(dwQuery, NULL, NULL, &length, lpdwQueryIndex)
          != ERROR_INSUFFICIENT_BUFFER)
    {
        // no authentication happening, we're done
        error = ERROR_HTTP_HEADER_NOT_FOUND;
        goto quit;
    }

    // Allocate a Fixed Size Buffer
    lpszRawHeaderBuf = (LPSTR) ALLOCATE_MEMORY(LPTR, length);
    dwcbRawHeaderBuf = length;

    if ( lpszRawHeaderBuf == NULL )
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    error = pHttpRequest->QueryInfo
        (dwQuery, NULL, lpszRawHeaderBuf, &dwcbRawHeaderBuf, lpdwQueryIndex);

    INET_ASSERT(error != ERROR_INSUFFICIENT_BUFFER );
    INET_ASSERT(error != ERROR_HTTP_HEADER_NOT_FOUND );

quit:

    if ( error != ERROR_SUCCESS  )
    {
        dwcbRawHeaderBuf = 0;

        if ( lpszRawHeaderBuf )
            *lpszRawHeaderBuf = '\0';
    }

    *lppszOutStr = lpszRawHeaderBuf;
    *lpdwSize = dwcbRawHeaderBuf;

    return error;
}

/*-----------------------------------------------------------------------------
    CrackAuthenticationHeader

Routine Description:

    Attempts to decode a HTTP 1.1 Authentication header into its
    components.

Arguments:

    hRequestMapped           - Mapped Request handle
    fIsProxy                 - Whether proxy or server auth
    lpdwAuthenticationIndex  - Index of current HTTP header. ( initally called with 0 )
    lppszAuthHeader          - allocated pointer which should be freed by client
    lppszAuthScheme          - Pointer to Authentication scheme string.
    lppszRealm               - Pointer to Realm string,
    lpExtra                  - Pointer to any Extra String data in the header that is not
                                   part of the Realm
    lpdwExtra                - Pointer to Size of Extra data.
    lppszAuthScheme

  Return Value:

    DWORD
    Success - ERROR_SUCCESS

    Failure - ERROR_NOT_ENOUGH_MEMORY,
              ERROR_HTTP_HEADER_NOT_FOUND

Comments:
-----------------------------------------------------------------------------*/
DWORD PLUG_CTX::CrackAuthenticationHeader
(
    IN HINTERNET hRequestMapped,
    IN BOOL      fIsProxy,
    IN     DWORD dwAuthenticationIndex,
    IN OUT LPSTR *lppszAuthHeader,
    IN OUT LPSTR *lppszExtra,
    IN OUT DWORD *lpdwExtra,
       OUT LPSTR *lppszAuthScheme
    )
{
    DWORD error = ERROR_SUCCESS;

    LPSTR lpszAuthHeader = NULL;
    DWORD cbAuthHeader = 0;
    LPSTR lpszExtra = NULL;
    LPSTR lpszAuthScheme = NULL;

    LPDWORD lpdwAuthenticationIndex = &dwAuthenticationIndex;
    INET_ASSERT(lpdwExtra);
    INET_ASSERT(lppszExtra);
    INET_ASSERT(lpdwAuthenticationIndex);

    DWORD dwQuery = fIsProxy?
        HTTP_QUERY_PROXY_AUTHENTICATE : HTTP_QUERY_WWW_AUTHENTICATE;

    error = wQueryHeadersAlloc (hRequestMapped, dwQuery,
        lpdwAuthenticationIndex, &lpszAuthHeader, &cbAuthHeader);

    if ( error != ERROR_SUCCESS )
    {
        INET_ASSERT(*lpdwAuthenticationIndex
            || error == ERROR_HTTP_HEADER_NOT_FOUND );
        goto quit;
    }


    //
    // Parse Header for Scheme type
    //
    lpszAuthScheme = lpszAuthHeader;

    while ( *lpszAuthScheme == ' ' )  // strip spaces
        lpszAuthScheme++;

    lpszExtra = strchr(lpszAuthScheme, ' ');

    if (lpszExtra)
        *lpszExtra++ = '\0';

    if (lstrcmpi(GetScheme(), lpszAuthScheme))
    {
        DEBUG_PRINT(HTTP, ERROR,
               ("Authentication: HTTP Scheme has changed!: Scheme=%q\n",
                lpszAuthScheme));
        goto quit;

    }


    DEBUG_PRINT (HTTP, INFO,
        ("Authentication: found in headers: Scheme=%q, Extra=%q\n",
        lpszAuthScheme, lpszExtra));

quit:
    *lppszExtra  = lpszExtra;
    *lpdwExtra   = lpszExtra ? lstrlen(lpszExtra) : 0;
    *lppszAuthHeader = lpszAuthHeader;
    *lppszAuthScheme = lpszAuthScheme;
    return error;
}


/*---------------------------------------------------------------------------
    ResolveProtocol
---------------------------------------------------------------------------*/
VOID PLUG_CTX::ResolveProtocol()
{
    SECURITY_STATUS ssResult;
    PWINCONTEXT pWinContext;
    SecPkgContext_NegotiationInfo SecPkgCtxtInfo;

    INET_ASSERT(GetSchemeType() == WINHTTP_AUTH_SCHEME_NEGOTIATE);
    
    SecPkgCtxtInfo.PackageInfo = NULL;

    // Call QueryContextAttributes on the context handle.
    pWinContext = (PWINCONTEXT) (_pvContext);
    ssResult = (*(g_pSspData->pFuncTbl->QueryContextAttributes))
        (pWinContext->pSspContextHandle, SECPKG_ATTR_NEGOTIATION_INFO, &SecPkgCtxtInfo);

    if (ssResult == SEC_E_OK 
        && (SecPkgCtxtInfo.NegotiationState == SECPKG_NEGOTIATION_COMPLETE
            || (SecPkgCtxtInfo.NegotiationState == SECPKG_NEGOTIATION_OPTIMISTIC)))
    {
        // Resolve actual auth protocol from package name.
        // update both the auth context and Creds entry.
        if (!lstrcmpi(SecPkgCtxtInfo.PackageInfo->Name, "NTLM"))
        {
            _eSubScheme = WINHTTP_AUTH_SCHEME_NTLM;
            _dwSubFlags = PLUGIN_AUTH_FLAGS_NO_REALM;
        }
        else if (!lstrcmpi(SecPkgCtxtInfo.PackageInfo->Name, "Kerberos"))
        {
            _eSubScheme = WINHTTP_AUTH_SCHEME_KERBEROS;            
            _dwSubFlags = PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED | PLUGIN_AUTH_FLAGS_NO_REALM;
        }

// BUGBUG - This faults.
//        

    }

    if (SecPkgCtxtInfo.PackageInfo)
    {
        (*(g_pSspData->pFuncTbl->FreeContextBuffer))(SecPkgCtxtInfo.PackageInfo);
    }
}


/*---------------------------------------------------------------------------
    Constructor
---------------------------------------------------------------------------*/
PLUG_CTX::PLUG_CTX(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy,
                 SPMData *pSPM, AUTH_CREDS* pCreds)
    : AUTHCTX(pSPM, pCreds)
{
    _fIsProxy = fIsProxy;
    _pRequest = pRequest;
    _szAlloc = NULL;
    _szData = NULL;
    _cbData = 0;
    _pRequest->SetAuthState(AUTHSTATE_NONE);
    _fNTLMProxyAuth = _fIsProxy && (GetSchemeType() == WINHTTP_AUTH_SCHEME_NTLM);

    _pszFQDN = NULL;
}

/*---------------------------------------------------------------------------
    Destructor
---------------------------------------------------------------------------*/
PLUG_CTX::~PLUG_CTX()
{
    if (GetState() == AUTHCTX::STATE_LOADED)
    {
        if (_pCreds)
        {
            if (_CtxCriSec.Lock())
            {
                ClearAuthUser(&_pvContext, _pCreds->lpszHost);

                _CtxCriSec.Unlock();
            }
        }
    }
    if (_pRequest)
    {
        _pRequest->SetAuthState(AUTHSTATE_NONE);
    }

    if (_pszFQDN)
    {
        FREE_MEMORY(_pszFQDN);
    }
}


/*---------------------------------------------------------------------------
    PreAuthUser
---------------------------------------------------------------------------*/
DWORD PLUG_CTX::PreAuthUser(OUT LPSTR pBuf, IN OUT LPDWORD pcbBuf)
{
    if (!_CtxCriSec.Lock())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    INET_ASSERT(_pSPMData == _pCreds->pSPM);

    DWORD dwError;
    SECURITY_STATUS ssResult;

    //  Make sure the auth provider is loaded.
    if (GetState() != AUTHCTX::STATE_LOADED)
    {
        if (GetState() != AUTHCTX::STATE_ERROR )
            Load();
        if (GetState() != AUTHCTX::STATE_LOADED)
        {
            dwError = ERROR_WINHTTP_INTERNAL_ERROR;
            goto exit;
        }
    }

    BOOL fCanUseLogon = _fIsProxy 
        || _pRequest->SilentLogonOK(_pCreds->lpszHost);

    LPSTR lpszFQDN = GetFQDN(_pCreds->lpszHost);
    LPSTR lpszHostName =  lpszFQDN ? lpszFQDN : _pCreds->lpszHost;

    __try
    {
        ssResult = SEC_E_INTERNAL_ERROR;
        dwError = PreAuthenticateUser(&_pvContext,
                               lpszHostName,
                               GetScheme(),
                               fCanUseLogon,
                               0, // dwFlags
                               pBuf,
                               pcbBuf,
                               _pCreds->lpszUser,
                               _pCreds->lpszPass,
                               &ssResult);


        // Transit to the correct auth state.
        if (ssResult == SEC_E_OK || ssResult == SEC_I_CONTINUE_NEEDED)
        {
            if (GetSchemeType() == WINHTTP_AUTH_SCHEME_NEGOTIATE)
                ResolveProtocol();

            // Kerberos + SEC_E_OK or SEC_I_CONTINUE_NEEDED transits to challenge.
            // Negotiate does not transit to challenge.
            // Any other protocol + SEC_E_OK only transits to challenge.
            if ((GetSchemeType() == WINHTTP_AUTH_SCHEME_KERBEROS
                && (ssResult == SEC_E_OK || ssResult == SEC_I_CONTINUE_NEEDED))
                || (GetSchemeType() != WINHTTP_AUTH_SCHEME_NEGOTIATE && ssResult == SEC_E_OK))
            {
                _pRequest->SetAuthState(AUTHSTATE_CHALLENGE);
            }        
        }
    }

    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DEBUG_PRINT (HTTP, ERROR, ("preAuthenticateUser call down faulted\n"));
        _pSPMData->eState = STATE_ERROR;
        dwError = ERROR_WINHTTP_INTERNAL_ERROR;
    }

    ENDEXCEPT

exit:
    _CtxCriSec.Unlock();
    return dwError;
}


/*---------------------------------------------------------------------------
    UpdateFromHeaders
---------------------------------------------------------------------------*/
DWORD PLUG_CTX::UpdateFromHeaders(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy)
{
    DWORD dwError, cbExtra, dwAuthIdx;
    LPSTR szAuthHeader, szExtra, szScheme;

    // Get the auth header index corresponding to the scheme of this ctx.
    if ((dwError = FindHdrIdxFromScheme(&dwAuthIdx)) != ERROR_SUCCESS)
        goto quit;

    // Get the scheme and any extra data.
    if ((dwError = CrackAuthenticationHeader(pRequest, fIsProxy, dwAuthIdx,
        &szAuthHeader, &szExtra, &cbExtra, &szScheme)) != ERROR_SUCCESS)
        goto quit;
    
    if (!cbExtra)
        _pRequest->SetAuthState(AUTHSTATE_NEGOTIATE);

    // Check if auth scheme requires keep-alive.
    if (!(GetFlags() & PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED))
    {
        // if in negotiate phase check if we are going via proxy.
        if (pRequest->GetAuthState() == AUTHSTATE_NEGOTIATE)
        {
            // BUGBUG: if via proxy, we are not going to get keep-alive
            // connection to the server.  It would be nice if we knew
            // a priori the whether proxy would allow us to tunnel to
            // http port on the server.  Otherwise if we try and fail,
            // we look bad vs. other browsers who are ignorant of ntlm
            // and fall back to basic.
            CHAR szBuffer[64];
            DWORD dwBufferLength = sizeof(szBuffer);
            DWORD dwIndex = 0;
            BOOL fSessionBasedAuth = FALSE;
            if (pRequest->QueryResponseHeader(HTTP_QUERY_PROXY_SUPPORT, 
                                          szBuffer, &dwBufferLength, 
                                          0, &dwIndex) == ERROR_SUCCESS)
            {
                if (!_stricmp(szBuffer, "Session-Based-Authentication"))
                {
                    fSessionBasedAuth = TRUE;
                }
            }
            if (!fIsProxy && pRequest->IsRequestUsingProxy()
                && !pRequest->IsTalkingToSecureServerViaProxy() && !fSessionBasedAuth)
            {
                // Ignore NTLM via proxy since we won't get k-a to server.
                dwError = ERROR_HTTP_HEADER_NOT_FOUND;
                goto quit;
            }
        }

        // Else if in challenge phase, we require a persistent connection.
        else
        {
            // If we don't have a keep-alive connection ...
            if (!(pRequest->IsPersistentConnection (fIsProxy)))
            {
                dwError = ERROR_HTTP_HEADER_NOT_FOUND;
                goto quit;
            }
        }

    } // end if keep-alive required

    quit:

    if (dwError == ERROR_SUCCESS)
    {
        // If no password cache is set in the auth context,
        // find or create one and set it in the handle.
        if (!_pCreds)
        {
            _pCreds = CreateCreds(pRequest, fIsProxy, _pSPMData, NULL);

            if (!_pCreds)
            {
                INET_ASSERT(FALSE);
                dwError = ERROR_WINHTTP_INTERNAL_ERROR;
            }
            else
            {
                INET_ASSERT(_pCreds->pSPM == _pSPMData);
            }
        }
    }

    if (dwError == ERROR_SUCCESS)
    {
        // Point to allocated data.
        _szAlloc = szAuthHeader;
        _szData = szExtra;
        _cbData = cbExtra;
    }
    else
    {
        // Free allocated data.
        if (_szAlloc)
            delete _szAlloc;
        _szAlloc = NULL;
        _szData = NULL;
        _cbData = 0;
    }

    // Return of non-success will cancel auth session.
    return dwError;
}



/*---------------------------------------------------------------------------
    PostAuthUser
---------------------------------------------------------------------------*/
DWORD PLUG_CTX::PostAuthUser()
{
    if (!_CtxCriSec.Lock())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    INET_ASSERT(_pSPMData == _pCreds->pSPM);
    DWORD dwError;

    //  Make sure the auth provider is loaded.
    if (GetState() != AUTHCTX::STATE_LOADED)
    {
        if (GetState() != AUTHCTX::STATE_ERROR )
            Load();
        if (GetState() != AUTHCTX::STATE_LOADED)
        {
            dwError = ERROR_WINHTTP_INTERNAL_ERROR;
            goto exit;
        }
    }

    BOOL fCanUseLogon = _fIsProxy 
        || _pRequest->SilentLogonOK(_pCreds->lpszHost);

    LPSTR lpszFQDN = GetFQDN(_pCreds->lpszHost);
    LPSTR lpszHostName = lpszFQDN ? lpszFQDN : _pCreds->lpszHost;

    SECURITY_STATUS ssResult;
    __try
    {
        ssResult = SEC_E_INTERNAL_ERROR;
        dwError = AuthenticateUser(&_pvContext,
                                   lpszHostName,
                                   GetScheme(),
                                   fCanUseLogon,
                                   _szData,
                                   _cbData,
                                   _pCreds->lpszUser,
                                   _pCreds->lpszPass,
                                   &ssResult);



        // Kerberos package can get into a bad state.
        if (GetSchemeType() == WINHTTP_AUTH_SCHEME_KERBEROS && ssResult == SEC_E_WRONG_PRINCIPAL)
            dwError = ERROR_WINHTTP_INCORRECT_PASSWORD;
            
        // Transit to the correct auth state.
        if (ssResult == SEC_E_OK || ssResult == SEC_I_CONTINUE_NEEDED)
        {
            if (GetSchemeType() == WINHTTP_AUTH_SCHEME_NEGOTIATE)
                ResolveProtocol();

            // Kerberos + SEC_E_OK or SEC_I_CONTINUE_NEEDED transits to challenge.
            // Negotiate does not transit to challenge.
            // Any other protocol + SEC_E_OK only transits to challenge.
            if ((GetSchemeType() == WINHTTP_AUTH_SCHEME_KERBEROS
                && (ssResult == SEC_E_OK || ssResult == SEC_I_CONTINUE_NEEDED))
                || (GetSchemeType() != WINHTTP_AUTH_SCHEME_NEGOTIATE && ssResult == SEC_E_OK))
            {
                _pRequest->SetAuthState(AUTHSTATE_CHALLENGE);
            }        
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        DEBUG_PRINT (HTTP, ERROR, ("AuthenticateUser faulted!\n"));
        dwError = ERROR_BAD_FORMAT;
        _pSPMData->eState = STATE_ERROR;
    }
    ENDEXCEPT

    if (_szAlloc)
    {
        delete _szAlloc;
        _szAlloc = NULL;
        _szData = NULL;
    }

    _cbData = 0;

exit:
    _CtxCriSec.Unlock();
    return dwError;
}

LPSTR PLUG_CTX::GetFQDN(LPSTR lpszHostName)
{
    if (lstrcmpi(GetScheme(), "Negotiate")) // only need to get FQDN for Kerberos
    {
        return NULL;
    }

    if (_pszFQDN)
    {
        return _pszFQDN;
    }

    SERIALIZED_LIST* pResolverCache = GetRootHandle(_pRequest)->GetResolverCache()->GetResolverCacheList();
    LPHOSTENT lpHostent;
    DWORD TTL;
    if (QueryHostentCache(pResolverCache,
                          (LPSTR)lpszHostName, 
                          NULL, 
                          &lpHostent, 
                          &TTL)) 
    {
        _pszFQDN = (lpHostent->h_name ? NewString(lpHostent->h_name) : NULL);
        ReleaseHostentCacheEntry(pResolverCache, lpHostent);
        return _pszFQDN;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\auth\passport.cxx ===
#include <wininetp.h>
#include <urlmon.h>
#include <splugin.hxx>
#include "htuu.h"

/*---------------------------------------------------------------------------
PASSPORT_CTX
---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------
    Constructor
---------------------------------------------------------------------------*/
PASSPORT_CTX::PASSPORT_CTX(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy, 
                    SPMData* pSPM, AUTH_CREDS* pCreds)
    : AUTHCTX(pSPM, pCreds)
{
    _fIsProxy = fIsProxy;

    _pRequest = pRequest;
    
    m_hLogon = NULL;

    m_pNewThreadInfo = NULL;
    m_pwszPartnerInfo = NULL;
    m_lpszRetUrl = NULL;

    m_wRealm[0] = '\0';
    m_FromPP[0] = '\0';

    ::MultiByteToWideChar(CP_ACP, 0, _pRequest->GetServerName(), -1, m_wTarget, MAX_AUTH_TARGET_LEN);
}

BOOL PASSPORT_CTX::Init(void)
{
    m_pNewThreadInfo = ::InternetCreateThreadInfo(FALSE);
    if (m_pNewThreadInfo == NULL)
    {
        return FALSE;
    }

    LPINTERNET_THREAD_INFO pCurrentThreadInfo = ::InternetGetThreadInfo();
    m_pNewThreadInfo->ThreadId = ::GetCurrentThreadId();
    ::InternetSetThreadInfo(m_pNewThreadInfo);
    
    m_pInternet = GetRootHandle (_pRequest);
    
    if (!m_pInternet->GetPPContext())
    {
        PP_CONTEXT hPP = ::PP_InitContext(L"WinHttp5.Dll", NULL);
        m_pInternet->SetPPContext(hPP);
        hPP = NULL;
    }
    
    ::InternetSetThreadInfo(pCurrentThreadInfo);

    if (!m_pInternet->GetPPContext())
    {
        return FALSE;
    }
    
    return TRUE;
}
/*---------------------------------------------------------------------------
    Destructor
---------------------------------------------------------------------------*/
PASSPORT_CTX::~PASSPORT_CTX()
{
    LPINTERNET_THREAD_INFO pCurrentThreadInfo = ::InternetGetThreadInfo();
    
    m_pNewThreadInfo->ThreadId = ::GetCurrentThreadId();
    ::InternetSetThreadInfo(m_pNewThreadInfo);
    
    if (m_hLogon)
    {
        ::PP_FreeLogonContext(m_hLogon);
        m_hLogon = NULL;
    }

    ::InternetSetThreadInfo(pCurrentThreadInfo);

    if (m_pNewThreadInfo)
    {
        ::InternetFreeThreadInfo(m_pNewThreadInfo);
    }

    if (m_pwszPartnerInfo)
    {
        delete [] m_pwszPartnerInfo;
    }

    if (m_lpszRetUrl)
    {
        delete [] m_lpszRetUrl;
    }

}

CHAR g_szPassportDAHost[256];

BOOL PASSPORT_CTX::CallbackRegistered(void)
{
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo)
    {
        WINHTTP_STATUS_CALLBACK appCallback = 
            ((INTERNET_HANDLE_BASE *)lpThreadInfo->hObjectMapped)->GetStatusCallback();

        if (appCallback != NULL) 
        {
            return TRUE;
        }
    }

    return FALSE;
}


DWORD PASSPORT_CTX::HandleSuccessfulLogon(
    LPWSTR  pwszFromPP,
    PDWORD  pdwFromPP,
    BOOL    fPreAuth
    )
{
    // biaow-todo: I am betting the RU DWORD UrlLength = 1024;
    LPWSTR pwszUrl = (LPWSTR) ALLOCATE_FIXED_MEMORY(1024 * sizeof(WCHAR));
    DWORD dwwUrlLength = 1024;//             won't be too long, but I could be wrong 
    LPSTR pszUrl = (LPSTR) ALLOCATE_FIXED_MEMORY(dwwUrlLength * sizeof(CHAR));
    BOOL fRetrySameUrl;
    DWORD dwRet = ERROR_SUCCESS;

    if (pwszUrl == NULL || pszUrl == NULL)
    {
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    if (::PP_GetAuthorizationInfo(m_hLogon,
                                  pwszFromPP, 
                                  pdwFromPP,
                                  &fRetrySameUrl,
                                  pwszUrl,
                                  &dwwUrlLength
                                  ) == FALSE)    
    {
        INET_ASSERT(TRUE); // this shouldn't happen
        dwRet = ERROR_WINHTTP_LOGIN_FAILURE;
        goto exit;
    }

    // save the DA Host name for Logout security check
    WCHAR wszDAHost[256];
    DWORD dwHostLen = ARRAY_ELEMENTS(wszDAHost);
    if (::PP_GetLogonHost(m_hLogon, 
                          wszDAHost, &dwHostLen) == TRUE)
    {
        ::WideCharToMultiByte(CP_ACP, 0, wszDAHost, -1, g_szPassportDAHost, 256, NULL, NULL);
    }

    if (!fRetrySameUrl)
    {
        if (_pRequest->GetMethodType() == HTTP_METHOD_TYPE_GET)
        {
            // DA wanted us to GET to a new Url
            ::WideCharToMultiByte(CP_ACP, 0, pwszUrl, -1, pszUrl, 1024, NULL, NULL);
        }
        else
        {
            fRetrySameUrl = TRUE; // *** WinHttp currently supports retry custom verb to same URL only ***
        }
    }
    
    if (fPreAuth)
    {
        // We are sending, in the context of AuthOnRequest.

        if (fRetrySameUrl)
        {
            // DA told us to keep Verb & Url, so there is nothing more needs to be done
            goto exit;
        }
        
        // Regardless whether we are asked to handle redirect, we'll need to fake
        // that a 302 just came in. 
        
        // biaow-todo: this is causing problem for QueryHeaders(StatusCode). I don't know why yet...
        /*
        _pRequest->AddInternalResponseHeader(HTTP_QUERY_STATUS_TEXT, // use non-standard index, since we never query this normally
                                  "HTTP/1.0 302 Object Moved",
                                  strlen("HTTP/1.0 302 Object Moved")
                                  );
        _pRequest->AddInternalResponseHeader(HTTP_QUERY_LOCATION, 
                                             pszUrl, 
                                             strlen(pszUrl));
        */

        if (_pRequest->GetOpenFlags() & INTERNET_FLAG_NO_AUTO_REDIRECT)
        {
            if (!CallbackRegistered())
            {
                _pRequest->SetPPAbort(TRUE);
                dwRet = ERROR_WINHTTP_LOGIN_FAILURE;
                goto exit;
            }
        }
        
        ::InternetIndicateStatusString(WINHTTP_CALLBACK_STATUS_REDIRECT, pszUrl);
    }
    else
    {
        // We are receiving a 302, in the context of AuthOnResponse.
        
        // Here we need to re-play the request to lpszRetUrl. One way to 
        // achieve this is returning ERROR_INTERNET_FORCE_RETRY. But before
        // that, we'll need to remember the lpszRetUrl.

        // *NOTE* This is in effective an 401. To prevent the send path from
        // following the 302 Location: header, caller must set the status code
        // to 401.

        if (!fRetrySameUrl)
        {
            if (_pRequest->GetOpenFlags() & INTERNET_FLAG_NO_AUTO_REDIRECT)
            {
                if (!CallbackRegistered())
                {
                    dwRet = ERROR_WINHTTP_LOGIN_FAILURE;
                    goto exit;
                }

                ::InternetIndicateStatusString(WINHTTP_CALLBACK_STATUS_REDIRECT, pszUrl);
            }
        }
        
        dwRet = ERROR_WINHTTP_RESEND_REQUEST;
    }

    PCSTR lpszRetUrl = NULL;

    if (fRetrySameUrl)
    {
        lpszRetUrl = _pRequest->GetURL();
    }
    else
    {
        lpszRetUrl = pszUrl;
    }

    if (m_lpszRetUrl)
    {
        delete [] m_lpszRetUrl;
    }

    m_lpszRetUrl = new CHAR[strlen(lpszRetUrl) + 1];
    if (m_lpszRetUrl)
    {
        strcpy(m_lpszRetUrl, lpszRetUrl);
    }

exit:

    if (pwszUrl)
    {
        FREE_MEMORY(pwszUrl);
    }
    if (pszUrl)
    {
        FREE_MEMORY(pszUrl);
    }
    
    return dwRet;
}

/*---------------------------------------------------------------------------
    PreAuthUser
---------------------------------------------------------------------------*/
DWORD PASSPORT_CTX::PreAuthUser(IN LPSTR pBuf, IN OUT LPDWORD pcbBuf)
{
    DEBUG_ENTER ((
		DBG_HTTP,
        Dword,
        "PASSPORT_CTX::PreAuthUser",
        "this=%#x pBuf=%#x pcbBuf=%#x {%d}",
        this,
        pBuf,
        pcbBuf,
        *pcbBuf
        ));

    DWORD dwError = ERROR_SUCCESS;
    LPWSTR pwszFromPP = NULL;
    LPWSTR pwszUser = NULL;
    LPWSTR pwszPass = NULL;

    // Prefix the header value with the auth type.
    const static BYTE szPassport[] = "Passport1.4 ";
    #define PASSPORT_LEN sizeof(szPassport)-1
    
    if (m_FromPP[0] == '\0') 
    {
        DWORD dwFromPPLen = 2048;
        pwszFromPP = (LPWSTR) ALLOCATE_FIXED_MEMORY(dwFromPPLen * sizeof(WCHAR));

        if (pwszFromPP == NULL)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        LPINTERNET_THREAD_INFO pCurrentThreadInfo = ::InternetGetThreadInfo();

        m_pNewThreadInfo->ThreadId = ::GetCurrentThreadId();
        ::InternetSetThreadInfo(m_pNewThreadInfo);

        // if an app already specified creds, use them and do a pre-authentication.

        if (_pCreds->lpszUser && _pCreds->lpszPass)
        {
            pwszUser = (LPWSTR) ALLOCATE_FIXED_MEMORY((strlen(_pCreds->lpszUser) + 1) * sizeof(WCHAR));
            pwszPass = (LPWSTR) ALLOCATE_FIXED_MEMORY((strlen(_pCreds->lpszPass) + 1) * sizeof(WCHAR));

            if (pwszUser == NULL || pwszPass == NULL)
            {
                ::InternetSetThreadInfo(pCurrentThreadInfo);
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }

            ::MultiByteToWideChar(CP_ACP, 0, _pCreds->lpszUser, -1, pwszUser, strlen(_pCreds->lpszUser) + 1);
            ::MultiByteToWideChar(CP_ACP, 0, _pCreds->lpszPass, -1, pwszPass, strlen(_pCreds->lpszPass) + 1);

            ::PP_SetCredentials(m_hLogon, NULL, NULL, pwszUser, pwszPass);
        }

        // we could do a PP_SetCredentials(...null,null) here. But I don't think we need to.

        DWORD dwLogonStatus = ::PP_Logon(m_hLogon,
                                         0,
                                         NULL,
                                         0);

        ::InternetSetThreadInfo(pCurrentThreadInfo);

        if (dwLogonStatus != PP_LOGON_SUCCESS)
        {
            dwError = ERROR_WINHTTP_LOGIN_FAILURE;
            goto cleanup;
        }

        dwError = HandleSuccessfulLogon(pwszFromPP, &dwFromPPLen, TRUE);

        if (dwError == ERROR_WINHTTP_LOGIN_FAILURE)
        {
            goto cleanup;
        }
        
        ::WideCharToMultiByte(CP_ACP, 0, pwszFromPP, -1, m_FromPP, 2048, NULL, NULL);
    }

    // check to see if we need to update url

    if (m_lpszRetUrl)
    {
        _pRequest->ModifyRequest(_pRequest->GetMethodType(),
                                 m_lpszRetUrl,
                                 strlen(m_lpszRetUrl),
                                 NULL,
                                 0);
        delete [] m_lpszRetUrl;
        m_lpszRetUrl = NULL;
    }

    // Ticket and profile is already present
    
    // put in the header
    memcpy (pBuf, szPassport, PASSPORT_LEN);
    pBuf += PASSPORT_LEN;
    
    // append the ticket
    strcpy(pBuf, m_FromPP);
    *pcbBuf = PASSPORT_LEN + strlen(m_FromPP);

cleanup:
    if (pwszFromPP)
        FREE_MEMORY(pwszFromPP);
    if (pwszUser)
        FREE_MEMORY(pwszUser);
    if (pwszPass)
        FREE_MEMORY(pwszPass);
exit:
    DEBUG_LEAVE(dwError);
    return dwError;
}

/*---------------------------------------------------------------------------
    UpdateFromHeaders
---------------------------------------------------------------------------*/
DWORD PASSPORT_CTX::UpdateFromHeaders(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy)
{
    DEBUG_ENTER ((
		DBG_HTTP,
        Dword,
        "PASSPORT_CTX::UpdateFromHeaders", 
        "this=%#x request=%#x isproxy=%B",
        this,
        pRequest,
        fIsProxy
        ));

    DWORD dwAuthIdx, cbChallenge, dwError;
    LPSTR szChallenge = NULL;

    LPINTERNET_THREAD_INFO pCurrentThreadInfo = NULL;
    LPINTERNET_THREAD_INFO pNewThreadInfo = NULL;
    
    // Get the associated header.
    if ((dwError = FindHdrIdxFromScheme(&dwAuthIdx)) != ERROR_SUCCESS)
        goto exit;

    // Get the complete auth header.
    dwError = GetAuthHeaderData(pRequest, fIsProxy, NULL, 
        &szChallenge, &cbChallenge, ALLOCATE_BUFFER, dwAuthIdx);

    if (dwError != ERROR_SUCCESS)
    {
        szChallenge = NULL;
        goto exit;
    }

    if (!_pCreds)
    {
        _pCreds = CreateCreds(pRequest, fIsProxy, _pSPMData, NULL);
        if (!_pCreds)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
    }
    
    if (m_pwszPartnerInfo)
    {
        delete [] m_pwszPartnerInfo;
    }

    {
        HTTP_METHOD_TYPE tOrgMethod = _pRequest->GetMethodType();
        PCSTR pszOrgVerb;
        ::MapHttpMethodType(tOrgMethod, &pszOrgVerb);
        PCSTR pszOrgUrl = _pRequest->GetURL();

        const LPWSTR pwszOrgVerbAttr = L",OrgVerb=";
        const LPWSTR pwszOrgUrlAttr =  L",OrgUrl=";

        DWORD dwPartnerInfoLength = cbChallenge 
                                    +::wcslen(pwszOrgVerbAttr)
                                    +::strlen(pszOrgVerb)
                                    +::wcslen(pwszOrgUrlAttr)
                                    +::strlen(pszOrgUrl)
                                    + 1; // NULL terminator
        
        DWORD dwSize = 0;
        PWSTR pwszPartnerInfo = NULL;

        m_pwszPartnerInfo = new WCHAR[dwPartnerInfoLength];
        if (m_pwszPartnerInfo == NULL)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        pwszPartnerInfo = m_pwszPartnerInfo;

        dwSize = ::MultiByteToWideChar(CP_ACP, 0, szChallenge, -1, pwszPartnerInfo, dwPartnerInfoLength) - 1;
        ::wcscat(pwszPartnerInfo, pwszOrgVerbAttr);
        pwszPartnerInfo += (dwSize + wcslen(pwszOrgVerbAttr));
        dwPartnerInfoLength -= (dwSize + wcslen(pwszOrgVerbAttr));
        dwSize = ::MultiByteToWideChar(CP_ACP, 0, pszOrgVerb, -1, pwszPartnerInfo, dwPartnerInfoLength) - 1;
        ::wcscat(pwszPartnerInfo, pwszOrgUrlAttr);
        pwszPartnerInfo += (dwSize + wcslen(pwszOrgUrlAttr));
        dwPartnerInfoLength -= (dwSize + wcslen(pwszOrgUrlAttr));
        dwSize = ::MultiByteToWideChar(CP_ACP, 0, pszOrgUrl, -1, pwszPartnerInfo, dwPartnerInfoLength) - 1;

        dwError = ERROR_SUCCESS;
    }

exit:

    if (szChallenge)
        delete []szChallenge;

    DEBUG_LEAVE(dwError);
    return dwError;
}

BOOL PASSPORT_CTX::InitLogonContext(void)
{
    // set up the thread context before calling the Passport auth library
    
    LPINTERNET_THREAD_INFO pCurrentThreadInfo = ::InternetGetThreadInfo();
    m_pNewThreadInfo->ThreadId = ::GetCurrentThreadId();
    ::InternetSetThreadInfo(m_pNewThreadInfo);

    if (!m_hLogon)
    {
        INET_ASSERT(m_pInternet->GetPPContext()); // must have been initialized in the Init() call

        m_hLogon = ::PP_InitLogonContext(
                                        m_pInternet->GetPPContext(),
                                        m_pwszPartnerInfo,
                                        (_pRequest->GetOpenFlags() & INTERNET_FLAG_NO_COOKIES)
                                        );
    }

    // restore the WinHttp thread context
    ::InternetSetThreadInfo(pCurrentThreadInfo);
    
    return m_hLogon != NULL;
}

/*---------------------------------------------------------------------------
    PostAuthUser
---------------------------------------------------------------------------*/
DWORD PASSPORT_CTX::PostAuthUser()
{
    DEBUG_ENTER ((
                 DBG_HTTP,
                 Dword,
                 "PASSPORT_CTX::PostAuthUser",
                 "this=%#x",
                 this
                 ));

    LPWSTR pwszUser = NULL;
    LPWSTR pwszPass = NULL;
    DWORD dwRet = ERROR_SUCCESS;

    if (InitLogonContext() == FALSE)
    {
        dwRet = ERROR_WINHTTP_LOGIN_FAILURE;
        goto Cleanup;
    }

    // if an app already specified creds, use them and do a pre-authentication.
    
    if (_pCreds->lpszUser && _pCreds->lpszPass)
    {
        pwszUser = (LPWSTR) ALLOCATE_FIXED_MEMORY(1024*sizeof(WCHAR));
        pwszPass = (LPWSTR) ALLOCATE_FIXED_MEMORY(1024*sizeof(WCHAR));

        if (pwszUser && pwszPass)
        {
            ::MultiByteToWideChar(CP_ACP, 0, _pCreds->lpszUser, -1, pwszUser, 1024);
            ::MultiByteToWideChar(CP_ACP, 0, _pCreds->lpszPass, -1, pwszPass, 1024);

            ::PP_SetCredentials(m_hLogon, NULL, NULL, pwszUser, pwszPass);
        }
        else
        {
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
        
    }
        
    // Ok, Let's give it a try

    LPINTERNET_THREAD_INFO pCurrentThreadInfo = ::InternetGetThreadInfo();
    m_pNewThreadInfo->ThreadId = ::GetCurrentThreadId();
    ::InternetSetThreadInfo(m_pNewThreadInfo);
    
    DWORD dwLogonStatus = ::PP_Logon(m_hLogon, 
                                     0, 
                                     NULL, 
                                     0);

    // restore the WinHttp thread context
    ::InternetSetThreadInfo(pCurrentThreadInfo);

    if (dwLogonStatus == PP_LOGON_FAILED)
    {
        // App/User supplied wrong creds, sorry.
        
        dwRet = ERROR_WINHTTP_LOGIN_FAILURE;
    }
    else if (dwLogonStatus == PP_LOGON_REQUIRED)
    {
        // no creds specified, we are required to sign on.
        
        // change from 302 to 401
        _pRequest->ReplaceResponseHeader(HTTP_QUERY_STATUS_CODE,
                                        "401", strlen("401"),
                                        0, HTTP_ADDREQ_FLAG_REPLACE);

        // biaow-todo: 1) nice to replace the status text as well; weird to have "HTTP/1.1 401 object moved"
        // for example 2) remove the Location: header
        
        if (RetryLogon() == TRUE)
        {
            dwRet = ERROR_WINHTTP_RESEND_REQUEST;
        }
        else
        {
            dwRet = ERROR_WINHTTP_INCORRECT_PASSWORD;
        }
    }
    else if (dwLogonStatus == PP_LOGON_SUCCESS)
    {
        // wow! we got in!!!

        LPWSTR pwszFromPP = (LPWSTR) ALLOCATE_FIXED_MEMORY(2048*sizeof(WCHAR));
        DWORD dwFromPPLen = 2048;

        if (pwszFromPP)
        {
            dwRet = HandleSuccessfulLogon(pwszFromPP, &dwFromPPLen, FALSE);
            if (dwRet != ERROR_WINHTTP_LOGIN_FAILURE)
            {
                ::WideCharToMultiByte(CP_ACP, 0, pwszFromPP, -1, m_FromPP, 2048, NULL, NULL);
            }
            FREE_MEMORY(pwszFromPP);
        }
        else
        {
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else
    {
        dwRet = ERROR_WINHTTP_LOGIN_FAILURE;
    }

Cleanup:
    _pRequest->SetStatusCode(401);  // this is needed to prevent send code from tracing Location: header

    if (pwszUser)
        FREE_MEMORY(pwszUser);
    if (pwszPass)
        FREE_MEMORY(pwszPass);

    DEBUG_LEAVE(dwRet);
    return dwRet;
}

/*---------------------------------------------------------------------------
PASSPORT_CTX::PromptForCreds
---------------------------------------------------------------------------*/
BOOL PASSPORT_CTX::RetryLogon(void)
{
    DEBUG_ENTER ((
		DBG_HTTP,
        Dword,
        "PASSPORT_CTX::PromptForCreds",
        "this=%#x",
        this
        ));

    // WCHAR wUser[1024] = {0}; LPWSTR pwszUser = NULL; 
    // WCHAR wPass[1024] = {0}; LPWSTR pwszPass = NULL;
    BOOL fRetry = FALSE;

    INET_ASSERT(m_hLogon != 0);

    BOOL fPrompt = FALSE;
    WCHAR wRealm[MAX_AUTH_REALM_LEN];
    ::PP_GetChallengeInfo(m_hLogon, 
                          NULL, &fPrompt, 
                          NULL, 0, 
                          wRealm, MAX_AUTH_REALM_LEN);

    if (fPrompt)
    {
        goto exit;
    }

    /*
    if (_pCreds->GetUser() && _pCreds->GetPass())
    {
        ::MultiByteToWideChar(CP_ACP, 0, _pCreds->GetUser(), -1, wUser, 1024);
        ::MultiByteToWideChar(CP_ACP, 0, _pCreds->GetPass(), -1, wPass, 1024);

        pwszUser = wUser;
        pwszPass = wPass; 
    }
    */

    if (::PP_SetCredentials(m_hLogon, wRealm, m_wTarget, NULL, NULL) == TRUE)
    {
        fRetry = TRUE;
        goto exit;
    }

exit:

    DEBUG_LEAVE((DWORD) fRetry);
    return (DWORD) fRetry;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\auth\uudec.c ===
#include <stdio.h>
#include "htuu.h"

int main (int argc, char **argv)
{
    char outbuf[500];
    char *pOut = outbuf;
    int cbOut = (strlen(argv[1]) * 3) / 4;

    if (argc != 2)
    {
        fprintf (stderr, "usage: uudec <base64-string>\n");
        exit (1);
    }
    
    HTUU_decode (argv[1], pOut, sizeof(outbuf));

    while (cbOut--)
    {
        printf ("%02x %c\n", (unsigned char) *pOut, *pOut);
        pOut++;
    }
        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\auth\sspi.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    sspi.c

Abstract:

    This file contains the implementation for SSPI Authentication 

    The following functions are exported by this module:

    UnloadAuthenticateUser
	AuthenticateUser
	PreAuthenticateUser
    AuthenticateUserUI

Author:

    Sudheer Koneru	(SudK)	Created	2/17/96

Revision History:


--*/

#include <wininetp.h>
#include "htuu.h"
//#include "msnspmh.h"
#ifdef DEBUG_WINSSPI
#include <stdio.h>
#endif

#include "auth.h"
#include "internal.h"
//LPSTR StrChrA(LPCSTR lpStart, WORD wMatch); // from shlwapi.h

#include "sspspm.h"
#include "winctxt.h"

extern SspData  *g_pSspData;
LPVOID SSPI_InitGlobals(void);


DWORD g_cSspiContexts;

#define NAME_SEPERATOR  0x5c    // this is a backslash character which 
                                // seperates the domain name from user name

VOID
WINAPI
UnloadAuthenticateUser(LPVOID *lppvContext,
					   LPSTR lpszScheme,
					   LPSTR lpszHost)
{

	PWINCONTEXT		pWinContext = (PWINCONTEXT) (*lppvContext);

    if (!SSPI_InitGlobals())
        return;

	if (*lppvContext == NULL)	{
		return;
	}

    if (pWinContext->pInBuffer != NULL && 
        pWinContext->pInBuffer != pWinContext->szInBuffer)
    {
        LocalFree (pWinContext->pInBuffer);
    }
    pWinContext->pInBuffer = NULL;
    pWinContext->dwInBufferLength = 0;

    // Free SSPI security context
    //
	if (pWinContext->pSspContextHandle != NULL)
		(*(g_pSspData->pFuncTbl->DeleteSecurityContext))(pWinContext->pSspContextHandle);

    //  Free SSPI credential handle
    //
    if (pWinContext->pCredential)
        (*(g_pSspData->pFuncTbl->FreeCredentialHandle))(pWinContext->pCredential);
    pWinContext->pCredential = NULL;
    pWinContext->pSspContextHandle = NULL;
 
	if ( (pWinContext->lpszServerName != NULL) &&
		 (pWinContext->lpszServerName != pWinContext->szServerName) )
	{
		LocalFree(pWinContext->lpszServerName);
	}

	LocalFree(pWinContext);

	*lppvContext = NULL;

	AuthLock();
    g_cSspiContexts--;
    AuthUnlock();

	return;
}


//+---------------------------------------------------------------------------
//
//  Function:   SaveServerName
//
//  Synopsis:   This function saves the destination server name in this
//              connection context for AuthenticateUserUI
//
//  Arguments:  [lpszServerName] - points to the target server name
//              [pWinContext] - points to the connection context
//
//  Returns:    TRUE if server name is successfully saved in connection context.
//              Otherwise, FALSE is returned.
//
//----------------------------------------------------------------------------
BOOL
SaveServerName (
	LPSTR 			lpszServerName,
	PWINCONTEXT		pWinContext
    )
{
	DWORD dwLen = lstrlen(lpszServerName);

	if (dwLen < DEFAULT_SERVER_NAME_LEN)
	{
		lstrcpy(pWinContext->szServerName, lpszServerName);
		pWinContext->lpszServerName = pWinContext->szServerName;
	}
	else
	{   //
        //  Server name is longer, need to allocate memory for the name
        //

        //  Free already allocated memory if any
		if (pWinContext->lpszServerName && 
			pWinContext->lpszServerName != pWinContext->szServerName)
		{
			LocalFree (pWinContext->lpszServerName);
		}

		pWinContext->lpszServerName = (char *) LocalAlloc(0, dwLen+1);

		if (pWinContext->lpszServerName == NULL)
			return FALSE;

		lstrcpy(pWinContext->lpszServerName, lpszServerName);
	}

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   BuildNTLMauthData
//
//  Synopsis:   This function builds SEC_WINNT_AUTH_IDENTITY structure 
//              from the user name and password specified.  If domain name 
//              is not specified in the user name, the Domain field in 
//              the structure is set to NULL.  NOTE: This structure is 
//              specific to the NTLM SSPI package.
//              This function allocates a chunck of memory big enough for 
//              storing user name, domain, and password. Then setup 
//              pointers in pAuthData to use sections of this memory.
//
//  Arguments:  [pAuthData] - points to the SEC_WINNT_AUTH_IDENTITY structure
//              [lpszUserName] - points to the user name, which may also 
//                               include user's domain name.
//              [lpszPassword] - points to user's password
//
//  Returns:    TRUE if SEC_WINNT_AUTH_IDENTITY structure is successfully 
//              initialized and built.  Otherwise, FALSE is returned.
//
//----------------------------------------------------------------------------
BOOL
BuildNTLMauthData (
    PSEC_WINNT_AUTH_IDENTITY pAuthData, 
	LPTSTR       lpszUserName,
	LPTSTR       lpszPassword
    )
{
    DWORD  dwUserLen, dwDomainLen, dwPwdLen;
    LPTSTR pName;
    LPTSTR pDomain = NULL;

    //
    //  Check to see if domain name is specified in lpszUserName
    //
    pAuthData->Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
    pName = StrChrA (lpszUserName, NAME_SEPERATOR);

    if (pName)  // Domain name specified
    {
        // Make sure that we don't change the original string in lpszUserName 
        // because that it would be reused for other connections

        // Calculate no. of bytes in domain name
        dwDomainLen = (int)(pName - lpszUserName);

        // Convert to no. of characters
        pAuthData->DomainLength = dwDomainLen / sizeof(TCHAR);

        pDomain = lpszUserName;
        pName++;
    }
    else        // No domain specified
    {
        pName = lpszUserName;
        pAuthData->Domain = NULL;
        pDomain = NULL;
        dwDomainLen = pAuthData->DomainLength = 0;
    }

    dwUserLen = pAuthData->UserLength = lstrlen (pName);
    dwPwdLen = pAuthData->PasswordLength = lstrlen (lpszPassword);

    //
    //  Allocate memory for all: name, domain, and password
    //
    pAuthData->User = (UCHAR*) LocalAlloc (LMEM_ZEROINIT, 
                                           dwUserLen + dwDomainLen + dwPwdLen +
                                           sizeof(TCHAR) * 3);
    if (pAuthData->User == NULL)
        return (FALSE);

    CopyMemory (pAuthData->User, pName, dwUserLen);

    //  Setup memory pointer for password
    //
    pAuthData->Password = (UCHAR*)((UINT_PTR)pAuthData->User + 
                                   dwUserLen + sizeof(TCHAR));
    CopyMemory (pAuthData->Password, lpszPassword, dwPwdLen);

    if (pAuthData->DomainLength > 0)
    {
        //  Setup memory pointer for domain
        //
        pAuthData->Domain = (UCHAR*)((UINT_PTR)pAuthData->Password + 
                                     dwPwdLen + sizeof(TCHAR));
        CopyMemory (pAuthData->Domain, pDomain, dwDomainLen);
    }
    else
    {
       pAuthData->Domain = NULL;
    }

    return (TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   FreeNTLMauthData
//
//  Synopsis:   This function frees memory allocated for the 
//              SEC_WINNT_AUTH_IDENTITY structure
//
//  Arguments:  [pAuthData] - points to the SEC_WINNT_AUTH_IDENTITY structure
//
//  Returns:    void.
//
//----------------------------------------------------------------------------
VOID
FreeNTLMauthData (
    PSEC_WINNT_AUTH_IDENTITY pAuthData
    )
{
    //
    //  Free User which points to memory for all domain, name, and password
    //
    if (pAuthData->User)
        LocalFree (pAuthData->User);
}

//+---------------------------------------------------------------------------
//
//  Function:   NewWinContext
//
//  Synopsis:   This function creates a new context and a new credential 
//              handle for this connection.  If a user name/password is 
//              specified, the credential handle is created for the 
//              specified user.  Otherwise, the credential handle is created 
//              for the local logon user.
//
//  Arguments:  [pkgId] - the package ID (index into SSPI package list)
//              [lpszScheme] - the name of the current authentication scheme,
//                             which is also the SSPI package name
//              [ppCtxt] - this returns the pointer of the created context 
//                         to the caller.
//              [lpszUserName] - the name of a specific user to be used 
//                               for authentication. If this is NULL, the 
//                               credential of the currently logon user is 
//                               used for authentication.
//              [lpszPassword] - the password of the specified user, if any.
//
//  Returns:    ERROR_SUCCESS - if the new context is created successfully
//              ERROR_NOT_ENOUGH_MEMORY - if memory allocation failed
//              ERROR_INVALID_PARAMETER - the SSPI call for creating the 
//                              security credential handle failed
//
//----------------------------------------------------------------------------
DWORD
NewWinContext (
    INT         pkgId, 
	LPSTR       lpszScheme,
    PWINCONTEXT *ppCtxt,
    BOOL        fCanUseLogon,
	LPSTR       lpszUserName,
	LPSTR       lpszPassword
    )
{
    SECURITY_STATUS ss;
    TimeStamp   Lifetime;
    PWINCONTEXT pWinContext;
    SEC_WINNT_AUTH_IDENTITY  AuthData;
    PSEC_WINNT_AUTH_IDENTITY pAuthData;
    DWORD Capabilities ;

    DWORD SecurityBlobSize;

    //
    // need space for maxtoken size for in+out, + base64 encoding overhead for each.
    // really 1.34 overhead, but just round up to 1.5
    //
    SecurityBlobSize = GetPkgMaxToken(pkgId);
    SecurityBlobSize += (SecurityBlobSize/2);

    //
    // note: for compatibility sake, make the buffer size the MAX_BLOB_SIZE at the minimum
    // consider removing this once we're convinced all packages return good cbMaxToken values.
    //

    if( SecurityBlobSize < MAX_BLOB_SIZE )
    {
        SecurityBlobSize = MAX_BLOB_SIZE;
    }


    pWinContext = (PWINCONTEXT) LocalAlloc(
                        0,
                        sizeof(WINCONTEXT) +
                        (SecurityBlobSize*2)
                        );
	if (pWinContext == NULL)
		return (ERROR_NOT_ENOUGH_MEMORY);
		
    //  Initialize context
    //
    ZeroMemory( pWinContext, sizeof(WINCONTEXT) );
	pWinContext->pkgId = (DWORD)pkgId;
	
    pWinContext->szOutBuffer = (char*)(pWinContext+1);
    pWinContext->cbOutBuffer = SecurityBlobSize;

    pWinContext->szInBuffer = pWinContext->szOutBuffer + pWinContext->cbOutBuffer;
    pWinContext->cbInBuffer = SecurityBlobSize;

    //
    // Get bitmask representing the package capabilities
    //

    Capabilities = GetPkgCapabilities( pkgId );

    if ( ( Capabilities & SSPAUTHPKG_SUPPORT_NTLM_CREDS ) == 0 )
    {
        pAuthData = NULL;
    }
    else if (lpszUserName && lpszPassword)
    {
        //  Build AuthData from the specified user name/password
        if (!BuildNTLMauthData (&AuthData, lpszUserName, lpszPassword))
        {
            LocalFree (pWinContext);
            return (ERROR_NOT_ENOUGH_MEMORY);
        }

        pAuthData = &AuthData;
    }
    else if (fCanUseLogon)
    {
        // The zone policy allows silent use of the logon credential.
        pAuthData = NULL;
    }
    else
    {
        LocalFree (pWinContext);
        // We must prompt the user for credentials.
        return ERROR_WINHTTP_INCORRECT_PASSWORD;
    }

    //
    //  Call SSPI function acquire security credential for this package
    //
    ss = (*(g_pSspData->pFuncTbl->AcquireCredentialsHandle))(
                       NULL,                // New principal
                       lpszScheme,          // SSPI Package Name
                       SECPKG_CRED_OUTBOUND,// Credential Use
                       NULL,                // Logon ID
                       pAuthData,           // Auth Data
                       NULL,                // Get key func
                       NULL,                // Get key arg
                       &pWinContext->Credential,    // Credential Handle
                       &Lifetime );

    if (pAuthData)
        FreeNTLMauthData (pAuthData);

    if (ss != STATUS_SUCCESS)
    {
        LocalFree (pWinContext);
		return (ERROR_INVALID_PARAMETER);
    }

    pWinContext->pCredential = &pWinContext->Credential;

    *ppCtxt = pWinContext;

	AuthLock();
    g_cSspiContexts++;
    AuthUnlock();

    return (ERROR_SUCCESS);
}

//+---------------------------------------------------------------------------
//
//  Function:   RedoNTLMAuth4User
//
//  Synopsis:   This function recreates a NTLM credential handle for the 
//              specified user and generate a NEGOTIATE message in 
//              the provided buffer with the new credential handle.
//
//  Arguments:  [pWinContext] - points to the connection context
//              [pkgId] - specifies the SSPI pkg to be used for authentication
//              [lpszUserName] - the name of the specific user to be used 
//                               for authentication. 
//              [lpszPassword] - the password of the specified user,
//              [lpszServerName] - the target server name
//              [lpszScheme] - the name of the current authentication scheme,
//                             which is also the SSPI package name
//              [lpOutBuffer] - points to the buffer for the new authorization 
//                              header including the UUENCODED NEGOTIATE msg
//              [lpdwOutBufferLength] - returns the length of the generated 
//                                      authorization header.
//
//  Returns:    ERROR_SUCCESS - if the new authorization header is successfully 
//                              created for the new user name/password
//              ERROR_NOT_ENOUGH_MEMORY - if memory allocation failed
//              ERROR_INVALID_HANDLE - the SSPI call for generating the 
//                              new NEGOTIATE msg failed
//
//----------------------------------------------------------------------------
DWORD
RedoNTLMAuth4User (
	PWINCONTEXT	pWinContext, 
    INT         pkgId, 
	LPSTR       lpszUserName,
	LPSTR       lpszPassword, 
	LPSTR       lpszServerName,
	LPSTR       lpszScheme,
    IN BOOL     fCanUseLogon,
	LPSTR       lpOutBuffer,
	LPDWORD     lpdwOutBufferLength,
	SECURITY_STATUS *pssResult
    )
{
    SECURITY_STATUS         ss;
    DWORD                   dwStatus;
    TimeStamp               Lifetime;
    SEC_WINNT_AUTH_IDENTITY AuthData;
    ULONG                   fContextReq = ISC_REQ_DELEGATE;
    DWORD                   dwMaxLen;

   	if (pWinContext->pSspContextHandle)
   	{
		(*(g_pSspData->pFuncTbl->DeleteSecurityContext))(pWinContext->pSspContextHandle);
   	    pWinContext->pSspContextHandle = NULL;
	}

    //  Free existing credential handle
    //
    if (pWinContext->pCredential)
    {
    	(*(g_pSspData->pFuncTbl->FreeCredentialHandle))(pWinContext->pCredential);
        pWinContext->pCredential = NULL;
    }
    //
    //  Build the NTLM SSPI AuthData from the specified user name/password
    //
    if (!BuildNTLMauthData (&AuthData, lpszUserName, lpszPassword))
        return (ERROR_NOT_ENOUGH_MEMORY);

    //
    //  Call SSPI function acquire security credential for this user
    //
    ss = (*(g_pSspData->pFuncTbl->AcquireCredentialsHandle))(
                       NULL,                // New principal
                       lpszScheme,          // SSPI Package Name
                       SECPKG_CRED_OUTBOUND,// Credential Use
                       NULL,                // Logon ID
                       &AuthData,           // Auth Data
                       NULL,                // Get key func
                       NULL,                // Get key arg
                       &pWinContext->Credential,    // Credential Handle
                       &Lifetime );

    FreeNTLMauthData (&AuthData);   // don't need it any more

    if (ss != STATUS_SUCCESS)
    {
		return (ERROR_INVALID_HANDLE);
    }

    pWinContext->pCredential = &pWinContext->Credential;

    dwMaxLen = *lpdwOutBufferLength;

    //
    //  Generate NEGOTIATE message in the provided buffer for this user 
    //
    dwStatus =  GetSecAuthMsg( g_pSspData,
                                pWinContext->pCredential,
                                pkgId,
                                NULL, 
                                &(pWinContext->SspContextHandle),
                                fContextReq,
                                NULL,
                                0,
                                lpOutBuffer,
                                lpdwOutBufferLength,
                                lpszServerName,
                                fCanUseLogon,
                                TRUE,
                                lpszScheme,
                                pssResult);
    
    if (dwStatus != SPM_STATUS_OK)
    {
        *lpdwOutBufferLength = 0; // no exchange blob generated
        return(ERROR_INVALID_HANDLE);
    }

    pWinContext->pSspContextHandle = &(pWinContext->SspContextHandle);

    //
    //  If we are not in the initial state, continue to a RESPONSE message
    //
    if (pWinContext->pInBuffer != NULL && pWinContext->dwInBufferLength > 0)
    {
        *lpdwOutBufferLength = dwMaxLen;
        ZeroMemory( lpOutBuffer, dwMaxLen );

        dwStatus = GetSecAuthMsg( g_pSspData,
                                pWinContext->pCredential,
                                pWinContext->pkgId,
                                pWinContext->pSspContextHandle,
                                (PCtxtHandle) &(pWinContext->SspContextHandle),
                                fContextReq,
                                pWinContext->pInBuffer, 
                                pWinContext->dwInBufferLength, 
                                lpOutBuffer,
                                lpdwOutBufferLength,
                                pWinContext->lpszServerName,
                                fCanUseLogon,
                                TRUE,
                                lpszScheme,
                                pssResult);

        //  Clear out the input exchange blob
        //
        if (pWinContext->pInBuffer != NULL)
        {
            if (pWinContext->pInBuffer != pWinContext->szInBuffer)
                LocalFree (pWinContext->pInBuffer);
            pWinContext->pInBuffer = NULL;
            pWinContext->dwInBufferLength = 0;
        }

        if (dwStatus != SPM_STATUS_OK)
        {
            *lpdwOutBufferLength = 0; // no exchange blob generated
            return(ERROR_INVALID_HANDLE);
        }
    }

    return (ERROR_SUCCESS);
}


//
// functions
//

/*++

Routine Description:

    Generates a Basic User Authentication string for WinINet or 
	other callers can use

Arguments:

	lpContext               - if the package accepts the request & authentication
					requires multiple transactions, the package will supply
					a context value which will be used in subsequent calls,
					Currently this contains a pointer to a pointer of a 
					User defined Void Pointer.  Can be Assume to be NULL
					if this is the first instance of a Realm - Host Combo

	lpszServerName  - the name of the server we are performing 
					authentication for. We may want to supply the full URL
					
	lpszScheme              - the name of the authentication scheme we are seeking, in case the package supports multiple schemes

	dwFlags                 - on input, flags modifying how the package should behave,
					e.g. "only authenticate if you don't have to get user 
					information"  On output contains flags relevant to
					future HTTP requests, e.g. "don't cache any data from 
					this connection". Note, this information should not be 
					specific to HTTP - we may want to use the same flags 
					for FTP, etc.
	
	lpszInBuffer              - pointer to the string containing the response from
					the server (if any)

	dwInBufferLength - number of bytes in lpszInBuffer. No CR-LF sequence, no terminating NUL

	lpOutBuffer -   pointer to a buffer where the challenge response will be written by the 
					package if it can handle the request

	lpdwOutBufferLength - on input, contains the size of lpOutBuffer. On output, contains the
						  number of bytes to return to the server in the next GET request 
						  (or whatever). If lpOutBuffer is too small, the package should 
						  return ERROR_INSUFFICIENT_BUFFER and set *lpdwOutBufferLength to be
						  the required length

	We will keep a list of the authentication packages and the schemes they support, 
	along with the entry point name (should be the same for all packages) in the registry. 

	Wininet should keep enough information such that it can make a reasonable guess as to
	whether we need to authenticate a connection attempt, or whether we can use previously 
	authenticated information


Return Value:

    DWORD
	Success - non-zero 
	Failure - 0. Error status is available by calling GetLastError()

--*/
DWORD
WINAPI
AuthenticateUser(
	IN OUT LPVOID *lppvContext,
	IN LPSTR lpszServerName,
	IN LPSTR lpszScheme,
	IN BOOL  fCanUseLogon,
	IN LPSTR lpszInBuffer,
	IN DWORD dwInBufferLength,
	IN LPSTR lpszUserName,
	IN LPSTR lpszPassword,
	OUT SECURITY_STATUS *pssResult
	)
{
	PWINCONTEXT		pWinContext;
    LPSTR           pServerBlob = NULL;
	int		        pkgId;
    DWORD           SPMStatus;
    ULONG           fContextReq = ISC_REQ_DELEGATE;
    BOOL            bNonBlock = TRUE;

    if (!SSPI_InitGlobals())
        return ERROR_INVALID_PARAMETER;

	
    pkgId = GetPkgId(lpszScheme);

    if (pkgId == -1) 
        return (ERROR_INVALID_PARAMETER);

	if (*lppvContext == NULL)   // a new connection
    {
        char msg[1024];
        DWORD dwStatus;

		//
		// First time we are getting called here, there should be no input blob
		//
        if (dwInBufferLength != 0)
			return (ERROR_INVALID_PARAMETER);

        dwStatus = NewWinContext (pkgId, lpszScheme, &pWinContext,
            fCanUseLogon, lpszUserName, lpszPassword);
		if (dwStatus != ERROR_SUCCESS)
			return (dwStatus);

		(*lppvContext) = (LPVOID) pWinContext;
#ifdef DEBUG_WINSSPI
        (void)wsprintf (msg, "AuthenticateUser> Scheme= %s  Server= '%s'\n", 
                       lpszScheme, lpszServerName);
        OutputDebugString(msg);
#endif
	}
	else
	{
		pWinContext = (PWINCONTEXT) (*lppvContext);

		//
		// The package Id better be the same. Cant just switch packageId 
		// arbitrarily
		//
		if (pWinContext->pkgId != (DWORD)pkgId)
			return (ERROR_INVALID_PARAMETER);
		
		pServerBlob = lpszInBuffer;

		//++(pWinContext->dwCallId);		// Increment Call Id

		//
		// BUGBUG: Hack for now to know when auth failed
		// The only time we get lpszInBuffer to be empty is when 
		// Web server failed the authentication request
		//
        if (dwInBufferLength == 0)
        {
			//
			// This means auth has failed as far as NTLM are concerned.
			// Will result in UI being done again for new passwd
			//

			// Make sure we should have the same server name as before
			//
			if ( pWinContext->lpszServerName != NULL &&  
				 lstrcmp (pWinContext->lpszServerName, lpszServerName) != 0 )
			{
				return(ERROR_INVALID_PARAMETER);
			}

            if (!SaveServerName (lpszServerName, pWinContext))
			    return (ERROR_NOT_ENOUGH_MEMORY);

			//
			//	Delete the original SSPI context handle and 
			//	let UI recreate one.
			//
			if (pWinContext->pSspContextHandle)
			{
				(*(g_pSspData->pFuncTbl->DeleteSecurityContext))(pWinContext->pSspContextHandle);
        		pWinContext->pSspContextHandle = NULL;
			}

            if (pWinContext->pInBuffer != NULL && 
                pWinContext->pInBuffer != pWinContext->szInBuffer)
            {
                LocalFree (pWinContext->pInBuffer);
            }

            pWinContext->pInBuffer = NULL;
            pWinContext->dwInBufferLength = 0;

            //
            //  clear buffer length for the exchange blob
            //
		    pWinContext->dwOutBufferLength = 0;

            return (ERROR_WINHTTP_INCORRECT_PASSWORD);
		}
	}

    //
    //  Setup dwOutBufferLength to represent max. memory in szOutBuffer
    //
    pWinContext->dwOutBufferLength = pWinContext->cbOutBuffer;
    ZeroMemory (pWinContext->szOutBuffer, pWinContext->cbOutBuffer);

    //
    // This will generate an authorization header with UUEncoded blob from SSPI.
    // BUGBUG: Better make sure outbuf buffer is big enough for this.
    //
    SPMStatus =  GetSecAuthMsg( g_pSspData,
                                pWinContext->pCredential,
                                pkgId,
                                pWinContext->pSspContextHandle,
                                &(pWinContext->SspContextHandle),
                                fContextReq,
								pServerBlob, 
                       			dwInBufferLength,
                                pWinContext->szOutBuffer,
                                &pWinContext->dwOutBufferLength,
                                lpszServerName,
                                fCanUseLogon,
                                bNonBlock,
                                lpszScheme,
                                pssResult);

    if (SPMStatus != SPM_STATUS_OK)             // Fail to generate blob
    {
        pWinContext->dwOutBufferLength = 0;     // no exchange blob generated

        //
        //  if SSPI is requesting an opportunity to prompt for user credential
        //
		if (SPMStatus == SPM_STATUS_WOULD_BLOCK)
		{
			if (!SaveServerName (lpszServerName, pWinContext))
				return (ERROR_NOT_ENOUGH_MEMORY);

            //  If there is a exchange blob, this is not the first call
            //
            if (pServerBlob && dwInBufferLength > 0)
            {
                //  Save the exchange blob in the connection context
                //  so we can call SSPI again with the exchange blob
                if (dwInBufferLength > MAX_BLOB_SIZE)
                {
                	pWinContext->pInBuffer = (PCHAR) LocalAlloc(0, 
                                                    dwInBufferLength);
                    if (pWinContext->pInBuffer == NULL)
	        			return (ERROR_NOT_ENOUGH_MEMORY);
                }
                else
                    pWinContext->pInBuffer = pWinContext->szInBuffer;

                CopyMemory( pWinContext->szInBuffer, pServerBlob, 
                            dwInBufferLength );
                pWinContext->dwInBufferLength = dwInBufferLength;
            }
            else
            {
    			//
	    		//	Delete the original SSPI context handle and 
		    	//	let UI recreate one.
			    //
    			if (pWinContext->pSspContextHandle)
	    		{
		    		(*(g_pSspData->pFuncTbl->DeleteSecurityContext))(pWinContext->pSspContextHandle);
        	    	pWinContext->pSspContextHandle = NULL;
			    }

                //
                //  clear buffer length for the exchange blob
                //
                if (pWinContext->pInBuffer != NULL && 
                    pWinContext->pInBuffer != pWinContext->szInBuffer)
                {
                    LocalFree (pWinContext->pInBuffer);
                }

                pWinContext->pInBuffer = NULL;
                pWinContext->dwInBufferLength = 0;
            }
            pWinContext->dwOutBufferLength = 0;

			return(ERROR_WINHTTP_INCORRECT_PASSWORD);
		}

        return (ERROR_WINHTTP_LOGIN_FAILURE);
    }
    else if (pWinContext->pSspContextHandle == NULL)
    {   
        //  This means that we've just created a security context
        //
        pWinContext->pSspContextHandle = &(pWinContext->SspContextHandle);
    }

	return ERROR_WINHTTP_RESEND_REQUEST;
}


DWORD
WINAPI
PreAuthenticateUser(
	IN OUT LPVOID *lppvContext,
	IN LPSTR lpszServerName,
	IN LPSTR lpszScheme,
    IN BOOL  fCanUseLogon,
	IN DWORD dwFlags,
	OUT LPSTR lpOutBuffer,
	IN OUT LPDWORD lpdwOutBufferLength,
	IN LPSTR lpszUserName,
	IN LPSTR lpszPassword,
	SECURITY_STATUS *pssResult
	)
{
    INT             pkgId;
    DWORD           dwStatus;
    PWINCONTEXT		pWinContext;
	BOOL			bNonBlock = TRUE;
    ULONG           fContextReq = ISC_REQ_DELEGATE;
    DWORD Capabilities ;

    if (!SSPI_InitGlobals())
        return ERROR_INVALID_PARAMETER;

	if (lpszServerName == NULL || *lpszServerName == '\0')
        return(ERROR_INVALID_PARAMETER);

    pkgId = GetPkgId(lpszScheme);

    if (pkgId == -1)    {
        return(ERROR_INVALID_PARAMETER);
    }

    Capabilities = GetPkgCapabilities( pkgId );

    //
    //  If this is for an existing connection
    //
	if (*lppvContext != NULL)
    {
    	pWinContext = (PWINCONTEXT) (*lppvContext);

    	if ((DWORD)pkgId != pWinContext->pkgId)
	    	return(ERROR_INVALID_PARAMETER);

        //
        //  For package that does not handle its own UI, if there is no 
        //  generated blob, it means that we have just collected 
        //  user name/password.
        //
        if ( ( pWinContext->dwOutBufferLength == 0 ) &&
                ( Capabilities & SSPAUTHPKG_SUPPORT_NTLM_CREDS ) )
        {
            if (lpszUserName == NULL || lpszPassword == NULL)
            {
    	    	return(ERROR_INVALID_PARAMETER);
            }

            //
            // Need to recreate a credential handle and 
            // generate a new NEGOTIATE message in lpOutBuffer
            //
            dwStatus = RedoNTLMAuth4User (pWinContext, 
                                         pkgId,
                                         lpszUserName,
                                         lpszPassword, 
                                         lpszServerName ,
                                         lpszScheme,
                                         fCanUseLogon,
                                         lpOutBuffer,
                                         lpdwOutBufferLength,
                                         pssResult);

            if (dwStatus != ERROR_SUCCESS)
                return (dwStatus);

        	return(ERROR_SUCCESS);
        }
	    else if (pWinContext->dwOutBufferLength == 0)
        //
        //  For other packages, If there is no generated blob, 
        //  something is wrong 
        //
	    	return(ERROR_INVALID_PARAMETER);

    }
    // If not NTLM, don't pre-auth.
    else if ( (Capabilities & SSPAUTHPKG_SUPPORT_NTLM_CREDS ) == 0 )
    {
        return (ERROR_INVALID_HANDLE);
    }
    else
    {
        // probably sending 1st request on a new connection for the same URL
        //  Create a new context and SSPI credential handle for this connection
        //
        // Set fCanUseLogon to TRUE : we would not be pre-authing
        // unless we have a valid pwc which means we already checked
        // zone policy for silent logon.
        dwStatus = NewWinContext (pkgId, lpszScheme, &pWinContext, 
                                  fCanUseLogon, lpszUserName, lpszPassword);
		if (dwStatus != ERROR_SUCCESS)
			return (dwStatus);
		
#ifdef DEBUG_WINSSPI
        (void)wsprintf (msg, 
            "PreAuthenticateUser> New Context for Scheme= %s  Server= '%s'\n", 
            lpszScheme, lpszServerName);
        OutputDebugString(msg);
#endif
        pWinContext->dwOutBufferLength = pWinContext->cbOutBuffer;
        ZeroMemory (pWinContext->szOutBuffer, pWinContext->cbOutBuffer);
    
        //
        // This will generate an authorization header with the 
        // UUEncoded blob from SSPI. 
        // BUGBUG: Better make sure outbuf buffer is big enough for this.
        //
        dwStatus =  GetSecAuthMsg( g_pSspData,
                                    pWinContext->pCredential,
                                    pkgId,
                                    NULL, 
                                    &(pWinContext->SspContextHandle),
                                    fContextReq,
                                    NULL,
                                    0,
                                    pWinContext->szOutBuffer,
                                    &pWinContext->dwOutBufferLength,
                                    lpszServerName,
                                    fCanUseLogon,
                                    bNonBlock,
                                    lpszScheme,
                                    pssResult);
    
        if (dwStatus != SPM_STATUS_OK)
        {
            //  This is a rare case
            //
            pWinContext->dwOutBufferLength = 0; // no exchange blob generated
            return(ERROR_INVALID_HANDLE);
        }

		(*lppvContext) = (LPVOID) pWinContext;

        //  Save the pointer of the created security ctxt
        //
        pWinContext->pSspContextHandle = &(pWinContext->SspContextHandle);
	}

	//
    //  Copy exchange blob to the output buffer
	//	Make sure output buffer provided is big enough
	//
	if (*lpdwOutBufferLength < pWinContext->dwOutBufferLength)
	{
	    *lpdwOutBufferLength = pWinContext->dwOutBufferLength + 1;
		return(ERROR_INSUFFICIENT_BUFFER);
	}

	CopyMemory (lpOutBuffer, pWinContext->szOutBuffer, 
				pWinContext->dwOutBufferLength);
	if (*lpdwOutBufferLength > pWinContext->dwOutBufferLength)
        lpOutBuffer[pWinContext->dwOutBufferLength] = '\0';

    *lpdwOutBufferLength = pWinContext->dwOutBufferLength;

    //
    //  The exchange blob has being copied to request header, so clear its len
    //

    pWinContext->dwOutBufferLength = 0;

	return(ERROR_SUCCESS);
}

BOOL g_fUUEncodeData = TRUE;

typedef enum _COMPUTER_NAME_FORMAT {
    ComputerNameNetBIOS,
    ComputerNameDnsHostname,
    ComputerNameDnsDomain,
    ComputerNameDnsFullyQualified,
    ComputerNamePhysicalNetBIOS,
    ComputerNamePhysicalDnsHostname,
    ComputerNamePhysicalDnsDomain,
    ComputerNamePhysicalDnsFullyQualified,
    ComputerNameMax
} COMPUTER_NAME_FORMAT ;

typedef 
BOOL
(WINAPI * PFN_GET_COMPUTER_NAME_EX)(
    IN COMPUTER_NAME_FORMAT NameType,
    OUT LPSTR lpBuffer,
    IN OUT LPDWORD nSize
    );

PFN_GET_COMPUTER_NAME_EX g_pfnGetComputerNameExA = NULL;


/*-----------------------------------------------------------------------------
**
**  Function:   GetSecAuthMsg
**
**  Synopsis:   This function generates a SSPI NEGOTIATE or RESPONSE 
**				authorization string for the specified SSPI package.
**				The authorization string generated by this function 
**				follows the format: 
**					"<Package Name> <Package Specific Auth. Data>"
**				If global uuencoding is turned on, this functions will 
**				uuencode the message before building it into an  
**				authorization string; by default, the uuencoding flag is 
**				always on.  
**				This functions calls InitializeSecurityContext() to 
**				generate the NEGOTIATE/RESPONSE message for the authori-
**				zation string. If the SSPI function returns NO_CREDENTIAL, 
**				and if the PROMPT_CREDS flag is not turned on when blocking
**				is permitted, this function will call the SSPI function 
**				again with the PROMPT_CREDS flag set; if SSPI returns 
**				NO_CREDENTIAL again, this SSPI will return ERROR to the 
**				caller.
**
**
**  Arguments:
**
**		pData - pointer to SspData containing the SSPI function table 
**				and the SSPI package list. 
**		pkgID - the package index of the SSPI package to use.
**		pInContext - pointer to a context handle. If NULL is specified, 
**					 this function will use a temporary space for the context
**					 handle and delete the handle before returning to the 
**					 caller. If non-NULL address is specified, the context 
**					 handle created by the SSPI is returned to the caller. 
**					 And the caller will have to delete the handle when it's
**					 done with it.
**		fContextReq - the SSPI request flag to pass to InitializeSecurityContext
**		pBuffIn - pointer to the uudecoded CHALLENGE message if any. 
**				  For generating NEGOTIATE message, this pointer should be NULL.
**		cbBuffIn - length of the CHALLENGE message. This should be zero when  
**				   when pBuffIn is NULL.
**		pFinalBuff - pointer to a buffer for the final authorization string.
**		pszTarget - Server Host Name
**		bNonBlock - a flag which is set if blocking is not permitted.
**
**  Return Value:
**
**		SPM_STATUS_OK	- if an authorization string is generated successfully
**  	SPM_STATUS_WOULD_BLOCK - if generating an authorization string would 
**					cause blocking when blocking is not permitted. 
**		SPM_ERROR - if any problem/error is encountered in generating an 
**					authorization string, including user hitting cancel on 
**					the SSPI dialog prompt for name/password.
**
**---------------------------------------------------------------------------*/
DWORD
GetSecAuthMsg (
    PSspData        pData, 			 
    PCredHandle     pCredential, 
    DWORD           pkgID,              // the package index into package list
    PCtxtHandle     pInContext,
	PCtxtHandle		pOutContext,
    ULONG           fContextReq,        // Request Flags
    VOID            *pBuffIn, 
    DWORD           cbBuffIn, 
    char            *pFinalBuff, 
    DWORD           *pcbBuffOut,
    SEC_CHAR        *pszTarget,         // Server Host Name
    BOOL            fTargetTrusted,
    UINT            bNonBlock,
    LPSTR           pszScheme,
    SECURITY_STATUS *pssResult
    )
{
    char                  *SlowDecodedBuf = NULL;

    int                   retsize;
    SECURITY_STATUS       SecStat;
    TimeStamp             Lifetime;
    SecBufferDesc         OutBuffDesc;
    SecBuffer             OutSecBuff;
    SecBufferDesc         InBuffDesc;
    SecBuffer             InSecBuff;
    ULONG                 ContextAttributes;

    char                  *SlowOutBufPlain = NULL;

    char                  *pOutMsg = NULL;
    DWORD                 RetStatus;
    long                  maxbufsize;
    CHAR                  szDecoratedTarget[MAX_PATH + 6];
    DWORD                 cbTarget;

    ULONG                 cbMaxToken;


	//
	// BUGBUG: Deal with output buffer not being long enough


    if (pFinalBuff == NULL) {
        return(SPM_ERROR);
    }

    //
    //  Prepare our output buffer.  We use a temporary buffer because
    //  the real output buffer will most likely need to be uuencoded
    //
    OutBuffDesc.ulVersion = 0;
    OutBuffDesc.cBuffers  = 1;
    OutBuffDesc.pBuffers  = &OutSecBuff;

    OutSecBuff.cbBuffer   = MAX_AUTH_MSG_SIZE;
    OutSecBuff.BufferType = SECBUFFER_TOKEN;


    // Dynamically allocate since being in a service doesn't
    // give us the guaranteed luxury of 10+KB stack allocations.

    cbMaxToken = GetPkgMaxToken(pkgID);

    SlowOutBufPlain = (char *) ALLOCATE_FIXED_MEMORY(cbMaxToken);

    if( SlowOutBufPlain == NULL )
    {
        RetStatus = SPM_STATUS_INSUFFICIENT_BUFFER;
        goto Cleanup;
    }
    OutSecBuff.pvBuffer = SlowOutBufPlain;
    OutSecBuff.cbBuffer = cbMaxToken;

    //
    //  Prepare our Input buffer if a CHALLENGE message is passed in.
    //
    if ( pBuffIn )
    {
        InBuffDesc.ulVersion = 0;
        InBuffDesc.cBuffers  = 1;
        InBuffDesc.pBuffers  = &InSecBuff;

        InSecBuff.BufferType = SECBUFFER_TOKEN;

        //
        // If this is UUENCODED, decode it first
        //
        if ( g_fUUEncodeData)
        {
            DWORD cbDecodedBuf;

            cbDecodedBuf = cbBuffIn;
            SlowDecodedBuf = (char*) ALLOCATE_FIXED_MEMORY(cbDecodedBuf);
            if( SlowDecodedBuf == NULL )
            {
                RetStatus = SPM_STATUS_INSUFFICIENT_BUFFER;
                goto Cleanup;
            }

            InSecBuff.cbBuffer   = HTUU_decode ((char*)pBuffIn, (UCHAR*)SlowDecodedBuf,
                                                cbDecodedBuf);
            InSecBuff.pvBuffer   = SlowDecodedBuf;
        }
		else
        {
            InSecBuff.cbBuffer   = cbBuffIn;
            InSecBuff.pvBuffer   = pBuffIn;
        }
    }

    // If scheme is Negotiate, set ISC_REQ_MUTUAL_AUTH and decorate
    // the server name indicated by pszTarget by appending a '$' to the
    // server name.
    if (pszScheme && !(lstrcmpi(pszScheme, "Negotiate")))
    {
        fContextReq |= ISC_REQ_MUTUAL_AUTH;
        cbTarget = (pszTarget ? strlen(pszTarget) : 0);
        if (cbTarget && (cbTarget <= MAX_PATH - sizeof( "HTTP/" )))
        {
            memcpy(szDecoratedTarget, "HTTP/", sizeof( "HTTP/" ) - 1 );
            memcpy(szDecoratedTarget + sizeof( "HTTP/" ) - 1, pszTarget, cbTarget + 1);
            pszTarget = szDecoratedTarget;

            OutputDebugStringA(pszTarget);
        }
    }


	//
	//	Call SSPI function generate the NEGOTIATE/RESPONSE message
	//

    if (fContextReq & ISC_REQ_DELEGATE)
    {
        // we should only request delegation when calling InitializeSecurityContext if 
        // the site is in the intranet or trusted sites zone. Otherwise you will be giving 
        // the user's TGT to any web server that is trusted for delegation.

        if (fTargetTrusted)
        {
            fContextReq &= ~ISC_REQ_DELEGATE;
        }
    }

SspiRetry:

//
// BUGBUG: Same credential handle could be used by multiple threads at the
// same time.
//
    SecStat = (*(pData->pFuncTbl->InitializeSecurityContext))(
                                pCredential, 
                                pInContext,
                                pszTarget,
                                fContextReq,
                                0,
                                SECURITY_NATIVE_DREP,
                                (pBuffIn) ? &InBuffDesc : NULL, 
                                0,
                                pOutContext, 
                                &OutBuffDesc,
                                &ContextAttributes,
                                &Lifetime );
	*pssResult = SecStat;
	
	//
	//	If SSPI function fails 
	//
    if ( !NT_SUCCESS( SecStat ) )
    {
        RetStatus = SPM_ERROR;

		//
		//	If SSPI do not have user name/password for the secified package,
		//
        if (SecStat == SEC_E_NO_CREDENTIALS)
        {
            //
            //  If we have prompted the user and still get back "No Credential"
            //  error, it means the user does not have valid credential; the 
            //	user hit <CANCEL> on the UI box. If we have supplied a valid 
			//	credential, but get back a "No Credential" error, then something
			//	has gone wrong; we definitely should return to caller with ERROR
            //
            if ((fContextReq & ISC_REQ_PROMPT_FOR_CREDS) ||
				(fContextReq & ISC_REQ_USE_SUPPLIED_CREDS))
			{
                RetStatus = SPM_ERROR;	// return ERROR to caller
            }
            else if (bNonBlock)
            {
				//
				//	Blocking is not permitted, return WOULD_BLOCK to caller
				//
                RetStatus = SPM_STATUS_WOULD_BLOCK;
            }
            else
            {
                //	Blocking is permitted and we have not asked the SSPI to
                //  prompt the user for proper credential, we should call  
                //  the SSPI again with PROMPT_CREDS flag set.
                //
                fContextReq = fContextReq | ISC_REQ_PROMPT_FOR_CREDS;
                goto SspiRetry;
            }
        }
        SetLastError( SecStat );

        goto Cleanup;
    }

    RetStatus = SPM_STATUS_OK;

    //
    //  Only return the SSPI blob if a output buffer is specified
    //
    if (pFinalBuff)
    {
    	//
	    //	Initialize the final buffer to hold the package name followed by 
    	//	a space. And setup the pOutMsg pointer to points to the character 
    	//	following the space so that the final NEGOTIATE/RESPONSE can be 
    	//	copied into the pFinalBuff starting at the character pointed to 
    	//	by pOutMsg. 
    	//
        wsprintf (pFinalBuff, "%s ", pData->PkgList[pkgID]->pName);
        pOutMsg = pFinalBuff + lstrlen(pFinalBuff);

        if ( g_fUUEncodeData)
        {
            maxbufsize = *pcbBuffOut - 
                         lstrlen(pData->PkgList[pkgID]->pName) - 1;
        	//
        	//  uuencode it, but make sure that it fits in the given buffer
        	//
            retsize = HTUU_encode ((BYTE *) OutSecBuff.pvBuffer,
                                   OutSecBuff.cbBuffer,
                                   (CHAR *) pOutMsg, maxbufsize);
            if (retsize > 0)
                *pcbBuffOut = retsize + lstrlen(pData->PkgList[pkgID]->pName)+1;
            else
                RetStatus = SPM_STATUS_INSUFFICIENT_BUFFER;
        }
        else if ( *pcbBuffOut >= lstrlen(pData->PkgList[pkgID]->pName) + 
                                 OutSecBuff.cbBuffer + 1 )
        {
            CopyMemory( (CHAR *) pOutMsg, 
                        OutSecBuff.pvBuffer,
                        OutSecBuff.cbBuffer );
            *pcbBuffOut = lstrlen(pData->PkgList[pkgID]->pName) + 1 +
                          OutSecBuff.cbBuffer;
        }
        else
        {
            *pcbBuffOut = lstrlen(pData->PkgList[pkgID]->pName) + 
                          OutSecBuff.cbBuffer + 1;
            RetStatus = SPM_STATUS_INSUFFICIENT_BUFFER;
        }
    }

Cleanup:

    if( SlowOutBufPlain != NULL )
    {
        FREE_MEMORY( SlowOutBufPlain );
    }

    if( SlowDecodedBuf != NULL )
    {
        FREE_MEMORY( SlowDecodedBuf );
    }

    return (RetStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\auth\sspspm.h ===
//#----------------------------------------------------------------------------
//
//  File:           sspspm.h
//
//      Synopsis:   Definitions specific to SSPI SPM DLL.
//
//      Copyright (C) 1995  Microsoft Corporation.  All Rights Reserved.
//
//  Authors:        LucyC       Created                         25 Sept 1995
//
//-----------------------------------------------------------------------------
#ifndef _SSPSPM_H_
#define _SSPSPM_H_

#include <platform.h>

#ifdef __cplusplus
extern "C" {
#endif

//
//  Names of secruity DLL
//
#define SSP_SPM_NT_DLL      "security.dll"
#define SSP_SPM_WIN95_DLL   "secur32.dll"


#define SSP_SPM_DLL_NAME_SIZE   16          // max. length of security DLL names

#define MAX_SSPI_PKG        32              // Max. no. of SSPI supported

#define SSPPKG_ERROR        ((UCHAR) 0xff)
#define SSPPKG_NO_PKG       SSPPKG_ERROR
#define MAX_AUTH_MSG_SIZE   10000
#define TCP_PRINT   fprintf
#define DBG_CONTEXT stderr

#define MAX_BLOB_SIZE       13000

//
//  Server host list definition.

//  The following defines an entry in the server host list.
//
typedef struct _ssp_host_list
{
    struct _ssp_host_list   *pNext;

    unsigned char           *pHostname; // name of server host
    unsigned char           pkgID;      // the package being used for this host

} SspHosts, *PSspHosts;

//
//  List of SSPI packages installed on this machine.
//  The following defines an entry of the SSPI package list.
//
typedef struct _ssp_auth_pkg
{
    LPTSTR       pName;         // package name
    DWORD        Capabilities ; // Interesting capabilities bit
    ULONG        cbMaxToken;    // max size of security token
} SSPAuthPkg, *PSSPAuthPkg;

#define SSPAUTHPKG_SUPPORT_NTLM_CREDS   0x00000001

//
//  The following defines the global data structure which the SPM DLL keeps
//  in the HTSPM structure.
//
typedef struct _ssp_htspm
{
    PSecurityFunctionTable pFuncTbl;

    SSPAuthPkg      **PkgList;          // array of pointers to auth packages
    UCHAR           PkgCnt;



    BOOLEAN         bKeepList;          // whether to keep a list of servers
    
    PSspHosts       pHostlist;

} SspData, *PSspData;

#define SPM_STATUS_OK                   0
#define SPM_ERROR                       1
#define SPM_STATUS_WOULD_BLOCK          2
#define SPM_STATUS_INSUFFICIENT_BUFFER  3

/////////////////////////////////////////////////////////////////////////////
//
//  Function headers from sspcalls.c
//
/////////////////////////////////////////////////////////////////////////////

DWORD
GetSecAuthMsg (
    PSspData        pData,
    PCredHandle     pCredential,
    DWORD           pkgID,              // the package index into package list
    PCtxtHandle     pInContext,
    PCtxtHandle     pOutContext,
    ULONG           fContextReq,        // Request Flags
    VOID            *pBuffIn,
    DWORD           cbBuffIn,
    char            *pFinalBuff,
    DWORD           *pcbBuffOut,
    SEC_CHAR        *pszTarget,         // Server Host Name
    BOOL            fTargetTrusted,
    UINT            bNonBlock,
    LPSTR           pszScheme,
	SECURITY_STATUS *pssResult
    );

INT
GetPkgId(LPTSTR  lpszPkgName);

DWORD
GetPkgCapabilities(
    INT Package
    );
ULONG
GetPkgMaxToken(
    INT Package
    );

/////////////////////////////////////////////////////////////////////////////
//
//  Function headers from buffspm.c
//
/////////////////////////////////////////////////////////////////////////////

PSspHosts
SspSpmNewHost (
    PSspData pData,
    UCHAR    *pHost,       // name of server host to be added
    UCHAR    Package
    );

VOID
SspSpmDeleteHost(
    SspData     *pData,
    PSspHosts   pDelHost
    );

VOID
SspSpmTrashHostList(
    SspData     *pData
    );

PSspHosts
SspSpmGetHost(
    PSspData pData,
    UCHAR *pHost
    );

#ifdef __cplusplus
} // end extern "C" {
#endif

#endif  /* _SSPSPM_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\auth\sspspm.cxx ===
/*#----------------------------------------------------------------------------
**
**  File:           sspspm.c
**
**  Synopsis:   Security Protocol Module for SSPI Authentication providers.
**                  
**      This module contains major funtions of the SEC_SSPI.DLL which 
**      allows the Internet Explorer to use SSPI providers for authentication.
**      The function exported to the Internet Explorer is Ssp_Load() which 
**      passes the address of the Ssp__DownCall() function to the Explorer.
**      Then the Explorer will call Ssp__DownCall() when it needs service from 
**      this SPM DLL.  The two major functions called by Ssp__DownCall() to 
**      service Explorer's request are Ssp__PreProcessRequest() and 
**      Ssp__ProcessResponse().  In brief, Ssp__PreProcessRequest() is 
**      called before the Explorer sends out a request which does not have 
**      any 'Authorization' header yet.  And Ssp__ProcessResponse() is called 
**      whenever the Explorer receives an 401 'Unauthorized' response from the 
**      server.  This SPM DLL supports all SSPI packages which are installed 
**      on the machine.
**
**      This SPM DLL is called by the Internet Explorer only for its
**      The Internet Explorer only calls this SPM DLL when it needs 
**      authentication data in its request/response. In other words, the 
**      Explorer never calls this SPM DLL when an authentication succeeded; 
**      it never calls this DLL when it decide to give up on a connection 
**      because of server response timeout.  Because of this fact, this SPM 
**      DLL never has sufficient information on the state of each server 
**      connection; it only know its state based on the content of the last 
**      request and the content of the current response. For this reason, this 
**      SPM DLL does not keep state information for each host it has visited 
**      unless the information is essential. 
**      The security context handle returned from the first call of  
**      InitializeSecurityContext() for NEGOTIATE message generation is 
**      always the identical for a SSPI package when the same server host is 
**      passed.  Since the server host name is always in the request/response
**      header, the only information essential in generating a NEGOTIATE or 
**      RESPONSE is already available in the header. So unlike most SSPI 
**      application, this DLL will not keep the security context handle which 
**      it received from the SSPI function calls. Whenever it needs to call 
**      the SSPI function for generating a RESPONSE, it will first call the 
**      SSPI function without the CHALLENGE to get a security context handle.
**      Then it calls the SSPI function again with the CHALLENGE to generate 
**      a RESPONSE.
**
**
**      Copyright (C) 1995  Microsoft Corporation.  All Rights Reserved.
**
**  Authors:        LucyC       Created                         25 Sept. 1995
**
**---------------------------------------------------------------------------*/
#include <wininetp.h>
#include <ntlmsp.h>
#include "sspspm.h"

//
// Global variable where all the SSPI Pkgs data is collected
//

SspData  *g_pSspData;


HINSTANCE g_hSecLib;

/*-----------------------------------------------------------------------------
**
**  Function:   SpmAddSSPIPkg
**
**  Synopsis:   This function adds a SSPI package to the SPM's package list.
**
**  Arguments:  pData - Points to the private SPM data structure containing 
**                      the package list and the package info.
**              pPkgName - package name
**              cbMaxToken - max size of security token
**
**  Returns:    The index in the package list where this new package is added.
**              If failed to add the new package, SSPPKG_ERROR is returned.
**
**  History:    LucyC       Created                             21 Oct. 1995
**
**---------------------------------------------------------------------------*/
static UCHAR
SpmAddSSPIPkg (
    SspData *pData, 
    LPTSTR   pPkgName,
    ULONG    cbMaxToken
    )
{
    if ( !(pData->PkgList[pData->PkgCnt] =
                        (SSPAuthPkg *)LocalAlloc(0, sizeof(SSPAuthPkg))))
    {
        return SSPPKG_ERROR;
    }

    if ( !(pData->PkgList[pData->PkgCnt]->pName = 
                        (LPSTR)LocalAlloc(0, lstrlen(pPkgName)+1)))
    {
        LocalFree(pData->PkgList[pData->PkgCnt]);
        pData->PkgList[pData->PkgCnt] = NULL;
        return SSPPKG_ERROR;
    }

    lstrcpy (pData->PkgList[pData->PkgCnt]->pName, pPkgName);
    pData->PkgList[ pData->PkgCnt ]->Capabilities = 0 ;

    pData->PkgList[ pData->PkgCnt ]->cbMaxToken = cbMaxToken;

    //
    // Determine if this package supports anything of interest to
    // us.
    //

    if ( lstrcmpi( pPkgName, NTLMSP_NAME_A ) == 0 )
    {
        //
        // NTLM supports the standard credential structure
        //

        pData->PkgList[ pData->PkgCnt ]->Capabilities |= SSPAUTHPKG_SUPPORT_NTLM_CREDS ;
    }
    else if ( lstrcmpi( pPkgName, "Negotiate" ) == 0 )
    {
        //
        // Negotiate supports that cred structure too
        //

        pData->PkgList[ pData->PkgCnt ]->Capabilities |= SSPAUTHPKG_SUPPORT_NTLM_CREDS ;

    }
    else
    {
        //
        // Add more comparisons here, eventually.
        //

        ;
    }

    pData->PkgCnt++;
    return (pData->PkgCnt - 1);
}

/*-----------------------------------------------------------------------------
**
**  Function:   SpmFreePkgList
**
**  Synopsis:   This function frees memory allocated for the package list. 
**
**  Arguments:  pData - Points to the private SPM data structure containing 
**                      the package list and the package info.
**
**  Returns:    void.
**
**  History:    LucyC       Created                             21 Oct. 1995
**
**---------------------------------------------------------------------------*/
static VOID
SpmFreePkgList (
    SspData *pData
    )
{
    int ii;

    for (ii = 0; ii < pData->PkgCnt; ii++)
    {
        LocalFree(pData->PkgList[ii]->pName);

        LocalFree(pData->PkgList[ii]);
    }

    LocalFree(pData->PkgList);
}


/*-----------------------------------------------------------------------------
**
**  Function:   Ssp__Unload
**
**  Synopsis:   This function is called by the Internet Explorer before 
**              the SPM DLL is unloaded from the memory.
**
**  Arguments:  fpUI - From Explorer for making all UI_SERVICE call
**              pvOpaqueOS - From Explorer for making all UI_SERVICE call
**              htspm - the SPM structure which contains the global data 
**                      storage for this SPM DLL.
**
**  Returns:    always returns SPM_STATUS_OK, which means successful.
**
**  History:    LucyC       Created                             25 Sept. 1995
**
**---------------------------------------------------------------------------*/
DWORD SSPI_Unload()
{
    if (!AuthLock())
    {
        return SPM_STATUS_INSUFFICIENT_BUFFER;
    }

    if (g_pSspData != NULL)
    {
        SpmFreePkgList(g_pSspData);
        LocalFree(g_pSspData);
        g_pSspData = NULL;
    }

    if (g_hSecLib)
    {
        FreeLibrary (g_hSecLib);
        g_hSecLib = NULL;
    }

    AuthUnlock();
        
    return SPM_STATUS_OK;
}

/*-----------------------------------------------------------------------------
**
**  Function:   SspSPM_InitData
**
**  Synopsis:   This function allocates and initializes global data structure 
**              of the SPM DLL.
**
**  Arguments:  
**
**  Returns:    Pointer to the allocated global data structure.
**
**  History:    LucyC       Created                             25 Sept. 1995
**
**---------------------------------------------------------------------------*/
LPVOID SSPI_InitGlobals(void)
{
    SspData *pData = NULL;
    OSVERSIONINFO   VerInfo;
    INIT_SECURITY_INTERFACE    addrProcISI = NULL;

    SECURITY_STATUS sstat;
    ULONG           ii, cntPkg;
    PSecPkgInfo     pPkgInfo = NULL;
    PSecurityFunctionTable    pFuncTbl = NULL;

    if (g_pSspData)
        return g_pSspData;

    static BOOL Initializing = FALSE;
    static BOOL Initialized = FALSE;
    
    if (InterlockedExchange((LPLONG)&Initializing, TRUE)) {
        while (!Initialized) {
            SleepEx(0, TRUE);
        }
        goto quit;
    }
    
    //
    // Initialize SSP SPM Global Data
    //

    VerInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    if (!GetVersionEx (&VerInfo))   // If this fails, something has gone wrong
    {
        goto quit;
    }

    if (VerInfo.dwPlatformId != VER_PLATFORM_WIN32_NT)
    {
        goto quit;
    }

    if (!(pData = (SspData *) LocalAlloc(0, sizeof(SspData))))    {
        
        goto quit;

    }

    //
    //  Keep these information in global SPM
    //
    ZeroMemory (pData, sizeof(SspData));

    //
    //  Load Security DLL
    //
    g_hSecLib = LoadLibrary (SSP_SPM_NT_DLL);
    if (g_hSecLib == NULL)
    {
        // This should never happen.
        LocalFree(pData);
        pData = NULL;
        goto Cleanup;
    }

    addrProcISI = (INIT_SECURITY_INTERFACE) GetProcAddress( g_hSecLib, 
                    SECURITY_ENTRYPOINT);       
    if (addrProcISI == NULL)
    {
        LocalFree(pData);
        pData = NULL;
        goto Cleanup;
    }

    //
    // Get the SSPI function table
    //
    pFuncTbl = (*addrProcISI)();

    //
    //  Get list of packages supported
    //
    sstat = (*(pFuncTbl->EnumerateSecurityPackages))(&cntPkg, &pPkgInfo);
    if (sstat != SEC_E_OK || pPkgInfo == NULL)
    {
        //
        // ??? Should we give up here ???
        // EnumerateSecurityPackage() failed
        //
        goto Cleanup;
    }

    if (cntPkg)
    {
        //
        //  Create the package list
        //
        if (!(pData->PkgList = (PSSPAuthPkg *)LocalAlloc(0, 
                                            cntPkg*sizeof(PSSPAuthPkg))))
        {
            goto Cleanup;
        }
    }

    for (ii = 0; ii < cntPkg; ii++)
    {
        //DebugTrace(SSPSPMID, "Found %s SSPI package\n", 
        //                     pPkgInfo[ii].Name);

        if (SpmAddSSPIPkg (pData, 
                           pPkgInfo[ii].Name,
                           pPkgInfo[ii].cbMaxToken
                           ) == SSPPKG_ERROR)
        {
            goto Cleanup;
        }
    }

    pData->pFuncTbl = pFuncTbl;
    pData->bKeepList = TRUE;

    if (pData->PkgCnt == 0)
    {
        goto Cleanup;
    }

    g_pSspData = pData;
    pData = NULL;

Cleanup:


    if( pPkgInfo != NULL )
    {
        //
        // Free buffer returned by the enumerate security package function
        //

        (*(pFuncTbl->FreeContextBuffer))(pPkgInfo);
    }

    if( pData != NULL )
    {
        SpmFreePkgList (pData);
    }

    if (g_hSecLib)
    {
        FreeLibrary (g_hSecLib);
        g_hSecLib = NULL;
    }


quit: 
    Initialized = TRUE;

    return (g_pSspData);
}

INT
GetPkgId(LPTSTR  lpszPkgName)
{
    int ii;

    if ( g_pSspData == NULL )
    {
        return -1;
    }
    
    if (!AuthLock())
    {
        return -1;
    }
    
    for (ii = 0; ii < g_pSspData->PkgCnt; ii++)
    {
        if (!lstrcmp(g_pSspData->PkgList[ii]->pName, lpszPkgName))
        {
            AuthUnlock();
            return(ii);
        }
    }

    AuthUnlock();
    return(-1);
}

DWORD
GetPkgCapabilities(
    INT Package
    )
{
    if (!AuthLock())
    {
        return 0;
    }
    
    DWORD dwCaps;
    if ( Package < g_pSspData->PkgCnt )
    {
        dwCaps = g_pSspData->PkgList[ Package ]->Capabilities ;
    }
    else
        dwCaps = 0 ;

    AuthUnlock();
    return dwCaps;
}

ULONG
GetPkgMaxToken(
    INT Package
    )
{
    if (!AuthLock())
    {
        return MAX_AUTH_MSG_SIZE;
    }
    
    ULONG dwMaxToken;

    if ( Package < g_pSspData->PkgCnt )
    {
        dwMaxToken = g_pSspData->PkgList[ Package ]->cbMaxToken;
    }
    else {
        // be compatible with old static buffer size
        dwMaxToken = MAX_AUTH_MSG_SIZE;
    }

    AuthUnlock();
    return dwMaxToken;
}

//
//  Calls to this function are serialized
//

DWORD_PTR SSPI_InitScheme (LPCSTR lpszScheme)
{
    int ii;

       if (!SSPI_InitGlobals())
           return 0;
           
       if (!AuthLock())
       {
           return 0;
       }
    //  Once initialized, check to see if this scheme is installed 
    for (ii = 0; ii < g_pSspData->PkgCnt && 
        lstrcmp (g_pSspData->PkgList[ii]->pName, lpszScheme); ii++);

    if (ii >= g_pSspData->PkgCnt)
    {
        // This scheme is not installed on this machine
        AuthUnlock();
        return (0);
    }
    
    AuthUnlock();
    return ((DWORD_PTR)g_pSspData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\auth\splugin.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    splugin.cxx

Abstract:

    This file contains the implementation for Plug In Authentication

    The following functions are exported by this module:

    AuthOnRequest
    AuthOnResponse
    AuthCtxClose
    AuthInDialog
    AuthNotify
    AuthUnload

Author:

    Arthur Bierer (arthurbi) 25-Dec-1995

Revision History:
 
    Rajeev Dujari (rajeevd)  01-Oct-1996 overhauled

    Adriaan Canter (adriaanc) 01-03-1998 :
    AUTHCTX now a virtual base class, from which derived classes
    inherit to implement the different authentication protocols:

    BASIC_CTX  (Basic auth),
    PLUG_CTX   (NTLM, Negotiate)
    DIGEST_CTX (Digest auth, new)


--*/

#include <wininetp.h>
#include <splugin.hxx>
#include "auth.h"
#include "sspspm.h"

//
// constants
//

#define WILDCARD 0x05 // don't use '*' since it can appear in an URL
#define AssertHaveLock() INET_ASSERT(g_dwOwnerId == GetCurrentThreadId())

#define MAX_AUTH_HDR_SIZE (MAX_BLOB_SIZE + HTTP_PROXY_AUTHORIZATION_LEN + 2)

//
//  globals
//

// Global authentication providers list and state.
AUTHCTX::SPMState  AUTHCTX::g_eState;
AUTHCTX::SPMData  *AUTHCTX::g_pSPMList = NULL;


// Global auth crit sect.
CCritSec g_crstAuth;

#ifdef DBG
DWORD g_dwOwnerId = 0;
LONG g_nLockCount = 0;
#endif

//
// private prototypes
//

//-----------------------------------------------------------------------------
//
//  AUTH_CREDS class definition.
//
//
PRIVATE AUTH_CREDS *Creds_Create
(
    LPSTR lpszHost,
    LPSTR lpszRealm,
    AUTHCTX::SPMData* pSPM
);

void  Creds_Free (AUTH_CREDS *Creds);



//-----------------------------------------------------------------------------
//
//  Utilities
//
//

PRIVATE VOID SspiFlush (LPSTR pszDll);
PRIVATE BOOL TemplateMatch(LPSTR lpszTemplate, LPSTR lpszFilename);
PRIVATE LPSTR MakeTemplate (LPSTR docname);
PRIVATE LPSTR GetProxyName (HTTP_REQUEST_HANDLE_OBJECT *pRequest);

PRIVATE BOOL ReadRegKey(
    BYTE * pbRegValue,
    DWORD * pdwNumBytes,
    LPSTR  pszRegKey,
    LPSTR  pszRegValueName,
    DWORD  dwRegTypeExpected);



//-----------------------------------------------------------------------------
//
//
//      AUTH_CREDS functions
//
//          Creds_CREATE
//          Creds_FREE
//          SetUser
//          SetPass
//          FlushCredsList
//

PRIVATE AUTH_CREDS *Creds_Create // AUTH_CREDS constructor
(
    LPSTR lpszHost,     // Host Name to place in structure.
    LPSTR lpszRealm,    // Realm string to add.
    AUTHCTX::SPMData * pSPM
)
{
    AUTH_CREDS* Creds = (AUTH_CREDS *) ALLOCATE_ZERO_MEMORY(sizeof(*Creds));
    if (!Creds)
        return NULL;

    INET_ASSERT (!Creds->lpszHost);
    Creds->lpszHost    = lpszHost ?  NewString(lpszHost)   : NULL;
    
    INET_ASSERT (!Creds->lpszRealm);
    Creds->lpszRealm   = lpszRealm ? NewString(lpszRealm)  : NULL;
    Creds->pSPM         = pSPM;

    if (  (!Creds->lpszHost  && lpszHost)
       || (!Creds->lpszRealm && lpszRealm)
       )
    {
        Creds_Free(Creds);
        return NULL;
    }

    return Creds;
}

PRIVATE VOID Creds_Free(AUTH_CREDS *Creds) // AUTH_CREDS destructor
{
    if ( Creds )
    {
        if (Creds->lpszHost)
            FREE_MEMORY(Creds->lpszHost);
        if ( Creds->lpszUser )
            FREE_MEMORY(Creds->lpszUser);
        if ( Creds->lpszPass )
            FREE_MEMORY(Creds->lpszPass);
        if ( Creds->lpszRealm )
            FREE_MEMORY(Creds->lpszRealm);
        FREE_MEMORY(Creds);
    }
}

PUBLIC DWORD AUTH_CREDS::SetUser (LPSTR lpszInput)
{
    //AssertHaveLock();
    if (!lpszInput)
    {
        if (lpszUser)
            FREE_MEMORY (lpszUser);
        lpszUser = NULL;
        return ERROR_SUCCESS;
    }
    if (lpszUser && !lstrcmp (lpszUser, lpszInput))
        return ERROR_SUCCESS; // didn't change
    LPSTR lpszTemp = NewString(lpszInput);
    if (!lpszTemp)
        return ERROR_NOT_ENOUGH_MEMORY;
    if (lpszUser)
        FREE_MEMORY (lpszUser);
    lpszUser = lpszTemp;
    return ERROR_SUCCESS;
}

PUBLIC DWORD AUTH_CREDS::SetPass (LPSTR lpszInput)
{
    //AssertHaveLock();
    if (!lpszInput)
    {
        if (lpszPass)
            FREE_MEMORY (lpszPass);
        lpszPass = NULL;
        return ERROR_SUCCESS;
    }
    if (lpszPass && !lstrcmp (lpszPass, lpszInput))
        return ERROR_SUCCESS; // didn't change
    LPSTR lpszTemp = NewString(lpszInput);
    if (!lpszTemp)
        return ERROR_NOT_ENOUGH_MEMORY;
    if (lpszPass)
        FREE_MEMORY (lpszPass);
    lpszPass = lpszTemp;
    return ERROR_SUCCESS;
}


/*++
Delete some entries from a singly linked list.
--*/
/*
PRIVATE void FlushCredsList (AUTH_CREDS **ppList)
{
    AssertHaveLock();

    AUTH_CREDS *Creds = *ppList;
    while (Creds)
    {
        AUTH_CREDS *CredsNext = Creds->pNext;

        if (!Creds->nLockCount)
            Creds_Free (Creds);
        else
        {
            *ppList = Creds;
            ppList = &(Creds->pNext);
        }

        Creds = CredsNext;
    }
    *ppList = NULL;
}
*/


//-----------------------------------------------------------------------------
//
//
//      Auth* functions
//
//          AuthOpen
//          AuthClose
//          AuthLock
//          AuthUnlock
//          AuthInDialog
//          AuthNotify
//          AuthFlush
//
//

BOOL AuthOpen (void)
{
    INET_ASSERT (!g_dwOwnerId && !g_nLockCount);
    return g_crstAuth.Init();
}

void AuthClose (void)
{
    g_crstAuth.FreeLock();
    INET_ASSERT (!g_dwOwnerId && !g_nLockCount);
}

BOOL AuthLock (void)
{
    INET_ASSERT(g_crstAuth.IsInitialized() == TRUE);
    if (!g_crstAuth.Lock())
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }
    DEBUG_ONLY (if (!g_nLockCount++) g_dwOwnerId = GetCurrentThreadId();)
    return TRUE;
}

void AuthUnlock (void)
{
    INET_ASSERT(g_crstAuth.IsInitialized() == TRUE);
    INET_ASSERT (g_nLockCount > 0);
    DEBUG_ONLY (if (!--g_nLockCount) g_dwOwnerId = 0;)
    g_crstAuth.Unlock();
}

/*++
Flush any server and proxy password cache entries not in use.
--*/
PUBLIC void AuthFlush (void)
{
    // Serialize access to globals.
    if (AuthLock())
    {
        if (!g_cSspiContexts)
            AUTHCTX::UnloadAll();

        DIGEST_CTX::FlushCreds();

        AuthUnlock();
    }
}


PUBLIC void AuthUnload (void)
/*++
Routine Description:
    Frees all Cached URLs, and unloads any loaded DLL authentication modeles.

--*/
{
    if (g_crstAuth.IsInitialized())
    {
        AuthFlush();
        if (AuthLock())
        {
            AUTHCTX::UnloadAll();
            AuthUnlock();
        }
    }
}


//-----------------------------------------------------------------------------
//
//
//      Utility Functions:
//
//          SspiFlush
//          TemplateMatch
//          MakeTemplate
//          GetProxyName
//          ReadRegKey
//          TrimQuotes
//          TrimWhiteSpace
//          GetDelimitedToken
//          GetKeyValuePair
//
//


typedef BOOL (WINAPI * SSPI_FLUSH) (VOID) ;

void SspiFlush (LPSTR pszDll)
{
    __try
    {
        HINSTANCE hinst = GetModuleHandle (pszDll);

        if (hinst)
        {
            SSPI_FLUSH pfnFlush = (SSPI_FLUSH)
                GetProcAddress (hinst, "CleanupCredentialCache");

            if (pfnFlush)
            {
                (*pfnFlush) ();
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        INET_ASSERT (FALSE);
    }
    ENDEXCEPT
}



PRIVATE BOOL TemplateMatch(LPSTR lpszTemplate, LPSTR lpszFilename)

/*++

Routine Description:

    Attempts to match a template URL string with a URL ( FileName )

Arguments:

    lpszTemplate             - Template to match against.
    lpszFilename             - URL to match with the template

Return Value:

    BOOL
    Success - TRUE - match
    Failure - FALSE - no match

Comments:

    Note: This Legacy code from the SpyGlass IE 1.0 browser

--*/

{
    /* code for this routine cloned from HTAA_templateMatch() */

    CHAR *p = lpszTemplate;
    CHAR *q = lpszFilename;
    int m;

    if (!lpszTemplate || !lpszFilename)
        return 0;

    for (; *p && *q && *p == *q; p++, q++)  /* Find first mismatch */
        ;                                                                       /* do nothing else */

    if (!*p && !*q)
        return 1;                                                       /* Equally long equal strings */
    else if (WILDCARD == *p)
    {                                                                               /* Wildcard */
        p++;                                                            /* Skip wildcard character */
        m = strlen(q) - strlen(p);                      /* Amount to match to wildcard */
        if (m < 0)
            return 0;                                               /* No match, filename too short */
        else
        {                                                                       /* Skip the matched characters and compare */
        if (lstrcmp(p, q + m))
                return 0;                                       /* Tail mismatch */
            else
                return 1;                                       /* Tail match */
        }
    }                                                                               /* if wildcard */
    else
        return 0;                                                       /* Length or character mismatch */
}


PRIVATE LPSTR MakeTemplate (LPSTR docname)

/*++
Routine Description:
    Makes a Template String (from a URL) that can later be used to match a range of URLs.

Arguments:
    ppszTemplate             - pointer to pointer of where Template can be stored
    docname                  - URL to create a template with.

Return Value: BOOL
    Success - TRUE - created
    Failure - FALSE - error

Comments:
    Note: This Legacy code from the SpyGlass IE 1.0 browser
--*/

{
    CHAR *pszTemplate = NULL;
    unsigned long k;
    k = 0;

    if (docname)
    {
        CHAR *slash;
        CHAR *first_slash;

        //
        // Ignore everything after first reserved character.
        //

        BYTE chSave = 0;
        LPSTR lpszScan = docname;
        while (*lpszScan)
        {
            if (*lpszScan == '?' || *lpszScan == ';')
            {
                chSave = *lpszScan;
                *lpszScan = 0;
                break;
            }
            lpszScan++;
        }

        slash = strrchr(docname, '/');

        //
        // If there is a "//" and no other slashes,
        //  then make sure not to chop the hostname off
        //  the URL. ex: http://www.netscape.com
        //  should be //www.netscape.com* not //*
        //

        if (slash)
        {
            first_slash = strchr(docname, '/' );
            if ((first_slash+1) == slash)
                k = lstrlen(docname);
            else
                k = (unsigned long)(slash-docname)+1;
        }

        // Restore any reserved character (or rewrite terminating null)
        *lpszScan = chSave;
    }

    pszTemplate = (CHAR *) ALLOCATE_FIXED_MEMORY(k+2);
    if (!pszTemplate)
        return 0;

    memcpy(pszTemplate, docname, k);
    pszTemplate[k]= WILDCARD;
    pszTemplate[k+1]=0;

    DEBUG_PRINT(HTTP, INFO, ("MakeTemplate: made template [%s] from [%s]\n",
        pszTemplate, docname ));

    return pszTemplate;
}

LPSTR GetProxyName (HTTP_REQUEST_HANDLE_OBJECT *pRequest)
{
    // Get the proxy name.
    LPSTR lpszProxy;
    DWORD cbProxy;
    INTERNET_PORT port;

   pRequest->GetProxyName(
                &lpszProxy,
                &cbProxy,
                &port);

   return lpszProxy;
}


//++------------------------------------------------------------------------
//
//   Function: ReadRegKey
//
//   Synopsis: This function reads a registry key.
//
//   Arguments:
//
//   Returns:   TRUE     no error
//                 FALSE    a fatal error happened
//
//   History:      AshishS    Created     5/22/96
//------------------------------------------------------------------------

BOOL ReadRegKey(
    BYTE * pbRegValue, // The value of the reg key will be
                 // stored here
    DWORD * pdwNumBytes, // Pointer to DWORD conataining
     // the number of bytes in the above buffer - will be
     // set to actual bytes stored.
    LPSTR  pszRegKey, // Reg Key to be opened
    LPSTR  pszRegValueName, // Reg Value to query
    DWORD  dwRegTypeExpected) // Expected type of Value
{
    HKEY   hRegKey;
    DWORD  dwRegType;
    LONG lResult;

     //read registry to find out name of the file
    if ( (lResult = REGOPENKEYEX(HKEY_LOCAL_MACHINE,
                                 pszRegKey, // address of subkey name
                                 0,          // reserved
                                 KEY_READ,   // samDesired
                                 &hRegKey
                                  // address of handle of open key
        )) != ERROR_SUCCESS )
    {
        goto cleanup;
    }


    if ( (lResult =RegQueryValueEx( hRegKey,
                                    pszRegValueName,
                                    0,           // reserved
                                    &dwRegType,// address of buffer
                                     // for value type
                                    pbRegValue,
                                    pdwNumBytes)) != ERROR_SUCCESS )
    {
        REGCLOSEKEY(hRegKey);
        goto cleanup;
    }

    REGCLOSEKEY(hRegKey);

    if ( dwRegType != dwRegTypeExpected )
    {
        goto cleanup;
    }

    return TRUE;

cleanup:

    return FALSE;

}


/*-----------------------------------------------------------------------------
Inplace trim of one leading and one trailing quote.
-----------------------------------------------------------------------------*/
VOID TrimQuotes(LPSTR *psz, LPDWORD pcb)
{
    if (*pcb && (**psz == '"'))
    {
        (*psz)++;
        (*pcb)--;
    }
    if (*pcb && (*(*psz + *pcb - 1) == '"'))
        (*pcb)--;
}

/*-----------------------------------------------------------------------------
Inplace trim of leading and trailing whitespace.
-----------------------------------------------------------------------------*/
VOID TrimWhiteSpace(LPSTR *psz, LPDWORD pcb)
{
    DWORD cb = *pcb;
    CHAR* beg = *psz;
    CHAR* end = beg + cb - 1;

    while ((cb != 0) && ((*beg == ' ') || (*beg == '\t')))
    {
        beg++;
        cb--;
    }

    while ((cb != 0) && ((*end == ' ') || (*end == '\t')))
    {
        end--;
        cb--;
    }

    *psz = beg;
    *pcb = cb;
}

/*-----------------------------------------------------------------------------
Inplace strtok based on one delimiter. Ignores delimiter scoped by quotes.
-----------------------------------------------------------------------------*/
BOOL GetDelimitedToken(LPSTR* pszBuf,   LPDWORD pcbBuf,
                       LPSTR* pszTok,   LPDWORD pcbTok,
                       CHAR   cDelim)
{
    CHAR *pEnd;
    BOOL fQuote = FALSE,
         fRet   = FALSE;

    *pcbTok = 0;
    *pszTok = *pszBuf;
    pEnd = *pszBuf + *pcbBuf - 1;

    while (*pcbBuf)
    {
        if ( ((**pszBuf == cDelim) && !fQuote)
            || (*pszBuf == pEnd)
            || (**pszBuf =='\r')
            || (**pszBuf =='\n'))
        {
            fRet = TRUE;
            break;
        }

        if (**pszBuf == '"')
            fQuote = !fQuote;

        (*pszBuf)++;
        (*pcbBuf)--;
    }

    if (fRet)
    {
        *pcbBuf = (DWORD) (pEnd - *pszBuf);
        if (**pszBuf == cDelim)
        {
            *pcbTok = (DWORD)(*pszBuf - *pszTok);
            (*pszBuf)++;
        }
        else
            *pcbTok = (DWORD) (*pszBuf - *pszTok) + 1;
    }

    return fRet;
}


/*-----------------------------------------------------------------------------
Inplace retrieval of key and value from a buffer of form key = <">value<">
-----------------------------------------------------------------------------*/
BOOL GetKeyValuePair(LPSTR  szB,    DWORD cbB,
                     LPSTR* pszK,   LPDWORD pcbK,
                     LPSTR* pszV,   LPDWORD pcbV)
{
    if (GetDelimitedToken(&szB, &cbB, pszK, pcbK, '='))
    {
        TrimWhiteSpace(pszK, pcbK);

        if (cbB)
        {
            *pszV = szB;
            *pcbV = cbB;
            TrimWhiteSpace(pszV, pcbV);
        }
        else
        {
            *pszV = NULL;
            *pcbV = 0;
        }
        return TRUE;
    }

    else
    {
        *pszK  = *pszV  = NULL;
        *pcbK  = *pcbV = 0;
    }
    return FALSE;
}


//-----------------------------------------------------------------------------
//
//
//      Main authentication functions:
//
//          AddAuthorizationHeader
//          AuthOnRequest
//          ProcessResponseHeader
//          AuthOnRequest
//
//



/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
PRIVATE void AddAuthorizationHeader
(
    HTTP_REQUEST_HANDLE_OBJECT *pRequest,
    AUTHCTX* pAuthCtx
)
{
    if (!pAuthCtx)
        return;

    INET_ASSERT(pAuthCtx->_pSPMData);

    // AssertHaveLock();

    // Call the auth package.
    // CHAR *szHeader;
    // DWORD dwFastHeaderSize = MAX_BLOB_SIZE + HTTP_PROXY_AUTHORIZATION_LEN + 2;
    // CHAR* pszFastHeader = NULL;
    CHAR *szSlowHeader = NULL;
    // ULONG cbHeader;
    LPSTR pBuf;
    DWORD cbBuf;
    DWORD dwPlugInError;
    // CHAR *pszHeader;

    /*
    pszFastHeader = (CHAR*)ALLOCATE_FIXED_MEMORY(dwFastHeaderSize);
    if (!pszFastHeader)
    {
        // Don't worry about reporting an error.
        // Since this is a low mem condition, the only failure resulting
        // from this is that the header won't be added, and this won't
        // directly cause any more harm than unexpectedly failing to
        // authenticate, which isn't bad, given the low mem state.
        return;
    }
    */


    INT PackageId;
    ULONG cbMaxToken;

    //
    // GetPkgMaxToken() will return 10000 if invalid pkg.
    //

    if( (pAuthCtx->_pSPMData) &&
        (pAuthCtx->_pSPMData->szScheme) &&
        ((PackageId = GetPkgId( pAuthCtx->_pSPMData->szScheme )) != -1)
        )
    {
        cbMaxToken = GetPkgMaxToken( PackageId );
    } else {
        cbMaxToken = MAX_AUTH_MSG_SIZE;
    }

    //
    // add space for base64 overhead (33%, but round up)
    //

    cbMaxToken += (cbMaxToken/2);
    
    // Prefix with the appropriate header.

    /*
    if( cbMaxToken < dwFastHeaderSize )
    {
        cbHeader = dwFastHeaderSize;
        szHeader = pszFastHeader;
    } else {
        cbHeader = cbMaxToken;
        */
        szSlowHeader = (CHAR*)ALLOCATE_FIXED_MEMORY(cbMaxToken);

        if( szSlowHeader == NULL )
        {
            //
            // no clean way to report an error here.  just try with the stack
            // buffer.
            //
            /*
            cbHeader = dwFastHeaderSize;
            szHeader = pszFastHeader;
        } else {
            szHeader = szSlowHeader;  */
            return;
        }
    //}

    if (pAuthCtx->_fIsProxy)
    {
        memcpy (szSlowHeader, HTTP_PROXY_AUTHORIZATION_SZ, HTTP_PROXY_AUTHORIZATION_LEN);
        pBuf = szSlowHeader + HTTP_PROXY_AUTHORIZATION_LEN;

        // Don't reuse this keep-alive socket after a password cache flush.
        pRequest->SetAuthorized();
    }
    else
    {
        memcpy (szSlowHeader, HTTP_AUTHORIZATION_SZ, HTTP_AUTHORIZATION_LEN);
        pBuf = szSlowHeader + HTTP_AUTHORIZATION_LEN;

        // Don't reuse a keep-alive socket after a password cache flush.
        if (!pRequest->IsViaProxy())
            pRequest->SetAuthorized();
    }

    *pBuf++ = ' ';
    cbBuf = cbMaxToken - HTTP_PROXY_AUTHORIZATION_LEN - 2;
    INET_ASSERT (HTTP_PROXY_AUTHORIZATION_LEN >= HTTP_AUTHORIZATION_LEN);


    dwPlugInError =
        pAuthCtx->PreAuthUser(pBuf, &cbBuf);

    //  If the plug in did not fail, add its header to the outgoing header list
    if (dwPlugInError == ERROR_SUCCESS && pAuthCtx->GetState() != AUTHCTX::STATE_ERROR)
    {
        // Append CR-LF.
        pBuf += cbBuf;
        *pBuf++ = '\r';
        *pBuf++ = '\n';
        *pBuf = 0;
        cbBuf = (DWORD) (pBuf - szSlowHeader);

        // Add or replace the (proxy-)authorization header.
        wHttpAddRequestHeaders (pRequest, szSlowHeader, cbBuf,
            HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE);

    }

    // delete [] pszHeader;
    if( szSlowHeader )
    {
        FREE_MEMORY( szSlowHeader );
    }

    /*
    if (pszFastHeader)
    {
        FREE_MEMORY( pszFastHeader );
    }
    */

    DEBUG_LEAVE(0);
}

// biaow: move this to a better place

PSTR DwordSchemeToString(DWORD dwScheme)
{
    switch (dwScheme)
    {
    case WINHTTP_AUTH_SCHEME_BASIC:
        return "Basic";
    case WINHTTP_AUTH_SCHEME_NTLM:
        return "NTLM";
    case WINHTTP_AUTH_SCHEME_PASSPORT:
        return "Passport1.4";
    case WINHTTP_AUTH_SCHEME_DIGEST:
        return "Digest";
    case WINHTTP_AUTH_SCHEME_NEGOTIATE:
        return "Negotiate";
    default:
        return "";
    }
}

DWORD DwordSchemeToFlags(DWORD dwScheme)
{
    switch (dwScheme)
    {
    case WINHTTP_AUTH_SCHEME_BASIC:
        return PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED;
    case WINHTTP_AUTH_SCHEME_NTLM:
        return PLUGIN_AUTH_FLAGS_NO_REALM;
    case WINHTTP_AUTH_SCHEME_PASSPORT:
        return PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED;
    case WINHTTP_AUTH_SCHEME_DIGEST:
        return PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED | PLUGIN_AUTH_FLAGS_CAN_HANDLE_UI;
    case WINHTTP_AUTH_SCHEME_NEGOTIATE:
        return PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED | PLUGIN_AUTH_FLAGS_NO_REALM;
    default:
        return 0;
    }
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
PUBLIC DWORD AuthOnRequest (IN HINTERNET hRequestMapped)
{
    DEBUG_ENTER ((DBG_HTTP, Dword, "AuthOnRequest", "%#x", hRequestMapped));

    DWORD dwError = ERROR_SUCCESS;
    LPSTR lpszUser, lpszPass;
    
    // Get username, password, url, and auth context from request handle.
    HTTP_REQUEST_HANDLE_OBJECT *pRequest =
        (HTTP_REQUEST_HANDLE_OBJECT *) hRequestMapped;

    LPSTR lpszUrl = pRequest->GetURL();
    LPSTR lpszHost= pRequest->GetServerName();

    AUTHCTX *pAuthCtx = pRequest->GetAuthCtx();
    AUTH_CREDS *Creds;
    BOOL fCredsChanged = FALSE;
    
    // PROXY AUTHENTICATION
    //
    // CERN proxies should remove proxy-authorization headers before forwarding
    // requests to servers.  Otherwise, don't add proxy authorization headers
    // that would be seen by servers on a direct connect or via SSL tunneling.

    if  (pRequest->IsRequestUsingProxy()
      && !pRequest->IsTalkingToSecureServerViaProxy())
    {
        // if an app sets proxy creds, we want to make sure that the specified
        // auth scheme is the same as the auth scheme in progress. Otherwise, we
        // will delete the current auth context and build a new one based on the
        // new scheme.
        if (pRequest->_pProxyCreds 
            && (pAuthCtx && pAuthCtx->_fIsProxy)
            && (pAuthCtx->GetRawSchemeType() != pRequest->_pProxyCreds->_AuthScheme))
        {
            delete pAuthCtx;
            pAuthCtx = NULL;
            pRequest->SetAuthCtx(NULL);
        }

        if (pAuthCtx && pAuthCtx->_fIsProxy)
        {
            // We have a proxy authentication in progress.
            // If a user/pass set on handle, transfer to AUTH_CREDS.

            // First check for proxy credentials and fallback to server
            // for legacy wininet apps. This will invalidate the credentials
            // on the handle they were found for any subsequent calls to
            // GetUserAndPass.
            
                // Serialize access to globals.
            if (AuthLock())
            {
                if (pRequest->_pProxyCreds)
                {
                    pAuthCtx->_pCreds->SetUser(pRequest->_pProxyCreds->_pszUserName);
                    pAuthCtx->_pCreds->SetPass(pRequest->_pProxyCreds->_pszPassword);
                }
                else if (pRequest->GetUserAndPass(IS_PROXY, &lpszUser, &lpszPass))
                {
                    pAuthCtx->_pCreds->SetUser(lpszUser);
                    pAuthCtx->_pCreds->SetPass(lpszPass);
                }

                AuthUnlock();

                // Add the authorization header.
                AddAuthorizationHeader (pRequest, pAuthCtx);
            }
        }

        // NO PROXY AUTHENTICATION CONTEXT -> SEE IF A AUTH_CREDS EXISTS.
        else  // See if we have a cached proxy user/pass.
        {
            if (pRequest->_pProxyCreds)
            {
                AUTHCTX::SPMData* pSPMData = 
                    reinterpret_cast<AUTHCTX::SPMData*>(New AUTHCTX::SPMData(
                        DwordSchemeToString(pRequest->_pProxyCreds->_AuthScheme), 
                        DwordSchemeToFlags(pRequest->_pProxyCreds->_AuthScheme)));

                if (pSPMData)
                {
                    AUTH_CREDS *pCreds = AUTHCTX::CreateCreds(pRequest, TRUE,
                                                      pSPMData, pRequest->_pProxyCreds->_pszRealm);
                    if (pCreds)
                    {
                        pCreds->SetUser(pRequest->_pProxyCreds->_pszUserName);
                        pCreds->SetPass(pRequest->_pProxyCreds->_pszPassword);

                        pAuthCtx = AUTHCTX::CreateAuthCtx(pRequest, IS_PROXY, pCreds);
                        if (pAuthCtx && pAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_BASIC)
                        {
                            AddAuthorizationHeader (pRequest, pAuthCtx);
                        }
                        delete pAuthCtx;
                        pAuthCtx = NULL;
                    }
                }
            }
        }
    }

    // SERVER AUTHENTICATION
    //
    // Don't send server authorization when initiating SSL tunneling with proxy.
    if (!pRequest->IsTunnel())
    {
        // if an app sets server creds, we want to make sure that the specified
        // auth scheme is the same as the auth scheme in progress. Otherwise, we
        // will delete the current auth context and build a new one based on the
        // new scheme.
        if (pRequest->_pServerCreds 
            && (pAuthCtx && !pAuthCtx->_fIsProxy)
            && (pAuthCtx->GetRawSchemeType() != pRequest->_pServerCreds->_AuthScheme))
        {
            delete pAuthCtx;
            pAuthCtx = NULL;
            pRequest->SetAuthCtx(NULL);
        }

        // See if we have a server authentication in progress
        if (pAuthCtx && !pAuthCtx->_fIsProxy)
        {
            // Server authentication in progress.

            // If a user/pass set on handle, transfer to AUTH_CREDS.
            // This will invalidate the credentials on the handle they
            // were found for any subsequent calls to GetUserAndPass.
            
            if (AuthLock())
            {
                if (pRequest->_pServerCreds)
                {
                    pAuthCtx->_pCreds->SetUser(pRequest->_pServerCreds->_pszUserName);
                    pAuthCtx->_pCreds->SetPass(pRequest->_pServerCreds->_pszPassword);
                }
                else if (pRequest->GetUserAndPass(IS_SERVER, &lpszUser, &lpszPass))
                {
                    pAuthCtx->_pCreds->SetUser(lpszUser);
                    pAuthCtx->_pCreds->SetPass(lpszPass);
                }

                AuthUnlock();

                // Add the authorization header.
                AddAuthorizationHeader (pRequest, pAuthCtx);
            }
        }
        else  // See if we have a cached server user/pass.
        {
            // NO PROXY AUTHENTICATION CONTEXT -> SEE IF A AUTH_CREDS EXISTS
                
            if (pRequest->_pServerCreds)
            {
                BOOL fPreauth = FALSE;
                AUTHCTX *pNewAuthCtx = NULL;

                AUTHCTX::SPMData* pSPMData = 
                    reinterpret_cast<AUTHCTX::SPMData*>(New AUTHCTX::SPMData(
                        DwordSchemeToString(pRequest->_pServerCreds->_AuthScheme), 
                        DwordSchemeToFlags(pRequest->_pServerCreds->_AuthScheme)));
                
                INET_ASSERT(pSPMData);

                AUTH_CREDS *pCreds = AUTHCTX::CreateCreds(pRequest, FALSE,
                                                  pSPMData, pRequest->_pServerCreds->_pszRealm);
                if (pCreds)
                {
                    pCreds->SetUser(pRequest->_pServerCreds->_pszUserName);
                    pCreds->SetPass(pRequest->_pServerCreds->_pszPassword);

                    pNewAuthCtx = AUTHCTX::CreateAuthCtx(pRequest, IS_SERVER, pCreds);
                    
                    if(pNewAuthCtx)
                    {
                        if (pNewAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_NTLM
                            || pNewAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_NEGOTIATE)
                        {
                            // NTLM or Negotiate (in which case we don't really know the
                            // protocol yet) - create the auth context, set it in the handle
                            // and set state to AUTHSTATE_NEGOTIATE. Handle now has
                            // a valid auth context and is in the correct auth state
                            // for the remainder of the authorization sequence.

                            // It's possible that the Creds entry was created when no proxy
                            // was in use and the user set a proxy. Check that this is
                            // not the case.

                            if (!pRequest->IsMethodBody() 
                                || (pNewAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_NTLM
                                    && pRequest->IsDisableNTLMPreauth())
                                || (pRequest->IsRequestUsingProxy()
                                    && !pRequest->IsTalkingToSecureServerViaProxy()))
                            {
                                // NTLM preauth disabled or over proxy; no preauth.
                                delete pNewAuthCtx;
                                pNewAuthCtx = NULL;
                            }
                            else
                            {
                                // Set the auth context in the handle and
                                // add the auth header.
                                pRequest->SetAuthCtx(pNewAuthCtx);
                                pRequest->SetAuthState(AUTHSTATE_NEGOTIATE);
                                AddAuthorizationHeader (pRequest, pNewAuthCtx);
                                fPreauth = TRUE;
                            }
                        }
                        else
                        {
                            // For Basic and Digest add the header but do not set the
                            // context in the handle since we will delete it next.
                            // In this case we record that we have pre-authenticated which
                            // is necessary state info if the server challenges with a 401
                            // and we are forced to re-authenticate.
                            if ((pNewAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_DIGEST && !fCredsChanged)
                                || (pNewAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_BASIC))
                            {
                                AddAuthorizationHeader (pRequest, pNewAuthCtx);
                                pRequest->SetCreds(pNewAuthCtx->_pCreds);
                                fPreauth = TRUE;
                            }

                            if (pNewAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_PASSPORT)
                            {
                                pRequest->SetAuthCtx(pNewAuthCtx);
                                AddAuthorizationHeader (pRequest, pNewAuthCtx);
                            }
                        }

                        if (fPreauth)
                        {
                            // Proceed to delete the context if basic or digest.
                            if (pNewAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_DIGEST
                                || pNewAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_BASIC)
                            {
                                delete pNewAuthCtx;
                                pNewAuthCtx = NULL;
                            }
                        }                    
                    }
                }
            }
        }
    }

    DEBUG_LEAVE(dwError);
    return dwError;
}


/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
DWORD ProcessResponseHeaders
(
    HINTERNET hRequestMapped,
    BOOL fIsProxy
)
{
    DEBUG_ENTER ((DBG_HTTP, Dword, "ProcessResponseHeaders", "%#x", hRequestMapped));

    DWORD dwError = ERROR_SUCCESS;

    // Get context from request handle.
    HTTP_REQUEST_HANDLE_OBJECT *pRequest
        = (HTTP_REQUEST_HANDLE_OBJECT *) hRequestMapped;
    AUTHCTX* pAuthCtx = pRequest->GetAuthCtx();

    if (pAuthCtx)
    {
        if ((dwError = pAuthCtx->UpdateFromHeaders(pRequest, fIsProxy))
            != ERROR_SUCCESS)
        {
            // Delete the auth context and fail auth 
            // immediately if any other error than
            // scheme has been changed.
            delete pAuthCtx;
            pRequest->SetAuthCtx(NULL);
            if (dwError != ERROR_HTTP_HEADER_NOT_FOUND)
                goto cleanup;

            // Attempt to create a new auth context using
            // the challenge received from the server.
            // If this fails, we follow logic as commented
            // below.
            pAuthCtx = AUTHCTX::CreateAuthCtx(pRequest, fIsProxy);        
            if (!pAuthCtx)
            {
                dwError = ERROR_SUCCESS;
                goto cleanup;
            }
        }
    }
    else
    {
        // CreateAuthCtx returns NULL if auth scheme not
        // supported (fall through from HttpFiltOnResponse
        // in sendreq.cxx) or if scheme is NTLM and the
        // socket is not keep-alive or via proxy.
        // In these cases it is necessary to check for a NULL
        // return value. The correct return code for these cases is
        // ERROR_SUCCESS, which will be returned by AuthOnResponse.
        pAuthCtx = AUTHCTX::CreateAuthCtx(pRequest, fIsProxy);
        if (!pAuthCtx)
        {
            dwError = ERROR_SUCCESS;
            goto cleanup;
        }
    }

    LPSTR lpszUser, lpszPass;

    // First check for proxy credentials and fallback to server
    // for legacy wininet apps. This will invalidate the credentials
    // on the handle they were found for any subsequent calls to
    // GetUserAndPass.

    // I believe we should be putting the credentials in the
    // password cache at this time. The scenario is that a client
    // sets credentials on a handle, after a successful authentication
    // the Creds will have null credentials. Pre-auth will then pull up
    // credentials for the default user!!!!!!!!!!!
    
        // Serialize access to globals.
    if (AuthLock())
    {
        if (pRequest->_pServerCreds && !fIsProxy)
        {
            lpszUser = pRequest->_pServerCreds->_pszUserName;
            lpszPass = pRequest->_pServerCreds->_pszPassword;
        }
        else if (pRequest->_pProxyCreds && fIsProxy)
        {
            lpszUser = pRequest->_pProxyCreds->_pszUserName;
            lpszPass = pRequest->_pProxyCreds->_pszPassword;
        }
        else if ((!pRequest->GetUserAndPass(fIsProxy, &lpszUser, &lpszPass)) && fIsProxy && !GlobalIsProcessExplorer)
        {
            pRequest->GetUserAndPass(IS_SERVER, &lpszUser, &lpszPass);
        }

        AuthUnlock();
    }
    else
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    // If we retrieved credentials from the handle set
    // them in the Creds.
    if (lpszUser && lpszPass)
    {
       pAuthCtx->_pCreds->SetUser(lpszUser);
       pAuthCtx->_pCreds->SetPass(lpszPass);
    }

    // Post authenticate user.
    dwError = pAuthCtx->PostAuthUser();

    // Map all unexpected error codes to login failure.
    if (dwError != ERROR_WINHTTP_FORCE_RETRY
        && dwError != ERROR_WINHTTP_INCORRECT_PASSWORD)
    {
        dwError = ERROR_WINHTTP_LOGIN_FAILURE;
    }

    pRequest->SetAuthCtx(pAuthCtx);

cleanup:
    
    return dwError;
}

extern CHAR g_szPassportDAHost[];


BOOL IsSameDomain(LPCSTR pszTarget, LPCSTR pszResponse)
{
    LPCSTR pszTargetR = pszTarget + strlen(pszTarget);
    DWORD dwDotsSeen = 0;
    while (--pszTargetR > pszTarget)
    {
        if (*pszTargetR == '.')
        {
            if (++dwDotsSeen == 2)
            {
                break;
            }
        }
    }

    if (dwDotsSeen == 2)
    {
        ++pszTargetR;
        DWORD dwOffsetR = strlen(pszTargetR);
        if (strlen(pszResponse) < dwOffsetR)
        {
            return FALSE;
        }

        LPCSTR pszResponseR = pszResponse + strlen(pszResponse) - dwOffsetR;

        return !strcmp(pszTargetR, pszResponseR);
    }
    else
    {
        return FALSE;
    }
}

VOID CheckForTweenerLogout(HTTP_REQUEST_HANDLE_OBJECT *pRequest)
{
    DWORD dwIndex = 0;
    DWORD dwError;

    do
    {
        LPSTR szData;
        DWORD cbData;
        dwError = pRequest->FastQueryResponseHeader(HTTP_QUERY_AUTHENTICATION_INFO,
                                                    (LPVOID*) &szData,
                                                    &cbData,
                                                    dwIndex);
        if (dwError == ERROR_SUCCESS)
        {
            if (strstr(szData, "Passport1.4") && strstr(szData, "logout"))
            {
                if (IsSameDomain(pRequest->GetServerName(), g_szPassportDAHost))
                {
                    // g_fIgnoreCachedCredsForPassport = TRUE;
                    // todo: call session->Logout
                }
                
                break;
            }
        }

        ++dwIndex;

    } while (dwError == ERROR_SUCCESS);
}


/*-----------------------------------------------------------------------------

Routine Description:

    Validates, and Caches Authentication Request headers if needed. If a URL matches a
    cached set of templates it is assumed to require specific authentication information.

Arguments:

    hRequest                - An open HTTP request handle
                              where headers will be added if needed.

Return Value:

    DWORD
    Success - ERROR_SUCCESS

    Failure - One of Several Error codes defined in winerror.h or wininet.w

Comments:

    Need to handle mutiple authentication pages.

-----------------------------------------------------------------------------*/
PUBLIC DWORD AuthOnResponse (HINTERNET hRequestMapped)
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "AuthOnResponse",
                 "%#x [%#x]",
                 hRequestMapped,
                 ((INTERNET_HANDLE_OBJECT *)hRequestMapped)->GetPseudoHandle()
                 ));

    // Get URL and password cache entry from request handle.
    HTTP_REQUEST_HANDLE_OBJECT *pRequest =
        (HTTP_REQUEST_HANDLE_OBJECT *) hRequestMapped;

    AUTHCTX *pAuthCtx = pRequest->GetAuthCtx();
    DWORD dwStatus = pRequest->GetStatusCode();

    if (pAuthCtx)
    {
        if (pAuthCtx->_fIsProxy && dwStatus != HTTP_STATUS_PROXY_AUTH_REQ)
        {
            // We are done with proxy authentication.
            delete pAuthCtx;
            pRequest->SetAuthCtx (NULL);
            
            if (pRequest->_pProxyCreds)
            {
                delete pRequest->_pProxyCreds;
                pRequest->_pProxyCreds = NULL;
            }
        }
        else if (!pAuthCtx->_fIsProxy && dwStatus != HTTP_STATUS_DENIED)
        {
			if ((pAuthCtx->GetSchemeType() != WINHTTP_AUTH_SCHEME_PASSPORT) || dwStatus != HTTP_STATUS_REDIRECT)
            {
                // We are done with server authentication.
                delete pAuthCtx;
                pRequest->SetAuthCtx (NULL);

                if (pRequest->_pServerCreds)
                {
                    delete pRequest->_pServerCreds;
                    pRequest->_pServerCreds = NULL;
                }
            }
			else
            {
                // in the case of Passport Auth, 302 is still not done yet, 
                // but this is quite strange since 302 came a second time
                // biaow-todo: we could be in a loop here
            }
        }
    }

    // Remove any stale authorization headers in case wHttpSendRequest
    // loops, for example, to handle a redirect.  To ignore trailing colon,
    // subtract 1 from header lengths passed to ReplaceRequestHeader.
    pRequest->ReplaceRequestHeader
        (HTTP_QUERY_AUTHORIZATION,
                    "", 0, 0, HTTP_ADDREQ_FLAG_REPLACE);
    pRequest->ReplaceRequestHeader
        (HTTP_QUERY_PROXY_AUTHORIZATION,
            "", 0, 0, HTTP_ADDREQ_FLAG_REPLACE);

    DWORD error;

    DWORD dwZone, dwPolicy;

//
// note: Negotiate MUTUAL_AUTH can return dwStatus = 200 with a final
// WWW-Authenticate blob to process.  logic below could be adjusted
// to ProcessResponseHeaders() in this situation, which allows MUTUAL_AUTH
// to be enforced.
//
    
    switch (dwStatus)
    {
        case HTTP_STATUS_PROXY_AUTH_REQ: // 407
            error = ProcessResponseHeaders(pRequest, IS_PROXY);
            break;

        case HTTP_STATUS_REDIRECT: // 302
    
            // process the header to see whether this is a 302 passport1.4 challenge

        case HTTP_STATUS_DENIED: // 401

            error = ProcessResponseHeaders(pRequest, IS_SERVER);
            break;

        default:
            pRequest->SetAuthState(AUTHSTATE_NONE);
            error = ERROR_SUCCESS;
    }

    // creds set by WinHttpSetCredentials() is good for one "authentication attempt" only. 
    // Since we are done authentication here, we are deleting it.

    // biaow: detect the "final" failure so that we can delete the creds.
    
    CheckForTweenerLogout(pRequest);
    
    DEBUG_LEAVE(error);
    return error;
}




//-----------------------------------------------------------------------------
//
//
//      AUTHCTX Base class definitions
//
//
//
//      static funcs:
//          Enumerate
//          UnloadAll
//          CreateAuthCtx
//          CreateAuthCtx (using Creds*)
//          GetSPMListState
//          SearchCredsList
//          FindOrCreateCreds
//          GetAuthHeaderData
//
//      base funcs:
//          FindHdrIdxFromScheme
//          GetScheme
//          GetSchemeType - returns enum
//          GetFlags      - returns SPM flags
//          GetState      - returns state of SPM provider
//
//
//      virtual overrides: defined in basic.cxx, plug.cxx and digest.cxx
//          UpdateFromHeaders
//          PreAuthUser
//          PostAuthUser
//
//
//


/*---------------------------------------------------------------------------
AUTHCTX::SPMData constructor
---------------------------------------------------------------------------*/
AUTHCTX::SPMData::SPMData(LPSTR _szScheme, DWORD _dwFlags)
{
    if (_szScheme)
    {
        szScheme = NewString(_szScheme);
        cbScheme = strlen(_szScheme);
    }
    else
    {
        szScheme = NULL;
        cbScheme = 0;
    }

    if (szScheme)
    {
        if (!lstrcmpi(szScheme, "Basic"))
            eScheme = WINHTTP_AUTH_SCHEME_BASIC;
        else if (!lstrcmpi(szScheme, "NTLM"))
            eScheme = WINHTTP_AUTH_SCHEME_NTLM;
        else if (!lstrcmpi(szScheme, "Digest"))
            eScheme = WINHTTP_AUTH_SCHEME_DIGEST;
        else if (!lstrcmpi(szScheme, "Negotiate"))
            eScheme = WINHTTP_AUTH_SCHEME_NEGOTIATE;
        else if (!lstrcmpi(szScheme, "Passport1.4"))
            eScheme = WINHTTP_AUTH_SCHEME_PASSPORT;
        else
            eScheme = 0;

        dwFlags    = _dwFlags;
        eState     = STATE_NOTLOADED;
    }
    else
    {
        dwFlags    = 0;
        eState     = STATE_ERROR;
    }
}

/*---------------------------------------------------------------------------
AUTHCTX::SPMData destructor
---------------------------------------------------------------------------*/
AUTHCTX::SPMData::~SPMData()
{ delete szScheme; }


/*---------------------------------------------------------------------------
AUTHCTX constructor
---------------------------------------------------------------------------*/
AUTHCTX::AUTHCTX(SPMData *pData, AUTH_CREDS *pCreds)
{
    _pSPMData = pData;
    _pCreds = pCreds;
    _pRequest = NULL;
    _fIsProxy = FALSE;
    _pvContext = NULL;
    _eSubScheme = 0;
    _dwSubFlags = 0;

    _CtxCriSec.Init();
}


/*---------------------------------------------------------------------------
    Destructor
---------------------------------------------------------------------------*/
AUTHCTX::~AUTHCTX()
{
    if (AuthLock())
    {
        if (_pCreds)
            Creds_Free(_pCreds);
        AuthUnlock();
    }

    _CtxCriSec.FreeLock();
}


// ------------------------  Static Functions ---------------------------------


/*---------------------------------------------------------------------------
    Enumerate
---------------------------------------------------------------------------*/
VOID AUTHCTX::Enumerate()
{
    struct SchemeFlagsPair
    {
        LPSTR pszScheme;
        DWORD Flags;
    };

    SchemeFlagsPair SchemeFlags[] = {
                        {"NTLM", PLUGIN_AUTH_FLAGS_NO_REALM},
                        {"Basic", PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED},
                        {"Digest", PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED | PLUGIN_AUTH_FLAGS_CAN_HANDLE_UI},
                        {"Negotiate", PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED | PLUGIN_AUTH_FLAGS_NO_REALM},
                        {"Passport1.4",  PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED}
                        };
    
    SPMData   *pNew;
    g_pSPMList = NULL;
    g_eState = STATE_ERROR;

    AssertHaveLock();

    // Hard-wired Basic, NTLM and Digest
    for (DWORD dwIndex = 0; dwIndex < sizeof(SchemeFlags) / sizeof(SchemeFlagsPair); dwIndex++)
    {
        if (!GlobalPlatformVersion5 // we don't support Negotiate on NT4 or Win9x
            && !stricmp(SchemeFlags[dwIndex].pszScheme, "Negotiate"))
        {
            continue;
        }

        pNew = (AUTHCTX::SPMData*) New SPMData(SchemeFlags[dwIndex].pszScheme, SchemeFlags[dwIndex].Flags);
        if (!pNew)
            return;

        // Add to head of list.
        if (pNew->eState != STATE_ERROR)
        {
            pNew->pNext = g_pSPMList;
            g_pSPMList = pNew;
        }
    }

    // The list is now in the correct state.
    g_eState = STATE_LOADED;
}


VOID AUTHCTX::UnloadAll()
{
    // BUGBUG - AuthFlush is called when the last browser session
    // is closed. First the global Creds lists are destructed, and
    // then this func (UnloadAll) is called. However, the global
    // Creds lists are not necessarily flushed (they may have out-
    // standing ref counts) and may persist across browser sessions.
    // when we destruct the SPM list in this func, SPMs reference
    // by any surviving Creds entries are bogus and can be used
    // for subsequent authentication, resulting in a fault.
    //
    // The temporary hack here is to not destruct the SPM
    // list if any Creds list is not destructed. We leak the
    // SPM list on process detach but don't fault. Put the
    // SPM destruct code in DllProcessDetach.
    
    SPMData *pData = g_pSPMList;
    while (pData)
    {
        SPMData *pNext = pData->pNext;
        delete pData;
        pData = pNext;
    }

    SSPI_Unload();
    g_eState = STATE_NOTLOADED;
    g_pSPMList = NULL;
}

DWORD StringSchemeToDword(LPSTR szScheme)
{
    if (!stricmp(szScheme, "Basic"))
    {
        return WINHTTP_AUTH_SCHEME_BASIC;
    }
    else if (!stricmp(szScheme, "Digest"))
    {
        return WINHTTP_AUTH_SCHEME_DIGEST;
    }
    else if (!stricmp(szScheme, "Passport1.4"))
    {
        return WINHTTP_AUTH_SCHEME_PASSPORT;
    }
    else if (!stricmp(szScheme, "NTLM"))
    {
        return WINHTTP_AUTH_SCHEME_NTLM;
    }
    else if (!stricmp(szScheme, "Negotiate"))
    {
        return WINHTTP_AUTH_SCHEME_NEGOTIATE;
    }
    else
    {
        return 0;
    }
}

/*---------------------------------------------------------------------------
    CreateAuthCtx
    Create an AUTHCTX* from headers - initially the authentication context
    is created without a AUTH_CREDS entry. The AUTH_CREDS entry will be found or created
    and possibly updated in UpdateFromHeaders.
---------------------------------------------------------------------------*/
AUTHCTX* AUTHCTX::CreateAuthCtx(HTTP_REQUEST_HANDLE_OBJECT * pRequest, BOOL fIsProxy)
{
    LPSTR szScheme;
    DWORD cbScheme, dwError, dwAuthIdx;
    AUTHCTX *pAuthCtx = NULL;

    dwAuthIdx = 0;
    szScheme = NULL;


    // Get scheme. This is assumed to be the first
    // non-ws token in the auth header info.
    do
    {
        // It is necessary to hold on to the auth index
        // in this loop because we could have gone through
        // more than one scheme.
        dwError = GetAuthHeaderData(pRequest, fIsProxy, NULL,
            &szScheme, &cbScheme, ALLOCATE_BUFFER | GET_SCHEME, dwAuthIdx);

        if (dwError != ERROR_SUCCESS)
            goto quit;

        pRequest->_SupportedSchemes |= StringSchemeToDword(szScheme);
        pRequest->_AuthTarget = fIsProxy ? WINHTTP_AUTH_TARGET_PROXY : WINHTTP_AUTH_TARGET_SERVER;
        
        // This will create the appropriate authentication context
        // with a NULL password cache. The password cache will be
        // created in the call to UpdateFromHeaders.
        
        if (pAuthCtx == NULL)
        {
            pAuthCtx = CreateAuthCtx(pRequest, fIsProxy, szScheme);

            // If creation of an auth context is successful, update
            // the context from any header info.
            if (pAuthCtx)
            {
                if (pAuthCtx->UpdateFromHeaders(pRequest, fIsProxy) != ERROR_SUCCESS)
                {
                    delete pAuthCtx;
                    pAuthCtx = NULL;
                }
                else
                {
                    pRequest->_PreferredScheme = StringSchemeToDword(szScheme);
                }
            }
        }
        
        dwAuthIdx++;

        delete szScheme;
        szScheme = NULL;

    } while (1);

quit:

    if (szScheme)
        delete szScheme;

    return pAuthCtx;
}

/*---------------------------------------------------------------------------
    CreateAuthCtx
    Create an AUTHCTX without a AUTH_CREDS from scheme
---------------------------------------------------------------------------*/
AUTHCTX* AUTHCTX::CreateAuthCtx(HTTP_REQUEST_HANDLE_OBJECT *pRequest,
    BOOL fIsProxy, LPSTR szScheme)
{
    if (!AuthLock())
    {
        return NULL;
    }

    AUTHCTX *pNewAuthCtx = NULL;

    // we don't want to create a Passport1.4 context on 401 response (from DA)
    if (!lstrcmpi("Passport1.4", szScheme))
    {
        if (pRequest->GetStatusCode() == HTTP_STATUS_DENIED)
        {
            goto quit;
        }
    }

    // If necessary, enumerate auth providers from registry.
    if (AUTHCTX::GetSPMListState() == AUTHCTX::STATE_NOTLOADED)
        AUTHCTX::Enumerate();

    if (AUTHCTX::GetSPMListState() != AUTHCTX::STATE_LOADED)
    {
        // not critical, just no authentication
        goto quit;
    }

    SPMData *pSPM;
    pSPM = g_pSPMList;

    // Find SPMData to create from scheme.
    while (pSPM)
    {
        if (!lstrcmpi(pSPM->szScheme, szScheme))
            break;

        pSPM = pSPM->pNext;
    }

    if (!pSPM)
    {
        // No matching auth scheme found.
        // Not critical, just no auth.
        goto quit;
    }

    // Create an auth context without Creds
    switch(pSPM->eScheme)
    {
        // Create BASIC_CTX with NULL AUTH_CREDS.
        case WINHTTP_AUTH_SCHEME_BASIC:
            pNewAuthCtx = New BASIC_CTX(pRequest, fIsProxy, pSPM, NULL);
            break;

        // Create DIGEST_CTX with NULL AUTH_CREDS.
        case WINHTTP_AUTH_SCHEME_DIGEST:
            pNewAuthCtx = New DIGEST_CTX(pRequest, fIsProxy, pSPM, NULL);
            break;

        case WINHTTP_AUTH_SCHEME_PASSPORT:
            pNewAuthCtx = new PASSPORT_CTX(pRequest, fIsProxy, pSPM, NULL);
            if (pNewAuthCtx)
            {
                if (((PASSPORT_CTX*)pNewAuthCtx)->Init() == FALSE)
                {
                    delete pNewAuthCtx;
                    pNewAuthCtx = NULL;
                }
            }
            break;

        // Create PLUG_CTX with NULL AUTH_CREDS.
        case WINHTTP_AUTH_SCHEME_NTLM:
        case WINHTTP_AUTH_SCHEME_NEGOTIATE:

        default:
            pNewAuthCtx = New PLUG_CTX(pRequest, fIsProxy, pSPM, NULL);

    }


quit:
    AuthUnlock();
    return pNewAuthCtx;
}


/*---------------------------------------------------------------------------
    CreateAuthCtx
    Create an AUTHCTX from a AUTH_CREDS.
---------------------------------------------------------------------------*/
AUTHCTX* AUTHCTX::CreateAuthCtx(HTTP_REQUEST_HANDLE_OBJECT *pRequest,
                    BOOL fIsProxy, AUTH_CREDS* pCreds)
{
    if (!AuthLock())
    {
        return NULL;
    }
    
    AUTHCTX *pNewAuthCtx = NULL;

    // If necessary, enumerate auth providers from registry.
    if (AUTHCTX::GetSPMListState() == AUTHCTX::STATE_NOTLOADED)
        AUTHCTX::Enumerate();

    if (AUTHCTX::GetSPMListState() != AUTHCTX::STATE_LOADED)
    {
        // not critical, just no authentication
        goto quit;
    }

    // Handle tests (via proxy, is keep-alive)
    // will be done in UpdateFromHeaders. Here
    // we just construct the AUTHCTX.
    switch(pCreds->pSPM->eScheme)
    {
        // Create BASIC_CTX.
        case WINHTTP_AUTH_SCHEME_BASIC:

            pNewAuthCtx = New BASIC_CTX(pRequest, fIsProxy, pCreds->pSPM, pCreds);
            break;

        // Create DIGEST_CTX.
        case WINHTTP_AUTH_SCHEME_DIGEST:
            pNewAuthCtx = New DIGEST_CTX(pRequest, fIsProxy, pCreds->pSPM, pCreds);
            break;

        case WINHTTP_AUTH_SCHEME_PASSPORT:
            pNewAuthCtx = new PASSPORT_CTX(pRequest, fIsProxy, pCreds->pSPM, pCreds);
            if (pNewAuthCtx)
            {
                if (((PASSPORT_CTX*)pNewAuthCtx)->Init() == FALSE)
                {
                    delete pNewAuthCtx;
                    pNewAuthCtx = NULL;
                }
            }
            break;

        // Create PLUG_CTX.
        case WINHTTP_AUTH_SCHEME_NTLM:
        case WINHTTP_AUTH_SCHEME_NEGOTIATE:

        default:
            pNewAuthCtx = New PLUG_CTX(pRequest, fIsProxy, pCreds->pSPM, pCreds);

    }


quit:
    AuthUnlock();
    return pNewAuthCtx;
}

AUTHCTX::SPMState AUTHCTX::GetSPMListState()
    { return g_eState; }


/*-----------------------------------------------------------------------------
    SearchCredsList
-----------------------------------------------------------------------------*/
//AUTH_CREDS* AUTHCTX::SearchCredsList
//    (AUTH_CREDS* Creds, LPSTR lpszHost, LPSTR lpszUri, LPSTR lpszRealm, SPMData *pSPM)
/*++

Routine Description:
    Scans the Linked List Cache for URLs, Realms, and Servers.  Also allows
    filter fields, to narrow searches.

Arguments:
    Creds                   - Pointer to first item to search from.
    lpszHost              - Host, or Server name to search on.
    lpszUri               - URL to search on.
    lpszRealm             - Security Realm to search on
    lpszScheme            - Authentication scheme to search on.
Return Value:

    AUTH_CREDS *
    Success - Pointer to found item.

    Failure - NULL pointer.

Comments:
    Note: This Legacy code from the SpyGlass IE 1.0 browser

    The AUTH_CREDS lists are searched on every request.  Could optimize by keeping
    a hash value of the server/proxy name.

    If an exact match isn't found on a 401 response, the list is walked again
    to search for a realm match.  Could add a parameter to do both at once.
--*/

/*
{
    AssertHaveLock();

    while (Creds)
    {
        if (   (!pSPM || pSPM == Creds->pSPM)
            && (!lpszHost  || !lstrcmpi(Creds->lpszHost,lpszHost))
            && (!lpszRealm || !lstrcmpi(Creds->lpszRealm,lpszRealm))
            && (!lpszUri   || TemplateMatch (Creds->lpszUrl, lpszUri))
           )
        {

            DEBUG_PRINT(HTTP, INFO, ("Lookup: Found template match [%q]\n",
                Creds->lpszUser));
            return Creds;
        }
        else
        {
            Creds = Creds->pNext;
        }
    }

    return NULL;
}
*/



/*-----------------------------------------------------------------------------
    FindOrCreateCreds
-----------------------------------------------------------------------------*/
AUTH_CREDS* AUTHCTX::CreateCreds(
    HTTP_REQUEST_HANDLE_OBJECT *pRequest,
    BOOL     fIsProxy,
    SPMData *pSPM,
    LPSTR    lpszRealm
)
{
    //AssertHaveLock();

    // Create a AUTH_CREDS.
    AUTH_CREDS *Creds;
    Creds = NULL;

    if (!pSPM)
    {
        INET_ASSERT(FALSE);
        goto quit;
    }

    // Get host from request handle.
    LPSTR lpszHost;
    lpszHost = fIsProxy?
        GetProxyName(pRequest) : pRequest->GetServerName();

    // For NTLM, use the hostname analagously to basic realm.
    if (pSPM->eScheme == WINHTTP_AUTH_SCHEME_NTLM || pSPM->eScheme == WINHTTP_AUTH_SCHEME_NEGOTIATE)
    {
        INET_ASSERT (!lpszRealm);
        lpszRealm = lpszHost;
    }

    Creds = Creds_Create (lpszHost, lpszRealm, pSPM);
    
quit:
    
    return Creds;
}

/*-----------------------------------------------------------------------------
    GetAuthHeaderData
-----------------------------------------------------------------------------*/
DWORD AUTHCTX::GetAuthHeaderData(
    HTTP_REQUEST_HANDLE_OBJECT *pRequest,
    BOOL      fIsProxy,
    LPSTR     szItem,
    LPSTR    *pszData,
    LPDWORD   pcbData,
    DWORD     dwFlags,
    DWORD     dwIndex)
{
    LPSTR szData;
    DWORD cbData, cbItem, dwError = ERROR_SUCCESS;;
    CHAR *szTok, *szKey, *szValue;
    DWORD cbTok, cbKey, cbValue;

    szTok = szKey = szValue = NULL;
    cbTok = cbKey = cbValue = NULL;

    cbItem = szItem ? strlen(szItem) : 0;

    DWORD dwQuery = fIsProxy?
        HTTP_QUERY_PROXY_AUTHENTICATE : HTTP_QUERY_WWW_AUTHENTICATE;

    // NULL item passed in means get up to the first \r\n, or
    // possibly only the scheme is desired depending on dwFlags.
    if (!cbItem)
    {
        if ((dwError = pRequest->FastQueryResponseHeader(dwQuery,
            (LPVOID*) &szData,
            &cbData,
            dwIndex)) != ERROR_SUCCESS)
        {
            goto quit;
        }

        // Only the scheme is desired.
        if (dwFlags & GET_SCHEME)
        {
            CHAR* ptr;
            ptr = szValue = szData;
            cbValue = 0;
            while (!(*ptr == ' ' || *ptr == '\t' || *ptr == '\r' || *ptr == '\n'))
            {
                ptr++;
                cbValue++;
            }
        }
        else
        {
            // The entire header is desired.
            szValue = szData;
            cbValue = cbData;
        }

    }
    else
    {
        // An item was passed in - attempt to parse this
        // from the headers and return the corresponding
        // value.
        if ((dwError = pRequest->FastQueryResponseHeader(dwQuery,
                  (LPVOID*) &szData,
                  &cbData,
                  dwIndex)) != ERROR_SUCCESS)
        {
            goto quit;
        }

        // Successfully retrieved header. Parse for the desired item.

        // Point past scheme
        while (!(*szData == ' ' || *szData == '\t' || *szData == '\r' || *szData == '\n'))
        {
            szData++;
            cbData--;
        }

        // Attempt to parse an item of the format 'key = <">value<">'
        // from a comma delmited list of items.
        dwError = ERROR_HTTP_HEADER_NOT_FOUND;
        while (GetDelimitedToken(&szData, &cbData, &szTok, &cbTok, ','))
        {
            if (GetKeyValuePair(szTok, cbTok, &szKey, &cbKey, &szValue, &cbValue))
            {
                if ((cbItem == cbKey) && !strnicmp(szKey, szItem, cbItem))
                {
                    TrimQuotes(&szValue, &cbValue);
                    dwError = ERROR_SUCCESS;
                    break;
                }
            }
        }

    }

    if (dwError == ERROR_SUCCESS)
    {
        // Allocate buffer containing data
        // or return reference.
        if (dwFlags & ALLOCATE_BUFFER)
        {
            *pszData = New CHAR[cbValue+1];
            if (!*pszData)
            {
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }
            memcpy(*pszData, szValue, cbValue);
            (*pszData)[cbValue] = '\0';
            *pcbData = cbValue;
        }
        else
        {
            *pszData = szValue;
            *pcbData = cbValue;
        }
    }

quit:

    if (dwError != ERROR_SUCCESS)
    {
        INET_ASSERT(dwIndex || dwError == ERROR_HTTP_HEADER_NOT_FOUND);
    }

    return dwError;
}


// ------------------------  Base class funcs---------------------------------




/*-----------------------------------------------------------------------------
FindHdrIdxFromScheme
-----------------------------------------------------------------------------*/
DWORD AUTHCTX::FindHdrIdxFromScheme(LPDWORD pdwIndex)
{
    LPSTR szHeader;
    DWORD cbScheme, cbHeader, dwQuery, dwError;

    dwQuery = _fIsProxy?
        HTTP_QUERY_PROXY_AUTHENTICATE : HTTP_QUERY_WWW_AUTHENTICATE;

    *pdwIndex = 0;

    while ((dwError = _pRequest->FastQueryResponseHeader(dwQuery,
            (LPVOID*) &szHeader,
            &cbHeader,
            *pdwIndex)) == ERROR_SUCCESS)
    {
        DWORD cb = 0;
        CHAR *ptr = szHeader;
        while (!(*ptr == ' ' || *ptr == '\t' || *ptr == '\r' || *ptr == '\n'))
        {
            ptr++;
            cb++;
        }

        if ((_pSPMData->cbScheme == cb)
            && (!strnicmp(_pSPMData->szScheme, szHeader, cb)))
        {
            break;
        }
        (*pdwIndex)++;
    }
    return dwError;
}

/*-----------------------------------------------------------------------------
    Get funcs.
-----------------------------------------------------------------------------*/
LPSTR AUTHCTX::GetScheme()
    { return _pSPMData->szScheme; }

DWORD AUTHCTX::GetSchemeType()
{
    if (_pSPMData->eScheme == WINHTTP_AUTH_SCHEME_NEGOTIATE)
    {
        if (_eSubScheme == WINHTTP_AUTH_SCHEME_NTLM || _eSubScheme == WINHTTP_AUTH_SCHEME_KERBEROS)
        {
            return _eSubScheme;
        }
    }
    return _pSPMData->eScheme;
}

DWORD AUTHCTX::GetRawSchemeType()
{
    return _pSPMData->eScheme;
}

DWORD AUTHCTX::GetFlags()
{
    if (_pSPMData->eScheme == WINHTTP_AUTH_SCHEME_NEGOTIATE)
    {
        if (_eSubScheme == WINHTTP_AUTH_SCHEME_NTLM || _eSubScheme == WINHTTP_AUTH_SCHEME_KERBEROS)
        {
            return _dwSubFlags;
        }
    }
    return _pSPMData->dwFlags;
}

AUTHCTX::SPMState AUTHCTX::GetState()
    { return _pSPMData->eState; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\auth\winctxt.h ===
#ifndef _WIN_SIC_CTXT_H_
#define _WIN_SIC_CTXT_H_

#define DEFAULT_SERVER_NAME_LEN		128

typedef struct _WINCONTEXT	{

    //
    //  Buffer for storing exchange blob returned by SSPI before 
    //  PreAuthenticateUser is called
    //
    char        *szOutBuffer;
    DWORD       cbOutBuffer;        // bytes associated with allocated szOutBuffer
	DWORD		dwOutBufferLength;

    char        *szInBuffer;
    DWORD       cbInBuffer;         // bytes associated with allocated szInBuffer
    PCHAR       pInBuffer;
	DWORD		dwInBufferLength;

	DWORD		dwCallId;

	DWORD		pkgId;

    CredHandle  Credential;     // SSPI credential handle for this connection
    PCredHandle pCredential;

	//
	// The SSPI Context Handle is stored here
	//
	CtxtHandle	SspContextHandle;
	PCtxtHandle	pSspContextHandle;  // before any ctxt is created, this is NULL

	LPSTR		lpszServerName;

	char		szServerName[DEFAULT_SERVER_NAME_LEN];

} WINCONTEXT, *PWINCONTEXT;

#endif  // _WIN_SIC_CTXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\common\buffer.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    buffer.cxx

Abstract:

    Contains code to impliment a double buffering class used in SSL/PCT (secure channel)
        transactions.


Author:

    Arthur L Bierer (arthurbi) 20-March-1996

Revision History:

    20-March-1996 arthurbi
        Created

--*/

#include <wininetp.h>


BOOL
DBLBUFFER::InitBuffer(
    BOOL fDblBufferMode
    )

/*++

Routine Description:

    Allocates, and initalizes internal buffers.

Arguments:

    fDblBufferMode  - TRUE if we are to maintain to buffers,
                      FALSE if we treat the output and input buffers the same

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE, not enough memory to allocate buffers.

Comments:


--*/

{
    DEBUG_ENTER((DBG_BUFFER,
                 Bool,
                 "DBLBUFFER::InitBuffer",
                 "%B",
                 fDblBufferMode
                 ));

    INET_ASSERT(_lpBuffer == NULL);
    INET_ASSERT(_dwInitDefaultBufferSize > 0 );

    _lpBuffer = (LPBYTE)ALLOCATE_FIXED_MEMORY(_dwInitDefaultBufferSize);

    DEBUG_PRINT(API,
                INFO,
                ("allocated %d byte buffer %#x\n",
                _dwInitDefaultBufferSize,
                _lpBuffer
                ));

    BOOL success = FALSE;

    if (_lpBuffer != NULL) {

        INET_ASSERT(_dwBufferOut == 0);
        INET_ASSERT(_dwBufferIn == 0);

        _fDblBufferMode = fDblBufferMode;

        _dwBufferLength = _dwInitDefaultBufferSize ;
        _lpBufferOut = _lpBuffer + _dwBufferLength;
        _lpBufferIn      = _lpBuffer + _dwBufferLength;

        success = TRUE;
    }

    DEBUG_LEAVE(success);

    return success;
}

DWORD
DBLBUFFER::GetInputBufferRemaining(
    VOID
    )

/*++

Routine Description:

    Determines the amount of free bytes availble for reading into the input buffer.
        Will attempt to push current data to the front of the buffer, to make the
        most room in the currently allocated buffer.

Arguments:

    none.

Return Value:

    DWORD
        Number of bytes free.

Comments:

        Assumed to only be called in DblBuffer mode.

--*/


{
    DEBUG_ENTER((DBG_INET,
                 Int,
                 "DBLBUFFER::GetInputBufferRemaining",
                 NULL
                 ));


    INET_ASSERT(_lpBuffer);
    INET_ASSERT(_dwBufferOut == 0 );
    INET_ASSERT(_fDblBufferMode );


    BOOL fIsInputBufferCompressed = (_lpBufferIn == _lpBuffer);

    if ( ! fIsInputBufferCompressed )
    {
        BOOL fIsSuccess;

        fIsSuccess = CompressInputBufferUsage( ) ;

        INET_ASSERT(fIsSuccess);
    }

    INET_ASSERT(_lpBufferIn == _lpBuffer );

    DEBUG_LEAVE((DWORD) (_lpEndOfBuffer - (_dwBufferIn + _lpBuffer) ));

    return (DWORD) (_lpEndOfBuffer - (_dwBufferIn + _lpBuffer) );
}

BOOL
DBLBUFFER::CopyIn(
    IN LPBYTE lpBuffer,
    IN DWORD dwBufferSize
    )
{

    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "DBLBUFFER::CopyIn",
                 "%x, %d",
                 lpBuffer,
                 dwBufferSize
                 ));


    INET_ASSERT(lpBuffer);
    INET_ASSERT(dwBufferSize > 0);

    LPBYTE pbPointer;
    DWORD  dwCurInputSize;

    //
    // Get the current input buffer size
    //

    dwCurInputSize = GetInputBufferSize();

    if ( ! ResizeBufferIfNeeded(dwBufferSize) )
    {
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }

    pbPointer = GetInputBufferPointer()+dwCurInputSize;
    SetInputBufferSize(dwBufferSize+dwCurInputSize);


    CopyMemory(
        pbPointer,             // dest
        lpBuffer,              // src
        dwBufferSize           // size
        );


    DEBUG_LEAVE(TRUE);

    return TRUE;

}

BOOL
DBLBUFFER::CopyOut(
    OUT LPBYTE     lpBuffer,
    IN OUT LPDWORD lpdwBufferRemaining,
    IN OUT LPDWORD lpdwBytesReceived,
    IN OUT LPDWORD lpdwBytesRead
    )

/*++

Routine Description:

    Fills passed in buffer with the contents of the output buffer.

Arguments:

    lpBuffer                    -       Buffer to fill with output buffer bytes

        lpdwBufferRemaining -   Number of bytes remaining in Buffer to fill.

        lpdwBytesReceived       -       Number of bytes currently in Buffer to fill.

        lpdwBytesRead           -       Current total of bytes copied into Buffer to fill.

Return Value:

    BOOL
    Success - TRUE

    Failure - FALSE

Comments:


--*/

{

    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "DBLBUFFER::CopyOut",
                 "%x, %u, %u, %u",
                 lpBuffer,
                 (lpdwBufferRemaining ? *lpdwBufferRemaining : 0),
                 (lpdwBytesReceived ? *lpdwBytesReceived : 0),
                 (lpdwBytesRead ? *lpdwBytesRead : 0)
                 ));


    INET_ASSERT(lpBuffer);
    INET_ASSERT(lpdwBufferRemaining);
    INET_ASSERT(lpdwBytesReceived);
    INET_ASSERT(lpdwBytesRead);

    //
    // Figure out the max number of bytes we can copy into our user's buffer
    //      We need to make sure it will fit into the user's buffer.
    //

    DWORD dwBytesToCopy = (*lpdwBufferRemaining  >= _dwBufferOut)
            ? _dwBufferOut : *lpdwBufferRemaining;


    DEBUG_PRINT(API,
                INFO,
                ("DBLBUFFER::CopyOut: Copying ( to: %x bytes-to-copy=%d )\n",
                (lpBuffer+*lpdwBytesReceived),
                dwBytesToCopy
                ));


    //
    // Transfer Data to User's buffer.
    //

    CopyMemory ((lpBuffer+*lpdwBytesReceived),
                            _lpBufferOut,
                            dwBytesToCopy);


    //
    // Update the number of bytes we copied to the user buffer
    //

    *lpdwBytesRead                  += dwBytesToCopy;
    *lpdwBytesReceived              += dwBytesToCopy;
    *lpdwBufferRemaining    -= dwBytesToCopy;

    //
    // Update Our Internal Vars
    //

    _dwBufferOut                    -= dwBytesToCopy;
    _lpBufferOut                    += dwBytesToCopy;

    UpdateVars();

    //
    // We always succeed for now !
    //

    DEBUG_LEAVE(TRUE);

    return TRUE;
}

BOOL
DBLBUFFER::CompressInputBufferUsage(
    VOID
    )
/*++

Routine Description:

        Moves the input buffer to the begining of the internal allocated buffer.
        This produces a larger block of internal free space.

Arguments:

        none.

Return Value:

    BOOL
    Success - TRUE

    Success     - FALSE, there was no need to compress the buffer.

Comments:

  Assumed to be called only if DblBufferMode is enabled.

--*/


{
    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "DBLBUFFER::CompressInputBufferUsage",
                 NULL
                 ));

    BOOL bResult = FALSE;

    //
    // Maximize use of buffer by moving input data to the front
    // of the buffer.
    //

    INET_ASSERT(_lpBuffer);
    INET_ASSERT(_dwBufferOut == 0);
    INET_ASSERT(_fDblBufferMode);

    if (_lpBufferIn > _lpBuffer) {

        DEBUG_PRINT(API,
                    INFO,
                    ("compressing input buffer %d (%#x) @ %#x => %#x\n",
                    _dwBufferIn,
                    _dwBufferIn,
                    _lpBufferIn,
                    _lpBuffer
                    ));

        MoveMemory(_lpBuffer,
                   _lpBufferIn,
                   _dwBufferIn
                   );

        //
        // Input Buffer now starts at the begining of the allocated buffer
        //

        _lpBufferIn = _lpBuffer;
        bResult = TRUE;
    }

    DEBUG_LEAVE(bResult);

    return bResult;
}



BOOL
DBLBUFFER::ConcatenateOutputBufferUsage(
    IN LPBYTE lpSecondOutputBuffer,
    IN DWORD  dwSecondOutputBufferSize
    )

/*++

Routine Description:

    Combines the current output buffer with the contents of a new buffer.
    (Note: intented for use in combining decrypted data which may be seperated by
    header or trailer data)

Arguments:

    lpSecondOutputBuffer        - New Buffer to combine with internal output buffer.

    dwSecondOutputBufferSize    - Size of New Buffer in bytes.


Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE

Comments:

    If the internal buffer is sized 0, the new buffer replaces the internal buffer.
    Its assumed that the New buffer is a former input buffer turned output by
    some external operation, such as a block decryption operation.
--*/

{


    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "DBLBUFFER::ConcatenateOutputBufferUsage",
                 "%x, %u",
                 lpSecondOutputBuffer,
                 dwSecondOutputBufferSize
                 ));


    //
    // Combinate Two buffers into one.
    //

    INET_ASSERT(_lpBuffer);
    INET_ASSERT(_fDblBufferMode );
    INET_ASSERT(lpSecondOutputBuffer);
    INET_ASSERT(dwSecondOutputBufferSize);

    INET_ASSERT(_lpBufferOut < _lpBufferIn );
    INET_ASSERT(lpSecondOutputBuffer >= _lpBuffer && lpSecondOutputBuffer <=_lpEndOfBuffer );



    if ( _dwBufferOut != 0 )
    {
        DEBUG_PRINT(API,
                    INFO,
                    ("DBLBUFFER::ConcatenateOutputBufferUsage: Combining new data with output buffer\n"
                    ));

        MoveMemory((_lpBufferOut+_dwBufferOut),
                   lpSecondOutputBuffer,
                   dwSecondOutputBufferSize);
        //
        // Output Buffer is now bigger ( sum of orginal + new buffer size )
        //

        _dwBufferOut += dwSecondOutputBufferSize;

    }
    else
    {
        //
        // No previous output buffer, new buffer becomes output buffer
        //

        INET_ASSERT(_lpBufferOut == _lpEndOfBuffer );

        _lpBufferOut = lpSecondOutputBuffer;
        _dwBufferOut = dwSecondOutputBufferSize;

    }

    DEBUG_LEAVE(TRUE);

    return TRUE;
}


BOOL
DBLBUFFER::ResizeBufferIfNeeded(
    IN DWORD dwAddlBufferNeeded
    )

/*++

Routine Description:

    ReSizes internal buffer space to extend size of the buffer by dwAddlBufferNeeded.
    If the additional bytes can be made availble by compressing currently stored
    into one place ( ie the start of the buffer ), the reallocation of the buffer
    will not be done.

Arguments:

    dwAddlBufferNeeded  - Number of additional bytes to resize

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE, the reallocation failed due to lack of memory.

Comments:

    Its assumed the caller will only use this function in dbl buffering mode.

 --*/

{

    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "DBLBUFFER::ResizeBufferIfNeeded",
                 "%u",
                 dwAddlBufferNeeded
                 ));

    INET_ASSERT(_lpBuffer);
    INET_ASSERT(_dwBufferOut == 0 );
    INET_ASSERT(_fDblBufferMode );

    DWORD dwInputBytesFree = GetInputBufferRemaining();

    INET_ASSERT(_lpBuffer == _lpBufferIn );

    //
    // #bytes needed > #bytes left free in Buffer.
    //

    if ( dwAddlBufferNeeded > dwInputBytesFree )
    {
        HLOCAL hBuffer;

        hBuffer = (HLOCAL) _lpBuffer;

        //
        // length increases by (bytes needed - current bytes free[in old buffer])
        //

        _dwBufferLength += (dwAddlBufferNeeded - dwInputBytesFree);

        DEBUG_PRINT(API,
                    INFO,
                    ("DBLBUFFER::ResizeBufferIfNeeded: Resizing Buffer to %d, addl=%d, free=%d\n",
                    _dwBufferLength,
                    dwAddlBufferNeeded,
                    dwInputBytesFree
                    ));

        INET_ASSERT(_dwBufferLength < DBLBUFFER_MAX_SIZE);

        //
        // Do Resize, and store result
        //

        _lpBuffer = (LPBYTE)ResizeBuffer(hBuffer, _dwBufferLength, FALSE);

        DEBUG_PRINT(BUFFER,
                    INFO,
                    ("resized %#x => %#x, %d bytes\n",
                    hBuffer,
                    _lpBuffer,
                    _dwBufferLength
                    ));

        if ( ! _lpBuffer )
        {
            DEBUG_PRINT(API,
                        ERROR,
                        ("DBLBUFFER::ResizeBufferIfNeeded: Failed while Resizing, Out of Mem?\n"
                        ));

            DEBUG_LEAVE(FALSE);

            return FALSE;  // failing due to NOT_ENOUGH_MEMORY
        }

        //
        // Update ReSized Buffer pointers
        //

        _lpBufferIn = _lpBuffer;

        UpdateVars();
    }

    DEBUG_LEAVE(TRUE);

    return TRUE;
}

BOOL
DBLBUFFER::SetOutputInputBuffer(
    IN LPBYTE lpNewOutputBuffer,
    IN DWORD  dwNewOutputBufferSize,
    IN LPBYTE lpNewInputBuffer,
    IN DWORD  dwNewInputBufferSize,
    IN BOOL   fConcatenatePreviousOutput
    )

/*++

Routine Description:

    Allows caller to specify new addresses for input and output buffer.
    If fConcatenatePreviousOutput is set, SetOutputInputBuffer will combine
    the passed in output buffer with any internal output buffer.
    Also allows size changes to buffers.

Arguments:

    lpNewOutputBuffer           - New Output Buffer.

    dwNewOutputBufferSize       - Size of New Output Buffer.

    lpNewInputBuffer            - New Input Buffer.

    dwNewInputBufferSize        - New Input Buffer Size.

    fConcatenatePreviousOutput  - TRUE if we are to combine internal output buffer
                                  with (passed in) new output buffer
                                  FALSE if we are to just replace output buffer pointers.

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE

Comments:

    Assumed to be called from double buffering mode.

--*/


{

    INET_ASSERT(_lpBuffer);
    INET_ASSERT(lpNewOutputBuffer >= _lpBuffer && lpNewOutputBuffer <= _lpEndOfBuffer );
    INET_ASSERT((lpNewInputBuffer >= _lpBuffer && lpNewInputBuffer <= _lpEndOfBuffer) || dwNewInputBufferSize == 0);
    INET_ASSERT(fConcatenatePreviousOutput || _dwBufferOut == 0 );
    INET_ASSERT(_fDblBufferMode );

    DEBUG_PRINT(API,
         INFO,
         ("DBLBUFFER::SetOutputInputBuffer: Getting New Output( %x, size=%d ) New Input( %x, size=%d)\n",
         lpNewOutputBuffer,
         dwNewOutputBufferSize,
         lpNewInputBuffer,
         dwNewInputBufferSize
         ));


    if ( fConcatenatePreviousOutput )
    {
        ConcatenateOutputBufferUsage(
                    lpNewOutputBuffer,
                    dwNewOutputBufferSize
                    );
    }
    else
    {
        _lpBufferOut = lpNewOutputBuffer;
        _dwBufferOut = dwNewOutputBufferSize;
    }


    _lpBufferIn = lpNewInputBuffer;
    _dwBufferIn = dwNewInputBufferSize;

    UpdateVars();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\common\caddrlst.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    caddrlst.cxx

Abstract:

    Contains CAddressList class definition

    Contents:
        CAddressList::FreeList
        CAddressList::SetList
        CAddressList::SetList
        CAddressList::GetNextAddress
        CAddressList::InvalidateAddress
        CAddressList::ResolveHost
        CFsm_ResolveHost::RunSM
        (CAddressList::IPAddressToAddressList)
        (CAddressList::HostentToAddressList)

Author:

    Richard L Firth (rfirth) 19-Apr-1997

Environment:

    Win32 user-mode DLL

Revision History:

    19-Apr-1997 rfirth
        Created

    28-Jan-1998 rfirth
        No longer randomly index address list. NT5 and Win98 are modified to
        return the address list in decreasing order of desirability by RTT/
        route

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

//#define TEST_CODE

//Thread-procedure for async gethostbyname
DWORD WINAPI AsyncGetHostByName(LPVOID lpParameter);

//The destructor is called only when all refcounts have dropped to 0.
// i.e. when the INTERNET_HANDLE_OBJECT has released its reference, 
//      AND when all the GHBN threads are done.
//  At this point, we can flush the hostent cache and terminate list.
CResolverCache::~CResolverCache()
{
    FlushHostentCache(&_ResolverCache);
    TerminateSerializedList(&_ResolverCache);

    if (_pHandlesList)
        delete _pHandlesList;
}

void CResolverCache::ForceEmptyAndDeleteHandlesList()
{
    INET_ASSERT(_pHandlesList);
        
    _pHandlesList->LockList();

    CListItem* pItem = _pHandlesList->GetHead();

    while(pItem)
    {
        CListItem* pNext = pItem->GetNext();

        (((CGetHostItem*)pItem)->ForceDelete());
        delete pItem;
        _pHandlesList->ReduceCount();

        pItem = pNext;
    }

    //it's not going to be reused after this, so head and tail don't have to be set to NULL
    // on _pHandlesList
    _pHandlesList->UnlockList();
}

void CResolverCache::EmptyHandlesList()
{
    if (_pHandlesList)
    {
        _pHandlesList->LockList();

        CListItem* pItem = _pHandlesList->GetHead();

        while(pItem)
        {
            CListItem* pNext = pItem->GetNext();

            (((CGetHostItem*)pItem)->WaitDelete());
            delete pItem;
            _pHandlesList->ReduceCount();

            pItem = pNext;
        }

        //it's not going to be reused after this, so head and tail don't have to be set to NULL
        // on _pHandlesList
        _pHandlesList->UnlockList();
    }
}

void CResolverCache::TrimHandlesListSize(ULONG nTrimSize)
{        
    _pHandlesList->LockList();

    if (_pHandlesList->GetCount() >= nTrimSize)
    {
        CListItem* pItem = _pHandlesList->GetHead();
        CListItem* pPrev = NULL;

        while(pItem)
        {
            CListItem* pNext = pItem->GetNext();
            
            if (((CGetHostItem*)pItem)->CanBeDeleted())
            {
                if (pPrev)
                {
                	pPrev->SetNext(pNext);
                }
                else
                {
                    //The item being removed WAS the head.
                	_pHandlesList->SetHead(pNext);
                }

                if (!pNext)
                {
                    //The item being removed WAS the tail.
                    _pHandlesList->SetTail(pPrev);
                }
	
                delete pItem;
                _pHandlesList->ReduceCount();
            }
            else
            {  
                pPrev = pItem;
            }
            
            pItem = pNext;
        }
    }

    _pHandlesList->UnlockList();
}

BOOL CResolverCache::AddToHandlesList(HANDLE hThread, CGetHostItem* pGetHostItem)
{
    BOOL bRetval = TRUE;

    INET_ASSERT(_pHandlesList);
    pGetHostItem->SetThreadHandle(hThread);
    
    TrimHandlesListSize();
    _pHandlesList->AddToTail(pGetHostItem);

    return bRetval;    
}

DWORD WINAPI AsyncGetHostByName(LPVOID lpParameter)
{
#ifdef WINHTTP_FOR_MSXML
    //
    // MSXML needs to initialize is thread local storage data.
    // It does not do this during DLL_THREAD_ATTACH, so our
    // worker thread must explicitly call into MSXML to initialize
    // its TLS for this thread.
    //
    InitializeMsxmlTLS();
#endif

    CGetHostItem* pGetHostItem = (CGetHostItem*)lpParameter;
    LPSTR lpszHostName = pGetHostItem->GetHostName();
    LPHOSTENT lpHostEnt;
    DWORD dwError = 0;

    if (!(lpHostEnt = _I_gethostbyname(lpszHostName)))
    {
        dwError = _I_WSAGetLastError();
    }
    else
    {
        VOID* pAlloc = pGetHostItem->GetAllocPointer();
        CacheHostent((pGetHostItem->GetResolverCache())->GetResolverCacheList(), lpszHostName, lpHostEnt, LIVE_DEFAULT, &pAlloc, pGetHostItem->GetAllocSize());
        if (pAlloc)
        {
            //pAlloc is overwritten to NULL in CacheHostent if the memory is used,
            //we need to delete the alloced memory only if non-NULL
            pGetHostItem->SetDelete();
        }
    }

    return dwError;
}

//
// methods
//

VOID
CAddressList::FreeList(
    VOID
    )

/*++

Routine Description:

    Free address list

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (m_Addresses != NULL) {
        m_Addresses = (LPRESOLVED_ADDRESS)FREE_MEMORY((HLOCAL)m_Addresses);

        INET_ASSERT(m_Addresses == NULL);

        m_AddressCount = 0;
        m_BadAddressCount = 0;
        m_CurrentAddress = 0;
    }
}


DWORD
CAddressList::SetList(
    IN DWORD dwIpAddress
    )

/*++

Routine Description:

    Sets the list contents from the IP address

Arguments:

    dwIpAddress - IP address from which to create list contents

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    if (!Acquire())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    FreeList();

    DWORD error = IPAddressToAddressList(dwIpAddress);

    Release();

    return error;
}


DWORD
CAddressList::SetList(
    IN LPHOSTENT lpHostent
    )

/*++

Routine Description:

    Sets the list contents from the hostent

Arguments:

    lpHostent   - pointer to hostent containing resolved addresses to add

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    if (!Acquire())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    FreeList();

    DWORD error = HostentToAddressList(lpHostent);

    Release();

    return error;
}


BOOL
CAddressList::GetNextAddress(
    OUT LPDWORD lpdwResolutionId,
    IN OUT LPDWORD lpdwIndex,
    IN INTERNET_PORT nPort,
    OUT LPCSADDR_INFO lpAddressInfo
    )

/*++

Routine Description:

    Get next address to use when connecting. If we already have a preferred
    address, use that. We make a copy of the address to use in the caller's
    data space

Arguments:

    lpdwResolutionId    - used to determine whether the address list has been
                          resolved between calls

    lpdwIndex           - IN: current index tried; -1 if we want to try default
                          OUT: index of address address returned if successful

    nPort               - which port we want to connect to

    lpAddressInfo       - pointer to returned address if successful

Return Value:

    BOOL
        TRUE    - lpResolvedAddress contains resolved address to use

        FALSE   - need to (re-)resolve name

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CAddressList::GetNextAddress",
                 "%#x [%d], %#x [%d], %d, %#x",
                 lpdwResolutionId,
                 *lpdwResolutionId,
                 lpdwIndex,
                 *lpdwIndex,
                 nPort,
                 lpAddressInfo
                 ));

    PERF_ENTER(GetNextAddress);

    BOOL bOk = TRUE;

    //
    // if we tried all the addresses and failed already, re-resolve the name
    //

    if (!Acquire())
    {
        bOk = FALSE;
        goto quit;
    }

    if (m_BadAddressCount < m_AddressCount) {
        if (*lpdwIndex != (DWORD)-1) {

            INET_ASSERT(m_BadAddressCount < m_AddressCount);

            INT i = 0;

            m_CurrentAddress = *lpdwIndex;

            INET_ASSERT((m_CurrentAddress >= 0)
                        && (m_CurrentAddress < m_AddressCount));

            if ((m_CurrentAddress < 0) || (m_CurrentAddress >= m_AddressCount)) {
                m_CurrentAddress = 0;
            }
            do {
                NextAddress();
                if (++i == m_AddressCount) {
                    bOk = FALSE;
                    break;
                }
            } while (!IsCurrentAddressValid());
        }

        //
        // check to make sure this address hasn't expired
        //

        //if (!CheckHostentCacheTtl()) {
        //    bOk = FALSE;
        //}
    } else {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("exhausted %d addresses\n",
                    m_BadAddressCount
                    ));

        bOk = FALSE;
    }
    if (bOk) {

        DWORD dwLocalLength = LocalSockaddrLength();
        LPBYTE lpRemoteAddr = (LPBYTE)(lpAddressInfo + 1) + dwLocalLength;

        memcpy(lpAddressInfo + 1, LocalSockaddr(), dwLocalLength);
        memcpy(lpRemoteAddr, RemoteSockaddr(), RemoteSockaddrLength());
        lpAddressInfo->LocalAddr.lpSockaddr = (LPSOCKADDR)(lpAddressInfo + 1);
        lpAddressInfo->LocalAddr.iSockaddrLength = dwLocalLength;
        lpAddressInfo->RemoteAddr.lpSockaddr = (LPSOCKADDR)lpRemoteAddr;
        lpAddressInfo->RemoteAddr.iSockaddrLength = RemoteSockaddrLength();
        lpAddressInfo->iSocketType = SocketType();
        lpAddressInfo->iProtocol = Protocol();
        ((LPSOCKADDR_IN)lpAddressInfo->RemoteAddr.lpSockaddr)->sin_port =
            _I_htons((unsigned short)nPort);
        *lpdwIndex = m_CurrentAddress;

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("current address = %d.%d.%d.%d\n",
                    ((LPBYTE)RemoteSockaddr())[4] & 0xff,
                    ((LPBYTE)RemoteSockaddr())[5] & 0xff,
                    ((LPBYTE)RemoteSockaddr())[6] & 0xff,
                    ((LPBYTE)RemoteSockaddr())[7] & 0xff
                    ));

//dprintf("returning address %d.%d.%d.%d, index %d:%d\n",
//        ((LPBYTE)RemoteSockaddr())[4] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[5] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[6] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[7] & 0xff,
//        m_ResolutionId,
//        m_CurrentAddress
//        );
    }
    *lpdwResolutionId = m_ResolutionId;

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("ResolutionId = %d, Index = %d\n",
                m_ResolutionId,
                m_CurrentAddress
                ));

    Release();

quit:
    PERF_LEAVE(GetNextAddress);

    DEBUG_LEAVE(bOk);

    return bOk;
}
	

VOID
CAddressList::InvalidateAddress(
    IN DWORD dwResolutionId,
    IN DWORD dwAddressIndex
    )

/*++

Routine Description:

    We failed to create a connection. Invalidate the address so other requests
    will try another address

Arguments:

    dwResolutionId  - used to ensure coherency of address list

    dwAddressIndex  - which address to invalidate

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "CAddressList::InvalidateAddress",
                 "%d, %d",
                 dwResolutionId,
                 dwAddressIndex
                 ));
//dprintf("invalidating %d.%d.%d.%d, index %d:%d\n",
//        ((LPBYTE)RemoteSockaddr())[4] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[5] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[6] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[7] & 0xff,
//        dwResolutionId,
//        dwAddressIndex
//        );
    if (!Acquire())
        goto quit;  // just take the hit of trying again, if we can.

    //
    // only do this if the list is the same age as when the caller last tried
    // an address
    //

    if (dwResolutionId == m_ResolutionId) {

        INET_ASSERT(((INT)dwAddressIndex >= 0)
                    && ((INT)dwAddressIndex < m_AddressCount));

        if (dwAddressIndex < (DWORD)m_AddressCount) {
            m_Addresses[dwAddressIndex].IsValid = FALSE;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("invalidated address %d.%d.%d.%d\n",
                        ((LPBYTE)RemoteSockaddr())[4] & 0xff,
                        ((LPBYTE)RemoteSockaddr())[5] & 0xff,
                        ((LPBYTE)RemoteSockaddr())[6] & 0xff,
                        ((LPBYTE)RemoteSockaddr())[7] & 0xff
                        ));

            INET_ASSERT(m_BadAddressCount <= m_AddressCount);

            if (m_BadAddressCount < m_AddressCount) {
                ++m_BadAddressCount;
                if (m_BadAddressCount < m_AddressCount) {
                    for (int i = 0;
                         !IsCurrentAddressValid() && (i < m_AddressCount);
                         ++i) {
                        NextAddress();
                    }
                }
            }
        }
    }
    Release();

quit:

    DEBUG_LEAVE(0);
}


DWORD
CAddressList::ResolveHost(
    IN LPSTR lpszHostName,
    IN OUT LPDWORD lpdwResolutionId,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Resolves host name (or (IP-)address)

    BUGBUG: Ideally, we don't want to keep hold of worker threads if we are in
            the blocking gethostbyname() call. But correctly handling this is
            difficult, so we always block the thread while we are resolving.
            For this reason, an async request being run on an app thread should
            have switched to a worker thread before calling this function.

Arguments:

    lpszHostName        - host name (or IP-address) to resolve

    lpdwResolutionId    - used to determine whether entry changed

    dwFlags             - controlling request:

                            SF_INDICATE - if set, make indications via callback

                            SF_FORCE    - if set, force (re-)resolve

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    Name successfully resolved

        Failure - ERROR_WINHTTP_NAME_NOT_RESOLVED
                    Couldn't resolve the name

                  ERROR_NOT_ENOUGH_MEMORY
                    Couldn't allocate memory for the FSM
--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CAddressList::ResolveHost",
                 "%q, %d, %#x",
                 lpszHostName,
                 *lpdwResolutionId,
                 dwFlags
                 ));

    DWORD error;

    error = DoFsm(New CFsm_ResolveHost(lpszHostName,
                                       lpdwResolutionId,
                                       dwFlags,
                                       this
                                       ));

//quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_ResolveHost::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_SESSION,
                 Dword,
                 "CFsm_ResolveHost::RunSM",
                 "%#x",
                 Fsm
                 ));

    CAddressList * pAddressList = (CAddressList *)Fsm->GetContext();
    CFsm_ResolveHost * stateMachine = (CFsm_ResolveHost *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pAddressList->ResolveHost_Fsm(stateMachine);
        break;

    case FSM_STATE_ERROR:
        error = Fsm->GetError();
        Fsm->SetDone();
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CAddressList::ResolveHost_Fsm(
    IN CFsm_ResolveHost * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CAddressList::ResolveHost_Fsm",
                 "%#x(%q, %#x [%d], %#x)",
                 Fsm,
                 Fsm->m_lpszHostName,
                 Fsm->m_lpdwResolutionId,
                 *Fsm->m_lpdwResolutionId,
                 Fsm->m_dwFlags
                 ));

    PERF_ENTER(ResolveHost);

    //
    // restore variables from FSM object
    //

    CFsm_ResolveHost & fsm = *Fsm;
    LPSTR lpszHostName = fsm.m_lpszHostName;
    LPDWORD lpdwResolutionId = fsm.m_lpdwResolutionId;
    DWORD dwFlags = fsm.m_dwFlags;
    LPINTERNET_THREAD_INFO lpThreadInfo = fsm.GetThreadInfo();
    INTERNET_HANDLE_BASE * pHandle = fsm.GetMappedHandleObject();
    DWORD error = ERROR_SUCCESS;
    CResolverCache* pResolverCache = GetRootHandle(pHandle)->GetResolverCache();
    DWORD dwWaitTime;
    LPHOSTENT lpHostent = NULL;
    DWORD ttl;

    
    //
    // BUGBUG - RLF 04/23/97
    //
    // This is sub-optimal. We want to block worker FSMs and free up the worker
    // thread. Sync client threads can wait. However, since a clash is not very
    // likely, we'll block all threads for now and come up with a better
    // solution later (XTLock).
    //
    // Don't have time to implement the proper solution now
    //

    if (!Acquire())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    //
    // if the resolution id is different then the name has already been resolved
    //

    if (*lpdwResolutionId != m_ResolutionId) 
    {
        goto done;
    }

    //
    // if we're an app thread making an async request then go async now rather
    // than risk blocking the app thread. This will be the typical scenario for
    // IE, and we care about little else
    //
    // BUGBUG - RLF 05/20/97
    //
    // We should really lock & test the cache first, but let's do that after
    // Beta2 (its perf work)
    //

    // It cannot happen that this condition be true.
    // WinHttpSendRequest would have queued an async fsm if it was async to begin with.
    INET_ASSERT(lpThreadInfo->IsAsyncWorkerThread
                || !pHandle->IsAsyncHandle());
/*
    if (!lpThreadInfo->IsAsyncWorkerThread
        && pHandle->IsAsyncHandle()
        && (fsm.GetAppContext() != NULL)) 
    {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("async request on app thread - jumping to hyper-drive\n"
                    ));

        error = Fsm->QueueWorkItem();
        goto done;
    }
 */
    //
    // throw out current list (if any)
    //

    FreeList();

    //
    // let the app know we are resolving the name
    //

    if (dwFlags & SF_INDICATE) 
    {
        error = InternetIndicateStatusString(WINHTTP_CALLBACK_STATUS_RESOLVING_NAME,
                                        lpszHostName,
                                        TRUE/*bCopyBuffer*/
                                        );
                                        
        //bail out if aborted before network operation.
        if (error != ERROR_SUCCESS)
        {
            INET_ASSERT(error == ERROR_WINHTTP_OPERATION_CANCELLED);
            goto done;
        }
    }

    //
    // figure out if we're being asked to resolve a name or an address. If
    // inet_addr() succeeds then we were given a string representation of an
    // address
    //

    DWORD ipAddr;
//dprintf("resolving %q\n", lpszHostName);
    ipAddr = _I_inet_addr(lpszHostName);
    if (ipAddr != INADDR_NONE) 
    {

        //
        // IP address was passed in. Simply convert to address list and quit
        //

        error = SetList(ipAddr);
        goto quit;
    }

    //
    // 255.255.255.255 (or 65535.65535 or 16777215.255) would never work anyway
    //

    INET_ASSERT(lstrcmp(lpszHostName, "255.255.255.255"));

    //
    // now try to find the name or address in the cache. If it's not in the
    // cache then resolve it
    //

    if (!(dwFlags & SF_FORCE)
    && QueryHostentCache(pResolverCache->GetResolverCacheList(), lpszHostName, NULL, &lpHostent, &ttl)) 
    {
        error = SetList(lpHostent);
        ReleaseHostentCacheEntry(pResolverCache->GetResolverCacheList(), lpHostent);
        ++m_ResolutionId;
        goto quit;
    }
    
    //
    // if we call winsock gethostbyname() then we don't get to find out the
    // time-to-live as returned by DNS, so we have to use the default value
    // (LIVE_DEFAULT)
    //
    
    dwWaitTime = GetTimeoutValue(WINHTTP_OPTION_RESOLVE_TIMEOUT);

    // if a resolve timeout is specified by the application, then honor it.
    // If anything fails in the async pathway, DON'T default to sync GHBN.
    if (dwWaitTime != INFINITE)
    {
        DWORD dwThreadId;
        LPSTR lpszCopyHostName = NewString(lpszHostName);
        
        if (lpszCopyHostName)
        {
#define SZ_AVG_RESOLVER_ENTRY_BYTES 512
            VOID* pAlloc = ALLOCATE_MEMORY(LMEM_FIXED, SZ_AVG_RESOLVER_ENTRY_BYTES);
            CGetHostItem* pGetHostItem = New CGetHostItem(lpszCopyHostName, pResolverCache, pAlloc, pAlloc?SZ_AVG_RESOLVER_ENTRY_BYTES:0);

            if (!pGetHostItem)
            {
                FREE_FIXED_MEMORY(lpszCopyHostName);
                goto failed;
            }
            
            HANDLE hThread = 0;

            WRAP_REVERT_USER(CreateThread, (NULL, 0, &AsyncGetHostByName,
            					pGetHostItem, 0, &dwThreadId), hThread);

            // HANDLE hThread = CreateThread(NULL, 0, &AsyncGetHostByName,
            //					pGetHostItem, 0, &dwThreadId);

            if (!hThread)
            {
                delete pGetHostItem;
                goto failed;
            }
            
            DWORD dwWaitResponse = WaitForSingleObject(hThread, dwWaitTime);

            if (dwWaitResponse == WAIT_OBJECT_0)
            {
                DWORD dwError;
                BOOL fRet = GetExitCodeThread(hThread, &dwError); //want to use this error?

                INET_ASSERT(dwError != STILL_ACTIVE);

                if (fRet && !dwError && QueryHostentCache(pResolverCache->GetResolverCacheList(), lpszCopyHostName, NULL, &lpHostent, &ttl))
                {
                    error = SetList(lpHostent);
                    ReleaseHostentCacheEntry(pResolverCache->GetResolverCacheList(), lpHostent);
                    ++m_ResolutionId;
                }

                CloseHandle(hThread);
                delete pGetHostItem;

                DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("%q %sresolved\n",
                    lpszHostName,
                    lpHostent ? "" : "NOT "
                    ));					
            }				
            else //(dwWaitResponse == WAIT_TIMEOUT)
            {
            	//let thread die and if it successfully resolved host, it can add to cache.
                pResolverCache->AddToHandlesList(hThread, pGetHostItem);
            }
        } //lpszCopyHostName
    }// dwWaitTime (specified on this handle)
    else
    {
        //synchronous get host by name
        
        lpHostent = _I_gethostbyname(lpszHostName);

        DEBUG_PRINT(SOCKETS,
            INFO,
            ("%q %sresolved\n",
            lpszHostName,
            lpHostent ? "" : "NOT "
            ));

        if (lpHostent != NULL) 
        {
            CacheHostent(pResolverCache->GetResolverCacheList(), lpszHostName, lpHostent, LIVE_DEFAULT);
            error = SetList(lpHostent);
            ++m_ResolutionId;
        }
    }
    
failed:

    if (!lpHostent)
    {
        error = ERROR_WINHTTP_NAME_NOT_RESOLVED;
    }

quit:

    if ((error == ERROR_SUCCESS) && (dwFlags & SF_INDICATE)) {

        //
        // inform the app that we have resolved the name
        //

        InternetIndicateStatusAddress(WINHTTP_CALLBACK_STATUS_NAME_RESOLVED,
                                      RemoteSockaddr(),
                                      RemoteSockaddrLength()
                                      );
    }
    *lpdwResolutionId = m_ResolutionId;

done:

    Release();

exit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
        //PERF_LEAVE(ResolveHost);
    }

    PERF_LEAVE(ResolveHost);

    DEBUG_LEAVE(error);

    return error;
}

//
// private methods
//


PRIVATE
DWORD
CAddressList::IPAddressToAddressList(
    IN DWORD ipAddr
    )

/*++

Routine Description:

    Converts an IP-address to a RESOLVED_ADDRESS

Arguments:

    ipAddr  - IP address to convert

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    LPRESOLVED_ADDRESS address = (LPRESOLVED_ADDRESS)ALLOCATE_MEMORY(
                                                        LMEM_FIXED,
                                                        sizeof(RESOLVED_ADDRESS)

                                                        //
                                                        // 1 local and 1 remote
                                                        // socket address
                                                        //

                                                        + 2 * sizeof(SOCKADDR)
                                                        );
    if (address == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LPBYTE lpVariable;
    LPSOCKADDR_IN lpSin;

    lpVariable = (LPBYTE)address + (sizeof(RESOLVED_ADDRESS));

    //
    // for each IP address in the hostent, build a CSADDR_INFO structure:
    // create a local SOCKADDR containing only the address family (AF_INET),
    // everything else is zeroed; create a remote SOCKADDR containing the
    // address family (AF_INET), zero port value and the IP address
    // presented in the arguments
    //

    address->AddrInfo.LocalAddr.lpSockaddr = (LPSOCKADDR)lpVariable;
    address->AddrInfo.LocalAddr.iSockaddrLength = sizeof(SOCKADDR);
    lpSin = (LPSOCKADDR_IN)lpVariable;
    lpVariable += sizeof(*lpSin);
    lpSin->sin_family = AF_INET;
    lpSin->sin_port = 0;
    *(LPDWORD)&lpSin->sin_addr = INADDR_ANY;
    memset(lpSin->sin_zero, 0, sizeof(lpSin->sin_zero));

    address->AddrInfo.RemoteAddr.lpSockaddr = (LPSOCKADDR)lpVariable;
    address->AddrInfo.RemoteAddr.iSockaddrLength = sizeof(SOCKADDR);
    lpSin = (LPSOCKADDR_IN)lpVariable;
    lpVariable += sizeof(*lpSin);
    lpSin->sin_family = AF_INET;
    lpSin->sin_port = 0;
    *(LPDWORD)&lpSin->sin_addr = ipAddr;
    memset(lpSin->sin_zero, 0, sizeof(lpSin->sin_zero));

    address->AddrInfo.iSocketType = SOCK_STREAM;
    address->AddrInfo.iProtocol = IPPROTO_TCP;
    address->IsValid = TRUE;

    //
    // update the object
    //

    INET_ASSERT(m_AddressCount == 0);
    INET_ASSERT(m_Addresses == NULL);

    m_AddressCount = 1;
    m_BadAddressCount = 0;
    m_Addresses = address;
    m_CurrentAddress = 0;   // only one to choose from
    return ERROR_SUCCESS;
}


PRIVATE
DWORD
CAddressList::HostentToAddressList(
    IN LPHOSTENT lpHostent
    )

/*++

Routine Description:

    Converts a HOSTENT structure to an array of RESOLVED_ADDRESSs

Arguments:

    lpHostent   - pointer to HOSTENT to convert

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    INET_ASSERT(lpHostent != NULL);

    LPBYTE * addressList = (LPBYTE *)lpHostent->h_addr_list;

    INET_ASSERT(addressList[0]);

    //
    // first off, figure out how many addresses there are in the hostent
    //

    int nAddrs;

    if (fDontUseDNSLoadBalancing) {
        nAddrs = 1;
    } else {
        for (nAddrs = 0; addressList[nAddrs] != NULL; ++nAddrs) {
            /* NOTHING */
        }
#ifdef TEST_CODE
        nAddrs = 4;
#endif
    }

    LPRESOLVED_ADDRESS addresses = (LPRESOLVED_ADDRESS)ALLOCATE_MEMORY(
                                                LMEM_FIXED,
                                                nAddrs * (sizeof(RESOLVED_ADDRESS)

                                                //
                                                // need 1 local and 1 remote socket
                                                // address for each
                                                //

                                                + 2 * sizeof(SOCKADDR))
                                                );
    if (addresses == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // for each IP address in the hostent, build a RESOLVED_ADDRESS structure:
    // create a local SOCKADDR containing only the address family (AF_INET),
    // everything else is zeroed; create a remote SOCKADDR containing the
    // address family (AF_INET), zero port value, and the IP address from
    // the hostent presented in the arguments
    //

    LPBYTE lpVariable = (LPBYTE)addresses + (nAddrs * sizeof(RESOLVED_ADDRESS));
    LPSOCKADDR_IN lpSin;

    for (int i = 0; i < nAddrs; ++i) {

        addresses[i].AddrInfo.LocalAddr.lpSockaddr = (LPSOCKADDR)lpVariable;
        addresses[i].AddrInfo.LocalAddr.iSockaddrLength = sizeof(SOCKADDR);
        lpSin = (LPSOCKADDR_IN)lpVariable;
        lpVariable += sizeof(*lpSin);
        lpSin->sin_family = AF_INET;
        lpSin->sin_port = 0;
        *(LPDWORD)&lpSin->sin_addr = INADDR_ANY;
        memset(lpSin->sin_zero, 0, sizeof(lpSin->sin_zero));
        addresses[i].AddrInfo.RemoteAddr.lpSockaddr = (LPSOCKADDR)lpVariable;
        addresses[i].AddrInfo.RemoteAddr.iSockaddrLength = sizeof(SOCKADDR);
        lpSin = (LPSOCKADDR_IN)lpVariable;
        lpVariable += sizeof(*lpSin);
        lpSin->sin_family = AF_INET;
        lpSin->sin_port = 0;
#ifdef TEST_CODE
        //if (i) {
            *(LPDWORD)&lpSin->sin_addr = 0x04030201;
            //*(LPDWORD)&lpSin->sin_addr = 0x1cfe379d;
        //}
#else
        *(LPDWORD)&lpSin->sin_addr = *(LPDWORD)addressList[i];
#endif
        memset(lpSin->sin_zero, 0, sizeof(lpSin->sin_zero));

        addresses[i].AddrInfo.iSocketType = SOCK_STREAM;
        addresses[i].AddrInfo.iProtocol = IPPROTO_TCP;
        addresses[i].IsValid = TRUE;
    }
#ifdef TEST_CODE
    *((LPDWORD)&((LPSOCKADDR_IN)addresses[3].AddrInfo.RemoteAddr.lpSockaddr)->sin_addr) = *(LPDWORD)addressList[0];
    //((LPSOCKADDR_IN)addresses[7].AddrInfo.RemoteAddr.lpSockaddr)->sin_addr = ((LPSOCKADDR_IN)addresses[0].AddrInfo.RemoteAddr.lpSockaddr)->sin_addr;
    //*((LPDWORD)&((LPSOCKADDR_IN)addresses[0].AddrInfo.RemoteAddr.lpSockaddr)->sin_addr) = 0x04030201;
#endif

    //
    // update the object
    //

    INET_ASSERT(m_AddressCount == 0);
    INET_ASSERT(m_Addresses == NULL);

    m_AddressCount = nAddrs;
    m_BadAddressCount = 0;
    m_Addresses = addresses;
    m_CurrentAddress = 0;
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\common\icasync.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    icasync.cxx

Abstract:

    Contains async socket (select) thread and support functions. Work items now
    processed by SHLWAPI/KERNEL32 thread pool

    Contents:
        InitializeAsyncSupport
        TerminateAsyncSupport
        QueueSocketWorkItem
        BlockWorkItem
        UnblockWorkItems
        CheckForBlockedWorkItems
        ICAsyncThread::~ICAsyncThread
        ICAsyncThread::QueueSocketWorkItem
        ICAsyncThread::BlockWorkItem
        ICAsyncThread::UnblockWorkItems
        ICAsyncThread::CheckForBlockedWorkItems
        ICAsyncThread::SelectThreadWrapper
        ICAsyncThread::SelectThread
        (ICAsyncThread::CreateSelectSocket)
        (ICAsyncThread::DestroySelectSocket)
        (ICAsyncThread::RecreateSelectSocket)
        (ICAsyncThread::InterruptSelect)
        (ICAsyncThread::DrainSelectSocket)

Author:

    Richard L Firth (rfirth) 04-Mar-1998

Environment:

    Win32 user-mode

Revision History:

    04-Mar-1998 rfirth
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

DWORD CAsyncCount::AddRef()
{
    DWORD error = ERROR_SUCCESS;
    
    if (!GeneralInitCritSec.Lock())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    ++dwRef;

    GeneralInitCritSec.Unlock();
quit:
    return error;       
}

VOID CAsyncCount::Release()
{
    BOOL bUnlock = GeneralInitCritSec.Lock();

    //Decrement the refcount always, but only Terminate if we obtained the critsec.
    if (!--dwRef && bUnlock)
    {
        //BUGBUG-enable later.
        TerminateAsyncSupport(TRUE);
    }

    if (bUnlock)
    {
        GeneralInitCritSec.Unlock();
    }
}
    
//
// private classes
//


class ICAsyncThread {

private:

    CPriorityList m_BlockedQueue;
    SOCKET m_SelectSocket;
    LONG m_lSelectInterrupts;
    BOOL m_bTerminating;
    DWORD m_dwError;
    HANDLE m_hThread;
    BOOL m_bCleanUp;

public:

    ICAsyncThread() {

        DEBUG_ENTER((DBG_ASYNC,
                     None,
                     "ICAsyncThread::ICAsyncThread",
                     NULL
                     ));

        m_SelectSocket = INVALID_SOCKET;
        m_lSelectInterrupts = -1;
        m_bTerminating = FALSE;
        m_dwError = ERROR_SUCCESS;

        DWORD dwThreadId;

        m_hThread = CreateThread(
                    NULL,
                    0,
                    (LPTHREAD_START_ROUTINE)ICAsyncThread::SelectThreadWrapper,
                    (LPVOID)this,
                    0,
                    &dwThreadId
                    );
        if (m_hThread == NULL) {
            SetError();
        }

        m_bCleanUp = FALSE;
        
        DEBUG_LEAVE(0);
    }

    ~ICAsyncThread();

    VOID SetCleanUp()
    {
        m_bCleanUp = TRUE;
    }
    
    DWORD GetError(VOID) const {
        return m_dwError;
    }

    VOID SetError(DWORD dwError = GetLastError()) {
        m_dwError = dwError;
    }

    BOOL IsTerminating(VOID) const {
        return m_bTerminating;
    }

    VOID SetTerminating(VOID) {
        m_bTerminating = TRUE;
    }

    DWORD
    QueueSocketWorkItem(
        IN CFsm * pFsm
        );

    BOOL
    RemoveFsmFromAsyncList(
        IN CFsm * pFsm
        );

    DWORD
    BlockWorkItem(
        IN CFsm * WorkItem,
        IN DWORD_PTR dwBlockId,
        IN DWORD dwTimeout = TP_NO_TIMEOUT
        );

    DWORD
    UnblockWorkItems(
        IN DWORD dwCount,
        IN DWORD_PTR dwBlockId,
        IN DWORD dwError,
        IN LONG lPriority = TP_NO_PRIORITY_CHANGE
        );

    DWORD
    CheckForBlockedWorkItems(
        IN DWORD dwCount,
        IN DWORD_PTR dwBlockId
        );

    static
    DWORD
    SelectThreadWrapper(
        IN ICAsyncThread * pThread
        );

    DWORD
    SelectThread(
        VOID
        );

    DWORD
    CreateSelectSocket(
        VOID
        );

    PRIVATE
    VOID
    DestroySelectSocket(
        VOID
        );

    VOID
    RecreateSelectSocket(
        VOID
        );

    VOID
    InterruptSelect(
        VOID
        );

    BOOL
    DrainSelectSocket(
        VOID
        );
};

//
// private data
//

PRIVATE ICAsyncThread * p_AsyncThread = NULL;
PRIVATE HANDLE* p_ThreadHandleArray = NULL;
PRIVATE DWORD* p_ThreadIdArray = NULL;
PRIVATE int p_iNumIOCPThreads = 0;

//
// functions
//



VOID
TerminateIOCPGlobals()
{
    if (g_lpCustomOverlapped)
    {
        delete g_lpCustomOverlapped;
        g_lpCustomOverlapped = NULL;
    }
    if (g_hCompletionPort)
    {
        CloseHandle(g_hCompletionPort);
        g_hCompletionPort = NULL;
    }
}


DWORD
IOCompletionThreadFunc(
    IN ULONG_PTR pContext
    )
{
    LPOVERLAPPED lpOverlapped;
    DWORD dwBytes;
    ULONG_PTR lpCompletionKey;
    DWORD dwTimeout = 1000;
    DWORD dwError = 0;
    BOOL bDeleteOverlapped = FALSE;
    LPINTERNET_THREAD_INFO lpThreadInfo;

    BOOL fExitThread = FALSE;
    lpThreadInfo = InternetGetThreadInfo();

    while (TRUE)
    {
                         
        BOOL bRet = GetQueuedCompletionStatus(g_hCompletionPort,
                                            &dwBytes,
                                            &lpCompletionKey,
                                            &lpOverlapped,
                                            fExitThread ? 0 : INFINITE);

        DEBUG_ENTER((DBG_API,
                         Dword,
                         "***GetQueuedCompletionStatus",
                         "(hcomp)%#x, (dwBytes)%#x, (completionkey)%#x, (overlapped)%#x",
                         g_hCompletionPort,
                         dwBytes,
                         lpCompletionKey,
                         lpOverlapped
                         ));

        if (!bRet && !lpOverlapped)
        {
            DEBUG_LEAVE_API(NULL);
            
            DWORD dwError = GetLastError();

            if (dwError == WAIT_TIMEOUT)
            {
                break;
            }

            // other errors currently not possible since we only have custom completion packets.
            INET_ASSERT (FALSE);

            continue;
        }

        ICSocket* pObject;
        CFsm* pFsm;
        CWrapOverlapped* lpWrapOverlapped;
        if (lpOverlapped != g_lpCustomOverlapped)
        {
            pObject = (ICSocket *) lpCompletionKey;
            pFsm = pObject->GetAndSetCurrentFsm(NULL);
            DEBUG_LEAVE(pFsm);
            
#if INET_DEBUG
            InterlockedDecrement(&g_cWSACompletions);
#endif

            INET_ASSERT(pFsm);
            bDeleteOverlapped = TRUE;
            lpWrapOverlapped = GetWrapOverlappedObject(lpOverlapped);

            if (pFsm->HasTimeout())
            {
                if (!RemoveFsmFromAsyncList(pFsm))
                {
                    //failure! the select thread already enforced timeout and updated state
                    //INET_ASSERT (FALSE && "COOL");
                    goto runworkitem;
                }
            }
            
            ((CFsm_SocketIOCP*)pFsm)->dwBytesTransferred = dwBytes;
            ((CFsm_SocketIOCP*)pFsm)->bIOCPSuccess = bRet;
            
            pFsm->ResetSocket();
            pFsm->SetPriority(TP_NO_PRIORITY_CHANGE);
            
            if (bRet)
            {
                pFsm->SetError(ERROR_SUCCESS);
                pFsm->SetState(pFsm->GetNextState());
            }
            else
            {
                //VENKATK_BUG-informational assert - remove later.
                DWORD dwErrorDebug = GetLastError();
                INET_ASSERT (FALSE && "IoCompletionError");
                
                ((CFsm_SocketIOCP*)pFsm)->dwIOCPError = GetLastError();

                if (((CFsm_SocketIOCP*)pFsm)->dwIOCPError == WSA_OPERATION_ABORTED)
                    pFsm->SetErrorState(ERROR_WINHTTP_OPERATION_CANCELLED);
                else
                    pFsm->SetErrorState(ERROR_WINHTTP_CONNECTION_ERROR);
            }
        }
        else
        {
            DEBUG_LEAVE(lpCompletionKey);
            INET_ASSERT( lpOverlapped == g_lpCustomOverlapped );
            INET_ASSERT( (dwBytes == COMPLETION_BYTES_CUSTOM) ||
                          (dwBytes == COMPLETION_BYTES_EXITIOCP) );

            if (dwBytes == COMPLETION_BYTES_EXITIOCP)
            {
                INET_ASSERT (lpCompletionKey == NULL);
                break;
            }   

            bDeleteOverlapped = FALSE;
            pFsm = (CFsm*) lpCompletionKey;
            
#if INET_DEBUG
            InterlockedDecrement(&g_cCustomCompletions);
#endif
        }

runworkitem:
        if (pFsm)
        {
            INTERNET_HANDLE_BASE *pBase = ((INTERNET_HANDLE_BASE *)pFsm->GetMappedHandleObject());
            pBase->Reference();  // might go away if closehandle is called.

            lpThreadInfo->IsAsyncWorkerThread = TRUE;
            dwError = CFsm::RunWorkItem(pFsm);

            if (dwError != ERROR_IO_PENDING)
            {
                // If there are any pending async work items for this request,
                // then schedule the first one in the list.
                if (pBase->GetHandleType() == TypeHttpRequestHandle)
                {
                    HTTP_REQUEST_HANDLE_OBJECT *pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)pBase;
                    if (pRequest->LockAsync())
                    {
                        if (!pRequest->IsWorkItemListEmpty())
                        {
                            pRequest->ScheduleWorkItem();
                        }
                        else
                        {
                            pRequest->SetWorkItemInProgress(FALSE);
                        }
                        pRequest->UnlockAsync();
                    }
                    else
                    {
                        // Need to report an error even if async item was
                        // successful if we can't check for pending work items.
                        dwError = (dwError == ERROR_SUCCESS ?
                                ERROR_NOT_ENOUGH_MEMORY : dwError);
                    }
                }
            }
            pBase->Dereference();
            // Must stay marked as being on an async worker thread until after
            // releasing the reference in order to prevent confusion in the async count.
            lpThreadInfo->IsAsyncWorkerThread = FALSE;
        }
        else
        {
            INET_ASSERT (pFsm);
        }

        if (!lpThreadInfo)
        {
            lpThreadInfo = InternetGetThreadInfo();
        }

        if (lpThreadInfo && lpThreadInfo->fExitThread)
        {
            //exit this thread after dequeuing as many available completions as possible.
            fExitThread = TRUE;
        }
        
        if (bDeleteOverlapped)
        {
            lpWrapOverlapped->Dereference();//VENKATKBUG - move it up later, but for now keep it here for debugging.
        }
    }

    if (fExitThread)
    {
        if (GeneralInitCritSec.Lock())
        {
            if (g_pAsyncCount && !g_pAsyncCount->GetRef())
            {
                //Additional check to make sure we don't go and knock off a freshly created set of globals.
                //These won't be leaked - would already have been deleted in the renewed InitializeIOCPSupport call.
                TerminateIOCPGlobals();
            }
            GeneralInitCritSec.Unlock();
        }
    }
    
    return dwError;
}

/*
 * called from InitalizeAsyncSupport and synchronized there
 *
 * also, don't bother to cleanup - if there's an error TerminateIOCPSupport is called.
 */

DWORD
InitializeIOCPSupport(
    VOID
    )
{
    int dwNumIOCPThreads = g_cNumIOCPThreads;

    if (!dwNumIOCPThreads)
    {
        SYSTEM_INFO sSysInfo;
        memset(&sSysInfo, 0, sizeof(SYSTEM_INFO));
        GetSystemInfo(&sSysInfo);
        if (sSysInfo.dwNumberOfProcessors)
            dwNumIOCPThreads = sSysInfo.dwNumberOfProcessors;

        if (!dwNumIOCPThreads)
        {
            dwNumIOCPThreads = WINHTTP_GLOBAL_IOCP_THREADS_BACKUP;
        }
    }
    g_cNumIOCPThreads = dwNumIOCPThreads;

#if INET_DEBUG
    g_cWSACompletions = 0;
    g_cCustomCompletions = 0;
#endif

    DWORD dwError = ERROR_SUCCESS;

    //May be left over from previous run.
    if (g_hCompletionPort)
    {
        CloseHandle(g_hCompletionPort);
        g_hCompletionPort = NULL;
    };

    if (g_lpCustomOverlapped)
    {
        delete g_lpCustomOverlapped;
        g_lpCustomOverlapped = NULL;
    }
    
    g_hCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0);

    if (!g_hCompletionPort)
    {
        dwError = GetLastError();
        goto quit;
    }

    g_lpCustomOverlapped = New OVERLAPPED();

    if (!g_lpCustomOverlapped)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    memset(g_lpCustomOverlapped, 0, sizeof(OVERLAPPED));

    p_ThreadHandleArray = New HANDLE[dwNumIOCPThreads];
    p_ThreadIdArray = New DWORD[dwNumIOCPThreads];

    if (!p_ThreadHandleArray || !p_ThreadIdArray)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }
        
    for (int i=0; i<dwNumIOCPThreads; i++)
    {
        BOOL bSuccess;
        DWORD dwThreadId;
        HANDLE hThread;

        hThread = CreateThread(
                    NULL,
                    0,
                    (LPTHREAD_START_ROUTINE)IOCompletionThreadFunc,
                    NULL,
                    0,
                    &dwThreadId
                    );
        
        if (hThread)
        {   
            p_ThreadHandleArray[p_iNumIOCPThreads++] = hThread;
            p_ThreadIdArray[i] = dwThreadId;
        }
        else
        {
            //successfully queued functions terminated in TerminateIOCPSupport   
            dwError = GetLastError();
            break;
        }
        
    }

quit:
    return dwError;
}


VOID
TerminateIOCPSupport(
    VOID
    )
{
    DWORD dwWaitResult;
    int iNumThreadsToEnd = p_iNumIOCPThreads;
    HANDLE* pThreadHandleArray = p_ThreadHandleArray;
    DWORD fDeleteHandleArray = FALSE;
    BOOL fTerminatingOnWorker = FALSE;
    
    if (!p_ThreadHandleArray)
        goto quit;

#if INET_DEBUG
    if (g_cWSACompletions || g_cCustomCompletions)
    {
        INET_ASSERT(FALSE);
        WaitForMultipleObjects(p_iNumIOCPThreads, p_ThreadHandleArray, TRUE, 500);
    }
#endif

    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();

    if (!lpThreadInfo)
    {
        goto quit;
    }

    if (lpThreadInfo->IsAsyncWorkerThread)
    {
        //can't terminate the worker thread we're on.
        --iNumThreadsToEnd;
        fTerminatingOnWorker = TRUE;

        lpThreadInfo->fExitThread = TRUE;
        
        if (iNumThreadsToEnd)
        {
            int iIndex = -1;
            DWORD dwThreadId = GetCurrentThreadId();

            //verify we're on a worker thread.
            for (int i=0; i<p_iNumIOCPThreads; i++)
            {
                if (p_ThreadIdArray[i] == dwThreadId)
                {
                    iIndex = i;
                    break;
                }
            }
            
            if (iIndex != -1)
            {
                pThreadHandleArray = New HANDLE[iNumThreadsToEnd];

                if (!pThreadHandleArray)
                {
                    goto quit;
                }
                fDeleteHandleArray = TRUE;
                
                int i=0;
                for (int j=0; j<p_iNumIOCPThreads; j++)
                {
                    if (j != iIndex)
                    {
                        pThreadHandleArray[i++] = p_ThreadHandleArray[j]; 
                    }
                }
            }
            else
            {
                INET_ASSERT(FALSE);
            }
        }
        else
        {
            goto quit;
        }
    }
    
    for (int i=0; i<iNumThreadsToEnd; i++)
    {
        BOOL bSuccess = PostQueuedCompletionStatus(g_hCompletionPort,
                                            COMPLETION_BYTES_EXITIOCP,
                                            NULL,
                                            g_lpCustomOverlapped
                                            );
        INET_ASSERT (bSuccess);
    }

    dwWaitResult = WaitForMultipleObjects(iNumThreadsToEnd, pThreadHandleArray, TRUE, 2000);

    if ((dwWaitResult == WAIT_TIMEOUT) || (dwWaitResult == WAIT_FAILED))
    {
        goto forceTerminate;
    }
    else
    {
        INET_ASSERT ( ((LONG)dwWaitResult >= WAIT_OBJECT_0) && ((LONG)dwWaitResult < (WAIT_OBJECT_0+p_iNumIOCPThreads)));
    }

quit:
    INET_ASSERT ((g_cWSACompletions == 0) &&
                 (g_cCustomCompletions == 0));
                 
    if (p_ThreadHandleArray)
    {
        for (int i=0; i<p_iNumIOCPThreads; i++)
        {
            CloseHandle(p_ThreadHandleArray[i]);
        }
    
        delete [] p_ThreadHandleArray;
        p_ThreadHandleArray = NULL;
    }
    if (p_ThreadIdArray)
    {
        delete [] p_ThreadIdArray;
        p_ThreadIdArray = NULL;
    }
    if (fDeleteHandleArray)
    {
        delete [] pThreadHandleArray;
    }
    if (fTerminatingOnWorker)
    {
        //don't delete these globals since they may be in use on this last thread.
        TerminateIOCPGlobals();
    }
    p_iNumIOCPThreads = 0;
    
    return;

forceTerminate:
    for (int i=0; i<iNumThreadsToEnd; i++)
    {
        if (WaitForSingleObject(pThreadHandleArray[i], 0) != WAIT_OBJECT_0)
        {
            TerminateThread(pThreadHandleArray[i], -1);
        }
    }
    goto quit;
}


DWORD
InitializeAsyncSupport(
    VOID
    )

/*++

Routine Description:

    Create async select thread object

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS


        Failure -

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "InitializeAsyncSupport",
                 NULL
                 ));

    DWORD error = ERROR_WINHTTP_SHUTDOWN;

    if (!InDllCleanup) {

        if (!GeneralInitCritSec.Lock())
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }

        if (!InDllCleanup) {
            if (p_AsyncThread == NULL) {

                HANDLE  hThreadToken = NULL;
                //
                // If the current thread is impersonating, then grab its access token
                // and revert the current thread (so it is nolonger impersonating).
                // After creating the worker thread, we will make the main thread
                // impersonate again. Apparently you should not call CreateThread
                // while impersonating.
                //
                if (OpenThreadToken(GetCurrentThread(), (TOKEN_IMPERSONATE | TOKEN_READ),
                        FALSE,
                        &hThreadToken))
                {
                    INET_ASSERT(hThreadToken != 0);

                    RevertToSelf();
                }

                p_AsyncThread = New ICAsyncThread();
                if (p_AsyncThread == NULL) {
                    error = ERROR_NOT_ENOUGH_MEMORY;
                } else {
                    error = p_AsyncThread->GetError();
                    if (error == ERROR_SUCCESS)
                        error = InitializeIOCPSupport();
                    if (error != ERROR_SUCCESS) {
                        TerminateAsyncSupport(TRUE);
                    }
                }

                if (hThreadToken)
                {
                    SetThreadToken(NULL, hThreadToken);

                    CloseHandle(hThreadToken);
                }


            } else {
                error = ERROR_SUCCESS;
            }
        }
        GeneralInitCritSec.Unlock();
    }

quit:
    DEBUG_LEAVE(error);

    return error;
}


VOID
TerminateAsyncSupport(
    BOOL bCleanUp
    )

/*++

Routine Description:

    Terminates async support

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "TerminateAsyncSupport",
                 NULL
                 ));

    ICAsyncThread * pThread;
    
    if (GeneralInitCritSec.Lock())
    {
        TerminateIOCPSupport();
        
        pThread = (ICAsyncThread *)InterlockedExchangePointer((PVOID*)&p_AsyncThread,
                                                       (PVOID)NULL
                              );
        
        if (pThread != NULL) 
        {
            if (bCleanUp)
                pThread->SetCleanUp();
            delete pThread;
        }

        GeneralInitCritSec.Unlock();
    }
    
    DEBUG_LEAVE(0);
}



BOOL
RemoveFsmFromAsyncList(
    IN CFsm * pFsm
    )
{
    BOOL bSuccess = TRUE;
    if (p_AsyncThread != NULL) 
    {
        bSuccess = p_AsyncThread->RemoveFsmFromAsyncList(pFsm);
    }

    return bSuccess;
}


DWORD
QueueSocketWorkItem(
    IN CFsm * pFsm,
    IN SOCKET Socket
    )

/*++

Routine Description:

    Adds a blocked socket operation/work item to the blocked queue

Arguments:

    pFsm    - in-progress socket operation (FSM)

    Socket  - socket handle to wait on

Return Value:

    DWORD
        Success - ERROR_IO_PENDING

        Failure - ERROR_WINHTTP_INTERNAL_ERROR

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "QueueSocketWorkItem",
                 "%#x, %#x",
                 pFsm,
                 Socket
                 ));

    DWORD error = ERROR_WINHTTP_INTERNAL_ERROR;

    if (p_AsyncThread != NULL) {
        pFsm->SetSocket(Socket);
        error = p_AsyncThread->QueueSocketWorkItem(pFsm);
        if (error == ERROR_SUCCESS) {
            error = ERROR_IO_PENDING;
        }
    }

    INET_ASSERT(error != ERROR_WINHTTP_INTERNAL_ERROR);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
BlockWorkItem(
    IN CFsm * pFsm,
    IN DWORD_PTR dwBlockId,
    IN DWORD dwTimeout
    )

/*++

Routine Description:

    Blocks a work item

Arguments:

    pFsm        - work item to block

    dwBlockId   - block on this id

    dwTimeout   - for this number of milliseconds

Return Value:

    DWORD
        Error   - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "BlockWorkItem",
                 "%#x, %#x, %d",
                 pFsm,
                 dwBlockId,
                 dwTimeout
                 ));

    DWORD error = ERROR_WINHTTP_INTERNAL_ERROR;

    if (p_AsyncThread != NULL) {
        error = p_AsyncThread->BlockWorkItem(pFsm, dwBlockId, dwTimeout);
    }

    INET_ASSERT(error != ERROR_WINHTTP_INTERNAL_ERROR);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
UnblockWorkItems(
    IN DWORD dwCount,
    IN DWORD_PTR dwBlockId,
    IN DWORD dwError,
    IN LONG lPriority
    )

/*++

Routine Description:

    Unblocks 1 or more work items

Arguments:

    dwCount     - unblock this many work items

    dwBlockId   - that are blocked on this id

    dwError     - with this error

    lPriority   - new priority unless default value of TP_NO_PRIORITY_CHANGE

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Int,
                 "UnblockWorkItems",
                 "%d, %#x, %d (%s), %d",
                 dwCount,
                 dwBlockId,
                 dwError,
                 InternetMapError(dwError),
                 lPriority
                 ));

    DWORD dwUnblocked = 0;

    if (p_AsyncThread != NULL) {
        dwUnblocked = p_AsyncThread->UnblockWorkItems(dwCount,
                                                      dwBlockId,
                                                      dwError,
                                                      lPriority
                                                      );
    }

    DEBUG_LEAVE(dwUnblocked);

    return dwUnblocked;
}


DWORD
CheckForBlockedWorkItems(
    IN DWORD dwCount,
    IN DWORD_PTR dwBlockId
    )

/*++

Routine Description:

    Checks if there are any items blocked on dwBlockId

Arguments:

    dwCount     - number of items to look for

    dwBlockId   - blocked on this id

Return Value:

    DWORD
        Number of blocked items found

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Int,
                 "CheckForBlockedWorkItems",
                 "%d, %#x",
                 dwCount,
                 dwBlockId
                 ));

    DWORD dwFound = 0;

    if (p_AsyncThread != NULL) {
        dwFound = p_AsyncThread->CheckForBlockedWorkItems(dwCount, dwBlockId);
    }

    DEBUG_LEAVE(dwFound);

    return dwFound;
}

//
// private functions
//

//
// ICAsyncThread methods
//


ICAsyncThread::~ICAsyncThread(
    VOID
    )

/*++

Routine Description:

    ICAsyncThread destructor. If we are being dynamically unloaded, signal the
    selecter thread and allow it to cleanup. Else the thread is already dead and
    we just need to reclaim the resources

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "ICAsyncThread::~ICAsyncThread",
                 NULL
                 ));

    SetTerminating();
    if (GlobalDynaUnload || m_bCleanUp) {
        InterruptSelect();

        //
        // Assuming the async thread was successfully created, the above clean-up
        // will have put it in a state where it's going to exit.  Need to wait
        // for it to exit before returning from here so it doesn't get scheduled
        // after wininet has been unloaded.
        //
        if(m_hThread)
        {
            DWORD dwRes = WaitForSingleObject(m_hThread, 5 * 1000);
            INET_ASSERT(dwRes == WAIT_OBJECT_0);
        }
    }
    DestroySelectSocket();

    if(m_hThread)
    {
        CloseHandle(m_hThread);
    }

    DEBUG_LEAVE(0);
}


DWORD
ICAsyncThread::QueueSocketWorkItem(
    IN CFsm * pFsm
    )

/*++

Routine Description:

    Add the work-item waiting on a blocked socket to the blocked queue.
    Interrupt the SelectThread to alert it to new work

Arguments:

    pFsm    - blocked work-item to queue

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_INTERNAL_ERROR

Async Issues: VENKATK_BUG
    1. Reduce contention for m_BlockedQueue by:
        maintaining sorted queue for timeout-only fsms.
    2. Don't call InterruptSelect() for timeout queueing
    3. check if content can be moved to per-fsm instead of
        global queue..
--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "ICAsyncThread::QueueSocketWorkItem",
                 "%#x",
                 pFsm
                 ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error = ERROR_WINHTTP_INTERNAL_ERROR;

    INET_ASSERT(lpThreadInfo != NULL);

    if (lpThreadInfo != NULL) {
        pFsm->StartTimer();
        error = m_BlockedQueue.Insert((CPriorityListEntry *)pFsm->List());
        lpThreadInfo->Fsm = NULL;
        InterruptSelect();
    }

    DEBUG_LEAVE(error);

    return error;
}


BOOL
ICAsyncThread::RemoveFsmFromAsyncList(
    IN CFsm * pFsm
    )
{
    BOOL bSuccess = FALSE;
    if (m_BlockedQueue.Acquire())
    {
        if (pFsm->IsOnAsyncList())
        {
            m_BlockedQueue.Remove((CPriorityListEntry *)pFsm);
            pFsm->SetOnAsyncList(FALSE);
            bSuccess = TRUE;
        }
        m_BlockedQueue.Release();
    }
    
    return bSuccess;
}


DWORD
ICAsyncThread::BlockWorkItem(
    IN CFsm * pFsm,
    IN DWORD_PTR dwBlockId,
    IN DWORD dwTimeout
    )

/*++

Routine Description:

    Blocks a work item (FSM)

Arguments:

    pFsm        - work item (FSM) to block

    dwBlockId   - block on this

    dwTimeout   - for this amount of time (mSec)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "ICAsyncThread::BlockWorkItem",
                 "%#x [%d], %#x, %d",
                 pFsm,
                 pFsm->GetPriority(),
                 dwBlockId,
                 dwTimeout
                 ));

    DWORD error = error = ERROR_WINHTTP_INTERNAL_ERROR;
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    INET_ASSERT(lpThreadInfo != NULL);

    if (lpThreadInfo != NULL) {
        pFsm->SetBlockId(dwBlockId);
        pFsm->SetTimeout(dwTimeout);

        RESET_FSM_OWNED(pFsm);

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("!!! FSM %#x unowned\n",
                    pFsm
                    ));

        error = m_BlockedQueue.Insert((CPriorityListEntry *)pFsm->List());
        lpThreadInfo->Fsm = NULL;
    }

    DEBUG_LEAVE(error);
    return error;
}


DWORD
ICAsyncThread::UnblockWorkItems(
    IN DWORD dwCount,
    IN DWORD_PTR dwBlockId,
    IN DWORD dwError,
    IN LONG lPriority
    )

/*++

Routine Description:

    Unblock a nunber of work items waiting on a block id

Arguments:

    dwCount     - unblock this many work items

    dwBlockId   - unblock work items waiting on this id

    dwError     - unblock work items with this error code

    lPriority   - if not TP_NO_PRIORITY_CHANGE, change priority to this value

Return Value:

    DWORD
        Number of work items unblocked

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Int,
                 "ICAsyncThread::UnblockWorkItems",
                 "%d, %#x, %d (%s), %d",
                 dwCount,
                 dwBlockId,
                 dwError,
                 InternetMapError(dwError),
                 lPriority
                 ));

    DWORD dwUnblocked = 0;

    if (!m_BlockedQueue.Acquire())
        goto quit;

    CPriorityListEntry * pCur = (CPriorityListEntry *)m_BlockedQueue.Head();
    CPriorityListEntry * pPrev = (CPriorityListEntry *)m_BlockedQueue.Self();

    while ((dwCount != 0) && (pCur != (CPriorityListEntry *)m_BlockedQueue.Self())) {

        CFsm * pFsm = ContainingFsm((LPVOID)pCur);

        //CHECK_FSM_UNOWNED(pFsm);

        if (pFsm->IsBlockedOn(dwBlockId)) {
            m_BlockedQueue.Remove((CPriorityListEntry *)pFsm);
            pFsm->SetError(dwError);
            if (lPriority != TP_NO_PRIORITY_CHANGE) {
                pFsm->SetPriority(lPriority);
            }
//dprintf("UNBLOCKED %s FSM %#x state %s socket %#x\n", pFsm->MapType(), pFsm, pFsm->MapState(), pFsm->GetSocket());
            pFsm->QueueWorkItem();
            ++dwUnblocked;
            --dwCount;
        } else {
            pPrev = pCur;
        }
        pCur = (CPriorityListEntry *)pPrev->Next();
    }
    m_BlockedQueue.Release();

quit:
    DEBUG_LEAVE(dwUnblocked);

    return dwUnblocked;
}


DWORD
ICAsyncThread::CheckForBlockedWorkItems(
    IN DWORD dwCount,
    IN DWORD_PTR dwBlockId
    )

/*++

Routine Description:

    Examines to see if a blocked FSM is still blocked in order to prevent
        wasted processing if it isn't.

Arguments:

    dwCount     - unblock this many work items

    dwBlockId   - unblock work items waiting on this id

Return Value:

    DWORD
        Number of work items that are currently blocked

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Int,
                 "ICAsyncThread::CheckForBlockedWorkItems",
                 "%d, %#x",
                 dwCount,
                 dwBlockId
                 ));

    DWORD dwFound = 0;

    if (!m_BlockedQueue.Acquire())
        goto quit;

    CPriorityListEntry * pCur = (CPriorityListEntry *)m_BlockedQueue.Head();
    CPriorityListEntry * pPrev = (CPriorityListEntry *)m_BlockedQueue.Self();

    while ((dwCount != 0) && (pCur != (CPriorityListEntry *)m_BlockedQueue.Self())) {

        CFsm * pFsm = ContainingFsm((LPVOID)pCur);

        if (pFsm->IsBlockedOn(dwBlockId)) {
            ++dwFound;
            --dwCount;
        }
        pCur = (CPriorityListEntry *)pCur->Next();
    }
    m_BlockedQueue.Release();

quit:
    DEBUG_LEAVE(dwFound);

    return dwFound;
}


DWORD
ICAsyncThread::SelectThreadWrapper(
    IN ICAsyncThread * pThread
    )

/*++

Routine Description:

    Kicks off select thread as member function of pThread object

Arguments:

    pThread - pointer to thread object

Return Value:

    DWORD
        return code from SelectThread (not used)

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "ICAsyncThread::SelectThreadWrapper",
                 "%#x",
                 pThread
                 ));

    DWORD error = pThread->SelectThread();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICAsyncThread::SelectThread(
    VOID
    )

/*++

Routine Description:

    Waits for completed items on blocked queue to finish, either due to timeout,
    invalidated request handle or successful or error completion of the socket
    operation.

    Completed items are put on the work queue and a worker signalled to process
    it

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    //
    // we need thread info for debug output
    //

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo == NULL) {

        DEBUG_PRINT(ASYNC,
                    FATAL,
                    ("Can't get thread info block\n"
                    ));

        INET_ASSERT(FALSE);

        return ERROR_WINHTTP_INTERNAL_ERROR;
    }

    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "ICAsyncThread::SelectThread",
                 NULL
                 ));

    //
    // have to create select socket in this thread or winsock blocks main thread
    // on Win95 when autodial enabled
    //

    DWORD error = CreateSelectSocket();

    if (error != ERROR_SUCCESS) {

        DEBUG_LEAVE(error);

        return error;
    }

    DWORD ticks = GetTickCountWrap();

    while (!IsTerminating()) {

        //
        // run through the blocked items finding sockets to wait on and minimum
        // time to wait. If we find any items already timed out or invalidated
        // then remove them and put on the work queue
        //

        if (!m_BlockedQueue.Acquire())
        {
            // wait and try again when more memory might be available
            goto wait_again;
        }

        PLIST_ENTRY pEntry;
        PLIST_ENTRY pPrev;

        pPrev = m_BlockedQueue.Self();

        //
        // BUGBUG - queue limited by size of FD_SET
        //

        struct fd_set read_fds;
        int nTimeouts = 0;
        struct fd_set write_fds;
        struct fd_set except_fds;
        int n = 0;
        BOOL bLazy = FALSE;
        DWORD timeout = 0xffffffff;
        DWORD timeNow = GetTickCountWrap();

        FD_ZERO(&read_fds);
        FD_ZERO(&write_fds);
        FD_ZERO(&except_fds);

        CFsm * pFsm;

        for (pEntry = m_BlockedQueue.Head();
             pEntry != m_BlockedQueue.Self();
             pEntry = ((CPriorityListEntry *)pPrev)->Next()) {

            pFsm = ContainingFsm((LPVOID)pEntry);
            if (pFsm->IsInvalid() || pFsm->IsTimedOut(timeNow)) {

                DEBUG_PRINT(ASYNC,
                            INFO,
                            ("%s FSM %#x %s\n",
                            pFsm->MapType(),
                            pFsm,
                            pFsm->IsInvalid() ? "invalid" : "timed out"
                            ));

                m_BlockedQueue.Remove((CPriorityListEntry *)pEntry);

                if (pFsm->IsOnAsyncList())
                {
                    INET_ASSERT( (pFsm->GetAction() == FSM_ACTION_SEND) ||
                                    (pFsm->GetAction() == FSM_ACTION_RECEIVE) );
                                 
                    ((INTERNET_HANDLE_BASE *)pFsm->GetMappedHandleObject())->AbortSocket();
                    
                    pFsm->SetErrorState(pFsm->IsInvalid()
                                        ? ERROR_WINHTTP_OPERATION_CANCELLED
                                        : ERROR_WINHTTP_TIMEOUT
                                        );
                                        
                    pFsm->SetOnAsyncList(FALSE);
                    continue;
                }

                pFsm->SetErrorState(pFsm->IsInvalid()
                                        ? ERROR_WINHTTP_OPERATION_CANCELLED
                                        : ERROR_WINHTTP_TIMEOUT
                                        );
                pFsm->ResetSocket();
                pFsm->QueueWorkItem();
                continue;
            }
            else if (pFsm->IsOnAsyncList())
            {
                INET_ASSERT (pFsm->IsActive());
                ++nTimeouts;
            }
            else if (pFsm->IsActive()) 
            {
                SOCKET sock = pFsm->GetSocket();

                if (pFsm->GetAction() == FSM_ACTION_RECEIVE) 
                {
                    DEBUG_PRINT(ASYNC,
                                INFO,
                                ("FSM %#x READ waiting on socket %#x\n",
                                pFsm,
                                sock
                                ));

                    FD_SET(sock, &read_fds);
                } 
                else 
                {
                    //
                    // connect() & send()
                    //
                    DEBUG_PRINT(ASYNC,
                                INFO,
                                ("%s FSM %#x WRITE waiting on socket %#x\n",
                                pFsm->MapType(),
                                pFsm,
                                sock
                                ));

                    FD_SET(sock, &write_fds);
                }

                //
                // all sockets are checked for exception
                //
                FD_SET(sock, &except_fds);
                ++n;

//DWORD t;
//if ((t = pFsm->GetElapsedTime()) > 10) {
//    dprintf("%s FSM %#x socket %#x on queue %d mSec times-out in %d\n",
//    pFsm->MapType(),
//    pFsm,
//    sock,
//    t,
//    pFsm->GetTimeout() - GetTickCount());
//}
            }// if pFsm->IsActive()

            DWORD interval = pFsm->GetTimeout() - timeNow;

            //VENKATKBUG - check negative interval issue?
            if (interval < timeout) {
                timeout = interval;
//dprintf("min timeout = %d\n", timeout);
            }
            pPrev = pEntry;
        }

        m_BlockedQueue.Release();

wait_again:
        //
        // BUGBUG - wait for default (5 secs) timeout if nothing currently on
        //          list
        //
        if ((n == 0) && (nTimeouts == 0))
        {
            timeout = 5000;
            bLazy = TRUE;
        }

        INET_ASSERT(n < FD_SETSIZE);

        FD_SET(m_SelectSocket, &read_fds);
        ++n;

        struct timeval to;

        to.tv_sec = timeout / 1000;
        to.tv_usec = (timeout % 1000) * 1000;

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("waiting %d mSec (%d.%06d) for select(). %d sockets\n",
                    timeout,
                    to.tv_sec,
                    to.tv_usec,
                    n
                    ));

        //SuspendCAP();

        if (IsTerminating()) {
            break;
        }
        n = PERF_Select(n, &read_fds, &write_fds, &except_fds, &to);
        if (IsTerminating()) {
            break;
        }

        //ResumeCAP();

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("select() returns %d\n",
                    n
                    ));

        //
        // if the only thing that's happened is that a new request has been
        // added to the list then rebuild the list and re-select
        //

        if ((n == 1) && FD_ISSET(m_SelectSocket, &read_fds)) {
            if (!DrainSelectSocket() && !IsTerminating()) {
                RecreateSelectSocket();
            }
            continue;
        }

        //
        // if any items are completed (either successfully or with an error)
        // or timed out or invalidated then put them on the work queue
        //


        if ((n>=0) || (nTimeouts >= 0))
        {
            if (m_BlockedQueue.Acquire())
            {

                pPrev = m_BlockedQueue.Self();
                timeNow = GetTickCountWrap();

                for (pEntry = m_BlockedQueue.Head();
                     pEntry != m_BlockedQueue.Self();
                     pEntry = ((CPriorityListEntry *)pPrev)->Next()) 
                {
                    DWORD dwEntryError;
                    BOOL bComplete = FALSE;
                    LONG lPriority = TP_NO_PRIORITY_CHANGE;

                    pFsm = ContainingFsm((LPVOID)pEntry);
                    if (pFsm->IsInvalid()) {

                        DEBUG_PRINT(ASYNC,
                                    INFO,
                                    ("%s FSM %#x invalid\n",
                                    pFsm->MapType(),
                                    pFsm
                                    ));

                        dwEntryError = ERROR_WINHTTP_OPERATION_CANCELLED;
                        bComplete = TRUE;
                    } else if (pFsm->IsTimedOut(timeNow)) {

                        DEBUG_PRINT(ASYNC,
                                    INFO,
                                    ("%s FSM %#x timed out\n",
                                    pFsm->MapType(),
                                    pFsm
                                    ));

                        dwEntryError = ERROR_WINHTTP_TIMEOUT;
                        bComplete = TRUE;
                    } else if (pFsm->IsActive()) {

                        SOCKET sock = pFsm->GetSocket();

                        if (FD_ISSET(sock, &except_fds)) {

                            DEBUG_PRINT(ASYNC,
                                        INFO,
                                        ("%s FSM %#x socket %#x exception\n",
                                        pFsm->MapType(),
                                        pFsm,
                                        sock
                                        ));

                            switch (pFsm->GetAction()) {
                            case FSM_ACTION_CONNECT:
                                dwEntryError = ERROR_WINHTTP_CANNOT_CONNECT;
                                break;

                            case FSM_ACTION_SEND:
                            case FSM_ACTION_RECEIVE:
                                INET_ASSERT (! pFsm->IsOnAsyncList());
                            
                                dwEntryError = ERROR_WINHTTP_CONNECTION_ERROR;
                                break;

                            default:

                                INET_ASSERT(FALSE);

                                break;
                            }
                            bComplete = TRUE;
                        } else if (FD_ISSET(sock, &read_fds)
                        || FD_ISSET(sock, &write_fds)) {

                            DEBUG_PRINT(ASYNC,
                                        INFO,
                                        ("%s FSM %#x socket %#x completed\n",
                                        pFsm->MapType(),
                                        pFsm,
                                        sock
                                        ));

                            dwEntryError = ERROR_SUCCESS;
                            bComplete = TRUE;

                            //
                            // BUGBUG - the priority needs to be boosted
                            //

                        }
                    }
                    if (bComplete) 
                    {
                        m_BlockedQueue.Remove((CPriorityListEntry *)pFsm);
                        if (dwEntryError != ERROR_SUCCESS) 
                        {
                            if (pFsm->IsOnAsyncList())
                            {
                                INET_ASSERT( (pFsm->GetAction() == FSM_ACTION_SEND) ||
                                                (pFsm->GetAction() == FSM_ACTION_RECEIVE) );
                                            
                                INET_ASSERT( (dwEntryError == ERROR_WINHTTP_TIMEOUT) ||
                                             (dwEntryError == ERROR_WINHTTP_OPERATION_CANCELLED) );
                                         
                                ((INTERNET_HANDLE_BASE *)pFsm->GetMappedHandleObject())->AbortSocket();
                            
                                //INET_ASSERT (FALSE && "ICASYNC aborting FSM!");
                                pFsm->SetErrorState(dwEntryError);//VENKATKBUG - ?? to do?
                                pFsm->SetOnAsyncList(FALSE);
                                continue;
                            }
                            pFsm->SetErrorState(dwEntryError);
                        } 
                        else 
                        {
                            INET_ASSERT (! (pFsm->IsOnAsyncList()) );
                                        
                            pFsm->SetError(ERROR_SUCCESS);
                            pFsm->SetState(pFsm->GetNextState());
                        }
                        pFsm->SetPriority(lPriority);

//dprintf("%s FSM %#x socket %#x signalled, time on queue = %d\n", pFsm->MapType(), pFsm, pFsm->GetSocket(), pFsm->StopTimer());
                        //
                        // no longer waiting on this socket handle
                        //

                        pFsm->ResetSocket();

                        //
                        // BUGBUG - if the next operation will complete quickly
                        //          (FSM_HINT_QUICK) then we should run it here
                        //          instead of queuing to another thread
                        //

                        pFsm->QueueWorkItem();
                    } 
                    else 
                    {
                        pPrev = pEntry;
                    }
                }//loop: for (pEntry = m_BlockedQueue.Head();pEntry != m_BlockedQueue.Self();pEntry = ((CPriorityListEntry *)pPrev)->Next()) 
                m_BlockedQueue.Release();
            }// if (m_BlockedQueue.Acquire())
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
            }
        } 
        else // if! n >= 0
        {
            error = _I_WSAGetLastError();

            DEBUG_PRINT(ASYNC,
                        ERROR,
                        ("select() returns %d (%s)\n",
                        error,
                        InternetMapError(error)
                        ));

            //
            // WSAENOTSOCK can happen if the socket was cancelled just
            // before we waited on it. We can also get WSAEINTR if
            // select() is terminated early (by APC)
            //

            INET_ASSERT((error == WSAENOTSOCK) || (error == WSAEINTR) || (error == WSAEBADF));

            if (error == WSAEINTR) {
                continue;
            }

            //
            // when running on a portable (& probably desktops also), if we
            // suspend & resume, the select socket can be invalidated. We
            // need to recognize this situation and handle it
            //

            FD_ZERO(&read_fds);
            FD_ZERO(&write_fds);
            FD_ZERO(&except_fds);

            FD_SET(m_SelectSocket, &read_fds);

            to.tv_sec = 0;
            to.tv_usec = 0;
            n = _I_select(1, &read_fds, &write_fds, &except_fds, &to);
            if (n < 0) {

                //
                // the select socket is dead. Throw it away & create a new
                // one. We should pick up any blocked requests that tried
                // unsuccessfully to interrupt the old select socket
                //

                RecreateSelectSocket();
            } else {

                //
                // some socket(s) other than the select socket has become
                // invalid. Cancel the corresponding request(s)
                //
            }
        } // if! n >= 0

        //
        // perform timed events
        //
        // BUGBUG - need variable for 5000
        //

        if ((GetTickCountWrap() - ticks) >= 5000) {
            if( bLazy == TRUE && !InDllCleanup && !IsTerminating())
            {
#ifndef WININET_SERVER_CORE
                //
                // wake background task mgr
                // this may involve one of the background workitem
                // to be queued and get executed
                //
                NotifyBackgroundTaskMgr();
#endif
            }
#ifndef WININET_SERVER_CORE //now per-session
            PurgeServerInfoList(FALSE);
#endif
            ticks = GetTickCountWrap();
        }
    }
    //REDUNDANT: TerminateAsyncSupport();

    DEBUG_LEAVE(error);
//dprintf("!!! Waiter FSM is done\n");
    return error;
}


DWORD
ICAsyncThread::CreateSelectSocket(
    VOID
    )

/*++

Routine Description:

    In order to not have to keep inefficiently polling select() with a short
    time-out, we create a 'trick' datagram socket that we can use to interrupt
    select() with: this is a local socket, and if we send something to ourself
    then select() will complete (assuming one of the sockets we are waiting on
    is the one we create here)

    N.B. Sockets support must be initialized by the time we get here

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - mapped socket error

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "ICAsyncThread::CreateSelectSocket",
                 NULL
                 ));

    INET_ASSERT(m_SelectSocket == INVALID_SOCKET);

    DWORD error;
    SOCKET sock;

    sock = _I_socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (sock == INVALID_SOCKET) {

        DEBUG_PRINT(ASYNC,
                    ERROR,
                    ("socket() failed\n"
                    ));

        goto socket_error;
    }

    SOCKADDR_IN sockAddr;

    sockAddr.sin_family = AF_INET;
    sockAddr.sin_port = 0;
    *(LPDWORD)&sockAddr.sin_addr = _I_htonl(INADDR_LOOPBACK);
    memset(&sockAddr.sin_zero, 0, sizeof(sockAddr.sin_zero));

    int rc;

    DEBUG_PRINT(ASYNC,
                INFO,
                ("binding socket %#x to address %d.%d.%d.%d\n",
                sock,
                ((LPBYTE)&sockAddr.sin_addr)[0] & 0xff,
                ((LPBYTE)&sockAddr.sin_addr)[1] & 0xff,
                ((LPBYTE)&sockAddr.sin_addr)[2] & 0xff,
                ((LPBYTE)&sockAddr.sin_addr)[3] & 0xff
                ));

    rc = _I_bind(sock, (LPSOCKADDR)&sockAddr, sizeof(sockAddr));
    if (rc == SOCKET_ERROR) {

        DEBUG_PRINT(ASYNC,
                    ERROR,
                    ("bind() failed\n"
                    ));

        goto socket_error;
    }

    int namelen;
    SOCKADDR sockname;
    namelen = sizeof(sockname);

    rc = _I_getsockname(sock, &sockname, &namelen);
    if (rc == SOCKET_ERROR) {

        DEBUG_PRINT(ASYNC,
                    ERROR,
                    ("getsockname() failed\n"
                    ));

        goto socket_error;
    }

    DEBUG_PRINT(ASYNC,
                INFO,
                ("connecting to address %d.%d.%d.%d\n",
                ((LPBYTE)&sockname.sa_data)[2] & 0xff,
                ((LPBYTE)&sockname.sa_data)[3] & 0xff,
                ((LPBYTE)&sockname.sa_data)[4] & 0xff,
                ((LPBYTE)&sockname.sa_data)[5] & 0xff
                ));

    rc = _I_connect(sock, &sockname, namelen);
    if (rc == SOCKET_ERROR) {

        DEBUG_PRINT(ASYNC,
                    ERROR,
                    ("connect() failed\n"
                    ));

        goto socket_error;
    }

    m_SelectSocket = sock;
    error = ERROR_SUCCESS;

quit:

    DEBUG_LEAVE(error);

    return error;

socket_error:

    error = MapInternetError(_I_WSAGetLastError());
    DestroySelectSocket();
    goto quit;
}


VOID
ICAsyncThread::DestroySelectSocket(
    VOID
    )

/*++

Routine Description:

    Just closes SelectSocket (if we think its open)

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "ICAsyncThread::DestroySelectSocket",
                 NULL
                 ));

    if (m_SelectSocket != INVALID_SOCKET) {
        _I_closesocket(m_SelectSocket);
        m_SelectSocket = INVALID_SOCKET;
    }

    DEBUG_LEAVE(0);
}


VOID
ICAsyncThread::RecreateSelectSocket(
    VOID
    )

/*++

Routine Description:

    Attempt to destroy & recreate select socket. Required when socket is killed
    due to suspend, e.g.

    Since the underlying net components may take a while to restart, we loop up
    to 12 times, waiting up to ~16 secs (~32 secs cumulative)

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "ICAsyncThread::RecreateSelectSocket",
                 NULL
                 ));

    DestroySelectSocket();

    DEBUG_PRINT(ASYNC,
                INFO,
                ("current interrupt count = %d\n",
                m_lSelectInterrupts
                ));

    m_lSelectInterrupts = -1;

    int iterations = 12;
    DWORD time = 8;
    DWORD error;

    do {
        error = CreateSelectSocket();
        if (error != ERROR_SUCCESS) {
            PERF_Sleep(time);
            time <<= 1;
        }
    } while ((error != ERROR_SUCCESS) && --iterations);

    DEBUG_LEAVE(0);
}


VOID
ICAsyncThread::InterruptSelect(
    VOID
    )

/*++

Routine Description:

    We interrupt a waiting select() by sending a small amount of data to ourself
    on the 'trick datagram socket'

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "ICAsyncThread::InterruptSelect",
                 NULL
                 ));

    //
    // if the async select socket is already created then interrupt it. If it is
    // not yet created then it probably means that the async scheduler thread
    // hasn't gotten around to it yet, ipso facto the async scheduler can't be
    // stuck in a select(), hence its okay to skip
    //

    if (m_SelectSocket != INVALID_SOCKET) {
        if (InterlockedIncrement(&m_lSelectInterrupts) == 0) {
            if (_I_send != NULL) {
#if INET_DEBUG
                int nSent =
#endif
                _I_send(m_SelectSocket, gszBang, 1, 0);

#if INET_DEBUG
                if (nSent < 0) {

                    DWORD error = _I_WSAGetLastError();

                    DEBUG_PRINT(ASYNC,
                                INFO,
                                ("send(%#x) returns %s (%d)\n",
                                m_SelectSocket,
                                InternetMapError(error),
                                error
                                ));

                }

                INET_ASSERT(!InDllCleanup ? (nSent == 1) : TRUE);
#endif
            }
        } else {
            InterlockedDecrement(&m_lSelectInterrupts);

            DEBUG_PRINT(ASYNC,
                        INFO,
                        ("select() already interrupted, count = %d\n",
                        m_lSelectInterrupts
                        ));

        }
    } else {

        DEBUG_PRINT(ASYNC,
                    WARNING,
                    ("select socket not yet created\n"
                    ));

    }

    DEBUG_LEAVE(0);
}


BOOL
ICAsyncThread::DrainSelectSocket(
    VOID
    )

/*++

Routine Description:

    Just reads the data written to the async select socket in order to wake up
    select()

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - successfully drained

        FALSE   - error occurred

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Bool,
                 "ICAsyncThread::DrainSelectSocket",
                 NULL
                 ));

    BOOL bSuccess = TRUE;

    if (m_SelectSocket != INVALID_SOCKET) {

        //
        // reduce the interrupt count. Threads making async requests will cause
        // the select() to be interrupted again
        //

        InterlockedDecrement(&m_lSelectInterrupts);

        char buf[32];
        int nReceived;

        nReceived = _I_recv(m_SelectSocket, buf, sizeof(buf), 0);

#ifdef unix
        if(nReceived > -1)
        {
#endif /* unix */

        //INET_ASSERT(nReceived == 1);
        //INET_ASSERT(buf[0] == '!');

#ifdef unix
        }
#endif /* unix */

        if (nReceived < 0) {

            DWORD error = _I_WSAGetLastError();

            INET_ASSERT(error != ERROR_SUCCESS);

            DEBUG_PRINT(ASYNC,
                        ERROR,
                        ("recv() returns %s [%d]\n",
                        InternetMapError(error),
                        error
                        ));

            bSuccess = FALSE;
        }
    } else {

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("m_SelectSocket == INVALID_SOCKET\n"
                    ));

        bSuccess = FALSE;
    }

    DEBUG_LEAVE(bSuccess);

    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\common\handle.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    handle.cxx

Abstract:

    Contains functions to allocate and deallocate handle values

    Contents:
        HandleInitialize
        HandleTerminate
        AllocateHandle
        FreeHandle
        MapHandleToAddress
        DereferenceObject

Author:

    Richard L Firth (rfirth) 31-Oct-1994

Revision History:

    12-Mar-2001 rajeevd
        Gutted

    11-Jan-1996 rfirth
        Use fixed memory instead of moveable (Win95 has a bug w/ LocalUnlock)

    31-Oct-1994 rfirth
        Created
--*/

#include <wininetp.h>


//
// private prototypes
//

DEBUG_ONLY (PRIVATE void LogHandleClassSizes(); )

//
// functions
//

DWORD HandleInitialize (VOID)
{
    DEBUG_ONLY (LogHandleClassSizes(); )
    return ERROR_SUCCESS;
}


VOID HandleTerminate(VOID)
{
    // nothing to do
}


DWORD AllocateHandle (IN LPVOID Address,OUT LPHINTERNET lpHandle)
{
    HINTERNET Handle = (HINTERNET) Address;
    *lpHandle = Handle;
    return ERROR_SUCCESS;
}


DWORD FreeHandle(IN HINTERNET Handle)
{
    return ERROR_SUCCESS;
}


DWORD
MapHandleToAddress(
    IN HINTERNET Handle,
    OUT LPVOID * lpAddress,
    IN BOOL Invalidate
    )

/*++

Routine Description:

    The handle object represented by Handle is referenced

    Assumes:    1. only HINTERNETs visible at the API are presented to this
                   function.
                   
Arguments:

    Handle      - handle value generated by AllocateHandle()

    lpAddress   - place to store mapped address. If the handle has been closed
                  and unmapped, NULL is returned. If the handle is still
                  mapped, even though it has been invalidated, its address will
                  be returned, and its reference count incremented

    Invalidate  - TRUE if we are invalidating this handle

Return Value:

    LPVOID
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE
                    if *lpAddress == NULL then the handle has been closed and
                    unmapped, else it is still mapped, but invalidated. In
                    this case, we incremented the reference count

--*/

{
    DEBUG_ENTER((DBG_HANDLE,
                Dword,
                "MapHandleToAddress",
                "%#x, %#x, %B",
                Handle,
                lpAddress,
                Invalidate
                ));

    DWORD error;

    // Cast the handle to an address and validate
    LPVOID address = (LPVOID) Handle;
    if (address)
    {
        error = ((HANDLE_OBJECT *)address)->IsValid(TypeWildHandle);
    }
    else
    {
        error = ERROR_INVALID_HANDLE;
    }
    
    if (error != ERROR_SUCCESS)
    {
        DEBUG_PRINT(HANDLE,
                    ERROR,
                    ("invalid handle object: %#x [%#x]\n",
                    Handle,
                    address
                    ));
        error = ERROR_INVALID_HANDLE;
        address = NULL;
        goto quit;
    }

    // Attempt to increment the reference count on the handle.
    
    error = ((HANDLE_OBJECT *)address)->Reference();
    DEBUG_PRINT(HANDLE, ERROR, ("Reference() returns %d\n", error));
    switch (error)
    {
        case ERROR_SUCCESS: // handle was refcounted but is not tombstoned

            if (Invalidate)
            {
                // we were called from a handle close API.
                // Subsequent API calls will discover that the
                // handle is already invalidated and will quit
                ((HANDLE_OBJECT *)address)->Invalidate();
            }
            break;

        case ERROR_INVALID_HANDLE: // handle was refcounted but was tombstoned.
        
            break;

        default:
            INET_ASSERT (false);

        // intentional fall through
            
        case ERROR_ACCESS_DENIED: // handle is being destroyed
            
            DEBUG_PRINT(HANDLE,
                        ERROR,
                        ("Reference() failed - handle %#x [%#x] about to be deleted\n",
                        Handle,
                        address
                        ));
                        
            error = ERROR_INVALID_HANDLE;
            address = NULL;
            break;
    }

 quit:
    *lpAddress = address;
    DEBUG_LEAVE(error);
    return error;
}


DWORD
DereferenceObject(
    IN LPVOID lpObject
    )

/*++

Routine Description:

    Undoes the reference added to the handle object by MapHandleToAddress(). May
    result in the handle object being deleted

Arguments:

    lpObject    - address of object to dereference. This MUST be the mapped
                  object address as returned by MapHandleToAddress()

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    The handle object was destroyed

        Failure - ERROR_INVALID_HANDLE
                    The object was not a valid handle

--*/

{
    DEBUG_ENTER((DBG_HANDLE,
                Dword,
                "DereferenceObject",
                "%#x",
                lpObject
                ));

    INET_ASSERT(lpObject != NULL);

    HANDLE_OBJECT * object = (HANDLE_OBJECT *)lpObject;
    DWORD error = object->IsValid(TypeWildHandle);

    // Serialize with MapHandleToAddress
    
    if (error == ERROR_SUCCESS)
    {
        object->Dereference();
    }
    else
    {
        //
        // IsValid() should never return an error if the reference counts
        // are correct
        //
        INET_ASSERT(FALSE);
    }

    DEBUG_LEAVE(error);

    return error;
}


#if INET_DEBUG
PRIVATE
void
LogHandleClassSizes()
{
    DEBUG_PRINT(HANDLE,
                INFO,
                ("sizeof(HANDLE_OBJECT)                  = %d bytes\n",
                 sizeof(HANDLE_OBJECT)
                ));
    DEBUG_PRINT(HANDLE,
                INFO,
                ("sizeof(INTERNET_HANDLE_OBJECT)         = %d bytes\n",
                 sizeof(INTERNET_HANDLE_OBJECT)
                ));
    DEBUG_PRINT(HANDLE,
                INFO,
                ("sizeof(INTERNET_CONNECT_HANDLE_OBJECT) = %d bytes\n",
                 sizeof(INTERNET_CONNECT_HANDLE_OBJECT)
                ));
    DEBUG_PRINT(HANDLE,
                INFO,
                ("sizeof(HTTP_REQUEST_HANDLE_OBJECT)     = %d bytes\n",
                 sizeof(HTTP_REQUEST_HANDLE_OBJECT)
                ));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\common\fsm.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    fsm.cxx

Abstract:

    Contains CFsm class implementation

    Contents:
        ContainingFsm
        DoFsm
        CFsm::CFsm
        CFsm::~CFsm
        CFsm::Push
        CFsm::Pop
        CFsm::QueueWorkItem
        CFsm::RunWorkItem
        CFsm::Run
        [CFsm::MapType]
        [CFsm::StateName]

Author:

     Richard L Firth (rfirth) 11-Apr-1997

Environment:

    Win32 user-mode DLL

Revision History:

    11-Apr-1997 rfirth
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

#ifdef USE_DINARES_FSM_ALLOC_CACHE

CCritSec                FsmAllocCritSec;
void *                  FsmAllocList;
size_t                  FsmAllocSize;

#endif

#if INET_DEBUG

struct { int size; char* name; } class_sizes[] = {
    sizeof(CFsm), "CFsm",
    sizeof(CFsm_ResolveHost), "CFsm_ResolveHost",
    sizeof(CFsm_InternetParseUrl), "CFsm_InternetParseUrl",
    sizeof(CFsm_InternetQueryDataAvailable), "CFsm_InternetQueryDataAvailable",
    sizeof(CFsm_InternetWriteFile), "CFsm_InternetWriteFile",
    sizeof(CFsm_InternetReadFile), "CFsm_InternetReadFile",
    sizeof(CFsm_SocketConnect), "CFsm_SocketConnect",
    sizeof(CFsm_SocketSend), "CFsm_SocketSend",
    sizeof(CFsm_SocketReceive), "CFsm_SocketReceive",
    //sizeof(CFsm_SocketDataAvailable), "CFsm_SocketDataAvailable",
    sizeof(CFsm_SecureConnect), "CFsm_SecureConnect",
    sizeof(CFsm_SecureHandshake), "CFsm_SecureHandshake",
    sizeof(CFsm_SecureNegotiate), "CFsm_SecureNegotiate",
    sizeof(CFsm_NegotiateLoop), "CFsm_NegotiateLoop",
    sizeof(CFsm_SecureSend), "CFsm_SecureSend",
    sizeof(CFsm_SecureReceive), "CFsm_SecureReceive",
    sizeof(CFsm_GetConnection), "CFsm_GetConnection",
    sizeof(CFsm_HttpSendRequest), "CFsm_HttpSendRequest",
    sizeof(CFsm_MakeConnection), "CFsm_MakeConnection",
    sizeof(CFsm_OpenConnection), "CFsm_OpenConnection",
    sizeof(CFsm_OpenProxyTunnel), "CFsm_OpenProxyTunnel",
    sizeof(CFsm_SendRequest), "CFsm_SendRequest",
    sizeof(CFsm_ReceiveResponse), "CFsm_ReceiveResponse",
    sizeof(CFsm_HttpReadData), "CFsm_HttpReadData",
    sizeof(CFsm_HttpWriteData), "CFsm_HttpWriteData",
    sizeof(CFsm_ReadData), "CFsm_ReadData",
    sizeof(CFsm_HttpQueryAvailable), "CFsm_HttpQueryAvailable",
    sizeof(CFsm_DrainResponse), "CFsm_DrainResponse",
    sizeof(CFsm_Redirect), "CFsm_Redirect",
    sizeof(CFsm_ReadLoop), "CFsm_ReadLoop",
    sizeof(CFsm_ParseHttpUrl), "CFsm_ParseHttpUrl",
    sizeof(CFsm_OpenUrl), "CFsm_OpenUrl",
    sizeof(CFsm_ParseUrlForHttp), "CFsm_ParseUrlForHttp",
    sizeof(CFsm_ReadFile), "CFsm_ReadFile",
    sizeof(CFsm_ReadFileEx), "CFsm_ReadFileEx",
    //sizeof(CFsm_WriteFile), "CFsm_WriteFile",
    sizeof(CFsm_BackgroundTask), "CFsm_BackgroundTask",
    sizeof(CFsm_QueryAvailable), "CFsm_QueryAvailable"
};

void dump_class_sizes() {
    for (int i = 0; i < ARRAY_ELEMENTS(class_sizes); ++i) {
        DEBUG_PRINT(ASYNC,INFO,("%s = %d\n", class_sizes[i].name, class_sizes[i].size));
    }
}

#endif

//
// functions
//

//
// This is Dinarte's experiement for reducing Mem alloc on
//  creating FSMs.
//

#ifdef USE_DINARES_FSM_ALLOC_CACHE


VOID
FsmInitialize(
    VOID
    )

/*++

Routine Description:

    Performs initialization required by functions in this module

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - return code from LocalAlloc

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                None,
                "FsmInitialize",
                NULL
                ));

    FsmAllocCritSec.Init();

    FsmAllocSize = sizeof(CFsm);
    if (FsmAllocSize < sizeof(CFsm_ResolveHost))
        FsmAllocSize = sizeof(CFsm_ResolveHost);
    if (FsmAllocSize < sizeof(CFsm_SocketConnect))
        FsmAllocSize = sizeof(CFsm_SocketConnect);
    if (FsmAllocSize < sizeof(CFsm_SocketSend))
        FsmAllocSize = sizeof(CFsm_SocketSend);
    if (FsmAllocSize < sizeof(CFsm_SocketReceive))
        FsmAllocSize = sizeof(CFsm_SocketReceive);
    if (FsmAllocSize < sizeof(CFsm_SecureConnect))
        FsmAllocSize = sizeof(CFsm_SecureConnect);
    if (FsmAllocSize < sizeof(CFsm_SecureHandshake))
        FsmAllocSize = sizeof(CFsm_SecureHandshake);
    if (FsmAllocSize < sizeof(CFsm_SecureNegotiate))
        FsmAllocSize = sizeof(CFsm_SecureNegotiate);
    if (FsmAllocSize < sizeof(CFsm_NegotiateLoop))
        FsmAllocSize = sizeof(CFsm_NegotiateLoop);
    if (FsmAllocSize < sizeof(CFsm_SecureSend))
        FsmAllocSize = sizeof(CFsm_SecureSend);
    if (FsmAllocSize < sizeof(CFsm_SecureReceive))
        FsmAllocSize = sizeof(CFsm_SecureReceive);
    if (FsmAllocSize < sizeof(CFsm_GetConnection))
        FsmAllocSize = sizeof(CFsm_GetConnection);
    if (FsmAllocSize < sizeof(CFsm_HttpSendRequest))
        FsmAllocSize = sizeof(CFsm_HttpSendRequest);
    if (FsmAllocSize < sizeof(CFsm_MakeConnection))
        FsmAllocSize = sizeof(CFsm_MakeConnection);
    if (FsmAllocSize < sizeof(CFsm_OpenConnection))
        FsmAllocSize = sizeof(CFsm_OpenConnection);
    if (FsmAllocSize < sizeof(CFsm_OpenProxyTunnel))
        FsmAllocSize = sizeof(CFsm_OpenProxyTunnel);
    if (FsmAllocSize < sizeof(CFsm_SendRequest))
        FsmAllocSize = sizeof(CFsm_SendRequest);
    if (FsmAllocSize < sizeof(CFsm_ReceiveResponse))
        FsmAllocSize = sizeof(CFsm_ReceiveResponse);
    if (FsmAllocSize < sizeof(CFsm_HttpReadData))
        FsmAllocSize = sizeof(CFsm_HttpReadData);
    if (FsmAllocSize < sizeof(CFsm_HttpWriteData))
        FsmAllocSize = sizeof(CFsm_HttpWriteData);
    if (FsmAllocSize < sizeof(CFsm_ReadData))
        FsmAllocSize = sizeof(CFsm_ReadData);
    if (FsmAllocSize < sizeof(CFsm_HttpQueryAvailable))
        FsmAllocSize = sizeof(CFsm_HttpQueryAvailable);
    if (FsmAllocSize < sizeof(CFsm_DrainResponse))
        FsmAllocSize = sizeof(CFsm_DrainResponse);
    if (FsmAllocSize < sizeof(CFsm_Redirect))
        FsmAllocSize = sizeof(CFsm_Redirect);
    if (FsmAllocSize < sizeof(CFsm_ReadLoop))
        FsmAllocSize = sizeof(CFsm_ReadLoop);
    if (FsmAllocSize < sizeof(CFsm_ParseHttpUrl))
        FsmAllocSize = sizeof(CFsm_ParseHttpUrl);
    if (FsmAllocSize < sizeof(CFsm_OpenUrl))
        FsmAllocSize = sizeof(CFsm_OpenUrl);
    if (FsmAllocSize < sizeof(CFsm_ParseUrlForHttp))
        FsmAllocSize = sizeof(CFsm_ParseUrlForHttp);
    if (FsmAllocSize < sizeof(CFsm_ReadFile))
        FsmAllocSize = sizeof(CFsm_ReadFile);
    if (FsmAllocSize < sizeof(CFsm_ReadFileEx))
        FsmAllocSize = sizeof(CFsm_ReadFileEx);
    if (FsmAllocSize < sizeof(CFsm_QueryAvailable))
        FsmAllocSize = sizeof(CFsm_QueryAvailable);

    //
    // Pre-allocate a pool of state-machines for locality of reference
    //

    for (int cPreAlloc = 8192 / FsmAllocSize; cPreAlloc > 0; --cPreAlloc)
    {
        void * pFsm = (void *)ALLOCATE_FIXED_MEMORY(FsmAllocSize);

        if (pFsm == NULL)
            break;

        *(void **)pFsm = FsmAllocList;
        FsmAllocList = pFsm;
    }
}


VOID
FsmTerminate(
    VOID
    )

/*++

Routine Description:

    Obverse of FsmInitialize - frees any system resources allocated by
    FsmInitialize

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                None,
                "FsmTerminate",
                NULL
                ));

    //
    // there shouldn't be any other threads active when this function is called
    // but we'll grab the critical section anyway, just to make sure
    //

    if (FsmAllocCritSec.Lock())
    {

        while (FsmAllocList)
        {
            void * pFsm = FsmAllocList;
            FsmAllocList = *(void **)pFsm;
            FREE_MEMORY((HLOCAL)pFsm);
        }

        FsmAllocCritSec.Unlock();
    }

    //
    // delete the critical section
    //

    FsmAllocCritSec.FreeLock();

    DEBUG_LEAVE(0);
}

#endif


CFsm *
ContainingFsm(
    IN LPVOID lpAddress
    )

/*++

Routine Description:

    Returns address of start of CFsm object, including vtable

Arguments:

    lpAddress   - pointer to list inside CFsm object

Return Value:

    CFsm *  - pointer to start of object

--*/

{
    return CONTAINING_RECORD(lpAddress, CFsm, m_ListEntry);
}


//DWORD
//RunAll(
//    VOID
//    )
//{
//    DWORD error;
//    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
//
//    if (lpThreadInfo != NULL) {
//        while (lpThreadInfo->Fsm != NULL) {
//            lpThreadInfo->Fsm->Run();
//        }
//    } else {
//        error = ERROR_WINHTTP_INTERNAL_ERROR;
//    }
//    return error;
//}


DWORD
DoFsm(
    IN CFsm * pFsm
    )

/*++

Routine Description:

    Common FSM run processing

Arguments:

    pFsm    - FSM to run (maybe NULL if new failed)

Return Value:

    DWORD   - return code from running FSM

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "DoFsm",
                 "%#x (%s)",
                 pFsm,
                 pFsm->MapType()
                 ));

    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    INET_ASSERT(lpThreadInfo != NULL);

    if (lpThreadInfo != NULL) {
        if (pFsm != NULL) {
            error = pFsm->GetError();
            if (error == ERROR_SUCCESS) {
                error = pFsm->Run(lpThreadInfo, NULL, NULL);
            } else {

                INET_ASSERT(FALSE);

                delete pFsm;
            }
        } else {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
DoAsyncFsm(
    IN CFsm * pFsm,
    IN HTTP_REQUEST_HANDLE_OBJECT *pRequest
    )

/*++

Routine Description:

    Common FSM run processing for asynchronous requests which
    are starting new fsm chains.

Arguments:

    pFsm     - FSM to run (maybe NULL if new failed)

    pRequest - When not NULL, the FSM will be checked and placed
               into a blocked queue if an async work item on the
               request item is already in progress.  It's assumed
               this is only called for async request objects.

Return Value:

    DWORD   - return code from running FSM

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "DoAsyncFsm",
                 "%#x (%s)",
                 pFsm,
                 pFsm->MapType()
                 ));

    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    INET_ASSERT(lpThreadInfo != NULL);

    if (lpThreadInfo != NULL) {
        if (pFsm != NULL) {
            error = pFsm->GetError();
            if (error == ERROR_SUCCESS) {
                if (pRequest) {
                    if (pRequest->LockAsync())
                    {
                        if (pRequest->IsWorkItemInProgress())
                        {
                            // Wait until current and blocked work items are finished.
                            error = pRequest->BlockWorkItem(pFsm);
                            if (error == ERROR_SUCCESS)
                            {
                                error = ERROR_IO_PENDING;
                            }
                        }
                        else
                        {
                            pRequest->SetWorkItemInProgress(TRUE);
                            pFsm->SetPushPop(TRUE);
                            pFsm->Push();
                            error = pFsm->QueueWorkItem();
                        }
                        pRequest->UnlockAsync();
                    }
                    else
                    {
                        delete pFsm;
                        pFsm = NULL;
                        error = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
                else {
                    error = pFsm->Run(lpThreadInfo, NULL, NULL);
                }
            } else {

                INET_ASSERT(FALSE);

                delete pFsm;
            }
        } else {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
    }

    DEBUG_LEAVE(error);

    return error;
}


//
// methods
//


//
// This is Dinarte's experiement for reducing Mem alloc on
//  creating FSMs. Not used right now.
//

#ifdef USE_DINARES_FSM_ALLOC_CACHE


void *
CFsm::operator new(
    IN size_t Size
    )

/*++

Routine Description:

    Allocates memory for the new state-machine from a special memory pool.

Arguments:

    Size        - size of the state-machine

Return Value:

    None.

--*/

{
    VOID * pFsm = NULL;

    if (FsmAllocCritSec.Lock())
    {
        // Only alloc from the list if we can synchronize access to it.

        pFsm = FsmAllocList;

        if (pFsm)
        {
            FsmAllocList = *(void **)pFsm;
        }

        FsmAllocCritSec.Unlock();
    }

    if (pFsm == NULL)
    {
        INET_ASSERT(Size <= FsmAllocSize);

        pFsm = (void *)ALLOCATE_FIXED_MEMORY(FsmAllocSize);
    }

    return(pFsm);
}


VOID
CFsm::operator delete(
    IN VOID * pFsm
    )

/*++

Routine Description:

    Deallocates memory for the state-machine by adding it to a special
    memory pool.

Arguments:

    pFsm        - pointer to the state-machine

Return Value:

    None.

--*/

{
    if (pFsm)
    {
        if (FsmAllocCritSec.Lock())
        {
            *(void **)pFsm = FsmAllocList;
            FsmAllocList = pFsm;

            FsmAllocCritSec.Unlock();
        }
        // else leak?
    }
}
#endif


CFsm::CFsm(
    IN DWORD (* lpfnHandler)(CFsm *),
    IN LPVOID lpvContext,
    IN BOOL fPushPop /* = TRUE */
    ) : CPriorityListEntry(0)

/*++

Routine Description:

    CFsm constructor. This gets called many times since its the base of all the
    derived FSMs

Arguments:

    lpfnHandler - state-machine handler

    lpvContext  - callee context

Return Value:

    None.

--*/

{
#if INET_DEBUG
    static bool b = TRUE;
    if (b) {
        dump_class_sizes();
        b=FALSE;
    }
#endif

    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "CFsm::CFsm",
                 "{%#x}",
                 this
                 ));

    INIT_FSM();

    m_lpThreadInfo = InternetGetThreadInfo();
    if (m_lpThreadInfo == NULL) {

        INET_ASSERT(m_lpThreadInfo != NULL);

        SetError(ERROR_WINHTTP_INTERNAL_ERROR);

        DEBUG_LEAVE(0);

        return;
    }
    m_hObject = m_lpThreadInfo->hObject;
    m_hObjectMapped = (INTERNET_HANDLE_OBJECT *)m_lpThreadInfo->hObjectMapped;
    m_dwContext = m_hObjectMapped->GetContext();
    m_dwMappedErrorCode = m_lpThreadInfo->dwMappedErrorCode;
    m_State = FSM_STATE_INIT;
    m_NextState = FSM_STATE_CONTINUE;
    m_FunctionState = FSM_STATE_BAD;
    m_lpfnHandler = lpfnHandler;
    m_lpvContext = lpvContext;
    SetError(ERROR_SUCCESS);
    m_bPushPop = fPushPop;
    if (fPushPop)
        Push();
    m_Hint = FSM_HINT_SLOW;
    m_Socket = INVALID_SOCKET;
    m_Action = FSM_ACTION_NONE;
    m_dwBlockId = 0;
    m_dwTimeout = INFINITE;
    m_fTimeoutWraps = FALSE;
    m_dwTimer = 0;
    m_bTimerStarted = FALSE;
    m_bIsBlockingFsm = FALSE;
    m_bIsApi = FALSE;
    m_ApiType = ApiType_None;
    m_dwApiData = 0;
    m_ApiResult.Handle = NULL;
    m_bHasTimeout = FALSE;
    m_bOnAsyncList = FALSE;

    DEBUG_LEAVE(0);
}


CFsm::~CFsm()

/*++

Routine Description:

    CFsm desctructor

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "CFsm::~CFsm",
                 "{%#x}",
                 this
                 ));

    CHECK_FSM();
    CHECK_OWNED();

    if (m_bPushPop)
        Pop();    

#ifdef STRESS_BUG_DEBUG
    m_Link = (CFsm *) (DWORD_PTR) 0xFEFEFEFE;
    m_dwError = 0xFEFEFEFE;
    m_lpThreadInfo = (LPINTERNET_THREAD_INFO) (DWORD_PTR) 0xFEFEFEFE;
    m_dwContext = 0xFEFEFEFE;
    m_hObject = (HINTERNET)(DWORD_PTR) 0xFEFEFEFE;
#endif

    DEBUG_LEAVE(0);
}


VOID
CFsm::Push(
    VOID
    )

/*++

Routine Description:

    Adds this FSM to the head of the queue

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "CFsm::Push",
                 "{%#x (%s:%s)}",
                 this,
                 MapState(),
                 MapFunctionState()
                 ));

    CHECK_FSM();
    CHECK_UNOWNED();
    INET_ASSERT(m_lpThreadInfo != NULL);
    CHECK_INTERNET_THREAD_INFO(m_lpThreadInfo);

    m_Link = m_lpThreadInfo->Fsm;
    m_lpThreadInfo->Fsm = this;

    CHECK_FSM_OWNED(m_Link);
    RESET_FSM_OWNED(m_Link);

    DEBUG_PRINT(ASYNC,
                INFO,
                ("!!! FSM %#x unowned\n", m_Link
                ));

    SET_OWNED();

    DEBUG_PRINT(ASYNC,
                INFO,
                ("!!! FSM %#x owned by %#x\n",
                this,
                GetCurrentThreadId()
                ));

    DEBUG_LEAVE(0);
}


VOID
CFsm::Pop(
    VOID
    )

/*++

Routine Description:

    Puts the next FSM (if any) at the head of the queue

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "CFsm::Pop",
                 "{%#x (%s:%s)}",
                 this,
                 MapState(),
                 MapFunctionState()
                 ));

    INET_ASSERT(m_lpThreadInfo != NULL);
    CHECK_INTERNET_THREAD_INFO(m_lpThreadInfo);
    CHECK_FSM();
    CHECK_OWNED();
    CHECK_FSM_UNOWNED(m_Link);

    CFsm * pNextFsm = m_Link;

    m_lpThreadInfo->Fsm = pNextFsm;

    SET_FSM_OWNED(pNextFsm);

    DEBUG_PRINT(ASYNC,
                INFO,
                ("!!! FSM %#x owned by %#x\n",
                pNextFsm,
                GetCurrentThreadId()
                ));

    if (pNextFsm != NULL) {
        pNextFsm->SetState(pNextFsm->GetNextState());
        pNextFsm->SetError(GetError());

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("next FSM %#x (%s), state %s, function-state %s\n",
                    pNextFsm,
                    pNextFsm->MapType(),
                    pNextFsm->MapState(),
                    pNextFsm->MapFunctionState()
                    ));

    } else {

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("last FSM\n"
                    ));

    }

    DEBUG_LEAVE(0);
}


DWORD
CFsm::QueueWorkItem(
    VOID
    )

/*++

Routine Description:

    Queues this FSM to worker thread for processing. Worker thread callback is
    CFsm::RunWorkItem

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - return code from SHQueueUserWorkItem

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "CFsm::QueueWorkItem",
                 "{%#x [%s, socket %#x, block id %#x, timeout %#x, error %d, state %s:%s]}",
                 this,
                 MapType(),
                 GetSocket(),
                 GetBlockId(),
                 GetTimeout(),
                 GetError(),
                 MapState(),
                 MapFunctionState()
                 ));

    DWORD error = ERROR_IO_PENDING;

    RESET_OWNED();
    
    DEBUG_PRINT(SOCKETS,
                INFO,
                ("Posting IO completion with 0x%x\n",
                this
                ));


    DEBUG_ENTER((DBG_API,
                     Bool,
                     "***PostQueuedCompletionStatus",
                     "(hComp)%#x, (# bytes)%#x, (completionkey)%#x, (overlapped)%#x",
                     g_hCompletionPort,
                     COMPLETION_BYTES_CUSTOM,
                     this,
                     g_lpCustomOverlapped
                     ));

    if (PostQueuedCompletionStatus(g_hCompletionPort,
                                    COMPLETION_BYTES_CUSTOM,
                                    ULONG_PTR (this),
                                    g_lpCustomOverlapped
                                    ))
    {
        DEBUG_LEAVE(TRUE);  
#if INET_DEBUG
        InterlockedIncrement(&g_cCustomCompletions);
#endif
        LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

        INET_ASSERT(lpThreadInfo != NULL);

        if (lpThreadInfo != NULL)
            lpThreadInfo->Fsm = NULL;
    }
    else
    {
        DEBUG_LEAVE(FALSE);  
        
        error = GetLastError();
    }

    INET_ASSERT(error == ERROR_IO_PENDING);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm::RunWorkItem(
    IN CFsm * pFsm
    )

/*++

Routine Description:

    Run the current work item to the next block state or completion. This
    (class static) function is called in the context of a system thread pool
    callback function

Arguments:

    pFsm    - pointer to FSM to run

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_INTERNAL_ERROR

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    INET_ASSERT(lpThreadInfo != NULL);

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        return ERROR_WINHTTP_INTERNAL_ERROR;
    }

    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "RunWorkItem",
                 "%#x",
                 pFsm
                 ));

    PERF_ENTER(Worker);

    DWORD error;

    DEBUG_PRINT(ASYNC,
                INFO,
                ("%s Fsm %#x: socket %#x, block id %#x, timeout %#x, error %d\n",
                pFsm->MapType(),
                pFsm,
                pFsm->GetSocket(),
                pFsm->GetBlockId(),
                pFsm->GetTimeout(),
                pFsm->GetError()
                ));

    INTERNET_HANDLE_BASE *pSession = (INTERNET_HANDLE_BASE *)(pFsm->GetMappedHandle());
    HANDLE ThreadToken = pSession->GetThreadToken();
    HANDLE ThreadHandle = GetCurrentThread();
    if (ThreadToken)
    {
        if (::SetThreadToken(&ThreadHandle,
                         &ThreadToken) == FALSE)
        {
            ThreadToken = 0;
        }

    }

    while (TRUE) {

        INET_ASSERT(pFsm != NULL);

        BOOL bIsApi = pFsm->IsApi();
        API_TYPE apiType = pFsm->GetApiType();
        FSM_TYPE fsmType = pFsm->GetType();

        lpThreadInfo->Fsm = pFsm;

        SET_FSM_OWNED(pFsm);

        // We could pass back a pointer from CFsm::Run in the case of READ_COMPLETE, so to account for
        // 64-bit, we need a bigger area:
        LPVOID      dwResultExtended = 0;
        DWORD       &dwResult= *(DWORD *)&dwResultExtended;
        DWORD       dwApiData= 0;

        if (pFsm->IsInvalid())
        {
            pFsm->SetErrorState(ERROR_WINHTTP_OPERATION_CANCELLED);
            pFsm->Run(lpThreadInfo, &dwResult, &dwApiData);
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
        }
        else
        {
            error = pFsm->Run(lpThreadInfo, &dwResult, &dwApiData);
        }

        //
        // We should follow the following rules for this.
        //
        //  1)  If Operation Failed
        //
        //      error != ERROR_SUCCESS && dwResult == 0
        //
        //  To assign fields of INTERNET_ASYNC_RESULT, do:
        //
        //      INTERNET_ASYNC_RESULT.dwResult = 0
        //      INTERNET_ASYNC_RESULT.dwError = error
                
        //  2) If operation Succeeded
        //
        //  error == ERROR_SUCCESS && dwResult != 0
        //
        //  To assign fields of INTERNET_ASYNC_RESULT, do:
        //
        //      if( ApiReturnType == HINTERNET )
        //          INTERNET_ASYNC_RESULT.dwResult = (HINTERNET)dwApiResult
        //      else
        //          if( ApiReturnType == BOOL )
        //              INTERNET_ASYNC_RESULT.dwResult = TRUE
        //          endif
        //      endif
        //
        //      INTERNET_ASYNC_RESULT.dwError = dwApiData

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("dwResult = %d [%#x], dwApiData=%d [%#x], apiType = %s, error = %d\n",
                    dwResult, dwResult,
                    dwApiData, dwApiData,
                    (apiType==ApiType_Handle)?"HANDLE":"BOOL",
                    error));



        if (error == ERROR_IO_PENDING) {
            break;
        }
        pFsm = lpThreadInfo->Fsm;
        if (pFsm == NULL) {
            if (bIsApi
            && ((INTERNET_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)
                ->IsAsyncHandle()) {

                INET_ASSERT((apiType == ApiType_Handle)
                            || (apiType == ApiType_Bool));

                WINHTTP_ASYNC_RESULT asyncResult;


		/*
                asyncResult.dwResult = (apiType == ApiType_Handle)
                                     ? dwResult
                                     : (BOOL)(error == ERROR_SUCCESS);
		*/

                asyncResult.dwResult = (error == ERROR_SUCCESS
                                            ?((apiType == ApiType_Handle)
                                                ? dwResult
                                                : TRUE)
                                            :0);

                //
                // InternetQueryDataAvailable uses dwApiData to return the
                // number of bytes available, in addition to returning the
                // the value through the lpdwNumberOfBytesAvailable parameter
                //

                asyncResult.dwError = (error == ERROR_SUCCESS)
                                        ? dwApiData
                                        : error;
                SetLastError(error);

                //INET_ASSERT(((INTERNET_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)
                //            ->GetObjectType() == TypeHttpRequestHandle);

                DWORD dwStatus;
                DWORD dwFailureAPI = API_UNKNOWN;

                LPVOID lpvStatusInformation = (LPVOID)&asyncResult;
                DWORD dwStatusInformationLength = sizeof(asyncResult);
                switch(fsmType)
                {
                    case FSM_TYPE_HTTP_SEND_REQUEST:
                        if (dwResult == AR_HTTP_BEGIN_SEND_REQUEST)
                        {
                            dwStatus = WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE;
                            dwFailureAPI = API_SEND_REQUEST;
                        }
                        else
                        {
                            dwStatus = WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE;
                            dwFailureAPI = API_RECEIVE_RESPONSE;
                        }
                        break;
                        
                    case FSM_TYPE_QUERY_DATA_AVAILABLE:
                        dwStatus = WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE;
                        if(error == ERROR_SUCCESS)
                        {
                            lpvStatusInformation = NULL;
                            dwStatusInformationLength = dwApiData;
                        }
                        else
                            dwFailureAPI = API_QUERY_DATA_AVAILABLE;
                        
                        break;
                    

                    // completion for WinHttpReadData:
                    case FSM_TYPE_READ_FILE:
                        dwStatus = WINHTTP_CALLBACK_STATUS_READ_COMPLETE;
                        if(error == ERROR_SUCCESS)
                        {
                            lpvStatusInformation = dwResultExtended;
                            dwStatusInformationLength = dwApiData;
                        }
                        else
                            dwFailureAPI = API_READ_DATA;
                       
                        break;
                    case FSM_TYPE_HTTP_WRITE:
                        dwStatus = WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE;
                        dwFailureAPI = API_WRITE_DATA;
                        break;
                    default:
                        // Shouldn't hit this, if it does, we should see if a more appropriate notification is needed:
                        INET_ASSERT(FALSE);
                        dwStatus = WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE;
                        break;
                }

                if(error != ERROR_SUCCESS)
                {
                    dwStatus = WINHTTP_CALLBACK_STATUS_REQUEST_ERROR;
                    asyncResult.dwResult = dwFailureAPI;
                    // asyncResult.dwError contains the error code as appropriate.
                }
                
                InternetIndicateStatus(dwStatus,
                                       lpvStatusInformation,
                                       dwStatusInformationLength
                                       );

                //INET_ASSERT(((INTERNET_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)
                //            ->GetObjectType() == TypeHttpRequestHandle);

                DereferenceObject((LPVOID)lpThreadInfo->hObjectMapped);
            }
            break;
        } else if (bIsApi) {

            //
            // completing an async API that is not the last in the chain.
            // Typically, HttpSendRequest() within InternetOpenUrl()
            //

            DereferenceObject((LPVOID)lpThreadInfo->hObjectMapped);
        }
    }

    if (ThreadToken)
    {
        RevertToSelf();
    }

    PERF_LEAVE(Worker);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm::Run(
    IN LPINTERNET_THREAD_INFO lpThreadInfo,
    OUT DWORD  *lpdwApiResult OPTIONAL,
    OUT DWORD  *lpdwApiData OPTIONAL
    )

/*++

Routine Description:

    Runs the state handler for this FSM

Arguments:

    lpThreadInfo    - INTERNET_THREAD_INFO for this thread

    lpdwApiResult   - where optional API result is written

    lpdwApiData     - where optional API data iswritten

Return Value:

    DWORD   - return code from state handler

--*/

{

    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "CFsm::Run",
                 "%#x, %#x [%#x], %#x [%#x]",
                 lpThreadInfo,
                 lpdwApiResult,
                 (lpdwApiResult?*lpdwApiResult:NULL),
                 lpdwApiData,
                 (lpdwApiData?*lpdwApiData:NULL)
                 ));

    CHECK_FSM();
    CHECK_OWNED();
    INET_ASSERT(lpThreadInfo != NULL);
    INET_ASSERT(lpThreadInfo->Fsm != NULL);

    DWORD error = ERROR_SUCCESS;

    _InternetSetObjectHandle(lpThreadInfo, m_hObject, m_hObjectMapped);

    m_lpThreadInfo = lpThreadInfo;

    while (TRUE) {

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("%s Fsm %#x state %s (%d) function-state %s (%d) error %s (%d)\n",
                    MapType(),
                    this,
                    MapState(),
                    GetState(),
                    MapFunctionState(),
                    GetFunctionState(),
                    InternetMapError(GetError()),
                    GetError()
                    ));

        error = (*m_lpfnHandler)(this);

        if (error == ERROR_IO_PENDING) {
            break;
        }
        
        SetError(error);
        SetMappedError(lpThreadInfo->dwMappedErrorCode);
        if (IsDone()) {

            DEBUG_PRINT(ASYNC,
                        INFO,
                        ("%s Fsm %#x done, next is %s %#x\n",
                        MapType(),
                        this,
                        m_Link ? m_Link->MapType() : "",
                        m_Link
                        ));

            if (lpdwApiResult != NULL) {
                *lpdwApiResult = GetApiResult();
            }
            if (lpdwApiData != NULL) {
                *lpdwApiData = GetApiData();
            }

            // This needs to happen only when the FSM is the top-level FSM, so we don't have to
            // touch the rest of the logic where CFsm::Run is called. We first save the values for
            // the FSMs we're interested in, in temporary variables. Then, once the FSM is destroyed
            // we check the LPINTERNET_THREAD_INFO to see if this was indeed the top-level-FSM.
            // If so, we jam the values saved into the parameters passed into Run. In this case,
            // we know that CFsm::RunWorkItem is the one that has called, so CFsm::RunWorkItem
            // knows how to interpret the values.

            // Stage#1:
            DWORD dwBytes = 0;
            LPVOID lpBufferExtended = 0;
            DWORD &lpBuffer = *(DWORD *)&lpBufferExtended;
            FSM_TYPE fsmType = GetType();
            if(fsmType == FSM_TYPE_HTTP_SEND_REQUEST)
                lpBuffer = (((CFsm_HttpSendRequest *)this)->m_arRequest);
                
            if(error == ERROR_SUCCESS)
            {
                switch(fsmType)
                {
                    case FSM_TYPE_QUERY_DATA_AVAILABLE:
                        dwBytes = *(((CFsm_QueryAvailable *)this)->m_lpdwNumberOfBytesAvailable);
                        break;

                    // completion for WinHttpReadData:
                    case FSM_TYPE_READ_FILE:
                        lpBufferExtended = (LPVOID) (((CFsm_ReadFile *)this)->m_lpBuffer);
                        dwBytes = *(((CFsm_ReadFile *)this)->m_lpdwNumberOfBytesRead);
                        break;
                }
            }
            // End Stage#1 

            DEBUG_PRINT(ASYNC,
                        INFO,
                        ("Fsm %#x finished with lpdwApiResult = %#x[%#x], lpdwApiData = %#x[%#x]\n",
                        this,
                		lpdwApiResult,
                		(lpdwApiResult == NULL)?NULL:*lpdwApiResult,
                		lpdwApiData,
                		(lpdwApiData == NULL)?NULL:*lpdwApiData
                		));

            INET_ASSERT (!IsOnAsyncList());
            delete this;

            // Stage#2:
            if (lpThreadInfo->Fsm == NULL) {
                // top-level completion:
                if(fsmType == FSM_TYPE_HTTP_SEND_REQUEST)
                    if (lpdwApiResult != NULL)
                        *lpdwApiResult = lpBuffer;
                    
                if(error == ERROR_SUCCESS)
                {
                    switch(fsmType)
                    {
                        case FSM_TYPE_QUERY_DATA_AVAILABLE:
                            if (lpdwApiData != NULL)
                                *lpdwApiData = dwBytes;
                            break;

                        // completion for WinHttpReadData:
                        case FSM_TYPE_READ_FILE:
                            if (lpdwApiResult != NULL)
                            {
                                LPVOID  &lpApiResultExtended = *(LPVOID *)lpdwApiResult;
                                lpApiResultExtended = lpBufferExtended;
                            }
                            if (lpdwApiData != NULL)
                                *lpdwApiData = dwBytes;
                            break;
                    }
                }
            }
            // End Stage#2


            break;
        }
        SetState(GetNextState());
    }

    DEBUG_LEAVE(error);

    return error;
}

#if INET_DEBUG

#if !defined(CASE_OF)
#define CASE_OF(x) case x: return #x
#endif

DEBUG_FUNCTION
LPSTR
CFsm::MapType(
    VOID
    ) {
    switch (m_Type) {
    case FSM_TYPE_NONE:                     return "NONE";
    case FSM_TYPE_WAIT_FOR_COMPLETION:      return "WAIT_FOR_COMPLETION";
    case FSM_TYPE_RESOLVE_HOST:             return "RESOLVE_HOST";
    case FSM_TYPE_SOCKET_CONNECT:           return "SOCKET_CONNECT";
    case FSM_TYPE_SOCKET_SEND:              return "SOCKET_SEND";
    case FSM_TYPE_SOCKET_RECEIVE:           return "SOCKET_RECEIVE";
    case FSM_TYPE_SOCKET_QUERY_AVAILABLE:   return "SOCKET_QUERY_AVAILABLE";
    case FSM_TYPE_SECURE_CONNECT:           return "SECURE_CONNECT";
    case FSM_TYPE_SECURE_HANDSHAKE:         return "SECURE_HANDSHAKE";
    case FSM_TYPE_SECURE_NEGOTIATE:         return "SECURE_NEGOTIATE";
    case FSM_TYPE_NEGOTIATE_LOOP:           return "NEGOTIATE_LOOP";
    case FSM_TYPE_SECURE_SEND:              return "SECURE_SEND";
    case FSM_TYPE_SECURE_RECEIVE:           return "SECURE_RECEIVE";
    case FSM_TYPE_GET_CONNECTION:           return "GET_CONNECTION";
    case FSM_TYPE_HTTP_SEND_REQUEST:        return "HTTP_SEND_REQUEST";
    case FSM_TYPE_MAKE_CONNECTION:          return "MAKE_CONNECTION";
    case FSM_TYPE_OPEN_CONNECTION:          return "OPEN_CONNECTION";
    case FSM_TYPE_OPEN_PROXY_TUNNEL:        return "OPEN_PROXY_TUNNEL";
    case FSM_TYPE_SEND_REQUEST:             return "SEND_REQUEST";
    case FSM_TYPE_RECEIVE_RESPONSE:         return "RECEIVE_RESPONSE";
    case FSM_TYPE_HTTP_READ:                return "HTTP_READ";
    case FSM_TYPE_HTTP_WRITE:               return "HTTP_WRITE";
    case FSM_TYPE_READ_DATA:                return "READ_DATA";
    case FSM_TYPE_HTTP_QUERY_AVAILABLE:     return "HTTP_QUERY_AVAILABLE";
    case FSM_TYPE_DRAIN_RESPONSE:           return "DRAIN_RESPONSE";
    case FSM_TYPE_REDIRECT:                 return "REDIRECT";
    case FSM_TYPE_READ_LOOP:                return "READ_LOOP";
    case FSM_TYPE_PARSE_HTTP_URL:           return "PARSE_HTTP_URL";
    case FSM_TYPE_PARSE_URL_FOR_HTTP:       return "PARSE_URL_FOR_HTTP";
    case FSM_TYPE_READ_FILE:                return "READ_FILE";
    case FSM_TYPE_READ_FILE_EX:             return "READ_FILE_EX";
    case FSM_TYPE_WRITE_FILE:               return "WRITE_FILE";
    case FSM_TYPE_QUERY_DATA_AVAILABLE:     return "QUERY_DATA_AVAILABLE";
    case FSM_TYPE_FTP_CONNECT:              return "FTP_CONNECT";
    case FSM_TYPE_FTP_FIND_FIRST_FILE:      return "FTP_FIND_FIRST_FILE";
    case FSM_TYPE_FTP_GET_FILE:             return "FTP_GET_FILE";
    case FSM_TYPE_FTP_PUT_FILE:             return "FTP_PUT_FILE";
    case FSM_TYPE_FTP_DELETE_FILE:          return "FTP_DELETE_FILE";
    case FSM_TYPE_FTP_RENAME_FILE:          return "FTP_RENAME_FILE";
    case FSM_TYPE_FTP_OPEN_FILE:            return "FTP_OPEN_FILE";
    case FSM_TYPE_FTP_CREATE_DIRECTORY:     return "FTP_CREATE_DIRECTORY";
    case FSM_TYPE_FTP_REMOVE_DIRECTORY:     return "FTP_REMOVE_DIRECTORY";
    case FSM_TYPE_FTP_SET_CURRENT_DIRECTORY:    return "FTP_SET_CURRENT_DIRECTORY";
    case FSM_TYPE_FTP_GET_CURRENT_DIRECTORY:    return "FTP_GET_CURRENT_DIRECTORY";
    case FSM_TYPE_GOPHER_FIND_FIRST_FILE:   return "GOPHER_FIND_FIRST_FILE";
    case FSM_TYPE_GOPHER_OPEN_FILE:         return "GOPHER_OPEN_FILE";
    case FSM_TYPE_GOPHER_GET_ATTRIBUTE:     return "GOPHER_GET_ATTRIBUTE";
    case FSM_TYPE_INTERNET_PARSE_URL:       return "INTERNET_PARSE_URL";
    case FSM_TYPE_INTERNET_FIND_NEXT_FILE:  return "INTERNET_FIND_NEXT_FILE";
    case FSM_TYPE_INTERNET_QUERY_DATA_AVAILABLE:    return "INTERNET_QUERY_DATA_AVAILABLE";
    case FSM_TYPE_INTERNET_WRITE_FILE:      return "INTERNET_WRITE_FILE";
    case FSM_TYPE_INTERNET_READ_FILE:       return "INTERNET_READ_FILE";
    }
    return "?";
}

DEBUG_FUNCTION
LPSTR
CFsm::StateName(
    IN DWORD State
    ) {
    switch (State) {
    CASE_OF(FSM_STATE_BAD);
    CASE_OF(FSM_STATE_INIT);
    CASE_OF(FSM_STATE_WAIT);
    CASE_OF(FSM_STATE_DONE);
    CASE_OF(FSM_STATE_ERROR);
    CASE_OF(FSM_STATE_CONTINUE);
    CASE_OF(FSM_STATE_FINISH);
    CASE_OF(FSM_STATE_1);
    CASE_OF(FSM_STATE_2);
    CASE_OF(FSM_STATE_3);
    CASE_OF(FSM_STATE_4);
    CASE_OF(FSM_STATE_5);
    CASE_OF(FSM_STATE_6);
    CASE_OF(FSM_STATE_7);
    CASE_OF(FSM_STATE_8);
    CASE_OF(FSM_STATE_9);
    CASE_OF(FSM_STATE_10);
    }
    return "?";
}

#endif // INET_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\common\icstring.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    icstring.hxx

Abstract:

    Contains ICSTRING class methods. Split from ICSTRING.HXX (inline methods)

    Contents:
        ICSTRING::ICSTRING(ICSTRING&)
        ICSTRING::~ICSTRING()
        ICSTRING::operator=(LPSTR)
        ICSTRING::operator=(ICSTRING&)
        ICSTRING::operator+=(LPSTR)
        ICSTRING::operator+=(char)
        ICSTRING::strncat(LPVOID, DWORD)
        ICSTRING::CreateStringBuffer(LPVOID, DWORD, DWORD)
        ICSTRING::CreateOffsetString(DWORD, DWORD)
        ICSTRING::CopyTo(LPSTR)
        ICSTRING::CopyTo(LPSTR, LPSTR)
        ICSTRING::CopyTo(LPSTR, DWORD)
        ICSTRING::CopyTo(LPSTR, LPDWORD)

Author:

    Richard L Firth (rfirth) 18-Dec-1995

Revision History:

    18-Dec-1995 rfirth
        Created

--*/

#include <wininetp.h>

//
// methods
//

//
//ICSTRING::ICSTRING(
//    IN ICSTRING& String
//    )
//
///*++
//
//Routine Description:
//
//    copy constructor. We now create an entirely new string (used to be just a
//    reference of the rvalue)
//
//Arguments:
//
//    String  - to copy
//
//Return Value:
//
//    None.
//
//--*/
//
//{
//    //
//    // can't already have string in lvalue, & rvalue mustn't be an offset string
//    //
//
//    INET_ASSERT(!HaveString());
//    INET_ASSERT(!String.IsOffset());
//    INET_ASSERT(!String.IsError());
//
//    *this = String.StringAddress();
//}


ICSTRING::~ICSTRING(
    VOID
    )

/*++

Routine Description:

    destructor

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // can only free the string if it is not a reference. Offset type
    // implies reference
    //

    if (!IsReference() && (_String != NULL)) {

        INET_ASSERT(!IsOffset());

        (VOID)ResizeBuffer((HLOCAL)_String, 0, FALSE);
    }
}


ICSTRING&
ICSTRING::operator=(
    IN LPSTR String
    )

/*++

Routine Description:

    Copy/assigment. Copies a string to this object. If NULL, frees up the
    current buffer

Arguments:

    String  - to be assigned

Return Value:

    ICSTRING&

--*/

{
    //
    // if this is an offset string then there's not much to do
    //

    if (IsOffset()) {
        Initialize();
        return *this;
    }

    //
    // string MUST NOT be a copy (we'll free the real string pointer, owned
    // by another object) and SHOULD NOT be copied itself (the objects with
    // copies of the string will potentially have a bad pointer)
    //

    INET_ASSERT((String == NULL) ? TRUE : !IsReference());
    INET_ASSERT(!IsReferenced());

    //
    // if the pointer is NULL or the string is empty then we are freeing the
    // string pointer
    //

    DWORD len;

    if (String == NULL) {
        len = 0;
    } else {
        len = ::strlen(String);
        if (len != 0) {
            INET_ASSERT(len < 0xffffffff);
            ++len;
        }
    }

    //
    // free or grow the buffer, depending on requirements
    //

    if ((len > _BufferLength) || ((len == 0) && (_String != NULL))) {
        _String = (LPSTR)ResizeBuffer((HLOCAL)_String, len, FALSE);
        _BufferLength = (_String != NULL) ? len : 0;
    }
    if (_String != NULL) {

        INET_ASSERT(len != 0);

        memcpy((LPVOID)_String, (LPVOID)String, len);
        _StringLength = len - 1;
        SetHaveString(TRUE);
        SetError(FALSE);
    } else {
        _StringLength = 0;
        SetHaveString(FALSE);
        SetError(len != 0); // an error might have occurred
    }
    return *this;
}


ICSTRING&
ICSTRING::operator=(
    IN ICSTRING& String
    )

/*++

Routine Description:

    Copy/assignment. Makes new copy of object (used to just make a reference)

Arguments:

    String  - ICSTRING object to be assigned

Return Value:

    ICSTRING&

--*/

{
    INET_ASSERT(!IsReferenced());
    INET_ASSERT(!String.IsReferenced());
    INET_ASSERT(!String.IsError());

    //
    // if we're copying an offset, make sure that any string we may already
    // have is freed
    //

    if (String.IsOffset()) {
        if (_String != NULL) {
            ResizeBuffer(_String, 0, FALSE);
        }
        _String = String._String;
        _StringLength = String._StringLength;
        _BufferLength = String._BufferLength;
        _Union.Dword = String._Union.Dword;
    } else {

        INET_ASSERT(!IsOffset() && !String.IsOffset());

        //
        // use string assignment to correctly setup this object
        //

        *this = String.StringAddress();
    }
    return *this;
}


VOID
ICSTRING::operator+=(
    IN LPSTR String
    )

/*++

Routine Description:

    Concatenates a string to the buffer. Reallocates it if necessary. String
    CANNOT be NULL

Arguments:

    String  - to concatenate

Return Value:

    None.

--*/

{
    INET_ASSERT(!IsReference());
    INET_ASSERT(!IsReferenced());
    INET_ASSERT(!IsOffset());
    INET_ASSERT(String != NULL);

    if (IsError()) {
        return;
    }

    if (*String == '\0') {
        return;
    }

    DWORD len = ::strlen(String);
    DWORD newlen = _StringLength + len + 1;

    INET_ASSERT ((newlen > _StringLength) && (newlen > len));

    if (_BufferLength < newlen) {
        _String = (LPSTR)ResizeBuffer((HLOCAL)_String, newlen, FALSE);

        INET_ASSERT((_String == NULL) ? (newlen == 0) : TRUE);

        _BufferLength = newlen;
    }
    if (_String != NULL) {
        memcpy((LPVOID)((LPBYTE)_String + _StringLength),
               (LPVOID)String,
               len + 1
               );
        _StringLength += len;
    } else {
        _StringLength = 0;
        _BufferLength = 0;
        SetError(TRUE);
    }
}


VOID
ICSTRING::operator+=(
    IN char Ch
    )

/*++

Routine Description:

    Concatenates a character to the buffer. Reallocates it if necessary. Ch
    CAN be '\0'

Arguments:

    Ch  - to concatenate

Return Value:

    None.

--*/

{
    INET_ASSERT(!IsReference());
    INET_ASSERT(!IsReferenced());
    INET_ASSERT(!IsOffset());

    if (IsError()) {
        return;
    }

    DWORD newlen = _StringLength + 2;

    INET_ASSERT (newlen > _StringLength);
    
    if (_BufferLength < newlen) {
        _String = (LPSTR)ResizeBuffer((HLOCAL)_String, newlen, FALSE);

        INET_ASSERT((_String == NULL) ? (newlen == 0) : TRUE);

        _BufferLength = newlen;
    }
    if (_String != NULL) {
        _String[_StringLength] = Ch;
        ++_StringLength;
        _String[_StringLength] = '\0';
    } else {
        _StringLength = 0;
        _BufferLength = 0;
        SetError(TRUE);
    }
}


VOID
ICSTRING::Strncat(
    IN LPVOID Pointer,
    IN DWORD Length
    )

/*++

Routine Description:

    Copies Length characters from Pointer to the end of _String

Arguments:

    Pointer - place to copy from

    Length  - number of characters to copy

Return Value:

    None.

--*/

{
    if (IsError()) {
        return;
    }

    INET_ASSERT(Pointer != NULL);
    INET_ASSERT(Length != 0);
    INET_ASSERT(_String != NULL);
    INET_ASSERT(!IsReference());
    INET_ASSERT(!IsReferenced());

    DWORD newLength;

    newLength = _StringLength + Length + 1;

    INET_ASSERT ((newLength > _StringLength) && (newLength > Length));
    
    if (_BufferLength < newLength) {
        _String = (LPSTR)ResizeBuffer((HLOCAL)_String, newLength, FALSE);
        _BufferLength = newLength;
    }
    if (_String != NULL) {
        memcpy((LPVOID)&_String[_StringLength], Pointer, Length);
        _StringLength += Length;

        INET_ASSERT(_StringLength < _BufferLength);

        _String[_StringLength] = '\0';
    } else {
        _StringLength = 0;
        _BufferLength = 0;
        SetError(TRUE);
    }
}


VOID
ICSTRING::CreateStringBuffer(
    IN LPVOID Pointer,
    IN DWORD StringLength,
    IN DWORD BufferLength
    )

/*++

Routine Description:

    In order to avoid reallocations, if we know the size of the buffer we
    want for several strcat()'s, e.g., we can allocate it once, copy the
    initial string here, then perform multiple concatenate operations (+=)

Arguments:

    Pointer         - place to start copying from

    StringLength    - length of string

    BufferLength    - length of buffer required

Return Value:

    None.

--*/

{
    INET_ASSERT(Pointer != NULL);
    INET_ASSERT(BufferLength > StringLength);
    INET_ASSERT(BufferLength != 0);

    //
    // if we currently have an offset string then initialize to a non-offset
    //

    if (IsOffset()) {
        Initialize();
    }
    _String = (LPSTR)ResizeBuffer(_String, BufferLength, FALSE);
    if (_String != NULL) {
        _StringLength = StringLength;
        _BufferLength = BufferLength;
        memcpy((LPVOID)_String, Pointer, _StringLength);
        _String[_StringLength] = '\0';
        SetHaveString(TRUE);
        SetReference(FALSE);
        SetReferenced(FALSE);
        SetOffset(FALSE);
        SetError(FALSE);
    } else {
        SetError(TRUE);
    }
}


VOID
ICSTRING::CreateOffsetString(
    IN DWORD Offset,
    IN DWORD Length
    )

/*++

Routine Description:

    Create a reference ICSTRING that is an offset within another buffer

Arguments:

    Offset  - offset into buffer

    Length  - of string

Return Value:

    None.

--*/

{
    _String = (LPSTR)(DWORD_PTR)Offset;
    _StringLength = Length;
    _BufferLength = Length;
    ZapFlags();
    SetHaveString(TRUE);    // ICSTRING initialized with non-NULL
    SetReference(TRUE);     // reference to another string buffer
    SetOffset(TRUE);        // offset from base
    SetError(FALSE);
}


VOID
ICSTRING::CopyTo(
    IN LPSTR Buffer
    )

/*++

Routine Description:

    Copies source _String to destination Buffer

Arguments:

    Buffer  - place to copy to

Return Value:

    None.

--*/

{
    INET_ASSERT(Buffer != NULL);
    INET_ASSERT(!IsOffset());

    memcpy((LPVOID)Buffer, (LPVOID)_String, _StringLength);
    Buffer[_StringLength] = '\0';
}


VOID
ICSTRING::CopyTo(
    IN LPSTR Base,
    IN LPSTR Buffer
    )

/*++

Routine Description:

    Copies a based (offset) string from source Base + _String to destination
    Buffer

Arguments:

    Base    - value for base

    Buffer  - place to write string

Return Value:

    None.

--*/

{
    INET_ASSERT(Buffer != NULL);
    //INET_ASSERT(IsOffset() ? (Base != NULL) : (Base == NULL));

    memcpy((LPVOID)Buffer,
           IsOffset() ? (Base + (DWORD_PTR)_String) : _String,
           _StringLength
           );
    Buffer[_StringLength] = '\0';
}


VOID
ICSTRING::CopyTo(
    IN LPSTR Buffer,
    IN DWORD Length
    )

/*++

Routine Description:

    Copies at most Length characters from source _String to destination
    Buffer

Arguments:

    Buffer  - place to write string

    Length  - number of characters to copy

Return Value:

    None.

--*/

{
    INET_ASSERT(Buffer != NULL);
    INET_ASSERT(!IsOffset());

    DWORD length = min(Length - 1, _StringLength);

    memcpy((LPVOID)Buffer, (LPVOID)_String, length);
    Buffer[length] = '\0';
}


VOID
ICSTRING::CopyTo(
    IN LPSTR Buffer,
    IN OUT LPDWORD Length
    )

/*++

Routine Description:

    Copies at most *Length characters from source _String to destination
    Buffer. Updates *Length to be number of characters copied, not including
    terminating NUL

Arguments:

    Buffer  - place to write string

    Length  - IN: length of buffer
              OUT: number of characters copied

Return Value:

    None.

--*/

{
    INET_ASSERT(Buffer != NULL);
    INET_ASSERT(!IsOffset());

    DWORD length = min(*Length - 1, _StringLength);

    memcpy((LPVOID)Buffer, (LPVOID)_String, length);
    Buffer[length] = '\0';
    *Length = length;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\common\icsocket.cxx ===
/*++

Copyright (c) 1995-1997 Microsoft Corporation

Module Name:

    icsocket.cxx

Abstract:

    Contains sockets functions and ICSocket methods

    Contents:
        ContainingICSocket
        MapNetAddressToName
        ICSocket::ICSocket
        ICSocket::~ICSocket
        ICSocket::Destroy
        ICSocket::Reference
        ICSocket::Dereference
        ICSocket::EnableSocks
        ICSocket::Connect
        CFsm_SocketConnect::RunSM
        ICSocket::Connect_Start
        ICSocket::Connect_Continue
        ICSocket::Connect_Error
        ICSocket::Connect_Finish
        ICSocket::SocksConnect
        ICSocket::Disconnect
        ICSocket::Close
        ICSocket::Abort
        ICSocket::Shutdown
        ICSocket::IsReset
        ICSocket::SetTimeout
        ICSocket::SetLinger
        ICSocket::SetNonBlockingMode
        ICSocket::GetBufferLength(SOCKET_BUFFER_ID)
        ICSocket::GetBufferLength(SOCKET_BUFFER_ID, LPDWORD)
        ICSocket::SetBufferLength
        ICSocket::SetSendCoalescing
        SetSourcePort
        ICSocket::Send
        CFsm_SocketSend::RunSM
        ICSocket::Send_Start
        ICSocket::SendTo
        ICSocket::Receive
        CFsm_SocketReceive::RunSM
        ICSocket::Receive_Start
        ICSocket::Receive_Continue
        ICSocket::AllocateQueryBuffer
        //ICSocket::FreeQueryBuffer
        //ICSocket::ReceiveFrom
        ICSocket::DataAvailable
        //ICSocket::DataAvailable2
        ICSocket::WaitForReceive
        //ICSocket::GetBytesAvailable
        ICSocket::CreateSocket
        ICSocket::GetSockName
        ICSocket::Listen
        ICSocket::DirectConnect
        ICSocket::SelectAccept

Author:

    Richard L Firth (rfirth) 08-Apr-1997

Environment:

    Win32 user mode

Revision History:

    08-Apr-1997 rfirth
        Created from ixport.cxx

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

//
// private prototypes
//

//
// functions
//

#if INET_DEBUG

PRIVATE LPSTR MapFamily(int family) {
    switch (family) {
    case AF_UNSPEC:     return "AF_UNSPEC";
    case AF_UNIX:       return "AF_UNIX";
    case AF_INET:       return "AF_INET";
    case AF_IMPLINK:    return "AF_IMPLINK";
    case AF_PUP:        return "AF_PUP";
    case AF_CHAOS:      return "AF_CHAOS";
    case AF_IPX:        return "AF_IPX";
    case AF_OSI:        return "AF_OSI";
    case AF_ECMA:       return "AF_ECMA";
    case AF_DATAKIT:    return "AF_DATAKIT";
    case AF_CCITT:      return "AF_CCITT";
    case AF_SNA:        return "AF_SNA";
    case AF_DECnet:     return "AF_DECnet";
    case AF_DLI:        return "AF_DLI";
    case AF_LAT:        return "AF_LAT";
    case AF_HYLINK:     return "AF_HYLINK";
    case AF_APPLETALK:  return "AF_APPLETALK";
    case AF_NETBIOS:    return "AF_NETBIOS";
#if defined(AF_VOICEVIEW)
    case AF_VOICEVIEW:  return "AF_VOICEVIEW";
#endif /* AF_VOICEVIEW */
#if defined(AF_FIREFOX)
    case AF_FIREFOX:    return "AF_FIREFOX";
#endif /* AF_FIREFOX */
#if defined(AF_UNKNOWN1)
    case AF_UNKNOWN1:   return "AF_UNKNOWN1";
#endif /* AF_UNKNOWN1 */
#if defined(AF_BAN)
    case AF_BAN:        return "AF_BAN";
#endif /* AF_BAN */
    }
    return "?";
}

PRIVATE LPSTR MapSock(int sock) {
    switch (sock) {
    case SOCK_STREAM:       return "SOCK_STREAM";
    case SOCK_DGRAM:        return "SOCK_DGRAM";
    case SOCK_RAW:          return "SOCK_RAW";
    case SOCK_RDM:          return "SOCK_RDM";
    case SOCK_SEQPACKET:    return "SOCK_SEQPACKET";
    }
    return "?";
}

PRIVATE LPSTR MapProto(int proto) {
    switch (proto) {
    case IPPROTO_IP:    return "IPPROTO_IP";
    case IPPROTO_ICMP:  return "IPPROTO_ICMP";
    case IPPROTO_IGMP:  return "IPPROTO_IGMP";
    case IPPROTO_GGP:   return "IPPROTO_GGP";
    case IPPROTO_TCP:   return "IPPROTO_TCP";
    case IPPROTO_PUP:   return "IPPROTO_PUP";
    case IPPROTO_UDP:   return "IPPROTO_UDP";
    case IPPROTO_IDP:   return "IPPROTO_IDP";
    case IPPROTO_ND:    return "IPPROTO_ND";
    }
    return "?";
}

#endif // INET_DEBUG



ICSocket *
ContainingICSocket(
    LPVOID lpAddress
    )

/*++

Routine Description:

    Returns address of start of ICSocket (i.e. vtable) given address of list

Arguments:

    lpAddress   - address of m_List part of ICSocket

Return Value:

    ICSocket *  - address of start of ICSocket object (also ICSecureSocket)

--*/

{
    return CONTAINING_RECORD(lpAddress, ICSocket, m_List);
}

//
// ICSocket methods
//


ICSocket::ICSocket(
    VOID
    )

/*++

Routine Description:

    ICSocket constructor

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "ICSocket::ICSocket",
                 "{%#x}",
                 this
                 ));

    SIGN_ICSOCKET();

    m_List.Flink = NULL;
    m_List.Blink = NULL;
    m_dwTimeout = 0;
    m_fTimeoutWraps = 0;
    m_Socket = INVALID_SOCKET;
    m_dwFlags = 0;
    m_bAborted = FALSE;
    m_SocksAddress = 0;
    m_SocksPort = 0;
    m_ReferenceCount = 1;
    _pCurrentFsm = NULL;

    _lpWrapOverlappedSend = NULL;
    _lpWrapOverlappedRecv = NULL;

    DEBUG_LEAVE(0);
}


ICSocket::~ICSocket()

/*++

Routine Description:

    ICSocket destructor. Virtual function

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "ICSocket::~ICSocket",
                 "{%#x [sock=%#x, port=%d, ref=%d]}",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 ReferenceCount()
                 ));

    CHECK_ICSOCKET();

    INET_ASSERT(!IsOnList());
    INET_ASSERT(m_ReferenceCount == 0);

    if (IsOpen()) {
        SetLinger(FALSE, 0);
        Shutdown(SD_BOTH);
        Close();
    }

    if (_lpWrapOverlappedSend)
        _lpWrapOverlappedSend->Dereference();

    if (_lpWrapOverlappedRecv)
        _lpWrapOverlappedRecv->Dereference();
        
    DEBUG_LEAVE(0);
}


VOID
ICSocket::Destroy(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "ICSocket::Destroy",
                 "{%#x [%#x/%d]}",
                 this,
                 GetSocket(),
                 GetSourcePort()
                 ));

    INET_ASSERT(ReferenceCount() == 1);

    m_ReferenceCount = 0;
    delete this;

    DEBUG_LEAVE(0);
}


VOID
ICSocket::Reference(
    VOID
    )

/*++

Routine Description:

    Just increases the reference count

Arguments:

    None.

Return Value:

    None.

--*/

{
    CHECK_ICSOCKET();

    InterlockedIncrement(&m_ReferenceCount);
}


BOOL
ICSocket::Dereference(
    VOID
    )

/*++

Routine Description:

    Reduces the reference count. If it goes to zero, the object is deleted

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - object deleted

        FALSE   - object still alive

--*/

{
    CHECK_ICSOCKET();

    if (InterlockedDecrement(&m_ReferenceCount) == 0) {

        INET_ASSERT(m_ReferenceCount == 0);

        delete this;
        return TRUE;
    }
    return FALSE;
}


PRIVATE
DWORD
ICSocket::EnableSocks(
    IN LPSTR lpSocksHost,
    IN INTERNET_PORT ipSocksPort
    )

/*++

Routine Description:

    Set SOCKS gateway IP address and port in this socket object

Arguments:

    lpSocksHost - IP address or host name of SOCKS host

    ipSocksPort - port address of SOCKS host

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_NAME_NOT_RESOLVED
                    failed to resolve SOCKS host name

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::EnableSocks",
                 "{%#x/%d} %q, %d",
                 GetSocket(),
                 GetSourcePort(),
                 lpSocksHost,
                 ipSocksPort
                 ));

    DWORD error = ERROR_SUCCESS;

    m_SocksPort = ipSocksPort;
    m_SocksAddress = _I_inet_addr(lpSocksHost);
    if (m_SocksAddress == INADDR_NONE) {    // 0xffffffff

        LPHOSTENT lpHostent = _I_gethostbyname(lpSocksHost);

        if (lpHostent != NULL) {
            m_SocksAddress = **(LPDWORD*)&lpHostent->h_addr_list[0];
        } else {
            m_SocksAddress = 0;
            error = ERROR_WINHTTP_NAME_NOT_RESOLVED;
        }
    }

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("SOCKS address = %d.%d.%d.%d:%d\n",
                ((BYTE*)&m_SocksAddress)[0] & 0xff,
                ((BYTE*)&m_SocksAddress)[1] & 0xff,
                ((BYTE*)&m_SocksAddress)[2] & 0xff,
                ((BYTE*)&m_SocksAddress)[3] & 0xff,
                m_SocksPort
                ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::SocketConnect(
    IN LONG Timeout,
    IN INT Retries,
    IN DWORD dwFlags,
    IN CServerInfo *pServerInfo
    )

/*++

Routine Description:

    Initiate connection with server

Arguments:

    Timeout - maximum amount of time (mSec) to wait for connection

    Retries - maximum number of attempts to connect

    dwFlags - flags controlling request

    pServerInfo - Server Info to connect with

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't create FSM

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SocketConnect",
                 "{%#x [%#x]} %d, %d, %#x, %x",
                 this,
                 m_Socket,
                 Timeout,
                 Retries,
                 dwFlags,
                 pServerInfo
                 ));


    DWORD error;

    CFsm_SocketConnect * pFsm;

    pFsm = New CFsm_SocketConnect(Timeout, Retries, dwFlags, this);

    if ( pFsm )
    {
        pFsm->SetServerInfo(pServerInfo);
    }

    error = DoFsm(pFsm);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
ICSocket::Connect(
    IN LONG Timeout,
    IN INT Retries,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Initiate connection with server

Arguments:

    Timeout - maximum amount of time (mSec) to wait for connection

    Retries - maximum number of attempts to connect

    dwFlags - flags controlling request

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't create FSM

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Connect",
                 "{%#x [%#x]} %d, %d, %#x",
                 this,
                 m_Socket,
                 Timeout,
                 Retries,
                 dwFlags
                 ));

#ifdef TEST_CODE
    Timeout *= 20;
    Retries *= 20;
#endif

    DWORD error;

    error = DoFsm(New CFsm_SocketConnect(Timeout, Retries, dwFlags, this));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SocketConnect::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    Runs next CFsm_SocketConnect state

Arguments:

    Fsm - FSM controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SocketConnect::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSocket * pSocket = (ICSocket *)Fsm->GetContext();
    CFsm_SocketConnect * stateMachine = (CFsm_SocketConnect *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
        error = pSocket->Connect_Start(stateMachine);
        break;

    case FSM_STATE_CONTINUE:
        error = pSocket->Connect_Continue(stateMachine);
        break;

    case FSM_STATE_ERROR:
        error = pSocket->Connect_Error(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Connect_Start(
    IN CFsm_SocketConnect * Fsm
    )

/*++

Routine Description:

    Starts a socket connect operation - creates a socket and connects it to a
    server using the address information returned by GetServiceAddress(). There
    may be several addresses to try. We return as soon as we successfully
    generate a connection, or after we have tried <Retries> attempts, or until
    <Timeout> milliseconds have elapsed

Arguments:

    Fsm - socket connect FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Connect_Start",
                 "{%#x [%#x]}, %#x(%d, %d, %#x)",
                 this,
                 m_Socket,
                 Fsm,
                 Fsm->m_Timeout,
                 Fsm->m_Retries,
                 Fsm->m_dwFlags
                 ));

    PERF_ENTER(Connect_Start);

    CFsm_SocketConnect & fsm = *Fsm;
    LPINTERNET_THREAD_INFO lpThreadInfo = fsm.GetThreadInfo();

    INET_ASSERT(lpThreadInfo != NULL);

    DWORD error = ERROR_SUCCESS;
    int serr = SOCKET_ERROR;

    BOOL fSynchronous = FALSE;

    INET_ASSERT(IsClosed());

    //
    // ensure the next state is CONTINUE. It may be INIT because we could have
    // been looping through bad addresses (if sufficient timeout & retries)
    //

    fsm.SetNextState(FSM_STATE_CONTINUE);

    //
    // get address to use. If exhausted, re-resolve
    //

    if (fsm.GetFunctionState() == FSM_STATE_2) {
        fsm.SetFunctionState(FSM_STATE_1);
        goto resolve_continue;
    }
    if (!fsm.m_pServerInfo->GetNextAddress(&fsm.m_dwResolutionId,
                                           &fsm.m_dwAddressIndex,
                                           GetPort(),
                                           fsm.m_pAddress
                                           )) {
        if (fsm.m_bResolved) {
            error = ERROR_WINHTTP_CANNOT_CONNECT;
        } else {
            fsm.SetFunctionState(FSM_STATE_2);
            fsm.SetNextState(FSM_STATE_INIT);
            fsm.m_dwAddressIndex = -1;
            error = fsm.m_pServerInfo->ResolveHost(&fsm.m_dwResolutionId,
                                                   fsm.m_dwFlags
                                                   );
            if (error == ERROR_IO_PENDING) {
                goto quit;
            }

resolve_continue:

            fsm.m_bResolved = TRUE;
            if (error == ERROR_SUCCESS) {
                if (!fsm.m_pServerInfo->GetNextAddress(&fsm.m_dwResolutionId,
                                                       &fsm.m_dwAddressIndex,
                                                       GetPort(),
                                                       fsm.m_pAddress
                                                       )) {
                    error = ERROR_WINHTTP_CANNOT_CONNECT;
                }
            }
            else if (error == ERROR_WINHTTP_NAME_NOT_RESOLVED)
            {
                fsm.SetNextState(FSM_STATE_CONTINUE);
                goto quit; // exit out NOW with ERROR_WINHTTP_NAME_NOT_RESOLVED, instead of CANNOT_CONNECT
            }
        }
    }
    if (error != ERROR_SUCCESS) {

        //
        // name resolution failed - done
        //

        goto quit;
    }

    //
    // update port for keep-alive info
    //

    SetPort(_I_ntohs(((LPSOCKADDR_IN)fsm.m_pAddress->RemoteAddr.lpSockaddr)->sin_port));

    //
    // BUGBUG - this code was supplying AF_UNSPEC to socket(), which should
    //          be okay, but because of a bug in the Win95 wsipx driver
    //          which manifests itself when we call bind(), we must send in
    //          the address family supplied in the local socket address by
    //          GetAddressByName()
    //

    int protocol;
    DWORD dwConnFlags;

    protocol = fsm.m_pAddress->iProtocol;

    m_Socket = _I_socket(fsm.m_pAddress->LocalAddr.lpSockaddr->sa_family,
                         fsm.m_pAddress->iSocketType,
                         protocol
                         );
    if (m_Socket == INVALID_SOCKET) {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("failed to create socket\n"
                    ));

        goto check_socket_error;
    }

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("created socket %#x\n",
                m_Socket
                ));

    //
    // inform the app that we are connecting to the server (but only on the
    // first attempt)
    //

    //if ((fsm.m_dwFlags & SF_INDICATE) && (error == ERROR_SUCCESS)) {
    if (fsm.m_dwFlags & SF_INDICATE) {
        error = InternetIndicateStatusAddress(WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER,
                                      fsm.m_pAddress->RemoteAddr.lpSockaddr,
                                      fsm.m_pAddress->RemoteAddr.iSockaddrLength
                                      );
        if (error != ERROR_SUCCESS)
        {
            INET_ASSERT(error = ERROR_WINHTTP_OPERATION_CANCELLED);
            fsm.SetNextState(FSM_STATE_DONE);
            goto quit;
        }   
    }

    //
    // if requested to, put the socket in non-blocking mode
    //

    if (fsm.m_dwFlags & SF_NON_BLOCKING
    && (GlobalRunningNovellClient32 ? GlobalNonBlockingClient32 : TRUE)) {
        error = SetNonBlockingMode(TRUE);
        if (error != ERROR_SUCCESS) {
            fsm.SetErrorState(error);
            goto quit;
        }
    }

    //
    // bind the socket to the local address
    //

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("binding to local address %d.%d.%d.%d, port %d, index %d\n",
                ((LPBYTE)fsm.m_pAddress->LocalAddr.lpSockaddr)[4] & 0xff,
                ((LPBYTE)fsm.m_pAddress->LocalAddr.lpSockaddr)[5] & 0xff,
                ((LPBYTE)fsm.m_pAddress->LocalAddr.lpSockaddr)[6] & 0xff,
                ((LPBYTE)fsm.m_pAddress->LocalAddr.lpSockaddr)[7] & 0xff,
                _I_ntohs(((LPSOCKADDR_IN)fsm.m_pAddress->LocalAddr.lpSockaddr)->sin_port),
                fsm.m_dwAddressIndex
                ));

    serr = _I_bind(m_Socket,
                   fsm.m_pAddress->LocalAddr.lpSockaddr,
                   fsm.m_pAddress->LocalAddr.iSockaddrLength
                   );
    if (serr == SOCKET_ERROR) {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("failed to bind socket %#x\n",
                    m_Socket
                    ));

        goto check_socket_error;
    }

    //
    // Socket successfully created and bound - now, if async,
    // associate IOCP with this socket.
    //
    if (fsm.m_dwFlags & SF_NON_BLOCKING)
    {
        DEBUG_ENTER((DBG_API,
                         Dword,
                         "***CreateIoCompletionPort",
                         "(m_Socket)%#x, (hcomp)%#x, (icsocket-compkey)%#x, %#x, (app handle)%#x, (fsm)%#x, (mapped handle obj)%#x",
                         m_Socket,
                         g_hCompletionPort,
                         this,
                         0,
                         fsm.GetAppHandle(),
                         fsm,
                         fsm.GetMappedHandleObject()
                         ));
                         
        HANDLE hCompPort = CreateIoCompletionPort(  (HANDLE)m_Socket,
                                                    g_hCompletionPort,
                                                    (ULONG_PTR)this,
                                                    0 );

        DEBUG_LEAVE(hCompPort);
        
        INET_ASSERT (hCompPort == g_hCompletionPort);
        if (!hCompPort)
        {
            error = GetLastError();
            fsm.SetErrorState(error);
            goto quit;
        }
    }  
    //
    // record source port (useful for matching with net sniff)
    //

    SetSourcePort();

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("socket %#x bound to port %d (%#x)\n",
                m_Socket,
                m_SourcePort,
                m_SourcePort
                ));

    //
    // let another thread know the socket to cancel if it wants to kill
    // this operation
    //

    INET_ASSERT(fsm.GetMappedHandleObject() != NULL);

    if (fsm.GetMappedHandleObject() != NULL) {
        fsm.GetMappedHandleObject()->SetAbortHandle(this);
    }

    //
    // try to connect to the next address
    //

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("connecting %#x/%d to remote address %d.%d.%d.%d, port %d, index %d\n",
                m_Socket,
                m_SourcePort,
                ((LPBYTE)fsm.m_pAddress->RemoteAddr.lpSockaddr)[4] & 0xff,
                ((LPBYTE)fsm.m_pAddress->RemoteAddr.lpSockaddr)[5] & 0xff,
                ((LPBYTE)fsm.m_pAddress->RemoteAddr.lpSockaddr)[6] & 0xff,
                ((LPBYTE)fsm.m_pAddress->RemoteAddr.lpSockaddr)[7] & 0xff,
                _I_ntohs(((LPSOCKADDR_IN)fsm.m_pAddress->RemoteAddr.lpSockaddr)->sin_port),
                fsm.m_dwAddressIndex
                ));

    fsm.SetNextState(FSM_STATE_CONTINUE);
    fsm.StartTimer();

#ifdef TEST_CODE
    SetLastError(-1);
    serr = -1;
#else
    //if we are running in blocking mode (ie synchronous case) w/ timeout, unblock for 
    //the connect so we can enforce the timeout.
    if (!(fsm.m_dwFlags & SF_NON_BLOCKING) 
        && (fsm.GetTimeout() != INFINITE)) 
    {
        fSynchronous = TRUE;
        error = SetNonBlockingMode(TRUE);
        if (error != ERROR_SUCCESS) 
        {
            fsm.SetErrorState(error);
            goto quit;
        }
    }
    
    if (IsSocks()) {
        serr = SocksConnect((LPSOCKADDR_IN)fsm.m_pAddress->RemoteAddr.lpSockaddr,
                            fsm.m_pAddress->RemoteAddr.iSockaddrLength
                            );
    } else {
        serr = _I_connect(m_Socket,
                          fsm.m_pAddress->RemoteAddr.lpSockaddr,
                          fsm.m_pAddress->RemoteAddr.iSockaddrLength
                          );
    }
#endif

    //
    // here if a socket operation failed, in which case serr will be SOCKET_ERROR
    //

check_socket_error:

    if (serr == 0) {

        //
        // successful (probably synchronous) connect completion
        //

        //
        // in the sync case, we just call the continue handler. No need to
        // return to the state handler
        //

        Connect_Continue(Fsm);
        goto quit;
    }

    //
    // here if a socket operation failed. We have to read the socket error in
    // this thread before doing anything else or we'll lose the error. We handle
    // it in Connect_Error()
    //

    error = _I_WSAGetLastError();

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("connect(%#x) returns %d\n",
                m_Socket,
                error
                ));

    if (fSynchronous && (error == WSAEWOULDBLOCK))
    {
        int n = 1;
        BOOL bComplete = FALSE;
        
        struct fd_set write_fds;
        struct fd_set except_fds;
        
        FD_ZERO(&write_fds);
        FD_ZERO(&except_fds);
        
        SOCKET sock = m_Socket;

        // connect() & send()

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("%s FSM %#x WRITE waiting on socket %#x\n",
                    fsm.MapType(),
                    &fsm,
                    sock
                    ));

        FD_SET(sock, &write_fds);
        
        // all sockets are checked for exception
        FD_SET(sock, &except_fds);
        
        LONG timeout = fsm.GetTimeout();
        struct timeval to;
        struct timeval* pto;

        if (timeout != INFINITE)
        {
            to.tv_sec = timeout / 1000;
            to.tv_usec = (timeout % 1000) * 1000;
            pto = &to;
        }
        else
        {
            pto = NULL;
        }
        
        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("waiting %d mSec (%d.%06d) for select(). %d sockets\n",
                    timeout,
                    pto ? to.tv_sec : -1,
                    pto ? to.tv_usec : -1,
                    n
                    ));
                    
        n = PERF_Select(n, NULL, &write_fds, &except_fds, pto);

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("select() returns %d\n",
                    n
                    ));

        error = ERROR_WINHTTP_CANNOT_CONNECT;

        if (n == 0)
        {
            INET_ASSERT (pto != NULL);
            
            error = ERROR_WINHTTP_TIMEOUT;
        }
        else if (n > 0) 
        {
            if (FD_ISSET(sock, &except_fds)) 
            {
                DEBUG_PRINT(ASYNC,
                            INFO,
                            ("%s FSM %#x socket %#x exception\n",
                            fsm.MapType(),
                            fsm,
                            sock
                            ));                
            } 
            else if (FD_ISSET(sock, &write_fds)) 
            {
                DEBUG_PRINT(ASYNC,
                            INFO,
                            ("%s FSM %#x socket %#x completed\n",
                            fsm.MapType(),
                            fsm,
                            sock
                            ));

                error = ERROR_SUCCESS;
            }
            else
            {
                INET_ASSERT (FALSE);
            }
        } //n >= 0
        else
        {
            error = MapInternetError(_I_WSAGetLastError());
        }
        
        //Now set the socket back to blocking mode.
        //  If we run into an error doing that, then fall out of the connect loop 
        //  Else we'll fall into the Connect_Continue->Connect_Error codepath, which
        //  will also account for count-outs and timeouts.
        DWORD dwError;
        if ((dwError = SetNonBlockingMode(FALSE)) != ERROR_SUCCESS)
        {
            error = MapInternetError(dwError);
            fsm.SetErrorState(error);
            goto quit;
        }

    } //fSynchronous

    //
    // if we are using non-blocking sockets then we need to wait until the
    // connect has completed, or an error occurs.
    // If we got any status other than WSAEWOULDBLOCK then we have to handle
    // the error
    //

    if (IsNonBlocking() && (error == WSAEWOULDBLOCK)) {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("connect() blocked, socket %#x, port %d\n",
                    m_Socket,
                    m_SourcePort
                    ));

        fsm.SetAction(FSM_ACTION_CONNECT);

        DWORD timeout = GetTimeoutValue(WINHTTP_OPTION_CONNECT_TIMEOUT);
        INTERNET_HANDLE_OBJECT * pObject = fsm.GetMappedHandleObject();
        
#ifndef WININET_SERVER_CORE //no cache
        if (pObject != NULL) {
            if (pObject->IsFromCacheTimeoutSet()
            && (pObject->GetObjectType() == TypeHttpRequestHandle)
            && ((HTTP_REQUEST_HANDLE_OBJECT *)pObject)->CanRetrieveFromCache()) {
                timeout = GetTimeoutValue(WINHTTP_OPTION_FROM_CACHE_TIMEOUT);

                DWORD connectTime = fsm.m_pServerInfo->GetConnectTime();

                if (connectTime == 0) {
                    connectTime = timeout;
                }
                timeout += connectTime;
            }
        }
#endif //no cache

        fsm.SetTimeout(timeout);
        fsm.SetNextState(FSM_STATE_CONTINUE);

        //
        // after we set the state to waiting, and get ERROR_IO_PENDING from
        // QueueSocketWorkItem() then we can no longer touch this FSM until
        // it completes asynchronously
        //

        //
        // perf - test the socket. If this completes quickly we don't take a
        // context switch
        //

        //error = WaitForReceive(0);
        //if (error == ERROR_WINHTTP_TIMEOUT) {
            error = QueueSocketWorkItem(Fsm, m_Socket);
        //}
        if (error == ERROR_SUCCESS) {

            //
            // in the unlikely event the request completed quickly and
            // successfully
            //

            serr = 0;
            goto check_socket_error;
        } else if (error == ERROR_IO_PENDING) {

            //
            // the request is pending. We already set waiting state
            //

            goto quit;
        }

        //
        // if here then QueueSocketWorkItem() returned some other error
        //

    } 
    else
    {

        //
        // some other socket error occurred. Convert to INTERNET error
        //

        //
        // Also okay to be here for successful synchronous connect with timeout.
        //
        if (error)
            fsm.SetErrorState(MapInternetError(error));
        error = Connect_Continue(Fsm);
    }

    fsm.SetErrorState(error);

quit:

    //
    // we are done if not pending AND we will not re-enter this state in order
    // to re-do the name resolution/find another address
    //

    if ((error != ERROR_IO_PENDING) && (fsm.GetNextState() != FSM_STATE_INIT)) 
    {
        fsm.SetDone();

        PERF_LEAVE(Connect_Start);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Connect_Continue(
    IN CFsm_SocketConnect * Fsm
    )

/*++

Routine Description:

    Performs common processing after connect completion or failure

Arguments:

    Fsm - reference to socket connect finite state machine

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Connect_Continue",
                 "{%#x [%#x/%d]}, %#x(%d, %d, %#x)",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 Fsm,
                 Fsm->m_Timeout,
                 Fsm->m_Retries,
                 Fsm->m_dwFlags
                 ));

    PERF_ENTER(Connect_Continue);

    CFsm_SocketConnect & fsm = *Fsm;
    fsm.StopTimer();

//    INET_ASSERT((fsm.GetMappedHandleObject() != NULL)
//        ? (fsm.GetMappedHandleObject()->GetAbortHandle() != NULL)
//        : TRUE);

    DWORD error = fsm.GetError();

    //INET_ASSERT(error != SOCKET_ERROR);

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("connect() resumed, socket %#x, port %d\n",
                m_Socket,
                m_SourcePort
                ));

    //
    // check for aborted request
    //

    if (IsAborted()) 
    {
        error = ERROR_WINHTTP_OPERATION_CANCELLED;
    }
    
    if (error == ERROR_SUCCESS) {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("socket %#x/port %d connected; time = %d mSec\n",
                    m_Socket,
                    m_SourcePort,
                    fsm.ReadTimer()
                    ));

        error = Connect_Finish(Fsm);
    } else {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("failed to connect socket %#x/port %d: error %s\n",
                    m_Socket,
                    m_SourcePort,
                    InternetMapError(error)
                    ));

        fsm.SetError(error);
        error = Connect_Error(Fsm);
    }

    PERF_LEAVE(Connect_Continue);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Connect_Error(
    IN CFsm_SocketConnect * Fsm
    )

/*++

Routine Description:

    Called to handle a connect error. Either causes the FSM to terminate or
    prepares the FSM to try another connection

Arguments:

    Fsm - socket connect FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Connect_Error",
                 "{%#x [%#x/%d]}, %#x(%d, %d, %#x)",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 Fsm,
                 Fsm->m_Timeout,
                 Fsm->m_Retries,
                 Fsm->m_dwFlags
                 ));

    PERF_ENTER(Connect_Error);

    CFsm_SocketConnect & fsm = *Fsm;

    fsm.StopTimer();

    INTERNET_HANDLE_OBJECT * pObject = fsm.GetMappedHandleObject();

    //
    // no longer performing socket operation - clear abort handle
    //

    INET_ASSERT(pObject != NULL);

    if (pObject != NULL) {
        pObject->ResetAbortHandle();
    }

    DWORD error = fsm.GetError();
    BOOL bRestartable = FALSE;

    //INET_ASSERT(error != SOCKET_ERROR);
    INET_ASSERT(error != ERROR_SUCCESS);

    //
    // check for aborted request - this overrides any socket error
    //

    if (IsAborted() || error == ERROR_WINHTTP_OPERATION_CANCELLED) 
    {
        error = ERROR_WINHTTP_OPERATION_CANCELLED;
    }
    else if (fsm.IsCountedOut()
               || fsm.IsTimedOut()  // entire request timeout
               || (error == ERROR_WINHTTP_TIMEOUT)) 
    {  // just this request t/o

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("counted out or timed out\n"
                    ));
                    
        // VENKATK_BUG verify this:
        // CANNOT_CONNECT takes precedence over TIMEOUT
        //
        if (fsm.IsTimedOut()) 
        {
            error = ERROR_WINHTTP_TIMEOUT;
        } 
        else if (fsm.IsCountedOut()) 
        {
            error = ERROR_WINHTTP_CANNOT_CONNECT;
        }
    } 
    else if (error != ERROR_NOT_ENOUGH_MEMORY)
    {

        //
        // not aborted, timed-out, counted-out, or offline. We can try again
        //

        bRestartable = TRUE;
    }

    //
    // if the socket is open, close it and try the next connection. Invalidate
    // the address we tried
    //

    if (IsOpen()) 
    {
        Close();
    }

    DWORD mappedError = fsm.GetMappedError();

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("mapped error = %d [%s]\n",
                mappedError,
                InternetMapError(mappedError)
                ));

    //
    // don't invalidate address if from-cache-if-net-fail timeout
    //

    BOOL bInvalidate = TRUE;

    if ((pObject != NULL) && pObject->IsFromCacheTimeoutSet()) 
    {
        bInvalidate = FALSE;
    }
    
    if ((mappedError == WSAENETUNREACH)
        || (mappedError == WSAETIMEDOUT)
        || ((error == ERROR_WINHTTP_TIMEOUT) && bInvalidate)
        || (error == ERROR_WINHTTP_CANNOT_CONNECT)
#ifdef TEST_CODE
        || (error == (DWORD)-1)
#endif
        ) 
    {
        fsm.m_pServerInfo->InvalidateAddress(fsm.m_dwResolutionId,
                                             fsm.m_dwAddressIndex
                                             );
    }

    //
    // if the operation was cancelled or we lost connectivity then quit
    //

    if (bRestartable) 
    {
        fsm.SetNextState(FSM_STATE_INIT);
    } 
    else 
    {
        fsm.SetDone(error);

        PERF_LEAVE(Connect_Error);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Connect_Finish(
    IN CFsm_SocketConnect * Fsm
    )

/*++

Routine Description:

    Called when the connection has been successfully established

Arguments:

    Fsm - socket connect FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Connect_Finish",
                 "{%#x [%#x/%d]}, %#x(%d, %d, %#x)",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 Fsm,
                 Fsm->m_Timeout,
                 Fsm->m_Retries,
                 Fsm->m_dwFlags
                 ));

    PERF_ENTER(Connect_Finish);

    CFsm_SocketConnect & fsm = *Fsm;

    INET_ASSERT(IsOpen());

    //
    // store the average connect time to this server in our CServerInfo
    //

    if (fsm.m_pServerInfo != NULL) {
        fsm.m_pServerInfo->UpdateConnectTime(fsm.ReadTimer());
    }
    if (fsm.m_pOriginServer != NULL) {
        fsm.m_pOriginServer->UpdateConnectTime(fsm.ReadTimer());
    }

#ifdef TEST_CODE
    BOOL optval;
    int optlen = sizeof(optval);
    int serr = _I_getsockopt(GetSocket(),
                             IPPROTO_TCP,
                             TCP_NODELAY,
                             (char FAR *)&optval,
                             &optlen
                             );

    if (serr != 0) {
        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("getsockopt(TCP_NODELAY) returns %s (%d)\n",
                    InternetMapError(_I_WSAGetLastError()),
                    _I_WSAGetLastError()
                    ));
    }
#endif

    //
    // no longer performing socket operation - clear abort handle
    //

    INET_ASSERT(fsm.GetMappedHandleObject() != NULL);

    if (fsm.GetMappedHandleObject() != NULL) {
        fsm.GetMappedHandleObject()->ResetAbortHandle();
    }

    //
    // set the send & receive buffer sizes if not -1 (meaning don't change)
    //

    DWORD bufferLength;

    bufferLength = GetBufferLength(ReceiveBuffer);
    if (bufferLength != (DWORD)-1) {
        SetBufferLength(ReceiveBuffer, bufferLength);
    }
    bufferLength = GetBufferLength(SendBuffer);
    if (bufferLength != (DWORD)-1) {
        SetBufferLength(SendBuffer, bufferLength);
    }

    //
    // disable send coalescing
    //

    SetSendCoalescing(FALSE);

    //
    // let the app know we connected to the server successfully
    //

    if (fsm.m_dwFlags & SF_INDICATE) {
        InternetIndicateStatusAddress(WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER,
                                      fsm.m_pAddress->RemoteAddr.lpSockaddr,
                                      fsm.m_pAddress->RemoteAddr.iSockaddrLength
                                      );
    }

    fsm.SetDone();

    PERF_LEAVE(Connect_Finish);

    DEBUG_LEAVE(ERROR_SUCCESS);

    return ERROR_SUCCESS;
}


int
ICSocket::SocksConnect(
    IN LPSOCKADDR_IN pSockaddr,
    IN INT nLen
    )

/*++

Routine Description:

    Connect to remote host via SOCKS proxy. Modified from original. If we are
    here then we are going specifically via a known SOCKS proxy. There is now
    only one Hosts object, containing a single SOCKD socks proxy address and
    user name

    N.B. Irrespective of whether we are non-blocking, this function executes
    in blocking mode (we expect that we are on an intranet and complete quickly)

Arguments:

    pSockaddr   - address of remote host (on other side of SOCKS firewall)

    nLen        - length of *pSockaddr

Return Value:

    int
        Success - 0

        Failure - -1

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Int,
                 "ICSocket::SocksConnect",
                 "{%#x} %#x, %d",
                 GetSocket(),
                 pSockaddr,
                 nLen
                 ));

    //
    // BUGBUG - should check if the socket type is SOCK_STREAM or if we have
    //          already connected this socket. This code was part of original
    //          general purpose solution. We don't need it
    //

    //
    // initialize sockaddr for connecting to SOCKS firewall
    //

    struct sockaddr_in sin;

    sin.sin_family = AF_INET;
    sin.sin_port = _I_htons(m_SocksPort);
    sin.sin_addr.s_addr = m_SocksAddress;
    memset(&sin.sin_zero, 0, sizeof(sin.sin_zero));

    //
    // initialize SOCKS request packet
    //

    struct {
        unsigned char VN;
        unsigned char CD;
        unsigned short DSTPORT;
        unsigned long  DSTIP;
        char UserId[255];
    } request;

    request.VN = 4;
    request.CD = 1;
    request.DSTPORT = pSockaddr->sin_port;
    request.DSTIP = pSockaddr->sin_addr.s_addr;

    DWORD length = sizeof(request.UserId);

    length += 8 + 1; // 8 == sizeof fixed portion of request;
                     // +1 for additional '\0'

    //
    // put socket into blocking mode
    //

    BOOL non_blocking = IsNonBlocking();

    if (non_blocking) {
        SetNonBlockingMode(FALSE);
    }

    //
    // communicate with SOCKS firewall: send SOCKS request & receive response
    //

    int serr = _I_connect(m_Socket, (LPSOCKADDR)&sin, sizeof(sin));

    if (serr != SOCKET_ERROR) {
        serr = _I_send(m_Socket, (char *)&request, length, 0);
        if (serr == (int)length) {

            char response[256];


            serr = _I_recv(m_Socket, (char *)response, sizeof(response), 0);
            if( serr == 1 ) {
                // need to read at least 2 bytes
                DEBUG_PRINT(SOCKETS,
                            ERROR,
                            ("need to read one more byte\n"));
                serr = _I_recv(  
                    m_Socket, (char *)(&response[1]), sizeof(response) - 1, 0);
            }

            if (serr != SOCKET_ERROR) {
                if (response[1] != 90) {
                    serr = SOCKET_ERROR;
                }

            } else {

                DEBUG_PRINT(SOCKETS,
                            ERROR,
                            ("recv(%#x) returns %d\n",
                            m_Socket,
                            _I_WSAGetLastError()
                            ));

            }
        } else {

            DEBUG_PRINT(SOCKETS,
                        ERROR,
                        ("send(%#x) returns %d\n",
                        m_Socket,
                        _I_WSAGetLastError()
                        ));

            serr = SOCKET_ERROR;
        }
    } else {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("connect(%#x) returns %d\n",
                    m_Socket,
                    _I_WSAGetLastError()
                    ));

    }

    //
    // if originally non-blocking, make socket non-blocking again
    //

    if (non_blocking) {
        SetNonBlockingMode(TRUE);
    }

    //
    // if success, mark the socket as being connected through firewall
    //

    if (serr == SOCKET_ERROR) {
        _I_WSASetLastError(WSAECONNREFUSED);
    }

    DEBUG_LEAVE(serr);

    return serr;
}


DWORD
ICSocket::Disconnect(
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Undoes the work of ConnectSocket - i.e. closes a connected socket. We make
    callbacks to inform the app that this socket is being closed

Arguments:

    dwFlags - controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Disconnect",
                 "{%#x/%d} %#x",
                 GetSocket(),
                 GetSourcePort(),
                 dwFlags
                 ));

    //
    // let the app know we are closing the connection
    //

    if (dwFlags & SF_INDICATE) {
        InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION, NULL, 0);
    }

    DWORD error = Close();

    if ((error == ERROR_SUCCESS) && (dwFlags & SF_INDICATE)) {

        //
        // let the app know the connection is closed
        //

        InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED, NULL, 0);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Close(
    VOID
    )

/*++

Routine Description:

    Closes a connected socket. Assumes that any linger or shutdown etc.
    requirements have already been applied to the socket

Arguments:

    none.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Close",
                 "{%#x/%d}",
                 GetSocket(),
                 GetSourcePort()
                 ));

    DWORD error = ERROR_SUCCESS;

    if (IsOpen()) {
//dprintf("**** closing %#x\n", m_Socket);

        int serr;

        __try {
            serr = _I_closesocket(m_Socket);
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            serr = 0;
        }
        ENDEXCEPT
        error = (serr == SOCKET_ERROR)
            ? MapInternetError(_I_WSAGetLastError())
            : ERROR_SUCCESS;
    }

    //
    // the socket is now closed
    //

    m_Socket = INVALID_SOCKET;

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Abort(
    VOID
    )

/*++

Routine Description:

    Aborts a socket by simply closing it

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Abort",
                 "{%#x/%d}",
                 GetSocket(),
                 GetSourcePort()
                 ));

    DWORD error = Close();

    if (error == ERROR_SUCCESS) {
        SetAborted();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Shutdown(
    IN DWORD dwControl
    )

/*++

Routine Description:

    Stops any more send/receives from the socket

Arguments:

    dwControl   - 0 to stop receives, 1 to stop sends, 2 to stop both

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Shutdown",
                 "{%#x/%d}",
                 GetSocket(),
                 GetSourcePort()
                 ));

    DWORD error = ERROR_SUCCESS;

    if (IsOpen()) {

        int serr = _I_shutdown(m_Socket, dwControl);

        if (serr == SOCKET_ERROR) {

            //
            // map any sockets error to WinInet error
            //

            error = MapInternetError(_I_WSAGetLastError());
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


BOOL
ICSocket::IsReset(
    VOID
    )

/*++

Routine Description:

    Determines if the socket has been closed. We peek the socket for 1 byte. If
    the socket is in blocking mode, we temporarily switch to non-blocking to
    perform the test - we don't want to block, nor remove any data from the
    socket

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - socket reset (closed by server)

        FALSE   - socket alive

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "ICSocket::IsReset",
                 "{%#x [%#x/%d]}",
                 this,
                 GetSocket(),
                 GetSourcePort()
                 ));

    CHECK_ICSOCKET();

    BOOL bReset = FALSE;
    BOOL bSetBlocking = FALSE;

    if (IsOpen()) {
        if (!IsNonBlocking()) {
            SetNonBlockingMode(TRUE);
            bSetBlocking = TRUE;
        }

        char ch;
#ifndef unix
        int n = _I_recv(m_Socket, &ch, 1, MSG_PEEK);
        if (n < 0) {

            DWORD error = _I_WSAGetLastError();

            if (error != WSAEWOULDBLOCK) {

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("recv() returns %s (%d)\n",
                            InternetMapError(error),
                            error
                            ));

                n = 0;
            }
        }
        if (n == 0) {
#else
        DWORD dwAvail = 0;
        int n = _I_ioctlsocket(m_Socket,FIONREAD,&dwAvail);
        if (n != 0) {
#endif /* unix */
            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("socket %#x/port %d is reset\n",
                        m_Socket,
                        m_SourcePort
                        ));

            bReset = TRUE;
        }
        if (bSetBlocking) {
            SetNonBlockingMode(FALSE);
        }
    } else {
        bReset = TRUE;
    }

    DEBUG_LEAVE(bReset);

    return bReset;
}


DWORD
ICSocket::SetTimeout(
    IN DWORD Type,
    IN int Timeout
    )

/*++

Routine Description:

    Sets a timeout value for a connected socket

Arguments:

    Type            - type of timeout to set - send, or receive

    Timeout         - timeout value to set

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SetTimeout",
                 "{%#x/%d} %s (%d), %d",
                 GetSocket(),
                 GetSourcePort(),
                 (Type == SEND_TIMEOUT) ? "SEND_TIMEOUT"
                    : (Type == RECEIVE_TIMEOUT) ? "RECEIVE_TIMEOUT"
                    : "?",
                 Type,
                 Timeout
                 ));

    INET_ASSERT((Type == SEND_TIMEOUT) || (Type == RECEIVE_TIMEOUT));

    if (Timeout == INFINITE)
    {
        Timeout = 0;
    }
    
    int serr = _I_setsockopt(m_Socket,
                             SOL_SOCKET,
                             (Type == SEND_TIMEOUT)
                                ? SO_SNDTIMEO
                                : SO_RCVTIMEO,
                             (const char FAR *)&Timeout,
                             sizeof(Timeout)
                             );

    DWORD error = ERROR_SUCCESS;

    if (serr == SOCKET_ERROR) {
        if (IsAborted()) {
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
        } else {
            error = MapInternetError(_I_WSAGetLastError());
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::SetLinger(
    IN BOOL Linger,
    IN int Timeout
    )

/*++

Routine Description:

    Sets the linger option for a connected socket

Arguments:

    Linger  - FALSE if the caller wants immediate shutdown of the socket
              when closed, or TRUE if we are to wait around until
              queued data has been sent

    Timeout - timeout value to use if Linger is TRUE

Return Value:

    DWORD
        Success - ERROR_SUCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SetLinger",
                 "{%#x/%d} %B, %d",
                 GetSocket(),
                 GetSourcePort(),
                 Linger,
                 Timeout
                 ));

    DWORD error = ERROR_SUCCESS;

    if (IsAborted()) {
        error = ERROR_WINHTTP_OPERATION_CANCELLED;
    } else if (IsOpen()) {

        LINGER linger;

        INET_ASSERT(Timeout <= USHRT_MAX);

        linger.l_onoff = (u_short)(Linger ? 1 : 0);
        linger.l_linger = (u_short)Timeout;


        //
        // in some shutdown situations, we are hitting exception in winsock
        // on win95 (!). Handle exception
        //

        __try {
            if (_I_setsockopt(m_Socket,
                              SOL_SOCKET,
                              SO_LINGER,
                              (const char FAR *)&linger,
                              sizeof(linger)
                              ) == SOCKET_ERROR) {
                error = MapInternetError(_I_WSAGetLastError());
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // do nothing except catch exception in retail
            //

            DEBUG_PRINT(SOCKETS,
                        ERROR,
                        ("exception closing socket %#x/%d\n",
                        GetSocket(),
                        GetSourcePort()
                        ));

            INET_ASSERT(IsOpen());

        }
        ENDEXCEPT
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::SetNonBlockingMode(
    IN BOOL bNonBlocking
    )

/*++

Routine Description:

    Sets socket non-blocking/blocking mode

Arguments:

    bNonBlocking    - TRUE if non-blocking, FALSE if blocking

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error mapped to INTERNET error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SetNonBlockingMode",
                 "{%#x/%d} %B",
                 GetSocket(),
                 GetSourcePort(),
                 bNonBlocking
                 ));

    u_long on = (bNonBlocking) ? 1 : 0;
    DWORD error = ERROR_SUCCESS;

    if (_I_ioctlsocket(m_Socket, FIONBIO, &on) == 0) {
        if (on) {
            m_dwFlags |= SF_NON_BLOCKING;
        } else {
            m_dwFlags &= ~SF_NON_BLOCKING;
        }
    } else {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("failed to put socket %#x/port %d into %sblocking mode\n",
                    m_Socket,
                    m_SourcePort,
                    on ? "non-" : ""
                    ));

        if (IsAborted()) {
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
        } else {
            error = MapInternetError(_I_WSAGetLastError());
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::GetBufferLength(
    IN SOCKET_BUFFER_ID SocketBufferId
    )

/*++

Routine Description:

    Returns the send or receive buffer length for this socket object

Arguments:

    SocketBufferId  - which buffer length to return

Return Value:

    DWORD

--*/

{
    //
    // BUGBUG - RLF 04/29/96
    //
    // This function should access first the current object, then the parent
    // object, then the globals for this data
    //

    switch (SocketBufferId) {
    case ReceiveBuffer:
        return GlobalSocketReceiveBufferLength;

    case SendBuffer:
        return GlobalSocketSendBufferLength;
    }
    return (DWORD)-1;
}


DWORD
ICSocket::GetBufferLength(
    IN SOCKET_BUFFER_ID SocketBufferId,
    OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Gets the socket send or receive buffer length (if supported)

Arguments:

    SocketBufferId      - which buffer to set

    lpdwBufferLength    - where to write length

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Int,
                 "ICSocket::GetBufferLength",
                 "{%#x/%d} %s, %#x",
                 GetSocket(),
                 GetSourcePort(),
                 (SocketBufferId == ReceiveBuffer)
                    ? "ReceiveBuffer"
                    : ((SocketBufferId == SendBuffer)
                        ? "SendBuffer"
                        : "?")
                 ));

    DWORD size = sizeof(*lpdwBufferLength);

    int serr = _I_getsockopt(m_Socket,
                             SOL_SOCKET,
                             SocketBufferId,
                             (char FAR *)lpdwBufferLength,
                             (int FAR *)&size
                             );

    DWORD error;

    if (serr != SOCKET_ERROR) {
        error = ERROR_SUCCESS;
    } else {
        error = MapInternetError(_I_WSAGetLastError());
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::SetBufferLength(
    IN SOCKET_BUFFER_ID SocketBufferId,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Sets the socket send or receive buffer length

Arguments:

    SocketBufferId  - which buffer to set

    dwBufferLength  - length to set it to

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error mapped to INTERNET error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SetBufferLength",
                 "{%#x/%d} %s, %d",
                 GetSocket(),
                 GetSourcePort(),
                 (SocketBufferId == ReceiveBuffer)
                    ? "ReceiveBuffer"
                    : (SocketBufferId == SendBuffer)
                        ? "SendBuffer"
                        : "?",
                 dwBufferLength
                 ));

    INET_ASSERT((int)dwBufferLength >= 0);

    DWORD size = sizeof(dwBufferLength);

    int serr = _I_setsockopt(m_Socket,
                             SOL_SOCKET,
                             SocketBufferId,
                             (const char FAR *)&dwBufferLength,
                             (int)size
                             );

    DWORD error = ERROR_SUCCESS;

    if (serr == SOCKET_ERROR) {
        if (IsAborted()) {
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
        } else {
            error = MapInternetError(_I_WSAGetLastError());
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::SetSendCoalescing(
    IN BOOL bOnOff
    )

/*++

Routine Description:

    Enables or disables Nagle algorithm

Arguments:

    bOnOff  - FALSE to disable, TRUE to enable

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SetSendCoalescing",
                 "{%#x/%d} %B",
                 GetSocket(),
                 GetSourcePort(),
                 bOnOff
                 ));

    int optval = bOnOff ? 0 : 1;
    int serr = _I_setsockopt(m_Socket,
                             IPPROTO_TCP,
                             TCP_NODELAY,
                             (const char FAR *)&optval,
                             sizeof(optval)
                             );

    DWORD error = ERROR_SUCCESS;

    if (serr == SOCKET_ERROR) {
        if (IsAborted()) {
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
        } else {
            error = MapInternetError(_I_WSAGetLastError());
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


VOID
ICSocket::SetSourcePort(
    VOID
    )

/*++

Routine Description:

    Record the port we are connected to locally. Useful for debugging & matching
    up socket with net sniff

Arguments:

    None.

Return Value:

    None.

--*/

{
    SOCKADDR_IN address;
    int namelen = sizeof(address);

    if (_I_getsockname(GetSocket(), (LPSOCKADDR)&address, &namelen) == 0) {
        m_SourcePort = (INTERNET_PORT)_I_ntohs(address.sin_port);
    } else {
        m_SourcePort = 0;
    }
}


DWORD
ICSocket::Send(
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Sends data over connected socket

Arguments:

    lpBuffer        - pointer to buffer containing data to send

    dwBufferLength  - length of lpBuffer in bytes

    dwFlags         - flags controlling send:

                        SF_INDICATE     - make status callbacks to the app when
                                          we are starting to send data and when
                                          we finish

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't create FSM

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Send",
                 "{%#x [%#x/%d]} %#x, %d, %#x",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 lpBuffer,
                 dwBufferLength,
                 dwFlags
                 ));

    INET_ASSERT(lpBuffer != NULL);
    INET_ASSERT((int)dwBufferLength > 0);

    DWORD error = DoFsm(New CFsm_SocketSend(lpBuffer,
                                            dwBufferLength,
                                            dwFlags,
                                            this
                                            ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SocketSend::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    Runs next CFsm_SocketSend state

Arguments:

    Fsm - socket send FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SocketSend::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSocket * pSocket = (ICSocket *)Fsm->GetContext();
    CFsm_SocketSend * stateMachine = (CFsm_SocketSend *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
    case FSM_STATE_ERROR:
        error = pSocket->Send_Start(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Send_Start(
    IN CFsm_SocketSend * Fsm
    )

/*++

Routine Description:

    Continues send request - sends the data

Arguments:

    Fsm - socket send FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Send_Start",
                 "{%#x [%#x/%d]} %#x(%#x, %d, %#x)",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 Fsm,
                 Fsm->m_lpBuffer,
                 Fsm->m_dwBufferLength,
                 Fsm->m_dwFlags
                 ));

    CFsm_SocketSend & fsm = *Fsm;
    DWORD error = fsm.GetError();
    FSM_STATE state = fsm.GetState();
    INTERNET_HANDLE_OBJECT * pObject = fsm.GetMappedHandleObject();

    if (error != ERROR_SUCCESS) 
    {
        goto quit;
    }
    if (state == FSM_STATE_INIT) {
        if (!(m_dwFlags & (SF_ENCRYPT | SF_DECRYPT))) {

            DEBUG_DUMP_API(SOCKETS,
                           "sending data:\n",
                           fsm.m_lpBuffer,
                           fsm.m_dwBufferLength
                           );

        }

        if (pObject != NULL) {
            pObject->SetAbortHandle(this);
        }
        
        if (fsm.m_dwFlags & SF_INDICATE) {
            error = InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_SENDING_REQUEST, NULL, 0);

            if (error != ERROR_SUCCESS)
            {
                INET_ASSERT(error == ERROR_WINHTTP_OPERATION_CANCELLED);
                goto quit;
            }
        }

        fsm.StartTimer();
    }
    
    while (fsm.m_dwBufferLength != 0) 
    {
        //
        // the socket may have already been aborted
        //

        if (IsAborted()) {
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
            break;
        }

        if (fsm.m_pServerInfo != NULL) {
            fsm.m_pServerInfo->SetLastActiveTime();
        }

        DWORD dwSendSize;
#define GLOBAL_MAX_SEND_LENGTH_DEFAULT (4*1024*1024)
        if (fsm.m_dwBufferLength > GLOBAL_MAX_SEND_LENGTH_DEFAULT)
        {
            dwSendSize = GLOBAL_MAX_SEND_LENGTH_DEFAULT;
        }
        else
        {
            dwSendSize = fsm.m_dwBufferLength;
        }
        
        int nSent;
        
        if (IsNonBlocking()) 
        {
            if (fsm.bIOCPInited)
            {
                fsm.bIOCPInited = FALSE;

                if (fsm.bIOCPSuccess)
                {
                    //send completed successfully
                    DEBUG_PRINT(SOCKETS,
                                INFO,
                                ("WSASend sent %d bytes @ %#x to socket %#x/port %d\n",
                                fsm.dwBytesTransferred,
                                fsm.m_lpBuffer,
                                m_Socket,
                                m_SourcePort
                                ));
                                
                    error = ERROR_SUCCESS;

                    nSent = (int)fsm.dwBytesTransferred;
                    fsm.m_iTotalSent = nSent;
                    fsm.m_lpBuffer = (LPBYTE)fsm.m_lpBuffer + nSent;
                    fsm.m_dwBufferLength -= nSent;
                    continue;
                }
                else
                {
                    //
                    // map any sockets error to WinInet error and terminate this
                    // request
                    //

                    //VENKATKBUG - handle retrieable errors such as WSAWOULDBLOCK
                    
                    DEBUG_PRINT(SOCKETS,
                                ERROR,
                                ("send() returns %d (%s)\n",
                                error,
                                InternetMapError(error)
                                ));

                    error = MapInternetError(error);
                    break;
                }
            }// if fsm.bIOCPInited()
    
                
            WSABUF wsabuf;
            wsabuf.len = dwSendSize; //fsm.m_dwBufferLength;
            wsabuf.buf = (char FAR *)fsm.m_lpBuffer;
            int nError;

            if (!_lpWrapOverlappedSend)
            {
                _lpWrapOverlappedSend = New CWrapOverlapped();

                if (!_lpWrapOverlappedSend)
                {
                    error = ERROR_NOT_ENOUGH_MEMORY;
                    goto quit;
                }
            }

            CWrapOverlapped* lpWrapOverlapped = _lpWrapOverlappedSend;
            LPWSAOVERLAPPED lpOverlapped = _lpWrapOverlappedSend->GetOverlapped();
            memset(lpOverlapped, 0, sizeof(WSAOVERLAPPED));
            
            CFsm* pFsmOld = GetAndSetCurrentFsm(&fsm);
            INET_ASSERT (pFsmOld == NULL);

            fsm.bIOCPInited = TRUE;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("calling WSASend() blocked, socket %#x, port %d\n",
                        m_Socket,
                        m_SourcePort
                        ));

            fsm.SetAction(FSM_ACTION_SEND);

            DWORD timeout = GetTimeoutValue(WINHTTP_OPTION_SEND_TIMEOUT);

            if (timeout != INFINITE)
            {
                fsm.SetTimeout(timeout);
                fsm.SetOnAsyncList(TRUE);
                error = QueueSocketWorkItem(Fsm, m_Socket);
                
                INET_ASSERT (error == ERROR_IO_PENDING);
                if (error != ERROR_IO_PENDING)
                {
                    // 2 causes - both irrecoverable
                    // 1. no global pointer to ICAsyncThread
                    // OR 2. no threadinfo or SelectThread.
                    // so bail!
                    GetAndSetCurrentFsm(NULL);
                    fsm.bIOCPInited = FALSE;
                    fsm.SetOnAsyncList(FALSE);
                    fsm.SetErrorState(error);
                    goto quit;
                }
            }

            _lpWrapOverlappedSend->Reference(); // to keep this ICSocket=>the Overlapped struct valid beyong the WSASend() call.
            _lpWrapOverlappedSend->Reference(); // to make sure it stays alive for the IOCP to get the fsm off it.
            
            DEBUG_ENTER((DBG_API,
                             Dword,
                             "***WSASend",
                             "(m_Socket)%#x, (wsabuf.buf)%#x, (wsabuf.len)%#x, (this)%#x, (overlapped)%#x, (fsm)%#x",
                             m_Socket,
                             wsabuf.buf,
                             wsabuf.len,
                             this,
                             lpOverlapped,
                             &fsm
                             ));
                             
            nError = _I_WSASend(m_Socket,
                            &wsabuf,
                            1,
                            (LPDWORD)&nSent,
                            0,
                            lpOverlapped,
                            NULL);


            DEBUG_LEAVE(nError);                        

            lpWrapOverlapped->Dereference(); // release the WSASend reference.
            
            DEBUG_PRINT(SOCKETS,
                        ERROR,
                        ("WSASend() returns %d (%s) with nSent=%d bytes\n",
                        nError,
                        InternetMapError(nError),
                        nSent
                        ));

            if (nError == 0)
            {
#if INET_DEBUG
                InterlockedIncrement(&g_cWSACompletions);
#endif
                 error = ERROR_IO_PENDING;
                 break;
            }
            else
            {
                INET_ASSERT (nError == SOCKET_ERROR);

                error = _I_WSAGetLastError();

                if (error == WSA_IO_PENDING) 
                {
#if INET_DEBUG
                    InterlockedIncrement(&g_cWSACompletions);
#endif
                    error = ERROR_IO_PENDING;
                    break;
                } 
                else
                {
                    // no IOCompletion here.
                    // VENKATKBUG: remove this assert later, only informational.
                    // DWORD dwError = error; //dummy for debugging
                    // INET_ASSERT (FALSE);
                    if (fsm.HasTimeout())
                    {
                        if (!RemoveFsmFromAsyncList(&fsm))
                        {
                            //failure! the select thread already enforced timeout and updated state
                            //informational assert.
                            //VENKATK_BUG-enable later INET_ASSERT (FALSE && "COOL: select enforced timeout");
                        }
                    }

                    GetAndSetCurrentFsm(NULL);
                    lpWrapOverlapped->Dereference(); // release the IOCP-based reference.
                    
                    //
                    // check first to see if the error was due to the socket being
                    // closed as a result of the request being cancelled
                    //
                    if (IsAborted()) 
                    {
                        error = ERROR_WINHTTP_OPERATION_CANCELLED;
                        break;
                    }
                    
                    //
                    // map any sockets error to WinInet error and terminate this
                    // request
                    //

                    //VENKATKBUG - handle retrieable errors such as WSAWOULDBLOCK
                    error = MapInternetError(error);
                    break;
                }
            }//if! nError == 0
        }
        else// if IsNonBlocking()
        {
            nSent = _I_send(m_Socket,
                                (char FAR *)fsm.m_lpBuffer,
                                dwSendSize, //fsm.m_dwBufferLength,
                                0
                                );

            if (nSent != SOCKET_ERROR) 
            {
                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("sent %d bytes @ %#x to socket %#x/port %d\n",
                            nSent,
                            fsm.m_lpBuffer,
                            m_Socket,
                            m_SourcePort
                            ));

                fsm.m_iTotalSent += nSent;
                fsm.m_lpBuffer = (LPBYTE)fsm.m_lpBuffer + nSent;
                fsm.m_dwBufferLength -= nSent;
            } 
            else 
            {
                //
                // check first to see if the error was due to the socket being
                // closed as a result of the request being cancelled
                //

                if (IsAborted()) 
                {
                    error = ERROR_WINHTTP_OPERATION_CANCELLED;
                    break;
                } 
                else 
                {
                    error = _I_WSAGetLastError();
                    //
                    // map any sockets error to WinHttp error and terminate this
                    // request
                    //

                    DEBUG_PRINT(SOCKETS,
                                ERROR,
                                ("send() returns %d (%s)\n",
                                error,
                                InternetMapError(error)
                                ));

                    error = MapInternetError(error);
                    break;
                }
            }// if! nSent!=SOCKET_ERROR
        }// if! IsNonBlocking()
    }// while fsm.m_dwBufferLength != 0

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.StopTimer();
        if (fsm.GetMappedHandleObject() != NULL) {
            fsm.GetMappedHandleObject()->ResetAbortHandle();
        }
        if (IsAborted()) {
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
        } else if (error == ERROR_SUCCESS) {
            if (fsm.m_dwFlags & SF_INDICATE) 
            {
                INT iTotalSent = fsm.m_iTotalSent;
                InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_REQUEST_SENT,
                                       &iTotalSent,
                                       sizeof(iTotalSent)
                                       );
            }
            if (fsm.m_pServerInfo != NULL) {
                //fsm.m_pServerInfo->UpdateSendTime(fsm.ReadTimer());
            }
        }
        fsm.SetDone(error);
    }

    DEBUG_LEAVE(error);

    return error;
}

//
//DWORD
//ICSocket::SendTo(
//    IN LPSOCKADDR lpDestination,
//    IN DWORD dwDestinationLength,
//    IN LPVOID lpBuffer,
//    IN DWORD dwBufferLength,
//    OUT LPDWORD lpdwBytesSent,
//    IN DWORD dwWinsockFlags,
//    IN DWORD dwFlags
//    )
//
///*++
//
//Routine Description:
//
//    Wrapper for sendto()
//
//Arguments:
//
//    lpDestination       - pointer to remote address to send to
//
//    dwDestinationLength - length of *lpDestination
//
//    lpBuffer            - pointer to buffer containing data to send
//
//    dwBufferLength      - number of bytes to send from lpBuffer
//
//    lpdwBytesSent       - number of bytes sent to destination
//
//    dwWinsockFlags      - flags to pass through to sendto()
//
//    dwFlags             - ICSocket flags
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - ERROR_WINHTTP_OPERATION_CANCELLED
//                    The operation was cancelled by the caller
//
//                  ERROR_WINHTTP_TIMEOUT
//                    The operation timed out
//
//                  ERROR_WINHTTP_CONNECTION_ERROR
//                    An error occurred. We approximate to connection reset
//
//                  WSA error
//                    Some other sockets error occurred
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_SOCKETS,
//                 Dword,
//                 "ICSocket::SendTo",
//                 "{%#x} %#x, %d, %#x, %d, %#x, %#x, %#x",
//                 m_Socket,
//                 lpDestination,
//                 dwDestinationLength,
//                 lpBuffer,
//                 dwBufferLength,
//                 lpdwBytesSent,
//                 dwWinsockFlags,
//                 dwFlags
//                 ));
//
//    INET_ASSERT(IsSocketValid());
//    INET_ASSERT(lpdwBytesSent != NULL);
//
//    int totalSent = 0;
//    DWORD error = ERROR_SUCCESS;
//    INTERNET_HANDLE_OBJECT * pObject = NULL;
//    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
//    BOOL fNonBlocking;
//
//    if (IsAborted()) {
//        error = ERROR_WINHTTP_OPERATION_CANCELLED;
//        goto quit;
//    }
//
//    if (lpThreadInfo == NULL) {
//
//        INET_ASSERT(FALSE);
//
//        error = ERROR_WINHTTP_INTERNAL_ERROR;
//        goto quit;
//    }
//
//    fNonBlocking = lpThreadInfo->IsAsyncWorkerThread;
//
//    //
//    // set the cancel socket in the object
//    //
//
//    pObject = (INTERNET_HANDLE_OBJECT * )lpThreadInfo->hObjectMapped;
//    if (pObject != NULL) {
//        pObject->SetAbortHandle(this);
//    }
//
//    //
//    // if we are in async (== non-blocking) mode, let the async request
//    // scheduler know what operation we will be waiting on
//    //
//
//    if (fNonBlocking) {
//
//        INET_ASSERT(lpThreadInfo->lpArb != NULL);
//
//        SET_ARB_SOCKET_OPERATION(lpThreadInfo->lpArb, m_Socket, SEND);
//    }
//
//    if (dwFlags & SF_INDICATE) {
//
//        //
//        // let the app know we are starting to send data
//        //
//
//        InternetIndicateStatus(INTERNET_STATUS_SENDING_REQUEST,
//                               NULL,
//                               0
//                               );
//    }
//
//    DEBUG_DUMP(SOCKETS,
//               "sending data:\n",
//               lpBuffer,
//               dwBufferLength
//               );
//
//    int nSent;
//
//    //
//    // loop until all data sent
//    //
//
//    do {
//
//        nSent = _I_sendto(m_Socket,
//                          (char FAR *)lpBuffer + totalSent,
//                          dwBufferLength,
//                          dwWinsockFlags,
//                          lpDestination,
//                          dwDestinationLength
//                          );
//        if (nSent != SOCKET_ERROR) {
//
//            DEBUG_PRINT(SOCKETS,
//                        INFO,
//                        ("sent %d bytes @ %#x on socket %#x\n",
//                        nSent,
//                        (LPBYTE)lpBuffer + totalSent,
//                        m_Socket
//                        ));
//
//            INET_ASSERT(nSent > 0);
//
//            totalSent += nSent;
//            dwBufferLength -= nSent;
//        } else {
//            error = _I_WSAGetLastError();
//            if ((error == WSAEWOULDBLOCK) && fNonBlocking) {
//
//                INET_ASSERT(_dwFlags & SF_NON_BLOCKING);
//
//                DEBUG_PRINT(SOCKETS,
//                            INFO,
//                            ("sendto(%#x) would block\n",
//                            m_Socket
//                            ));
//
//                lpThreadInfo->lpArb->Header.dwResultCode = ERROR_SUCCESS;
//
//                SwitchToAsyncScheduler(m_Socket);
//
//                error = lpThreadInfo->lpArb->Header.dwResultCode;
//
//                DEBUG_PRINT(SOCKETS,
//                            INFO,
//                            ("sendto(%#x) resumed, returns %s\n",
//                            m_Socket,
//                            InternetMapError(error)
//                            ));
//
//                if (error != ERROR_SUCCESS) {
//                }
//            } else {
//
//                //
//                // some other error
//                //
//
//                error = MapInternetError(error);
//            }
//        }
//
//        INET_ASSERT((int)dwBufferLength >= 0);
//
//    } while ((dwBufferLength != 0) && (error == ERROR_SUCCESS));
//
//    if ((dwFlags & SF_INDICATE) && (error == ERROR_SUCCESS)) {
//
//        //
//        // let the app know we have finished sending
//        //
//
//        InternetIndicateStatus(INTERNET_STATUS_REQUEST_SENT,
//                               &totalSent,
//                               sizeof(totalSent)
//                               );
//    }
//
//    //
//    // if we are in async (== non-blocking) mode, let the async request
//    // scheduler know that we no longer require this socket
//    //
//
//    if (fNonBlocking) {
//
//        INET_ASSERT(lpThreadInfo->lpArb != NULL);
//
//        SET_ARB_SOCKET_OPERATION(lpThreadInfo->lpArb, INVALID_SOCKET, SEND);
//    }
//
//quit:
//
//    *lpdwBytesSent = totalSent;
//
//    //
//    // no longer performing operation on this socket
//    //
//
//    if (pObject != NULL) {
//        pObject->ResetAbortHandle();
//
//        //
//        // if the operation has been cancelled, then this error overrides any
//        // other
//        //
//
//        //if (pObject->IsInvalidated()) {
//        //    error = pObject->GetError();
//        //    if (error == ERROR_SUCCESS) {
//        //        error = ERROR_WINHTTP_OPERATION_CANCELLED;
//        //    }
//        //}
//        if (IsAborted()) {
//            error = ERROR_WINHTTP_OPERATION_CANCELLED;
//        }
//    }
//
//    INET_ASSERT((pObject != NULL) ? (pObject->GetAbortHandle() == NULL) : TRUE);
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}


DWORD
ICSocket::Receive(
    IN OUT LPVOID * lplpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwBufferRemaining,
    IN OUT LPDWORD lpdwBytesReceived,
    IN DWORD dwExtraSpace,
    IN DWORD dwFlags,
    OUT LPBOOL lpbEof
    )

/*++

Routine Description:

    Receives data from connected socket. Depending on flags settings, we will
    perform a single receive, loop until we have filled the buffer and/or loop
    until we have received all the data.

    This function returns user data, so if the stream we are receiving from is
    encrypted, we must decrypt the data before returning. This may require
    receiving more data than the user expects because we have to decrypt at
    message boundaries

    This function is intended to be called in a loop. The buffer pointer and
    buffer sizes are intended to be updated by each successive call to this
    function, and should therefore have the same values the next time this
    function is called

Arguments:

    lplpBuffer          - pointer to pointer to users buffer. If supplied, the
                          buffer should be LMEM_FIXED

    lpdwBufferLength    - size of buffer

    lpdwBufferRemaining - number of bytes left in the buffer

    lpdwBytesReceived   - number of bytes received

    dwExtraSpace        - number of additional bytes caller wants at end of
                          buffer (only useful if resizing AND only applied at
                          end of receive)

    dwFlags             - flags controlling receive:

                            SF_EXPAND       - lpBuffer can be expanded to fit
                                              data

                            SF_COMPRESS     - if set, we will shrink the buffer
                                              to compress out any unused space

                            SF_RECEIVE_ALL  - if set, this function will loop
                                              until all data received, or the
                                              supplied buffer is filled

                            SF_INDICATE     - if set, we will make status
                                              callbacks to the app when we are
                                              starting to receive data, and when
                                              we finish

                            SF_WAIT         - (used with SF_NON_BLOCKING). Even
                                              though the socket is non-blocking,
                                              the caller wants us to not
                                              relinquish control under the
                                              request has been satisfied

    lpbEof              - TRUE if we got end-of-connection indication
                          (recv() returns 0)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't allocate/grow buffer

                  ERROR_INSUFFICIENT_BUFFER
                    The initial buffer was insufficient (i.e. caller supplied
                    buffer pointer was NULL, or we ran out of buffer space and
                    are not allowed to resize it)

                  WSA error
                    Sockets error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Receive",
                 "%#x [%#x], %#x [%d], %#x [%d], %#x [%d], %d, %#x, %#x [%B]",
                 lplpBuffer,
                 *lplpBuffer,
                 lpdwBufferLength,
                 *lpdwBufferLength,
                 lpdwBufferRemaining,
                 *lpdwBufferRemaining,
                 lpdwBytesReceived,
                 *lpdwBytesReceived,
                 dwExtraSpace,
                 dwFlags,
                 lpbEof,
                 *lpbEof
                 ));

    INET_ASSERT((int)*lpdwBufferLength >= 0);
    INET_ASSERT((int)*lpdwBufferRemaining >= 0);
    INET_ASSERT((int)*lpdwBytesReceived >= 0);

#define SF_MUTEX_FLAGS  (SF_RECEIVE_ALL | SF_NO_WAIT)

    INET_ASSERT((dwFlags & SF_MUTEX_FLAGS) != SF_MUTEX_FLAGS);

    DWORD error = DoFsm(New CFsm_SocketReceive(lplpBuffer,
                                               lpdwBufferLength,
                                               lpdwBufferRemaining,
                                               lpdwBytesReceived,
                                               dwExtraSpace,
                                               dwFlags,
                                               lpbEof,
                                               this
                                               ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SocketReceive::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    Runs next CFsm_SocketReceive state

Arguments:

    Fsm - socket receive FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SocketReceive::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSocket * pSocket = (ICSocket *)Fsm->GetContext();
    CFsm_SocketReceive * stateMachine = (CFsm_SocketReceive *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
        error = pSocket->Receive_Start(stateMachine);
        break;

    case FSM_STATE_CONTINUE:
    case FSM_STATE_ERROR:
        error = pSocket->Receive_Continue(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Receive_Start(
    IN CFsm_SocketReceive * Fsm
    )

/*++

Routine Description:

    Initiates a receive request - grows the buffer if required and kicks off the
    first receive operation

Arguments:

    Fsm - reference to FSM controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Receive_Start",
                 "{%#x [%#x/%d]} %#x(%#x [%#x], %#x [%d], %#x [%d], %#x [%d], %d, %#x, %#x [%B])",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 Fsm,
                 Fsm->m_lplpBuffer,
                 *Fsm->m_lplpBuffer,
                 Fsm->m_lpdwBufferLength,
                 *Fsm->m_lpdwBufferLength,
                 Fsm->m_lpdwBufferRemaining,
                 *Fsm->m_lpdwBufferRemaining,
                 Fsm->m_lpdwBytesReceived,
                 *Fsm->m_lpdwBytesReceived,
                 Fsm->m_dwExtraSpace,
                 Fsm->m_dwFlags,
                 Fsm->m_lpbEof,
                 *Fsm->m_lpbEof
                 ));

    CFsm_SocketReceive & fsm = *Fsm;
    DWORD error = ERROR_SUCCESS;

    //
    // if we weren't given a buffer, but the caller told us its okay to resize
    // then we allocate the initial buffer
    //

    if ((fsm.m_dwBufferLength == 0) || (fsm.m_dwBufferLeft == 0)) {

        INET_ASSERT((fsm.m_dwBufferLength == 0) ? (fsm.m_dwBufferLeft == 0) : TRUE);

        if (fsm.m_dwFlags & SF_EXPAND) {

            //
            // allocate a fixed memory buffer
            //

            //
            // BUGBUG - the initial buffer size should come from the handle
            //          object
            //

            fsm.m_dwBufferLeft = DEFAULT_RECEIVE_BUFFER_INCREMENT;
            if (fsm.m_dwBufferLength == 0) {
                fsm.m_bAllocated = TRUE;
            }
            fsm.m_dwBufferLength += fsm.m_dwBufferLeft;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("resizing %#x to %d\n",
                        fsm.m_hBuffer,
                        fsm.m_dwBufferLength
                        ));

            fsm.m_hBuffer = ResizeBuffer(fsm.m_hBuffer, fsm.m_dwBufferLength, FALSE);
            if (fsm.m_hBuffer == (HLOCAL)NULL) {
                error = GetLastError();

                INET_ASSERT(error != ERROR_SUCCESS);

                fsm.m_bAllocated = FALSE;
            }
        } else {

            //
            // the caller didn't say its okay to resize
            //

            error = ERROR_INSUFFICIENT_BUFFER;
        }
    } else if (fsm.m_hBuffer == (HLOCAL)NULL) {
        error = ERROR_INSUFFICIENT_BUFFER;
    }
    if (error == ERROR_SUCCESS) {
        if (fsm.GetMappedHandleObject() != NULL) {
            fsm.GetMappedHandleObject()->SetAbortHandle(this);
        }

        //
        // keep the app informed (if requested to do so)
        //

        if (fsm.m_dwFlags & SF_INDICATE) {
            error = InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE, NULL, 0);

            if (error != ERROR_SUCCESS)
            {
                INET_ASSERT(error == ERROR_WINHTTP_OPERATION_CANCELLED);
                fsm.SetError(error);
            }
        }

        //
        // kick off the receive request. If we complete synchronously (with
        // an error or successfully), then call the finish handler here
        //

        error = Receive_Continue(Fsm);
    } else {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Receive_Continue(
    IN CFsm_SocketReceive * Fsm
    )

/*++

Routine Description:

    Receives data from connected socket. Depending on flags settings, we will
    perform a single receive, loop until we have filled the buffer and/or loop
    until we have received all the data.

Arguments:

    Fsm - reference to FSM controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Receive_Continue",
                 "{%#x [%#x/%d]} %#x(%#x [%#x], %#x [%d], %#x [%d], %#x [%d], %d, %#x, %#x [%B])",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 Fsm,
                 Fsm->m_lplpBuffer,
                 *Fsm->m_lplpBuffer,
                 Fsm->m_lpdwBufferLength,
                 *Fsm->m_lpdwBufferLength,
                 Fsm->m_lpdwBufferRemaining,
                 *Fsm->m_lpdwBufferRemaining,
                 Fsm->m_lpdwBytesReceived,
                 *Fsm->m_lpdwBytesReceived,
                 Fsm->m_dwExtraSpace,
                 Fsm->m_dwFlags,
                 Fsm->m_lpbEof,
                 *Fsm->m_lpbEof
                 ));

    CFsm_SocketReceive & fsm = *Fsm;
    DWORD error = fsm.GetError();
    INTERNET_HANDLE_OBJECT * pObject = fsm.GetMappedHandleObject();

    if (error != ERROR_SUCCESS) {
        goto error_exit;
    }

    fsm.m_lpBuffer = (LPBYTE)fsm.m_hBuffer + fsm.m_dwBytesReceived;

    //
    // receive some data
    //

    do 
    {
        if (fsm.m_pServerInfo != NULL) 
        {
            fsm.m_pServerInfo->SetLastActiveTime();
        }

        INET_ASSERT((int)fsm.m_dwBufferLeft > 0);

        int nRead;

        if (IsNonBlocking()) 
        {
            if (fsm.bIOCPInited)
            {
                fsm.bIOCPInited = FALSE;
                nRead = fsm.dwBytesTransferred;
                
                if (fsm.bIOCPSuccess)
                {
                    if (nRead == 0) 
                    {
                        //
                        // done
                        //
                        DEBUG_PRINT(SOCKETS,
                                    INFO,
                                    ("EOF connection %#x/port %d\n",
                                    m_Socket,
                                    m_SourcePort
                                    ));

                        fsm.m_bEof = TRUE;
                        break;
                    } 
                    else if (nRead > 0) 
                    {

                        DEBUG_PRINT(SOCKETS,
                                    INFO,
                                    ("received %d bytes from socket %#x/port %d\n",
                                    nRead,
                                    m_Socket,
                                    m_SourcePort
                                    ));

                        fsm.m_dwBytesReceived += nRead;
                        fsm.m_dwBytesRead += nRead;
                        fsm.m_lpBuffer += nRead;
                        fsm.m_dwBufferLeft -= nRead;

                        //
                        // if SF_RECEIVE_ALL is not set then the caller just wants us to
                        // perform a single receive. We're done
                        //

                        if (!(fsm.m_dwFlags & SF_RECEIVE_ALL) ) 
                        {
                            break;
                        }
                        //
                        // if we've filled the current buffer, then either we're done, or
                        // the caller wants us to receive the entire response, in which
                        // case we attempt to grow the buffer and receive the next part
                        // of the message. Note that we may have already received the
                        // entire response if it just happened to be the same size as our
                        // buffer
                        //

                        // BUGBUG [arthurbi] we're broken for SSL/PCT case !!!
                        //  We need to handle expanding the buffer.
                        //

                        if (fsm.m_dwBufferLeft == 0) 
                        {
                            //
                            // BUGBUG - RLF - why are we testing for SF_DECRYPT here?
                            //

                            if (!(fsm.m_dwFlags & SF_EXPAND) || (m_dwFlags & SF_DECRYPT)) 
                            {
                                break;
                            } 
                            else 
                            {
                                //
                                // BUGBUG - the buffer increment should come from the handle
                                //          object
                                //

                                fsm.m_dwBufferLeft = DEFAULT_RECEIVE_BUFFER_INCREMENT;
                                fsm.m_dwBufferLength += DEFAULT_RECEIVE_BUFFER_INCREMENT;

                                DEBUG_PRINT(SOCKETS,
                                            INFO,
                                            ("resizing %#x to %d\n",
                                            fsm.m_hBuffer,
                                            fsm.m_dwBufferLength
                                            ));

                                fsm.m_hBuffer = ResizeBuffer(fsm.m_hBuffer,
                                                             fsm.m_dwBufferLength,
                                                             FALSE
                                                             );
                                if (fsm.m_hBuffer != NULL) 
                                {
                                    fsm.m_lpBuffer = (LPBYTE)fsm.m_hBuffer + fsm.m_dwBytesReceived;
                                }
                                else 
                                {
                                    error = GetLastError();
                                    INET_ASSERT(error != ERROR_SUCCESS);

                                    fsm.m_dwBytesReceived = 0;
                                    fsm.m_dwBufferLength = 0;
                                    fsm.m_dwBufferLeft = 0;
                                }
                            }
                        }// if fsm.m_dwBufferLeft == 0
                    }// if nRead >= 0
                }// if fsm.bIOCPSuccess
                else 
                {
                    error = fsm.dwIOCPError;
                    // a real error occurred. We need to get out
                    //

                    error = MapInternetError(error);

                    //VENKATKBUG_ remove this assert later - only informational
                    INET_ASSERT (FALSE && "IOCPError");
                    break;
                }// if! fsm.bSuccess

                continue; //for any fall-thrus.
            } // if fsm.bIOCPInited
            
            int nError;
            WSABUF wsabuf;
            wsabuf.len = fsm.m_dwBufferLeft;
            wsabuf.buf = (char FAR *)fsm.m_lpBuffer;
            DWORD dwFlags = 0;

            if (!_lpWrapOverlappedRecv)
            {
                _lpWrapOverlappedRecv = New CWrapOverlapped();

                if (!_lpWrapOverlappedRecv)
                {
                    error = ERROR_NOT_ENOUGH_MEMORY;
                    fsm.SetErrorState(error);
                    goto error_exit;
                }
            }
            
            CWrapOverlapped* lpWrapOverlapped = _lpWrapOverlappedRecv;
            LPWSAOVERLAPPED lpOverlapped = _lpWrapOverlappedRecv->GetOverlapped();
            memset(lpOverlapped, 0, sizeof(WSAOVERLAPPED));

            CFsm* pFsmOld = GetAndSetCurrentFsm(&fsm);
            INET_ASSERT (pFsmOld == NULL);
            
            fsm.bIOCPInited = TRUE;

            fsm.SetAction(FSM_ACTION_RECEIVE);

            DWORD timeout = GetTimeoutValue(WINHTTP_OPTION_RECEIVE_TIMEOUT);

            if (timeout != INFINITE)
            {
                fsm.SetTimeout(timeout);
                fsm.SetOnAsyncList(TRUE);
                error = QueueSocketWorkItem(Fsm, m_Socket);

                INET_ASSERT (error == ERROR_IO_PENDING);

                if (error != ERROR_IO_PENDING)
                {
                    // 2 causes - both irrecoverable
                    // 1. no global pointer to ICAsyncThread
                    // OR 2. no threadinfo or SelectThread.
                    // so bail!
                    fsm.bIOCPInited = FALSE;
                    GetAndSetCurrentFsm(NULL);
                    fsm.SetOnAsyncList(FALSE);
                    fsm.SetErrorState(error);
                    goto error_exit;
                }
            }

            _lpWrapOverlappedRecv->Reference(); // to keep this ICSocket=>the Overlapped struct valid beyong the WSARecv() call.
            _lpWrapOverlappedRecv->Reference(); // to make sure it stays alive for the IOCP to get the fsm off it.
            
            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("calling WSARecv() blocked, socket %#x/port %d\n",
                        m_Socket,
                        m_SourcePort
                        ));

            DEBUG_ENTER((DBG_API,
                             Dword,
                             "***WSARecv",
                             "(m_Socket)%#x, (wsabuf.buf)%#x, (wsabuf.len)%#x, (this)%#x, (overlapped)%#x, (fsm)%#x",
                             m_Socket,
                             wsabuf.buf,
                             wsabuf.len,
                             this,
                             lpOverlapped,
                             &fsm
                             ));

            nError = _I_WSARecv(m_Socket,
                                &wsabuf,
                                1,
                                (LPDWORD)&nRead,
                                &dwFlags,
                                lpOverlapped,
                                NULL);     
        
            DEBUG_LEAVE(nError);

            lpWrapOverlapped->Dereference(); // release the first reference.
            
            DEBUG_PRINT(SOCKETS,
                        ERROR,
                        ("WSARecv() returns %d (%s) with nRead=%d bytes\n",
                        nError,
                        InternetMapError(nError),
                        nRead
                        ));

            //VENKATKBUG - omitting hackorama, but may need to put it in just the same.

            if (nError == 0)
            {
#if INET_DEBUG
                InterlockedIncrement(&g_cWSACompletions);
#endif
                 error = ERROR_IO_PENDING;
                 break;
            }
            else // if! nError == 0
            {
                INET_ASSERT (nError == SOCKET_ERROR);
                
                error = _I_WSAGetLastError();
                if (error == WSA_IO_PENDING)
                {
#if INET_DEBUG
                    InterlockedIncrement(&g_cWSACompletions);
#endif
                    error = ERROR_IO_PENDING;
                    break;
                }
                else
                {
                    // no IOCompletion here.
                    // VENKATKBUG_ strictly informational assert - remove later.
                    // DWORD dwError = error; //dummy for debugging
                    // INET_ASSERT (FALSE);
                    if (fsm.HasTimeout())
                    {
                        if (!RemoveFsmFromAsyncList(&fsm))
                        {
                            //failure! the select thread already enforced timeout and updated state
                            //informational assert.
                            //VENKATK_BUG-enable later INET_ASSERT (FALSE && "COOL: select enforced timeout");
                        }
                    }

                    lpWrapOverlapped->Dereference(); // release the IOCP-based reference.
                    GetAndSetCurrentFsm(NULL);
                    
                    //cannot handle SF_NO_WAIT and SF_WAIT
                    error = MapInternetError(error);

                    //VENKATKBUG - retry for certain error types.
                    break;
                }
            } // if! nError == 0
        }
        else //if IsNonBlocking()
        {
            nRead = _I_recv(m_Socket,
                            (char FAR *)fsm.m_lpBuffer,
                            (int)fsm.m_dwBufferLeft,
                            0
                            );
                            
            //
            // hackorama # 95, subparagraph 13
            //
            // RLF 07/15/96
            //
            // On Win95 (wouldn't you know it?) in low-memory conditions, we can get
            // into a situation where one or more pages of our receive buffer is
            // filled with zeroes.
            //
            // The reason this happens is that the winsock VxD creates an alias to
            // our buffer, locks the buffer & writes into it, then marks the alias
            // dirty, but not the original buffer. If the buffer is paged out then
            // back in, one or more pages are zeroed because the O/S didn't know
            // they had been written to; it decides to initialize the pages with
            // zeroes.
            //
            // We try to circumvent this by immediately probing each page (we read
            // a byte then write it back).
            //
            // This doesn't fix the problem, just makes the window a lot smaller.
            // However, apart from writing a device driver or modifying the VxD,
            // there's not much else we can do
            //

            ProbeWriteBuffer(fsm.m_lpBuffer, fsm.m_dwBufferLeft);

            if (nRead == 0) 
            {
                //
                // done
                //

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("EOF connection %#x/port %d\n",
                            m_Socket,
                            m_SourcePort
                            ));

                fsm.m_bEof = TRUE;
                break;
            } 
            else if (nRead > 0) 
            {
                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("received %d bytes from socket %#x/port %d\n",
                            nRead,
                            m_Socket,
                            m_SourcePort
                            ));

                fsm.m_dwBytesReceived += nRead;
                fsm.m_dwBytesRead += nRead;
                fsm.m_lpBuffer += nRead;
                fsm.m_dwBufferLeft -= nRead;

                //
                // if SF_RECEIVE_ALL is not set then the caller just wants us to
                // perform a single receive. We're done
                //

                if (!(fsm.m_dwFlags & SF_RECEIVE_ALL) ) 
                {
                    break;
                }

                //
                // if we've filled the current buffer, then either we're done, or
                // the caller wants us to receive the entire response, in which
                // case we attempt to grow the buffer and receive the next part
                // of the message. Note that we may have already received the
                // entire response if it just happened to be the same size as our
                // buffer
                //

                // BUGBUG [arthurbi] we're broken for SSL/PCT case !!!
                //  We need to handle expanding the buffer.
                //

                if (fsm.m_dwBufferLeft == 0) 
                {
                    //
                    // BUGBUG - RLF - why are we testing for SF_DECRYPT here?
                    //

                    if (!(fsm.m_dwFlags & SF_EXPAND) || (m_dwFlags & SF_DECRYPT)) 
                    {
                        break;
                    } 
                    else 
                    {
                        //
                        // BUGBUG - the buffer increment should come from the handle
                        //          object
                        //

                        fsm.m_dwBufferLeft = DEFAULT_RECEIVE_BUFFER_INCREMENT;
                        fsm.m_dwBufferLength += DEFAULT_RECEIVE_BUFFER_INCREMENT;

                        DEBUG_PRINT(SOCKETS,
                                    INFO,
                                    ("resizing %#x to %d\n",
                                    fsm.m_hBuffer,
                                    fsm.m_dwBufferLength
                                    ));

                        fsm.m_hBuffer = ResizeBuffer(fsm.m_hBuffer,
                                                     fsm.m_dwBufferLength,
                                                     FALSE
                                                     );
                        if (fsm.m_hBuffer != NULL) 
                        {
                            fsm.m_lpBuffer = (LPBYTE)fsm.m_hBuffer + fsm.m_dwBytesReceived;
                        } 
                        else 
                        {
                            error = GetLastError();

                            INET_ASSERT(error != ERROR_SUCCESS);

                            fsm.m_dwBytesReceived = 0;
                            fsm.m_dwBufferLength = 0;
                            fsm.m_dwBufferLeft = 0;
                        }
                    }
                }//if fsm.m_dwBufferLeft == 0
            } 
            else //if nRead >= 0
            {
                if (IsAborted()) 
                {
                    error = ERROR_WINHTTP_OPERATION_CANCELLED;
                    break;
                } 
                else 
                {
                    error = _I_WSAGetLastError();
                    //
                    // a real error occurred. We need to get out
                    //

                    DEBUG_PRINT(SOCKETS,
                                ERROR,
                                ("recv() on socket %#x/port %d returns %d\n",
                                m_Socket,
                                m_SourcePort,
                                error
                                ));

                    error = MapInternetError(error);
                    break;
                }
            }//if! nRead >= 0
        }// if! IsNonBlocking()
    } 
    while (error == ERROR_SUCCESS);

error_exit:

    //
    // get correct error based on settings
    //

    if (error == ERROR_IO_PENDING) 
    {
        goto done;
    } 
    else if (IsAborted()) 
    {
        error = ERROR_WINHTTP_OPERATION_CANCELLED;
    }

    if (pObject != NULL) {
        pObject->ResetAbortHandle();
    }

    if (error == ERROR_SUCCESS) {

        //
        // inform the app that we finished, and tell it how much we received
        // this time
        //

        if (fsm.m_dwFlags & SF_INDICATE) {
            DWORD dwBytesRead = fsm.m_dwBytesRead;
            InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED,
                                   &dwBytesRead,
                                   sizeof(dwBytesRead)
                                   );
        }

        //
        // if we received the entire response and the caller specified
        // SF_COMPRESS then we shrink the buffer to fit. We may end up growing
        // the buffer to contain dwExtraSpace if it is not zero and we just
        // happened to fill the current buffer
        //

        if (fsm.m_bEof && (fsm.m_dwFlags & SF_COMPRESS)) {

            fsm.m_dwBufferLeft = fsm.m_dwExtraSpace;

            //
            // include any extra that the caller required
            //

            fsm.m_dwBufferLength = fsm.m_dwBytesReceived + fsm.m_dwExtraSpace;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("shrinking buffer %#x to %d (%#x) bytes (includes %d extra)\n",
                        fsm.m_hBuffer,
                        fsm.m_dwBufferLength,
                        fsm.m_dwBufferLength,
                        fsm.m_dwExtraSpace
                        ));

            fsm.m_hBuffer = ResizeBuffer(fsm.m_hBuffer,
                                         fsm.m_dwBufferLength,
                                         FALSE
                                         );

            INET_ASSERT((fsm.m_hBuffer == NULL)
                        ? ((fsm.m_dwBytesReceived + fsm.m_dwExtraSpace) == 0)
                        : TRUE
                        );

        }

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("read %d bytes @ %#x from socket %#x/port %d\n",
                    fsm.m_dwBytesRead,
                    (LPBYTE)fsm.m_hBuffer + *fsm.m_lpdwBytesReceived,
                    m_Socket,
                    m_SourcePort
                    ));

        DEBUG_DUMP_API(SOCKETS,
                       "received data:\n",
                       (LPBYTE)fsm.m_hBuffer + *fsm.m_lpdwBytesReceived,
                       fsm.m_dwBytesRead
                       );

    } else if (fsm.m_bAllocated && (fsm.m_hBuffer != NULL)) {

        //
        // if we failed but allocated a buffer then we need to free it (we were
        // leaking this buffer if the request was cancelled)
        //

        fsm.m_hBuffer = FREE_MEMORY(fsm.m_hBuffer);

        INET_ASSERT(fsm.m_hBuffer == NULL);

        fsm.m_dwBufferLength = 0;
        fsm.m_dwBufferLeft = 0;
        fsm.m_dwBytesReceived = 0;
        fsm.m_bEof = TRUE;
    }

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("returning: lpBuffer=%#x, bufferLength=%d, bufferLeft=%d, bytesReceived=%d\n",
                fsm.m_hBuffer,
                fsm.m_dwBufferLength,
                fsm.m_dwBufferLeft,
                fsm.m_dwBytesReceived
                ));

    //
    // update output parameters
    //

    *fsm.m_lplpBuffer = (LPVOID)fsm.m_hBuffer;
    *fsm.m_lpdwBufferLength = fsm.m_dwBufferLength;
    *fsm.m_lpdwBufferRemaining = fsm.m_dwBufferLeft;
    *fsm.m_lpdwBytesReceived = fsm.m_dwBytesReceived;
    *fsm.m_lpbEof = fsm.m_bEof;

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone(error);
    }

done:

    DEBUG_LEAVE(error);

    return error;
}

//
//DWORD
//ICSocket::ReceiveFrom(
//    IN LPVOID lpBuffer,
//    IN DWORD dwBufferLength,
//    OUT LPDWORD lpdwBytesReceived,
//    OUT LPSOCKADDR lpDestination OPTIONAL,
//    IN OUT LPDWORD lpdwDestinationLength OPTIONAL,
//    IN DWORD dwTimeout,
//    IN DWORD dwWinsockFlags,
//    IN DWORD dwFlags
//    )
//
///*++
//
//Routine Description:
//
//    Wrapper for recvfrom()
//
//Arguments:
//
//    lpBuffer                - pointer to buffer where data returned
//
//    dwBufferLength          - size of lpBuffer in bytes
//
//    lpdwBytesReceived       - pointer to returned number of bytes received
//
//    lpDestination           - pointer to returned destination address
//
//    lpdwDestinationLength   - IN: size of lpDestination buffer
//                              OUT: length of returned destination address info
//
//    dwTimeout               - number of milliseconds to wait for response
//
//    dwWinsockFlags          - flags to pass through to recvfrom()
//
//    dwFlags                 - ICSocket flags
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - ERROR_WINHTTP_OPERATION_CANCELLED
//                    The operation was cancelled by the caller
//
//                  ERROR_WINHTTP_TIMEOUT
//                    The operation timed out
//
//                  ERROR_WINHTTP_CONNECTION_ERROR
//                    An error occurred. We approximate to connection reset
//
//                  WSA error
//                    Some other sockets error occurred
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_SOCKETS,
//                 Dword,
//                 "ICSocket::ReceiveFrom",
//                 "{%#x} %#x, %d, %#x, %#x, %#x [%d], %d, %#x, %#x",
//                 m_Socket,
//                 lpBuffer,
//                 dwBufferLength,
//                 lpdwBytesReceived,
//                 lpDestination,
//                 lpdwDestinationLength,
//                 lpdwDestinationLength ? *lpdwDestinationLength : 0,
//                 dwTimeout,
//                 dwWinsockFlags,
//                 dwFlags
//                 ));
//
//    //INET_ASSERT(IsSocketValid());
//    INET_ASSERT(lpdwBytesReceived != NULL);
//
//    //
//    // most ICSocket flags not allowed for this operation
//    //
//
//    INET_ASSERT(!(dwFlags
//                  & (SF_ENCRYPT
//                     | SF_DECRYPT
//                     | SF_EXPAND
//                     | SF_COMPRESS
//                     | SF_SENDING_DATA
//                     | SF_SCH_REDO
//                     )
//                  )
//                );
//
//    DWORD error = ERROR_SUCCESS;
//    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
//    BOOL bStopOfflineTimer = FALSE;
//    BOOL fNonBlocking;
//    DWORD bytesReceived;
//    INTERNET_HANDLE_OBJECT * pObject = NULL;
//
//    if (lpThreadInfo == NULL) {
//
//        INET_ASSERT(FALSE);
//
//        error = ERROR_WINHTTP_INTERNAL_ERROR;
//        goto quit;
//    }
//
//    //
//    // the socket may have already been aborted
//    //
//
//    if (IsAborted()) {
//        error = ERROR_WINHTTP_OPERATION_CANCELLED;
//        goto quit;
//    }
//
//    //
//    // let another thread know the socket to cancel if it wants to kill this
//    // operation
//    //
//
//    pObject = (INTERNET_HANDLE_OBJECT * )lpThreadInfo->hObjectMapped;
//    if (pObject != NULL) {
//        pObject->SetAbortHandle(this);
//    }
//
//    //
//    // keep the app informed (if requested to do so)
//    //
//
//    if (dwFlags & SF_INDICATE) {
//        InternetIndicateStatus(INTERNET_STATUS_RECEIVING_RESPONSE,
//                               NULL,
//                               0
//                               );
//    }
//
//    //
//    // if we are in async (== non-blocking) mode, let the async request
//    // scheduler know what operation we will be waiting on
//    //
//
//    fNonBlocking = lpThreadInfo->IsAsyncWorkerThread;
//    if (fNonBlocking) {
//
//        INET_ASSERT(lpThreadInfo->lpArb != NULL);
//
//        SET_ARB_SOCKET_OPERATION_TIMEOUT(lpThreadInfo->lpArb,
//                                         m_Socket,
//                                         RECEIVE,
//                                         dwTimeout
//                                         );
//
//        DWORD timerError = StartOfflineTimerForArb(lpThreadInfo->lpArb);
//
//        INET_ASSERT(timerError == ERROR_SUCCESS);
//
//        bStopOfflineTimer = (timerError == ERROR_SUCCESS) ? TRUE : FALSE;
//    }
//
//    int nBytes;
//
//    bytesReceived = 0;
//
//    do {
//
//        nBytes = _I_recvfrom(m_Socket,
//                             (char FAR *)lpBuffer + bytesReceived,
//                             dwBufferLength,
//                             dwWinsockFlags,
//                             lpDestination,
//                             (int FAR *)lpdwDestinationLength
//                             );
//        if (nBytes != SOCKET_ERROR) {
//
//            DEBUG_PRINT(SOCKETS,
//                        INFO,
//                        ("received %d bytes from socket %#x\n",
//                        nBytes,
//                        m_Socket
//                        ));
//
//            INET_ASSERT(nBytes > 0);
//
//            bytesReceived += nBytes;
//            dwBufferLength -= nBytes;
//
//            //
//            // for recvfrom(), we quit as soon as we get some data
//            //
//
//            error = ERROR_SUCCESS;
//            break;
//        } else {
//            error = _I_WSAGetLastError();
//            if ((error == WSAEWOULDBLOCK) && fNonBlocking) {
//
//                INET_ASSERT(_dwFlags & SF_NON_BLOCKING);
//
//                //
//                // if this function is called expedited (we expect the request
//                // to complete quickly) then we test to see if it already
//                // completed before switching to the async scheduler
//                //
//
//                BOOL switchFiber = TRUE;
//
//                if (dwFlags & SF_EXPEDITED) {
//                    error = WaitForReceive(1);
//
//                    //
//                    // if the socket is already readable then we don't switch
//                    // fibers (only to virtually immediately come back here,
//                    // incurring a couple of thread switches
//                    //
//
//                    if (error == ERROR_SUCCESS) {
//                        switchFiber = FALSE;
//
//                        //
//                        // use this error to go round loop once again
//                        //
//
//                        error = WSAEWOULDBLOCK;
//                    }
//                }
//                if (switchFiber) {
//
//                    DEBUG_PRINT(SOCKETS,
//                                INFO,
//                                ("recvfrom(%#x) blocked\n",
//                                m_Socket
//                                ));
//
//                    lpThreadInfo->lpArb->Header.dwResultCode = ERROR_SUCCESS;
//
//                    SwitchToAsyncScheduler(m_Socket);
//
//                    error = lpThreadInfo->lpArb->Header.dwResultCode;
//
//                    DEBUG_PRINT(SOCKETS,
//                                INFO,
//                                ("recvfrom(%#x) resumed, returns %s\n",
//                                m_Socket,
//                                InternetMapError(error)
//                                ));
//
//                    if (error != ERROR_SUCCESS) {
//                    } else {
//
//                        //
//                        // use this error to force another loop now we believe
//                        // we have the data
//                        //
//
//                        error = WSAEWOULDBLOCK;
//                    }
//                }
//            } else {
//
//                //
//                // real error
//                //
//
//                error = MapInternetError(error);
//            }
//        }
//    } while (error == WSAEWOULDBLOCK);
//
//    if (error == ERROR_SUCCESS) {
//
//        DEBUG_DUMP(SOCKETS,
//                   "received data:\n",
//                   lpBuffer,
//                   bytesReceived
//                   );
//
//    }
//
//    if (fNonBlocking) {
//
//        INET_ASSERT(lpThreadInfo->lpArb != NULL);
//
//        SET_ARB_SOCKET_OPERATION(lpThreadInfo->lpArb, INVALID_SOCKET, RECEIVE);
//
//        if (bStopOfflineTimer) {
//            StopOfflineTimerForArb(lpThreadInfo->lpArb);
//        }
//    }
//
//    //
//    // inform the app that we finished, and tell it how much we received this
//    // time
//    //
//
//    if ((dwFlags & SF_INDICATE) && (error == ERROR_SUCCESS)) {
//        InternetIndicateStatus(INTERNET_STATUS_RESPONSE_RECEIVED,
//                               &bytesReceived,
//                               sizeof(bytesReceived)
//                               );
//    }
//
//    *lpdwBytesReceived = bytesReceived;
//
//    if (pObject != NULL) {
//        pObject->ResetAbortHandle();
//
//        //
//        // if the operation has been cancelled, then this error overrides any
//        // other
//        //
//
//        //if (pObject->IsInvalidated()) {
//        //    error = pObject->GetError();
//        //    if (error == ERROR_SUCCESS) {
//        //        error = ERROR_WINHTTP_OPERATION_CANCELLED;
//        //    }
//        //}
//        if (IsAborted()) {
//            error = ERROR_WINHTTP_OPERATION_CANCELLED;
//        }
//    }
//
//quit:
//
//    INET_ASSERT((pObject != NULL) ? (pObject->GetAbortHandle() == NULL) : TRUE);
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}
//

DWORD
ICSocket::DataAvailable(
    OUT LPDWORD lpdwBytesAvailable
    )

/*++

Routine Description:

    Determines the amount of data available to be read on the socket

Arguments:

    lpdwBytesAvailable  - pointer to returned data available


Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::DataAvailable",
                 "%#x",
                 lpdwBytesAvailable
                 ));

    //
    // sanity check parameters
    //

    INET_ASSERT(m_Socket != INVALID_SOCKET);
    INET_ASSERT(lpdwBytesAvailable != NULL);

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error;

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    //
    // the socket may already be aborted
    //

    if (IsAborted()) {
        error = ERROR_WINHTTP_OPERATION_CANCELLED;
        goto quit;
    }

    //
    // if we're in async mode, we have to perform a zero-length receive in order
    // to get the information from the socket
    //

    int nRead;

    //
    // we actually have to peek a non-zero number of bytes because on Win95,
    // attempting to perform a receive of 0 bytes (to put the socket in blocked
    // read mode) results in zero bytes being returned, and the socket never
    // blocks
    //

    nRead = _I_recv(m_Socket, NULL, 0, 0);

    //
    // N.B. buf[] will only ever be used if there is data to peek right now
    //

    char buf[1];

    PERF_LOG(PE_PEEK_RECEIVE_START,
             m_Socket,
             lpThreadInfo->ThreadId,
             lpThreadInfo->hObject
             );

    nRead = _I_recv(m_Socket, buf, sizeof(buf), MSG_PEEK);
    if (nRead == SOCKET_ERROR) {
        error = _I_WSAGetLastError();
        if ((error == WSAEWOULDBLOCK) && (m_dwFlags & SF_NON_BLOCKING)) {

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("peek(1) blocked, socket %#x\n",
                        m_Socket
                        ));

            PERF_LOG(PE_PEEK_RECEIVE_END,
                     m_Socket,
                     lpThreadInfo->ThreadId,
                     lpThreadInfo->hObject
                     );

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("peek(1) resumed, socket %#x, returns %s\n",
                        m_Socket,
                        InternetMapError(error)
                        ));
        }
    /*} else if ((nRead == 0) && !(m_dwFlags & SF_NON_BLOCKING)) {

        PERF_LOG(PE_PEEK_RECEIVE_END,
                 m_Socket,
                 lpThreadInfo->ThreadId,
                 lpThreadInfo->hObject
                 );

        //
        // nothing to peek right now. If the socket is in blocking mode then
        // we wait here until there is something to receive
        //

        error = WaitForReceive(INFINITE);*/
    } else {

        PERF_LOG(PE_PEEK_RECEIVE_END,
                 m_Socket,
                 lpThreadInfo->ThreadId,
                 lpThreadInfo->hObject
                 );

        //
        // nRead == 0 but non-blocking, or nRead > 0
        //

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("peek(1) returns %d\n",
                    nRead
                    ));

        error = ERROR_SUCCESS;
    }

    if (error == ERROR_SUCCESS) {

        //
        // now we can get the amount from the socket
        //

        error = (DWORD)_I_ioctlsocket(m_Socket,
                                      FIONREAD,
                                      (u_long FAR *)lpdwBytesAvailable
                                      );

        //
        // N.B. assumes ioctlsocket() returns 0 on success == ERROR_SUCCESS
        //

        if (error == SOCKET_ERROR) {
            error = _I_WSAGetLastError();
        } else {

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("ioctlsocket(FIONREAD) returns %d\n",
                        *lpdwBytesAvailable
                        ));

        }
    }

    //
    // map any sockets error to WinInet error
    //

    if (error != ERROR_SUCCESS) {
        error = MapInternetError(error);
    }

quit:

    DEBUG_LEAVE(error);

    return error;
}

//
//DWORD
//ICSocket::DataAvailable2(
//    OUT LPVOID lpBuffer,
//    IN DWORD dwBufferLength,
//    OUT LPDWORD lpdwBytesAvailable
//    )
//
///*++
//
//Routine Description:
//
//    Determines the amount of data available to be read on the socket
//
//Arguments:
//
//    lplpBuffer          - pointer to pointer to buffer where data read
//
//    dwBufferLength      - size of the buffer
//
//    lpdwBytesAvailable  - pointer to returned data available
//
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - WSA error
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_SOCKETS,
//                 Dword,
//                 "ICSocket::DataAvailable2",
//                 "%#x, %d, %#x",
//                 lpBuffer,
//                 dwBufferLength,
//                 lpdwBytesAvailable
//                 ));
//
//    //
//    // sanity check parameters
//    //
//
//    INET_ASSERT(lpdwBytesAvailable != NULL);
//
//    //
//    // we're about to receive data from the socket. The amount of data currently
//    // on hand must be 0
//    //
//
//    INET_ASSERT(*lpdwBytesAvailable == 0);
//    INET_ASSERT(lpBuffer != NULL);
//
//    DWORD error;
//
//    //
//    // new scheme: actually read the data from sockets into our buffer. This is
//    // the only way on Win95 to determine the correct number of bytes available.
//    // We only perform a single receive
//    //
//
//    DWORD bufferLeft = dwBufferLength;
//    BOOL eof;
//
//    error = Receive(&lpBuffer,
//                    &dwBufferLength,
//                    &bufferLeft,  // don't care about this
//                    lpdwBytesAvailable,
//                    0,
//                    0,
//                    &eof          // don't care about this either
//                    );
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}


DWORD
ICSocket::WaitForReceive(
    IN DWORD Timeout
    )

/*++

Routine Description:

    Waits until a receive socket becomes unblocked (readable)

Arguments:

    Timeout - milliseconds to wait, or INFINITE

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error
                    sockets error

                  ERROR_WINHTTP_TIMEOUT
                    Receive timed out

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::WaitForReceive",
                 "{%#x} %d",
                 m_Socket,
                 Timeout
                 ));

    struct fd_set read_fds;
    struct fd_set except_fds;

    FD_ZERO(&read_fds);
    FD_ZERO(&except_fds);

    FD_SET(m_Socket, &read_fds);
    FD_SET(m_Socket, &except_fds);

    int n;

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("waiting on socket %#x\n",
                m_Socket
                ));

    TIMEVAL timeout;
    LPTIMEVAL lpTimeout;

    if (Timeout != INFINITE) {
        timeout.tv_sec  = Timeout / 1000;
        timeout.tv_usec = (Timeout % 1000) * 1000;
        lpTimeout = &timeout;
    } else {
        lpTimeout = NULL;
    }

    n = _I_select(0, &read_fds, NULL, &except_fds, lpTimeout);

    DWORD error;

    if (n == SOCKET_ERROR) {

        //
        // real error?
        //

        error = _I_WSAGetLastError();

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("select() returns %d\n",
                    error
                    ));

        INET_ASSERT(FALSE);

        error = MapInternetError(error);
    } else if (n != 0) {
        if (FD_ISSET(m_Socket, &except_fds)) {

            DEBUG_PRINT(SOCKETS,
                        ERROR,
                        ("socket %#x exception\n",
                        m_Socket
                        ));

            error = ERROR_WINHTTP_CONNECTION_ERROR;
        } else {

            //
            // it *must* be unblocked (i.e. readable)
            //

            INET_ASSERT(FD_ISSET(m_Socket, &read_fds));

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("socket %#x unblocked\n",
                        m_Socket
                        ));

            error = ERROR_SUCCESS;
        }
    } else {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("timed out\n"
                    ));

        error = ERROR_WINHTTP_TIMEOUT;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::AllocateQueryBuffer(
    OUT LPVOID * lplpBuffer,
    OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Allocates a query buffer for the socket

Arguments:

    lplpBuffer          - returned pointer to allocated query buffer

    lpdwBufferLength    - returned length of allocated query buffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::AllocateQueryBuffer",
                 "{%#x/%d} %#x, %#x",
                 GetSocket(),
                 GetSourcePort(),
                 lplpBuffer,
                 lpdwBufferLength
                 ));

    DWORD error;
    DWORD bufferLength;
    DWORD size = sizeof(bufferLength);

    int serr = _I_getsockopt(m_Socket,
                             SOL_SOCKET,
                             SO_RCVBUF,
                             (char FAR *)&bufferLength,
                             (int FAR *)&size
                             );
    if (serr != SOCKET_ERROR) {
        bufferLength = min(bufferLength, DEFAULT_SOCKET_QUERY_BUFFER_LENGTH);
        if (bufferLength == 0) {
            bufferLength = DEFAULT_SOCKET_QUERY_BUFFER_LENGTH;
        }
        *lplpBuffer = (LPVOID)ALLOCATE_MEMORY(LMEM_FIXED, bufferLength);
        if (*lplpBuffer != NULL) {
            *lpdwBufferLength = bufferLength;
            error = ERROR_SUCCESS;
        } else {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        error = MapInternetError(_I_WSAGetLastError());
    }

    DEBUG_LEAVE(error);

    return error;
}

//
//VOID
//ICSocket::FreeQueryBuffer(
//    IN LPVOID lpBuffer
//    )
//
///*++
//
//Routine Description:
//
//    description-of-function.
//
//Arguments:
//
//    lpBuffer    -
//
//Return Value:
//
//    None.
//
//--*/
//
//{
//    lpBuffer = (LPVOID)FREE_MEMORY((HLOCAL)lpBuffer);
//
//    INET_ASSERT(lpBuffer == NULL);
//}

//
//DWORD
//ICSocket::GetBytesAvailable(
//    OUT LPDWORD lpdwBytesAvailable
//    )
//
///*++
//
//Routine Description:
//
//    Determines amount of data available to be read from socket
//
//Arguments:
//
//    lpdwBytesAvailable  - pointer to returned available length
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure -
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_SOCKETS,
//                 Dword,
//                 "ICSocket::GetBytesAvailable",
//                 "{%#x} %#x",
//                 m_Socket,
//                 lpdwBytesAvailable
//                 ));
//
//    //INET_ASSERT(m_Socket != INVALID_SOCKET);
//    INET_ASSERT(lpdwBytesAvailable != NULL);
//
//    //
//    // get the amount from the socket. If the socket has been reset or shutdown
//    // by the server then we expect to get an error, else 0 (== ERROR_SUCCESS)
//    //
//
//    DWORD error = (DWORD)_I_ioctlsocket(m_Socket,
//                                        FIONREAD,
//                                        (u_long FAR *)lpdwBytesAvailable
//                                        );
//    if (error == SOCKET_ERROR) {
//        error = _I_WSAGetLastError();
//    } else {
//
//        DEBUG_PRINT(SOCKETS,
//                    INFO,
//                    ("ioctlsocket(FIONREAD) returns %d\n",
//                    *lpdwBytesAvailable
//                    ));
//
//    }
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}
//

DWORD
ICSocket::CreateSocket(
    IN DWORD dwFlags,
    IN int nAddressFamily,
    IN int nType,
    IN int nProtocol
    )

/*++

Routine Description:

    Opens a socket handle for this ICSocket object

Arguments:

    dwFlags         - flags to use for new socket

    nAddressFamily  - parameter to socket()

    nType           - parameter to socket()

    nProtocol       - parameter to socket()

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error mapped to INTERNET error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::CreateSocket",
                 "%#x, %s (%d), %s (%d), %s (%d)",
                 dwFlags,
                 MapFamily(nAddressFamily),
                 nAddressFamily,
                 MapSock(nType),
                 nType,
                 MapProto(nProtocol),
                 nProtocol
                 ));

    INET_ASSERT(m_Socket == INVALID_SOCKET);

    int serr;
    DWORD error;
    DWORD dwConnFlags;

    m_Socket = _I_socket(nAddressFamily, nType, nProtocol);
    if (m_Socket == INVALID_SOCKET) {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("failed to create socket\n"
                    ));

        goto socket_error;
    }

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("created socket %#x\n",
                m_Socket
                ));

    if (dwFlags & SF_NON_BLOCKING) {
        INET_ASSERT(FALSE);

        error = SetNonBlockingMode(TRUE);
        if (error == ERROR_SUCCESS) {

            //
            //  ICSocket is non-blocking socket object
            //

            m_dwFlags |= SF_NON_BLOCKING;
        } else {
            goto close_socket;
        }
    }

    //
    // bind our data socket to an endpoint, so that we know an address to
    // tell the FTP server
    //

    SOCKADDR_IN ourDataAddr;

    ourDataAddr.sin_family = AF_INET;
    *((long *)&ourDataAddr.sin_addr) = INADDR_ANY;
    ourDataAddr.sin_port = 0;

    serr = _I_bind(m_Socket,
                   (PSOCKADDR)&ourDataAddr,
                   sizeof(ourDataAddr)
                   );

    if (serr == SOCKET_ERROR) {
        goto socket_error;
    }

    error = ERROR_SUCCESS;

quit:

    DEBUG_LEAVE(error);

    return error;

socket_error:

    error = MapInternetError(_I_WSAGetLastError());

close_socket:

    Close();
    m_dwFlags &= ~SF_NON_BLOCKING;
    goto quit;
}


DWORD
ICSocket::GetSockName(
    PSOCKADDR psaSockName
    )
{
    INET_ASSERT(m_Socket != INVALID_SOCKET);
    INET_ASSERT(psaSockName);

    int serr;
    int cbAddrLen;
    DWORD error;

    serr = ERROR_SUCCESS;
    error = ERROR_SUCCESS;

    //
    // get the address info .
    //

    cbAddrLen = sizeof(SOCKADDR_IN);


    serr = _I_getsockname(m_Socket,
                          psaSockName,
                          &cbAddrLen
                          );


    if ( serr == SOCKET_ERROR )
    {
        error = _I_WSAGetLastError();
    }

    return error;
}


DWORD
ICSocket::Listen(
    VOID
    )
{
    INET_ASSERT(m_Socket != INVALID_SOCKET);

    DWORD error = ERROR_SUCCESS;

    //
    // Listen on the socket.
    //

    if (_I_listen(m_Socket, 1) == SOCKET_ERROR) {
        error = _I_WSAGetLastError();
    }
    return error;
}


DWORD
ICSocket::DirectConnect(
    PSOCKADDR psaRemoteSock
    )

/*++

Routine Description:

    Connects a ICSocket to the remote address

Arguments:

    psaRemoteSock   - pointer to remote socket address (TCP/IP!)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error mapped to INTERNET error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::DirectConnectSocket",
                 "{%#x} %#x",
                 m_Socket,
                 psaRemoteSock
                 ));

    INET_ASSERT(m_Socket != INVALID_SOCKET);

    DWORD error;
    BOOL bStopOfflineTimer = FALSE;

    //
    // we need the thread info for async processing
    //

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    BOOL isAsync;

    isAsync = lpThreadInfo->IsAsyncWorkerThread;

    //
    // BUGBUG - this is essentially common to ConnectSocket()
    //

    //
    // let another thread know the socket to cancel if it wants to kill
    // this operation
    //

    INTERNET_HANDLE_OBJECT * pObject;

    pObject = (INTERNET_HANDLE_OBJECT * )lpThreadInfo->hObjectMapped;
    if (pObject != NULL) {
        pObject->SetAbortHandle(this);
    }

#if defined(UNIX) && defined(ux10)
    DEBUG_PRINT(SOCKETS,
                INFO,
                ("connecting to remote address %d.%d.%d.%d, port %d\n",
                ((LPBYTE)&((LPSOCKADDR_IN)psaRemoteSock)->sin_addr)[0],
                ((LPBYTE)&((LPSOCKADDR_IN)psaRemoteSock)->sin_addr)[1],
                ((LPBYTE)&((LPSOCKADDR_IN)psaRemoteSock)->sin_addr)[2],
                ((LPBYTE)&((LPSOCKADDR_IN)psaRemoteSock)->sin_addr)[3],
                _I_ntohs(((LPSOCKADDR_IN)psaRemoteSock)->sin_port)
                ));
#else
    DEBUG_PRINT(SOCKETS,
                INFO,
                ("connecting to remote address %d.%d.%d.%d, port %d\n",
                ((LPSOCKADDR_IN)psaRemoteSock)->sin_addr.S_un.S_un_b.s_b1,
                ((LPSOCKADDR_IN)psaRemoteSock)->sin_addr.S_un.S_un_b.s_b2,
                ((LPSOCKADDR_IN)psaRemoteSock)->sin_addr.S_un.S_un_b.s_b3,
                ((LPSOCKADDR_IN)psaRemoteSock)->sin_addr.S_un.S_un_b.s_b4,
                _I_ntohs(((LPSOCKADDR_IN)psaRemoteSock)->sin_port)
                ));
#endif

    DWORD connectTime;

    connectTime = GetTickCountWrap();

    int serr;

    PERF_LOG(PE_CONNECT_START,
             m_Socket,
             lpThreadInfo->ThreadId,
             lpThreadInfo->hObject
             );

    if (IsSocks()) {
        serr = SocksConnect((LPSOCKADDR_IN)psaRemoteSock, sizeof(SOCKADDR_IN));
    } else {
        serr = _I_connect(m_Socket, psaRemoteSock, sizeof(SOCKADDR_IN));
    }
    if (serr != 0) {
        error = _I_WSAGetLastError();

        //
        // if we are using non-blocking sockets then we need to wait until
        // the connect has completed, or an error occurs
        //

        if (isAsync) {
            if (error == WSAEWOULDBLOCK) {

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("connect() blocked, socket %#x\n",
                            m_Socket
                            ));

                PERF_LOG(PE_CONNECT_END,
                         m_Socket,
                         lpThreadInfo->ThreadId,
                         lpThreadInfo->hObject
                         );

                connectTime = (GetTickCountWrap() - connectTime);

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("connect() resumed, socket %#x, returns %s\n",
                            m_Socket,
                            InternetMapError(error)
                            ));
            } else {

                DEBUG_PRINT(SOCKETS,
                            ERROR,
                            ("failed to connect non-blocking socket %#x, error %d\n",
                            m_Socket,
                            error
                            ));

            }
        } else {

            DEBUG_PRINT(SOCKETS,
                        ERROR,
                        ("failed to connect blocking socket %#x, error %d\n",
                        m_Socket,
                        error
                        ));

        }
    } else {

        PERF_LOG(PE_CONNECT_END,
                 m_Socket,
                 lpThreadInfo->ThreadId,
                 lpThreadInfo->hObject
                 );

        connectTime = (GetTickCountWrap() - connectTime);

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("socket %#x connected, time = %d mSec\n",
                    m_Socket,
                    connectTime
                    ));

        error = ERROR_SUCCESS;
    }

    if (error != ERROR_SUCCESS) {
        error = MapInternetError(error);
    }

    if (pObject != NULL) {
        pObject->ResetAbortHandle();

        //
        // if the operation has been cancelled, then this error overrides any
        // other
        //

        if (pObject->IsInvalidated()) {
            error = pObject->GetError();
            if (error == ERROR_SUCCESS) {
                error = ERROR_WINHTTP_OPERATION_CANCELLED;
            }
        }
        if (IsAborted()) {
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
        }
    }

quit:

    INET_ASSERT((pObject != NULL) ? (pObject->GetAbortHandle() == NULL) : TRUE);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::SelectAccept(
    IN ICSocket & acceptSocket,
    IN DWORD dwTimeout
    )

/*++

Routine Description:

    Wait until listening socket has connection to accept. We use the socket
    handle in this ICSocket object to accept a connection & create a socket
    handle in another ICSocket object (in acceptSocket)

Arguments:

    acceptSocket    - socket object to wait on

    dwTimeout       - number of milliseconds to wait

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error mapped to INTERNET error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SelectAccept",
                 "%#x, %d",
                 &acceptSocket,
                 dwTimeout
                 ));

    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    fd_set read_fds;
    fd_set except_fds;

    FD_ZERO(&read_fds);
    FD_ZERO(&except_fds);
    FD_SET(m_Socket, &read_fds);
    FD_SET(m_Socket, &except_fds);

    TIMEVAL timeout;

    timeout.tv_sec  = dwTimeout / 1000;
    timeout.tv_usec = dwTimeout % 1000;

    int n;

    n = _I_select(0, &read_fds, NULL, &except_fds, &timeout);
    if (n == 1) {
        if (FD_ISSET(m_Socket, &read_fds)) {
            error = ERROR_SUCCESS;
        } else if (FD_ISSET(m_Socket, &except_fds)) {
            error = ERROR_WINHTTP_CANNOT_CONNECT;

            DEBUG_PRINT(FTP,
                        ERROR,
                        ("select(): listening socket %#x in error (%d)\n",
                        m_Socket,
                        error
                        ));

            INET_ASSERT(acceptSocket.m_Socket == INVALID_SOCKET);
        } else {
            // Fix PREFIX warning (uninitialized error variable); this case should not happen.
            error = ERROR_WINHTTP_INTERNAL_ERROR;
        }
    } else if (n == 0) {

        //
        // timeout
        //

        error = ERROR_WINHTTP_TIMEOUT;

        DEBUG_PRINT(FTP,
                    WARNING,
                    ("select() timed out (%d.%d)\n",
                    timeout.tv_sec,
                    timeout.tv_usec
                    ));

        INET_ASSERT(acceptSocket.m_Socket == INVALID_SOCKET);

    } else {

        //
        // socket error
        //

        DEBUG_PRINT(FTP,
                    ERROR,
                    ("select() returns %d\n",
                    _I_WSAGetLastError()
                    ));

        INET_ASSERT(acceptSocket.m_Socket == INVALID_SOCKET);

        goto socket_error;
    }

    //
    // if we have a success indication then accept the connection; it may still
    // fail
    //

    if (error == ERROR_SUCCESS) {
        acceptSocket.m_Socket = _I_accept(m_Socket, NULL, NULL);
        if (acceptSocket.m_Socket != INVALID_SOCKET) {

            //
            // copy non-blocking indication to new socket
            //

            INET_ASSERT(!(m_dwFlags & SF_NON_BLOCKING));
            //acceptSocket.m_dwFlags |= (m_dwFlags & SF_NON_BLOCKING);
        } else {

            DEBUG_PRINT(FTP,
                        ERROR,
                        ("accept() returns %d\n",
                        error
                        ));

            goto socket_error;
        }
    }

quit:

    DEBUG_LEAVE(error);

    return error;

socket_error:

    error = MapInternetError(_I_WSAGetLastError());
    goto quit;
}


LPSTR
MapNetAddressToName(
    IN INTERNET_HANDLE_OBJECT* pSessionObject,
    IN LPSTR lpszAddress,
    OUT LPSTR * lplpszMappedName
    )

/*++

Routine Description:

    Given a network address, tries to map it to the corresponding host name. We
    consult the name resolution cache to determine this

Arguments:

    lpszAddress         - pointer to network address to map

    lplpszMappedName    - pointer to pointer to mapped name. Caller must free

Return Value:

    LPSTR
        Success - pointer to mapped name

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                Pointer,
                "MapNetAddressToName",
                "%q, %#x",
                lpszAddress,
                lplpszMappedName
                ));

    INET_ASSERT(lpszAddress != NULL);
    INET_ASSERT(lplpszMappedName != NULL);

    LPSTR lpszMappedName = NULL;

    //
    // now try to find the address in the cache. If it's not in the cache then
    // we don't resolve it, simply return the address
    //

    //
    // BUGBUG - if required, we need to resolve the name, but we need to know
    //          whether the address can be resolved on the intranet
    //

    DWORD ipAddr = _I_inet_addr(lpszAddress);

    //
    // inet_addr() shouldn't fail - we should have called IsNetAddress() already
    //

    //INET_ASSERT(ipAddr != INADDR_NONE);

    if (ipAddr != INADDR_NONE) {

        LPHOSTENT lpHostent;
        DWORD ttl;

        if (pSessionObject && pSessionObject->GetResolverCache()->GetResolverCacheList() &&
            QueryHostentCache(pSessionObject->GetResolverCache()->GetResolverCacheList(), NULL, (LPBYTE)&ipAddr, &lpHostent, &ttl)) {

            INET_ASSERT(lpHostent != NULL);

            lpszAddress = lpszMappedName = NewString(lpHostent->h_name);
            ReleaseHostentCacheEntry(pSessionObject->GetResolverCache()->GetResolverCacheList(), lpHostent);
        }
    }

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("mapped name is %q\n",
                lpszAddress
                ));

    DEBUG_LEAVE(lpszAddress);

    *lplpszMappedName = lpszMappedName;

    return lpszAddress;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\common\parsers.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    parsers.cxx

Abstract:

    Common text parsing functions (generally moved here from other protocols)

    Contents:
        ExtractWord
        ExtractDword
        ExtractInt
        SkipWhitespace
        SkipSpaces
        SkipLine
        FindToken
        NiceNum

Author:

    Richard L Firth (rfirth) 03-Jul-1996

Revision History:

    03-Jul-1996 rfirth
        Created

--*/

#include <wininetp.h>

//
// functions
//


BOOL
ExtractWord(
    IN OUT LPSTR* pString,
    IN DWORD NumberLength,
    OUT LPWORD pConvertedNumber
    )

/*++

Routine Description:

    pulls a <NumberLength> character number out of a string.

    Assumes:    1. The number to be converted is an unsigned short
                2. A whole number is contained within *pString

Arguments:

    pString             - pointer to pointer to string from which to get number

    NumberLength        - number of characters that comprise number string, if
                          not equal to 0, else if 0, we don't know the length
                          of the number string a priori

    pConvertedNumber    - pointer to variable where converted number written

Return Value:

    BOOL
        TRUE    - number converted OK

        FALSE   - one of the characters in the number is not a digit

--*/

{
    WORD number;
    BOOL exact;
    LPSTR string;

    //
    // if the caller doesn't know how many characters comprise the number, then
    // we will convert until the next non-digit character, or until we have
    // converted the maximum number of digits that can comprise an unsigned
    // short value
    //

    if (NumberLength == 0) {
        NumberLength = sizeof("65535") - 1;
        exact = FALSE;
    } else {
        exact = TRUE;
    }
    number = 0;
    string = *pString;
    while (NumberLength && isdigit(*string)) {
        number = number * 10 + (WORD)((BYTE)(*string++) - (BYTE)'0');
        --NumberLength;
    }
    *pConvertedNumber = number;
    *pString = string;

    //
    // if we were asked to convert a certain number of characters but failed
    // because we hit a non-digit character, then return FALSE. Anything else
    // (we converted required number of characters, or the caller didn't know
    // how many characters comprised the number) is TRUE
    //

    return (exact && (NumberLength != 0)) ? FALSE : TRUE;
}


BOOL
ExtractDword(
    IN OUT LPSTR* pString,
    IN DWORD NumberLength,
    OUT LPDWORD pConvertedNumber
    )

/*++

Routine Description:

    pulls a <NumberLength> character number out of a string.

    Assumes:    1. The number to be converted is an unsigned long
                2. A whole number is contained within *pString

Arguments:

    pString             - pointer to pointer to string from which to get number

    NumberLength        - number of characters that comprise number string, if
                          not equal to 0, else if 0, we don't know the length
                          of the number string a priori

    pConvertedNumber    - pointer to variable where converted number written

Return Value:

    BOOL
        TRUE    - number converted OK

        FALSE   - one of the characters in the number is not a digit

--*/

{
    DWORD number;
    BOOL exact;

    //
    // if the caller doesn't know how many characters comprise the number, then
    // we will convert until the next non-digit character, or until we have
    // converted the maximum number of digits that can comprise an unsigned
    // short value
    //

    if (NumberLength == 0) {
        NumberLength = sizeof("4294967295") - 1;
        exact = FALSE;
    } else {
        exact = TRUE;
    }
    for (number = 0; isdigit(**pString) && NumberLength--; ) {
        number = number * 10 + (DWORD)((BYTE)*((*pString)++) - (BYTE)'0');
    }
    *pConvertedNumber = number;

    //
    // if we were asked to convert a certain number of characters but failed
    // because we hit a non-digit character, then return FALSE. Anything else
    // (we converted required number of characters, or the caller didn't know
    // how many characters comprised the number) is TRUE
    //

    return (exact && (NumberLength != 0)) ? FALSE : TRUE;
}


BOOL
ExtractInt(
    IN OUT LPSTR* pString,
    IN DWORD NumberLength,
    OUT LPINT pConvertedNumber
    )

/*++

Routine Description:

    pulls a <NumberLength> character number out of a string.

    Assumes:    1. The number to be converted is an signed integer (32-bits)

Arguments:

    pString             - pointer to pointer to string from which to get number

    NumberLength        - number of characters that comprise number string, if
                          not equal to 0, else if 0, we don't know the length
                          of the number string a priori

    pConvertedNumber    - pointer to variable where converted number written

Return Value:

    BOOL
        TRUE    - number converted OK

        FALSE   - one of the characters in the number is not a digit

--*/

{
    int number;
    int sign;
    BOOL exact;

    if ((**pString == '-') || (**pString == '+')) {
        sign = (**pString == '-') ? -1 : +1;
        if (NumberLength) {
            --NumberLength;
        }
        ++*pString;
    } else {
        sign = 1;
    }

    //
    // if the caller doesn't know how many characters comprise the number, then
    // we will convert until the next non-digit character, or until we have
    // converted the maximum number of digits that can comprise an unsigned
    // short value
    //

    if (NumberLength == 0) {
        NumberLength = sizeof("2147483647") - 1;
        exact = FALSE;
    } else {
        exact = TRUE;
    }
    for (number = 0; isdigit(**pString) && NumberLength; ) {
        number = number * 10 + (INT)(((BYTE)**pString) - (BYTE)'0');
        ++*pString;
        --NumberLength;
    }
    *pConvertedNumber = number * sign;

    //
    // if we were asked to convert a certain number of characters but failed
    // because we hit a non-digit character, then return FALSE. Anything else
    // (we converted required number of characters, or the caller didn't know
    // how many characters comprised the number) is TRUE
    //

    return (exact && (NumberLength != 0)) ? FALSE : TRUE;
}


BOOL
SkipWhitespace(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    )

/*++

Routine Description:

    Skips any whitespace characters

Arguments:

    lpBuffer        - pointer to pointer to buffer

    lpBufferLength  - pointer to remaining buffer length

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. No more data left in buffer

--*/

{
    while ((*lpBufferLength != 0) && isspace(**lpBuffer)) {
        ++*lpBuffer;
        --*lpBufferLength;
    }
    return *lpBufferLength != 0;
}


BOOL
SkipSpaces(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    )

/*++

Routine Description:

    Skips any space characters. We only look for the actual space character

Arguments:

    lpBuffer        - pointer to pointer to buffer

    lpBufferLength  - pointer to remaining buffer length

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. No more data left in buffer

--*/

{
    while ((*lpBufferLength != 0) && (**lpBuffer == ' ')) {
        ++*lpBuffer;
        --*lpBufferLength;
    }
    return *lpBufferLength != 0;
}


BOOL
SkipLine(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    )

/*++

Routine Description:

    Positions text pointer at start of next non-empty line

Arguments:

    lpBuffer        - pointer to string. Updated on output

    lpBufferLength  - pointer to remaining length of string. Updated on output

Return Value:

    BOOL
        TRUE    - found start of next non-empty line

        FALSE   - ran out of buffer

--*/

{
    while ((*lpBufferLength != 0) && (**lpBuffer != '\r') && (**lpBuffer != '\n')) {
        ++*lpBuffer;
        --*lpBufferLength;
    }
    while ((*lpBufferLength != 0) && ((**lpBuffer == '\r') || (**lpBuffer == '\n'))) {
        ++*lpBuffer;
        --*lpBufferLength;
    }
    return *lpBufferLength != 0;
}


#undef  isspace
#define isspace(ch) ((ch==0x20) || ((ch >= 0x09) && (ch <= 0x0d)))

BOOL
FindToken(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    )

/*++

Routine Description:

    Moves over the current token, past any spaces, and to the start of the next
    token

Arguments:

    lpBuffer        - pointer to pointer to buffer

    lpBufferLength  - pointer to remaining buffer length

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. No more data left in buffer

--*/

{
    while ((*lpBufferLength != 0) && !isspace(**lpBuffer)) {
        ++*lpBuffer;
        --*lpBufferLength;
    }
    while ((*lpBufferLength != 0) && isspace(**lpBuffer)) {
        ++*lpBuffer;
        --*lpBufferLength;
    }
    return *lpBufferLength != 0;
}


LPSTR
NiceNum(
    OUT LPSTR Buffer,
    IN SIZE_T Number,
    IN int FieldWidth
    )

/*++

Routine Description:

    Converts a number to a string. The string is very human-sensible (i.e.
    1,234,567 instead of 1234567. Sometimes its hard to make out these numbers
    when your salary is so large)

Arguments:

    Buffer      - place to put resultant string

    Number      - to convert

    FieldWidth  - maximum width of the field, or 0 for "don't care"

Return Value:

    LPSTR
        pointer to Buffer

--*/

{
    int i;

    if (Number == 0) {
        if (FieldWidth == 0) {
            Buffer[0] = '0';
            Buffer[1] = '\0';
        } else {
            memset(Buffer, ' ', FieldWidth);
            Buffer[FieldWidth - 1] = '0';
            Buffer[FieldWidth] = '\0';
        }
    } else {

        //
        // if the caller specified zero for the field width then work out how
        // many characters the string will occupy
        //

        if (FieldWidth == 0) {

            SIZE_T n;

            n = Number;
            ++FieldWidth;
            while (n >= 10) {
                n /= 10;
                ++FieldWidth;
            }

            FieldWidth += (FieldWidth / 3) - (((FieldWidth % 3) == 0) ? 1 : 0);
        }

        //
        // now create the representation
        //

        Buffer[FieldWidth] = '\0';
        Buffer += FieldWidth;
        i = 0;
        while (Number && FieldWidth) {
            *--Buffer = (char)((Number % 10) + '0');
            --FieldWidth;
            Number /= 10;
            if ((++i == 3) && FieldWidth) {
                if (Number) {
                    *--Buffer = ',';
                    --FieldWidth;
                    i = 0;
                }
            }
        }
        while (FieldWidth--) {
            *--Buffer = ' ';
        }
    }
    return Buffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\common\iwinsock.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    iwinsock.cxx

Abstract:

    Contains functions to load sockets DLL and entry points. Functions and data
    in this module take care of indirecting sockets calls, hence _I_ in front
    of the function name

    Contents:
        IwinsockInitialize
        IwinsockTerminate
        LoadWinsock
        UnloadWinsock
        SafeCloseSocket

Author:

    Richard L Firth (rfirth) 12-Apr-1995

Environment:

    Win32(s) user-mode DLL

Revision History:

    12-Apr-1995 rfirth
        Created

    08-May-1996 arthurbi
        Added support for Socks Firewalls.

    05-Mar-1998 rfirth
        Moved SOCKS support into ICSocket class. Removed SOCKS library
        loading/unloading from this module (revert to pre-SOCKS)

--*/

#include <wininetp.h>

#if defined(__cplusplus)
extern "C" {
#endif

//#define RLF_DEBUG   1

#if INET_DEBUG

#ifdef RLF_DEBUG
#define DPRINTF dprintf
#else
#define DPRINTF (void)
#endif

BOOL
InitDebugSock(
    VOID
    );

VOID
TerminateDebugSock(
    VOID
    );

#else
#define DPRINTF (void)
#endif

//
// private types
//

typedef struct {
    LPSTR FunctionOrdinal;
    FARPROC * FunctionAddress;
} SOCKETS_FUNCTION;


//
// global data
//

GLOBAL
SOCKET
(PASCAL FAR * _I_accept)(
    SOCKET s,
    struct sockaddr FAR *addr,
    int FAR *addrlen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_bind)(
    SOCKET s,
    const struct sockaddr FAR *addr,
    int namelen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_closesocket)(
    SOCKET s
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_connect)(
    SOCKET s,
    const struct sockaddr FAR *name,
    int namelen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_gethostname)(
    char FAR * name,
    int namelen
    ) = NULL;

GLOBAL
LPHOSTENT
(PASCAL FAR * _I_gethostbyname)(
    LPSTR lpHostName
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_getsockname)(
    SOCKET s,
    struct sockaddr FAR *name,
    int FAR * namelen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_getsockopt)(
    SOCKET s,
    int level,
    int optname,
    char FAR * optval,
    int FAR *optlen
    );

GLOBAL
u_long
(PASCAL FAR * _I_htonl)(
    u_long hostlong
    ) = NULL;

GLOBAL
u_short
(PASCAL FAR * _I_htons)(
    u_short hostshort
    ) = NULL;

GLOBAL
unsigned long
(PASCAL FAR * _I_inet_addr)(
    const char FAR * cp
    ) = NULL;

GLOBAL
char FAR *
(PASCAL FAR * _I_inet_ntoa)(
    struct in_addr in
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_ioctlsocket)(
    SOCKET s,
    long cmd,
    u_long FAR *argp
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_listen)(
    SOCKET s,
    int backlog
    ) = NULL;

GLOBAL
u_short
(PASCAL FAR * _I_ntohs)(
    u_short netshort
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_recv)(
    SOCKET s,
    char FAR * buf,
    int len,
    int flags
    ) = NULL;

GLOBAL
int 
(PASCAL FAR * _I_WSARecv)(
    SOCKET s,                                               
    LPWSABUF lpBuffers,                                     
    DWORD dwBufferCount,                                    
    LPDWORD lpNumberOfBytesRecvd,                           
    LPDWORD lpFlags,                                        
    LPWSAOVERLAPPED lpOverlapped,                           
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine  
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_recvfrom)(
    SOCKET s,
    char FAR * buf,
    int len,
    int flags,
    struct sockaddr FAR *from, 
    int FAR * fromlen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_select)(
    int nfds,
    fd_set FAR *readfds,
    fd_set FAR *writefds,
    fd_set FAR *exceptfds,
    const struct timeval FAR *timeout
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_send)(
    SOCKET s,
    const char FAR * buf,
    int len,
    int flags
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_WSASend)(
    SOCKET s,                                                  
    LPWSABUF lpBuffers,                                     
    DWORD dwBufferCount,                                    
    LPDWORD lpNumberOfBytesSent,                            
    DWORD dwFlags,                                          
    LPWSAOVERLAPPED lpOverlapped,                           
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine  
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_sendto)(
    SOCKET s,
    const char FAR * buf,
    int len,
    int flags,
    const struct sockaddr FAR *to, 
    int tolen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_setsockopt)(
    SOCKET s,
    int level,
    int optname,
    const char FAR * optval,
    int optlen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_shutdown)(
    SOCKET s,
    int how
    ) = NULL;

GLOBAL
SOCKET
(PASCAL FAR * _I_socket)(
    int af,
    int type,
    int protocol
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_WSAStartup)(
    WORD wVersionRequired,
    LPWSADATA lpWSAData
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_WSACleanup)(
    void
    ) = NULL;

//VENKATKBUG-remove later - for now trap any errors 
GLOBAL
int
(PASCAL FAR * __I_WSAGetLastError)(
    void
    ) = NULL;


int
___I_WSAGetLastError(
    VOID
    )
{
    int nError = __I_WSAGetLastError();
/*
    VENKATK_BUG - OK to have WSAENOTSOCK - could happen for timeout situations.
    INET_ASSERT (nError != WSAENOTSOCK);
 */
    return nError;
}


GLOBAL
int
(PASCAL FAR * _I_WSAGetLastError)(
    void
    ) = ___I_WSAGetLastError;
    
GLOBAL
void
(PASCAL FAR * _I_WSASetLastError)(
    int iError
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I___WSAFDIsSet)(
    SOCKET,
    fd_set FAR *
    ) = NULL;

#if INET_DEBUG

void SetupSocketsTracing(void);

#endif

//
// private data
//

//
// InitializationLock - protects against multiple threads loading WSOCK32.DLL
// and entry points
//

PRIVATE CCritSec InitializationLock;

//
// hWinsock - NULL when WSOCK32.DLL is not loaded
//

PRIVATE HINSTANCE hWinsock = NULL;

//
// WinsockLoadCount - the number of times we have made calls to LoadWinsock()
// and UnloadWinsock(). When this reaches 0 (again), we can unload the Winsock
// DLL for real
//

PRIVATE DWORD WinsockLoadCount = 0;

//
// SocketsFunctions - this is the list of entry points in WSOCK32.DLL that we
// need to load for WININET.DLL
//

PRIVATE
SOCKETS_FUNCTION
SocketsFunctions[] = {
    "accept",           (FARPROC*)&_I_accept,
    "bind",             (FARPROC*)&_I_bind,
    "closesocket",      (FARPROC*)&_I_closesocket,
    "connect",          (FARPROC*)&_I_connect,
    "getsockname",      (FARPROC*)&_I_getsockname,
    "getsockopt",       (FARPROC*)&_I_getsockopt,
    "htonl",            (FARPROC*)&_I_htonl,
    "htons",            (FARPROC*)&_I_htons,

    "inet_addr",        (FARPROC*)&_I_inet_addr,
    "inet_ntoa",        (FARPROC*)&_I_inet_ntoa,
    "ioctlsocket",      (FARPROC*)&_I_ioctlsocket,

    "listen",           (FARPROC*)&_I_listen,
    "ntohs",            (FARPROC*)&_I_ntohs,
    "recv",             (FARPROC*)&_I_recv,
    "recvfrom",         (FARPROC*)&_I_recvfrom,
    "select",           (FARPROC*)&_I_select,
    "send",             (FARPROC*)&_I_send,
    "sendto",           (FARPROC*)&_I_sendto,
    "setsockopt",       (FARPROC*)&_I_setsockopt,
    "shutdown",         (FARPROC*)&_I_shutdown,
    "socket",           (FARPROC*)&_I_socket,
    "gethostbyname",    (FARPROC*)&_I_gethostbyname,
    "gethostname",      (FARPROC*)&_I_gethostname,
    "WSAGetLastError",  (FARPROC*)&__I_WSAGetLastError,
    "WSASetLastError",  (FARPROC*)&_I_WSASetLastError,
    "WSAStartup",       (FARPROC*)&_I_WSAStartup,
    "WSACleanup",       (FARPROC*)&_I_WSACleanup,
    "__WSAFDIsSet",     (FARPROC*)&_I___WSAFDIsSet,
    "WSARecv",          (FARPROC*)&_I_WSARecv,
    "WSASend",          (FARPROC*)&_I_WSASend
};


//
// private prototypes
//

#if INET_DEBUG

void SetupSocketsTracing(void);

#endif

//
// functions
//


BOOL
IwinsockInitialize(
    VOID
    )

/*++

Routine Description:

    Performs initialization/resource allocation for this module

Arguments:

    None.

Return Value:

    None.

--*/

{
    BOOL fResult;
    //
    // initialize the critical section that protects against multiple threads
    // trying to initialize Winsock
    //

    fResult = InitializationLock.Init();

#if INET_DEBUG
    if (fResult)
        fResult = InitDebugSock();
#endif

    return fResult;
}


VOID
IwinsockTerminate(
    VOID
    )

/*++

Routine Description:

    Performs termination & resource cleanup for this module

Arguments:

    None.

Return Value:

    None.

--*/

{
    InitializationLock.FreeLock();

#if INET_DEBUG
    TerminateDebugSock();
#endif
}


DWORD
LoadWinsock(
    VOID
    )

/*++

Routine Description:

    Dynamically loads Windows sockets library

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - Win32 error
                    e.g. LoadLibrary() failure

                  WSA error
                    e.g. WSAStartup() failure

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                Dword,
                "LoadWinsock",
                NULL
                ));

    DWORD error = ERROR_SUCCESS;

    //
    // ensure no 2 threads are trying to modify the loaded state of winsock at
    // the same time
    //

    if (!InitializationLock.Lock())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    if (hWinsock == NULL) {

        BOOL failed = FALSE;

        //
        // BUGBUG - read this value from registry
        //

        hWinsock = LoadLibrary("ws2_32");
        
        if (hWinsock == NULL) {
            
            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("failed to load ws2_32.dll"));
            
            hWinsock = LoadLibrary("wsock32");
        }
        
        if (hWinsock != NULL) {

            //
            // load the entry points
            //

            for (int i = 0; i < ARRAY_ELEMENTS(SocketsFunctions); ++i) {

                FARPROC farProc;

                farProc = GetProcAddress(
                                hWinsock,
                                (LPCSTR)SocketsFunctions[i].FunctionOrdinal
                                );
                if (farProc == NULL) {
                    failed = TRUE;
                    break;
                }
                *SocketsFunctions[i].FunctionAddress = farProc;
            }
            if (!failed) {

                //
                // although we need a WSADATA for WSAStartup(), it is an
                // expendible structure (not required for any other sockets
                // calls)
                //

                WSADATA wsaData;

                error = _I_WSAStartup(0x0101, &wsaData);
                if (error == ERROR_SUCCESS) {

                    DEBUG_PRINT(SOCKETS,
                                INFO,
                                ("winsock description: %q\n",
                                wsaData.szDescription
                                ));

                    int stringLen;

                    stringLen = lstrlen(wsaData.szDescription);
                    if (strnistr(wsaData.szDescription, "novell", stringLen)
                    && strnistr(wsaData.szDescription, "wsock32", stringLen)) {

                        DEBUG_PRINT(SOCKETS,
                                    INFO,
                                    ("running on Novell Client32 stack\n"
                                    ));

                        GlobalRunningNovellClient32 = TRUE;
                    }
#if INET_DEBUG
                    SetupSocketsTracing();
#endif
                } else {
                    failed = TRUE;
                }
            }
        } else {
            failed = TRUE;
        }

        //
        // if we failed to find an entry point or WSAStartup() returned an error
        // then unload the library
        //

        if (failed) {

            //
            // important: there should be no API calls between determining the
            // failure and coming here to get the error code
            //
            // if error == ERROR_SUCCESS then we have to get the last error, else
            // it is the error returned by WSAStartup()
            //

            if (error == ERROR_SUCCESS) {
                error = GetLastError();

                INET_ASSERT(error != ERROR_SUCCESS);

            }
            UnloadWinsock();
        }
    } else {

        //
        // just increment the number of times we have called LoadWinsock()
        // without a corresponding call to UnloadWinsock();
        //

        ++WinsockLoadCount;
    }

    InitializationLock.Unlock();

    //
    // if we failed for any reason, need to report that TCP/IP not available
    //

    if (error != ERROR_SUCCESS) {
        error = ERROR_NOT_SUPPORTED;
    }

quit:
    DEBUG_LEAVE(error);

    return error;
}


VOID
UnloadWinsock(
    VOID
    )

/*++

Routine Description:

    Unloads winsock DLL and prepares hWinsock and SocketsFunctions[] for reload

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "UnloadWinsock",
                 NULL
                 ));

    //
    // ensure no 2 threads are trying to modify the loaded state of winsock at
    // the same time
    //

    if (!InitializationLock.Lock())
    {
        goto quit;
    }

    //
    // only unload the DLL if it has been mapped into process memory
    //

    if (hWinsock != NULL) {

        //
        // and only if this is the last load instance
        //

        if (WinsockLoadCount == 0) {

            INET_ASSERT(_I_WSACleanup != NULL);

            if (_I_WSACleanup != NULL) {

                //
                // need to terminate async support too - it is reliant on
                // Winsock
                //

                //called only from LoadWinsock which is called only from INTERNET_HANDLE_OBJECT()
                //so not in dynamic unload, so alrite to cleanup.
                TerminateAsyncSupport(TRUE);

                int serr = _I_WSACleanup();

                if (serr != 0) {

                    DEBUG_PRINT(SOCKETS,
                                ERROR,
                                ("WSACleanup() returns %d; WSA error = %d\n",
                                serr,
                                (_I_WSAGetLastError != NULL)
                                    ? _I_WSAGetLastError()
                                    : -1
                                ));

                }
            }
            for (int i = 0; i < ARRAY_ELEMENTS(SocketsFunctions); ++i) {
                *SocketsFunctions[i].FunctionAddress = (FARPROC)NULL;
            }
            FreeLibrary(hWinsock);
            hWinsock = NULL;
        } else {

            //
            // if there have been multiple virtual loads, then just reduce the
            // load count
            //

            --WinsockLoadCount;
        }
    }

    InitializationLock.Unlock();

quit:
    DEBUG_LEAVE(0);
}


DWORD
SafeCloseSocket(
    IN SOCKET Socket
    )

/*++

Routine Description:

    closesocket() call protected by exception handler in case winsock DLL has
    been unloaded by system before Wininet DLL unloaded

Arguments:

    Socket  - socket handle to close

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - socket error mapped to ERROR_WINHTTP_ error

--*/

{
    int serr;

    __try {
        serr = _I_closesocket(Socket);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        serr = 0;
    }
    ENDEXCEPT
    return (serr == SOCKET_ERROR)
        ? MapInternetError(_I_WSAGetLastError())
        : ERROR_SUCCESS;
}

CWrapOverlapped* GetWrapOverlappedObject(LPVOID lpAddress)
{
    return CONTAINING_RECORD(lpAddress, CWrapOverlapped, m_Overlapped);
}

#if INET_DEBUG

//
// debug data types
//

SOCKET
PASCAL FAR
_II_socket(
    int af,
    int type,
    int protocol
    );

int
PASCAL FAR
_II_closesocket(
    SOCKET s
    );

SOCKET
PASCAL FAR
_II_accept(
    SOCKET s,
    struct sockaddr FAR *addr,
    int FAR *addrlen
    );

GLOBAL
SOCKET
(PASCAL FAR * _P_accept)(
    SOCKET s,
    struct sockaddr FAR *addr,
    int FAR *addrlen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _P_closesocket)(
    SOCKET s
    ) = NULL;

GLOBAL
SOCKET
(PASCAL FAR * _P_socket)(
    int af,
    int type,
    int protocol
    ) = NULL;

#define MAX_STACK_TRACE     5
#define MAX_SOCK_ENTRIES    1000

typedef struct _DEBUG_SOCK_ENTRY {
    SOCKET Socket;
    DWORD StackTraceLength;
    PVOID StackTrace[ MAX_STACK_TRACE ];
} DEBUG_SOCK_ENTRY, *LPDEBUG_SOCK_ENTRY;

CCritSec DebugSockLock;
DEBUG_SOCK_ENTRY GlobalSockEntry[MAX_SOCK_ENTRIES];

DWORD GlobalSocketsCount = 0;


#define LOCK_DEBUG_SOCK()   (DebugSockLock.Lock())
#define UNLOCK_DEBUG_SOCK() (DebugSockLock.Unlock())

HINSTANCE NtDllHandle;

typedef USHORT (*RTL_CAPTURE_STACK_BACK_TRACE)(
   IN ULONG FramesToSkip,
   IN ULONG FramesToCapture,
   OUT PVOID *BackTrace,
   OUT PULONG BackTraceHash
   );

RTL_CAPTURE_STACK_BACK_TRACE pRtlCaptureStackBackTrace;

BOOL
InitDebugSock(
    VOID
    )
{
    memset( GlobalSockEntry, 0x0, sizeof(GlobalSockEntry) );
    GlobalSocketsCount = 0;

    if (!DebugSockLock.Init())
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

VOID
TerminateDebugSock(
    VOID
    )
{
    DebugSockLock.FreeLock();
}

VOID
SetupSocketsTracing(
    VOID
    )
{
    if (!(InternetDebugCategoryFlags & DBG_TRACE_SOCKETS)) {
        return ;
    }
    if (!IsPlatformWinNT()) {
        return ;
    }
    if ((NtDllHandle = LoadLibrary("ntdll.dll")) == NULL) {
        return ;
    }
    if ((pRtlCaptureStackBackTrace =
        (RTL_CAPTURE_STACK_BACK_TRACE)
            GetProcAddress(NtDllHandle, "RtlCaptureStackBackTrace")) == NULL) {
        FreeLibrary(NtDllHandle);
        return ;
    }

//#ifdef DONT_DO_FOR_NOW
    _P_accept = _I_accept;
    _I_accept = _II_accept;
    _P_closesocket = _I_closesocket;
    _I_closesocket = _II_closesocket;
    _P_socket = _I_socket;
    _I_socket = _II_socket;
//#endif
}

VOID
AddSockEntry(
    SOCKET S
    )
{
    DWORD i;
    DWORD Hash;

    if (!(InternetDebugCategoryFlags & DBG_TRACE_SOCKETS)) {
        return ;
    }

    LOCK_DEBUG_SOCK();

    //
    // search for a free entry.
    //

    for( i = 0; i < MAX_SOCK_ENTRIES; i++ ) {

        if( GlobalSockEntry[i].Socket == 0 ) {

            DWORD Hash;

            //
            // found a free entry.
            //

            GlobalSockEntry[i].Socket = S;

            //
            // get caller stack.
            //

#if i386
            Hash = 0;

            GlobalSockEntry[i].StackTraceLength =
                pRtlCaptureStackBackTrace(
                    2,
                    MAX_STACK_TRACE,
                    GlobalSockEntry[i].StackTrace,
                    &Hash );
#else // i386
            GlobalSockEntry[i].StackTraceLength = 0;
#endif // i386


            GlobalSocketsCount++;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("socket count = %ld\n",
                        GlobalSocketsCount
                        ));

            DPRINTF("%d sockets\n", GlobalSocketsCount);

            UNLOCK_DEBUG_SOCK();
            return;
        }
    }

    //
    // we have reached a high handle limit, which is unusal, needs to be
    // debugged.
    //

    INET_ASSERT( FALSE );
    UNLOCK_DEBUG_SOCK();

    return;
}

VOID
RemoveSockEntry(
    SOCKET S
    )
{
    DWORD i;

    if (!(InternetDebugCategoryFlags & DBG_TRACE_SOCKETS)) {
        return ;
    }

    LOCK_DEBUG_SOCK();

    for( i = 0; i < MAX_SOCK_ENTRIES; i++ ) {

        if( GlobalSockEntry[i].Socket == S ) {

            //
            // found the entry. Free it now.
            //

            memset( &GlobalSockEntry[i], 0x0, sizeof(DEBUG_SOCK_ENTRY) );

            GlobalSocketsCount--;

#ifdef IWINSOCK_DEBUG_PRINT

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("count(%ld), RemoveSock(%lx)\n",
                        GlobalSocketsCount,
                        S
                        ));

#endif // IWINSOCK_DEBUG_PRINT

            DPRINTF("%d sockets\n", GlobalSocketsCount);

            UNLOCK_DEBUG_SOCK();
            return;
        }
    }

#ifdef IWINSOCK_DEBUG_PRINT

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("count(%ld), UnknownSock(%lx)\n",
                GlobalSocketsCount,
                S
                ));

#endif // IWINSOCK_DEBUG_PRINT

    //
    // socket entry is not found.
    //

    // INET_ASSERT( FALSE );

    UNLOCK_DEBUG_SOCK();
    return;
}

SOCKET
PASCAL FAR
_II_socket(
    int af,
    int type,
    int protocol
    )
{
    SOCKET S;

    S = _P_socket( af, type, protocol );
    AddSockEntry( S );
    return( S );
}

int
PASCAL FAR
_II_closesocket(
    SOCKET s
    )
{
    int Ret;

    RemoveSockEntry( s );
    Ret = _P_closesocket( s );
    return( Ret );
}

SOCKET
PASCAL FAR
_II_accept(
    SOCKET s,
    struct sockaddr FAR *addr,
    int FAR *addrlen
    )
{
    SOCKET S;

    S = _P_accept( s, addr, addrlen );
    AddSockEntry( S );
    return( S );

}

VOID
IWinsockCheckSockets(
    VOID
    )
{
    DEBUG_PRINT(SOCKETS,
                INFO,
                ("GlobalSocketsCount = %d\n",
                GlobalSocketsCount
                ));

    for (DWORD i = 0; i < MAX_SOCK_ENTRIES; ++i) {

        SOCKET sock;

        if ((sock = GlobalSockEntry[i].Socket) != 0) {

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("Socket %#x\n",
                        sock
                        ));

        }
    }
}

#endif // INET_DEBUG

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\common\reslock.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    reslock.cxx

Abstract:

    Contains methods for RESOURCE_LOCK class

    Contents:
        RESOURCE_LOCK::Acquire()
        RESOURCE_LOCK::Release()

Author:

    Richard L Firth (rfirth) 18-Jun-1996

Revision History:

    18-Jun-1996 rfirth
        Created

--*/

#include <wininetp.h>

//
// class members
//

#ifdef OLD_VERSION


BOOL
RESOURCE_LOCK::Acquire(
    IN BOOL bExclusiveMode
    )

/*++

Routine Description:

    Acquires the resource protected by this lock. Acquires for non-exclusive
    (read) or exclusive (write) ownership

Arguments:

    bExclusiveMode  - TRUE if we are acquiring the resource for exclusive
                      (write) ownership

Return Value:

    BOOL
        TRUE    - resource is acquired

        FALSE   - failed to acquire resource (timeout?)

--*/

{
    DEBUG_ENTER((DBG_RESLOCK,
                Bool,
                "RESOURCE_LOCK::Acquire",
                "%B",
                bExclusiveMode
                ));

    INET_ASSERT(this != NULL);
    //INET_ASSERT(IsInitialized());
    //INET_ASSERT(IsValid());

    if (!IsInitialized()) {

        DEBUG_LEAVE(FALSE);

        return FALSE;
    }

    BOOL acquired = TRUE;

    //_CritSect.Lock();
    if (bExclusiveMode) {

        //
        // acquired for exclusive ownership (write access). Set the owning
        // thread id and wait for the last current reader to release. Note
        // that if we're being re-entered, the Lock() has already
        // done the work of checking the thread id and updating re-entrancy
        // counts, so if its already not zero, we know it must be us
        //

        ++_WriteCount;
        if (_ThreadId == 0) {
            _ThreadId = GetCurrentThreadId();
#if INET_DEBUG
            INET_ASSERT(_ThreadId != _ThreadIdReader);
#endif
            acquired = Wait(_hWriteEvent);
            _CritSect.Lock();
        } else {

            INET_ASSERT(_ThreadId == GetCurrentThreadId());

        }
    } else {

        //
        // don't allow re-entry if already held for exclusive access
        //

        INET_ASSERT(_ThreadId == 0);

        //
        // acquired for non-exclusive ownership (read access). Just increase
        // the number of active readers. If this is the first then inhibit the
        // writer
        //

        if (InterlockedIncrement(&_Readers) == 0) {
#if INET_DEBUG
            if (_ThreadIdReader == 0) {
                _ThreadIdReader = GetCurrentThreadId();
            }
#endif
            ResetEvent(_hWriteEvent);
        }

        //
        // reader doesn't need to keep hold of critical section
        //

        //_CritSect.Unlock();
    }

    DEBUG_LEAVE(acquired);

    return acquired;
}


VOID
RESOURCE_LOCK::Release(
    VOID
    )

/*++

Routine Description:

    Releases a resource previously acquired by RESOURCE_LOCK::Acquire()

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_RESLOCK,
                None,
                "RESOURCE_LOCK::Release",
                NULL
                ));

    INET_ASSERT(this != NULL);
    //INET_ASSERT(IsInitialized());
    //INET_ASSERT(IsValid());

    if (!IsInitialized()) {

        DEBUG_LEAVE(0);

        return;
    }

    if ((_ThreadId != 0) && (_ThreadId == GetCurrentThreadId())) {

        INET_ASSERT(_WriteCount > 0);

        if (--_WriteCount == 0) {

            //
            // we acquired _hWriteEvent; signal it to allow next writer to continue
            //

            SetEvent(_hWriteEvent);

            //
            // this resource no longer owned for exclusive access
            //

            _ThreadId = 0;
        }
        _CritSect.Unlock();
    } else if (InterlockedDecrement(&_Readers) < 0) {

        INET_ASSERT(_Readers >= -1);

        //
        // we are last currently active reader; allow waiting writer to continue
        //

#if INET_DEBUG
        if (_ThreadIdReader == GetCurrentThreadId()) {
            _ThreadIdReader = 0;
        }
#endif
        SetEvent(_hWriteEvent);
    }

    DEBUG_LEAVE(0);
}

#else

BOOL
RESOURCE_LOCK::Acquire(
    IN BOOL bExclusiveMode
    )
{
    DEBUG_ENTER((DBG_RESLOCK,
                Bool,
                "RESOURCE_LOCK::Acquire",
                "%B",
                bExclusiveMode
                ));

    BOOL fReturn = TRUE;

    if (!IsInitialized()) {

        fReturn = FALSE;
        goto quit;
    }

    if (bExclusiveMode) {
        do {

            DEBUG_PRINT(RESLOCK,
                        INFO,
                        ("Waiting on WriteEvent\n")
                        );

            if (_ThreadId != GetCurrentThreadId()) {
                Wait(_hWriteEvent);
            }
            
            if (!_CritSect.Lock())
            {
                DEBUG_PRINT(RESLOCK,
                            ERROR,
                            ("Failed to obtain critsec lock after waiting on WriteEvent\n")
                            );
                fReturn = FALSE;
                break;
            }

            INET_ASSERT((_ThreadId == 0) || (_ThreadId == GetCurrentThreadId()));

            if ((_Readers == -1)
                && ((_ThreadId == 0) || (_ThreadId == GetCurrentThreadId()))) {
                _ThreadId = GetCurrentThreadId();
                if (++_WriteCount == 1) {
                    ResetEvent(_hWriteEvent);
                }
                break;
            }

            DEBUG_PRINT(RESLOCK,
                        INFO,
                        ("trying again\n")
                        );

            _CritSect.Unlock();
        } while ( 1 );
    } else {
        if (_CritSect.Lock()) {
            if (++_Readers == 0) {

                DEBUG_PRINT(RESLOCK,
                            INFO,
                            ("Resetting WriteEvent\n")
                            );

                ResetEvent(_hWriteEvent);
            }
            _CritSect.Unlock();
        }
        else {
            DEBUG_PRINT(RESLOCK,
                        ERROR,
                        ("Failed to obtain critsec lock after waiting on WriteEvent\n")
                        );
            fReturn = FALSE;
        }
    }

quit:
    DEBUG_LEAVE(fReturn);

    return fReturn;
}

VOID
RESOURCE_LOCK::Release(
    VOID
    )
{
    DEBUG_ENTER((DBG_RESLOCK,
                None,
                "RESOURCE_LOCK::Release",
                NULL
                ));

    if (IsInitialized()) {
        if (_ThreadId == GetCurrentThreadId()) {

            DEBUG_PRINT(RESLOCK,
                        INFO,
                        ("Clearing writer\n")
                        );

            if (--_WriteCount == 0) {
                _ThreadId = 0;
                SetEvent(_hWriteEvent);
            }
            _CritSect.Unlock();
        } else {
            if (_CritSect.Lock()) {
                if (--_Readers == -1) {

                    DEBUG_PRINT(RESLOCK,
                                INFO,
                                ("Setting WriteEvent\n")
                                );

                    SetEvent(_hWriteEvent);
                }
                _CritSect.Unlock();
            }
            else {
                DEBUG_PRINT(RESLOCK,
                            INFO,
                            ("Couldn't set WriteEvent due to not enough memory\n")
                            );
            }
        }
    }

    DEBUG_LEAVE(0);
}

#endif // OLD_VERSION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\common\priolist.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    priolist.cxx

Abstract:

    Contains prioritized, serialized list class implementation

    Contents:
        CPriorityList::Insert
        CPriorityList::Remove

Author:

    Richard L Firth (rfirth) 03-May-1997

Notes:

    Properly, the CPriorityList class should extend a CSerializedList class, but
    we don't currently have one, just a serialized list type (common\serialst.cxx).

    WARNING: Code in this module makes assumptions about the contents of a
    SERIALIZED_LIST

Revision History:

    03-May-1997 rfirth
        Created

--*/

#include <wininetp.h>

//
// class methods
//


DWORD
CPriorityList::Insert(
    IN CPriorityListEntry * pEntry
    )

/*++

Routine Description:

    Insert prioritized list entry into prioritized, serialized list

Arguments:

    pEntry  - pointer to prioritized list entry to add

Return Value:

    ERROR_SUCCESS

    ERROR_NOT_ENOUGH_MEMORY - returned when lock can't be acquired.

--*/

{
    DEBUG_ENTER((DBG_UTIL,
                 None,
                 "CPriorityList::Insert",
                 "{%#x} %#x",
                 this,
                 pEntry
                 ));

    DWORD error = ERROR_SUCCESS;

    if (!Acquire())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    INET_ASSERT(!IsOnSerializedList(&m_List, pEntry->List()));
    INET_ASSERT(pEntry->Next() == NULL);
    INET_ASSERT(pEntry->Prev() == NULL);

    CPriorityListEntry * pCur;

    for (pCur = (CPriorityListEntry *)m_List.List.Flink;
         pCur != (CPriorityListEntry *)&m_List.List.Flink;
         pCur = (CPriorityListEntry *)pCur->Next()) {

        if (pCur->GetPriority() < pEntry->GetPriority()) {
            break;
        }
    }
    InsertHeadList(pCur->Prev(), pEntry->List());
    ++m_List.ElementCount;
    Release();

quit:
    DEBUG_LEAVE(error);

    return error;
}


DWORD
CPriorityList::Remove(
    IN CPriorityListEntry * pEntry
    )

/*++

Routine Description:

    Remove entry from prioritized serialized list

Arguments:

    pEntry  - address of entry to remove

Return Value:

    ERROR_SUCCESS

    ERROR_NOT_ENOUGH_MEMORY - returned when lock can't be acquired.
                              Note:  All current cases have already acquired the lock

--*/

{
    DEBUG_ENTER((DBG_UTIL,
                 None,
                 "CPriorityList::Remove",
                 "{%#x} %#x",
                 this,
                 pEntry
                 ));

    DWORD dwError = ERROR_SUCCESS;

    if (Acquire())
    {

        INET_ASSERT(IsOnSerializedList(&m_List, pEntry->List()));

        pEntry->Remove();
        --m_List.ElementCount;
        Release();
    }
    else
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
    }

    DEBUG_LEAVE(dwError);
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\common\rescache.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    rescache.cxx

Abstract:

    Contains functions which manipulate hostent cache for winsock gethostbyObject
    calls

    Contents:
        QueryHostentCache
        CacheHostent
        FlushHostentCache
        ReleaseHostentCacheEntry
        ThrowOutHostentCacheEntry
        (RemoveCacheEntry)
        (ResolverCacheHit)
        (HostentMatch)
        (CreateCacheEntry)
        (CompareHostentNames)
        (BytesInHostent)
        (CopyHostentToBuffer)

Author:

    Richard L Firth (rfirth) 10-Jul-1994

Environment:

    Win-16/32 user level

Revision History:

    rfirth 10-Jul-1994
        Created

--*/

//
// includes
//

#include "wininetp.h"

//
// private manifests
//

//
// private macros
//

#define SET_EXPIRATION_TIME(cacheEntry)

//
// private data
//

PRIVATE BOOL HostentCacheInitialized = FALSE;

//
// DnsCachingEnabled - caching is enabled by default
//

PRIVATE BOOL DnsCachingEnabled = TRUE;

//
// DnsCacheTimeout - number of seconds before a cache entry expires. This value
// is added to the current time (in seconds) to get the expiry time
//

PRIVATE DWORD DnsCacheTimeout = DEFAULT_DNS_CACHE_TIMEOUT;

//
// MaximumDnsCacheEntries - the maximum number of RESOLVER_CACHE_ENTRYs in the
// cache before we start throwing out the LRU
//

PRIVATE LONG MaximumDnsCacheEntries = DEFAULT_DNS_CACHE_ENTRIES;

//
// ResolverCache - serialized list of RESOLVER_CACHE_ENTRYs, kept in MRU order.
// We only need to remove the tail of the list to remove the LRU entry
//

//
// private prototypes
//

PRIVATE
VOID
RemoveCacheEntry(
    IN SERIALIZED_LIST* pResolverCache,
    IN LPRESOLVER_CACHE_ENTRY lpCacheEntry
    );

PRIVATE
BOOL
ResolverCacheHit(
    IN LPRESOLVER_CACHE_ENTRY lpCacheEntry,
    IN LPSTR Name OPTIONAL,
    IN LPBYTE Address OPTIONAL
    );

PRIVATE
BOOL
HostentMatch(
    IN LPHOSTENT Hostent,
    IN LPSTR Name OPTIONAL,
    IN LPBYTE Address OPTIONAL
    );

PRIVATE
LPRESOLVER_CACHE_ENTRY
CreateCacheEntry(
    IN LPSTR lpszHostName,
    IN LPHOSTENT Hostent,
    IN DWORD TimeToLive,
    IN VOID** pAlloc=NULL,
    IN DWORD dwAllocSize=0
    );

PRIVATE
BOOL
CompareHostentNames(
    IN LPHOSTENT Hostent,
    IN LPSTR Name
    );

PRIVATE
DWORD
BytesInHostent(
    IN LPHOSTENT Hostent
    );

PRIVATE
DWORD
CopyHostentToBuffer(
    OUT PCHAR Buffer,
    IN UINT BufferLength,
    IN PHOSTENT Hostent
    );

#if INET_DEBUG

PRIVATE
DEBUG_FUNCTION
LPSTR
CacheTimestr(
    IN DWORD Time
    );

PRIVATE
DEBUG_FUNCTION
LPSTR
CacheHostentStr(
    IN LPHOSTENT Hostent
    );

PRIVATE
DEBUG_FUNCTION
LPSTR
CacheMapIpAddress(
    IN LPBYTE Address
    );

#endif

//
// functions
//


BOOL
QueryHostentCache(
    SERIALIZED_LIST* pResolverCache,
    IN LPSTR Name OPTIONAL,
    IN LPBYTE Address OPTIONAL,
    OUT LPHOSTENT * Hostent,
    OUT LPDWORD TimeToLive
    )

/*++

Routine Description:

    Checks if Name is stored in the last resolved name cache. If the entry is
    found, but has expired then it is removed from the cache

Arguments:

    Name        - pointer to name string

    Address     - pointer to IP address

    Hostent     - pointer to returned pointer to hostent

    TimeToLive  - pointer to returned time to live

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "QueryHostentCache",
                 "%q, %s, %#x, %#x",
                 Name,
                 CacheMapIpAddress(Address),
                 Hostent,
                 TimeToLive
                 ));

    BOOL found;

    if (!DnsCachingEnabled || !LockSerializedList(pResolverCache))
    {
        DEBUG_PRINT(SOCKETS,
                    WARNING,
                    ("DNS caching disabled or unable to serialize access\n"
                    ));

        *Hostent = NULL;
        found = FALSE;
        goto quit;
    }

    LPRESOLVER_CACHE_ENTRY cacheEntry;
    LPRESOLVER_CACHE_ENTRY previousEntry;
    DWORD timeNow;

    cacheEntry = (LPRESOLVER_CACHE_ENTRY)HeadOfSerializedList(pResolverCache);
    timeNow = (DWORD)time(NULL);

    while (cacheEntry != (LPRESOLVER_CACHE_ENTRY)SlSelf(pResolverCache)) {

        //
        // on every cache lookup, purge any stale entries. LIVE_FOREVER means
        // that we don't expect the entry's net address to expire, but it
        // DOESN'T mean that we can't throw out the entry if its the LRU and
        // we're at maximum cache capacity. We can't do this if the item is
        // still in-use. In this case, we mark it stale
        //

        if ((cacheEntry->ExpirationTime != LIVE_FOREVER)
        && (cacheEntry->ExpirationTime <= timeNow)) {

            //
            // if reference count not zero then another thread is using
            // this entry - mark as stale else delete it
            //

            if (cacheEntry->ReferenceCount != 0) {

                INET_ASSERT(cacheEntry->State == ENTRY_IN_USE);

                cacheEntry->State = ENTRY_DELETE;
            } else {

                //
                // this entry is stale; throw it out
                // "my hovercraft is full of eels"
                //

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("throwing out stale DNS entry %q, expiry = %s\n",
                            cacheEntry->Hostent.h_name,
                            CacheTimestr(cacheEntry->ExpirationTime)
                            ));

                //
                // BUGBUG - what happens if ExpirationTime == timeNow?
                //

                previousEntry = (LPRESOLVER_CACHE_ENTRY)cacheEntry->ListEntry.Blink;
                RemoveCacheEntry(pResolverCache, cacheEntry);
                cacheEntry = previousEntry;
            }
        } else if (ResolverCacheHit(cacheEntry, Name, Address)
        && ((cacheEntry->State == ENTRY_UNUSED)
        || (cacheEntry->State == ENTRY_IN_USE))) {

            //
            // we found the entry, and it still has time to live. Make it the
            // head of the list (MRU first), set the state to in-use and increase
            // the reference count
            //

            if (RemoveFromSerializedList(pResolverCache, &cacheEntry->ListEntry))
            {
                if (InsertAtHeadOfSerializedList(pResolverCache, &cacheEntry->ListEntry))
                {
                    cacheEntry->State = ENTRY_IN_USE;
                    ++cacheEntry->ReferenceCount;
                    *Hostent = &cacheEntry->Hostent;
                    found = TRUE;


                    DEBUG_PRINT(SOCKETS,
                                INFO,
                                ("entry found in DNS cache\n"
                                ));
                }
                else
                {
                    DEBUG_PRINT(SOCKETS,
                                INFO,
                                ("entry found in DNS cache, but removed due to not enough memory\n"
                                ));
                }
            }

            goto done;
        }
        cacheEntry = (LPRESOLVER_CACHE_ENTRY)cacheEntry->ListEntry.Flink;
    }

    *Hostent = NULL;
    found = FALSE;

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("didn't find entry in DNS cache\n"
                ));

done:

    UnlockSerializedList(pResolverCache);

quit:

    DEBUG_LEAVE(found);

    return found;
}


VOID
CacheHostent(
    SERIALIZED_LIST* pResolverCache,
    IN LPSTR lpszHostName,
    IN LPHOSTENT Hostent,
    IN DWORD TimeToLive,
    IN VOID** pAlloc,
    IN DWORD dwAllocSize
    )

/*++

Routine Description:

    Adds a hostent structure to the cache. Creates a new structure and links it
    into the cache list, displacing the LRU entry if required. If we cannot
    create the entry, no action is taken, no errors returned

Arguments:

    lpszHostName    - the name we originally requested be resolved. May be
                      different than the names returned by the resolver, e.g.
                      "proxy" => "proxy1.microsoft.com, proxy2.microsoft.com"

    Hostent         - pointer to hostent to add to cache

    TimeToLive      - amount of time this information has to live. Can be:

                        LIVE_FOREVER    - don't timeout (but can be discarded)

                        LIVE_DEFAULT    - use the default value

                        anything else   - number of seconds to live

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "CacheHostent",
                 "%q, %#x, %d",
                 lpszHostName,
                 Hostent,
                 TimeToLive
                 ));

    if (!DnsCachingEnabled || !LockSerializedList(pResolverCache))
    {
        DEBUG_PRINT(SOCKETS,
                    WARNING,
                    ("DNS caching disabled or unable to serialize access\n"
                    ));

        goto quit;
    }

    //
    // check that the entry is not already in the cache - 2 or more threads may
    // have been simultaneously resolving the same name
    //

    LPHOSTENT lpHostent;
    DWORD ttl;

    INET_ASSERT(lpszHostName != NULL);

    if (!QueryHostentCache(pResolverCache, lpszHostName, NULL, &lpHostent, &ttl)) {

        LPRESOLVER_CACHE_ENTRY cacheEntry;

        //
        // remove as many entries as we can beginning at the tail of the list.
        // We try to remove enough to get the cache size back below the limit.
        // This may consist of removing expired entries or entries marked as
        // DELETE. If there are expired, in-use entries then we mark them as
        // DELETE. This may result in the cache list growing until those threads
        // which have referenced cache entries release them
        //

        cacheEntry = (LPRESOLVER_CACHE_ENTRY)TailOfSerializedList(pResolverCache);

        while ((pResolverCache->ElementCount >= MaximumDnsCacheEntries)
        && (cacheEntry != (LPRESOLVER_CACHE_ENTRY)SlSelf(pResolverCache))) {

            //
            // cache has maximum entries: throw out the Least Recently Used (its
            // the one at the back of the queue, ma'am) but only if no-one else
            // is currently accessing it
            //

            if ((cacheEntry->State != ENTRY_IN_USE)
            && (cacheEntry->ReferenceCount == 0)) {

                INET_ASSERT((cacheEntry->State == ENTRY_UNUSED)
                            || (cacheEntry->State == ENTRY_DELETE));

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("throwing out LRU %q\n",
                            cacheEntry->Hostent.h_name
                            ));

                LPRESOLVER_CACHE_ENTRY nextEntry;

                nextEntry = (LPRESOLVER_CACHE_ENTRY)cacheEntry->ListEntry.Flink;
                RemoveCacheEntry(pResolverCache, cacheEntry);
                cacheEntry = nextEntry;
            } else if (cacheEntry->State == ENTRY_IN_USE) {

                //
                // this entry needs to be freed when it is released
                //

                cacheEntry->State = ENTRY_DELETE;
            }
            cacheEntry = (LPRESOLVER_CACHE_ENTRY)cacheEntry->ListEntry.Blink;
        }

        //
        // add the entry at the head of the queue - it is the Most Recently Used
        // after all. If we fail to allocate memory, its no problem: it'll just
        // take a little longer if this entry would have been hit before we needed
        // to throw out another entry
        //

        if (cacheEntry = CreateCacheEntry(lpszHostName, Hostent, TimeToLive, pAlloc, dwAllocSize)) {

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("caching %q, expiry = %s\n",
                        CacheHostentStr(&cacheEntry->Hostent),
                        CacheTimestr(cacheEntry->ExpirationTime)
                        ));

            if (!InsertAtHeadOfSerializedList(pResolverCache, &cacheEntry->ListEntry))
            {
                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("Unable to cache new entry due to not enough memory\n"
                            ));
            }
        }
    } else {

        //
        // this entry is already in the cache. 2 or more threads must have been
        // resolving the same name simultaneously. We just bump the expiration
        // time to the more recent value
        //

        DEBUG_PRINT(SOCKETS,
                    WARNING,
                    ("found %q already in the cache!?\n",
                    Hostent->h_name
                    ));

        ReleaseHostentCacheEntry(pResolverCache, lpHostent);

    }

    UnlockSerializedList(pResolverCache);

quit:

    DEBUG_LEAVE(0);
}


VOID
FlushHostentCache(
    SERIALIZED_LIST* pResolverCache
    )

/*++

Routine Description:

    Removes all entries in DNS hostent cache

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "FlushHostentCache",
                 NULL
                 ));

    LPRESOLVER_CACHE_ENTRY cacheEntry;
    LPRESOLVER_CACHE_ENTRY previousEntry;

    if (LockSerializedList(pResolverCache))
    {
        previousEntry = (LPRESOLVER_CACHE_ENTRY)SlSelf(pResolverCache);
        cacheEntry = (LPRESOLVER_CACHE_ENTRY)HeadOfSerializedList(pResolverCache);
        while (cacheEntry != (LPRESOLVER_CACHE_ENTRY)SlSelf(pResolverCache)) {
            if (cacheEntry->State == ENTRY_UNUSED) {
                RemoveCacheEntry(pResolverCache, cacheEntry);
            } else {

                DEBUG_PRINT(SOCKETS,
                            WARNING,
                            ("cache entry %#x (%q) still in-use\n",
                            cacheEntry->HostName
                            ));

                cacheEntry->State = ENTRY_DELETE;
                previousEntry = cacheEntry;
            }
            cacheEntry = (LPRESOLVER_CACHE_ENTRY)previousEntry->ListEntry.Flink;
        }

        UnlockSerializedList(pResolverCache);
    }

    DEBUG_LEAVE(0);
}


VOID
ReleaseHostentCacheEntry(
    SERIALIZED_LIST* pResolverCache,
    IN LPHOSTENT lpHostent
    )

/*++

Routine Description:

    Either mark a hostent unused or if it is stale, delete it

Arguments:

    lpHostent   - pointer to hostent to free

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "ReleaseHostentCacheEntry",
                 "%#x",
                 lpHostent
                 ));

    LPRESOLVER_CACHE_ENTRY cacheEntry = CONTAINING_RECORD(lpHostent,
                                                          RESOLVER_CACHE_ENTRY,
                                                          Hostent
                                                          );

    if (LockSerializedList(pResolverCache))
    {

        //
        // reference count should never go below zero!
        //

        INET_ASSERT(cacheEntry->ReferenceCount > 0);

        if (--cacheEntry->ReferenceCount <= 0) {

            //
            // last releaser gets to decide what to do - mark unused or delete
            //

            if (cacheEntry->State == ENTRY_IN_USE) {
                cacheEntry->State = ENTRY_UNUSED;
            } else if (cacheEntry->State == ENTRY_DELETE) {

                //
                // entry is already stale - throw it out
                //

                RemoveCacheEntry(pResolverCache, cacheEntry);
            } else {

                //
                // unused? or bogus value? Someone changed state while refcount
                // not zero?
                //

                INET_ASSERT((cacheEntry->State == ENTRY_IN_USE)
                            || (cacheEntry->State == ENTRY_DELETE));

            }
        }

        UnlockSerializedList(pResolverCache);
    }

    DEBUG_LEAVE(0);
}


VOID
ThrowOutHostentCacheEntry(
    SERIALIZED_LIST* pResolverCache,
    IN LPHOSTENT lpHostent
    )

/*++

Routine Description:

    Removes this entry from the DNS cache, based on the host name. We assume
    that the entry came from the cache, so unless it has been already purged,
    we should be able to throw it out

Arguments:

    lpHostent   - pointer to host entry containing details (name) of entry to
                  throw out

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "ThrowOutHostentCacheEntry",
                 "%#x [%q]",
                 lpHostent,
                 lpHostent->h_name
                 ));

    if (DnsCachingEnabled && LockSerializedList(pResolverCache)) {

        LPRESOLVER_CACHE_ENTRY cacheEntry;

        cacheEntry = (LPRESOLVER_CACHE_ENTRY)HeadOfSerializedList(pResolverCache);
        while (cacheEntry != (LPRESOLVER_CACHE_ENTRY)SlSelf(pResolverCache)) {
            if (HostentMatch(&cacheEntry->Hostent, lpHostent->h_name, NULL)) {

                //
                // if the entry is unused then we can delete it, else we have
                // to leave it to the thread with the last reference
                //

                if (cacheEntry->State == ENTRY_UNUSED) {
                    RemoveCacheEntry(pResolverCache, cacheEntry);
                } else {
                    cacheEntry->State = ENTRY_DELETE;
                }
                break;
            }
        }

        UnlockSerializedList(pResolverCache);
    } else {

        DEBUG_PRINT(SOCKETS,
                    WARNING,
                    ("DNS caching disabled or unable to serialize access\n"
                    ));

    }

    DEBUG_LEAVE(0);
}


PRIVATE
VOID
RemoveCacheEntry(
    SERIALIZED_LIST* pResolverCache,
    IN LPRESOLVER_CACHE_ENTRY lpCacheEntry
    )

/*++

Routine Description:

    Takes a cache entry off the list and frees it

    N.B.: This function must be called with the resolver cache serialized list
    already locked

Arguments:

    lpCacheEntry    - currently queued entry to remove

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "RemoveCacheEntry",
                 "%#x",
                 lpCacheEntry
                 ));

    if (RemoveFromSerializedList(pResolverCache, &lpCacheEntry->ListEntry))
    {

        INET_ASSERT(lpCacheEntry->ReferenceCount == 0);
        INET_ASSERT((lpCacheEntry->State == ENTRY_UNUSED)
                    || (lpCacheEntry->State == ENTRY_DELETE));

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("throwing out %q, expiry = %s\n",
                    CacheHostentStr(&lpCacheEntry->Hostent),
                    CacheTimestr(lpCacheEntry->ExpirationTime)
                    ));

        lpCacheEntry = (LPRESOLVER_CACHE_ENTRY)FREE_MEMORY((HLOCAL)lpCacheEntry);

        INET_ASSERT(lpCacheEntry == NULL);

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("CurrentDnsCacheEntries = %d\n",
                    pResolverCache->ElementCount
                    ));

        INET_ASSERT((pResolverCache->ElementCount >= 0)
                    && (pResolverCache->ElementCount <= MaximumDnsCacheEntries));
    }
    else
    {
        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("unable to throw out %q due to insufficient resources, expiry = %s\n",
                    CacheHostentStr(&lpCacheEntry->Hostent),
                    CacheTimestr(lpCacheEntry->ExpirationTime)
                    ));
    }

    DEBUG_LEAVE(0);
}


PRIVATE
BOOL
ResolverCacheHit(
    IN LPRESOLVER_CACHE_ENTRY lpCacheEntry,
    IN LPSTR Name OPTIONAL,
    IN LPBYTE Address OPTIONAL
    )

/*++

Routine Description:

    Checks this RESOLVER_CACHE_ENTRY for a match with Name or Address. If Name,
    can match with name or alias(es) in hostent, or with originally resolved
    name

Arguments:

    lpCacheEntry    - pointer to RESOLVER_CACHE_ENTRY to check

    Name            - optional name to check

    Address         - optional server address to check

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "ResolverCacheHit",
                 "%#x, %q, %s",
                 lpCacheEntry,
                 Name,
                 CacheMapIpAddress(Address)
                 ));

    BOOL found;

    if ((Name != NULL)
    && (lpCacheEntry->HostName != NULL)
    && (lstrcmpi(lpCacheEntry->HostName, Name) == 0)) {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("matched name %q\n",
                    lpCacheEntry->HostName
                    ));

        found = TRUE;
    } else {
        found = FALSE;
    }
    if (!found) {
        found = HostentMatch(&lpCacheEntry->Hostent, Name, Address);
    }

    DEBUG_LEAVE(found);

    return found;
}


PRIVATE
BOOL
HostentMatch(
    IN LPHOSTENT Hostent,
    IN LPSTR Name OPTIONAL,
    IN LPBYTE Address OPTIONAL
    )

/*++

Routine Description:

    Compares a hostent structure for a match with a host name or address

Arguments:

    Hostent - pointer to hostent to compare

    Name    - pointer to name string

    Address - pointer to IP address in network byte order

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "HostentMatch",
                 "%#x, %q, %s",
                 Hostent,
                 Name,
                 CacheMapIpAddress(Address)
                 ));

    BOOL found;

    if (Name) {
        found = CompareHostentNames(Hostent, Name);
    } else {

        LPBYTE* addressList = (LPBYTE*)Hostent->h_addr_list;
        LPBYTE address;

        found = FALSE;

        while (address = *addressList++) {
            if (*(LPDWORD)address == *(LPDWORD)Address) {

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("matched %s\n",
                            CacheMapIpAddress(address)
                            ));

                found = TRUE;
                break;
            }
        }
    }

    if (found) {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("hostent = %q\n",
                    CacheHostentStr(Hostent)
                    ));

    }

    DEBUG_LEAVE(found);

    return found;
}


PRIVATE
LPRESOLVER_CACHE_ENTRY
CreateCacheEntry(
    IN LPSTR lpszHostName,
    IN LPHOSTENT Hostent,
    IN DWORD TimeToLive,
    IN VOID** pAlloc,
    IN DWORD dwAllocSize
    )

/*++

Routine Description:

    Allocates a RESOLVER_CACHE_ENTRY and packs it with the hostent information
    and sets the ExpirationTime

Arguments:

    lpszHostName    - name we resolved

    Hostent         - pointer to hostent to add

    TimeToLive      - amount of time before this hostent expires

Return Value:

    LPRESOLVER_CACHE_ENTRY

--*/

{
    LPRESOLVER_CACHE_ENTRY cacheEntry;
    UINT hostentSize;

    //
    // BytesInHostent gives us the size of the fixed and variable parts of the
    // hostent structure
    //

    hostentSize = (UINT)BytesInHostent(Hostent);

    INET_ASSERT(lpszHostName != NULL);

    //
    // only copy lpszHostName if it is different to the names in the hostent
    //

    UINT hostNameSize;

    if (!CompareHostentNames(Hostent, lpszHostName)) {
        hostNameSize = lstrlen(lpszHostName) + 1;
    } else {
        hostNameSize = 0;
    }

    //
    // allocate space for the cache entry (take off the size of the fixed part
    // of the hostent - BytesInHostent already accounted for it)
    //

    DWORD dwSize = sizeof(RESOLVER_CACHE_ENTRY)
                 - sizeof(HOSTENT)
                 + hostentSize
                 + hostNameSize;

    if (dwSize <= dwAllocSize)
    {
        cacheEntry = (LPRESOLVER_CACHE_ENTRY)(*pAlloc);
        *pAlloc = NULL;
    }
    else
    {
        cacheEntry = (LPRESOLVER_CACHE_ENTRY)ALLOCATE_MEMORY(LMEM_FIXED,
                                                             dwSize
                                                             );
    }
    
    if (cacheEntry != NULL) {
        CopyHostentToBuffer((PCHAR)&cacheEntry->Hostent, hostentSize, Hostent);

        //
        // copy the host name to the end of the buffer if required
        //

        if (hostNameSize != 0) {
            cacheEntry->HostName = (LPSTR)&cacheEntry->Hostent + hostentSize;
            RtlCopyMemory(cacheEntry->HostName, lpszHostName, hostNameSize);
        } else {
            cacheEntry->HostName = NULL;
        }

        //
        // calculate the expiration time as the current time (in seconds since
        // 1/1/70) + number of seconds to live OR indefinite if TimeToLive is
        // specified as LIVE_FOREVER, which is what we use if the host
        // information didn't originate from DNS
        //

        cacheEntry->ExpirationTime = (DWORD)((TimeToLive == LIVE_FOREVER)
                                        ? LIVE_FOREVER
                                        : time(NULL)
                                            + ((TimeToLive == LIVE_DEFAULT)
                                                ? DnsCacheTimeout
                                                : TimeToLive));

        //
        // the entry state is initially unused
        //

        cacheEntry->State = ENTRY_UNUSED;

        //
        // and reference is zero
        //

        cacheEntry->ReferenceCount = 0;
    }

    return cacheEntry;
}


PRIVATE
BOOL
CompareHostentNames(
    IN LPHOSTENT Hostent,
    IN LPSTR Name
    )

/*++

Routine Description:

    Compares a prospective host name against all names in a hostent

Arguments:

    Hostent - pointer to hostent containing names to compare

    Name    - prospective host name

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CompareHostentNames",
                 "%#x, %q",
                 Hostent,
                 Name
                 ));

    BOOL found;

    if (!lstrcmpi(Hostent->h_name, Name)) {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("matched name %q\n",
                    Hostent->h_name
                    ));

        found = TRUE;
        goto done;
    }

    LPSTR alias;
    LPSTR* aliasList;

    aliasList = Hostent->h_aliases;
    while (alias = *aliasList++) {
        if (!lstrcmpi(alias, Name)) {

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("matched alias %q\n",
                        alias
                        ));

            found = TRUE;
            goto done;
        }
    }

    DEBUG_PRINT(SOCKETS,
                WARNING,
                ("%q not matched\n",
                Name
                ));

    found = FALSE;

done:

    DEBUG_LEAVE(found);

    return found;
}


PRIVATE
DWORD
BytesInHostent(
    IN LPHOSTENT Hostent
    )
{
    DWORD total;
    int i;

    total = sizeof(HOSTENT);
    total += lstrlen(Hostent->h_name) + 1;

    //
    // Account for the NULL terminator pointers at the end of the
    // alias and address arrays.
    //

    total += sizeof(char *) + sizeof(char *);

    for (i = 0; Hostent->h_aliases[i] != NULL; i++) {
        total += lstrlen(Hostent->h_aliases[i]) + 1 + sizeof(char *);
    }

    for (i = 0; Hostent->h_addr_list[i] != NULL; i++) {
        total += Hostent->h_length + sizeof(char *);
    }

    //
    // Pad the answer to an eight-byte boundary.
    //

    return (total + 7) & ~7;
}


PRIVATE
DWORD
CopyHostentToBuffer (
    OUT PCHAR Buffer,
    IN UINT BufferLength,
    IN LPHOSTENT Hostent
    )
{
    UINT requiredBufferLength;
    UINT bytesFilled;
    PCHAR currentLocation = Buffer;
    UINT aliasCount;
    UINT addressCount;
    UINT i;
    PHOSTENT outputHostent = (PHOSTENT)Buffer;

    //
    // Determine how many bytes are needed to fully copy the structure.
    //

    requiredBufferLength = (UINT)BytesInHostent(Hostent);

    //
    // Zero the user buffer.
    //

    if ( (DWORD)BufferLength > requiredBufferLength ) {
        RtlZeroMemory( Buffer, requiredBufferLength );
    } else {
        RtlZeroMemory( Buffer, BufferLength );
    }

    //
    // Copy over the hostent structure if it fits.
    //

    bytesFilled = sizeof(*Hostent);

    if ( bytesFilled > (DWORD)BufferLength ) {
        return requiredBufferLength;
    }

    RtlCopyMemory( currentLocation, Hostent, sizeof(*Hostent) );
    currentLocation = Buffer + bytesFilled;

    outputHostent->h_name = NULL;
    outputHostent->h_aliases = NULL;
    outputHostent->h_addr_list = NULL;

    //
    // Count the host's aliases and set up an array to hold pointers to
    // them.
    //

    for ( aliasCount = 0;
          Hostent->h_aliases[aliasCount] != NULL;
          aliasCount++ );

    bytesFilled += (aliasCount+1) * sizeof(char FAR *);

    if ( bytesFilled > (DWORD)BufferLength ) {
        Hostent->h_aliases = NULL;
        return requiredBufferLength;
    }

    outputHostent->h_aliases = (char FAR * FAR *)currentLocation;
    currentLocation = Buffer + bytesFilled;

    //
    // Count the host's addresses and set up an array to hold pointers to
    // them.
    //

    for ( addressCount = 0;
          Hostent->h_addr_list[addressCount] != NULL;
          addressCount++ );

    bytesFilled += (addressCount+1) * sizeof(void FAR *);

    if ( bytesFilled > (DWORD)BufferLength ) {
        Hostent->h_addr_list = NULL;
        return requiredBufferLength;
    }

    outputHostent->h_addr_list = (char FAR * FAR *)currentLocation;
    currentLocation = Buffer + bytesFilled;

    //
    // Start filling in addresses.  Do addresses before filling in the
    // host name and aliases in order to avoid alignment problems.
    //

    for ( i = 0; i < addressCount; i++ ) {

        bytesFilled += Hostent->h_length;

        if ( bytesFilled > (DWORD)BufferLength ) {
            outputHostent->h_addr_list[i] = NULL;
            return requiredBufferLength;
        }

        outputHostent->h_addr_list[i] = currentLocation;

        RtlCopyMemory(
            currentLocation,
            Hostent->h_addr_list[i],
            Hostent->h_length
            );

        currentLocation = Buffer + bytesFilled;
    }

    outputHostent->h_addr_list[i] = NULL;

    //
    // Copy the host name if it fits.
    //

    bytesFilled += lstrlen(Hostent->h_name) + 1;

    if ( bytesFilled > (DWORD)BufferLength ) {
        return requiredBufferLength;
    }

    outputHostent->h_name = currentLocation;

    RtlCopyMemory(currentLocation, Hostent->h_name, lstrlen(Hostent->h_name) + 1);
    currentLocation = Buffer + bytesFilled;

    //
    // Start filling in aliases.
    //

    for ( i = 0; i < aliasCount; i++ ) {

        bytesFilled += lstrlen(Hostent->h_aliases[i]) + 1;

        if ( bytesFilled > (DWORD)BufferLength ) {
            outputHostent->h_aliases[i] = NULL;
            return requiredBufferLength;
        }

        outputHostent->h_aliases[i] = currentLocation;

        RtlCopyMemory(
            currentLocation,
            Hostent->h_aliases[i],
            lstrlen(Hostent->h_aliases[i]) + 1
            );

        currentLocation = Buffer + bytesFilled;
    }

    outputHostent->h_aliases[i] = NULL;

    return requiredBufferLength;
}

#if INET_DEBUG

//
// CAVEAT - can only call these functions once per printf() etc. because of
//          static buffers (but still thread-safe)
//

PRIVATE
DEBUG_FUNCTION
LPSTR
CacheTimestr(IN DWORD Time) {

    //
    // previous code - writes formatted human-sensible date/time to buffer
    //

    //LPSTR p;
    //
    ////
    //// remove the LF from the time string returned by ctime()
    ////
    //
    //p = ctime((const time_t *)&Time);
    //p[strlen(p) - 1] = '\0';
    //return p;

    //
    // abbreviated CRT version - just write # seconds since 1970 to buffer
    //

    static char buf[16];

    wsprintf(buf, "%d", Time);
    return (LPSTR)buf;
}

PRIVATE
DEBUG_FUNCTION
LPSTR
CacheHostentStr(IN LPHOSTENT Hostent) {

    static char buf[1024];
    LPSTR p;

    p = buf;
    p += wsprintf(p, "n=%s", Hostent->h_name);

    for (LPSTR * aliases = (LPSTR *)Hostent->h_aliases; *aliases; ++aliases) {
        p += wsprintf(p, ", a=%s", *aliases);
    }

    for (LPBYTE * addrs = (LPBYTE *)Hostent->h_addr_list; *addrs; ++addrs) {
        p += wsprintf(p,
                      ", i=%s",
                      CacheMapIpAddress(*addrs)
                      );
    }

    return (LPSTR)buf;
}

PRIVATE
DEBUG_FUNCTION
LPSTR
CacheMapIpAddress(IN LPBYTE Address) {

    if (!Address) {
        return "";
    }

    static char buf[16];

    wsprintf(buf,
             "%d.%d.%d.%d",
             Address[0] & 0xff,
             Address[1] & 0xff,
             Address[2] & 0xff,
             Address[3] & 0xff
             );

    return (LPSTR)buf;
}

#endif

#if defined(RNR_SUPPORTED)

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rescache.c

Abstract:

    Contains name resolution cache

    Contents:

Author:

    Shishir Pardikar    2-14-96

Environment:

    Win32 user mode

Revision History:

        2-14-96 shishirp
        Created

--*/

//
//BUGBUG: This include should be removed, duplicate of above
//
#ifndef SPX_SUPPORT
#include <wininetp.h>
#endif


//
// private manifests
//

#define NAMERES_CACHE_USED            0x00000001
#define NAMERES_CACHE_USES_GUID       0x00000002

#define ENTERCRIT_NAMERESCACHE()  (vcritNameresCache.Lock())
#define LEAVECRIT_NAMERESCACHE()  (vcritNameresCache.Unlock())
#define IS_EMPTY(indx)            ((vlpNameresCache[(indx)].dwFlags & NAMERES_CACHE_USED) == 0)
#define USES_GUID(indx)           ((vlpNameresCache[(indx)].dwFlags & NAMERES_CACHE_USES_GUID))

// number of cache entries
#define DEFAULT_NAMERES_CACHE_ENTRIES   10

// expiry time for an addresslist
#define DEFAULT_EXPIRY_DELTA            (24 * 60 * 60 * (LONGLONG)10000000)


//
//  structure definition
//

typedef struct tagNAMERES_CACHE {
    DWORD               dwFlags;       // general flags to be used as needed
    DWORD               dwNameSpace;   // namespace ??
    GUID                sGuid;         // GUID describing service type
    LPSTR               lpszName;      // ptr to name that needs resolution
    FILETIME            ftLastUsedTime;    // last accesstime, mainly for purging
    FILETIME            ftCreationTime;// When it was created
    ADDRESS_INFO_LIST   sAddrList;     // List of address (defined in ixport.h)
} NAMERES_CACHE, far *LPNAMERES_CACHE;





//
// private variables for name resolution cache
//


// Name cache size allocated in init
LPNAMERES_CACHE vlpNameresCache = NULL;

// Number of elements allowed in the nameres cache
int vcntNameresCacheEntries = DEFAULT_NAMERES_CACHE_ENTRIES;


// time in 100ns after which an address is expired
LONGLONG vftExpiryDelta = DEFAULT_EXPIRY_DELTA;

BOOL vfNameresCacheInited = FALSE;

// serialization
CCritSec vcritNameresCache;

//
// private function prototypes
//


PRIVATE
DWORD
CreateNameresCacheEntry(
    int     indx,
    DWORD   dwNameSpace,
    LPGUID  lpGuid,
    LPSTR   lpszName,
    INT     cntAddresses,
    LPCSADDR_INFO  lpCsaddrInfo
);


PRIVATE
DWORD
DeleteNameresCacheEntry(
    int indx
);


PRIVATE
int
FindNameresCacheEntry(
    DWORD   dwNameSpace,
    LPGUID  lpGuid,
    LPSTR   lpszName
);


PRIVATE
int
FindNameresCacheEntryByAddr(
    int cntAddr,
    LPCSADDR_INFO lpCsaddrInfo
);

PRIVATE
int
PurgeEntries(
    BOOL    fForce  // purge atleast one entry
);


PRIVATE
DWORD
CopyCsaddr(
    LPCSADDR_INFO   lpSrc,
    int             cntAddr,
    LPCSADDR_INFO   *lplpDst
);

//
// functions
//


DWORD
InitNameresCache(
    VOID
)
/*++

Routine Description:

    Init name resolution cache. This routine a) allocates a table of
    name cache entries b)

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.

--*/
{


    if (vfNameresCacheInited)
    {
        return (ERROR_SUCCESS);
    }

    // first try to alloc the memory, if it fails just quit
    vlpNameresCache = (LPNAMERES_CACHE)ALLOCATE_MEMORY(
                        LPTR,
                        vcntNameresCacheEntries * sizeof(NAMERES_CACHE)
                        );

    if (!vlpNameresCache)
    {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    if (!vcritNameresCache.Init() || !ENTERCRIT_NAMERESCACHE())
    {
        FREE_MEMORY(vlpNameresCache);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    vfNameresCacheInited = TRUE;

    LEAVECRIT_NAMERESCACHE();

    return (ERROR_SUCCESS);

}


DWORD
AddNameresCacheEntry(
    DWORD    dwNameSpace,
    LPGUID   lpGuid,
    LPSTR    lpName,
    int      cntAddresses,
    LPCSADDR_INFO  lpCsaddrInfo
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int indx;
    DWORD dwError = ERROR_SUCCESS;

    if (!vfNameresCacheInited) {
        return (ERROR_INVALID_PARAMETER);
    }

    if (!ENTERCRIT_NAMERESCACHE())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    indx = FindNameresCacheEntry(dwNameSpace, lpGuid, lpName);

    // if indx is valid, delete the entry, do some purging too
    if (indx != -1) {
        DeleteNameresCacheEntry(indx);
        PurgeEntries(FALSE);
    }
    else {
        // create atleast one hole
        indx = PurgeEntries(TRUE);
    }

    INET_ASSERT((indx >=0 && (indx < vcntNameresCacheEntries)));

    dwError = CreateNameresCacheEntry(indx,
                            dwNameSpace,
                            lpGuid,
                            lpName,
                            cntAddresses,
                            lpCsaddrInfo);

    LEAVECRIT_NAMERESCACHE();

    return (dwError);
}




DWORD
RemoveNameresCacheEntry(
    DWORD    dwNameSpace,
    LPGUID   lpGuid,
    LPSTR    lpszName
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int indx;
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (vfNameresCacheInited) {

        if (!ENTERCRIT_NAMERESCACHE())
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }

        indx = FindNameresCacheEntry(dwNameSpace, lpGuid, lpszName);

        if (indx != -1) {

            DeleteNameresCacheEntry(indx);

            dwError = ERROR_SUCCESS;
        }
        else {
            dwError = ERROR_FILE_NOT_FOUND; //yuk
        }

        LEAVECRIT_NAMERESCACHE();
    }
quit:
    return (dwError);
}


#ifdef MAYBE

DWORD
RemoveNameresCacheEntryByAddr(
    int cntAddresses,
    LPCSADDR_INFO lpCsaddrInfo
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int indx;
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (vfNameresCacheInited) {
        if (!ENTERCRIT_NAMERESCACHE())
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }


        indx = FindNameresCacheEntryByAddr(cntAddresses, lpCsaddrInfo);

        if (indx != -1) {

            DeleteNameresCacheEntry(indx);

            dwError = ERROR_SUCCESS;
        }
        else {
            dwError = ERROR_FILE_NOT_FOUND;
        }

        LEAVECRIT_NAMERESCACHE();
    }
quit:
    return (dwError);

}
#endif //MAYBE

DWORD
GetNameresCacheEntry(
    DWORD    dwNameSpace,
    LPGUID   lpGuid,
    LPSTR    lpName,
    INT      *lpcntAddresses,
    LPCSADDR_INFO  *lplpCsaddrInfo
)
/*++

Routine Description:

    This routine looks up the cache and returns the list of addresses
    corresponding to lpGuid/lpName.

Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int indx;
    DWORD   dwError = ERROR_FILE_NOT_FOUND; // poor error

    if (!vfNameresCacheInited) {
        return (ERROR_INVALID_PARAMETER);
    }

    if (!ENTERCRIT_NAMERESCACHE())
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    // is this entry already cached?
    indx = FindNameresCacheEntry(dwNameSpace, lpGuid, lpName);


    if (indx != -1) {
        // yes, let use give back the info

        *lpcntAddresses = vlpNameresCache[indx].sAddrList.AddressCount;

        if ((dwError = CopyCsaddr(vlpNameresCache[indx].sAddrList.Addresses, *lpcntAddresses, lplpCsaddrInfo))
            != ERROR_SUCCESS) {

            goto bailout;
        }
        // update the last used time, we will use this to
        // age out the entries

        GetCurrentGmtTime(&(vlpNameresCache[indx].ftLastUsedTime));
        dwError = ERROR_SUCCESS;
    }

bailout:

    LEAVECRIT_NAMERESCACHE();

quit:
    return (dwError);
}


DWORD
DeinitNameresCache(
    VOID
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int i;

    if (vfNameresCacheInited) {
        if (!ENTERCRIT_NAMERESCACHE())
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        for (i = 0; i < vcntNameresCacheEntries; ++i) {
            if (!IS_EMPTY(i)) {
                DeleteNameresCacheEntry(i);
            }
        }

        FREE_MEMORY(vlpNameresCache);

        vlpNameresCache = NULL;

        vfNameresCacheInited = FALSE;

        LEAVECRIT_NAMERESCACHE();
        vcritNameresCache.FreeLock();
    }
    return (ERROR_SUCCESS);
}


PRIVATE
DWORD
CreateNameresCacheEntry(
    int     indx,
    DWORD   dwNameSpace,
    LPGUID  lpGuid,
    LPSTR   lpszName,
    int     cntAddresses,
    LPCSADDR_INFO  lpCsaddrInfo
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    DWORD dwError = ERROR_NOT_ENOUGH_MEMORY;

    INET_ASSERT((indx >=0 && (indx < vcntNameresCacheEntries)));

    INET_ASSERT(IS_EMPTY(indx));


    memset(&vlpNameresCache[indx], 0, sizeof(vlpNameresCache[indx]));

    // we could get a name or a guid
    // do it for name first before doing it for GUID

    // BUGBUG in future we should consider name+GUID+port
    if (lpszName) {
       vlpNameresCache[indx].lpszName = (LPSTR)ALLOCATE_MEMORY(LPTR, lstrlen(lpszName)+1);
       if (!vlpNameresCache[indx].lpszName) {
           goto bailout;
       }
       strcpy(vlpNameresCache[indx].lpszName, lpszName);
    }
    else if (lpGuid) {
        INET_ASSERT(FALSE); // rigth now. In future this should go away
        memcpy(&(vlpNameresCache[indx].sGuid), lpGuid, sizeof(GUID));
        vlpNameresCache[indx].dwFlags |= NAMERES_CACHE_USES_GUID;
    }
    else {
        dwError = ERROR_INVALID_PARAMETER;
        goto bailout;
    }

    INET_ASSERT(cntAddresses > 0);

    if (CopyCsaddr(lpCsaddrInfo, cntAddresses, &(vlpNameresCache[indx].sAddrList.Addresses))
        != ERROR_SUCCESS) {
        goto bailout;
    }

    vlpNameresCache[indx].sAddrList.AddressCount = cntAddresses;

    // mark this as being non-empty
    vlpNameresCache[indx].dwFlags |= NAMERES_CACHE_USED;

    // set the creation and last-used times as now

    GetCurrentGmtTime(&(vlpNameresCache[indx].ftCreationTime));
    vlpNameresCache[indx].ftLastUsedTime = vlpNameresCache[indx].ftCreationTime ;

    dwError = ERROR_SUCCESS;

bailout:

    if (dwError != ERROR_SUCCESS) {
        if (vlpNameresCache[indx].sAddrList.Addresses) {
            FREE_MEMORY(vlpNameresCache[indx].sAddrList.Addresses);
            vlpNameresCache[indx].sAddrList.Addresses = NULL;
        }
        if (vlpNameresCache[indx].lpszName) {
            FREE_MEMORY(vlpNameresCache[indx].lpszName);
            vlpNameresCache[indx].lpszName = NULL;
        }
        memset(&vlpNameresCache[indx], 0, sizeof(vlpNameresCache[indx]));
    }

    return (dwError);
}


PRIVATE
DWORD
DeleteNameresCacheEntry(
    int indx
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    INET_ASSERT((indx >=0) && (indx < vcntNameresCacheEntries));

    if (vlpNameresCache[indx].lpszName) {
        FREE_MEMORY(vlpNameresCache[indx].lpszName);
    }

    INET_ASSERT(vlpNameresCache[indx].sAddrList.Addresses);

    FREE_MEMORY(vlpNameresCache[indx].sAddrList.Addresses);

    memset(&vlpNameresCache[indx], 0, sizeof(NAMERES_CACHE));

    return (ERROR_SUCCESS);
}

#ifdef MAYBE

PRIVATE
int
FindNameresCacheEntryByAddr(
    int cntAddr,
    LPCSADDR_INFO lpCsaddrInfo
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int i;

    for (i = 0; i < vcntNameresCacheEntries; ++i) {
        if (!IS_EMPTY(i) && // not empty
            (vlpNameresCache[i].sAddrList.AddressCount == cntAddr) && // count is the same
            (!memcmp(vlpNameresCache[i].sAddrList.Addresses,    // list matches
                     lpCsaddrInfo,
                     cntAddr * sizeof(CSADDR_INFO)))) {
            return (i);
        }
    }
    return (-1);
}
#endif //MAYBE


PRIVATE
int
FindNameresCacheEntry(
    DWORD   dwNameSpace,
    LPGUID  lpGuid,
    LPSTR   lpszName
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int i;

    for (i = 0; i < vcntNameresCacheEntries; ++i) {
        if (!IS_EMPTY(i)) {
            if (vlpNameresCache[i].dwNameSpace == dwNameSpace) {
                if (!USES_GUID(i)) {

                    INET_ASSERT(vlpNameresCache[i].lpszName);

                    if (lpszName &&
                        !lstrcmpi(lpszName, vlpNameresCache[i].lpszName)) {
                        return (i);
                    }
                }
                else{

                    if (lpGuid && !memcmp(lpGuid, &vlpNameresCache[i].sGuid, sizeof(GUID))) {
                        return (i);
                    }
                }
            }
        }
    }
    return (-1);
}


PRIVATE
int
PurgeEntries(
    BOOL    fForce  // purge atleast one entry
)
/*++

Routine Description:


Arguments:


Return Value:

    index of a free entry

--*/
{
    int i, indxlru = -1, indxHole=-1;
    FILETIME ft;
    BOOL fFoundHole = FALSE;

    GetCurrentGmtTime(&ft);

    for (i = 0; i < vcntNameresCacheEntries; ++i) {
        if (!IS_EMPTY(i)) {

            // purge stale entries
            if ( (FT2LL(ft) - FT2LL(vlpNameresCache[i].ftCreationTime))
                    > FT2LL(vftExpiryDelta)) {
                DeleteNameresCacheEntry(i);
                indxHole = i;
            }
            else if (FT2LL(vlpNameresCache[i].ftLastUsedTime) <= FT2LL(ft)) {
                ft = vlpNameresCache[i].ftLastUsedTime;
                indxlru = i; // LRU entry if we need to purge it
            }
        }
        else {
            indxHole = i;
        }
    }

    // if there is no hole, purge the LRU entry if forced
    if (indxHole == -1) {

        INET_ASSERT(indxlru != -1);

        if (fForce) {
            DeleteNameresCacheEntry(indxlru);
            indxHole = indxlru;
        }
    }
    return (indxHole);
}

PRIVATE
DWORD
CopyCsaddr(
    LPCSADDR_INFO   lpSrc,
    int             cntAddr,
    LPCSADDR_INFO   *lplpDst
)
{
    int i;
    LPCSADDR_INFO lpDst;
    UINT uSize;


    // BUGBUG assumes the way Compressaddress (ixport.cxx) allocates memory
    uSize = LocalSize(lpSrc);
    if (!uSize) {
        return (GetLastError());
    }

    *lplpDst = (LPCSADDR_INFO)ALLOCATE_MEMORY(LPTR, uSize);

    if (!*lplpDst) {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    lpDst = *lplpDst;


    memcpy(lpDst, lpSrc, uSize);

    // now start doing fixups
    for (i=0; i<cntAddr; ++i) {
        lpDst[i].LocalAddr.lpSockaddr = (LPSOCKADDR)((LPBYTE)lpDst+((DWORD)(lpSrc[i].LocalAddr.lpSockaddr) - (DWORD)lpSrc));
        lpDst[i].RemoteAddr.lpSockaddr = (LPSOCKADDR)((LPBYTE)lpDst+((DWORD)(lpSrc[i].RemoteAddr.lpSockaddr) - (DWORD)lpSrc));
    }
    return (ERROR_SUCCESS);
}

#endif // defined(RNR_SUPPORTED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\common\secinit.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    secinit.cxx

Abstract:

    Contains load function for security.dll on NT and secur32.dll on win95
    Also handles WinTrust.dll function loading.

Author:

    Sophia Chung (sophiac)  6-Feb-1996

Environment:

    User Mode - Win32

Revision History:

--*/
#include <wininetp.h>

//
// InitializationLock - protects against multiple threads loading security.dll
// (secur32.dll) and entry points
//

CCritSec InitializationSecLock;

HCRYPTPROV  GlobalFortezzaCryptProv;

//
// GlobalSecFuncTable - Pointer to Global Structure of Pointers that are used
//  for storing the entry points into the SCHANNEL.dll
//

PSecurityFunctionTable GlobalSecFuncTable = NULL;

//
// pWinVerifyTrust - Pointer to Entry Point in WINTRUST.DLL
//

WIN_VERIFY_TRUST_FN pWinVerifyTrust;
WT_HELPER_PROV_DATA_FROM_STATE_DATA_FN pWTHelperProvDataFromStateData;

//
// hSecurity - NULL when security.dll/secur32.dll  is not loaded
//

HINSTANCE hSecurity = NULL;

//
// hWinTrust - NULL when WinTrust DLL is not loaded.
//

HINSTANCE hWinTrust = NULL;

HCERTSTORE g_hMyCertStore = NULL;

BOOL g_bFortezzaInstalled = FALSE;
BOOL g_bCheckedForFortezza = FALSE;

CRYPT_INSTALL_DEFAULT_CONTEXT_FN g_CryptInstallDefaultContext = NULL;
CRYPT_UNINSTALL_DEFAULT_CONTEXT_FN g_CryptUninstallDefaultContext = NULL;
CERT_FIND_CHAIN_IN_STORE_FN g_CertFindChainInStore = NULL;
CERT_FREE_CERTIFICATE_CHAIN_FN g_CertFreeCertificateChain = NULL;


DWORD
LoadWinTrust(
    VOID
    )

/*++

Routine Description:

    This function loads the WinTrust.DLL and binds a pointer to a function
    that is needed in the WinTrust DLL.

Arguments:

    NONE.

Return Value:

    WINDOWS Error Code.

--*/

{
    DWORD error = ERROR_SUCCESS;

    if (!LOCK_SECURITY())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if( hWinTrust == NULL )
    {
        LPSTR lpszDllFileName = WINTRUST_DLLNAME;
        pWinVerifyTrust = NULL;

        //
        // Load the DLL
        //

        hWinTrust       = LoadLibrary(lpszDllFileName);

        if ( hWinTrust )
        {
            pWinVerifyTrust = (WIN_VERIFY_TRUST_FN)
                            GetProcAddress(hWinTrust, WIN_VERIFY_TRUST_NAME);
            pWTHelperProvDataFromStateData = (WT_HELPER_PROV_DATA_FROM_STATE_DATA_FN)
                            GetProcAddress(hWinTrust, WT_HELPER_PROV_DATA_FROM_STATE_DATA_NAME);
        }


        if ( !hWinTrust || !pWinVerifyTrust )
        {
            error = GetLastError();

            if ( error == ERROR_SUCCESS )
            {
                error = ERROR_WINHTTP_INTERNAL_ERROR;
            }
        }
    }

    INET_ASSERT(pWinVerifyTrust);


    if ( error != ERROR_SUCCESS )
    {
        if (hWinTrust)
        {
            FreeLibrary(hWinTrust);
            hWinTrust = NULL;
        }
    }

    UNLOCK_SECURITY();

    return error;
}



BOOL
SecurityInitialize(
    VOID
    )
/*++

Routine Description:

    This function initializes the global lock required for the security
    pkgs.

Arguments:

    NONE.

Return Value:

    WINDOWS Error Code.

--*/
{
    return InitializationSecLock.Init();
}

VOID
SecurityTerminate(
    VOID
    )
/*++

Routine Description:

    This function Deletes the global lock required for the security
    pkgs.

Arguments:

    NONE.

Return Value:

    WINDOWS Error Code.

--*/
{
    InitializationSecLock.FreeLock();
}


VOID
UnloadSecurity(
    VOID
    )

/*++

Routine Description:

    This function terminates the global data required for the security
    pkgs and dynamically unloads security APIs from security.dll (NT)
    or secur32.dll (WIN95).

Arguments:

    NONE.

Return Value:

    WINDOWS Error Code.

--*/

{
    DWORD i;

    if (!LOCK_SECURITY())
    {
        INET_ASSERT(FALSE);
        return;
    }

    //
    //  free all security pkg credential handles
    //

    for (i = 0; SecProviders[i].pszName != NULL; i++) {
         if (SecProviders[i].fEnabled)  {
             if (SecProviders[i].pCertCtxt == NULL && !IsCredClear(SecProviders[i].hCreds)) {
                // Beta1 Hack. Because of some circular dependency between dlls
                // both crypt32 and schannel's PROCESS_DETACH gets called before wininet.
                // This is catastrophic if we have a cert context attached to the credentials
                // handle. In this case we will just leak the handle since the process is dying
                // anyway. We really need to fix this.
                WRAP_REVERT_USER_VOID(g_FreeCredentialsHandle,
                                      (&SecProviders[i].hCreds));
            }
         }
#if 0 // See comments above.
         if (SecProviders[i].pCertCtxt != NULL) {
            CertFreeCertificateContext(SecProviders[i].pCertCtxt);
            SecProviders[i].pCertCtxt = NULL;
        }
#endif

    }

    //
    // close cert store. Protect against fault if DLL already unloaded
    //

    if (g_hMyCertStore != NULL)
    {
        SAFE_WRAP_REVERT_USER_VOID(CertCloseStore,
                                   (g_hMyCertStore, CERT_CLOSE_STORE_FORCE_FLAG));
        g_hMyCertStore = NULL;
    } 

    // IMPORTANT : Don't free GlobalFortezzaCryptProv. When we free the cert context
    // from the SecProviders[] array above it gets freed automatically.
    if (GlobalFortezzaCryptProv != NULL)
    {
        GlobalFortezzaCryptProv = NULL;
    }


    //
    // unload dll
    //

    if (hSecurity != NULL) {
        FreeLibrary(hSecurity);
        hSecurity = NULL;
    }

    UNLOCK_SECURITY();

}


DWORD
LoadSecurity(
    VOID
    )
/*++

Routine Description:

    This function dynamically loads security APIs from security.dll (NT)
    or secur32.dll (WIN95).

Arguments:

    NONE.

Return Value:

    WINDOWS Error Code.
--*/
{
    DWORD Error = ERROR_SUCCESS;
    INITSECURITYINTERFACE pfInitSecurityInterface = NULL;

    if (!LOCK_SECURITY())
        return ERROR_NOT_ENOUGH_MEMORY;

    if (g_hMyCertStore == NULL)
    {

        //
        // CRYPT32.DLL is delayloaded. Need SEH in case it fails.
        //
        // Don't worry about an error, because not supporting
        // client auth shouldn't stop us from scenarios
        // which do not require it as part of the SSL handshake.
        //

        SAFE_WRAP_REVERT_USER(CertOpenSystemStore, (0, "MY"), g_hMyCertStore);

    }
    if (Error == ERROR_SUCCESS)
    {
        Error = LoadWinTrust();
    }
    if ( Error != ERROR_SUCCESS )
    {
        goto quit;
    }

    if( hSecurity != NULL )
    {
        goto quit;
    }

        //
        // load dll.
        //

       //
       // This is better for performance. Rather than call through
       //    SSPI, we go right to the DLL doing the work.
       //

       hSecurity = LoadLibrary( "schannel" );

        if ( hSecurity == NULL ) {
            Error = GetLastError();
            goto quit;
        }

        //
        // get function addresses.
        //

#ifdef UNICODE
        pfInitSecurityInterface =
            (INITSECURITYINTERFACE) GetProcAddress( hSecurity,
                                                     "InitSecurityInterfaceW" );
#else
        pfInitSecurityInterface =
            (INITSECURITYINTERFACE) GetProcAddress( hSecurity,
                                                     "InitSecurityInterfaceA" );
#endif


        if ( pfInitSecurityInterface == NULL )
        {
             Error = GetLastError();
             goto quit;
        }


    GlobalSecFuncTable = (SecurityFunctionTable*) ((*pfInitSecurityInterface) ());

    if ( GlobalSecFuncTable == NULL ) {
         Error = GetLastError(); // BUGBUG does this work?
         goto quit;
    }

    HMODULE hCrypt32;
    hCrypt32 = GetModuleHandle("crypt32");

    INET_ASSERT(hCrypt32 != NULL);

    // We don't error out here because not finding these entry points
    // just affects Fortezza. The rest will still work fine.
    if (hCrypt32)
    {
        g_CryptInstallDefaultContext = (CRYPT_INSTALL_DEFAULT_CONTEXT_FN)
                                    GetProcAddress(hCrypt32, CRYPT_INSTALL_DEFAULT_CONTEXT_NAME);

        g_CryptUninstallDefaultContext = (CRYPT_UNINSTALL_DEFAULT_CONTEXT_FN)
                                    GetProcAddress(hCrypt32, CRYPT_UNINSTALL_DEFAULT_CONTEXT_NAME);

        g_CertFindChainInStore = (CERT_FIND_CHAIN_IN_STORE_FN)
                                    GetProcAddress(hCrypt32, CERT_FIND_CHAIN_IN_STORE_NAME);

        g_CertFreeCertificateChain = (CERT_FREE_CERTIFICATE_CHAIN_FN)
                                    GetProcAddress(hCrypt32, CERT_FREE_CERTIFICATE_CHAIN_NAME);
    }

quit:

    if ( Error != ERROR_SUCCESS )
    {
        FreeLibrary( hSecurity );
        hSecurity = NULL;
    }

    UNLOCK_SECURITY();

    return( Error );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\common\servinfo.cxx ===
/*++

Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

    servinfo.cxx

Abstract:

    Class implementation for global server info list

    Contents:
        INTERNET_HANDLE_OBJECT::GetServerInfo
        INTERNET_HANDLE_OBJECT::FindServerInfo
        ReleaseServerInfo
        INTERNET_HANDLE_OBJECT::PurgeServerInfoList
        CServerInfo::CServerInfo
        CServerInfo::~CServerInfo
        CServerInfo::Reference
        CServerInfo::Dereference
        CServerInfo::UpdateConnectTime
        CServerInfo::UpdateRTT
        CServerInfo::GetConnection
        CFsm_GetConnection::RunSM
        CServerInfo::GetConnection_Fsm
        CServerInfo::ReleaseConnection
        CServerInfo::RemoveWaiter
        (CServerInfo::FindKeepAliveConnection)
        (CServerInfo::KeepAliveWaiters)
        (CServerInfo::RunOutOfConnections)
        (CServerInfo::UpdateConnectionLimit)
        CServerInfo::PurgeKeepAlives
        ContainingServerInfo

Author:

    Richard L Firth (rfirth) 07-Oct-1996

Revision History:

    07-Oct-1996 rfirth
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

//
// private macros
//

//#define CHECK_CONNECTION_COUNT() \
//    INET_ASSERT(!UnlimitedConnections() \
//        ? (TotalAvailableConnections() <= ConnectionLimit()) : TRUE)

#define CHECK_CONNECTION_COUNT()    /* NOTHING */

//#define RLF_DEBUG   1

#if INET_DEBUG
#ifdef RLF_DEBUG
#define DPRINTF dprintf
#else
#define DPRINTF (void)
#endif
#else
#define DPRINTF (void)
#endif

//
// functions
//


DWORD
INTERNET_HANDLE_OBJECT::GetServerInfo(
    IN LPSTR lpszHostName,
    IN DWORD dwServiceType,
    IN BOOL bDoResolution,
    OUT CServerInfo * * lplpServerInfo
    )

/*++

Routine Description:

    Finds or creates a CServerInfo entry

Arguments:

    lpszHostName    - pointer to server name to get info for

    dwServiceType   - type of service for which CServerInfo requested

    bDoResolution   - TRUE if we are to resolve host name

    lplpServerInfo  - pointer to created/found CServerInfo if successful

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't create the CServerInfo

                  ERROR_WINHTTP_NAME_NOT_RESOLVED
                    We were asked to resolve the name, but failed

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 Dword,
                 "GetServerInfo",
                 "%q, %s (%d), %B, %#x",
                 lpszHostName,
                 InternetMapService(dwServiceType),
                 dwServiceType,
                 bDoResolution,
                 lplpServerInfo
                 ));

    ICSTRING hostName(lpszHostName);
    CServerInfo * lpServerInfo = NULL;
    BOOL bCreated = FALSE;
    DWORD error = ERROR_SUCCESS;

    if (hostName.HaveString()) {
        hostName.MakeLowerCase();

        LPSTR lpszHostNameLower = hostName.StringAddress();

        if (!LockSerializedList(&_ServerInfoList))
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }

        lpServerInfo = FindServerInfo(lpszHostNameLower);

        if (lpServerInfo == NULL) 
        {
            lpServerInfo = New CServerInfo(&_ServerInfoList,
                                           lpszHostNameLower,
                                           &error,
                                           dwServiceType,
                                           GetMaxConnectionsPerServer(WINHTTP_OPTION_MAX_CONNS_PER_SERVER)
                                           );
            if (lpServerInfo != NULL)
            {
                if (error != ERROR_SUCCESS)
                {
                    delete lpServerInfo;
                    lpServerInfo = NULL;
                }
                else
                {
                    bCreated = TRUE;
                    // Reference this to keep it alive beyond the unlock/
                    lpServerInfo->Reference();
                }
            }
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        UnlockSerializedList(&_ServerInfoList);
    } else {

        //
        // failed to create ICSTRING
        //

        error = GetLastError();

        INET_ASSERT(error != ERROR_SUCCESS);

        lpServerInfo = NULL;
    }

    //
    // if we created a new CServerInfo and we are instructed to resolve the host
    // name then do it now, outside of the global server info list lock. This
    // operation may take some time
    //

    if (bDoResolution && (lpServerInfo != NULL)) {
        //error = lpServerInfo->ResolveHostName();
        if (error != ERROR_SUCCESS) {
            ReleaseServerInfo(lpServerInfo);
            lpServerInfo = NULL;
        }
    }

quit:
    *lplpServerInfo = lpServerInfo;

    DEBUG_LEAVE(error);

    return error;
}


CServerInfo *
INTERNET_HANDLE_OBJECT::FindServerInfo(
    IN LPSTR lpszHostName
    )

/*++

Routine Description:

    Walks the server info list looking for the requested server

Arguments:

    lpszHostName    - pointer to server name to find (IN LOWER CASE!)

Return Value:

    CServerInfo *
        Success - pointer to found list entry

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 Pointer,
                 "FindServerInfo",
                 "%q",
                 lpszHostName
                 ));

    DWORD hashHostName = CalculateHashValue(lpszHostName);

    CServerInfo * lpServerInfo = NULL;
    BOOL found = FALSE;

    if (!LockSerializedList(&_ServerInfoList))
    {
        goto quit;
    }

    for (lpServerInfo = (CServerInfo *)HeadOfSerializedList(&_ServerInfoList);
        lpServerInfo != (CServerInfo *)SlSelf(&_ServerInfoList);
        lpServerInfo = lpServerInfo->Next()) {

        if (lpServerInfo->Match(hashHostName, lpszHostName)) {
            found = TRUE;
            break;
        }
    }

    if (!found) 
    {
        lpServerInfo = NULL;
    }

    // Need to keep this alive beyond the lock.
    if (lpServerInfo)
    {
        lpServerInfo->Reference();
    }
    UnlockSerializedList(&_ServerInfoList);

quit:
    DEBUG_LEAVE(lpServerInfo);
    return lpServerInfo;
}



VOID
ReleaseServerInfo(
    IN CServerInfo * lpServerInfo
    )

/*++

Routine Description:

    Release a CServerInfo by dereferencing it. If the reference count goes to
    zero, the CServerInfo will be destroyed

Arguments:

    lpServerInfo    - pointer to CServerInfo to release

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "ReleaseServerInfo",
                 "%#x [%q]",
                 lpServerInfo,
                 lpServerInfo->GetHostName()
                 ));

    lpServerInfo->Dereference();

    DEBUG_LEAVE(0);
}


VOID
INTERNET_HANDLE_OBJECT::PurgeServerInfoList(
    IN BOOL bForce
    )

/*++

Routine Description:

    Throw out any CServerInfo entries that have expired or any KEEP_ALIVE
    entries (for any CServerInfo) that have expired

Arguments:

    bForce  - TRUE if we forcibly remove entries which have not yet expired but
              which have a reference count of 1, else FALSE to remove only
              entries that have expired

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "PurgeServerInfoList",
                 "%B",
                 bForce
                 ));

    if (!LockSerializedList(&_ServerInfoList))
    {
        // Can't purge list if unable to obtain the lock.
        goto quit;
    }

    PLIST_ENTRY pEntry = HeadOfSerializedList(&_ServerInfoList);
    PLIST_ENTRY pPrevious = (PLIST_ENTRY)SlSelf(&_ServerInfoList);

    while (TRUE) {
        if (pEntry == (PLIST_ENTRY)SlSelf(&_ServerInfoList)) {
            break;
        }

        CServerInfo * pServerInfo;

        //pServerInfo = (CServerInfo *)pEntry;
        //pServerInfo = CONTAINING_RECORD(pEntry, CONNECTION_LIMIT, m_List);
        pServerInfo = ContainingServerInfo(pEntry);

        BOOL deleted = FALSE;

        if (pServerInfo->ReferenceCount() == 1) {
            if (bForce || pServerInfo->Expired()) {
//dprintf("purging server info entry for %q\n", pServerInfo->GetHostName());
                deleted = pServerInfo->Dereference();
            } else {
                pServerInfo->PurgeKeepAlives(PKA_NO_FORCE);
            }
        }
        if (!deleted) {
            pPrevious = pEntry;
        }
        pEntry = pPrevious->Flink;
    }

    UnlockSerializedList(&_ServerInfoList);

quit:
    DEBUG_LEAVE(0);
}


VOID
INTERNET_HANDLE_OBJECT::PurgeKeepAlives(
    IN DWORD dwForce
    )

/*++

Routine Description:

    Throw out any KEEP_ALIVE entries from any CServerInfo that have expired or
    which have failed authentication or which are unused, depending on dwForce

Arguments:

    dwForce - force to apply when purging. Value can be:

                PKA_NO_FORCE    - only purge timed-out sockets or sockets in
                                  close-wait state (default)

                PKA_NOW         - purge all sockets

                PKA_AUTH_FAILED - purge sockets that have been marked as failing
                                  authentication

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "PurgeKeepAlives",
                 "%s [%d]",
                 (dwForce == PKA_NO_FORCE) ? "NO_FORCE"
                 : (dwForce == PKA_NOW) ? "NOW"
                 : (dwForce == PKA_AUTH_FAILED) ? "AUTH_FAILED"
                 : "?",
                 dwForce
                 ));

    if (!LockSerializedList(&_ServerInfoList))
    {
        goto quit;
    }

    PLIST_ENTRY pEntry = HeadOfSerializedList(&_ServerInfoList);

    while (pEntry != (PLIST_ENTRY)SlSelf(&_ServerInfoList)) {

        CServerInfo * lpServerInfo = ContainingServerInfo(pEntry);

        lpServerInfo->PurgeKeepAlives(dwForce);
        pEntry = pEntry->Flink;
    }

    UnlockSerializedList(&_ServerInfoList);

quit:
    DEBUG_LEAVE(0);
}


//
// methods
//


CServerInfo::CServerInfo(
    IN SERIALIZED_LIST * ServerInfoList,
    IN LPSTR lpszHostName,
    OUT DWORD* pdwError,
    IN DWORD dwService,
    IN DWORD dwMaxConnections
    )

/*++

Routine Description:

    CServerInfo constructor

Arguments:

    lpszHostName        - server for which to create CServerInfo

    dwService           - which service to create CServerInfo for

    dwMaxConnections    - maximum number of simultaneous connections to this
                          server

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "CServerInfo::CServerInfo",
                 "%q, %s (%d), %d",
                 lpszHostName,
                 InternetMapService(dwService),
                 dwService,
                 dwMaxConnections
                 ));

    INIT_SERVER_INFO();

    m_ServerInfoList = ServerInfoList;
    *pdwError = ERROR_SUCCESS;

    InitializeListHead(&m_List);
    m_Expires = 0;
    m_Wrap = 0;
    m_ReferenceCount = 1;
    m_HostName = lpszHostName;
    if (!m_HostName.StringAddress())
    {
        goto error;
    }
    
    m_HostName.MakeLowerCase();
    m_Hash = CalculateHashValue(m_HostName.StringAddress());
    m_Services.Word = 0;
    m_HttpSupport.Word = 0;
    m_Flags.Word = 0;
    m_ProxyLink = NULL;

    INET_ASSERT(dwService == INTERNET_SERVICE_HTTP);
    SetHTTP();

    //
    // only initialize the keep-alive and connection limit lists if we are
    // creating the server info entry for a HTTP server (or CERN proxy)
    //

    //
    // BUGBUG - we only want to do this on demand
    //

    //if (IsHTTP()) {
    InitializeSerializedList(&m_KeepAliveList);
    SetKeepAliveListInitialized();

    //
    // the maximum number of connections per server is initialized to the
    // default (registry) value unless overridden by the caller
    //

    if (dwMaxConnections == 0) 
    {
        dwMaxConnections = DEFAULT_MAX_CONNECTIONS_PER_SERVER;
    }
    
    m_ConnectionLimit = dwMaxConnections;
    //} else {
    //    m_ConnectionLimit = UNLIMITED_CONNECTIONS;
    //}
    //dprintf("*** %s: limit = %d\n", GetHostName(), m_ConnectionLimit);
    //
    // BUGBUG - only create event if limiting connections. Need method to manage
    //          connection limit count/event creation
    //

    m_NewLimit = m_ConnectionLimit;
    m_ConnectionsAvailable = m_ConnectionLimit;
    //m_ActiveConnections = 0;
    m_LastActiveTime = 0;
    m_ConnectTime = (DWORD)-1;
    m_RTT = 0;
    m_dwError = ERROR_SUCCESS;

    //
    // add to the global list. We are assuming here that the caller has already
    // checked for dupes
    //

    if (!InsertAtHeadOfSerializedList(m_ServerInfoList, &m_List))
        *pdwError = ERROR_NOT_ENOUGH_MEMORY;

quit:
    DEBUG_LEAVE(0);
    return;

error:
    *pdwError = ERROR_NOT_ENOUGH_MEMORY;
    goto quit;
    
}


CServerInfo::~CServerInfo()

/*++

Routine Description:

    CServerInfo destructor

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "CServerInfo::~CServerInfo",
                 "{%q}",
                 GetHostName()
                 ));

    CHECK_SERVER_INFO();

    //GlobalServerInfoDeAllocCount++;

    // unlink if we have a nested obj
    if ( m_ProxyLink )
    {
        CServerInfo *pDerefObj = NULL;

        // will leak if unable to dereference
        if (LockSerializedList(m_ServerInfoList))
        {
            pDerefObj = m_ProxyLink;
            m_ProxyLink = NULL;
            UnlockSerializedList(m_ServerInfoList);
        }

        if (pDerefObj)
        {
            pDerefObj->Dereference();
        }
    }

    RemoveFromSerializedList(m_ServerInfoList, &m_List);

    INET_ASSERT(m_ReferenceCount == 0);

    if (IsKeepAliveListInitialized() && LockSerializedList(&m_KeepAliveList))
    {
        while (!IsSerializedListEmpty(&m_KeepAliveList))
        {
//dprintf("%#x ~S-I killing K-A %#x\n", GetCurrentThreadId(), HeadOfSerializedList(&m_KeepAliveList));

            LPVOID pEntry = SlDequeueHead(&m_KeepAliveList);

            INET_ASSERT(pEntry != NULL);

            if (pEntry != NULL) {

                ICSocket * pSocket = ContainingICSocket(pEntry);

//dprintf("~CServerInfo: destroying socket %#x\n", pSocket->GetSocket());
                pSocket->Destroy();
            }
        }
        UnlockSerializedList(&m_KeepAliveList);
        TerminateSerializedList(&m_KeepAliveList);
    }

    DEBUG_LEAVE(0);
}


VOID
CServerInfo::Reference(
    VOID
    )

/*++

Routine Description:

    Increments the reference count for the CServerInfo

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::Reference",
                 "{%q}",
                 GetHostName()
                 ));

    CHECK_SERVER_INFO();
    INET_ASSERT(m_ReferenceCount > 0);

    InterlockedIncrement(&m_ReferenceCount);
//dprintf("CServerInfo %s - %d\n", GetHostName(), m_ReferenceCount);

    DEBUG_PRINT(SESSION,
                INFO,
                ("Reference count = %d\n",
                ReferenceCount()
                ));

    DEBUG_LEAVE(0);
}


BOOL
CServerInfo::Dereference(
    VOID
    )

/*++

Routine Description:

    Dereferences the SESSION_INFO. If the reference count goes to zero then this
    entry is deleted. If the reference count goes to 1 then the expiry timer is
    started

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - entry was deleted

        FALSE   - entry was not deleted

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::Dereference",
                 "{%q}",
                 GetHostName()
                 ));

    CHECK_SERVER_INFO();
    INET_ASSERT(m_ReferenceCount > 0);

    //
    // we need to grab the list - we may be removing this entry or updating
    // the reference count and expiry fields which must be done atomically
    //

    SERIALIZED_LIST *   ServerInfoList = m_ServerInfoList;
    BOOL deleted = FALSE;

    if (!LockSerializedList(ServerInfoList))
        goto quit;

    LONG result = InterlockedDecrement(&m_ReferenceCount);
//dprintf("CServerInfo %s - %d\n", GetHostName(), m_ReferenceCount);

    DEBUG_PRINT(SESSION,
                INFO,
                ("Reference count = %d\n",
                ReferenceCount()
                ));

    if (result == 0) {
        delete this;
        deleted = TRUE;
    } else if (result == 1) {

        //
        // start expiration proceedings...
        //

        SetExpiryTime();
    }

    UnlockSerializedList(ServerInfoList);

quit:
    DEBUG_LEAVE(deleted);

    return deleted;
}


DWORD    
CServerInfo::SetCachedProxyServerInfo(
    IN CServerInfo * pProxyServer,
    IN DWORD dwProxyVersion,
    IN BOOL fUseProxy,
    IN INTERNET_SCHEME HostScheme,
    IN INTERNET_PORT HostPort,
    IN INTERNET_SCHEME ProxyScheme,
    IN INTERNET_PORT ProxyPort
    )
/*++

Routine Description:

    If the Version information match up, copies
     the proxy information and links this server object
     to the appopriate proxy server object

    Assumes that this is called on successful use of the proxy
      object.

Arguments:

    None.

Return Value:

    DWORD
        ERROR_SUCCESS

        ERROR_NOT_ENOUGH_MEMORY   - entry was not deleted because there
                                    wasn't available memory to obtain lock

--*/


{
    DWORD error=ERROR_SUCCESS;

    if (!LockSerializedList(m_ServerInfoList))
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    if ( dwProxyVersion != GlobalProxyVersionCount ) 
    {
        SetProxyScriptCached(FALSE);
        goto cleanup; // bail, we don't accept out of date additions to the cache
    }

    if ( m_ProxyLink )
    {
        if ( IsProxyScriptCached() && 
             HostScheme == m_HostScheme &&
             HostPort == m_HostPort &&
             fUseProxy )
        {
            if ( pProxyServer == m_ProxyLink ) {            
                INET_ASSERT(dwProxyVersion == GlobalProxyVersionCount);
                m_dwProxyVersion = dwProxyVersion; // we're now up to date
                goto cleanup; // match, no version or host changes
            }

            INET_ASSERT(pProxyServer != m_ProxyLink );            
        }
        //
        // unlink, because we have a new entry to save,
        //  and the previous entry is bad
        //
        m_ProxyLink->Dereference();
        m_ProxyLink = NULL;
    }

    //
    // Add new cached entry
    //

    SetProxyScriptCached(TRUE);

    m_HostScheme     = HostScheme;
    m_HostPort       = HostPort;

    m_dwProxyVersion = dwProxyVersion; // we're now up to date

    if ( fUseProxy )
    {
        INET_ASSERT(this != pProxyServer);

        m_ProxyLink = pProxyServer;
        m_ProxyLink->Reference();

        m_ProxyLink->m_HostScheme = ProxyScheme;
        m_ProxyLink->m_HostPort   = ProxyPort;

        switch (ProxyScheme)
        {
            case INTERNET_SCHEME_HTTP:
                m_ProxyLink->SetCernProxy();
                break;
            case INTERNET_SCHEME_SOCKS: 
                m_ProxyLink->SetSocksGateway();
                break;
        }
    }

cleanup:

    UnlockSerializedList(m_ServerInfoList);        

quit:

    return error;
}

CServerInfo * 
CServerInfo::GetCachedProxyServerInfo(
    IN INTERNET_SCHEME HostScheme,
    IN INTERNET_PORT HostPort,
    OUT BOOL *pfCachedEntry
    )

/*++

Routine Description:

   Retrieves a cached server object, that indicates
    a probable proxy to use

   On Success, the return has an additional increment
    on its ref count, assumition that caller derefs

Arguments:

    None.

Return Value:

    CServerInfo *     
        NULL on failure

--*/

{
    CServerInfo *pProxyServer = NULL;

    if (!LockSerializedList(m_ServerInfoList))
        return NULL;

    *pfCachedEntry = FALSE; 

    if ( IsProxyScriptCached() )
    {        
        //
        // Examine Version Count
        //

        if ( GlobalProxyVersionCount == m_dwProxyVersion &&
             HostScheme == m_HostScheme &&
             HostPort == m_HostPort
             )
        {
            *pfCachedEntry = TRUE;

            if ( m_ProxyLink ) {
                // matched cached entry
                m_ProxyLink->Reference();
                pProxyServer = m_ProxyLink;                    
            }
        }
        else
        {
            // version is expired, remove reference
            SetProxyScriptCached(FALSE);
            if ( m_ProxyLink ) {                
                m_ProxyLink->Dereference();
                m_ProxyLink = NULL;
            }
        }            
    }
        
    UnlockSerializedList(m_ServerInfoList);        
    return pProxyServer;
}

BOOL    
CServerInfo::CopyCachedProxyInfoToProxyMsg(
    IN OUT AUTO_PROXY_ASYNC_MSG *pQueryForProxyInfo
    )

/*++

Routine Description:

   Retrieves Cached Proxy info from object

Arguments:

    None.

Return Value:

    BOOL
        TRUE - sucess

--*/

{
    BOOL fSuccess = FALSE;

    // really only need to lock to proctect m_HostPort && m_HostScheme
    if (!LockSerializedList(m_ServerInfoList))
        return FALSE;

    pQueryForProxyInfo->SetUseProxy(FALSE);
    pQueryForProxyInfo->_lpszProxyHostName =  
        m_HostName.StringAddress() ? 
        NewString(m_HostName.StringAddress()) :
        NULL;

    if ( pQueryForProxyInfo->_lpszProxyHostName != NULL ) {
        // copy out cached entry to proxy message structure
        pQueryForProxyInfo->_nProxyHostPort        = m_HostPort;
        pQueryForProxyInfo->_tProxyScheme          = m_HostScheme;
        pQueryForProxyInfo->_bFreeProxyHostName    = TRUE;
        pQueryForProxyInfo->_dwProxyHostNameLength = 
            strlen((pQueryForProxyInfo)->_lpszProxyHostName);
        pQueryForProxyInfo->SetUseProxy(TRUE);
        fSuccess = TRUE; // success
    }

    UnlockSerializedList(m_ServerInfoList);        
    return fSuccess;
}




VOID
CServerInfo::UpdateConnectTime(
    IN DWORD dwConnectTime
    )

/*++

Routine Description:

    Calculates average connect time

Arguments:

    dwConnectTime   - current connect time

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::UpdateConnectTime",
                 "{%q} %d",
                 GetHostName(),
                 dwConnectTime
                 ));

    DWORD connectTime = m_ConnectTime;

    if (connectTime == (DWORD)-1) {
        connectTime = dwConnectTime;
    } else {
        connectTime = (connectTime + dwConnectTime) / 2;
    }
//dprintf("%s: connect time = %d, ave = %d\n", GetHostName(), dwConnectTime, connectTime);

    DEBUG_PRINT(SESSION,
                INFO,
                ("average connect time = %d mSec\n",
                connectTime
                ));

    InterlockedExchange((LPLONG)&m_ConnectTime, connectTime);

    DEBUG_LEAVE(0);
}


VOID
CServerInfo::UpdateRTT(
    IN DWORD dwRTT
    )

/*++

Routine Description:

    Calculates rolling average round-trip time

Arguments:

    dwRTT   - current round-trip time

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::UpdateRTT",
                 "{%q} %d",
                 GetHostName(),
                 dwRTT
                 ));

    DWORD RTT = m_RTT;

    if (RTT == 0) {
        RTT = dwRTT;
    } else {
        RTT = (RTT + dwRTT) / 2;
    }
//dprintf("%s: RTT = %d, ave = %d\n", GetHostName(), dwRTT, RTT);

    DEBUG_PRINT(SESSION,
                INFO,
                ("average round trip time = %d mSec\n",
                RTT
                ));

    InterlockedExchange((LPLONG)&m_RTT, RTT);

    DEBUG_LEAVE(0);
}



DWORD
CFsm_GetConnection::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    Runs next CFsm_GetConnection state

Arguments:

    Fsm - FSM controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
//dprintf("%#x: %s FSM %#x state %s\n", GetCurrentThreadId(), Fsm->MapType(), Fsm, Fsm->MapState());
    DEBUG_ENTER((DBG_SESSION,
                 Dword,
                 "CFsm_GetConnection::RunSM",
                 "%#x",
                 Fsm
                 ));

    CServerInfo * pServerInfo = (CServerInfo *)Fsm->GetContext();
    CFsm_GetConnection * stateMachine = (CFsm_GetConnection *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
        stateMachine->StartTimer();

        //
        // fall through
        //

    case FSM_STATE_CONTINUE:

#ifdef NEW_CONNECTION_SCHEME
    case FSM_STATE_ERROR:
#endif
        error = pServerInfo->GetConnection_Fsm(stateMachine);
        break;

#ifndef NEW_CONNECTION_SCHEME

    case FSM_STATE_ERROR:

        INET_ASSERT((Fsm->GetError() == ERROR_WINHTTP_TIMEOUT)
                    || (Fsm->GetError() == ERROR_WINHTTP_OPERATION_CANCELLED));

        pServerInfo->RemoveWaiter((DWORD_PTR)Fsm);
        error = Fsm->GetError();
        Fsm->SetDone();
//dprintf("%#x: FSM_STATE_ERROR - %d\n", GetCurrentThreadId(), error);
        break;

#endif

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}



DWORD
CServerInfo::GetConnection_Fsm(
    IN CFsm_GetConnection * Fsm
    )

/*++

Routine Description:

    Tries to get a connection of requested type for caller. If no connection is
    available then one of the following happens:

        * If there are available keep-alive connections of a different type then
          one is closed and the caller allowed to create a new connection

        * If this is an async request, the FSM is blocked and the thread returns
          to the pool if a worker, or back to the app if an app thread

        * If this is a sync request, we wait on an event for a connection to be
          made available, or the connect timeout to elapse

Arguments:

    Fsm - get connection FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    Depending on *lplpSocket, we either returned the socket to
                    use, or its okay to create a new connection

                  ERROR_IO_PENDING
                    Request will complete asynchronously

        Failure - ERROR_WINHTTP_TIMEOUT
                    Failed to get connection in time allowed

                  ERROR_WINHTTP_INTERNAL_ERROR
                    Something unexpected happened

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 Dword,
                 "CServerInfo::GetConnection_Fsm",
                 "{%q [%d+%d/%d]} %#x(%#x, %d, %d)",
                 GetHostName(),
                 m_ConnectionsAvailable,
                 ElementsOnSerializedList(&m_KeepAliveList),
                 m_ConnectionLimit,
                 Fsm,
                 Fsm->m_dwSocketFlags,
                 Fsm->m_nPort,
                 Fsm->m_dwTimeout
                 ));

    PERF_ENTER(GetConnection);

    BOOL bFound = FALSE;
    DWORD error = ERROR_SUCCESS;
    CFsm_GetConnection & fsm = *Fsm;
    ICSocket * pSocket = NULL;
    LPINTERNET_THREAD_INFO lpThreadInfo = fsm.GetThreadInfo();
    HANDLE hEvent = NULL;
    BOOL bUnlockList = TRUE;
    BOOL bKeepAliveWaiters;

    INET_ASSERT(lpThreadInfo != NULL);
    INET_ASSERT(lpThreadInfo->hObjectMapped != NULL);
    INET_ASSERT(((HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->
                GetHandleType() == TypeHttpRequestHandle);

    if ((lpThreadInfo == NULL) || (lpThreadInfo->hObjectMapped == NULL)) {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    BOOL bAsyncRequest;

    bAsyncRequest = lpThreadInfo->IsAsyncWorkerThread
                    || ((INTERNET_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->
                        IsAsyncHandle();

    *fsm.m_lplpSocket = NULL;

try_again:

    bUnlockList = TRUE;

    //
    // use m_Waiters to serialize access. N.B. - we will acquire m_KeepAliveList
    // from within m_Waiters
    //

    if (!m_Waiters.Acquire()) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    if (IsNewLimit()) {
        UpdateConnectionLimit();
    }
    bKeepAliveWaiters = KeepAliveWaiters();
    if (fsm.m_dwSocketFlags & SF_KEEP_ALIVE) {

        //
        // maintain requester order - if there are already waiters then queue
        // this request, else try to satisfy the requester. HOWEVER, only check
        // for existing requesters the FIRST time through. If we're here with
        // FSM_STATE_CONTINUE then we've been unblocked and we can ignore any
        // waiters that came after us
        //

        if ((fsm.GetState() == FSM_STATE_CONTINUE) || !bKeepAliveWaiters) {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("no current waiters for K-A connections\n"
                        ));

            while (pSocket = FindKeepAliveConnection(fsm.m_dwSocketFlags,
                                                     fsm.m_nPort,
                                                     fsm.m_lpszSecureTunnelHost)) {
                if (pSocket->IsReset() || pSocket->HasExpired()) {

                    DPRINTF("%#x: %#x: ********* socket %#x is closed already\n",
                            GetCurrentThreadId(),
                            Fsm,
                            pSocket->GetSocket()
                            );

                    DEBUG_PRINT(SESSION,
                                INFO,
                                ("K-A connection %#x [%#x/%d] is reset (%B) or expired (%B)\n",
                                pSocket,
                                pSocket->GetSocket(),
                                pSocket->GetSourcePort(),
                                pSocket->IsReset(),
                                pSocket->HasExpired()
                                ));

                    pSocket->SetLinger(FALSE, 0);
                    pSocket->Shutdown(2);
//dprintf("GetConnection: destroying reset socket %#x\n", pSocket->GetSocket());
                    pSocket->Destroy();
                    pSocket = NULL;
                    if (!UnlimitedConnections()) {
                        ++m_ConnectionsAvailable;
                    }
                    CHECK_CONNECTION_COUNT();
                } else {

                    DPRINTF("%#x: %#x: *** matched %#x, %#x\n",
                            GetCurrentThreadId(),
                            Fsm,
                            pSocket->GetSocket(),
                            pSocket->GetFlags()
                            );

                    break;
                }
            }
            if (pSocket == NULL) {

                DEBUG_PRINT(SESSION,
                            INFO,
                            ("no available K-A connections\n"
                            ));

                /*
                //
                // if all connections are in use as keep-alive connections then
                // since we're here, we want a keep-alive connection that doesn't
                // match the currently available keep-alive connections. Terminate
                // the oldest keep-alive connection (at the head of the queue)
                // and generate a new connection
                //

                LockSerializedList(&m_KeepAliveList);
                if (ElementsOnSerializedList(&m_KeepAliveList) == m_ConnectionLimit) {
                    pSocket = ContainingICSocket(SlDequeueHead(&m_KeepAliveList));
                    pSocket->SetLinger(FALSE, 0);
                    pSocket->Shutdown(2);
                    pSocket->Destroy();
                    if (!UnlimitedConnections()) {
                        ++m_ConnectionsAvailable;
                    }
                    CHECK_CONNECTION_COUNT();
                }
                UnlockSerializedList(&m_KeepAliveList);
                */
            }
        } else {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("%d waiters for K-A connection to %q\n",
                        ElementsOnSerializedList(&m_KeepAliveList),
                        GetHostName()
                        ));

        }
    }

    //
    // if we found a matching keep-alive connection or we are not limiting
    // connections then we're done
    //

    if ((pSocket != NULL) || UnlimitedConnections()) {

        INET_ASSERT(error == ERROR_SUCCESS);

        goto exit;
    }

    //
    // no keep-alive connections matched, or there are already waiters for
    // keep-alive connections
    //

    INET_ASSERT(m_ConnectionsAvailable <= m_ConnectionLimit);

    if (m_ConnectionsAvailable > 0) {

        if (fsm.m_lpszSecureTunnelHost)
            goto exit;  // don't create a connection here for SSL tunneling

        //
        // can create a connection
        //

        DEBUG_PRINT(SESSION,
                    INFO,
                    ("OK to create new connection\n"
                    ));

        DPRINTF("%#x: %#x: *** %s OK to create connection %d/%d\n",
                GetCurrentThreadId(),
                Fsm,
                GetHostName(),
                m_ConnectionsAvailable,
                m_ConnectionLimit
                );

        --m_ConnectionsAvailable;
    } else if (fsm.GetElapsedTime() > fsm.m_dwTimeout) {
        error = ERROR_WINHTTP_TIMEOUT;
    } else {
        
        //
        // if there are keep-alive connections but no keep-alive waiters
        // then either we don't want a keep-alive connection, or the ones
        // available don't match our requirements.
        // If we need a connection of a different type - e.g. SSL when all
        // we have is non-SSL then close a connection & generate a new one.
        // If we need a non-keep-alive connection then its okay to return
        // a current keep-alive connection, the understanding being that the
        // caller will not add Connection: Keep-Alive header (HTTP 1.0) or
        // will add Connection: Close header (HTTP 1.1)
        //

        //
        // BUGBUG - what about waiters for non-keep-alive connections?
        //
        // scenario - limit of 1 connection:
        //
        //  A. request for k-a
        //      continue & create connection
        //  B. request non-k-a
        //      none available; wait
        //  C. release k-a connection; unblock sync waiter B
        //  D. request non-k-a
        //      k-a available; return it; caller converts to non-k-a
        //  E. unblocked waiter B request non-k-a
        //      none available; wait
        //
        // If this situation continues, eventually B will time-out, whereas it
        // could have had the connection taken by D. Request D is younger and
        // therefore can afford to wait while B continues with the connection
        //

        BOOL fHaveConnection = FALSE;

        if (!bKeepAliveWaiters || (fsm.GetState() == FSM_STATE_CONTINUE)) {
            if (!LockSerializedList(&m_KeepAliveList)) {
                error = ERROR_NOT_ENOUGH_MEMORY;
                goto exit;
            }
            if (ElementsOnSerializedList(&m_KeepAliveList) != 0) {
                pSocket = ContainingICSocket(SlDequeueHead(&m_KeepAliveList));
                fHaveConnection = TRUE;

#define SOCK_FLAGS  (SF_ENCRYPT | SF_DECRYPT | SF_SECURE | SF_TUNNEL)

                DWORD dwSocketTypeFlags = pSocket->GetFlags() & SOCK_FLAGS;
                DWORD dwRequestTypeFlags = fsm.m_dwSocketFlags & SOCK_FLAGS;

                if ((dwSocketTypeFlags ^ dwRequestTypeFlags)
                    || (fsm.m_nPort != pSocket->GetPort())) {

                    DEBUG_PRINT(SESSION,
                                INFO,
                                ("different socket types (%#x, %#x) or ports (%d, %d) requested\n",
                                fsm.m_dwSocketFlags,
                                pSocket->GetFlags(),
                                fsm.m_nPort,
                                pSocket->GetPort()
                                ));

                    DPRINTF("%#x: %#x: *** closing socket %#x: %#x vs. %#x\n",
                            GetCurrentThreadId(),
                            Fsm,
                            pSocket->GetSocket(),
                            pSocket->GetFlags(),
                            fsm.m_dwSocketFlags
                            );

                    pSocket->SetLinger(FALSE, 0);
                    pSocket->Shutdown(2);
//dprintf("GetConnection: destroying different type socket %#x\n", pSocket->GetSocket());
                    pSocket->Destroy();
                    pSocket = NULL;
                    // If we were trying to wait for established SSL tunnel,
                    // but one wasn't found, then this connection is open
                    // for anyone.
                    if (!UnlimitedConnections() && fsm.m_lpszSecureTunnelHost) {
                        ++m_ConnectionsAvailable;
                    }
                } else {

                    DPRINTF("%#x: %#x: *** returning k-a connection %#x as non-k-a\n",
                            GetCurrentThreadId(),
                            Fsm,
                            pSocket->GetSocket()
                            );

                }
                CHECK_CONNECTION_COUNT();
            }
            UnlockSerializedList(&m_KeepAliveList);
            if (fHaveConnection) {
                goto exit;
            }
        }

        DPRINTF("%#x: %#x: blocking %s FSM %#x state %s %d/%d\n",
                GetCurrentThreadId(),
                Fsm,
                Fsm->MapType(),
                Fsm,
                Fsm->MapState(),
                m_ConnectionsAvailable,
                m_ConnectionLimit
                );

        //
        // we have to wait for a connection to become available. If we are an
        // async request then we queue this FSM & return the thread to the pool
        // or, if app thread, return pending indication to the app. If this is
        // a sync request (in an app thread) then we block on an event waiting
        // for a connection to become available
        //

        if (!bAsyncRequest) {

            //
            // create unnamed, initially unsignalled, auto-reset event
            //

            hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
            if (hEvent == NULL) {
                error = GetLastError();
                goto exit;
            }
        }

        CConnectionWaiter * pWaiter;
        DWORD dwStatus = ERROR_SUCCESS;

#if INET_DEBUG

        for (pWaiter = (CConnectionWaiter *)m_Waiters.Head();
             pWaiter != (CConnectionWaiter *)m_Waiters.Self();
             pWaiter = (CConnectionWaiter *)pWaiter->Next()) {

            INET_ASSERT(pWaiter->Id() != (DWORD_PTR)(bAsyncRequest ? (DWORD_PTR)Fsm : lpThreadInfo->ThreadId));
        }
#endif

        pWaiter = New CConnectionWaiter(&m_Waiters,
                                        !bAsyncRequest,
                                        (fsm.m_dwSocketFlags & SF_KEEP_ALIVE)
                                            ? TRUE
                                            : FALSE,
                                        bAsyncRequest
                                            ? (DWORD_PTR)Fsm
                                            : lpThreadInfo->ThreadId,
                                        hEvent,

                                        //
                                        // priority in request handle object
                                        // controls relative position in list
                                        // of waiters
                                        //

                                        ((HTTP_REQUEST_HANDLE_OBJECT *)
                                            lpThreadInfo->hObjectMapped)->
                                                GetPriority(),

                                        &dwStatus
                                        );

        DPRINTF("%#x: %#x: new waiter %#x: as=%B, K-A=%B, id=%#x, hE=%#x, pri=%d, status=%#x, sf=%#x, preq=%#x ssl=%s\n",
                GetCurrentThreadId(),
                Fsm,
                pWaiter,
                bAsyncRequest,
                (fsm.m_dwSocketFlags & SF_KEEP_ALIVE)
                    ? TRUE
                    : FALSE,
                bAsyncRequest
                    ? (DWORD_PTR)Fsm
                    : lpThreadInfo->ThreadId,
                hEvent,
                ((HTTP_REQUEST_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->
                    GetPriority(),
                dwStatus,
                fsm.m_dwSocketFlags,
                ((HTTP_REQUEST_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped),
                fsm.m_lpszSecureTunnelHost ? fsm.m_lpszSecureTunnelHost : ""
                );

        if (pWaiter == NULL) {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
        else if (dwStatus != ERROR_SUCCESS) {
            error = dwStatus;
            delete pWaiter;  // free since it wasn't inserted
            goto exit;
        }
        
        if (bAsyncRequest) {

            //
            // ensure that when the FSM is unblocked normally, the new state
            // is STATE_CONTINUE
            //

            Fsm->SetState(FSM_STATE_CONTINUE);
            error = BlockWorkItem(Fsm,
                                  (DWORD_PTR)pWaiter,
                                  fsm.m_dwTimeout
                                  );
            if (error == ERROR_SUCCESS) {
                error = ERROR_IO_PENDING;
            }
        } 
        else
        {
            m_Waiters.Release();
            bUnlockList = FALSE;

            DPRINTF("%#x: %#x: %s FSM %#x %s waiting %d msec\n",
                    GetCurrentThreadId(),
                    Fsm,
                    Fsm->MapType(),
                    Fsm,
                    Fsm->MapState(),
                    fsm.m_dwTimeout
                    );

            DWORD dwWaitTime = (fsm.m_dwTimeout != INFINITE) ? 
                                (fsm.m_dwTimeout - fsm.GetElapsedTime()) : 
                                  INFINITE;

            if (((int)dwWaitTime <= 0) && (dwWaitTime != INFINITE)) {

                DEBUG_PRINT(SESSION,
                            ERROR,
                            ("SYNC wait timed out (%d mSec)\n",
                            fsm.m_dwTimeout
                            ));

                error = ERROR_WINHTTP_TIMEOUT;
            } else {

                DEBUG_PRINT(SESSION,
                            INFO,
                            ("waiting %d mSec for SYNC event %#x\n",
                            dwWaitTime,
                            hEvent
                            ));

                //
                // we'd better not be doing a sync wait if we are in the
                // context of an app thread making an async request
                //

                INET_ASSERT(lpThreadInfo->IsAsyncWorkerThread
                            || !((INTERNET_HANDLE_OBJECT *)lpThreadInfo->
                                hObjectMapped)->IsAsyncHandle());

                //INET_ASSERT(dwWaitTime <= 60000);

                error = WaitForSingleObject(hEvent, dwWaitTime);

                DPRINTF("%#x: %#x: sync waiter unblocked - error = %d\n",
                        GetCurrentThreadId(),
                        Fsm,
                        error
                        );

            }
            if (error == STATUS_TIMEOUT) {

                DPRINTF("%#x: %#x: %s: %d+%d/%d: timed out %#x (%s FSM %#x %s)\n",
                        GetCurrentThreadId(),
                        Fsm,
                        GetHostName(),
                        m_ConnectionsAvailable,
                        ElementsOnSerializedList(&m_KeepAliveList),
                        m_ConnectionLimit,
                        GetCurrentThreadId(),
                        Fsm->MapType(),
                        Fsm,
                        Fsm->MapState()
                        );

                RemoveWaiter(lpThreadInfo->ThreadId);
                error = ERROR_WINHTTP_TIMEOUT;
            }

            BOOL bOk;

            bOk = CloseHandle(hEvent);

            INET_ASSERT(bOk);

            if (error == WAIT_OBJECT_0) {

                DPRINTF("%#x: %#x: sync requester trying again\n",
                        GetCurrentThreadId(),
                        Fsm
                        );

                fsm.SetState(FSM_STATE_CONTINUE);
                goto try_again;
            }
        }
    }

exit:

    //
    // if we are returning a (keep-alive) socket that has a different blocking
    // mode from that requested, change it
    //

    if (pSocket != NULL) {
        if ((pSocket->GetFlags() & SF_NON_BLOCKING)
            ^ (fsm.m_dwSocketFlags & SF_NON_BLOCKING)) {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("different blocking modes requested: %#x, %#x\n",
                        fsm.m_dwSocketFlags,
                        pSocket->GetFlags()
                        ));

            DPRINTF("%#x: %#x: *** changing socket %#x to %sBLOCKING\n",
                    GetCurrentThreadId(),
                    Fsm,
                    pSocket->GetSocket(),
                    fsm.m_dwSocketFlags & SF_NON_BLOCKING ? "NON-" : ""
                    );

            if (!(GlobalRunningNovellClient32 && !GlobalNonBlockingClient32)) {
                pSocket->SetNonBlockingMode(fsm.m_dwSocketFlags & SF_NON_BLOCKING);
            }
        }
        *fsm.m_lplpSocket = pSocket;
    }

    if (bUnlockList) {
        m_Waiters.Release();
    }

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DPRINTF("%#x: %#x: %s: %d+%d/%d: get: %d, %#x, %d\n",
            GetCurrentThreadId(),
            Fsm,
            GetHostName(),
            m_ConnectionsAvailable,
            ElementsOnSerializedList(&m_KeepAliveList),
            m_ConnectionLimit,
            error,
            pSocket ? pSocket->GetSocket() : 0,
            m_Waiters.Count()
            );

    PERF_LEAVE(GetConnection);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CServerInfo::ReleaseConnection(
    IN ICSocket * lpSocket OPTIONAL
    )

/*++

Routine Description:

    Returns a keep-alive connection to the pool, or allows another requester to
    create a connection

Arguments:

    lpSocket    - pointer to ICSocket if we are returning a keep-alive connection

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 Dword,
                 "CServerInfo::ReleaseConnection",
                 "{%q [%d+%d/%d]} %#x [%#x]",
                 GetHostName(),
                 AvailableConnections(),
                 KeepAliveConnections(),
                 ConnectionLimit(),
                 lpSocket,
                 lpSocket ? lpSocket->GetSocket() : 0
                 ));

    PERF_ENTER(ReleaseConnection);

    DWORD error = ERROR_SUCCESS;
    BOOL bRelease = FALSE;

    if (!m_Waiters.Acquire()) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // quite often (at least with catapult proxy based on IIS) the server may
    // drop the connection even though it indicated it would keep it open. This
    // typically happens on 304 (frequent) and 302 (less so) responses. If we
    // determine the server has dropped the connection then throw it away and
    // allow the app to create a new one
    //

    if (lpSocket != NULL) {
        if (lpSocket->IsClosed() || lpSocket->IsReset()) {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("socket %#x already dead - throwing it out\n",
                        lpSocket->GetSocket()
                        ));

            DPRINTF("%#x: socket %#x: already reset\n",
                    GetCurrentThreadId(),
                    lpSocket->GetSocket()
                    );

//dprintf("ReleaseConnection: destroying already closed socket %#x\n", lpSocket->GetSocket());
            BOOL bDestroyed = lpSocket->Dereference();

            INET_ASSERT(bDestroyed);

            lpSocket = NULL;
        } else {

            //
            // if we are returning a keep-alive socket, put it in non-blocking
            // mode if not already. Typically, Internet Explorer uses non-blocking
            // sockets. In the infrequent cases where we want a blocking socket
            // - mainly when doing java downloads - we will convert the socket
            // to blocking mode when we get it from the pool
            //

            if (!lpSocket->IsNonBlocking()) {

                DPRINTF("%#x: ***** WARNING: releasing BLOCKING k-a socket %#x\n",
                        GetCurrentThreadId(),
                        lpSocket->GetSocket()
                        );

                if (!(GlobalRunningNovellClient32 && !GlobalNonBlockingClient32)) {
                    lpSocket->SetNonBlockingMode(TRUE);
                }
            }
        }
    }
    if (lpSocket != NULL) {

        DPRINTF("%#x: releasing K-A %#x (%d+%d/%d)\n",
                GetCurrentThreadId(),
                lpSocket ? lpSocket->GetSocket() : 0,
                AvailableConnections(),
                KeepAliveConnections(),
                ConnectionLimit()
                );

        INET_ASSERT(lpSocket->IsOpen());
        INET_ASSERT(!lpSocket->IsOnList());
        //INET_ASSERT(!lpSocket->IsReset());

        lpSocket->SetKeepAlive();

        DEBUG_PRINT(SESSION,
                    INFO,
                    ("releasing keep-alive socket %#x\n",
                    lpSocket->GetSocket()
                    ));

        lpSocket->SetExpiryTime(GlobalKeepAliveSocketTimeout);

        INET_ASSERT(!IsOnSerializedList(&m_KeepAliveList, lpSocket->List()));

        if (!InsertAtTailOfSerializedList(&m_KeepAliveList, lpSocket->List()))
        {
            DEBUG_PRINT(SESSION,
                        INFO,
                        ("not enough memory to release %#x to k-a pool\n",
                        lpSocket->GetSocket()
                        ));

            lpSocket->Dereference();

            if (!UnlimitedConnections())
            {
                ++m_ConnectionsAvailable;
            }
        }

        lpSocket = NULL;

        INET_ASSERT(UnlimitedConnections()
            ? TRUE
            : (KeepAliveConnections() <= ConnectionLimit()));

        bRelease = TRUE;
    } else {

        DPRINTF("%#x: releasing connection (%d+%d/%d)\n",
                GetCurrentThreadId(),
                AvailableConnections(),
                KeepAliveConnections(),
                ConnectionLimit()
                );

        if (!UnlimitedConnections()) {
            ++m_ConnectionsAvailable;
        }

        CHECK_CONNECTION_COUNT();

        bRelease = TRUE;
    }
    if (bRelease && !UnlimitedConnections()) {

        CHECK_CONNECTION_COUNT();

        CConnectionWaiter * pWaiter = (CConnectionWaiter *)m_Waiters.RemoveHead();

        if (pWaiter != NULL) {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("unblocking %s waiter %#x, pri=%d\n",
                        pWaiter->IsSync() ? "SYNC" : "ASYNC",
                        pWaiter->Id(),
                        pWaiter->GetPriority()
                        ));

            DPRINTF("%#x: Unblocking %s connection waiter %#x, pri=%d\n",
                    GetCurrentThreadId(),
                    pWaiter->IsSync() ? "Sync" : "Async",
                    pWaiter->Id(),
                    pWaiter->GetPriority()
                    );

            if (pWaiter->IsSync()) {
                pWaiter->Signal();
            } else {

                DWORD n = UnblockWorkItems(1, (DWORD_PTR)pWaiter, ERROR_SUCCESS);

                //INET_ASSERT(n == 1);
            }
            delete pWaiter;
        } else {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("no waiters\n"
                        ));

            DPRINTF("%#x: !!! NOT unblocking connection waiter\n",
                    GetCurrentThreadId()
                    );

        }
    } else {

        DPRINTF("%#x: !!! NOT releasing or unlimited?\n",
                GetCurrentThreadId()
                );

        DEBUG_PRINT(SESSION,
                    INFO,
                    ("bRelease = %B, UnlimitedConnections() = %B\n",
                    bRelease,
                    UnlimitedConnections()
                    ));

    }

    DEBUG_PRINT(SESSION,
                INFO,
                ("avail+k-a/limit = %d+%d/%d\n",
                AvailableConnections(),
                KeepAliveConnections(),
                ConnectionLimit()
                ));

    if (IsNewLimit()) {
        UpdateConnectionLimit();
    }

    m_Waiters.Release();

quit:
    PERF_LEAVE(ReleaseConnection);

    DEBUG_LEAVE(error);

    DPRINTF("%#x: %s: %d+%d/%d: rls %#x: %d, %d\n",
            GetCurrentThreadId(),
            GetHostName(),
            AvailableConnections(),
            KeepAliveConnections(),
            ConnectionLimit(),
            lpSocket ? lpSocket->GetSocket() : 0,
            error,
            m_Waiters.Count()
            );

    return error;
}



VOID
CServerInfo::RemoveWaiter(
    IN DWORD_PTR dwId
    )

/*++

Routine Description:

    Removes a CConnectionWaiter corresponding to the FSM

Arguments:

    dwId    - waiter id to match

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::RemoveWaiter",
                 "%#x",
                 dwId
                 ));

    if (!m_Waiters.Acquire())
        goto quit;

    CConnectionWaiter * pWaiter;
    BOOL found = FALSE;

    for (pWaiter = (CConnectionWaiter *)m_Waiters.Head();
         pWaiter != (CConnectionWaiter *)m_Waiters.Self();
         pWaiter = (CConnectionWaiter *)pWaiter->Next()) {

        if (pWaiter->Id() == dwId) {
            m_Waiters.Remove((CPriorityListEntry *)pWaiter);
            delete pWaiter;
            found = TRUE;
            break;
        }
    }
    m_Waiters.Release();

quit:
    //INET_ASSERT(found);

    DEBUG_LEAVE(0);
}

//
// private CServerInfo methods
//


ICSocket *
CServerInfo::FindKeepAliveConnection(
    IN DWORD dwSocketFlags,
    IN INTERNET_PORT nPort,
    IN LPSTR pszTunnelServer
    )

/*++

Routine Description:

    Find a keep-alive connection with the requested attributes and port number

Arguments:

    dwSocketFlags   - socket type flags (e.g. SF_SECURE)

    nPort           - port to server

    pszTunnelServer - hostname of server through SSL tunnel, or
                      NULL if not checked.

Return Value:

    ICSocket *

--*/

{
    DPRINTF("%#x: *** looking for K-A connection\n", GetCurrentThreadId());

    DEBUG_ENTER((DBG_SESSION,
                 Pointer,
                 "CServerInfo::FindKeepAliveConnection",
                 "{%q} %#x, %d",
                 GetHostName(),
                 dwSocketFlags,
                 nPort
                 ));

    ICSocket * pSocket = NULL;
    BOOL bFound = FALSE;

    //
    // don't check whether socket is non-blocking - we only really want to match
    // on secure/non-secure. Possible flags to check on are:
    //
    //  SF_ENCRYPT          - should be subsumed by SF_SECURE
    //  SF_DECRYPT          - should be subsumed by SF_SECURE
    //  SF_NON_BLOCKING     - this isn't criterion for match
    //  SF_CONNECTIONLESS   - not implemented?
    //  SF_AUTHORIZED       - must be set if authorized & in pool
    //  SF_SECURE           - opened for SSL/PCT if set
    //  SF_KEEP_ALIVE       - must be set
    //  SF_TUNNEL           - must be set if we're looking for a CONNECT tunnel to proxy
    //

    dwSocketFlags &= ~SF_NON_BLOCKING;

    if (!LockSerializedList(&m_KeepAliveList))
        goto quit;

    PLIST_ENTRY pEntry;

    for (pEntry = HeadOfSerializedList(&m_KeepAliveList);
         pEntry != (PLIST_ENTRY)SlSelf(&m_KeepAliveList);
         pEntry = pEntry->Flink) {

        pSocket = ContainingICSocket(pEntry);

        INET_ASSERT(pSocket->IsKeepAlive());

        //
        // We make sure the socket we request is the correct socket,
        //  Match() is a bit confusing and needs a bit of explaining,
        //  Match IS NOT AN EXACT MATCH, it mearly checks to make sure 
        //  that the requesting flags (dwSocketFlags) are found in the 
        //  socket flags.  So this can lead to a secure socket being returned
        //  on a non-secure open request, now realistically this doesn't happen
        //  because of the port number.  But in the case of tunnelling this may be
        //  an issue, so we add an additional check to make sure that we only
        //  get a tunneled socket to a proxy if we specifically request one.
        //

        if (pSocket->Match(dwSocketFlags)
        && (pSocket->GetPort() == nPort)
        &&  pSocket->MatchTunnelSemantics(dwSocketFlags, pszTunnelServer)
        &&  RemoveFromSerializedList(&m_KeepAliveList, pSocket->List())) {

            INET_ASSERT(!IsOnSerializedList(&m_KeepAliveList, pSocket->List()));

            bFound = TRUE;

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("returning keep-alive socket %#x\n",
                        pSocket->GetSocket()
                        ));

            DPRINTF("%#x: *** %s keep-alive connection %#x (%d/%d), wantf=%#x, gotf=%#x\n",
                    GetCurrentThreadId(),
                    GetHostName(),
                    pSocket->GetSocket(),
                    AvailableConnections(),
                    ConnectionLimit(),
                    dwSocketFlags,
                    pSocket->GetFlags()
                    );

            break;
        }
    }
    UnlockSerializedList(&m_KeepAliveList);
    if (!bFound) {
        pSocket = NULL;
    }

quit:
    DEBUG_LEAVE(pSocket);

    return pSocket;
}


BOOL
CServerInfo::KeepAliveWaiters(
    VOID
    )

/*++

Routine Description:

    Determine if any of the waiters on the list are for keep-alive connections

Arguments:

    None.

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 Bool,
                 "CServerInfo::KeepAliveWaiters",
                 NULL
                 ));

    BOOL found = FALSE;
    CConnectionWaiter * pWaiter;

    if (!m_Waiters.Acquire())
        goto quit;

    for (pWaiter = (CConnectionWaiter *)m_Waiters.Head();
         pWaiter != (CConnectionWaiter *)m_Waiters.Self();
         pWaiter = (CConnectionWaiter *)pWaiter->Next()) {

        if (pWaiter->IsKeepAlive()) {
            found = TRUE;
            break;
        }
    }
    m_Waiters.Release();

quit:
    DEBUG_LEAVE(found);

    return found;
}



VOID
CServerInfo::UpdateConnectionLimit(
    VOID
    )

/*++

Routine Description:

    Change connection limit to new limit

    Assumes: 1. Caller has acquired this object before calling this function

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::UpdateConnectionLimit",
                 "{%q: %d=>%d (%d+%d)}",
                 GetHostName(),
                 ConnectionLimit(),
                 GetNewLimit(),
                 AvailableConnections(),
                 KeepAliveConnections()
                 ));

    LONG difference = GetNewLimit() - ConnectionLimit();

    //
    // BUGBUG - only handling increases in limit for now
    //

    INET_ASSERT(difference > 0);

    if (difference > 0) {
        m_ConnectionsAvailable += difference;
    }
    m_ConnectionLimit = m_NewLimit;

    DEBUG_PRINT(SESSION,
                INFO,
                ("%q: new: %d+%d/%d\n",
                GetHostName(),
                AvailableConnections(),
                KeepAliveConnections(),
                ConnectionLimit()
                ));

    DEBUG_LEAVE(0);
}


VOID
CServerInfo::PurgeKeepAlives(
    IN DWORD dwForce
    )

/*++

Routine Description:

    Purges any timed-out keep-alive connections

Arguments:

    dwForce - force to apply when purging. Value can be:

                PKA_NO_FORCE    - only purge timed-out sockets or sockets in
                                  close-wait state (default)

                PKA_NOW         - purge all sockets

                PKA_AUTH_FAILED - purge sockets that have been marked as failing
                                  authentication

Return Value:

    None.

--*/

{
//dprintf("%#x PurgeKeepAlives(%d)\n", GetCurrentThreadId(), dwForce);
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::PurgeKeepAlives",
                 "{%q [ref=%d, k-a=%d]} %s [%d]",
                 GetHostName(),
                 ReferenceCount(),
                 KeepAliveConnections(),
                 (dwForce == PKA_NO_FORCE) ? "NO_FORCE"
                 : (dwForce == PKA_NOW) ? "NOW"
                 : (dwForce == PKA_AUTH_FAILED) ? "AUTH_FAILED"
                 : "?",
                 dwForce
                 ));

    if (IsKeepAliveListInitialized()) {

        INET_ASSERT(ReferenceCount() >= 1);

        if (!m_Waiters.Acquire())
            goto quit;

        if (!LockSerializedList(&m_KeepAliveList))
            goto Cleanup;

        PLIST_ENTRY last = (PLIST_ENTRY)SlSelf(&m_KeepAliveList);
        DWORD ticks = GetTickCountWrap();

        for (PLIST_ENTRY pEntry = HeadOfSerializedList(&m_KeepAliveList);
            pEntry != (PLIST_ENTRY)SlSelf(&m_KeepAliveList);
            pEntry = last->Flink) {

            ICSocket * pSocket = ContainingICSocket(pEntry);
            BOOL bDelete;

            if (pSocket->IsReset()) {
//dprintf("%q: socket %#x/%d CLOSE-WAIT\n", GetHostName(), pSocket->GetSocket(), pSocket->GetSourcePort());
                bDelete = TRUE;
            } else if (dwForce == PKA_NO_FORCE) {
                bDelete = pSocket->HasExpired(ticks);
            } else if (dwForce == PKA_NOW) {
                bDelete = TRUE;
            } else if (dwForce == PKA_AUTH_FAILED) {
                bDelete = pSocket->IsAuthorized();
            } else {
                INET_ASSERT(FALSE); // invalid value for dwForce!
                bDelete = TRUE;
            }
            if (bDelete) {
//dprintf("%q: socket %#x/%d. Close-Wait=%B, Expired=%B, Now=%B, Auth=%B\n",
//        GetHostName(),
//        pSocket->GetSocket(),
//        pSocket->GetSourcePort(),
//        pSocket->IsReset(),
//        pSocket->HasExpired(ticks),
//        (dwForce == PKA_NOW),
//        (dwForce == PKA_AUTH_FAILED) && pSocket->IsAuthorized()
//        );

                DEBUG_PRINT(SESSION,
                            INFO,
                            ("purging keep-alive socket %#x/%d: Close-Wait=%B, Expired=%B, Now=%B, Auth=%B\n",
                            pSocket->GetSocket(),
                            pSocket->GetSourcePort(),
                            pSocket->IsReset(),
                            pSocket->HasExpired(ticks),
                            (dwForce == PKA_NOW),
                            (dwForce == PKA_AUTH_FAILED) && pSocket->IsAuthorized()
                            ));

                if (RemoveFromSerializedList(&m_KeepAliveList, pEntry))
                {
                    BOOL bDestroyed;

                    bDestroyed = pSocket->Dereference();

                    INET_ASSERT(bDestroyed);

                    if (!UnlimitedConnections()) {
                        ++m_ConnectionsAvailable;

                        INET_ASSERT(m_ConnectionsAvailable <= m_ConnectionLimit);

                    }
                }
                else
                {
                    DEBUG_PRINT(SESSION,
                                INFO,
                                ("k-a socket %#x couldn't be removed from the list\n",
                                pSocket->GetSocket()
                                ));
                }
            } else {

                DEBUG_PRINT(SESSION,
                            INFO,
                            ("socket %#x/%d expires in %d mSec\n",
                            pSocket->GetSocket(),
                            pSocket->GetSourcePort(),
                            pSocket->GetExpiryTime() - ticks
                            ));

                last = pEntry;
            }
        }

        UnlockSerializedList(&m_KeepAliveList);
Cleanup:
        m_Waiters.Release();
    }

quit:
    DEBUG_LEAVE(0);
}

//
// friend functions
//


CServerInfo *
ContainingServerInfo(
    IN LPVOID lpAddress
    )

/*++

Routine Description:

    Returns address of CServerInfo given address of m_List

Arguments:

    lpAddress   - address of m_List

Return Value:

    CServerInfo *

--*/

{
    return CONTAINING_RECORD(lpAddress, CServerInfo, m_List);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\common\serialst.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    serialst.cxx

Abstract:

    Functions to deal with a serialized list. These are replaced by macros in
    the retail version, except for functions no longer inlined due to critsec
    wrapper

    Contents:
        [InitializeSerializedList]
        [TerminateSerializedList]
        [LockSerializedList]
        [UnlockSerializedList]
        [InsertAtHeadOfSerializedList]
        [InsertAtTailOfSerializedList]
        [RemoveFromSerializedList]
        [IsSerializedListEmpty]
        [HeadOfSerializedList]
        [TailOfSerializedList]
        [CheckEntryOnSerializedList]
        [(CheckEntryOnList)]
        SlDequeueHead
        SlDequeueTail
        IsOnSerializedList

Author:

    Richard L Firth (rfirth) 16-Feb-1995

Environment:

    Win-32 user level

Revision History:

    16-Feb-1995 rfirth
        Created

--*/

#include <wininetp.h>

#if INET_DEBUG

//
// manifests
//

#define SERIALIZED_LIST_SIGNATURE   'tslS'

//
// private prototypes
//

PRIVATE
DEBUG_FUNCTION
BOOL
CheckEntryOnList(
    IN PLIST_ENTRY List,
    IN PLIST_ENTRY Entry,
    IN BOOL ExpectedResult
    );

//
// data
//

BOOL fCheckEntryOnList = FALSE;
BOOL ReportCheckEntryOnListErrors = FALSE;

//
// functions
//


DEBUG_FUNCTION
BOOL
InitializeSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    initializes a serialized list

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST

Return Value:

    None.

--*/

{
    INET_ASSERT(SerializedList != NULL);

    SerializedList->Signature = SERIALIZED_LIST_SIGNATURE;
    SerializedList->LockCount = 0;

    INITIALIZE_RESOURCE_INFO(&SerializedList->ResourceInfo);

    InitializeListHead(&SerializedList->List);
    SerializedList->ElementCount = 0;
    return SerializedList->Lock.Init();
}


DEBUG_FUNCTION
VOID
TerminateSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Undoes InitializeSerializeList

Arguments:

    SerializedList  - pointer to serialized list to terminate

Return Value:

    None.

--*/

{
    INET_ASSERT(SerializedList != NULL);
    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);
    INET_ASSERT(SerializedList->ElementCount == 0);

    if (SerializedList->ElementCount != 0) {

        DEBUG_PRINT(SERIALST,
                    ERROR,
                    ("list @ %#x has %d elements, first is %#x\n",
                    SerializedList,
                    SerializedList->ElementCount,
                    SerializedList->List.Flink
                    ));

    } else {

        INET_ASSERT(IsListEmpty(&SerializedList->List));

    }
    SerializedList->Lock.FreeLock();
}


DEBUG_FUNCTION
BOOL
LockSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Acquires a serialized list locks

Arguments:

    SerializedList  - SERIALIZED_LIST to lock

Return Value:

    Success if able to acquire a lock.

--*/

{
    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);
    INET_ASSERT(SerializedList->LockCount >= 0);

    if ((!SerializedList->Lock.IsInitialized() && !SerializedList->Lock.Init()) ||
         !SerializedList->Lock.Lock())
    {
        return FALSE;
    }
    else
    {
        if (SerializedList->LockCount != 0)
        {
            INET_ASSERT(SerializedList->ResourceInfo.Tid == GetCurrentThreadId());
        }
    }
    ++SerializedList->LockCount;
    SerializedList->ResourceInfo.Tid = GetCurrentThreadId();

    return TRUE;
}


DEBUG_FUNCTION
VOID
UnlockSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Releases a serialized list lock

Arguments:

    SerializedList  - SERIALIZED_LIST to unlock

Return Value:

    None.

--*/

{
    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);
    INET_ASSERT(SerializedList->ResourceInfo.Tid == GetCurrentThreadId());
    INET_ASSERT(SerializedList->LockCount > 0);

    --SerializedList->LockCount;
    SerializedList->Lock.Unlock();
}


DEBUG_FUNCTION
BOOL
InsertAtHeadOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    Adds an item to the head of a serialized list

Arguments:

    SerializedList  - SERIALIZED_LIST to update

    Entry           - thing to update it with

Return Value:

    FALSE - only if unable to acquire the lock

--*/

{
    INET_ASSERT(Entry != &SerializedList->List);

    if (LockSerializedList(SerializedList))
    {
        if (fCheckEntryOnList)
        {
            CheckEntryOnList(&SerializedList->List, Entry, FALSE);
        }
        InsertHeadList(&SerializedList->List, Entry);
        ++SerializedList->ElementCount;

        INET_ASSERT(SerializedList->ElementCount > 0);

        UnlockSerializedList(SerializedList);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


DEBUG_FUNCTION
BOOL
InsertAtTailOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    Adds an item to the head of a serialized list

Arguments:

    SerializedList  - SERIALIZED_LIST to update

    Entry           - thing to update it with

Return Value:

    FALSE - only if not enough memory was available to insert an item.

--*/

{
    INET_ASSERT(Entry != &SerializedList->List);

    if (LockSerializedList(SerializedList))
    {
        if (fCheckEntryOnList) {
            CheckEntryOnList(&SerializedList->List, Entry, FALSE);
        }
        InsertTailList(&SerializedList->List, Entry);
        ++SerializedList->ElementCount;

        INET_ASSERT(SerializedList->ElementCount > 0);

        UnlockSerializedList(SerializedList);
        return TRUE;
    }
    return FALSE;
}


BOOL
DEBUG_FUNCTION
RemoveFromSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    Removes the entry from a serialized list

Arguments:

    SerializedList  - SERIALIZED_LIST to remove entry from

    Entry           - pointer to entry to remove

Return Value:

    FALSE if unable sycnhronize access to the list due to low-memory.

--*/

{
    INET_ASSERT((Entry->Flink != NULL) && (Entry->Blink != NULL));

    if (LockSerializedList(SerializedList))
    {
        if (fCheckEntryOnList)
        {
            CheckEntryOnList(&SerializedList->List, Entry, TRUE);
        }

        INET_ASSERT(SerializedList->ElementCount > 0);

        RemoveEntryList(Entry);
        --SerializedList->ElementCount;
        Entry->Flink = NULL;
        Entry->Blink = NULL;
        UnlockSerializedList(SerializedList);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


DEBUG_FUNCTION
BOOL
IsSerializedListEmpty(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Checks if a serialized list contains any elements

Arguments:

    SerializedList  - pointer to list to check

Return Value:

    BOOL

--*/

{
    // For simplicity, don't worry about returning additional status.
    // Due to this always being tied to additional manipulation,
    // the lock has already been acquired in all current cases.
    if (!LockSerializedList(SerializedList))
        return TRUE;

    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);

    BOOL empty;

    if (IsListEmpty(&SerializedList->List)) {

        INET_ASSERT(SerializedList->ElementCount == 0);

        empty = TRUE;
    } else {

        INET_ASSERT(SerializedList->ElementCount != 0);

        empty = FALSE;
    }

    UnlockSerializedList(SerializedList);

    return empty;
}


DEBUG_FUNCTION
PLIST_ENTRY
HeadOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Returns the element at the tail of the list, without taking the lock

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST

Return Value:

    PLIST_ENTRY
        pointer to element at tail of list

--*/

{
    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);

    return SerializedList->List.Flink;
}


DEBUG_FUNCTION
PLIST_ENTRY
TailOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Returns the element at the tail of the list, without taking the lock

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST

Return Value:

    PLIST_ENTRY
        pointer to element at tail of list

--*/

{
    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);

    return SerializedList->List.Blink;
}


DEBUG_FUNCTION
BOOL
CheckEntryOnSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry,
    IN BOOL ExpectedResult
    )

/*++

Routine Description:

    Checks an entry exists (or doesn't exist) on a list

Arguments:

    SerializedList  - pointer to serialized list

    Entry           - pointer to entry

    ExpectedResult  - TRUE if expected on list, else FALSE

Return Value:

    BOOL
        TRUE    - expected result

        FALSE   - unexpected result

--*/

{
    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);

    if (!LockSerializedList(SerializedList))
        return FALSE;

    BOOL result;

    __try {
        result = CheckEntryOnList(&SerializedList->List, Entry, ExpectedResult);
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        DEBUG_PRINT(SERIALST,
                    FATAL,
                    ("List @ %#x (%d elements) is bad\n",
                    SerializedList,
                    SerializedList->ElementCount
                    ));

        result = FALSE;
    }
    ENDEXCEPT
    UnlockSerializedList(SerializedList);

    return result;
}


PRIVATE
DEBUG_FUNCTION
BOOL
CheckEntryOnList(
    IN PLIST_ENTRY List,
    IN PLIST_ENTRY Entry,
    IN BOOL ExpectedResult
    )
{
    BOOLEAN found = FALSE;
    PLIST_ENTRY p;

    if (!IsListEmpty(List)) {
        for (p = List->Flink; p != List; p = p->Flink) {
            if (p == Entry) {
                found = TRUE;
                break;
            }
        }
    }
    if (found != ExpectedResult) {
        if (ReportCheckEntryOnListErrors) {

            LPSTR description;

            description = found
                        ? "Entry %#x already on list %#x\n"
                        : "Entry %#x not found on list %#x\n"
                        ;

            DEBUG_PRINT(SERIALST,
                        ERROR,
                        (description,
                        Entry,
                        List
                        ));

            DEBUG_BREAK(SERIALST);

        }
        return FALSE;
    }
    return TRUE;
}

#else  // else !INET_DEBUG

BOOL
InitializeSerializedList(LPSERIALIZED_LIST pList)
{
    InitializeListHead(&(pList)->List);
    (pList)->ElementCount = 0;
    return (pList->Lock).Init();
}


BOOL
InsertAtHeadOfSerializedList(LPSERIALIZED_LIST list, PLIST_ENTRY entry)
{
    if (LockSerializedList(list))
    {
        InsertHeadList(&(list)->List, entry);
        ++(list)->ElementCount;
        UnlockSerializedList(list);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


BOOL
InsertAtTailOfSerializedList(LPSERIALIZED_LIST list, PLIST_ENTRY entry)
{
    if (LockSerializedList(list))
    {
        InsertTailList(&(list)->List, entry);
        ++(list)->ElementCount;
        UnlockSerializedList(list);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


BOOL
RemoveFromSerializedList(LPSERIALIZED_LIST list, PLIST_ENTRY entry)
{
    if (LockSerializedList(list))
    {
        RemoveEntryList(entry);
        --(list)->ElementCount;
        UnlockSerializedList(list);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

#endif // INET_DEBUG

//
// functions that are always functions
//


LPVOID
SlDequeueHead(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Dequeues the element at the head of the queue and returns its address or
    NULL if the queue is empty

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST to dequeue from

Return Value:

    LPVOID

--*/

{
    LPVOID entry = NULL;

    if (!IsSerializedListEmpty(SerializedList)) {
        if (LockSerializedList(SerializedList)) {
            if (!IsSerializedListEmpty(SerializedList)) {
                entry = (LPVOID)HeadOfSerializedList(SerializedList);
                if (!RemoveFromSerializedList(SerializedList, (PLIST_ENTRY)entry))
                    entry = NULL;
            }
            UnlockSerializedList(SerializedList);
        }
    }

    return entry;
}


LPVOID
SlDequeueTail(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Dequeues the element at the tail of the queue and returns its address or
    NULL if the queue is empty

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST to dequeue from

Return Value:

    LPVOID

--*/

{
    LPVOID entry = NULL;

    if (!IsSerializedListEmpty(SerializedList)) {
        if (LockSerializedList(SerializedList)) {
            if (!IsSerializedListEmpty(SerializedList)) {
                entry = (LPVOID)TailOfSerializedList(SerializedList);
                if (!RemoveFromSerializedList(SerializedList, (PLIST_ENTRY)entry))
                    entry = NULL;
            }
            UnlockSerializedList(SerializedList);
        }
    } else {
        entry = NULL;
    }
    return entry;
}


BOOL
IsOnSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    Checks if an entry is on a serialized list. Useful to call before
    RemoveFromSerializedList() if multiple threads can remove the element

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST

    Entry           - pointer to element to check

Return Value:

    BOOL
        TRUE    - Entry is on SerializedList

        FALSE   -   "    " not on     "

--*/

{
    BOOL onList = FALSE;
    LPVOID entry;

    if (!IsSerializedListEmpty(SerializedList)) {
        if (LockSerializedList(SerializedList)) {
            if (!IsSerializedListEmpty(SerializedList)) {
                for (PLIST_ENTRY entry = HeadOfSerializedList(SerializedList);
                    entry != (PLIST_ENTRY)SlSelf(SerializedList);
                    entry = entry->Flink) {

                    if (entry == Entry) {
                       onList = TRUE;
                       break;
                    }
                }
            }
            UnlockSerializedList(SerializedList);
        }
    }
    return onList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\common\util.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    util.cxx

Abstract:

    Contains utility functions

    Contents:
        new
        delete
        NewString
        CatString
        ResizeBuffer
        _memrchr
        strnistr
        PrivateStrChr
        PlatformType
        PlatformSupport
        GetTimeoutValue
        ProbeReadBuffer
        ProbeWriteBuffer
        ProbeAndSetDword
        ProbeString
        LoadDllEntryPoints
        UnloadDllEntryPoints
        MapInternetError
        CalculateHashValue
        GetCurrentGmtTime
        GetFileExtensionFromUrl
        FTtoString
        PrintFileTimeInInternetFormat
        CertHashToStr
        ConvertSecurityInfoIntoCertInfoStruct
        UnicodeToUtf8
        CountUnicodeToUtf8
        ConvertUnicodeToUtf8
        StringContainsHighAnsi

Author:

    Richard L Firth (rfirth) 31-Oct-1994

Revision History:

    31-Oct-1994 rfirth
        Created

--*/

#include <wininetp.h>

#if !defined(PAGE_SIZE)
#define PAGE_SIZE   4096
#endif
#define DEFAULT_MAX_EXTENSION_LENGTH    8

//
// private prototypes
//


#ifndef WINHTTP_FOR_MSXML
//
// functions
//
void * __cdecl operator new(size_t Size) {
    return (void *)ALLOCATE_FIXED_MEMORY((UINT)Size);
}

void __cdecl operator delete(void * Pointer) {
    FREE_MEMORY((HLOCAL)Pointer);
}
#endif //!WINHTTP_FOR_MSXML

#ifdef USE_ROCKALL
#ifdef New
#undef New


#define SIZE_DIFF 1

#if INET_DEBUG
#   include <DebugHeap.hpp>
#   define ROCKALL_HEAP    DEBUG_HEAP
#else
#   include <SmpHeap.hpp>
#   define ROCKALL_HEAP    SMP_HEAP
#endif

ROCKALL_HEAP * s_pRockAllHeap;

BYTE           s_RockAllHeapStaticBuffer[sizeof(ROCKALL_HEAP)];


void INITIALIZE_MEMORY_MANAGER()
{
    s_pRockAllHeap = (ROCKALL_HEAP *) s_RockAllHeapStaticBuffer;
    s_pRockAllHeap->ROCKALL_HEAP::ROCKALL_HEAP();
}

void TERMINATE_MEMORY_MANAGER(BOOL bReport)
{
    if (s_pRockAllHeap)
    {
#if INET_DEBUG
        if (bReport)
        {
            s_pRockAllHeap->HeapLeaks();
        }
#endif
        s_pRockAllHeap->ROCKALL_HEAP::~ROCKALL_HEAP();
        s_pRockAllHeap = NULL;
        ZeroMemory(s_RockAllHeapStaticBuffer, sizeof(s_RockAllHeapStaticBuffer));
    }
}

void *
ALLOCATOR(int Flags, int Size)
{
    INET_ASSERT(s_pRockAllHeap && "Heap not initialized!");
    return s_pRockAllHeap->New(Size, NULL, ((Flags & LMEM_ZEROINIT) ? true : false));
}

void *
DEALLOCATOR(void * hLocal)
{
    INET_ASSERT(s_pRockAllHeap && "Heap not initialized!");
    DWORD error = GetLastError();
    void * p = (s_pRockAllHeap->Delete(hLocal) ? NULL : hLocal);
    SetLastError(error);
    return p;
}

void *
REALLOCATOR(void * hLocal, int Size, int Flags)
{
    INET_ASSERT(s_pRockAllHeap && "Heap not initialized!");
    return s_pRockAllHeap->Resize(hLocal, 
                    Size, 
                    ((Flags & LMEM_MOVEABLE) ? SIZE_DIFF : 0), 
                    NULL, 
                    false, 
                    ((Flags & LMEM_ZEROINIT) ? true : false));
}

int
MEMORYSIZER(void * hLocal)
{
    int Size;
    INET_ASSERT(s_pRockAllHeap && "Heap not initialized!");
    s_pRockAllHeap->Details(hLocal, &Size);
    return Size;
}
#endif
#endif

LPSTR
NewString(
    IN LPCSTR lpszIn,
    IN DWORD dwLen
    )

/*++

Routine Description:

    kind of version of strdup() but using LocalAlloc to allocate memory

Arguments:

    String  - pointer to string to make copy of

Return Value:

    LPSTR
        Success - pointer to duplicated string
        Failure - NULL

--*/

{
    int len = (dwLen ? dwLen : strlen(lpszIn));
    LPSTR lpszOut;

    if (lpszOut = (LPSTR)ALLOCATE_FIXED_MEMORY(len+1)) {
        memcpy(lpszOut, lpszIn, len);
        *(lpszOut + len) = '\0';
    }
    return lpszOut;
}

LPWSTR
NewStringW(
    IN LPCWSTR lpszIn,
    IN DWORD dwLen
    )

/*++

Routine Description:

    kind of version of strdup() but using LocalAlloc to allocate memory

Arguments:

    String  - pointer to string to make copy of

Return Value:

    LPSTR
        Success - pointer to duplicated string
        Failure - NULL

--*/

{
    int len = (dwLen ? dwLen : lstrlenW(lpszIn));
    LPWSTR lpszOut;

    if (lpszOut = (LPWSTR)ALLOCATE_FIXED_MEMORY((sizeof(WCHAR)*(len+1)))) {
        memcpy(lpszOut, lpszIn, len*sizeof(WCHAR));
        *(lpszOut + len) = L'\0';
    }
    return lpszOut;
}

/*++

Routine Description:

    kind of version of strcat() but using LocalAlloc to allocate memory

Arguments:

    strings to concatenate

Return Value:

    LPSTR
        Success - pointer to duplicated string
        Failure - NULL

--*/

LPSTR
CatString (
    IN LPCSTR lpszLeft,
    IN LPCSTR lpszRight
    )
{
    int cbLeft  = strlen(lpszLeft);
    int cbRight = strlen(lpszRight) + 1; // include null termination
    LPSTR lpszOut;

    if (lpszOut = (LPSTR) ALLOCATE_FIXED_MEMORY (cbLeft + cbRight)) {
        memcpy (lpszOut, lpszLeft, cbLeft);
        memcpy (lpszOut + cbLeft, lpszRight, cbRight);
    }
    return lpszOut;
}



HLOCAL
ResizeBuffer(
    IN HLOCAL BufferHandle,
    IN DWORD Size,
    IN BOOL Moveable
    )

/*++

Routine Description:

    Allocate, reallocate or free a buffer. If the buffer is moveable memory
    then it must be unlocked. If reallocating, the buffer can be grown or
    shrunk, depending on the current and required sizes

    Caveat Programmer:

    Regardless of whether a pre-existing buffer is moveable or fixed memory,
    it will be reallocated with the LMEM_MOVEABLE flag, possibly causing the
    output pointer to be different from the pre-existing pointer

Arguments:

    BufferHandle    - current handle of memory buffer. If NULL, a buffer will
                      be allocated

    Size            - size of buffer to allocate (or shrink to). If 0, the
                      buffer will be freed

    Moveable        - if TRUE and allocating memory then allocates a moveable
                      memory buffer, else fixed

Return Value:

    HLOCAL
        Success - handle of moveable memory buffer

        Failure - NULL;

--*/

{
    INET_ASSERT(!Moveable);

    if (BufferHandle == NULL) {

        //
        // don't allocate anything if no size - LocalAlloc() will return pointer
        // to memory object marked as discarded if we request a zero-length
        // moveable buffer. But I know that if Size is also 0, I don't want a
        // buffer at all, discarded or otherwise
        //

        if (Size != 0) {
            BufferHandle = ALLOCATE_MEMORY(Moveable ? LMEM_MOVEABLE : LMEM_FIXED, Size);
        }
    } else if (Size == 0) {
        BufferHandle = FREE_MEMORY(BufferHandle);

        INET_ASSERT(BufferHandle == NULL);

    } else {
        BufferHandle = REALLOCATE_MEMORY(BufferHandle, Size, LMEM_MOVEABLE);
    }
    return BufferHandle;
}


LPSTR
_memrchr(
    IN LPSTR lpString,
    IN CHAR cTarget,
    IN INT iLength
    )

/*++

Routine Description:

    Reverse find character in string

Arguments:

    lpString    - pointer to string in which to locate character

    cTarget     - target character to find

    iLength     - length of string

Return Value:

    LPSTR   - pointer to located character or NULL

--*/

{
    for (--iLength; (iLength >= 0) && (lpString[iLength] != cTarget); --iLength) {

        //
        // empty loop
        //

    }
    return (iLength < 0) ? NULL : &lpString[iLength];
}


LPSTR
strnistr(
    IN LPSTR str1,
    IN LPSTR str2,
    IN DWORD Length
    )

/*++

Routine Description:

    Case-insensitive search for substring

Arguments:

    str1    - string to search in

    str2    - substring to find

    Length  - of str1

Return Value:

    LPSTR   - pointer to located str2 in str1 or NULL

--*/

{
    if (!*str2) {
        return str1;
    }

    for (LPSTR cp = str1; *cp && Length; ++cp, --Length) {

        LPSTR s1 = cp;
        LPSTR s2 = str2;
        DWORD l2 = Length;

        while (*s1 && *s2 && l2 && (toupper(*s1) == toupper(*s2))) {
            ++s1;
            ++s2;
            --l2;
        }

        if (!*s2) {
            return cp;
        }

        if (!l2) {
            break;
        }
    }

    return NULL;
}

LPSTR
FASTCALL
PrivateStrChr(
    IN LPCSTR lpStart,
    IN WORD wMatch
    )
/*++

Routine Description:

    Find first occurrence of character in string

    Private implimentation of StrChrA, this code is based on
     a code snipet from ShlWapi, but by placing it here,
     we can remove the extra NLS support that was needed
     in SHLWAPI.   This piece of code is over twice as fast
     as the call into SHLWAPI.

Arguments:

    lpStart - points to start of null terminated string

    wMatch  - the character to match

Return Value:

    LPSTR   - ptr to the first occurrence of ch in str, NULL if not found.

--*/
{
    for ( ; *lpStart; lpStart++)
    {
        if ((BYTE)*lpStart == LOBYTE(wMatch)) {
            return((LPSTR)lpStart);
        }
    }

    return (NULL);
}


DWORD
GetTickCountWrap()
{
#ifdef DEBUG_GETTICKCOUNT
    static BOOL fInit = FALSE;
    static DWORD dwDelta = 0;
    static DWORD dwBasis = 0;

    if (!fInit)
    {
        HKEY clientKey;
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"),
                                 0, // reserved
                                 KEY_QUERY_VALUE,
                                 &clientKey))
        {
            DWORD dwSize = sizeof(dwDelta);
            RegQueryValueEx(clientKey, "RollOverDelta", NULL, NULL, (LPBYTE)&dwDelta, &dwSize);
        }
        dwBasis = GetTickCount();
        fInit = TRUE;
    }
    DWORD dwResult = GetTickCount() - dwBasis + dwDelta;
    return dwResult;
#else
    return GetTickCount();
#endif
}


DWORD
PlatformType(
    IN OUT LPDWORD lpdwVersion5os
    )

/*++

Routine Description:

    Returns the platform type based on the operating system information. We use
    our own platform types

Arguments:

    lpdwVersion5os - optional pointer to value, set to TRUE if we on NT 5

Return Value:

    DWORD
        Failure - PLATFORM_TYPE_UNKNOWN
                    either GetVersionEx() failed, or we are running on an
                    unrecognized operating system

        Success - PLATFORM_TYPE_WIN95
                    The world's favourite desktop O/S

                  PLATFORM_TYPE_WINNT
                    The world's best O/S on top of anything

--*/

{
#ifndef UNIX
    OSVERSIONINFO versionInfo;

    *lpdwVersion5os = FALSE;

    versionInfo.dwOSVersionInfoSize = sizeof(versionInfo);
    if (GetVersionEx(&versionInfo)) {
        switch (versionInfo.dwPlatformId) {
        case VER_PLATFORM_WIN32_WINDOWS:
            if(versionInfo.dwMinorVersion >= 90) {
                GlobalPlatformMillennium = TRUE;
            }
            return PLATFORM_TYPE_WIN95;

        case VER_PLATFORM_WIN32_NT:

            if ( lpdwVersion5os && 
                versionInfo.dwMajorVersion >= 5 ) {                
                *lpdwVersion5os = TRUE;
            }            
            return PLATFORM_TYPE_WINNT;

        }

    }
    return PLATFORM_TYPE_UNKNOWN;
#else
    return PLATFORM_TYPE_UNIX;
#endif /* UNIX */
}

//
//DWORD
//PlatformSupport(
//    VOID
//    )
//
///*++
//
//Routine Description:
//
//    Returns a bitmap of capabilities supported by this operating system
//
//Arguments:
//
//    None.
//
//Return Value:
//
//    DWORD
//
//--*/
//
//{
//    switch (PlatformType()) {
//    case PLATFORM_TYPE_WINNT:
//        return PLATFORM_SUPPORTS_UNICODE;
//    }
//    return 0;
//}


DWORD
GetTimeoutValue(
    IN DWORD TimeoutOption
    )

/*++

Routine Description:

    Gets a timeout value. The timeout is retrieved from the current handle. If
    it is not available in the current handle then the parent handle is checked
    (actually the current handle is derived from the parent, so this doesn't
    really do anything). If the value is still not available, then the global
    default is used

Arguments:

    TimeoutOption   - WINHTTP_OPTION_ value used to specify the timeout value

Return Value:

    DWORD
        Requested timeout value

--*/

{
    HINTERNET hInternet;
    DWORD timeout;
    DWORD error;
    HINTERNET_HANDLE_TYPE handleType;
    
    hInternet = InternetGetMappedObjectHandle();
    
    if (hInternet) 
    {
        error = ((HANDLE_OBJECT*)hInternet)->IsValid(TypeWildHandle);
        
        if (error == ERROR_SUCCESS) 
        {
            error = RGetHandleType(hInternet, &handleType);

            if (error == ERROR_SUCCESS)
            {
                switch(handleType)
                {
                case TypeHttpRequestHandle:
                    //no error possible here
                    timeout = ((HTTP_REQUEST_HANDLE_OBJECT*)hInternet)->GetTimeout(TimeoutOption);
                    break;
                case TypeHttpConnectHandle:
                    //no timeouts on this handle
                    //go up to parent
                    hInternet = (HINTERNET)GetRootHandle((INTERNET_HANDLE_OBJECT *)hInternet);
                    //fall through
                case TypeInternetHandle:            
                    //either there was an error in allocing memory for OPTIONAL_PARAMS struct
                    //or the option may not have been set
                    //in either case, force the global timeout choice by setting an error (not propagated)
                    if (! ((INTERNET_HANDLE_OBJECT*)hInternet)->GetTimeout(TimeoutOption, &timeout) )
                        error = E_FAIL;
                    break;
                default:
                    error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
                    break;
                }
            }
        }
    }
    
    if ( !hInternet || (error != ERROR_SUCCESS)) 
    {
    //should this ever happen?
        INET_ASSERT(FALSE);
        switch (TimeoutOption) {
        case WINHTTP_OPTION_RESOLVE_TIMEOUT:
            timeout = GlobalResolveTimeout;
            break;

        case WINHTTP_OPTION_CONNECT_TIMEOUT:
            timeout = GlobalConnectTimeout;
            break;

        case WINHTTP_OPTION_CONNECT_RETRIES:
            timeout = GlobalConnectRetries;
            break;

        case WINHTTP_OPTION_SEND_TIMEOUT:
            timeout = GlobalSendTimeout;
            break;

        case WINHTTP_OPTION_RECEIVE_TIMEOUT:
            timeout = GlobalReceiveTimeout;
            break;
        default:
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
            timeout = 0;
            break;
        }
    }
    return timeout;
}


DWORD
ProbeReadBuffer(
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Probes a buffer for readability. Used as part of API parameter validation,
    this function tests the first and last locations in a buffer. This is not
    as strict as the IsBadXPtr() Windows APIs, but it means we don't have to
    test every location in the buffer

Arguments:

    lpBuffer        - pointer to buffer to test

    dwBufferLength  - length of buffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DWORD error;

    //
    // the buffer can be NULL if the probe length is 0. Otherwise, its an error
    //

    if (lpBuffer == NULL) {
        error = (dwBufferLength == 0) ? ERROR_SUCCESS : ERROR_INVALID_PARAMETER;
    } else if (dwBufferLength != 0) {
        __try {

            LPBYTE p;
            LPBYTE end;
            volatile BYTE b;

            p = (LPBYTE)lpBuffer;
            end = p + dwBufferLength - 1;
            b = *end;

            //
            // visit every page in the buffer - it doesn't matter that we may
            // test a character in the middle of a page
            //

            for (; p < end; p += PAGE_SIZE) {
                b = *p;
            }
            error = ERROR_SUCCESS;
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            error = ERROR_INVALID_PARAMETER;
        }
        ENDEXCEPT
    } else {

        //
        // zero-length buffer
        //

        error = ERROR_INVALID_PARAMETER;
    }

    return error;
}


DWORD
ProbeWriteBuffer(
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Probes a buffer for writeability. Used as part of API parameter validation,
    this function tests the first and last locations in a buffer. This is not
    as strict as the IsBadXPtr() Windows APIs, but it means we don't have to
    test every location in the buffer

Arguments:

    lpBuffer        - pointer to buffer to test

    dwBufferLength  - length of buffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DWORD error;

    //
    // the buffer can be NULL if the probe length is 0. Otherwise, its an error
    //

    if (lpBuffer == NULL) {
        error = (dwBufferLength == 0) ? ERROR_SUCCESS : ERROR_INVALID_PARAMETER;
    } else if (dwBufferLength != 0) {
        __try {

            LPBYTE p;
            LPBYTE end;
            volatile BYTE b;

            p = (LPBYTE)lpBuffer;
            end = p + dwBufferLength - 1;
            b = *end;
            *end = b;

            //
            // visit every page in the buffer - it doesn't matter that we may
            // test a character in the middle of a page
            //

            for (; p < end; p += PAGE_SIZE) {
                b = *p;
                *p = b;
            }
            error = ERROR_SUCCESS;
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            error = ERROR_INVALID_PARAMETER;
        }
        ENDEXCEPT
    } else {

        //
        // zero-length buffer
        //

        error = ERROR_SUCCESS;
    }

    return error;
}


DWORD
ProbeAndSetDword(
    IN LPDWORD lpDword,
    IN DWORD dwValue
    )

/*++

Routine Description:

    Probes a single DWORD buffer for writeability, and as a side-effect sets it
    to a default value. Used as part of API parameter validation

Arguments:

    lpDword - pointer to DWORD buffer to test

    dwValue - default value to set

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DWORD error;

    __try {
        *lpDword = dwValue;
        error = ERROR_SUCCESS;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        error = ERROR_INVALID_PARAMETER;
    }
    ENDEXCEPT
    return error;
}


DWORD
ProbeString(
    IN LPSTR lpString,
    OUT LPDWORD lpdwStringLength
    )

/*++

Routine Description:

    Probes a string buffer for readability, and returns the length of the string

Arguments:

    lpString            - pointer to string to check

    lpdwStringLength    - returned length of string

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DWORD error;
    DWORD length;

    //
    // initialize string length and return code
    //

    length = 0;
    error = ERROR_SUCCESS;

    //
    // the buffer can be NULL
    //

    if (lpString != NULL) {
        __try {

            //
            // unfortunately, for a string, we have to visit every location in
            // the buffer to find the terminator
            //

            while (*lpString != '\0') {
                ++length;
                ++lpString;
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            error = ERROR_INVALID_PARAMETER;
        }
        ENDEXCEPT
    }

    *lpdwStringLength = length;

    return error;
}

DWORD
ProbeStringW(
    IN LPWSTR lpString,
    OUT LPDWORD lpdwStringLength
    )

/*++

Routine Description:

    Probes a wide string buffer for readability, and returns the length of the string

Arguments:

    lpString            - pointer to string to check

    lpdwStringLength    - returned length of string

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DWORD error;
    DWORD length;

    //
    // initialize string length and return code
    //

    length = 0;
    error = ERROR_SUCCESS;

    //
    // the buffer can be NULL
    //

    if (lpString != NULL) {
        __try {

            //
            // unfortunately, for a string, we have to visit every location in
            // the buffer to find the terminator
            //

            while (*lpString != '\0') {
                ++length;
                ++lpString;
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            error = ERROR_INVALID_PARAMETER;
        }
        ENDEXCEPT
    }

    *lpdwStringLength = length;

    return error;
}


DWORD
LoadDllEntryPoints(
    IN OUT LPDLL_INFO lpDllInfo,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Dynamically loads a DLL and the entry points described in lpDllEntryPoints

    Assumes:    1. Any thread serialization taken care of by caller

                2. Module handle, entry point addresses and reference count
                   already set to 0 if this is first time the DLL_INFO is
                   being used to load the DLL

Arguments:

    lpDllInfo   - pointer to DLL_INFO structure containing all info about DLL
                  and entry points to load

    dwFlags     - flags controlling how this function operates:

                    LDEP_PARTIAL_LOAD_OK
                        - not fatal if we can't load all entry points

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - Win32 error

--*/

{
    DEBUG_ENTER((DBG_UTIL,
                 Dword,
                 "LoadDllEntryPoints",
                 "%x [%q, %d], %#x",
                 lpDllInfo,
                 lpDllInfo->lpszDllName,
                 lpDllInfo->dwNumberOfEntryPoints,
                 dwFlags
                 ));

    DWORD error = ERROR_SUCCESS;

    if (lpDllInfo->hModule == NULL) {

        DWORD dwMode = SetErrorMode(SEM_FAILCRITICALERRORS);
        HMODULE hDll = LoadLibrary(lpDllInfo->lpszDllName);

        if (hDll != NULL) {
            lpDllInfo->hModule = hDll;
            lpDllInfo->LoadCount = 1;

            for (DWORD i = 0; i < lpDllInfo->dwNumberOfEntryPoints; ++i) {

                FARPROC proc = GetProcAddress(
                                    hDll,
                                    lpDllInfo->lpEntryPoints[i].lpszProcedureName
                                    );

                *lpDllInfo->lpEntryPoints[i].lplpfnProcedure = proc;
                if ((proc == NULL) && !(dwFlags & LDEP_PARTIAL_LOAD_OK)) {
                    error = GetLastError();
                    UnloadDllEntryPoints(lpDllInfo, TRUE);
                    break;
                }
            }
        } else {
            error = GetLastError();
        }
        SetErrorMode(dwMode);
    } else {

        DEBUG_PRINT(UTIL,
                    INFO,
                    ("info for %q already loaded\n",
                    lpDllInfo->lpszDllName
                    ));

        InterlockedIncrement(&lpDllInfo->LoadCount);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
UnloadDllEntryPoints(
    IN OUT LPDLL_INFO lpDllInfo,
    IN BOOL bForce
    )

/*++

Routine Description:

    Undoes the work of LoadDllEntryPoints()

    Assumes:    1. Any thread serialization taken care of by caller

Arguments:

    lpDllInfo   - pointer to DLL_INFO structure containing all info about DLL
                  and (loaded) entry points

    bForce      - TRUE if the DLL will be unloaded irrespective of the usage
                  count

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - Win32 error

--*/

{
    DEBUG_ENTER((DBG_UTIL,
                Dword,
                "UnloadDllEntryPoints",
                "%x [%q, %d], %B",
                lpDllInfo,
                lpDllInfo->lpszDllName,
                lpDllInfo->dwNumberOfEntryPoints,
                bForce
                ));

    DWORD error = ERROR_SUCCESS;

    if (bForce) {
        lpDllInfo->LoadCount = 0;
    } else if (InterlockedDecrement(&lpDllInfo->LoadCount) == 0) {
        bForce = TRUE;
    }
    if (bForce && (lpDllInfo->hModule != NULL)) {
        if (!FreeLibrary(lpDllInfo->hModule)) {
            error = GetLastError();
        }

        //
        // even if FreeLibrary() failed we clear out the load info
        //

        lpDllInfo->hModule = NULL;
        for (DWORD i = 0; i < lpDllInfo->dwNumberOfEntryPoints; ++i) {
            *lpDllInfo->lpEntryPoints[i].lplpfnProcedure = NULL;
        }
    }

    DEBUG_LEAVE(error);

    return error;
}

#ifndef CERT_E_WRONG_USAGE
#   define CERT_E_WRONG_USAGE              _HRESULT_TYPEDEF_(0x800B0110)
#endif


DWORD
MapInternetError(
    IN DWORD dwErrorCode,
    IN LPDWORD lpdwStatus /* = NULL */
    )

/*++

Routine Description:

    Maps a winsock/RPC/transport error into a more user-friendly WinInet error,
    and stores the original error in the per-thread context so that the app can
    retrieve it if it really cares

    N.B. We should no longer be receiving winsock errors directly at the WinInet
    interface. They are available via InternetGetLastResponseInfo()

Arguments:

    dwErrorCode - original (winsock) error code to map

Return Value:

    DWORD
        Mapped error code, or the orignal error if its not one that we handle

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD dwStatus = 0;

    DEBUG_ENTER((DBG_UTIL,
                Dword,
                "MapInternetError",
                "%#x [%s]",
                dwErrorCode,
                InternetMapError(dwErrorCode)
                ));

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo) {
        lpThreadInfo->dwMappedErrorCode = dwErrorCode;
    }

    switch (dwErrorCode) {

    case SEC_E_INSUFFICIENT_MEMORY        :
        dwErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        break;

    case SEC_E_INVALID_HANDLE             :
    case SEC_E_UNSUPPORTED_FUNCTION       :
    case SEC_E_TARGET_UNKNOWN             :
    case SEC_E_INTERNAL_ERROR             :
    case SEC_E_SECPKG_NOT_FOUND           :
    case SEC_E_NOT_OWNER                  :
    case SEC_E_CANNOT_INSTALL             :
    case SEC_E_INVALID_TOKEN              :
    case SEC_E_CANNOT_PACK                :
    case SEC_E_QOP_NOT_SUPPORTED          :
    case SEC_E_NO_IMPERSONATION           :
    case SEC_E_LOGON_DENIED               :
    case SEC_E_UNKNOWN_CREDENTIALS        :
    case SEC_E_NO_CREDENTIALS             :
    case SEC_E_MESSAGE_ALTERED            :
    case SEC_E_OUT_OF_SEQUENCE            :
    case SEC_E_NO_AUTHENTICATING_AUTHORITY:
    case SEC_I_CONTINUE_NEEDED            :
    case SEC_I_COMPLETE_NEEDED            :
    case SEC_I_COMPLETE_AND_CONTINUE      :
    case SEC_I_LOCAL_LOGON                :
    case SEC_E_BAD_PKGID                  :
    case SEC_E_CONTEXT_EXPIRED            :
    case SEC_E_INCOMPLETE_MESSAGE         :
        dwErrorCode = ERROR_WINHTTP_SECURE_FAILURE;
        dwStatus    = WINHTTP_CALLBACK_STATUS_FLAG_SECURITY_CHANNEL_ERROR;
        break;

    // Cert and Encryption errors

    case CERT_E_EXPIRED:
    case CERT_E_VALIDITYPERIODNESTING:
        dwErrorCode = ERROR_WINHTTP_SECURE_FAILURE;
        dwStatus    = WINHTTP_CALLBACK_STATUS_FLAG_CERT_DATE_INVALID;
        break;

    case CERT_E_UNTRUSTEDROOT:
        dwErrorCode = ERROR_WINHTTP_SECURE_FAILURE;
        dwStatus    = WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CA;
        break;

    case CERT_E_CN_NO_MATCH:
        dwErrorCode = ERROR_WINHTTP_SECURE_FAILURE;
        dwStatus    = WINHTTP_CALLBACK_STATUS_FLAG_CERT_CN_INVALID;
        break;

    case CRYPT_E_REVOKED:
        dwErrorCode = ERROR_WINHTTP_SECURE_FAILURE;
        dwStatus    = WINHTTP_CALLBACK_STATUS_FLAG_CERT_REVOKED;
        break;

    // ignore revocation if the certificate does not have a CDP
    case CRYPT_E_NO_REVOCATION_CHECK:
        dwErrorCode = ERROR_SUCCESS;
        break;

    case CRYPT_E_REVOCATION_OFFLINE:
        dwErrorCode = ERROR_WINHTTP_SECURE_FAILURE;
        dwStatus    = WINHTTP_CALLBACK_STATUS_FLAG_CERT_REV_FAILED;
        break;

    case CERT_E_ROLE:
    case CERT_E_PATHLENCONST:
    case CERT_E_CRITICAL:
    case CERT_E_PURPOSE:
    case CERT_E_ISSUERCHAINING:
    case CERT_E_MALFORMED:
    case CERT_E_CHAINING:
    // We can't allow connection if server doesn't have a server auth certificate.
    // To force CERT_E_WRONG_USAGE to error out we map it to the error below.
    // In the future we need to map it to it's own non-recoverable error, so we can 
    // give the user a specific error message.
    case CERT_E_WRONG_USAGE:
        dwErrorCode = ERROR_WINHTTP_SECURE_FAILURE;
        dwStatus    = WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CERT;
        break;

    case WSAEINTR:
    case WSAEBADF:
    case WSAEACCES:
    case WSAEFAULT:
    case WSAEINVAL:
    case WSAEMFILE:
    case WSAEADDRINUSE:
    case WSAEADDRNOTAVAIL:
        dwErrorCode = ERROR_WINHTTP_INTERNAL_ERROR;
        break;

    case WSAENOTSOCK:

        //
        // typically, if we see this error its because we tried to use a closed
        // socket handle
        //
        dwErrorCode = ERROR_WINHTTP_OPERATION_CANCELLED;
        break;

    case WSAEWOULDBLOCK:
    case WSAEINPROGRESS:
    case WSAEALREADY:
    case WSAEDESTADDRREQ:
    case WSAEPROTOTYPE:
    case WSAENOPROTOOPT:
    case WSAEPROTONOSUPPORT:
    case WSAESOCKTNOSUPPORT:
    case WSAEOPNOTSUPP:
    case WSAEISCONN:
    case WSAETOOMANYREFS:
    case WSAELOOP:
    case WSAENAMETOOLONG:
    case WSAENOTEMPTY:
    case WSAEPROCLIM:
    case WSAEUSERS:
    case WSAEDQUOT:
    case WSAESTALE:
    case WSAEREMOTE:
    case WSAEDISCON:
    case WSASYSNOTREADY:
    case WSAVERNOTSUPPORTED:
    case WSANOTINITIALISED:

        //
        // currently unmapped errors
        //

        break;

    case WSAEMSGSIZE:
        dwErrorCode = ERROR_INSUFFICIENT_BUFFER;
        break;

    case WSAEPFNOSUPPORT:
    case WSAEAFNOSUPPORT:
        dwErrorCode = ERROR_NOT_SUPPORTED;
        break;

    case WSAECONNABORTED:
    case WSAESHUTDOWN:

    case WSAECONNRESET:
    case WSAENETRESET:
        dwErrorCode = ERROR_WINHTTP_CONNECTION_ERROR;
        break;

    case WSAENOBUFS:
        dwErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        break;

    case WSAETIMEDOUT:
        dwErrorCode = ERROR_WINHTTP_TIMEOUT;
        break;

    case WSAENETDOWN:
    case WSAECONNREFUSED:
    case WSAENETUNREACH:
    case WSAENOTCONN:
        dwErrorCode = ERROR_WINHTTP_CANNOT_CONNECT;
        break;

    case WSAEHOSTDOWN:
    case WSAEHOSTUNREACH:
    case WSAHOST_NOT_FOUND:
    case WSATRY_AGAIN:
    case WSANO_RECOVERY:
    case WSANO_DATA:
        dwErrorCode = ERROR_WINHTTP_NAME_NOT_RESOLVED;
        break;

    default:

        DEBUG_PRINT(UTIL,
                    WARNING,
                    ("MapInternetError(): unmapped error code %d [%#x]\n",
                    dwErrorCode,
                    dwErrorCode
                    ));

        break;
    }

    if (lpdwStatus)
    {
        *lpdwStatus = dwStatus;
        DEBUG_PRINT(UTIL,
                    INFO,
                    ("MapInternetError(): mapped status flag %#x\n",
                    *lpdwStatus
                    ));
    }

    DEBUG_LEAVE(dwErrorCode);

    return dwErrorCode;
}


DWORD
CalculateHashValue(
    IN LPSTR lpszString
    )

/*++

Routine Description:

    Calculate a hash number given a string

Arguments:

    lpszString  - string to hash

Return Value:

    DWORD

--*/

{
    DWORD hashValue = 0;
    DWORD position = 1;

    while (*lpszString) {
        hashValue += *lpszString * position;
        ++lpszString;
        ++position;
    }
    return hashValue;
}



VOID GetCurrentGmtTime(
    LPFILETIME  lpFt
    )
/*++

Routine Description:
    This routine returns the current GMT time

Arguments:

    lpFt    FILETIME strucutre in which this is returned

Returns:

Comments:

--*/
{
    SYSTEMTIME sSysT;

    GetSystemTime(&sSysT);
    SystemTimeToFileTime(&sSysT, lpFt);
}



LPTSTR
FTtoString(
    IN FILETIME *pftTime)

/*++

FTtoString:

    This routine converts a given FILETIME structure to a string representing
    the given date and time in the local format.

Arguments:

    pftTime supplies the FILETIME structure to convert.

Return Value:

    NULL - Memory allocation failure.
    Otherwise, the address of the string, allocated via LocalAlloc.

Author:

    Doug Barlow (dbarlow) 4/12/1996

--*/

{
    LONG cchTotal, cchNeeded;
    SYSTEMTIME stTime, stLocal;
    LPTSTR szDateTime = NULL;


    //
    // Convert the FILETIME to a SYSTEMTIME.
    //

    if (!FileTimeToSystemTime(pftTime, &stTime))
        goto ErrorExit;

    //
    // For now, leave it in GMT time, function not implimented in Win'95.
    //

    //if ( IsPlatformWinNT() )
    //{
    //    if (!SystemTimeToTzSpecificLocalTime(NULL, &stTime, &stLocal))
    //        goto ErrorExit;
    //}
    //else
    {
        stLocal = stTime;
    }


    //
    // Calculate how long the date string will be.
    //

    cchTotal =
        GetDateFormat(
            LOCALE_SYSTEM_DEFAULT,
            DATE_SHORTDATE,
            &stLocal,
            NULL,
            NULL,
            0);
    if (0 >= cchTotal)
        goto ErrorExit;
    cchNeeded =
        GetTimeFormat(
            LOCALE_SYSTEM_DEFAULT,
            0,
            &stLocal,
            NULL,
            NULL,
            0);
    if (0 >= cchNeeded)
        goto ErrorExit;
    cchTotal += cchNeeded;
    cchTotal += 4 * sizeof(TCHAR);  // space, trailing NULL, and two extra.
    szDateTime = (LPTSTR)ALLOCATE_MEMORY(LMEM_FIXED, cchTotal);
    if (NULL == szDateTime)
        goto ErrorExit;


    //
    // Fill in the time string.
    //

    cchNeeded =
        GetDateFormat(
            LOCALE_SYSTEM_DEFAULT,
            DATE_SHORTDATE,
            &stLocal,
            NULL,
            szDateTime,
            cchTotal);
    if (0 >= cchNeeded)
        goto ErrorExit;
    lstrcat(szDateTime, TEXT(" "));
    cchNeeded = lstrlen(szDateTime);
    cchNeeded =
        GetTimeFormat(
            LOCALE_SYSTEM_DEFAULT,
            0,
            &stLocal,
            NULL,
            &szDateTime[cchNeeded],
            cchTotal - cchNeeded);
    if (0 >= cchNeeded)
        goto ErrorExit;
    return szDateTime;


ErrorExit:
    if (NULL != szDateTime)
        FREE_MEMORY(szDateTime);
    return NULL;
}


BOOL
CertHashToStr(
    IN LPSTR lpMD5Hash,
    IN DWORD dwMD5HashSize,
    IN OUT LPSTR *lplpszHashStr
    )
/*++

Routine Description:

    Converts a set of bytes into a neatly formated string of ':' (colon) seperated
      hex digits that can be shown to the user.

Arguments:

    lpMD5Hash - ptr to set of hash bytes

    dwMD5HashSize - size of lpMD5Hash

    lplpszHashStr - ptr to ptr where newly allocated return string will be stored.

Return Value:

    BOOL

--*/

{

    DWORD dwStrSize = (2*dwMD5HashSize) + dwMD5HashSize;
    LPSTR lpszHashStr;

    *lplpszHashStr = new CHAR[dwStrSize];

    if ( *lplpszHashStr == NULL )
    {
        return FALSE;
    }

    lpszHashStr = *lplpszHashStr;

    for ( DWORD i = 0 ; i < dwMD5HashSize; i++ )
    {
        unsigned char uHashByte;

        if ( i != 0 )
        {
            *lpszHashStr = ':';
            lpszHashStr++;
        }

        uHashByte = (unsigned char) * ( ((unsigned char * ) lpMD5Hash) + i);

        wsprintf( lpszHashStr, "%02X", uHashByte);

        lpszHashStr += 2;

    }

    INET_ASSERT( *lpszHashStr == '\0' );

    return TRUE;
}


//
// private functions
//

DWORD
ConvertSecurityInfoIntoCertInfoStruct(
    IN  LPINTERNET_SECURITY_INFO   pSecInfo,
    OUT INTERNET_CERTIFICATE_INFO *pCertificate,
    IN OUT DWORD *pcbCertificate
    )
/*++

Routine Description:

    Converts an X509 Certificate Structure into a WININET struct
    used for storing the same info.

Arguments:

    hContext        - Context handle of the active SSPI session.

    pCertInfo       - Pointer to Structure where info is returned in.

Return Value:

    DWORD
    ERROR_SUCCESS   - if cert cannot be converted

    ERROR_NOT_ENOUGH_MEMORY

--*/

{


    DWORD   error = ERROR_SUCCESS;
    PCERT_INFO pCertInfo = NULL;
    DWORD cbCert = sizeof(INTERNET_CERTIFICATE_INFO),
          cbSubject = 0,
          cbIssuer = 0;

    BOOL fCanAlloc = FALSE;

    if(pSecInfo == NULL)
    {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    if(pCertificate == NULL || *pcbCertificate == 0)
    {
        *pcbCertificate = sizeof(INTERNET_CERTIFICATE_INFO);
        goto quit;
    }

    if(*pcbCertificate < sizeof(INTERNET_CERTIFICATE_INFO) )
    {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    ZeroMemory(pCertificate, sizeof(INTERNET_CERTIFICATE_INFO));
    fCanAlloc = TRUE;

    if(pSecInfo->pCertificate &&
       pSecInfo->pCertificate->pCertInfo )
    {
        pCertInfo = pSecInfo->pCertificate->pCertInfo;

        //
        // Now Convert Structures from SSPI format to WININET style.
        //  While in the process, we'll role them all into one
        //  big structure that we'll return to the user.
        //

        cbSubject = CertNameToStr(pSecInfo->pCertificate->dwCertEncodingType,
                                     &pCertInfo->Subject,
                                      CERT_SIMPLE_NAME_STR |
                                      CERT_NAME_STR_CRLF_FLAG |
                                      CERT_NAME_STR_NO_PLUS_FLAG,
                                     NULL,
                                     0);


        if ( cbSubject > 0 )
        {
            // freed by caller outside of wininet
            pCertificate->lpszSubjectInfo = (LPSTR) LocalAlloc(LPTR, cbSubject);

            if ( pCertificate->lpszSubjectInfo == NULL )
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }

            CertNameToStr(pSecInfo->pCertificate->dwCertEncodingType,
                                     &pCertInfo->Subject,
                                      CERT_SIMPLE_NAME_STR |
                                      CERT_NAME_STR_CRLF_FLAG |
                                      CERT_NAME_STR_NO_PLUS_FLAG ,
                                     pCertificate->lpszSubjectInfo,
                                     cbSubject);

        }

        cbIssuer = CertNameToStr(pSecInfo->pCertificate->dwCertEncodingType,
                                     &pCertInfo->Issuer,
                                      CERT_SIMPLE_NAME_STR |
                                      CERT_NAME_STR_CRLF_FLAG |
                                      CERT_NAME_STR_NO_PLUS_FLAG,
                                     NULL,
                                     0);

        if ( cbIssuer > 0 )
        {
            // freed by caller outside of wininet
            pCertificate->lpszIssuerInfo = (LPSTR) LocalAlloc(LPTR, cbIssuer);

            if ( pCertificate->lpszIssuerInfo == NULL )
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }

            CertNameToStr(pSecInfo->pCertificate->dwCertEncodingType,
                                     &pCertInfo->Issuer,
                                      CERT_SIMPLE_NAME_STR |
                                      CERT_NAME_STR_CRLF_FLAG |
                                      CERT_NAME_STR_NO_PLUS_FLAG ,
                                     pCertificate->lpszIssuerInfo,
                                     cbIssuer);

        }

        CopyMemory(
                (PVOID) &pCertificate->ftStart,
                (PVOID) &pCertInfo->NotBefore,
                sizeof(FILETIME)
                );

        CopyMemory(
                (PVOID) &pCertificate->ftExpiry,
                (PVOID) &pCertInfo->NotAfter,
                sizeof(FILETIME)
                );

    }

    /*if(pSecInfo->dwProtocol)
    {
        DWORD dwProtocolID;
        TCHAR lpszProtocol[100];

        ATTR_MAP ProtocolAttrMap[] =
        {
            {SP_PROT_SSL2_CLIENT, IDS_PROTOCOL_SSL2},
            {SP_PROT_SSL3_CLIENT, IDS_PROTOCOL_SSL3},
            {SP_PROT_PCT1_CLIENT, IDS_PROTOCOL_PCT1},
            {SP_PROT_TLS1_CLIENT, IDS_PROTOCOL_TLS1}
        };


        for(j=0; j < sizeof(ProtocolAttrMap)/sizeof(ProtocolAttrMap[0]); j++)
        {
            if(ProtocolAttrMap[j].dwAttr == pSecInfo->dwProtocol)
            {
                dwProtocolID = ProtocolAttrMap[j].dwStringID;
                break;
            }
        }
        if(LoadString(GlobalDllHandle,
                   dwProtocolID,
                   lpszProtocol,
                   sizeof(lpszProtocol)/sizeof(lpszProtocol[0])))
        {
            pCertificate->lpszProtocolName  = NewString(lpszProtocol);
        }
    } */

    pCertificate->dwKeySize = pSecInfo->dwCipherStrength;

quit:

    if ( error != ERROR_SUCCESS &&
         fCanAlloc
        )
    {

        if ( pCertificate->lpszSubjectInfo )
        {
            LocalFree(pCertificate->lpszSubjectInfo);
            pCertificate->lpszSubjectInfo = NULL;
        }

        if ( pCertificate->lpszIssuerInfo )
        {
            LocalFree(pCertificate->lpszIssuerInfo);
            pCertificate->lpszIssuerInfo = NULL;
        }
    }

    return error;
}


#ifdef DONT_USE_IERT
/***
*char *StrTokEx(pstring, control) - tokenize string with delimiter in control
*
*Purpose:
*       StrTokEx considers the string to consist of a sequence of zero or more
*       text tokens separated by spans of one or more control chars. the first
*       call, with string specified, returns a pointer to the first char of the
*       first token, and will write a null char into pstring immediately
*       following the returned token. when no tokens remain
*       in pstring a NULL pointer is returned. remember the control chars with a
*       bit map, one bit per ascii char. the null char is always a control char.
*
*Entry:
*       char **pstring - ptr to ptr to string to tokenize
*       char *control - string of characters to use as delimiters
*
*Exit:
*       returns pointer to first token in string,
*       returns NULL when no more tokens remain.
*       pstring points to the beginning of the next token.
*
*WARNING!!!
*       upon exit, the first delimiter in the input string will be replaced with '\0'
*
*******************************************************************************/

char * StrTokEx (char ** pstring, const char * control)
{
        unsigned char *str;
        const unsigned char *ctrl = (const unsigned char *)control;
        unsigned char map[32];
        int count;

        char *tokenstr;

        if(*pstring == NULL)
            return NULL;
            
        /* Clear control map */
        for (count = 0; count < 32; count++)
                map[count] = 0;

        /* Set bits in delimiter table */
        do
        {
            map[*ctrl >> 3] |= (1 << (*ctrl & 7));
        } while (*ctrl++);

        /* Initialize str. */
        str = (unsigned char *)*pstring;
        
        /* Find beginning of token (skip over leading delimiters). Note that
         * there is no token if this loop sets str to point to the terminal
         * null (*str == '\0') */
        while ( (map[*str >> 3] & (1 << (*str & 7))) && *str )
            str++;

        tokenstr = (char *)str;

        /* Find the end of the token. If it is not the end of the string,
         * put a null there. */
        for ( ; *str ; str++ )
        {
            if ( map[*str >> 3] & (1 << (*str & 7)) ) 
            {
                *str++ = '\0';
                break;
            }
        }

        /* string now points to beginning of next token */
        *pstring = (char *)str;

        /* Determine if a token has been found. */
        if ( tokenstr == (char *)str )
            return NULL;
        else
            return tokenstr;
}

/***
* double StrToDbl(const char *str, char **strStop) - convert string to double
*
* Purpose:
*           To convert a string into a double.  This function supports
*           simple double representations like '1.234', '.5678'.  It also support
*           the a killobyte computaion by appending 'k' to the end of the string
*           as in '1.5k' or '.5k'.  The results would then become 1536 and 512.5.
*
* Return:
*           The double representation of the string.
*           strStop points to the character that caused the scan to stop.
*
*******************************************************************************/

double StrToDbl(const char *str, char **strStop)
{
    double dbl = 0;
    char *psz;
    int iMult = 1;
    int iKB = 1;
    int iVal = 0;
    BOOL bHaveDot = FALSE;

    psz = (char*)str;
    while(*psz)
    {
        if((*psz >= '0') && (*psz <= '9'))
        {
            iVal = (iVal * 10) + (*psz - '0');
            if(bHaveDot)
                iMult *= 10;
        }
        else if((*psz == '.') && !bHaveDot)
        {
            bHaveDot = TRUE;
        }
        else if((*psz == 'k') || (*psz == 'K'))
        {
            iKB = 1024;
            psz++;
            break;
        }
        else
        {
            break;
        }
        psz++;
    }
    *strStop = psz;

    dbl = (double) (iVal * iKB) / iMult;
    
    return(dbl);
}
#endif  // DONT_USE_IERT


/*
 *  WideCharToAsciiString
 *
 *  Purpose:
 *      Create an ascii string from a wide-char string.
 *      Output ascii string is allocated using New, so use delete[] to free.
 *
 */

DWORD
WideCharToAscii(PCWSTR pszW, char ** ppszA)
{
    DWORD cchA;
    DWORD cchW;

    *ppszA = NULL;

    if (!pszW)
        return ERROR_SUCCESS;

    cchW = lstrlenW(pszW);

    // Determine how big the ascii string will be
    cchA = WideCharToMultiByte(CP_ACP, 0, pszW, cchW, NULL, 0, NULL, NULL);

    *ppszA = new char[cchA + 1];

    if (!*ppszA)
        return ERROR_NOT_ENOUGH_MEMORY;

    // Determine how big the ascii string will be
    cchA = WideCharToMultiByte(CP_ACP, 0, pszW, cchW, *ppszA, cchA, NULL, NULL);

    (*ppszA)[cchA] = '\0';
    
    return ERROR_SUCCESS;
}


DWORD
AsciiToWideChar_UsingGlobalAlloc(const char * pszA, LPWSTR * ppszW)
{
    DWORD cchA;
    DWORD cchW;

    *ppszW = NULL;

    if (!pszA)
        return ERROR_SUCCESS;

    cchA = lstrlenA(pszA);

    // Determine how big the widechar string will be
    cchW = MultiByteToWideChar(CP_ACP, 0, pszA, cchA, NULL, 0);

    *ppszW = (PWSTR) GlobalAlloc(GPTR, (cchW + 1) * sizeof(WCHAR));

    if (!*ppszW)
        return ERROR_NOT_ENOUGH_MEMORY;

    cchW = MultiByteToWideChar(CP_ACP, 0, pszA, cchA, *ppszW, cchW * sizeof(WCHAR));

    (*ppszW)[cchW] = 0;

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\common\ssocket.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ssocket.cxx

Abstract:

    Contains secure sockets functions and ICSecureSocket methods

    Contents:
        SecurityPkgInitialize
        ReadCertificateIntoCertInfoStruct
        ChkCertificateCommonNameIsValid
        ChkCertificateExpired
        ICSecureSocket::ICSecureSocket
        ICSecureSocket::~ICSecureSocket
        ICSecureSocket::Connect
        CFsm_SecureConnect::RunSM
        ICSecureSocket::Connect_Fsm
        ICSecureSocket::SecureHandshakeWithServer
        CFsm_SecureHandshake::RunSM
        ICSecureSocket::SecureHandshake_Fsm
        ICSecureSocket::NegotiateSecConnection
        CFsm_SecureNegotiate::RunSM
        ICSecureSocket::SecureNegotiate_Fsm
        ICSecureSocket::SSPINegotiateLoop
        CFsm_NegotiateLoop::RunSM
        ICSecureSocket::NegotiateLoop_Fsm
        ICSecureSocket::Disconnect
        ICSecureSocket::Send
        CFsm_SecureSend::RunSM
        ICSecureSocket::Send_Fsm
        ICSecureSocket::Receive
        CFsm_SecureReceive::RunSM
        ICSecureSocket::Receive_Fsm
        ICSecureSocket::SetHostName
        (ICSecureSocket::EncryptData)
        (ICSecureSocket::DecryptData)
        (ICSecureSocket::TerminateSecConnection)
        ICSecureSocket::GetCertInfo

Author:

    Richard L Firth (rfirth) 08-Apr-1997

Environment:

    Win32 user mode

Revision History:

    08-Apr-1997 rfirth
        Created from ixport.cxx

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include <ierrui.hxx>

extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsecapi.h>

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <softpub.h>

}

//
//
//  List of encryption packages:  PCT, SSL, etc
//

//
// BUGBUG [arthurbi] The SSL and PCT package names
//  are hard coded into the stucture below.  We need
//  to be more flexible in case someone write a FOO security
//  package.
//

// BUGBUG:  Don't change the order of the packages below.  some old SSL2 sites deny the UNISP
// provider, and if we walk down the list to PCT1 or SSL3, things hang.
struct _SEC_PROVIDER SecProviders[] =
{
    UNISP_NAME, INVALID_CRED_VALUE , ENC_CAPS_PCT | ENC_CAPS_SSL | ENC_CAPS_SCHANNEL_CREDS, FALSE, SP_PROT_CLIENTS, NULL,
    UNISP_NAME, INVALID_CRED_VALUE , ENC_CAPS_SSL | ENC_CAPS_SCHANNEL_CREDS, FALSE, SP_PROT_SSL2_CLIENT, NULL,
//    PCT1SP_NAME, INVALID_CRED_VALUE , ENC_CAPS_PCT| ENC_CAPS_SCHANNEL_CREDS, FALSE, SP_PROT_PCT1_CLIENT, NULL,
//    SSL3SP_NAME, INVALID_CRED_VALUE , ENC_CAPS_SSL| ENC_CAPS_SCHANNEL_CREDS, FALSE, SP_PROT_SSL3_CLIENT, NULL,
    NULL,        INVALID_CRED_VALUE , FALSE,        FALSE, 0
};



//
// dwEncFlags - Global Status of calling and initalizing the SCHANNEL and various
//   other encyrption support DLL & APIs.  Failure in the process will
//   cause this to be set to an error state, success prevents re-initalizaiton
//

DWORD dwEncFlags = 0;

//
// GlobalSecureProtocolsCopy - Copy of the current protocols the user wants to use
//   changing them allows us to restrict to specific protocols
//
DWORD GlobalSecureProtocolsCopy = DEFAULT_SECURE_PROTOCOLS;


#ifdef SECPKG_ATTR_PROTO_INFO
PRIVATE
LPTSTR
ProtoInfoToString(
    IN const PSecPkgContext_ProtoInfo pProtoInfo);
#endif

//
// general security package functions
//
BOOL
SecurityPkgInitialize(
    BOOL fForce
    )
/*++

Routine Description:

    This function finds a list of security packages that are supported
    on the client's machine, check if pct or ssl is supported, and
    create a credential handle for each supported pkg.

Arguments:

    None

Return Value:

    TRUE if at least one security pkg is found; otherwise FALSE

--*/
{
    TimeStamp         tsExpiry;
    SECURITY_STATUS   scRet;
    PSecPkgInfo       pPackageInfo = NULL;
    ULONG             cPackages;
    ULONG             fCapabilities;
    ULONG             i;
    ULONG             j;
    DWORD             cProviders = 0;

    SCHANNEL_CRED DefaultCredData = {SCHANNEL_CRED_VERSION,
                                     0,
                                     NULL,
                                     0,
                                     0,
                                     NULL,
                                     0,
                                     NULL,
                                     SP_PROT_CLIENTS,
                                     0,
                                     0,
                                     0,
                                     SCH_CRED_MANUAL_CRED_VALIDATION |
                                     SCH_CRED_NO_DEFAULT_CREDS
                                    };

    //
    // Set new DWORD for our copy of the global protocol settings.
    //
    bool    fSame = (GlobalSecureProtocolsCopy==GlobalSecureProtocols);
    GlobalSecureProtocolsCopy = GlobalSecureProtocols;

    //
    //  check if this routine has been called.  if yes, return TRUE
    //  if we've found a supported pkg; otherwise FALSE
    //

    if ( dwEncFlags == ENC_CAPS_NOT_INSTALLED )
       return FALSE;
    else if ((dwEncFlags&ENC_CAPS_TYPE_MASK) && fSame && !fForce)
       return TRUE;

    //
    //  Initialize dwEncFlags
    //

    dwEncFlags = ENC_CAPS_NOT_INSTALLED;

    //
    //  Check if at least one security package is supported
    //


    scRet = g_EnumerateSecurityPackages( &cPackages,
                                         &pPackageInfo );

    if ( scRet != STATUS_SUCCESS )
    {
        DEBUG_PRINT(API,
                    ERROR,
                    ("EnumerateSecurityPackages failed, error %lx\n",
                    scRet
                    ));

        SetLastError( scRet );
        return FALSE;
    }

    for ( i = 0; i < cPackages ; i++ )
    {
        //
        //  Use only if the package name is the PCT/SSL package
        //

        fCapabilities = pPackageInfo[i].fCapabilities;

        if ( fCapabilities & SECPKG_FLAG_STREAM )
        {
            //
            //  Check if the package supports server side authentication
            //  and all recv/sent messages are tamper proof
            //

            if ( fCapabilities & SECPKG_FLAG_CLIENT_ONLY ||
                 !(fCapabilities & SECPKG_FLAG_PRIVACY ))
            {
                continue;
            }

            //
            //  Check if the pkg matches one of our known packages
            //

            for ( j = 0; SecProviders[j].pszName != NULL; j++ )
            {
                if ( !stricmp( pPackageInfo[i].Name, SecProviders[j].pszName ) )
                {
                    CredHandle OldCred;
                    PVOID pCredData = NULL;

                    //
                    //  Create a credential handle for each supported pkg
                    //

                    INET_ASSERT((SecProviders[j].dwFlags & ENC_CAPS_SCHANNEL_CREDS));

                    pCredData = &DefaultCredData;

                    if (SecProviders[j].pCertCtxt != NULL) {
                        DefaultCredData.cCreds = 1;
                        DefaultCredData.paCred = &SecProviders[j].pCertCtxt;
                    }

                    //
                    // Enable Supported protocols in the Default Cred Data, then acquire the Credential
                    //

                    DefaultCredData.grbitEnabledProtocols = (GlobalSecureProtocols & SecProviders[j].dwProtocolFlags);

                    OldCred.dwUpper = SecProviders[j].hCreds.dwUpper;
                    OldCred.dwLower = SecProviders[j].hCreds.dwLower;

                    // Zero out previous credentials
                    SecProviders[j].hCreds.dwUpper = SecProviders[j].hCreds.dwLower = 0;

                    WRAP_REVERT_USER(g_AcquireCredentialsHandle,
                                     (NULL,
                                      SecProviders[j].pszName, // Package
                                      SECPKG_CRED_OUTBOUND,
                                      NULL,
                                      pCredData,
                                      NULL,
                                      NULL,
                                      &(SecProviders[j].hCreds), // Handle
                                      &tsExpiry),
                                     scRet);

                    if(!IS_CRED_INVALID(&OldCred))
                    {
                        WRAP_REVERT_USER_VOID(g_FreeCredentialsHandle, (&OldCred));
                    }

                    DefaultCredData.cCreds = 0;
                    DefaultCredData.paCred = NULL;

                    if ( scRet != STATUS_SUCCESS )
                    {
                        DEBUG_PRINT(API,
                                    WARNING,
                                    ("AcquireCredentialHandle failed, error %lx\n",
                                    scRet
                                    ));

                        SecProviders[j].fEnabled = FALSE;

                        SecProviders[j].hCreds.dwUpper = 0xffffffff;
                        SecProviders[j].hCreds.dwLower = 0xffffffff;


                    }
                    else
                    {
                        DEBUG_PRINT(
                             API,
                             INFO,
                             ("AcquireCredentialHandle() supports %s, acquires %x:%x\n",
                             SecProviders[j].pszName,
                             SecProviders[j].hCreds.dwUpper,
                             SecProviders[j].hCreds.dwLower
                             ));

                        SecProviders[j].fEnabled = TRUE;
                        cProviders++;
                        dwEncFlags |= SecProviders[j].dwFlags;
                    }
                }
            }
        }
    }

    if ( !cProviders )
    {
        //
        //  No security packages were found, return FALSE to caller
        //

        DEBUG_PRINT(API,
                    ERROR,
                    ("No security packages were found, error %lx\n",
                    SEC_E_SECPKG_NOT_FOUND
                    ));

        g_FreeContextBuffer( pPackageInfo );

        SetLastError( (DWORD) SEC_E_SECPKG_NOT_FOUND );

        return FALSE;
    }

    //
    //  Successfully found a security package(s)
    //

    return TRUE;
}


DWORD
QuerySecurityInfo(
                  IN CtxtHandle *hContext,
                  OUT LPINTERNET_SECURITY_INFO pInfo,
                  IN LPDWORD lpdwStatusFlag)
{
    SECURITY_STATUS      scRet;

    scRet = g_QueryContextAttributes(hContext,
                                     SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                                     &pInfo->pCertificate );

    if (scRet == ERROR_SUCCESS)
    {
        scRet = g_QueryContextAttributes(hContext,
                                     SECPKG_ATTR_CONNECTION_INFO,
                                     &pInfo->dwProtocol );

        if (scRet == ERROR_SUCCESS)
        {
            pInfo->dwSize = sizeof(INTERNET_SECURITY_INFO);
        }
    }
    
    if (scRet != ERROR_SUCCESS)
    {
        //
        // Map the SSPI error.
        //
        return MapInternetError((DWORD) scRet, lpdwStatusFlag);
    }
    return ERROR_SUCCESS;
}

// Helper function to detect Fortezza connections.
BOOL IsCertificateFortezza(PCCERT_CONTEXT pCertContext)
{
    INET_ASSERT(pCertContext != NULL);
    if (pCertContext == NULL)
        return FALSE;

    LPSTR pszOid = pCertContext->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId;

    if (pszOid)
    {
        if (strcmp(pszOid, szOID_INFOSEC_mosaicUpdatedSig) == 0 ||
             strcmp(pszOid, szOID_INFOSEC_mosaicKMandUpdSig) == 0)
        {
            return TRUE;
        }
    }
    return FALSE;
}


LONG WinVerifySecureChannel(HWND hwnd, WINTRUST_DATA *pWTD)
/*++

Routine Description:

    Wininet's wrapper for secure channel WinVerifyTrust calls.

Arguments:

    hWnd - in case WinVerifyTrust needs to do UI.
    pWTD - pointer to WINTRUST_DATA containing details about the
           secure channel. Passed to WinVerifyTrust.
Return Value:

    WIN32 error code.

--*/
{
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    BOOL async;
    LONG  lResult;
    BOOL  bFortezza;
    GUID  gHTTPS = HTTPSPROV_ACTION;

    if (lpThreadInfo != NULL) {
        async = _InternetGetAsync(lpThreadInfo);
        _InternetSetAsync(lpThreadInfo, FALSE);
    }

    bFortezza = IsCertificateFortezza(pWTD->pCert->psCertContext);

    if (bFortezza && g_CryptInstallDefaultContext == NULL)
    {
        // HACK: we have no way to verify a connection without
        // a crypt32 which has the new APIs exposed. Till IE5 picks up
        // the new crypto bits we will assume Fortezza connections
        // verify correctly.
        lResult = ERROR_SUCCESS;
    }
    else
    {
        HCRYPTDEFAULTCONTEXT hCryptDefaultContext = NULL;

        if (bFortezza)
        {
            if (!g_CryptInstallDefaultContext(
                        GlobalFortezzaCryptProv,
                        CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID,
                        szOID_INFOSEC_mosaicUpdatedSig,         // check with John Banes
                        0,                                      // dwFlags
                        NULL,                                   // pvReserved
                        &hCryptDefaultContext
                        ))
            {
                lResult = GetLastError();
                goto quit;
            }
        }

        WRAP_REVERT_USER(g_WinVerifyTrust, (hwnd, &gHTTPS, pWTD), lResult);

        DEBUG_PUT(("WinVerifyTrust returned: %x\n", lResult));

        if (hCryptDefaultContext)
        {
            // Ignore error code while freeing since we can't do anything
            // meaningful about it here.
            BOOL bResult;
            bResult = g_CryptUninstallDefaultContext(
                        hCryptDefaultContext,
                        0,
                        NULL);
            INET_ASSERT(bResult);
        }
    }

quit:

    if (lpThreadInfo != NULL) {
        _InternetSetAsync(lpThreadInfo, async);
    }
    return lResult;
}


//
// ICSecureSocket methods
//


ICSecureSocket::ICSecureSocket(void)

/*++

Routine Description:

    ICSecureSocket constructor

Arguments:


Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "ICSecureSocket::ICSecureSocket",
                 "{%#x}",
                 this
                 ));

    SIGN_SECURE_SOCKET();

    m_hContext.dwLower = m_hContext.dwUpper = 0;
    m_dwProviderIndex = 0;
    m_dwFlags |= SF_SECURE;
    m_lpszHostName = NULL;
    m_pdblbufBuffer = NULL;
    m_pSecurityInfo = NULL;
    m_pCertCache    = NULL;

    DEBUG_LEAVE(0);
}


ICSecureSocket::~ICSecureSocket()

/*++

Routine Description:

    ICSecureSocket destructor. Virtual function

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "ICSecureSocket::~ICSecureSocket",
                 "{%#x [%q, sock=%#x, port=%d]}",
                 this,
                 GetHostName(),
                 GetSocket(),
                 GetSourcePort()
                 ));

    CHECK_SECURE_SOCKET();

    if (IsSecure())
    {
        if (m_pdblbufBuffer != NULL) {
            delete m_pdblbufBuffer;
        }

        // Free security context associated with this object if it's
        // still allocated.
        TerminateSecConnection();


        /* SCLE ref */
        SetSecurityEntry(NULL);
        if (m_lpszHostName != NULL) {
            m_lpszHostName = (LPSTR)FREE_MEMORY(m_lpszHostName);
            INET_ASSERT(m_lpszHostName == NULL);
        }
        //if ( _pCertChainList )
        //    delete _pCertChainList;
    }

    DEBUG_LEAVE(0);
}


DWORD
ICSecureSocket::Connect(
    IN LONG Timeout,
    IN INT Retries,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Initiate secure connection with server

Arguments:

    Timeout - maximum amount of time (mSec) to wait for connection

    Retries - maximum number of attempts to connect

    dwFlags - flags controlling request

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't create FSM

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Connect",
                 "{%#x [%#x]} %d, %d, %#x",
                 this,
                 m_Socket,
                 Timeout,
                 Retries,
                 dwFlags
                 ));

    DWORD error;

    // might be http CONNECT that will morph into an established tunnel
    if (IsSecure())
    {
        error = DoFsm(New CFsm_SecureConnect(Timeout,
                                               Retries,
                                               dwFlags,
                                               this
                                               ));
    }
    else
    {
        // thunk to non-secure connect
        error = ICSocket::Connect(Timeout,
                                  Retries,
                                  dwFlags
                                  );
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SecureConnect::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SecureConnect::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSecureSocket * pSecureSocket = (ICSecureSocket *)Fsm->GetContext();
    CFsm_SecureConnect * stateMachine = (CFsm_SecureConnect *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pSecureSocket->Connect_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::Connect_Fsm(
    IN CFsm_SecureConnect * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Connect_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_SecureConnect & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_2:
            goto connect_continue;

        case FSM_STATE_3:
            goto negotiate_continue;

        default:
            error = ERROR_WINHTTP_INTERNAL_ERROR;

            INET_ASSERT(FALSE);

            goto quit;
        }
    }

    m_dwProviderIndex = 0;

    //
    // Hack for SSL2 Client Hello, set to FALSE,
    //  but if we fail on the first recv, fReOpenSocket
    //  is set to TRUE.
    //

    do {

        //
        // Attempt to do the connect
        //

        fsm.SetFunctionState(FSM_STATE_2);
        error = ICSocket::Connect(fsm.m_Timeout, fsm.m_Retries, fsm.m_dwFlags);

connect_continue:

        if (error != ERROR_SUCCESS) {
            break;
        }
        if (m_dwFlags & SF_ENCRYPT) {
            fsm.SetFunctionState(FSM_STATE_3);
            error = SecureHandshakeWithServer(fsm.m_dwFlags, &fsm.m_bAttemptReconnect);
            if (error == ERROR_IO_PENDING) {
                break;
            }

negotiate_continue:

            //
            // SSL2 hack for old IIS servers.
            //  We re-open the socket, and call again.
            //

            if ((error != ERROR_SUCCESS) && fsm.m_bAttemptReconnect) {
                Disconnect(fsm.m_dwFlags);
            }
        }
    } while (fsm.m_bAttemptReconnect);

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
        if ((error != ERROR_SUCCESS) && IsOpen()) {
            Disconnect(fsm.m_dwFlags);
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::SecureHandshakeWithServer(
    IN DWORD dwFlags,
    OUT LPBOOL lpbAttemptReconnect
    )

/*++

Routine Description:

    For SSL/PCT or some secure channel this function attempts to use
    an arbitrary Socket for handshaking with a server. The assumption
    is made that caller can recall this function on failure

Arguments:

    dwFlags             -

    lpbAttemptReconnect -

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                Dword,
                "ICSecureSocket::SecureHandshakeWithServer",
                "%#x, %#x [%B]",
                dwFlags,
                lpbAttemptReconnect,
                *lpbAttemptReconnect
                ));

    INET_ASSERT(IsSecure());

    DWORD error = DoFsm(New CFsm_SecureHandshake(dwFlags,
                                                 lpbAttemptReconnect,
                                                 this
                                                 ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SecureHandshake::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SecureHandshake::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSecureSocket * pSecureSocket = (ICSecureSocket *)Fsm->GetContext();
    CFsm_SecureHandshake * stateMachine = (CFsm_SecureHandshake *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pSecureSocket->SecureHandshake_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::SecureHandshake_Fsm(
    IN CFsm_SecureHandshake * Fsm
    )
{


    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::SecureHandshake_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_SecureHandshake & fsm = *Fsm;
    DWORD error = fsm.GetError();
    DWORD dwSecureFlags;
    DWORD dwCertFlags;
    BOOL fErrorInvalidCa;

    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_2:
            goto negotiate_continue;

        default:
            error = ERROR_WINHTTP_INTERNAL_ERROR;

            INET_ASSERT(FALSE);

            goto quit;
        }
    }

    //INET_ASSERT(fsm.m_dwFlags & SF_ENCRYPT);
    INET_ASSERT(m_Socket != INVALID_SOCKET);

    *fsm.m_lpbAttemptReconnect = FALSE;

    error = ERROR_SUCCESS;

    //
    // Save Off Flags in our Internal Object.
    //   Treat SF_ENCRYPT just like SF_DECRYPT
    //

    m_dwFlags |= SF_DECRYPT;
    m_dwFlags |= fsm.m_dwFlags;

    INET_ASSERT(!(m_dwFlags
                & ~(SF_NON_BLOCKING
                    | SF_SECURE
                    | SF_ENCRYPT
                    | SF_DECRYPT
                    | SF_INDICATE
                    | SF_SENDING_DATA
                    )));

    //
    // Allocate Internal Buffer for SSL/PCT data.
    //

    if (m_pdblbufBuffer == NULL) {

        BOOL fInitSuccess;

        m_pdblbufBuffer = New DBLBUFFER();
        if (m_pdblbufBuffer == NULL) {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }
        fInitSuccess = m_pdblbufBuffer->InitBuffer(TRUE);
        if (!fInitSuccess) {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }
    }

    // First make sure the security dlls are loaded.
    error = LoadSecurity();

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    // If the user has the Fortezza CSP but has not logged on to the card yet.
    // return back an error to indicate that we need to put up additional UI.

    // if (IsFortezzaInstalled( ) && !AttemptedFortezzaLogin( ))
    //{
    //    error = ERROR_WINHTTP_FORTEZZA_LOGIN_NEEDED;
    //    goto quit;
    //}

    //
    //  dwEncFlags is a global flag set to the
    //  supported security pkg mask
    //

    if (!LOCK_SECURITY())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    if (dwEncFlags == ENC_CAPS_NOT_INSTALLED) {
         error = (DWORD)SEC_E_SECPKG_NOT_FOUND;
    } else if (dwEncFlags == 0) {


         //
         //  first time thru, do the load.
         //

         DEBUG_PRINT(SOCKETS,
                     INFO,
                     ("Loading security dll\n"
                     ));

        if ( !SecurityPkgInitialize() ) {
             error = GetLastError();
             UNLOCK_SECURITY();
             goto quit;
        }
    }

    UNLOCK_SECURITY();

    if ( error != ERROR_SUCCESS )
    {
        goto quit;
    }


    //
    // If we succeed in loading or and initalizing the Security DLLs, we
    //      attempt to negotiate the connection
    //

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("Negotiate secure channel\n"
                ));

    //
    // Turn of Encryption/Decryption before the handshake,
    // since the NegotiateSecConnection does its own Send and Recvs
    // of specialized data.
    //

    m_dwFlags &= ~(SF_ENCRYPT | SF_DECRYPT);
    fsm.SetFunctionState(FSM_STATE_2);
    error = NegotiateSecConnection(fsm.m_dwFlags,
                                   fsm.m_lpbAttemptReconnect
                                   );
    if (error == ERROR_IO_PENDING) {
        goto quit;
    }

negotiate_continue:

    m_dwFlags |= (SF_ENCRYPT | SF_DECRYPT);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    //  Find out what size Key we're using, and set the flags
    //   acordingly.
    //

    dwSecureFlags = 0;
    if (m_pSecurityInfo && !m_pSecurityInfo->InCache()) {
        error = VerifyTrust();
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }

    //
    // we've got a secure connection, set the flags.
    //

    SetSecure();

    if(m_pSecurityInfo)
    {
        INTERNET_SECURITY_INFO ciInfo;
        m_pSecurityInfo->CopyOut(ciInfo);

        if(ciInfo.dwCipherStrength < 56)
        {
            SetSecureFlags(SECURITY_FLAG_STRENGTH_WEAK);
        }
        else if (ciInfo.dwCipherStrength==80 &&
                 (ciInfo.aiCipher == CALG_SKIPJACK || ciInfo.aiCipher==CALG_TEK))
        {
            SetSecureFlags(SECURITY_FLAG_FORTEZZA);
        }
        else if(ciInfo.dwCipherStrength < 96)
        {
             SetSecureFlags(SECURITY_FLAG_STRENGTH_MEDIUM);
        }
        else
        {
             SetSecureFlags(SECURITY_FLAG_STRENGTH_STRONG);
        }
        if(ciInfo.pCertificate)
        {
            WRAP_REVERT_USER_VOID(CertFreeCertificateContext, (ciInfo.pCertificate));
            ciInfo.pCertificate = NULL;
        }
    }

quit:

    if (error != ERROR_IO_PENDING)
    {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::VerifyTrust(
    )

/*++

Routine Description:

    This function establishes a secure channel with the server by
    performing the security handshake protocol.  It will walk
    the list of installed security packages until it finds a package
    that succeeds in the security handshake.  If one package fails
    it is up to the caller to re-call NegotiateSecConnection with
    a re-opened socket so another socket can attempt the connection.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/
{

    // We've done our handshake, now update the security info
    INTERNET_SECURITY_INFO ciCert;
    DWORD dwCertFlags = 0;
    WINTRUST_DATA           sWTD;
    WINTRUST_CERT_INFO      sWTCI;
    HTTPSPolicyCallbackData polHttps;
    DWORD                   cbServerName;
    DWORD error;
    DWORD dwStatusFlag = 0;
    HINTERNET  hInternet;
    HINTERNET  hInternetMapped;
    LPINTERNET_THREAD_INFO lpThreadInfo = NULL;

    DWORD dwFlags = 0;    // HTTPS policy flags to ignore errors

    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::VerifyTrust",
                 "{%#x",
                 this
                 ));

    // HACK HACK: 67640
    // WinVerifyTrust can do a nested HttpSendRequest which causes the hObject's on the 
    // thread to get messed up. This happens only when the ceritificate has a URL for 
    // a CRL in it. We save and restore these values to workaround the problem.
    // Need to work out a better solution to handle this but it is too close to ship to 
    // try anything with greater code impact. 
    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo != NULL)
    {
        hInternet = lpThreadInfo->hObject;
        hInternetMapped = lpThreadInfo->hObjectMapped;
    }


    error = QuerySecurityInfo(&m_hContext, &ciCert, &dwStatusFlag);
    if (error != ERROR_SUCCESS)
    {
        if (m_pSecurityInfo)
            m_pSecurityInfo->SetStatusFlags(dwStatusFlag);
        goto quit;
    }

    if(m_pSecurityInfo)
    {
        *m_pSecurityInfo = &ciCert;
        // Other flags have been filtered already, but make sure revocation
        // flag is removed, so it isn't passed to WVT.
        dwCertFlags = m_pSecurityInfo->GetSecureFlags() &
                ~(SECURITY_FLAG_CHECK_REVOCATION | SECURITY_FLAG_BREAK_ON_STATUS_SECURE_FAILURE);
    }
    if (ciCert.pCertificate == NULL)
    {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    memset(&sWTD, 0x00, sizeof(WINTRUST_DATA));
    sWTD.cbStruct               = sizeof(WINTRUST_DATA);
    sWTD.dwUIChoice             = WTD_UI_NONE;
    sWTD.pPolicyCallbackData    = (LPVOID)&polHttps;
    sWTD.dwUnionChoice          = WTD_CHOICE_CERT;
    sWTD.pCert                  = &sWTCI;
    sWTD.pwszURLReference       = NULL;
    if (m_pSecurityInfo &&
        (m_pSecurityInfo->GetSecureFlags() & SECURITY_FLAG_CHECK_REVOCATION))
    {
        sWTD.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN;
    }
    else
    {
        sWTD.fdwRevocationChecks = 0;
    }

    memset(&sWTCI, 0x00, sizeof(WINTRUST_CERT_INFO));
    sWTCI.cbStruct              = sizeof(WINTRUST_CERT_INFO);
    sWTCI.psCertContext         = (CERT_CONTEXT *)ciCert.pCertificate;
    sWTCI.chStores              = 1;
    sWTCI.pahStores  = (HCERTSTORE *)&ciCert.pCertificate->hCertStore;


    memset(&polHttps, 0x00, sizeof(HTTPSPolicyCallbackData));
    polHttps.cbStruct =  sizeof(HTTPSPolicyCallbackData);
    polHttps.dwAuthType = AUTHTYPE_SERVER;
    polHttps.fdwChecks = dwCertFlags;
    
    cbServerName = MultiByteToWideChar(CP_ACP, 0, m_lpszHostName, -1, NULL, 0);

    polHttps.pwszServerName = New WCHAR[cbServerName+1];

    if(polHttps.pwszServerName == 0)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    sWTCI.pcwszDisplayName      = polHttps.pwszServerName;

    cbServerName = MultiByteToWideChar(CP_ACP, 0, m_lpszHostName, -1, polHttps.pwszServerName, cbServerName);

    error = LoadWinTrust();
    if(ERROR_SUCCESS == error)
    {
        error = WinVerifySecureChannel(NULL, &sWTD);
    }

    error = MapInternetError(error, &dwStatusFlag);


    //
    // If there was problem with the certificate and the caller requested
    // combined SSL errors cycle through all possible certificate errors.
    //

    if (ERROR_SUCCESS != error && m_pSecurityInfo)
    {
        BOOL  fCertError = FALSE;
 
        do
        {
            if (dwStatusFlag & WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CA)
            {
                polHttps.fdwChecks |=  DLG_FLAGS_IGNORE_INVALID_CA;
                dwFlags |= DLG_FLAGS_INVALID_CA;
                m_pSecurityInfo->SetStatusFlags(WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CA);
                if (!(dwCertFlags & SECURITY_FLAG_IGNORE_UNKNOWN_CA))
                    fCertError = TRUE;
            }
            else if (dwStatusFlag & WINHTTP_CALLBACK_STATUS_FLAG_CERT_CN_INVALID)
            {
                polHttps.fdwChecks |= DLG_FLAGS_IGNORE_CERT_CN_INVALID;
                dwFlags |= DLG_FLAGS_SEC_CERT_CN_INVALID;
                m_pSecurityInfo->SetStatusFlags(WINHTTP_CALLBACK_STATUS_FLAG_CERT_CN_INVALID);
                if (!(dwCertFlags & INTERNET_FLAG_IGNORE_CERT_CN_INVALID))
                    fCertError = TRUE;
            }
            else if (dwStatusFlag & WINHTTP_CALLBACK_STATUS_FLAG_CERT_DATE_INVALID)
            {
                polHttps.fdwChecks |= DLG_FLAGS_IGNORE_CERT_DATE_INVALID;
                dwFlags |= DLG_FLAGS_SEC_CERT_DATE_INVALID;
                m_pSecurityInfo->SetStatusFlags(WINHTTP_CALLBACK_STATUS_FLAG_CERT_DATE_INVALID);
                if (!(dwCertFlags & INTERNET_FLAG_IGNORE_CERT_DATE_INVALID))
                    fCertError = TRUE;
            }
            else if (dwStatusFlag & WINHTTP_CALLBACK_STATUS_FLAG_CERT_REVOKED)
            {
                // In wininet, we break out on revoked and only pass it back.
                // This is because the UI is broken into only 2 buckets, and
                // revoked takes precedence.
                sWTD.fdwRevocationChecks = 0;
                m_pSecurityInfo->SetStatusFlags(WINHTTP_CALLBACK_STATUS_FLAG_CERT_REVOKED);
                fCertError = TRUE;
            }
            else if (dwStatusFlag & WINHTTP_CALLBACK_STATUS_FLAG_CERT_REV_FAILED)
            {
                // In wininet, this was handled outside the loop as a special
                // case.  There's no need for that now, so OR the error in and
                // continue.
                sWTD.fdwRevocationChecks = 0;
                dwFlags |= DLG_FLAGS_SEC_CERT_REV_FAILED;
                m_pSecurityInfo->SetStatusFlags(WINHTTP_CALLBACK_STATUS_FLAG_CERT_REV_FAILED);
                fCertError = TRUE;
            }
            else
            {
                //
                // Pass all other errors through.
                //

                break;
            }

            error = WinVerifySecureChannel(NULL, &sWTD);

            error = MapInternetError(error, &dwStatusFlag);

        } while (ERROR_SUCCESS != error);

        //
        // Change the error only if one of the known certifciate errors was
        // encountered.
        //

        if (m_pSecurityInfo->GetStatusFlags())
        {
            // Just send a status notification if there's an error,
            // and let the app decide if this should be closed as a failure.
            if (lpThreadInfo)
            {
                WINHTTP_STATUS_CALLBACK appCallback = NULL;
                RGetStatusCallback(hInternetMapped, &appCallback);
                if (appCallback)
                {
                    DWORD dwStatusFlags = m_pSecurityInfo->GetStatusFlags();
                    // Report SSL status of all errors found
                    InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_SECURE_FAILURE,
                                           &dwStatusFlags,
                                           sizeof(dwStatusFlags)
                                           );

                }
            }
            // ...except if the client told us upfront to fail.
            if (fCertError &&
                   (m_pSecurityInfo->GetSecureFlags() &
                    SECURITY_FLAG_BREAK_ON_STATUS_SECURE_FAILURE))
            {
                error = ERROR_WINHTTP_SECURE_FAILURE;
            }
            else
            {
                error = SUCCESS;
            }
            m_pSecurityInfo->SetSecureFlags(dwFlags);
        }
    }

    delete polHttps.pwszServerName;

    if(ciCert.pCertificate)
    {
        WRAP_REVERT_USER_VOID(CertFreeCertificateContext, (ciCert.pCertificate));
    }

    if (error != ERROR_SUCCESS)
    {
        goto quit;
    }

    if(m_pSecurityInfo && (!m_pSecurityInfo->InCache()))
    {
        // Add it to the cache if it's not already there.
        /* SCLE ref */

        // Use global or session cache, depending on the settings
        // This was mapped when initializing the socket with SetHostName
        if (m_pCertCache)
            m_pCertCache->Add(m_pSecurityInfo);
    }

quit:                                 
    if (lpThreadInfo != NULL) {
        _InternetSetObjectHandle(lpThreadInfo, hInternet, hInternetMapped);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::NegotiateSecConnection(
    IN DWORD dwFlags,
    OUT LPBOOL lpbAttemptReconnect
    )

/*++

Routine Description:

    This function establishes a secure channel with the server by
    performing the security handshake protocol.  It will walk
    the list of installed security packages until it finds a package
    that succeeds in the security handshake.  If one package fails
    it is up to the caller to re-call NegotiateSecConnection with
    a re-opened socket so another socket can attempt the connection.

Arguments:

    dwFlags    - Socket Flags that may need to be passed on to Socket Calls
                (needed to support Async I/O)

    lpbAttemptReconnect - on return, if this value is TRUE, the caller should call
                          this function again, and it will try another protocol.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::NegotiateSecConnection",
                 "{%#x [%#x]} %#x, %#x [%B]",
                 this,
                 m_Socket,
                 dwFlags,
                 lpbAttemptReconnect,
                 *lpbAttemptReconnect
                 ));

    INET_ASSERT(IsSecure());

    DWORD error = DoFsm(New CFsm_SecureNegotiate(dwFlags,
                                                 lpbAttemptReconnect,
                                                 this
                                                 ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SecureNegotiate::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SecureNegotiate::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSecureSocket * pSecureSocket = (ICSecureSocket *)Fsm->GetContext();
    CFsm_SecureNegotiate * stateMachine = (CFsm_SecureNegotiate *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pSecureSocket->SecureNegotiate_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::SecureNegotiate_Fsm(
    IN CFsm_SecureNegotiate * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::SecureNegotiate_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_SecureNegotiate & fsm = *Fsm;
    DWORD error = fsm.GetError();
    DWORD dwSSPIFlags = 0;
    DWORD dwStatusFlag = 0;

    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_2:
            goto send_continue;

        case FSM_STATE_3:
            goto negotiate_loop_continue;

        default:
            error = ERROR_WINHTTP_INTERNAL_ERROR;

            INET_ASSERT(FALSE);

            goto quit;
        }
    }

    INET_ASSERT(IsOpen());

    *fsm.m_lpbAttemptReconnect = FALSE;

    //
    // set OutBuffer for InitializeSecurityContext call
    //

    fsm.m_OutBuffer.cBuffers = 1;
    fsm.m_OutBuffer.pBuffers = fsm.m_OutBuffers;
    fsm.m_OutBuffer.ulVersion = SECBUFFER_VERSION;

    if(GlobalSecureProtocols != GlobalSecureProtocolsCopy)
    {
        if (LOCK_SECURITY())
        {
            //ReInit the credentials if our settings have changed.
            SecurityPkgInitialize();
            UNLOCK_SECURITY();
        }
        else
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto error_exit;
        }
    }

    //
    // Pick the provider we're going to use.
    //

    while ((SecProviders[GetProviderIndex()].pszName != NULL)
           && ( !SecProviders[GetProviderIndex()].fEnabled
             || !(SecProviders[GetProviderIndex()].dwProtocolFlags & GlobalSecureProtocols) ) ) {

        //
        // Next provider
        //

        SetProviderIndex(GetProviderIndex() + 1);
    }

    if (SecProviders[GetProviderIndex()].pszName == NULL) {

        //
        // BUGBUG shouldn't we error out here?
        //

        SetProviderIndex(0);
        goto error_exit;
    }

    DWORD i;

    i = GetProviderIndex();

    DEBUG_PRINT(API,
                INFO,
                ("Starting handshake protocol with pkg %d - %s\n",
                i,
                SecProviders[i].pszName
                ));


    //
    // 1. initiate a client HELLO message and generate a token
    //

    fsm.m_OutBuffers[0].pvBuffer = NULL;
    fsm.m_OutBuffers[0].BufferType = SECBUFFER_TOKEN;

    SECURITY_STATUS scRet;
    DWORD ContextAttr;
    TimeStamp tsExpiry;

    fsm.m_bDoingClientAuth = FALSE;

    // Resynchronize the certificate store to catch
    // recently installed certificates
    if (g_hMyCertStore)
    {
        WRAP_REVERT_USER_VOID(CertControlStore,
                              (g_hMyCertStore, 0, CERT_STORE_CTRL_AUTO_RESYNC, NULL));
    }

    //
    // We need a credential handle,
    //  if we're doing client do the magic to get a specialized
    //  one otherwise use the standard global one.
    //

    if ( IsCredClear(fsm.m_hCreds) )
    {
        fsm.m_hCreds = SecProviders[i].hCreds;

        if (GetCertContextArray())
        {
            if (GetCertContextArray()->GetSelectedCertContext())
            {
                error = CliAuthSelectCredential(
                            &m_hContext,
                            SecProviders[i].pszName,
                            GetCertContextArray(),
                            &fsm.m_hCreds,
                            &dwStatusFlag);

                if (error != ERROR_SUCCESS) {
                    goto quit;
                }

                fsm.m_bDoingClientAuth = TRUE;
            }

            dwSSPIFlags |= ISC_REQ_USE_SUPPLIED_CREDS;
        }
    }

    // Force a full handshake when per session and entry isn't in the cache.
    if (m_pCertCache != &GlobalCertCache && !m_pSecurityInfo->InCache())
        dwSSPIFlags |= ISC_REQ_USE_SESSION_KEY;

    WRAP_REVERT_USER(g_InitializeSecurityContext,
                     (&fsm.m_hCreds,
                     NULL,
                     (LPSTR)GetHostName(),
                     ISC_REQ_SEQUENCE_DETECT
                     | ISC_REQ_REPLAY_DETECT
                     | ISC_REQ_CONFIDENTIALITY
                     | ISC_REQ_ALLOCATE_MEMORY
                     | dwSSPIFlags,
                     0,
                     SECURITY_NATIVE_DREP,
                     NULL,       // default, don't do hack.
                     0,
                     &m_hContext,
                     &fsm.m_OutBuffer, // address where output data go
                     &ContextAttr,
                     &tsExpiry),
                     scRet);

    DEBUG_PRINT(API,
                INFO,
                ("1. InitializeSecurityContext returned %s [%x]. hContext = %#x:%#x\n",
                InternetMapSSPIError((DWORD)scRet),
                scRet,
                m_hContext.dwUpper,
                m_hContext.dwLower
                ));

    if (scRet == SEC_E_INVALID_HANDLE) {
         SecProviders[i].fEnabled = FALSE;
    }
    if (scRet == SEC_E_INVALID_TOKEN) {
        error = ERROR_WINHTTP_CANNOT_CONNECT;
    } else {

        //
        // Turn the error in to one we understand */
        //

        error = MapInternetError((DWORD)scRet, &dwStatusFlag);
    }
    if (scRet != SEC_I_CONTINUE_NEEDED) {
        goto error_exit;
    }

    DEBUG_PRINT(API,
                INFO,
                ("1. OutBuffer is <%x, %d, %x>\n",
                fsm.m_OutBuffers[0].pvBuffer,
                fsm.m_OutBuffers[0].cbBuffer,
                fsm.m_OutBuffers[0].BufferType
                ));

    if ((fsm.m_OutBuffers[0].cbBuffer != 0)
    && (fsm.m_OutBuffers[0].pvBuffer != NULL)) {

        //
        // Send response to server if there is one
        //

        fsm.SetFunctionState(FSM_STATE_2);
        error = ICSocket::Send(fsm.m_OutBuffers[0].pvBuffer,
                               fsm.m_OutBuffers[0].cbBuffer,
                               0
                               );
        if (error == ERROR_IO_PENDING) {
            goto quit;
        }

send_continue:

        g_FreeContextBuffer(fsm.m_OutBuffers[0].pvBuffer);
        fsm.m_OutBuffers[0].pvBuffer = NULL;
        if (error != ERROR_SUCCESS) {

            //
            // We should deal with this better
            //

            goto error_exit;
        }
    }

    fsm.SetFunctionState(FSM_STATE_3);
    error = SSPINegotiateLoop(NULL, fsm.m_dwFlags, fsm.m_hCreds, TRUE, fsm.m_bDoingClientAuth);

    //
    // We're not actually deleting the handle, rather we're no longer keeping
    //  a reference to the Credential handle in our fsm after we hand it off
    //

    if ( fsm.m_bDoingClientAuth )
    {
        ClearCreds(fsm.m_hCreds);
        fsm.m_bDoingClientAuth = FALSE;
    }
    if (error == ERROR_IO_PENDING) {
        goto quit;
    }

negotiate_loop_continue:
error_exit:

    if (error == ERROR_WINHTTP_SECURE_FAILURE && m_pSecurityInfo)
        m_pSecurityInfo->SetStatusFlags(dwStatusFlag);
    
    if (error == ERROR_WINHTTP_CANNOT_CONNECT) {

        //
        // error was a CANNOT_CONNECT, so try the next protocol.
        //

        SetProviderIndex(GetProviderIndex() + 1);

        if (SecProviders[GetProviderIndex()].pszName == NULL) {
            SetProviderIndex(0);
            *fsm.m_lpbAttemptReconnect = FALSE;
        } else {
            *fsm.m_lpbAttemptReconnect = TRUE;
        }
    }

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::SSPINegotiateLoop(
    OUT DBLBUFFER * pdblbufBuffer,
    IN DWORD dwFlags,
    CredHandle hCreds,
    IN BOOL bDoInitialRead,
    IN BOOL bDoingClientAuth
    )

/*++

Routine Description:

    This function completes the handshakes needed to establish a
    security protocol.  The initial handshakes are either generated
    by NegotiateSecureConnection, when generating a new connection, or
    during a receive when a REDO request is received.

Arguments:

    pdblbufBuffer - an input buffer into which to put any Extra data left over
                    after the handshake.  This data is assumed to be application
                    data, and will be decrypted later.

    dwFlags    - Socket Flags that may need to be passed on to Socket Calls
                (needed to support Async I/O)

    bDoInitialRead - if TRUE, this function will do a read before calling
                     InitializeSecurityContext, otherwise, it passes in 0 bytes of data.

Return Value:

    ERROR_SUCCESS - we successfully completed our connection.
    ERROR_WINHTTP_CANNOT_CONNECT - The connection was dropped on us, possibly because we used a bad
                                    protocol.  Try the next protocol.

    ERROR_*                       - Other internet error, disconnect.


Comments:

    BUGBUG (hack alert) [arthurbi]
    Do to a bug in IIS 1.0 Servers we cannot connect because
    we send a "Client SSL 3 Message".  This message confuses the
    server and causes it to close the socket.  The fix is to
    reopen the socket and send a "Client SSL 2 Message."  Newer
    versions of the server will be fixed.


--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::SSPINegotiateLoop",
                 "{%#x [%#x]} %#x, %#x, %B",
                 this,
                 m_Socket,
                 pdblbufBuffer,
                 dwFlags,
                 bDoInitialRead
                 ));

    INET_ASSERT(IsSecure());

    DWORD error = DoFsm(New CFsm_NegotiateLoop(pdblbufBuffer,
                                               dwFlags,
                                               bDoInitialRead,
                                               bDoingClientAuth,
                                               hCreds,
                                               this
                                               ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_NegotiateLoop::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_NegotiateLoop::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSecureSocket * pSecureSocket = (ICSecureSocket *)Fsm->GetContext();
    CFsm_NegotiateLoop * stateMachine = (CFsm_NegotiateLoop *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pSecureSocket->NegotiateLoop_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::NegotiateLoop_Fsm(
    IN CFsm_NegotiateLoop * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::NegotiateLoop_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_NegotiateLoop & fsm = *Fsm;
    DWORD error = fsm.GetError();
    DWORD dwStatus = 0;

    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_2:
            goto receive_continue;

        case FSM_STATE_3:
            goto send_continue;

        default:
            error = ERROR_WINHTTP_INTERNAL_ERROR;

            INET_ASSERT(FALSE);

            goto quit;
        }
    }

    INET_ASSERT(IsOpen());

    fsm.m_dwProviderIndex = GetProviderIndex();

    fsm.m_dwSSPIFlags = ISC_REQ_SEQUENCE_DETECT
                      | ISC_REQ_REPLAY_DETECT
                      | ISC_REQ_CONFIDENTIALITY
                      | ISC_REQ_ALLOCATE_MEMORY
                      | ISC_RET_EXTENDED_ERROR;

    //
    // set OutBuffer for InitializeSecurityContext call
    //

    fsm.m_OutBuffer.cBuffers = 1;
    fsm.m_OutBuffer.pBuffers = fsm.m_OutBuffers;
    fsm.m_OutBuffer.ulVersion = SECBUFFER_VERSION;

    //
    // If we have a selected cert chain, then try to
    // generate a credential from that list.
    //

    if (IsCredClear(fsm.m_hCreds))
    {
        fsm.m_hCreds = SecProviders[fsm.m_dwProviderIndex].hCreds;

        if ( GetCertContextArray() &&
             GetCertContextArray()->GetSelectedCertContext() )
        {
            error = CliAuthSelectCredential(
                        &m_hContext,
                        SecProviders[fsm.m_dwProviderIndex].pszName,
                        GetCertContextArray(),
                        &fsm.m_hCreds,
                        &dwStatus);

            if (error != ERROR_SUCCESS) {
                goto quit;
            }

            fsm.m_bDoingClientAuth = TRUE;
        }
    }

    if (fsm.m_bDoingClientAuth ||
        GetCertContextArray() )
    {
        fsm.m_dwSSPIFlags |= ISC_REQ_USE_SUPPLIED_CREDS;
    }

    // Force a full handshake when per session and entry isn't in the cache.
    if (m_pCertCache == &GlobalCertCache && !m_pSecurityInfo->InCache())
        fsm.m_dwSSPIFlags |= ISC_REQ_USE_SESSION_KEY;

    fsm.m_scRet = SEC_I_CONTINUE_NEEDED;

    while (fsm.m_scRet == SEC_I_CONTINUE_NEEDED ||
           fsm.m_scRet == SEC_E_INCOMPLETE_MESSAGE ||
           fsm.m_scRet == SEC_I_INCOMPLETE_CREDENTIALS) {

        //
        //  send to target server
        //  if we've got a SEC_E_INCOMPLETE_MESSAGE we need to do a read
        //  again because we didn't get the entire message we expected from
        //  the server.
        //


        //
        //  receive response from server and pass token into security pkg
        //    BUT only if we haven't already received extra data
        //    from SSPI which we need to process in lu of actual data
        //    data from WinSock, and if the package has not returned
        //    one of the defined warnings that indicates that we should
        //    pass the previous buffer again.
        //


        // Make sure fsm.m_lpszBuffer holds the input data to be passed
        // to initialize security context.  There are 4 cases:
        // 1) We have Extra Data, so we don't need to do a socket receive
        // 2) We were called during a re-negotiate, so if this is the first
        //    time through the loop, we have 0 bytes.
        // 3) We are recovering from a SEC_I_INCOMPLETE_CREDENTIALS, so
        //    use the same buffer again.
        // 4) We do a SocketReceive
        // We'll indicate 1 and 3 by having the fsm.m_dwBytesReceived count being the number of bytes
        // left in the buffer to be re-sent or sent to the sspi call.
        // If bytes-received is zero, then either we are doing a Redo, or we need to receive
        // data.  fsm.m_bDoRead let's us know if for some reason we should do or not do this read



        if ((0 == fsm.m_dwBytesReceived) || (fsm.m_scRet == SEC_E_INCOMPLETE_MESSAGE)) {
            if (fsm.m_bDoRead) {
                fsm.SetFunctionState(FSM_STATE_2);
                error = ICSocket::Receive((LPVOID *)&fsm.m_lpszBuffer,
                                          &fsm.m_dwBufferLength,
                                          &fsm.m_dwBufferLeft,
                                          &fsm.m_dwBytesReceived,
                                          0,
                                          SF_EXPAND,
                                          &fsm.m_bEofReceive
                                          );
                if (error == ERROR_IO_PENDING) {
                    goto done;
                }

receive_continue:

                if ((error != ERROR_SUCCESS) || fsm.m_bEofReceive) {

                    DEBUG_PRINT(API,
                                ERROR,
                                ("SocketReceive failed\n"
                                ));

                    if (error == ERROR_SUCCESS) {
                        error = ERROR_WINHTTP_CANNOT_CONNECT;
                    }
                    break;
                }
            } else {
                fsm.m_bDoRead = TRUE;
            }
        }

        if (fsm.m_scRet == SEC_I_INCOMPLETE_CREDENTIALS) {

            CERT_CONTEXT_ARRAY* pCertContextArray;

            //
            // If've already done Client Auth, and it fails again
            //  then we fail.
            //

            if (fsm.m_bDoingClientAuth) {
                error = ERROR_CANCELLED;
                goto quit;
            }

            //
            // If we don't already have a cert chain list,
            // then get one, and make our selection
            //

            INET_ASSERT(!GetCertContextArray());

            pCertContextArray = NULL;

            //delete pCertChainList;
            //SetCertChainList(NULL);

            error = CliAuthAcquireCertContexts(
                        &m_hContext,
                        SecProviders[fsm.m_dwProviderIndex].pszName,
                        &pCertContextArray,
                        &dwStatus
                        );

            SetCertContextArray(pCertContextArray);

            if (error == ERROR_SUCCESS) {
                error = ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED;
            }

            fsm.m_scRet = error;
            break;
        }

        //
        // InBuffers[1] is for getting extra data that
        //  SSPI/SCHANNEL doesn't proccess on this
        //  run around the loop.
        //

        fsm.m_InBuffers[0].pvBuffer   = fsm.m_lpszBuffer;
        fsm.m_InBuffers[0].cbBuffer   = fsm.m_dwBytesReceived;
        fsm.m_InBuffers[0].BufferType = SECBUFFER_TOKEN;

        fsm.m_InBuffers[1].pvBuffer   = NULL;
        fsm.m_InBuffers[1].cbBuffer   = 0;
        fsm.m_InBuffers[1].BufferType = SECBUFFER_EMPTY;

        //
        // Initialize these so if we fail, pvBuffer contains NULL,
        // so we don't try to free random garbage at the quit
        //

        fsm.m_OutBuffers[0].pvBuffer   = NULL;
        fsm.m_OutBuffers[0].BufferType = SECBUFFER_TOKEN;
        fsm.m_OutBuffers[0].cbBuffer   = 0;

        SecBufferDesc InBuffer;

        InBuffer.cBuffers        = 2;
        InBuffer.pBuffers        = fsm.m_InBuffers;
        InBuffer.ulVersion       = SECBUFFER_VERSION;

        DWORD ContextAttr;
        TimeStamp tsExpiry;

        WRAP_REVERT_USER(g_InitializeSecurityContext,
                         (&fsm.m_hCreds,
                          &m_hContext,
                          NULL,
                          fsm.m_dwSSPIFlags,
                          0,
                          SECURITY_NATIVE_DREP,
                          &InBuffer,
                          0,
                          NULL,
                          &fsm.m_OutBuffer,
                          &ContextAttr,
                          &tsExpiry),
                         fsm.m_scRet);

        DEBUG_PRINT(API,
                    INFO,
                    ("3. InitializeSecurityContext returned %s [%x]\n",
                    InternetMapSSPIError((DWORD)fsm.m_scRet),
                    fsm.m_scRet
                    ));

        if (fsm.m_scRet == STATUS_SUCCESS ||
             fsm.m_scRet == SEC_I_CONTINUE_NEEDED ||
             (FAILED(fsm.m_scRet) && (0 != (ContextAttr & ISC_RET_EXTENDED_ERROR))))
        {
            if  (fsm.m_OutBuffers[0].cbBuffer != 0    &&
                 fsm.m_OutBuffers[0].pvBuffer != NULL )
            {

                //
                // Send response to server if there is one
                //

                fsm.SetFunctionState(FSM_STATE_3);
                error = ICSocket::Send(fsm.m_OutBuffers[0].pvBuffer,
                                       fsm.m_OutBuffers[0].cbBuffer,
                                       0
                                       );
                if (error == ERROR_IO_PENDING) {
                    goto done;
                }

send_continue:

                g_FreeContextBuffer(fsm.m_OutBuffers[0].pvBuffer);
                fsm.m_OutBuffers[0].pvBuffer = NULL;
            }
        }


        if ( fsm.m_scRet == STATUS_SUCCESS )
        {
            DEBUG_PRINT(API,
                     INFO,
                    ("NegotiateSecConnection succeeded.\n"));


            if (fsm.m_pdblbufBuffer)
            {
                if ( fsm.m_InBuffers[1].BufferType == SECBUFFER_EXTRA )
                {

                    fsm.m_pdblbufBuffer->CopyIn(
                        (LPBYTE) (fsm.m_lpszBuffer + (fsm.m_dwBytesReceived - fsm.m_InBuffers[1].cbBuffer)),
                        fsm.m_InBuffers[1].cbBuffer
                        );

                }
                else
                {
                    fsm.m_pdblbufBuffer->SetInputBufferSize(0);
                }
            }



            //
            // Bail out to quit
            //

            break;
        }
        else if (FAILED(fsm.m_scRet) && (fsm.m_scRet != SEC_E_INCOMPLETE_MESSAGE))
        {

             //
             //  free security context handle and delete the local
             //  data structures associated with the handle and
             //  try another pkg if available
             //

             DEBUG_PRINT(API,
                         INFO,
                         ("3. InitializeSecurityContext failed, %lx\n",
                         fsm.m_scRet
                         ));


             // Turn the error in to one we understand */
             error = MapInternetError((DWORD)fsm.m_scRet, &dwStatus);

             TerminateSecConnection();
             /* Break out to try next protocol */
             break;
        }

        if ((fsm.m_scRet != SEC_E_INCOMPLETE_MESSAGE)
        && (fsm.m_scRet != SEC_I_INCOMPLETE_CREDENTIALS)) {

            DEBUG_PRINT(API,
                        INFO,
                        ("3. OutBuffer is <%x, %d, %x>\n",
                        fsm.m_OutBuffers[0].pvBuffer,
                        fsm.m_OutBuffers[0].cbBuffer,
                        fsm.m_OutBuffers[0].BufferType
                        ));

            if (fsm.m_InBuffers[1].BufferType == SECBUFFER_EXTRA) {

                //
                // skip next recv and set up buffers
                //  so InitalizeSecurityContext pulls its
                //  info from the Extra it returned previously.
                //

                DEBUG_PRINT(API,
                         INFO,
                         ("Got SECBUFFER_EXTRA, moving %d bytes to front of buffer\n",
                         fsm.m_InBuffers[1].cbBuffer
                         ));

                INET_ASSERT(fsm.m_InBuffers[1].cbBuffer > 0);

                MoveMemory(
                        fsm.m_lpszBuffer,             // dest
                        fsm.m_lpszBuffer + (fsm.m_dwBytesReceived - fsm.m_InBuffers[1].cbBuffer),
                        fsm.m_InBuffers[1].cbBuffer   // size
                        );

                fsm.m_dwBytesReceived = fsm.m_InBuffers[1].cbBuffer;
                fsm.m_dwBufferLeft   = fsm.m_dwBufferLength - fsm.m_dwBytesReceived;
            } else {

                //
                // prepare for next receive
                //

                fsm.m_dwBufferLeft = fsm.m_dwBufferLength;
                fsm.m_dwBytesReceived = 0;
            }
        }
    }

quit:

    if (fsm.m_lpszBuffer != NULL)
    {
         fsm.m_lpszBuffer = (LPSTR)FREE_MEMORY(fsm.m_lpszBuffer);
         INET_ASSERT(fsm.m_lpszBuffer == NULL);
    }

done:

    if (error != ERROR_IO_PENDING)
    {
        DWORD dwStatus;
        if (m_pSecurityInfo && (dwStatus = m_pSecurityInfo->GetStatusFlags()))
        {
            // Report SSL status of all errors found
            DWORD dwStatus = m_pSecurityInfo->GetStatusFlags();
            InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_SECURE_FAILURE,
                                   &dwStatus,
                                   sizeof(dwStatus)
                                   );
        }
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::Disconnect(
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Undoes the work of ConnectSocket - i.e. closes a connected socket. We make
    callbacks to inform the app that this socket is being closed

Arguments:

    dwFlags - controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Disconnect",
                 "{%#x} %#x",
                 m_Socket,
                 dwFlags
                 ));

    DWORD error = ICSocket::Disconnect(dwFlags);

    //
    // delete security context handle for the connection
    //

    if ((m_dwFlags & (SF_ENCRYPT | SF_DECRYPT))
    && dwEncFlags != ENC_CAPS_NOT_INSTALLED) {
        TerminateSecConnection();
    }

    //
    // Zero out the pending input buffer
    //

    if (m_pdblbufBuffer != NULL) {
        m_pdblbufBuffer->SetInputBufferSize(0);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::Send(
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Sends data over a secure connection

Arguments:

    lpBuffer        - pointer to user data to send

    dwBufferLength  - length of user data

    dwFlags         - flags controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Send",
                 "{%#x [%#x]} %#x, %d, %#x",
                 this,
                 m_Socket,
                 lpBuffer,
                 dwBufferLength,
                 dwFlags
                 ));

    INET_ASSERT(lpBuffer != NULL);
    INET_ASSERT((int)dwBufferLength > 0);

    DWORD error;

    if (IsSecure())  // might be attempting http CONNECT
    {
        error = DoFsm(New CFsm_SecureSend(lpBuffer,
                                          dwBufferLength,
                                          dwFlags,
                                          this
                                          ));
    }
    else
    {
        // thunk to non-secure send
        error = ICSocket::Send(lpBuffer,
                               dwBufferLength,
                               dwFlags
                               );
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SecureSend::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SecureSend::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSecureSocket * pSecureSocket = (ICSecureSocket *)Fsm->GetContext();
    CFsm_SecureSend * stateMachine = (CFsm_SecureSend *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pSecureSocket->Send_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::Send_Fsm(
    IN CFsm_SecureSend * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Send_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_SecureSend & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if (fsm.GetState() == FSM_STATE_INIT) {

        //
        // Log The Data BEFORE we Encrypt It ( if we do )
        //

        DEBUG_DUMP_API(SOCKETS,
                       "sending data:\n",
                       fsm.m_lpBuffer,
                       fsm.m_dwBufferLength
                       );

    }

    while (((int)fsm.m_dwBufferLength > 0) && (error == ERROR_SUCCESS)) {

        LPVOID lpBuffer;
        DWORD dwLength;
        DWORD dwBytes;

        if (m_dwFlags & SF_ENCRYPT) {

            DWORD dwBytesEncrypted;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("Encrypting data..\n"
                        ));

            error = EncryptData(fsm.m_lpBuffer,
                                fsm.m_dwBufferLength,
                                &fsm.m_lpCryptBuffer,
                                &fsm.m_dwCryptBufferLength,
                                &dwBytesEncrypted
                                );
            if (error != ERROR_SUCCESS) {
                break;
            }

            INET_ASSERT(fsm.m_lpCryptBuffer != NULL);
            INET_ASSERT((int)fsm.m_dwCryptBufferLength > 0);
            INET_ASSERT(dwBytesEncrypted <= fsm.m_dwBufferLength);

            lpBuffer = fsm.m_lpCryptBuffer;
            dwLength = fsm.m_dwCryptBufferLength;
            dwBytes = dwBytesEncrypted;
        } else {
            lpBuffer = fsm.m_lpBuffer;
            dwLength = fsm.m_dwBufferLength;
            dwBytes = dwLength;
        }

        fsm.m_lpBuffer = (LPVOID)((LPBYTE)fsm.m_lpBuffer + dwBytes);
        fsm.m_dwBufferLength -= dwBytes;

        error = ICSocket::Send(lpBuffer, dwLength, fsm.m_dwFlags);
        if (error != ERROR_SUCCESS) {
            break;
        }
    }

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();

        //
        // Free Encryption Buffer if doing SSL/PCT
        //

        if (fsm.m_lpCryptBuffer != NULL ) {
            fsm.m_lpCryptBuffer = (LPVOID)FREE_MEMORY(fsm.m_lpCryptBuffer);
            INET_ASSERT(fsm.m_lpCryptBuffer == NULL);
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::Receive(
    IN OUT LPVOID* lplpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwBufferRemaining,
    IN OUT LPDWORD lpdwBytesReceived,
    IN DWORD dwExtraSpace,
    IN DWORD dwFlags,
    OUT LPBOOL lpbEof
    )

/*++

Routine Description:

    Receives and decrypts data from a secure connection

Arguments:

    lplpBuffer          - see ICSocket::Receive
    lpdwBufferLength    -
    lpdwBufferRemaining -
    lpdwBytesReceived   -
    dwExtraSpace        -
    dwFlags             -
    lpbEof              -

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    INET_ASSERT(lplpBuffer != NULL);
    INET_ASSERT(lpdwBufferLength != NULL);
    INET_ASSERT((*lpdwBufferLength == 0) ? (dwFlags & SF_EXPAND) : TRUE);

    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Receive",
                 "%#x [%#x], %#x [%d], %#x [%d], %#x [%d], %d, %#x, %#x [%B]",
                 lplpBuffer,
                 *lplpBuffer,
                 lpdwBufferLength,
                 *lpdwBufferLength,
                 lpdwBufferRemaining,
                 *lpdwBufferRemaining,
                 lpdwBytesReceived,
                 *lpdwBytesReceived,
                 dwExtraSpace,
                 dwFlags,
                 lpbEof,
                 *lpbEof
                 ));

    DWORD error;

    // Thunk to non-secure if establishing via a CONNECT
    if (IsSecure())
    {
        error = DoFsm(New CFsm_SecureReceive(lplpBuffer,
                                             lpdwBufferLength,
                                             lpdwBufferRemaining,
                                             lpdwBytesReceived,
                                             dwExtraSpace,
                                             dwFlags,
                                             lpbEof,
                                             this
                                             ));
    }
    else
    {
        error = ICSocket::Receive(lplpBuffer,
                                  lpdwBufferLength,
                                  lpdwBufferRemaining,
                                  lpdwBytesReceived,
                                  dwExtraSpace,
                                  dwFlags,
                                  lpbEof
                                  );
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SecureReceive::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SecureReceive::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSecureSocket * pSecureSocket = (ICSecureSocket *)Fsm->GetContext();
    CFsm_SecureReceive * stateMachine = (CFsm_SecureReceive *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pSecureSocket->Receive_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::Receive_Fsm(
    IN CFsm_SecureReceive * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Receive_Fsm",
                 "%#x",
                 Fsm
                 ));

    //INET_ASSERT(m_dwFlags & SF_DECRYPT);

    CFsm_SecureReceive & fsm = *Fsm;
    DWORD error = fsm.GetError();
    LPVOID * lplpBuffer;
    LPDWORD lpdwBufferLength;
    LPDWORD lpdwBufferLeft;
    LPDWORD lpdwBytesReceived;

    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_2:
            goto negotiate_continue;

        case FSM_STATE_3:
            goto receive_continue;

        default:
            error = ERROR_WINHTTP_INTERNAL_ERROR;

            INET_ASSERT(FALSE);

            goto quit;
        }
    }

    //
    // if we weren't given a buffer, but the caller told us its okay to resize
    // then we allocate the initial buffer
    //

    if ((fsm.m_dwBufferLength == 0) || (fsm.m_dwBufferLeft == 0)) {

        INET_ASSERT((fsm.m_dwBufferLength == 0) ? (fsm.m_dwBufferLeft == 0) : TRUE);

        if (fsm.m_dwFlags & SF_EXPAND) {

            //
            // allocate a fixed memory buffer
            //

            //
            // BUGBUG - the initial buffer size should come from the handle
            //          object
            //

            fsm.m_dwBufferLeft = DEFAULT_RECEIVE_BUFFER_INCREMENT;
            if (fsm.m_dwBufferLength == 0) {
                fsm.m_bAllocated = TRUE;
            }
            fsm.m_dwBufferLength += fsm.m_dwBufferLeft;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("resizing %#x to %d\n",
                        fsm.m_hBuffer,
                        fsm.m_dwBufferLength
                        ));

            fsm.m_hBuffer = ResizeBuffer(fsm.m_hBuffer,
                                         fsm.m_dwBufferLength,
                                         FALSE);
            if (fsm.m_hBuffer == (HLOCAL)NULL) {
                error = GetLastError();

                INET_ASSERT(error != ERROR_SUCCESS);

                fsm.m_bAllocated = FALSE;
            }
        } else {

            //
            // the caller didn't say its okay to resize
            //

            error = ERROR_INSUFFICIENT_BUFFER;
        }
    } else if (fsm.m_hBuffer == (HLOCAL)NULL) {
        error = ERROR_INSUFFICIENT_BUFFER;
    }
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // keep the app informed (if requested to do so)
    //

    if (fsm.m_dwFlags & SF_INDICATE) {
        InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE,
                               NULL,
                               0
                               );
    }

    fsm.m_dwReadFlags = fsm.m_dwFlags;

    //
    // Loop Through our Reads, assembling enough unencrypted bytes
    //  to return back to the client.  In the non-SSL/PCT case, we should
    //  be able to quit after one iteration.
    //

    do {

        LPVOID * lplpReadBuffer;
        LPDWORD lpdwReadBufferLength;
        LPDWORD lpdwReadBufferLeft;
        LPDWORD lpdwReadBufferReceived;

        //
        // If we're attempting to read SSL/PCT data, we need examine, whether
        // we have all the bytes decrypted and read already in our scratch buffer.
        //

        if (m_dwFlags & SF_DECRYPT) {

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("Decrypting data..\n"
                        ));

            if (m_pdblbufBuffer != NULL) {

                DEBUG_DUMP_API(SOCKETS,
                               "About to decrypt this data:\n",
                               (LPBYTE)m_pdblbufBuffer->GetInputBufferPointer(),
                               m_pdblbufBuffer->GetInputBufferSize()
                               );

            }

            fsm.m_dwDecryptError = DecryptData(&fsm.m_dwInputBytesLeft,
                                               (LPBYTE)fsm.m_hBuffer,
                                               &fsm.m_dwBufferLeft,
                                               &fsm.m_dwBytesReceived,
                                               &fsm.m_dwBytesRead
                                               );

            if (fsm.m_dwDecryptError == SEC_E_INCOMPLETE_MESSAGE &&
                fsm.m_bEof &&
                m_pdblbufBuffer->GetInputBufferSize() > 0) {

                error = ERROR_HTTP_INVALID_SERVER_RESPONSE;
                goto error_exit;

            }
            else if (fsm.m_dwDecryptError == SEC_I_RENEGOTIATE) {

                CredHandle hDummyCreds;

                //
                // BUGBUG - don't have to do this - Receive() called from
                //          SSPINegotiateLoop() won't come back through here
                //

                m_dwFlags &= ~(SF_ENCRYPT | SF_DECRYPT);
                ClearCreds(hDummyCreds);

                fsm.SetFunctionState(FSM_STATE_2);
                error = SSPINegotiateLoop(m_pdblbufBuffer,
                                          fsm.m_dwFlags,
                                          hDummyCreds,
                                          FALSE,
                                          FALSE);
                if (error == ERROR_IO_PENDING) {
                    goto error_exit;
                }

negotiate_continue:

                m_dwFlags |= (SF_ENCRYPT | SF_DECRYPT);

                if (error != ERROR_SUCCESS) {
                    break;
                }

                fsm.m_dwDecryptError = (ULONG)SEC_E_INCOMPLETE_MESSAGE;

                //
                // If there was extra data, and it was shoved back into
                // dblbuffer, then we should redo the decryption, since
                // it now has extra input data to process.
                //

                if (m_pdblbufBuffer->GetInputBufferSize() > 0) {
                    continue;
                }

                //
                // Okay, here we've received 0 bytes, so so we have to
                // receive more data, and process it.  Do this by zero-ing
                // out the input buffer, and setting the decrypt_error to be
                // Incomplete.
                //

            }

            //
            // If we have no buffer left to fill, or the caller ask for a single recv
            // and we've managed to read something into the buffer, then return by breaking.
            //

            if ((fsm.m_dwBufferLeft == 0)
            || (!(fsm.m_dwFlags & SF_RECEIVE_ALL) && (fsm.m_dwBytesRead > 0))) {
                break;  // we're done.
            }

            INET_ASSERT(error == ERROR_SUCCESS);

            //
            // BUGBUG [arthurbi] GetInputBufferSize needs to be called before getting
            //   the pointer, because the pointer may be moved around while generating
            //   the size.
            //

            DWORD remaining;
            DWORD inputSize;

            inputSize = m_pdblbufBuffer->GetInputBufferSize();
            remaining = m_pdblbufBuffer->GetInputBufferRemaining();
            fsm.m_dwBufferLengthDummy = inputSize + remaining;
            fsm.m_dwBufferLeftDummy = remaining;
            fsm.m_dwBufferReceivedDummy = inputSize;
            fsm.m_lpBufferDummy = m_pdblbufBuffer->GetInputBufferPointer();

            //
            // We need to be careful, and only recv one block of data at a time
            // if we're not we break keep-alive by doing too many reads.
            //
            // So unless we know ( by the non-0 return ) exactly how many bytes
            // to read, we shut off SF_RECEIVE_ALL.
            //

            fsm.m_dwReadFlags &= ~(SF_RECEIVE_ALL
                                   | SF_INDICATE
                                   | SF_EXPAND
                                   | SF_COMPRESS
                                   );

            if (fsm.m_dwInputBytesLeft != 0) {

                //
                // don't add RECEIVE_ALL if NO_WAIT already set by caller - they
                // are mutually exclusive
                //

                if (!(fsm.m_dwReadFlags & SF_NO_WAIT)) {
                    fsm.m_dwReadFlags |= SF_RECEIVE_ALL;
                }
                fsm.m_dwBufferLeftDummy = min(fsm.m_dwInputBytesLeft,
                                              fsm.m_dwBufferLeftDummy);
            }
            lplpReadBuffer = (LPVOID *)&fsm.m_lpBufferDummy;
            lpdwReadBufferLength = &fsm.m_dwBufferLengthDummy;
            lpdwReadBufferLeft = &fsm.m_dwBufferLeftDummy;
            lpdwReadBufferReceived = &fsm.m_dwBufferReceivedDummy;
        } else {
            lplpReadBuffer = &fsm.m_hBuffer;
            lpdwReadBufferLength = &fsm.m_dwBufferLength;
            lpdwReadBufferLeft = &fsm.m_dwBufferLeft;
            lpdwReadBufferReceived = &fsm.m_dwBytesReceived;
        }

        //
        // receive some data, assuming the socket is not closed.
        //

        if (!fsm.m_bEof) {
            //fsm.m_dwBytesReceivedPre = *lpdwReadBufferReceived;
            fsm.SetFunctionState(FSM_STATE_3);
            error = ICSocket::Receive(lplpReadBuffer,
                                      lpdwReadBufferLength,
                                      lpdwReadBufferLeft,
                                      lpdwReadBufferReceived,
                                      fsm.m_dwExtraSpace,
                                      fsm.m_dwReadFlags,
                                      &fsm.m_bEof
                                      );
            if (error == ERROR_IO_PENDING) {
                goto error_exit;
            }

receive_continue:

            //fsm.m_dwBytesRead += fsm.m_dwByReceived - fsm.m_dwDCBufferRecvPre;
            if (error != ERROR_SUCCESS) {
                goto quit;
            }

            //
            // Once again, for SSL/PCT we need to update our input buffer after the read.
            //

            if (m_dwFlags & SF_DECRYPT) {
                m_pdblbufBuffer->SetInputBufferSize(fsm.m_dwBufferReceivedDummy);
            }
        }
    } while ((m_dwFlags & SF_DECRYPT)
             && (error == ERROR_SUCCESS)
             && (fsm.m_dwDecryptError == SEC_E_INCOMPLETE_MESSAGE)
             && (!fsm.m_bEof || (m_pdblbufBuffer->GetInputBufferSize() > 0)));

    if (error == ERROR_SUCCESS) {

        //
        // inform the app that we finished, and tell it how much we received
        // this time
        //

        if (fsm.m_dwFlags & SF_INDICATE) 
        {
            DWORD dwBytesRead = fsm.m_dwBytesRead;
            InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED,
                                   &dwBytesRead,
                                   sizeof(dwBytesRead)
                                   );
        }

        //
        // if we received the entire response and the caller specified
        // SF_COMPRESS then we shrink the buffer to fit. We may end up growing
        // the buffer to contain dwExtraSpace if it is not zero and we just
        // happened to fill the current buffer
        //

        if (fsm.m_bEof && (fsm.m_dwFlags & SF_COMPRESS)) {

            fsm.m_dwBufferLeft = fsm.m_dwExtraSpace;

            //
            // include any extra that the caller required
            //

            fsm.m_dwBufferLength = fsm.m_dwBytesReceived + fsm.m_dwExtraSpace;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("shrinking buffer %#x to %d (%#x) bytes (includes %d extra)\n",
                        fsm.m_hBuffer,
                        fsm.m_dwBufferLength,
                        fsm.m_dwBufferLength,
                        fsm.m_dwExtraSpace
                        ));

            fsm.m_hBuffer = ResizeBuffer(fsm.m_hBuffer,
                                         fsm.m_dwBufferLength,
                                         FALSE);

            INET_ASSERT((fsm.m_hBuffer == NULL)
                        ? ((fsm.m_dwBytesReceived + fsm.m_dwExtraSpace) == 0)
                        : TRUE
                        );

        }

        DEBUG_PRINT_API(SOCKETS,
                        INFO,
                        ("read %d bytes @ %#x from socket %#x\n",
                        fsm.m_dwBytesRead,
                        (LPBYTE)fsm.m_hBuffer + *fsm.m_lpdwBytesReceived,
                        m_Socket
                        ));

        DEBUG_DUMP_API(SOCKETS,
                       "received data:\n",
                       (LPBYTE)fsm.m_hBuffer + *fsm.m_lpdwBytesReceived,
                       fsm.m_dwBytesRead
                       );

    }

quit:

    //
    // if we failed but allocated a buffer then we need to free it (we were
    // leaking this buffer if the request was cancelled)
    //

    if ((error != ERROR_SUCCESS) && fsm.m_bAllocated && (fsm.m_hBuffer != NULL)) {
//dprintf("SocketReceive() freeing allocated buffer %#x\n", hBuffer);
        fsm.m_hBuffer = (HLOCAL)FREE_MEMORY(fsm.m_hBuffer);

        INET_ASSERT(fsm.m_hBuffer == NULL);

        fsm.m_dwBufferLength = 0;
        fsm.m_dwBufferLeft = 0;
        fsm.m_dwBytesReceived = 0;
        fsm.m_bEof = TRUE;
    }

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("returning: lpBuffer=%#x, bufferLength=%d, bufferLeft=%d, bytesReceived=%d\n",
                fsm.m_hBuffer,
                fsm.m_dwBufferLength,
                fsm.m_dwBufferLeft,
                fsm.m_dwBytesReceived
                ));

    //
    // update output parameters
    //

    *fsm.m_lplpBuffer = (LPVOID)fsm.m_hBuffer;
    *fsm.m_lpdwBufferLength = fsm.m_dwBufferLength;
    *fsm.m_lpdwBufferRemaining = fsm.m_dwBufferLeft;
    *fsm.m_lpdwBytesReceived = fsm.m_dwBytesReceived;

    //
    // Hack, we hide eof's from caller, since we may have buffered data sitting around
    //

    if ((m_dwFlags & SF_DECRYPT) && (fsm.m_dwBytesRead != 0)) {
        fsm.m_bEof = FALSE;
    }

    *fsm.m_lpbEof = fsm.m_bEof;

    //
    // map any sockets error to WinInet error
    //

    if (error != ERROR_SUCCESS) {
        error = MapInternetError(error);
    }

error_exit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::SetHostName(
    IN LPSTR lpszHostName,
    IN SECURITY_CACHE_LIST *pCertCache
    )

/*++

Routine Description:

    Set name of server we are connected to. Find or create a security cache
    entry for this name

Arguments:

    lpszHostName    - name to set

    pCertCache      - SSL cert cache reference (global vs. session)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::SetHostName",
                 "{%#x [%q %#x/%d]} %q, %#x",
                 this,
                 m_lpszHostName,
                 GetSocket(),
                 GetSourcePort(),
                 lpszHostName,
                 pCertCache
                 ));

    INET_ASSERT(IsSecure());
    INET_ASSERT((lpszHostName != NULL) || (m_lpszHostName == NULL));

    DWORD error = ERROR_SUCCESS;

    if (lpszHostName != NULL) {
        if (m_lpszHostName != NULL) {
            m_lpszHostName = (LPSTR)FREE_MEMORY(m_lpszHostName);

            INET_ASSERT(m_lpszHostName == NULL);

        }
        m_pCertCache = pCertCache;
        m_lpszHostName = NewString(lpszHostName);
        if (m_lpszHostName == NULL) {
            error = ERROR_NOT_ENOUGH_MEMORY;
        } else if (m_pSecurityInfo == NULL) {
            /* SCLE ref */
            if (pCertCache)
                m_pSecurityInfo = pCertCache->Find(lpszHostName);
            if (m_pSecurityInfo == NULL) {
                /* SCLE ref */
                m_pSecurityInfo = New SECURITY_CACHE_LIST_ENTRY(lpszHostName);
            }
        }
    }

    DEBUG_LEAVE(error);

    return error;
}

//
// private ICSecureSocket methods
//


DWORD
ICSecureSocket::EncryptData(
    IN LPVOID lpBuffer,
    IN DWORD dwInBufferLen,
    OUT LPVOID * lplpBuffer,
    OUT LPDWORD lpdwOutBufferLen,
    OUT LPDWORD lpdwInBufferBytesEncrypted
    )

/*++

Routine Description:

    This function encrypts data in the lplpbuffer.

Arguments:

    lpBuffer         - pointer to buffer containing unencrypted user data

    dwInBufferLen    - length of input buffer

    lplpBuffer       - pointer to pointer to encrypted user buffer

    lpdwOutBufferLen - pointer to length of output lplpbuffer

    lpdwInBufferBytesEncrypted - pointer to length of bytes read and encrypted in output buffer

Return Value:

    Error Code

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::EncryptData",
                 "%#x, %d, %#x, %#x, %#x",
                 lpBuffer,
                 dwInBufferLen,
                 lplpBuffer,
                 lpdwOutBufferLen,
                 lpdwInBufferBytesEncrypted
                 ));

    SECURITY_STATUS scRet = STATUS_SUCCESS;
    SecBufferDesc Buffer;
    SecBuffer Buffers[3];
    HLOCAL hBuffer;
    DWORD error;
    DWORD dwMaxDataBufferSize;
    DWORD dwExtraInputBufferLen;
    SecPkgContext_StreamSizes Sizes;

    INET_ASSERT(IsSecure());
    INET_ASSERT(lpBuffer != NULL);
    INET_ASSERT(dwInBufferLen != 0);
    INET_ASSERT(lplpBuffer != NULL);
    INET_ASSERT(lpdwOutBufferLen != NULL);
    INET_ASSERT(lpdwInBufferBytesEncrypted != NULL);

    hBuffer = (HLOCAL) *lplpBuffer;
    *lpdwOutBufferLen = 0;
    *lpdwInBufferBytesEncrypted = 0;

    //INET_ASSERT(hBuffer == NULL );

    //
    //  find the header and trailer sizes
    //

    scRet = g_QueryContextAttributes(&m_hContext,
                                     SECPKG_ATTR_STREAM_SIZES,
                                     &Sizes );
    if (scRet != ERROR_SUCCESS) {

        //
        // Map the SSPI error.
        //

        DEBUG_PRINT(API,
                    INFO,
                    ("QueryContextAttributes returned, %s [%x] (%s)\n",
                    InternetMapSSPIError((DWORD)scRet),
                    scRet,
                    InternetMapError(scRet)
                    ));

        error = MapInternetError((DWORD) scRet);
        goto quit;
    } else {

        DEBUG_PRINT(API,
                    INFO,
                    ("QueryContextAttributes returned header=%d, trailer=%d, maxmessage=%d\n",
                    Sizes.cbHeader,
                    Sizes.cbTrailer,
                    Sizes.cbMaximumMessage
                    ));
    }

    INET_ASSERT(Sizes.cbMaximumMessage > (Sizes.cbHeader + Sizes.cbTrailer));

    //
    // Figure out the max SSL packet we can send over the wire.
    //  If the data is too big to send, then remeber how much
    //  we did send, and how much we didn't send.
    //

    dwMaxDataBufferSize = Sizes.cbMaximumMessage - (Sizes.cbHeader + Sizes.cbTrailer);

    dwExtraInputBufferLen =
            (dwMaxDataBufferSize < dwInBufferLen ) ?
                (dwInBufferLen - dwMaxDataBufferSize) : 0;

    dwInBufferLen =
            ( dwExtraInputBufferLen > 0 ) ?
            dwMaxDataBufferSize :
            dwInBufferLen;

    DEBUG_PRINT(API,
                INFO,
                ("resizing %#x to %d\n",
                hBuffer,
                dwInBufferLen + Sizes.cbHeader + Sizes.cbTrailer
                ));

    hBuffer = ResizeBuffer(hBuffer,
                           dwInBufferLen + Sizes.cbHeader + Sizes.cbTrailer,
                           FALSE );

    if (hBuffer == (HLOCAL)NULL) {
        error = GetLastError();

        INET_ASSERT(error != ERROR_SUCCESS);

        goto quit;
    }

    //
    // prepare data for SecBuffer
    //

    Buffers[0].pvBuffer = hBuffer;
    Buffers[0].cbBuffer = Sizes.cbHeader;
    Buffers[0].BufferType = SECBUFFER_TOKEN;

    Buffers[1].pvBuffer = (LPBYTE)hBuffer + Sizes.cbHeader;
    memcpy(Buffers[1].pvBuffer,
           lpBuffer,
           dwInBufferLen);

    Buffers[1].cbBuffer = dwInBufferLen;
    Buffers[1].BufferType = SECBUFFER_DATA;

    //
    // check if security pkg supports trailer: PCT does
    //

    if ( Sizes.cbTrailer ) {
         Buffers[2].pvBuffer = (LPBYTE)hBuffer + Sizes.cbHeader + dwInBufferLen;
         Buffers[2].cbBuffer = Sizes.cbTrailer;
         Buffers[2].BufferType = SECBUFFER_TOKEN;
    } else {
         Buffers[2].pvBuffer = NULL;
         Buffers[2].cbBuffer = 0;
         Buffers[2].BufferType = SECBUFFER_EMPTY;
    }

    Buffer.cBuffers = 3;
    Buffer.pBuffers = Buffers;
    Buffer.ulVersion = SECBUFFER_VERSION;

    scRet = g_SealMessage(&m_hContext,
                          0,
                          &Buffer,
                          0);

    DEBUG_PRINT(API,
                INFO,
                ("SealMessage returned, %s [%x]\n",
                InternetMapSSPIError((DWORD)scRet),
                scRet
                ));


    if (scRet != ERROR_SUCCESS) {

        //
        // Map the SSPI error.
        //

        DEBUG_PRINT(API,
                    ERROR,
                    ("SealMessage returned, %s [%x]\n",
                    InternetMapSSPIError((DWORD)scRet),
                    scRet
                    ));

        error = MapInternetError((DWORD) scRet);

        if (hBuffer != NULL) {
            FREE_MEMORY(hBuffer);
        }
        goto quit;
    } else {
        error = ERROR_SUCCESS;
    }

    *lplpBuffer = Buffers[0].pvBuffer;
    *lpdwOutBufferLen = Sizes.cbHeader + Buffers[1].cbBuffer +
                        Buffers[2].cbBuffer;
    *lpdwInBufferBytesEncrypted = dwInBufferLen;

    DEBUG_PRINT(API,
                INFO,
                ("SealMessage returned Buffer = %x, EncryptBytes = %d, UnencryptBytes=%d\n",
                *lplpBuffer,
                *lpdwOutBufferLen,
                dwInBufferLen
                ));

quit:

    DEBUG_LEAVE(error);

    return error;
}


#define SSLPCT_SMALLESTHEADERCHUNK      3


DWORD
ICSecureSocket::DecryptData(
    OUT DWORD * lpdwBytesNeeded,
    OUT LPBYTE lpOutBuffer,
    IN OUT LPDWORD lpdwOutBufferLeft,
    IN OUT LPDWORD lpdwOutBufferReceived,
    IN OUT LPDWORD lpdwOutBufferBytesRead
    )

/*++

Routine Description:

    This function decrypts data into the lpOutBuffer. It attempts to fill lpOutBuffer.
    If it fails, it may do so because more bytes are
    needed to fill lplpEncDecBuffer or lplpEndDecBuffer is not big enough to fully
    contain a complete server generated SSL/PCT message.


Return Value:

    Error Code

--*/

{
    INET_ASSERT(IsSecure());
    INET_ASSERT(lpOutBuffer);
    INET_ASSERT(lpdwOutBufferBytesRead);
    INET_ASSERT(lpdwBytesNeeded);

    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::DecryptData",
                 "{%#x [%#x:%#x], %#x} %#x [%d], %#x, %#x [%d], %#x [%d], %#x [%d]",
                 &m_hContext,
                 m_hContext.dwUpper,
                 m_hContext.dwLower,
                 m_pdblbufBuffer,
                 lpdwBytesNeeded,
                 *lpdwBytesNeeded,
                 lpOutBuffer,
                 lpdwOutBufferLeft,
                 *lpdwOutBufferLeft,
                 lpdwOutBufferReceived,
                 *lpdwOutBufferReceived,
                 lpdwOutBufferBytesRead,
                 *lpdwOutBufferBytesRead
                 ));

    SecBufferDesc Buffer;
    SecBuffer Buffers[4];   // the 4 buffers are: header, data, trailer, extra
    DWORD scRet = ERROR_SUCCESS;

    *lpdwBytesNeeded = 0;

    //
    //  HOW THIS THING WORKS:
    //  We sit in a loop, attempting to fill our passed in buffer with
    //  decrypted data.  If there is no decrypted data we check to
    //  see if there is encrypted data sitting in our buffer.
    //
    //  Assuming there is enough we decrypt a chunk, and place it in the
    //  output buffer of our double buffer class. We reloop and try to
    //  copy it to our passed in byffer.
    //
    //  If there is more encrypted data, and more space to fill in
    //  the user buffer, we attempt to decrypt the next chunk of this.
    //
    //  If we do not have enough data, we return with an error, and
    //  expect a network read to be done.
    //

    do {

        //
        // Check to see if we can fill up User buffer.
        //

        m_pdblbufBuffer->CopyOut(
            lpOutBuffer,
            lpdwOutBufferLeft,
            lpdwOutBufferReceived,
            lpdwOutBufferBytesRead
        );

        //
        // If we've filled our output buffer, than exit with ERROR_SUCCESS
        //

        if ( *lpdwOutBufferLeft == 0)
        {
            break;
        }

        //
        // If we've got less than ~3 bytes return so we can read more data.
        //

        if (m_pdblbufBuffer->GetInputBufferSize() < SSLPCT_SMALLESTHEADERCHUNK) {
            scRet = (DWORD) SEC_E_INCOMPLETE_MESSAGE;
            break;
        }

        //
        // prepare data the SecBuffer for a call to SSL/PCT decryption code.
        //

        Buffers[0].pvBuffer = m_pdblbufBuffer->GetInputBufferPointer( );
        Buffers[0].cbBuffer = m_pdblbufBuffer->GetInputBufferSize(); // # of bytes to decrypt
        Buffers[0].BufferType = SECBUFFER_DATA;

        int i;

        for ( i = 1; i < 4; i++ )
        {
            //
            // clear other 3 buffers for receving result from SSPI package
            //

            Buffers[i].pvBuffer = NULL;
            Buffers[i].cbBuffer = 0;
            Buffers[i].BufferType = SECBUFFER_EMPTY;
        }

        Buffer.cBuffers = 4; // the 4 buffers are: header, data, trailer, extra
        Buffer.pBuffers = Buffers;
        Buffer.ulVersion = SECBUFFER_VERSION;

        //
        // Decrypt the DATA !!!
        //

        scRet = g_UnsealMessage(&m_hContext,
                                &Buffer,
                                0,
                                NULL );

        DEBUG_PRINT(API,
                    INFO,
                    ("UnsealMessage returned, %s [%x]\n",
                    InternetMapSSPIError((DWORD)scRet),
                    scRet
                    ));



        if ( scRet != ERROR_SUCCESS &&
             scRet != SEC_I_RENEGOTIATE)
        {
            DEBUG_PRINT(API,
                        ERROR,
                        ("UnsealMessage failed, error %lx\n",
                        scRet
                        ));

            INET_ASSERT( scRet != SEC_E_MESSAGE_ALTERED );

            if ( scRet == SEC_E_INCOMPLETE_MESSAGE )
            {
                DWORD dwAddlBufferNeeded = Buffers[1].cbBuffer;

                DEBUG_PRINT(API,
                             INFO,
                             ("UnsealMessage short of %d bytes\n",
                             dwAddlBufferNeeded
                             ));

                 //
                 // If we're missing data, return to get the missing data.
                 // But make sure we have enough room first!
                 //

                if (!m_pdblbufBuffer->ResizeBufferIfNeeded(dwAddlBufferNeeded)) {
                    scRet = ERROR_NOT_ENOUGH_MEMORY;
                }
                *lpdwBytesNeeded = dwAddlBufferNeeded;
                break;
            }
            else if ( scRet == 0x00090317 /*SEC_I_CONTEXT_EXPIRED*/)
            {
                //
                // Ignore this error and treat this like a simple terminator
                //  to end the connection.
                //

                scRet = ERROR_SUCCESS;
            }
            else
            {
                break;
            }
        }



        //
        // Success we decrypted a block
        //

        LPBYTE  lpExtraBuffer;
        DWORD   dwExtraBufferSize;
        LPBYTE  lpDecryptedBuffer;
        DWORD   dwDecryptedBufferSize;


        lpDecryptedBuffer       =   (LPBYTE) Buffers[1].pvBuffer;
        dwDecryptedBufferSize   =   Buffers[1].cbBuffer;

        //
        // BUGBUG [arthurbi] this is hack to work with the OLD SSLSSPI.DLL .
        //  They return extra on the second buffer instead of the third.
        //

        if ( Buffers[2].BufferType == SECBUFFER_EXTRA )
        {
            lpExtraBuffer   = (LPBYTE) Buffers[2].pvBuffer;
            dwExtraBufferSize = Buffers[2].cbBuffer;
        }
        else if ( Buffers[3].BufferType == SECBUFFER_EXTRA )
        {
            lpExtraBuffer   = (LPBYTE) Buffers[3].pvBuffer;
            dwExtraBufferSize = Buffers[3].cbBuffer;
        }
        else
        {
            lpExtraBuffer = NULL;
            dwExtraBufferSize = 0;
        }


        m_pdblbufBuffer->SetOutputInputBuffer(
            lpDecryptedBuffer,
            dwDecryptedBufferSize,
            lpExtraBuffer,
            dwExtraBufferSize,
            FALSE // don't combine.
        );

        if ( dwDecryptedBufferSize == 0 )
            break;  // No more data to process

        INET_ASSERT( *lpdwOutBufferLeft );  // don't expect to get here this way.

    } while ( *lpdwOutBufferLeft && scRet == ERROR_SUCCESS );



    DEBUG_PRINT(API,
         INFO,
         ("DecryptData returning, "
          "OutBuffer = %x, DecryptBytesRecv = %d\n",
         lpOutBuffer,
         *lpdwOutBufferBytesRead
         ));

    DEBUG_LEAVE((DWORD)scRet);

    return ( scRet );
}


VOID
ICSecureSocket::TerminateSecConnection(
    VOID
    )

/*++

Routine Description:

    This function deletes the security context handle which result
    in deleting the local data structures with which they are associated.

Arguments:

    None

Return Value:

    None

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "ICSecureSocket::TerminateSecConnection",
                 "{%#x [%#x:%#x]}",
                 this,
                 m_hContext.dwUpper,
                 m_hContext.dwLower
                 ));

    INET_ASSERT(IsSecure());

    //INET_ASSERT(m_hContext.dwLower != 0);
    //INET_ASSERT(m_hContext.dwUpper != 0);

    if (GlobalSecFuncTable)
    {
        if (!((m_hContext.dwLower == 0) && (m_hContext.dwUpper == 0)))
        {
            // There are cases where because of circular dependencies
            // schannel could get unloaded before wininet. In that case
            // this call could fault. This usually happens when the process 
            // is shutting down.
            SAFE_WRAP_REVERT_USER_VOID(g_DeleteSecurityContext, (&m_hContext));

            m_hContext.dwLower = m_hContext.dwUpper = 0;
        }
    }
    else
    {

        DEBUG_PRINT(API,
                    ERROR,
                    ("Attempting to Delete a security context, with a NULL SSPI func table!(missing SCHANNEL.DLL?)\n"
                    ));

    }

    DEBUG_LEAVE(0);
}

#ifdef SECPKG_ATTR_PROTO_INFO
/*++

ProtoInfoToString:

    This routine converts an SSPI SecPkgContext_ProtoInfo structure into a
    string.  The returned string must be released via LocalFree.

Arguments:

    pProtoInfo supplies the SecPkgContext_ProtoInfo structure to be converted to
    string representation.

Return Value:

    Non-NULL is the address of the returned string.  This must be freed via
        LocalFree once it is no longer needed.

    NULL implies no memory is available.

Author:

    Doug Barlow (dbarlow) 4/23/1996

--*/


PRIVATE
LPTSTR
ProtoInfoToString(
    IN const PSecPkgContext_ProtoInfo pProtoInfo)
{
    TCHAR
        szValue[32],
        szSep[8];
    LPTSTR
        szFinal
            = NULL;
    DWORD
        length;

    length = GetLocaleInfo(
                LOCALE_USER_DEFAULT,
                LOCALE_SDECIMAL,
                szSep,
                sizeof(szSep) / sizeof(TCHAR));
    if (0 >= length)
        lstrcpy(szSep, TEXT("."));

    length = wsprintf(
                szValue,
                TEXT("%d%s%d"),
                pProtoInfo->majorVersion,
                szSep,
                pProtoInfo->minorVersion);
    INET_ASSERT(sizeof(szValue) / sizeof(TCHAR) > length);

    length = lstrlen(pProtoInfo->sProtocolName);
    length += 2;                    // Space and Trailing NULL
    length += lstrlen(szValue);
    szFinal = (LPTSTR)ALLOCATE_MEMORY(LMEM_FIXED, length * sizeof(TCHAR));
    if (NULL != szFinal)
    {
        lstrcpy(szFinal, pProtoInfo->sProtocolName);
        lstrcat(szFinal, TEXT(" "));
        lstrcat(szFinal, szValue);
    }
    return szFinal;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\debug\debugmem.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    debugmem.cxx

Abstract:

    Debug memory allocator

    Contents:
        InternetDebugMemInitialize
        InternetDebugMemTerminate
        InternetDebugAllocMem
        InternetDebugFreeMem
        InternetDebugReAllocMem
        InternetDebugSizeMem
        InternetDebugCheckMemFreed
        InternetDebugMemReport
        (InternetDebugCheckMemBlock)
        (DebugFillMem)
        (InternetAlloc)
        (InternetFree)
        (InternetReAlloc)
        (InternetSize)
        (InternetHeapAlloc)
        (InternetHeapReAlloc)
        (InternetHeapFree)
        (InternetHeapSize)
        (InternetDebugMemTest)
        (ReportMemoryUsage)
        (ReportMemoryBlocks)
        (DumpDeferredFreeList)
        (DumpMemoryList)
        (FindAndDumpDeferredBlock)
        (DumpBlock)
        (DumpDebugMemoryHeader)
        (DumpDebugMemoryFooter)
        (DumpUserData)
        (MapLastAccessOperation)
        (MapMemoryFlags)
        (DbgMemGetDebugSymbol)

Author:

     Richard L Firth (rfirth) 02-Feb-1995

Environment:

    Win32 user mode

Revision History:

    02-Feb-1995
        Created

--*/

#include <wininetp.h>
#include "rprintf.h"

#if defined(USE_DEBUG_MEMORY)

//
// manifests
//

#define DEFAULT_INITIAL_HEAP_SIZE   (64 K)
#define DEFAULT_MAXIMUM_HEAP_SIZE   (1 M)
#define DEFAULT_HEADER_GUARD_SIZE   32
#define DEFAULT_FOOTER_GUARD_SIZE   32
#define DEFAULT_ALLOC_ALIGNMENT     4
#define HEADER_SIGNATURE            0x414d454d  // "MEMA"
#define FOOTER_SIGNATURE            0x434f4c4c  // "LLOC"
#define DWORD_ALLOC_FILL            0xc5c5c5c5
#define BYTE_ALLOC_FILL             0xc5
#define BYTE_ALLOC_FILL_EXTRA       0x88
#define GUARD_DWORD_FILL            0x44524147  // "GARD"
#define DWORD_FREE_FILL             0xb7b7b7b7
#define BYTE_FREE_FILL              0xb7
#define DEFAULT_MAX_BLOCKS_DUMPED   1024
#define DEFAULT_MAX_DATA_DUMPED     65536
#define DEFAULT_BACKTRACE_DEPTH     2

//
// only perform stack dump for x86 (or other stack-based processors)
//

#if defined(i386)
#define DUMP_STACK  1
#else
#define DUMP_STACK  0
#endif

//
// just using one stack these days
//

#define ONE_STACK   1

//
// private types
//

typedef enum {
    MemAllocate = 0x6f6c6c41,   // "Allo"
    MemReallocate = 0x6c416552, // "ReAl"
    MemLock = 0x6b636f4c,       // "Lock"
    MemUnlock = 0x6f6c6e55,     // "Unlo"
    MemFree = 0x65657246,       // "Free"
    MemSize = 0x657a6953        // "Size"
} MEMORY_ACTION;

typedef enum {
    HEAP_COMPACT_NEVER = 0,
    HEAP_COMPACT_ON_ALLOC_FAIL,
    HEAP_COMPACT_ON_FREE
} HEAP_COMPACT_TYPE;

typedef enum {
    HEAP_VALIDATE_NEVER = 0,
    HEAP_VALIDATE_ON_ALLOC,
    HEAP_VALIDATE_ON_FREE
} HEAP_VALIDATE_TYPE;

//
// DEBUG_MEMORY_HEADER - keeps debug memory on list
//

typedef struct {
    LIST_ENTRY List;
    DWORD ThreadId;
    LPSTR CreatedFile;
    DWORD CreatedLine;
    LPSTR AccessedFile;
    DWORD AccessedLine;
    SIZE_T RequestedLength;
    SIZE_T BlockLength;
    SIZE_T ActualLength;
    DWORD Signature;
    DWORD Flags;
    DWORD TimeDeferred;
    LONG ClashTest;
    MEMORY_ACTION LastAccessOperation;
#if DUMP_STACK
#if ONE_STACK
    LPVOID Stack[8];    // should be variable
#else
    LPVOID CreateStack[4];
    LPVOID LastAccessStack[4];
#endif // ONE_STACK
#endif // DUMP_STACK
    DWORD Guard[2];

    //
    // sizeof(MEMORY_SIGNATURE) currently 24 DWORDs in Win32
    //

} DEBUG_MEMORY_HEADER, *LPDEBUG_MEMORY_HEADER;

//
// DEBUG_MEMORY_FOOTER - used to check for overwrites
//

typedef struct {
    DWORD Guard[4];
    DWORD Signature;
    SIZE_T BlockLength;  // should be the same as the header
    DWORD Guard2[2];

    //
    // sizeof(DEBUG_MEMORY_FOOTER) currently 8 DWORDs in Win32
    //

} DEBUG_MEMORY_FOOTER, *LPDEBUG_MEMORY_FOOTER;

//
// private data
//

PRIVATE BOOL MemoryPackageInitialized = FALSE;

//
// InternetDebugMemFlags - bitfield of flags controlling debug memory usage.
// The default is no debug alloc (don't create header + footers) and to use
// LocalAlloc() etc.
//

//
// BUGBUG - I'm making an assumption that the compiler thinks the bits have the
//          same values as I think they have. If not, it could mess up the
//          registry/environment flags
//

PRIVATE struct {                                            // default value
    DWORD bNoDebugAlloc             : 1;    //  0x00000001          TRUE
    DWORD bUseLocalAlloc            : 1;    //  0x00000002          TRUE
    DWORD bUseSymbols               : 1;    //  0x00000004          FALSE
    DWORD bAssertOnMemoryErrors     : 1;    //  0x00000008          FALSE
    DWORD bFillMemoryOnAlloc        : 1;    //  0x00000010          FALSE
    DWORD bFillMemoryOnFree         : 1;    //  0x00000020          FALSE
    DWORD bReportMemoryUsage        : 1;    //  0x00000040          FALSE
    DWORD bReportUnfreedBlocks      : 1;    //  0x00000080          FALSE
    DWORD bReportMemoryFooters      : 1;    //  0x00000100          FALSE
    DWORD bReportUserData           : 1;    //  0x00000200          FALSE
    DWORD bStopDumpIfBadBlock       : 1;    //  0x00000400          FALSE
    DWORD bLimitUnfreedBlocks       : 1;    //  0x00000800          FALSE
    DWORD bLimitUserData            : 1;    //  0x00001000          FALSE
    DWORD bDumpAsDwords             : 1;    //  0x00002000          FALSE
    DWORD bHeapNoSerialize          : 1;    //  0x00004000          FALSE
    DWORD bHeapGenerateExceptions   : 1;    //  0x00008000          FALSE
    DWORD bHeapIsGrowable           : 1;    //  0x00010000          FALSE
    DWORD bDeferFree                : 1;    //  0x00020000          FALSE
    DWORD bDumpToFile               : 1;    //  0x00040000          FALSE
} InternetDebugMemFlags = {
    TRUE,   // no debug alloc
    TRUE,   // use LocalAlloc()
    FALSE,  // don't load debug symbols
    FALSE,  // don't assert on memory errors
    FALSE,  // don't fill memory on alloc
    FALSE,  // don't fill memory on free
    FALSE,  // don't report memory usage (stats)
    FALSE,  // don't report unfreed blocks
    FALSE,  // don't report memory footers (irrelevant)
    FALSE,  // don't report user data (irrelevant)
    FALSE,  // don't stop dump if bad block (irrelevant)
    FALSE,  // don't limit dump of unfreed blocks (irrelevant)
    FALSE,  // don't limit dump of user data (irrelevant)
    FALSE,  // don't dump user data as DWORDs (irrelevant)
    FALSE,  // serialize access to heap (irrelevant)
    FALSE,  // don't generate heap exceptions (irrelevant)
    TRUE,   // heap is growable (irrelevant)
    FALSE,  // don't defer frees
    FALSE   // don't dump to WinHttp log file
};

//
// defines to make using InternetDebugMemFlags easier
//

#define bNoDebugAlloc           InternetDebugMemFlags.bNoDebugAlloc
#define bUseLocalAlloc          InternetDebugMemFlags.bUseLocalAlloc
#define bUseSymbols             InternetDebugMemFlags.bUseSymbols
#define bAssertOnMemoryErrors   InternetDebugMemFlags.bAssertOnMemoryErrors
#define bFillMemoryOnAlloc      InternetDebugMemFlags.bFillMemoryOnAlloc
#define bFillMemoryOnFree       InternetDebugMemFlags.bFillMemoryOnFree
#define bReportMemoryUsage      InternetDebugMemFlags.bReportMemoryUsage
#define bReportUnfreedBlocks    InternetDebugMemFlags.bReportUnfreedBlocks
#define bReportMemoryFooters    InternetDebugMemFlags.bReportMemoryFooters
#define bReportUserData         InternetDebugMemFlags.bReportUserData
#define bStopDumpIfBadBlock     InternetDebugMemFlags.bStopDumpIfBadBlock
#define bLimitUnfreedBlocks     InternetDebugMemFlags.bLimitUnfreedBlocks
#define bLimitUserData          InternetDebugMemFlags.bLimitUserData
#define bDumpAsDwords           InternetDebugMemFlags.bDumpAsDwords
#define bHeapNoSerialize        InternetDebugMemFlags.bHeapNoSerialize
#define bHeapGenerateExceptions InternetDebugMemFlags.bHeapGenerateExceptions
#define bHeapIsGrowable         InternetDebugMemFlags.bHeapIsGrowable
#define bDeferFree              InternetDebugMemFlags.bDeferFree
#define bDumpToFile             InternetDebugMemFlags.bDumpToFile

PRIVATE DWORD MaxBlocksDumped = DEFAULT_MAX_BLOCKS_DUMPED;
PRIVATE DWORD MaxUserDataDumped = DEFAULT_MAX_DATA_DUMPED;
PRIVATE DWORD StackBacktraceDepth = DEFAULT_BACKTRACE_DEPTH;

//
// heap variables
//

PRIVATE HANDLE hDebugHeap = NULL;
PRIVATE DWORD InitialHeapSize = DEFAULT_INITIAL_HEAP_SIZE;
PRIVATE DWORD MaximumHeapSize = DEFAULT_MAXIMUM_HEAP_SIZE;
PRIVATE HEAP_COMPACT_TYPE HeapCompactControl = HEAP_COMPACT_NEVER;
PRIVATE HEAP_VALIDATE_TYPE HeapValidateControl = HEAP_VALIDATE_NEVER;

//
// debug mem signatures etc.
//

PRIVATE DWORD AllocAlignment = DEFAULT_ALLOC_ALIGNMENT;
PRIVATE DWORD HeaderGuardSize = DEFAULT_HEADER_GUARD_SIZE;
PRIVATE DWORD FooterGuardSize = DEFAULT_FOOTER_GUARD_SIZE;
PRIVATE DWORD AllocMemoryFiller = DWORD_ALLOC_FILL;
PRIVATE DWORD FreeMemoryFiller = DWORD_FREE_FILL;

//
// usage variables - access using some sort of lock (critsec/interlocked)
//

PRIVATE CRITICAL_SECTION MemoryVarsCritSec;
PRIVATE SIZE_T TotalActualMemoryAllocated = 0;  // cumulative
PRIVATE SIZE_T TotalBlockMemoryAllocated = 0;    //     "
PRIVATE SIZE_T TotalRealMemoryAllocated = 0;    //     "
PRIVATE SIZE_T TotalActualMemoryFreed = 0;      //     "
PRIVATE SIZE_T TotalBlockMemoryFreed = 0;        //     "
PRIVATE SIZE_T TotalRealMemoryFreed = 0;         //     "
PRIVATE SIZE_T ActualMemoryAllocated = 0;        // difference
PRIVATE SIZE_T BlockLengthAllocated = 0;         //     "
PRIVATE SIZE_T RealLengthAllocated = 0;          //     "
PRIVATE DWORD MemoryAllocations = 0;            // cumulative
PRIVATE DWORD GoodMemoryAllocations = 0;        //     "
PRIVATE DWORD MemoryReAllocations = 0;          //     "
PRIVATE DWORD GoodMemoryReAllocations = 0;      //     "
PRIVATE DWORD MemoryFrees = 0;                  //     "
PRIVATE DWORD GoodMemoryFrees = 0;              //     "
PRIVATE SIZE_T LargestBlockRequested = 0;
PRIVATE SIZE_T LargestBlockAllocated = 0;
PRIVATE LPSTR LargestBlockRequestedFile = NULL;
PRIVATE DWORD LargestBlockRequestedLine = 0;
PRIVATE SIZE_T SmallestBlockRequested = (SIZE_T)-1;
PRIVATE SIZE_T SmallestBlockAllocated = (SIZE_T)-1;
PRIVATE LPSTR SmallestBlockRequestedFile = NULL;
PRIVATE DWORD SmallestBlockRequestedLine = 0;
PRIVATE DWORD DeferFreeTime = 0;

//
// lists
//

PRIVATE SERIALIZED_LIST AllocatedBlockList;
PRIVATE SERIALIZED_LIST DeferredFreeList;

//
// macros
//

#define MEMORY_ASSERT(x) \
    if (bAssertOnMemoryErrors) { \
        INET_ASSERT(x); \
    } else { \
        /* NOTHING */ \
    }

//
// private prototypes
//

PRIVATE
VOID
DebugFillMem(
    IN LPVOID Pointer,
    IN SIZE_T Size,
    IN DWORD dwFiller
    );

PRIVATE
HLOCAL
InternetAlloc(
    IN UINT Flags,
    IN SIZE_T Size
    );

PRIVATE
HLOCAL
InternetFree(
    IN HLOCAL hLocal
    );

PRIVATE
HLOCAL
InternetReAlloc(
    IN HLOCAL hLocal,
    IN SIZE_T Size,
    IN UINT Flags
    );

PRIVATE
SIZE_T
InternetSize(
    IN HLOCAL hLocal
    );

PRIVATE
HLOCAL
InternetHeapAlloc(
    IN UINT Flags,
    IN SIZE_T Size
    );

PRIVATE
HLOCAL
InternetHeapReAlloc(
    IN HLOCAL hLocal,
    IN SIZE_T Size,
    IN UINT Flags
    );

PRIVATE
HLOCAL
InternetHeapFree(
    IN HLOCAL hLocal
    );

PRIVATE
SIZE_T
InternetHeapSize(
    IN HLOCAL hLocal
    );

PRIVATE
BOOL
InternetDebugCheckMemBlock(
    IN LPDEBUG_MEMORY_HEADER lpHeader
    );

PRIVATE
VOID
InternetDebugMemTest(
    VOID
    );

PRIVATE
VOID
ReportMemoryUsage(
    VOID
    );

PRIVATE
VOID
ReportMemoryBlocks(
    VOID
    );

PRIVATE
VOID
DumpDeferredFreeList(
    VOID
    );

PRIVATE
VOID
DumpMemoryList(
    IN LPSERIALIZED_LIST lpList
    );

PRIVATE
VOID
FindAndDumpDeferredBlock(
    IN HLOCAL hLocal
    );

PRIVATE
BOOL
DumpBlock(
    IN LPDEBUG_MEMORY_HEADER lpHeader
    );

PRIVATE
BOOL
DumpDebugMemoryHeader(
    LPDEBUG_MEMORY_HEADER lpHeader
    );

PRIVATE
BOOL
DumpDebugMemoryFooter(
    LPDEBUG_MEMORY_FOOTER lpFooter
    );

PRIVATE
VOID
DumpUserData(
    LPDEBUG_MEMORY_HEADER lpHeader
    );

PRIVATE
LPSTR
MapLastAccessOperation(
    MEMORY_ACTION Action
    );

PRIVATE
LPSTR
MapMemoryFlags(
    DWORD Flags,
    LPSTR Buffer
    );

PRIVATE
LPSTR
DbgMemGetDebugSymbol(
    DWORD Address,
    LPDWORD Offset
    );

//
// functions
//


VOID
InternetDebugMemInitialize(
    VOID
    )

/*++

Routine Description:

    Initializes debug memory allocator

Arguments:

    None.

Return Value:

    None.

--*/

{
    BOOL init;

    init = (BOOL)InterlockedExchange((LPLONG)&MemoryPackageInitialized, TRUE);
    if (init) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("Memory package already initialized\n"
                    ));

        DEBUG_BREAK(MEMALLOC);

        return;
    }

    InitializeSerializedList(&AllocatedBlockList);
    InitializeSerializedList(&DeferredFreeList);
    InitializeCriticalSection(&MemoryVarsCritSec);

    //
    // sleaze: disable any debug output until we finish this. Debug log
    // routines want to allocate memory(!). InternetReadRegistryDword()
    // (called from InternetGetDebugVariable()) wants to perform DEBUG_ENTER
    // etc.
    //

    DWORD debugControlFlags = InternetDebugControlFlags;

    InternetDebugControlFlags = DBG_NO_DEBUG;

    //
    // if "WinHttpMem" is set then we set up to use debug memory - we use our
    // own heap, full debugging & reporting etc. (basically max memory debugging
    // as defined by me)
    //

    DWORD useDefaultDebugMemoryFlags = FALSE;

    InternetGetDebugVariable("WinHttpMem",
                             &useDefaultDebugMemoryFlags
                             );
    if (useDefaultDebugMemoryFlags) {
        bNoDebugAlloc = FALSE;          // use full debug allocator (header + footers, etc.)
        bUseLocalAlloc = FALSE;         // use our own heap
        bUseSymbols = FALSE;            // don't load debug symbols
        bAssertOnMemoryErrors = TRUE;   // assert to debugger/log if memory errors
        bFillMemoryOnAlloc = TRUE;      // fill user data w/ signature if not zeroinit
        bFillMemoryOnFree = TRUE;       // fill freed memory (useful on Win95/non-debug on NT)
        bReportMemoryUsage = TRUE;      // dump memory usage stats
        bReportUnfreedBlocks = TRUE;    // dump unfreed blocks (headers)
        bReportMemoryFooters = TRUE;    // dump unfreed block footers
        bReportUserData = TRUE;         // dump unfreed block user data
        bStopDumpIfBadBlock = TRUE;     // stop dumping if error occurs
        bLimitUnfreedBlocks = TRUE;     // limit block dump in case of loop in list
        bLimitUserData = TRUE;          // limit user data dump in case of bad length
        bDumpAsDwords = TRUE;           // dump data in dc format vs. db
        bHeapNoSerialize = FALSE;       // heap functions are serialized
        bHeapGenerateExceptions = FALSE;// heap functions return errors
        bHeapIsGrowable = FALSE;        // limit heap to maximum size (1 Meg)
        if (useDefaultDebugMemoryFlags == 2) {
            bDumpToFile = TRUE;
        }
    } else {

        //
        // no use-debug-mem override, see if there are any specific flags set
        //

        InternetGetDebugVariable("WinHttpDebugMemFlags",
                                 (LPDWORD)&InternetDebugMemFlags
                                 );
    }

    //
    // we used to load IMAGEHLP.DLL here and not use its functions until we were
    // dumping still in-use memory during DLL shutdown. Problem is that the
    // system has probably already freed IMAGEHLP.DLL by the time we come to use
    // it, resulting in GPF, so now we only load it at the time we're about to
    // use it
    //

    //if (bUseSymbols) {
    //    InitSymLib();
    //}

    if (!bUseLocalAlloc) {

        //
        // not using LocalAlloc(), using HeapAlloc(). Create heap
        //

        InitialHeapSize = DEFAULT_INITIAL_HEAP_SIZE;
        InternetGetDebugVariable("WinHttpDebugHeapInitialSize",
                                 &InitialHeapSize
                                 );

        MaximumHeapSize = DEFAULT_MAXIMUM_HEAP_SIZE;
        InternetGetDebugVariable("WinHttpDebugHeapMaximumSize",
                                 &MaximumHeapSize
                                 );

        if (bHeapIsGrowable) {
            MaximumHeapSize = 0;
        }

        hDebugHeap = HeapCreate((bHeapGenerateExceptions
                                    ? HEAP_GENERATE_EXCEPTIONS
                                    : 0)
                                | (bHeapNoSerialize
                                    ? HEAP_NO_SERIALIZE
                                    : 0),
                                InitialHeapSize,
                                MaximumHeapSize
                                );
        if (hDebugHeap == NULL) {

            DEBUG_PUT(("HeapCreate() failed - %d\n",
                        GetLastError()
                        ));

            bUseLocalAlloc = TRUE;
        } else {
            HeapCompactControl = HEAP_COMPACT_NEVER;
            InternetGetDebugVariable("WinHttpDebugHeapCompactControl",
                                     (LPDWORD)&HeapCompactControl
                                     );

            HeapValidateControl = HEAP_VALIDATE_NEVER;
            InternetGetDebugVariable("WinHttpDebugHeapValidateControl",
                                     (LPDWORD)&HeapValidateControl
                                     );

            DEBUG_PUT(("WinHttp heap = %#x\n",
                        hDebugHeap
                        ));

        }
    }

    //
    // restore default debug flags
    //

    InternetDebugControlFlags = debugControlFlags;

    //InternetDebugMemTest();
}


VOID
InternetDebugMemTerminate(
    IN BOOL bReport
    )

/*++

Routine Description:

    Frees resources allocated in InternetDebugMemInitialize, after checking that
    all memory is freed

Arguments:

    bReport - TRUE if in-use blocks reported at termination

Return Value:

    None.

--*/

{
    BOOL bOpened = bReport ? InternetDebugMemReport(TRUE, FALSE) : FALSE;

    InternetDebugCheckMemFreed(FALSE);
    DeleteCriticalSection(&MemoryVarsCritSec);
    TerminateSerializedList(&AllocatedBlockList);
    TerminateSerializedList(&DeferredFreeList);

    if (hDebugHeap != NULL) {

        //
        // any future allocations(!) must use process heap
        //

        bUseLocalAlloc = TRUE;

        if (!HeapDestroy(hDebugHeap)) {

            DWORD error = GetLastError();

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("HeapDestroy(%#x) returns %s (%d)\n",
                        hDebugHeap,
                        InternetMapError(error),
                        error
                        ));

            MEMORY_ASSERT(FALSE);

        }
    }
    if (bOpened) {
        InternetCloseDebugFile();
    }
    MemoryPackageInitialized = FALSE;
}


HLOCAL
InternetDebugAllocMem(
    IN UINT Flags,
    IN UINT Size,
    IN LPSTR File,
    IN DWORD Line
    )

/*++

Routine Description:

    Debug memory allocator. If this succeeds, then the real block is put on our
    list and has its head & tail (& possibly contents) initialized. The caller
    gets an pointer which is an offset to the user area in the block

Arguments:

    Flags   - controlling flags (normally passed to LocalAlloc)

    Size    - of block to allocate

    File    - from where alloc called

    Line    - in File

Return Value:

    HLOCAL
        Success - pointer to caller's start of allocated block

        Failure - NULL

--*/

{
    if (!MemoryPackageInitialized) {
        return NULL;
    }

//dprintf("InternetDebugAllocMem(%#x, %d) = ", Flags, Size);
    InterlockedIncrement((LPLONG)&MemoryAllocations);

    //
    // keep these tests separate so we don't have to look up the flags #defines
    //

    INET_ASSERT(!(Flags & LMEM_MOVEABLE));
    INET_ASSERT(!(Flags & LMEM_DISCARDABLE));

    if (Size == 0) {

        DEBUG_PRINT(MEMALLOC,
                    WARNING,
                    ("InternetDebugAllocMem(%#x, %d)\n",
                    Flags,
                    Size
                    ));

        MEMORY_ASSERT(FALSE);

    }

    SIZE_T blockLength;

    if (bNoDebugAlloc) {
        blockLength = Size;
    } else {
        if (Size > LargestBlockRequested) {
            LargestBlockRequested = Size;
            LargestBlockRequestedFile = File;
            LargestBlockRequestedLine = Line;
        } else if (Size < SmallestBlockRequested) {
            SmallestBlockRequested = Size;
            SmallestBlockRequestedFile = File;
            SmallestBlockRequestedLine = Line;
        }
        blockLength = ROUND_UP_DWORD(Size)
                    + sizeof(DEBUG_MEMORY_HEADER)
                    + sizeof(DEBUG_MEMORY_FOOTER);
    }

    //
    // possible problem: if Size + signatures would overflow UINT. Only really
    // problematic on 16-bit platforms
    //

    if (blockLength < Size) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("can't allocate %lu bytes: would overflow\n",
                    (DWORD)Size
                    ));

        DEBUG_BREAK(MEMALLOC);

//dprintf("NULL\n");
        return NULL;
    }

    //
    // BUGBUG - allocating 0 bytes?
    //

    HLOCAL hLocal = InternetAlloc(Flags, blockLength);

    if (hLocal != NULL) {
        InterlockedIncrement((LPLONG)&GoodMemoryAllocations);
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("failed to allocate %u bytes memory\n",
                    blockLength
                    ));

        DEBUG_BREAK(MEMALLOC);

//dprintf("NULL\n");
        return NULL;
    }

    SIZE_T actualLength = InternetSize(hLocal);
    SIZE_T requestedLength;

    if (bNoDebugAlloc) {
        blockLength = actualLength;
        requestedLength = actualLength;
    } else {
        requestedLength = Size;
        if (actualLength > LargestBlockAllocated) {
            LargestBlockAllocated = actualLength;
        } else if (actualLength < SmallestBlockAllocated) {
            SmallestBlockAllocated = actualLength;
        }
    }

    EnterCriticalSection(&MemoryVarsCritSec);
    TotalActualMemoryAllocated += actualLength;
    TotalBlockMemoryAllocated += blockLength;
    TotalRealMemoryAllocated += requestedLength;
    ActualMemoryAllocated += actualLength;
    BlockLengthAllocated += blockLength;
    RealLengthAllocated += requestedLength;
    LeaveCriticalSection(&MemoryVarsCritSec);

    if (bNoDebugAlloc || (hLocal == NULL)) {
        if ((hLocal != NULL) && !(Flags & LMEM_ZEROINIT) && bFillMemoryOnAlloc) {
            DebugFillMem(hLocal, Size, AllocMemoryFiller);
        }
//dprintf("%#x\n", hLocal);
        return hLocal;
    }

    LPDEBUG_MEMORY_HEADER lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal;

    //InitializeListHead(&lpHeader->List);
    lpHeader->ThreadId = GetCurrentThreadId();
    lpHeader->CreatedFile = File;
    lpHeader->CreatedLine = Line;
    lpHeader->AccessedFile = File;
    lpHeader->AccessedLine = Line;
    lpHeader->RequestedLength = Size;
    lpHeader->BlockLength = blockLength;
    lpHeader->ActualLength = actualLength;
    lpHeader->Signature = HEADER_SIGNATURE;
    lpHeader->Flags = Flags;
    lpHeader->TimeDeferred = 0;
    lpHeader->ClashTest = -1;
    lpHeader->LastAccessOperation = MemAllocate;

#if DUMP_STACK
#if ONE_STACK

    memset(lpHeader->Stack, 0, sizeof(lpHeader->Stack));
    GET_CALL_STACK(lpHeader->Stack);

#else

    GET_CALLERS_ADDRESS(&lpHeader->CreateStack[0],
                        &lpHeader->CreateStack[1]
                        );

    memset(lpHeader->CreateStack, 0, sizeof(lpHeader->CreateStack));

    GET_CALL_STACK(lpHeader->CreateStack);

    memcpy(lpHeader->LastAccessStack,
           lpHeader->CreateStack,
           sizeof(lpHeader->LastAccessStack)
           );

#endif // ONE_STACK
#endif // DUMP_STACK

    UINT i;

    for (i = 0; i < ARRAY_ELEMENTS(lpHeader->Guard); ++i) {
        lpHeader->Guard[i] = GUARD_DWORD_FILL;
    }

    //
    // BUGBUG - should be using AllocAlignment - could be > sizeof(DWORD)
    //

    if (!(Flags & LMEM_ZEROINIT) && bFillMemoryOnAlloc) {
        DebugFillMem(lpHeader + 1, Size, AllocMemoryFiller);
    }

    UINT bFillLength2 = (Size % sizeof(DWORD)) ? (sizeof(DWORD) - (Size % sizeof(DWORD))) : 0;
    LPBYTE lpbUserPointer = (LPBYTE)(lpHeader + 1) + Size;

    for (i = 0; i < bFillLength2; ++i) {
        *lpbUserPointer++ = BYTE_ALLOC_FILL_EXTRA;
    }

    LPDEBUG_MEMORY_FOOTER lpFooter = (LPDEBUG_MEMORY_FOOTER)lpbUserPointer;

    for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard); ++i) {
        lpFooter->Guard[i] = GUARD_DWORD_FILL;
    }

    lpFooter->BlockLength = blockLength;
    lpFooter->Signature = FOOTER_SIGNATURE;

    for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard2); ++i) {
        lpFooter->Guard2[i] = GUARD_DWORD_FILL;
    }

    if (!CheckEntryOnSerializedList(&AllocatedBlockList, &lpHeader->List, FALSE)) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetDebugAllocMem(%d): %#x already on list?\n",
                    Size,
                    lpHeader
                    ));

        MEMORY_ASSERT(FALSE);

    }

    //
    // put at the tail of list so we can view unfreed blocks in chronological
    // order
    //

    if (!InsertAtTailOfSerializedList(&AllocatedBlockList, &lpHeader->List))
    {
        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetDebugAllocMem(%d): %#x couldn't be appended to unfreed list\n",
                    Size,
                    lpHeader
                    ));

        MEMORY_ASSERT(FALSE);
    }

//dprintf("%#x\n", lpHeader + 1);
    return (HLOCAL)(lpHeader + 1);
}


HLOCAL
InternetDebugFreeMem(
    IN HLOCAL hLocal,
    IN LPSTR File,
    IN DWORD Line
    )

/*++

Routine Description:

    Frees a block of memory allocated by InternetDebugAllocMem(). Checks that
    the block is on our allocated block list, and that the header and footer
    areas are still intact

Arguments:

    hLocal  - handle (pointer) of block to free

    File    - from where alloc called

    Line    - in File

Return Value:

    HLOCAL
        Success - NULL

        Failure - hLocal

--*/

{
    if (!MemoryPackageInitialized) {
        return NULL;
    }

//dprintf("InternetDebugFreeMem(%#x)\n", hLocal);
    InterlockedIncrement((LPLONG)&MemoryFrees);

    if (hLocal == NULL) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetDebugFreeMem(NULL)\n"
                    ));

        MEMORY_ASSERT(FALSE);

        return InternetFree(hLocal);
    }

    HLOCAL hLocalOriginal = hLocal;
    SIZE_T actualLength;
    SIZE_T blockLength;
    SIZE_T realLength;

    if (bNoDebugAlloc) {
        actualLength = InternetSize(hLocal);
        blockLength = actualLength;
        realLength = actualLength;
    } else {
        hLocal = (HLOCAL)((LPDEBUG_MEMORY_HEADER)hLocal - 1);
        actualLength = InternetSize(hLocal);

        LPDEBUG_MEMORY_HEADER lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal;

        if (CheckEntryOnSerializedList(&AllocatedBlockList, &lpHeader->List, TRUE) &&
            RemoveFromSerializedList(&AllocatedBlockList, &lpHeader->List)) {

            if (!((lpHeader->ActualLength == actualLength)
            && (lpHeader->BlockLength <= actualLength)
            && !(lpHeader->BlockLength & (sizeof(DWORD) - 1))
            && (lpHeader->RequestedLength < lpHeader->BlockLength))) {

                DEBUG_PRINT(MEMALLOC,
                            ERROR,
                            ("InternetDebugFreeMem(%#x): block lengths mismatch\n",
                            hLocalOriginal
                            ));

                MEMORY_ASSERT(FALSE);
            }
            if (InternetDebugCheckMemBlock(lpHeader)) {
                blockLength = lpHeader->BlockLength;
                realLength = lpHeader->RequestedLength;
            } else {
                blockLength = 0;
                realLength = 0;
            }
            if (bDeferFree) {

#if DUMP_STACK
#if ONE_STACK

                memset(lpHeader->Stack, 0, sizeof(lpHeader->Stack));
                GET_CALL_STACK(lpHeader->Stack);

#else

                GET_CALLERS_ADDRESS(&lpHeader->CreateStack[0],
                                    &lpHeader->CreateStack[1]
                                    );

                memset(lpHeader->CreateStack, 0, sizeof(lpHeader->CreateStack));

                GET_CALL_STACK(lpHeader->CreateStack);

                memcpy(lpHeader->LastAccessStack,
                       lpHeader->CreateStack,
                       sizeof(lpHeader->LastAccessStack)
                       );

#endif // ONE_STACK
#endif // DUMP_STACK

                if (!InsertAtTailOfSerializedList(&DeferredFreeList, &lpHeader->List))
                {
                    DEBUG_PRINT(MEMALLOC,
                                ERROR,
                                ("InternetDebugFreeMem(%#x): couldn't add to deferred free list %#x\n",
                                hLocalOriginal,
                                &lpHeader->List
                                ));

                    MEMORY_ASSERT(FALSE);
                }
                hLocal = NULL;
            }
        } else {

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("InternetDebugFreeMem(%#x): can't find %#x or couldn't free from list\n",
                        hLocalOriginal,
                        &lpHeader->List
                        ));

            MEMORY_ASSERT(FALSE);

            FindAndDumpDeferredBlock(hLocal);
        }
    }

    if (hLocal && bFillMemoryOnFree) {
        DebugFillMem(hLocal, actualLength, FreeMemoryFiller);
    }

    hLocal = InternetFree(hLocal);

    if (hLocal == NULL) {
        InterlockedIncrement((LPLONG)&GoodMemoryFrees);
        EnterCriticalSection(&MemoryVarsCritSec);
        TotalActualMemoryFreed += actualLength;
        TotalBlockMemoryFreed += blockLength;
        TotalRealMemoryFreed += realLength;
        ActualMemoryAllocated -= actualLength;
        BlockLengthAllocated -= blockLength;
        RealLengthAllocated -= realLength;
        LeaveCriticalSection(&MemoryVarsCritSec);
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetDebugFreeMem(%#x) failed\n",
                    hLocalOriginal
                    ));

        MEMORY_ASSERT(FALSE);

        hLocal = hLocalOriginal;
    }

    return hLocal;
}


HLOCAL
InternetDebugReAllocMem(
    IN HLOCAL hLocal,
    IN UINT Size,
    IN UINT Flags,
    IN LPSTR File,
    IN DWORD Line
    )

/*++

Routine Description:

    Reallocates a debug memory block allocated by InternetDebugAllocMem()

Arguments:

    hLocal  - the handle (pointer) of the allocated block

    Size    - requested size of new block; can be larger or smaller than current
              size

    Flags   - controlling flags (normally passed to LocalReAlloc)

    File    - from where alloc called

    Line    - in File

Return Value:

    HLOCAL
        Success - pointer to new block. May be same or different than previous
                  pointer, depending on flags

        Failure - NULL

--*/

{
    if (!MemoryPackageInitialized) {
        return NULL;
    }

//dprintf("InternetDebugReAllocMem(%#x, %d, %#x)\n", hLocal, Size, Flags);
    InterlockedIncrement((LPLONG)&MemoryReAllocations);

    //
    // we can't handle the following flags
    //

    INET_ASSERT(!(Flags & LMEM_MODIFY));

    //
    // can't handle reallocating down to zero
    //

    if (Size == 0) {

        MEMORY_ASSERT(FALSE);

    }

    HLOCAL hLocalOriginal = hLocal;
    LPDEBUG_MEMORY_HEADER lpHeader;
    SIZE_T actualLength;
    SIZE_T blockLength;
    SIZE_T requestedLength;
    SIZE_T oldRequestedLength;

    if (bNoDebugAlloc) {
        actualLength = InternetSize(hLocal);
        blockLength = actualLength;
        requestedLength = actualLength;
    } else {
        if (Size > LargestBlockRequested) {
            LargestBlockRequested = Size;
            LargestBlockRequestedFile = File;
            LargestBlockRequestedLine = Line;
        } else if (Size < SmallestBlockRequested) {
            SmallestBlockRequested = Size;
            SmallestBlockRequestedFile = File;
            SmallestBlockRequestedLine = Line;
        }
        lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal - 1;
        hLocal = (HLOCAL)lpHeader;
        if (!CheckEntryOnSerializedList(&AllocatedBlockList, &lpHeader->List, TRUE) ||
             RemoveFromSerializedList(&AllocatedBlockList, &lpHeader->List)) {

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("InternetDebugReAllocMem(%#x): can't find %#x or couldn't remove from list\n",
                        hLocalOriginal
                        ));

            MEMORY_ASSERT(FALSE);

            return hLocalOriginal;
        }
        InternetDebugCheckMemBlock(lpHeader);
        actualLength = InternetSize((HLOCAL)lpHeader);
        blockLength = lpHeader->BlockLength;
        requestedLength = lpHeader->RequestedLength;
        oldRequestedLength = requestedLength;
        if (!((lpHeader->ActualLength == actualLength)
        && (lpHeader->BlockLength <= actualLength)
        && !(lpHeader->BlockLength & (sizeof(DWORD) - 1))
        && (lpHeader->RequestedLength < lpHeader->BlockLength))) {

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("InternetDebugReAllocMem(%#x): block lengths mismatch\n",
                        hLocalOriginal
                        ));

            MEMORY_ASSERT(FALSE);
        }
    }
    EnterCriticalSection(&MemoryVarsCritSec);
    ActualMemoryAllocated -= actualLength;
    BlockLengthAllocated -= blockLength;
    RealLengthAllocated -= requestedLength;
    LeaveCriticalSection(&MemoryVarsCritSec);
    requestedLength = Size;
    if (bNoDebugAlloc) {
        blockLength = Size;
    } else {
        blockLength = ROUND_UP_DWORD(Size)
                    + sizeof(DEBUG_MEMORY_HEADER)
                    + sizeof(DEBUG_MEMORY_FOOTER);
    }
    hLocal = InternetReAlloc(hLocal, blockLength, Flags);
    if (hLocal != NULL) {
        InterlockedIncrement((LPLONG)&GoodMemoryReAllocations);
        actualLength = InternetSize(hLocal);
        if (bNoDebugAlloc) {
            blockLength = actualLength;
        } else {
            lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal;
            //InitializeListHead(&lpHeader->List);
            lpHeader->ThreadId = GetCurrentThreadId();
            lpHeader->AccessedFile = File;
            lpHeader->AccessedLine = Line;
            lpHeader->RequestedLength = requestedLength;
            lpHeader->BlockLength = blockLength;
            lpHeader->ActualLength = actualLength;
            lpHeader->Flags = Flags;
            lpHeader->TimeDeferred = 0;
            lpHeader->ClashTest = -1;
            lpHeader->LastAccessOperation = MemReallocate;

#if DUMP_STACK
#if ONE_STACK
#else

            //GET_CALLERS_ADDRESS(&lpHeader->LastAccessStack[0],
            //                    &lpHeader->LastAccessStack[1]
            //                    );

            memset(lpHeader->LastAccessStack, 0, sizeof(lpHeader->LastAccessStack));

            GET_CALL_STACK(lpHeader->LastAccessStack);

#endif // ONE_STACK
#endif // DUMP_STACK

            LPBYTE extraPointer;
            UINT dwFillLength;
            UINT i;

            if ((requestedLength > oldRequestedLength)
            && bFillMemoryOnAlloc && !(Flags & LMEM_ZEROINIT)) {

                extraPointer = (LPBYTE)(lpHeader + 1) + oldRequestedLength;

                SIZE_T difference = requestedLength - oldRequestedLength;
                DWORD dwFiller = AllocMemoryFiller;
                SIZE_T syncLength = oldRequestedLength & (sizeof(DWORD) - 1);

                if (syncLength) {
                    syncLength = sizeof(DWORD) - syncLength;
                    syncLength = min(syncLength, difference);
                    difference -= syncLength;
                    for (i = 0; i < syncLength; ++i) {
                        *extraPointer++ = ((LPBYTE)&dwFiller)[i];
                    }
                }

                //dwFillLength = difference / sizeof(DWORD);
                //difference %= sizeof(DWORD);
                //while (dwFillLength--) {
                //    *(LPDWORD)extraPointer = 0;
                //    extraPointer += sizeof(DWORD);
                //}
                //while (difference--) {
                //    *extraPointer++ = 0;
                //}

                if (difference) {
                    DebugFillMem(extraPointer, difference, dwFiller);
                    extraPointer += difference;
                }
            } else {
                extraPointer = (LPBYTE)(lpHeader + 1) + requestedLength;
            }

            SIZE_T bFillLength = (sizeof(DWORD) - (requestedLength % sizeof(DWORD))) & (sizeof(DWORD) - 1);

            while (bFillLength--) {
                *extraPointer++ = BYTE_ALLOC_FILL_EXTRA;
            }

            LPDEBUG_MEMORY_FOOTER lpFooter = (LPDEBUG_MEMORY_FOOTER)extraPointer;

            INET_ASSERT(lpFooter == (LPDEBUG_MEMORY_FOOTER)
                ((LPBYTE)(lpHeader + 1) + ROUND_UP_DWORD(requestedLength)));

            for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard); ++i) {
                lpFooter->Guard[i] = GUARD_DWORD_FILL;
            }
            lpFooter->Signature = FOOTER_SIGNATURE;
            lpFooter->BlockLength = blockLength;
            for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard2); ++i) {
                lpFooter->Guard2[i] = GUARD_DWORD_FILL;
            }
            if (!InsertAtTailOfSerializedList(&AllocatedBlockList, &lpHeader->List)) {
                DEBUG_PRINT(MEMALLOC,
                            ERROR,
                            ("failed to append to allocated block list.\n"
                            ));

                DEBUG_BREAK(MEMALLOC);
            }
            hLocal = (HLOCAL)(lpHeader + 1);
        }
        EnterCriticalSection(&MemoryVarsCritSec);
        ActualMemoryAllocated += actualLength;
        BlockLengthAllocated += blockLength;
        RealLengthAllocated += requestedLength;
        LeaveCriticalSection(&MemoryVarsCritSec);
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("failed to reallocate %u bytes memory. Last error = %d\n",
                    Size,
                    GetLastError()
                    ));

        DEBUG_BREAK(MEMALLOC);

    }
    return hLocal;
}


SIZE_T
InternetDebugSizeMem(
    IN HLOCAL hLocal,
    IN LPSTR File,
    IN DWORD Line
    )

/*++

Routine Description:

    Returns actual allocated block size

Arguments:

    hLocal  - pointer to allocated block

    File    - from where alloc called

    Line    - in File

Return Value:

    SIZE_T
        size of allocated block

--*/

{
    if (!MemoryPackageInitialized) {
        return 0;
    }

//dprintf("InternetDebugSizeMem(%#x)\n", hLocal);
    SIZE_T size = InternetSize(hLocal);

    if (!bNoDebugAlloc) {

        LPDEBUG_MEMORY_HEADER lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal - 1;

        INET_ASSERT(lpHeader->Signature == HEADER_SIGNATURE);

        SIZE_T sizeInHeader = lpHeader->BlockLength
                          - (sizeof(DEBUG_MEMORY_HEADER) + sizeof(DEBUG_MEMORY_FOOTER));

        INET_ASSERT((sizeInHeader <= size)
                    && (size >= sizeof(DEBUG_MEMORY_HEADER) + sizeof(DEBUG_MEMORY_FOOTER))
                    && (lpHeader->ActualLength == size)
                    );

        size = sizeInHeader;
    }

    return size;
}


BOOL
InternetDebugCheckMemFreed(
    IN BOOL bReport
    )

/*++

Routine Description:

    Called when we're about to quit. Checks that all allocated memory has been
    cleaned up

Arguments:

    bReport - TRUE if in-use blocks reported

Return Value:

    BOOL
        TRUE    - all allocated memory freed

        FALSE   - we failed to clean up

--*/

{
    if (bReport) {
        if (bReportMemoryUsage) {
            ReportMemoryUsage();
        }
        if (bReportUnfreedBlocks) {
            ReportMemoryBlocks();
        }
    }
    if (ElementsOnSerializedList(&AllocatedBlockList) != 0) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetDebugCheckMemFreed(): %d memory blocks still allocated\n",
                    MemoryAllocations - MemoryFrees
                    ));

        MEMORY_ASSERT(FALSE);

        return FALSE;
    }
    return TRUE;
}


BOOL
InternetDebugMemReport(
    IN BOOL bTerminateSymbols,
    IN BOOL bCloseFile
    )

/*++

Routine Description:

    Dumps in-use blocks to debugger and/or file

Arguments:

    bTerminateSymbols   - TRUE if we are to terminate symbols here

    bCloseFile          - TRUE if we are to close debug log file here

Return Value:

    BOOL    - TRUE if we opened debug log file

--*/

{
    BOOL bOpened = FALSE;

    if (bDumpToFile) {
        bOpened = InternetOpenDebugFile();
        if (bOpened) {
            InternetDebugResetControlFlags(DBG_NO_DEBUG);
            InternetDebugSetControlFlags(DBG_TO_FILE | DBG_NO_ASSERT_BREAK);
        }
    }
    ReportMemoryUsage();
    ReportMemoryBlocks();
    if (bUseSymbols && bTerminateSymbols) {
        TermSymLib();
    }
    if (bOpened && bCloseFile) {
        InternetCloseDebugFile();
    }
    return bOpened;
}

//
// private functions
//


PRIVATE
VOID
DebugFillMem(
    IN LPVOID Pointer,
    IN SIZE_T Size,
    IN DWORD dwFiller
    )

/*++

Routine Description:

    Fills memory with repeating debug pattern. Performs DWORD fill then finishes
    off any remaining bytes with character fill (rep movsd/rep movsb (ideally)
    (x86!))

Arguments:

    Pointer     - memory to fill

    Size        - of Pointer in bytes

    dwFiller    - DWORD value to use

Return Value:

    None.

--*/

{
    INET_ASSERT(((DWORD_PTR)Pointer & (sizeof(DWORD) - 1)) == 0);

    SIZE_T dwFillLength = Size / sizeof(DWORD);
    SIZE_T bFillLength = Size % sizeof(DWORD);

    //
    // assume > 0 DWORDs to fill
    //

    LPDWORD lpdwPointer = (LPDWORD)Pointer;
    SIZE_T i;

    for (i = 0; i < dwFillLength; ++i) {
        *lpdwPointer++ = dwFiller;
    }

    if (bFillLength) {

        LPBYTE lpbPointer = (LPBYTE)lpdwPointer;

        for (i = 0; i < bFillLength; ++i) {
            *lpbPointer++ = ((LPBYTE)&dwFiller)[i];
        }
    }
}


PRIVATE
HLOCAL
InternetAlloc(
    IN UINT Flags,
    IN SIZE_T Size
    )

/*++

Routine Description:

    Allocator - uses process (local) heap or component (debug) heap based on
    global flag setting

Arguments:

    Flags   - LocalAlloc flags

    Size    - of block to allocate

Return Value:

    HLOCAL
        Success - pointer to allocated block

        Failure - NULL

--*/

{
    if (bUseLocalAlloc) {
        return LocalAlloc(Flags, Size);
    } else {
        return InternetHeapAlloc(Flags, Size);
    }
}


PRIVATE
HLOCAL
InternetFree(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Deallocator - uses process (local) heap or component (debug) heap based on
    global flag setting

Arguments:

    hLocal  - pointer to block to deallocate

Return Value:

    HLOCAL
        Success - NULL

        Failure - pointer to still allocated block

--*/

{
    if (bUseLocalAlloc) {
        return LocalFree(hLocal);
    } else {
        return InternetHeapFree(hLocal);
    }
}


PRIVATE
HLOCAL
InternetReAlloc(
    IN HLOCAL hLocal,
    IN SIZE_T Size,
    IN UINT Flags
    )

/*++

Routine Description:

    Reallocator - uses process (local) heap or component (debug) heap based on
    global flag setting

Arguments:

    hLocal  - pointer to block to reallocate

    Flags   - LocalAlloc flags

    Size    - of block to allocate

Return Value:

    HLOCAL
        Success - pointer to allocated block

        Failure - NULL

--*/

{
    if (bUseLocalAlloc) {
        return LocalReAlloc(hLocal, Size, Flags);
    } else {
        return InternetHeapReAlloc(hLocal, Size, Flags);
    }
}


PRIVATE
SIZE_T
InternetSize(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Block sizer - uses process (local) heap or component (debug) heap based on
    global flag setting

Arguments:

    hLocal  - pointer to block to size

Return Value:

    SIZE_T
        Success - size of block

        Failure - 0

--*/

{
    if (bUseLocalAlloc) {
        return LocalSize(hLocal);
    } else {
        return InternetHeapSize(hLocal);
    }
}


PRIVATE
HLOCAL
InternetHeapAlloc(
    IN UINT Flags,
    IN SIZE_T Size
    )

/*++

Routine Description:

    Allocate memory from debug heap

Arguments:

    Flags   - passed to LocalAlloc

    Size    - of block to allocate

Return Value:

    HLOCAL

--*/

{
    HLOCAL hLocal;

    if (hDebugHeap != NULL) {
        hLocal = (HLOCAL)HeapAlloc(hDebugHeap,
                                   (bHeapNoSerialize
                                        ? HEAP_NO_SERIALIZE
                                        : 0)
                                   | (bHeapGenerateExceptions
                                        ? HEAP_GENERATE_EXCEPTIONS
                                        : 0)
                                   | ((Flags & LMEM_ZEROINIT)
                                        ? HEAP_ZERO_MEMORY
                                        : 0),
                                   Size
                                   );
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetHeapAlloc(): hDebugHeap is NULL\n"
                    ));

        MEMORY_ASSERT(FALSE);

        hLocal = LocalAlloc(Flags, Size);
    }
    if (hLocal == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }
    return hLocal;
}


PRIVATE
HLOCAL
InternetHeapReAlloc(
    IN HLOCAL hLocal,
    IN SIZE_T Size,
    IN UINT Flags
    )

/*++

Routine Description:

    Reallocate memory from debug heap

Arguments:

    hLocal  - pointer to block to reallocate

    Size    - new size

    Flags   - to LocalReAlloc

Return Value:

    HLOCAL
        Success - pointer to new block

        Failure - NULL

--*/

{
    if (hDebugHeap != NULL) {
        hLocal = (HLOCAL)HeapReAlloc(hDebugHeap,
                                     (bHeapNoSerialize
                                        ? HEAP_NO_SERIALIZE
                                        : 0)
                                     | (bHeapGenerateExceptions
                                        ? HEAP_GENERATE_EXCEPTIONS
                                        : 0)
                                     | ((Flags & LMEM_MOVEABLE)
                                        ? 0
                                        : HEAP_REALLOC_IN_PLACE_ONLY)
                                     | ((Flags & LMEM_ZEROINIT)
                                        ? HEAP_ZERO_MEMORY
                                        : 0),
                                     (LPVOID)hLocal,
                                     Size
                                     );
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetHeapReAlloc(): hDebugHeap is NULL\n"
                    ));

        MEMORY_ASSERT(FALSE);

        //
        // block still allocated
        //

        hLocal = NULL;
    }
    return hLocal;
}


PRIVATE
HLOCAL
InternetHeapFree(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Free memory to debug heap

Arguments:

    hLocal  - to free

Return Value:

    HLOCAL
        Success - NULL

        Failure - hLocal

--*/

{
    BOOL ok;

    if (hDebugHeap != NULL) {
        ok = HeapFree(hDebugHeap,
                      bHeapNoSerialize ? HEAP_NO_SERIALIZE : 0,
                      (LPVOID)hLocal
                      );
        if (!ok) {

            DWORD error = GetLastError();

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("HeapFree() returns %s (%d)\n",
                        InternetMapError(error),
                        error
                        ));

            MEMORY_ASSERT(FALSE);

        }
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetHeapFree(): hDebugHeap is NULL\n"
                    ));

        MEMORY_ASSERT(FALSE);

        ok = FALSE;
    }
    return ok ? NULL : hLocal;
}


PRIVATE
SIZE_T
InternetHeapSize(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Determines size of block allocated from debug heap

Arguments:

    hLocal  - handle (pointer) of block for which to get size

Return Value:

    SIZE_T
        Success - size of block

        Failure - 0

--*/

{
    SIZE_T size;

    if (hDebugHeap != NULL) {
        size = HeapSize(hDebugHeap,
                        bHeapNoSerialize ? HEAP_NO_SERIALIZE : 0,
                        (LPCVOID)hLocal
                        );
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetHeapSize(): hDebugHeap is NULL\n"
                    ));

        MEMORY_ASSERT(FALSE);

        size = (SIZE_T)-1;
    }
    if (size == (SIZE_T)-1) {
        SetLastError(ERROR_INVALID_HANDLE);
        return 0;
    } else {
        return size;
    }
}


PRIVATE
BOOL
InternetDebugCheckMemBlock(
    IN LPDEBUG_MEMORY_HEADER lpHeader
    )

/*++

Routine Description:

    Checks the consistency of a debug memory block

Arguments:

    lpHeader    - pointer to what we think is DEBUG_MEMORY_HEADER

Return Value:

    None.

--*/

{
    BOOL result;

    __try {
        LPDEBUG_MEMORY_FOOTER lpFooter = (LPDEBUG_MEMORY_FOOTER)
            ((LPBYTE)lpHeader
                + (lpHeader->BlockLength - sizeof(DEBUG_MEMORY_FOOTER)));

        BOOL headerGuardOverrun = FALSE;
        UINT i;

        for (i = 0; i < ARRAY_ELEMENTS(lpHeader->Guard); ++i) {
            if (lpHeader->Guard[i] != GUARD_DWORD_FILL) {
                headerGuardOverrun = TRUE;
                break;
            }
        }

        BOOL footerGuardOverrun = FALSE;

        for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard); ++i) {
            if (lpFooter->Guard[i] != GUARD_DWORD_FILL) {
                footerGuardOverrun = TRUE;
                break;
            }
        }

        BOOL footerGuard2Overrun = FALSE;

        for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard2); ++i) {
            if (lpFooter->Guard2[i] != GUARD_DWORD_FILL) {
                footerGuard2Overrun = TRUE;
                break;
            }
        }

        LPBYTE lpExtraMemory = (LPBYTE)(lpHeader + 1) + lpHeader->RequestedLength;
        BOOL extraMemoryOverrun = FALSE;
        SIZE_T byteLength = ROUND_UP_DWORD(lpHeader->RequestedLength) - lpHeader->RequestedLength;

        for (i = 0; i < byteLength; ++i) {
            if (lpExtraMemory[i] != BYTE_ALLOC_FILL_EXTRA) {
                extraMemoryOverrun = TRUE;
                break;
            }
        }

        if (headerGuardOverrun
        || footerGuardOverrun
        || footerGuard2Overrun
        || extraMemoryOverrun
        || (lpHeader->Signature != HEADER_SIGNATURE)
        || (lpFooter->Signature != FOOTER_SIGNATURE)
        || (lpFooter->BlockLength != lpHeader->BlockLength)) {

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("Bad block: %#x\n",
                        lpHeader
                        ));

            MEMORY_ASSERT(FALSE);

            result = FALSE;
        } else {
            result = TRUE;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        DEBUG_PRINT(MEMALLOC,
                    FATAL,
                    ("Invalid block %#x - exception occurred\n",
                    lpHeader
                    ));

        MEMORY_ASSERT(FALSE);

        result = FALSE;
    }
    return result;
}


PRIVATE
VOID
InternetDebugMemTest(
    VOID
    )
{
    //
    // test
    //

    LPVOID p;

    p = (LPVOID)ALLOCATE_MEMORY(LMEM_FIXED, 1);
    *((LPBYTE)p + 1) = 'X';
    p = (LPVOID)FREE_MEMORY((HLOCAL)p);

    INET_ASSERT(p == NULL);

    p = (LPVOID)ALLOCATE_MEMORY(LMEM_FIXED, 1);
    p = (LPVOID)REALLOCATE_MEMORY(p, 1111, LMEM_MOVEABLE | LMEM_ZEROINIT);
    p = (LPVOID)REALLOCATE_MEMORY(p, 439, LMEM_MOVEABLE);
    p = (LPVOID)REALLOCATE_MEMORY(p, 720, LMEM_MOVEABLE);
    p = (LPVOID)REALLOCATE_MEMORY(p, 256, LMEM_MOVEABLE | LMEM_ZEROINIT);
    p = (LPVOID)REALLOCATE_MEMORY(p, 16, LMEM_MOVEABLE | LMEM_ZEROINIT);
    p = (LPVOID)REALLOCATE_MEMORY(p, 128, LMEM_MOVEABLE);
    p = (LPVOID)REALLOCATE_MEMORY(p, 32, LMEM_MOVEABLE | LMEM_ZEROINIT);
    p = (LPVOID)REALLOCATE_MEMORY(p, 4, LMEM_MOVEABLE);
    p = (LPVOID)REALLOCATE_MEMORY(p, 64, LMEM_MOVEABLE);
    p = (LPVOID)REALLOCATE_MEMORY(p, 63, LMEM_MOVEABLE | LMEM_ZEROINIT);
    p = (LPVOID)REALLOCATE_MEMORY(p, 64, LMEM_MOVEABLE | LMEM_ZEROINIT);
    p = (LPVOID)REALLOCATE_MEMORY(p, 65, LMEM_MOVEABLE | LMEM_ZEROINIT);
    p = (LPVOID)REALLOCATE_MEMORY(p, 65, LMEM_MOVEABLE);
    p = (LPVOID)REALLOCATE_MEMORY(p, 64, LMEM_MOVEABLE);
    p = (LPVOID)REALLOCATE_MEMORY(p, 64, LMEM_MOVEABLE);
    p = (LPVOID)FREE_MEMORY((HLOCAL)p);

    INET_ASSERT(p == NULL);

    p = (LPVOID)ALLOCATE_MEMORY(LMEM_FIXED, 8);
    p = (LPVOID)REALLOCATE_MEMORY(p, 8, LMEM_FIXED);
    p = (LPVOID)REALLOCATE_MEMORY(p, 100000, LMEM_FIXED);
    p = (LPVOID)FREE_MEMORY((HLOCAL)p);

    INET_ASSERT(p == NULL);

    InternetDebugCheckMemFreed(TRUE);
}


PRIVATE
VOID
ReportMemoryUsage(
    VOID
    )
{
    //
    // make copies of variables in case debug print functions want to allocate
    // debug memory (!)
    //

    SIZE_T totalActualMemoryAllocated;
    SIZE_T totalBlockMemoryAllocated;
    SIZE_T totalRealMemoryAllocated;
    SIZE_T totalActualMemoryFreed;
    SIZE_T totalBlockMemoryFreed;
    SIZE_T totalRealMemoryFreed;
    SIZE_T actualMemoryAllocated;
    SIZE_T blockLengthAllocated;
    SIZE_T realLengthAllocated;
    DWORD memoryAllocations;
    DWORD goodMemoryAllocations;
    DWORD memoryReAllocations;
    DWORD goodMemoryReAllocations;
    DWORD memoryFrees;
    DWORD goodMemoryFrees;
    SIZE_T largestBlockRequested;
    SIZE_T largestBlockAllocated;
    SIZE_T smallestBlockRequested;
    SIZE_T smallestBlockAllocated;

    EnterCriticalSection(&MemoryVarsCritSec);

    totalActualMemoryAllocated = TotalActualMemoryAllocated;
    totalBlockMemoryAllocated = TotalBlockMemoryAllocated;
    totalRealMemoryAllocated = TotalRealMemoryAllocated;
    totalActualMemoryFreed = TotalActualMemoryFreed;
    totalBlockMemoryFreed = TotalBlockMemoryFreed;
    totalRealMemoryFreed = TotalRealMemoryFreed;
    actualMemoryAllocated = ActualMemoryAllocated;
    blockLengthAllocated = BlockLengthAllocated;
    realLengthAllocated = RealLengthAllocated;
    memoryAllocations = MemoryAllocations;
    goodMemoryAllocations = GoodMemoryAllocations;
    memoryReAllocations = MemoryReAllocations;
    goodMemoryReAllocations = GoodMemoryReAllocations;
    memoryFrees = MemoryFrees;
    goodMemoryFrees = GoodMemoryFrees;
    largestBlockRequested = LargestBlockRequested;
    largestBlockAllocated = LargestBlockAllocated;
    smallestBlockRequested = SmallestBlockRequested;
    smallestBlockAllocated = SmallestBlockAllocated;

    LeaveCriticalSection(&MemoryVarsCritSec);

#ifdef _WIN64
    char numBuf[64];
#else
    char numBuf[32];
#endif

    DEBUG_PUT(("********************************************************************************\n"
               "\n"
               "WinHttp Debug Memory Usage:\n"
               "\n"
               "\tInternetDebugMemFlags = %#08x\n"
               "\n",
               InternetDebugMemFlags
               ));
    DEBUG_PUT(("\tTotal Memory Allocated. . . , . . . . %s\n", NiceNum(numBuf, totalActualMemoryAllocated, 0)));
    DEBUG_PUT(("\tTotal Block Length Allocated. . . . . %s\n", NiceNum(numBuf, totalBlockMemoryAllocated, 0)));
    DEBUG_PUT(("\tTotal User Length Allocated . . . . . %s\n", NiceNum(numBuf, totalRealMemoryAllocated, 0)));
    DEBUG_PUT(("\tTotal Memory Freed. . . . . . . . . . %s\n", NiceNum(numBuf, totalActualMemoryFreed, 0)));
    DEBUG_PUT(("\tTotal Block Length Freed. . . . . . . %s\n", NiceNum(numBuf, totalBlockMemoryFreed, 0)));
    DEBUG_PUT(("\tTotal User Length Freed . . . . . . . %s\n", NiceNum(numBuf, totalRealMemoryFreed, 0)));
    DEBUG_PUT(("\tMemory Still Allocated. . . . . . . . %s\n", NiceNum(numBuf, actualMemoryAllocated, 0)));
    DEBUG_PUT(("\tBlock Length Still Allocated. . . . . %s\n", NiceNum(numBuf, blockLengthAllocated, 0)));
    DEBUG_PUT(("\tUser Length Still Allocated . . . . . %s\n", NiceNum(numBuf, realLengthAllocated, 0)));
    DEBUG_PUT(("\tAttempted Memory Allocations. . . . . %s\n", NiceNum(numBuf, memoryAllocations, 0)));
    DEBUG_PUT(("\tGood Memory Allocations . . . . . . . %s\n", NiceNum(numBuf, goodMemoryAllocations, 0)));
    DEBUG_PUT(("\tAttempted Memory Reallocations. . . . %s\n", NiceNum(numBuf, memoryReAllocations, 0)));
    DEBUG_PUT(("\tGood Memory Reallocations . . . . . . %s\n", NiceNum(numBuf, goodMemoryReAllocations, 0)));
    DEBUG_PUT(("\tAttempted Memory Frees. . . . . . . . %s\n", NiceNum(numBuf, memoryFrees, 0)));
    DEBUG_PUT(("\tGood Memory Frees . . . . . . . . . . %s\n", NiceNum(numBuf, goodMemoryFrees, 0)));
    DEBUG_PUT(("\tLargest Block Requested . . . . . . . %s\n", NiceNum(numBuf, largestBlockRequested, 0)));
    DEBUG_PUT(("\tLargest Block Allocated . . . . . . . %s\n", NiceNum(numBuf, largestBlockAllocated, 0)));
    DEBUG_PUT(("\tLargest Block Requested From. . . . . %s!%d\n", SourceFilename(LargestBlockRequestedFile), LargestBlockRequestedLine));
    DEBUG_PUT(("\tSmallest Block Requested. . . . . . . %s\n", NiceNum(numBuf, smallestBlockRequested, 0)));
    DEBUG_PUT(("\tSmallest Block Allocated. . . . . . . %s\n", NiceNum(numBuf, smallestBlockAllocated, 0)));
    DEBUG_PUT(("\tSmallest Block Requested From . . . . %s!%d\n", SourceFilename(SmallestBlockRequestedFile), SmallestBlockRequestedLine));
    DEBUG_PUT(("\n"
               "\tBlocks Still Allocated. . . . . . . . %s\n", NiceNum(numBuf, goodMemoryAllocations - goodMemoryFrees, 0)));
    DEBUG_PUT(("\tMemory Still Allocated. . . . . . . . %s\n", NiceNum(numBuf, totalActualMemoryAllocated - totalActualMemoryFreed, 0)));
    DEBUG_PUT(("\n"
               "********************************************************************************\n"
               "\n"));
}


PRIVATE
VOID
ReportMemoryBlocks(
    VOID
    )
{
    DEBUG_PUT(("ReportMemoryBlocks\n\n"));

    DEBUG_PUT(("AllocatedBlockList:\n\n"));

    DumpMemoryList(&AllocatedBlockList);
    if (bDeferFree) {
        DumpDeferredFreeList();
    }
}


PRIVATE
VOID
DumpDeferredFreeList(
    VOID
    )
{
    DEBUG_PUT(("DeferredFreeList:\n\n"));

    DumpMemoryList(&DeferredFreeList);
}


PRIVATE
VOID
DumpMemoryList(
    IN LPSERIALIZED_LIST lpList
    )
{
    LPDEBUG_MEMORY_HEADER lpHeader;
    int counter = 1;

    if (bUseSymbols) {

        //
        // have to load IMAGEHLP.DLL here because we're in DLL_PROCESS_DETACH
        // and if we loaded it earlier, there's a good chance the system has
        // already freed it
        //

        InitSymLib();
    }

    LockSerializedList(lpList);
    lpHeader = (LPDEBUG_MEMORY_HEADER)HeadOfSerializedList(lpList);
    while (lpHeader != (LPDEBUG_MEMORY_HEADER)SlSelf(lpList)) {

        DEBUG_PUT(("Block # %d\n", counter));


        if (!DumpBlock(lpHeader)) {
            break;
        }

        DEBUG_PUT(("********************************************************************************\n\n"));

        lpHeader = (LPDEBUG_MEMORY_HEADER)(lpHeader->List.Flink);
        ++counter;
    }
    UnlockSerializedList(lpList);
}


PRIVATE
VOID
FindAndDumpDeferredBlock(
    IN HLOCAL hLocal
    )
{
    LPDEBUG_MEMORY_HEADER lpHeader;

    LockSerializedList(&DeferredFreeList);

    lpHeader = (LPDEBUG_MEMORY_HEADER)HeadOfSerializedList(&DeferredFreeList);
    while (lpHeader != (LPDEBUG_MEMORY_HEADER)SlSelf(&DeferredFreeList)) {
        if (hLocal == (HLOCAL)lpHeader) {
            DumpBlock(lpHeader);
            break;
        }
        lpHeader = (LPDEBUG_MEMORY_HEADER)(lpHeader->List.Flink);
    }

    UnlockSerializedList(&DeferredFreeList);
}


PRIVATE
BOOL
DumpBlock(
    IN LPDEBUG_MEMORY_HEADER lpHeader
    )
{
    BOOL ok = DumpDebugMemoryHeader(lpHeader);

    if (!ok && bStopDumpIfBadBlock) {

        DEBUG_PUT(("*** stopping block dump: header @ %#x is bad\n", lpHeader));

        return FALSE;
    }
    if (bReportUserData) {
        DumpUserData(lpHeader);
    }
    if (bReportMemoryFooters) {

        LPDEBUG_MEMORY_FOOTER lpFooter;

        lpFooter = (LPDEBUG_MEMORY_FOOTER)
                        ((LPBYTE)lpHeader
                        + sizeof(*lpHeader)
                        + ROUND_UP_DWORD(lpHeader->RequestedLength));
        ok = DumpDebugMemoryFooter(lpFooter);
        if (!ok && bStopDumpIfBadBlock) {

            DEBUG_PUT(("*** stopping block dump: footer @ %#x is bad\n", lpFooter));

            return FALSE;
        }
    }
    return TRUE;
}


PRIVATE
BOOL
DumpDebugMemoryHeader(
    LPDEBUG_MEMORY_HEADER lpHeader
    )
{
    char numBuf[32];
    BOOL result;
    LPSTR symbol;
    DWORD offset;
    int i;
    char flagsBuf[256];

    __try {
        DEBUG_PUT(("DEBUG_MEMORY_HEADER @ %#x:\n"
                   "\n",
                   lpHeader
                   ));
        DEBUG_PUT(("\tList. . . . . . . . . F=%#x B=%#x\n",
                   lpHeader->List.Flink,
                   lpHeader->List.Blink
                   ));
        DEBUG_PUT(("\tThread. . . . . . . . %#x\n",
                   lpHeader->ThreadId
                   ));
        DEBUG_PUT(("\tAllocated From. . . . %s!%d\n",
                   SourceFilename(lpHeader->CreatedFile),
                   lpHeader->CreatedLine
                   ));
        DEBUG_PUT(("\tLast Accessed From. . %s!%d\n",
                   SourceFilename(lpHeader->AccessedFile),
                   lpHeader->AccessedLine
                   ));
        DEBUG_PUT(("\tRequested Length. . . %s\n",
                   NiceNum(numBuf, lpHeader->RequestedLength, 0)
                   ));
        DEBUG_PUT(("\tBlock Length. . . . . %s\n",
                   NiceNum(numBuf, lpHeader->BlockLength, 0)
                   ));
        DEBUG_PUT(("\tActual Length . . . . %s\n",
                   NiceNum(numBuf, lpHeader->ActualLength, 0)
                   ));
        DEBUG_PUT(("\tSignature . . . . . . %x (%s)\n",
                   lpHeader->Signature,
                   (lpHeader->Signature == HEADER_SIGNATURE) ? "Good" : "BAD!!!"
                   ));
        DEBUG_PUT(("\tFlags . . . . . . . . %08x %s\n",
                   lpHeader->Flags,
                   MapMemoryFlags(lpHeader->Flags, flagsBuf)
                   ));
        DEBUG_PUT(("\tTime Deferred . . . . %08x\n",
                   lpHeader->TimeDeferred
                   ));
        DEBUG_PUT(("\tClash Test. . . . . . %d\n",
                   lpHeader->ClashTest
                   ));
        DEBUG_PUT(("\tLast Operation. . . . %s\n",
                   MapLastAccessOperation(lpHeader->LastAccessOperation)
                   ));

#if DUMP_STACK
#if ONE_STACK

        if (lpHeader->Stack[0]) {
            symbol = DbgMemGetDebugSymbol((DWORD)lpHeader->Stack[0], &offset);
        } else {
            symbol = "";
            offset = 0;
        }
        DEBUG_PUT(("\tStack . . . . . . . . %08x %s+%#x\n",
                   lpHeader->Stack[0],
                   symbol,
                   offset
                   ));
        for (i = 1; i < ARRAY_ELEMENTS(lpHeader->Stack); ++i) {
            //if (!lpHeader->lpHeader->Stack[i]) {
            //    break;
            //}
            if (lpHeader->Stack[i]) {
                symbol = DbgMemGetDebugSymbol((DWORD)lpHeader->Stack[i], &offset);
            } else {
                symbol = "";
                offset = 0;
            }
            DEBUG_PUT(("\t. . . . . . . . . . . %08x %s+%#x\n",
                       lpHeader->Stack[i],
                       symbol,
                       offset
                       ));
        }

#else

        if (lpHeader->LastAccessStack[0]) {
            symbol = DbgMemGetDebugSymbol((DWORD)lpHeader->LastAccessStack[0], &offset);
        } else {
            symbol = "";
            offset = 0;
        }
        DEBUG_PUT(("\tLastAccessStack . . . %08x %s+%#x\n",
                   lpHeader->LastAccessStack[0],
                   symbol,
                   offset
                   ));
        for (i = 1; i < ARRAY_ELEMENTS(lpHeader->LastAccessStack); ++i) {
            //if (!lpHeader->LastAccessStack[i]) {
            //    break;
            //}
            if (lpHeader->LastAccessStack[i]) {
                symbol = DbgMemGetDebugSymbol((DWORD)lpHeader->LastAccessStack[i], &offset);
            } else {
                symbol = "";
                offset = 0;
            }
            DEBUG_PUT(("\t. . . . . . . . . . . %08x %s+%#x\n",
                       lpHeader->LastAccessStack[i],
                       symbol,
                       offset
                       ));
        }
        if (lpHeader->CreateStack[0]) {
            symbol = DbgMemGetDebugSymbol((DWORD)lpHeader->CreateStack[0], &offset);
        } else {
            symbol = "";
            offset = 0;
        }
        DEBUG_PUT(("\tCreateStack . . . . . %08x %s+%#x\n",
                   lpHeader->CreateStack[0],
                   symbol,
                   offset
                   ));
        for (i = 1; i < ARRAY_ELEMENTS(lpHeader->CreateStack); ++i) {
            //if (!lpHeader->lpHeader->CreateStack[i]) {
            //    break;
            //}
            if (lpHeader->CreateStack[i]) {
                symbol = DbgMemGetDebugSymbol((DWORD)lpHeader->CreateStack[i], &offset);
            } else {
                symbol = "";
                offset = 0;
            }
            DEBUG_PUT(("\t. . . . . . . . . . . %08x %s+%#x\n",
                       lpHeader->CreateStack[i],
                       symbol,
                       offset
                       ));
        }

#endif // ONE_STACK
#endif // DUMP_STACK

        DEBUG_PUT(("\tGuard . . . . . . . . %08x\n"
                   "\n",
                   lpHeader->Guard[0]
                   ));
        result = TRUE;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        //DEBUG_PUT(("DEBUG_MEMORY_HEADER @ %#x is BAD\n", lpHeader));

        result = FALSE;
    }
    return result;
}


PRIVATE
BOOL
DumpDebugMemoryFooter(
    LPDEBUG_MEMORY_FOOTER lpFooter
    )
{
    char numBuf[32];
    BOOL result;

    _try {
        DEBUG_PUT(("DEBUG_MEMORY_FOOTER @ %#x:\n"
                   "\n",
                   lpFooter
                   ));
        DEBUG_PUT(("\tGuard . . . . . . . . %08x %08x %08x %08x\n",
                   lpFooter->Guard[0],
                   lpFooter->Guard[1],
                   lpFooter->Guard[2],
                   lpFooter->Guard[3]
                   ));
        DEBUG_PUT(("\tSignature . . . . . . %x (%s)\n",
                   lpFooter->Signature,
                   (lpFooter->Signature == FOOTER_SIGNATURE) ? "Good" : "BAD!!!"
                   ));
        DEBUG_PUT(("\tBlock Length. . . . . %s\n",
                   NiceNum(numBuf, lpFooter->BlockLength, 0)
                   ));
        DEBUG_PUT(("\tGuard2. . . . . . . . %08x %08x\n"
                   "\n",
                   lpFooter->Guard2[0],
                   lpFooter->Guard2[1]
                   ));
        result = TRUE;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        //DEBUG_PUT(("DEBUG_MEMORY_FOOTER @ %#x is BAD\n", lpFooter));

        result = FALSE;
    }
    return result;
}


PRIVATE
VOID
DumpUserData(
    LPDEBUG_MEMORY_HEADER lpHeader
    )
{
    static char spaces[] = "                                              ";    // 15 * 3 + 2
    SIZE_T userSize = lpHeader->RequestedLength;
    SIZE_T Size = ROUND_UP_DWORD(userSize);
    LPBYTE Address = (LPBYTE)(lpHeader + 1);

    DEBUG_PUT(("\t%d (%#x) bytes of user data (rounded to %d (%#x)) @ %#x\n\n",
               userSize,
               userSize,
               Size,
               Size,
               Address
               ));

    if (bLimitUserData && (Size > MaxUserDataDumped)) {

        DEBUG_PUT(("*** User data length %d too large: limited to %d (probably bad block)\n",
                   Size,
                   MaxUserDataDumped
                   ));

        Size = MaxUserDataDumped;
    }

    //
    // dump out the data, debug style
    //

    while (Size) {

        char buf[128];
        int len;
        int clen;

        rsprintf(buf, "\t%08x  ", Address);

        clen = (int)min(Size, 16);
        if (bDumpAsDwords) {
            len = clen / 4;
        } else {
            len = clen;
        }

        //
        // dump the hex representation of each character - up to 16 per line
        //

        int i;

        for (i = 0; i < len; ++i) {
            if (bDumpAsDwords) {
                rsprintf(&buf[11 + i * 9], "%08x ", ((LPDWORD)Address)[i]);
            } else {
                rsprintf(&buf[11 + i * 3],
                         ((i & 15) == 7) ? "%02.2x-" : "%02.2x ",
                         Address[i] & 0xff
                         );
            }
        }

        //
        // write as many spaces as required to tab to ASCII field
        //

        int offset;

        if (bDumpAsDwords) {
            memcpy(&buf[11 + i * 9], spaces, (4 - len) * 9 + 2);
            offset = 49;
        } else {
            memcpy(&buf[11 + i * 3], spaces, (16 - len) * 3 + 2);
            offset = 60;
        }

        //
        // dump ASCII representation of each character
        //

        for (i = 0; i < clen; ++i) {

            char ch;

            ch = Address[i];
            buf[offset + i] = ((ch < 32) || (ch > 127)) ? '.' : ch;
        }

        buf[offset + i++] = '\r';
        buf[offset + i++] = '\n';
        buf[offset + i] = 0;

        //
        // InternetDebugOut() - no printf expansion (%s in data!), no prefixes
        //

        InternetDebugOut(buf, FALSE);

        Address += clen;
        Size -= clen;
    }

    InternetDebugOut("\r\n", FALSE);
}


PRIVATE
LPSTR
MapLastAccessOperation(
    MEMORY_ACTION Action
    )
{
    switch (Action) {
    case MemAllocate:
        return "Alloc";

    case MemReallocate:
        return "Realloc";

    case MemLock:
        return "Lock";

    case MemUnlock:
        return "Unlock";

    case MemFree:
        return "Free";

    case MemSize:
        return "Size";
    }
    return "?";
}


PRIVATE
LPSTR
MapMemoryFlags(
    DWORD Flags,
    LPSTR Buffer
    )
{
    LPSTR buf = Buffer;
    int i = 0;

    *buf++ = '(';
    if (Flags & LMEM_DISCARDABLE) {
        buf += wsprintf(buf, "DISCARDABLE");
        ++i;
    }
    if (Flags & LMEM_ZEROINIT) {
        if (i) {
            buf += wsprintf(buf, ", ");
        }
        ++i;
        buf += wsprintf(buf, "ZEROINIT");
    }
    if (Flags & LMEM_NODISCARD) {
        if (i) {
            buf += wsprintf(buf, ", ");
        }
        ++i;
        buf += wsprintf(buf, "NODISCARD");
    }
    if (Flags & LMEM_NOCOMPACT) {
        if (i) {
            buf += wsprintf(buf, ", ");
        }
        ++i;
        buf += wsprintf(buf, "NOCOMPACT");
    }
    if (i) {
        buf += wsprintf(buf, ", ");
    }
    ++i;
    buf += wsprintf(buf, (Flags & LMEM_MOVEABLE) ? "MOVEABLE" : "FIXED");
    *buf++ = ')';
    *buf++ = '\0';
    return Buffer;
}


PRIVATE
LPSTR
DbgMemGetDebugSymbol(
    DWORD Address,
    LPDWORD Offset
    ) {
    //if (!bUseSymbols) {
    //    return "?";
    //}

    //
    // RLF 04/14/98 - IMAGEHLP blowing up probably because we are doing this at
    //                process detach time. Just return offset and run convsym
    //                utility on WinHttp.log
    //

    //return GetDebugSymbol(Address, Offset);
    *Offset = Address;
    return "";
}

#endif // defined(USE_DEBUG_MEMORY)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\debug\memalloc.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    memalloc.cxx

Abstract:

    Debug-only memory allocation routines

    Contents:
        InetInitializeDebugMemoryPackage
        InetTerminateDebugMemoryPackage
        InetAllocateMemory
        InetReallocateMemory
        (InetIsBlockMoveable)
        InetFreeMemory
        (InetCheckBlockConsistency)
        InetLockMemory
        InetUnlockMemory
        InetMemorySize
        InetCheckDebugMemoryFreed
        (x86SleazeCallersAddress)

Author:

     Richard L Firth (rfirth) 02-Feb-1995

Environment:

    Win32 user mode

Revision History:

    02-Feb-1995
        Created

--*/

#include <wininetp.h>
#include "rprintf.h"

#if INET_DEBUG

//
// manifests
//

#define HEADER_SIGNATURE    0x414d454d  // 'MEMA'
#define FOOTER_SIGNATURE    0x434f4c4c  // 'LLOC'
#define DWORD_FILL          0xa9a9a9a9
#define BYTE_FILL           0xa9
#define BYTE_FILL_EXTRA     0xcb
#define GUARD_DWORD_FILL    0xcccd21f4
#define DWORD_FREE_FILL     0xb7b7b7b7
#define BYTE_FREE_FILL      0xb7

//
// private types
//

typedef struct {

    //
    // hMoveable - local handle of moveable memory that this tag links
    //

    HLOCAL hMoveable;

} DEBUG_MOVEABLE_TAG, *LPDEBUG_MOVEABLE_TAG;

typedef struct {

    //
    // List - maintains a list of allocated blocks
    //

    LIST_ENTRY List;

    //
    // BlockLength - the size of this block, *including* all headers, footers
    // and padding
    //

    UINT BlockLength;

    //
    // RealLength - the original caller request
    //

    UINT RealLength;

    //
    // Signature - just used as a sanity check to ensure that what we are
    // dealing with is actually a block we allocated
    //

    DWORD Signature;

    //
    // LockCount - if this is moveable memory, keeps the number of times this
    // block has been locked
    //

    LONG LockCount;

    //
    // Flags - what type of memory this is, etc.
    //

    DWORD Flags;

    //
    // LastAccessOperation - the operation caller at LastAccessReturnAddress
    // performed
    //

    MEMALLOC_ACTION LastAccessOperation;

    //
    // LastAccessReturnAddress - caller of last function to perform memory
    // function operation (alloc, lock, realloc, unlock, etc) on this block
    //

    LPVOID LastAccessReturnAddress[2];

    //
    // CreatorReturnAddress - return EIP (x86-only) of caller of allocator
    // and caller of caller
    //

    LPVOID CreatorReturnAddress[2];

    //
    // Tag - if this is moveable memory, we can't add this block to the allocated
    // block list, we have to allocate a DEBUG_MOVEABLE_TAG, link that and point
    // to it from here
    //

    LPDEBUG_MOVEABLE_TAG Tag;

    //
    // Guard - just a sentinel to find out if the caller is writing before the
    // start of this block
    //

    DWORD Guard[4];

    //
    // sizeof(MEMORY_SIGNATURE) currently 17 DWORDs
    //

} DEBUG_MEMORY_HEADER, *LPDEBUG_MEMORY_HEADER;

typedef struct {

    //
    // Guard - allows us to determine if the end of allocated memory was
    // overwritten
    //

    DWORD Guard[4];

    //
    // Signature - should be the footer signature
    //

    DWORD Signature;

    //
    // BlockLength - should be the same as the header
    //

    DWORD BlockLength;

    //
    // Guard2 - to make sure the end of the block is coherent
    //

    DWORD Guard2[2];

    //
    // sizeof(DEBUG_MEMORY_FOOTER) currently 8 DWORDs
    //

} DEBUG_MEMORY_FOOTER, *LPDEBUG_MEMORY_FOOTER;

//
// data
//

LONG ActualMemoryAllocated = 0;
LONG BlockLengthAllocated = 0;
LONG RealLengthAllocated = 0;
DWORD MemoryAllocations = 0;
DWORD MemoryFrees = 0;
SERIALIZED_LIST AllocatedBlockList;

//
// macros
//

#if defined(i386)

#define GET_CALLERS_ADDRESS(p, pp)  x86SleazeCallersAddress(p, pp)

#else

#define GET_CALLERS_ADDRESS(p, pp)

#endif // defined(i386)

//
// private prototypes
//

PRIVATE
BOOL
InetIsBlockMoveable(
    IN HLOCAL hLocal
    );

PRIVATE
VOID
InetCheckBlockConsistency(
    IN LPVOID lpMemory
    );

PRIVATE
VOID
x86SleazeCallersAddress(
    LPVOID* pCaller,
    LPVOID* pCallersCaller
    );

//
// functions
//


VOID
InetInitializeDebugMemoryPackage(
    VOID
    )

/*++

Routine Description:

    Just initializes data items in this module

Arguments:

    None.

Return Value:

    None.

--*/

{
    static BOOL MemoryPackageInitialized = FALSE;

    if (!MemoryPackageInitialized) {
        InitializeSerializedList(&AllocatedBlockList);
        MemoryPackageInitialized = TRUE;
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("Memory package already initialized\n"
                    ));

        DEBUG_BREAK(MEMALLOC);

    }
}


VOID
InetTerminateDebugMemoryPackage(
    VOID
    )

/*++

Routine Description:

    Undoes any resource allocation in InetInitializeDebugMemoryPackage, after
    checking that all memory is freed

Arguments:

    None.

Return Value:

    None.

--*/

{
    InetCheckDebugMemoryFreed();
    TerminateSerializedList(&AllocatedBlockList);
}


HLOCAL
InetAllocateMemory(
    IN UINT LocalAllocFlags,
    IN UINT NumberOfBytes
    )

/*++

Routine Description:

    Debug memory allocator: allocates memory with head & tail. Fills memory
    with signature unless otherwise requested. If this is moveable memory
    then the caller must lock the memory with InetLockMemory(), else a pointer
    will be returned to the head of the heap's real start-of-block, and the
    caller will probably nuke the signature contents (but we should discover
    this when the block is freed)

Arguments:

    LocalAllocFlags - flags to be passed on to LocalAlloc
    NumberOfBytes   - to allocate for caller

Return Value:

    LPVOID
        Success - pointer to memory after DEBUG_MEMORY_HEADER
        Failure - NULL

--*/

{
    HLOCAL hLocal;
    UINT blockLength;
    BOOL isMoveable;

    isMoveable = (LocalAllocFlags & LMEM_MOVEABLE) ? TRUE : FALSE;
    blockLength = ROUND_UP_DWORD(NumberOfBytes)
                + sizeof(DEBUG_MEMORY_HEADER)
                + sizeof(DEBUG_MEMORY_FOOTER)
                ;

    //
    // possible problem: if NumberOfBytes + signatures would overflow UINT.
    // Only really problematic on 16-bit platforms
    //

    if (blockLength < NumberOfBytes) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("can't allocate %lu bytes: would overflow\n",
                    (DWORD)NumberOfBytes
                    ));

        DEBUG_BREAK(MEMALLOC);

        return (HLOCAL)NULL;
    }

    hLocal = LocalAlloc(LocalAllocFlags, blockLength);
    if (hLocal != NULL) {

        LPVOID lpMem;
        LPDEBUG_MEMORY_HEADER lpHeader;
        DWORD dwFiller;
        BYTE bFiller;
        UINT dwFillLength;
        UINT bFillLength1;
        UINT bFillLength2;
        UINT i;
        LPVOID userPointer;

        ActualMemoryAllocated += LocalSize(hLocal);
        BlockLengthAllocated += blockLength;
        RealLengthAllocated += NumberOfBytes;
        ++MemoryAllocations;

        if (isMoveable) {
            lpMem = (LPVOID)LocalLock(hLocal);
            if (lpMem == NULL) {

                DEBUG_PRINT(MEMALLOC,
                            ERROR,
                            ("LocalLock(%x) failed: %d\n",
                            hLocal,
                            GetLastError()
                            ));

                DEBUG_BREAK(MEMALLOC);

            }
        } else {
            lpMem = (LPVOID)hLocal;
        }

        lpHeader = (LPDEBUG_MEMORY_HEADER)lpMem;
        InitializeListHead(&lpHeader->List);
        lpHeader->BlockLength = blockLength;
        lpHeader->RealLength = NumberOfBytes;
        lpHeader->Signature = HEADER_SIGNATURE;
        lpHeader->LockCount = 0;
        lpHeader->Flags = LocalAllocFlags;

        GET_CALLERS_ADDRESS(&lpHeader->CreatorReturnAddress[0],
                            &lpHeader->CreatorReturnAddress[1]
                            );

        lpHeader->LastAccessOperation = MemAllocate;

        for (i = 0; i < ARRAY_ELEMENTS(lpHeader->Guard); ++i) {
            lpHeader->Guard[i] = GUARD_DWORD_FILL;
        }

        if (LocalAllocFlags & LMEM_ZEROINIT) {
            dwFiller = 0;
            bFiller = 0;
        } else {
            dwFiller = DWORD_FILL;
            bFiller = BYTE_FILL;
        }
        dwFillLength = NumberOfBytes / sizeof(DWORD);
        bFillLength1 = NumberOfBytes % sizeof(DWORD);
        bFillLength2 = bFillLength1 ? (sizeof(DWORD) - bFillLength1) : 0;
        userPointer = (LPVOID)(lpHeader + 1);

        LPDWORD lpdwUserPointer = (LPDWORD)userPointer;

        for (i = 0; i < dwFillLength; ++i) {
            *lpdwUserPointer++ = dwFiller;
        }

        LPBYTE lpbUserPointer = (LPBYTE)lpdwUserPointer;

        for (i = 0; i < bFillLength1; ++i) {
            *lpbUserPointer++ = bFiller;
        }
        for (i = 0; i < bFillLength2; ++i) {
            *lpbUserPointer++ = BYTE_FILL_EXTRA;
        }

        userPointer = (LPVOID)lpbUserPointer;

        for (i = 0; i < ARRAY_ELEMENTS(((LPDEBUG_MEMORY_FOOTER)userPointer)->Guard); ++i) {
            ((LPDEBUG_MEMORY_FOOTER)userPointer)->Guard[i] = GUARD_DWORD_FILL;
        }
        ((LPDEBUG_MEMORY_FOOTER)userPointer)->BlockLength = blockLength;
        ((LPDEBUG_MEMORY_FOOTER)userPointer)->Signature = FOOTER_SIGNATURE;
        for (i = 0; i < ARRAY_ELEMENTS(((LPDEBUG_MEMORY_FOOTER)userPointer)->Guard2); ++i) {
            ((LPDEBUG_MEMORY_FOOTER)userPointer)->Guard2[i] = GUARD_DWORD_FILL;
        }

        //
        // if this is moveable memory, then we can't link it into the allocated
        // block list because if it moves, the list gets nuked. So we have to
        // allocate a DEBUG_MOVEABLE_TAG, link that and point to it from here
        //

        if (isMoveable) {

            LPDEBUG_MOVEABLE_TAG lpTag;

            lpTag = (LPDEBUG_MOVEABLE_TAG)InetAllocateMemory(LMEM_FIXED, sizeof(DEBUG_MOVEABLE_TAG));

            INET_ASSERT(lpTag != NULL);

            lpTag->hMoveable = hLocal;
            lpHeader->Tag = lpTag;
        } else {
            if (!InsertAtHeadOfSerializedList(&AllocatedBlockList, &lpHeader->List)) {
                DEBUG_PRINT(MEMALLOC,
                            ERROR,
                            ("InetAllocateMemory(%x): Unable to insert to allocated block list\n",
                            hLocal
                            ));

                DEBUG_BREAK(MEMALLOC);
            }
        }

        if (isMoveable) {
            if (LocalUnlock(hLocal)) {

                DEBUG_PRINT(MEMALLOC,
                            ERROR,
                            ("LocalUnlock(%x): memory still locked\n",
                            hLocal
                            ));

                DEBUG_BREAK(MEMALLOC);

            } else {

                DWORD err;

                err = GetLastError();
                if (err != NO_ERROR) {

                    DEBUG_PRINT(MEMALLOC,
                                ERROR,
                                ("LocalUnlock(%x) returns %d\n",
                                hLocal,
                                err
                                ));

                    DEBUG_BREAK(MEMALLOC);

                }
            }
        } else {
            hLocal = (HLOCAL)(lpHeader + 1);
        }
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("failed to allocate %u bytes memory\n",
                    blockLength
                    ));

        DEBUG_BREAK(MEMALLOC);

    }
    return hLocal;
}


HLOCAL
InetReallocateMemory(
    IN HLOCAL hLocal,
    IN UINT Size,
    IN UINT Flags,
    IN BOOL IsMoveable
    )

/*++

Routine Description:

    Reallocates previously allocated block

    BUGBUG - this doesn't handle the more exotic LocalReAlloc stuff, like
             DISCARDABLE memory, allocating/freeing through realloc etc

Arguments:

    hLocal      - block to reallocate
    Size        - new size
    Flags       - new flags
    IsMoveable  - TRUE if this is moveable memory. We need this help because
                  there is no good way to find out from hLocal whether this
                  memory is moveable or fixed

Return Value:

    HLOCAL

--*/

{
    LPDEBUG_MEMORY_HEADER lpHeader;
    UINT realLength;
    UINT heapLength;

    //
    // can't handle reallocating down to zero
    //

    INET_ASSERT(Size != 0);

    if (IsMoveable) {
        lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);
        heapLength = LocalSize(hLocal);
    } else {
        lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal - 1;
        heapLength = LocalSize((HLOCAL)lpHeader);
    }

    InetCheckBlockConsistency((LPVOID)lpHeader);

    if (IsMoveable) {
        LocalUnlock(hLocal);
    }

    realLength = Size;

    Size = ROUND_UP_DWORD(Size)
         + sizeof(DEBUG_MEMORY_HEADER)
         + sizeof(DEBUG_MEMORY_FOOTER)
         ;

    ActualMemoryAllocated -= heapLength;
    BlockLengthAllocated -= lpHeader->BlockLength;
    RealLengthAllocated -= lpHeader->RealLength;

    hLocal = LocalReAlloc(hLocal, Size, Flags);
    if (hLocal != NULL) {

        LPBYTE extraPointer;
        UINT extraLength;
        UINT i;
        LPDEBUG_MEMORY_FOOTER lpFooter;

        if (IsMoveable) {
            lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);
        } else {
            lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal;
        }

        lpHeader->BlockLength = Size;
        lpHeader->RealLength = realLength;
        lpHeader->Flags = Flags;

        GET_CALLERS_ADDRESS(&lpHeader->LastAccessReturnAddress[0],
                            &lpHeader->LastAccessReturnAddress[1]
                            );

        lpHeader->LastAccessOperation = MemReallocate;

        extraPointer = (LPBYTE)(lpHeader + 1) + realLength;
        extraLength = (sizeof(DWORD) - (realLength % sizeof(DWORD)))
                    & (sizeof(DWORD) - 1)
                    ;
        for (i = 0; i < extraLength; ++i) {
            *extraPointer++ = BYTE_FILL_EXTRA;
        }
        lpFooter = (LPDEBUG_MEMORY_FOOTER)((LPBYTE)(lpHeader + 1)
                 + ROUND_UP_DWORD(realLength)
                 );
        for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard); ++i) {
            lpFooter->Guard[i] = GUARD_DWORD_FILL;
        }
        lpFooter->Signature = FOOTER_SIGNATURE;
        lpFooter->BlockLength = Size;
        for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard2); ++i) {
            lpFooter->Guard2[i] = GUARD_DWORD_FILL;
        }
        ActualMemoryAllocated += LocalSize(hLocal);
        BlockLengthAllocated += Size;
        RealLengthAllocated += lpHeader->RealLength;
        if (IsMoveable) {
            LocalUnlock(hLocal);
        } else {
            hLocal = (HLOCAL)(lpHeader + 1);
        }
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("failed to reallocate %u bytes memory. Last error = %d\n",
                    Size,
                    GetLastError()
                    ));

        DEBUG_BREAK(MEMALLOC);

    }
    return hLocal;
}


PRIVATE
BOOL
InetIsBlockMoveable(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Determines if hLocal is moveable or fixed memory

Arguments:

    hLocal  -

Return Value:

    BOOL

--*/

{
    LPDEBUG_MEMORY_HEADER lpHeader;
    BOOL isMoveable;

    //
    // BUGBUG - this method won't work for Win32s unless it supports SEH. But
    //          there is another method...
    //

    lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal - 1;
    __try {
        if (lpHeader->Signature == HEADER_SIGNATURE) {
            isMoveable = FALSE;
        } else {

            lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);

            INET_ASSERT(lpHeader != NULL);

            isMoveable = (BOOL)(lpHeader->Signature == HEADER_SIGNATURE);
            LocalUnlock(hLocal);
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // yeowww! hLocal must be a handle to moveable memory. Either that, or
        // it is completely bogus
        //

        lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);

        INET_ASSERT(lpHeader != NULL);

        isMoveable = (BOOL)(lpHeader->Signature == HEADER_SIGNATURE);
        LocalUnlock(hLocal);
    }
    return isMoveable;
}


HLOCAL
InetFreeMemory(
    IN HLOCAL hLocal,
    IN BOOL IsMoveable
    )

/*++

Routine Description:

    Debug memory deallocator: checks memory is already allocated and that the
    head and tail structures are still ok. Fills freed memory with signature

Arguments:

    hLocal  - address/handle of memory to free
    IsMoveable  - TRUE if this is moveable memory. We need this help because
                  there is no good way to determine if the memory is moveable
                  or fixed

Return Value:

    HLOCAL
        Success - NULL
        Failure - hLocal

--*/

{
    UINT memFlags;
    LPDEBUG_MEMORY_HEADER lpHeader;
    BOOL isMoveable;
    UINT memSize;
    UINT blockLength;
    UINT realLength;

    if (!IsMoveable) {
        hLocal = (HLOCAL)((LPDEBUG_MEMORY_HEADER)hLocal - 1);
    }

    memFlags = LocalFlags(hLocal);

    INET_ASSERT(memFlags != LMEM_INVALID_HANDLE);
    INET_ASSERT((memFlags & LMEM_LOCKCOUNT) == 0);

    if (IsMoveable) {
        lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);

        INET_ASSERT(lpHeader != NULL);

    } else {
        lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal;
    }

    memSize = LocalSize(hLocal);

    INET_ASSERT((lpHeader->BlockLength <= memSize)
                && !(lpHeader->BlockLength & (sizeof(DWORD) - 1))
                && (lpHeader->RealLength < lpHeader->BlockLength)
                );

    InetCheckBlockConsistency((LPVOID)lpHeader);

    //
    // if this is moveable memory then we didn't link it to the allocated
    // block list, but allocated a DEBUG_MOVEABLE_TAG to do the job. We
    // must remove it
    //

    if (IsMoveable) {

        LPDEBUG_MOVEABLE_TAG lpTag;

        lpTag = lpHeader->Tag;

        INET_ASSERT(lpTag->hMoveable == hLocal);

        InetFreeMemory(lpTag, FALSE);
    } else {
        if (!RemoveFromSerializedList(&AllocatedBlockList, &lpHeader->List)) {
            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("Couldn't remove %#x from allocated block list\n",
                        hLocal
                        ));

            DEBUG_BREAK(MEMALLOC);

            return hLocal;
        }
    }

    if (IsMoveable) {

        BOOL stillLocked;

        stillLocked = LocalUnlock(hLocal);

        INET_ASSERT(!stillLocked);
        INET_ASSERT(GetLastError() == NO_ERROR);

    }

    blockLength = lpHeader->BlockLength;
    realLength = lpHeader->RealLength;
    hLocal = LocalFree(hLocal);

    INET_ASSERT(hLocal == NULL);

    ActualMemoryAllocated -= memSize;
    BlockLengthAllocated -= blockLength;
    RealLengthAllocated -= realLength;
    ++MemoryFrees;

    return hLocal;
}


PRIVATE
VOID
InetCheckBlockConsistency(
    IN LPVOID lpMemory
    )

/*++

Routine Description:

    Checks that what we think is a valid allocated block (allocated by
    InetAllocateMemory), really is

Arguments:

    lpMemory    - pointer to what we think is DEBUG_MEMORY_HEADER

Return Value:

    None.

--*/

{
    LPDEBUG_MEMORY_HEADER lpHeader;
    LPDEBUG_MEMORY_FOOTER lpFooter;
    UINT i;
    BOOL headerGuardOverrun;
    BOOL footerGuardOverrun;
    BOOL footerGuard2Overrun;
    BOOL extraMemoryOverrun;
    LPBYTE lpExtraMemory;
    UINT byteLength;

    __try {
        lpHeader = (LPDEBUG_MEMORY_HEADER)lpMemory;
        lpFooter = (LPDEBUG_MEMORY_FOOTER)((LPBYTE)lpMemory
                 + (lpHeader->BlockLength - sizeof(DEBUG_MEMORY_FOOTER)))
                 ;

        headerGuardOverrun = FALSE;
        for (i = 0; i < ARRAY_ELEMENTS(lpHeader->Guard); ++i) {
            if (lpHeader->Guard[i] != GUARD_DWORD_FILL) {
                headerGuardOverrun = TRUE;
                break;
            }
        }

        footerGuardOverrun = FALSE;
        for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard); ++i) {
            if (lpFooter->Guard[i] != GUARD_DWORD_FILL) {
                footerGuardOverrun = TRUE;
                break;
            }
        }

        footerGuard2Overrun = FALSE;
        for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard2); ++i) {
            if (lpFooter->Guard2[i] != GUARD_DWORD_FILL) {
                footerGuard2Overrun = TRUE;
                break;
            }
        }

        lpExtraMemory = (LPBYTE)(lpHeader + 1) + lpHeader->RealLength;
        extraMemoryOverrun = FALSE;
        byteLength = ROUND_UP_DWORD(lpHeader->RealLength) - lpHeader->RealLength;
        for (i = 0; i < byteLength; ++i) {
            if (lpExtraMemory[i] != BYTE_FILL_EXTRA) {
                extraMemoryOverrun = TRUE;
                break;
            }
        }

        if (headerGuardOverrun
        || footerGuardOverrun
        || footerGuard2Overrun
        || extraMemoryOverrun
        || (lpHeader->Signature != HEADER_SIGNATURE)
        || (lpFooter->Signature != FOOTER_SIGNATURE)
        || (lpFooter->BlockLength != lpHeader->BlockLength)) {

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("Bad block: %x\n",
                        lpMemory
                        ));

            DEBUG_BREAK(MEMALLOC);

        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        DEBUG_PRINT(MEMALLOC,
                    FATAL,
                    ("Invalid block %x - exception occurred\n",
                    lpMemory
                    ));

        DEBUG_BREAK(MEMALLOC);

    }
}


LPVOID
InetLockMemory(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Locks a moveable memory block and increments the lock count. Checks block
    consistency

Arguments:

    hLocal  - handle of moveable memory to lock

Return Value:

    LPVOID
        pointer to locked memory

--*/

{
    LPDEBUG_MEMORY_HEADER lpHeader = NULL;
    UINT memFlags;

    memFlags = LocalFlags(hLocal);

    INET_ASSERT(memFlags != LMEM_INVALID_HANDLE);

    lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);

    INET_ASSERT(lpHeader != NULL);

    InetCheckBlockConsistency((LPVOID)lpHeader);
    ++lpHeader->LockCount;

    GET_CALLERS_ADDRESS(&lpHeader->LastAccessReturnAddress[0],
                        &lpHeader->LastAccessReturnAddress[1]
                        );

    lpHeader->LastAccessOperation = MemLock;

    memFlags = LocalFlags(hLocal);

    INET_ASSERT((memFlags != LMEM_INVALID_HANDLE)
                && (lpHeader->LockCount == (LONG)(memFlags & LMEM_LOCKCOUNT))
                );

    return ++lpHeader;
}


BOOL
InetUnlockMemory(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Unlocks a (locked!) moveable memory block

Arguments:

    hLocal  - handle (pointer) of block to unlock

Return Value:

    None.

--*/

{
    UINT memFlags;
    BOOL stillLocked;
    LPDEBUG_MEMORY_HEADER lpHeader;
    DWORD lockCount;

    memFlags = LocalFlags(hLocal);

    INET_ASSERT(memFlags != LMEM_INVALID_HANDLE);
    INET_ASSERT((memFlags & LMEM_LOCKCOUNT) >= 1);

    //
    // memory must be locked or LocalFlags would have returned error.
    // Lock memory again to get pointer to block, then unlock it.
    // There should still be at least one lock on the block
    //

    lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);
    LocalUnlock(hLocal);

    InetCheckBlockConsistency((LPVOID)lpHeader);

    GET_CALLERS_ADDRESS(&lpHeader->LastAccessReturnAddress[0],
                        &lpHeader->LastAccessReturnAddress[1]
                        );

    lpHeader->LastAccessOperation = MemUnlock;

    lockCount = --lpHeader->LockCount;
    stillLocked = LocalUnlock(hLocal);

    INET_ASSERT(stillLocked ? (lockCount > 0) : GetLastError() == NO_ERROR);

    return stillLocked;
}


UINT
InetMemorySize(
    IN HLOCAL hLocal,
    IN BOOL IsMoveable
    )

/*++

Routine Description:

    Returns allocated block size

Arguments:

    hLocal      - memory handle
    IsMoveable  - TRUE if hLocal is a handle to moveable memory >>> THAT IS NOT
                  LOCKED <<<

Return Value:

    UINT

--*/

{
    UINT size;
    UINT sizeInHeader;
    LPDEBUG_MEMORY_HEADER lpHeader;

    if (IsMoveable) {
        lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);

        INET_ASSERT(lpHeader != NULL);

        sizeInHeader = lpHeader->RealLength;
        size = LocalSize(hLocal);
        LocalUnlock(hLocal);
    } else {
        lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal - 1;

        INET_ASSERT(lpHeader->Signature == HEADER_SIGNATURE);

        sizeInHeader = lpHeader->RealLength;
        size = LocalSize((HLOCAL)lpHeader);
    }

    INET_ASSERT((sizeInHeader <= size)
                && (size >= sizeof(DEBUG_MEMORY_HEADER) + sizeof(DEBUG_MEMORY_FOOTER))
                );

    return sizeInHeader;
}


BOOL
InetCheckDebugMemoryFreed(
    VOID
    )

/*++

Routine Description:

    Check that we don't have any memory allocated

Arguments:

    None.

Return Value:

    BOOL

--*/

{
    if (ActualMemoryAllocated || (MemoryFrees != MemoryAllocations)) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("MemoryAllocated = %ld, MemoryAllocations = %lu, MemoryFrees = %lu\n",
                    ActualMemoryAllocated,
                    MemoryAllocations,
                    MemoryFrees
                    ));

        DEBUG_BREAK(MEMALLOC);

        return FALSE;
    }
    return TRUE;
}

#if defined(i386)


VOID
x86SleazeCallersAddress(
    LPVOID* pCaller,
    LPVOID* pCallersCaller
    )

/*++

Routine Description:

    This is a sleazy function that reads return addresses out of the stack/
    frame pointer (ebp). We pluck out the return address of the function
    that called THE FUNCTION THAT CALLED THIS FUNCTION, and the caller of
    that function. Returning the return address of the function that called
    this function is not interesting to that caller (almost worthy of Sir
    Humphrey Appleby isn't it?)

    Assumes:

        my ebp  =>  | caller's ebp |
                    | caller's eip |
                    | arg #1       | (pCaller)
                    | arg #2       | (pCallersCaller

Arguments:

    pCaller         - place where we return addres of function that called
                      the function that called this function
    pCallersCaller  - place where we return caller of above

Return Value:

    None.

--*/

{

    //
    // this only works on x86 and only if not fpo functions!
    //

    LPVOID* ebp;

    ebp = (PVOID*)&pCaller - 2; // told you it was sleazy
    ebp = (PVOID*)*(PVOID*)ebp;
    *pCaller = *(ebp + 1);
    ebp = (PVOID*)*(PVOID*)ebp;
    *pCallersCaller = *(ebp + 1);
}

#endif // defined(i386)

#endif // INET_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\debug\dbghandle.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    handle.cxx

Abstract:

    Contains function to return number of open handles owned by this process

    Contents:
        InternetHandleCount

Author:

    Richard L Firth (rfirth) 02-May-1995

Environment:

    Win32 user-mode DLL

Revision History:

    02-May-1995 rfirth
        Created

--*/

#include <wininetp.h>
#include "rprintf.h"

#if INET_DEBUG

//
// private types
//

typedef (*NT_QUERY_SYSTEM_INFORMATION)(ULONG, PVOID, ULONG, PULONG);

//
// functions
//


DWORD
InternetHandleCount(
    VOID
    )

/*++

Routine Description:

    Gets the number of system handles owned by this process. We LoadLibrary()
    NTDLL.DLL so that the debug version of this DLL still works on Win95

Arguments:

    None.

Return Value:

    DWORD

--*/

{
    static HINSTANCE hNtdll = NULL;
    static NT_QUERY_SYSTEM_INFORMATION _NtQuerySystemInformation;

    if (IsPlatformWin95()) {
        return 0;
    }

    if (hNtdll == NULL) {
        hNtdll = LoadLibrary("ntdll");
        if (hNtdll == NULL) {
            return 0;
        }
        _NtQuerySystemInformation = (NT_QUERY_SYSTEM_INFORMATION)GetProcAddress(hNtdll, "NtQuerySystemInformation");
        if (_NtQuerySystemInformation == 0) {
            FreeLibrary(hNtdll);
            hNtdll = NULL;
        }
    }

    if (_NtQuerySystemInformation) {

        DWORD idProcess;
        NTSTATUS status;
        ULONG outputLength;
        BYTE buffer[32768];
        PSYSTEM_PROCESS_INFORMATION info;

        status = _NtQuerySystemInformation(SystemProcessInformation,
                                           (PVOID)buffer,
                                           sizeof(buffer),
                                           &outputLength
                                           );
        if (!NT_SUCCESS(status)) {
            return 0;
        }
        info = (PSYSTEM_PROCESS_INFORMATION)buffer;
        idProcess = GetCurrentProcessId();
        while (TRUE) {
            if ((DWORD_PTR)info->UniqueProcessId == idProcess) {
                return info->HandleCount;
            }
            if (info->NextEntryOffset == 0) {
                return 0;
            }
            info = (PSYSTEM_PROCESS_INFORMATION)((PCHAR)info + info->NextEntryOffset);
        }
    }
    return 0;
}

#endif // INET_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\debug\exceptn.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    exceptn.cxx

Abstract:

    Contains exception-handling code for debug version

    Contents:
        SetExceptionHandler
        (WininetExceptionFilter)
        (MapX86ProcessorFlags)

Author:

    Richard L Firth (rfirth) 18-Feb-1997

Revision History:

    18-Feb-1997 rfirth
        Created

--*/

#include <wininetp.h>
#include "rprintf.h"

#if INET_DEBUG

//
// private prototypes
//

PRIVATE
LONG
WininetExceptionFilter(
    IN PEXCEPTION_POINTERS pExPtrs
    );

#if defined(_X86_)

PRIVATE
LPSTR
MapX86ProcessorFlags(
    IN DWORD Flags
    );

#endif // defined(_X86_)

//
// functions
//


VOID
SetExceptionHandler(
    VOID
    )

/*++

Routine Description:

    Just sets the unhandled exception filter for this process

Arguments:

    None.

Return Value:

    None.

--*/

{
    SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)WininetExceptionFilter);
}


PRIVATE
LONG
WininetExceptionFilter(
    IN PEXCEPTION_POINTERS pExPtrs
    )

/*++

Routine Description:

    We get to look at unhandled exceptions, and dump them to the debug log

Arguments:

    pExPtrs - pointer to exception pointers structure

Return Value:

    LONG

--*/

{
    //
    // don't bother if we are not logging
    //

    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return EXCEPTION_CONTINUE_SEARCH;
    }

    LPSTR text;
    LONG disposition = EXCEPTION_EXECUTE_HANDLER;
    DWORD eipOffset = 0;

    switch (pExPtrs->ExceptionRecord->ExceptionCode) {
    case EXCEPTION_ACCESS_VIOLATION:
        text = "Access Violation";
        break;

    case EXCEPTION_DATATYPE_MISALIGNMENT:
        text = "Data Misalignment Exception";
        break;

    case EXCEPTION_BREAKPOINT:
        text = "Breakpoint Exception";
        disposition = EXCEPTION_CONTINUE_EXECUTION;
        eipOffset = 1;
        break;

    case EXCEPTION_SINGLE_STEP:
        text = "Single Step Exception";
        break;

    case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
        text = "Array Bounds Exceeded Exception";
        break;

    case EXCEPTION_FLT_DENORMAL_OPERAND:
    case EXCEPTION_FLT_DIVIDE_BY_ZERO:
    case EXCEPTION_FLT_INEXACT_RESULT:
    case EXCEPTION_FLT_INVALID_OPERATION:
    case EXCEPTION_FLT_OVERFLOW:
    case EXCEPTION_FLT_STACK_CHECK:
    case EXCEPTION_FLT_UNDERFLOW:
        text = "Floating Point Exception";
        break;

    case EXCEPTION_INT_DIVIDE_BY_ZERO:
        text = "Integer Divide-By-Zero Exception";
        break;

    case EXCEPTION_INT_OVERFLOW:
        text = "Integer Overflow Exception";
        break;

    case EXCEPTION_PRIV_INSTRUCTION:
        text = "Privileged Instruction Exception";
        break;

    case EXCEPTION_IN_PAGE_ERROR:
        text = "In-Page Error";
        break;

    case EXCEPTION_ILLEGAL_INSTRUCTION:
        text = "Illegal Instruction";
        break;

    case EXCEPTION_NONCONTINUABLE_EXCEPTION:
        text = "Non-Continuable Exception";
        break;

    case EXCEPTION_STACK_OVERFLOW:
        text = "Stack Overflow";
        break;

    case EXCEPTION_INVALID_DISPOSITION:
        text = "Invalid Disposition Exception";
        break;

    case EXCEPTION_GUARD_PAGE:
        text = "Guard Page Exception";
        break;

    case EXCEPTION_INVALID_HANDLE:
        text = "Invalid Handle Exception";
        break;

    case CONTROL_C_EXIT:
        text = "Control-C Exception";
        break;

    default:
        text = "Unknown Exception";
        break;
    }

    InitSymLib();

    
    DWORD dwCodeOffset;
    // BUGBUG: Not 64b compatible
    LPSTR lpszDebugSymbol = GetDebugSymbol(PtrToUlong(pExPtrs->ExceptionRecord->ExceptionAddress),
                                           &dwCodeOffset
                                           );

    char buffer[512];
    int offset;
    BOOL needCrLf = FALSE;

    offset = rsprintf(buffer,
                      "\n"
                      "********************************************************************************\n"
                      "Thread %#x\n"
                      "%s at %#08x",
                      GetCurrentThreadId(),
                      text,
                      pExPtrs->ExceptionRecord->ExceptionAddress
                      );
    if (dwCodeOffset != (DWORD_PTR)pExPtrs->ExceptionRecord->ExceptionAddress) {
        offset += rsprintf(&buffer[offset],
                           " (%s+%#x)\n",
                           lpszDebugSymbol,
                           dwCodeOffset
                           );
    } else {
        buffer[offset++] = ' ';
        needCrLf = TRUE;
    }
    if (pExPtrs->ExceptionRecord->ExceptionCode == EXCEPTION_ACCESS_VIOLATION) {
        rsprintf(&buffer[offset],
                 "%sing %#08x\n",
                 pExPtrs->ExceptionRecord->ExceptionInformation[0]
                    ? "writ"
                    : "read",
                 pExPtrs->ExceptionRecord->ExceptionInformation[1]
                 );
    } else if (needCrLf) {
        buffer[offset++] = '\r';
        buffer[offset++] = '\n';
        buffer[offset] = '\0';
    }
    InternetDebugOut(buffer, FALSE);

#if defined(_X86_)

    if ((pExPtrs->ContextRecord->ContextFlags & CONTEXT_FULL) == CONTEXT_FULL) {
        rsprintf(buffer,
                 "\n"
                 "Processor Context:\n"
                 "eax=%08x ebx=%08x ecx=%08x edx=%08x esi=%08x edi=%08x\n"
                 "eip=%08x esp=%08x ebp=%08x iopl=%d         %s\n"
                 "cs=%04x ss=%04x ds=%04x es=%04x fs=%04x gs=%04x                  efl=%08x\n",
                 pExPtrs->ContextRecord->Eax,
                 pExPtrs->ContextRecord->Ebx,
                 pExPtrs->ContextRecord->Ecx,
                 pExPtrs->ContextRecord->Edx,
                 pExPtrs->ContextRecord->Esi,
                 pExPtrs->ContextRecord->Edi,
                 pExPtrs->ContextRecord->Eip,
                 pExPtrs->ContextRecord->Esp,
                 pExPtrs->ContextRecord->Ebp,
                 ((pExPtrs->ContextRecord->EFlags & 0x00003000) >> 12),
                 MapX86ProcessorFlags(pExPtrs->ContextRecord->EFlags),
                 pExPtrs->ContextRecord->SegCs,
                 pExPtrs->ContextRecord->SegSs,
                 pExPtrs->ContextRecord->SegDs,
                 pExPtrs->ContextRecord->SegEs,
                 pExPtrs->ContextRecord->SegFs,
                 pExPtrs->ContextRecord->SegGs,
                 pExPtrs->ContextRecord->EFlags
                 );
        InternetDebugOut(buffer, FALSE);
    }

    //
    // dump out the stack, debug style
    //

    LPBYTE Address = (LPBYTE)pExPtrs->ContextRecord->Esp;

    rsprintf(buffer,
             "\n"
             "256 bytes of process stack at %04x:%08x:\n\n",
             pExPtrs->ContextRecord->SegSs,
             Address
             );
    InternetDebugOut(buffer, FALSE);

    for (DWORD Size = 256; Size; ) {

        DWORD nDumped = InternetDebugDumpFormat(Address, 16, sizeof(DWORD), buffer);

        InternetDebugOut(buffer, FALSE);
        Size -= nDumped;
        Address += nDumped;
    }

    //
    // dump call stack
    //

    LPVOID backtrace[16];

    memset(&backtrace, 0, sizeof(backtrace));

    x86SleazeCallStack((LPVOID *)backtrace,
                       ARRAY_ELEMENTS(backtrace),
                       (LPVOID *)pExPtrs->ContextRecord->Ebp
                       );

    BOOL ok = FALSE;

    for (int i = 0; i < ARRAY_ELEMENTS(backtrace); ++i) {
        if (backtrace[i] != NULL) {
            ok = TRUE;
            break;
        }
    }
    if (ok) {
        rsprintf(buffer,
                 "\n"
                 "Stack back-trace:\n\n"
                 );
        InternetDebugOut(buffer, FALSE);
        for (int i = 0; i < ARRAY_ELEMENTS(backtrace); ++i) {
            if (backtrace[i] == NULL) {
                break;
            }
            lpszDebugSymbol = GetDebugSymbol((DWORD)backtrace[i], &dwCodeOffset);
            rsprintf(buffer,
                     "%08x %s+%#x\n",
                     backtrace[i],
                     lpszDebugSymbol,
                     dwCodeOffset
                     );
            InternetDebugOut(buffer, FALSE);
        }
    }

#endif // defined(_X86_)

    InternetDebugOut("\r\n********************************************************************************\r\n\r\n", FALSE);

    InternetFlushDebugFile();

#if defined(_X86_)

    if (disposition == EXCEPTION_CONTINUE_EXECUTION) {
        pExPtrs->ContextRecord->Eip += eipOffset;
    }

#endif // defined(_X86_)

    return disposition;
}

#if defined(_X86_)


PRIVATE
LPSTR
MapX86ProcessorFlags(
    IN DWORD Flags
    )
{
    //
    // BUGBUG - not re-entrant
    //

    static char buf[32 * 3 + 1];

    rsprintf(buf,
             "%s %s %s %s %s %s %s %s",
             (Flags & 0x00000800) ? "ov" : "nv",    // Overflow:    Overflow or No-overflow
             (Flags & 0x00000400) ? "dn" : "up",    // Direction:   Up or Down
             (Flags & 0x00000200) ? "ei" : "di",    // Interrupts:  Enabled or Disabled
             (Flags & 0x00000080) ? "ng" : "pl",    // Sign:        Negative or Positive
             (Flags & 0x00000040) ? "zr" : "nz",    // Zero:        Zero or Not-zero
             (Flags & 0x00000010) ? "ac" : "na",    // Aux-Carry:   Aux-carry or No-aux-carry
             (Flags & 0x00000004) ? "pe" : "po",    // Parity:      Parity-even or Parity-odd
             (Flags & 0x00000001) ? "cy" : "nc"     // Carry:       Carry or No-carry
             );
    return buf;
}

#endif // defined(_X86_)

#endif // INET_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\debug\rprintf.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    rprintf.cxx

Abstract:

    Contains my own version of printf(), sprintf() and vprintf(). Useful since
    adding new printf escape sequences becomes easy

    Contents:
        rprintf     limited re-entrant version of printf
        rsprintf    limited re-entrant version of sprintf
        _sprintf    routine which does the work

Author:

    Richard L Firth (rfirth) 20-Jun-1995

Revision History:

    29-Aug-1989 rfirth
        Created

--*/

#include <wininetp.h>
#include "rprintf.h"

//
// defines for flags word
//

#define F_SPACES        0x00000001  // prefix field with spaces
#define F_ZEROES        0x00000002  // prefix field with zeroes
#define F_MINUS         0x00000004  // field is left justified
#define F_HASH          0x00000008  // hex field is prefixed with 0x/0X
#define F_XUPPER        0x00000010  // hex field has upper case letters
#define F_LONG          0x00000020  // long int/hex/oct prefix
#define F_PLUS          0x00000040  // prefix +'ve signed number with +
#define F_DOT           0x00000080  // separator for field and precision
#define F_NEAR          0x00000100  // far pointer has near prefix
#define F_FAR           0x00000200  // near pointer has far prefix
#define F_SREPLICATE    0x00000400  // this field replicated
#define F_EREPLICATE    0x00000800  // end of replications
#define F_UNICODE       0x00001000  // string is wide character (%ws/%wq)
#define F_QUOTING       0x00002000  // strings enclosed in double quotes
#define F_ELLIPSE       0x00004000  // a sized, quoted string ends in "..."

#define BUFFER_SIZE     1024

//
// minimum field widths for various ASCII representations of numbers
//

#define MIN_BIN_WIDTH   16          // minimum field width in btoa
#define MIN_HEX_WIDTH   8           // minimum field width in xtoa
#define MIN_INT_WIDTH   10          // minimum field width in itoa
#define MIN_LHEX_WIDTH  8           // minimum field width in long xtoa
#define MIN_LINT_WIDTH  10          // minimum field width in long itoa
#define MIN_LOCT_WIDTH  11          // minimum field width in long otoa
#define MIN_OCT_WIDTH   11          // minimum field width in otoa
#define MIN_UINT_WIDTH  10          // minimum field width in utoa

//
// character defines
//

#define EOSTR           '\0'
#define CR              '\x0d'
#define LF              '\x0a'

#if !defined(min)

#define min(a, b)   ((a)<(b)) ? (a) : (b)

#endif

PRIVATE int     _atoi(char**);
PRIVATE void    convert(char**, ULONG_PTR, int, int, unsigned, char(*)(ULONG_PTR*));
PRIVATE char    btoa(ULONG_PTR *);
PRIVATE char    otoa(ULONG_PTR *);
PRIVATE char    utoa(ULONG_PTR *);
PRIVATE char    xtoa(ULONG_PTR *);
PRIVATE char    Xasc(ULONG_PTR *);

/***    rprintf - a re-entrant cut-down version of printf. Understands usual
 *                  printf format characters introduced by '%' plus one or
 *                  two additions
 *
 *      ENTRY   format  - pointer to buffer containing format string defining
 *                        the output. As per usual printf the arguments to
 *                        fill in the blanks in the format string are on the
 *                        the stack after the format string
 *
 *              <args>  - arguments on stack, size and type determined from
 *                        the format string
 *
 *      EXIT    format string used to convert arguments (if any) and print
 *              the results to stdout.
 *              The number of character copied is the value returned
 */

#ifdef UNUSED
int cdecl rprintf(char* format, ...) {

    int charsPrinted = 0;
    char buffer[BUFFER_SIZE];
    DWORD nwritten;
    va_list args;

    /* print the output into  buffer then print the formatted buffer to the
     * screen
     */

    va_start(args, format);
    charsPrinted = _sprintf(buffer, format, args);
    va_end(args);

    WriteConsole(GetStdHandle(STD_OUTPUT_HANDLE),
                              buffer,
                              charsPrinted,
                              &nwritten,
                              0
                              );
    return nwritten;
}
#endif

/***    rsprintf - a re-entrant cut-down version of sprintf. See rprintf for
 *                  details
 *
 *      ENTRY   buffer  - pointer to the buffer which will receive the
 *                        formatted output
 *
 *              format  - pointer to buffer which defines the formatted
 *                        output. Consists of normal printing characters
 *                        and printf-style format characters (see rprintf)
 *
 *      EXIT    characters from format string and arguments converted to
 *              character format based on format string are copied into the
 *              buffer
 *              The number of character copied is the value returned
 */

int cdecl rsprintf(char* buffer, char* format, ...) {

    va_list args;
    int n;

    va_start(args, format);
    n = _sprintf(buffer, format, args);
    va_end(args);
    return n;
}

/***    _sprintf - performs the sprintf function. Receives an extra parameter
 *                  on the stack which is the pointer to the variable argument
 *                  list of rprintf and rsprintf
 *
 *      ENTRY   buffer  - pointer to buffer which will receive the output
 *
 *              format  - pointer to the format string
 *
 *              args    - variable argument list which will be used to fill in
 *                        the escape sequences in the format string
 *
 *      EXIT    The characters in the format string are used to convert the
 *              arguments and copy them to the buffer.
 *              The number of character copied is the value returned
 */

int cdecl _sprintf(char* buffer, char* format, va_list args) {

    char*       original = buffer;
    int         FieldWidth;
    int         FieldPrecision;
    int         FieldLen;
    BOOL        SubDone;
    int         StrLen;
    int         i;
    DWORD       flags;
    int         replications;

    while (*format) {
        switch ((unsigned)*format) {
        case '\n':

            //
            // convert line-feed to carriage-return, line-feed. But only if the
            // format string doesn't already contain a carriage-return directly
            // before the line-feed! This way we can make multiple calls into
            // this function, with the same buffer, and only once expand the
            // line-feed
            //

            if (*(buffer - 1) != CR) {
                *buffer++ = CR;
            }
            *buffer++ = LF;
            break;

        case '%':
            SubDone = FALSE;
            flags = 0;
            FieldWidth = 0;
            FieldPrecision = 0;
            replications = 1;   /* default replication is 1 */
            while (!SubDone) {
                switch ((unsigned)*++format) {
                case '%':
                    *buffer++ = '%';
                    SubDone = TRUE;
                    break;

                case ' ':
                    flags |= F_SPACES;
                    break;

                case '#':
                    flags |= F_HASH;
                    break;

                case '-':
                    flags |= F_MINUS;
                    break;

                case '+':
                    flags |= F_PLUS;
                    break;

                case '.':
                    flags |= F_DOT;
                    break;

                case '*':
                    if (flags & F_DOT) {
                        FieldPrecision = va_arg(args, int);
                    } else {
                        FieldWidth = va_arg(args, int);
                    }
                    break;

                case '@':
                    replications = _atoi(&format);
                    break;

                case '[':
                    flags |= F_SREPLICATE;
                    break;

                case ']':
                    flags |= F_EREPLICATE;
                    break;

                case '0':
                    /* if this is leading zero then caller wants
                     * zero prefixed number of given width (%04x)
                     */
                    if (!(flags & F_ZEROES)) {
                        flags |= F_ZEROES;
                        break;
                    }

                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    if (flags & F_DOT) {
                        FieldPrecision = _atoi(&format);
                    } else {
                        FieldWidth = _atoi(&format);
                    }
                    break;

                case 'b':

                    //
                    // Binary representation
                    //

                    while (replications--) {
                        convert(&buffer,
                                va_arg(args, unsigned int),
                                (FieldWidth) ? FieldWidth : MIN_BIN_WIDTH,
                                MIN_BIN_WIDTH,
                                flags,
                                btoa
                                );
                    }
                    SubDone = TRUE;
                    break;

                case 'B':

                    //
                    // Boolean representation
                    //

                    if (va_arg(args, BOOL)) {
                        *buffer++ = 'T';
                        *buffer++ = 'R';
                        *buffer++ = 'U';
                        *buffer++ = 'E';
                    } else {
                        *buffer++ = 'F';
                        *buffer++ = 'A';
                        *buffer++ = 'L';
                        *buffer++ = 'S';
                        *buffer++ = 'E';
                    }
                    SubDone = TRUE;
                    break;

                case 'c':

                    //
                    // assume that a character is the size of the
                    // width of the stack which in turn has the same
                    // width as an integer
                    //

                    --FieldWidth;
                    while (replications--) {
                        for (i = 0; i < FieldWidth; i++) {
                            *buffer++ = ' ';
                        }
                        *buffer++ = (char) va_arg(args, int);
                    }
                    SubDone = TRUE;
                    break;

                case 'd':
                case 'i':
                    while (replications--) {

                        long l;

                        l = (flags & F_LONG) ? va_arg(args, long) : (long)va_arg(args, int);
                        if (l < 0) {
                            *buffer++ = '-';
                            if (flags & F_LONG) {
                                l = -(long)l;
                            } else {
                                l = -(int)l;
                            }
                        } else if (flags & F_PLUS) {
                            *buffer++ = '+';
                        }
                        convert(&buffer,
                                l,
                                FieldWidth,
                                (flags & F_LONG) ? MIN_LINT_WIDTH : MIN_INT_WIDTH,
                                flags,
                                utoa
                                );
                    }
                    SubDone = TRUE;
                    break;

                case 'e':
                    /* not currently handled */
                    break;

                case 'f':
                    /* not currently handled */
                    break;

                case 'F':
                    flags |= F_FAR;
                    break;

                case 'g':
                case 'G':
                    /* not currently handled */
                    break;

                case 'h':
                    /* not currently handled */
                    break;

                case 'l':
                    flags |= F_LONG;
                    break;

                case 'L':
                    /* not currently handled */
                    break;

                case 'n':
                    *(va_arg(args, int*))  = (int)(buffer - original);
                    SubDone = TRUE;
                    break;

                case 'N':
                    flags |= F_NEAR;
                    break;

                case 'o':
                    while (replications--) {
                        convert(&buffer,
                                (flags & F_LONG) ? va_arg(args, unsigned long) : (unsigned long)va_arg(args, unsigned),
                                FieldWidth,
                                (flags & F_LONG) ? MIN_LOCT_WIDTH : MIN_OCT_WIDTH,
                                flags,
                                otoa
                                );
                    }
                    SubDone = TRUE;
                    break;

                case 'p':
                    while (replications--) {

                        void* p;

                        if (!(flags & F_NEAR)) {
                            convert(&buffer,
                                    (ULONG_PTR) va_arg(args, char near *),
                                    MIN_HEX_WIDTH,
                                    MIN_HEX_WIDTH,
                                    flags | F_XUPPER,
                                    Xasc
                                    );
                            *buffer++ = ':';
                        }
                        convert(&buffer,
                                (ULONG_PTR)va_arg(args, unsigned),
                                MIN_HEX_WIDTH,
                                MIN_HEX_WIDTH,
                                flags | F_XUPPER,
                                Xasc
                                );
                    }
                    SubDone = TRUE;
                    break;

                case 'Q':       // quoted unicode string
                    flags |= F_UNICODE;
                    // *** FALL THROUGH ***

                case 'q':
                    *buffer++ = '"';
                    flags |= F_QUOTING;

                    //
                    // *** FALL THROUGH ***
                    //

                case 's':
                    while (replications--) {

                        char* s;

                        s = va_arg(args, char*);
                        if (s != NULL) {
                            // darrenmi 2/24/00 Note that if the string has a field precision,
                            // it's not always null terminated!! Don't depend on it being psz
                            // and stop when we hit our max length.
                            StrLen = 0;

                            if (flags & F_UNICODE) {
                                WCHAR   *pWork = (LPWSTR)s;
                                while((!FieldPrecision || StrLen < FieldPrecision) && *pWork)
                                {
                                    pWork++;
                                    StrLen++;
                                }
                            } else {
                                CHAR    *pWork = s;
                                while((!FieldPrecision || StrLen < FieldPrecision) && *pWork)
                                {
                                    pWork++;
                                    StrLen++;
                                }
                            }
                            
                            FieldLen = (FieldPrecision)
                                        ? min(StrLen, FieldPrecision)
                                        : StrLen
                                        ;
                            if ((flags & F_QUOTING) && (FieldPrecision > 3) && (FieldLen < StrLen)) {
                                FieldLen -= 3;
                                flags |= F_ELLIPSE;
                            }

                            for (i = 0; i < (FieldWidth - FieldLen); i++) {
                                *buffer++ = ' ';
                            }

                            if (flags & F_UNICODE) {

                                char wbuf[4096];
                                int wi;

                                WideCharToMultiByte(CP_ACP, 0,
                                        (LPWSTR)s, -1,
                                        wbuf, 4096,
                                        NULL, NULL);

                                for (wi = 0; wbuf[wi] && FieldLen; ++wi) {
                                    *buffer = wbuf[wi];

                                    //
                                    // if this is a quoted string, and it contains
                                    // \r and/or \n, then we reverse-convert these
                                    // characters, since we don't want then to
                                    // break the string. Do the same for \t
                                    //

                                    if (flags & F_QUOTING) {

                                        char ch;

                                        ch = *buffer;
                                        if ((ch == '\r') || (ch == '\n') || (ch == '\t')) {
                                            *buffer++ = '\\';
                                            *buffer = (ch == '\r')
                                                        ? 'r'
                                                        : (ch == '\n')
                                                            ? 'n'
                                                            : 't'
                                                            ;
                                        }
                                    }
                                    ++buffer;
                                    --FieldLen;
                                }
                            } else {
                                while (*s && FieldLen) {
                                    *buffer = *s++;

                                    //
                                    // if this is a quoted string, and it contains
                                    // \r and/or \n, then we reverse-convert these
                                    // characters, since we don't want then to
                                    // break the string. Do the same for \t
                                    //

                                    if (flags & F_QUOTING) {

                                        char ch;

                                        ch = *buffer;
                                        if ((ch == '\r') || (ch == '\n') || (ch == '\t')) {
                                            *buffer++ = '\\';
                                            *buffer = (ch == '\r')
                                                        ? 'r'
                                                        : (ch == '\n')
                                                            ? 'n'
                                                            : 't'
                                                            ;
                                        }
                                    }
                                    ++buffer;
                                    --FieldLen;
                                }
                            }
                            if (flags & F_ELLIPSE) {
                                *buffer++ = '.';
                                *buffer++ = '.';
                                *buffer++ = '.';
                            }
                        } else if (!(flags & F_QUOTING)) {
                            *buffer++ = '(';
                            *buffer++ = 'n';
                            *buffer++ = 'u';
                            *buffer++ = 'l';
                            *buffer++ = 'l';
                            *buffer++ = ')';
                        }
                    }
                    if (flags & F_QUOTING) {
                        *buffer++ = '"';
                    }
                    SubDone = TRUE;
                    break;

                case 'S':
                    break;

                case 'u':
                    while (replications--) {
                        convert(&buffer,
                                va_arg(args, unsigned),
                                FieldWidth,
                                MIN_UINT_WIDTH,
                                flags,
                                utoa
                                );
                    }
                    SubDone = TRUE;
                    break;

                case 'w':
                    flags |= F_UNICODE;
                    break;

                case 'X':
                    flags |= F_XUPPER;

                    //
                    // *** FALL THROUGH ***
                    //

                case 'x':
                    while (replications--) {
                        if (flags & F_HASH) {
                            *buffer++ = '0';
                            *buffer++ = (flags & F_XUPPER) ? (char)'X' : (char)'x';
                        }
                        convert(&buffer,
                                (flags & F_LONG) ? va_arg(args, unsigned long) : va_arg(args, unsigned),
                                FieldWidth,
                                (flags & F_LONG) ? MIN_LHEX_WIDTH : MIN_HEX_WIDTH,
                                flags,
                                (flags & F_XUPPER) ? Xasc : xtoa
                                );
                    }
                    SubDone = TRUE;
                    break;
                } /* switch <%-specifier> */
            }
            break;

        default:
            *buffer++ = *format;
        } /* switch <character> */
        ++format;
    } /* while */
    *buffer = EOSTR;
    return (int)(buffer - original);
}

/***    _atoi - ascii to integer conversion used to get the field width out
 *              of the format string
 *
 *      ENTRY   p - pointer to pointer to format string
 *
 *      EXIT    returns the number found in the prefix string as a (16-bit)
 *              int format string pointer is updated past the field width
 */

PRIVATE
int _atoi(char** p) {

    int n = 0;
    int i = 5;

    while ((**p >= '0' && **p <= '9') && i--) {
        n = n*10+((int)(*(*p)++)-(int)'0');
    }

    /* put the format pointer back one since the major loop tests *++format */

    --*p;
    return n;
}

/***    convert - convert number to representation defined by procedure
 *
 *      ENTRY   buffer  - pointer to buffer to receive conversion
 *              n       - number to convert
 *              width   - user defined field width
 *              mwidth  - minimum width for representation
 *              flags   - flags controlling conversion
 *              proc    - pointer to conversion routine
 *
 *      EXIT    buffer is updated to point past the number representation
 *              just put into it
 */

PRIVATE
void
convert(
    char** buffer,
    ULONG_PTR n,
    int width,
    int mwidth,
    unsigned flags,
    char (*proc)(ULONG_PTR*)
    )
{
    char    numarray[33];
    int     MinWidth;
    int     i;

    MinWidth = (width < mwidth) ? mwidth : width;
    i = MinWidth;
    do {
        numarray[--i] = (*proc)(&n);
    } while (n);
    while (width > MinWidth-i) {
        numarray[--i] = (char)((flags & F_SPACES) ? ' ' : '0');
    }
    while (i < MinWidth) {
        *(*buffer)++ = numarray[i++];
    }
}

/***    btoa - return next (least significant) char in a binary to ASCII
 *              conversion
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char btoa(ULONG_PTR *pn) {

    char    rch;

    rch = (char)(*pn&1)+'0';
    *pn >>= 1;
    return rch;
}

/***    otoa - return next (least significant) char in an octal to ASCII
 *              conversion
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char otoa(ULONG_PTR *pn) {

    char    rch;

    rch = (char)'0'+(char)(*pn&7);
    *pn >>= 3;
    return rch;
}

/***    utoa - return next (least significant) char in an unsigned int to
 *              ASCII conversion
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char utoa(ULONG_PTR *pn) {

    char    rch;

    rch = (char)'0'+(char)(*pn%10);
    *pn /= 10;
    return rch;
}

/***    xtoa - return next (least significant) char in a hexadecimal to
 *              ASCII conversion. Returns lower case hex characters
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char xtoa(ULONG_PTR *pn) {

    ULONG_PTR   n = *pn & 0x000f;
    char        rch = (n <= 9) /* decimal digit? */
                      ? (char)n+'0'
                      : (char)n+'0'+('a'-'9'-1);

    *pn >>= 4;
    return rch;
}

/***    Xasc - return next (least significant) char in a hexadecimal to
 *              ASCII conversion. Returns upper case hex characters
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char Xasc(ULONG_PTR *pn) {

    ULONG_PTR   n = *pn & 0x000f;
    char        rch = (n <= 9) /* decimal digit? */
                        ? (char)n+'0'
                        : (char)n+'0'+('A'-'9'-1);

    *pn >>= 4;
    return rch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\debug\rprintf.h ===
/*****************************************************************************
 *
 *  RPRINTF.C   RLF 06/15/89
 *
 *  CONTENTS    rprintf     limited re-entrant version of printf
 *              rsprintf    limited re-entrant version of sprintf
 *              _sprintf    routine which does the work
 *
 *  NOTES       Tab Stops = 4
 *
 *  $Log:   T:/pvcs/h/rprintf.h_v  $
 *
 *    Rev 1.1   29 Oct 1989 11:50:16   Richard Firth
 * Added defines for PRINTF and SPRINTF to allow easy modification when MS gets
 * the real thing working for multi-threaded programs
 *
 *    Rev 1.0   29 Aug 1989 20:04:40   RICHARDF
 * Initial revision.
 *
 ****************************************************************************/

#ifdef UNUSED
// UNUSED - causes unneed crt bloat
int cdecl rprintf(char*, ...);
#endif
int cdecl rsprintf(char*, char*, ...);
int cdecl _sprintf(char*, char*, va_list);

#define SPRINTF rsprintf
#define PRINTF  rprintf

//#define rsprintf wsprintf
//#define _sprintf wsprintf

#define RPRINTF_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\debug\inetdbg.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    inetdbg.cxx

Abstract:

    Debugging functions for internet DLL

    Contents:
        InternetDebugInitialize
        InternetDebugTerminate
        InternetGetDebugInfo
        InternetSetDebugInfo
        InternetOpenDebugFile
        InternetReopenDebugFile
        InternetCloseDebugFile
        InternetFlushDebugFile
        InternetDebugSetControlFlags
        InternetDebugResetControlFlags
        InternetDebugEnter
        InternetDebugLeave
        InternetDebugError
        InternetDebugPrint
        (InternetDebugPrintString)
        InternetDebugPrintf
        InternetDebugOut
        InternetDebugDump
        InternetDebugDumpFormat
        InternetAssert
        InternetGetDebugVariable
        (InternetGetDebugVariableString)
        InternetMapError
        InternetMapStatus
        InternetMapOption
        InternetMapHttpOption
        InternetMapHttpState
        InternetMapHttpStateFlag
        InternetMapAsyncRequest
        InternetMapHandleType
        InternetMapScheme
        InternetMapOpenType
        InternetMapService
        (ExtractFileName)
        (SetDebugPrefix)
        SourceFilename
        InitSymLib
        TermSymLib
        GetDebugSymbol
        x86SleazeCallStack
        x86SleazeCallersAddress

Author:

    Richard L Firth (rfirth) 13-Feb-1995

Environment:

    Win32(s) user-mode DLL

Revision History:

    13-Feb-1995 rfirth
        Created

--*/

#include <wininetp.h>
#include <ntverp.h>

#ifdef WINHTTP_FOR_MSMXL
#include <ieverp.h>
#endif

#include "rprintf.h"
#include <imagehlp.h>

#ifdef ENABLE_DEBUG

//
// private manifests
//

#define SWITCH_VARIABLE_NAME        "WinHttpDebugging"
#define CONTROL_VARIABLE_NAME       "WinHttpControl"
#define CATEGORY_VARIABLE_NAME      "WinHttpCategory"
#define ERROR_VARIABLE_NAME         "WinHttpError"
#define BREAK_VARIABLE_NAME         "WinHttpBreak"
//#define DEFAULT_LOG_VARIABLE_NAME   "WinHttpxLog"
#define CHECK_LIST_VARIABLE_NAME    "WinHttpCheckSerializedList"
#define LOG_FILE_VARIABLE_NAME      "WinHttpLogFile"
#define INDENT_VARIABLE_NAME        "WinHttpLogIndent"

#define DEFAULT_LOG_FILE_NAME       "WINHTTP5.LOG"

#define ENVIRONMENT_VARIABLE_BUFFER_LENGTH  80

#define PRINTF_STACK_BUFFER_LENGTH  (4 K)

//
// private macros
//

#define CASE_OF(constant)   case constant: return # constant

//
// private prototypes
//

PRIVATE
VOID
InternetDebugPrintString(
    IN LPSTR String
    );

PRIVATE
VOID
InternetGetDebugVariableString(
    IN LPSTR lpszVariableName,
    OUT LPSTR lpszVariable,
    IN DWORD dwVariableLen
    );

PRIVATE
LPSTR
ExtractFileName(
    IN LPSTR Module,
    OUT LPSTR Buf
    );

PRIVATE
LPSTR
SetDebugPrefix(
    IN LPSTR Buffer
    );
//
//
// these variables are employed in macros, so must be public
//

PUBLIC DWORD InternetDebugErrorLevel = DBG_ERROR;
PUBLIC DWORD InternetDebugControlFlags = DBG_NO_DEBUG;
PUBLIC DWORD InternetDebugCategoryFlags = 0;
PUBLIC DWORD InternetDebugBreakFlags = 0;

//
// these variables are only accessed in this module, so can be private
//

PRIVATE int InternetDebugIndentIncrement = 2;
PRIVATE HANDLE InternetDebugFileHandle = INVALID_HANDLE_VALUE;
PRIVATE char InternetDebugFilename[MAX_PATH + 1] = DEFAULT_LOG_FILE_NAME;
PRIVATE BOOL InternetDebugEnabled = TRUE;
PRIVATE DWORD InternetDebugStartTime = 0;

extern "C" {
BOOL UrlcacheDebugEnabled = FALSE;
#if defined(UNIX) && defined(ux10)
/* Temporary fix for Apogee Compiler bug on HP only */
extern BOOL fCheckEntryOnList;
#else
BOOL fCheckEntryOnList;
#endif /* UNIX */
}

//
// high frequency performance counter globals
//


PRIVATE LONGLONG ftInit;  // initial local time
PRIVATE LONGLONG pcInit;  // initial perf counter
PRIVATE LONGLONG pcFreq;  // perf counter frequency

//
// functions
//


VOID
InternetDebugInitialize(
    VOID
    )

/*++

Routine Description:

    reads environment INETDBG flags and opens debug log file if required

Arguments:

    None.

Return Value:

    None.

--*/

{
#ifndef WININET_SERVER_CORE
    //
    // ensure registry key open (normally done in GlobalDataInitialize() later)
    //

#endif //!WININET_SERVER_CORE
    
    OpenInternetSettingsKey();

    //
    // record the starting tick count for cumulative deltas
    //

    InternetDebugStartTime = GetTickCountWrap();

    if (QueryPerformanceFrequency ((LARGE_INTEGER *) &pcFreq) && pcFreq) {

        QueryPerformanceCounter ((LARGE_INTEGER *) &pcInit);
        SYSTEMTIME st;
        GetLocalTime (&st);
        SystemTimeToFileTime (&st, (FILETIME *) &ftInit);
    }

    //
    // check see if there are any debug variable overrides in the environment
    // or the registry. If "WinHttpLog=<!0>" is set then we use the flags that
    // are most commonly used to generate WININET.LOG, with no console or
    // debugger output. We allow the other variables to be overridden
    //

    char WinHttpVer[16] = {0};
    BOOL defaultDebugVariables = FALSE;
    rsprintf(WinHttpVer, 
            "WinHttp%dLog", 
            InternetVersionInfo.dwMajorVersion);


    InternetGetDebugVariable(WinHttpVer, (LPDWORD)&defaultDebugVariables);
    if (!defaultDebugVariables)
    {
        InternetGetDebugVariable(SWITCH_VARIABLE_NAME, (LPDWORD)&defaultDebugVariables);
    }

    if (defaultDebugVariables) {
        InternetDebugEnabled = TRUE;
        InternetDebugControlFlags = INTERNET_DEBUG_CONTROL_DEFAULT;
        InternetDebugCategoryFlags = INTERNET_DEBUG_CATEGORY_DEFAULT;
        InternetDebugErrorLevel = INTERNET_DEBUG_ERROR_LEVEL_DEFAULT;
        InternetDebugBreakFlags = 0;
    }
    
    // InternetGetDebugVariable(SWITCH_VARIABLE_NAME, (LPDWORD)&InternetDebugEnabled);
    InternetGetDebugVariable(CONTROL_VARIABLE_NAME, &InternetDebugControlFlags);
    InternetGetDebugVariable(CATEGORY_VARIABLE_NAME, &InternetDebugCategoryFlags);
    InternetGetDebugVariable(ERROR_VARIABLE_NAME, &InternetDebugErrorLevel);
    InternetGetDebugVariable(BREAK_VARIABLE_NAME, &InternetDebugBreakFlags);
    InternetGetDebugVariable(CHECK_LIST_VARIABLE_NAME, (LPDWORD)&fCheckEntryOnList);
    InternetGetDebugVariable(INDENT_VARIABLE_NAME, (LPDWORD)&InternetDebugIndentIncrement);
    InternetGetDebugVariableString(LOG_FILE_VARIABLE_NAME,
                                   InternetDebugFilename,
                                   sizeof(InternetDebugFilename)
                                   );

    UrlcacheDebugEnabled = InternetDebugEnabled &&
        (InternetDebugCategoryFlags & DBG_CACHE);

    if ((InternetDebugIndentIncrement < 0) || (InternetDebugIndentIncrement > 32)) {
        InternetDebugIndentIncrement = 2;
    }

    //
    // quit now if debugging is disabled
    //

    if (!InternetDebugEnabled) {
        InternetDebugControlFlags |= (DBG_NO_DEBUG | DBG_NO_DATA_DUMP);
        return;
    }

    //
    // if we want to write debug output to file, open WININET.LOG in the current
    // directory. Open it in text mode, for write-only (by this process)
    //

    if (InternetDebugControlFlags & DBG_TO_FILE) {
        if (!InternetReopenDebugFile(InternetDebugFilename)) {
            InternetDebugControlFlags &= ~DBG_TO_FILE;
        }
    }

    //
    // install the debug exception handler
    //

    SetExceptionHandler();
}


VOID
InternetDebugTerminate(
    VOID
    )

/*++

Routine Description:

    Performs any required debug termination

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_TO_FILE) {
        InternetCloseDebugFile();
    }
    InternetDebugControlFlags = DBG_NO_DEBUG;

    CloseInternetSettingsKey();
}

DWORD
InternetGetDebugInfo(
    OUT LPINTERNET_DEBUG_INFO lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns the internal debug variables

Arguments:

    lpBuffer            - pointer to structure that receives the variables

    lpdwBufferLength    - IN: Length of buffer
                          OUT: length of returned data if successful, else
                          required length of buffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS;

        Failure - ERROR_INSUFFICIENT_BUFFER

--*/

{
    DWORD requiredLength;
    DWORD error;
    int filenameLength;

    filenameLength = ((InternetDebugFileHandle != INVALID_HANDLE_VALUE)
                        ? strlen(InternetDebugFilename) : 0) + 1;

    requiredLength = sizeof(*lpBuffer) + filenameLength;
    if ((lpBuffer != NULL) && (*lpdwBufferLength >= requiredLength)) {
        lpBuffer->ErrorLevel = InternetDebugErrorLevel;
        lpBuffer->ControlFlags = InternetDebugControlFlags;
        lpBuffer->CategoryFlags = InternetDebugCategoryFlags;
        lpBuffer->BreakFlags = InternetDebugBreakFlags;
        lpBuffer->IndentIncrement = InternetDebugIndentIncrement;
        if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {
            memcpy(lpBuffer->Filename, InternetDebugFilename, filenameLength);
        } else {
            lpBuffer->Filename[0] = '\0';
        }
        error = ERROR_SUCCESS;
    } else {
        error = ERROR_INSUFFICIENT_BUFFER;
    }
    *lpdwBufferLength = requiredLength;
    return error;
}


DWORD
InternetSetDebugInfo(
    IN LPINTERNET_DEBUG_INFO lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Sets the internal debugging variables to the values in the buffer. To make
    incrmental changes, the caller must first read the variables, change the
    bits they're interested in, then change the whole lot at one go

Arguments:

    lpBuffer        - pointer to structure that contains the variables

    dwBufferLength  - size of lpBuffer. Ignored

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    InternetDebugErrorLevel = lpBuffer->ErrorLevel;
    InternetDebugCategoryFlags = lpBuffer->CategoryFlags;
    InternetDebugControlFlags = lpBuffer->ControlFlags;
    InternetDebugBreakFlags = lpBuffer->BreakFlags;
    InternetDebugIndentIncrement = lpBuffer->IndentIncrement;

    //
    // handle the debug file. If we get an empty string, then (if we are logging
    // to a file), close the file.
    //
    // If the filename is exactly the same as we're already using, then the
    // caller doesn't want to change the log file
    //
    // If the filename is different, then we are being asked to create a new log
    // file: close the old and open the new. If we cannot open the new file then
    // set the filename to the NUL string in the debug buffer
    //

    if (lpBuffer->Filename[0]) {
        if (strcmp(InternetDebugFilename, lpBuffer->Filename) != 0) {
            InternetCloseDebugFile();
            InternetReopenDebugFile(lpBuffer->Filename);
            if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {
                strcpy(InternetDebugFilename, lpBuffer->Filename);
            } else {
                lpBuffer->Filename[0] = '\0';
            }
        }
    } else {
        InternetCloseDebugFile();
    }
    return ERROR_SUCCESS;
}


BOOL
InternetOpenDebugFile(
    VOID
    )

/*++

Routine Description:

    Opens debug filename if not already open. Use InternetDebugFilename

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - file was opened

        FALSE   - file not opened (already open or error)

--*/

{
    if (InternetDebugFileHandle == INVALID_HANDLE_VALUE) {
        InternetDebugFileHandle = CreateFile(
            InternetDebugFilename,
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,  // lpSecurityAttributes
            (InternetDebugControlFlags & DBG_APPEND_FILE)
                ? OPEN_ALWAYS
                : CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL
            | FILE_FLAG_SEQUENTIAL_SCAN
            | ((InternetDebugControlFlags & DBG_FLUSH_OUTPUT)
                ? FILE_FLAG_WRITE_THROUGH
                : 0),
            NULL
            );
        return InternetDebugFileHandle != INVALID_HANDLE_VALUE;
    }
    return FALSE;
}


BOOL
InternetReopenDebugFile(
    IN LPSTR Filename
    )

/*++

Routine Description:

    (Re)opens a debug log file. Closes the current one if it is open

Arguments:

    Filename    - new file to open

Return Value:

    None.

--*/

{
    if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {
        InternetCloseDebugFile();
    }
    if (Filename && *Filename) {
        InternetDebugFileHandle = CreateFile(
            Filename,
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,  // lpSecurityAttributes
            (InternetDebugControlFlags & DBG_APPEND_FILE)
                ? OPEN_ALWAYS
                : CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL
            | FILE_FLAG_SEQUENTIAL_SCAN
            | ((InternetDebugControlFlags & DBG_FLUSH_OUTPUT)
                ? FILE_FLAG_WRITE_THROUGH
                : 0),
            NULL
            );

        //
        // put our start info in the log file. Mainly useful when we're
        // appending to the file
        //

        if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {

            SYSTEMTIME currentTime;
            char filespec[MAX_PATH + 1];
            LPSTR filename;

            if (GetModuleFileName(NULL, filespec, sizeof(filespec))) {
                filename = strrchr(filespec, '\\');
                if (filename != NULL) {
                    ++filename;
                } else {
                    filename = filespec;
                }
            } else {
                filename = "";
            }

            InternetDebugGetLocalTime(&currentTime, NULL);

            InternetDebugPrintf("\n"
                                ">>>> WinHttpX Version %d.%d Build %s.%d " __DATE__ " " __TIME__ "\n"
                                ">>>> Process %s [%d (%#x)] started at %02d:%02d:%02d.%03d %02d/%02d/%d\n",
                                InternetVersionInfo.dwMajorVersion,
                                InternetVersionInfo.dwMinorVersion,
#ifdef WINHTTP_FOR_MSXML // fix MSXML build
                                "5.00",
#else
                                VER_PRODUCTVERSION_STRING,
#endif
                                InternetBuildNumber,
                                filename,
                                GetCurrentProcessId(),
                                GetCurrentProcessId(),
                                currentTime.wHour,
                                currentTime.wMinute,
                                currentTime.wSecond,
                                currentTime.wMilliseconds,
                                currentTime.wMonth,
                                currentTime.wDay,
                                currentTime.wYear
                                );

            InternetDebugPrintf(">>>> Command line = %q\n", GetCommandLine());

            InternetDebugPrintf("\n"
                                "     InternetDebugErrorLevel      = %s [%d]\n"
                                "     InternetDebugControlFlags    = %#08x\n"
                                "     InternetDebugCategoryFlags   = %#08x\n"
                                "     InternetDebugBreakFlags      = %#08x\n"
                                "     InternetDebugIndentIncrement = %d\n"
                                "\n",
                                (InternetDebugErrorLevel == DBG_INFO)       ? "Info"
                                : (InternetDebugErrorLevel == DBG_WARNING)  ? "Warning"
                                : (InternetDebugErrorLevel == DBG_ERROR)    ? "Error"
                                : (InternetDebugErrorLevel == DBG_FATAL)    ? "Fatal"
                                : (InternetDebugErrorLevel == DBG_ALWAYS)   ? "Always"
                                : "?",
                                InternetDebugErrorLevel,
                                InternetDebugControlFlags,
                                InternetDebugCategoryFlags,
                                InternetDebugBreakFlags,
                                InternetDebugIndentIncrement
                                );
            return TRUE;
        }
    }
    return FALSE;
}


VOID
InternetCloseDebugFile(
    VOID
    )

/*++

Routine Description:

    Closes the current debug log file

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {
        if (InternetDebugControlFlags & DBG_FLUSH_OUTPUT) {
            InternetFlushDebugFile();
        }
        CloseHandle(InternetDebugFileHandle);
        InternetDebugFileHandle = INVALID_HANDLE_VALUE;
    }
}


VOID
InternetFlushDebugFile(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {
        FlushFileBuffers(InternetDebugFileHandle);
    }
}


VOID
InternetDebugSetControlFlags(
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Sets debug control flags

Arguments:

    dwFlags - flags to set

Return Value:

    None.

--*/

{
    InternetDebugControlFlags |= dwFlags;
}


VOID
InternetDebugResetControlFlags(
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Resets debug control flags

Arguments:

    dwFlags - flags to reset

Return Value:

    None.

--*/

{
    InternetDebugControlFlags &= ~dwFlags;
}


VOID
InternetDebugEnter(
    IN DWORD Category,
    IN DEBUG_FUNCTION_RETURN_TYPE ReturnType,
    IN LPCSTR Function,
    IN LPCSTR ParameterList OPTIONAL,
    IN ...
    )

/*++

Routine Description:

    Creates an INTERNET_DEBUG_RECORD for the current function and adds it to
    the per-thread (debug) call-tree

Arguments:

    Category        - category flags, e.g. DBG_FTP

    ReturnType      - type of data it returns

    Function        - name of the function. Must be global, static string

    ParameterList   - string describing parameters to function, or NULL if none

    ...             - parameters to function

Return Value:

    None.

--*/

{
    LPINTERNET_THREAD_INFO pThreadInfo;
    LPINTERNET_DEBUG_RECORD pRecord;

    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    pThreadInfo = InternetGetThreadInfo();

    //INET_ASSERT(pThreadInfo != NULL);

    if (!pThreadInfo) {
        return;
    }

    pRecord = NEW(INTERNET_DEBUG_RECORD);

    //INET_ASSERT(pRecord != NULL);

    if (!pRecord) {
        return;
    }

    pRecord->Stack = pThreadInfo->Stack;
    pRecord->Category = Category;
    pRecord->ReturnType = ReturnType;
    pRecord->Function = Function;
    pRecord->LastTime = GetTickCountWrap();
    pThreadInfo->Stack = pRecord;
    ++pThreadInfo->CallDepth;

    //
    // if the function's category (FTP, GOPHER, HTTP) is selected in the
    // category flags, then we dump the function entry information
    //

    if (InternetDebugCategoryFlags & Category) {

        char buf[4096];
        LPSTR bufptr;

        bufptr = buf;
        bufptr += rsprintf(bufptr, "%s(", Function);
        if (ARGUMENT_PRESENT(ParameterList)) {

            va_list parms;

            va_start(parms, ParameterList);
            bufptr += _sprintf(bufptr, (char*)ParameterList, parms);
            va_end(parms);
        }
        rsprintf(bufptr, ")\n");
        InternetDebugPrintString(buf);

        //
        // only increase the indentation if we will display debug information
        // for this category
        //

        pThreadInfo->IndentIncrement += InternetDebugIndentIncrement;
    }
}


VOID
InternetDebugLeave(
    IN DWORD_PTR Variable,
    IN LPCSTR Filename,
    IN DWORD LineNumber
    )

/*++

Routine Description:

    Destroys the INTERNET_DEBUG_RECORD for the current function and dumps info
    about what the function is returning, if requested to do so

Arguments:

    Variable    - variable containing value being returned by function

    Filename    - name of file where DEBUG_LEAVE() invoked

    LineNumber  - and line number in Filename

Return Value:

    None.

--*/

{
    LPINTERNET_THREAD_INFO pThreadInfo;
    LPINTERNET_DEBUG_RECORD pRecord;
    LPSTR format;
    LPSTR errstr;
    BOOL noVar;
    char formatBuf[128];
    DWORD lastError;
    char hexnumBuf[15];

    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    //
    // seems that something in this path can nuke the last error, so we must
    // refresh it
    //

    lastError = GetLastError();

    pThreadInfo = InternetGetThreadInfo();

    //INET_ASSERT(pThreadInfo != NULL);

    if (!pThreadInfo) {
        return;
    }

    pRecord = pThreadInfo->Stack;

    //INET_ASSERT(pRecord != NULL);

    if (!pRecord) {
        return;
    }

    //
    // we are about to output a diagnostic message to the debug log, debugger,
    // or console. First check that we are required to display messages at
    // this level. The level for function ENTER and LEAVE is INFO
    //

    if (InternetDebugErrorLevel <= DBG_INFO) {

        //
        // only display the string and reduce the indent if we are requested
        // for information about this category
        //

        errstr = NULL;
        noVar = FALSE;
        if (InternetDebugCategoryFlags & pRecord->Category) {
            switch (pRecord->ReturnType) {
            case None:
                format = "%s() returning VOID";
                noVar = TRUE;
                break;

            case Bool:
                Variable = (DWORD_PTR)(Variable ? "TRUE" : "FALSE");

                //
                // *** FALL THROUGH ***
                //

            case String:
                format = "%s() returning %s";
                break;

            case Int:
                format = "%s() returning %d";
                break;

            case Dword:
                format = "%s() returning %u";
                errstr = InternetMapError((DWORD)Variable);
                if (errstr != NULL) {
                    if (*errstr == '?') {
                        rsprintf(hexnumBuf, "%#x", Variable);
                        errstr = hexnumBuf;
                        format = "%s() returning %u [?] (%s)";
                    } else {
                        format = "%s() returning %u [%s]";
                    }
                }
                break;

            case Handle:
            case Pointer:
                if (Variable == 0) {
                    format = "%s() returning NULL";
                    noVar = TRUE;
                } else {
                    if (pRecord->ReturnType == Handle) {
                        format = "%s() returning handle %#x";
                    } else {
                        format = "%s() returning %#x";
                    }
                }
                break;

            default:

                INET_ASSERT(FALSE);

                break;
            }

            pThreadInfo->IndentIncrement -= InternetDebugIndentIncrement;
            if (pThreadInfo->IndentIncrement < 0) {
                pThreadInfo->IndentIncrement = 0;
            }

            //
            // add line number info, if requested
            //

            strcpy(formatBuf, format);
            if (!(InternetDebugControlFlags & DBG_NO_LINE_NUMBER)) {
                strcat(formatBuf, " (line %d)");
            }
            strcat(formatBuf, "\n");

            //
            // output an empty line if we are required to separate API calls in
            // the log. Only do this if this is an API level function, and it
            // is the top-level function
            //

            if ((InternetDebugControlFlags & DBG_SEPARATE_APIS)
            && (pRecord->Stack == NULL)) {
                strcat(formatBuf, "\n");
            }

            //
            // dump the line, depending on requirements and number of arguments
            //

            if (noVar) {
                InternetDebugPrint(formatBuf,
                                   pRecord->Function,
                                   LineNumber
                                   );
            } else if (errstr != NULL) {
                InternetDebugPrint(formatBuf,
                                   pRecord->Function,
                                   Variable,
                                   errstr,
                                   LineNumber
                                   );
            } else {
                InternetDebugPrint(formatBuf,
                                   pRecord->Function,
                                   Variable,
                                   LineNumber
                                   );
            }
/*
            //
            // output an empty line if we are required to separate API calls in
            // the log. Only do this if this is an API level function, and it
            // is the top-level function
            //

            if ((InternetDebugControlFlags & DBG_SEPARATE_APIS)
            && (pRecord->Stack == NULL)) {

                //
                // don't call InternetDebugPrint - we don't need timing, thread,
                // level etc. information just for the separator
                //

                InternetDebugOut("\n", FALSE);
            }
*/
        }
    }

    //
    // regardless of whether we are outputting debug info for this category,
    // remove the debug record and reduce the call-depth
    //

    --pThreadInfo->CallDepth;
    pThreadInfo->Stack = pRecord->Stack;

    DEL(pRecord);

    //
    // refresh the last error, in case it was nuked
    //

    SetLastError(lastError);
}


VOID
InternetDebugError(
    IN DWORD Error
    )

/*++

Routine Description:

    Used to display that a function is returning an error. We try to display a
    symbolic name for the error too (as when we are returning a DWORD from a
    function, using DEBUG_LEAVE)

    Displays a string of the form:

        Foo() returning error 87 [ERROR_INVALID_PARAMETER]

Arguments:

    Error   - the error code

Return Value:

    None.

--*/

{
    LPINTERNET_THREAD_INFO pThreadInfo;
    LPINTERNET_DEBUG_RECORD pRecord;
    LPSTR errstr;
    DWORD lastError;
    char hexnumBuf[15];

    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    //
    // seems that something in this path can nuke the last error, so we must
    // refresh it
    //

    lastError = GetLastError();

    pThreadInfo = InternetGetThreadInfo();

    //INET_ASSERT(pThreadInfo != NULL);
    INET_ASSERT(GetLastError() == lastError);

    if (pThreadInfo == NULL) {
        return;
    }

    pRecord = pThreadInfo->Stack;

    //INET_ASSERT(pRecord != NULL);

    if (pRecord == NULL) {
        return;
    }

    errstr = InternetMapError(Error);
    if ((errstr == NULL) || (*errstr == '?')) {
        rsprintf(hexnumBuf, "%#x", Error);
        errstr = hexnumBuf;
    }
    InternetDebugPrint("%s() returning %d [%s]\n",
                       pRecord->Function,
                       Error,
                       errstr
                       );

    //
    // refresh the last error, in case it was nuked
    //

    SetLastError(lastError);
}


VOID
InternetDebugPrint(
    IN LPSTR Format,
    ...
    )

/*++

Routine Description:

    Internet equivalent of printf()

Arguments:

    Format  - printf format string

    ...     - any extra args

Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    char buf[PRINTF_STACK_BUFFER_LENGTH];
    LPSTR bufptr;

    bufptr = SetDebugPrefix(buf);
    if (bufptr == NULL) {
        return;
    }

    //
    // now append the string that the DEBUG_PRINT originally gave us
    //

    va_list list;

    va_start(list, Format);
    _sprintf(bufptr, Format, list);
    va_end(list);

    InternetDebugOut(buf, FALSE);
}


VOID
InternetDebugPrintValist(
    IN LPSTR Format,
    va_list list
    )

/*++

Routine Description:

    Internet equivalent of printf(), but takes valist as the args

Arguments:

    Format  - printf format string

    list    - stack frame of variable arguments

Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    char buf[PRINTF_STACK_BUFFER_LENGTH];
    LPSTR bufptr;

    bufptr = SetDebugPrefix(buf);
    if (bufptr == NULL) {
        return;
    }

    _sprintf(bufptr, Format, list);

    InternetDebugOut(buf, FALSE);
}


PRIVATE
VOID
InternetDebugPrintString(
    IN LPSTR String
    )

/*++

Routine Description:

    Same as InternetDebugPrint(), except we perform no expansion on the string

Arguments:

    String  - already formatted string (may contain %s)

Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    char buf[PRINTF_STACK_BUFFER_LENGTH];
    LPSTR bufptr;

    bufptr = SetDebugPrefix(buf);
    if (bufptr == NULL) {
        return;
    }

    //
    // now append the string that the DEBUG_PRINT originally gave us
    //

    strcpy(bufptr, String);

    InternetDebugOut(buf, FALSE);
}


VOID
InternetDebugPrintf(
    IN LPSTR Format,
    IN ...
    )

/*++

Routine Description:

    Same as InternetDebugPrint(), but we don't access the per-thread info
    (because we may not have any)

Arguments:

    Format  - printf format string

    ...     - any extra args


Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    va_list list;
    char buf[PRINTF_STACK_BUFFER_LENGTH];

    va_start(list, Format);
    _sprintf(buf, Format, list);
    va_end(list);

    InternetDebugOut(buf, FALSE);
}


VOID
InternetDebugOut(
    IN LPSTR Buffer,
    IN BOOL Assert
    )

/*++

Routine Description:

    Writes a string somewhere - to the debug log file, to the console, or via
    the debugger, or any combination

Arguments:

    Buffer  - pointer to formatted buffer to write

    Assert  - TRUE if this function is being called from InternetAssert(), in
              which case we *always* write to the debugger. Of course, there
              may be no debugger attached, in which case no action is taken

Return Value:

    None.

--*/

{
    int buflen;
    DWORD written;

    buflen = strlen(Buffer);
    if ((InternetDebugControlFlags & DBG_TO_FILE)
    && (InternetDebugFileHandle != INVALID_HANDLE_VALUE)) {
        WriteFile(InternetDebugFileHandle, Buffer, buflen, &written, NULL);
        if (InternetDebugControlFlags & DBG_FLUSH_OUTPUT) {
            InternetFlushDebugFile();
        }
    }

    if (InternetDebugControlFlags & DBG_TO_CONSOLE) {
        WriteConsole(GetStdHandle(STD_OUTPUT_HANDLE),
                     Buffer,
                     buflen,
                     &written,
                     0
                     );
    }

    if (Assert || (InternetDebugControlFlags & DBG_TO_DEBUGGER)) {
        OutputDebugString(Buffer);
    }
}


VOID
InternetDebugDump(
    IN LPSTR Text,
    IN LPBYTE Address,
    IN DWORD Size
    )

/*++

Routine Description:

    Dumps Size bytes at Address, in the time-honoured debug tradition

Arguments:

    Text    - to display before dumping data

    Address - start of buffer

    Size    - number of bytes

Return Value:

    None.

--*/

{
    //
    // if flags say no data dumps then quit
    //

    if (InternetDebugControlFlags & (DBG_NO_DEBUG | DBG_NO_DATA_DUMP)) {
        return;
    }

    //
    // display the introduction text, if any
    //

    if (Text) {
        if (InternetDebugControlFlags & DBG_INDENT_DUMP) {
            InternetDebugPrint(Text);
        } else {
            InternetDebugOut(Text, FALSE);
        }
    }

    char buf[128];

    //
    // display a line telling us how much data there is, if requested to
    //

    if (InternetDebugControlFlags & DBG_DUMP_LENGTH) {
        rsprintf(buf, "%d (%#x) bytes @ %#x\n", Size, Size, Address);
        if (InternetDebugControlFlags & DBG_INDENT_DUMP) {
            InternetDebugPrintString(buf);
        } else {
            InternetDebugOut(buf, FALSE);
        }
    }

    //
    // dump out the data, debug style
    //

    while (Size) {

        int len = InternetDebugDumpFormat(Address, Size, sizeof(BYTE), buf);

        //
        // if we are to indent the data to the current level, then display the
        // buffer via InternetDebugPrint() which will apply all the thread id,
        // indentation, and other options selected, else just display the data
        // via InternetDebugOut(), which will simply send it to the output media
        //

        if (InternetDebugControlFlags & DBG_INDENT_DUMP) {
            InternetDebugPrintString(buf);
        } else {
            InternetDebugOut(buf, FALSE);
        }

        Address += len;
        Size -= len;
    }
}


DWORD
InternetDebugDumpFormat(
    IN LPBYTE Address,
    IN DWORD Size,
    IN DWORD ElementSize,
    OUT LPSTR Buffer
    )

/*++

Routine Description:

    Formats Size bytes at Address, in the time-honoured debug tradition, for
    data dump purposes

Arguments:

    Address     - start of buffer

    Size        - number of bytes

    ElementSize - size of each word element in bytes

    Buffer      - pointer to output buffer, assumed to be large enough

Return Value:

    DWORD   - number of bytes formatted

--*/

{
    //
    // we (currently) only understand DWORD, WORD and BYTE dumps
    //

    if ((ElementSize != sizeof(DWORD)) && (ElementSize != sizeof(WORD))) {
        ElementSize = sizeof(BYTE);
    }

    static char spaces[] = "                                               ";    // 15 * 3 + 2
    int i, len;

    len = min(Size, 16);
    rsprintf(Buffer, "%08x  ", Address);

    //
    // dump the hex representation of each character or word - up to 16 per line
    //

    DWORD offset = 10;

    for (i = 0; i < len; i += ElementSize) {

        DWORD value;
        LPSTR formatString;

        switch (ElementSize) {
        case 4:
            formatString = "%08x ";
            value = *(LPDWORD)&Address[i];
            break;

        case 2:
            formatString = "%04x ";
            value = *(LPWORD)&Address[i] & 0xffff;
            break;

        default:
            formatString = ((i & 15) == 7) ? "%02.2x-" : "%02.2x ";
            value = Address[i] & 0xff;
            break;
        }
        rsprintf(&Buffer[offset], formatString, value);
        offset += ElementSize * 2 + 1;
    }

    //
    // write as many spaces as required to tab to ASCII field
    //

    memcpy(&Buffer[offset], spaces, (16 - len) * 3 + 2);
    offset += (16 - len) * 3 + 2;

    //
    // dump ASCII representation of each character
    //

    for (i = 0; i < len; ++i) {

        char ch;

        ch = Address[i];
        Buffer[offset + i] =  ((ch < 32) || (ch > 127)) ? '.' : ch;
    }

    Buffer[offset + i++] = '\r';
    Buffer[offset + i++] = '\n';
    Buffer[offset + i] = '\0';

    return len;
}


VOID
InternetAssert(
    IN LPSTR Assertion,
    IN LPSTR FileName,
    IN DWORD LineNumber
    )

/*++

Routine Description:

    displays assertion message at debugger and raised breakpoint exception

Arguments:

    Assertion   - string describing assertion which failed

    FileName    - module where assertion failure occurred

    LineNumber  - at this line number

Return Value:

    None.

--*/

{
    char buffer[512];

    rsprintf(buffer,
             "\n"
             "*** WinHttp Assertion failed: %s\n"
             "*** Source file: %s\n"
             "*** Source line: %d\n"
             "*** Thread %08x\n"
             "\n",
             Assertion,
             FileName,
             LineNumber,
             GetCurrentThreadId()
             );
    InternetDebugOut(buffer, TRUE);

    //
    // break to the debugger, unless it is requested that we don't
    //

    if (!(InternetDebugControlFlags & DBG_NO_ASSERT_BREAK)) {
        DebugBreak();
    }
}


VOID
InternetGetDebugVariable(
    IN LPSTR lpszVariableName,
    OUT LPDWORD lpdwVariable
    )

/*++

Routine Description:

    Get debug variable. First examine environment, then registry

Arguments:

    lpszVariableName    - variable name

    lpdwVariable        - returned variable

Return Value:

    None.

--*/

{
    DWORD len;
    char varbuf[ENVIRONMENT_VARIABLE_BUFFER_LENGTH];

    //
    // get the debug variables first from the environment, then - if not there -
    // from the registry
    //

    len = GetEnvironmentVariable(lpszVariableName, varbuf, sizeof(varbuf));
    if (len && len < sizeof(varbuf)) {
        *lpdwVariable = (DWORD)strtoul(varbuf, NULL, 0);
    } else {
        InternetReadRegistryDword(lpszVariableName, lpdwVariable);
    }
}


PRIVATE
VOID
InternetGetDebugVariableString(
    IN LPSTR lpszVariableName,
    OUT LPSTR lpszVariable,
    IN DWORD dwVariableLen
    )

/*++

Routine Description:

    Get debug variable string. First examine environment, then registry

Arguments:

    lpszVariableName    - variable name

    lpszVariable        - returned string variable

    dwVariableLen       - size of buffer

Return Value:

    None.

--*/

{
    if (GetEnvironmentVariable(lpszVariableName, lpszVariable, dwVariableLen) == 0) {

        char buf[MAX_PATH + 1];
        DWORD len = min(sizeof(buf), dwVariableLen);

        if (InternetReadRegistryString(lpszVariableName, buf, &len) == ERROR_SUCCESS) {
            memcpy(lpszVariable, buf, len + 1);
        }
    }
}

LPSTR
InternetMapChunkToken(
    IN CHUNK_TOKEN_VALUE eToken
    )
{
    switch(eToken)
    {
        CASE_OF(CHUNK_TOKEN_DIGIT);
        CASE_OF(CHUNK_TOKEN_DATA);
        CASE_OF(CHUNK_TOKEN_COLON);
        CASE_OF(CHUNK_TOKEN_CR);
        CASE_OF(CHUNK_TOKEN_LF);

        default:
            return "?";

    }
}

LPSTR
InternetMapChunkState(
    IN CHUNK_DECODE_STATE eState
    )
{
    switch(eState)
    {
        CASE_OF(CHUNK_DECODE_STATE_START);
        CASE_OF(CHUNK_DECODE_STATE_SIZE);
        CASE_OF(CHUNK_DECODE_STATE_SIZE_CRLF);
        CASE_OF(CHUNK_DECODE_STATE_EXT);
        CASE_OF(CHUNK_DECODE_STATE_DATA);
        CASE_OF(CHUNK_DECODE_STATE_DATA_CRLF);
        CASE_OF(CHUNK_DECODE_STATE_FOOTER_NAME);
        CASE_OF(CHUNK_DECODE_STATE_FOOTER_VALUE);
        CASE_OF(CHUNK_DECODE_STATE_FINAL_CRLF);
        CASE_OF(CHUNK_DECODE_STATE_ERROR);

        default:
            return "?";

    }
}


LPSTR
InternetMapError(
    IN DWORD Error
    )

/*++

Routine Description:

    Map error code to string. Try to get all errors that might ever be returned
    by an Internet function

Arguments:

    Error   - code to map

Return Value:

    LPSTR - pointer to symbolic error name

--*/

{
    switch (Error) {

    //
    // WINERROR errors
    //

    CASE_OF(ERROR_SUCCESS);
    CASE_OF(ERROR_INVALID_FUNCTION);
    CASE_OF(ERROR_FILE_NOT_FOUND);
    CASE_OF(ERROR_PATH_NOT_FOUND);
    CASE_OF(ERROR_TOO_MANY_OPEN_FILES);
    CASE_OF(ERROR_ACCESS_DENIED);
    CASE_OF(ERROR_INVALID_HANDLE);
    CASE_OF(ERROR_ARENA_TRASHED);
    CASE_OF(ERROR_NOT_ENOUGH_MEMORY);
    CASE_OF(ERROR_INVALID_BLOCK);
    CASE_OF(ERROR_BAD_ENVIRONMENT);
    CASE_OF(ERROR_BAD_FORMAT);
    CASE_OF(ERROR_INVALID_ACCESS);
    CASE_OF(ERROR_INVALID_DATA);
    CASE_OF(ERROR_OUTOFMEMORY);
    CASE_OF(ERROR_INVALID_DRIVE);
    CASE_OF(ERROR_CURRENT_DIRECTORY);
    CASE_OF(ERROR_NOT_SAME_DEVICE);
    CASE_OF(ERROR_NO_MORE_FILES);
    CASE_OF(ERROR_WRITE_PROTECT);
    CASE_OF(ERROR_BAD_UNIT);
    CASE_OF(ERROR_NOT_READY);
    CASE_OF(ERROR_BAD_COMMAND);
    CASE_OF(ERROR_CRC);
    CASE_OF(ERROR_BAD_LENGTH);
    CASE_OF(ERROR_SEEK);
    CASE_OF(ERROR_NOT_DOS_DISK);
    CASE_OF(ERROR_SECTOR_NOT_FOUND);
    CASE_OF(ERROR_OUT_OF_PAPER);
    CASE_OF(ERROR_WRITE_FAULT);
    CASE_OF(ERROR_READ_FAULT);
    CASE_OF(ERROR_GEN_FAILURE);
    CASE_OF(ERROR_SHARING_VIOLATION);
    CASE_OF(ERROR_LOCK_VIOLATION);
    CASE_OF(ERROR_WRONG_DISK);
    CASE_OF(ERROR_SHARING_BUFFER_EXCEEDED);
    CASE_OF(ERROR_HANDLE_EOF);
    CASE_OF(ERROR_HANDLE_DISK_FULL);
    CASE_OF(ERROR_NOT_SUPPORTED);
    CASE_OF(ERROR_REM_NOT_LIST);
    CASE_OF(ERROR_DUP_NAME);
    CASE_OF(ERROR_BAD_NETPATH);
    CASE_OF(ERROR_NETWORK_BUSY);
    CASE_OF(ERROR_DEV_NOT_EXIST);
    CASE_OF(ERROR_TOO_MANY_CMDS);
    CASE_OF(ERROR_ADAP_HDW_ERR);
    CASE_OF(ERROR_BAD_NET_RESP);
    CASE_OF(ERROR_UNEXP_NET_ERR);
    CASE_OF(ERROR_BAD_REM_ADAP);
    CASE_OF(ERROR_PRINTQ_FULL);
    CASE_OF(ERROR_NO_SPOOL_SPACE);
    CASE_OF(ERROR_PRINT_CANCELLED);
    CASE_OF(ERROR_NETNAME_DELETED);
    CASE_OF(ERROR_NETWORK_ACCESS_DENIED);
    CASE_OF(ERROR_BAD_DEV_TYPE);
    CASE_OF(ERROR_BAD_NET_NAME);
    CASE_OF(ERROR_TOO_MANY_NAMES);
    CASE_OF(ERROR_TOO_MANY_SESS);
    CASE_OF(ERROR_SHARING_PAUSED);
    CASE_OF(ERROR_REQ_NOT_ACCEP);
    CASE_OF(ERROR_REDIR_PAUSED);
    CASE_OF(ERROR_FILE_EXISTS);
    CASE_OF(ERROR_CANNOT_MAKE);
    CASE_OF(ERROR_FAIL_I24);
    CASE_OF(ERROR_OUT_OF_STRUCTURES);
    CASE_OF(ERROR_ALREADY_ASSIGNED);
    CASE_OF(ERROR_INVALID_PASSWORD);
    CASE_OF(ERROR_INVALID_PARAMETER);
    CASE_OF(ERROR_NET_WRITE_FAULT);
    CASE_OF(ERROR_NO_PROC_SLOTS);
    CASE_OF(ERROR_TOO_MANY_SEMAPHORES);
    CASE_OF(ERROR_EXCL_SEM_ALREADY_OWNED);
    CASE_OF(ERROR_SEM_IS_SET);
    CASE_OF(ERROR_TOO_MANY_SEM_REQUESTS);
    CASE_OF(ERROR_INVALID_AT_INTERRUPT_TIME);
    CASE_OF(ERROR_SEM_OWNER_DIED);
    CASE_OF(ERROR_SEM_USER_LIMIT);
    CASE_OF(ERROR_DISK_CHANGE);
    CASE_OF(ERROR_DRIVE_LOCKED);
    CASE_OF(ERROR_BROKEN_PIPE);
    CASE_OF(ERROR_OPEN_FAILED);
    CASE_OF(ERROR_BUFFER_OVERFLOW);
    CASE_OF(ERROR_DISK_FULL);
    CASE_OF(ERROR_NO_MORE_SEARCH_HANDLES);
    CASE_OF(ERROR_INVALID_TARGET_HANDLE);
    CASE_OF(ERROR_INVALID_CATEGORY);
    CASE_OF(ERROR_INVALID_VERIFY_SWITCH);
    CASE_OF(ERROR_BAD_DRIVER_LEVEL);
    CASE_OF(ERROR_CALL_NOT_IMPLEMENTED);
    CASE_OF(ERROR_SEM_TIMEOUT);
    CASE_OF(ERROR_INSUFFICIENT_BUFFER);
    CASE_OF(ERROR_INVALID_NAME);
    CASE_OF(ERROR_INVALID_LEVEL);
    CASE_OF(ERROR_NO_VOLUME_LABEL);
    CASE_OF(ERROR_MOD_NOT_FOUND);
    CASE_OF(ERROR_PROC_NOT_FOUND);
    CASE_OF(ERROR_WAIT_NO_CHILDREN);
    CASE_OF(ERROR_CHILD_NOT_COMPLETE);
    CASE_OF(ERROR_DIRECT_ACCESS_HANDLE);
    CASE_OF(ERROR_NEGATIVE_SEEK);
    CASE_OF(ERROR_SEEK_ON_DEVICE);
    CASE_OF(ERROR_DIR_NOT_ROOT);
    CASE_OF(ERROR_DIR_NOT_EMPTY);
    CASE_OF(ERROR_PATH_BUSY);
    CASE_OF(ERROR_SYSTEM_TRACE);
    CASE_OF(ERROR_INVALID_EVENT_COUNT);
    CASE_OF(ERROR_TOO_MANY_MUXWAITERS);
    CASE_OF(ERROR_INVALID_LIST_FORMAT);
    CASE_OF(ERROR_BAD_ARGUMENTS);
    CASE_OF(ERROR_BAD_PATHNAME);
    CASE_OF(ERROR_BUSY);
    CASE_OF(ERROR_CANCEL_VIOLATION);
    CASE_OF(ERROR_ALREADY_EXISTS);
    CASE_OF(ERROR_FILENAME_EXCED_RANGE);
    CASE_OF(ERROR_LOCKED);
    CASE_OF(ERROR_NESTING_NOT_ALLOWED);
    CASE_OF(ERROR_BAD_PIPE);
    CASE_OF(ERROR_PIPE_BUSY);
    CASE_OF(ERROR_NO_DATA);
    CASE_OF(ERROR_PIPE_NOT_CONNECTED);
    CASE_OF(ERROR_MORE_DATA);
    CASE_OF(ERROR_NO_MORE_ITEMS);
    CASE_OF(ERROR_NOT_OWNER);
    CASE_OF(ERROR_PARTIAL_COPY);
    CASE_OF(ERROR_MR_MID_NOT_FOUND);
    CASE_OF(ERROR_INVALID_ADDRESS);
    CASE_OF(ERROR_PIPE_CONNECTED);
    CASE_OF(ERROR_PIPE_LISTENING);
    CASE_OF(ERROR_OPERATION_ABORTED);
    CASE_OF(ERROR_IO_INCOMPLETE);
    CASE_OF(ERROR_IO_PENDING);
    CASE_OF(ERROR_NOACCESS);
    CASE_OF(ERROR_STACK_OVERFLOW);
    CASE_OF(ERROR_INVALID_FLAGS);
    CASE_OF(ERROR_NO_TOKEN);
    CASE_OF(ERROR_BADDB);
    CASE_OF(ERROR_BADKEY);
    CASE_OF(ERROR_CANTOPEN);
    CASE_OF(ERROR_CANTREAD);
    CASE_OF(ERROR_CANTWRITE);
    CASE_OF(ERROR_REGISTRY_RECOVERED);
    CASE_OF(ERROR_REGISTRY_CORRUPT);
    CASE_OF(ERROR_REGISTRY_IO_FAILED);
    CASE_OF(ERROR_NOT_REGISTRY_FILE);
    CASE_OF(ERROR_KEY_DELETED);
    CASE_OF(ERROR_CIRCULAR_DEPENDENCY);
    CASE_OF(ERROR_SERVICE_NOT_ACTIVE);
    CASE_OF(ERROR_DLL_INIT_FAILED);
    CASE_OF(ERROR_CANCELLED);
    CASE_OF(ERROR_BAD_USERNAME);
    CASE_OF(ERROR_LOGON_FAILURE);

    CASE_OF(WAIT_FAILED);
    //CASE_OF(WAIT_ABANDONED_0);
    CASE_OF(WAIT_TIMEOUT);
    CASE_OF(WAIT_IO_COMPLETION);
    //CASE_OF(STILL_ACTIVE);

    CASE_OF(RPC_S_INVALID_STRING_BINDING);
    CASE_OF(RPC_S_WRONG_KIND_OF_BINDING);
    CASE_OF(RPC_S_INVALID_BINDING);
    CASE_OF(RPC_S_PROTSEQ_NOT_SUPPORTED);
    CASE_OF(RPC_S_INVALID_RPC_PROTSEQ);
    CASE_OF(RPC_S_INVALID_STRING_UUID);
    CASE_OF(RPC_S_INVALID_ENDPOINT_FORMAT);
    CASE_OF(RPC_S_INVALID_NET_ADDR);
    CASE_OF(RPC_S_NO_ENDPOINT_FOUND);
    CASE_OF(RPC_S_INVALID_TIMEOUT);
    CASE_OF(RPC_S_OBJECT_NOT_FOUND);
    CASE_OF(RPC_S_ALREADY_REGISTERED);
    CASE_OF(RPC_S_TYPE_ALREADY_REGISTERED);
    CASE_OF(RPC_S_ALREADY_LISTENING);
    CASE_OF(RPC_S_NO_PROTSEQS_REGISTERED);
    CASE_OF(RPC_S_NOT_LISTENING);
    CASE_OF(RPC_S_UNKNOWN_MGR_TYPE);
    CASE_OF(RPC_S_UNKNOWN_IF);
    CASE_OF(RPC_S_NO_BINDINGS);
    CASE_OF(RPC_S_NO_PROTSEQS);
    CASE_OF(RPC_S_CANT_CREATE_ENDPOINT);
    CASE_OF(RPC_S_OUT_OF_RESOURCES);
    CASE_OF(RPC_S_SERVER_UNAVAILABLE);
    CASE_OF(RPC_S_SERVER_TOO_BUSY);
    CASE_OF(RPC_S_INVALID_NETWORK_OPTIONS);
    CASE_OF(RPC_S_NO_CALL_ACTIVE);
    CASE_OF(RPC_S_CALL_FAILED);
    CASE_OF(RPC_S_CALL_FAILED_DNE);
    CASE_OF(RPC_S_PROTOCOL_ERROR);
    CASE_OF(RPC_S_UNSUPPORTED_TRANS_SYN);
    CASE_OF(RPC_S_UNSUPPORTED_TYPE);
    CASE_OF(RPC_S_INVALID_TAG);
    CASE_OF(RPC_S_INVALID_BOUND);
    CASE_OF(RPC_S_NO_ENTRY_NAME);
    CASE_OF(RPC_S_INVALID_NAME_SYNTAX);
    CASE_OF(RPC_S_UNSUPPORTED_NAME_SYNTAX);
    CASE_OF(RPC_S_UUID_NO_ADDRESS);
    CASE_OF(RPC_S_DUPLICATE_ENDPOINT);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_TYPE);
    CASE_OF(RPC_S_MAX_CALLS_TOO_SMALL);
    CASE_OF(RPC_S_STRING_TOO_LONG);
    CASE_OF(RPC_S_PROTSEQ_NOT_FOUND);
    CASE_OF(RPC_S_PROCNUM_OUT_OF_RANGE);
    CASE_OF(RPC_S_BINDING_HAS_NO_AUTH);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_SERVICE);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_LEVEL);
    CASE_OF(RPC_S_INVALID_AUTH_IDENTITY);
    CASE_OF(RPC_S_UNKNOWN_AUTHZ_SERVICE);
    CASE_OF(EPT_S_INVALID_ENTRY);
    CASE_OF(EPT_S_CANT_PERFORM_OP);
    CASE_OF(EPT_S_NOT_REGISTERED);
    CASE_OF(RPC_S_NOTHING_TO_EXPORT);
    CASE_OF(RPC_S_INCOMPLETE_NAME);
    CASE_OF(RPC_S_INVALID_VERS_OPTION);
    CASE_OF(RPC_S_NO_MORE_MEMBERS);
    CASE_OF(RPC_S_NOT_ALL_OBJS_UNEXPORTED);
    CASE_OF(RPC_S_INTERFACE_NOT_FOUND);
    CASE_OF(RPC_S_ENTRY_ALREADY_EXISTS);
    CASE_OF(RPC_S_ENTRY_NOT_FOUND);
    CASE_OF(RPC_S_NAME_SERVICE_UNAVAILABLE);
    CASE_OF(RPC_S_INVALID_NAF_ID);
    CASE_OF(RPC_S_CANNOT_SUPPORT);
    CASE_OF(RPC_S_NO_CONTEXT_AVAILABLE);
    CASE_OF(RPC_S_INTERNAL_ERROR);
    CASE_OF(RPC_S_ZERO_DIVIDE);
    CASE_OF(RPC_S_ADDRESS_ERROR);
    CASE_OF(RPC_S_FP_DIV_ZERO);
    CASE_OF(RPC_S_FP_UNDERFLOW);
    CASE_OF(RPC_S_FP_OVERFLOW);
    CASE_OF(RPC_X_NO_MORE_ENTRIES);
    CASE_OF(RPC_X_SS_CHAR_TRANS_OPEN_FAIL);
    CASE_OF(RPC_X_SS_CHAR_TRANS_SHORT_FILE);
    CASE_OF(RPC_X_SS_IN_NULL_CONTEXT);
    CASE_OF(RPC_X_SS_CONTEXT_DAMAGED);
    CASE_OF(RPC_X_SS_HANDLES_MISMATCH);
    CASE_OF(RPC_X_SS_CANNOT_GET_CALL_HANDLE);
    CASE_OF(RPC_X_NULL_REF_POINTER);
    CASE_OF(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
    CASE_OF(RPC_X_BYTE_COUNT_TOO_SMALL);
    CASE_OF(RPC_X_BAD_STUB_DATA);


    //
    // WINHTTP errors
    //

    CASE_OF(ERROR_WINHTTP_OUT_OF_HANDLES);
    CASE_OF(ERROR_WINHTTP_TIMEOUT);
    CASE_OF(ERROR_WINHTTP_INTERNAL_ERROR);
    CASE_OF(ERROR_WINHTTP_INVALID_URL);
    CASE_OF(ERROR_WINHTTP_UNRECOGNIZED_SCHEME);
    CASE_OF(ERROR_WINHTTP_NAME_NOT_RESOLVED);
    CASE_OF(ERROR_WINHTTP_INVALID_OPTION);
    CASE_OF(ERROR_WINHTTP_OPTION_NOT_SETTABLE);
    CASE_OF(ERROR_WINHTTP_SHUTDOWN);
    CASE_OF(ERROR_WINHTTP_INCORRECT_PASSWORD);
    CASE_OF(ERROR_WINHTTP_LOGIN_FAILURE);
    CASE_OF(ERROR_WINHTTP_OPERATION_CANCELLED);
    CASE_OF(ERROR_WINHTTP_INCORRECT_HANDLE_TYPE);
    CASE_OF(ERROR_WINHTTP_INCORRECT_HANDLE_STATE);
    CASE_OF(ERROR_WINHTTP_CANNOT_CONNECT);
    CASE_OF(ERROR_WINHTTP_CONNECTION_ERROR);
    CASE_OF(ERROR_WINHTTP_FORCE_RETRY);
    CASE_OF(ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED);
    CASE_OF(ERROR_WINHTTP_NOT_INITIALIZED);
    CASE_OF(ERROR_WINHTTP_SECURE_FAILURE);

    CASE_OF(ERROR_HTTP_HEADER_NOT_FOUND);
    CASE_OF(ERROR_HTTP_INVALID_SERVER_RESPONSE);
    CASE_OF(ERROR_HTTP_INVALID_QUERY_REQUEST);
    CASE_OF(ERROR_HTTP_HEADER_ALREADY_EXISTS);
    CASE_OF(ERROR_HTTP_REDIRECT_FAILED);
    CASE_OF(ERROR_HTTP_NOT_REDIRECTED);

    //
    // SSPI errors
    //

    CASE_OF(SEC_E_INSUFFICIENT_MEMORY);
    CASE_OF(SEC_E_INVALID_HANDLE);
    CASE_OF(SEC_E_UNSUPPORTED_FUNCTION);
    CASE_OF(SEC_E_TARGET_UNKNOWN);
    CASE_OF(SEC_E_INTERNAL_ERROR);
    CASE_OF(SEC_E_SECPKG_NOT_FOUND);
    CASE_OF(SEC_E_NOT_OWNER);
    CASE_OF(SEC_E_CANNOT_INSTALL);
    CASE_OF(SEC_E_INVALID_TOKEN);
    CASE_OF(SEC_E_CANNOT_PACK);
    CASE_OF(SEC_E_QOP_NOT_SUPPORTED);
    CASE_OF(SEC_E_NO_IMPERSONATION);
    CASE_OF(SEC_E_LOGON_DENIED);
    CASE_OF(SEC_E_UNKNOWN_CREDENTIALS);
    CASE_OF(SEC_E_NO_CREDENTIALS);
    CASE_OF(SEC_E_MESSAGE_ALTERED);
    CASE_OF(SEC_E_OUT_OF_SEQUENCE);
    CASE_OF(SEC_E_NO_AUTHENTICATING_AUTHORITY);
    CASE_OF(SEC_I_CONTINUE_NEEDED);
    CASE_OF(SEC_I_COMPLETE_NEEDED);
    CASE_OF(SEC_I_COMPLETE_AND_CONTINUE);
    CASE_OF(SEC_I_LOCAL_LOGON);
    CASE_OF(SEC_E_BAD_PKGID);
    CASE_OF(SEC_E_CONTEXT_EXPIRED);
    CASE_OF(SEC_E_INCOMPLETE_MESSAGE);


    //
    // WINSOCK errors
    //

    CASE_OF(WSAEINTR);
    CASE_OF(WSAEBADF);
    CASE_OF(WSAEACCES);
    CASE_OF(WSAEFAULT);
    CASE_OF(WSAEINVAL);
    CASE_OF(WSAEMFILE);
    CASE_OF(WSAEWOULDBLOCK);
    CASE_OF(WSAEINPROGRESS);
    CASE_OF(WSAEALREADY);
    CASE_OF(WSAENOTSOCK);
    CASE_OF(WSAEDESTADDRREQ);
    CASE_OF(WSAEMSGSIZE);
    CASE_OF(WSAEPROTOTYPE);
    CASE_OF(WSAENOPROTOOPT);
    CASE_OF(WSAEPROTONOSUPPORT);
    CASE_OF(WSAESOCKTNOSUPPORT);
    CASE_OF(WSAEOPNOTSUPP);
    CASE_OF(WSAEPFNOSUPPORT);
    CASE_OF(WSAEAFNOSUPPORT);
    CASE_OF(WSAEADDRINUSE);
    CASE_OF(WSAEADDRNOTAVAIL);
    CASE_OF(WSAENETDOWN);
    CASE_OF(WSAENETUNREACH);
    CASE_OF(WSAENETRESET);
    CASE_OF(WSAECONNABORTED);
    CASE_OF(WSAECONNRESET);
    CASE_OF(WSAENOBUFS);
    CASE_OF(WSAEISCONN);
    CASE_OF(WSAENOTCONN);
    CASE_OF(WSAESHUTDOWN);
    CASE_OF(WSAETOOMANYREFS);
    CASE_OF(WSAETIMEDOUT);
    CASE_OF(WSAECONNREFUSED);
    CASE_OF(WSAELOOP);
    CASE_OF(WSAENAMETOOLONG);
    CASE_OF(WSAEHOSTDOWN);
    CASE_OF(WSAEHOSTUNREACH);
    CASE_OF(WSAENOTEMPTY);
    CASE_OF(WSAEPROCLIM);
    CASE_OF(WSAEUSERS);
    CASE_OF(WSAEDQUOT);
    CASE_OF(WSAESTALE);
    CASE_OF(WSAEREMOTE);
    CASE_OF(WSAEDISCON);
    CASE_OF(WSASYSNOTREADY);
    CASE_OF(WSAVERNOTSUPPORTED);
    CASE_OF(WSANOTINITIALISED);
    CASE_OF(WSAHOST_NOT_FOUND);
    CASE_OF(WSATRY_AGAIN);
    CASE_OF(WSANO_RECOVERY);
    CASE_OF(WSANO_DATA);

#if 0
    //
    // RAS errors
    //

    CASE_OF(PENDING);
    CASE_OF(ERROR_INVALID_PORT_HANDLE);
    CASE_OF(ERROR_PORT_ALREADY_OPEN);
    CASE_OF(ERROR_BUFFER_TOO_SMALL);
    CASE_OF(ERROR_WRONG_INFO_SPECIFIED);
    CASE_OF(ERROR_CANNOT_SET_PORT_INFO);
    CASE_OF(ERROR_PORT_NOT_CONNECTED);
    CASE_OF(ERROR_EVENT_INVALID);
    CASE_OF(ERROR_DEVICE_DOES_NOT_EXIST);
    CASE_OF(ERROR_BUFFER_INVALID);
    CASE_OF(ERROR_ROUTE_NOT_AVAILABLE);
    CASE_OF(ERROR_ROUTE_NOT_ALLOCATED);
    CASE_OF(ERROR_INVALID_COMPRESSION_SPECIFIED);
    CASE_OF(ERROR_OUT_OF_BUFFERS);
    CASE_OF(ERROR_PORT_NOT_FOUND);
    CASE_OF(ERROR_ASYNC_REQUEST_PENDING);
    CASE_OF(ERROR_ALREADY_DISCONNECTING);
    CASE_OF(ERROR_PORT_NOT_OPEN);
    CASE_OF(ERROR_PORT_DISCONNECTED);
    CASE_OF(ERROR_NO_ENDPOINTS);
    CASE_OF(ERROR_CANNOT_OPEN_PHONEBOOK);
    CASE_OF(ERROR_CANNOT_LOAD_PHONEBOOK);
    CASE_OF(ERROR_CANNOT_FIND_PHONEBOOK_ENTRY);
    CASE_OF(ERROR_CANNOT_WRITE_PHONEBOOK);
    CASE_OF(ERROR_CORRUPT_PHONEBOOK);
    CASE_OF(ERROR_CANNOT_LOAD_STRING);
    CASE_OF(ERROR_KEY_NOT_FOUND);
    CASE_OF(ERROR_DISCONNECTION);
    CASE_OF(ERROR_REMOTE_DISCONNECTION);
    CASE_OF(ERROR_HARDWARE_FAILURE);
    CASE_OF(ERROR_USER_DISCONNECTION);
    CASE_OF(ERROR_INVALID_SIZE);
    CASE_OF(ERROR_PORT_NOT_AVAILABLE);
    CASE_OF(ERROR_CANNOT_PROJECT_CLIENT);
    CASE_OF(ERROR_UNKNOWN);
    CASE_OF(ERROR_WRONG_DEVICE_ATTACHED);
    CASE_OF(ERROR_BAD_STRING);
    CASE_OF(ERROR_REQUEST_TIMEOUT);
    CASE_OF(ERROR_CANNOT_GET_LANA);
    CASE_OF(ERROR_NETBIOS_ERROR);
    CASE_OF(ERROR_SERVER_OUT_OF_RESOURCES);
    CASE_OF(ERROR_NAME_EXISTS_ON_NET);
    CASE_OF(ERROR_SERVER_GENERAL_NET_FAILURE);
    CASE_OF(WARNING_MSG_ALIAS_NOT_ADDED);
    CASE_OF(ERROR_AUTH_INTERNAL);
    CASE_OF(ERROR_RESTRICTED_LOGON_HOURS);
    CASE_OF(ERROR_ACCT_DISABLED);
    CASE_OF(ERROR_PASSWD_EXPIRED);
    CASE_OF(ERROR_NO_DIALIN_PERMISSION);
    CASE_OF(ERROR_SERVER_NOT_RESPONDING);
    CASE_OF(ERROR_FROM_DEVICE);
    CASE_OF(ERROR_UNRECOGNIZED_RESPONSE);
    CASE_OF(ERROR_MACRO_NOT_FOUND);
    CASE_OF(ERROR_MACRO_NOT_DEFINED);
    CASE_OF(ERROR_MESSAGE_MACRO_NOT_FOUND);
    CASE_OF(ERROR_DEFAULTOFF_MACRO_NOT_FOUND);
    CASE_OF(ERROR_FILE_COULD_NOT_BE_OPENED);
    CASE_OF(ERROR_DEVICENAME_TOO_LONG);
    CASE_OF(ERROR_DEVICENAME_NOT_FOUND);
    CASE_OF(ERROR_NO_RESPONSES);
    CASE_OF(ERROR_NO_COMMAND_FOUND);
    CASE_OF(ERROR_WRONG_KEY_SPECIFIED);
    CASE_OF(ERROR_UNKNOWN_DEVICE_TYPE);
    CASE_OF(ERROR_ALLOCATING_MEMORY);
    CASE_OF(ERROR_PORT_NOT_CONFIGURED);
    CASE_OF(ERROR_DEVICE_NOT_READY);
    CASE_OF(ERROR_READING_INI_FILE);
    CASE_OF(ERROR_NO_CONNECTION);
    CASE_OF(ERROR_BAD_USAGE_IN_INI_FILE);
    CASE_OF(ERROR_READING_SECTIONNAME);
    CASE_OF(ERROR_READING_DEVICETYPE);
    CASE_OF(ERROR_READING_DEVICENAME);
    CASE_OF(ERROR_READING_USAGE);
    CASE_OF(ERROR_READING_MAXCONNECTBPS);
    CASE_OF(ERROR_READING_MAXCARRIERBPS);
    CASE_OF(ERROR_LINE_BUSY);
    CASE_OF(ERROR_VOICE_ANSWER);
    CASE_OF(ERROR_NO_ANSWER);
    CASE_OF(ERROR_NO_CARRIER);
    CASE_OF(ERROR_NO_DIALTONE);
    CASE_OF(ERROR_IN_COMMAND);
    CASE_OF(ERROR_WRITING_SECTIONNAME);
    CASE_OF(ERROR_WRITING_DEVICETYPE);
    CASE_OF(ERROR_WRITING_DEVICENAME);
    CASE_OF(ERROR_WRITING_MAXCONNECTBPS);
    CASE_OF(ERROR_WRITING_MAXCARRIERBPS);
    CASE_OF(ERROR_WRITING_USAGE);
    CASE_OF(ERROR_WRITING_DEFAULTOFF);
    CASE_OF(ERROR_READING_DEFAULTOFF);
    CASE_OF(ERROR_EMPTY_INI_FILE);
    CASE_OF(ERROR_AUTHENTICATION_FAILURE);
    CASE_OF(ERROR_PORT_OR_DEVICE);
    CASE_OF(ERROR_NOT_BINARY_MACRO);
    CASE_OF(ERROR_DCB_NOT_FOUND);
    CASE_OF(ERROR_STATE_MACHINES_NOT_STARTED);
    CASE_OF(ERROR_STATE_MACHINES_ALREADY_STARTED);
    CASE_OF(ERROR_PARTIAL_RESPONSE_LOOPING);
    CASE_OF(ERROR_UNKNOWN_RESPONSE_KEY);
    CASE_OF(ERROR_RECV_BUF_FULL);
    CASE_OF(ERROR_CMD_TOO_LONG);
    CASE_OF(ERROR_UNSUPPORTED_BPS);
    CASE_OF(ERROR_UNEXPECTED_RESPONSE);
    CASE_OF(ERROR_INTERACTIVE_MODE);
    CASE_OF(ERROR_BAD_CALLBACK_NUMBER);
    CASE_OF(ERROR_INVALID_AUTH_STATE);
    CASE_OF(ERROR_WRITING_INITBPS);
    CASE_OF(ERROR_X25_DIAGNOSTIC);
    CASE_OF(ERROR_ACCT_EXPIRED);
    CASE_OF(ERROR_CHANGING_PASSWORD);
    CASE_OF(ERROR_OVERRUN);
    CASE_OF(ERROR_RASMAN_CANNOT_INITIALIZE);
    CASE_OF(ERROR_BIPLEX_PORT_NOT_AVAILABLE);
    CASE_OF(ERROR_NO_ACTIVE_ISDN_LINES);
    CASE_OF(ERROR_NO_ISDN_CHANNELS_AVAILABLE);
    CASE_OF(ERROR_TOO_MANY_LINE_ERRORS);
    CASE_OF(ERROR_IP_CONFIGURATION);
    CASE_OF(ERROR_NO_IP_ADDRESSES);
    CASE_OF(ERROR_PPP_TIMEOUT);
    CASE_OF(ERROR_PPP_REMOTE_TERMINATED);
    CASE_OF(ERROR_PPP_NO_PROTOCOLS_CONFIGURED);
    CASE_OF(ERROR_PPP_NO_RESPONSE);
    CASE_OF(ERROR_PPP_INVALID_PACKET);
    CASE_OF(ERROR_PHONE_NUMBER_TOO_LONG);
    CASE_OF(ERROR_IPXCP_NO_DIALOUT_CONFIGURED);
    CASE_OF(ERROR_IPXCP_NO_DIALIN_CONFIGURED);
    CASE_OF(ERROR_IPXCP_DIALOUT_ALREADY_ACTIVE);
    CASE_OF(ERROR_ACCESSING_TCPCFGDLL);
    CASE_OF(ERROR_NO_IP_RAS_ADAPTER);
    CASE_OF(ERROR_SLIP_REQUIRES_IP);
    CASE_OF(ERROR_PROJECTION_NOT_COMPLETE);
    CASE_OF(ERROR_PROTOCOL_NOT_CONFIGURED);
    CASE_OF(ERROR_PPP_NOT_CONVERGING);
    CASE_OF(ERROR_PPP_CP_REJECTED);
    CASE_OF(ERROR_PPP_LCP_TERMINATED);
    CASE_OF(ERROR_PPP_REQUIRED_ADDRESS_REJECTED);
    CASE_OF(ERROR_PPP_NCP_TERMINATED);
    CASE_OF(ERROR_PPP_LOOPBACK_DETECTED);
    CASE_OF(ERROR_PPP_NO_ADDRESS_ASSIGNED);
    CASE_OF(ERROR_CANNOT_USE_LOGON_CREDENTIALS);
    CASE_OF(ERROR_TAPI_CONFIGURATION);
    CASE_OF(ERROR_NO_LOCAL_ENCRYPTION);
    CASE_OF(ERROR_NO_REMOTE_ENCRYPTION);
    CASE_OF(ERROR_REMOTE_REQUIRES_ENCRYPTION);
    CASE_OF(ERROR_IPXCP_NET_NUMBER_CONFLICT);
    CASE_OF(ERROR_INVALID_SMM);
    CASE_OF(ERROR_SMM_UNINITIALIZED);
    CASE_OF(ERROR_NO_MAC_FOR_PORT);
    CASE_OF(ERROR_SMM_TIMEOUT);
    CASE_OF(ERROR_BAD_PHONE_NUMBER);
    CASE_OF(ERROR_WRONG_MODULE);
    CASE_OF(ERROR_INVALID_CALLBACK_NUMBER);
    CASE_OF(ERROR_SCRIPT_SYNTAX);
#endif // 0
    default:
        return "?";
    }
}


LPSTR
InternetMapStatus(
    IN DWORD Status
    )

/*++

Routine Description:

    Convert WINHTTP_CALLBACK_STATUS_ value to symbolic name

Arguments:

    Status  - to map

Return Value:

    LPSTR - pointer to symbolic name, or "?" if unknown

--*/

{
    switch (Status) {
    CASE_OF(WINHTTP_CALLBACK_STATUS_RESOLVING_NAME);
    CASE_OF(WINHTTP_CALLBACK_STATUS_NAME_RESOLVED);
    CASE_OF(WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER);
    CASE_OF(WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER);
    CASE_OF(WINHTTP_CALLBACK_STATUS_SENDING_REQUEST);
    CASE_OF(WINHTTP_CALLBACK_STATUS_REQUEST_SENT);
    CASE_OF(WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED);
    CASE_OF(WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION);
    CASE_OF(WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED);
    CASE_OF(WINHTTP_CALLBACK_STATUS_HANDLE_CREATED);
    CASE_OF(WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING);
    CASE_OF(WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_REDIRECT);
    CASE_OF(WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_READ_COMPLETE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_REQUEST_ERROR);
    }
    return "?";
}


LPSTR
InternetMapSSPIError(
    IN DWORD Status
    )

/*++

Routine Description:

    Convert a SSL/PCT SSPI Error Code to a string.

Arguments:

    Status  - to map

Return Value:

    LPSTR - pointer to symbolic name, or "?" if unknown

--*/

{
    switch (Status) {

    CASE_OF(STATUS_SUCCESS);
    CASE_OF(SEC_E_INSUFFICIENT_MEMORY        );
    CASE_OF(SEC_E_INVALID_HANDLE             );
    CASE_OF(SEC_E_UNSUPPORTED_FUNCTION       );
    CASE_OF(SEC_E_TARGET_UNKNOWN             );
    CASE_OF(SEC_E_INTERNAL_ERROR             );
    CASE_OF(SEC_E_SECPKG_NOT_FOUND           );
    CASE_OF(SEC_E_NOT_OWNER                  );
    CASE_OF(SEC_E_CANNOT_INSTALL             );
    CASE_OF(SEC_E_INVALID_TOKEN              );
    CASE_OF(SEC_E_CANNOT_PACK                );
    CASE_OF(SEC_E_QOP_NOT_SUPPORTED          );
    CASE_OF(SEC_E_NO_IMPERSONATION           );
    CASE_OF(SEC_E_LOGON_DENIED               );
    CASE_OF(SEC_E_UNKNOWN_CREDENTIALS        );
    CASE_OF(SEC_E_NO_CREDENTIALS             );
    CASE_OF(SEC_E_MESSAGE_ALTERED            );
    CASE_OF(SEC_E_OUT_OF_SEQUENCE            );
    CASE_OF(SEC_E_NO_AUTHENTICATING_AUTHORITY);
    CASE_OF(SEC_I_CONTINUE_NEEDED            );
    CASE_OF(SEC_I_COMPLETE_NEEDED            );
    CASE_OF(SEC_I_COMPLETE_AND_CONTINUE      );
    CASE_OF(SEC_I_LOCAL_LOGON                );
    CASE_OF(SEC_E_BAD_PKGID                  );
    CASE_OF(SEC_E_CONTEXT_EXPIRED            );
    CASE_OF(SEC_E_INCOMPLETE_MESSAGE         );
//    CASE_OF(SEC_E_NO_SPM                     );
//    CASE_OF(SEC_E_NOT_SUPPORTED              );

    }
    return "?";
}




LPSTR
InternetMapHttpOption(
    IN DWORD Option
    )

/*++

Routine Description:

    Convert HTTP_QUERY_ option value to symbolic name

Arguments:

    Option  - to map

Return Value:

    LPSTR - pointer to symbolic name, or "?" if unknown

--*/

{
    switch (Option) {
    CASE_OF(HTTP_QUERY_MIME_VERSION);               // 0
    CASE_OF(HTTP_QUERY_CONTENT_TYPE);               // 1
    CASE_OF(HTTP_QUERY_CONTENT_TRANSFER_ENCODING);  // 2
    CASE_OF(HTTP_QUERY_CONTENT_ID);                 // 3
    CASE_OF(HTTP_QUERY_CONTENT_DESCRIPTION);        // 4
    CASE_OF(HTTP_QUERY_CONTENT_LENGTH);             // 5
    CASE_OF(HTTP_QUERY_CONTENT_LANGUAGE);           // 6
    CASE_OF(HTTP_QUERY_ALLOW);                      // 7
    CASE_OF(HTTP_QUERY_PUBLIC);                     // 8
    CASE_OF(HTTP_QUERY_DATE);                       // 9
    CASE_OF(HTTP_QUERY_EXPIRES);                    // 10
    CASE_OF(HTTP_QUERY_LAST_MODIFIED);              // 11
    CASE_OF(HTTP_QUERY_MESSAGE_ID);                 // 12
    CASE_OF(HTTP_QUERY_URI);                        // 13
    CASE_OF(HTTP_QUERY_DERIVED_FROM);               // 14
    CASE_OF(HTTP_QUERY_COST);                       // 15
    CASE_OF(HTTP_QUERY_LINK);                       // 16
    CASE_OF(HTTP_QUERY_PRAGMA);                     // 17
    CASE_OF(HTTP_QUERY_VERSION);                    // 18
    CASE_OF(HTTP_QUERY_STATUS_CODE);                // 19
    CASE_OF(HTTP_QUERY_STATUS_TEXT);                // 20
    CASE_OF(HTTP_QUERY_RAW_HEADERS);                // 21
    CASE_OF(HTTP_QUERY_RAW_HEADERS_CRLF);           // 22
    CASE_OF(HTTP_QUERY_CONNECTION);                 // 23
    CASE_OF(HTTP_QUERY_ACCEPT);                     // 24
    CASE_OF(HTTP_QUERY_ACCEPT_CHARSET);             // 25
    CASE_OF(HTTP_QUERY_ACCEPT_ENCODING);            // 26
    CASE_OF(HTTP_QUERY_ACCEPT_LANGUAGE);            // 27
    CASE_OF(HTTP_QUERY_AUTHORIZATION);              // 28
    CASE_OF(HTTP_QUERY_CONTENT_ENCODING);           // 29
    CASE_OF(HTTP_QUERY_FORWARDED);                  // 30
    CASE_OF(HTTP_QUERY_FROM);                       // 31
    CASE_OF(HTTP_QUERY_IF_MODIFIED_SINCE);          // 32
    CASE_OF(HTTP_QUERY_LOCATION);                   // 33
    CASE_OF(HTTP_QUERY_ORIG_URI);                   // 34
    CASE_OF(HTTP_QUERY_REFERER);                    // 35
    CASE_OF(HTTP_QUERY_RETRY_AFTER);                // 36
    CASE_OF(HTTP_QUERY_SERVER);                     // 37
    CASE_OF(HTTP_QUERY_TITLE);                      // 38
    CASE_OF(HTTP_QUERY_USER_AGENT);                 // 39
    CASE_OF(HTTP_QUERY_WWW_AUTHENTICATE);           // 40
    CASE_OF(HTTP_QUERY_PROXY_AUTHENTICATE);         // 41
    CASE_OF(HTTP_QUERY_ACCEPT_RANGES);              // 42
    CASE_OF(HTTP_QUERY_SET_COOKIE);                 // 43
    CASE_OF(HTTP_QUERY_COOKIE);                     // 44
    CASE_OF(HTTP_QUERY_REQUEST_METHOD);             // 45
    CASE_OF(HTTP_QUERY_REFRESH);                    // 46
    CASE_OF(HTTP_QUERY_CONTENT_DISPOSITION);        // 47
    CASE_OF(HTTP_QUERY_AGE);                        // 48
    CASE_OF(HTTP_QUERY_CACHE_CONTROL);              // 49
    CASE_OF(HTTP_QUERY_CONTENT_BASE);               // 50
    CASE_OF(HTTP_QUERY_CONTENT_LOCATION);           // 51
    CASE_OF(HTTP_QUERY_CONTENT_MD5);                // 52
    CASE_OF(HTTP_QUERY_CONTENT_RANGE);              // 53
    CASE_OF(HTTP_QUERY_ETAG);                       // 54
    CASE_OF(HTTP_QUERY_HOST);                       // 55
    CASE_OF(HTTP_QUERY_IF_MATCH);                   // 56
    CASE_OF(HTTP_QUERY_IF_NONE_MATCH);              // 57
    CASE_OF(HTTP_QUERY_IF_RANGE);                   // 58
    CASE_OF(HTTP_QUERY_IF_UNMODIFIED_SINCE);        // 59
    CASE_OF(HTTP_QUERY_MAX_FORWARDS);               // 60
    CASE_OF(HTTP_QUERY_PROXY_AUTHORIZATION);        // 61
    CASE_OF(HTTP_QUERY_RANGE);                      // 62
    CASE_OF(HTTP_QUERY_TRANSFER_ENCODING);          // 63
    CASE_OF(HTTP_QUERY_UPGRADE);                    // 64
    CASE_OF(HTTP_QUERY_VARY);                       // 65
    CASE_OF(HTTP_QUERY_VIA);                        // 66
    CASE_OF(HTTP_QUERY_WARNING);                    // 67
    CASE_OF(HTTP_QUERY_EXPECT);                     // 68
    CASE_OF(HTTP_QUERY_PROXY_CONNECTION);           // 69
    CASE_OF(HTTP_QUERY_UNLESS_MODIFIED_SINCE);      // 70
    CASE_OF(HTTP_QUERY_ECHO_REQUEST);               // 71
    CASE_OF(HTTP_QUERY_ECHO_REPLY);                 // 72
    CASE_OF(HTTP_QUERY_ECHO_HEADERS);               // 73
    CASE_OF(HTTP_QUERY_ECHO_HEADERS_CRLF);          // 74
    CASE_OF(HTTP_QUERY_CUSTOM);                     // 65535
    }
    return "?";
}


LPSTR
InternetMapHttpState(
    IN WORD State
    )

/*++

Routine Description:

    Convert HTTPREQ_STATE_ to symbolic name

Arguments:

    State   - to map

Return Value:

    LPSTR

--*/

{
    switch (State & ~HTTPREQ_FLAG_MASK)
    {
    CASE_OF(HttpRequestStateCreating);
    CASE_OF(HttpRequestStateOpen);
    CASE_OF(HttpRequestStateRequest);
    CASE_OF(HttpRequestStateResponse);
    CASE_OF(HttpRequestStateObjectData);
    CASE_OF(HttpRequestStateError);
    CASE_OF(HttpRequestStateClosing);
    CASE_OF(HttpRequestStateReopen);
    }
    return "?";
}

LPSTR
InternetMapHttpStateFlag(
    IN WORD Flag
    )

/*++

Routine Description:

    Convert HTTPREQ_STATE_ flag to symbolic name

Arguments:

    Flag    - to map

Return Value:

    LPSTR

--*/

{
    switch (Flag & ~HTTPREQ_FLAG_MASK)
    {
    case HTTPREQ_STATE_ANYTHING_OK:
        return "ANYTHING";

    case HTTPREQ_STATE_CLOSE_OK:
        return "CLOSE";

    case HTTPREQ_STATE_ADD_OK:
        return "ADD";

    case HTTPREQ_STATE_SEND_OK:
        return "SEND";

    case HTTPREQ_STATE_READ_OK:
        return "READ";

    case HTTPREQ_STATE_QUERY_REQUEST_OK:
        return "QUERY_REQUEST";

    case HTTPREQ_STATE_QUERY_RESPONSE_OK:
        return "QUERY_RESPONSE";

    case HTTPREQ_STATE_REUSE_OK:
        return "REUSE";
    }
    return "?";
}


LPSTR
InternetMapAsyncRequest(
    IN AR_TYPE Type
    )

/*++

Routine Description:

    Convert AR_TYPE to symbolic name

Arguments:

    Type    - Async request type

Return Value:

    LPSTR - pointer to symbolic name, or "?" if unknown

--*/

{
    switch (Type) {
    CASE_OF(AR_INTERNET_CONNECT);
    CASE_OF(AR_INTERNET_OPEN_URL);
    CASE_OF(AR_INTERNET_READ_FILE);
    CASE_OF(AR_INTERNET_WRITE_FILE);
    CASE_OF(AR_INTERNET_QUERY_DATA_AVAILABLE);
    CASE_OF(AR_INTERNET_FIND_NEXT_FILE);
    CASE_OF(AR_FTP_FIND_FIRST_FILE);
    CASE_OF(AR_FTP_GET_FILE);
    CASE_OF(AR_FTP_PUT_FILE);
    CASE_OF(AR_FTP_DELETE_FILE);
    CASE_OF(AR_FTP_RENAME_FILE);
    CASE_OF(AR_FTP_OPEN_FILE);
    CASE_OF(AR_FTP_CREATE_DIRECTORY);
    CASE_OF(AR_FTP_REMOVE_DIRECTORY);
    CASE_OF(AR_FTP_SET_CURRENT_DIRECTORY);
    CASE_OF(AR_FTP_GET_CURRENT_DIRECTORY);
    CASE_OF(AR_GOPHER_FIND_FIRST_FILE);
    CASE_OF(AR_GOPHER_OPEN_FILE);
    CASE_OF(AR_GOPHER_GET_ATTRIBUTE);
    CASE_OF(AR_HTTP_SEND_REQUEST);
    CASE_OF(AR_HTTP_BEGIN_SEND_REQUEST);
    CASE_OF(AR_HTTP_END_SEND_REQUEST);
    CASE_OF(AR_READ_PREFETCH);
    CASE_OF(AR_SYNC_EVENT);
    CASE_OF(AR_TIMER_EVENT);
    CASE_OF(AR_HTTP_REQUEST1);
    CASE_OF(AR_FILE_IO);
    CASE_OF(AR_INTERNET_READ_FILE_EX);
    }
    return "?";
}


LPSTR
InternetMapHandleType(
    IN DWORD HandleType
    )

/*++

Routine Description:

    Map handle type to symbolic name

Arguments:

    HandleType  - from handle object

Return Value:

    LPSTR

--*/

{
    switch (HandleType) {
    CASE_OF(TypeGenericHandle);
    CASE_OF(TypeInternetHandle);
    CASE_OF(TypeFtpConnectHandle);
    CASE_OF(TypeFtpFindHandle);
    CASE_OF(TypeFtpFindHandleHtml);
    CASE_OF(TypeFtpFileHandle);
    CASE_OF(TypeFtpFileHandleHtml);
    CASE_OF(TypeGopherConnectHandle);
    CASE_OF(TypeGopherFindHandle);
    CASE_OF(TypeGopherFindHandleHtml);
    CASE_OF(TypeGopherFileHandle);
    CASE_OF(TypeGopherFileHandleHtml);
    CASE_OF(TypeHttpConnectHandle);
    CASE_OF(TypeHttpRequestHandle);
    CASE_OF(TypeFileRequestHandle);
    CASE_OF(TypeWildHandle);
    }
    return "?";
}


LPSTR
InternetMapScheme(
    IN INTERNET_SCHEME Scheme
    )

/*++

Routine Description:

    Maps INTERNET_SCHEME_ to symbolic name

Arguments:

    Scheme  - to map

Return Value:

    LPSTR

--*/

{
    switch (Scheme) {
    CASE_OF(INTERNET_SCHEME_UNKNOWN);
    CASE_OF(INTERNET_SCHEME_DEFAULT);
    CASE_OF(INTERNET_SCHEME_HTTP);
    CASE_OF(INTERNET_SCHEME_HTTPS);
    }
    return "?";
}


LPSTR
InternetMapOpenType(
    IN DWORD OpenType
    )

/*++

Routine Description:

    Maps INTERNET_OPEN_TYPE_ to symbolic name

Arguments:

    OpenType    - to map

Return Value:

    LPSTR

--*/

{
    switch (OpenType) {
    CASE_OF(INTERNET_OPEN_TYPE_DIRECT);
    CASE_OF(INTERNET_OPEN_TYPE_PROXY);
    CASE_OF(INTERNET_OPEN_TYPE_PRECONFIG);
    }
    return "?";
}


LPSTR
InternetMapService(
    IN DWORD Service
    )

/*++

Routine Description:

    Maps INTERNET_SERVICE_ to symbolic name

Arguments:

    Service - to map

Return Value:

    LPSTR

--*/

{
    switch (Service)
    {
        CASE_OF(INTERNET_SERVICE_HTTP);
    }
    return "?";
}

//
// private functions
//


PRIVATE
LPSTR
ExtractFileName(
    IN LPSTR Module,
    OUT LPSTR Buf
    )
{
    LPSTR filename;
    LPSTR extension;
    int   len;

    filename = strrchr(Module, '\\');
    extension = strrchr(Module, '.');
    if (filename) {
        ++filename;
    } else {
        filename = Module;
    }
    if (!extension) {
        extension = filename + strlen(filename);
    }
    len = (int) (extension - filename);
    memcpy(Buf, filename, len);
    Buf[len] = '\0';
    return Buf;
}


PRIVATE
LPSTR
SetDebugPrefix(
    IN LPSTR Buffer
    )
{
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    //INET_ASSERT(lpThreadInfo != NULL);

    if (!lpThreadInfo) {
        return NULL;
    }

    LPINTERNET_DEBUG_RECORD lpRecord;

    lpRecord = lpThreadInfo->Stack;

    if (InternetDebugControlFlags & DBG_ENTRY_TIME) {
        if ((InternetDebugControlFlags & (DBG_DELTA_TIME | DBG_CUMULATIVE_TIME))
        && lpRecord) {

            DWORD ticks;
            DWORD ticksNow;

            ticksNow = GetTickCountWrap();
            ticks = ticksNow -  ((InternetDebugControlFlags & DBG_CUMULATIVE_TIME)
                                    ? InternetDebugStartTime
                                    : lpRecord->LastTime);

            Buffer += rsprintf(Buffer,
                               "% 5d.%3d ",
                               ticks / 1000,
                               ticks % 1000
                               );
            if (InternetDebugControlFlags & DBG_DELTA_TIME) {
                lpRecord->LastTime = ticksNow;
            }
        } else {

            SYSTEMTIME timeNow;

            InternetDebugGetLocalTime(&timeNow, NULL);

            Buffer += rsprintf(Buffer,
                               "%02d:%02d:%02d.%03d ",
                               timeNow.wHour,
                               timeNow.wMinute,
                               timeNow.wSecond,
                               timeNow.wMilliseconds
                               );
        }
    }

/*
    if (InternetDebugControlFlags & DBG_LEVEL_INDICATOR) {
        Buffer += rsprintf(Buffer, );
    }
*/

    if (InternetDebugControlFlags & DBG_THREAD_INFO) {

        //
        // thread id
        //

        Buffer += rsprintf(Buffer, "%08x", lpThreadInfo->ThreadId);

        //
        // INTERNET_THREAD_INFO address
        //

        if (InternetDebugControlFlags & DBG_THREAD_INFO_ADR) {
            Buffer += rsprintf(Buffer, ":%08x", lpThreadInfo);
        }

        //
        // ARB address
        //

        //if (InternetDebugControlFlags & DBG_ARB_ADDR) {
        //    Buffer += rsprintf(Buffer, ":%08x", lpThreadInfo->lpArb);
        //}

        //
        // FIBER address
        //

        //if (InternetDebugControlFlags & DBG_FIBER_INFO) {
        //
        //    LPVOID p;
        //
        //    p = (lpThreadInfo->lpArb != NULL)
        //      ? lpThreadInfo->lpArb->Header.lpFiber
        //      : NULL
        //      ;
        //    Buffer += rsprintf(Buffer, ":%08x", p);
        //}

        //
        // async ID
        //

        if (InternetDebugControlFlags & DBG_ASYNC_ID) {
            if (lpThreadInfo->IsAsyncWorkerThread) {
                Buffer += rsprintf(Buffer, ":<--->");
            } else if (lpThreadInfo->InCallback) {

                //
                // async worker thread calling back into the app; any WinInet
                // API requests during this time treated as though from the
                // app context
                //

                Buffer += rsprintf(Buffer, ":<c-b>");
            }
            else
            {

                //
                // this is an app thread
                //

                Buffer += rsprintf(Buffer, ":<app>");
            }
        }

        //
        // request handle
        //

        if (InternetDebugControlFlags & DBG_REQUEST_HANDLE) {
            Buffer += rsprintf(Buffer, ":%6X", lpThreadInfo->hObject);
        }

        *Buffer++ = ' ';
    }

    if (InternetDebugControlFlags & DBG_CALL_DEPTH) {
        Buffer += rsprintf(Buffer, "%03d ", lpThreadInfo->CallDepth);
    }

    for (int i = 0; i < lpThreadInfo->IndentIncrement; ++i) {
        *Buffer++ = ' ';
    }

    //
    // if we are not debugging the category - i.e we got here via a requirement
    // to display an error, or we are in a function that does not have a
    // DEBUG_ENTER - then prefix the string with the current function name
    // (obviously misleading if the function doesn't have a DEBUG_ENTER)
    //

    if (lpRecord != NULL) {
        if (!(lpRecord->Category & InternetDebugCategoryFlags)) {
            Buffer += rsprintf(Buffer, "%s(): ", lpRecord->Function);
        }
    }

    return Buffer;
}

int dprintf(char * format, ...) {

    va_list args;
    char buf[PRINTF_STACK_BUFFER_LENGTH];
    int n;

    va_start(args, format);
    n = _sprintf(buf, format, args);
    va_end(args);
    OutputDebugString(buf);

    return n;
}


LPSTR
SourceFilename(
    LPSTR Filespec
    )
{
    if (!Filespec) {
        return "?";
    }

    LPSTR p;

    if (p = strrchr(Filespec, '\\')) {

        //
        // we want e.g. common\debugmem.cxx, but get
        // common\..\win32\debugmem.cxx. Bah!
        //

        //LPSTR q;
        //
        //if (q = strrchr(p - 1, '\\')) {
        //    p = q;
        //}
    }
    return p ? p + 1 : Filespec;
}

typedef BOOL (* SYMINITIALIZE)(HANDLE, LPSTR, BOOL);
typedef BOOL (* SYMLOADMODULE)(HANDLE, HANDLE, PSTR, PSTR, DWORD, DWORD);
typedef BOOL (* SYMGETSYMFROMADDR)(HANDLE, DWORD, PDWORD, PIMAGEHLP_SYMBOL);
typedef BOOL (* SYMCLEANUP)(HANDLE);

PRIVATE HMODULE hSymLib = NULL;
PRIVATE SYMINITIALIZE pSymInitialize = NULL;
PRIVATE SYMLOADMODULE pSymLoadModule = NULL;
PRIVATE SYMGETSYMFROMADDR pSymGetSymFromAddr = NULL;
PRIVATE SYMCLEANUP pSymCleanup = NULL;


VOID
InitSymLib(
    VOID
    )
{
    if (hSymLib == NULL) {
        hSymLib = LoadLibrary("IMAGEHLP.DLL");
        if (hSymLib != NULL) {
            pSymInitialize = (SYMINITIALIZE)GetProcAddress(hSymLib,
                                                           "SymInitialize"
                                                           );
            pSymLoadModule = (SYMLOADMODULE)GetProcAddress(hSymLib,
                                                           "SymLoadModule"
                                                           );
            pSymGetSymFromAddr = (SYMGETSYMFROMADDR)GetProcAddress(hSymLib,
                                                                   "SymGetSymFromAddr"
                                                                   );
            pSymCleanup = (SYMCLEANUP)GetProcAddress(hSymLib,
                                                     "SymCleanup"
                                                     );
            if (!pSymInitialize
            || !pSymLoadModule
            || !pSymGetSymFromAddr
            || !pSymCleanup) {
                FreeLibrary(hSymLib);
                hSymLib = NULL;
                pSymInitialize = NULL;
                pSymLoadModule = NULL;
                pSymGetSymFromAddr = NULL;
                pSymCleanup = NULL;
                return;
            }
        }
        pSymInitialize(GetCurrentProcess(), NULL, FALSE);
        //SymInitialize(GetCurrentProcess(), NULL, TRUE);
        pSymLoadModule(GetCurrentProcess(), NULL, "WININET.DLL", "WININET", 0, 0);
    }
}


VOID
TermSymLib(
    VOID
    )
{
    if (pSymCleanup) {
        pSymCleanup(GetCurrentProcess());
        FreeLibrary(hSymLib);
    }
}


LPSTR
GetDebugSymbol(
    DWORD Address,
    LPDWORD Offset
    )
{
    *Offset = Address;
    if (!pSymGetSymFromAddr) {
        return "";
    }

    //
    // BUGBUG - only one caller at a time please
    //

    static char symBuf[512];

    //((PIMAGEHLP_SYMBOL)symBuf)->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
    ((PIMAGEHLP_SYMBOL)symBuf)->SizeOfStruct = sizeof(symBuf);
    ((PIMAGEHLP_SYMBOL)symBuf)->MaxNameLength = sizeof(symBuf) - sizeof(IMAGEHLP_SYMBOL);
    if (!pSymGetSymFromAddr(GetCurrentProcess(),
                            Address,
                            Offset,
                            (PIMAGEHLP_SYMBOL)symBuf)) {
        ((PIMAGEHLP_SYMBOL)symBuf)->Name[0] = '\0';
    }
    return ((PIMAGEHLP_SYMBOL)symBuf)->Name;
}

#ifndef DONT_RIP
BOOL fRip = TRUE;
#else
BOOL fRip = FALSE;
#endif

#define _TEXTW(x) L##x
#define TEXTW(x)  _TEXTW(x)
#define SZ_MODULE "WINHTTP5"
#define ARRAYSIZE(pArray) (sizeof(pArray)/sizeof(pArray[0]))
EXTERN_C const CHAR  FAR c_szRipNoFn[] = SZ_MODULE "  RIP at %s, line %d: (%s)\r\n";
EXTERN_C const WCHAR FAR c_wszRipNoFn[] = TEXTW(SZ_MODULE) L"  RIP at %s, line %d: (%s)\r\n";



static
LPCSTR
_PathFindFileNameA(
    LPCSTR pPath)
{
    LPCSTR pT;

    for (pT = pPath; *pPath; pPath = CharNextA(pPath)) {
        if ((pPath[0] == '\\' || pPath[0] == ':' || pPath[0] == '/')
            && pPath[1] &&  pPath[1] != '\\'  &&   pPath[1] != '/')
            pT = pPath + 1;
    }

    return pT;
}


static
LPCWSTR
_PathFindFileNameW(
    LPCWSTR pPath)
{
    LPCWSTR pT;

    for (pT = pPath; *pPath; pPath++) {
        if ((pPath[0] == TEXTW('\\') || pPath[0] == TEXTW(':') || pPath[0] == TEXTW('/'))
            && pPath[1] &&  pPath[1] != TEXTW('\\')  &&   pPath[1] != TEXTW('/'))
            pT = pPath + 1;
    }

    return pT;
}


/*----------------------------------------------------------
Purpose: This function converts a multi-byte string to a
         wide-char string.

         If pszBuf is non-NULL and the converted string can fit in
         pszBuf, then *ppszWide will point to the given buffer.
         Otherwise, this function will allocate a buffer that can
         hold the converted string.

         If pszAnsi is NULL, then *ppszWide will be freed.  Note
         that pszBuf must be the same pointer between the call
         that converted the string and the call that frees the
         string.

Returns: TRUE
         FALSE (if out of memory)

*/
BOOL
UnicodeFromAnsi(
    LPWSTR * ppwszWide,
    LPCSTR pszAnsi,           // NULL to clean up
    LPWSTR pwszBuf,
    int cchBuf)
{
    BOOL bRet;

    // Convert the string?
    if (pszAnsi)
    {
        // Yes; determine the converted string length
        int cch;
        LPWSTR pwsz;
        int cchAnsi = lstrlenA(pszAnsi)+1;

        cch = MultiByteToWideChar(CP_ACP, 0, pszAnsi, cchAnsi, NULL, 0);

        // String too big, or is there no buffer?
        if (cch > cchBuf || NULL == pwszBuf)
        {
            // Yes; allocate space
            cchBuf = cch + 1;
            pwsz = (LPWSTR)LocalAlloc(LPTR, ((cchBuf)*sizeof(WCHAR)));
        }
        else
        {
            // No; use the provided buffer
            pwsz = pwszBuf;
        }

        if (pwsz)
        {
            // Convert the string
            cch = MultiByteToWideChar(CP_ACP, 0, pszAnsi, cchAnsi, pwsz, cchBuf);
            bRet = (0 < cch);
        }
        else
        {
            bRet = FALSE;
        }

        *ppwszWide = pwsz;
    }
    else
    {
        // No; was this buffer allocated?
        if (*ppwszWide && pwszBuf != *ppwszWide)
        {
            // Yes; clean up
            LocalFree((HLOCAL)*ppwszWide);
            *ppwszWide = NULL;
        }
        bRet = TRUE;
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Displays a RIP string.

Returns: TRUE to debugbreak
*/
BOOL
CcshellRipA(
    LPCSTR pszFile,
    int line,
    LPCSTR pszEval,
    BOOL bBreakInside)
{
    BOOL bRet = FALSE;
    LPCSTR psz;
    CHAR ach[256];

    psz = _PathFindFileNameA(pszFile);
    wsprintfA(ach, c_szRipNoFn, psz, line, pszEval);
    OutputDebugStringA(ach);

    if (fRip)
    {
        if (bBreakInside)
        {
            // !!!  RIP  !!!!  RIP  !!!!  RIP !!!
            
            // MSDEV USERS:  This is not the real RIP.  Hit 
            //               Shift-F11 to jump back to the caller.
            SH_DEBUG_BREAK;                                                // ASSERT

            // !!!  RIP  !!!!  RIP  !!!!  RIP !!!
        }
        else
            bRet = TRUE;
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Displays a RIP string.

*/
BOOL
CcshellRipW(
    LPCWSTR pszFile,
    int line,
    LPCWSTR pszEval,
    BOOL bBreakInside)
{
    BOOL bRet = FALSE;
    LPCWSTR psz;
    WCHAR ach[256];

    psz = _PathFindFileNameW(pszFile);

    // If psz == NULL, CharPrevW failed which implies we are running on Win95.  
    // We can get this if we get an assert in some of the W functions in 
    // shlwapi...  Call the A version of assert...
    if (!psz)
    {
        char szFile[MAX_PATH];
        char szEval[256];   // since the total output is thhis size should be enough...

        WideCharToMultiByte(CP_ACP, 0, pszFile, -1, szFile, ARRAYSIZE(szFile), NULL, NULL);
        WideCharToMultiByte(CP_ACP, 0, pszEval, -1, szEval, ARRAYSIZE(szEval), NULL, NULL);
        return CcshellRipA(szFile, line, szEval, bBreakInside);
    }

    wsprintfW(ach, c_wszRipNoFn, psz, line, pszEval);
    OutputDebugStringW(ach);

    if (fRip)
    {
        if (bBreakInside)
        {
            // !!!  RIP  !!!!  RIP  !!!!  RIP !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            SH_DEBUG_BREAK;                                                // ASSERT

            // !!!  RIP  !!!!  RIP  !!!!  RIP !!!
        }
        else
            bRet = TRUE;
    }

    return bRet;
}

EXTERN_C const CHAR  FAR c_szRipMsg[] = SZ_MODULE "  RIP: ";
EXTERN_C const CHAR  FAR c_szNewline[] = "\n";

BOOL
__cdecl 
CcshellRipMsgA(
    BOOL f, 
    LPCSTR pszMsg, ...)
{
    CHAR ach[1024+40];
    va_list vArgs;

    if (!f)
    {
        OutputDebugStringA(c_szRipMsg);

        va_start(vArgs, pszMsg);
        wvsprintfA(ach, pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringA(ach);

        OutputDebugStringA(c_szNewline);

        if (fRip)
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            SH_DEBUG_BREAK;                                                            // ASSERT
        }
    }
    return FALSE;
}

BOOL
__cdecl
CcshellRipMsgW(
    BOOL f, 
    LPCSTR pszMsg, ...)         // (this is deliberately CHAR)
{
    WCHAR ach[1024+40];
    va_list vArgs;

    if (!f)
    {
        LPWSTR pwsz;
        WCHAR wszBuf[128];
        OutputDebugStringA(c_szRipMsg);

        // (We convert the string, rather than simply input an
        // LPCWSTR parameter, so the caller doesn't have to wrap
        // all the string constants with the TEXT() macro.)

        ach[0] = L'\0';     // In case this fails
        if (UnicodeFromAnsi(&pwsz, pszMsg, wszBuf, ARRAYSIZE(wszBuf)))
        {
            va_start(vArgs, pszMsg);
            wvsprintfW(ach, pwsz, vArgs);
            va_end(vArgs);
            UnicodeFromAnsi(&pwsz, NULL, wszBuf, 0);
        }

        OutputDebugStringW(ach);
        OutputDebugStringA(c_szNewline);

        if (fRip)
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            SH_DEBUG_BREAK;                                                            // ASSERT
        }
    }
    return FALSE;
}

#if defined(i386)


VOID
x86SleazeCallStack(
    OUT LPVOID * lplpvStack,
    IN DWORD dwStackCount,
    IN LPVOID * Ebp
    )

/*++

Routine Description:

    Similar to x86SleazeCallersAddress but gathers a variable number of return
    addresses. We assume all functions have stack frame

Arguments:

    lplpvStack      - pointer to returned array of caller's addresses

    dwStackCount    - number of elements in lplpvStack

    Ebp             - starting Ebp if not 0, else use current stack

Return Value:

    None.

--*/

{
    DWORD my_esp;

    _asm mov my_esp, esp;

    __try {
        if (Ebp == 0) {
            Ebp = (LPVOID *)(&lplpvStack - 2);
        }
        while (dwStackCount--) {
            if (((DWORD)Ebp > my_esp + 0x10000) || ((DWORD)Ebp < my_esp - 0x10000)) {
                break;
            }
            *lplpvStack++ = *(Ebp + 1);
            Ebp = (LPVOID *)*Ebp;
            if (((DWORD)Ebp <= 0x10000)
            || ((DWORD)Ebp >= 0x80000000)
            || ((DWORD)Ebp & 3)
            || ((DWORD)Ebp > my_esp + 0x10000)
            || ((DWORD)Ebp < my_esp - 0x10000)) {
                break;
            }
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    }
}


VOID
x86SleazeCallersAddress(
    LPVOID* pCaller,
    LPVOID* pCallersCaller
    )

/*++

Routine Description:

    This is a sleazy function that reads return addresses out of the stack/
    frame pointer (ebp). We pluck out the return address of the function
    that called THE FUNCTION THAT CALLED THIS FUNCTION, and the caller of
    that function. Returning the return address of the function that called
    this function is not interesting to that caller (almost worthy of Sir
    Humphrey Appleby isn't it?)

    Assumes:

        my ebp  =>  | caller's ebp |
                    | caller's eip |
                    | arg #1       | (pCaller)
                    | arg #2       | (pCallersCaller

Arguments:

    pCaller         - place where we return addres of function that called
                      the function that called this function
    pCallersCaller  - place where we return caller of above

Return Value:

    None.

--*/

{

    //
    // this only works on x86 and only if not fpo functions!
    //

    LPVOID* ebp;

    ebp = (PVOID*)&pCaller - 2; // told you it was sleazy
    ebp = (PVOID*)*(PVOID*)ebp;
    *pCaller = *(ebp + 1);
    ebp = (PVOID*)*(PVOID*)ebp;
    *pCallersCaller = *(ebp + 1);
}

#endif // defined(i386)

#endif // ENABLE_DEBUG

INTERNETAPI
BOOL
WINAPI
InternetDebugGetLocalTime(
    OUT SYSTEMTIME * pstLocalTime,
    OUT DWORD      * pdwMicroSec
)
{
#ifndef ENABLE_DEBUG
    // QUICK HACK TO KEEP THINGS CLEAN AND STILL MEASURE WITH HIGH PERFORMANCE
    // COUNTER

    static BOOL pcTested = FALSE;
    static LONGLONG ftInit;  // initial local time
    static LONGLONG pcInit;  // initial perf counter
    static LONGLONG pcFreq;  // perf counter frequency

    if (!pcTested)
    {
        pcTested = TRUE;
        if (QueryPerformanceFrequency ((LARGE_INTEGER *) &pcFreq) && pcFreq)
        {
            QueryPerformanceCounter ((LARGE_INTEGER *) &pcInit);
            SYSTEMTIME st;
            GetLocalTime (&st);
            SystemTimeToFileTime (&st, (FILETIME *) &ftInit);
        }
    }

    if (!pcFreq)
        GetLocalTime (pstLocalTime);
    else
    {
        LONGLONG pcCurrent, ftCurrent;
        QueryPerformanceCounter ((LARGE_INTEGER *) &pcCurrent);
        ftCurrent = ftInit + ((10000000 * (pcCurrent - pcInit)) / pcFreq);
        FileTimeToSystemTime ((FILETIME *) &ftCurrent, pstLocalTime);
    }

    return TRUE;
#else
    if (!pcFreq)
        GetLocalTime (pstLocalTime);
    else
    {
        LONGLONG pcCurrent, ftCurrent;
        QueryPerformanceCounter ((LARGE_INTEGER *) &pcCurrent);
        ftCurrent = ftInit + ((10000000 * (pcCurrent - pcInit)) / pcFreq);
        FileTimeToSystemTime ((FILETIME *) &ftCurrent, pstLocalTime);
    }

    return TRUE;
#endif // ENABLE_DEBUG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\dll\makefile.inc ===
!if "$(BUILD_PRODUCT)" == "IE"
MC_INC = -A
!endif

$(O)\inetmsg.rc $(O)\inetmsg.h $(O)\msg00001.bin : inetmsg.mc
    mc $(MC_INC) -v -d -r $(O) -h $(O) inetmsg.mc

winhttp.rc : $(O)\selfreg_winhttp.inf

$(O)\selfreg_winhttp.inf : selfreg.inx
    $(CLEANINF) $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\dll\dllentry.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dllentry.cxx

Abstract:

    Entry point for WinInet Internet client DLL

    Contents:
        WinInetDllEntryPoint

Author:

    Richard L Firth (rfirth) 10-Nov-1994

Environment:

    Win32 (user-mode) DLL

Revision History:

    10-Nov-1994 rfirth
        Created

--*/

#include <wininetp.h>
#include <process.h>
#include <perfdiag.hxx>
#include <shlwapi.h>
#include <advpub.h>
#include <olectl.h>

#ifdef WINHTTP_STATIC_LIBRARY
#error dllentry.cxx should not be built in the static winhttpx.lib!!
#endif

#if defined(__cplusplus)
extern "C" {
#endif

BOOL
WINAPI
DllMain(
    IN HINSTANCE DllHandle,
    IN DWORD Reason,
    IN LPVOID Reserved
    );


#if defined(__cplusplus)
}
#endif

//
// global data
//

GLOBAL CCritSec GeneralInitCritSec;

//
// functions
//


BOOL
WINAPI
DllMain(
    IN HINSTANCE DllHandle,
    IN DWORD Reason,
    IN LPVOID Reserved
    )

/*++

Routine Description:

    Performs global initialization and termination for all protocol modules.

    This function only handles process attach and detach which are required for
    global initialization and termination, respectively. We disable thread
    attach and detach. New threads calling Wininet APIs will get an
    INTERNET_THREAD_INFO structure created for them by the first API requiring
    this structure

Arguments:

    DllHandle   - handle of this DLL. Unused

    Reason      - process attach/detach or thread attach/detach

    Reserved    - if DLL_PROCESS_ATTACH, NULL means DLL is being dynamically
                  loaded, else static. For DLL_PROCESS_DETACH, NULL means DLL
                  is being freed as a consequence of call to FreeLibrary()
                  else the DLL is being freed as part of process termination

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Failed to initialize

--*/

{
    if (Reason != DLL_PROCESS_ATTACH) {

        DEBUG_ENTER((DBG_DLL,
                     Bool,
                     "DllMain",
                     "%#x, %s, %#x",
                     DllHandle,
                     (Reason == DLL_PROCESS_ATTACH) ? "DLL_PROCESS_ATTACH"
                     : (Reason == DLL_PROCESS_DETACH) ? "DLL_PROCESS_DETACH"
                     : (Reason == DLL_THREAD_ATTACH) ? "DLL_THREAD_ATTACH"
                     : (Reason == DLL_THREAD_DETACH) ? "DLL_THREAD_DETACH"
                     : "?",
                     Reserved
                     ));

    }

    DWORD error;

    //
    // perform global dll initialization, if any.
    //
    switch (Reason) {
    case DLL_PROCESS_ATTACH:
        INITIALIZE_DEBUG_REGKEY();
        INITIALIZE_MEMORY_MANAGER();

        GlobalDllHandle = DllHandle;
        GlobalPlatformType = PlatformType(&GlobalPlatformVersion5);

        if (!GeneralInitCritSec.Init())
        {
            return FALSE;
        }
        
        if (!g_pAsyncCount)
        {
            g_pAsyncCount = New CAsyncCount();

            if (!g_pAsyncCount)
                return FALSE;
        }

        INET_DEBUG_START();

        if (!GlobalDllInitialize() || !InternetCreateThreadInfo(TRUE))
        {
            return FALSE;
        }

        DEBUG_ENTER((DBG_DLL,
                     Bool,
                     "DllMain",
                     "%#x, %s, %#x",
                     DllHandle,
                     (Reason == DLL_PROCESS_ATTACH) ? "DLL_PROCESS_ATTACH"
                     : (Reason == DLL_PROCESS_DETACH) ? "DLL_PROCESS_DETACH"
                     : (Reason == DLL_THREAD_ATTACH) ? "DLL_THREAD_ATTACH"
                     : (Reason == DLL_THREAD_DETACH) ? "DLL_THREAD_DETACH"
                     : "?",
                     Reserved
                     ));

        // LOG_EVENT(WINHTTP_INFO, "WinHttp5 loaded");

        DEBUG_LEAVE(TRUE);

        break;

    case DLL_PROCESS_DETACH:

        // LOG_EVENT(WINHTTP_INFO, "WinHttp5 unloaded");
        
        //
        // signal to all APIs (and any other function that might have an
        // interest) that the DLL is being shutdown
        //

        GlobalDynaUnload = (Reserved == NULL) ? TRUE : FALSE;
        InDllCleanup = TRUE;

        DEBUG_PRINT(DLL,
                    INFO,
                    ("DLL Terminated\n"
                    ));

        DEBUG_LEAVE(TRUE);

        if (GlobalDynaUnload) {
            if (GlobalDataInitialized) {
                GlobalDataTerminate();
            }
            GlobalDllTerminate();
            InternetTerminateThreadInfo();
        }

        PERF_DUMP();

        PERF_END();

        //TERMINATE_DEBUG_MEMORY(FALSE);
        INET_DEBUG_FINISH();
        TERMINATE_DEBUG_REGKEY();

        //InternetDestroyThreadInfo();

        if (g_pAsyncCount)
        {
            delete g_pAsyncCount;
            g_pAsyncCount = NULL;
        }

        TERMINATE_MEMORY_MANAGER(TRUE);

        GeneralInitCritSec.FreeLock();
        break;

    case DLL_THREAD_DETACH:

        //
        // kill the INTERNET_THREAD_INFO
        //

        DEBUG_LEAVE(TRUE);

        InternetDestroyThreadInfo();
        break;

    case DLL_THREAD_ATTACH:

        //
        // we do nothing for thread attach - if we need an INTERNET_THREAD_INFO
        // then it gets created by the function which realises we need one
        //

        AllowCAP();

        DEBUG_LEAVE(TRUE);

        break;
    }

    return TRUE;
}



//////////////////////////////////////////////////////////////////////////
//
// Autoregistration entry points
//
//////////////////////////////////////////////////////////////////////////
HRESULT RegisterTypeLib()
{
    ITypeLib *  pTypeLib;
    char        szPath[MAX_PATH];
    OLECHAR     wszPath[MAX_PATH];
    HRESULT     hr;

    GetModuleFileName(GlobalDllHandle, szPath, MAX_PATH);
    
    MultiByteToWideChar(CP_ACP, 0, szPath, -1, wszPath, MAX_PATH);

    hr = LoadTypeLib(wszPath, &pTypeLib);

    if (SUCCEEDED(hr))
    {
        hr = ::RegisterTypeLib(pTypeLib, wszPath, NULL);
        
        pTypeLib->Release();
    }

    if (FAILED(hr))
    {
        hr = SELFREG_E_TYPELIB;
    }

    return hr;
}

HRESULT UnregisterTypeLib()
{
    ITypeLib *  pTypeLib;
    TLIBATTR *  pTLibAttr;
    char        szPath[MAX_PATH];
    OLECHAR     wszPath[MAX_PATH];
    HRESULT     hr = NOERROR;


    GetModuleFileName(GlobalDllHandle, szPath, MAX_PATH);
    
    MultiByteToWideChar(CP_ACP, 0, szPath, -1, wszPath, MAX_PATH);

    hr = LoadTypeLib(wszPath, &pTypeLib);

    if (SUCCEEDED(hr))
    {
        hr = pTypeLib->GetLibAttr(&pTLibAttr);

        if (SUCCEEDED(hr))
        {
            hr = ::UnRegisterTypeLib(pTLibAttr->guid, pTLibAttr->wMajorVerNum,
                        pTLibAttr->wMinorVerNum,
                        pTLibAttr->lcid,
                        pTLibAttr->syskind);

            pTypeLib->ReleaseTLibAttr(pTLibAttr);
        }

        pTypeLib->Release();
    }

    return hr;
}


HRESULT CallRegInstall(LPSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, achREGINSTALL);

        if (pfnri)
        {
            hr = pfnri(GlobalDllHandle, szSection, NULL);
        }

        FreeLibrary(hinstAdvPack);
    }

    return hr;
}


STDAPI DllRegisterServer()
{

    HRESULT hr;
    
    hr = CallRegInstall("Reg");

    if (SUCCEEDED(hr))
    {
        hr = RegisterTypeLib();
    }

    return hr;
}



STDAPI DllUnregisterServer()
{
    HRESULT hr;

    UnregisterTypeLib();

    hr = CallRegInstall("Unreg");

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\handles\autoprox.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    autoprox.cxx

Abstract:

    Contains class implementation for auto-proxy DLLs which can extent WININET's
        abilities (logic) for deciding what proxies to use.

    How auto-proxy works:
        By offloading requests to a specialized Win32 Thread which picks
        up queued up message requests for Queries, Shutdown, and Initialization


    Contents:
        AUTO_PROXY_ASYNC_MSG

Author:

    Arthur L Bierer (arthurbi) 17-Dec-1996

Revision History:

    17-Dec-1996 arthurbi
        Created

--*/

#include <wininetp.h>



AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN INTERNET_SCHEME isUrlScheme,
    IN LPSTR lpszUrl,
    IN LPSTR lpszUrlHostName,
    IN DWORD dwUrlHostNameLength
    )
{
    URL_COMPONENTS urlComponents;

    Initalize();

    if ( lpszUrl )
    {
        _lpszUrl      = lpszUrl;
        _dwUrlLength  = lstrlen(lpszUrl);
        _tUrlProtocol = isUrlScheme;
        _pmProxyQuery = PROXY_MSG_GET_PROXY_INFO;
        _pmaAllocMode = MSG_ALLOC_STACK_ONLY;

        memset(&urlComponents, 0, sizeof(urlComponents));
        urlComponents.dwStructSize = sizeof(urlComponents);
        urlComponents.lpszHostName = lpszUrlHostName;
        urlComponents.dwHostNameLength = dwUrlHostNameLength;

        //
        // parse out the host name and port. The host name will be decoded; the
        // original URL will not be modified
        //

        if (WinHttpCrackUrlA(lpszUrl, 0, ICU_DECODE, &urlComponents))
        {
           _nUrlPort            = urlComponents.nPort;
           _lpszUrlHostName     = urlComponents.lpszHostName;
           _dwUrlHostNameLength = urlComponents.dwHostNameLength;

           if ( _tUrlProtocol == INTERNET_SCHEME_UNKNOWN )
           {
               _tUrlProtocol = urlComponents.nScheme;
           }

        }
        else
        {
            _Error = GetLastError();
        }
    }
    else
    {
        _Error = ERROR_NOT_ENOUGH_MEMORY;
    }
}

AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN INTERNET_SCHEME isUrlScheme,
    IN LPSTR lpszUrlHostName,
    IN DWORD dwUrlHostNameLength
    )
{

    Initalize();

    _tUrlProtocol = isUrlScheme;
    _pmProxyQuery = PROXY_MSG_GET_PROXY_INFO;
    _pmaAllocMode = MSG_ALLOC_STACK_ONLY;
    _lpszUrlHostName     = lpszUrlHostName;
    _dwUrlHostNameLength = dwUrlHostNameLength;
}

AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN INTERNET_SCHEME isUrlScheme,
    IN LPSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN LPSTR lpszUrlHostName,
    IN DWORD dwUrlHostNameLength,
    IN INTERNET_PORT nUrlPort
    )
{
    Initalize();

    _tUrlProtocol        = isUrlScheme;
    _pmProxyQuery        = PROXY_MSG_GET_PROXY_INFO;
    _pmaAllocMode        = MSG_ALLOC_STACK_ONLY;
    _nUrlPort            = nUrlPort;
    _lpszUrlHostName     = lpszUrlHostName;
    _dwUrlHostNameLength = dwUrlHostNameLength;
    _lpszUrl             = lpszUrl;
    _dwUrlLength         = dwUrlLength;

}

VOID
AUTO_PROXY_ASYNC_MSG::SetProxyMsg(
    IN INTERNET_SCHEME isUrlScheme,
    IN LPSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN LPSTR lpszUrlHostName,
    IN DWORD dwUrlHostNameLength,
    IN INTERNET_PORT nUrlPort
    )
{
    _tUrlProtocol        = isUrlScheme;
    _pmProxyQuery        = PROXY_MSG_GET_PROXY_INFO;
    _pmaAllocMode        = MSG_ALLOC_STACK_ONLY;
    _nUrlPort            = nUrlPort;
    _lpszUrlHostName     = lpszUrlHostName;
    _dwUrlHostNameLength = dwUrlHostNameLength;
    _lpszUrl             = lpszUrl;
    _dwUrlLength         = dwUrlLength;
}


AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN PROXY_MESSAGE_TYPE pmProxyQuery
    )
{
    Initalize();

    _pmaAllocMode = MSG_ALLOC_HEAP_MSG_OBJ_OWNS;
    _pmProxyQuery = pmProxyQuery;
}

AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN AUTO_PROXY_ASYNC_MSG *pStaticAutoProxy
    )
{
    Initalize();

    _tUrlProtocol          = pStaticAutoProxy->_tUrlProtocol;
    _lpszUrl               = (pStaticAutoProxy->_lpszUrl) ? NewString(pStaticAutoProxy->_lpszUrl) : NULL;
    _dwUrlLength           = pStaticAutoProxy->_dwUrlLength;
    _lpszUrlHostName       =
                (pStaticAutoProxy->_lpszUrlHostName ) ?
                NewString(pStaticAutoProxy->_lpszUrlHostName, pStaticAutoProxy->_dwUrlHostNameLength) :
                NULL;
    _dwUrlHostNameLength   = pStaticAutoProxy->_dwUrlHostNameLength;
    _nUrlPort              = pStaticAutoProxy->_nUrlPort;
    _tProxyScheme          = pStaticAutoProxy->_tProxyScheme;

    //
    // ProxyHostName is something that is generated by the request,
    //   therefore it should not be copied OR freed.
    //

    INET_ASSERT( pStaticAutoProxy->_lpszProxyHostName == NULL );
    //_lpszProxyHostName     = (pStaticAutoProxy->_lpszProxyHostName ) ? NewString(pStaticAutoProxy->_lpszProxyHostName) : NULL;


    _dwProxyHostNameLength = pStaticAutoProxy->_dwProxyHostNameLength;
    _nProxyHostPort        = pStaticAutoProxy->_nProxyHostPort;
    _pmProxyQuery          = pStaticAutoProxy->_pmProxyQuery;
    _pmaAllocMode          = MSG_ALLOC_HEAP_MSG_OBJ_OWNS;
    _pProxyState           = pStaticAutoProxy->_pProxyState;

    INET_ASSERT(_pProxyState == NULL);

    _dwQueryResult         = pStaticAutoProxy->_dwQueryResult;
    _Error                 = pStaticAutoProxy->_Error;
    _MessageFlags.Dword    = pStaticAutoProxy->_MessageFlags.Dword;
    _dwProxyVersion        = pStaticAutoProxy->_dwProxyVersion;
}

AUTO_PROXY_ASYNC_MSG::~AUTO_PROXY_ASYNC_MSG(
    VOID
    )
{
    DEBUG_ENTER((DBG_OBJECTS,
                None,
                "~AUTO_PROXY_ASYNC_MSG",
                NULL
                ));

    if ( IsAlloced() )
    {
        DEBUG_PRINT(OBJECTS,
                    INFO,
                    ("Freeing Allocated MSG ptr=%x\n",
                    this
                    ));


        if ( _lpszUrl )
        {
            //DEBUG_PRINT(OBJECTS,
            //            INFO,
            //            ("Url ptr=%x, %q\n",
            //            _lpszUrl,
            //            _lpszUrl
            //            ));

            FREE_MEMORY(_lpszUrl);
        }

        if ( _lpszUrlHostName )
        {
            FREE_MEMORY(_lpszUrlHostName);
        }


        if ( _pProxyState )
        {
            delete _pProxyState;
        }
    }
    if (_bFreeProxyHostName && (_lpszProxyHostName != NULL)) {
        FREE_MEMORY(_lpszProxyHostName);
    }

    DEBUG_LEAVE(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\debug\perfdiag.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    perfdiag.cxx

Abstract:

    Performance diagnostics

    Contents:
        WininetPerfLog
        PerfSleep
        PerfSelect
        PerfWaitForSingleObject
        (CPerfDiag::get_next_record)
        CPerfDiag::CPerfDiag
        CPerfDiag::~CPerfDiag
        CPerfDiag::Log(DWORD, DWORD)
        CPerfDiag::Log(DWORD, DWORD, DWORD, HINTERNET)
        CPerfDiag::Log(DWORD, DWORD, DWORD, DWORD, HINTERNET)
        CPerfDiag::Dump
        (map_perf_event)
        (map_callback_status)
        (map_async_request)
        (map_thread_pri)
        (map_length)

Author:

    Richard L Firth (rfirth) 24-Jan-1997

Revision History:

    24-Jan-1997 rfirth
        Created

--*/

#include <wininetp.h>

#if defined(USE_PERF_DIAG)

#include <perfdiag.hxx>

//
// global data
//

GLOBAL CPerfDiag * GlobalPerfDiag = NULL;
GLOBAL BOOL GlobalDumpPerfToFile = TRUE;

//
// private prototypes
//

PRIVATE LPSTR map_perf_event(DWORD dwEvent);
PRIVATE LPSTR map_callback_status(DWORD dwStatus);
PRIVATE LPSTR map_async_request(DWORD dwRequest);
PRIVATE LPSTR map_thread_pri(DWORD dwPriority);
PRIVATE LPSTR map_length(DWORD dwLength, LPSTR lpBuf);

//
// APIs
//

INTERNETAPI
VOID
WINAPI
WininetPerfLog(
    IN DWORD dwEvent,
    IN DWORD dwInfo1,
    IN DWORD dwInfo2,
    IN HINTERNET hInternet
    ) {
    if (!GlobalPerfDiag) {
        GlobalPerfDiag = New CPerfDiag;
    }
    if (GlobalPerfDiag) {
        GlobalPerfDiag->Log(dwEvent, dwInfo1, dwInfo2, GetCurrentThreadId(), hInternet);
    }
}

//
// functions
//

VOID PerfSleep(DWORD dwMilliseconds) {
    PERF_LOG(PE_YIELD_SLEEP_START);
    Sleep(dwMilliseconds);
    PERF_LOG(PE_YIELD_SLEEP_END);
}

int PerfSelect(int nfds,	
    fd_set FAR * readfds,	
    fd_set FAR * writefds,	
    fd_set FAR * exceptfds,	
    const struct timeval FAR * timeout 	
    ) {
    PERF_LOG(PE_YIELD_SELECT_START);

    int n = _I_select(nfds, readfds, writefds, exceptfds, timeout);

    PERF_LOG(PE_YIELD_SELECT_END);
    return n;
}

DWORD PerfWaitForSingleObject(
    HANDLE hObject,
    DWORD dwTimeout
    ) {
    PERF_LOG(PE_YIELD_OBJECT_WAIT_START);

    DWORD result = WaitForSingleObject(hObject, dwTimeout);

    PERF_LOG(PE_YIELD_OBJECT_WAIT_END);

    return result;
}

//
// private methods
//

LPPERF_INFO CPerfDiag::get_next_record(VOID) {

    if (!m_lpbPerfBuffer || m_bFull) {
        return NULL;
    }

    LPBYTE lpbCurrent;
    LPBYTE lpbNext;
    LPBYTE result;

    do {
        lpbCurrent = m_lpbNext;
        lpbNext = lpbCurrent + sizeof(PERF_INFO);
        result = (LPBYTE)InterlockedExchangePointer((PVOID*)&m_lpbNext, lpbNext);
    } while ((result != (LPBYTE)lpbCurrent) && (lpbCurrent < m_lpbEnd));
    if (lpbCurrent >= m_lpbEnd) {
        m_bFull = TRUE;
        OutputDebugString("*** Wininet performance log is full!\n");
        lpbCurrent = NULL;
    }
    return (LPPERF_INFO)lpbCurrent;
}

//
// public methods
//

CPerfDiag::CPerfDiag() {
    m_lpbPerfBuffer = NULL;
    m_dwPerfBufferLen = 0;
    m_lpbEnd = NULL;
    m_lpbNext = NULL;
    m_bFull = FALSE;
    m_bStarted = FALSE;
    m_bStartFinished = FALSE;
    m_liStartTime.QuadPart = 0i64;
    perf_start();
}

CPerfDiag::~CPerfDiag() {
    free_perf_buffer();
}

VOID CPerfDiag::Log(DWORD dwEvent, DWORD dwInfo) {

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo) {
        Log(dwEvent, dwInfo, 0, lpThreadInfo->ThreadId, lpThreadInfo->hObject);
    }
}

VOID CPerfDiag::Log(DWORD dwEvent, DWORD dwInfo, DWORD dwThreadId, HINTERNET hInternet) {
    Log(dwEvent, dwInfo, 0, dwThreadId, hInternet);
}

VOID CPerfDiag::Log(DWORD dwEvent, DWORD dwInfo, DWORD dwInfo2, DWORD dwThreadId, HINTERNET hInternet) {

    //if (!m_bStarted) {
    //    perf_start();
    //}

    LPPERF_INFO lpInfo = get_next_record();

    if (!lpInfo) {
        return;
    }

    lpInfo->hInternet = hInternet;
    lpInfo->dwThreadId = dwThreadId;
    lpInfo->dwThreadPriority = GetThreadPriority(GetCurrentThread());
    lpInfo->dwEvent = dwEvent;
    lpInfo->dwInfo = dwInfo;
    lpInfo->dwInfo2 = dwInfo2;
    get_time(lpInfo);
}

VOID CPerfDiag::Dump(VOID) {

    HANDLE hFile = INVALID_HANDLE_VALUE;
    static const char PerfFileName[] = "WININET.PRF";

    if (GlobalDumpPerfToFile) {
        hFile = CreateFile((LPCSTR)PerfFileName,
                           GENERIC_WRITE,
                           FILE_SHARE_READ,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           INVALID_HANDLE_VALUE
                           );
        if (hFile == INVALID_HANDLE_VALUE) {
            OutputDebugString("failed to create perf file ");
            OutputDebugString((LPCSTR)PerfFileName);
            OutputDebugString("\n");
            GlobalDumpPerfToFile = FALSE;
        }
    }

    LARGE_INTEGER liFrequency;
    LONGLONG div1;
    LONGLONG div2;

    QueryPerformanceFrequency(&liFrequency);
    div1 = liFrequency.QuadPart;
    div2 = div1 / 1000000;

    LPPERF_INFO lpInfo;
    int record = 1;

    for (lpInfo = (LPPERF_INFO)m_lpbPerfBuffer; lpInfo != (LPPERF_INFO)m_lpbNext; ++lpInfo) {

        char buf[1024];
        LONGLONG ticks;
        DWORD microseconds;
        DWORD seconds;
        DWORD minutes;

        ticks = lpInfo->liTime.QuadPart - m_liStartTime.QuadPart;
        seconds = (DWORD)(ticks / div1);
        microseconds = (DWORD)((ticks % div1) / div2);

        //
        // don't understand why I have to do this? Win95 only (you could have guessed)
        // rounding error?
        //

        while (microseconds >= 1000000) {
            microseconds -= 1000000;
            ++seconds;
        }
        minutes = seconds / 60;
        seconds = seconds % 60;

        char lenbuf[32];
        char lenbuf2[32];

        int nChars = wsprintf(buf,
                              "%5d: Delta=%.2d:%.2d.%.6d TID=%08x Pri=%-8s hReq=%06x Info=%08x %-24s %-22s %s\r\n",
                              record,
                              minutes,
                              seconds,
                              microseconds,
                              lpInfo->dwThreadId,
                              map_thread_pri(lpInfo->dwThreadPriority),
                              lpInfo->hInternet,
                              lpInfo->dwInfo,
                              map_perf_event(lpInfo->dwEvent),
                              ((lpInfo->dwEvent == PE_APP_CALLBACK_START)
                              || (lpInfo->dwEvent == PE_APP_CALLBACK_END))
                                 ? map_callback_status(lpInfo->dwInfo)
                              : (((lpInfo->dwEvent == PE_WORKER_REQUEST_START)
                              || (lpInfo->dwEvent == PE_WORKER_REQUEST_END)
                              || (lpInfo->dwEvent == PE_CLIENT_REQUEST_START)
                              || (lpInfo->dwEvent == PE_CLIENT_REQUEST_END)
                              || (lpInfo->dwEvent == PE_CLIENT_REQUEST_QUEUED))
                                 ? map_async_request(lpInfo->dwInfo)
                              : (((lpInfo->dwEvent == PE_SEND_END)
                              || (lpInfo->dwEvent == PE_RECEIVE_END))
                                 ? map_length(lpInfo->dwInfo2, lenbuf)
                              : (((lpInfo->dwEvent == PE_ENTER_PATH)
                              || (lpInfo->dwEvent == PE_LEAVE_PATH)
                              || (lpInfo->dwEvent == PE_TRACE_PATH))
                                 ? (LPSTR)lpInfo->dwInfo2
                                 : ""))),
                              (((lpInfo->dwEvent == PE_CLIENT_REQUEST_END)
                              || (lpInfo->dwEvent == PE_WORKER_REQUEST_END))
                              && ((lpInfo->dwInfo == AR_INTERNET_READ_FILE)
                              || (lpInfo->dwInfo == AR_INTERNET_QUERY_DATA_AVAILABLE)))
                                 ? map_length(lpInfo->dwInfo2, lenbuf2)
                                 : ""
                             );
        if (GlobalDumpPerfToFile) {

            DWORD nWritten;

            WriteFile(hFile, buf, nChars, &nWritten, NULL);
        } else {
            OutputDebugString(buf);
        }
        ++record;
    }
    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }
}


PRIVATE LPSTR map_perf_event(DWORD dwEvent) {
    switch (dwEvent) {
    case PE_START:                      return "START";
    case PE_END:                        return "END";
    case PE_CLIENT_REQUEST_START:       return "CLIENT_REQUEST_START";
    case PE_CLIENT_REQUEST_END:         return "CLIENT_REQUEST_END";
    case PE_CLIENT_REQUEST_QUEUED:      return "CLIENT_REQUEST_QUEUED";
    case PE_WORKER_REQUEST_START:       return "WORKER_REQUEST_START";
    case PE_WORKER_REQUEST_END:         return "WORKER_REQUEST_END";
    case PE_APP_CALLBACK_START:         return "APP_CALLBACK_START";
    case PE_APP_CALLBACK_END:           return "APP_CALLBACK_END";
    case PE_NAMERES_START:              return "NAMERES_START";
    case PE_NAMERES_END:                return "NAMERES_END";
    case PE_CONNECT_START:              return "CONNECT_START";
    case PE_CONNECT_END:                return "CONNECT_END";
    case PE_SEND_START:                 return "SEND_START";
    case PE_SEND_END:                   return "SEND_END";
    case PE_RECEIVE_START:              return "RECEIVE_START";
    case PE_RECEIVE_END:                return "RECEIVE_END";
    case PE_PEEK_RECEIVE_START:         return "PEEK_RECEIVE_START";
    case PE_PEEK_RECEIVE_END:           return "PEEK_RECEIVE_END";
    case PE_SOCKET_CLOSE_START:         return "SOCKET_CLOSE_START";
    case PE_SOCKET_CLOSE_END:           return "SOCKET_CLOSE_END";
    case PE_ACQUIRE_KEEP_ALIVE:         return "ACQUIRE_KEEP_ALIVE";
    case PE_RELEASE_KEEP_ALIVE:         return "RELEASE_KEEP_ALIVE";
    case PE_SOCKET_ERROR:               return "SOCKET_ERROR";
    case PE_CACHE_READ_CHECK_START:     return "CACHE_READ_CHECK_START";
    case PE_CACHE_READ_CHECK_END:       return "CACHE_READ_CHECK_END";
    case PE_CACHE_WRITE_CHECK_START:    return "CACHE_WRITE_CHECK_START";
    case PE_CACHE_WRITE_CHECK_END:      return "CACHE_WRITE_CHECK_END";
    case PE_CACHE_RETRIEVE_START:       return "CACHE_RETRIEVE_START";
    case PE_CACHE_RETRIEVE_END:         return "CACHE_RETRIEVE_END";
    case PE_CACHE_READ_START:           return "CACHE_READ_START";
    case PE_CACHE_READ_END:             return "CACHE_READ_END";
    case PE_CACHE_WRITE_START:          return "CACHE_WRITE_START";
    case PE_CACHE_WRITE_END:            return "CACHE_WRITE_END";
    case PE_CACHE_CREATE_FILE_START:    return "CACHE_CREATE_FILE_START";
    case PE_CACHE_CREATE_FILE_END:      return "CACHE_CREATE_FILE_END";
    case PE_CACHE_CLOSE_FILE_START:     return "CACHE_CLOSE_FILE_START";
    case PE_CACHE_CLOSE_FILE_END:       return "CACHE_CLOSE_FILE_END";
    case PE_CACHE_EXPIRY_CHECK_START:   return "CACHE_EXPIRY_CHECK_START";
    case PE_CACHE_EXPIRY_CHECK_END:     return "CACHE_EXPIRY_CHECK_END";
    case PE_YIELD_SELECT_START:         return "YIELD_SELECT_START";
    case PE_YIELD_SELECT_END:           return "YIELD_SELECT_END";
    case PE_YIELD_OBJECT_WAIT_START:    return "YIELD_OBJECT_WAIT_START";
    case PE_YIELD_OBJECT_WAIT_END:      return "YIELD_OBJECT_WAIT_END";
    case PE_YIELD_SLEEP_START:          return "YIELD_SLEEP_START";
    case PE_YIELD_SLEEP_END:            return "YIELD_SLEEP_END";
    case PE_TRACE:                      return "TRACE";
    case PE_ENTER_PATH:                 return "ENTER_PATH";
    case PE_LEAVE_PATH:                 return "LEAVE_PATH";
    case PE_TRACE_PATH:                 return "TRACE_PATH";
    }
    return "?";
}

PRIVATE LPSTR map_callback_status(DWORD dwStatus) {
    switch (dwStatus) {
    case WINHTTP_CALLBACK_STATUS_RESOLVING_NAME:        return "RESOLVING_NAME";
    case WINHTTP_CALLBACK_STATUS_NAME_RESOLVED:         return "NAME_RESOLVED";
    case WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER:  return "CONNECTING_TO_SERVER";
    case WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER:   return "CONNECTED_TO_SERVER";
    case WINHTTP_CALLBACK_STATUS_SENDING_REQUEST:       return "SENDING_REQUEST";
    case WINHTTP_CALLBACK_STATUS_REQUEST_SENT:          return "REQUEST_SENT";
    case WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE:    return "RECEIVING_RESPONSE";
    case WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED:     return "RESPONSE_RECEIVED";
    case WINHTTP_CALLBACK_STATUS_CTL_RESPONSE_RECEIVED: return "CTL_RESPONSE_RECEIVED";
    case WINHTTP_CALLBACK_STATUS_PREFETCH:              return "PREFETCH";
    case WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION:    return "CLOSING_CONNECTION";
    case WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED:     return "CONNECTION_CLOSED";
    case WINHTTP_CALLBACK_STATUS_HANDLE_CREATED:        return "HANDLE_CREATED";
    case WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING:        return "HANDLE_CLOSING";
    case WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE:      return "REQUEST_COMPLETE";
    case WINHTTP_CALLBACK_STATUS_REDIRECT:              return "REDIRECT";
    case WINHTTP_CALLBACK_STATUS_STATE_CHANGE:          return "STATE_CHANGE";
    case WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE:     return "HEADERS_AVAILABLE";
    case WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE:        return "DATA_AVAILABLE";
    case WINHTTP_CALLBACK_STATUS_READ_COMPLETE:         return "READ_COMPLETE";
    case WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE:        return "WRITE_COMPLETE";
    case WINHTTP_CALLBACK_STATUS_REQUEST_ERROR:         return "REQUEST_ERROR";
    }
    return "?";
}

PRIVATE LPSTR map_async_request(DWORD dwRequest) {
    switch (dwRequest) {
    case AR_INTERNET_CONNECT:               return "InternetConnect";
    case AR_INTERNET_OPEN_URL:              return "InternetOpenUrl";
    case AR_INTERNET_READ_FILE:             return "InternetReadFile";
    case AR_INTERNET_WRITE_FILE:            return "InternetWriteFile";
    case AR_INTERNET_QUERY_DATA_AVAILABLE:  return "InternetQueryDataAvailable";
    case AR_INTERNET_FIND_NEXT_FILE:        return "InternetFindNextFile";
    case AR_FTP_FIND_FIRST_FILE:            return "FtpFindFirstFile";
    case AR_FTP_GET_FILE:                   return "FtpGetFile";
    case AR_FTP_PUT_FILE:                   return "FtpPutFile";
    case AR_FTP_DELETE_FILE:                return "FtpDeleteFile";
    case AR_FTP_RENAME_FILE:                return "FtpRenameFile";
    case AR_FTP_OPEN_FILE:                  return "FtpOpenFile";
    case AR_FTP_CREATE_DIRECTORY:           return "FtpCreateDirectory";
    case AR_FTP_REMOVE_DIRECTORY:           return "FtpRemoveDirectory";
    case AR_FTP_SET_CURRENT_DIRECTORY:      return "FtpSetCurrentDirectory";
    case AR_FTP_GET_CURRENT_DIRECTORY:      return "FtpGetCurrentDirectory";
    case AR_GOPHER_FIND_FIRST_FILE:         return "GopherFindFirstFile";
    case AR_GOPHER_OPEN_FILE:               return "GopherOpenFile";
    case AR_GOPHER_GET_ATTRIBUTE:           return "GopherGetAttribute";
    case AR_HTTP_SEND_REQUEST:              return "HttpSendRequest";
    case AR_READ_PREFETCH:                  return "READ_PREFETCH";
    case AR_SYNC_EVENT:                     return "SYNC_EVENT";
    case AR_TIMER_EVENT:                    return "TIMER_EVENT";
    }
    return "?";
}

PRIVATE LPSTR map_thread_pri(DWORD dwPriority) {
    switch (dwPriority) {
    case THREAD_PRIORITY_ABOVE_NORMAL:
        return "ABOVE";

    case THREAD_PRIORITY_BELOW_NORMAL:
        return "BELOW";

    case THREAD_PRIORITY_HIGHEST:
        return "HIGHEST";

    case THREAD_PRIORITY_IDLE:
        return "IDLE";

    case THREAD_PRIORITY_LOWEST:
        return "LOWEST";

    case THREAD_PRIORITY_NORMAL:
        return "NORMAL";

    case THREAD_PRIORITY_TIME_CRITICAL:
        return "TIMECRIT";
    }
    return "?";
}

PRIVATE LPSTR map_length(DWORD dwLength, LPSTR lpBuf) {
    wsprintf(lpBuf, "%d", dwLength);
    return lpBuf;
}

#endif // defined(USE_PERF_DIAG)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\handles\connect.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    connect.cxx

Abstract:

    Contains methods for INTERNET_CONNECT_HANDLE_OBJECT class

    Contents:
        RMakeInternetConnectObjectHandle
        INTERNET_CONNECT_HANDLE_OBJECT::INTERNET_CONNECT_HANDLE_OBJECT
        INTERNET_CONNECT_HANDLE_OBJECT::~INTERNET_CONNECT_HANDLE_OBJECT

Author:

    Madan Appiah (madana)  16-Nov-1994

Environment:

    User Mode - Win32

Revision History:

   Sophia Chung (sophiac) 14-Feb-1995 (added FTP and Archie class impl.)
   (code adopted from madana)

--*/

#include <wininetp.h>

//
// functions
//


DWORD
RMakeInternetConnectObjectHandle(
    IN HINTERNET ParentHandle,
    IN OUT HINTERNET * ChildHandle,
    IN LPSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN DWORD dwFlags, // dead
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Creates an INTERNET_CONNECT_HANDLE_OBJECT. Wrapper function callable from
    C code

Arguments:

    ParentHandle    - parent InternetOpen() handle

    ChildHandle     - IN: protocol-specific child handle
                      OUT: address of handle object

    lpszServerName  - pointer to server name

    nServerPort     - server port to connect to

    dwFlags         - various open flags from InternetConnect()

    dwContext       - app-supplied context value to associate with the handle

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DWORD error;
    INTERNET_CONNECT_HANDLE_OBJECT * hConnect;

    hConnect = New INTERNET_CONNECT_HANDLE_OBJECT(
                                (INTERNET_HANDLE_BASE *)ParentHandle,
                                *ChildHandle,
                                lpszServerName,
                                nServerPort,
                                dwFlags,
                                dwContext
                                );

    if (hConnect != NULL) {
        error = hConnect->GetStatus();
        if (error == ERROR_SUCCESS) {

            //
            // inform the app of the new handle
            //

            error = InternetIndicateStatusNewHandle((LPVOID)hConnect);

            //
            // ERROR_WINHTTP_OPERATION_CANCELLED is the only error that we are
            // expecting here. If we get this error then the app has cancelled
            // the operation. Either way, the handle we just generated will be
            // already deleted
            //

            if (error != ERROR_SUCCESS) {

                INET_ASSERT(error == ERROR_WINHTTP_OPERATION_CANCELLED);

                hConnect = NULL;
            }
        } else {
            delete hConnect;
            hConnect = NULL;
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    *ChildHandle = (HINTERNET)hConnect;

    return error;
}


//
// INTERNET_CONNECT_HANDLE_OBJECT class implementation
//


INTERNET_CONNECT_HANDLE_OBJECT::INTERNET_CONNECT_HANDLE_OBJECT(
    INTERNET_CONNECT_HANDLE_OBJECT *InternetConnectObj
    ) : INTERNET_HANDLE_BASE((INTERNET_HANDLE_BASE *)InternetConnectObj)

/*++

Routine Description:

    Constructor that creates a copy of an INTERNET_CONNECT_HANDLE_OBJECT when
    generating a derived handle object, such as a HTTP_REQUEST_HANDLE_OBJECT

Arguments:

    InternetConnectObj  - INTERNET_CONNECT_HANDLE_OBJECT to copy

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_CONNECT_HANDLE_OBJECT::INTERNET_CONNECT_HANDLE_OBJECT",
                 "%#x",
                 InternetConnectObj
                 ));

    //
    // copy the name objects and server port
    //

    _HostName = InternetConnectObj->_HostName;
    _HostPort = InternetConnectObj->_HostPort;

    //
    // _SchemeType is actual scheme we use. May be different than original
    // object type when going via CERN proxy. Initially set to default (HTTP)
    //

    _SchemeType = InternetConnectObj->_SchemeType;

    DEBUG_LEAVE(0);
}


INTERNET_CONNECT_HANDLE_OBJECT::INTERNET_CONNECT_HANDLE_OBJECT(
    INTERNET_HANDLE_BASE * Parent,
    HINTERNET Child,
    LPTSTR lpszServerName,
    INTERNET_PORT nServerPort,
    DWORD dwFlags,
    DWORD_PTR dwContext
    ) : INTERNET_HANDLE_BASE(Parent)

/*++

Routine Description:

    Constructor for direct-to-net INTERNET_CONNECT_HANDLE_OBJECT

Arguments:

    Parent          - pointer to parent handle (INTERNET_HANDLE_BASE as
                      created by InternetOpen())

    Child           - handle of child object - typically an identifying value
                      for the protocol-specific code

    lpszServerName  - name of the server we are connecting to. May also be the
                      IP address expressed as a string

    nServerPort     - the port number at the server to which we connect

    dwFlags         - creation flags from InternetConnect():

    dwContext       - context value for call-backs

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_CONNECT_HANDLE_OBJECT::INTERNET_CONNECT_HANDLE_OBJECT",
                 "%#x, %#x, %q, %d, %#x, %#x",
                 Parent,
                 Child,
                 lpszServerName,
                 nServerPort,
                 dwFlags,
                 dwContext
                 ));


    // record the parameters, making copies of string buffers
    _HostName = lpszServerName;
    _HostPort = nServerPort;
    SetSchemeType(INTERNET_SCHEME_HTTP);
    SetObjectType(TypeHttpConnectHandle);
    _Context = dwContext;
    _Status = ERROR_SUCCESS; // BUGBUG: what if we fail to allocate _HostName?

    DEBUG_LEAVE(0);
}


INTERNET_CONNECT_HANDLE_OBJECT::~INTERNET_CONNECT_HANDLE_OBJECT(VOID)

/*++

Routine Description:

    Destructor for INTERNET_CONNECT_HANDLE_OBJECT

Arguments:

    None.

Return Value:

    None.

--*/

{
    // Nothing to see here, people; move along!
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\handles\hutil.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    hutil.cxx

Abstract:

    contains outdated c-c++ interface functions

Author:

    Madan Appiah (madana)  16-Nov-1994

Environment:

    User Mode - Win32

Revision History:

   Sophia Chung (sophiac) 14-Feb-1995 (added FTP and Archie class impl.)
   (code adopted from madana)

--*/

#include <wininetp.h>

DWORD
RIsHandleLocal(
    HINTERNET Handle,
    BOOL * IsLocalHandle, // dead
    BOOL * IsAsyncHandle,
    HINTERNET_HANDLE_TYPE ExpectedHandleType
    )
{
    INTERNET_HANDLE_OBJECT* HandleObj = (INTERNET_HANDLE_OBJECT*) Handle;
    DWORD Error = HandleObj->IsValid(ExpectedHandleType);
    if (Error != ERROR_SUCCESS)
        return Error;
    *IsAsyncHandle = HandleObj->IsAsyncHandle();
    return ERROR_SUCCESS;
}


DWORD
RGetHandleType(
    HINTERNET Handle,
    LPHINTERNET_HANDLE_TYPE HandleType
    )
{
    HANDLE_OBJECT *HandleObj = (HANDLE_OBJECT *)Handle;
    DWORD error;

    //
    // validate handle before we use it.
    //

    error = HandleObj->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {

        //
        // find the handle type.
        //

        *HandleType = HandleObj->GetHandleType();
    }
    return error;
}

DWORD
RGetContext(
    HINTERNET hInternet,
    DWORD_PTR *lpdwContext
    )
{
    DWORD error;

    //
    // ensure the handle is valid
    //

    error = ((HANDLE_OBJECT*)hInternet)->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {
        *lpdwContext = ((INTERNET_HANDLE_OBJECT*)hInternet)->GetContext();
    }
    return error;
}

DWORD
RSetContext(
    HINTERNET hInternet,
    DWORD_PTR dwContext
    )
{
    DWORD error;

    //
    // ensure the handle is valid
    //

    error = ((HANDLE_OBJECT*)hInternet)->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {
        ((INTERNET_HANDLE_OBJECT*)hInternet)->SetContext(dwContext);
    }
    return error;
}

DWORD
RGetStatusCallback(
    IN HINTERNET Handle,
    OUT LPWINHTTP_STATUS_CALLBACK lpStatusCallback
    )
{
    //
    // NULL handle should have been caught before we got here
    // (its in WINHTTPQueryOption())
    //

    INET_ASSERT(Handle != NULL);

    *lpStatusCallback = ((INTERNET_HANDLE_OBJECT *)Handle)->GetStatusCallback();
    return ERROR_SUCCESS;
}

DWORD
RExchangeStatusCallback(
    IN HINTERNET Handle,
    IN OUT LPWINHTTP_STATUS_CALLBACK lpStatusCallback,
    IN BOOL fType,
    IN DWORD dwFlags)
{
    DWORD error;

    //
    // NULL handle value should have been caught already
    // (in WINHTTPSetStatusCallback())
    //

    INET_ASSERT(Handle != NULL);

    error = ((HANDLE_OBJECT *)Handle)->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {
        error = ((INTERNET_HANDLE_OBJECT *)Handle)->
                                ExchangeStatusCallback(lpStatusCallback, fType, dwFlags);
    }
    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\handles\proxysup.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    proxysup.cxx

Abstract:

    Contains class implementation for proxy server and proxy bypass list

    Contents:
        IsLocalMacro

        PROXY_SERVER_LIST_ENTRY::WriteEntry

        PROXY_SERVER_LIST::AddList
        PROXY_SERVER_LIST::Find
        PROXY_SERVER_LIST::Add
        PROXY_SERVER_LIST::ProxyScheme
        PROXY_SERVER_LIST::GetProxyHostName
        PROXY_SERVER_LIST::AddToBypassList
        PROXY_SERVER_LIST::GetList

        PROXY_BYPASS_LIST_ENTRY::WriteEntry

        PROXY_BYPASS_LIST::AddList
        PROXY_BYPASS_LIST::Find
        PROXY_BYPASS_LIST::Add
        PROXY_BYPASS_LIST::IsBypassed
        PROXY_BYPASS_LIST::IsHostInBypassList
        PROXY_BYPASS_LIST::GetList

        PROXY_INFO::GetProxyStringInfo
        PROXY_INFO::HostBypassesProxy
        PROXY_INFO::RedoSendRequest
        PROXY_INFO::Terminate
        PROXY_INFO::CleanOutLists

        PROXY_STATE::GetNextProxy

        (GetRegistryProxyParameter)

Author:

    Richard L Firth (rfirth) 03-Feb-1996

Revision History:

    03-Feb-1996 rfirth
        Created

--*/

#include <wininetp.h>

//
// private manifests
//

#define DEFAULT_PROXY_BUFFER_LENGTH     (4 K)
#define MAX_IP_ADDRESS_STRING_LENGTH    (4 * 4 - 1) // ###.###.###.###
#define PROXY_REGISTRY_STRING_LENGTH    (4 K)

//
// private types
//

typedef enum {
    STATE_START,
    STATE_PROTOCOL,
    STATE_SCHEME,
    STATE_SERVER,
    STATE_PORT,
    STATE_END,
    STATE_ERROR
} PARSER_STATE;


//
// private prototypes
//

PRIVATE
LPSTR
GetRegistryProxyParameter(
    IN LPSTR lpszParameterName
    );





//
// functions
//


BOOL
IsLocalMacro(
    IN LPSTR lpszMetaName,
    IN DWORD dwMetaNameLength
    )

/*++

Routine Description:

    Checks for local macro name

Arguments:

    lpszMetaName        - name to check

    dwMetaNameLength    - length

Return Value:

    BOOL
        TRUE    - it is <local>

        FALSE   - not

--*/

{
    INET_ASSERT(lpszMetaName != NULL);

    static const char s_local[] = "<local>";

    return (strnicmp(s_local, lpszMetaName, dwMetaNameLength) == 0);
}


//
// member functions
//


BOOL
PROXY_SERVER_LIST_ENTRY::WriteEntry(
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Writes this proxy server list entry as a string in the supplied buffer

Arguments:

    lpszBuffer          - pointer to buffer where string is written

    lpdwBufferLength    - IN: amount of space in buffer
                          OUT: number of bytes copied, or required size

Return Value:

    BOOL
        TRUE    - entry written to buffer

        FALSE   - entry not written to buffer - *lpdwBufferLength contains
                  required size

--*/

{
    DWORD requiredLength;
    LPSTR protocolName;
    DWORD protocolNameLength;
    LPSTR schemeName;
    DWORD schemeNameLength;
    INTERNET_PORT magnitude = 1;

    protocolName = MapUrlScheme(_Protocol, &protocolNameLength);
    if (protocolName != NULL) {
        requiredLength = protocolNameLength + 1;    // for '='
    } else {
        requiredLength = 0;
    }
    schemeName = MapUrlScheme(_Scheme, &schemeNameLength);
    if (schemeName != NULL) {
        requiredLength += schemeNameLength + sizeof("://") - 1;
    }
    requiredLength += _ProxyName.StringLength();
    if (_ProxyPort != INTERNET_INVALID_PORT_NUMBER) {
        for (INTERNET_PORT n = 10000, i = 5; n > 0; n /= 10, --i) {
            if (_ProxyPort / n) {
                requiredLength += i + 1;    // for ':'
                magnitude = n;
                break;
            }
        }
    }

    BOOL success;

    if (*lpdwBufferLength > requiredLength) {
        if (protocolName != NULL) {
            memcpy(lpszBuffer, protocolName, protocolNameLength);
            lpszBuffer += protocolNameLength;
            *lpszBuffer++ = '=';
        }
        if (schemeName != NULL) {
            memcpy(lpszBuffer, schemeName, schemeNameLength);
            lpszBuffer += schemeNameLength;
            memcpy(lpszBuffer, "://", sizeof("://") - 1);
            lpszBuffer += sizeof("://") - 1;
        }
        _ProxyName.CopyTo(lpszBuffer);
        lpszBuffer += _ProxyName.StringLength();
        if (_ProxyPort != INTERNET_INVALID_PORT_NUMBER) {
            *lpszBuffer++ = ':';
            for (INTERNET_PORT n = _ProxyPort, i = magnitude; i; i /= 10) {
                *lpszBuffer++ = (char)(n / i) + '0';
                n %= i;
            }
        }
        success = TRUE;
    } else {
        success = FALSE;
    }
    *lpdwBufferLength = requiredLength;
    return success;
}


DWORD
PROXY_SERVER_LIST::AddList(
    IN LPSTR lpszList
    )

/*++

Routine Description:

    Parses a list of proxy servers and creates a PROXY_SERVER_LIST_ENTRY for
    each one

Arguments:

    lpszList    - pointer to list of proxies of the form:

                    [<scheme>=][<scheme>"://"]<server>[":"<port>][";"*]

                  The list can be NULL, in which case we read it from the
                  registry

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    At least one entry in lpszList is bogus

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "PROXY_SERVER_LIST::AddList",
                "%.80q",
                lpszList
                ));

    DWORD entryLength;
    LPSTR protocolName;
    DWORD protocolLength;
    LPSTR schemeName;
    DWORD schemeLength;
    LPSTR serverName;
    DWORD serverLength;
    PARSER_STATE state;
    DWORD nSlashes;
    INTERNET_PORT port;
    BOOL done;

    entryLength = 0;
    protocolName = lpszList;
    protocolLength = 0;
    schemeName = NULL;
    schemeLength = 0;
    serverName = NULL;
    serverLength = 0;
    state = STATE_PROTOCOL;
    nSlashes = 0;
    port = 0;
    done = FALSE;

    //
    // walk the list, pulling out the various scheme parts
    //

    do {

        char ch = *lpszList++;

        if ((nSlashes == 1) && (ch != '/')) {
            state = STATE_ERROR;
            break;
        }

        switch (ch) {
        case '=':
            if ((state == STATE_PROTOCOL) && (entryLength != 0)) {
                protocolLength = entryLength;
                entryLength = 0;
                state = STATE_SCHEME;
                schemeName = lpszList;
            } else {

                //
                // '=' can't legally appear anywhere else
                //

                state = STATE_ERROR;
            }
            break;

        case ':':
            switch (state) {
            case STATE_PROTOCOL:
                if (*lpszList == '/') {
                    schemeName = protocolName;
                    protocolName = NULL;
                    schemeLength = entryLength;
                    protocolLength = 0;
                    state = STATE_SCHEME;
                } else if (*lpszList != '\0') {
                    serverName = protocolName;
                    serverLength = entryLength;
                    state = STATE_PORT;
                } else {
                    state = STATE_ERROR;
                }
                entryLength = 0;
                break;

            case STATE_SCHEME:
                if (*lpszList == '/') {
                    schemeLength = entryLength;
                } else if (*lpszList != '\0') {
                    serverName = schemeName;
                    serverLength = entryLength;
                    state = STATE_PORT;
                } else {
                    state = STATE_ERROR;
                }
                entryLength = 0;
                break;

            case STATE_SERVER:
                serverLength = entryLength;
                state = STATE_PORT;
                entryLength = 0;
                break;

            default:
                state = STATE_ERROR;
                break;
            }
            break;

        case '/':
            if ((state == STATE_SCHEME) && (nSlashes < 2) && (entryLength == 0)) {
                if (++nSlashes == 2) {
                    state = STATE_SERVER;
                    serverName = lpszList;
                }
            } else {
                state = STATE_ERROR;
            }
            break;

        default:
            if (state != STATE_PORT) {
                ++entryLength;
            } else if (isdigit(ch)) {

                //
                // BUGBUG - we will overflow if >65535
                //

                port = port * 10 + (ch - '0');
            } else {

                //
                // STATE_PORT && non-digit character - error
                //

                state = STATE_ERROR;
            }
            break;

        case '\0':
            done = TRUE;

            //
            // fall through
            //

        case '\t':
        case '\n':
        case '\v':  // vertical tab, 0x0b
        case '\f':  // form feed, 0x0c
        case '\r':
        case ' ':
        case ';':
        case ',':
            if (serverLength == 0) {
                serverLength = entryLength;
            }
            if (serverLength != 0) {
                if (serverName == NULL) {
                    serverName = (schemeName != NULL)
                        ? schemeName
                        : protocolName;
                }

                INET_ASSERT(serverName != NULL);

                INTERNET_SCHEME protocol;

                if (protocolLength != 0) {
                    protocol = MapUrlSchemeName(protocolName, protocolLength);
                } else {
                    protocol = INTERNET_SCHEME_DEFAULT;
                }

                INTERNET_SCHEME scheme;

                if (schemeLength != 0) {
                    scheme = MapUrlSchemeName(schemeName, schemeLength);
                } else {
                    scheme = INTERNET_SCHEME_DEFAULT;
                }

                //
                // add an entry if this is a protocol we handle and we don't
                // already have an entry for it
                //

                if ((protocol != INTERNET_SCHEME_UNKNOWN)
                && (scheme != INTERNET_SCHEME_UNKNOWN)

                //
                // we can only currently handle CERN (secure or unsecure) and
                // FTP proxies, so kick out anything that wants to go via any
                // other proxy scheme
                //

                && ((scheme == INTERNET_SCHEME_DEFAULT)
                || (scheme == INTERNET_SCHEME_HTTP)
                || (scheme == INTERNET_SCHEME_HTTPS))) {
                    if (!Find(protocol)) {

                        //
                        // don't worry if Add() fails - we just continue
                        //

                        Add(protocol, scheme, serverName, serverLength, port);
                    }
                }
            }
            entryLength = 0;
            protocolName = lpszList;
            protocolLength = 0;
            schemeName = NULL;
            schemeLength = 0;
            serverName = NULL;
            serverLength = 0;
            nSlashes = 0;
            port = 0;
            state = STATE_PROTOCOL;
            break;
        }
        if (state == STATE_ERROR) {
            break;
        }
    } while (!done);

    DWORD error;

    if (state == STATE_ERROR) {
        error = ERROR_INVALID_PARAMETER;
    } else {
        error = ERROR_SUCCESS;
    }

    DEBUG_LEAVE(error);

    return error;
}


BOOL
PROXY_SERVER_LIST::Find(
    IN INTERNET_SCHEME tScheme
    )

/*++

Routine Description:

    Find a PROXY_SERVER_LIST_ENTRY based on the scheme

Arguments:

    tScheme - protocol scheme to find

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Bool,
                "PROXY_SERVER_LIST::Find",
                "%s",
                InternetMapScheme(tScheme)
                ));

    BOOL found = FALSE;

    if (!LockSerializedList(&_List))
        goto quit;

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_SERVER_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_SERVER_LIST_ENTRY, _List);

        if (info->_Protocol == tScheme) {
            found = TRUE;
            break;
        }
    }

    UnlockSerializedList(&_List);

quit:
    DEBUG_LEAVE(found);

    return found;
}


DWORD
PROXY_SERVER_LIST::Add(
    IN INTERNET_SCHEME tProtocol,
    IN INTERNET_SCHEME tScheme,
    IN LPSTR lpszHostName,
    IN DWORD dwHostNameLength,
    IN INTERNET_PORT nPort
    )

/*++

Routine Description:

    Create an add a PROXY_SERVER_LIST_ENTRY to the PROXY_SERVER_LIST

Arguments:

    tProtocol           - protocol which uses the proxy

    tScheme             - scheme used to talk to the proxy

    lpszHostName        - proxy host name

    dwHostNameLength    - length of proxy host name

    nPort               - port at proxy host

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "PROXY_SERVER_LIST::Add",
                "%s, %s, %.*q, %d, %d",
                InternetMapScheme(tProtocol),
                InternetMapScheme(tScheme),
                dwHostNameLength,
                lpszHostName,
                dwHostNameLength,
                nPort
                ));

    PROXY_SERVER_LIST_ENTRY * entry;

    entry = New PROXY_SERVER_LIST_ENTRY(tProtocol,
                                        tScheme,
                                        lpszHostName,
                                        dwHostNameLength,
                                        nPort
                                        );

    DWORD error = ERROR_SUCCESS;

    if (entry != NULL) {
        //error = entry->ResolveAddress();
        //if (error == ERROR_SUCCESS) {
        //    InsertAtTailOfSerializedList(&_List, &entry->_List);
        //}
        if (entry->_Protocol == INTERNET_SCHEME_DEFAULT) {
            if (!InsertAtTailOfSerializedList(&_List, &entry->_List)) {
                delete entry;
                error = ERROR_NOT_ENOUGH_MEMORY;
            }
        } else {
            if (!InsertAtHeadOfSerializedList(&_List, &entry->_List)) {
                delete entry;
                error = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    DEBUG_LEAVE(error);

    return error;
}


INTERNET_SCHEME
PROXY_SERVER_LIST::ProxyScheme(
    IN INTERNET_SCHEME tProtocol
    )

/*++

Routine Description:

    Determines protocol over which tScheme goes through proxy

Arguments:

    tProtocol   - protocol scheme used to retrieve data (e.g. FTP)

Return Value:

    INTERNET_SCHEME
        Success - scheme by which protocol goes via proxy

        Failure - INTERNET_SCHEME_UNKNOWN
--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Int,
                "PROXY_SERVER_LIST::ProxyScheme",
                "%s",
                InternetMapScheme(tProtocol)
                ));

    INTERNET_SCHEME tScheme = INTERNET_SCHEME_UNKNOWN;

    if (!LockSerializedList(&_List))
        goto quit;

    //
    // the list really shouldn't be empty if we're here
    //

    INET_ASSERT(!IsSerializedListEmpty(&_List));

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_SERVER_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_SERVER_LIST_ENTRY, _List);

        //
        // if we find a match for the protocol, or this protocol is handled by
        // the default proxy entry then we are done
        //

        if ((info->_Protocol == tProtocol)
        || (info->_Protocol == INTERNET_SCHEME_DEFAULT)) {
            tScheme = info->_Scheme;

            //
            // the default scheme is HTTP (CERN proxy)
            //

            if (tScheme == INTERNET_SCHEME_DEFAULT) {
                tScheme = INTERNET_SCHEME_HTTP;
            }
            break;
        }
    }

    UnlockSerializedList(&_List);

quit:
    DEBUG_LEAVE(tScheme);

    return tScheme;
}


BOOL
PROXY_SERVER_LIST::GetProxyHostName(
    IN INTERNET_SCHEME tProtocol,
    IN OUT LPINTERNET_SCHEME lptScheme,
    OUT LPSTR * lplpszHostName,
    OUT LPBOOL lpbFreeHostName,
    OUT LPDWORD lpdwHostNameLength,
    OUT LPINTERNET_PORT lpHostPort
    )

/*++

Routine Description:

    Given a protocol, map it to the proxy we use to retrieve the data

Arguments:

    tProtocol           - protocol to map (e.g. find the proxy for FTP)

    lptScheme           - IN: preferred scheme if INTERNET_SCHEME_DEFAULT
                          OUT: returned scheme

    lplpszHostName      - pointer to returned pointer to host name

    lpbFreeHostName     - returned TRUE if *lplpszHostName allocated

    lpdwHostNameLength  - pointer to returned host name length

    lpHostPort          - pointer to returned host port

Return Value:

    BOOL
        TRUE    - requested info has been returned

        FALSE   - requested info was not found

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Bool,
                 "PROXY_SERVER_LIST::GetProxyHostName",
                 "%s, %#x, %#x, %#x, %#x, %#x",
                 InternetMapScheme(tProtocol),
                 lptScheme,
                 lplpszHostName,
                 lpbFreeHostName,
                 lpdwHostNameLength,
                 lpHostPort
                 ));

    INET_ASSERT(tProtocol != INTERNET_SCHEME_UNKNOWN);

    //
    // *lptScheme must now be one of the recognized schemes, or the default
    //

    INET_ASSERT((*lptScheme == INTERNET_SCHEME_DEFAULT)
                || (*lptScheme == INTERNET_SCHEME_HTTP)
                || (*lptScheme == INTERNET_SCHEME_HTTPS)
                || (*lptScheme == INTERNET_SCHEME_SOCKS)
                );

    BOOL found = FALSE;

    if (!LockSerializedList(&_List))
        goto quit;

    //
    // the list really shouldn't be empty if we're here
    //

    INET_ASSERT(!IsSerializedListEmpty(&_List));

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_SERVER_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_SERVER_LIST_ENTRY, _List);

        //
        // if we find a match for the protocol, or this protocol is handled by
        // the default proxy entry then we are done
        //
        // Hack: But make sure its NOT socks since, socks must be
        //  an exact match !!! No defaults.
        //

        if ((info->_Protocol == tProtocol)
        || ((info->_Protocol == INTERNET_SCHEME_DEFAULT)
                && (tProtocol != INTERNET_SCHEME_SOCKS)  )) {

            INTERNET_SCHEME scheme = info->_Scheme;

            //
            // the returned scheme is the input preferred scheme unless it was
            // the default scheme in which case we return HTTP (CERN proxy)
            //

            if (scheme == INTERNET_SCHEME_DEFAULT) {
                scheme = (*lptScheme == INTERNET_SCHEME_DEFAULT)
                            ? INTERNET_SCHEME_HTTP
                            : *lptScheme;
            }
            *lptScheme = scheme;
            *lpbFreeHostName = FALSE;
            *lpdwHostNameLength = 0;
            *lplpszHostName = NewString(info->_ProxyName.StringAddress(),
                                        info->_ProxyName.StringLength()
                                        );
            if (*lplpszHostName != NULL) {
                *lpbFreeHostName = TRUE;
                *lpdwHostNameLength = info->_ProxyName.StringLength();
            }

            INTERNET_PORT port = info->_ProxyPort;

            //
            // map the default port value
            //

            if (port == INTERNET_INVALID_PORT_NUMBER) {
                switch (scheme) {
                case INTERNET_SCHEME_HTTP:
                    port = INTERNET_DEFAULT_HTTP_PORT;
                    break;

                case INTERNET_SCHEME_HTTPS:
                    port = INTERNET_DEFAULT_HTTPS_PORT;
                    break;

                case INTERNET_SCHEME_SOCKS:
                    port = INTERNET_DEFAULT_SOCKS_PORT;
                    break;
                }
            }
            *lpHostPort = port;
            found = TRUE;

            DEBUG_PRINT(PROXY,
                        INFO,
                        ("proxy = %s://%s:%d\n",
                        MapUrlSchemeToName(scheme),
                        info->_ProxyName.StringAddress(),
                        port
                        ));

            break;
        }
    }

    UnlockSerializedList(&_List);

quit:
    DEBUG_LEAVE(found);

    return found;
}


DWORD
PROXY_SERVER_LIST::AddToBypassList(
    IN PROXY_BYPASS_LIST * lpBypassList
    )

/*++

Routine Description:

    For all proxy servers in the server list, we add the details to the bypass
    list. By default, an app mustn't send a request to the proxy via the proxy!
    Additionally, the app should not have to specifically nominate the proxy
    server(s) as bypassing the proxy

Arguments:

    lpBypassList    - pointer to bypass proxy list where proxy servers will be
                      added

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DWORD error = ERROR_SUCCESS;
    PLIST_ENTRY entry = HeadOfSerializedList(&_List);

    while ((entry != (PLIST_ENTRY)SlSelf(&_List)) && (error == ERROR_SUCCESS)) {

        PROXY_SERVER_LIST_ENTRY * info = (PROXY_SERVER_LIST_ENTRY *)entry;

        if (!lpBypassList->Find(info->_Scheme,
                                info->_ProxyName.StringAddress(),
                                info->_ProxyName.StringLength(),
                                info->_ProxyPort)) {
            error = lpBypassList->Add(info->_Scheme,
                                      info->_ProxyName.StringAddress(),
                                      info->_ProxyName.StringLength(),
                                      info->_ProxyPort
                                      );
        }
        entry = entry->Flink;
    }
    return error;
}


VOID
PROXY_SERVER_LIST::GetList(
    OUT LPSTR * lplpszList,
    IN DWORD dwBufferLength,
    IN OUT LPDWORD lpdwRequiredLength
    )

/*++

Routine Description:

    Writes the list of proxy servers to a buffer, and/or returns the required
    buffer length

Arguments:

    lplpszList          - pointer to pointer to buffer where list is written, if
                          sufficient space

    dwBufferLength      - amount of space in *lplpszList

    lpdwRequiredLength  - OUT: cumulative size of data

Return Value:

    None.

--*/

{
    LPSTR lpszList = *lplpszList;
    BOOL firstTime = TRUE;
    BOOL outOfBuffer = FALSE;

    if (!LockSerializedList(&_List))
        return;

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_SERVER_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_SERVER_LIST_ENTRY, _List);
        if (!firstTime) {

            //
            // write delimiter if enough space
            //

            if (dwBufferLength >= 1) {
                *lpszList++ = ' ';
                --dwBufferLength;
            }
            ++*lpdwRequiredLength;
        } else {
            firstTime = FALSE;
        }

        //
        // find the length of the current entry & write it to the buffer if
        // enough space
        //

        DWORD length = dwBufferLength;

        info->WriteEntry(lpszList, &length);
        if (dwBufferLength >= length) {

            //
            // we wrote it
            //

            dwBufferLength -= length;
        } else {

            //
            // no buffer left
            //

            dwBufferLength = 0;
            outOfBuffer = TRUE;
        }
        *lpdwRequiredLength += length;
        lpszList += length;
    }

    if (!outOfBuffer) {
        if (dwBufferLength > 0) {
            *lpszList++ = '\0';
            *lplpszList = lpszList;
        }
    }

    //
    // add 1 for the terminating NUL
    //

    ++*lpdwRequiredLength;

    UnlockSerializedList(&_List);
}


BOOL
PROXY_BYPASS_LIST_ENTRY::WriteEntry(
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Writes this proxy bypass list entry as a string in the supplied buffer

Arguments:

    lpszBuffer          - pointer to buffer where string is written

    lpdwBufferLength    - IN: amount of space in buffer
                          OUT: number of bytes copied, or required size

Return Value:

    BOOL
        TRUE    - entry written to buffer

        FALSE   - entry not written to buffer - *lpdwBufferLength contains
                  required size

--*/

{
    DWORD requiredLength;
    LPSTR schemeName;
    DWORD schemeNameLength;
    INTERNET_PORT magnitude = 1;

    if (_Scheme != INTERNET_SCHEME_DEFAULT) {
        schemeName = MapUrlScheme(_Scheme, &schemeNameLength);
        requiredLength = schemeNameLength + sizeof("://") - 1;
    } else {
        schemeName = NULL;
        requiredLength = 0;
    }
    if (IsLocal()) {
        requiredLength += sizeof("<local>") - 1;
    } else {
        requiredLength += _Name.StringLength();
    }
    if (_Port != INTERNET_INVALID_PORT_NUMBER) {
        for (INTERNET_PORT n = 10000, i = 5; n > 0; n /= 10, --i) {
            if (_Port / n) {
                requiredLength += i + 1;
                magnitude = n;
                break;
            }
        }
    }

    BOOL success;

    if (*lpdwBufferLength > requiredLength) {
        if (schemeName != NULL) {
            memcpy(lpszBuffer, schemeName, schemeNameLength);
            lpszBuffer += schemeNameLength;
            memcpy(lpszBuffer, "://", sizeof("://") - 1);
            lpszBuffer += sizeof("://") - 1;
        }
        if (IsLocal()) {
            memcpy(lpszBuffer, "<local>", sizeof("<local>") - 1);
            lpszBuffer += sizeof("<local>") - 1;
        } else {
            _Name.CopyTo(lpszBuffer);
            lpszBuffer += _Name.StringLength();
        }
        if (_Port != INTERNET_INVALID_PORT_NUMBER) {
            *lpszBuffer++ = ':';
            for (INTERNET_PORT n = _Port, i = magnitude; i; i /= 10) {
                *lpszBuffer++ = (char)(n / i) + '0';
                n %= i;
            }
        }
        success = TRUE;
    } else {
        success = FALSE;
    }
    *lpdwBufferLength = requiredLength;
    return success;
}


DWORD
PROXY_BYPASS_LIST::AddList(
    IN LPSTR lpszList
    )

/*++

Routine Description:

    Parses a list of proxy bypass specifiers and adds them to the list

Arguments:

    lpszList    - pointer to string containing list of proxy bypass specifiers.
                  The format is:

                    [<scheme>"://"][<server>][":"<port>"]

                  The list can be NULL, in which case we read it from the
                  registry

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "PROXY_BYPASS_LIST::AddList",
                "%.80q",
                lpszList
                ));

    DWORD entryLength;
    LPSTR schemeName;
    DWORD schemeLength;
    LPSTR serverName;
    DWORD serverLength;
    PARSER_STATE state;
    DWORD nSlashes;
    INTERNET_PORT port;
    BOOL done;

    entryLength = 0;
    schemeName = lpszList;
    schemeLength = 0;
    serverName = NULL;
    serverLength = 0;
    state = STATE_SCHEME;
    nSlashes = 0;
    port = 0;
    done = FALSE;

    //
    // walk the list, pulling out the various scheme parts
    //

    do {

        char ch = *lpszList++;

        if ((nSlashes == 1) && (ch != '/')) {
            state = STATE_ERROR;
            break;
        }

        switch (ch) {
        case ':':
            switch (state) {
            case STATE_SCHEME:
                if (*lpszList == '/') {
                    schemeLength = entryLength;
                } else if (*lpszList != '\0') {
                    serverName = schemeName;
                    serverLength = entryLength;
                    if (serverLength == 0) {
                        serverLength = 1;
                        serverName = "*";
                    }
                    state = STATE_PORT;
                } else {
                    state = STATE_ERROR;
                }
                entryLength = 0;
                break;

            case STATE_SERVER:
                serverLength = entryLength;
                state = STATE_PORT;
                entryLength = 0;
                break;

            default:
                state = STATE_ERROR;
                break;
            }
            break;

        case '/':
            if ((state == STATE_SCHEME) && (nSlashes < 2) && (entryLength == 0)) {
                if (++nSlashes == 2) {
                    state = STATE_SERVER;
                    serverName = lpszList;
                }
            } else {
                state = STATE_ERROR;
            }
            break;

        default:
            if (state != STATE_PORT) {
                ++entryLength;
            } else if (isdigit(ch)) {

                //
                // BUGBUG - we will overflow if >65535
                //

                port = port * 10 + (ch - '0');
            } else {

                //
                // STATE_PORT && non-digit character - error
                //

                state = STATE_ERROR;
            }
            break;

        case '\0':
            done = TRUE;

            //
            // fall through
            //

        case '\t':
        case '\n':
        case '\v':  // vertical tab, 0x0b
        case '\f':  // form feed, 0x0c
        case '\r':
        case ' ':
        case ';':
        case ',':
            if (serverLength == 0) {
                serverLength = entryLength;
                if ((serverLength == 0)
                && ((state == STATE_SERVER) || (state == STATE_PORT))) {

                    //
                    // we found e.g. "http://" or "http://:80". We allow this as
                    // "http://*" or "http://*:80"
                    //

                    serverLength = 1;
                    serverName = "*";
                }
            }
            if (serverLength != 0) {
                if (serverName == NULL) {
                    serverName = schemeName;
                }

                INTERNET_SCHEME scheme;

                if (schemeLength != 0) {
                    scheme = MapUrlSchemeName(schemeName, schemeLength);
                } else {
                    scheme = INTERNET_SCHEME_DEFAULT;
                }

                //
                // add an entry if this is a protocol we handle and we don't
                // already have an entry for it
                //

                if ((scheme != INTERNET_SCHEME_UNKNOWN)
                && !Find(scheme, serverName, serverLength, port)) {

                    //
                    // don't worry if Add() fails - we just continue
                    //

                    Add(scheme, serverName, serverLength, port);
                }
            }
            entryLength = 0;
            schemeName = lpszList;
            schemeLength = 0;
            serverName = NULL;
            serverLength = 0;
            nSlashes = 0;
            port = 0;
            state = STATE_SCHEME;
            break;
        }
        if (state == STATE_ERROR) {
            break;
        }
    } while (!done);

    DWORD error;

    if (state == STATE_ERROR) {
        error = ERROR_INVALID_PARAMETER;
    } else {
        error = ERROR_SUCCESS;
    }

    DEBUG_LEAVE(error);

    return error;
}


BOOL
PROXY_BYPASS_LIST::Find(
    IN INTERNET_SCHEME tScheme,
    IN LPSTR lpszHostName OPTIONAL,
    IN DWORD dwHostNameLength,
    IN INTERNET_PORT nPort
    )

/*++

Routine Description:

    Determines if a proxy bypass entry matches the criteria.

    Currently, name matching is simplistic: e.g. "*.com" and "**.com" are
    treated as 2 separate strings, where we should collapse multiple wildcard
    specifiers, etc. Also: "w*" should replace "ww*", etc.

Arguments:

    tScheme             - scheme for this entry

    lpszHostName        - host name or address. May contain wildcards (*)

    dwHostNameLength    - length of host name or address

    nPort               - port

Return Value:

    BOOL
        TRUE    - an entry corresponding to the arguments was found

        FALSE   - didn't find entry

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Bool,
                "PROXY_BYPASS_LIST::Find",
                "%s, %.*q, %d, %d",
                InternetMapScheme(tScheme),
                dwHostNameLength,
                lpszHostName,
                dwHostNameLength,
                nPort
                ));

    BOOL isLocal = IsLocalMacro(lpszHostName, dwHostNameLength);
    BOOL found = FALSE;

    if (!LockSerializedList(&_List))
        goto quit;

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_BYPASS_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_BYPASS_LIST_ENTRY, _List);

        //
        // do the easy bits first
        //

        if (!((info->_Scheme == tScheme)
        || (info->_Scheme == INTERNET_SCHEME_DEFAULT))) {
            continue;
        }
        if (!((info->_Port == nPort)
        || (info->_Port == INTERNET_INVALID_PORT_NUMBER))) {
            continue;
        }

        //
        // check for name match
        //

        if (info->_LocalSemantics) {
            if (isLocal) {
                found = TRUE;
                break;
            } else {
                continue;
            }
        }

        //
        // not local semantics, have to match target
        //

        //
        // BUGBUG - we only do simplistic matching. If the strings don't match
        //          exactly, except for case, they are deemed to be different
        //

        if (info->_Name.Strnicmp(lpszHostName, (int)dwHostNameLength) != 0) {
            continue;
        }

        //
        // any path that didn't continue, or has not already broken out has
        // succeeded in finding a match
        //

        DEBUG_PRINT(PROXY,
                    INFO,
                    ("Matched: %q, %q\n",
                    lpszHostName,
                    info->_Name.StringAddress()
                    ));

        found = TRUE;
        break;
    }

    UnlockSerializedList(&_List);

quit:
    DEBUG_LEAVE(found);

    return found;
}


DWORD
PROXY_BYPASS_LIST::Add(
    IN INTERNET_SCHEME tScheme,
    IN LPSTR lpszHostName,
    IN DWORD dwHostNameLength,
    IN INTERNET_PORT nPort
    )

/*++

Routine Description:

    Create and add a PROXY_BYPASS_LIST_ENTRY to the PROXY_BYPASS_LIST

Arguments:

    tScheme             - scheme to bypass. May be 0 meaning any protocol

    lpszHostName        - name of host to bypass. May be name or IP address and
                          may contain wildcard characters

    dwHostNameLength    - length of bypass name string

    nPort               - port to bypass. May be 0, meaning any port

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "PROXY_BYPASS_LIST::Add",
                "%s, %.*q, %d, %d",
                InternetMapScheme(tScheme),
                dwHostNameLength,
                lpszHostName,
                dwHostNameLength,
                nPort
                ));

    PROXY_BYPASS_LIST_ENTRY * entry;

    entry = New PROXY_BYPASS_LIST_ENTRY(tScheme,
                                        lpszHostName,
                                        dwHostNameLength,
                                        nPort
                                        );

    DWORD error = ERROR_SUCCESS;

    if (entry != NULL) {

        //
        // if the bypass entry uses local name matching semantics, then we add
        // it to the end of the list, else the head. The reason we do this is
        // to allow <local> to be a default after all other (possibly also
        // local) entries are checked
        //

        if (entry->IsLocal()) {
            if (!InsertAtTailOfSerializedList(&_List, &entry->_List)) {
                delete entry;
                error = ERROR_NOT_ENOUGH_MEMORY;
            }
        } else {
            if (!InsertAtHeadOfSerializedList(&_List, &entry->_List)) {
                delete entry;
                error = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    DEBUG_LEAVE(error);

    return error;
}


BOOL
PROXY_BYPASS_LIST::IsBypassed(
    IN INTERNET_HANDLE_OBJECT* pSessionObject,
    IN INTERNET_SCHEME tScheme,
    IN LPSTR lpszHostName,
    IN DWORD dwHostNameLength,
    IN INTERNET_PORT nPort
    )

/*++

Routine Description:

    Determines if a scheme/name/port is bypassed

Arguments:

    tScheme             - can be 0, meaning match any scheme

    lpszHostName        - can contain wildcards. May be name or IP address

    dwHostNameLength    - length of name/address part. May be 0, meaning match
                          any name/address

    nPort               - can be 0, meaning match any port

Return Value:

    BOOL
        TRUE    - an entry on the bypass list matched the criteria

        FALSE   - the host identified by the parameters is not on this bypass
                  list

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Bool,
                "PROXY_BYPASS_LIST::IsBypassed",
                "%s, %.*q, %d, %d",
                InternetMapScheme(tScheme),
                dwHostNameLength,
                lpszHostName,
                dwHostNameLength,
                nPort
                ));

    INET_ASSERT(lpszHostName != NULL);
    INET_ASSERT(dwHostNameLength != 0);

    //
    // determine if what we were given is an address, in which case we don't
    // perform <local> semantics matching
    //

    BOOL isAddress = FALSE;
    LPSTR mappedName = NULL;
    LPSTR allocedName = NULL;

    if (dwHostNameLength <= MAX_IP_ADDRESS_STRING_LENGTH) {

        char addressBuffer[MAX_IP_ADDRESS_STRING_LENGTH + 1];

        //
        // make the host name/address an ASCIIZ string
        //

        memcpy((LPVOID)addressBuffer, (LPVOID)lpszHostName, dwHostNameLength);
        addressBuffer[dwHostNameLength] = '\0';
        if (_I_inet_addr(addressBuffer) != INADDR_NONE) {

            //
            // looks like we were given an IP address
            //

            //
            // maybe this is the IP address of a known server (in cache)
            //

            mappedName = MapNetAddressToName(pSessionObject, addressBuffer, &allocedName);
            if (mappedName == addressBuffer) {

                //
                // BUGBUG - transport independence?
                //

                isAddress = TRUE;
            } else {
                lpszHostName = mappedName;
                dwHostNameLength = lstrlen(lpszHostName);
            }
        }
    }

    BOOL found;
    found = IsHostInBypassList (
                tScheme,
                lpszHostName,
                dwHostNameLength,
                nPort,
                isAddress);

    if (allocedName != NULL) {

        allocedName = (LPSTR)FREE_MEMORY(allocedName);
        INET_ASSERT(allocedName == NULL);
    }

    DEBUG_LEAVE(found);
    return found;
}


BOOL
PROXY_BYPASS_LIST::IsHostInBypassList(
    IN INTERNET_SCHEME tScheme,
    IN LPSTR lpszHostName,
    IN DWORD dwHostNameLength,
    IN INTERNET_PORT nPort,
    IN BOOL isAddress
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    tScheme             -
    lpszHostName        -
    dwHostNameLength    -
    nPort               -
    isAddress           -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Bool,
                 "PROXY_BYPASS_LIST::IsHostInBypassList",
                 "%d (%s), %.*q, %d, %d, %B",
                 tScheme,
                 InternetMapScheme(tScheme),
                 dwHostNameLength,
                 lpszHostName,
                 dwHostNameLength,
                 nPort,
                 isAddress
                 ));

    BOOL found = FALSE;

    //
    // if not an address, determine if the name contains at least one dot
    //

    BOOL isDot;

    if (!isAddress) {
        isDot = FALSE;
        for (DWORD i = 0; i < dwHostNameLength; ++i) {
            if (lpszHostName[i] == '.') {
                isDot = TRUE;
                break;
            }
        }
    } else {

        //
        // addresses have dots
        //

        isDot = TRUE;
    }

    if (!LockSerializedList(&_List))
        goto quit;

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_BYPASS_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_BYPASS_LIST_ENTRY, _List);

        //
        // do the easy bits first
        //

        if (!((info->_Scheme == tScheme)
        || (info->_Scheme == INTERNET_SCHEME_DEFAULT))) {
            continue;
        }
        if (!((info->_Port == nPort)
        || (info->_Port == INTERNET_INVALID_PORT_NUMBER))) {
            continue;
        }

        //
        // check local semantics
        //

        if (info->_LocalSemantics) {
            if (!isDot) {

                DEBUG_PRINT(PROXY,
                            INFO,
                            ("%q matched by <local>\n",
                            lpszHostName
                            ));

                found = TRUE;

                //
                // <local> is in the bypass list and the name does not contain a
                // dot. It bypasses the proxy
                //

                break;
            } else {

                //
                // the name contains a dot, but it may be matched by another
                // proxy bypass entry
                //

                continue;
            }
        }

        //
        // check for name match. Note that we take no special action if the host
        // name contains wildcard characters
        //

        LPSTR target = info->_Name.StringAddress();

        //
        // NULL target name matches any server name/address
        //

        if (target != NULL) {

            DEBUG_PRINT(PROXY,
                        INFO,
                        ("trying to match %q with %q\n",
                        lpszHostName,
                        target
                        ));

            DWORD i = 0;
            DWORD j = 0;
            DWORD i_back = (DWORD)-1;

            while ((target[i] != '\0') && (j < dwHostNameLength)) {
                if (target[i] == tolower(lpszHostName[j])) {
                    ++i;
                    ++j;
                } else if (target[i] == '*') {
                    while (target[i + 1] == '*') {
                        ++i;
                    }
                    i_back = i;
                    ++i;
                    while ((tolower(lpszHostName[j]) != target[i])
                    && (j < dwHostNameLength)) {
                        ++j;
                    }
                } else if (i_back != (DWORD)-1) {

                    //
                    // '*' is greedy closure. We already saw a '*' but later we
                    // discovered a mismatch. We will go back and try to eat as
                    // many characters as we can till the next match, or we hit
                    // the end of the string
                    //

                    i = i_back;
                } else {

                    //
                    // no match; quit
                    //

                    j = 0;
                    break;
                }

                //
                // if we reached the end of the target, but not the host name
                // AND we already met a '*' then back up
                //

                if ((target[i] == '\0')
                && (j != dwHostNameLength)
                && (i_back != (DWORD)-1)) {
                    i = i_back;
                }
            }

            //
            // if we hit the end of the host name while matching any character,
            // bump the target to the next non-star character
            //

            while (target[i] == '*') {
                ++i;
            }

            //
            // the host name matched if we reached the end of the target and end
            // of the host name
            //

            if (!((target[i] == '\0') && (j == dwHostNameLength))) {
                continue;
            }
        }

        //
        // any path that didn't continue, or has not already broken out has
        // succeeded in finding a match
        //

        DEBUG_PRINT(PROXY,
                    INFO,
                    ("Matched: %q, %q\n",
                    lpszHostName,
                    target
                    ));

        found = TRUE;
        break;
    }

    UnlockSerializedList(&_List);


    //
    // "localhost", "loopback" and "127.0.0.1" always bypass proxy
    //

    if (!found)
    {
        if ((strnicmp(lpszHostName, "localhost", dwHostNameLength) == 0) ||
            (strnicmp(lpszHostName, "loopback", dwHostNameLength) == 0))
        {
            found = TRUE;
        }
        else //
             // if the host name length is of reasonable size, it may represent
             // the IP address of loopback (127.0.0.1 or its variations).
             //
             if (dwHostNameLength < 16) 
        {
            static ULONG ipAddr127_0_0_1 = INADDR_NONE;
            char         szHostName[16];

            INET_ASSERT(dwHostNameLength < 16);

            lstrcpyn(szHostName,
                lpszHostName,
                (dwHostNameLength + 1) // must add in "+1" for the NULL char
                );

            //
            // convert "127.0.0.1" to a DWORD once, and save it.
            //
            if (ipAddr127_0_0_1 == INADDR_NONE)
            {
                ipAddr127_0_0_1 = _I_inet_addr("127.0.0.1");
                INET_ASSERT(ipAddr127_0_0_1 != INADDR_NONE);
            }

            found = (_I_inet_addr(szHostName) == ipAddr127_0_0_1);
        }
    }

quit:
    DEBUG_LEAVE(found);

    return found;
}


VOID
PROXY_BYPASS_LIST::GetList(
    OUT LPSTR * lplpszList,
    IN DWORD dwBufferLength,
    IN OUT LPDWORD lpdwRequiredLength
    )

/*++

Routine Description:

    Writes the list of proxy bypass servers to a buffer, and/or returns the
    required buffer length

Arguments:

    lplpszList          - pointer to pointer to buffer where list is written, if
                          sufficient space

    dwBufferLength      - amount of space in *lplpszList

    lpdwRequiredLength  - OUT: cumulative size of data

Return Value:

    None.
--*/

{
    LPSTR lpszList = *lplpszList;
    BOOL firstTime = TRUE;
    BOOL outOfBuffer = FALSE;

    if (!LockSerializedList(&_List))
        return;

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_BYPASS_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_BYPASS_LIST_ENTRY, _List);
        if (!firstTime) {

            //
            // write delimiter if enough space
            //

            if (dwBufferLength >= 1) {
                *lpszList++ = ' ';
                --dwBufferLength;
            }
            ++*lpdwRequiredLength;
        } else {
            firstTime = FALSE;
        }

        //
        // find the length of the current entry & write it to the buffer if
        // enough space
        //

        DWORD length = dwBufferLength;

        info->WriteEntry(lpszList, &length);
        if (dwBufferLength >= length) {

            //
            // we wrote it
            //

            dwBufferLength -= length;
        } else {

            //
            // no buffer left
            //

            dwBufferLength = 0;
            outOfBuffer = TRUE;
        }
        *lpdwRequiredLength += length;
        lpszList += length;
    }

    if (!outOfBuffer) {
        if (dwBufferLength > 0) {
            *lpszList++ = '\0';
            *lplpszList = lpszList;
        }
    }

    //
    // add 1 for the terminating NUL
    //

    ++*lpdwRequiredLength;
    UnlockSerializedList(&_List);
}

//
// PROXY_INFO - methods are defined below
//

VOID 
PROXY_INFO::InitializeProxySettings(
    VOID
    )    

/*++

Routine Description:

    Initalizes Proxy_Info objects

Arguments:

    None.

Return Value:

    None. 

--*/

{
    _ProxyServerList    = NULL;
    _ProxyBypassList    = NULL;
    _fDisableDirect     = FALSE;
    _fModifiedInProcess = FALSE;

    _Lock.Initialize();
    _Error = _Lock.IsInitialized()
                ? ERROR_SUCCESS
                : ERROR_WINHTTP_INTERNAL_ERROR;
}


VOID 
PROXY_INFO::TerminateProxySettings(
    VOID
    )

/*++

Routine Description:

    Cleans up and destroys Proxy_Info objects

Arguments:

    None.

Return Value:

    None. 

--*/

{
    //DEBUG_ENTER((DBG_OBJECTS,
    //             None,
    //             "PROXY_INFO::TerminateProxySettings",
    //             NULL
    //             ));

    Lock(TRUE);
    CleanOutLists();
    Unlock();

    //DEBUG_LEAVE(0);
}




DWORD
PROXY_INFO::SetProxySettings(
    IN LPINTERNET_PROXY_INFO_EX  lpProxySettings,
    IN BOOL fModifiedInProcess
    )

/*++

Routine Description:

    Sets the proxy info. Either creates new proxy server and bypass lists, or
    removes them (proxy to direct)

    Assumes: 1. The parameters have already been validated in the API that calls
                this method (i.e. InternetOpen(), InternetSetOption())

Arguments:

    
    lpProxySettings     - a set of relevent fields describing proxy settings

    fModifiedInProcess  - TRUE, if this object keeps a seperate set of values from those
                            stored in the registry store



Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    The lpszProxy or lpszProxyBypass list was bad

                  ERROR_NOT_ENOUGH_MEMORY
                    Failed to create an object or allocate space for a list,
                    etc.

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO::SetProxySettings",
                 "%x, %B",
                 lpProxySettings,
                 fModifiedInProcess
                 ));

    //
    // parameters should already be validated by caller
    //

    BOOL newList;
    BOOL possibleNewAutoProxy;
    LPCTSTR serverList;
    LPCTSTR bypassList;

    DWORD error = ERROR_SUCCESS;

    serverList = NULL;
    bypassList = NULL;
    newList = FALSE;
    _fModifiedInProcess = fModifiedInProcess;
    _dwSettingsVersion  = lpProxySettings->dwCurrentSettingsVersion;

    UPDATE_GLOBAL_PROXY_VERSION();

    if ( lpProxySettings->dwFlags & PROXY_TYPE_PROXY ) 
    {        
        serverList = lpProxySettings->lpszProxy;
        bypassList = lpProxySettings->lpszProxyBypass;

        if (serverList != NULL) {            
            newList = TRUE;
        }
    }

    //
    // about to start changing contents - acquire lock
    //

    Lock(TRUE);

    // remember disable direct flag...
    SetDisableDirect( (lpProxySettings->dwFlags & PROXY_TYPE_DIRECT) ? FALSE : TRUE  );

    //
    // clear out current contents,
    //

    CleanOutLists();

    //
    // Set the Static Proxy Lists
    //
        
    if (newList) 
    {

        INET_ASSERT((serverList != NULL) && (*serverList != 0));

        _ProxyServerList = New PROXY_SERVER_LIST(serverList);
        _ProxyBypassList = New PROXY_BYPASS_LIST(bypassList);

        if ((_ProxyServerList != NULL) && (_ProxyBypassList != NULL)) {
            _Error = _ProxyServerList->GetError();
            if (_Error == ERROR_SUCCESS) {
                _Error = _ProxyBypassList->GetError();
                if (_Error == ERROR_SUCCESS) {

                    //
                    // add all proxy servers to bypass list
                    //

                    _ProxyServerList->AddToBypassList(_ProxyBypassList);
                }
            }
        } else {
            _Error = ERROR_NOT_ENOUGH_MEMORY;
            CleanOutLists();
        }
        error = _Error;
    }

    //
    // other threads free to access this PROXY_INFO again
    //

    Unlock();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
PROXY_INFO::GetProxySettings(
    OUT LPINTERNET_PROXY_INFO_EX  lpProxySettings,
    IN BOOL fCheckVersion = FALSE
    )

/*++

Routine Description:

    Gets the proxy info. 

    Assumes: 1. The parameters have already been validated in the API that calls
                this method (i.e. InternetOpen(), InternetSetOption())

Arguments:

    
    lpProxySettings     - a set of relevent fields describing proxy settings

    fCheckVersion       - ignored 


Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - 

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO::GetProxySettings",
                 "%x, %B",
                 lpProxySettings,
                 fCheckVersion
                 ));

    DWORD error = ERROR_SUCCESS;

    if ( fCheckVersion == TRUE )
    {
        INET_ASSERT(FALSE);
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // about to start reading contents - acquire lock
    //

    Lock(FALSE);

    if ( ! IsDisableDirect() ) {
        lpProxySettings->dwFlags |= PROXY_TYPE_DIRECT;
    }

    if ( IsProxySettingsConfigured() ) 
    {   
        lpProxySettings->dwFlags |= PROXY_TYPE_PROXY;

        lpProxySettings->lpszProxy       = _ProxyServerList->CopyString();
        lpProxySettings->lpszProxyBypass = _ProxyBypassList->CopyString();

        if ( lpProxySettings->lpszProxy == NULL || 
             lpProxySettings->lpszProxyBypass == NULL )
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    //
    // other threads free to access this PROXY_INFO again
    //

    Unlock();

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
PROXY_INFO::RefreshProxySettings(
    IN BOOL fForceRefresh
    )
/*++

Routine Description:

    Refreshes the Proxy Information

    This doesn't make sense on PROXY_INFO, nothing done

Arguments:

    fForceRefresh - forces a resync of all settings, turning this on slows things down

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - 

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO::RefreshProxySettings",
                 "%B",
                 fForceRefresh
                 ));


    DEBUG_LEAVE(ERROR_SUCCESS);
 
    return ERROR_SUCCESS;
}


DWORD
PROXY_INFO::QueryProxySettings(
    IN AUTO_PROXY_ASYNC_MSG **ppQueryForProxyInfo
    )

/*++

Routine Description:

    Determines what proxy type, proxy name, and port the caller should use
    given an Url, its length, a target host, a target port, and output space
    to store the result.

    The result may be a complete string containing a Netscape style string with
    a delimited set of proxies, and access methods.  An example of this may
    look like:
    "PROXY itgproxy:80; PROXY proxy:80; PROXY 192.168.100.2:1080; SOCKS 192.168.100.2; DIRECT"
    This means we must try itgproxy, if this proxy fails we go on to proxy, and on to 192.168.100.2, etc.
    Note that if itgproxy, proxy, and 192.168.100.2 all fail we can try a SOCKS proxy, and if this fails we
    can try a direct connection.

    If there is an external proxy DLL registered and valid, we defer to it to decide
    what proxy to use, and thus ignore internal proxy information.

    Note this function can also be used to retrive mapping of protocol to proxy.  For example,
    if tUrlProtocol == INTERNET_SCHEME_FTP, the result *lptProxyScheme == INTERNET_SCHEME_SOCKS
    which means we should use a socks proxy/firewall for FTP accesss.

Arguments:

    tScheme             - can be 0, meaning match any scheme

    lpszHostName        - can contain wildcards. May be name or IP address

    nPort               - can be 0, meaning match any port

    pfAutoProxy         - TRUE if an auto-proxy is being used.

Return Value:

    BOOL
        TRUE    - an entry on the bypass list matched the criteria

        FALSE   - the host identified by the parameters is not on this bypass
                  list

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO::QueryProxySettings",
                 "%#X",
                 ppQueryForProxyInfo
                 ));

    AUTO_PROXY_ASYNC_MSG *pQueryForProxyInfo = *ppQueryForProxyInfo;
    INTERNET_SCHEME tProxyScheme = pQueryForProxyInfo->_tUrlProtocol;
    BOOL fIsByPassed = FALSE;
    BOOL fProxyConnect = FALSE;
    
    DWORD error = ERROR_SUCCESS;

    Lock(FALSE);

    if (!IsProxySettingsConfigured())  // virtual func, perhaps replace with faster internal?
    {
        fProxyConnect = FALSE;
        goto quit;
    }

    //
    // Ok, if we're here we are NOT using the Auto-Proxy DLL.
    //  1. Determine if we are Bypassed ( and thus prevented from using a proxy )
    //  2. Map the Protocol to a Proxy type.
    //  3. Grab the hostname of the proxy we wish to use.
    //

    if ( pQueryForProxyInfo->_lpszUrlHostName && pQueryForProxyInfo->_dwUrlHostNameLength > 0 )
    {
        fIsByPassed = IsBypassed(
                        pQueryForProxyInfo->_tUrlProtocol,
                        pQueryForProxyInfo->_lpszUrlHostName,
                        pQueryForProxyInfo->_dwUrlHostNameLength,
                        pQueryForProxyInfo->_nUrlPort
                        );

        if ( fIsByPassed )
        {
            goto quit;
        }
    }

    pQueryForProxyInfo->_tProxyScheme = ProxyScheme(pQueryForProxyInfo->_tUrlProtocol);

    if ( pQueryForProxyInfo->_tProxyScheme == INTERNET_SCHEME_UNKNOWN )
    {
       pQueryForProxyInfo->_tProxyScheme = INTERNET_SCHEME_SOCKS;
       pQueryForProxyInfo->_tUrlProtocol = INTERNET_SCHEME_SOCKS;
    }
    if (pQueryForProxyInfo->_bFreeProxyHostName
        && (pQueryForProxyInfo->_lpszProxyHostName != NULL)) {
        FREE_MEMORY(pQueryForProxyInfo->_lpszProxyHostName);
    }

    fProxyConnect = GetProxyHostName(
                        pQueryForProxyInfo->_tUrlProtocol,
                        &(pQueryForProxyInfo->_tProxyScheme),
                        &(pQueryForProxyInfo->_lpszProxyHostName),
                        &(pQueryForProxyInfo->_bFreeProxyHostName),
                        &(pQueryForProxyInfo->_dwProxyHostNameLength),
                        &(pQueryForProxyInfo->_nProxyHostPort)
                        );

quit:

    pQueryForProxyInfo->_dwQueryResult = (DWORD) fProxyConnect;

    //
    // If we've disabled direct connections, then fail
    //  when there is no proxy
    //

    if ( !fProxyConnect && IsDisableDirect() ) {         
        error = ERROR_WINHTTP_CANNOT_CONNECT;
    }

    Unlock();

    DEBUG_LEAVE(error);

    return error;
}



DWORD
PROXY_INFO::GetProxyStringInfo(
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    IMPORTANT PLEASE READ: LEGACY FUNCTION, this does not support all the new
      proxy behaviors, left here for Wininet compat with older programs

    Returns the proxy server and bypass lists in an INTERNET_PROXY_INFO. Called
    by InternetQueryOption(WINHTTP_OPTION_PROXY)

    Assumes: Access to this is serialized while we are getting this info

Arguments:

    lpBuffer            - pointer to buffer where information will be returned

    lpdwBufferLength    - IN: size of lpBuffer in BYTEs
                          OUT: number of BYTEs returned in lpBuffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    *lpdwBufferLength contains the required buffer length
--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "PROXY_INFO::GetProxyStringInfo",
                "%#x, %#x [%d]",
                lpBuffer,
                lpdwBufferLength,
                *lpdwBufferLength
                ));

    DEBUG_PRINT(PROXY,
                INFO,
                ("Calling Legacy GetProxyStringInfo, NEW CODE SHOULD AVOID THIS CODE PATH\n"
                ));

    DWORD requiredSize = sizeof(WINHTTP_PROXY_INFOA);
    LPSTR lpVariable = (LPSTR)(((WINHTTP_PROXY_INFOA *)lpBuffer) + 1);
    LPSTR lpszProxy;

    Lock(FALSE);

    if (_ProxyServerList != NULL) {
        lpszProxy = lpVariable;
        _ProxyServerList->GetList(&lpVariable,
                                  (*lpdwBufferLength > requiredSize)
                                    ? (*lpdwBufferLength - requiredSize)
                                    : 0,
                                  &requiredSize
                                  );
    } else {
        lpszProxy = NULL;
    }

    LPSTR lpszProxyBypass;

    if (_ProxyBypassList != NULL) {

        DWORD size = requiredSize;

        lpszProxyBypass = lpVariable;
        _ProxyBypassList->GetList(&lpVariable,
                                  (*lpdwBufferLength > requiredSize)
                                    ? (*lpdwBufferLength - requiredSize)
                                    : 0,
                                  &requiredSize
                                  );
        if (requiredSize == size) {
            lpszProxyBypass = NULL;
        }
    } else {
        lpszProxyBypass = NULL;
    }

    DWORD error;

    if (*lpdwBufferLength >= requiredSize) {

        LPINTERNET_PROXY_INFO lpInfo = (LPINTERNET_PROXY_INFO)lpBuffer;

        lpInfo->dwAccessType = (lpszProxy == NULL)
                                    ? INTERNET_OPEN_TYPE_DIRECT
                                    : INTERNET_OPEN_TYPE_PROXY;
        lpInfo->lpszProxy = lpszProxy;
        lpInfo->lpszProxyBypass = lpszProxyBypass;
        error = ERROR_SUCCESS;
    } else {
        error = ERROR_INSUFFICIENT_BUFFER;
    }
    *lpdwBufferLength = requiredSize;

    Unlock();

    DEBUG_LEAVE(error);

    return error;
}


BOOL
PROXY_INFO::RedoSendRequest(
    IN OUT LPDWORD lpdwError,
    IN DWORD dwSecureStatus,
    IN AUTO_PROXY_ASYNC_MSG *pQueryForProxyInfo,
    IN CServerInfo *pOriginServer,
    IN CServerInfo *pProxyServer
    )
/*++

Routine Description:

    Determines whether a connection needs to be retried do to a failed proxy.

Arguments:


    lpdwError   - Error code of connection.

    pProxyState - Pointer to proxy_state returned when acquiring the proxy information.


Return Value:

    LPSTR
        Success - pointer to allocated buffer

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Bool,
                 "PROXY_INFO::RedoSendRequest",
                 "%#x [%d, %d], %#x",
                 lpdwError,
                 lpdwError ? *lpdwError : 0,
                 dwSecureStatus,
                 pQueryForProxyInfo
                 ));

    BOOL fReturn = FALSE;
    PROXY_STATE *pProxyState = NULL;
    DWORD dwVersion;
    LPSTR lpszConnection;
    BOOL fCanCache = FALSE;

    if ( pQueryForProxyInfo )
    {
        pProxyState = pQueryForProxyInfo->_pProxyState;

        //
        // On success,
        //

        if ( *lpdwError == ERROR_SUCCESS )
        {
            if ( pQueryForProxyInfo->IsCanCacheResult() && 
                 pProxyState &&                  
                 pOriginServer &&
                 pProxyServer )
            {
                
                pOriginServer->SetCachedProxyServerInfo(
                    pProxyServer,                    
                    pQueryForProxyInfo->GetVersion(),
                    pQueryForProxyInfo->IsUseProxy(),
                    pQueryForProxyInfo->_tUrlProtocol,
                    pQueryForProxyInfo->_nUrlPort,
                    pQueryForProxyInfo->_tProxyScheme,
                    pQueryForProxyInfo->_nProxyHostPort
                    );
            }
        }
        else if ( *lpdwError != ERROR_SUCCESS &&
                  *lpdwError != ERROR_WINHTTP_OPERATION_CANCELLED &&
                  (*lpdwError != ERROR_WINHTTP_SECURE_FAILURE ||
                   dwSecureStatus & ~(WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CA |
                                      WINHTTP_CALLBACK_STATUS_FLAG_CERT_DATE_INVALID |
                                      WINHTTP_CALLBACK_STATUS_FLAG_CERT_CN_INVALID |
                                      WINHTTP_CALLBACK_STATUS_FLAG_SECURITY_CHANNEL_ERROR |
                                      WINHTTP_CALLBACK_STATUS_FLAG_CERT_REVOKED |
                                      WINHTTP_CALLBACK_STATUS_FLAG_CERT_REV_FAILED)) &&
                  *lpdwError != ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED )
        {
            //
            // For backround detection, we need to retry
            //  waiting for the backround results to complete
            //
            // Otherwise, If we have additional proxies, 
            //  we need to retry them as well.
            //

            if ( pQueryForProxyInfo->IsBackroundDetectionPending() )
            {
                *lpdwError = ERROR_SUCCESS;
                fReturn = TRUE;
            }
            else if ( pProxyState &&
                     !pProxyState->IsEmpty() &&
                      pProxyState->IsAnotherProxyAvail() )               
            {
                INTERNET_PORT LastProxyUsedPort; 
                LPSTR lpszLastProxyUsed = pProxyState->GetLastProxyUsed(&LastProxyUsedPort);

                Lock(FALSE);

                if ( ( lpszLastProxyUsed == NULL ) ||
                     _BadProxyList.AddEntry(lpszLastProxyUsed, LastProxyUsedPort) != ERROR_SUCCESS )
                {
                    fReturn = FALSE;                    
                }
                else
                {
                    *lpdwError = ERROR_SUCCESS;
                    fReturn = TRUE;
                }

                Unlock();
            }
        }
    }

    DEBUG_LEAVE(fReturn);

    return fReturn;
}

VOID PROXY_INFO::SetSessionObject(INTERNET_HANDLE_OBJECT * pSessionObject)
{
    INET_ASSERT(pSessionObject->GetHandleType() == TypeInternetHandle);
    _pSessionObject = pSessionObject;
}


VOID
PROXY_INFO::CleanOutLists(
    VOID
    )

/*++

Routine Description:

    Delete proxy server and bypass lists if not empty

    N.B. Exclusive lock MUST be acquired before calling this method

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 None,
                 "PROXY_INFO::CleanOutLists",
                 NULL
                 ));

    if (_ProxyServerList != NULL) {
        delete _ProxyServerList;
        _ProxyServerList = NULL;
    }
    if (_ProxyBypassList != NULL) {
        delete _ProxyBypassList;
        _ProxyBypassList = NULL;
    }

    DEBUG_LEAVE(0);
}

//
// PROXY_INFO_GLOBAL - Global Object thats inherits and expands the basic functionality 
//   of basic PROXY_INFO behavior.  The new functionality includes wrapping Auto-Proxy
///  and Auto-detection routines
//


VOID
PROXY_INFO_GLOBAL::TerminateProxySettings(
    VOID
    )

/*++

Routine Description:

    Destroy PROXY_INFO_GLOBAL object

Arguments:

    None.

Return Value:

    None.

--*/

{
    PROXY_INFO::TerminateProxySettings();
}

DWORD
PROXY_INFO_GLOBAL::SetProxySettings(
    IN LPINTERNET_PROXY_INFO_EX  lpProxySettings,
    IN BOOL fModifiedInProcess
    )

/*++

Routine Description:

    Sets the proxy info.  Mainly handles Auto-Config, its decendent will handle static stuff

    Assumes: 1. The parameters have already been validated in the API that calls
                this method (i.e. InternetOpen(), InternetSetOption())

Arguments:
    
    lpProxySettings     - a set of relevent fields describing proxy settings

    fModifiedInProcess  - TRUE if this object is not from the registry, but 
                           a modifed setting for this process (that overrides reg values)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    The lpszProxy or lpszProxyBypass list was bad

                  ERROR_NOT_ENOUGH_MEMORY
                    Failed to create an object or allocate space for a list,
                    etc.

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO_GLOBAL::SetProxySettings",
                 "%x, %B",
                 lpProxySettings,
                 fModifiedInProcess
                 ));

    DWORD error = ERROR_SUCCESS;

    //
    // about to start changing contents - acquire lock
    //

    Lock(TRUE);

    //
    // Once we're set to Modified, we're modified for the lifetime of the
    //   the process, and thus we no longer accept Registry settings
    //

    if ( IsModifiedInProcess() && 
         !fModifiedInProcess )
    {
        error = ERROR_SUCCESS;
        goto quit;
    }

    if ( _lpszConnectionName != NULL ) {
        FREE_MEMORY(_lpszConnectionName);
    }

    _lpszConnectionName = lpProxySettings->lpszConnectionName ? 
                            NewString(lpProxySettings->lpszConnectionName) : 
                            NULL;

    _dwProxyFlags = lpProxySettings->dwFlags;

    //
    // Set the Static Proxy Lists
    //
        
    error = PROXY_INFO::SetProxySettings(lpProxySettings, fModifiedInProcess);

quit:

    //
    // other threads free to access this PROXY_INFO again
    //

    Unlock();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
PROXY_INFO_GLOBAL::GetProxySettings(
    IN LPINTERNET_PROXY_INFO_EX  lpProxySettings,
    IN BOOL fCheckVersion = FALSE
    )

/*++

Routine Description:

    Gather the proxy info.  Mainly handles Auto-Config, its decendent will handle static stuff

Arguments:
    
    lpProxySettings     - a set of relevent fields describing proxy settings

    fCheckVersion       - 

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    The lpszProxy or lpszProxyBypass list was bad

                  ERROR_NOT_ENOUGH_MEMORY
                    Failed to create an object or allocate space for a list,
                    etc.

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO_GLOBAL::GetProxySettings",
                 "%x, %B",
                 lpProxySettings,
                 fCheckVersion
                 ));

    //
    // about to start reading contents - acquire lock
    //

    Lock(FALSE);

    DWORD error = ERROR_SUCCESS;

    lpProxySettings->lpszConnectionName =
                        _lpszConnectionName ? 
                            NewString(_lpszConnectionName) : 
                            NULL;

    lpProxySettings->dwFlags = _dwProxyFlags;


    //
    // Get the Static Proxy Lists
    //
        
    error = PROXY_INFO::GetProxySettings(lpProxySettings, fCheckVersion);

//quit:

    //
    // other threads free to access this PROXY_INFO again
    //

    Unlock();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
PROXY_INFO_GLOBAL::RefreshProxySettings(
    IN BOOL fForceRefresh
    )

/*++

Routine Description:

    Force a refresh of automatic settings, such as auto-proxy, auto-detect

Arguments:
    
    fForceRefresh - Forces a hard refresh

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    The lpszProxy or lpszProxyBypass list was bad

                  ERROR_NOT_ENOUGH_MEMORY
                    Failed to create an object or allocate space for a list,
                    etc.

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO_GLOBAL::RefreshProxySettings",
                 "%B",
                 fForceRefresh
                 ));

    DWORD error = ERROR_SUCCESS;

    Lock(FALSE);

    //
    // Force reload of registry settings and download of auto-proxy file from server
    //

    if ( IsRefreshDisabled())
    {
        QueueRefresh();
        goto quit;
    }


    //
    // Get the Static Proxy Lists
    //
        
    //error = PROXY_INFO::RefreshProxySettings(fForceRefresh);

quit:

    //
    // other threads free to access this PROXY_INFO again
    //

    Unlock();

    DEBUG_LEAVE(error);

    return error;
}

VOID
PROXY_INFO_GLOBAL::ReleaseQueuedRefresh(
    VOID
    )
/*++

Routine Description:

    Force a refresh of automatic settings, such as auto-proxy, auto-detect,
     When InternetOpen is called, allowing async threads.

Arguments:
    
    None.

Return Value:

    None.

--*/

{
    DWORD error = ERROR_SUCCESS;

    Lock(FALSE);

    SetRefreshDisabled(FALSE);

    if ( _fQueuedRefresh ) 
    {
        error = RefreshProxySettings(
                    FALSE
                    );

    }

    _fQueuedRefresh = FALSE;

    //
    // other threads free to access this PROXY_INFO again
    //

    Unlock();
}




DWORD
PROXY_INFO_GLOBAL::QueryProxySettings(
    IN AUTO_PROXY_ASYNC_MSG **ppQueryForProxyInfo
    )

/*++

Routine Description:

    Aquries Proxy Information.

    Note: if ppProxyState returns a non-NULL pointer than the Proxy
    strings can be assumed to be allocated pointers to strings.  Freeing
    the ppProxyState object will result in the pointers being freed as well.
    Otherwise the pointers will be to global string data that will not be
    freed unexpectedly.



Arguments:

    tUrlProtocol -  Scheme type, protocol that is being used.

    lpszUrl      -  Url being accessed.

    dwUrlLength  -  size of Url.

    lpszUrlHostName - Host name of site to connect to.

    dwUrlHostNameLength - Host name length.

    nUrlPort      - Port of server to connect to.

    lptProxyScheme - On output contains the correct proxy server type to use.
                        ex: if a SOCKS proxy is to be used to handle the FTP protocol,
                            this will be a INTERNET_SCHEME_SOCKS.

    lplpszProxyHostName - Pointer to allocated memory containing the address of
                           the proxy host name.



Return Value:

    LPSTR
        Success - pointer to allocated buffer

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO_GLOBAL::QueryProxySettings",
                 "%#x",
                 ppQueryForProxyInfo
                 ));

    INET_ASSERT(ppQueryForProxyInfo);

    BOOL fReturn = FALSE;
    DWORD error = ERROR_SUCCESS;
    BOOL fNeedsGetNextProxy = FALSE;
    BOOL fLocked = FALSE;
    AUTO_PROXY_ASYNC_MSG *pQueryForProxyInfo = *ppQueryForProxyInfo;

    //
    // If we're dealing with a list of Proxies, we may have already tried one
    //  proxy and failed.  So go to the next proxy in the list
    //  and see if another one is availble to try.
    //

    if ( pQueryForProxyInfo->IsProxyEnumeration() )
    {
        fNeedsGetNextProxy = TRUE;
        goto quit;
    }

    if ( pQueryForProxyInfo->IsQueryOnCallback() &&
         ! pQueryForProxyInfo->IsAvoidAsyncCall())
    {
        goto quit;
    }

    Lock(FALSE);
    fLocked = TRUE;

    //
    // Use normal Proxy infomation stored in the registry
    //

    error = PROXY_INFO::QueryProxySettings(&pQueryForProxyInfo);

    if ( error != ERROR_SUCCESS)
    {
        goto quit;
    }

quit:

    if ( error == ERROR_SUCCESS &&
          ( fNeedsGetNextProxy ||
            pQueryForProxyInfo->IsProxyEnumeration())  )
    {
        error = pQueryForProxyInfo->GetNextProxy(_BadProxyList);
    }

    if ( fLocked )
    {
        Unlock();
    }

//fastquit:

    DEBUG_LEAVE(error);

    return error;
}


BOOL
PROXY_INFO_GLOBAL::HostBypassesProxy(
    IN INTERNET_SCHEME tScheme,
    IN LPSTR           lpszHostName,
    IN DWORD           cchHostName
    )

/*++

Routine Description:

    Determine if request should bypass proxy for host

Arguments:

    tScheme         -
    lpszHostName    -
    cchHostName     -

Return Value:

    BOOL

--*/

{
    BOOL bReturn = FALSE;
    DWORD dwServiceType;
    BOOL bTryByPassList = TRUE;

    // Only do this if it is for a scheme wininet supports.
    if (tScheme == INTERNET_SCHEME_HTTP ||
        tScheme == INTERNET_SCHEME_HTTPS ||
        tScheme == INTERNET_SCHEME_DEFAULT)
    {
        dwServiceType = INTERNET_SERVICE_HTTP;
    }
    else
    {
        return bReturn;
    }

    // LOCK
    Lock(FALSE);

    if (bTryByPassList) {        
        bReturn = IsHostInBypassList(lpszHostName, cchHostName);
    }

    Unlock();
    return bReturn;
}

//
// PROXY_STATE - an abstraction object used to provice simple string enumeration
//   given a list of proxies that need to be tested 
// 



BOOL
PROXY_STATE::GetNextProxy(
    IN  INTERNET_SCHEME   tUrlScheme,
    IN  BAD_PROXY_LIST &  BadProxyList,
    OUT LPINTERNET_SCHEME lptProxyScheme,
    OUT LPSTR * lplpszProxyHostName,
    OUT LPBOOL lpbFreeProxyHostName,
    OUT LPDWORD lpdwProxyHostNameLength,
    OUT LPINTERNET_PORT lpProxyHostPort
    )

/*++

Routine Description:

    Parses the current Proxy State information to acquire the
        proxy name, port, type to use.


Arguments:

    tUrlScheme   -  Scheme type, protocol that is being used.

    BadProxyList -  Reference to array of bad proxies that we can add/remove/check
                        from.

    lptProxyScheme - On output contains the correct proxy server type to use.
                        ex: if a SOCKS proxy is to be used to handle the FTP protocol,
                            this will be a INTERNET_SCHEME_SOCKS.

    lplpszProxyHostName - Pointer to allocated memory containing the address of
                           the proxy host name.

    lpbFreeProxyHostName - TRUE if *lplpszProxyHostName was allocated

    lpdwProxyHostNameLength - length of lplpszProxyHostName.

    lpProxyHostPort    - Host Port of Proxy.



Return Value:

    LPSTR
        Success - pointer to allocated buffer

        Failure - NULL

--*/

{
    LPSTR lpszDelimiter = NULL;
    BOOL  fReturn       = FALSE;
    LPSTR lpszPortDelim = NULL;
    LPSTR lpszPort      = NULL;


    if ( !_fIsMultiProxyList )
    {
        *lptProxyScheme = _tProxyScheme;
        *lplpszProxyHostName = _lpszAutoProxyList;
        *lpbFreeProxyHostName = FALSE;
        *lpdwProxyHostNameLength = _dwcbAutoProxyList;
        *lpProxyHostPort  = _proxyHostPort;
    }

    _fIsAnotherProxyAvail = FALSE;

    while ( *_lpszOffset != '\0' )
    {
        LPSTR lpszNewOffset ;

        //
        // Remove the delimiter so we can see the next token.
        //  ex: PROXY foo:80; DIRECT
        //  we would find DIRECT first with strstr, if we didn't
        //  delimit first.
        //

        lpszDelimiter = strchr(_lpszOffset, ';' );

        if ( lpszDelimiter == NULL )
        {
            lpszDelimiter = strchr(_lpszOffset, ',' );
        }

        if ( lpszDelimiter )
        {
            *lpszDelimiter = '\0';
        }

        lpszNewOffset=
            strstr(_lpszOffset, "DIRECT");

        if ( lpszNewOffset )
        {
            lpszNewOffset += sizeof("DIRECT");
            _lpszOffset    = lpszNewOffset;

            //
            // FALSE means direct.
            //

            fReturn = FALSE;
            goto quit;
        }

        //
        // Its not direct, try PROXY or SOCKS.
        //

        lpszNewOffset =
            strstr(_lpszOffset, "PROXY");


        if ( lpszNewOffset)
        {
            lpszNewOffset += sizeof("PROXY");
            *lpProxyHostPort = INTERNET_DEFAULT_HTTP_PORT;

            if ( tUrlScheme == INTERNET_SCHEME_HTTPS )
            {
                *lptProxyScheme = INTERNET_SCHEME_HTTPS;
            }
            else
            {
                *lptProxyScheme = INTERNET_SCHEME_HTTP;

            }
        }
        else
        {
            lpszNewOffset =
                strstr(_lpszOffset, "SOCKS");

            if ( lpszNewOffset )
            {
                lpszNewOffset   += sizeof("SOCKS");
                *lptProxyScheme  = INTERNET_SCHEME_SOCKS;
                *lpProxyHostPort = INTERNET_DEFAULT_SOCKS_PORT;
            }
        }

        //
        // Now do the generic common things for SOCKS, or PROXY
        // entries, ie: get port, hostname, and hostname size.
        //

        if ( lpszNewOffset )
        {
            _lpszOffset    = lpszNewOffset;

            SKIPWS(_lpszOffset);

            *lplpszProxyHostName = _lpszOffset;
            *lpbFreeProxyHostName = FALSE;

            lpszPortDelim = strchr(_lpszOffset, ':');

            if ( lpszPortDelim )
            {
                *lpszPortDelim = '\0';
                lpszPort  = lpszPortDelim+1;

                *lpProxyHostPort = (INTERNET_PORT)
                    atoi(lpszPort);
            }

            *lpdwProxyHostNameLength = lstrlen(_lpszOffset);

            if (BadProxyList.IsBadProxyName(*lplpszProxyHostName, *lpProxyHostPort))
            {
                if ( lpszDelimiter )
                {
                    _lpszOffset = (lpszDelimiter+1);
                }
                else
                {
                    _lpszOffset = _lpszAutoProxyList + _dwcbAutoProxyList;
                }

                continue;
            }

            fReturn = TRUE;
        }

        break;
    }

quit:

    //if ( lpszPortDelim )
    //{
    //    *lpszPortDelim = ':';
    //}

    if ( lpszDelimiter )
    {
        *lpszDelimiter = ';';

        _lpszOffset = (lpszDelimiter+1);
    }
    else
    {
        _lpszOffset = _lpszAutoProxyList + _dwcbAutoProxyList;
    }

    if ( fReturn )
    {
        _lpszLastProxyUsed = *lplpszProxyHostName;
        _LastProxyUsedPort = *lpProxyHostPort;

        //
        // If theres another possible proxy in this list,
        //   then we'll need to remember that
        //

        if ( _lpszOffset &&
             *_lpszOffset &&
                (strstr(_lpszOffset, "PROXY") ||
                 strstr(_lpszOffset, "DIRECT") ||  
                 strstr(_lpszOffset, "SOCKS"))
            )
        {
            _fIsAnotherProxyAvail = TRUE;
        }
    }

    return fReturn;
}



#ifndef WININET_SERVER_CORE

PRIVATE
LPSTR
GetRegistryProxyParameter(
    IN LPSTR lpszParameterName
    )

/*++

Routine Description:

    Reads a string from the registry into a buffer, then shrinks the buffer

Arguments:

    lpszParameterName   - name of string to retrieve

Return Value:

    LPSTR
        Success - pointer to allocated buffer

        Failure - NULL

--*/

{
    LPSTR buffer = NULL;
    DWORD length = PROXY_REGISTRY_STRING_LENGTH;
    BOOL done = FALSE;

    do {
        buffer = (LPSTR)ResizeBuffer(buffer, length, FALSE);
        if (done || (buffer == NULL)) {
            break;
        }

        DWORD error;

        error = InternetReadRegistryString(lpszParameterName, buffer, &length);
        length = (error == ERROR_SUCCESS) ? ((length == 0) ? 0 : (length + 1)) : 0;
        done = TRUE;
    } while (TRUE);

    return buffer;
}
#endif //!WININET_SERVER_CORE



//
// wrapper function for urlzones.
//

BOOLAPI IsHostInProxyBypassList (INTERNET_SCHEME tScheme, LPCSTR pszHost, DWORD cchHost)
{
    BOOL    fRet = FALSE;

    if (!GlobalDataInitialized) {
        GlobalDataInitialize();
    }

    if(ERROR_SUCCESS == LoadWinsock())
    {
        fRet = g_pGlobalProxyInfo->HostBypassesProxy(tScheme, (LPSTR)pszHost, cchHost);
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\handles\hinet.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    hinet.cxx

Abstract:

    contains methods for INTERNET_HANDLE_BASE class

    Contents:
        HANDLE_OBJECT::HANDLE_OBJECT()
        HANDLE_OBJECT::HANDLE_OBJECT()
        HANDLE_OBJECT::Reference()
        HANDLE_OBJECT::Dereference()
        HANDLE_OBJECT::IsValid()
        INTERNET_HANDLE_BASE::INTERNET_HANDLE_BASE(LPCSTR, ...)
        INTERNET_HANDLE_BASE::INTERNET_HANDLE_BASE(INTERNET_HANDLE_BASE*)
        INTERNET_HANDLE_BASE::~INTERNET_HANDLE_BASE()
        INTERNET_HANDLE_BASE::SetAbortHandle(ICSocket)
        INTERNET_HANDLE_BASE::ResetAbortHandle()
        INTERNET_HANDLE_BASE::AbortSocket()
        INTERNET_HANDLE_BASE::SetProxyInfo()
        INTERNET_HANDLE_BASE::GetProxyInfo(LPVOID, LPDWORD)
        INTERNET_HANDLE_BASE::GetProxyInfo(INTERNET_SCHEME, LPINTERNET_SCHEME, LPSTR *, LPDWORD, LPINTERNET_PORT)

Author:

    Madan Appiah (madana)  16-Nov-1994

Environment:

    User Mode - Win32

Revision History:

   Sophia Chung (sophiac) 14-Feb-1995 (added FTP and Archie class impl.)
   (code adopted from madana)

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

//
// private manifests
//

#define PROXY_REGISTRY_STRING_LENGTH    (4 K)

//
// methods
//


HANDLE_OBJECT::HANDLE_OBJECT(
    IN HANDLE_OBJECT * Parent
    )

/*++

Routine Description:

    HANDLE_OBJECT constructor

Arguments:

    Parent  - pointer to parent HANDLE_OBJECT

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                None,
                "HANDLE_OBJECT",
                "%#x",
                this
                ));

    //InitializeListHead(&_List);
    _Parent = Parent;
    if (_Parent)
        _Parent->Reference();
    _Status = AllocateHandle(this, &_Handle);
    _ObjectType = TypeGenericHandle;
    _ReferenceCount = 1;
    _Invalid = FALSE;
    _Error = ERROR_SUCCESS;
    _Signature = OBJECT_SIGNATURE;
    _Context = NULL;
    if (!InsertAtTailOfSerializedList(&GlobalObjectList, &_List))
        _Status = ERROR_NOT_ENOUGH_MEMORY;

    //
    // if AllocateHandle() failed then we cannot create this handle object.
    // Invalidate it ready for the destructor
    //

    if (_Status != ERROR_SUCCESS) {
        _Invalid = TRUE;
        _ReferenceCount = 0;
    }

    DEBUG_PRINT(OBJECTS,
                INFO,
                ("handle %#x created; address %#x; %d objects\n",
                _Handle,
                this,
                ElementsOnSerializedList(&GlobalObjectList)
                ));

    DEBUG_LEAVE(0);
}


HANDLE_OBJECT::~HANDLE_OBJECT(VOID)

/*++

Routine Description:

    HANDLE_OBJECT destructor. Virtual function

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                None,
                "~HANDLE_OBJECT",
                "%#x",
                this
                ));

    //
    // remove this object from global object list
    //

    if (LockSerializedList(&GlobalObjectList))
    {
        // should always succeed since we already have the lock
        RemoveFromSerializedList(&GlobalObjectList, &_List);
        UnlockSerializedList(&GlobalObjectList);
    }

    INET_DEBUG_ASSERT((_List.Flink == NULL) && (_List.Blink == NULL));

    //
    // inform the app that this handle is completely closed
    //

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    HINTERNET hCurrent = _InternetGetObjectHandle(lpThreadInfo);
    HINTERNET hCurrentMapped = _InternetGetMappedObjectHandle(lpThreadInfo);

    _InternetSetObjectHandle(lpThreadInfo, _Handle, (HINTERNET)this);

    HINTERNET hTemp = _Handle;
    InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING,
                           (LPVOID)&hTemp,
                           sizeof(hTemp)
                           );

    _InternetSetObjectHandle(lpThreadInfo, hCurrent, hCurrentMapped);

    if (_Parent != NULL)
        _Parent->Dereference();
        
    //
    // now we can free up the API handle value
    //

    if (_Handle != NULL) {
        _Status = FreeHandle(_Handle);

        INET_ASSERT(_Status == ERROR_SUCCESS);

    }

    //
    // set the signature to a value that indicates the handle has been
    // destroyed (not useful in debug builds)
    //

    _Signature = DESTROYED_OBJECT_SIGNATURE;

    INET_ASSERT((_ReferenceCount == 0) && _Invalid);

    DEBUG_PRINT(OBJECTS,
                INFO,
                ("handle %#x destroyed; type %s; address %#x; %d objects\n",
                _Handle,
                InternetMapHandleType(_ObjectType),
                this,
                ElementsOnSerializedList(&GlobalObjectList)
                ));

    DEBUG_LEAVE(0);
}


DWORD
HANDLE_OBJECT::Reference(
    VOID
    )

/*++

Routine Description:

    Increases the reference count on the HANDLE_OBJECT

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE
                    Handle has already been invalidated
                  ERROR_ACCESS_DENIED
                    Handle object is being destroyed, cannot use it

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Dword,
                 "HANDLE_OBJECT::Reference",
                 "{%#x}",
                 _Handle
                 ));

    DWORD error;

    if (_Invalid) {

        DEBUG_PRINT(OBJECTS,
                    INFO,
                    ("handle object %#x [%#x] is invalid\n",
                    _Handle,
                    this
                    ));

        error = ERROR_INVALID_HANDLE;
    } else {
        error = ERROR_SUCCESS;
    }

    //
    // even if the handle has been invalidated (i.e. closed), we allow it
    // to continue to be referenced. The caller should return the fact
    // that the handle has been invalidated, but may require information
    // from the object in order to do so (e.g. in async thread)
    //

    do
    {
        LONG lRefCountBeforeIncrement = _ReferenceCount;

        //
        // refcount is > 0 means that the object's destructor has not been called yet
        //
        if (lRefCountBeforeIncrement > 0)
        {
            //
            // try to increment the refcount using compare-exchange
            //
#ifndef _WIN64
            LONG lRefCountCurrent = (LONG)SHInterlockedCompareExchange((LPVOID*)&_ReferenceCount,
                                                                       (LPVOID)(lRefCountBeforeIncrement + 1),
                                                                       (LPVOID)lRefCountBeforeIncrement);
#else
            //
            // can't use SHInterlockedCompareExchange on win64 because the values are really LONG's (32-bits) but they
            // are treated as pointers (64-bits) because SHInterlockedCompareExchange should really be called 
            // SHInterlockedCompareExchangePointer (sigh...).
            //
            LONG lRefCountCurrent = InterlockedCompareExchange(&_ReferenceCount,
                                                               lRefCountBeforeIncrement + 1,
                                                               lRefCountBeforeIncrement);
#endif        
            if (lRefCountCurrent == lRefCountBeforeIncrement)
            {
                //
                // since SHInterlockedCompareExchange returns the value in _ReferenceCount 
                // before the exchange, we know the exchange sucessfully took place (i.e. we 
                // sucessfully incremented the refrence count of the object by one)
                //
                INET_ASSERT(lRefCountCurrent > 0);
                break;
            }
        }
        else
        {
            //
            // the refcount dropped to zero before we could increment it,
            // so the object is being destroyed. 
            //
            error = ERROR_ACCESS_DENIED;
            break;
        }

    } while (TRUE);

    DEBUG_PRINT(REFCOUNT,
                INFO,
                ("handle object %#x [%#x] ReferenceCount = %d\n",
                _Handle,
                this,
                _ReferenceCount
                ));

    DEBUG_LEAVE(error);

    return error;
}


BOOL
HANDLE_OBJECT::Dereference(
    VOID
    )

/*++

Routine Description:

    Reduces the reference count on the HANDLE_OBJECT, and if it goes to zero,
    the object is deleted

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - this object was deleted

        FALSE   - this object is still valid

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Bool,
                 "HANDLE_OBJECT::Dereference",
                 "{%#x}",
                 _Handle
                 ));

    //
    // by the time we get here, the reference count should not be 0. There
    // should be 1 call to Dereference() for each call to Reference()
    //

    INET_ASSERT(_ReferenceCount != 0);

    BOOL deleted = FALSE;

    if (InterlockedDecrement(&_ReferenceCount) == 0)
    {
        deleted = TRUE;
    }


    if (deleted)
    {
        //
        // if we are calling the destructor, the handle had better be invalid!
        //
        INET_ASSERT(_Invalid);
        
        //
        // this handle has now been closed. If there is no activity on it
        // then it will be destroyed
        //

        DEBUG_PRINT(REFCOUNT,
                    INFO,
                    ("handle object %#x [%#x] ReferenceCount = %d\n",
                    _Handle,
                    this,
                    _ReferenceCount
                    ));

        delete this;
    } else {

        DEBUG_PRINT(REFCOUNT,
                    INFO,
                    ("handle object %#x [%#x] ReferenceCount = %d\n",
                    _Handle,
                    this,
                    _ReferenceCount
                    ));
    }

    DEBUG_LEAVE(deleted);

    return deleted;
}


DWORD
HANDLE_OBJECT::IsValid(
    IN HINTERNET_HANDLE_TYPE ExpectedHandleType
    )

/*++

Routine Description:

    Checks a HANDLE_OBJECT for validity

Arguments:

    ExpectedHandleType  - type of object we are testing for. Can be
                          TypeWildHandle which matches any valid handle

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE
                    The handle object is invalid

                  ERROR_WINHTTP_INCORRECT_HANDLE_TYPE
                    The handle object is valid, but not the type we want

--*/

{
    DWORD error;
    BOOL IsOkHandle = TRUE;

    //
    // test handle object within try..except in case we are given a bad address
    //

    __try {
        if (_Signature == OBJECT_SIGNATURE) {

            error = ERROR_SUCCESS;

            //
            // check handle type if we are asked to do so.
            //

            if (ExpectedHandleType != TypeWildHandle) {
                if (ExpectedHandleType != this->GetHandleType()) {
                    error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
                }
            }
        } else {
            error = ERROR_INVALID_HANDLE;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        error = ERROR_INVALID_HANDLE;
    }
    ENDEXCEPT
    return error;
}


INTERNET_HANDLE_BASE::INTERNET_HANDLE_BASE(
    LPCSTR UserAgent,
    DWORD AccessMethod,
    LPSTR ProxyServerList,
    LPSTR ProxyBypassList,
    DWORD Flags
    ) : HANDLE_OBJECT(NULL)

/*++

Routine Description:

    Creates the handle object for InternetOpen()

Arguments:

    UserAgent       - name of agent (user-agent string for HTTP)

    AccessMethod    - DIRECT, PROXY or PRECONFIG

    ProxyServerList - one or more proxy servers. The string has the form:

                        [<scheme>=][<scheme>"://"]<server>[":"<port>][";"*]

    ProxyBypassList - zero or more addresses which if matched will result in
                      requests NOT going via the proxy (only if PROXY access).
                      The string has the form:

                        bp_entry ::= [<scheme>"://"]<server>[":"<port>]
                        bp_macro ::= "<local>"
                        bp_list ::= [<> | bp_entry bp_macro][";"*]

    Flags           - various open flags:

                        WINHTTP_FLAG_ASYNC - not support in WinHttpX

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_HANDLE_BASE::INTERNET_HANDLE_BASE",
                 NULL
                 ));


    //
    // if the HANDLE_OBJECT constructor failed then bail out now
    //

    if (_Status != ERROR_SUCCESS) {

        DEBUG_PRINT(OBJECTS,
                    ERROR,
                    ("early-exit: _Status = %d\n",
                    _Status
                    ));

        DEBUG_LEAVE(0);

        return;
    }

    _PPContext = 0;

    _ThreadToken = 0;
    
    _IsCopy = FALSE;
    _UserAgent = (LPSTR)UserAgent;
    _ProxyInfo = NULL;
    _dwInternetOpenFlags = Flags;
    _WinsockLoaded = FALSE;

    _Context = NULL;

    _MaxConnectionsPerServer    = WINHTTP_CONNS_PER_SERVER_UNLIMITED;
    _MaxConnectionsPer1_0Server = WINHTTP_CONNS_PER_SERVER_UNLIMITED;
    
    //
    // set _Async based on the WINHTTP_FLAG_ASYNC supplied to InternetOpen()
    //

    _dwCodePage                 = CP_UTF8;
    _Async = (Flags & WINHTTP_FLAG_ASYNC) ? TRUE : FALSE;

    //
    // no data available yet
    //

    SetAvailableDataLength(0);

    //
    // not yet end of file
    //

    ResetEndOfFile();

    //
    // no status callback by default
    //

    _StatusCallback = NULL;
    _StatusCallbackType = FALSE;
    _dwStatusCallbackFlags = 0;

    SetObjectType(TypeInternetHandle);

    _ProxyInfoResourceLock.Initialize();

    _Status = SetProxyInfo(AccessMethod, ProxyServerList, ProxyBypassList);

    //
    // if _pICSocket is not NULL then this is the socket that this object handle
    // is currently working on. We close it to cancel the operation
    //

    _pICSocket = NULL;

    
    if (::OpenThreadToken(
                GetCurrentThread(),
                TOKEN_READ | TOKEN_IMPERSONATE,
                FALSE,
                &_ThreadToken
                ) == FALSE)
    {
        _ThreadToken = 0;
    }
    //
    // load winsock now.
    //

    if (_Status == ERROR_SUCCESS) {
    
        _Status = LoadWinsock();
        _WinsockLoaded = (_Status == ERROR_SUCCESS);

        if ( _Status == ERROR_SUCCESS )
        {
             LONG lOpenHandleCnt;

             LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

             if ( lpThreadInfo )
             {
                 lOpenHandleCnt = InterlockedIncrement((LPLONG)&GlobalInternetOpenHandleCount);

                 if ( lOpenHandleCnt == 0 )
                 {
                    DWORD fAlreadyInInit = (DWORD) InterlockedExchange((LPLONG) &GlobalAutoProxyInInit, TRUE);

                    INET_ASSERT (! fAlreadyInInit );

                    g_pGlobalProxyInfo->ReleaseQueuedRefresh();

                    InterlockedExchange((LPLONG)&GlobalAutoProxyInInit, FALSE);
                 }
             }
        }
    }

    DEBUG_LEAVE(0);
}


INTERNET_HANDLE_BASE::INTERNET_HANDLE_BASE(
    INTERNET_HANDLE_BASE *INetObj
    ) : HANDLE_OBJECT((HANDLE_OBJECT*)INetObj)

/*++

Routine Description:

    Constructor for derived handle object. We are creating this handle as part
    of an INTERNET_CONNECT_HANDLE_OBJECT

Arguments:

    INetObj - pointer to INTERNET_HANDLE_BASE to copy

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_HANDLE_BASE::INTERNET_HANDLE_BASE",
                 "{IsCopy}"
                 ));

    _PPContext = INetObj->_PPContext;
    _ThreadToken = INetObj->_ThreadToken;
    
    _IsCopy = TRUE;

    //
    // copy user agent string
    //

    //
    // BUGBUG - compiler generated copy constructor (no new string)
    //

    _UserAgent = INetObj->_UserAgent;

    //
    // do not inherit the proxy info - code must go to parent handle
    //

    _ProxyInfo = NULL;

    _dwInternetOpenFlags = INetObj->_dwInternetOpenFlags;

    //
    // creating this handle didn't load winsock
    //

    _WinsockLoaded = FALSE;

    //
    // inherit the context, async flag and status callback from
    // the parent object handle
    //

    _Context = INetObj->_Context;
 
    _MaxConnectionsPerServer    = INetObj->_MaxConnectionsPerServer;
    _MaxConnectionsPer1_0Server = INetObj->_MaxConnectionsPer1_0Server;

    _dwCodePage = INetObj->_dwCodePage;

    _Async = INetObj->_Async;

    //
    // inherit callback function
    //

    SetAvailableDataLength(0);
    ResetEndOfFile();
    _StatusCallback = INetObj->_StatusCallback;
    _StatusCallbackType = INetObj->_StatusCallbackType;
    _dwStatusCallbackFlags = INetObj->_dwStatusCallbackFlags;


    //
    // no socket operation to abort yet
    //

    _pICSocket = NULL;

    //
    // BUGBUG - this overwrites status set above?
    //

    _Status = INetObj->_Status;

    DEBUG_LEAVE(0);
}


INTERNET_HANDLE_BASE::~INTERNET_HANDLE_BASE(
    VOID
    )

/*++

Routine Description:

    INTERNET_HANDLE_BASE destructor

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_HANDLE_BASE::~INTERNET_HANDLE_BASE",
                 ""
                 ));


    if (_ProxyInfo && !IsProxyGlobal() && (_ProxyInfo != PROXY_INFO_DIRECT))
    {
        DEBUG_PRINT(OBJECTS,
                    INFO,
                    ("Free-ing ProxyInfo\n"
                    ));

        delete _ProxyInfo;
        _ProxyInfo = NULL;
    }


    //
    // if this handle is not a copy (i.e., it is a Session handle), then delete
    // the Passport context
    //

    if (!IsCopy()) {

        DEBUG_PRINT(OBJECTS,
                    INFO,
                    ("Not a Copy...\n"
                    ));

        if (_PPContext)
        {
            ::PP_FreeContext(_PPContext);
        }

        //
        // don't unload winsock. There really is no need to unload separately
        // from process detach and if we do unload, we first have to terminate
        // async support. Dynaloading and unloading winsock is vestigial
        //

        //if (_WinsockLoaded) {
        //    UnloadWinsock();
        //}

        if (_ThreadToken)
        {
            ::CloseHandle(_ThreadToken);
            _ThreadToken = NULL;
        }
    }

    DEBUG_LEAVE(0);
}

DWORD
INTERNET_HANDLE_BASE::ExchangeStatusCallback(
    LPWINHTTP_STATUS_CALLBACK lpStatusCallback,
    BOOL fType,
    DWORD dwFlags
    )
{
    DWORD error;


    WINHTTP_STATUS_CALLBACK callback;

    // exchange new and current callbacks
    callback = _StatusCallback;
    _StatusCallback = *lpStatusCallback;
    *lpStatusCallback = callback;
    _StatusCallbackType = fType;
    _dwStatusCallbackFlags = dwFlags;
    error = ERROR_SUCCESS;

    return error;
}


VOID
INTERNET_HANDLE_BASE::SetAbortHandle(
    IN ICSocket * Socket
    )

/*++

Routine Description:

    Associates with this request handle the ICSocket object currently being used
    for network I/O

Arguments:

    Socket  - pointer to ICSocket

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS | DBG_SOCKETS,
                 None,
                 "INTERNET_HANDLE_BASE::SetAbortHandle",
                 "{%#x} %#x [sock=%#x ref=%d]",
                 GetPseudoHandle(),
                 Socket,
                 Socket ? Socket->GetSocket() : 0,
                 Socket ? Socket->ReferenceCount() : 0
                 ));

    INET_ASSERT(Socket != NULL);

    //
    // first off, increase the socket reference count to stop any other threads
    // killing it whilst we are performing the socket operation. The only way
    // another thread can dereference the socket is by calling our AbortSocket()
    // method
    //

    Socket->Reference();

    //
    // now associate the socket object with this handle object. We should not
    // have a current association
    //

    ICSocket * pSocket;

    pSocket = (ICSocket *) InterlockedExchangePointer((PVOID*)&_pICSocket, Socket);

    //
    // because ConnectSocket() can call this method multiple times without
    // intervening calls to ResetAbortHandle(), pSocket can legitimately be
    // non-NULL at this point
    //

    //INET_ASSERT(pSocket == NULL);

    //
    // if the handle was invalidated on another thread before we got
    // chance to set the socket to close, then abort the request now
    //

    //
    // BUGBUG - screws up normal FTP close handle processing - we
    //          have to communicate with the server in order to
    //          drop the connection
    //

    //if (IsInvalidated()) {
    //    AbortSocket();
    //}

    DEBUG_LEAVE(0);
}


VOID
INTERNET_HANDLE_BASE::ResetAbortHandle(
    VOID
    )

/*++

Routine Description:

    Disassociates this request handle and the ICSocket object when the network
    operation has completed

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS | DBG_SOCKETS,
                 None,
                 "INTERNET_HANDLE_BASE::ResetAbortHandle",
                 "{%#x}",
                 GetPseudoHandle()
                 ));

    //
    // there really should be a ICSocket associated with this object, otherwise
    // our handle close/invalidation logic is broken
    //

    //
    // however, we can call ResetAbortHandle() from paths where we completed
    // early, not having called SetAbortHandle()
    //

    //INET_ASSERT(pSocket != NULL);

    //
    // so if there was a ICSocket associated with this object then remove the
    // reference added in SetAbortHandle()
    //


    ICSocket * pICSocket;

    pICSocket = (ICSocket *)InterlockedExchangePointer((PVOID*)&_pICSocket, NULL);
    if (pICSocket != NULL) {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("socket=%#x ref=%d\n",
                    pICSocket->GetSocket(),
                    pICSocket->ReferenceCount()
                    ));

        pICSocket->Dereference();
    }

    DEBUG_LEAVE(0);
}


VOID
INTERNET_HANDLE_BASE::AbortSocket(
    VOID
    )

/*++

Routine Description:

    If there is a ICSocket associated with this handle object then abort it. This
    forces the current network operation aborted and the request to complete
    with ERROR_WINHTTP_OPERATION_CANCELLED

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS | DBG_SOCKETS,
                 None,
                 "INTERNET_HANDLE_BASE::AbortSocket",
                 "{%#x, %#x [sock=%#x, ref=%d]}",
                 GetPseudoHandle(),
                 (_pICSocket != NULL)
                    ? (LPVOID)_pICSocket
                    : (LPVOID)_pICSocket,
                 _pICSocket
                    ? _pICSocket->GetSocket()
                    : (_pICSocket
                        ? _pICSocket->GetSocket()
                        : 0),
                 _pICSocket
                    ? _pICSocket->ReferenceCount()
                    : (_pICSocket
                        ? _pICSocket->ReferenceCount()
                        : 0)
                 ));

    //
    // get the associated ICSocket. It may have already been removed by a call
    // to ResetAbortHandle()
    //

    //
    // if there is an associated ICSocket then abort it (close the socket handle)
    // which will complete the current network I/O (if active) with an error.
    // Once the ICSocket is aborted, we reduce the reference count that was added
    // in SetAbortHandle(). This may cause the ICSocket to be deleted
    //

    LPVOID pAddr;

    pAddr = (LPVOID)InterlockedExchangePointer((PVOID*)&_pICSocket, NULL);
    if (pAddr != NULL) {

        ICSocket * pSocket = (ICSocket *)pAddr;
//dprintf(">>>>>>>> %#x AbortSocket %#x [%#x]\n", GetCurrentThreadId(), pSocket, pSocket->GetSocket());
        pSocket->Abort();
        pSocket->Dereference();
    }

    DEBUG_LEAVE(0);
}


DWORD
INTERNET_HANDLE_BASE::Refresh()
/*++

Routine Description:

    Refreshes the proxy info on an InternetOpen() HINTERNET based on the parameters

    Assumes: 1. The parameters have already been validated in the API that calls
                this method (i.e. InternetOpen(), InternetSetOption())

Return Value:

    DWORD
        Success - ERROR_SUCCESS

--*/
{

    DWORD error;

    //
    // Reload the proxy info from registry into the GlobalProxyInfo object,
    // unless it was changed in-process to something else.
    //

    if (!g_pGlobalProxyInfo->IsModifiedInProcess()) {

        return LoadProxySettings();

    } else {

        //
        // not using global proxy or it has been set to something other
        // than the registry contents. Just return success
        //

        return ERROR_SUCCESS;
    }
}



DWORD
INTERNET_HANDLE_BASE::SetProxyInfo(
    IN DWORD dwAccessType,
    IN LPCSTR lpszProxy OPTIONAL,
    IN LPCSTR lpszProxyBypass OPTIONAL
    )

/*++

Routine Description:

    Sets the proxy info on an InternetOpen() HINTERNET based on the parameters

    Assumes: 1. The parameters have already been validated in the API that calls
                this method (i.e. InternetOpen(), InternetSetOption())

Arguments:

    dwAccessType    - type of proxy access required

    lpszProxy       - pointer to proxy server list

    lpszProxyBypass - pointer to proxy bypass list

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    The lpszProxy or lpszProxyBypass list was bad

                  ERROR_NOT_ENOUGH_MEMORY
                    Failed to create an object or allocate space for a list,
                    etc.

--*/

{
    DEBUG_ENTER((DBG_INET,
                Dword,
                "INTERNET_HANDLE_BASE::SetProxyInfo",
                "%s (%d), %#x (%q), %#x (%q)",
                InternetMapOpenType(dwAccessType),
                dwAccessType,
                lpszProxy,
                lpszProxy,
                lpszProxyBypass,
                lpszProxyBypass
                ));

    //
    // Session and HTTP Request objects can have proxy information
    //

    INET_ASSERT((GetHandleType()==TypeInternetHandle) || (GetHandleType()==TypeHttpRequestHandle));

/*

    We are setting the proxy information for an InternetOpen() handle. Based on
    the current and new settings we do the following (Note: the handle is
    initialized to DIRECT operation):

                                        current access
                +---------------------------------------------------------------
        new     |      DIRECT        |       PROXY        |      PRECONFIG
       access   |                    |                    |
    +-----------+--------------------+--------------------+---------------------
    | DIRECT    | No action          | Delete proxy info  | Remove reference to
    |           |                    |                    | global proxy info
    +-----------+--------------------+--------------------+---------------------
    | PROXY     | Set new proxy info | Delete proxy info. | Remove reference to
    |           |                    | Set new proxy info | global proxy info.
    |           |                    |                    | Set new proxy info
    +-----------+--------------------+--------------------+---------------------
    | PRECONFIG | Set proxy info to  | Delete proxy info. | No action
    |           | global proxy info  | Set proxy info to  |
    |           |                    | global proxy info  |
    +-----------+--------------------+--------------------+---------------------
*/

    DWORD error = ERROR_SUCCESS;
    PROXY_INFO * proxyInfo = NULL;

    //
    // acquire proxy info for exclusive access
    //

    if (!AcquireProxyInfo(TRUE))
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    if (IsProxy()) {

        //
        // delete private proxy info, or unlink from global proxy info
        //

        SafeDeleteProxyInfo();
    }

    //
    // Map Various Proxy types to their internal counterparts,
    //   note that I've ordered them in what I think is their 
    //   use frequency (how often each one is most likely to get hit).
    //

    switch (dwAccessType)
    {
#ifndef WININET_SERVER_CORE
        // In WinHttpX, INTERNET_OPEN_TYPE_PRECONFIG is equivalent 
        // to INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY.
        case INTERNET_OPEN_TYPE_PRECONFIG:
            proxyInfo = g_pGlobalProxyInfo;
            break;
#endif
        case INTERNET_OPEN_TYPE_DIRECT:
            proxyInfo = PROXY_INFO_DIRECT;
            break;

        case INTERNET_OPEN_TYPE_PROXY:     
            {
                INET_ASSERT(!IsProxy());

                INTERNET_HANDLE_OBJECT * pSession;

                if (IsCopy())
                {
                    pSession = GetRootHandle(this);
                }
                else
                {
                    pSession = static_cast<INTERNET_HANDLE_OBJECT *>(this);
                    INET_ASSERT(pSession->IsValid(TypeInternetHandle) == ERROR_SUCCESS);
                }

                proxyInfo = New PROXY_INFO;
                if (proxyInfo != NULL) {
                    proxyInfo->InitializeProxySettings();
                    proxyInfo->SetSessionObject(pSession);
                    error = proxyInfo->GetError();
                    if (error == ERROR_SUCCESS &&
                        lpszProxy ) 
                    {

                        INTERNET_PROXY_INFO_EX info;
                        memset(&info, 0, sizeof(info));
                        info.dwStructSize = sizeof(info);
                        info.dwFlags = (PROXY_TYPE_DIRECT | PROXY_TYPE_PROXY);

                        info.lpszProxy = lpszProxy;
                        info.lpszProxyBypass = lpszProxyBypass;

                        error = proxyInfo->SetProxySettings(&info, TRUE /*modified*/);

                    }
                    if (error != ERROR_SUCCESS) {
                        delete proxyInfo;
                        proxyInfo = NULL;
                    }
                } else {
                    error = ERROR_NOT_ENOUGH_MEMORY;
                }

                break;
            }

        case INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY:
            {
                // Refresh global proxy info.
                Refresh();

                proxyInfo = New PROXY_INFO_GLOBAL_WRAPPER;
                if (proxyInfo == NULL)
                    error = ERROR_NOT_ENOUGH_MEMORY;
                else
                    proxyInfo->SetSessionObject(static_cast<INTERNET_HANDLE_OBJECT *>(this));
                    
                break;
            }

        default:
            proxyInfo = NULL;
            break;
    }

    SetProxyInfo(proxyInfo);

    ReleaseProxyInfo();

quit:
    DEBUG_LEAVE(error);

    return error;
}


DWORD
INTERNET_HANDLE_BASE::GetProxyStringInfo(
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns the current proxy information for this INTERNET_HANDLE_BASE

Arguments:

    lpBuffer            - pointer to buffer where WINHTTP_PROXY_INFOA will be
                          written, and any proxy strings (if sufficient space)

    lpdwBufferLength    - IN: number of bytes in lpBuffer
                          OUT: number of bytes returned in lpBuffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    lpBuffer doesn't have enough space to hold the proxy
                    information. *lpdwBufferLength has the required size

--*/

{
    DEBUG_ENTER((DBG_INET,
                Dword,
                "INTERNET_HANDLE_BASE::GetProxyStringInfo",
                "%#x, %#x [%d]",
                lpBuffer,
                lpdwBufferLength,
                lpdwBufferLength ? *lpdwBufferLength : 0
                ));

    INET_ASSERT(!IsCopy());

    AcquireProxyInfo(FALSE);

    DWORD error;

    if (IsProxy()) {
        error = _ProxyInfo->GetProxyStringInfo(lpBuffer, lpdwBufferLength);
    } else {
        if (*lpdwBufferLength >= sizeof(WINHTTP_PROXY_INFOA)) {

            WINHTTP_PROXY_INFOA * lpInfo = (WINHTTP_PROXY_INFOA *)lpBuffer;

            lpInfo->dwAccessType = INTERNET_OPEN_TYPE_DIRECT;
            lpInfo->lpszProxy = NULL;
            lpInfo->lpszProxyBypass = NULL;
            error = ERROR_SUCCESS;
        } else {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        *lpdwBufferLength = sizeof(WINHTTP_PROXY_INFOA);
    }

    ReleaseProxyInfo();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
INTERNET_HANDLE_BASE::GetProxyInfo(
    IN AUTO_PROXY_ASYNC_MSG **ppQueryForProxyInfo
    )

/*++

Routine Description:

    Returns all proxy information based on a protocol scheme

Arguments:

    tProtocol           - protocol to get proxy info for

    lptScheme           - returned scheme

    lplpszHostName      - returned proxy name

    lpdwHostNameLength  - returned length of proxy name

    lpHostPort          - returned proxy port

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE

--*/

{
    DEBUG_ENTER((DBG_INET,
                 Dword,
                 "INTERNET_HANDLE_BASE::GetProxyInfo",
                 "%#x",
                 ppQueryForProxyInfo
                 ));

    INET_ASSERT((GetHandleType() == TypeInternetHandle) ||
                (GetHandleType() == TypeHttpRequestHandle));

    DWORD error;
    BOOL rc;

    AcquireProxyInfo(FALSE);

    if ( _ProxyInfo && _ProxyInfo != PROXY_INFO_DIRECT )
    {
        error = _ProxyInfo->QueryProxySettings(ppQueryForProxyInfo);
    }
    else
    {
        error = ERROR_SUCCESS;
        (*ppQueryForProxyInfo)->SetUseProxy(FALSE);
    }

    ReleaseProxyInfo();

    DEBUG_LEAVE(error);

    return error;
}


BOOL
INTERNET_HANDLE_BASE::RedoSendRequest(
    IN OUT LPDWORD lpdwError,
    IN DWORD dwSecureStatus,
    IN AUTO_PROXY_ASYNC_MSG *pQueryForProxyInfo,
    IN CServerInfo *pOriginServer,
    IN CServerInfo *pProxyServer
    )
{

    INET_ASSERT(!IsCopy());

    BOOL rc;

   AcquireProxyInfo(FALSE);

    if ( _ProxyInfo )
    {
        rc = _ProxyInfo->RedoSendRequest(
                                         lpdwError,
                                         dwSecureStatus,
                                         pQueryForProxyInfo,
                                         pOriginServer,
                                         pProxyServer
                                         );
    }
    else
    {
        rc = FALSE;
    }

    ReleaseProxyInfo();

    return rc;
}

INTERNET_HANDLE_OBJECT::INTERNET_HANDLE_OBJECT
    (LPCSTR ua, DWORD access, LPSTR proxy, LPSTR bypass, DWORD flags)
        : INTERNET_HANDLE_BASE (ua, access, proxy, bypass, flags)
{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_HANDLE_OBJECT::INTERNET_HANDLE_OBJECT",
                 NULL
                 ));
                 
    InterlockedIncrement(&g_cSessionCount);
    if (g_pAsyncCount)
    {
        if (flags & WINHTTP_FLAG_ASYNC)
        {
            g_pAsyncCount->AddRef();
        }
    }
    else
    {
        RIP(FALSE);
    }

    InitializeSerializedList(&_ServerInfoList);
    //
    // WinHttpX supports session cookies. Each session has it's own
    // cookie jar, instead of a shared global cookie jar as in WinInet.
    //
    _CookieJar = NULL;
    _pOptionalParams = NULL;

    _pResolverCache = New CResolverCache(&_Status);
    if (!_pResolverCache)
    {
        _Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    
    if (_Status == ERROR_SUCCESS)
    {
        _CookieJar = CreateCookieJar();
        if (_CookieJar == NULL)
            _Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    _fUseSessionCertCache = FALSE;
    _SessionCertCache.Initialize();

    DEBUG_LEAVE(0);
};

INTERNET_HANDLE_OBJECT::~INTERNET_HANDLE_OBJECT ( )
{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_HANDLE_OBJECT::~INTERNET_HANDLE_OBJECT",
                 NULL
                 ));
                 
    PurgeServerInfoList(TRUE);

    TerminateSerializedList(&_ServerInfoList);

    if (_pResolverCache)
    {
        _pResolverCache->EmptyHandlesList();
        delete _pResolverCache;
    }
    
    delete _pOptionalParams;
    _pOptionalParams = NULL;
    // Delete Cookie Jar
    CloseCookieJar(_CookieJar);
    _CookieJar = NULL;

    _SessionCertCache.Terminate();

    if (g_pAsyncCount)
    {
        g_pAsyncCount->Release();
    }
    else
    {
        RIP(FALSE);
    }
        
    DEBUG_LEAVE(0);
}

//
// This function walks up to the InternetOpen handle from either
// a connect handle (child) or a request handle (grandchild).
// We only go one or two hops rather than recurse.
//

INTERNET_HANDLE_OBJECT* GetRootHandle (HANDLE_OBJECT* pHandle)
{
    pHandle = (HANDLE_OBJECT*) pHandle->GetParent();
    INET_ASSERT (pHandle);
    if (pHandle->GetHandleType() == TypeInternetHandle)
        return (INTERNET_HANDLE_OBJECT*) pHandle;

    pHandle =  (HANDLE_OBJECT*) pHandle->GetParent();
    INET_ASSERT (pHandle);
    INET_ASSERT (pHandle->GetHandleType() == TypeInternetHandle);
    return (INTERNET_HANDLE_OBJECT*) pHandle;
}

/* 
 * When called from API functions,
 * caller should SetLastError() in case of failure
 */
BOOL
INTERNET_HANDLE_OBJECT::SetTimeout(
    IN DWORD dwTimeoutOption,
    IN DWORD dwTimeoutValue
    )
{
    BOOL bRetval = TRUE;
    
    if (!_pOptionalParams)
    {
        _pOptionalParams = New OPTIONAL_SESSION_PARAMS();

        if (!_pOptionalParams)
        {
            bRetval = FALSE;
            goto quit;
        }
    }

    switch (dwTimeoutOption) 
    {
    case WINHTTP_OPTION_RESOLVE_TIMEOUT:
        _pOptionalParams->dwResolveTimeout = dwTimeoutValue;
        break;

    case WINHTTP_OPTION_CONNECT_TIMEOUT:
        _pOptionalParams->dwConnectTimeout = dwTimeoutValue;
        break;

    case WINHTTP_OPTION_CONNECT_RETRIES:
        _pOptionalParams->dwConnectRetries = dwTimeoutValue;
        break;

    case WINHTTP_OPTION_SEND_TIMEOUT:
        _pOptionalParams->dwSendTimeout = dwTimeoutValue;
        break;

    case WINHTTP_OPTION_RECEIVE_TIMEOUT:
        _pOptionalParams->dwReceiveTimeout = dwTimeoutValue;
        break;

    default:
        bRetval = FALSE;
    }

quit:
    return bRetval;
}

/* 
 * When called from API functions,
 * caller should SetLastError() in case of failure
 */
BOOL
INTERNET_HANDLE_OBJECT::SetTimeouts(
    IN DWORD        dwResolveTimeout,
    IN DWORD        dwConnectTimeout,
    IN DWORD        dwSendTimeout,
    IN DWORD        dwReceiveTimeout
    )
{
    BOOL bRetval = TRUE;
    
    if (!_pOptionalParams)
    {
        _pOptionalParams = New OPTIONAL_SESSION_PARAMS();

        if (!_pOptionalParams)
        {
            bRetval = FALSE;
            goto quit;
        }
    }

    _pOptionalParams->dwResolveTimeout = dwResolveTimeout;
    _pOptionalParams->dwConnectTimeout = dwConnectTimeout;
    _pOptionalParams->dwSendTimeout = dwSendTimeout;
    _pOptionalParams->dwReceiveTimeout = dwReceiveTimeout;
            
quit:
    return bRetval;
}

/* 
 * When called from API functions,
 * caller should SetLastError() in case of failure
 */
BOOL
INTERNET_HANDLE_OBJECT::GetTimeout(
    IN DWORD dwTimeoutOption,
    OUT DWORD* pdwTimeoutValue
    )
{
    BOOL bRetval = TRUE;
    if (!_pOptionalParams)
    {
        bRetval = FALSE;
        goto quit;
    }
    
    switch (dwTimeoutOption) 
    {
    case WINHTTP_OPTION_RESOLVE_TIMEOUT:
        *pdwTimeoutValue = _pOptionalParams->dwResolveTimeout;
        break;
    case WINHTTP_OPTION_CONNECT_TIMEOUT:
        *pdwTimeoutValue = _pOptionalParams->dwConnectTimeout;
        break;
    case WINHTTP_OPTION_CONNECT_RETRIES:
        *pdwTimeoutValue = _pOptionalParams->dwConnectRetries;
        break;
    case WINHTTP_OPTION_SEND_TIMEOUT:
        *pdwTimeoutValue = _pOptionalParams->dwSendTimeout;
        break;
    case WINHTTP_OPTION_RECEIVE_TIMEOUT:
        *pdwTimeoutValue = _pOptionalParams->dwReceiveTimeout;
        break;
    default:
        bRetval = FALSE;
        break;
    }

quit:    
    return bRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\handles\http.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    http.cxx

Abstract:

    Contains methods for HTTP_REQUEST_HANDLE_OBJECT class

    Contents:
        RMakeHttpReqObjectHandle
        HTTP_REQUEST_HANDLE_OBJECT::HTTP_REQUEST_HANDLE_OBJECT
        HTTP_REQUEST_HANDLE_OBJECT::~HTTP_REQUEST_HANDLE_OBJECT
        HTTP_REQUEST_HANDLE_OBJECT::SetProxyName
        HTTP_REQUEST_HANDLE_OBJECT::GetProxyName
        HTTP_REQUEST_HANDLE_OBJECT::ReuseObject
        HTTP_REQUEST_HANDLE_OBJECT::ResetObject
        HTTP_REQUEST_HANDLE_OBJECT::SetAuthenticated
        HTTP_REQUEST_HANDLE_OBJECT::IsAuthenticated

Author:

    Madan Appiah (madana)  16-Nov-1994

Environment:

    User Mode - Win32

Revision History:

   Sophia Chung (sophiac) 14-Feb-1995 (added FTP and Archie class impl.)
   (code adopted from madana)

--*/

#include <wininetp.h>

//
// functions
//


DWORD
RMakeHttpReqObjectHandle(
    IN HINTERNET ParentHandle,
    IN OUT HINTERNET * ChildHandle,
    IN CLOSE_HANDLE_FUNC wCloseFunc,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    C-callable wrapper for creating an HTTP_REQUEST_HANDLE_OBJECT

Arguments:

    ParentHandle    - mapped address of parent (connect) handle

    ChildHandle     - IN: protocol-specific handle value associated with object
                        *** NOT USED FOR HTTP ***
                      OUT: mapped address of HTTP_REQUEST_HANDLE_OBJECT

    wCloseFunc      - address of protocol-specific function to be called when
                      object is closed
                        *** NOT USED FOR HTTP ***

    dwFlags         - app-supplied flags

    dwContext       - app-supplied context value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * hHttp;

    hHttp = New HTTP_REQUEST_HANDLE_OBJECT(
                    (INTERNET_CONNECT_HANDLE_OBJECT *)ParentHandle,
                    *ChildHandle,
                    wCloseFunc,
                    dwFlags,
                    dwContext
                    );
    if (hHttp != NULL) {
        error = hHttp->GetStatus();
        if (error == ERROR_SUCCESS) {

            //
            // inform the app of the new handle
            //

            error = InternetIndicateStatusNewHandle((LPVOID)hHttp);

            //
            // ERROR_WINHTTP_OPERATION_CANCELLED is the only error that we are
            // expecting here. If we get this error then the app has cancelled
            // the operation. Either way, the handle we just generated will be
            // already deleted
            //

            if (error != ERROR_SUCCESS) {

                INET_ASSERT(error == ERROR_WINHTTP_OPERATION_CANCELLED);

                hHttp = NULL;
            }
        } else {
            delete hHttp;
            hHttp = NULL;
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    *ChildHandle = (HINTERNET)hHttp;

    return error;
}

//
// HTTP_REQUEST_HANDLE_OBJECT class implementation
//


HTTP_REQUEST_HANDLE_OBJECT::HTTP_REQUEST_HANDLE_OBJECT(
    INTERNET_CONNECT_HANDLE_OBJECT * Parent,
    HINTERNET Child,
    CLOSE_HANDLE_FUNC wCloseFunc,
    DWORD dwFlags,
    DWORD_PTR dwContext
    ) : INTERNET_CONNECT_HANDLE_OBJECT(Parent)

/*++

Routine Description:

    Constructor for direct-to-net HTTP_REQUEST_HANDLE_OBJECT

Arguments:

    Parent      - parent object

    Child       - IN: HTTPREQ structure pointer
                  OUT: pointer to created HTTP_REQUEST_HANDLE_OBJECT

    wCloseFunc  - address of function that closes/destroys HTTPREQ structure

    dwFlags     - open flags (e.g. INTERNET_FLAG_RELOAD)

    dwContext   - caller-supplied request context value

Return Value:

    None.

--*/

{
    if (g_pAsyncCount)
    {
        if (Parent && Parent->IsAsyncHandle())
        {
            g_pAsyncCount->AddRef();
        }
    }
    else
    {
        RIP(FALSE);
    }
    
    _pProxyCreds = NULL;
    _pServerCreds = NULL;

    _PreferredScheme = 0;
    _SupportedSchemes = 0;
    _AuthTarget = 0;
    _SecurityLevel = WINHTTP_AUTOLOGON_SECURITY_LEVEL_MEDIUM;
    _pszRealm = NULL;

    _Context = dwContext;
    _Socket = NULL;
    _QueryBuffer = NULL;
    _QueryBufferLength = 0;
    _QueryOffset = 0;
    _QueryBytesAvailable = 0;
    _bKeepAliveConnection = FALSE;
    _bNoLongerKeepAlive = FALSE;
    _OpenFlags = dwFlags | INTERNET_FLAG_KEEP_CONNECTION;
    _State = HttpRequestStateCreating;
    _RequestMethod = HTTP_METHOD_TYPE_UNKNOWN;
    _dwOptionalSaved = 0;
    _lpOptionalSaved = NULL;
    _fOptionalSaved = FALSE;
    _bIsWriteRequired = FALSE;
    _ResponseBuffer = NULL;
    _ResponseBufferLength = 0;
    ResetResponseVariables();
    _RequestHeaders.SetIsRequestHeaders(TRUE);
    _ResponseHeaders.SetIsRequestHeaders(FALSE);
    _fTalkingToSecureServerViaProxy = FALSE;
    _bViaProxy = 0;
    _fRequestUsingProxy = FALSE;
    _bWantKeepAlive = FALSE;

    _ServerInfo = NULL;
    _OriginServer = NULL;
    SetServerInfoWithScheme(INTERNET_SCHEME_HTTP, FALSE);

    //
    // set the read/write buffer sizes to the default values (4K)
    //

    _ReadBufferSize = (4 K);
    _WriteBufferSize = (4 K);

    _CacheUrlName = NULL;
    
    SetObjectType(TypeHttpRequestHandle);

    _pAuthCtx         = NULL;
    _pTunnelAuthCtx   = NULL;
    _pCreds             = NULL;

    _NoResetBits.Dword = 0;  // only here are we ever allowed to assign to Dword.

    SetDisableNTLMPreauth(GlobalDisableNTLMPreAuth);
    
    _ProxyHostName = NULL;
    _ProxyHostNameLength = NULL;
    _ProxyPort = INTERNET_INVALID_PORT_NUMBER;

    _SocksProxyHostName = NULL;
    _SocksProxyHostNameLength = NULL;
    _SocksProxyPort = INTERNET_INVALID_PORT_NUMBER;

    _HaveReadFileExData = FALSE;
    memset(&_BuffersOut, 0, sizeof(_BuffersOut));
    _BuffersOut.dwStructSize = sizeof(_BuffersOut);
    _BuffersOut.lpvBuffer = (LPVOID)&_ReadFileExData;

    m_fPPAbortSend = FALSE;

    _dwEnableFlags = 0;

    SetPriority(0);

#ifdef RLF_TEST_CODE

    static long l = 0;
    SetPriority(l++);

#endif

    _RTT = 0;

    if (_Status == ERROR_SUCCESS) {
        _Status = _RequestHeaders.GetError();
        if (_Status == ERROR_SUCCESS) {
            _Status = _ResponseHeaders.GetError();
        }
    }
    
    // Timeout and retry parameters

    INTERNET_HANDLE_OBJECT* pRoot = GetRootHandle(Parent);
    OPTIONAL_SESSION_PARAMS* pParams = pRoot->GetOptionalParams();

    if (pParams)
    {
        _dwResolveTimeout = pParams->dwResolveTimeout;
        _dwConnectTimeout = pParams->dwConnectTimeout;
        _dwConnectRetries = pParams->dwConnectRetries;
        _dwSendTimeout    = pParams->dwSendTimeout;
        _dwReceiveTimeout = pParams->dwReceiveTimeout;
    }
    else
    {
        _dwResolveTimeout = GlobalResolveTimeout;
        _dwConnectTimeout = GlobalConnectTimeout;
        _dwConnectRetries = GlobalConnectRetries;
        _dwSendTimeout    = GlobalSendTimeout;
        _dwReceiveTimeout = GlobalReceiveTimeout;
    }

    if (_OpenFlags & WINHTTP_FLAG_SECURE)
    {
        m_pSecurityInfo = pRoot->GetSslSessionCache()->Find(GetHostName());
        if (NULL == m_pSecurityInfo)
        {
            m_pSecurityInfo = New SECURITY_CACHE_LIST_ENTRY(GetHostName());
        }
    }
    else
    {
        m_pSecurityInfo = NULL;
    }

    if (_Status == ERROR_SUCCESS && IsAsyncHandle())
    {
        if (!_AsyncCritSec.Init())
        {
            _Status = ERROR_NOT_ENOUGH_MEMORY;
        }
        _fAsyncFsmInProgress = FALSE;
    }

}


HTTP_REQUEST_HANDLE_OBJECT::~HTTP_REQUEST_HANDLE_OBJECT(
    VOID
    )

/*++

Routine Description:

    Destructor for HTTP_REQUEST_HANDLE_OBJECT

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                None,
                "~HTTP_REQUEST_HANDLE_OBJECT",
                "%#x",
                this
                ));

    //
    // close the socket (or free it to the pool if keep-alive)
    //

    //
    // Authentication Note:
    // The CloseConnection parameter to force the connection closed
    // is set if we received a challenge but didn't respond, otherwise
    // IIS will get confused when a subsequent request recycles the
    // socket from the keep-alive pool.
    //

    CloseConnection(GetAuthState() == AUTHSTATE_CHALLENGE);

    //
    // If there's an authentication context, unload the provider.
    //

    if (_pAuthCtx) {
        delete _pAuthCtx;
    }
    if (_pTunnelAuthCtx) {
        delete _pTunnelAuthCtx;
    }

    //
    // free the various buffers
    //

    FreeResponseBuffer();
    FreeQueryBuffer();
    SetProxyName(NULL,NULL,0);

    FreeURL();
    
    if (m_pSecurityInfo != NULL) {
        m_pSecurityInfo->Release();
    }

    if (_pProxyCreds)
    {
        delete _pProxyCreds;
    }
    if (_pServerCreds)
    {
        delete _pServerCreds;
    }

    if (_pszRealm)
    {
        FREE_MEMORY(_pszRealm);
    }

    if (_ServerInfo != NULL)
        _ServerInfo->Dereference();
    if (_OriginServer != NULL)
        _OriginServer->Dereference();

    if (g_pAsyncCount)
    {
        g_pAsyncCount->Release();
    }
    else
    {
        RIP(FALSE);
    }

    // There should be no work items left in the blocked queue.
    INET_ASSERT(_FsmWorkItemList.GetCount() == 0);
        
    DEBUG_LEAVE(0);
}


VOID
HTTP_REQUEST_HANDLE_OBJECT::SetProxyName(
    IN LPSTR lpszProxyHostName,
    IN DWORD dwProxyHostNameLength,
    IN INTERNET_PORT ProxyPort
    )

/*++

Routine Description:

    Set proxy name in object. If already have name, free it. Don't set name if
    current pointer is input

Arguments:

    lpszProxyHostName       - pointer to proxy name to add

    dwProxyHostNameLength   - length of proxy name

    ProxyPort               - port

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_REQUEST_HANDLE_OBJECT::SetProxyName",
                 "{%q, %d, %d}%q, %d, %d",
                 _ProxyHostName,
                 _ProxyHostNameLength,
                 _ProxyPort,
                 lpszProxyHostName,
                 dwProxyHostNameLength,
                 ProxyPort
                 ));

    if (lpszProxyHostName != _ProxyHostName) {
        if (_ProxyHostName != NULL) {
            _ProxyHostName = (LPSTR)FREE_MEMORY(_ProxyHostName);

            INET_ASSERT(_ProxyHostName == NULL);

            SetOverrideProxyMode(FALSE);
        }
        if (lpszProxyHostName != NULL) {
            _ProxyHostName = NEW_STRING(lpszProxyHostName);
            if (_ProxyHostName == NULL) {
                dwProxyHostNameLength = 0;
            }
        }
        _ProxyHostNameLength = dwProxyHostNameLength;
        _ProxyPort = ProxyPort;
    } else if (lpszProxyHostName != NULL) {

        DEBUG_PRINT(HTTP,
                    WARNING,
                    ("!!! lpszProxyHostName == _ProxyHostName (%#x)\n",
                    lpszProxyHostName
                    ));

        INET_ASSERT(dwProxyHostNameLength == _ProxyHostNameLength);
        INET_ASSERT(ProxyPort == _ProxyPort);

    }

    DEBUG_LEAVE(0);
}


VOID
HTTP_REQUEST_HANDLE_OBJECT::GetProxyName(
    OUT LPSTR* lplpszProxyHostName,
    OUT LPDWORD lpdwProxyHostNameLength,
    OUT LPINTERNET_PORT lpProxyPort
    )

/*++

Routine Description:

    Return address & length of proxy name plus proxy port

Arguments:

    lplpszProxyHostName     - returned address of name

    lpdwProxyHostNameLength - returned length of name

    lpProxyPort             - returned port

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_REQUEST_HANDLE_OBJECT::GetProxyName",
                 "{%q, %d, %d}%#x, %#x, %#x",
                 _ProxyHostName,
                 _ProxyHostNameLength,
                 _ProxyPort,
                 lplpszProxyHostName,
                 lpdwProxyHostNameLength,
                 lpProxyPort
                 ));

    *lplpszProxyHostName = _ProxyHostName;
    *lpdwProxyHostNameLength = _ProxyHostNameLength;
    *lpProxyPort = _ProxyPort;

    DEBUG_LEAVE(0);
}


VOID
HTTP_REQUEST_HANDLE_OBJECT::ReuseObject(
    VOID
    )

/*++

Routine Description:

    Make the object re-usable: clear out any received data and headers and
    reset the state to open

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_REQUEST_HANDLE_OBJECT::ReuseObje