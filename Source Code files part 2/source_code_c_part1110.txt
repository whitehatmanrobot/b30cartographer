             character in its buffer
  PtrToChar - Specifies a pointer to the character to copy

Return Value:

  None.

--*/

VOID
pAppendCharToGrowBufferA (
    IN OUT  PGROWBUFFER Buf,
    IN      PCSTR PtrToChar
    )
{
    PBYTE p;
    UINT Len;

    if (IsLeadByte (*PtrToChar) && PtrToChar[1]) {
        Len = 2;
    } else {
        Len = 1;
    }

    p = GbGrow (Buf, Len);
    CopyMemory (p, PtrToChar, (SIZE_T) Len);
}


VOID
pAppendCharToGrowBufferW (
    IN OUT  PGROWBUFFER Buf,
    IN      PCWSTR PtrToChar
    )
{
    PBYTE p;

    p = GbGrow (Buf, sizeof(WCHAR));
    CopyMemory (p, PtrToChar, sizeof(WCHAR));
}


/*++

Routine Description:

  CreateParsedPattern parses the expanded pattern string into a set of
  structures.  Parsing is considered expensive relative to testing the
  pattern, so callers should avoid calling this function inside loops.  See
  IsPatternMatchEx for a good description of the pattern string syntax.

Arguments:

  Pattern - Specifies the pattern string, which can include the extended
            wildcard syntax.

Return Value:

  A pointer to a parsed pattern structure, which the caller will use like a
  handle, or NULL if a syntax error occurred.

--*/

PPARSEDPATTERNA
CreateParsedPatternA (
    IN      PCSTR Pattern
    )
{
    PMHANDLE Pool;
    PPARSEDPATTERNA Struct;
    PATTERNSTATE State;
    BOOL CompoundPattern = FALSE;
    GROWBUFFER ExactMatchBuf = INIT_GROWBUFFER;
    GROWBUFFER SegmentArray = INIT_GROWBUFFER;
    GROWBUFFER PatternArray = INIT_GROWBUFFER;
    GROWBUFFER SetBuf = INIT_GROWBUFFER;
    PPATTERNPROPSA CurrentPattern;
    MBCHAR ch = 0;
    PCSTR LookAhead;
    PCSTR SetBegin = NULL;
    PATTERNSTATE ReturnState = 0;
    SEGMENTA Segment;
    PSEGMENTA SegmentElement;
    UINT MaxLen;

    Segment.Type = SEGMENTTYPE_UNKNOWN;

    Pool = PmCreateNamedPool ("Parsed Pattern");

    Struct = (PPARSEDPATTERNA) PmGetAlignedMemory (Pool, sizeof (PARSEDPATTERNA));

    ZeroMemory (Struct, sizeof (PARSEDPATTERNA));

    State = BEGIN_PATTERN;

    for (;;) {

        switch (State) {

        case BEGIN_PATTERN:
            //
            // Here we test for either a compound pattern (one that
            // is a brace-separated list), or a simple pattern (one
            // that does not have a brace).
            //

            if (_mbsnextc (Pattern) == '<') {
                CompoundPattern = TRUE;
                State = BEGIN_COMPOUND_PATTERN;
            } else if (*Pattern) {
                State = BEGIN_PATTERN_EXPR;
            } else {
                State = PATTERN_DONE;
            }

            break;

        case BEGIN_COMPOUND_PATTERN:
            //
            // We are looking for the start of a compound pattern.
            // Space is allowed inbetween the patterns, but not
            // at the start.
            //

            while (isspace ((INT)(_mbsnextc (Pattern)))) {
                Pattern = _mbsinc (Pattern);
            }

            if (*Pattern == 0) {
                State = PATTERN_DONE;
                break;
            }

            if (_mbsnextc (Pattern) == '<') {
                Pattern = _mbsinc (Pattern);
                State = BEGIN_PATTERN_EXPR;
            } else {
                DEBUGMSGA ((DBG_ERROR, "Syntax error in pattern: %s", Pattern));
                State = PATTERN_ERROR;
            }

            break;

        case BEGIN_PATTERN_EXPR:
            //
            // We are now ready to condense the expression.
            //

            State = PARSE_CHAR_EXPR_OR_END;
            ExactMatchBuf.End = 0;
            SegmentArray.End = 0;
            break;

        case PARSE_END_FOUND:

            State = END_PATTERN_EXPR;

            if (ExactMatchBuf.End) {
                ReturnState = State;
                State = SAVE_EXACT_MATCH;
            }

            break;

        case END_PATTERN_EXPR:

            //
            // Copy the segment array into the pool, reference the copy
            // in the pattern array
            //

            if (SegmentArray.End) {
                CurrentPattern = (PPATTERNPROPSA) GbGrow (&PatternArray, sizeof (PATTERNPROPSA));

                CurrentPattern->Segment = (PSEGMENTA) PmGetAlignedMemory (Pool, SegmentArray.End);
                CurrentPattern->SegmentCount = SegmentArray.End / sizeof (SEGMENTA);

                CopyMemory (
                    CurrentPattern->Segment,
                    SegmentArray.Buf,
                    (SIZE_T) SegmentArray.End
                    );
            }

            if (CompoundPattern && *Pattern) {
                State = BEGIN_COMPOUND_PATTERN;
            } else {
                State = PATTERN_DONE;
            }

            break;

        case PARSE_CHAR_EXPR_OR_END:
            //
            // We now accept the following:
            //
            // 1. The end of the string or end of a compound pattern
            // 2. An escaped character
            // 3. The start of an expression
            // 4. A non-syntax character
            //

            ch = _mbsnextc (Pattern);
            if (ch == '>' && CompoundPattern) {

                //
                // Case 1, we found the end of a compound pattern
                //

                Pattern = _mbsinc (Pattern);
                State = PARSE_END_FOUND;
                break;

            }

            if (*Pattern == 0) {

                //
                // Case 1, we found the end of the pattern
                //

                if (CompoundPattern) {
                    State = PATTERN_ERROR;
                } else {
                    State = PARSE_END_FOUND;
                }

                break;
            }

            if (ch == '^') {
                //
                // Case 2, we found an escaped character, so transfer
                // it to the buffer.
                //

                MYASSERT (
                    Segment.Type == SEGMENTTYPE_UNKNOWN ||
                    Segment.Type == SEGMENTTYPE_EXACTMATCH
                    );

                Segment.Type = SEGMENTTYPE_EXACTMATCH;

                Pattern = _mbsinc (Pattern);
                pAppendCharToGrowBufferA (&ExactMatchBuf, Pattern);
                Pattern = _mbsinc (Pattern);
                break;
            }

            if (ch == '*' || ch == '?') {
                //
                // Case 3, we found an expression.  Save the wildcard type
                // and parse the optional args.
                //

                if (ExactMatchBuf.End) {
                    State = SAVE_EXACT_MATCH;
                    ReturnState = PARSE_CHAR_EXPR_OR_END;
                    break;
                }

                ZeroMemory (&Segment, sizeof (Segment));

                if (ch == '*') {
                    Segment.Type = SEGMENTTYPE_OPTIONAL;
                } else {
                    Segment.Type = SEGMENTTYPE_REQUIRED;
                    Segment.Wildcard.MaxLen = 1;
                }

                Pattern = _mbsinc (Pattern);

                if (_mbsnextc (Pattern) == '[') {
                    Pattern = _mbsinc (Pattern);
                    State = LOOK_FOR_NUMBER;
                } else {
                    ReturnState = PARSE_CHAR_EXPR_OR_END;
                    State = SAVE_SEGMENT;
                }

                break;
            }

            //
            // Case 4, we don't know about this character, so just copy it
            // and continue parsing.
            //

            pAppendCharToGrowBufferA (&ExactMatchBuf, Pattern);
            Pattern = _mbsinc (Pattern);

            break;

        case SAVE_EXACT_MATCH:

            //
            // Put the string in ExactMatchBuf into a segment struct
            //

            pAppendCharToGrowBufferA (&ExactMatchBuf, "");
            Segment.Exact.LowerCasePhrase = PmDuplicateStringA (
                                                Pool,
                                                (PCSTR) ExactMatchBuf.Buf
                                                );
            Segment.Exact.PhraseBytes = ExactMatchBuf.End - sizeof (CHAR);

            MYASSERT (Segment.Exact.LowerCasePhrase);
            _mbslwr ((PSTR) Segment.Exact.LowerCasePhrase);

            Segment.Type = SEGMENTTYPE_EXACTMATCH;
            ExactMatchBuf.End = 0;

            // FALL THROUGH!!
        case SAVE_SEGMENT:

            //
            // Put the segment element into the segment array
            //

            SegmentElement = (PSEGMENTA) GbGrow (&SegmentArray, sizeof (SEGMENTA));
            CopyMemory (SegmentElement, &Segment, sizeof (SEGMENTA));

            State = ReturnState;
            break;

        case LOOK_FOR_NUMBER:
            //
            // Here we are inside a bracket, and there is an optional
            // numeric arg, which must be followed by a colon.  Test
            // that here.
            //

            LookAhead = Pattern;
            MaxLen = 0;

            while (*LookAhead >= '0' && *LookAhead <= '9') {

                MaxLen = MaxLen * 10 + (*LookAhead - '0');
                LookAhead++;
            }

            if (LookAhead > Pattern && _mbsnextc (LookAhead) == ':') {
                Pattern = _mbsinc (LookAhead);

                //
                // Check for special case syntax error: ?[0:]
                //

                if (Segment.Type == SEGMENTTYPE_EXACTMATCH && !MaxLen) {
                    State = PATTERN_ERROR;
                    break;
                }

                Segment.Wildcard.MaxLen = MaxLen;
            }

            SetBegin = Pattern;
            State = LOOK_FOR_INCLUDE;

            SetBuf.End = 0;

            break;

        case LOOK_FOR_INCLUDE:
            //
            // Here we are inside a bracket, past an optional numeric
            // arg.  Now we look for all the include sets, which are
            // optional.  We have the following possibilities:
            //
            // 1. End of set
            // 2. An exclude set that needs to be skipped
            // 3. A valid include set
            // 4. Error
            //
            // We look at SetBegin, and not Pattern.
            //

            MYASSERT (SetBegin);

            ch = _mbsnextc (SetBegin);
            if (ch == ']') {
                //
                // Case 1: end of set
                //

                if (SetBuf.End) {
                    pAppendCharToGrowBufferA (&SetBuf, "");
                    Segment.Wildcard.IncludeSet = PmDuplicateStringA (
                                                        Pool,
                                                        (PCSTR) SetBuf.Buf
                                                        );
                    _mbslwr ((PSTR) Segment.Wildcard.IncludeSet);
                } else {
                    Segment.Wildcard.IncludeSet = NULL;
                }

                SetBuf.End = 0;

                State = LOOK_FOR_EXCLUDE;
                SetBegin = Pattern;
                break;
            }

            if (ch == '!') {
                //
                // Case 2: an exclude set
                //

                SetBegin = _mbsinc (SetBegin);
                State = SKIP_EXCLUDE_SET;
                ReturnState = LOOK_FOR_INCLUDE;
                break;
            }

            if (*SetBegin == 0) {   //lint !e613
                State = PATTERN_ERROR;
                break;
            }

            //
            // Case 3: a valid include set.
            //

            State = CONDENSE_SET;
            ReturnState = LOOK_FOR_INCLUDE;
            break;

        case LOOK_FOR_EXCLUDE:
            //
            // Here we are inside a bracket, past an optional numeric
            // arg.  All include sets are in the condensing buffer.
            // Now we look for all the exclude sets, which are
            // optional.  We have the following possibilities:
            //
            // 1. End of set
            // 2. A valid exclude set
            // 3. An include set that needs to be skipped
            // 4. Error
            //
            // We look at SetBegin, and not Pattern.
            //

            ch = _mbsnextc (SetBegin);
            if (ch == ']') {
                //
                // Case 1: end of set; we're done with this expr
                //

                if (SetBuf.End) {
                    pAppendCharToGrowBufferA (&SetBuf, "");
                    Segment.Wildcard.ExcludeSet = PmDuplicateStringA (
                                                        Pool,
                                                        (PCSTR) SetBuf.Buf
                                                        );
                    _mbslwr ((PSTR) Segment.Wildcard.ExcludeSet);
                } else {
                    Segment.Wildcard.ExcludeSet = NULL;
                }

                SetBuf.End = 0;
                State = SAVE_SEGMENT;
                ReturnState = PARSE_CHAR_EXPR_OR_END;
                Pattern = _mbsinc (SetBegin);
                break;
            }

            if (ch == '!') {
                //
                // Case 2: a valid exclude set; save it
                //

                SetBegin = _mbsinc (SetBegin);

                if (_mbsnextc (SetBegin) != '(') {
                    State = PATTERN_ERROR;
                    break;
                }

                SetBegin = _mbsinc (SetBegin);

                State = CONDENSE_SET;
                ReturnState = LOOK_FOR_EXCLUDE;
                break;
            }

            if (*SetBegin == 0) {   //lint !e613
                State = PATTERN_ERROR;
                break;
            }

            //
            // Case 3: an include set that needs to be skipped.
            //

            State = SKIP_INCLUDE_SET;
            ReturnState = LOOK_FOR_EXCLUDE;
            break;

        case CONDENSE_SET:
            //
            // Here SetBegin points to a set range, and it is our
            // job to copy the range into the set buffer, and
            // return back to the previous state.
            //

            //
            // Copy the character at SetBegin
            //

            if (_mbsnextc (SetBegin) == '^') {
                SetBegin = _mbsinc (SetBegin);
                if (*SetBegin == 0) {
                    State = PATTERN_ERROR;
                    break;
                }
            }
            pAppendCharToGrowBufferA (&SetBuf, SetBegin);

            //
            // Check if this is a range or not
            //

            LookAhead = _mbsinc (SetBegin);

            if (_mbsnextc (LookAhead) == '-') {

                //
                // Range, copy the character after the dash
                //

                SetBegin = _mbsinc (LookAhead);
                if (*SetBegin == 0) {
                    State = PATTERN_ERROR;
                    break;
                }

                if (_mbsnextc (SetBegin) == '^') {
                    SetBegin = _mbsinc (SetBegin);
                    if (*SetBegin == 0) {
                        State = PATTERN_ERROR;
                        break;
                    }
                }
                pAppendCharToGrowBufferA (&SetBuf, SetBegin);

            } else {

                //
                // A single character, copy the character again
                //

                pAppendCharToGrowBufferA (&SetBuf, SetBegin);
            }

            SetBegin = _mbsinc (SetBegin);
            ch = _mbsnextc (SetBegin);

            //
            // If this is an exclude set, we must have a closing paren
            // or a comma
            //

            State = ReturnState;

            if (ReturnState == LOOK_FOR_EXCLUDE) {

                if (ch == ')') {

                    SetBegin = _mbsinc (SetBegin);
                    ch = _mbsnextc (SetBegin);

                } else if (ch != ',') {
                    State = PATTERN_ERROR;
                } else {
                    //
                    // Continue condensing the next part of this exclude set
                    //

                    State = CONDENSE_SET;
                }
            }

            //
            // We either need a comma or a close brace
            //

            if (ch == ',') {
                SetBegin = _mbsinc (SetBegin);
            } else if (ch != ']') {
                State = PATTERN_ERROR;
            }

            break;

        case SKIP_EXCLUDE_SET:
            //
            // Skip over the parenthesis group, assuming it is syntatically
            // correct, and return to the previous state.
            //

            if (_mbsnextc (SetBegin) != '(') {
                State = PATTERN_ERROR;
                break;
            }

            SetBegin = _mbsinc (SetBegin);

            while (*SetBegin) {
                if (_mbsnextc (SetBegin) == '^') {

                    SetBegin = _mbsinc (SetBegin);

                } else if (_mbsnextc (SetBegin) == ')') {

                    break;

                }

                if (IsLeadByte (SetBegin[0]) && SetBegin[1]) {
                    SetBegin += 2;
                } else {
                    SetBegin += 1;
                }
            }

            if (*SetBegin == 0) {
                State = PATTERN_ERROR;
                break;
            }

            SetBegin = _mbsinc (SetBegin);

            //
            // Now we are either at a comma or a close brace
            //

            ch = _mbsnextc (SetBegin);
            State = ReturnState;

            if (ch == ',') {
                SetBegin = _mbsinc (SetBegin);
            } else if (ch != ']') {
                State = PATTERN_ERROR;
            }

            break;

        case SKIP_INCLUDE_SET:
            //
            // Skip to the next comma or closing brace.  We know it is
            // syntatically correct by now.
            //

            ch = 0;

            while (*SetBegin) { //lint !e613
                ch = _mbsnextc (SetBegin);
                if (ch == '^') {

                    SetBegin = _mbsinc (SetBegin);

                } else if (ch == ',' || ch == ']') {

                    break;

                }

                SetBegin = _mbsinc (SetBegin);
            }

            MYASSERT (*SetBegin);   //lint !e794

            if (ch == ',') {
                SetBegin = _mbsinc (SetBegin);
            }

            State = ReturnState;
            break;
        }   //lint !e787

        if (State == PATTERN_DONE || State == PATTERN_ERROR) {
            break;
        }
    }

    GbFree (&ExactMatchBuf);
    GbFree (&SetBuf);
    GbFree (&SegmentArray);

    if (State == PATTERN_ERROR) {
        GbFree (&PatternArray);
        PmDestroyPool (Pool);
        return NULL;
    }

    if (PatternArray.End == 0) {
        //build an empty parsed pattern
        GbFree (&PatternArray);
        Struct->PatternCount = 1;
        Struct->Pool = Pool;
        Struct->Pattern = (PPATTERNPROPSA) PmGetAlignedMemory (
                                                Pool,
                                                sizeof (PATTERNPROPSA)
                                                );
        Struct->Pattern[0].SegmentCount = 1;
        Struct->Pattern[0].Segment = (PSEGMENTA) PmGetAlignedMemory (
                                                    Pool,
                                                    sizeof (PSEGMENTA)
                                                    );
        Struct->Pattern[0].Segment[0].Type = SEGMENTTYPE_EXACTMATCH;
        Struct->Pattern[0].Segment[0].Exact.LowerCasePhrase = PmDuplicateStringA (Pool, "");
        Struct->Pattern[0].Segment[0].Exact.PhraseBytes = 0;

        return Struct;
    }

    //
    // Copy the fully parsed pattern array into the return struct
    //

    Struct->Pattern = (PPATTERNPROPSA) PmGetAlignedMemory (
                                            Pool,
                                            PatternArray.End
                                            );


    CopyMemory (Struct->Pattern, PatternArray.Buf, (SIZE_T) PatternArray.End);
    Struct->PatternCount = PatternArray.End / sizeof (PATTERNPROPSA);
    Struct->Pool = Pool;

    GbFree (&PatternArray);

    return Struct;
}


PPARSEDPATTERNW
CreateParsedPatternW (
    IN      PCWSTR Pattern
    )
{
    PMHANDLE Pool;
    PPARSEDPATTERNW Struct;
    PATTERNSTATE State;
    BOOL CompoundPattern = FALSE;
    GROWBUFFER ExactMatchBuf = INIT_GROWBUFFER;
    GROWBUFFER SegmentArray = INIT_GROWBUFFER;
    GROWBUFFER PatternArray = INIT_GROWBUFFER;
    GROWBUFFER SetBuf = INIT_GROWBUFFER;
    PPATTERNPROPSW CurrentPattern;
    WCHAR ch = 0;
    PCWSTR LookAhead;
    PCWSTR SetBegin = NULL;
    PATTERNSTATE ReturnState = 0;
    SEGMENTW Segment;
    PSEGMENTW SegmentElement;
    UINT MaxLen;

    Segment.Type = SEGMENTTYPE_UNKNOWN;

    Pool = PmCreateNamedPool ("Parsed Pattern");

    Struct = (PPARSEDPATTERNW) PmGetAlignedMemory (Pool, sizeof (PARSEDPATTERNW));

    ZeroMemory (Struct, sizeof (PARSEDPATTERNW));

    State = BEGIN_PATTERN;

    for (;;) {

        switch (State) {

        case BEGIN_PATTERN:
            //
            // Here we test for either a compound pattern (one that
            // is a brace-separated list), or a simple pattern (one
            // that does not have a brace).
            //

            if (*Pattern == L'<') {
                CompoundPattern = TRUE;
                State = BEGIN_COMPOUND_PATTERN;
            } else if (*Pattern) {
                State = BEGIN_PATTERN_EXPR;
            } else {
                State = PATTERN_DONE;
            }

            break;

        case BEGIN_COMPOUND_PATTERN:
            //
            // We are looking for the start of a compound pattern.
            // Space is allowed inbetween the patterns, but not
            // at the start.
            //

            while (iswspace (*Pattern)) {
                Pattern++;
            }

            if (*Pattern == 0) {
                State = PATTERN_DONE;
                break;
            }

            if (*Pattern == L'<') {
                Pattern++;
                State = BEGIN_PATTERN_EXPR;
            } else {
                DEBUGMSGW ((DBG_ERROR, "Syntax error in pattern: %s", Pattern));
                State = PATTERN_ERROR;
            }

            break;

        case BEGIN_PATTERN_EXPR:
            //
            // We are now ready to condense the expression.
            //

            State = PARSE_CHAR_EXPR_OR_END;
            ExactMatchBuf.End = 0;
            SegmentArray.End = 0;
            break;

        case PARSE_END_FOUND:

            State = END_PATTERN_EXPR;

            if (ExactMatchBuf.End) {
                ReturnState = State;
                State = SAVE_EXACT_MATCH;
            }

            break;

        case END_PATTERN_EXPR:

            //
            // Copy the segment array into the pool, reference the copy
            // in the pattern array
            //

            if (SegmentArray.End) {
                CurrentPattern = (PPATTERNPROPSW) GbGrow (&PatternArray, sizeof (PATTERNPROPSW));

                CurrentPattern->Segment = (PSEGMENTW) PmGetAlignedMemory (Pool, SegmentArray.End);
                CurrentPattern->SegmentCount = SegmentArray.End / sizeof (SEGMENTW);

                CopyMemory (
                    CurrentPattern->Segment,
                    SegmentArray.Buf,
                    (SIZE_T) SegmentArray.End
                    );
            }

            if (CompoundPattern && *Pattern) {
                State = BEGIN_COMPOUND_PATTERN;
            } else {
                State = PATTERN_DONE;
            }

            break;

        case PARSE_CHAR_EXPR_OR_END:
            //
            // We now accept the following:
            //
            // 1. The end of the string or end of a compound pattern
            // 2. An escaped character
            // 3. The start of an expression
            // 4. A non-syntax character
            //

            ch = *Pattern;
            if (ch == L'>' && CompoundPattern) {

                //
                // Case 1, we found the end of a compound pattern
                //

                Pattern++;
                State = PARSE_END_FOUND;
                break;

            }

            if (*Pattern == 0) {

                //
                // Case 1, we found the end of the pattern
                //

                if (CompoundPattern) {
                    State = PATTERN_ERROR;
                } else {
                    State = PARSE_END_FOUND;
                }

                break;
            }

            if (ch == L'^') {
                //
                // Case 2, we found an escaped character, so transfer
                // it to the buffer.
                //

                MYASSERT (
                    Segment.Type == SEGMENTTYPE_UNKNOWN ||
                    Segment.Type == SEGMENTTYPE_EXACTMATCH
                    );

                Segment.Type = SEGMENTTYPE_EXACTMATCH;

                Pattern++;
                pAppendCharToGrowBufferW (&ExactMatchBuf, Pattern);
                Pattern++;
                break;
            }

            if (ch == L'*' || ch == L'?') {
                //
                // Case 3, we found an expression.  Save the wildcard type
                // and parse the optional args.
                //

                if (ExactMatchBuf.End) {
                    State = SAVE_EXACT_MATCH;
                    ReturnState = PARSE_CHAR_EXPR_OR_END;
                    break;
                }

                ZeroMemory (&Segment, sizeof (Segment));

                if (ch == L'*') {
                    Segment.Type = SEGMENTTYPE_OPTIONAL;
                } else {
                    Segment.Type = SEGMENTTYPE_REQUIRED;
                    Segment.Wildcard.MaxLen = 1;
                }

                Pattern++;

                if (*Pattern == L'[') {
                    Pattern++;
                    State = LOOK_FOR_NUMBER;
                } else {
                    ReturnState = PARSE_CHAR_EXPR_OR_END;
                    State = SAVE_SEGMENT;
                }

                break;
            }

            //
            // Case 4, we don't know about this character, so just copy it
            // and continue parsing.
            //

            pAppendCharToGrowBufferW (&ExactMatchBuf, Pattern);
            Pattern++;

            break;

        case SAVE_EXACT_MATCH:

            //
            // Put the string in ExactMatchBuf into a segment struct
            //

            pAppendCharToGrowBufferW (&ExactMatchBuf, L"");
            Segment.Exact.LowerCasePhrase = PmDuplicateStringW (
                                                Pool,
                                                (PCWSTR) ExactMatchBuf.Buf
                                                );  //lint !e64
            Segment.Exact.PhraseBytes = ExactMatchBuf.End - sizeof (WCHAR);

            MYASSERT (Segment.Exact.LowerCasePhrase);
            _wcslwr ((PWSTR) Segment.Exact.LowerCasePhrase);

            Segment.Type = SEGMENTTYPE_EXACTMATCH;
            ExactMatchBuf.End = 0;

            // FALL THROUGH!!
        case SAVE_SEGMENT:

            //
            // Put the segment element into the segment array
            //

            SegmentElement = (PSEGMENTW) GbGrow (&SegmentArray, sizeof (SEGMENTW));
            CopyMemory (SegmentElement, &Segment, sizeof (SEGMENTW));

            State = ReturnState;
            break;

        case LOOK_FOR_NUMBER:
            //
            // Here we are inside a bracket, and there is an optional
            // numeric arg, which must be followed by a colon.  Test
            // that here.
            //

            LookAhead = Pattern;
            MaxLen = 0;

            while (*LookAhead >= L'0' && *LookAhead <= L'9') {

                MaxLen = MaxLen * 10 + (*LookAhead - L'0');
                LookAhead++;
            }

            if (LookAhead > Pattern && *LookAhead == L':') {
                Pattern = LookAhead + 1;

                //
                // Check for special case syntax error: ?[0:]
                //

                if (Segment.Type == SEGMENTTYPE_EXACTMATCH && !MaxLen) {
                    State = PATTERN_ERROR;
                    break;
                }

                Segment.Wildcard.MaxLen = MaxLen;
            }

            SetBegin = Pattern;
            State = LOOK_FOR_INCLUDE;

            SetBuf.End = 0;

            break;

        case LOOK_FOR_INCLUDE:
            //
            // Here we are inside a bracket, past an optional numeric
            // arg.  Now we look for all the include sets, which are
            // optional.  We have the following possibilities:
            //
            // 1. End of set
            // 2. An exclude set that needs to be skipped
            // 3. A valid include set
            // 4. Error
            //
            // We look at SetBegin, and not Pattern.
            //

            if (!SetBegin) {
                State = PATTERN_ERROR;
                break;
            }

            ch = *SetBegin;
            if (ch == L']') {
                //
                // Case 1: end of set
                //

                if (SetBuf.End) {
                    pAppendCharToGrowBufferW (&SetBuf, L"");
                    Segment.Wildcard.IncludeSet = PmDuplicateStringW (
                                                        Pool,
                                                        (PCWSTR) SetBuf.Buf
                                                        );  //lint !e64
                    _wcslwr ((PWSTR) Segment.Wildcard.IncludeSet);
                } else {
                    Segment.Wildcard.IncludeSet = NULL;
                }

                SetBuf.End = 0;

                State = LOOK_FOR_EXCLUDE;
                SetBegin = Pattern;
                break;
            }

            if (ch == L'!') {
                //
                // Case 2: an exclude set
                //

                SetBegin++;
                State = SKIP_EXCLUDE_SET;
                ReturnState = LOOK_FOR_INCLUDE;
                break;
            }

            if (*SetBegin == 0) {
                State = PATTERN_ERROR;
                break;
            }

            //
            // Case 3: a valid include set.
            //

            State = CONDENSE_SET;
            ReturnState = LOOK_FOR_INCLUDE;
            break;

        case LOOK_FOR_EXCLUDE:
            //
            // Here we are inside a bracket, past an optional numeric
            // arg.  All include sets are in the condensing buffer.
            // Now we look for all the exclude sets, which are
            // optional.  We have the following possibilities:
            //
            // 1. End of set
            // 2. A valid exclude set
            // 3. An include set that needs to be skipped
            // 4. Error
            //
            // We look at SetBegin, and not Pattern.
            //

            if (!SetBegin) {
                State = PATTERN_ERROR;
                break;
            }

            ch = *SetBegin;
            if (ch == L']') {
                //
                // Case 1: end of set; we're done with this expr
                //

                if (SetBuf.End) {
                    pAppendCharToGrowBufferW (&SetBuf, L"");
                    Segment.Wildcard.ExcludeSet = PmDuplicateStringW (
                                                        Pool,
                                                        (PCWSTR) SetBuf.Buf
                                                        );  //lint !e64
                    _wcslwr ((PWSTR) Segment.Wildcard.ExcludeSet);
                } else {
                    Segment.Wildcard.ExcludeSet = NULL;
                }

                SetBuf.End = 0;
                State = SAVE_SEGMENT;
                ReturnState = PARSE_CHAR_EXPR_OR_END;
                Pattern = SetBegin + 1;
                break;
            }

            if (ch == L'!') {
                //
                // Case 2: a valid exclude set; save it
                //

                SetBegin++; //lint !e613

                if (*SetBegin != L'(') {
                    State = PATTERN_ERROR;
                    break;
                }

                SetBegin++;

                State = CONDENSE_SET;
                ReturnState = LOOK_FOR_EXCLUDE;
                break;
            }

            if (*SetBegin == 0) {
                State = PATTERN_ERROR;
                break;
            }

            //
            // Case 3: an include set that needs to be skipped.
            //

            State = SKIP_INCLUDE_SET;
            ReturnState = LOOK_FOR_EXCLUDE;
            break;

        case CONDENSE_SET:
            //
            // Here SetBegin points to a set range, and it is our
            // job to copy the range into the set buffer, and
            // return back to the previous state.
            //

            //
            // Copy the character at SetBegin
            //

            if (!SetBegin) {
                State = PATTERN_ERROR;
                break;
            }

            if (*SetBegin == L'^') {
                SetBegin++;
                if (*SetBegin == 0) {
                    State = PATTERN_ERROR;
                    break;
                }
            }
            pAppendCharToGrowBufferW (&SetBuf, SetBegin);

            //
            // Check if this is a range or not
            //

            LookAhead = SetBegin + 1;

            if (*LookAhead == L'-') {

                //
                // Range, copy the character after the dash
                //

                SetBegin = LookAhead + 1;
                if (*SetBegin == 0) {
                    State = PATTERN_ERROR;
                    break;
                }

                if (*SetBegin == L'^') {
                    SetBegin++;
                    if (*SetBegin == 0) {
                        State = PATTERN_ERROR;
                        break;
                    }
                }
                pAppendCharToGrowBufferW (&SetBuf, SetBegin);

            } else {

                //
                // A single character, copy the character again
                //

                pAppendCharToGrowBufferW (&SetBuf, SetBegin);
            }

            SetBegin++;
            ch = *SetBegin;

            //
            // If this is an exclude set, we must have a closing paren
            // or a comma
            //

            State = ReturnState;

            if (ReturnState == LOOK_FOR_EXCLUDE) {

                if (ch == L')') {

                    SetBegin++;
                    ch = *SetBegin;

                } else if (ch != L',') {
                    State = PATTERN_ERROR;
                } else {
                    //
                    // Continue condensing the next part of this exclude set
                    //

                    State = CONDENSE_SET;
                }
            }

            //
            // We either need a comma or a close brace
            //

            if (ch == L',') {
                SetBegin++;
            } else if (ch != L']') {
                State = PATTERN_ERROR;
            }

            break;

        case SKIP_EXCLUDE_SET:
            //
            // Skip over the parenthesis group, assuming it is syntatically
            // correct, and return to the previous state.
            //

            if (!SetBegin) {
                State = PATTERN_ERROR;
                break;
            }

            if (*SetBegin != L'(') {
                State = PATTERN_ERROR;
                break;
            }

            SetBegin++;

            while (*SetBegin) {
                if (*SetBegin == L'^') {

                    SetBegin++;

                } else if (*SetBegin == L')') {

                    break;

                }

                SetBegin++;
            }

            if (*SetBegin == 0) {
                State = PATTERN_ERROR;
                break;
            }

            SetBegin++;

            //
            // Now we are either at a comma or a close brace
            //

            ch = *SetBegin;
            State = ReturnState;

            if (ch == L',') {
                SetBegin++;
            } else if (ch != L']') {
                State = PATTERN_ERROR;
            }

            break;

        case SKIP_INCLUDE_SET:
            //
            // Skip to the next comma or closing brace.  We know it is
            // syntatically correct by now.
            //

            if (!SetBegin) {
                State = PATTERN_ERROR;
                break;
            }

            ch = 0;

            while (*SetBegin) {
                ch = *SetBegin;
                if (ch == L'^') {

                    SetBegin++; //lint !e613

                } else if (ch == L',' || ch == L']') {

                    break;

                }

                SetBegin++;
            }

            MYASSERT (*SetBegin);

            if (ch == L',') {
                SetBegin++;
            }

            State = ReturnState;
            break;
        }   //lint !e787

        if (State == PATTERN_DONE || State == PATTERN_ERROR) {
            break;
        }
    }

    GbFree (&ExactMatchBuf);
    GbFree (&SetBuf);
    GbFree (&SegmentArray);

    if (State == PATTERN_ERROR) {
        GbFree (&PatternArray);
        PmDestroyPool (Pool);
        return NULL;
    }

    if (PatternArray.End == 0) {
        //build an empty parsed pattern
        GbFree (&PatternArray);
        Struct->PatternCount = 1;
        Struct->Pool = Pool;
        Struct->Pattern = (PPATTERNPROPSW) PmGetAlignedMemory (
                                                Pool,
                                                sizeof (PATTERNPROPSW)
                                                );
        Struct->Pattern[0].SegmentCount = 1;
        Struct->Pattern[0].Segment = (PSEGMENTW) PmGetAlignedMemory (
                                                    Pool,
                                                    sizeof (PSEGMENTW)
                                                    );
        Struct->Pattern[0].Segment[0].Type = SEGMENTTYPE_EXACTMATCH;
        Struct->Pattern[0].Segment[0].Exact.LowerCasePhrase = PmDuplicateStringW (Pool, L"");
        Struct->Pattern[0].Segment[0].Exact.PhraseBytes = 0;

        return Struct;
    }

    //
    // Copy the fully parsed pattern array into the return struct
    //

    Struct->Pattern = (PPATTERNPROPSW) PmGetAlignedMemory (
                                            Pool,
                                            PatternArray.End
                                            );


    CopyMemory (Struct->Pattern, PatternArray.Buf, (SIZE_T) PatternArray.End);
    Struct->PatternCount = PatternArray.End / sizeof (PATTERNPROPSW);
    Struct->Pool = Pool;

    GbFree (&PatternArray);

    return Struct;
}

BOOL
WildCharsPatternA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    UINT i,j;

    if (!ParsedPattern) {
        return FALSE;
    }
    for (i=0; i<ParsedPattern->PatternCount; i++) {
        if (ParsedPattern->Pattern[i].SegmentCount > 1) {
            return TRUE;
        }
        for (j=0; j<ParsedPattern->Pattern[i].SegmentCount; j++) {
            if ((ParsedPattern->Pattern[i].Segment[j].Type == SEGMENTTYPE_OPTIONAL) ||
                (ParsedPattern->Pattern[i].Segment[j].Type == SEGMENTTYPE_REQUIRED)
                ) {
                return TRUE;
            }
        }
    }
    return FALSE;
}

BOOL
WildCharsPatternW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    UINT i,j;

    if (!ParsedPattern) {
        return FALSE;
    }
    for (i=0; i<ParsedPattern->PatternCount; i++) {
        if (ParsedPattern->Pattern[i].SegmentCount > 1) {
            return TRUE;
        }
        for (j=0; j<ParsedPattern->Pattern[i].SegmentCount; j++) {
            if ((ParsedPattern->Pattern[i].Segment[j].Type == SEGMENTTYPE_OPTIONAL) ||
                (ParsedPattern->Pattern[i].Segment[j].Type == SEGMENTTYPE_REQUIRED)
                ) {
                return TRUE;
            }
        }
    }
    return FALSE;
}


BOOL
ParsedPatternTrimLastCharA (
    IN OUT  PPARSEDPATTERNA ParsedPattern
    )
{
    if (!ParsedPatternHasRootA (ParsedPattern)) {
        return FALSE;
    }
    ParsedPattern->Pattern->Segment[0].Exact.PhraseBytes -= DWSIZEOF (CHAR);
    *(PSTR)((PBYTE)ParsedPattern->Pattern->Segment[0].Exact.LowerCasePhrase +
            ParsedPattern->Pattern->Segment[0].Exact.PhraseBytes) = 0;
    return TRUE;
}

BOOL
ParsedPatternTrimLastCharW (
    IN OUT  PPARSEDPATTERNW ParsedPattern
    )
{
    if (!ParsedPatternHasRootW (ParsedPattern)) {
        return FALSE;
    }
    ParsedPattern->Pattern->Segment[0].Exact.PhraseBytes -= DWSIZEOF (WCHAR);
    *(PWSTR)((PBYTE)ParsedPattern->Pattern->Segment[0].Exact.LowerCasePhrase +
             ParsedPattern->Pattern->Segment[0].Exact.PhraseBytes) = 0;
    return TRUE;
}


VOID
UBINTtoHexA (
    IN      UBINT Number,
    OUT     PSTR String
    )
{
#ifdef IA64
    sprintf (String, "0x%08X%08X", (DWORD)(Number >> 32), (DWORD)Number);
#else
    sprintf (String, "0x00000000%08X", Number);
#endif
}

VOID
UBINTtoHexW (
    IN      UBINT Number,
    OUT     PWSTR String
    )
{
#ifdef IA64
    swprintf (String, L"0x%08X%08X", (DWORD)(Number >> 32), (DWORD)Number);
#else
    swprintf (String, L"0x00000000%08X", Number);
#endif
}

VOID
UBINTtoDecA (
    IN      UBINT Number,
    OUT     PSTR String
    )
{
#ifdef IA64
    sprintf (String, "%I64u", Number);
#else
    sprintf (String, "%lu", Number);
#endif
}

VOID
UBINTtoDecW (
    IN      UBINT Number,
    OUT     PWSTR String
    )
{
#ifdef IA64
    swprintf (String, L"%I64u", Number);
#else
    swprintf (String, L"%lu", Number);
#endif
}

VOID
BINTtoDecA (
    IN      BINT Number,
    OUT     PSTR String
    )
{
#ifdef IA64
    sprintf (String, "%I64d", Number);
#else
    sprintf (String, "%ld", Number);
#endif
}

VOID
BINTtoDecW (
    IN      BINT Number,
    OUT     PWSTR String
    )
{
#ifdef IA64
    swprintf (String, L"%I64d", Number);
#else
    swprintf (String, L"%ld", Number);
#endif
}

VOID
PrintPattern (
    IN      PCSTR PatStr,
    IN      PPARSEDPATTERNA Struct
    )

/*++

Routine Description:

  PrintPattern is used for debugging the pattern parsing and testing
  functions.

Arguments:

  PatStr - Specifies the original pattern string (which is printed as a
           heading)
  Struct - Specifies the parsed pattern struct

Return Value:

  None.

--*/

{
    CHAR poolStr [sizeof (UBINT) * 2 + 2 + 1];
    UINT u, v;

    printf ("Pattern: %s\n\n", PatStr);

    if (!Struct) {
        printf ("Invalid Pattern\n\n");
        return;
    }

    printf ("PatternCount: %u\n", Struct->PatternCount);
    UBINTtoHexA ((UBINT)Struct->Pool, poolStr);
    printf ("Pool: %s\n", poolStr);

    for (u = 0 ; u < Struct->PatternCount ; u++) {

        printf ("  Segment Count: %u\n", Struct->Pattern[u].SegmentCount);

        for (v = 0 ; v < Struct->Pattern->SegmentCount ; v++) {
            printf ("    Type: ");

            switch (Struct->Pattern[u].Segment[v].Type) {

            case SEGMENTTYPE_EXACTMATCH:
                printf ("SEGMENTTYPE_EXACTMATCH\n");
                printf ("      String: %s\n", Struct->Pattern[u].Segment[v].Exact.LowerCasePhrase);
                printf ("      Bytes: %u\n", Struct->Pattern[u].Segment[v].Exact.PhraseBytes);
                break;

            case SEGMENTTYPE_OPTIONAL:
                printf ("SEGMENTTYPE_OPTIONAL\n");
                printf ("      MaxLen: %u\n", Struct->Pattern[u].Segment[v].Wildcard.MaxLen);
                printf ("      IncludeSet: %s\n", Struct->Pattern[u].Segment[v].Wildcard.IncludeSet);
                printf ("      ExcludeSet: %s\n", Struct->Pattern[u].Segment[v].Wildcard.ExcludeSet);
                break;

            case SEGMENTTYPE_REQUIRED:
                printf ("SEGMENTTYPE_REQUIRED\n");
                printf ("      MaxLen: %u\n", Struct->Pattern[u].Segment[v].Wildcard.MaxLen);
                printf ("      IncludeSet: %s\n", Struct->Pattern[u].Segment[v].Wildcard.IncludeSet);
                printf ("      ExcludeSet: %s\n", Struct->Pattern[u].Segment[v].Wildcard.ExcludeSet);
                break;
            }   //lint !e744
        }

    }

    printf ("\n");
}



/*++

Routine Description:

  TestParsedPattern finds the end of the string to test and calls
  TestParsedPatternAB.

Arguments:

  ParsedPattern - Specifies the parsed pattern structure as returned by
                  CreateParsedPattern
  StringToTest  - Specifies the string to test against the pattern

Return Value:

  TRUE if the string fits the pattern, FALSE if it does not

--*/

BOOL
TestParsedPatternA (
    IN      PPARSEDPATTERNA ParsedPattern,
    IN      PCSTR StringToTest
    )
{
    PCSTR EndPlusOne = GetEndOfStringA (StringToTest);

    return TestParsedPatternABA (ParsedPattern, StringToTest, EndPlusOne);
}


BOOL
TestParsedPatternW (
    IN      PPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR StringToTest
    )
{
    PCWSTR EndPlusOne = GetEndOfStringW (StringToTest);

    return TestParsedPatternABW (ParsedPattern, StringToTest, EndPlusOne);
}


/*++

Routine Description:

  pTestSet tests a character against an include and exclude set. The sets are
  formatted in pairs of characters, where the first character in the pair is
  the low range, and the second character in the pair is the high range.  The
  specified character will automatically be lower-cased, and all whitespace
  characters are tested against the space character (ascii 32).

Arguments:

  ch         - Specifies the character to test.  This character is converted
               to lower case before the test.
  IncludeSet - Specifies the set of characters that ch must be a member of.
               If NULL is specified, then the include set is all characters.
  ExcludeSet - Specifies the range of characters that ch cannot be a member
               of.  If NULL is specified, then no characters are excluded.

Return Value:

  TRUE if ch is in the include set and not in the exclude set; FALSE
  otherwise.

--*/

BOOL
pTestSetA (
    IN      MBCHAR ch,
    IN      PCSTR IncludeSet,               OPTIONAL
    IN      PCSTR ExcludeSet                OPTIONAL
    )
{
    MBCHAR LowChar, HighChar;
    BOOL b = TRUE;

    if (isspace ((INT)ch)) {
        if (ch != ' ') {
            if (pTestSetA (' ', IncludeSet, ExcludeSet)) {
                return TRUE;
            }
        }
    } else {
        ch = _mbctolower (ch);
    }

    if (IncludeSet) {

        b = FALSE;

        while (*IncludeSet) {

            LowChar = _mbsnextc (IncludeSet);
            IncludeSet = _mbsinc (IncludeSet);
            HighChar = _mbsnextc (IncludeSet);
            IncludeSet = _mbsinc (IncludeSet);

            if (ch >= LowChar && ch <= HighChar) {
                b = TRUE;
                break;
            }
        }
    }

    if (b && ExcludeSet) {

        while (*ExcludeSet) {

            LowChar = _mbsnextc (ExcludeSet);
            ExcludeSet = _mbsinc (ExcludeSet);
            HighChar = _mbsnextc (ExcludeSet);
            ExcludeSet = _mbsinc (ExcludeSet);

            if (ch >= LowChar && ch <= HighChar) {
                b = FALSE;
                break;
            }
        }
    }

    return b;
}


BOOL
pTestSetW (
    IN      WCHAR ch,
    IN      PCWSTR IncludeSet,              OPTIONAL
    IN      PCWSTR ExcludeSet               OPTIONAL
    )
{
    WCHAR LowChar, HighChar;
    BOOL b = TRUE;

    if (iswspace (ch)) {
        if (ch != L' ') {
            if (pTestSetW (L' ', IncludeSet, ExcludeSet)) {
                return TRUE;
            }
        }
    } else {
        ch = towlower (ch);
    }

    if (IncludeSet) {

        b = FALSE;

        while (*IncludeSet) {

            LowChar = *IncludeSet++;
            HighChar = *IncludeSet++;

            if (ch >= LowChar && ch <= HighChar) {
                b = TRUE;
                break;
            }
        }
    }

    if (b && ExcludeSet) {

        while (*ExcludeSet) {

            LowChar = *ExcludeSet++;
            HighChar = *ExcludeSet++;

            if (ch >= LowChar && ch <= HighChar) {
                b = FALSE;
                break;
            }
        }
    }

    return b;
}



/*++

Routine Description:

  pTestOnePatternAB tests a string against a parsed pattern. It loops through
  each segment in the pattern, and calls itself recursively in certain
  circumstances.

Arguments:

  Pattern      - Specifies the parsed pattern, as returned from
                 CreateParsedPattern
  StartSeg     - Specifies the segment within Pattern to start testing.  This
                 is used for recursion and outside callers should pass in 0.
  StringToTest - Specifies the string to test against Pattern.  In recursion,
                 this member will be a pointer to the start of the sub string
                 to test.
  EndPlusOne   - Specifies one character beyond the end of the string.  This
                 typically points to the nul terminator.

Return Value:

  TRUE if the string between StringToTest and EndPlusOne fits Pattern. FALSE
  otherwise.

--*/

BOOL
pTestOnePatternABA (
    IN      PPATTERNPROPSA Pattern,
    IN      UINT StartSeg,
    IN      PCSTR StringToTest,
    IN      PCSTR EndPlusOne
    )
{
    UINT u;
    PSEGMENTA Segment;
    MBCHAR ch1, ch2;
    PCSTR q;
    PCSTR TempEnd;
    UINT BytesLeft;
    UINT Chars;

    for (u = StartSeg ; u < Pattern->SegmentCount ; u++) {

        Segment = &Pattern->Segment[u];

        switch (Segment->Type) {

        case SEGMENTTYPE_EXACTMATCH:
            //
            // Check if the exact match is long enough, or if
            // the remaining string must match
            //

            BytesLeft = (UINT)((PBYTE) EndPlusOne - (PBYTE) StringToTest);

            if (u + 1 == Pattern->SegmentCount) {
                if (BytesLeft != Segment->Exact.PhraseBytes) {
                    return FALSE;
                }
            } else if (BytesLeft < Segment->Exact.PhraseBytes) {
                return FALSE;
            }

            //
            // Compare the strings
            //

            q = Segment->Exact.LowerCasePhrase;

            TempEnd = (PCSTR) ((PBYTE) q + Segment->Exact.PhraseBytes);

            ch1 = 0;
            ch2 = 0;

            while (q < TempEnd) {

                ch1 = _mbsnextc (StringToTest);
                ch2 = _mbsnextc (q);

                ch1 = _mbctolower (ch1);

                if (ch1 != ch2) {
                    if (ch2 == ' ') {
                        if (!isspace ((INT)ch1)) {
                            break;
                        }
                    } else {
                        break;
                    }
                }

                q = _mbsinc (q);
                StringToTest = _mbsinc (StringToTest);
            }

            if (ch1 != ch2) {
                return FALSE;
            }

            //
            // Continue onto next segment
            //

            break;

        case SEGMENTTYPE_REQUIRED:
            MYASSERT (Segment->Wildcard.MaxLen > 0);

            //
            // Verify there are the correct number of characters
            // in the specified char set
            //

            Chars = Segment->Wildcard.MaxLen;
            if (Segment->Wildcard.IncludeSet || Segment->Wildcard.ExcludeSet) {
                while (StringToTest < EndPlusOne && Chars > 0) {

                    if (!pTestSetA (
                            _mbsnextc (StringToTest),
                            Segment->Wildcard.IncludeSet,
                            Segment->Wildcard.ExcludeSet
                            )) {
                        return FALSE;
                    }

                    Chars--;
                    StringToTest = _mbsinc (StringToTest);
                }
            } else {
                while (StringToTest < EndPlusOne && Chars > 0) {
                    Chars--;
                    StringToTest = _mbsinc (StringToTest);
                }
            }

            if (Chars) {
                return FALSE;
            }

            if (u + 1 == Pattern->SegmentCount) {
                if (*StringToTest) {
                    return FALSE;
                }
            }

            //
            // Continue onto next segment
            //

            break;

        case SEGMENTTYPE_OPTIONAL:

            if (Segment->Wildcard.MaxLen == 0) {
                //
                // Last segment is "anything"
                //

                if (u + 1 == Pattern->SegmentCount &&
                    !Segment->Wildcard.IncludeSet &&
                    !Segment->Wildcard.ExcludeSet
                    ) {
                    return TRUE;
                }
            }

            //
            // Find end of optional text
            //

            TempEnd = StringToTest;
            Chars = Segment->Wildcard.MaxLen;

            if (Segment->Wildcard.IncludeSet || Segment->Wildcard.ExcludeSet) {

                if (Chars) {
                    while (TempEnd < EndPlusOne && Chars > 0) {

                        if (!pTestSetA (
                                _mbsnextc (TempEnd),
                                Segment->Wildcard.IncludeSet,
                                Segment->Wildcard.ExcludeSet
                                )) {
                            break;
                        }

                        TempEnd = _mbsinc (TempEnd);
                        Chars--;
                    }

                } else {

                    while (TempEnd < EndPlusOne) {

                        if (!pTestSetA (
                                _mbsnextc (TempEnd),
                                Segment->Wildcard.IncludeSet,
                                Segment->Wildcard.ExcludeSet
                                )) {
                            break;
                        }

                        TempEnd = _mbsinc (TempEnd);
                    }
                }

            } else if (Chars) {

                while (TempEnd < EndPlusOne && Chars > 0) {
                    TempEnd = _mbsinc (TempEnd);
                    Chars--;
                }

            } else {
                TempEnd = EndPlusOne;
            }

            //
            // If this is the last segment, then match only when
            // the remaining text fits
            //

            if (u + 1 == Pattern->SegmentCount) {
                return TempEnd >= EndPlusOne;
            }

            //
            // Because other segments exist, we must check recursively
            //

            do {
                if (pTestOnePatternABA (Pattern, u + 1, StringToTest, EndPlusOne)) {
                    return TRUE;
                }

                StringToTest = _mbsinc (StringToTest);

            } while (StringToTest <= TempEnd);

            //
            // No match
            //

            return FALSE;
        }   //lint !e744
    }

    return TRUE;
}


BOOL
pTestOnePatternABW (
    IN      PPATTERNPROPSW Pattern,
    IN      UINT StartSeg,
    IN      PCWSTR StringToTest,
    IN      PCWSTR EndPlusOne
    )
{
    UINT u;
    PSEGMENTW Segment;
    WCHAR ch1, ch2;
    PCWSTR q;
    PCWSTR TempEnd;
    UINT BytesLeft;
    UINT Chars;

    for (u = StartSeg ; u < Pattern->SegmentCount ; u++) {

        Segment = &Pattern->Segment[u];

        switch (Segment->Type) {

        case SEGMENTTYPE_EXACTMATCH:
            //
            // Check if the exact match is long enough, or if
            // the remaining string must match
            //

            BytesLeft = (UINT)((PBYTE) EndPlusOne - (PBYTE) StringToTest);

            if (u + 1 == Pattern->SegmentCount) {
                if (BytesLeft != Segment->Exact.PhraseBytes) {
                    return FALSE;
                }
            } else if (BytesLeft < Segment->Exact.PhraseBytes) {
                return FALSE;
            }

            //
            // Compare the strings
            //

            q = Segment->Exact.LowerCasePhrase; //lint !e64

            TempEnd = (PCWSTR) ((PBYTE) q + Segment->Exact.PhraseBytes);

            ch1 = 0;
            ch2 = 0;

            while (q < TempEnd) {

                ch1 = towlower (*StringToTest);
                ch2 = *q;

                if (ch1 != ch2) {
                    if (ch2 == L' ') {
                        if (!iswspace (ch1)) {
                            break;
                        }
                    } else {
                        break;
                    }
                }

                q++;
                StringToTest++;
            }

            if (ch1 != ch2) {
                return FALSE;
            }

            //
            // Continue onto next segment
            //

            break;

        case SEGMENTTYPE_REQUIRED:
            MYASSERT (Segment->Wildcard.MaxLen > 0);

            //
            // Verify there are the correct number of characters
            // in the specified char set
            //

            Chars = Segment->Wildcard.MaxLen;
            if (Segment->Wildcard.IncludeSet || Segment->Wildcard.ExcludeSet) {
                while (StringToTest < EndPlusOne && Chars > 0) {

                    if (!pTestSetW (
                            *StringToTest,
                            Segment->Wildcard.IncludeSet,   //lint !e64
                            Segment->Wildcard.ExcludeSet
                            )) {    //lint !e64
                        return FALSE;
                    }

                    Chars--;
                    StringToTest++;
                }

                if (Chars) {
                    return FALSE;
                }

            } else {
                StringToTest += Chars;

                if (StringToTest > EndPlusOne) {
                    return FALSE;
                }
            }

            if (u + 1 == Pattern->SegmentCount) {
                if (*StringToTest) {
                    return FALSE;
                }
            }

            //
            // Continue onto next segment
            //

            break;

        case SEGMENTTYPE_OPTIONAL:

            if (Segment->Wildcard.MaxLen == 0) {
                //
                // Last segment is "anything"
                //

                if (u + 1 == Pattern->SegmentCount &&
                    !Segment->Wildcard.IncludeSet &&
                    !Segment->Wildcard.ExcludeSet
                    ) {
                    return TRUE;
                }
            }

            //
            // Find end of optional text
            //

            TempEnd = StringToTest;
            Chars = Segment->Wildcard.MaxLen;

            if (Segment->Wildcard.IncludeSet || Segment->Wildcard.ExcludeSet) {

                if (Chars) {
                    while (TempEnd < EndPlusOne && Chars > 0) {

                        if (!pTestSetW (
                                *TempEnd,
                                Segment->Wildcard.IncludeSet,   //lint !e64
                                Segment->Wildcard.ExcludeSet
                                )) {    //lint !e64
                            break;
                        }

                        TempEnd++;
                        Chars--;
                    }

                } else {

                    while (TempEnd < EndPlusOne) {

                        if (!pTestSetW (
                                *TempEnd,
                                Segment->Wildcard.IncludeSet,   //lint !e64
                                Segment->Wildcard.ExcludeSet
                                )) {    //lint !e64
                            break;
                        }

                        TempEnd++;
                    }
                }

            } else if (Chars) {

                TempEnd += Chars;
                if (TempEnd > EndPlusOne) {
                    TempEnd = EndPlusOne;
                }

            } else {
                TempEnd = EndPlusOne;
            }

            //
            // If this is the last segment, then match only when
            // the remaining text fits
            //

            if (u + 1 == Pattern->SegmentCount) {
                return TempEnd >= EndPlusOne;
            }

            //
            // Because other segments exist, we must check recursively
            //

            do {
                if (pTestOnePatternABW (Pattern, u + 1, StringToTest, EndPlusOne)) {
                    return TRUE;
                }

                StringToTest++;

            } while (StringToTest <= TempEnd);

            //
            // No match
            //

            return FALSE;
        }   //lint !e744
    }

    return TRUE;
}



/*++

Routine Description:

  TestParsedPattternAB loops through all the patterns in ParsedPattern,
  testing the specified string against each. The loop stops at the first
  match.

Arguments:

  ParsedPattern - Specifies the parsed pattern, as returned from
                  CreateParsedPattern
  StringToTest  - Specifies the start of the string to test.
  EndPlusOne    - Specifies a pointer to the first character after the end of
                  the string.  This often points to the nul at the end of the
                  string.  A nul must not exist in between StringToTest and
                  EndPlusOne; a nul can only be at *EndPlusOne.  A nul is not
                  required.

Return Value:

  TRUE if the string specified between StringToTest and EndPlusOne matches
  Pattern.  FALSE otherwise.

--*/

BOOL
TestParsedPatternABA (
    IN      PPARSEDPATTERNA ParsedPattern,
    IN      PCSTR StringToTest,
    IN      PCSTR EndPlusOne
    )
{
    UINT u;
    BOOL b = FALSE;

    for (u = 0 ; u < ParsedPattern->PatternCount ; u++) {

        b = pTestOnePatternABA (
                &ParsedPattern->Pattern[u],
                0,
                StringToTest,
                EndPlusOne
                );

        if (b) {
            break;
        }
    }

    return b;
}


BOOL
TestParsedPatternABW (
    IN      PPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR StringToTest,
    IN      PCWSTR EndPlusOne
    )
{
    UINT u;
    BOOL b = FALSE;

    for (u = 0 ; u < ParsedPattern->PatternCount ; u++) {

        b = pTestOnePatternABW (
                &ParsedPattern->Pattern[u],
                0,
                StringToTest,
                EndPlusOne
                );

        if (b) {
            break;
        }
    }

    return b;
}



/*++

Routine Description:

  DestroyParsedPattern cleans up a pattern allocated from CreateParsedPattern.

Arguments:

  ParsedPattern - Specifies the value returned from CreateParsedPattern.

Return Value:

  None.

--*/

VOID
DestroyParsedPatternA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    if (ParsedPattern) {
        PmDestroyPool (ParsedPattern->Pool);
    }
}


VOID
DestroyParsedPatternW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    if (ParsedPattern) {
        PmDestroyPool (ParsedPattern->Pool);
    }
}


/*++

Routine Description:

  DecodeParsedPattern decodes all exact-matches sub-strings of the given pattern.

Arguments:

  ParsedPattern - Specifies the parsed pattern.

Return Value:

  None.

--*/

VOID
DecodeParsedPatternA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    UINT u;
    UINT v;
    PSTR phrase;

    for (u = 0; u < ParsedPattern->PatternCount; u++) {
        for (v = 0; v < ParsedPattern->Pattern[u].SegmentCount; v++) {
            if (ParsedPattern->Pattern[u].Segment[v].Type == SEGMENTTYPE_EXACTMATCH) {
                phrase = (PSTR)ParsedPattern->Pattern[u].Segment[v].Exact.LowerCasePhrase;
                DecodeRuleCharsA (phrase, phrase);
                ParsedPattern->Pattern[u].Segment[v].Exact.PhraseBytes = ByteCountA (phrase);
            }
        }
    }
}


VOID
DecodeParsedPatternW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    UINT u;
    UINT v;
    PWSTR phrase;

    for (u = 0; u < ParsedPattern->PatternCount; u++) {
        for (v = 0; v < ParsedPattern->Pattern[u].SegmentCount; v++) {
            if (ParsedPattern->Pattern[u].Segment[v].Type == SEGMENTTYPE_EXACTMATCH) {
                phrase = (PWSTR)ParsedPattern->Pattern[u].Segment[v].Exact.LowerCasePhrase;
                DecodeRuleCharsW (phrase, phrase);
                ParsedPattern->Pattern[u].Segment[v].Exact.PhraseBytes = ByteCountW (phrase);
            }
        }
    }
}


/*++

Routine Description:

  GetParsedPatternMinMaxSize returns the minimum and the maximum size (in bytes)
  of a string that would match the given parsed pattern.

Arguments:

  ParsedPattern - Specifies the parsed pattern
  MinSize - Receives the minimum size of a string that would match the pattern
  MaxSize - Receives the maximum size of a string that would match the pattern

Return Value:

  None.

--*/

VOID
GetParsedPatternMinMaxSizeA (
    IN      PPARSEDPATTERNA ParsedPattern,
    OUT     PDWORD MinSize,
    OUT     PDWORD MaxSize
    )
{
    UINT u;
    UINT v;
    DWORD pmin;
    DWORD pmax;
    DWORD smin;
    DWORD smax;

    *MinSize = *MaxSize = 0;

    for (u = 0; u < ParsedPattern->PatternCount; u++) {

        pmin = pmax = 0;

        for (v = 0; v < ParsedPattern->Pattern[u].SegmentCount; v++) {
            switch (ParsedPattern->Pattern[u].Segment[v].Type) {
            case SEGMENTTYPE_EXACTMATCH:
                smin = smax = ParsedPattern->Pattern[u].Segment[v].Exact.PhraseBytes;
                break;
            case SEGMENTTYPE_OPTIONAL:
                smin = 0;
                if (ParsedPattern->Pattern[u].Segment[v].Wildcard.MaxLen) {
                    smax = ParsedPattern->Pattern[u].Segment[v].Wildcard.MaxLen * DWSIZEOF (CHAR);
                } else {
                    smax = DWORD_MAX;
                }
                break;
            case SEGMENTTYPE_REQUIRED:
                MYASSERT (ParsedPattern->Pattern[u].Segment[v].Wildcard.MaxLen > 0);
                smin = smax = ParsedPattern->Pattern[u].Segment[v].Wildcard.MaxLen * DWSIZEOF (CHAR);
                break;
            default:
                MYASSERT (FALSE);   //lint !e506
                smin = smax = 0;
            }
            pmin += smin;
            if (pmax < DWORD_MAX) {
                if (smax < DWORD_MAX) {
                    pmax += smax;
                } else {
                    pmax = DWORD_MAX;
                }
            }
        }

        if (pmin < *MinSize) {
            *MinSize = pmin;
        }
        if (pmax > *MaxSize) {
            *MaxSize = pmax;
        }
    }
}

VOID
GetParsedPatternMinMaxSizeW (
    IN      PPARSEDPATTERNW ParsedPattern,
    OUT     PDWORD MinSize,
    OUT     PDWORD MaxSize
    )
{
    UINT u;
    UINT v;
    DWORD pmin;
    DWORD pmax;
    DWORD smin;
    DWORD smax;

    *MinSize = *MaxSize = 0;

    for (u = 0; u < ParsedPattern->PatternCount; u++) {

        pmin = pmax = 0;

        for (v = 0; v < ParsedPattern->Pattern[u].SegmentCount; v++) {
            switch (ParsedPattern->Pattern[u].Segment[v].Type) {
            case SEGMENTTYPE_EXACTMATCH:
                smin = smax = ParsedPattern->Pattern[u].Segment[v].Exact.PhraseBytes;
                break;
            case SEGMENTTYPE_OPTIONAL:
                smin = 0;
                if (ParsedPattern->Pattern[u].Segment[v].Wildcard.MaxLen) {
                    smax = ParsedPattern->Pattern[u].Segment[v].Wildcard.MaxLen * DWSIZEOF (WCHAR);
                } else {
                    smax = DWORD_MAX;
                }
                break;
            case SEGMENTTYPE_REQUIRED:
                MYASSERT (ParsedPattern->Pattern[u].Segment[v].Wildcard.MaxLen > 0);
                smin = smax = ParsedPattern->Pattern[u].Segment[v].Wildcard.MaxLen * DWSIZEOF (WCHAR);
                break;
            default:
                MYASSERT (FALSE);   //lint !e506
                smin = smax = 0;
            }
            pmin += smin;
            if (pmax < DWORD_MAX) {
                if (smax < DWORD_MAX) {
                    pmax += smax;
                } else {
                    pmax = DWORD_MAX;
                }
            }
        }

        if (pmin < *MinSize) {
            *MinSize = pmin;
        }
        if (pmax > *MaxSize) {
            *MaxSize = pmax;
        }
    }
}


/*++

Routine Description:

    PatternIncludesPattern decides if a given pattern includes another pattern,
    meaning that any string that would match the second will match the first.

Arguments:

    IncludingPattern - Specifies the first parsed pattern
    IncludedPattern - Specifies the second parsed pattern

Return Value:

    TRUE if the first pattern includes the second

--*/

BOOL
PatternIncludesPatternA (
    IN      PPARSEDPATTERNA IncludingPattern,
    IN      PPARSEDPATTERNA IncludedPattern
    )
{
    PPATTERNPROPSA pp1;
    PPATTERNPROPSA pp2;
    PSEGMENTA ps1;
    PSEGMENTA ps2;
    DWORD min1;
    DWORD max1;
    DWORD min2;
    DWORD max2;

    //
    // only deal with simple patterns for now (PatternCount == 1)
    //
    if (IncludingPattern->PatternCount > 1 || IncludedPattern->PatternCount > 1) {
        DEBUGMSGA ((DBG_ERROR, "PatternIncludesPatternA: multiple patterns not supported yet"));
        return FALSE;
    }

    //
    // test the usual cases first, quickly
    //
    pp1 = IncludingPattern->Pattern;
    MYASSERT (pp1);
    if (pp1->SegmentCount == 1 && ParsedPatternSegmentIsPureOptionalA (pp1->Segment)) {
        return TRUE;
    }

    pp2 = IncludedPattern->Pattern;
    MYASSERT (pp2);
    if (pp2->SegmentCount == 1 && ParsedPatternSegmentIsPureOptionalA (pp2->Segment)) {
        return FALSE;
    }

    if (pp1->SegmentCount == 1) {
        ps1 = pp1->Segment;
        if (ps1->Type == SEGMENTTYPE_EXACTMATCH) {
            if (pp2->SegmentCount == 1) {
                ps2 = pp2->Segment;
                if (ps2->Type == SEGMENTTYPE_EXACTMATCH) {
                    return ps1->Exact.PhraseBytes == ps2->Exact.PhraseBytes &&
                           StringMatchA (ps1->Exact.LowerCasePhrase, ps2->Exact.LowerCasePhrase);
                }
            }
        }
    } else if (pp1->SegmentCount == 2) {
        ps1 = pp1->Segment;
        if (ps1->Type == SEGMENTTYPE_EXACTMATCH) {
            if (ParsedPatternSegmentIsPureOptionalA (pp1->Segment + 1)) {
                if (pp2->SegmentCount == 1) {
                    ps2 = pp2->Segment;
                    if (ps2->Type == SEGMENTTYPE_EXACTMATCH) {
                        return ps1->Exact.PhraseBytes <= ps2->Exact.PhraseBytes &&
                               StringMatchByteCountA (
                                    ps1->Exact.LowerCasePhrase,
                                    ps2->Exact.LowerCasePhrase,
                                    ps1->Exact.PhraseBytes
                                    );
                    }
                } else if (pp2->SegmentCount == 2) {
                    ps2 = pp2->Segment;
                    if (ps2->Type == SEGMENTTYPE_EXACTMATCH) {
                        if (ParsedPatternSegmentIsPureOptionalA (pp2->Segment + 1)) {
                            return ps1->Exact.PhraseBytes <= ps2->Exact.PhraseBytes &&
                                   StringMatchByteCountA (
                                        ps1->Exact.LowerCasePhrase,
                                        ps2->Exact.LowerCasePhrase,
                                        ps1->Exact.PhraseBytes
                                        );
                        }
                    }
                }
            }
        }
    }

    GetParsedPatternMinMaxSizeA (IncludingPattern, &min1, &max1);
    GetParsedPatternMinMaxSizeA (IncludedPattern, &min2, &max2);
    if (min2 < min1 || max2 > max1) {
        return FALSE;
    }

    //
    // BUGBUG - not implemented yet
    //
    return FALSE;
}

BOOL
PatternIncludesPatternW (
    IN      PPARSEDPATTERNW IncludingPattern,
    IN      PPARSEDPATTERNW IncludedPattern
    )
{
    PPATTERNPROPSW pp1;
    PPATTERNPROPSW pp2;
    PSEGMENTW ps1;
    PSEGMENTW ps2;
    DWORD min1;
    DWORD max1;
    DWORD min2;
    DWORD max2;

    //
    // only deal with simple patterns for now (PatternCount == 1)
    //
    if (IncludingPattern->PatternCount > 1 || IncludedPattern->PatternCount > 1) {
        DEBUGMSGW ((DBG_ERROR, "PatternIncludesPatternW: multiple patterns not supported yet"));
        return FALSE;
    }

    //
    // test the usual cases first, quickly
    //
    pp1 = IncludingPattern->Pattern;
    MYASSERT (pp1);
    if (pp1->SegmentCount == 1 && ParsedPatternSegmentIsPureOptionalW (pp1->Segment)) {
        return TRUE;
    }

    pp2 = IncludedPattern->Pattern;
    MYASSERT (pp2);
    if (pp2->SegmentCount == 1 && ParsedPatternSegmentIsPureOptionalW (pp2->Segment)) {
        return FALSE;
    }

    if (pp1->SegmentCount == 1) {
        ps1 = pp1->Segment;
        if (ps1->Type == SEGMENTTYPE_EXACTMATCH) {
            if (pp2->SegmentCount == 1) {
                ps2 = pp2->Segment;
                if (ps2->Type == SEGMENTTYPE_EXACTMATCH) {
                    return ps1->Exact.PhraseBytes == ps2->Exact.PhraseBytes &&
                           StringMatchW (ps1->Exact.LowerCasePhrase, ps2->Exact.LowerCasePhrase);   //lint !e64
                }
            }
        }
    } else if (pp1->SegmentCount == 2) {
        ps1 = pp1->Segment;
        if (ps1->Type == SEGMENTTYPE_EXACTMATCH) {
            if (ParsedPatternSegmentIsPureOptionalW (pp1->Segment + 1)) {
                if (pp2->SegmentCount == 1) {
                    ps2 = pp2->Segment;
                    if (ps2->Type == SEGMENTTYPE_EXACTMATCH) {
                        return ps1->Exact.PhraseBytes <= ps2->Exact.PhraseBytes &&
                               StringMatchByteCountW (
                                    ps1->Exact.LowerCasePhrase,
                                    ps2->Exact.LowerCasePhrase,
                                    ps1->Exact.PhraseBytes
                                    );  //lint !e64
                    }
                } else if (pp2->SegmentCount == 2) {
                    ps2 = pp2->Segment;
                    if (ps2->Type == SEGMENTTYPE_EXACTMATCH) {
                        if (ParsedPatternSegmentIsPureOptionalW (pp2->Segment + 1)) {
                            return ps1->Exact.PhraseBytes <= ps2->Exact.PhraseBytes &&
                                   StringMatchByteCountW (
                                        ps1->Exact.LowerCasePhrase,
                                        ps2->Exact.LowerCasePhrase,
                                        ps1->Exact.PhraseBytes
                                        );  //lint !e64
                        }
                    }
                }
            }
        }
    }

    GetParsedPatternMinMaxSizeW (IncludingPattern, &min1, &max1);
    GetParsedPatternMinMaxSizeW (IncludedPattern, &min2, &max2);
    if (min2 < min1 || max2 > max1) {
        return FALSE;
    }

    //
    // BUGBUG - not implemented yet
    //
    return FALSE;
}


VOID
_copymbchar (
    OUT     PSTR sz1,
    IN      PCSTR sz2
    )

/*++

Routine Description:

  _copymbchar transfers the character at sz2 to sz1, which may be one or
  two bytes long.

Arguments:

  sz1       - The destination string
  sz2       - The source string

Return Value:

  none

--*/


{
    if (IsLeadByte (*sz2)) {
        sz1[1] = sz2[1];
    }

    *sz1 = *sz2;
}


/*++

Routine Description:

  _tcsctrim removes character c from the end of str if it exists.  It removes
  only one character at the most.

Arguments:

  str       - A pointer to the string that may have character c at the end
  c         - The character that may be at the end of the string

Return Value:

  TRUE if character c was at the end of the string, or FALSE if it was not.

--*/

BOOL
_mbsctrim (
    OUT     PSTR str,
    IN      MBCHAR c
    )
{
    PSTR end;

    end = GetEndOfStringA (str);
    end = _mbsdec2 (str, end);
    if (end && _mbsnextc (end) == c) {
        *end = 0;
        return TRUE;
    }

    return FALSE;
}


BOOL
_wcsctrim (
    OUT     PWSTR str,
    IN      WCHAR c
    )
{
    PWSTR end;

    end = GetEndOfStringW (str);
    end == str ? end = NULL : end--;
    if (end && *end == c) {
        *end = 0;
        return TRUE;
    }

    return FALSE;
}


/*++

Routine Description:

  The FreeStringResourceEx functions are used to free a recently used
  string that is not being passed back to the caller.  In almost all
  cases, this string is at the end of our array of pointers, so we can
  efficiently search sequentially in reverse order.  If the pointer is
  not the last element of the array, it is first swapped with the real
  last element of the array so the array size is reduced.

Arguments:

  AllocTable - The GROWBUFFER table that holds the list of previously
               allocated strings (return values of ParseMessageEx or
               GetResourceStringEx).
  String     - A pointer to the string that is in AllocTable

Return Value:

  none

--*/

VOID
FreeStringResourceExA (
    IN      PGROWBUFFER AllocTable,
    IN      PCSTR String
    )
{
    PCTSTR *ptr, *end, *start;

    if (!String) {
        return;
    }

    //
    // Locate string (search sequentially in reverse order)
    //

    if (AllocTable->End < sizeof (PCSTR)) {
        DEBUGMSG ((DBG_ERROR, "FreeStringResourceA: Attempt to free address %x (%s); address table empty", String, String));
        return;
    }

    start = (PCSTR *) AllocTable->Buf;
    end = (PCSTR *) (AllocTable->Buf + AllocTable->End - sizeof (PCSTR));

    ptr = end;
    while (ptr >= start) {
        if (*ptr == String) {
            break;
        }
        ptr--;
    }

    //
    // String not found case
    //

    if (ptr < start) {
        DEBUGMSG ((DBG_ERROR, "FreeStringResourceA: Attempt to free address %x (%s); address not found in table", String, String));
        return;
    }

    //
    // Free LocalAlloc'd memory
    //

    LocalFree ((HLOCAL) String);

    //
    // If this element is not the end, copy real end to the ptr
    //

    if (ptr < end) {
        *ptr = *end;
    }

    //
    // Shrink buffer size
    //

    AllocTable->End -= sizeof (PCSTR);
}


VOID
FreeStringResourcePtrExA (
    IN      PGROWBUFFER AllocTable,
    IN OUT  PCSTR * String
    )
{
    if (NULL != *String) {
        FreeStringResourceExA(AllocTable, *String);
        *String = NULL;
    }
}


VOID
FreeStringResourceExW (
    IN      PGROWBUFFER AllocTable,
    IN      PCWSTR String
    )
{
    FreeStringResourceExA (AllocTable, (PCSTR) String);
}


VOID
FreeStringResourcePtrExW (
    IN      PGROWBUFFER AllocTable,
    IN OUT  PCWSTR * String
    )
{
    if (NULL != *String) {
        FreeStringResourceExW(AllocTable, *String);
        *String = NULL;
    }
}



/*++

Routine Description:

  The pAddStringResource function is used to track pointers allocated
  by FormatMessage.  They are added to an array (maintained in a GROWBUFFER
  structure).  This table of pointers is used by FreeStringResource or
  StringResourceFree.

Arguments:

  String   - A pointer to a LocalAlloc'd string (the return value of
             FormatMessage).  This string is added to a table of allocated
             strings.

Return Value:

  none

--*/

VOID
pAddStringResource (
    IN      PGROWBUFFER GrowBuf,
    IN      PCSTR String
    )
{
    PCSTR *ptr;

    ptr = (PCSTR *) GbGrow (GrowBuf, sizeof (PCSTR));
    if (ptr) {
        *ptr = String;
    }
    ELSE_DEBUGMSG ((DBG_ERROR, "pAddStringResource: GrowBuffer failure caused memory leak"));
}


/*++

Routine Description:

  pFreeAllStringResourcesEx frees all strings currently listed in AllocTable.
  This function allows the caller to wait until all processing is done
  to clean up string resources that may have been allocated.

Arguments:

  none

Return Value:

  none

--*/

VOID
pFreeAllStringResourcesEx (
    IN      PGROWBUFFER AllocTable
    )
{
    PCSTR *ptr, *start, *end;

    if (AllocTable->End) {
        start = (PCSTR *) AllocTable->Buf;
        end = (PCSTR *) (AllocTable->Buf + AllocTable->End);

        for (ptr = start ; ptr < end ; ptr++) {
            LocalFree ((HLOCAL) (*ptr));
        }
    }

    GbFree (AllocTable);
}



/*++

Routine Description:

  CreateAllocTable creates a GROWBUFFER structure that can be used with
  ParseMessageEx, GetStringResourceEx, FreeStringResourceEx and
  pFreeAllStringResourcesEx.  Call this function to recieve a private
  allocation table to pass to these functions.  Call DestroyAllocTable
  to clean up.

Arguments:

  none

Return Value:

  A pointer to a GROWBUFFER structure, or NULL if a memory allocation failed.

--*/

PGROWBUFFER
RealCreateAllocTable (
    VOID
    )
{
    PGROWBUFFER allocTable;
    GROWBUFFER tempForInit = INIT_GROWBUFFER;

    allocTable = (PGROWBUFFER) MemAlloc (g_hHeap, 0, sizeof (GROWBUFFER));
    CopyMemory (allocTable, &tempForInit, sizeof (GROWBUFFER));

    return allocTable;
}


/*++

Routine Description:

  DestroyAllocTable cleans up all memory associated with an AllocTable.

Arguments:

  AllocTable - A pointer to a GROWBUFFER structure allocated by CreateAllocTable

Return Value:

  none

--*/

VOID
DestroyAllocTable (
    OUT     PGROWBUFFER AllocTable
    )
{
    MYASSERT (AllocTable);
    pFreeAllStringResourcesEx (AllocTable);
    MemFree (g_hHeap, 0, AllocTable);
}


/*++

Routine Description:

  BeginMessageProcessing enters a guarded section of code that plans to use the
  ParseMessage and GetStringResource functions, but needs cleanup at the end
  of processing.

  EndMessageProcessing destroys all memory allocated within the message processing
  block, and leaves the guarded section.

Arguments:

  none

Return Value:

  BeginMessageProcessing returns FALSE if an out-of-memory condition occurrs.

--*/


BOOL
BeginMessageProcessing (
    VOID
    )
{
    if (!TryEnterOurCriticalSection (&g_MessageCs)) {
        DEBUGMSG ((DBG_ERROR, "Thread attempting to enter BeginMessageProcessing while another"
                              "thread is processing messages as well."));
        EnterOurCriticalSection (&g_MessageCs);
    }

    g_LastAllocTable = g_ShortTermAllocTable;
    g_ShortTermAllocTable = CreateAllocTable();

    MYASSERT (g_ShortTermAllocTable);

    return TRUE;
}


VOID
EndMessageProcessing (
    VOID
    )
{
    if (TryEnterOurCriticalSection (&g_MessageCs)) {
        DEBUGMSG ((DBG_ERROR, "Thread attempting to end message processing when it hasn't been started"));
        LeaveOurCriticalSection (&g_MessageCs);
        return;
    }

    DestroyAllocTable (g_ShortTermAllocTable);
    g_ShortTermAllocTable = g_LastAllocTable;
    LeaveOurCriticalSection (&g_MessageCs);
}


/*++

Routine Description:

  ParseMessage is used to obtain a string from the executable's message table
  and parse it with FormatMessage.  An array of arguments can be passed by
  the caller.  FormatMessage will replace %1 with the first element of the
  array, %2 with the second element, and so on.  The array does not need to
  be terminated, and if a message string uses %n, element n must be non-NULL.

Arguments:

  Template  - A string indicating which message to extract, or a WORD value
              cast as a string.  (ParseMessageID does this cast via a macro.)
  ArgArray  - Optional array of string pointers, where the meaning depends on
              the message string.  A reference in the message string to %n
              requires element n of ArgArray to be a valid string pointer.

Return Value:

  Pointer to the string allocated.  Call StringResourceFree to free all
  allocated strings (a one-time cleanup for all strings).  The pointer may
  be NULL if the resource does not exist or is empty.

--*/

PCSTR
ParseMessageExA (
    IN      PGROWBUFFER AllocTable,
    IN      PCSTR Template,
    IN      PCSTR ArgArray[]
    )
{
    PSTR MsgBuf;
    DWORD rc;

    if (SHIFTRIGHT16 ((UBINT)Template)) {
        //
        // From string
        //
        rc = FormatMessageA (
                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_ARGUMENT_ARRAY |
                FORMAT_MESSAGE_FROM_STRING,
                (LPVOID) Template,
                0,
                0,
                (LPVOID) &MsgBuf,
                0,
                (va_list *) ArgArray
                );
    } else {
        //
        // From resource
        //
        rc = FormatMessageA (
                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_ARGUMENT_ARRAY |
                FORMAT_MESSAGE_FROM_HMODULE,
                (LPVOID) g_hInst,
                (DWORD)((UBINT)Template),
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPVOID) &MsgBuf,
                0,
                (va_list *) ArgArray
                );
    }

    if (rc > 0) {
        pAddStringResource (AllocTable, MsgBuf);
        return MsgBuf;
    }

    return NULL;
}


PCWSTR
ParseMessageExW (
    IN      PGROWBUFFER AllocTable,
    IN      PCWSTR Template,
    IN      PCWSTR ArgArray[]
    )
{
    PWSTR MsgBuf;
    DWORD rc;

    if (SHIFTRIGHT16 ((UBINT)Template)) {
        //
        // From string
        //
        rc = FormatMessageW (
                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_ARGUMENT_ARRAY |
                FORMAT_MESSAGE_FROM_STRING,
                (LPVOID) Template,
                0,
                0,
                (LPVOID) &MsgBuf,
                0,
                (va_list *) ArgArray
                );
    } else {
        //
        // From resource
        //
        rc = FormatMessageW (
                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_ARGUMENT_ARRAY |
                FORMAT_MESSAGE_FROM_HMODULE,
                (LPVOID) g_hInst,
                (DWORD)(UBINT)Template,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPVOID) &MsgBuf,
                0,
                (va_list *) ArgArray
                );
    }

    if (rc > 0) {
        pAddStringResource (AllocTable, (PCSTR) MsgBuf);
        return MsgBuf;
    }

    return NULL;
}



/*++

Routine Description:

  GetStringResourceEx is an argument-less wrapper of ParseMessageEx.  It allows
  the caller to specify a message ID and recieve a pointer to the string if
  it exists, and a table to track FormatMessage's allocations.

Arguments:

  AllocTable - A pointer to a GROWBUFFER structure that is used to maintain
               the handles of allocated strings
  ID         - The ID of the message resource to retrieve

Return Value:

  Pointer to the string allocated.  The return pointer may
  be NULL if the resource does not exist or is empty.

  Call FreeStringResource or DestroyAllocTable to clean up AllocTable.


--*/

PCSTR
GetStringResourceExA (
    IN OUT  PGROWBUFFER AllocTable,
    IN      UINT ID
    )
{
    return ParseMessageExA (AllocTable, (PSTR) (WORD) ID, NULL);
}

PCWSTR
GetStringResourceExW (
    IN OUT  PGROWBUFFER AllocTable,
    IN      UINT ID
    )
{
    return ParseMessageExW (AllocTable, (PWSTR) (WORD) ID, NULL);
}



/*++

Routine Description:

  ParseMessageInWnd is used to exchange a string in a window with one from
  the executable's message table.  It is provided for dialog box initialization,
  where a field in the dialog box requires dynamic data.  The dialog box
  resource should contain a control with its window text set to the message
  string.  Upon processing WM_INITDIALOG, the code should call ParseMessageInWnd,
  supplying the necessary ArgArray, so the dialog box is initialized with
  a dynamic message.

Arguments:

  hwnd      - The handle of a window whose title contains the message string ID
  ArgArray  - Optional array of string pointers, where the meaning depends on
              the message string.  A reference in the message string to %n
              requires element n of ArgArray to be a valid string pointer.

Return Value:

  none

--*/

VOID
ParseMessageInWndA (
    IN      HWND Hwnd,
    IN      PCSTR ArgArray[]
    )
{
    CHAR buffer[512];
    PCSTR parsedMsg;

    GetWindowTextA (Hwnd, buffer, 512);
    parsedMsg = ParseMessageA (buffer, ArgArray);
    if (parsedMsg) {
        SetWindowTextA (Hwnd, parsedMsg);
        FreeStringResourceA (parsedMsg);
    }
}


VOID
ParseMessageInWndW (
    IN      HWND hwnd,
    IN      PCWSTR ArgArray[]
    )
{
    WCHAR buffer[512];
    PCWSTR parsedMsg;

    GetWindowTextW (hwnd, buffer, 512);
    parsedMsg = ParseMessageW (buffer, ArgArray);
    if (parsedMsg) {
        SetWindowTextW (hwnd, parsedMsg);
        FreeStringResourceW (parsedMsg);
    }
}



/*++

Routine Description:

  ResourceMessageBox is used to display a message based on a message resource
  ID.

Arguments:

  HwndOwner - The handle of the owner of the message box to be displayed
  ID        - The identifier of the message resource
  Flags     - MessageBox flags (MB_OK, etc.)
  ArgArray  - Optional array of string pointers, where the meaning depends on
              the message string.  A reference in the message string to %n
              requires element n of ArgArray to be a valid string pointer.

Return Value:

  The return value of MessageBox (MB_YES, etc.)

--*/

INT
ResourceMessageBoxA (
    IN      HWND HwndOwner,
    IN      UINT ID,
    IN      UINT Flags,
    IN      PCSTR ArgArray[]
    )
{
    PCSTR message;
    PCSTR title;
    int rc;

    message = ParseMessageA ((PSTR)(UBINT)ID, ArgArray);
    if (!message)
        return -1;

    title = GetStringResourceA (MSG_MESSAGEBOX_TITLE);

    rc = MessageBoxA (HwndOwner, message, title, Flags);

    FreeStringResourceA (message);
    if (title) {
        FreeStringResourceA (title);
    }

    return rc;
}


INT
ResourceMessageBoxW (
    IN      HWND HwndOwner,
    IN      UINT ID,
    IN      UINT Flags,
    IN      PCWSTR ArgArray[]
    )
{
    PCWSTR message;
    PCWSTR title;
    int rc;

    message = ParseMessageW ((PWSTR)(UBINT)ID, ArgArray);
    if (!message)
        return -1;

    title = GetStringResourceW (MSG_MESSAGEBOX_TITLE);

    rc = MessageBoxW (HwndOwner, message, title, Flags);

    FreeStringResourceW (message);
    if (title) {
        FreeStringResourceW (title);
    }

    return rc;
}


BOOL
StringReplaceA (
    IN      PSTR Buffer,
    IN      DWORD MaxSize,
    IN      PSTR ReplaceStartPos,
    IN      PSTR ReplaceEndPos,
    IN      PCSTR NewString
    )
{
    BOOL        rf = FALSE;
    DWORD       oldSubStringLength;
    DWORD       newSubStringLength;
    DWORD       currentStringLength;
    LONG        offset;
    PSTR        movePosition;

    //
    // Check assumptions.
    //
    MYASSERT(Buffer);
    MYASSERT(ReplaceStartPos && ReplaceStartPos >= Buffer);
    MYASSERT(ReplaceEndPos   && ReplaceEndPos >= ReplaceStartPos);  //lint !e613
    MYASSERT(NewString);

    //
    // Compute sizes.
    //
    oldSubStringLength  = (DWORD)((UBINT)ReplaceEndPos - (UBINT)ReplaceStartPos);
    newSubStringLength  = ByteCountA(NewString);
    currentStringLength = SizeOfStringA(Buffer) + 1;
    offset = (LONG)newSubStringLength - (LONG)oldSubStringLength;

    //
    // Make sure there is enough room in the buffer to perform the replace
    // operation.
    //
    if ((LONG)currentStringLength + offset > (LONG)MaxSize) {
        DEBUGMSG((DBG_WARNING,"ERROR: Buffer to small to perform string replacement."));
        rf = FALSE;
    } else {

        //
        // Shift the rest of the buffer to adjust it to the size of the new string.
        //
        if (newSubStringLength > oldSubStringLength) {

            //
            // right shift.
            //
            for (movePosition = Buffer + currentStringLength;
                 (UBINT)movePosition >= (UBINT)ReplaceStartPos + oldSubStringLength;
                 movePosition--) {

                *(movePosition + offset) = *movePosition;
            }
        } else {

            //
            // left or no shift.
            //
            for(movePosition = ReplaceStartPos + newSubStringLength;    //lint !e613
                movePosition < Buffer + currentStringLength;
                movePosition++) {

                *movePosition = *(movePosition - offset);
            }

        }

        //
        // Now, copy in the string.
        //
        CopyMemory (ReplaceStartPos, NewString, newSubStringLength);    //lint !e668

        //
        // String replacement completed successfully.
        //
        rf = TRUE;


    }

    return rf;

}



BOOL
StringReplaceW (
    IN      PWSTR Buffer,
    IN      DWORD MaxSize,
    IN      PWSTR ReplaceStartPos,
    IN      PWSTR ReplaceEndPos,
    IN      PCWSTR NewString
    )
{
    BOOL        rf = FALSE;
    DWORD       oldSubStringLength;
    DWORD       newSubStringLength;
    DWORD       currentStringLength;
    LONG        offset;
    PWSTR       movePosition;

    //
    // Check assumptions.
    //
    MYASSERT(Buffer);
    MYASSERT(ReplaceStartPos && ReplaceStartPos >= Buffer);
    MYASSERT(ReplaceEndPos   && ReplaceEndPos >= ReplaceStartPos);  //lint !e613
    MYASSERT(NewString);

    //
    // Compute sizes.
    //
    oldSubStringLength  = (DWORD)((UBINT)ReplaceEndPos - (UBINT)ReplaceStartPos);
    newSubStringLength  = CharCountW(NewString);
    currentStringLength = CharCountW(Buffer) + 1;
    offset = (LONG)newSubStringLength - (LONG)oldSubStringLength;

    //
    // Make sure there is enough room in the buffer to perform the replace
    // operation.
    //
    if ((LONG)currentStringLength + offset > (LONG)MaxSize) {
        DEBUGMSG((DBG_WARNING,"ERROR: Buffer to small to perform string replacement."));
        rf = FALSE;
    } else {

        //
        // Shift the rest of the buffer to adjust it to the size of the new string.
        //
        if (newSubStringLength > oldSubStringLength) {

            //
            // right shift.
            //
            for (movePosition = Buffer + currentStringLength;
                 (UBINT)movePosition >= (UBINT)ReplaceStartPos + oldSubStringLength;
                 movePosition--) {

                *(movePosition + offset) = *movePosition;
            }
        } else {

            //
            // left or no shift.
            //
            for (movePosition = ReplaceStartPos + newSubStringLength;    //lint !e613
                 movePosition < Buffer + currentStringLength;
                 movePosition++) {

                *movePosition = *(movePosition - offset);
            }

        }

        //
        // Now, copy in the string.
        //
        wcsncpy(ReplaceStartPos,NewString,newSubStringLength);

        //
        // String replacement completed successfully.
        //
        rf = TRUE;


    }

    return rf;

}

#if 0
/*++

Routine Description:

  AddInfSectionToHashTable enumerates the specified section and adds each
  item to the string table.  An optional callback allows data to be associated
  with each item.

Arguments:

  Table          - Specifies the table that receives new entries
  InfFile        - Specifies an open INF handle of the file to read
  Section        - Specifies the INF section name to enumerate
  Field          - Specifies which field to extract text from.  If the field
                   exists, it is added to the string table.
  Callback       - Specifies optional callback to be called before adding to
                   the string table.  The callback supplies additional data.
  CallbackParam  - Data passed to the callback

Return Value:

  TRUE if the INF file was processed successfullly, or FALSE if an error
  occurred.

--*/


BOOL
AddInfSectionToHashTableA (
    IN OUT  HASHTABLE Table,
    IN      HINF InfFile,
    IN      PCSTR Section,
    IN      DWORD Field,
    IN      ADDINFSECTION_PROCA Callback,
    IN      PVOID CallbackData
    )
{
    INFCONTEXT ic;
    LONG rc;
    HASHTABLE ht;
    DWORD reqSize;
    DWORD currentSize = 0;
    PSTR newBuffer, buffer = NULL;
    PVOID data;
    UINT dataSize;
    BOOL b = FALSE;

    //
    // On NT, Setup API is compiled with UNICODE, so the string table
    // functions are UNICODE only.
    //

    if (ISNT()) {
        SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
        return FALSE;
    }

    if (SetupFindFirstLineA (InfFile, Section, NULL, &ic)) {
        do {
            if (!SetupGetStringFieldA (&ic, Field, NULL, 0, &reqSize)) {
                continue;
            }

            if (reqSize > currentSize) {
                reqSize = ((reqSize / 1024) + 1) * 1024;
                if (buffer) {
                    newBuffer = (PSTR) MemReAlloc (g_hHeap, 0, buffer, reqSize);
                } else {
                    newBuffer = (PSTR) MemAlloc (g_hHeap, 0, reqSize);
                }

                if (!newBuffer) {
                    goto cleanup;
                }

                buffer = newBuffer;
                currentSize = reqSize;
            }

            if (!SetupGetStringFieldA (&ic, Field, buffer, currentSize, NULL)) {
                DEBUGMSG ((DBG_ERROR, "AddInfSectionToHashTable: SetupGetStringField failed unexpectedly"));
                continue;
            }

            data = NULL;
            dataSize = 0;

            if (Callback) {
                rc = Callback (buffer, &data, &dataSize, CallbackData);
                if (rc == CALLBACK_STOP) {
                    goto cleanup;
                }
                if (rc == CALLBACK_SKIP) {
                    continue;
                }
            }

            ht = HtAddStringExA (
                        Table,
                        buffer,
                        data,
                        CASE_INSENSITIVE
                        );

            if (!ht) {
                goto cleanup;
            }

        } while (SetupFindNextLine (&ic, &ic));
    }

    b = TRUE;

cleanup:
    if (buffer) {
        PushError();
        MemFree (g_hHeap, 0, buffer);
        PopError();
    }
    return b;
}


BOOL
AddInfSectionToHashTableW (
    IN OUT  HASHTABLE Table,
    IN      HINF InfFile,
    IN      PCWSTR Section,
    IN      DWORD Field,
    IN      ADDINFSECTION_PROCW Callback,
    IN      PVOID CallbackData
    )
{
    INFCONTEXT ic;
    HASHTABLE ht;
    LONG rc;
    DWORD reqSize;
    DWORD currentSize = 0;
    PWSTR newBuffer, buffer = NULL;
    PVOID data;
    UINT dataSize;
    BOOL b = FALSE;

    //
    // On Win9x, Setup API is compiled with ANSI, so the string table
    // functions are ANSI only.
    //

    if (ISWIN9X()) {
        SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
        return FALSE;
    }

    if (SetupFindFirstLineW (InfFile, Section, NULL, &ic)) {
        do {
            if (!SetupGetStringFieldW (&ic, Field, NULL, 0, &reqSize)) {
                continue;
            }

            if (reqSize > currentSize) {
                reqSize = ((reqSize / 1024) + 1) * 1024;
                if (buffer) {
                    newBuffer = (PWSTR) MemReAlloc (g_hHeap, 0, buffer, reqSize);
                } else {
                    newBuffer = (PWSTR) MemAlloc (g_hHeap, 0, reqSize);
                }

                if (!newBuffer) {
                    goto cleanup;
                }

                buffer = newBuffer;
                currentSize = reqSize;
            }

            if (!SetupGetStringFieldW (&ic, Field, buffer, currentSize, NULL)) {
                DEBUGMSG ((DBG_ERROR, "AddInfSectionToHashTable: SetupGetStringField failed unexpectedly"));
                continue;
            }

            data = NULL;
            dataSize = 0;

            if (Callback) {
                rc = Callback (buffer, &data, &dataSize, CallbackData);
                if (rc == CALLBACK_STOP) {
                    goto cleanup;
                }
                if (rc == CALLBACK_SKIP) {
                    continue;
                }
            }

            ht = HtAddStringExW (
                        Table,
                        buffer,
                        data,
                        CASE_INSENSITIVE
                        );

            if (!ht) {
                goto cleanup;
            }

        } while (SetupFindNextLine (&ic, &ic));
    }

    b = TRUE;

cleanup:
    if (buffer) {
        PushError();
        MemFree (g_hHeap, 0, buffer);
        PopError();
    }
    return b;
}
#endif

/*++

Routine Description:

  Finds the last wack in the path and returns a pointer to the next
  character.  If no wack is found, returns a pointer to the full
  string.

Arguments:

  PathSpec  - Specifies the path that has a file at the end of it

Return Value:

  A pointer to the file name in the path.

--*/

PCSTR
GetFileNameFromPathA (
    IN      PCSTR PathSpec
    )

{
    PCSTR p;

    p = _mbsrchr (PathSpec, '\\');
    if (p) {
        p = _mbsinc (p);
    } else {
        p = PathSpec;
    }

    return p;
}

PCWSTR
GetFileNameFromPathW (
    IN      PCWSTR PathSpec
    )

{
    PCWSTR p;

    p = wcsrchr (PathSpec, L'\\');
    if (p) {
        p++;
    } else {
        p = PathSpec;
    }

    return p;
}


/*++

Routine Description:

  Finds the last wack in the path and then the last point from the remaining path
  returning a pointer to the next character. If no point is found, returns a null pointer.

Arguments:

  PathSpec  - Specifies the path that has a file at the end of it

Return Value:

  A pointer to the file extension, excluding the dot, or NULL if no extension exists.

--*/

PCSTR
GetFileExtensionFromPathA (
    IN      PCSTR PathSpec
    )

{
    PCSTR p;
    PCSTR ReturnPtr = NULL;

    p = PathSpec;

    while (*p) {
        if (*p == '.') {
            ReturnPtr = p + 1;
        } else if (*p == '\\') {
            ReturnPtr = NULL;
        }

        p = _mbsinc (p);
    }

    return ReturnPtr;
}


PCWSTR
GetFileExtensionFromPathW (
    IN      PCWSTR PathSpec
    )

{
    PCWSTR p;
    PCWSTR ReturnPtr = NULL;

    p = PathSpec;

    while (*p) {
        if (*p == L'.') {
            ReturnPtr = p + 1;
        } else if (*p == L'\\') {
            ReturnPtr = NULL;
        }

        p++;
    }

    return ReturnPtr;
}


/*++

Routine Description:

  GetDotExtensionFromPath finds the last wack in the path and then the last dot from
  the remaining path, returning a pointer to the dot. If no dot is found, returns the
  end of the string.

Arguments:

  PathSpec  - Specifies the path that has a file at the end of it

Return Value:

  A pointer to the file extension, including the dot, or the end of the string if
  no extension exists.

--*/

PCSTR
GetDotExtensionFromPathA (
    IN      PCSTR PathSpec
    )

{
    PCSTR p;
    PCSTR ReturnPtr = NULL;

    p = PathSpec;

    while (*p) {
        if (*p == '.') {
            ReturnPtr = p;
        } else if (*p == '\\') {
            ReturnPtr = NULL;
        }

        p = _mbsinc (p);
    }

    if (!ReturnPtr) {
        return p;
    }

    return ReturnPtr;
}


PCWSTR
GetDotExtensionFromPathW (
    IN      PCWSTR PathSpec
    )

{
    PCWSTR p;
    PCWSTR ReturnPtr = NULL;

    p = PathSpec;

    while (*p) {
        if (*p == L'.') {
            ReturnPtr = p;
        } else if (*p == L'\\') {
            ReturnPtr = NULL;
        }

        p++;
    }

    if (!ReturnPtr) {
        return p;
    }

    return ReturnPtr;
}


/*++

Routine Description:

  CountInstancesOfChar returns the number of occurances Char
  is found in String.

Arguments:

  String - Specifies the text that may or may not contain
           search text

  Char - Specifies the char to count

Return Value:

  The number of times Char appears in String.

--*/

UINT
CountInstancesOfCharA (
    IN      PCSTR String,
    IN      MBCHAR Char
    )
{
    UINT count;

    count = 0;
    while (*String) {
        if (_mbsnextc (String) == Char) {
            count++;
        }

        String = _mbsinc (String);
    }

    return count;
}


UINT
CountInstancesOfCharW (
    IN      PCWSTR String,
    IN      WCHAR Char
    )
{
    UINT count;

    count = 0;
    while (*String) {
        if (*String == Char) {
            count++;
        }

        String++;
    }

    return count;
}


/*++

Routine Description:

  CountInstancesOfCharI returns the number of occurances Char
  is found in String.  The comparison is case-insenetive.

Arguments:

  String - Specifies the text that may or may not contain
           search text

  Char - Specifies the char to count

Return Value:

  The number of times Char appears in String.

--*/

UINT
CountInstancesOfCharIA (
    IN      PCSTR String,
    IN      MBCHAR Char
    )
{
    UINT count;

    Char = (MBCHAR)tolower ((INT)Char);

    count = 0;
    while (*String) {
        if ((MBCHAR) tolower ((INT)_mbsnextc (String)) == Char) {
            count++;
        }

        String = _mbsinc (String);
    }

    return count;
}


UINT
CountInstancesOfCharIW (
    IN      PCWSTR String,
    IN      WCHAR Char
    )
{
    UINT count;

    Char = towlower (Char);

    count = 0;
    while (*String) {
        if (towlower (*String) == Char) {
            count++;
        }

        String++;
    }

    return count;
}


/*++

Routine Description:

  Searches the string counting the number of occurances of
  SearchString exist in SourceString.

Arguments:

  SourceString - Specifies the text that may or may not contain
                 search text

  SearchString - Specifies the text phrase to count

Return Value:

  The number of times SearchString appears in SourceString.

--*/

UINT
CountInstancesOfSubStringA (
    IN      PCSTR SourceString,
    IN      PCSTR SearchString
    )
{
    PCSTR p;
    UINT count;
    UINT searchBytes;

    count = 0;
    p = SourceString;
    searchBytes = ByteCountA (SearchString);

    while (p = _mbsistr (p, SearchString)) {    //lint !e720
        count++;
        p += searchBytes;
    }

    return count;
}


UINT
CountInstancesOfSubStringW (
    IN      PCWSTR SourceString,
    IN      PCWSTR SearchString
    )
{
    PCWSTR p;
    UINT count;
    UINT SearchChars;

    count = 0;
    p = SourceString;
    SearchChars = CharCountW (SearchString);

    while (p = _wcsistr (p, SearchString)) {    //lint !e720
        count++;
        p += SearchChars;
    }

    return count;
}


/*++

Routine Description:

  Searches and replaces all occurances of SearchString with
  ReplaceString.

Arguments:

  SourceString - String that contiains zero or more instances
                 of the search text

  SearchString - String to search for.  Cannot be zero-length or NULL.

  ReplaceString - String to replace.  Can be zero-length but cannot
                  be NULL.

Return Value:

  A pointer to the pool-allocated string, or NULL if no instances
  of SearchString were found in SourceString.  Free the non-NULL
  pointer with FreePathString.

--*/

PCSTR
StringSearchAndReplaceA (
    IN      PCSTR SourceString,
    IN      PCSTR SearchString,
    IN      PCSTR ReplaceString
    )
{
    PSTR newString;
    PBYTE p, q;
    PBYTE dest;
    UINT count;
    UINT size;
    UINT searchBytes;
    UINT replaceBytes;
    UINT untouchedBytes;

    //
    // count occurances within the string
    //

    count = CountInstancesOfSubStringA (
                SourceString,
                SearchString
                );

    if (!count) {
        return NULL;
    }

    searchBytes = ByteCountA (SearchString);
    replaceBytes = ByteCountA (ReplaceString);
    MYASSERT (searchBytes);

    size = SizeOfStringA (SourceString) -
           count * searchBytes +
           count * replaceBytes;

    newString = (PSTR) PmGetAlignedMemory (g_PathsPool, size);
    if (!newString) {
        return NULL;
    }

    p = (PBYTE) SourceString;
    dest = (PBYTE) newString;

    while (q = (PBYTE) _mbsistr ((PCSTR) p, SearchString)) {    //lint !e720

        untouchedBytes = (DWORD)(q - p);

        if (untouchedBytes) {
            CopyMemory (dest, p, (SIZE_T) untouchedBytes);
            dest += untouchedBytes;
        }

        if (replaceBytes) {
            CopyMemory (dest, (PBYTE) ReplaceString, (SIZE_T) replaceBytes);
            dest += replaceBytes;
        }

        p = q + searchBytes;
    }

    StringCopyA ((PSTR) dest, (PSTR) p);

    return newString;
}


PCWSTR
StringSearchAndReplaceW (
    IN      PCWSTR SourceString,
    IN      PCWSTR SearchString,
    IN      PCWSTR ReplaceString
    )
{
    PWSTR newString;
    PBYTE p, q;
    PBYTE dest;
    UINT count;
    UINT size;
    UINT searchBytes;
    UINT replaceBytes;
    UINT untouchedBytes;

    //
    // count occurances within the string
    //

    count = CountInstancesOfSubStringW (
                SourceString,
                SearchString
                );

    if (!count) {
        return NULL;
    }

    searchBytes = ByteCountW (SearchString);
    replaceBytes = ByteCountW (ReplaceString);
    MYASSERT (searchBytes);

    size = SizeOfStringW (SourceString) -
           count * searchBytes +
           count * replaceBytes;

    newString = (PWSTR) PmGetAlignedMemory (g_PathsPool, size);
    if (!newString) {
        return NULL;
    }

    p = (PBYTE) SourceString;
    dest = (PBYTE) newString;

    while (q = (PBYTE) _wcsistr ((PCWSTR) p, SearchString)) {   //lint !e720

        untouchedBytes = (DWORD)(q - p);

        if (untouchedBytes) {
            CopyMemory (dest, p, (SIZE_T) untouchedBytes);
            dest += untouchedBytes;
        }

        if (replaceBytes) {
            CopyMemory (dest, (PBYTE) ReplaceString, (SIZE_T) replaceBytes);
            dest += replaceBytes;
        }

        p = q + searchBytes;
    }

    StringCopyW ((PWSTR) dest, (PWSTR) p);

    return newString;
}


PSTR *
CommandLineToArgvA (
    IN      PCSTR CmdLine,
    OUT     PUINT NumArgs
    )

/*++

Routine Description:

  CommandLineToArgvA implements an ANSI version of the Win32 function
  CommandLineToArgvW.

Arguments:

  CmdLine   - A pointer to the complete command line, including the
              module name.  This is the same string returned by
              GetCommandLineA().

  NumArgs   - Receives the number of arguments allocated, identical to
              main's argc parameter.  That is, NumArgs is equal to
              the number of command line arguments plus one for the
              command itself.

Return Value:

  A pointer to an array of string pointers, one per argument.  The
  command line arguments are placed in separate nul-terminated strings.
  The caller must free the memory using a single call to GlobalFree or
  LocalFree.

--*/

{
    PCSTR start, end;
    BOOL QuoteMode;
    MBCHAR ch = 0;
    UINT Pass;
    UINT ArgStrSize;
    UINT Args;
    PSTR ArgStrEnd = NULL;     // filled in on pass one, used on pass two
    PSTR *ArgPtrArray = NULL;  // filled in on pass one, used on pass two

    //
    // count args on first pass, then allocate memory and create arg string
    //

    ArgStrSize = 0;
    Pass = 0;
    do {
        // Init loop
        Pass++;
        Args = 0;
        start = CmdLine;

        // Skip leading space
        while (isspace (*start)) {
            start++;
        }

        while (*start) {
            // Look for quote mode
            if (*start == '\"') {
                QuoteMode = TRUE;
                start++;
            } else {
                QuoteMode = FALSE;
            }

            // Find end of arg
            end = start;
            while (*end) {
                ch = _mbsnextc (end);
                if (QuoteMode) {
                    if (ch == '\"') {
                        break;
                    }
                } else {
                    if (isspace ((INT)ch)) {
                        break;
                    }
                }

                end = _mbsinc (end);
            }

            // If Pass 1, add string size
            if (Pass == 1) {
                ArgStrSize += (UINT)((UBINT)end - (UBINT)start) + 1;
            }

            // If Pass 2, copy strings to buffer
            else {
                MYASSERT (ArgStrEnd);
                MYASSERT (ArgPtrArray);

                ArgPtrArray[Args] = ArgStrEnd;  //lint !e613
                StringCopyABA (ArgStrEnd, start, end);
                ArgStrEnd = GetEndOfStringA (ArgStrEnd);    //lint !e668
                ArgStrEnd++;    //lint !e613
            }

            // Set start to next arg
            Args++;

            if (QuoteMode && ch == '\"') {
                end = _mbsinc (end);
            }

            start = end;
            while (isspace (*start)) {
                start++;
            }
        }

        // If Pass 1, allocate strings
        if (Pass == 1) {
            if (Args) {
                ArgPtrArray = (PSTR *) GlobalAlloc (
                                            GPTR,
                                            (UINT)(sizeof (PSTR) * Args + ArgStrSize)
                                            );
                if (!ArgPtrArray) {
                    return NULL;
                }

                ArgStrEnd = (PSTR) (&ArgPtrArray[Args]);
            } else {
                return NULL;
            }
        }
    } while (Pass < 2);

    *NumArgs = Args;
    return ArgPtrArray;
}


BOOL
EnumNextMultiSzA (
    IN OUT  PMULTISZ_ENUMA MultiSzEnum
    )
{
    if (!MultiSzEnum->CurrentString || !(*MultiSzEnum->CurrentString)) {
        return FALSE;
    }

    MultiSzEnum->CurrentString = GetEndOfStringA (MultiSzEnum->CurrentString) + 1;  //lint !e613
    return (MultiSzEnum->CurrentString [0] != 0);
}

BOOL
EnumFirstMultiSzA (
    OUT     PMULTISZ_ENUMA MultiSzEnum,
    IN      PCSTR MultiSzStr
    )
{
    if ((MultiSzStr == NULL) || (MultiSzStr [0] == 0)) {
        return FALSE;
    }
    MultiSzEnum->Buffer  = MultiSzStr;
    MultiSzEnum->CurrentString = MultiSzStr;
    return TRUE;
}


BOOL
EnumNextMultiSzW (
    IN OUT  PMULTISZ_ENUMW MultiSzEnum
    )
{
    if (!MultiSzEnum->CurrentString || !(*MultiSzEnum->CurrentString)) {
        return FALSE;
    }

    MultiSzEnum->CurrentString = GetEndOfStringW (MultiSzEnum->CurrentString) + 1;
    return (MultiSzEnum->CurrentString [0] != 0);
}

BOOL
EnumFirstMultiSzW (
    OUT     PMULTISZ_ENUMW MultiSzEnum,
    IN      PCWSTR MultiSzStr
    )
{
    if ((MultiSzStr == NULL) || (MultiSzStr [0] == 0)) {
        return FALSE;
    }
    MultiSzEnum->Buffer  = MultiSzStr;
    MultiSzEnum->CurrentString = MultiSzStr;
    return TRUE;
}


PSTR
GetPrevCharA (
    IN      PCSTR StartStr,
    IN      PCSTR CurrPtr,
    IN      MBCHAR SearchChar
    )
{
    PCSTR ptr = CurrPtr;

    for (;;) {
        ptr = _mbsdec2 (StartStr, ptr);

        if (!ptr) {
            return NULL;
        }
        if (_mbsnextc (ptr) == SearchChar) {
            return (PSTR) ptr;
        }
    }
}


PWSTR
GetPrevCharW (
    IN      PCWSTR StartStr,
    IN      PCWSTR CurrPtr,
    IN      WCHAR SearchChar
    )
{
    PCWSTR ptr = CurrPtr;

    while (ptr > StartStr) {
        ptr--;

        if (*ptr == SearchChar) {
            return (PWSTR) ptr;
        }
    }

    return NULL;
}


VOID
ToggleWacksA (
    IN      PSTR Line,
    IN      BOOL Operation
    )
{
    CHAR curChar;
    CHAR newChar;
    PSTR p = Line;


    curChar = Operation ? WACK_REPLACE_CHAR : '\\';
    newChar = Operation ? '\\' : WACK_REPLACE_CHAR;

    do {

        p = _mbschr (p, curChar);

        if (p) {

            *p = newChar;
            p = _mbsinc (p);
        }

    } while (p);
}


VOID
ToggleWacksW (
    IN      PWSTR Line,
    IN      BOOL Operation
    )
{
    WCHAR curChar;
    WCHAR newChar;
    PWSTR p = Line;


    curChar = Operation ? WACK_REPLACE_CHAR : L'\\';
    newChar = Operation ? L'\\' : WACK_REPLACE_CHAR;

    do {

        p = wcschr (p, curChar);

        if (p) {

            *p = newChar;
            p++;
        }

    } while (p);
}


PSTR
pGoBackA (
    IN      PSTR LastChar,
    IN      PSTR FirstChar,
    IN      UINT NumWacks
    )
{
    LastChar = _mbsdec2 (FirstChar, LastChar);
    while (NumWacks && (LastChar >= FirstChar)) {
        if (_mbsnextc (LastChar) == '\\') {
            NumWacks --;
        }
        LastChar = _mbsdec2 (FirstChar, LastChar);
    }
    if (NumWacks) {
        return NULL;
    }
    return LastChar + 2;
}


PWSTR
pGoBackW (
    IN      PWSTR LastChar,
    IN      PWSTR FirstChar,
    IN      UINT NumWacks
    )
{
    LastChar --;
    while (NumWacks && (LastChar >= FirstChar)) {
        if (*LastChar == L'\\') {
            NumWacks --;
        }
        LastChar --;
    }
    if (NumWacks) {
        return NULL;
    }
    return LastChar + 2;
}


UINT
pCountDotsA (
    IN      PCSTR PathSeg
    )
{
    UINT numDots = 0;

    while (PathSeg && *PathSeg) {
        if (_mbsnextc (PathSeg) != '.') {
            return 0;
        }
        numDots ++;
        PathSeg = _mbsinc (PathSeg);
    }
    return numDots;
}


UINT
pCountDotsW (
    IN      PCWSTR PathSeg
    )
{
    UINT numDots = 0;

    while (PathSeg && *PathSeg) {
        if (*PathSeg != L'.') {
            return 0;
        }
        numDots ++;
        PathSeg ++;
    }
    return numDots;
}

PCSTR
SanitizePathA (
    IN      PCSTR FileSpec
    )
{
    CHAR pathSeg [MAX_MBCHAR_PATH];
    PCSTR wackPtr;
    UINT dotNr;
    PSTR newPath = DuplicatePathStringA (FileSpec, 0);
    PSTR newPathPtr = newPath;
    BOOL firstPass = TRUE;

    do {
        wackPtr = _mbschr (FileSpec, '\\');

        if (wackPtr) {
            if (firstPass && (wackPtr == FileSpec)) {
                // this one starts with a wack, let's see if we have double wacks
                wackPtr = _mbsinc (wackPtr);
                if (!wackPtr) {
                    FreePathStringA (newPath);
                    return NULL;
                }
                if (_mbsnextc (wackPtr) == '\\') {
                    // this one starts with a double wack
                    wackPtr = _mbsinc (wackPtr);
                    if (!wackPtr) {
                        FreePathStringA (newPath);
                        return NULL;
                    }
                    wackPtr = _mbschr (wackPtr, '\\');
                } else {
                    wackPtr = _mbschr (wackPtr, '\\');
                }
            }
            firstPass = FALSE;
            if (wackPtr) {
                StringCopyByteCountABA (pathSeg, FileSpec, wackPtr, MAX_MBCHAR_PATH);
                FileSpec = _mbsinc (wackPtr);
            } else {
                StringCopyByteCountABA (pathSeg, FileSpec, GetEndOfStringA (FileSpec), MAX_MBCHAR_PATH);
            }
        } else {
            StringCopyByteCountABA (pathSeg, FileSpec, GetEndOfStringA (FileSpec), MAX_MBCHAR_PATH);
        }

        if (*pathSeg) {
            dotNr = pCountDotsA (pathSeg);
            if (dotNr>1) {

                newPathPtr = pGoBackA (newPathPtr, newPath, dotNr);

                if (newPathPtr == NULL) {
                    DEBUGMSGA ((DBG_WARNING, "Broken path detected:%s", FileSpec));
                    FreePathStringA (newPath);
                    return NULL;
                }
            } else {

                StringCopyA (newPathPtr, pathSeg);
                newPathPtr = GetEndOfStringA (newPathPtr);
                if (wackPtr) {
                    *newPathPtr = '\\';
                    //we increment this because we know that \ is a single byte character.
                    newPathPtr ++;
                }
            }
        }
    } while (wackPtr);

    *newPathPtr = 0;

    return newPath;
}

PCWSTR
SanitizePathW (
    IN      PCWSTR FileSpec
    )
{
    WCHAR pathSeg [MEMDB_MAX];
    PCWSTR wackPtr;
    UINT dotNr;
    PWSTR newPath = DuplicatePathStringW (FileSpec, 0);
    PWSTR newPathPtr = newPath;
    BOOL firstPass = TRUE;

    do {
        wackPtr = wcschr (FileSpec, L'\\');

        if (wackPtr) {
            if (firstPass && (wackPtr == FileSpec)) {
                // this one starts with a wack, let's see if we have double wacks
                wackPtr ++;
                if (*wackPtr == 0) {
                    FreePathStringW (newPath);
                    return NULL;
                }
                if (*wackPtr == L'\\') {
                    // this one starts with a double wack
                    wackPtr ++;
                    if (!wackPtr) {
                        FreePathStringW (newPath);
                        return NULL;
                    }
                    wackPtr = wcschr (wackPtr, L'\\');
                } else {
                    wackPtr = wcschr (wackPtr, L'\\');
                }
            }
            firstPass = FALSE;
            if (wackPtr) {

                StringCopyByteCountABW (
                    pathSeg,
                    FileSpec,
                    wackPtr,
                    (UINT) sizeof (pathSeg)
                    );

                FileSpec = wackPtr + 1;
            } else {
                StringCopyByteCountABW (pathSeg, FileSpec, GetEndOfStringW (FileSpec), MAX_WCHAR_PATH);
            }
        } else {
            StringCopyByteCountABW (pathSeg, FileSpec, GetEndOfStringW (FileSpec), MAX_WCHAR_PATH);
        }

        if (*pathSeg) {
            dotNr = pCountDotsW (pathSeg);
            if (dotNr>1) {

                newPathPtr = pGoBackW (newPathPtr, newPath, dotNr);

                if (newPathPtr == NULL) {
                    DEBUGMSGW ((DBG_WARNING, "Broken path detected:%s", FileSpec));
                    FreePathStringW (newPath);
                    return NULL;
                }
            } else {

                StringCopyW (newPathPtr, pathSeg);
                newPathPtr = GetEndOfStringW (newPathPtr);
                if (wackPtr) {
                    *newPathPtr = L'\\';
                    newPathPtr ++;
                }
            }
        }
    } while (wackPtr);

    *newPathPtr = 0;

    return newPath;
}

UINT
pBuildFromDHList (
    IN      UINT ch1,
    IN      UINT ch2
    )
{
    PDHLIST p;
    UINT result = 0;

    p = g_DHList;
    while (p->char1) {
        if ((p->char1 == ch1) && (p->char2 == ch2)) {
            result = p->result;
            break;
        }
        p++;
    }
    return result;
}


VOID
_mbssetchar (
    OUT     PSTR Dest,
    IN      UINT Char
    )
{
    if (Char >= 256) {
        *(Dest+1) = *((PBYTE)(&Char));
        *(Dest) = *((PBYTE)(&Char) + 1);
    }
    else {
        *Dest = (CHAR) Char;
    }
}


/*++

Routine Description:

    FindLastWack finds the position of the last \ in the given string or NULL if none found

Arguments:

    Str - Specifies the string

Return Value:

    Pointer to the last occurence of a \ in the string or NULL

--*/

PCSTR
FindLastWackA (
    IN      PCSTR Str
    )
{
    PCSTR lastWack = NULL;

    if (Str) {
        while ((Str = _mbschr (Str, '\\')) != NULL) {
            lastWack = Str;
            Str++;
        }
    }

    return lastWack;
}


PCWSTR
FindLastWackW (
    IN      PCWSTR Str
    )
{
    PCWSTR lastWack = NULL;

    if (Str) {
        while ((Str = wcschr (Str, L'\\')) != NULL) {
            lastWack = Str;
            Str++;
        }
    }

    return lastWack;
}


/*++

Routine Description:

    GetNodePatternMinMaxLevels treats the given string pattern as a path with \ as separator
    and computes the min and max levels of the given node; the root has level 1; if a * is
    followed by \ it is treated as a single level (e.g. *\ only enumerates roots)

Arguments:

    NodePattern - Specifies the node as a string pattern
    FormattedNodePattern - Receives the formatted string, eliminating duplicate * and the last \;
                    may be the same as NodePattern
    MinLevel - Receives the minimum level of a node having this pattern
    MaxLevel - Receives the maximum level of a node having this pattern; may be NODE_LEVEL_MAX

Return Value:

    TRUE if NodePattern is a valid pattern and the function succeeded, FALSE otherwise

--*/

#define NODESTATE_BEGIN     0
#define NODESTATE_UNC       1
#define NODESTATE_BEGINSEG  2
#define NODESTATE_INSEG     3
#define NODESTATE_ESCAPED   4
#define NODESTATE_STAR      5
#define NODESTATE_STARONLY  6

BOOL
GetNodePatternMinMaxLevelsA (
    IN          PCSTR NodePattern,
    OUT         PSTR FormattedNode,     OPTIONAL
    OUT         PDWORD MinLevel,        OPTIONAL
    OUT         PDWORD MaxLevel         OPTIONAL
    )
{
    PCSTR nodePattern = NodePattern;
    MBCHAR currCh = 0;
    DWORD minLevel = 0;
    DWORD maxLevel = 0;
    DWORD state = NODESTATE_BEGIN;
    BOOL advance;
    BOOL copyChar;

    if (!NodePattern || *NodePattern == 0) {
        return FALSE;
    }

    while (*nodePattern) {
        advance = TRUE;
        copyChar = TRUE;
        currCh = _mbsnextc (nodePattern);
        switch (state) {
        case NODESTATE_BEGIN:
            switch (currCh) {
            case '\\':
                state = NODESTATE_UNC;
                break;
            case '*':
                minLevel ++;
                maxLevel ++;
                state = NODESTATE_INSEG;
                advance = FALSE;
                break;
            case '?':
                minLevel ++;
                maxLevel ++;
                state = NODESTATE_INSEG;
                advance = FALSE;
                break;
            case '^':
                minLevel ++;
                maxLevel ++;
                state = NODESTATE_ESCAPED;
                break;
            default:
                minLevel ++;
                maxLevel ++;
                state = NODESTATE_INSEG;
                break;
            }
            break;
        case NODESTATE_UNC:
            minLevel ++;
            if (maxLevel != NODE_LEVEL_MAX) {
                maxLevel ++;
            }
            switch (currCh) {
            case '\\':
                state = NODESTATE_BEGINSEG;
                break;
            case '*':
                state = NODESTATE_BEGINSEG;
                advance = FALSE;
                break;
            case '?':
                state = NODESTATE_INSEG;
                advance = FALSE;
                break;
            case '^':
                state = NODESTATE_ESCAPED;
                break;
            default:
                state = NODESTATE_INSEG;
                break;
            }
            break;
        case NODESTATE_BEGINSEG:
            switch (currCh) {
            case '\\':
                DEBUGMSGA ((DBG_STRINGS, "GetNodeMinMaxLevelsA: two wacks in a row: %s", NodePattern));
                return FALSE;
            case '*':
                minLevel --;
                state = NODESTATE_STARONLY;
                maxLevel = NODE_LEVEL_MAX;
                break;
            case '?':
                state = NODESTATE_INSEG;
                advance = FALSE;
                break;
            case '^':
                state = NODESTATE_ESCAPED;
                break;
            default:
                state = NODESTATE_INSEG;
                break;
            }
            break;
        case NODESTATE_STARONLY:
            state = NODESTATE_INSEG;
            if (currCh == '*') {
                copyChar = FALSE;
            } else {
                minLevel ++;
                if (maxLevel != NODE_LEVEL_MAX) {
                    maxLevel ++;
                }
                advance = FALSE;
            }
            break;
        case NODESTATE_STAR:
            state = NODESTATE_INSEG;
            if (currCh == '*') {
                copyChar = FALSE;
            } else {
                advance = FALSE;
            }
            break;
        case NODESTATE_INSEG:
            switch (currCh) {
            case '\\':
                minLevel ++;
                if (maxLevel != NODE_LEVEL_MAX) {
                    maxLevel ++;
                }
                state = NODESTATE_BEGINSEG;
                break;
            case '*':
                state = NODESTATE_STAR;
                maxLevel = NODE_LEVEL_MAX;
                break;
            case '?':
                state = NODESTATE_INSEG;
                if (maxLevel != NODE_LEVEL_MAX) {
                    maxLevel ++;
                }
                break;
            case '^':
                state = NODESTATE_ESCAPED;
                break;
            default:
                state = NODESTATE_INSEG;
                break;
            }
            break;
        case NODESTATE_ESCAPED:
            if (!_mbschr (EscapedCharsA, currCh)) {
                DEBUGMSGA ((DBG_STRINGS, "GetNodeMinMaxLevelsA: illegal escaped character: %s", NodePattern));
                return FALSE;
            }
            state = NODESTATE_INSEG;
            break;
        default:
            DEBUGMSGA ((DBG_STRINGS, "GetNodeMinMaxLevelsA: unknown state while processing: %s", NodePattern));
            return FALSE;
        }
        if (advance) {
            if (copyChar && FormattedNode) {
                if (IsLeadByte (*nodePattern)) {
                    *FormattedNode = *nodePattern;
                    FormattedNode ++;
                    nodePattern ++;
                }
                *FormattedNode = *nodePattern;
                FormattedNode ++;
                nodePattern ++;
            } else {
                nodePattern = _mbsinc (nodePattern);
            }
        }
    }
    if (MinLevel) {
        *MinLevel = minLevel;
    }
    if (MaxLevel) {
        *MaxLevel = maxLevel;
    }
    if (FormattedNode) {
        *FormattedNode = 0;
    }
    return TRUE;
}

BOOL
GetNodePatternMinMaxLevelsW (
    IN          PCWSTR NodePattern,
    OUT         PWSTR FormattedNode,    OPTIONAL
    OUT         PDWORD MinLevel,        OPTIONAL
    OUT         PDWORD MaxLevel         OPTIONAL
    )
{
    PCWSTR nodePattern = NodePattern;
    DWORD minLevel = 0;
    DWORD maxLevel = 0;
    DWORD state = NODESTATE_BEGIN;
    BOOL advance;
    BOOL copyChar;

    if (!NodePattern || *NodePattern == 0) {
        return FALSE;
    }

    while (*nodePattern) {
        advance = TRUE;
        copyChar = TRUE;
        switch (state) {
        case NODESTATE_BEGIN:
            switch (*nodePattern) {
            case L'\\':
                state = NODESTATE_UNC;
                break;
            case L'*':
                minLevel ++;
                maxLevel ++;
                state = NODESTATE_INSEG;
                advance = FALSE;
                break;
            case L'?':
                minLevel ++;
                maxLevel ++;
                state = NODESTATE_INSEG;
                advance = FALSE;
                break;
            case L'^':
                minLevel ++;
                maxLevel ++;
                state = NODESTATE_ESCAPED;
                break;
            default:
                minLevel ++;
                maxLevel ++;
                state = NODESTATE_INSEG;
                break;
            }
            break;
        case NODESTATE_UNC:
            minLevel ++;
            if (maxLevel != NODE_LEVEL_MAX) {
                maxLevel ++;
            }
            switch (*nodePattern) {
            case L'\\':
                state = NODESTATE_BEGINSEG;
                break;
            case L'*':
                state = NODESTATE_BEGINSEG;
                advance = FALSE;
                break;
            case L'?':
                state = NODESTATE_INSEG;
                advance = FALSE;
                break;
            case L'^':
                state = NODESTATE_ESCAPED;
                break;
            default:
                state = NODESTATE_INSEG;
                break;
            }
            break;
        case NODESTATE_BEGINSEG:
            switch (*nodePattern) {
            case L'\\':
                DEBUGMSGW ((DBG_STRINGS, "GetNodeMinMaxLevelsA: two wacks in a row: %s", NodePattern));
                return FALSE;
            case L'*':
                minLevel --;
                state = NODESTATE_STARONLY;
                maxLevel = NODE_LEVEL_MAX;
                break;
            case L'?':
                state = NODESTATE_INSEG;
                advance = FALSE;
                break;
            case L'^':
                state = NODESTATE_ESCAPED;
                break;
            default:
                state = NODESTATE_INSEG;
                break;
            }
            break;
        case NODESTATE_STARONLY:
            state = NODESTATE_INSEG;
            if (*nodePattern == L'*') {
                copyChar = FALSE;
            } else {
                minLevel ++;
                if (maxLevel != NODE_LEVEL_MAX) {
                    maxLevel ++;
                }
                advance = FALSE;
            }
            break;
        case NODESTATE_STAR:
            state = NODESTATE_INSEG;
            if (*nodePattern == L'*') {
                copyChar = FALSE;
            } else {
                advance = FALSE;
            }
            break;
        case NODESTATE_INSEG:
            switch (*nodePattern) {
            case L'\\':
                minLevel ++;
                if (maxLevel != NODE_LEVEL_MAX) {
                    maxLevel ++;
                }
                state = NODESTATE_BEGINSEG;
                break;
            case L'*':
                state = NODESTATE_STAR;
                maxLevel = NODE_LEVEL_MAX;
                break;
            case L'?':
                state = NODESTATE_INSEG;
                if (maxLevel != NODE_LEVEL_MAX) {
                    maxLevel ++;
                }
                break;
            case L'^':
                state = NODESTATE_ESCAPED;
                break;
            default:
                state = NODESTATE_INSEG;
                break;
            }
            break;
        case NODESTATE_ESCAPED:
            if (!wcschr (EscapedCharsW, *nodePattern)) {
                DEBUGMSGW ((DBG_STRINGS, "GetNodeMinMaxLevelsA: illegal escaped character: %s", NodePattern));
                return FALSE;
            }
            state = NODESTATE_INSEG;
            break;
        default:
            DEBUGMSGW ((DBG_STRINGS, "GetNodeMinMaxLevelsA: unknown state while processing: %s", NodePattern));
            return FALSE;
        }
        if (advance) {
            if (copyChar && FormattedNode) {
                *FormattedNode = *nodePattern;
                FormattedNode ++;
                nodePattern ++;
            } else {
                nodePattern ++;
            }
        }
    }
    if (MinLevel) {
        *MinLevel = minLevel;
    }
    if (MaxLevel) {
        *MaxLevel = maxLevel;
    }
    if (FormattedNode) {
        *FormattedNode = 0;
    }
    return TRUE;
}

#if 0
//
// PORTBUG Uses memdb max. #if 0'd out for now.
//
PCSTR
ConvertSBtoDB (
    IN      PCSTR RootPath,
    IN      PCSTR FullPath,
    IN      PCSTR Limit
    )
{
    CHAR result[MEMDB_MAX];
    PCSTR p,p1,q;
    PSTR s;
    UINT ch;
    UINT ch1;
    BOOL dhCase = FALSE;

    ZeroMemory (result, MAX_PATH);
    p = FullPath;
    q = RootPath;
    s = result;

    while (*p && (((DWORD)s - (DWORD)result) < MEMDB_MAX)) {
        if (q && *q) {
            _mbssetchar (s, _mbsnextc(p));
            q = _mbsinc (q);
        } else if (Limit && (p >= Limit)) {
            _mbssetchar (s, _mbsnextc(p));
        } else {
            ch = _mbsnextc (p);

            //
            // It is very important not to make the conversion for characters below A1. Otherwise
            // all english letters will be converted to large letters.
            //
            if (ch >= 0xA1 && ch <= 0xDF) {
                // this is a candidate for conversion
                // we need to see if there is a special Dakutenn/Handakuten conversion
                dhCase = FALSE;
                p1 = _mbsinc (p);
                if (p1) {
                    ch1 = _mbsnextc (p1);
                    ch1 = pBuildFromDHList (ch, ch1);
                    if (ch1) {
                        p = _mbsinc (p);
                        _mbssetchar (s, ch1);
                        dhCase = TRUE;
                    }
                }
                if (!dhCase) {
                    _mbssetchar (s, _mbbtombc (ch));
                }
            } else {
                _mbssetchar (s, ch);
            }
        }
        p = _mbsinc (p);
        s = _mbsinc (s);
    }
    result [MAX_PATH - 1] = 0;
    return (DuplicatePathString (result, 0));
}

#endif

ULONGLONG
StringToUint64A (
    IN      PCSTR String,
    OUT     PCSTR *EndOfNumber          OPTIONAL
    )
{
    ULONGLONG n;

    n = 0;
    while (*String >= '0' && *String <= '9') {
        n = n * 10 + *String - '0';
        String++;
    }

    if (EndOfNumber) {
        *EndOfNumber = String;
    }

    return n;
}


ULONGLONG
StringToUint64W (
    IN      PCWSTR String,
    OUT     PCWSTR *EndOfNumber         OPTIONAL
    )
{
    ULONGLONG n;

    n = 0;
    while (*String >= L'0' && *String <= L'9') {
        n = n * 10 + *String - L'0';
        String++;
    }

    if (EndOfNumber) {
        *EndOfNumber = String;
    }

    return n;
}


LONGLONG
StringToInt64A (
    IN      PCSTR String,
    OUT     PCSTR *EndOfNumber          OPTIONAL
    )
{
    LONGLONG n;
    BOOL negate = FALSE;

    if (*String == '-') {
        negate = TRUE;
        String++;
    } else if (*String == '+') {
        String++;
    }

    n = 0;
    while (*String >= '0' && *String <= '9') {
        n = n * 10 + *String - '0';
        String++;
    }

    if (negate) {
        n = -n;
    }

    if (EndOfNumber) {
        *EndOfNumber = String;
    }

    return n;
}


LONGLONG
StringToInt64W (
    IN      PCWSTR String,
    OUT     PCWSTR *EndOfNumber         OPTIONAL
    )
{
    LONGLONG n;
    BOOL negate = FALSE;

    if (*String == L'-') {
        negate = TRUE;
        String++;
    } else if (*String == L'+') {
        String++;
    }

    n = 0;
    while (*String >= L'0' && *String <= L'9') {
        n = n * 10 + *String - L'0';
        String++;
    }

    if (negate) {
        n = -n;
    }

    if (EndOfNumber) {
        *EndOfNumber = String;
    }

    return n;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\main\version.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    version.c

Abstract:

    Implements a set of enumeration routines to access version
    information from a Win32 binary.

Author:

    Jim Schmidt (jimschm) 03-Dec-1997

Revision History:

    calinn      03-Sep-1999 Moved over from Win9xUpg project.

--*/

//
// Includes
//

#include "pch.h"

//
// Debug constants
//

#define DBG_VERSION     "VerAPI"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

PCSTR g_DefaultTranslationsA[] = {
    "04090000",
    "040904E4",
    "040904B0",
    NULL
};

PCWSTR g_DefaultTranslationsW[] = {
    L"04090000",
    L"040904E4",
    L"040904B0",
    NULL
};

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

PCSTR
pVrEnumValueA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum
    );

PCWSTR
pVrEnumValueW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum
    );

PCSTR
pVrEnumNextTranslationA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum
    );

PCWSTR
pVrEnumNextTranslationW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum
    );

//
// Macro expansion definition
//

// None

//
// Code
//


/*++

Routine Description:

  VrCreateEnumStructA and VrCreateEnumStructW are called to load a version
  structure from a file and to obtain the fixed version stamp info that is
  language-independent.

  The caller must call VrDestroyEnumStruct after the VrValueEnum is no
  longer needed.

Arguments:

  VrValueEnum - Receives the version stamp info to be used by other
                functions in this module

  FileSpec    - Specifies the file to obtain version information from

Return Value:

  TRUE if the routine was able to get version info, or FALSE if an
  error occurred.

--*/

BOOL
VrCreateEnumStructA (
    OUT     PVRVALUE_ENUMA VrValueEnum,
    IN      PCSTR FileSpec
    )
{
    //
    // Initialize the structure
    //

    ZeroMemory (VrValueEnum, sizeof (VRVALUE_ENUMA));
    VrValueEnum->FileSpec = FileSpec;

    //
    // Allocate enough memory for the version stamp
    //

    VrValueEnum->Size = GetFileVersionInfoSizeA (
                                (PSTR) FileSpec,
                                &VrValueEnum->Handle
                                );

    if (!VrValueEnum->Size) {
        DEBUGMSG ((DBG_VERSION, "File %s does not have version information", FileSpec));
        return FALSE;
    }

    //
    // fix for version info bug:
    // allocate both buffers at once; this way the first buffer will not point to invalid
    // memory when a reallocation occurs because of the second grow
    //
    VrValueEnum->VersionBuffer = GbGrow (&VrValueEnum->GrowBuf, VrValueEnum->Size * 2);

    if (!VrValueEnum->VersionBuffer) {
        return FALSE;
    }

    VrValueEnum->StringBuffer = VrValueEnum->GrowBuf.Buf + VrValueEnum->Size;

    //
    // Now get the version info from the file
    //

    if (!GetFileVersionInfoA (
             (PSTR) FileSpec,
             VrValueEnum->Handle,
             VrValueEnum->Size,
             VrValueEnum->VersionBuffer
             )) {
        VrDestroyEnumStructA (VrValueEnum);
        return FALSE;
    }

    //
    // Extract the fixed info
    //

    VerQueryValueA (
        VrValueEnum->VersionBuffer,
        "\\",
        &VrValueEnum->FixedInfo,
        &VrValueEnum->FixedInfoSize
        );

    return TRUE;
}

BOOL
VrCreateEnumStructW (
    OUT     PVRVALUE_ENUMW VrValueEnum,
    IN      PCWSTR FileSpec
    )
{
    ZeroMemory (VrValueEnum, sizeof (VRVALUE_ENUMW));
    VrValueEnum->FileSpec = FileSpec;

    //
    // Allocate enough memory for the version stamp
    //

    VrValueEnum->Size = GetFileVersionInfoSizeW (
                                (PWSTR) FileSpec,
                                &VrValueEnum->Handle
                                );

    if (!VrValueEnum->Size) {
        DEBUGMSG ((DBG_VERSION, "File %S does not have version info", FileSpec));
        return FALSE;
    }

    //
    // fix for version info bug:
    // allocate both buffers at once; this way the first buffer will not point to invalid
    // memory when a reallocation occurs because of the second grow
    //
    VrValueEnum->VersionBuffer = GbGrow (&VrValueEnum->GrowBuf, VrValueEnum->Size * 2);

    if (!VrValueEnum->VersionBuffer) {
        return FALSE;
    }

    VrValueEnum->StringBuffer = VrValueEnum->GrowBuf.Buf + VrValueEnum->Size;

    //
    // Now get the version info from the file
    //

    if (!GetFileVersionInfoW (
             (PWSTR) FileSpec,
             VrValueEnum->Handle,
             VrValueEnum->Size,
             VrValueEnum->VersionBuffer
             )) {
        VrDestroyEnumStructW (VrValueEnum);
        return FALSE;
    }

    //
    // Extract the fixed info
    //

    VerQueryValueW (
        VrValueEnum->VersionBuffer,
        L"\\",
        &VrValueEnum->FixedInfo,
        &VrValueEnum->FixedInfoSize
        );

    return TRUE;
}


/*++

Routine Description:

  VrDestroyEnumStructA and VrDestroyEnumStructW cleans up all memory
  allocated by the routines in this module.

Arguments:

  VrValueEnum - Specifies the structure to clean up

Return Value:

  none

--*/

VOID
VrDestroyEnumStructA (
    IN      PVRVALUE_ENUMA VrValueEnum
    )
{
    //
    // Clean up all allocations made by any routine using
    // the VrValueEnum
    //

    if (VrValueEnum->GrowBuf.Buf) {
        GbFree (&VrValueEnum->GrowBuf);
    }

    ZeroMemory (VrValueEnum, sizeof (VRVALUE_ENUMA));
}

VOID
VrDestroyEnumStructW (
    IN      PVRVALUE_ENUMW VrValueEnum
    )
{
    //
    // Clean up all allocations made by any routine using
    // the VrValueEnum
    //

    if (VrValueEnum->GrowBuf.Buf) {
        GbFree (&VrValueEnum->GrowBuf);
    }

    ZeroMemory (VrValueEnum, sizeof (VRVALUE_ENUMW));
}


/*++

Routine Description:

  pVrEnumFirstTranslationA and pVrEnumFirstTranslationW return the translation
  string needed to access the string table of a version stamp.

Arguments:

  VrValueEnum - Specifies the structure that has been initialized
                by VrCreateEnumStruct.

Return Value:

  A pointer to a string specifying the first translation, or
  NULL if no translations exist.

--*/

PCSTR
pVrEnumFirstTranslationA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum
    )
{
    UINT arraySize;

    //
    // Query version block for array of code pages/languages
    //

    if (!VerQueryValueA (
            VrValueEnum->VersionBuffer,
            "\\VarFileInfo\\Translation",
            &VrValueEnum->Translations,
            &arraySize
            )) {
        //
        // No translations are available
        //

        arraySize = 0;
    }

    //
    // Return a pointer to the first translation
    //

    VrValueEnum->CurrentDefaultTranslation = 0;
    VrValueEnum->MaxTranslations = arraySize / sizeof (TRANSLATION);
    VrValueEnum->CurrentTranslation = 0;

    DEBUGMSG_IF ((
        VrValueEnum->MaxTranslations == 0,
        DBG_VERSION,
        "File %s has no translations",
        VrValueEnum->FileSpec
        ));

    return pVrEnumNextTranslationA (VrValueEnum);
}

PCWSTR
pVrEnumFirstTranslationW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum
    )
{
    UINT arraySize;

    //
    // Query version block for array of code pages/languages
    //

    if (!VerQueryValueW (
            VrValueEnum->VersionBuffer,
            L"\\VarFileInfo\\Translation",
            &VrValueEnum->Translations,
            &arraySize
            )) {
        //
        // No translations are available
        //

        arraySize = 0;
    }

    //
    // Return a pointer to the first translation
    //

    VrValueEnum->CurrentDefaultTranslation = 0;
    VrValueEnum->MaxTranslations = arraySize / sizeof (TRANSLATION);
    VrValueEnum->CurrentTranslation = 0;

    DEBUGMSG_IF ((
        VrValueEnum->MaxTranslations == 0,
        DBG_VERSION,
        "File %S has no translations",
        VrValueEnum->FileSpec
        ));

    return pVrEnumNextTranslationW (VrValueEnum);
}


/*++

Routine Description:

  pIsDefaultTranslationA and pIsDefaultTranslationW return TRUE
  if the specified translation string is enumerated by default.
  These routines stops multiple enumeration of the same
  translation string.

Arguments:

  TranslationStr - Specifies the translation string to test

Return Value:

  TRUE if the translation string is the same as a default translation
  string, or FALSE if it is not.

--*/

BOOL
pIsDefaultTranslationA (
    IN      PCSTR TranslationStr
    )
{
    INT i;

    for (i = 0 ; g_DefaultTranslationsA[i] ; i++) {
        if (StringIMatchA (TranslationStr, g_DefaultTranslationsA[i])) {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
pIsDefaultTranslationW (
    IN      PCWSTR TranslationStr
    )
{
    INT i;

    for (i = 0 ; g_DefaultTranslationsW[i] ; i++) {
        if (StringIMatchW (TranslationStr, g_DefaultTranslationsW[i])) {
            return TRUE;
        }
    }
    return FALSE;
}


/*++

Routine Description:

  pVrEnumNextTranslationA and pVrEnumNextTranslationW continue
  the enumeration of translation strings, needed to access the
  string table in a version stamp.

Arguments:

  VrValueEnum - Specifies the same structure passed to
                pVrEnumFirstTranslation.

Return Value:

  A pointer to a string specifying the next translation, or
  NULL if no additional translations exist.

--*/

PCSTR
pVrEnumNextTranslationA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum
    )
{
    PTRANSLATION translation;

    if (g_DefaultTranslationsA[VrValueEnum->CurrentDefaultTranslation]) {
        //
        // Return default translations first
        //

        StringCopyA (
            VrValueEnum->TranslationStr,
            g_DefaultTranslationsA[VrValueEnum->CurrentDefaultTranslation]
            );

        VrValueEnum->CurrentDefaultTranslation++;

    } else {

        do {
            //
            // Return NULL if all translations have been enumerated
            //

            if (VrValueEnum->CurrentTranslation == VrValueEnum->MaxTranslations) {
                return NULL;
            }

            //
            // Otherwise build translation string and return pointer to it
            //

            translation = &VrValueEnum->Translations[VrValueEnum->CurrentTranslation];

            wsprintfA (
                VrValueEnum->TranslationStr,
                "%04x%04x",
                translation->CodePage,
                translation->Language
                );

            VrValueEnum->CurrentTranslation++;

        } while (pIsDefaultTranslationA (VrValueEnum->TranslationStr));
    }

    return VrValueEnum->TranslationStr;
}

PCWSTR
pVrEnumNextTranslationW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum
    )
{
    PTRANSLATION translation;

    if (g_DefaultTranslationsW[VrValueEnum->CurrentDefaultTranslation]) {

        StringCopyW (
            VrValueEnum->TranslationStr,
            g_DefaultTranslationsW[VrValueEnum->CurrentDefaultTranslation]
            );

        VrValueEnum->CurrentDefaultTranslation++;

    } else {

        do {
            //
            // Return NULL if all translations have been enumerated
            //

            if (VrValueEnum->CurrentTranslation == VrValueEnum->MaxTranslations) {
                return NULL;
            }

            //
            // Otherwise build translation string and return pointer to it
            //

            translation = &VrValueEnum->Translations[VrValueEnum->CurrentTranslation];

            wsprintfW (
                VrValueEnum->TranslationStr,
                L"%04x%04x",
                translation->CodePage,
                translation->Language
                );

            VrValueEnum->CurrentTranslation++;

        } while (pIsDefaultTranslationW (VrValueEnum->TranslationStr));
    }

    return VrValueEnum->TranslationStr;
}


/*++

Routine Description:

  VrEnumFirstValueA and VrEnumFirstValueW return the first value
  stored in a version stamp for a specific field. If the field
  does not exist, the functions returns NULL.

  An enumeration of VrEnumFirstValue/VrEnumNextValue
  is used to list all localized strings for a field.

Arguments:

  VrValueEnum  - Specifies the structure that was initialized by
                 VrCreateEnumStruct.

  VersionField - Specifies the name of the version field to enumerate

Return Value:

  A pointer to the first value of the field, or NULL if the field does
  not exist.

--*/

PCSTR
VrEnumFirstValueA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum,
    IN      PCSTR VersionField
    )
{
    PCSTR result = NULL;

    if (!pVrEnumFirstTranslationA (VrValueEnum)) {
        return NULL;
    }

    VrValueEnum->VersionField = VersionField;

    result = pVrEnumValueA (VrValueEnum);

    if (!result) {
        result = VrEnumNextValueA (VrValueEnum);
    }

    return result;
}

PCWSTR
VrEnumFirstValueW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum,
    IN      PCWSTR VersionField
    )
{
    PCWSTR result = NULL;

    if (!pVrEnumFirstTranslationW (VrValueEnum)) {
        return NULL;
    }

    VrValueEnum->VersionField = VersionField;

    result = pVrEnumValueW (VrValueEnum);

    if (!result) {
        result = VrEnumNextValueW (VrValueEnum);
    }

    return result;
}


/*++

Routine Description:

  VrEnumNextValueA and VrEnumNextValueW return the next value
  stored in a version stamp for a specific field.

Arguments:

  VrValueEnum - Specifies the same structure passed to VrEnumFirstValue

Return Value:

  A pointer to the next value of the field, or NULL if another field
  does not exist.

--*/

PCSTR
VrEnumNextValueA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum
    )
{
    PCSTR result = NULL;

    do {
        if (!pVrEnumNextTranslationA (VrValueEnum)) {
            break;
        }

        result = pVrEnumValueA (VrValueEnum);

    } while (!result);

    return result;
}

PCWSTR
VrEnumNextValueW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum
    )
{
    PCWSTR result = NULL;

    do {
        if (!pVrEnumNextTranslationW (VrValueEnum)) {
            break;
        }

        result = pVrEnumValueW (VrValueEnum);

    } while (!result);

    return result;
}


/*++

Routine Description:

  pVrEnumValueA and pVrEnumValueW are routines that obtain
  the value of a version field. They are used for both
  VrEnumFirstValue and VrEnumNextValue.

Arguments:

  VrValueEnum - Specifies the structure being processed

Return Value:

  A pointer to the version value for the current translation, or
  NULL if the value does not exist for the current translation.

--*/

PCSTR
pVrEnumValueA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum
    )
{
    PSTR text;
    UINT stringLen;
    PBYTE string;
    PCSTR result = NULL;

    //
    // Prepare sub block for VerQueryValue API
    //

    text = RealAllocTextExA (NULL, 0);

    text = AllocTextA (
               SizeOfStringA (VrValueEnum->TranslationStr) +
               SizeOfStringA (VrValueEnum->VersionField) +
               16
               );

    if (!text) {
        return NULL;
    }

    wsprintfA (
        text,
        "\\StringFileInfo\\%s\\%s",
        VrValueEnum->TranslationStr,
        VrValueEnum->VersionField
        );

    __try {
        //
        // Get the value from the version stamp
        //

        if (!VerQueryValueA (
                VrValueEnum->VersionBuffer,
                text,
                &string,
                &stringLen
                )) {
            //
            // No value is available
            //

            __leave;
        }

        //
        // Copy value into buffer
        //

        StringCopyByteCountA (VrValueEnum->StringBuffer, (PCSTR) string, stringLen);

        result = (PCSTR)VrValueEnum->StringBuffer;

    }
    __finally {
        FreeTextA (text);
    }

    return result;
}

PCWSTR
pVrEnumValueW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum
    )
{
    PWSTR text;
    UINT stringLen;
    PBYTE string;
    PCWSTR result = NULL;

    //
    // Prepare sub block for VerQueryValue API
    //

    text = AllocTextW (
               18 +
               CharCountW (VrValueEnum->TranslationStr) +
               CharCountW (VrValueEnum->VersionField)
               );

    if (!text) {
        return NULL;
    }

    wsprintfW (
        text,
        L"\\StringFileInfo\\%s\\%s",
        VrValueEnum->TranslationStr,
        VrValueEnum->VersionField
        );

    __try {
        //
        // Get the value from the version stamp
        //

        if (!VerQueryValueW (
                VrValueEnum->VersionBuffer,
                text,
                &string,
                &stringLen
                )) {
            //
            // No value is available
            //

            __leave;
        }

        //
        // Copy value into buffer
        //

        CopyMemory (VrValueEnum->StringBuffer, string, stringLen * sizeof (WCHAR));
        VrValueEnum->StringBuffer [stringLen * sizeof (WCHAR)] = 0;
        result = (PWSTR) VrValueEnum->StringBuffer;

    }
    __finally {
        FreeTextW (text);
    }

    return result;
}


ULONGLONG
VrGetBinaryFileVersionA (
    IN      PVRVALUE_ENUMA VrValueEnum
    )

/*++

Routine Description:

  VrGetBinaryFileVersion returns the FileVersion field from
  the fixed info structure of version information.

Arguments:

  VrValueEnum - Specifies the structure being processed

Return Value:

  A ULONGLONG FileVersion field

--*/

{
    ULONGLONG result = 0;

    if (VrValueEnum->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        *((PDWORD) (&result)) = VrValueEnum->FixedInfo->dwFileVersionLS;
        *(((PDWORD) (&result)) + 1) = VrValueEnum->FixedInfo->dwFileVersionMS;
    }
    return result;
}


ULONGLONG
VrGetBinaryProductVersionA (
    IN      PVRVALUE_ENUMA VrValueEnum
    )

/*++

Routine Description:

  VrGetBinaryProductVersion returns the ProductVersion field from
  the fixed info structure of version information.

Arguments:

  VrValueEnum - Specifies the structure being processed

Return Value:

  A ULONGLONG ProductVersion field

--*/

{
    ULONGLONG result = 0;

    if (VrValueEnum->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        *((PDWORD) (&result)) = VrValueEnum->FixedInfo->dwProductVersionLS;
        *(((PDWORD) (&result)) + 1) = VrValueEnum->FixedInfo->dwProductVersionMS;
    }
    return result;
}


DWORD
VrGetBinaryFileDateLoA (
    IN      PVRVALUE_ENUMA VrValueEnum
    )

/*++

Routine Description:

  VrGetBinaryFileDateLo returns the LS dword from FileDate field from
  the fixed info structure of version information.

Arguments:

  VrValueEnum - Specifies the structure being processed

Return Value:

  A DWORD, LS dword of the FileDate field

--*/

{
    if (VrValueEnum->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        return VrValueEnum->FixedInfo->dwFileDateLS;
    }
    return 0;
}


DWORD
VrGetBinaryFileDateHiA (
    IN      PVRVALUE_ENUMA VrValueEnum
    )

/*++

Routine Description:

  VrGetBinaryFileDateHi returns the MS dword from FileDate field from
  the fixed info structure of version information.

Arguments:

  VrValueEnum - Specifies the structure being processed

Return Value:

  A DWORD, MS dword of the FileDate field

--*/

{
    if (VrValueEnum->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        return VrValueEnum->FixedInfo->dwFileDateMS;
    }
    return 0;
}


DWORD
VrGetBinaryOsVersionA (
    IN      PVRVALUE_ENUMA VrValueEnum
    )

/*++

Routine Description:

  VrGetBinaryOsVersion returns the FileOS field from
  the fixed info structure of version information.

Arguments:

  VrValueEnum - Specifies the structure being processed

Return Value:

  A DWORD FileOS field

--*/

{
    if (VrValueEnum->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        return VrValueEnum->FixedInfo->dwFileOS;
    }
    return 0;
}


DWORD
VrGetBinaryFileType (
    IN      PVRVALUE_ENUMA VrValueEnum
    )

/*++

Routine Description:

  VrGetBinaryFileType returns the FileType field from
  the fixed info structure of version information.

Arguments:

  VrValueEnum - Specifies the structure being processed

Return Value:

  A DWORD FileType field

--*/

{
    if (VrValueEnum->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        return VrValueEnum->FixedInfo->dwFileType;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\pch\pch.h ===
#include "baseinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inc\cmnres.h ===
#define IDC_PROGRESS_BAR_LABEL          1200
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwdb\utils\main\wnd.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    wnd.c

Abstract:

    Utilities for window management

Author:

    Jim Schmidt (jimschm)   01-Feb-2000

Revision History:


--*/

//
// Includes
//

#include "pch.h"


#define DBG_WND         "Wnd"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef struct {
    PCSTR WindowTitle;
    DWORD ProcessId;
    HWND Match;
} FINDWINDOW_STRUCTA, *PFINDWINDOW_STRUCTA;

typedef struct {
    PCWSTR WindowTitle;
    DWORD ProcessId;
    HWND Match;
} FINDWINDOW_STRUCTW, *PFINDWINDOW_STRUCTW;

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
CALLBACK
pEnumWndProcA (
    HWND hwnd,
    LPARAM lParam
    )

/*++

Routine Description:

  A callback that is called for every top level window on the system.
  It is used with pFindParentWindow to locate a specific window.

Arguments:

  hwnd      - Specifies the handle of the current enumerated window
  lParam    - Specifies a pointer to a FINDWINDOW_STRUCTA variable that
              holds WindowTitle and ProcessId, and receives the
              handle if a match is found.

Return Value:

  The handle to the matching window, or NULL if no window has the
  specified title and process ID.

--*/

{
    CHAR title[MAX_MBCHAR_PATH];
    DWORD processId;
    PFINDWINDOW_STRUCTA p;
    BOOL match = FALSE;

    p = (PFINDWINDOW_STRUCTA) lParam;

    if (!GetWindowThreadProcessId (hwnd, &processId)) {
        DEBUGMSG ((DBG_WND, "Enumerated hwnd no longer valid"));
        return TRUE;
    }

    if (processId == p->ProcessId) {
        match = TRUE;
    }

    if (p->WindowTitle) {

        GetWindowTextA (hwnd, title, ARRAYSIZE(title));

        DEBUGMSGA ((
            DBG_NAUSEA,
            "Testing window: %s, ID=%08Xh against %s, %08Xh",
            title,
            processId,
            p->WindowTitle,
            p->ProcessId
            ));

        match = match && StringMatchA (title, p->WindowTitle);
    }
    ELSE_DEBUGMSGA ((
        DBG_NAUSEA,
        "Testing window: Process ID=%08Xh against %08Xh",
        processId,
        p->ProcessId
        ));


    if (match) {
        p->Match = hwnd;

#ifdef DEBUG
        //
        // Get the window title for the following debug message
        //

        GetWindowTextA (hwnd, title, ARRAYSIZE(title));

        DEBUGMSGA ((
            DBG_NAUSEA,
            "Window found: %s, ID=%u",
            title,
            processId
            ));
#endif

        return FALSE;           // stop enum

    }

    return TRUE;        // continue enum
}


BOOL
CALLBACK
pEnumWndProcW (
    HWND hwnd,
    LPARAM lParam
    )

{
    WCHAR title[MAX_MBCHAR_PATH];
    DWORD processId;
    PFINDWINDOW_STRUCTW p;
    BOOL match = FALSE;

    p = (PFINDWINDOW_STRUCTW) lParam;

    if (!GetWindowThreadProcessId (hwnd, &processId)) {
        DEBUGMSG ((DBG_WND, "Enumerated hwnd no longer valid"));
        return TRUE;
    }

    if (processId == p->ProcessId) {
        match = TRUE;
    }

    if (p->WindowTitle) {

        GetWindowTextW (hwnd, title, ARRAYSIZE(title));

        DEBUGMSGW ((
            DBG_NAUSEA,
            "Testing window: %s, ID=%08Xh against %s, %08Xh",
            title,
            processId,
            p->WindowTitle,
            p->ProcessId
            ));

        match = match && StringMatchW (title, p->WindowTitle);
    }
    ELSE_DEBUGMSGW ((
        DBG_NAUSEA,
        "Testing window: Process ID=%08Xh against %08Xh",
        processId,
        p->ProcessId
        ));


    if (match) {
        p->Match = hwnd;

#ifdef DEBUG
        //
        // Get the window title for the following debug message
        //

        GetWindowTextW (hwnd, title, ARRAYSIZE(title));

        DEBUGMSGA ((
            DBG_NAUSEA,
            "Window found: %s, ID=%u",
            title,
            processId
            ));
#endif

        return FALSE;           // stop enum

    }

    return TRUE;        // continue enum
}


HWND
FindWindowInProcessA (
    IN      DWORD ProcessId,
    IN      PCSTR WindowTitle          OPTIONAL
    )

/*++

Routine Description:

  Finds a window by enumerating all top-level windows, and checking the
  process id. The first one to match the optionally supplied title is used.

Arguments:

  ProcessId     - Specifies the ID of the process who owns the window.  If
                  zero is specified, NULL is returned.
  WindowTitle   - Specifies the name of the window to find.

Return Value:

  The handle to the matching window, or NULL if no window has the
  specified title and process ID.

--*/

{
    FINDWINDOW_STRUCTA findWndStruct;

    //
    // If no process ID, we cannot have a match
    //

    if (!ProcessId) {
        DEBUGMSG ((DBG_WND, "ProcessId == 0"));
        return NULL;
    }

    ZeroMemory (&findWndStruct, sizeof (findWndStruct));

    findWndStruct.WindowTitle = WindowTitle;
    findWndStruct.ProcessId   = ProcessId;

    EnumWindows (pEnumWndProcA, (LPARAM) &findWndStruct);

    return findWndStruct.Match;
}


HWND
FindWindowInProcessW (
    IN      DWORD ProcessId,
    IN      PCWSTR WindowTitle         OPTIONAL
    )
{
    FINDWINDOW_STRUCTW findWndStruct;

    //
    // If no process ID, we cannot have a match
    //

    if (!ProcessId) {
        DEBUGMSG ((DBG_WND, "ProcessId == 0"));
        return NULL;
    }

    ZeroMemory (&findWndStruct, sizeof (findWndStruct));

    findWndStruct.WindowTitle = WindowTitle;
    findWndStruct.ProcessId   = ProcessId;

    EnumWindows (pEnumWndProcW, (LPARAM) &findWndStruct);

    return findWndStruct.Match;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inc\digpid.h ===
/*++

Copyright (c) 1998-1999, Microsoft Corporation

Module Name:


    digpid.h

Abstract:

--*/

// DigPid.h

#ifdef __cplusplus
extern "C" {
#endif

#define INVALID_PID 0xFFFFFFFF

typedef enum {
    ltFPP,
    ltCCP,
    ltOEM,
    ltSelect,
    ltMLP,
    ltMOLP,
    ltMSDN
} LICENSETYPE;
typedef DWORD DWLICENSETYPE;


// Note: be careful not to alter this definition (or at least it's definition).
// When more fields are needed, create a DIGITALPID2 or similar.  Too much external
// code depends on this header to change it.

typedef struct {
    DWORD dwLength;
    WORD  wVersionMajor;
    WORD  wVersionMinor;
    char  szPid2[24];
    DWORD dwKeyIdx;
    char  szSku[16];
    BYTE  abCdKey[16];
    DWORD dwCloneStatus;
    DWORD dwTime;
    DWORD dwRandom;
    DWLICENSETYPE dwlt;
    DWORD adwLicenseData[2];
    char  szOemId[8];
    DWORD dwBundleId;

    char  aszHardwareIdStatic[8];

    DWORD dwHardwareIdTypeStatic;
    DWORD dwBiosChecksumStatic;
    DWORD dwVolSerStatic;
    DWORD dwTotalRamStatic;
    DWORD dwVideoBiosChecksumStatic;

    char  aszHardwareIdDynamic[8];

    DWORD dwHardwareIdTypeDynamic;
    DWORD dwBiosChecksumDynamic;
    DWORD dwVolSerDynamic;
    DWORD dwTotalRamDynamic;
    DWORD dwVideoBiosChecksumDynamic;

    DWORD dwCrc32;
} DIGITALPID, *PDIGITALPID, FAR *LPDIGITALPID;

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inc\compliance.h ===
#ifndef _COMPLIANCE_H
#define _COMPLIANCE_H

#ifdef __cplusplus
extern "C" {
#endif

#define EVAL_MPC           TEXT("82503")
#define SRV_NFR_MPC        TEXT("51883")
#define ASRV_NFR_MPC       TEXT("51882")
#define NT4SRV_NFR_MPC     TEXT("51222")

#ifdef KERNEL_MODE
    #define OEM_INSTALL_RPC    L"OEM"
    #define SELECT_INSTALL_RPC L"270"
    #define MSDN_INSTALL_RPC   L"335"
#endif

#define COMPLIANCE_INSTALLTYPE_UNKNOWN      0x00000000
#define COMPLIANCE_INSTALLTYPE_WIN31        0x00000001
#define COMPLIANCE_INSTALLTYPE_WIN9X        0x00000002
#define COMPLIANCE_INSTALLTYPE_NTW          0x00000004
#define COMPLIANCE_INSTALLTYPE_NTS          0x00000008
#define COMPLIANCE_INSTALLTYPE_NTSE         0x00000010
#define COMPLIANCE_INSTALLTYPE_NTSDTC       0x00000020
//
// this is for the downlevel terminal server edition product, which needs
// to be treated as an install type, not just a product suite. this includes
// nt4 terminal server edition as well as citrix winframe
//
#define COMPLIANCE_INSTALLTYPE_NTSTSE       0x00000040
#define COMPLIANCE_INSTALLTYPE_NTWP         0x00000080
#define COMPLIANCE_INSTALLTYPE_NTSB         0x00000100
#define COMPLIANCE_INSTALLTYPE_NTSBS        0x00000200
#define COMPLIANCE_INSTALLTYPE_ANY          ( COMPLIANCE_INSTALLTYPE_WIN31 | \
                                              COMPLIANCE_INSTALLTYPE_WIN9X | \
                                              COMPLIANCE_INSTALLTYPE_NTW   | \
                                              COMPLIANCE_INSTALLTYPE_NTWP  | \
                                              COMPLIANCE_INSTALLTYPE_NTS   | \
                                              COMPLIANCE_INSTALLTYPE_NTSB  | \
                                              COMPLIANCE_INSTALLTYPE_NTSBS | \
                                              COMPLIANCE_INSTALLTYPE_NTSE  | \
                                              COMPLIANCE_INSTALLTYPE_NTSDTC | \
                                              COMPLIANCE_INSTALLTYPE_NTSTSE )

#define COMPLIANCE_INSTALLTYPE_NTANY        ( COMPLIANCE_INSTALLTYPE_NTW   | \
                                              COMPLIANCE_INSTALLTYPE_NTWP  | \
                                              COMPLIANCE_INSTALLTYPE_NTS   | \
                                              COMPLIANCE_INSTALLTYPE_NTSB  | \
                                              COMPLIANCE_INSTALLTYPE_NTSBS | \
                                              COMPLIANCE_INSTALLTYPE_NTSE  | \
                                              COMPLIANCE_INSTALLTYPE_NTSDTC | \
                                              COMPLIANCE_INSTALLTYPE_NTSTSE )


#define COMPLIANCE_INSTALLVAR_UNKNOWN       0x00000000
#define COMPLIANCE_INSTALLVAR_SELECT        0x00000001
#define COMPLIANCE_INSTALLVAR_MSDN          0x00000002
#define COMPLIANCE_INSTALLVAR_OEM           0x00000004
#define COMPLIANCE_INSTALLVAR_CDRETAIL      0x00000008
#define COMPLIANCE_INSTALLVAR_FLOPPYRETAIL  0x00000010 // win95 only!
#define COMPLIANCE_INSTALLVAR_EVAL          0x00000020
#define COMPLIANCE_INSTALLVAR_NFR           0x00000040
#define COMPLIANCE_INSTALLVAR_ANY           ( COMPLIANCE_INSTALLVAR_SELECT   | \
                                              COMPLIANCE_INSTALLVAR_MSDN     | \
                                              COMPLIANCE_INSTALLVAR_OEM      | \
                                              COMPLIANCE_INSTALLVAR_CDRETAIL | \
                                              COMPLIANCE_INSTALLVAR_EVAL     | \
                                              COMPLIANCE_INSTALLVAR_NFR      | \
                                              COMPLIANCE_INSTALLVAR_FLOPPYRETAIL )


#define COMPLIANCE_INSTALLSUITE_UNKNOWN     0x00000000
#define COMPLIANCE_INSTALLSUITE_NONE        0x00000001
#define COMPLIANCE_INSTALLSUITE_SBS         0x00000002
#define COMPLIANCE_INSTALLSUITE_SBSR        0x00000004
#define COMPLIANCE_INSTALLSUITE_ENT         0x00000008
#define COMPLIANCE_INSTALLSUITE_COMM        0x00000010
#define COMPLIANCE_INSTALLSUITE_HYDRA       0x00000020
#define COMPLIANCE_INSTALLSUITE_TERMINAL    COMPLIANCE_INSTALLSUITE_HYDRA
#define COMPLIANCE_INSTALLSUITE_BACK        0x00000040
#define COMPLIANCE_INSTALLSUITE_EMBED       0x00000080
#define COMPLIANCE_INSTALLSUITE_DTC         0x00000100
#define COMPLIANCE_INSTALLSUITE_PER         0x00000200
#define COMPLIANCE_INSTALLSUITE_BLADE       0x00000400
#define COMPLIANCE_INSTALLSUITE_ANY         ( COMPLIANCE_INSTALLSUITE_SBS   | \
                                              COMPLIANCE_INSTALLSUITE_SBSR  | \
                                              COMPLIANCE_INSTALLSUITE_ENT   | \
                                              COMPLIANCE_INSTALLSUITE_COMM  | \
                                              COMPLIANCE_INSTALLSUITE_HYDRA | \
                                              COMPLIANCE_INSTALLSUITE_BACK  | \
                                              COMPLIANCE_INSTALLSUITE_EMBED | \
                                              COMPLIANCE_INSTALLSUITE_DTC   | \
                                              COMPLIANCE_INSTALLSUITE_BLADE | \
                                              COMPLIANCE_INSTALLSUITE_PER )



#define COMPLIANCEERR_NONE                  0x00000000
#define COMPLIANCEERR_VERSION               0x00000001
#define COMPLIANCEERR_SUITE                 0x00000002
#define COMPLIANCEERR_TYPE                  0x00000003
#define COMPLIANCEERR_VARIATION             0x00000004
#define COMPLIANCEERR_UNKNOWNTARGET         0x00000005
#define COMPLIANCEERR_UNKNOWNSOURCE         0x00000006
#define COMPLIANCEERR_SERVICEPACK5          0x00000007
#define COMPLIANCEERR_UNKNOWN               COMPLIANCEERR_UNKNOWNSOURCE

#define COMPLIANCE_SKU_NONE                 0x00000000
#define COMPLIANCE_SKU_NTWFULL              0x00000001
#define COMPLIANCE_SKU_NTW32U               0x00000002
//#define COMPLIANCE_SKU_NTWU                 0x00000003
#define COMPLIANCE_SKU_NTSEFULL             0x00000004
#define COMPLIANCE_SKU_NTSFULL              0x00000005
#define COMPLIANCE_SKU_NTSEU                0x00000006
//#define COMPLIANCE_SKU_NTSSEU               0x00000007
#define COMPLIANCE_SKU_NTSU                 0x00000008
#define COMPLIANCE_SKU_NTSDTC               0x00000009
//#define COMPLIANCE_SKU_NTSDTCU              0x0000000a
#define COMPLIANCE_SKU_NTWPFULL             0x0000000b
#define COMPLIANCE_SKU_NTWPU                0x0000000c
#define COMPLIANCE_SKU_NTSB                 0x0000000d
#define COMPLIANCE_SKU_NTSBU                0x0000000e
#define COMPLIANCE_SKU_NTSBS                0x00000010
#define COMPLIANCE_SKU_NTSBSU               0x00000011
	
#define COMPLIANCE_SKU_STEPUP               0x00010000
#define COMPLIANCE_SKU_STEPUP_WIN9X         0x00020000


typedef struct _COMPLIANCE_DATA {
    DWORD InstallType;                      // mask describing install type
    DWORD InstallVariation;                 // mask describing install variation
    DWORD InstallSuite;                     // mask describing install suite
    BOOL  RequiresValidation;               // do we need to do validation for this SKU?
    DWORD MinimumVersion;                   // expressed as (majorversion.minorversion * 100), i.e., 3.51 == 351, 5.0 == 500, etc...
    DWORD MaximumKnownVersionNt;            // expressed as (majorversion.minorversion * 100), i.e., 3.51 == 351, 5.0 == 500, etc...
    DWORD BuildNumberNt;                    //
    DWORD BuildNumberWin9x;                 //
    DWORD InstallServicePack;                      // Service Pack number
} COMPLIANCE_DATA, *PCOMPLIANCE_DATA;

typedef struct _COMPLIANCE_SRC {
    DWORD InstallType;                      // mask describing install type
    DWORD InstallVariation;                 // mask describing install variation
    DWORD InstallSuite;                     // mask describing install suite
    DWORD Version;                          // expressed as (majorversion.minorversion * 100), i.e., 3.51 == 351, 5.0 == 500, etc...
} COMPLIANCE_SRC, *PCOMPLIANCE_SRC;

//
// The install media object abstraction
//

//
// media object this pointer
//
typedef struct _st_CCMEDIA *PCCMEDIA;

//
// Compliance checking method of media object
//
typedef BOOLEAN (* PCC_CHECK_FUNCTION)(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               NoUpgradeAllowed );

//
// install media object
//
typedef struct _st_CCMEDIA {
    DWORD               SourceType;
    DWORD               SourceVariation;
    DWORD               Version;            // major * 100 + minor
    DWORD               BuildNumber;
    BOOLEAN             StepUpMedia;
    PCC_CHECK_FUNCTION  CheckInstall;       // compliance check method
} CCMEDIA;


//
// common prototypes
//
PCCMEDIA
CCMediaCreate(
    IN          DWORD   SourceSKU,
    IN          DWORD   SourceVariation,
    IN OPTIONAL DWORD   Version,
    IN OPTIONAL DWORD   BuildNumber );

BOOLEAN
CCMediaInitialize(
    OUT PCCMEDIA        DestMedia,
    IN          DWORD   Type,
    IN          DWORD   Variation,
    IN          BOOLEAN StepupMedia,
    IN OPTIONAL DWORD   Version,
    IN OPTIONAL DWORD   BuildNumber);

BOOLEAN
CheckCompliance(
    IN DWORD SourceSku,
    IN DWORD SourceVariation,
    IN DWORD SourceVersion,
    IN DWORD SourceBuildNum,
    IN PCOMPLIANCE_DATA Destination,
    OUT PUINT Reason,
    OUT PBOOL NoUpgradeAllowed
    );

DWORD
DetermineSourceProduct(
    OUT DWORD *SourceSkuVariation,
    IN  PCOMPLIANCE_DATA pcd
    );

BOOL
GetSourceComplianceData(
    OUT PCOMPLIANCE_DATA pcd,
    IN  PCOMPLIANCE_DATA Target
    );

DWORD
CRC_32(
    LPBYTE pb,
    DWORD cb
    );

BOOL
IsValidStepUpMode(
    CHAR  *StepUpArray,
    ULONG *StepUpMode
    );


//
// kernel mode prototypes
//

#ifdef KERNEL_MODE

BOOLEAN
pSpIsCompliant(
    IN DWORD SourceVersion,
    IN DWORD SourceBuildNum,
    IN PDISK_REGION OsPartRegion,
    IN PWSTR SystemRoot,
    OUT PBOOLEAN UpgradeOnlyCompliant
    );

BOOLEAN
pSpDetermineCurrentInstallation(
    IN PDISK_REGION OsPartRegion,
    IN PWSTR SystemRoot,
    OUT PCOMPLIANCE_DATA pcd
    );

BOOLEAN
pSpGetCurrentInstallVariation(
    IN  PWSTR szPid20,
    OUT LPDWORD CurrentInstallVariation
    );

BOOL
pSpDetermineSourceProduct(
    OUT PCOMPLIANCE_DATA pcd
    );

BOOLEAN
SpGetStepUpMode(
    PWSTR   PidExtraData,
    BOOLEAN *StepUpMode
    );

BOOLEAN
DetermineSourceVersionInfo(
  OUT PDWORD Version,
  OUT PDWORD BuildNumber
  );


#define CCMemAlloc     SpMemAlloc
#define CCMemFree      SpMemFree

#else

//
// user mode prototypes
//

VOID
CCDisableBuildCheck( 
    VOID
    );


BOOL
IsCompliant(
    PBOOL UpgradeOnly,
    PBOOL NoUpgradeAllowed,
    PUINT SrcSku,
    PUINT CurrentInstallType,
    PUINT CurrentInstallBuild,
    PUINT Reason
    );

BOOLEAN
DetermineSourceVersionInfo(
  IN TCHAR *InfPath,
  OUT PDWORD Version,
  OUT PDWORD BuildNumber
  );

BOOL
DetermineCurrentInstallation(
    LPDWORD CurrentInstallType,
    LPDWORD CurrentInstallVariation,
    LPDWORD CurrentInstallVersion,
    LPDWORD CurrentInstallBuildNT,
    LPDWORD CurrentInstallBuildWin9x,
    LPDWORD CurrentInstallSuite,
    LPDWORD CurrentInstallServicePack
    );

BOOL
GetCurrentInstallVariation(
    LPDWORD CurrentInstallVariation,
    IN  DWORD   CurrentInstallType,
    IN  DWORD   CurrentInstallBuildNT,
    IN  DWORD   InstallVersion
    );

BOOL
GetCurrentNtVersion(
    LPDWORD CurrentInstallType,
    LPDWORD CurrentInstallSuite
    );

BOOL
GetCdSourceInstallType(
    LPDWORD SourceInstallType
    );

BOOL
GetSourceInstallVariation(
    LPDWORD SourceInstallVariation
    );

BOOL 
IsWinPEMode(
    VOID
    );
    

#define CCMemAlloc     malloc
#define CCMemFree      free

#endif

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif // _COMPLIANCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\hwlog\hwlog.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    ntsetup\hwlog\hwlog.c

Abstract:

    Logging some aspects of the hardware configuration to winnt32.log / setupact.log.
    Esp. disk drive by connection, and map drive letters to disk drives.

Author:

    Jay Krell (JayKrell) April 2001, May 2001

Revision History:

Environment:

    winnt32.dll -- Win9x ANSI (down to Win95gold) or NT Unicode
                   libcmt statically linked in, _tcs* ok
                   actually only built for Unicode/NT, and does nothing
                   if run on less than Windows 2000

    setup.exe -newsetup -- guimode setup
--*/

/* Platform notes
Win95:
 apparently no setupapi.dll (redist)
 apparently no cfgmgr32.dll
 no kernel32.dll::GetVolumeNameForVolumeMountPoint
NT 3.1
 no kernel32.dll::GetVolumeNameForVolumeMountPoint
NT 3.51
 apparently no setupapi.dll
 apparently no cfgmgr32.dll
 no kernel32.dll::GetVolumeNameForVolumeMountPoint
NT4
 no kernel32.dll::GetVolumeNameForVolumeMountPoint
 setupapi.dll
   has SetupDiGetClassDevs
   does not have SetupDiGetClassDevsEx
   does not have SetupDiEnumDeviceInterfaces
   does not have SetupDiGetDeviceInterfaceDetail
 cfgmgr32.dll
   has the functions we call
Win2000, WinXp:
 has all the functions we call
Win98, Win98se:
 no kernel32.dll::GetVolumeNameForVolumeMountPoint
 setupapi.dll, has everything we use
   has SetupDiGetClassDevs
   has SetupDiGetClassDevsEx
   has SetupDiEnumDeviceInterfaces
   has SetupDiGetDeviceInterfaceDetail
 cfgmgr32.dll, has everything we use
    has CM_Get_Parent_Ex
    has CM_Connect_MachineA
    has CM_Get_DevNode_Registry_Property_ExA

existing versions of

winnt32a.dll
    not statically dependent on setupapi.dll
    not statically dependent on cfgmgr32.dll
winnt32u.dll
    not statically dependent on setupapi.dll
    statically dependent on cfgmgr32.dll, all functions exported on NT4 and Win98
        CM_Get_Device_ID_List_SizeW
        CM_Get_Device_ID_ListW
        CM_Get_DevNode_Registry_PropertyW
        CM_Locate_DevNodeW

conclusions
    works on Win2000 and WinXp
    maybe some of it works on Win98, Win98se, Win9me
    maybe can be changed slightly to work on NT4
    cannot easily work on NT 3 or Win95
    but GetVolumeNameForVolumeMountPoint and the DeviceIoControl might prevent it
    dynamically link it "all"
*/

#define STANDALONE 0
#define DYNLINK    1

#if STANDALONE

#define UNICODE
#define _UNICODE

#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0501
#endif
// from windows.h, but we want this before nt.h
#if !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_IX86)
#define _X86_
#endif

#if !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_AMD64)
#define _AMD64_
#endif

#if !defined(_IA64_) && !defined(_X86_) && !defined(_M_IX86) && !defined(_AMD64_) && defined(_M_IA64)
#define _IA64_
#endif

#include "io.h"

#if !defined(_WIN64)
typedef unsigned long ULONG_PTR; // vc6 compatibility
typedef unsigned long DWORD_PTR; // vc6 compatibility
#endif

#endif

#include <stdio.h>
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "cfgmgr32.h"
#include "objbase.h"
#include "initguid.h"
#include "devguid.h"
#include "setupapi.h"
#include "winioctl.h"
#include <stdlib.h>
#include "tchar.h"
#include <stdarg.h>
#include <stdlib.h>
#include "hwlog.h"
typedef CONST VOID* PCVOID;

struct _SP_LINKAGE;
typedef struct _SP_LINKAGE SP_LINKAGE, *PSP_LINKAGE;
typedef CONST SP_LINKAGE* PCSP_LINKAGE;

typedef struct _SP_MACHINE {
    PCTSTR      Name;   // for setupapi.dll functions
    HMACHINE    Handle; // for cfgmgr32.dll functions
} SP_MACHINE, *PSP_MACHINE;
typedef CONST SP_MACHINE* PCSP_MACHINE;

typedef struct _SP_LOG_HARDWARE {
    SP_MACHINE  Machine;
    HANDLE      LogFile;
#if !DYNLINK
    CONST
#endif
    SP_LINKAGE* Linkage;
    BOOL (WINAPI* SetupLogError)(PCTSTR MessageString, LogSeverity);
    BOOL (__cdecl * SetuplogError)(
        IN  LogSeverity         Severity,
        IN  LPCTSTR             MessageString,
        IN  UINT                MessageId,      OPTIONAL
        ...
        ) OPTIONAL;
} SP_LOG_HARDWARE, *PSP_LOG_HARDWARE;
typedef CONST SP_LOG_HARDWARE* PCSP_LOG_HARDWARE;

#if STANDALONE || defined(UNICODE)

#define QUASH_SIMPLE_PHYSICAL_DEVICE_OBJECT_NAMES 1
#define INDENT_FACTOR          2
#define UNAVAILABLE_VERBOSE    1
#if 0 /* this is more like a small tree, one device per line, indenting */
#define ONE_PROPERTY_PER_LINE  0
#define INDENT_CHILDREN        1
#define NUMBER_CHILDREN        0
#define DESCRIPTION_DASH_PHYSICAL_DEVICE_OBJECT 0
#else
#define ONE_PROPERTY_PER_LINE  1
#define INDENT_CHILDREN        0
#define NUMBER_CHILDREN        1
#define DESCRIPTION_DASH_PHYSICAL_DEVICE_OBJECT 1
#endif
#define ONE_DEVICE_PER_LINE    (!ONE_PROPERTY_PER_LINE)

#if !defined(DBG)
#define DBG 1
#endif
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))

#if !defined(ISNT)
#if STANDALONE || !defined(UNICODE)
#define ISNT()                    ((GetVersion() & 0x80000000) == 0)
#else
#define ISNT()                    TRUE
#endif
#endif
#define SP_FILE_SHARE_DELETE()    (ISNT() ? FILE_SHARE_DELETE : 0)

// RTL_* from ntdef.h
#define FIELD_TYPE(type, field)    (((type*)0)->field)
#define BITS_OF_FIELD(type, field) (BITS_OF(FIELD_TYPE(type, field)))
#define BITS_OF(sizeOfArg)         (sizeof(sizeOfArg) * 8)

#define xPASTE(x,y) x##y
#define PASTE(x,y) xPASTE(x,y)

typedef struct _SP_LINKAGE
{
#if DYNLINK
#define U(x) union { PCSTR PASTE(Name, __LINE__); x; }
#else
#define U(x) x
#endif

    PCSTR Kernel32Dll;
    U(BOOL (WINAPI* GetVolumeNameForVolumeMountPoint)(PCTSTR lpszVolumeMountPoint, PTSTR lpszVolumeName, DWORD cchBufferLength));

    PCSTR Setupapidll;
    U(BOOL (WINAPI* SetupDiEnumDeviceInterfaces)(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, CONST GUID* InterfaceClassGuid, DWORD MemberIndex, PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData));
    U(HDEVINFO (WINAPI* SetupDiGetClassDevsEx)(CONST GUID* ClassGuid, PCTSTR Enumerator, HWND hwndParent, DWORD Flags, HDEVINFO DeviceInfoSet, PCTSTR MachineName, PVOID Reserved));
    U(BOOL (WINAPI* SetupDiGetDeviceInterfaceDetail)(HDEVINFO DeviceInfoSet, PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData, PSP_DEVICE_INTERFACE_DETAIL_DATA DeviceInterfaceDetailData, DWORD DeviceInterfaceDetailDataSize, PDWORD RequiredSize, PSP_DEVINFO_DATA DeviceInfoData));
    U(CONFIGRET (WINAPI* CM_Get_Parent_Ex)(OUT PDEVINST pdnDevInst, IN  DEVINST  dnDevInst, IN  ULONG ulFlags, IN  HMACHINE hMachine));
    U(CONFIGRET (WINAPI* CM_Connect_Machine)(IN  PCTSTR UNCServerName, OUT PHMACHINE phMachine));
    U(CONFIGRET (WINAPI* CM_Get_DevNode_Registry_Property_Ex)(
            IN DEVINST dnDevInst, IN ULONG ulProperty,
            OUT PULONG pulRegDataType OPTIONAL, OUT PVOID Buffer OPTIONAL,
            IN OUT PULONG pulLength, IN ULONG ulFlags, IN HMACHINE hMachine));

#undef U
} SP_LINKAGE;

#if defined(UNICODE)
#define T "W"
#else
#define T "A"
#endif
#if !DYNLINK
CONST
#endif
static SP_LINKAGE SpLinkage =
{
#if DYNLINK
    //
    // note: lowercase => .dll name
    //
    "kernel32.dll",
    "GetVolumeNameForVolumeMountPoint" T,

    "setupapi.dll",
    "SetupDiEnumDeviceInterfaces",
    "SetupDiGetClassDevsEx" T,
    "SetupDiGetDeviceInterfaceDetail" T,
    "CM_Get_Parent_Ex",
    "CM_Connect_Machine" T,
    "CM_Get_DevNode_Registry_Property_Ex" T
#undef T
#else
    NULL, // kernel32
    GetVolumeNameForVolumeMountPoint,

    NULL, // setupapi
    SetupDiEnumDeviceInterfaces,
    SetupDiGetClassDevsEx,
    SetupDiGetDeviceInterfaceDetail,
    CM_Get_Parent_Ex,
    CM_Connect_Machine,
    CM_Get_DevNode_Registry_Property_Ex
#endif
};

BOOL
SpDoDynlink(
    PSP_LOG_HARDWARE This
    )
{
#if DYNLINK
    SIZE_T i;
    FARPROC* rgproc = (FARPROC*)This->Linkage;
    PCSTR* rgpsz = (PCSTR*)This->Linkage;
    HMODULE DllHandle;

    for (i = 0 ; i != sizeof(SpLinkage)/sizeof(PVOID) ; ++i)
    {
        if (islower(rgpsz[i][0]))
        {
            if ((DllHandle = LoadLibraryA(rgpsz[i])) == NULL)
                return FALSE;
        }
        else if ((rgproc[i] = GetProcAddress(DllHandle, rgpsz[i])) == NULL)
        {
            return FALSE;
        }
    }
#endif
    return TRUE;
}

PCTSTR
SpGetSpacesString(
    SIZE_T n
    );

PCTSTR
SpGetDashesString(
    SIZE_T n
    );

PVOLUME_DISK_EXTENTS
SpGetVolumeDiskExtents(
    HANDLE DeviceFileHandle
    );

//
// need a downlevel static .lib version of ntdll.dll..
//
typedef struct SP_STRING {
    PTSTR  Chars;
    SIZE_T Length;
    SIZE_T MaximumLength;
} SP_STRING, *PSP_STRING;
typedef CONST SP_STRING* PCSP_STRING;

#define SpStringLength(s) ((s)->Length)

#define SpInitString(s, t) \
    ((s)->MaximumLength = sizeof((s)->Chars[0]) + ((s)->Length = lstrlen((s)->Chars = (PTSTR)t)))

VOID
SpHwDebugLog(
    PSP_LOG_HARDWARE This,
    PCTSTR           Format,
    ...
    );

VOID SpStringAppendFormatVa(PSP_STRING Buffer, PCSP_STRING Format, va_list va)
{
    if (Buffer->MaximumLength > Buffer->Length + 1)
    {
        _vsntprintf(
            Buffer->Chars + Buffer->Length,
            Buffer->MaximumLength - Buffer->Length,
            Format->Chars,
            va
            );
    }
    Buffer->Chars[Buffer->MaximumLength - 1] = 0;
}

VOID SpStringAppendFormat(PSP_STRING Buffer, PCSP_STRING Format, ...)
{
    va_list va;

    va_start(va, Format);
    SpStringAppendFormatVa(Buffer, Format, va);
    va_end(va);
}

VOID SpStringAppend(PSP_STRING s, PCSP_STRING t)
{
    SP_STRING Format;

    Format.Chars = TEXT("%s");
    Format.Length = 2;

    SpStringAppendFormat(s, &Format, t);
}

VOID SpStringCopy(PSP_STRING s, PCSP_STRING t)
{
    s->Chars[0] = 0;
    SpStringAppend(s, t);
}

VOID SpStringFormat(PSP_STRING s, PCSP_STRING Format, ...)
{
    va_list va;
    va_start(va, Format);

    s->Chars[0] = 0;
    SpStringAppendFormatVa(s, Format, va);

    va_end(va);
}

PVOID SpMalloc(SIZE_T n)
{ 
    return HeapAlloc(GetProcessHeap(), 0, n);
}

VOID SpFree(PVOID p)
{ 
    HeapFree(GetProcessHeap(), 0, p);
}

PVOID SpRealloc(PVOID p, SIZE_T n)
{ 
    return HeapReAlloc(GetProcessHeap(), 0, p, n);
}

VOID SpStringFree(PTSTR s) {  SpFree(s); }

VOID SpRemoveTrailingChars(PSP_STRING s, PCTSTR ch)
{
    while (s->Length != 0
        && (s->Chars[s->Length - 1] == ch[0] || s->Chars[s->Length - 1] == ch[1])
        && !(s->Chars[s->Length - 1] = 0)
        && (s->Length -= 1)
        )
    {
        // nothing
    }
}

VOID SpEnsureTrailingChar(PSP_STRING s, TCHAR ch)
{
    if (s->Length == 0
        || s->Chars[s->Length - 1] != ch)
    {
        s->Length += 1;
        s->Chars[s->Length - 1] = ch;
        s->Chars[s->Length] = 0;
    }
}

//
// for now, let's hope that device numbers stay in the range 0-63
//
typedef struct SP_DEVICE_NUMBERS {
    ULONGLONG Bitset;
} SP_DEVICE_NUMBERS, *PSP_DEVICE_NUMBERS;
typedef CONST SP_DEVICE_NUMBERS* PCSP_DEVICE_NUMBERS;

typedef struct SP_VOLUME
{
    PTSTR GuidVolumeNamePointer; // if this is null, use GuidVolumeNameBuffer
    TCHAR GuidVolumeNameBuffer[64];  // \\?\{guid}
#define SP_VOLUME_GET_NAME(v) (((v)->GuidVolumeNamePointer != NULL) ? (v)->GuidVolumeNamePointer : (v)->GuidVolumeNameBuffer)

//
// DiskNumbers are gotten via DeviceIoControl(STORAGE_DEVICE_NUMBER) (Win2K)
// and DeviceIoControl(IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS) (Whistler)
//
    ULONG             DeviceType;
    SP_DEVICE_NUMBERS DeviceNumbers;
    TCHAR  DriveLetter;
} SP_VOLUME, *PSP_VOLUME;
typedef CONST SP_VOLUME* PCSP_VOLUME;

//
// most systems are limited to 24 volumes, C-Z, unless they use
// mount points, and setup is unlikely to be affected by those volumes
//
typedef struct _SP_VOLUMES {
    SP_VOLUME Entries[24];
} SP_VOLUMES, *PSP_VOLUMES;
typedef CONST SP_VOLUMES* PCSP_VOLUMES;

#define SP_PROPERTY_QUIET_UNAVAILABLE (0x00000001)

typedef struct _SP_DEVICE_PROPERTY_CONST {
    //ULONG   SetupapiInteger;
    ULONG   ConfigManagerInteger;
    PCTSTR  Name;
    ULONG   Flags;
}  SP_DEVICE_PROPERTY_CONST, *PSP_DEVICE_PROPERTY_CONST;
typedef CONST SP_DEVICE_PROPERTY_CONST* PCSP_DEVICE_PROPERTY_CONST;

#if ONE_DEVICE_PER_LINE
//CONST static TCHAR FriendlyNameString[] = TEXT("FriendlyName");
//CONST static TCHAR DescriptionString[] = TEXT("Description");
CONST static TCHAR PhysicalDeviceObjectNameString[] = TEXT("");
CONST static TCHAR HardwareIdString[] = TEXT("");
CONST static TCHAR LowerFiltersString[] = TEXT("");
CONST static TCHAR UpperFiltersString[] = TEXT("");
//CONST static TCHAR FlagsString[] = TEXT("");
CONST static TCHAR LocationInformationString[] = TEXT("");
#else
//CONST static TCHAR FriendlyNameString[] = TEXT("FriendlyName");
//CONST static TCHAR DescriptionString[] = TEXT("Description");
CONST static TCHAR PhysicalDeviceObjectNameString[] = TEXT("PhysicalDeviceObjectName");
CONST static TCHAR HardwareIdString[] = TEXT("HardwareId");
CONST static TCHAR LowerFiltersString[] = TEXT("LowerFilters");
CONST static TCHAR UpperFiltersString[] = TEXT("UpperFilters");
//CONST static TCHAR FlagsString[] = TEXT("Flags");
CONST static TCHAR LocationInformationString[] = TEXT("Location");
#endif

#define SETUPAPI_PROPERTY_NUMBER(x) /* nothing */

#define DESCRIPTION             0
#define PHYSICAL_DEVICE_OBJECT  1
#define FRIENDLY_NAME           2
#define HARDWARE_ID             3
#define FIRST_GENERIC_PROPERTY  4

CONST static SP_DEVICE_PROPERTY_CONST DevicePropertyMetaInfo[] =
{
    { SETUPAPI_PROPERTY_NUMBER(SPDRP_DEVICEDESC) CM_DRP_DEVICEDESC, TEXT(""), SP_PROPERTY_QUIET_UNAVAILABLE },
    { SETUPAPI_PROPERTY_NUMBER(SPDRP_PHYSICAL_DEVICE_OBJECT_NAME) CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME, PhysicalDeviceObjectNameString },
    { SETUPAPI_PROPERTY_NUMBER(SPDRP_FRIENDLYNAME) CM_DRP_FRIENDLYNAME, TEXT(""), SP_PROPERTY_QUIET_UNAVAILABLE },
    { SETUPAPI_PROPERTY_NUMBER(SPDRP_HARDWAREID) CM_DRP_HARDWAREID, HardwareIdString },
    { SETUPAPI_PROPERTY_NUMBER(x) CM_DRP_LOCATION_INFORMATION, LocationInformationString, SP_PROPERTY_QUIET_UNAVAILABLE },
    { SETUPAPI_PROPERTY_NUMBER(SPDRP_LOWERFILTERS) CM_DRP_LOWERFILTERS, LowerFiltersString, SP_PROPERTY_QUIET_UNAVAILABLE },
    { SETUPAPI_PROPERTY_NUMBER(SPDRP_UPPERFILTERS) CM_DRP_UPPERFILTERS, UpperFiltersString, SP_PROPERTY_QUIET_UNAVAILABLE },
    //{ SETUPAPI_PROPERTY_NUMBER(x) CM_DRP_CONFIGFLAGS, FlagsString },
    //{ SETUPAPI_PROPERTY_NUMBER(x) CM_DRP_CAPABILITIES, TEXT("Capabilities") },
    //{ SETUPAPI_PROPERTY_NUMBER(x) CM_DRP_UI_NUMBER, TEXT("UI Number") },
    //{ SETUPAPI_PROPERTY_NUMBER(x) CM_DRP_CHARACTERISTICS, TEXT("Characteristics") },
    //{ SETUPAPI_PROPERTY_NUMBER(x) CM_DRP_ADDRESS, TEXT("Address") },
};

typedef struct _SP_DEVICE_PROPERTY {
    PCSP_DEVICE_PROPERTY_CONST   Const;
    TCHAR                        Value[256];
    ULONG                        Type;
} SP_DEVICE_PROPERTY, *PSP_DEVICE_PROPERTY;
typedef CONST SP_DEVICE_PROPERTY* PCSP_DEVICE_PROPERTY;

typedef struct _SP_DEVICE_CLASS {
    CONST GUID* Guid;
    ULONG       IsInterface;
    //PCTSTR       Name;
} SP_DEVICE_CLASS, *PSP_DEVICE_CLASS;
typedef CONST SP_DEVICE_CLASS* PCSP_DEVICE_CLASS;

/*
CONST static TCHAR VolumesString[] = TEXT("Volumes");
CONST static TCHAR DisksString[] = TEXT("Disks");
CONST static TCHAR CDROMsString[] = TEXT("CDROMs");
CONST static TCHAR PartitionsString[] = TEXT("Partitions");
*/

CONST static SP_DEVICE_CLASS DeviceClasses[] =
{
    { &GUID_DEVINTERFACE_CDROM, DIGCF_DEVICEINTERFACE,      /*CDROMsString*/ },
    { &GUID_DEVINTERFACE_DISK, DIGCF_DEVICEINTERFACE,       /*DisksString*/ },
    { &GUID_DEVINTERFACE_PARTITION, DIGCF_DEVICEINTERFACE,  /*PartitionsString*/ },
    // The information this adds is not very useful.
    //{ &GUID_DEVINTERFACE_VOLUME, DIGCF_DEVICEINTERFACE,     /*VolumesString*/ },
};

typedef struct _SP_DEVICE {
    PCSP_DEVICE_CLASS   Class;
    ULONG               DevInst;
    ULONG               DeviceType;
    SP_DEVICE_NUMBERS   DeviceNumbers;
    //BOOL              IsLeaf;
    SIZE_T              NumberOfParents;
    ULONG               ParentDevInsts[MAX_DEVICE_ID_LEN];
    TCHAR               DevicePath[MAX_PATH];
    TCHAR               GuidVolumePath[64];
    //SP_DEVICE_PROPERTY Properties[NUMBER_OF(DevicePropertyMetaInfo)];
} SP_DEVICE, *PSP_DEVICE;
typedef CONST SP_DEVICE* PCSP_DEVICE;

#define SP_IS_PATH_SEPERATOR(ch) ((ch) == '\\' || (ch) == '/')

SIZE_T
SpStringLengthWithoutTrailingPathSeperators(
    PCTSTR s
    )
{
    SIZE_T Length;

    if (s == NULL || *s == 0)
        return 0;

    Length = _tcslen(s);
    s += Length - 1;
    while (SP_IS_PATH_SEPERATOR(s[Length]))
        Length -= 1;

    return Length;
}

int __cdecl SpCompareVolume(CONST VOID* v1, CONST VOID* v2)
{
    CONST PCSP_VOLUME p1 = (PCSP_VOLUME)v1;
    CONST PCSP_VOLUME p2 = (PCSP_VOLUME)v2;
    CONST PCTSTR s1 = (p1 != NULL) ? SP_VOLUME_GET_NAME(p1) : TEXT("");
    CONST SIZE_T len1 = SpStringLengthWithoutTrailingPathSeperators(s1);
    CONST PCTSTR s2 = (p1 != NULL) ? SP_VOLUME_GET_NAME(p2) : TEXT("");
    CONST SIZE_T len2 = SpStringLengthWithoutTrailingPathSeperators(s2);

    return _tcsicmp(s1, s2);
}

VOID SpSortVolumes(PSP_VOLUMES Volumes)
{
    qsort(
        Volumes->Entries,
        NUMBER_OF(Volumes->Entries),
        sizeof(Volumes->Entries[0]),
        SpCompareVolume
        );
}

PCSP_VOLUME
SpFindVolume(
    PSP_VOLUMES Volumes,
    PCTSTR VolumeGuidPath
    )
{
    CONST SP_VOLUME VolumeKey = { (PTSTR)VolumeGuidPath };
    PCSP_VOLUME VolumeFound =
        (PCSP_VOLUME)
        bsearch(
            &VolumeKey,
            Volumes->Entries,
            NUMBER_OF(Volumes->Entries),
            sizeof(Volumes->Entries[0]),
            SpCompareVolume
            );

    return VolumeFound;
}

#if 0
void
SpCovertRNToN(
    PTSTR Buffer
    )
{
    PTSTR p;
    PTSTR q;
    for (p = q = Buffer ; *p != 0 && *(p + 1) != 0 ; )
    {
        if (*p == '\r' && *(p + 1) == '\n')
        {
            *q++ = '\n';
            p += 2;
        }
        else
        {
            *q++ = *p++;
        }
    }
    if (*p != 0)
        *q++ = *p++;
    *q++ = 0;
}

void
SpCovertNToRN(
    PTSTR Buffer
    )
{
    // determine size
    // heap alloc
    // convert
}
#endif

VOID
SpHwDebugLog(
    PSP_LOG_HARDWARE    This,
    PCTSTR              Format,
    ...
    )
{
    va_list va;
    TCHAR BufferT[500];
#ifdef UNICODE
     CHAR BufferA[500];
#endif
    SIZE_T Length;
    BOOLEAN Newline = FALSE;

    BufferT[0] = 0;
    va_start(va, Format);
    FormatMessage(
        FORMAT_MESSAGE_FROM_STRING,
        Format,
        0,
        0,
        BufferT,
        NUMBER_OF(BufferT),
        &va
        );
    BufferT[NUMBER_OF(BufferT) - 1] = 0;

    Length = lstrlen(BufferT);
    if (Length != 0)
    {
#if 0
        Newline = (BufferT[Length - 1] == '\n' || BufferT[Length - 1] == '\r');
        if (Newline)
        {
            while (Length != 0 && (BufferT[Length - 1] == '\n' || BufferT[Length - 1] == '\r'))
                Length -= 1;
            if (Length != 0)
                BufferT[Length] = 0;
            else
                Newline = FALSE;
        }
#endif
        if (Newline)
            lstrcat(BufferT, TEXT("\r\n"));
        if (This->LogFile != NULL)
        {
            DWORD BytesWritten;

            if (Newline)
                lstrcat(BufferT, TEXT("\r\n"));
#ifdef UNICODE
            WideCharToMultiByte(
                 CP_ACP,
                 0,
                 BufferT,
                 -1,
                 BufferA,
                 sizeof(BufferA) - 1,
                 NULL,
                 NULL
                 );
            WriteFile(This->LogFile, &BufferA, lstrlenA(BufferA), &BytesWritten, NULL);
#else
            WriteFile(This->LogFile, &BufferT, lstrlen(BufferT), &BytesWritten, NULL);
#endif
        }
        if (This->SetupLogError != NULL)
        {
            This->SetupLogError(BufferT, LogSevInformation);
        }
        if (This->SetuplogError != NULL)
        {
            This->SetuplogError(
                LogSevInformation,
                TEXT("%1"),
                0,
                BufferT,
                (PVOID)NULL,
                (PVOID)NULL
                );
        }
    }
    va_end(va);
}

#define SpHwLog SpHwDebugLog

#if 0
VOID PrependString(PTSTR s, PCTSTR t)
{
    SIZE_T slen = _tcslen(s);
    SIZE_T tlen = _tcslen(t);

    MoveMemory(s + tlen, s, (slen + 1) * sizeof(*s));
    MoveMemory(s, t, tlen);
}
#endif

#define SP_CLOSE_HANDLE(h) \
    do { if ((h) != NULL && (h) != INVALID_HANDLE_VALUE) { CloseHandle(h); h = INVALID_HANDLE_VALUE; } } while(0)

#define SP_FREE(p) \
    do { if ((p) != NULL) { SpFree(p); (p) = NULL; } } while(0)

PVOLUME_DISK_EXTENTS 
SpGetVolumeDiskExtents(
    HANDLE DeviceFileHandle
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    //
    // This pattern is iffy, but it is used elsewhere, and the implementation of
    // IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS is iffy too, and not quite as documented.
    // See drivers\vsm\vsmio\nt\voldev.c.
    //
    struct {
        VOLUME_DISK_EXTENTS VolumeDiskExtents;
        DISK_EXTENT         DiskExtents[4];
    } StackDiskExtents;
    PVOLUME_DISK_EXTENTS HeapDiskExtents = NULL;
    PVOLUME_DISK_EXTENTS DiskExtents = NULL;
    PVOLUME_DISK_EXTENTS ResultDiskExtents = NULL;
    DWORD BytesReturned;
    BOOL Success = FALSE;
    DWORD Size;

    DiskExtents = &StackDiskExtents.VolumeDiskExtents;
    Size = sizeof(StackDiskExtents);
    //
    // loop in case it is changing
    //
    while (!Success)
    {
        Success =
            DeviceIoControl(
                DeviceFileHandle,
                IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
                NULL,
                0,
                DiskExtents,
                Size,
                &BytesReturned,
                NULL
                );
        if (!Success) {
            if (GetLastError() != ERROR_MORE_DATA)
                goto Exit;
            Size = sizeof(VOLUME_DISK_EXTENTS) + DiskExtents->NumberOfDiskExtents * sizeof(DISK_EXTENT);
            SP_FREE(HeapDiskExtents);
            HeapDiskExtents = (PVOLUME_DISK_EXTENTS)SpMalloc(Size);
            if (HeapDiskExtents == NULL) {
                SetLastError(ERROR_OUTOFMEMORY);
                goto Exit;
            }
            DiskExtents = HeapDiskExtents;
        } else {
            if (DiskExtents->NumberOfDiskExtents == 0) {
                /* nothing */
            }
            else if (DiskExtents == HeapDiskExtents) {
                ResultDiskExtents = HeapDiskExtents;
                HeapDiskExtents = NULL;
            } else if (DiskExtents == &StackDiskExtents.VolumeDiskExtents) {
                Size = sizeof(VOLUME_DISK_EXTENTS) + DiskExtents->NumberOfDiskExtents * sizeof(DISK_EXTENT);
                ResultDiskExtents = (PVOLUME_DISK_EXTENTS)SpMalloc(Size);
                if (ResultDiskExtents == NULL) {
                    SetLastError(ERROR_OUTOFMEMORY);
                    goto Exit;
                }
                ASSERT(Size <= sizeof(StackDiskExtents));
                CopyMemory(ResultDiskExtents, &StackDiskExtents, Size);
            } else {
                ASSERT(FALSE && "DiskExtents != HeapDiskExtents, StackDiskExtents");
            }
        }
    }
Exit:
    SP_FREE(HeapDiskExtents);
    return ResultDiskExtents;
}

PTSTR
SpDeviceTypeToString(
    ULONG i,
    PTSTR s
    )
{
    //
    // this is a partial list from public\ddk\inc\devioctl.h
    //
    PCTSTR t = NULL;
    s[0] = 0;
    switch (i)
    {
    case FILE_DEVICE_CD_ROM:                t = TEXT("CDROM"); break;
    case FILE_DEVICE_CD_ROM_FILE_SYSTEM:    t = TEXT("CDROM File System"); break;
    case FILE_DEVICE_CONTROLLER:            t = TEXT("Device Controller"); break;
    case FILE_DEVICE_DFS:                   t = TEXT("Distributed File System"); break;
    case FILE_DEVICE_DISK:                  t = TEXT("Disk"); break;
    case FILE_DEVICE_DISK_FILE_SYSTEM:      t = TEXT("Disk File System"); break;
    case FILE_DEVICE_FILE_SYSTEM:           t = TEXT("File System"); break;
    case FILE_DEVICE_NETWORK_FILE_SYSTEM:   t = TEXT("Network File System"); break;
    case FILE_DEVICE_TAPE:                  t = TEXT("Tape"); break;
    case FILE_DEVICE_TAPE_FILE_SYSTEM:      t = TEXT("Tape File System"); break;
    case FILE_DEVICE_VIRTUAL_DISK:          t = TEXT("Virtual Disk"); break;
    case FILE_DEVICE_NETWORK_REDIRECTOR:    t = TEXT("Network Redirector"); break;
    case FILE_DEVICE_MASS_STORAGE:          t = TEXT("Mass Storage"); break;
    case FILE_DEVICE_SMB:                   t = TEXT("SMB"); break;
    case FILE_DEVICE_CHANGER:               t = TEXT("Changer"); break;
    case FILE_DEVICE_ACPI:                  t = TEXT("ACPI"); break;
    case FILE_DEVICE_DFS_FILE_SYSTEM:       t = TEXT("DFS File System"); break;
    case FILE_DEVICE_DFS_VOLUME:            t = TEXT("DFS Volume"); break;
    default:
        _stprintf(s, TEXT("Other (%ld)"), i);
        break;
    }
    if (t != NULL)
        _tcscpy(s, t);
    return s;
}

VOID
SpGetDeviceNumbersAndType(
    PSP_LOG_HARDWARE    This,
    PCTSTR              DevicePath,
    PSP_DEVICE_NUMBERS  DeviceNumbers,
    PULONG              DeviceType
    )
{
    PVOLUME_DISK_EXTENTS VolumeDiskExtents = NULL;
    STORAGE_DEVICE_NUMBER StorageDeviceNumber = { 0 };
    DWORD Error = 0;
    DWORD DeviceIoControlBytesReturned = 0;
    CONST static TCHAR Function[] = TEXT("SpGetDeviceNumbersAndType");
    HANDLE DeviceFileHandle = INVALID_HANDLE_VALUE;

#if 0
    SpHwDebugLog(
        This,
        TEXT("%1: DeviceIoControl(%2)\n"),
        Function,
        DevicePath
        );
#endif

    DeviceFileHandle =
        CreateFile(
            DevicePath,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_READ | SP_FILE_SHARE_DELETE(),
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
    if (DeviceFileHandle == INVALID_HANDLE_VALUE
        ) {
        Error = GetLastError();
        if (Error != ERROR_FILE_NOT_FOUND) {
            SpHwDebugLog(
                This,
                TEXT("%1: CreateFile(%2) warning %3!lu!\r\n"),
                Function,
                DevicePath,
                Error
                );
        }
        goto Exit;
    }

    if (!DeviceIoControl(
        DeviceFileHandle,
        IOCTL_STORAGE_GET_DEVICE_NUMBER,
        NULL,
        0,
        &StorageDeviceNumber,
        sizeof(StorageDeviceNumber),
        &DeviceIoControlBytesReturned,
        NULL
        )) {
        Error = GetLastError();
        if (Error != ERROR_INVALID_FUNCTION
            && Error != ERROR_FILE_NOT_FOUND
            && Error != ERROR_INVALID_PARAMETER // dynamic disk
            )
        {
            SpHwDebugLog(
                This,
                TEXT("%1: DeviceIoControl(%2) warning %3!lu!\r\n"),
                Function,
                DevicePath,
                Error
                );
        }
        if (Error == ERROR_INVALID_PARAMETER)
        {
            // dynamic disk
            *DeviceType = FILE_DEVICE_DISK;
        }
    } else if (DeviceIoControlBytesReturned < sizeof(StorageDeviceNumber)) {
        SpHwDebugLog(
            This,
            TEXT("%1: DeviceIoControl size mismatch (%4!lu!, %5!lu!)"),
            Function,
            (ULONG)DeviceIoControlBytesReturned,
            (ULONG)sizeof(StorageDeviceNumber)
            );
    } else {
        CONST ULONG DeviceNumber = StorageDeviceNumber.DeviceNumber;

#if 0
        {
            TCHAR DeviceTypeString[64];
            SpHwDebugLog(
                This,
                TEXT("%1: DeviceType of %2 is %3 (%4!lu!)\r\n"),
                Function,
                DevicePath,
                SpDeviceTypeToString(StorageDeviceNumber.DeviceType, DeviceTypeString),
                StorageDeviceNumber.DeviceType
                );
        }
#endif
        *DeviceType = StorageDeviceNumber.DeviceType;

        if (DeviceNumber > 63) {
            SpHwDebugLog(
                This,
                TEXT("%1: DeviceNumber out of range (%2!lu!)\r\n"),
                Function,
                StorageDeviceNumber.DeviceNumber
                );
        }
        else {
#if 0
            SpHwDebugLog(
                This,
                TEXT("%1 disk number %2!lu!\r\n"),
                DevicePath,
                DeviceNumber
                );
#endif
            DeviceNumbers->Bitset |= (1ui64 << DeviceNumber);
        }
    }
    VolumeDiskExtents = (PVOLUME_DISK_EXTENTS) SpGetVolumeDiskExtents(DeviceFileHandle);
    if (VolumeDiskExtents != NULL) {
        SIZE_T i;
        CONST SIZE_T VolumeDiskExtents_NumberOfDiskExtents = VolumeDiskExtents->NumberOfDiskExtents;

        for (i = 0 ; i != VolumeDiskExtents_NumberOfDiskExtents ; ++i) {
            CONST SIZE_T DiskNumber = VolumeDiskExtents->Extents[i].DiskNumber;
            if (DiskNumber > 63) {
                SpHwDebugLog(
                    This,
                    TEXT("%1: DiskNumber out of range (%2!lu!)\r\n"),
                    Function,
                    DiskNumber
                    );
            }
            else {
                DeviceNumbers->Bitset |= (1ui64 << DiskNumber);
            }
        }
    }
Exit:
    SP_CLOSE_HANDLE(DeviceFileHandle);
    SpFree(VolumeDiskExtents);
}

VOID
SpCollectVolumeInformation(
    PSP_LOG_HARDWARE    This,
    PSP_VOLUMES         Volumes
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    TCHAR DriveLetter;
    TCHAR GuidVolumeNameBuffer[NUMBER_OF(Volumes->Entries[0].GuidVolumeNameBuffer)];
    CONST static TCHAR Function[] = TEXT("SpCollectVolumeInformation");
    DWORD Error;
    SP_STRING GuidVolumeNameString;

    ZeroMemory(Volumes, sizeof(*Volumes));
    for (DriveLetter = 'C' ; DriveLetter <= 'Z' ; DriveLetter++) {
        CONST PSP_VOLUME Volume = &Volumes->Entries[DriveLetter - 'C'];
        CONST TCHAR DriveLetterPath[] = { DriveLetter, ':', '\\', 0 };
        CONST TCHAR DeviceDriveLetterPath[] = { '\\', '\\', '.', '\\', DriveLetter, ':', 0 };
        /* This looks interesting. WindowsXp only.
        if (GetVolumePathNamesForVolumeName(DriveLetterPath, VolumeName, NUMBER_OF(VolumeName)))
        {
        }
        */

        GuidVolumeNameBuffer[0] = 0;
        if (!This->Linkage->GetVolumeNameForVolumeMountPoint(
            DriveLetterPath, GuidVolumeNameBuffer, NUMBER_OF(GuidVolumeNameBuffer) - 1)
            )
        {
            Error = GetLastError();
            if (Error != ERROR_FILE_NOT_FOUND
                && Error != ERROR_PATH_NOT_FOUND
                ) {
                SpHwDebugLog(
                    This,
                    TEXT("%1: GetVolumeNameForVolumeMountPoint(%2) warning %3!lu!\r\n"),
                    Function,
                    DriveLetterPath,
                    Error
                    );
            }
            continue;
        }

        SpInitString(&GuidVolumeNameString, GuidVolumeNameBuffer);
        SpRemoveTrailingChars(&GuidVolumeNameString, TEXT("\\/"));
        Volume->DriveLetter = DriveLetter;
        CopyMemory(&Volume->GuidVolumeNameBuffer, &GuidVolumeNameBuffer, sizeof(GuidVolumeNameBuffer));
        SpGetDeviceNumbersAndType(
            This,
            Volume->GuidVolumeNameBuffer,
            &Volume->DeviceNumbers,
            &Volume->DeviceType
            );
    }
    qsort(Volumes->Entries, NUMBER_OF(Volumes->Entries), sizeof(Volumes->Entries[0]), SpCompareVolume);
//Exit:
    ;
}

BOOLEAN
SpCollectDeviceProperties(
    PSP_LOG_HARDWARE            This,
    ULONG                       DevInst,
    SIZE_T                      NumberOfProperties,
    PCSP_DEVICE_PROPERTY_CONST  InArray,
    PSP_DEVICE_PROPERTY         OutArray
    )
{
    BOOLEAN Success = FALSE;
    SIZE_T PropertyIndex = 0;
    CONFIGRET ConfigRet = 0;
    CONST static TCHAR Function[] = TEXT("SpCollectDeviceProperties");
    SP_STRING ValueString;
    SP_STRING Whitespace;

    SpInitString(&Whitespace, TEXT("\r\n\v\t "));

    for (PropertyIndex = 0 ; PropertyIndex != NumberOfProperties ; PropertyIndex += 1)
    {
        PCSP_DEVICE_PROPERTY_CONST In = &InArray[PropertyIndex];
        PSP_DEVICE_PROPERTY        Out = &OutArray[PropertyIndex];
        ULONG PropertyBufferSize = sizeof(Out->Value);

        //
        // zero out two chars due to multi_sz
        //
        Out->Value[0] = 0;
        Out->Value[1] = 0;
        ConfigRet =
            This->Linkage->CM_Get_DevNode_Registry_Property_Ex(
                DevInst,
                In->ConfigManagerInteger,
                &Out->Type,
                Out->Value,
                &PropertyBufferSize,
                0,
                This->Machine.Handle
                );
        if (ConfigRet == CR_BUFFER_SMALL)
        {
            //
            // zero out two chars due to multi_sz
            //
            Out->Value[0] = 0;
            Out->Value[1] = 0;
#if DBG
            SpHwDebugLog(
                This,
                TEXT("%1: Buffer too small, property %2\r\n"),
                Function,
                DevicePropertyMetaInfo[PropertyIndex].Name
                );
#endif
        }
#if UNAVAILABLE_VERBOSE
        if (ConfigRet == CR_NO_SUCH_VALUE
            && (DevicePropertyMetaInfo[PropertyIndex].Flags & SP_PROPERTY_QUIET_UNAVAILABLE) == 0
            )
        {
            _tcscpy(Out->Value, TEXT("<unavailable>"));
            ConfigRet = CR_SUCCESS;
        }
#endif
        if (Out->Type == REG_SZ)
        {
            SpInitString(&ValueString, Out->Value);
            SpRemoveTrailingChars(&ValueString, TEXT("\r\n"));
        }
#if QUASH_SIMPLE_PHYSICAL_DEVICE_OBJECT_NAMES
        /* of the form \Device\12345678 */
        if (ConfigRet == CR_SUCCESS
            && In->ConfigManagerInteger == CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME
            )
        {
            CONST static TCHAR SimpleDeviceName[] = TEXT("\\Device\\12345678");
            if (lstrlen(Out->Value) == NUMBER_OF(SimpleDeviceName) - 1)
            {
                SIZE_T i;
                for (i = 0 ; i != NUMBER_OF(SimpleDeviceName) - 1 ; ++i)
                {
                    if (iswdigit(SimpleDeviceName[i]) && iswdigit(Out->Value[i]))
                    {
                        // ok
                    }
                    else if (SimpleDeviceName[i] != Out->Value[i])
                    {
                        break;
                    }
                }
                if (i == NUMBER_OF(SimpleDeviceName) - 1)
                {
                    Out->Value[0] = 0;
                    Out->Value[1] = 0;
                }
            }
        }
#endif
        if (ConfigRet != CR_SUCCESS
            && ConfigRet != CR_NO_SUCH_VALUE
            && ConfigRet != CR_INVALID_PROPERTY
            && ConfigRet != CR_BUFFER_SMALL
            )
            goto Exit;
        Out->Const = In; // connect it back to the meta info
    }
    Success = TRUE;
Exit:;
    return Success;
}

BOOL
SpGrowArray(
    IN OUT PVOID*  Array,
    IN SIZE_T      SizeOfElement,
    IN OUT PSIZE_T NumberOfElements,
    IN OUT PSIZE_T NumberAllocated
    )
{
    ASSERT(*NumberOfElements < *NumberAllocated);
    *NumberOfElements += 1;
    if (*NumberOfElements >= *NumberAllocated) {
        PVOID Next = SpRealloc(*Array, SizeOfElement * *NumberAllocated * 2);
        if (Next == NULL) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        *Array = Next;
        *NumberAllocated *= 2;
    }
    return TRUE;
}

VOID
SpCollectDeviceInformation(
    PSP_LOG_HARDWARE            This,
    PCSP_DEVICE_CLASS           DeviceClasses,
    SIZE_T                      NumberOfDeviceClasses,
    PCSP_DEVICE_PROPERTY_CONST  DevicePropertyMetaInfo, // the size of this is assumed
    PSP_DEVICE*                 OutDevices,
    SIZE_T*                     OutNumberOfDevices
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    CONST static TCHAR Function[] = TEXT("SpCollectDeviceInformation");
    SIZE_T DeviceClassIndex = 0;
    ULONG DeviceInClassIndex = 0;
    SIZE_T NumberOfDevices = 0;
    SIZE_T NumberOfDevicesAllocated = 64;
    HANDLE DeviceInfoHandle = NULL;
    BOOL Success = FALSE;
    SP_DEVICE_INTERFACE_DATA SetupDeviceInterfaceData = { sizeof(SetupDeviceInterfaceData) };
    DWORD Error = 0;
    PSP_DEVICE Devices = NULL;
    ULONG DevInst = 0;
    ULONG ParentIndex = 0;
    SP_STRING String;
    struct
    {
        SP_DEVICE_INTERFACE_DETAIL_DATA Base;
        TCHAR                           Buffer[MAX_PATH];
    } DetailAndBuffer;
    SP_DEVINFO_DATA SetupDeviceInfoData = { sizeof(SetupDeviceInfoData) };
    CONFIGRET ConfigRet;

    DetailAndBuffer.Base.cbSize = sizeof(DetailAndBuffer.Base);

    Devices = (PSP_DEVICE)SpMalloc(NumberOfDevicesAllocated * sizeof(*Devices));
    ZeroMemory(Devices, NumberOfDevicesAllocated * sizeof(*Devices));

    //
    // loop over device class (disk, volume, cdrom, etc.)
    //
    for (DeviceClassIndex = 0 ; DeviceClassIndex != NumberOfDeviceClasses ; ++DeviceClassIndex) {
        DeviceInfoHandle =
            This->Linkage->SetupDiGetClassDevsEx(
                DeviceClasses[DeviceClassIndex].Guid,
                NULL,
                NULL,
                DIGCF_PRESENT | DeviceClasses[DeviceClassIndex].IsInterface,
                NULL,
                This->Machine.Name,
                NULL
                );
        if (DeviceInfoHandle == INVALID_HANDLE_VALUE)
        {
            Error = GetLastError();
            continue;
        }
        //
        // loop over devices in the class
        //
        Success = TRUE;
        for (DeviceInClassIndex = 0 ; Success ; ++DeviceInClassIndex) {

            PSP_DEVICE Device = &Devices[NumberOfDevices];

            Success =
                This->Linkage->SetupDiEnumDeviceInterfaces(
                    DeviceInfoHandle,
                    NULL,//&SetupDeviceInfoData,
                    DeviceClasses[DeviceClassIndex].Guid,
                    DeviceInClassIndex,
                    &SetupDeviceInterfaceData
                    );
            if (!Success)
                Error = GetLastError();
            if (!Success && Error == ERROR_NO_MORE_ITEMS) {
                break;
            }
            if (!Success) {
                break;
            }
            //
            // get the devinst and the device path
            //
            DevInst = SetupDeviceInfoData.DevInst;
            Success =
                This->Linkage->SetupDiGetDeviceInterfaceDetail(
                    DeviceInfoHandle,
                    &SetupDeviceInterfaceData,
                    &DetailAndBuffer.Base,
                    sizeof(DetailAndBuffer),
                    NULL, /* required size */
                    &SetupDeviceInfoData
                    );
            if (!Success) {
                break;
            }

            //Device->IsLeaf = TRUE;
            Device->DevInst = SetupDeviceInfoData.DevInst;
            _tcscpy(Device->DevicePath, DetailAndBuffer.Base.DevicePath);
#if 0
            SpHwDebugLog(
                This,
                TEXT("%1: %2\r\n"),
                Function,
                Device->DevicePath
                );
#endif

#if 1
            SpInitString(&String, Device->DevicePath);
            SpEnsureTrailingChar(&String, '\\');
            if (!This->Linkage->GetVolumeNameForVolumeMountPoint(Device->DevicePath,
                Device->GuidVolumePath, NUMBER_OF(Device->GuidVolumePath) - 1)
                ) {
                Error = GetLastError();
                if (Error != ERROR_FILE_NOT_FOUND
                    && Error != ERROR_PATH_NOT_FOUND
                    && Error != ERROR_NOT_READY
                    && Error != ERROR_INVALID_FUNCTION
                    )
                {
                    SpHwDebugLog(
                        This,
                        TEXT("%1: GetVolumeNameForVolumeMountPoint(%2) warning %3!lu!\r\n"),
                        Function,
                        Device->DevicePath,
                        Error
                        );
                    continue;
                }
            }
            //SpHwDebugLog(This, TEXT("%1: GetVolumeNameForVolumeMountPoint(%2) : %3\r\n"), Function, Device->DevicePath, Device->GuidVolumePath);
            SpRemoveTrailingChars(&String, TEXT("\\/"));
            SpInitString(&String, Device->GuidVolumePath);
            SpRemoveTrailingChars(&String, TEXT("\\/"));
#endif

            //
            // this is how we match up the devices to the drive letters
            //
            SpGetDeviceNumbersAndType(
                This,
                Device->DevicePath,
                &Device->DeviceNumbers,
                &Device->DeviceType
                );

            //
            // get the parent devinsts
            //
            for (
                (ConfigRet = CR_SUCCESS), (ParentIndex = 0);
                (ConfigRet == CR_SUCCESS)
                    && ParentIndex < NUMBER_OF(Device->ParentDevInsts);
                ParentIndex += 1
                )
            {
                ULONG ChildIndex = (ParentIndex == 0 ? Device->DevInst : Device->ParentDevInsts[ParentIndex - 1]);
                ConfigRet =
                    This->Linkage->CM_Get_Parent_Ex(
                        &Device->ParentDevInsts[ParentIndex],
                        ChildIndex,
                        0,
                        This->Machine.Handle
                        );
            }
            // the last one is never interesting, err.. two
            if (ParentIndex != 0)
                ParentIndex -= 1;
            if (ParentIndex != 0)
                ParentIndex -= 1;

            Device->NumberOfParents = ParentIndex;

            //
            // get the properties
            // we should do this here, but not if we don't also get the parent properties
            //
            //SpCollectDeviceProperties(Device, DevicePropertyMetaInfo);

            //
            // grow the array of devices if necessary
            //
            if (!SpGrowArray(&Devices, sizeof(Devices[0]), &NumberOfDevices, &NumberOfDevicesAllocated))
                goto Exit;

            //
            // We should probably the properties of the parents here,
            // but our data structures are not very good, and this would be inefficient
            // We must avoid O(n^2) behavior, because people really do have machines
            // with many disks, like 100.
            //
            // We should keep sorted arrays of devinsts.
            //
        }
    }
    if (!Success) {
        Error = GetLastError();
    }
    //SpChangeParentDevInstsToIndices(Devices, NumberOfDevices);
    *OutDevices = Devices;
    Devices = NULL;
    *OutNumberOfDevices = NumberOfDevices;
Exit:
    SpFree(Devices);
}

VOID
SpFillStaticString(
    PTSTR  s,
    SIZE_T n,
    TCHAR  ch
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ULONGLONG chch;
    ULONGLONG* pchch;
    SIZE_T i;
    SIZE_T m;

    if (s[n - 2] != 0)
        return;

    if (sizeof(ULONGLONG) <= sizeof(TCHAR))
    {
        for (i = 0 ; i != n - 1 ; i += 1)
        {
            s[i] = ch;
        }
        return;
    }
    chch = 0;
    for (i = 0 ; i != sizeof(ULONGLONG)/sizeof(TCHAR) ; i += 1)
    {
        chch <<= BITS_OF(ch);
        chch |= ch;
    }
    m = (n - 1) / (sizeof(ULONGLONG)/sizeof(TCHAR));
    pchch = (ULONGLONG*)s;
    for (i = 0 ; i < m ; i += 1)
    {
        pchch[i] = chch;
    }
    m *= (sizeof(ULONGLONG)/sizeof(TCHAR));
    for (i = m ; i < n - 1 ; i += 1)
    {
        s[i] = ch;
    }
#if DBG
    for (i = 0 ; i != n - 1 ; i += 1)
    {
        ASSERT(s[i] == ch);
    }
    ASSERT(s[i] == 0);
#endif
}

PCTSTR
SpGetDashesString(
    SIZE_T n
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    static union {
        ULONGLONG Ulonglongs[1 + 128 / (sizeof(ULONGLONG)/sizeof(TCHAR))];
        TCHAR     Tchars[128];
    } u;

    SpFillStaticString(u.Tchars, NUMBER_OF(u.Tchars), '-');
    n *= 2;
    if (n > NUMBER_OF(u.Tchars))
        n = NUMBER_OF(u.Tchars);
    return &u.Tchars[NUMBER_OF(u.Tchars) - n];
}

PCTSTR
SpGetSpacesString(
    SIZE_T n
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    static union {
        ULONGLONG Ulonglongs[1 + 128 / (sizeof(ULONGLONG)/sizeof(TCHAR))];
        TCHAR     Tchars[128];
    } u;

    SpFillStaticString(u.Tchars, NUMBER_OF(u.Tchars), ' ');
    n *= INDENT_FACTOR;
    if (n > NUMBER_OF(u.Tchars))
        n = NUMBER_OF(u.Tchars);
    return &u.Tchars[NUMBER_OF(u.Tchars) - 1 - n];
}

PCTSTR
SpGetFirstMultipleString(
    PCTSTR s
    )
{
    //
    // the first string being empty is odd case
    // it is the only string that can be empty
    //
    if (*s == 0 && *(s + 1) != 0)
        s += 1;
    return s;
}

PCTSTR
SpGetNextMultipleString(
    PCTSTR s
    )
{
    s += lstrlen(s) + 1;
    return s;
}

SIZE_T
SpMultipleStringCount(
    PCTSTR s
    )
{
    SIZE_T i = 0;
    if (*s != 0 || *(s + 1) != 0)
    {
        do
        {
            i += 1;
            s += lstrlen(s) + 1;
        } while (*s != 0);
    }
    return i;
}

VOID
SpLogDeviceProperties(
    PSP_LOG_HARDWARE        This,
    SIZE_T                  NumberOfProperties,
    PCSP_DEVICE_PROPERTY    PropertyData,
    ULONG                   Indent
    )
{
    ULONG PropertyType;
    SIZE_T PropertyIndex;
    //
    // we save away this string, so we that can indent the rest of the lines to account for it
    //
    TCHAR NumberString[BITS_OF(Indent)];

    NumberString[0] = 0;
#if NUMBER_CHILDREN
    _stprintf(NumberString, TEXT("%lu. "), Indent + 1);
#endif
#if ONE_DEVICE_PER_LINE
    SpHwLog(This, TEXT("%1"), SpGetSpacesString(Indent));
#endif
    for (PropertyIndex = 0 ; PropertyIndex != NumberOfProperties ; PropertyIndex += 1)
    {
        PCTSTR Name = PropertyData[PropertyIndex].Const->Name;
        if (PropertyData[PropertyIndex].Value[0] != 0
            && (PropertyIndex == 0
                //
                // friendly name sometimes == description
                // general fix: don't print adjacent equal values,
                //    unless they are both unavailable (which don't generally have anymore)
                //
                || _tcsicmp(PropertyData[PropertyIndex].Value, PropertyData[PropertyIndex - 1].Value) != 0
                || _tcsicmp(PropertyData[PropertyIndex].Value, TEXT("<unavailable>")) == 0
            ))
        {
#if DESCRIPTION_DASH_PHYSICAL_DEVICE_OBJECT
            if (PropertyIndex == PHYSICAL_DEVICE_OBJECT)
            {
                // nothing
            }
            else
#endif
            {
#if NUMBER_CHILDREN
                SpHwLog(This, TEXT("%1"), NumberString);
#endif
#if INDENT_CHILDREN && !ONE_DEVICE_PER_LINE
                SpHwLog(This, TEXT("%1"), SpGetSpacesString(Indent));
#endif
            }
            //
            // only print "PhysicalDeviceObject" if there was no description
            //
#if DESCRIPTION_DASH_PHYSICAL_DEVICE_OBJECT
            if (PropertyIndex == PHYSICAL_DEVICE_OBJECT
                && (
                    PropertyData[DESCRIPTION].Value[0] != 0
                    && _tcsicmp(PropertyData[DESCRIPTION].Value, TEXT("<unavailable>")) != 0)
                )
            {
                // nothing
            }
            else
#endif
            {
                if (Name != NULL && Name[0] != 0)
                {
                    //SpHwLog(This, TEXT("%1 = "), Name);
                    SpHwLog(This, TEXT("%1: "), Name);
                }
            }
            PropertyType = PropertyData[PropertyIndex].Type;
// if one device per line, shrink hardware id to just first item
// also compress its formating if it only contains one element
#if ONE_PROPERTY_PER_LINE
            if (PropertyType == REG_MULTI_SZ
                && SpMultipleStringCount(PropertyData[PropertyIndex].Value) < 2
                )
#endif
            {
                PropertyType = REG_SZ;
            }

            switch (PropertyType)
            {
                case REG_MULTI_SZ:
                    {
                        PCTSTR Value;
                        for (
                            Value = SpGetFirstMultipleString(PropertyData[PropertyIndex].Value);
                            *Value != 0;
                            Value = SpGetNextMultipleString(Value)
                            )
                        {
#if INDENT_CHILDREN
                            SpHwLog(
                                This,
                                TEXT("\r\n%1%2"),
                                SpGetSpacesString(Indent + 2),
                                Value
                                );
#else
                            SpHwLog(
                                This,
                                TEXT("\r\n%1  %2"),
                                NumberString,
                                Value
                                );
#endif
                        }
                    }
                case REG_SZ:
                    SpHwLog(This, TEXT("%1"), PropertyData[PropertyIndex].Value);
                    break;
            }
#if DESCRIPTION_DASH_PHYSICAL_DEVICE_OBJECT
            if (PropertyIndex == DESCRIPTION
                && PropertyData[PHYSICAL_DEVICE_OBJECT].Value[0] != 0
                )
            {
                SpHwLog(This, TEXT(" - "));
            }
            else
#endif
            {
#if ONE_PROPERTY_PER_LINE
                SpHwLog(This, TEXT("\r\n"));
#endif
#if ONE_DEVICE_PER_LINE
                SpHwLog(This, TEXT(" "));
#endif
            }
            if (NumberString[0] != 0 && NumberString[0] != ' ')
            {
                //
                // convert to spaces for the rest of the lines
                //
                SIZE_T i;
                for (i = 0 ; NumberString[i] != 0 ; ++i)
                {
                    NumberString[i] = ' ';
                }
            }
        }
    }
#if ONE_DEVICE_PER_LINE
    SpHwLog(This, TEXT("\r\n"));
#endif
}

VOID
SpLogDeviceTree(
    PSP_LOG_HARDWARE    This,
    PCSP_DEVICE         Device,
    ULONG               Indent
    )
{
    ULONG ParentIndex;
    SP_DEVICE_PROPERTY PropertyData[NUMBER_OF(DevicePropertyMetaInfo)];

    if (!SpCollectDeviceProperties(This, Device->DevInst, NUMBER_OF(PropertyData), DevicePropertyMetaInfo, PropertyData))
        return;
#if NUMBER_CHILDREN
    Indent = 1;
#endif
    SpLogDeviceProperties(This, NUMBER_OF(PropertyData), PropertyData, Indent - 1);
    for (ParentIndex = 0 ; ParentIndex < Device->NumberOfParents ; ParentIndex += 1)
    {
        if (!SpCollectDeviceProperties(This, Device->ParentDevInsts[ParentIndex], NUMBER_OF(PropertyData), DevicePropertyMetaInfo, PropertyData))
            break;
        SpLogDeviceProperties(This, NUMBER_OF(PropertyData), PropertyData, Indent + ParentIndex);
    }
#if NUMBER_CHILDREN
    SpHwLog(This, TEXT("\r\n"));
#endif
}

VOID
SpLogVolumeAndDeviceInformation(
    PSP_LOG_HARDWARE    This,
    PCSP_VOLUMES        Volumes,
    PCSP_DEVICE         Devices,
    SIZE_T              NumberOfDevices
    )
{
    ULONG Indent = 0;
    SIZE_T VolumeIndex = 0;
    SIZE_T DiskNumber = 0;
    SIZE_T DeviceIndex = 0;

    for (DeviceIndex = 0; DeviceIndex != NumberOfDevices ; DeviceIndex += 1)
    {
        PCSP_DEVICE Device = &Devices[DeviceIndex];

        for (DiskNumber = 0 ; DiskNumber != BITS_OF_FIELD(SP_DEVICE_NUMBERS, Bitset); DiskNumber += 1)
        {
            if ((Device->DeviceNumbers.Bitset & (1ui64 << DiskNumber)) != 0)
            {
                ULONG DriveLetters = 0;
                LONG NumberOfDriveLetters = 0;
                for (VolumeIndex = 0 ; VolumeIndex != NUMBER_OF(Volumes->Entries) ; ++VolumeIndex)
                {
                    CONST PCSP_VOLUME Volume = &Volumes->Entries[VolumeIndex];
                    if (Volume->DriveLetter != 0
                        && (Volume->DeviceNumbers.Bitset & (1ui64 << DiskNumber)) != 0
                        && Volume->DeviceType == Device->DeviceType
                        )
                    {
                        DriveLetters |= (1UL << (Volume->DriveLetter - 'C'));
                        NumberOfDriveLetters += 1;
                    }
                }
                if (DriveLetters != 0)
                {
                    SIZE_T i;
                    SpHwLog(
                        This,
                        TEXT("%1"),
                        SpGetSpacesString(Indent)
                        );
                    SpHwLog(
                        This,
                        TEXT("%1: "),
                        (NumberOfDriveLetters == 1)
                            ? TEXT("Volume")
                            : TEXT("Volumes")
                        );
                    for (i = 'C' ; i <= 'Z' ; i += 1)
                    {
                        if ((DriveLetters & (1UL << (i - 'C'))) != 0)
                            SpHwLog(
                                This,
                                TEXT("%1!c!:\\ "),
                                i
                                );
                    }
                    SpHwLog(This, TEXT("%1"), TEXT("\r\n\r\n"));
                }
#if 1
                SpHwLog(
                    This,
                    TEXT("Device Path: %1%2"),
                    Device->DevicePath,
                    TEXT("\r\n\r\n")
                    );
#endif
                //SpHwLog(This, TEXT("\r\n"));
                SpLogDeviceTree(This, Device, Indent + 1);
                //SpHwLog(This, TEXT("\r\n\r\n"));
                SpHwLog(
                    This,
                    TEXT("%1\r\n\r\n"),
                    SpGetDashesString(100)
                    );
            }
        }
    }
}

VOID
SpLogHardware(
    PSP_LOG_HARDWARE_IN In
    )
{
    SP_VOLUMES  Volumes = { 0 };
    PSP_DEVICE  Devices = NULL;
    SIZE_T NumberOfDevices = 0;
    CONFIGRET ConfigRet = 0;
    SP_MACHINE Machine = { 0 };
    SP_LOG_HARDWARE This = { 0 };

    This.Machine.Name = In->MachineName;
    This.LogFile = In->LogFile;
    This.Linkage = &SpLinkage;
    This.SetupLogError = In->SetupLogError;
    This.SetuplogError = In->SetuplogError;

    if (!SpDoDynlink(&This))
    {
        SpHwLog(&This, TEXT("downlevel, deviceinfo not logged\r\n"));
        return;
    }

    ConfigRet = This.Linkage->CM_Connect_Machine(This.Machine.Name, &This.Machine.Handle);
    if (ConfigRet != CR_SUCCESS)
        goto Exit;
    SpCollectVolumeInformation(
        &This,
        &Volumes
        );

    SpCollectDeviceInformation(
        &This,
        DeviceClasses,
        NUMBER_OF(DeviceClasses),
        DevicePropertyMetaInfo,
        &Devices,
        &NumberOfDevices
        );

    if (Devices != NULL && NumberOfDevices != 0)
    {
        SpLogVolumeAndDeviceInformation(
            &This,
            &Volumes,
            Devices,
            NumberOfDevices
            );
        SpFree(Devices);
    }
Exit:
    ;
}

#if STANDALONE

void Main(
    PSP_LOG_HARDWARE_IN Parameters
    )
{
#if STANDALONE == 1
    Parameters->LogFile = (HANDLE)_get_osfhandle(_fileno(stdout));
#elif STANDALONE == 2
    SetupOpenLog(FALSE);
    Parameters->SetupLogError = SetupLogError;
#endif
    SpLogHardware(Parameters);
#if STANDALONE == 2
    SetupCloseLog();
#endif
}

#ifdef UNICODE
int __cdecl _wmain(int argc, WCHAR** argv)
{
    SP_LOG_HARDWARE_IN Parameters = { 0 };
    Parameters.MachineName = (argc > 1) ? argv[1] : NULL;
    Main(&Parameters);
    return 0;
}
#endif

int __cdecl main(int argc, CHAR** argv)
{
    SP_LOG_HARDWARE_IN Parameters = { 0 };
#ifdef UNICODE
    WCHAR** argvw = NULL;
    argvw = CommandLineToArgvW(GetCommandLineW(), &argc);
    Parameters.MachineName = (argc > 1) ? argvw[1] : NULL;
#else
    Parameters.MachineName = (argc > 1) ? argv[1] : NULL;
#endif
    Main(&Parameters);
    return 0;
}

#endif

#else

VOID
SpLogHardware(
    PSP_LOG_HARDWARE_IN In
    )
{
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inc\mgdlllib.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    miglib.h

Abstract:

    Public Header file for Miglib functionality.

Author:

    Marc R. Whitten (marcw) 07-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "plugin.h"
#define DBG_FOO     "Foo"

//
// Strings
//

// None

//
// Constants
//

#define GATHERMODE TRUE
#define APPLYMODE FALSE
#define SOURCEOS_WIN9X TRUE
#define SOURCEOS_WINNT FALSE


// None

//
// Macros
//

#define S_REGKEY_MIGRATION_DLLS_WINNT   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\NT Migration DLLs")

#define MIGDLLEXPORT __declspec(dllexport)

//
// Types
//



#define DLLLIST PVOID


typedef struct {

    SIZE_T Size;
    PCSTR StaticProductIdentifier;
    UINT DllVersion;
    PINT CodePageArray;
    UINT SourceOs;
    UINT TargetOs;
    PCSTR * NeededFileList;
    PVENDORINFO VendorInfo;

} MIGRATIONINFOA, *PMIGRATIONINFOA;

typedef struct {

    SIZE_T Size;
    PCWSTR StaticProductIdentifier;
    UINT DllVersion;
    PINT CodePageArray;
    UINT SourceOs;
    UINT TargetOs;
    PCWSTR * NeededFileList;
    PVENDORINFO VendorInfo;

} MIGRATIONINFOW, *PMIGRATIONINFOW;



typedef struct {

    CHAR WorkingDirectory[MAX_PATH];
    CHAR SourceMedia[MAX_PATH];
    CHAR DllPath[MAX_PATH];

    MIGRATIONINFOA Info;

} MIGDLLPROPERTIESA, *PMIGDLLPROPERTIESA;

typedef struct {



    WCHAR WorkingDirectory[MAX_PATH];
    WCHAR SourceMedia[MAX_PATH];
    WCHAR DllPath[MAX_PATH];

    MIGRATIONINFOW Info;

} MIGDLLPROPERTIESW, *PMIGDLLPROPERTIESW;


typedef struct {

    BOOL Isolated;
    BOOL MigrationMode;
    BOOL SourceOs;
    BOOL SrcUnicode;
    BOOL OldStyle;
    HANDLE Library;

    MIGDLLPROPERTIESA Properties;

} MIGRATIONDLLA, *PMIGRATIONDLLA;

typedef struct {

    BOOL Isolated;
    BOOL MigrationMode;
    BOOL SourceOs;
    BOOL SrcUnicode;
    BOOL OldStyle;
    HANDLE Library;

    MIGDLLPROPERTIESW Properties;

} MIGRATIONDLLW, *PMIGRATIONDLLW;



typedef struct {

    PMIGDLLPROPERTIESA Properties;
    INT NextItem;
    DLLLIST List;

} MIGDLLENUMA, *PMIGDLLENUMA;

typedef struct {

    PMIGDLLPROPERTIESW Properties;
    INT NextItem;
    DLLLIST List;

} MIGDLLENUMW, *PMIGDLLENUMW;


typedef enum {

    OS_WINDOWS9X = 0,
    OS_WINDOWSNT4X = 1,
    OS_WINDOWS2000 = 2,
    OS_WINDOWSWHISTLER = 3

} OS_TYPES, *POS_TYPES;


typedef BOOL (* MIGDLLINIT) (VOID);
typedef VOID (* MIGDLLSHUTDOWN) (VOID);
typedef VOID (* MIGDLLCLOSEW) (PMIGRATIONDLLW);
typedef BOOL (* MIGDLLGATHERSYSTEMSETTINGSW) (PMIGRATIONDLLW, PCWSTR, PVOID, DWORD);
typedef BOOL (* MIGDLLINITIALIZESRCW) (PMIGRATIONDLLW, PCWSTR, PCWSTR, PCWSTR, PVOID, DWORD);
typedef BOOL (* MIGDLLOPENW) (PMIGRATIONDLLW, PCWSTR, BOOL, BOOL, BOOL);
typedef VOID (* MIGDLLFREELIST) (DLLLIST);
typedef BOOL (* MIGDLLENUMNEXTW) (PMIGDLLENUMW);
typedef BOOL (* MIGDLLENUMFIRSTW) (DLLLIST, PMIGDLLENUMW);
typedef BOOL (* MIGDLLREMOVEDLLINENUMFROMLISTW) (DLLLIST, PMIGDLLENUMW);
typedef BOOL (* MIGDLLADDDLLTOLISTW) (DLLLIST, PMIGRATIONDLLW);
typedef BOOL (* MIGDLLREMOVEDLLFROMLISTW) (DLLLIST, PCWSTR);
typedef PMIGDLLPROPERTIESW (* MIGDLLFINDDLLINLISTW) (DLLLIST, PCWSTR);
typedef BOOL (* MIGDLLQUERYMIGRATIONINFOW) (PMIGRATIONDLLW, PCWSTR, PMIGRATIONINFOW);
typedef DLLLIST (* MIGDLLCREATELIST) (VOID);
typedef BOOL (* MIGDLLAPPLYSYSTEMSETTINGSW) (PMIGRATIONDLLW, PCWSTR, PCWSTR, PVOID, DWORD);
typedef BOOL (* MIGDLLINITIALIZEDSTW) (PMIGRATIONDLLW, PCWSTR, PCWSTR, PVOID, DWORD);
typedef BOOL (* MIGDLLMOVEDLLLOCALLYW) (PMIGRATIONDLLW, PCWSTR);



//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Public function prototypes
//

BOOL
MigDllQueryMigrationInfoA (
    IN PMIGRATIONDLLA DllData,
    IN PCSTR WorkingDirectory,
    OUT PMIGRATIONINFOA * MigInfo
    );

BOOL
MigDllQueryMigrationInfoW (
    IN PMIGRATIONDLLW DllData,
    IN PCWSTR WorkingDirectory,
    OUT PMIGRATIONINFOW * MigInfo
    );

BOOL
MigDllApplySystemSettingsW (
    IN PMIGRATIONDLLW DllData,
    IN PCWSTR WorkingDirectory,
    IN PCWSTR AnswerFile,
    IN PVOID Reserved,
    IN DWORD ReservedSize
    );

BOOL
MigDllApplySystemSettingsA (
    IN PMIGRATIONDLLA DllData,
    IN PCSTR WorkingDirectory,
    IN PCSTR AnswerFile,
    IN PVOID Reserved,
    IN DWORD ReservedSize
    );


BOOL
MigDllApplyUserSettingsW (
    IN      PMIGRATIONDLLW DllData,
    IN      PCWSTR WorkingDir,
    IN      PCWSTR UserKey,
    IN      PCWSTR UserName,
    IN      PCWSTR UserDomain,
    IN      PCWSTR FixedUserName,
    IN      PCWSTR UnattendTxt,
    IN      PCWSTR UserProfilePath,
    IN OUT  PVOID Reserved,
    IN      DWORD ReservedSize
    );

BOOL
MigDllApplyUserSettingsA (
    IN      PMIGRATIONDLLA DllData,
    IN      PCSTR WorkingDir,
    IN      PCSTR UserKey,
    IN      PCSTR UserName,
    IN      PCSTR UserDomain,
    IN      PCSTR FixedUserName,
    IN      PCSTR UnattendTxt,
    IN      PCSTR UserProfilePath,
    IN OUT  PVOID Reserved,
    IN      DWORD ReservedSize
    );

BOOL
MigDllInitializeDstW (
    IN PMIGRATIONDLLW DllData,
    IN PCWSTR WorkingDir,
    IN PCWSTR SourceList,
    IN OUT PVOID Reserved,
    IN DWORD ReservedSize
    );

BOOL
MigDllInitializeDstA (
    IN PMIGRATIONDLLA DllData,
    IN PCSTR WorkingDir,
    IN PCSTR SourceList,
    IN OUT PVOID Reserved,
    IN DWORD ReservedSize
    );

BOOL
MigDllGatherSystemSettingsA (
    IN PMIGRATIONDLLA DllData,
    IN PCSTR AnswerFile,
    IN PVOID Reserved,
    IN DWORD ReservedSize
    );

BOOL
MigDllGatherSystemSettingsW (
    IN PMIGRATIONDLLW DllData,
    IN PCWSTR AnswerFile,
    IN PVOID Reserved,
    IN DWORD ReservedSize
    );

BOOL
MigDllGatherUserSettingsA (
    IN      PMIGRATIONDLLA DllData,
    IN      PCSTR UserKey,
    IN      PCSTR UserName,
    IN      PCSTR UnattendTxt,
    IN OUT  PVOID Reserved,
    IN      DWORD ReservedSize
    );

BOOL
MigDllGatherUserSettingsW (
    IN      PMIGRATIONDLLW DllData,
    IN      PCWSTR UserKey,
    IN      PCWSTR UserName,
    IN      PCWSTR UnattendTxt,
    IN OUT  PVOID Reserved,
    IN      DWORD ReservedSize
    );

BOOL
MigDllInitializeSrcA (
    IN PMIGRATIONDLLA DllData,
    IN PCSTR WorkingDir,
    IN PCSTR NativeSource,
    IN PCSTR MediaDir,
    IN OUT PVOID Reserved,
    IN DWORD ReservedSize
    );

BOOL
MigDllInitializeSrcW (
    IN PMIGRATIONDLLW DllData,
    IN PCWSTR WorkingDir,
    IN PCWSTR NativeSource,
    IN PCWSTR MediaDir,
    IN OUT PVOID Reserved,
    IN DWORD ReservedSize
    );

BOOL
MigDllOpenA (
    OUT PMIGRATIONDLLA DllData,
    IN PCSTR DllPath,
    IN BOOL MigrationMode,
    IN BOOL Isolated,
    IN BOOL SourceOs
    );

BOOL
MigDllOpenW (
    OUT PMIGRATIONDLLW DllData,
    IN PCWSTR DllPath,
    IN BOOL MigrationMode,
    IN BOOL Isolated,
    IN BOOL SourceOs
    );

VOID
MigDllCloseA (
    IN OUT PMIGRATIONDLLA DllData
    );

VOID
MigDllCloseW (
    IN OUT PMIGRATIONDLLW DllData
    );


DLLLIST
MigDllCreateList (
    VOID
    );

VOID
MigDllFreeList (
    DLLLIST List
    );

BOOL
MigDllAddDllToListA (
    IN DLLLIST List,
    IN PMIGRATIONDLLA MigrationDll
    );

BOOL
MigDllAddDllToListW (
    IN DLLLIST List,
    IN PMIGRATIONDLLW MigrationDll
    );


BOOL
MigDllRemoveDllFromListA (
    IN DLLLIST List,
    IN PCSTR ProductId
    );

BOOL
MigDllRemoveDllFromListW (
    IN DLLLIST List,
    IN PCWSTR ProductId
    );


INT
MigDllGetDllCountInList (
    IN DLLLIST List
    );

PMIGDLLPROPERTIESA
MigDllFindDllInListA (
    IN DLLLIST List,
    IN PCSTR ProductId
    );

PMIGDLLPROPERTIESW
MigDllFindDllInListW (
    IN DLLLIST List,
    IN PCWSTR ProductId
    );


BOOL
MigDllEnumNextA (
    IN OUT PMIGDLLENUMA Enum
    );

BOOL
MigDllEnumFirstA (
    OUT PMIGDLLENUMA Enum,
    IN DLLLIST List
    );

BOOL
MigDllRemoveDllInEnumFromListA (
    IN DLLLIST List,
    IN PMIGDLLENUMA Enum
    );

BOOL
MigDllEnumNextW (
    IN OUT PMIGDLLENUMW Enum
    );

BOOL
MigDllEnumFirstW (
    OUT PMIGDLLENUMW Enum,
    IN DLLLIST List
    );

BOOL
MigDllRemoveDllInEnumFromListW (
    IN DLLLIST List,
    IN PMIGDLLENUMW Enum
    );


VOID
MigDllSetMigIsolPathA (
    IN PCSTR Path
    );

VOID
MigDllSetMigIsolPathW (
    IN PCWSTR Path
    );


BOOL
MigDllMoveDllLocallyW (
    IN PMIGRATIONDLLW Dll,
    IN PCWSTR WorkingDirectory
    );


BOOL
MigDllInit (
    VOID
    );

VOID
MigDllShutdown (
    VOID
    );


//
// Macro expansion definition
//

// None

//
// ANSI/UNICODE macros
//

#ifdef UNICODE
//UNICODE
#define MigDllQueryMigrationInfo MigDllQueryMigrationInfoW
#define MigDllApplySystemSettings MigDllApplySystemSettingsW
#define MigDllApplyUserSettings MigDllApplyUserSettingsW
#define MigDllInitializeDst MigDllInitializeDstW
#define MigDllGatherSystemSettings MigDllGatherSystemSettingsW
#define MigDllGatherUserSettings MigDllGatherUserSettingsW
#define MigDllInitializeSrc MigDllInitializeSrcW
#define MigDllOpen MigDllOpenW
#define MigDllClose MigDllCloseW
#define MigDllAddDllToList MigDllAddDllToListW
#define MigDllRemoveDllFromList MigDllRemoveDllFromListW
#define MigDllFindDllInList MigDllFindDllInListW
#define MigDllEnumNext MigDllEnumNextW
#define MigDllEnumFirst MigDllEnumFirstW
#define MigDllRemoveDllInEnumFromList MigDllRemoveDllInEnumFromListW
#define MigDllSetMigIsolPath MigDllSetMigIsolPathW
#define MigDllMoveDllLocally MigDllMoveDllLocallyW
#define MIGRATIONINFO MIGRATIONINFOW
#define PMIGRATIONINFO PMIGRATIONINFOW
#define MIGDLLPROPERTIES MIGDLLPROPERTIESW
#define PMIGDLLPROPERTIES PMIGDLLPROPERTIESW
#define MIGRATIONDLL MIGRATIONDLLW
#define PMIGRATIONDLL PMIGRATIONDLLW
#define MIGDLLENUM MIGDLLENUMW
#define PMIGDLLENUM PMIGDLLENUMW

#else
//ANSI
#define MigDllQueryMigrationInfo MigDllQueryMigrationInfoA
#define MigDllApplySystemSettings MigDllApplySystemSettingsA
#define MigDllApplyUserSettings MigDllApplyUserSettingsA
#define MigDllInitializeDst MigDllInitializeDstA
#define MigDllGatherSystemSettings MigDllGatherSystemSettingsA
#define MigDllGatherUserSettings MigDllGatherUserSettingsA
#define MigDllInitializeSrc MigDllInitializeSrcA
#define MigDllOpen MigDllOpenA
#define MigDllClose MigDllCloseA
#define MigDllAddDllToList MigDllAddDllToListA
#define MigDllRemoveDllFromList MigDllRemoveDllFromListA
#define MigDllFindDllInList MigDllFindDllInListA
#define MigDllEnumNext MigDllEnumNextA
#define MigDllEnumFirst MigDllEnumFirstA
#define MigDllRemoveDllInEnumFromList MigDllRemoveDllInEnumFromListA
#define MigDllSetMigIsolPath MigDllSetMigIsolPathA
#define MIGRATIONINFO MIGRATIONINFOA
#define PMIGRATIONINFO PMIGRATIONINFOA
#define MIGDLLPROPERTIES MIGDLLPROPERTIESA
#define PMIGDLLPROPERTIES PMIGDLLPROPERTIESA
#define MIGRATIONDLL MIGRATIONDLLA
#define PMIGRATIONDLL PMIGRATIONDLLA
#define MIGDLLENUM MIGDLLENUMA
#define PMIGDLLENUM PMIGDLLENUMA
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inc\n98boot.h ===
typedef
BOOL
(CALLBACK WINNT32_PLUGIN_SETAUTOBOOT_ROUTINE_PROTOTYPE)(
    int
    );

typedef WINNT32_PLUGIN_SETAUTOBOOT_ROUTINE_PROTOTYPE * PWINNT32_PLUGIN_SETAUTOBOOT_ROUTINE;

/*++

Routine Description:

    This routine is called by winnt32 in the case where installation is
    finished all setup proccess..

Arguments:

    int bDrvLetter

Return Value:

    if ERROR, returned FALSE.

--*/

WINNT32_PLUGIN_SETAUTOBOOT_ROUTINE_PROTOTYPE Winnt32SetAutoBoot;


#define WINNT32_PLUGIN_SETAUTOBOOT_NAME     "Winnt32SetAutoBoot"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inc\hwdb.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    hwcomp.h

Abstract:

    Module's interface.

Author:

    Ovidiu Temereanca (ovidiut) 04-Jul-2000  Initial implementation

Revision History:

--*/


//
// Interface
//

BOOL
WINAPI
HwdbInitializeA (
    IN      PCSTR TempDir
    );

BOOL
WINAPI
HwdbInitializeW (
    IN      PCWSTR TempDir
    );

VOID
WINAPI
HwdbTerminate (
    VOID
    );

HANDLE
WINAPI
HwdbOpenA (
    IN      PCSTR DatabaseFile
    );

HANDLE
WINAPI
HwdbOpenW (
    IN      PCWSTR DatabaseFile
    );

VOID
WINAPI
HwdbClose (
    IN      HANDLE Hwdb
    );


typedef
BOOL
(*HWDBAPPENDINFSCALLBACKA) (
    IN      PVOID Context,
    IN      PCSTR PnpId,
    IN      PCSTR ActualInfFilename,
    IN      PCSTR SourceDir,
    IN      PCSTR FullInfPath
    );

BOOL
WINAPI
HwdbAppendInfsA (
    IN      HANDLE Hwdb,
    IN      PCSTR SourceDirectory,
    IN      HWDBAPPENDINFSCALLBACKA Callback,       OPTIONAL
    IN      PVOID CallbackContext                   OPTIONAL
    );

typedef
BOOL
(*HWDBAPPENDINFSCALLBACKW) (
    IN      PVOID Context,
    IN      PCWSTR PnpId,
    IN      PCWSTR ActualInfFilename,
    IN      PCWSTR SourceDir,
    IN      PCWSTR FullInfPath
    );

BOOL
WINAPI
HwdbAppendInfsW (
    IN      HANDLE Hwdb,
    IN      PCWSTR SourceDirectory,
    IN      HWDBAPPENDINFSCALLBACKW Callback,       OPTIONAL
    IN      PVOID CallbackContext                   OPTIONAL
    );

BOOL
WINAPI
HwdbAppendDatabase (
    IN      HANDLE HwdbTarget,
    IN      HANDLE HwdbSource
    );

BOOL
WINAPI
HwdbFlushA (
    IN      HANDLE Hwdb,
    IN      PCSTR OutputFile
    );

BOOL
WINAPI
HwdbFlushW (
    IN      HANDLE Hwdb,
    IN      PCWSTR OutputFile
    );

BOOL
WINAPI
HwdbHasDriverA (
    IN      HANDLE Hwdb,
    IN      PCSTR PnpId,
    OUT     PBOOL Unsupported
    );

BOOL
WINAPI
HwdbHasDriverW (
    IN      HANDLE Hwdb,
    IN      PCWSTR PnpId,
    OUT     PBOOL Unsupported
    );

BOOL
WINAPI
HwdbHasAnyDriverA (
    IN      HANDLE Hwdb,
    IN      PCSTR PnpIds,
    OUT     PBOOL Unsupported
    );

BOOL
WINAPI
HwdbHasAnyDriverW (
    IN      HANDLE Hwdb,
    IN      PCWSTR PnpIds,
    OUT     PBOOL Unsupported
    );

typedef
BOOL
(WINAPI* PHWDBINITIALIZEA) (
    IN      PCSTR TempDir
    );

typedef
BOOL
(WINAPI* PHWDBINITIALIZEW) (
    IN      PCWSTR TempDir
    );

typedef
VOID
(WINAPI* PHWDBTERMINATE) (
    VOID
    );

typedef
HANDLE
(WINAPI* PHWDBOPENA) (
    IN      PCSTR DatabaseFile
    );

typedef
HANDLE
(WINAPI* PHWDBOPENW) (
    IN      PCWSTR DatabaseFile
    );

typedef
VOID
(WINAPI* PHWDBCLOSE) (
    IN      HANDLE Hwdb
    );

typedef
BOOL
(WINAPI* PHWDBAPPENDINFSA) (
    IN      HANDLE Hwdb,
    IN      PCSTR SourceDirectory,
    IN      HWDBAPPENDINFSCALLBACKA Callback,       OPTIONAL
    IN      PVOID CallbackContext                   OPTIONAL
    );

typedef
BOOL
(WINAPI* PHWDBAPPENDINFSW) (
    IN      HANDLE Hwdb,
    IN      PCWSTR SourceDirectory,
    IN      HWDBAPPENDINFSCALLBACKW Callback,       OPTIONAL
    IN      PVOID CallbackContext                   OPTIONAL
    );

typedef
BOOL
(WINAPI* PHWDBAPPENDDATABASE) (
    IN      HANDLE HwdbTarget,
    IN      HANDLE HwdbSource
    );

typedef
BOOL
(WINAPI* PHWDBFLUSHA) (
    IN      HANDLE Hwdb,
    IN      PCSTR OutputFile
    );

typedef
BOOL
(WINAPI* PHWDBFLUSHW) (
    IN      HANDLE Hwdb,
    IN      PCWSTR OutputFile
    );

typedef
BOOL
(WINAPI* PHWDBHASDRIVERA) (
    IN      HANDLE Hwdb,
    IN      PCSTR PnpId,
    OUT     PBOOL Unsupported
    );

typedef
BOOL
(WINAPI* PHWDBHASDRIVERW) (
    IN      HANDLE Hwdb,
    IN      PCWSTR PnpId,
    OUT     PBOOL Unsupported
    );


typedef
BOOL
(WINAPI* PHWDBHASANYDRIVERA) (
    IN      HANDLE Hwdb,
    IN      PCSTR PnpId,
    OUT     PBOOL Unsupported
    );

typedef
BOOL
(WINAPI* PHWDBHASANYDRIVERW) (
    IN      HANDLE Hwdb,
    IN      PCWSTR PnpId,
    OUT     PBOOL Unsupported
    );

#if 0

typedef
BOOL
(WINAPI* PHWDBENUM_CALLBACKA) (
    IN      PVOID UserContext,
    IN      PCSTR PnpId,
    IN      PCSTR InfFileName
    );

typedef
BOOL
(WINAPI* PHWDBENUM_CALLBACKW) (
    IN      PVOID UserContext,
    IN      PCWSTR PnpId,
    IN      PCWSTR InfFileName
    );

BOOL
HwdbEnumeratePnpIdA (
    IN      HANDLE Hwdb,
    IN      PHWDBENUM_CALLBACKA EnumCallback,
    IN      PVOID UserContext
    );

BOOL
HwdbEnumeratePnpIdW (
    IN      HANDLE Hwdb,
    IN      PHWDBENUM_CALLBACKW EnumCallback,
    IN      PVOID UserContext
    );

typedef
BOOL
(WINAPI* PHWDBENUMERATEPNPIDA) (
    IN      HANDLE Hwdb,
    IN      PHWDBENUM_CALLBACKA EnumCallback,
    IN      PVOID UserContext
    );

typedef
BOOL
(WINAPI* PHWDBENUMERATEPNPIDW) (
    IN      HANDLE Hwdb,
    IN      PHWDBENUM_CALLBACKW EnumCallback,
    IN      PVOID UserContext
    );

#endif

typedef struct {
    CHAR InfFile[MAX_PATH];
    PCSTR PnpIds;
    PVOID Internal;
} HWDBINF_ENUMA, *PHWDBINF_ENUMA;

typedef struct {
    PCWSTR InfFile;
    PCWSTR PnpIds;
    PVOID Internal;
} HWDBINF_ENUMW, *PHWDBINF_ENUMW;


BOOL
HwdbEnumFirstInfA (
    OUT     PHWDBINF_ENUMA EnumPtr,
    IN      PCSTR DatabaseFile
    );

BOOL
HwdbEnumFirstInfW (
    OUT     PHWDBINF_ENUMW EnumPtr,
    IN      PCWSTR DatabaseFile
    );

BOOL
HwdbEnumNextInfA (
    IN OUT  PHWDBINF_ENUMA EnumPtr
    );

BOOL
HwdbEnumNextInfW (
    IN OUT  PHWDBINF_ENUMW EnumPtr
    );

VOID
HwdbAbortEnumInfA (
    IN OUT  PHWDBINF_ENUMA EnumPtr
    );

VOID
HwdbAbortEnumInfW (
    IN OUT  PHWDBINF_ENUMW EnumPtr
    );

//
// exported function names
//
#define S_HWDBAPI_HWDBINITIALIZE_A      "HwdbInitializeA"
#define S_HWDBAPI_HWDBINITIALIZE_W      "HwdbInitializeW"
#define S_HWDBAPI_HWDBTERMINATE         "HwdbTerminate"
#define S_HWDBAPI_HWDBOPEN_A            "HwdbOpenA"
#define S_HWDBAPI_HWDBOPEN_W            "HwdbOpenW"
#define S_HWDBAPI_HWDBCLOSE             "HwdbClose"
#define S_HWDBAPI_HWDBAPPENDINFS_A      "HwdbAppendInfsA"
#define S_HWDBAPI_HWDBAPPENDINFS_W      "HwdbAppendInfsW"
#define S_HWDBAPI_HWDBAPPENDDATABASE    "HwdbAppendDatabase"
#define S_HWDBAPI_HWDBFLUSH_A           "HwdbFlushA"
#define S_HWDBAPI_HWDBFLUSH_W           "HwdbFlushW"
#define S_HWDBAPI_HWDBHASDRIVER_A       "HwdbHasDriverA"
#define S_HWDBAPI_HWDBHASDRIVER_W       "HwdbHasDriverW"
#define S_HWDBAPI_HWDBHASANYDRIVER_A    "HwdbHasAnyDriverA"
#define S_HWDBAPI_HWDBHASANYDRIVER_W    "HwdbHasAnyDriverW"

typedef struct {
    PHWDBINITIALIZEA HwdbInitialize;
    PHWDBTERMINATE HwdbTerminate;
    PHWDBOPENA HwdbOpen;
    PHWDBCLOSE HwdbClose;
    PHWDBAPPENDINFSA HwdbAppendInfs;
    PHWDBFLUSHA HwdbFlush;
    PHWDBHASDRIVERA HwdbHasDriver;
    PHWDBHASANYDRIVERA HwdbHasAnyDriver;
} HWDB_ENTRY_POINTSA, *PHWDB_ENTRY_POINTSA;

typedef struct {
    PHWDBINITIALIZEW HwdbInitialize;
    PHWDBTERMINATE HwdbTerminate;
    PHWDBOPENW HwdbOpen;
    PHWDBCLOSE HwdbClose;
    PHWDBAPPENDINFSW HwdbAppendInfs;
    PHWDBFLUSHW HwdbFlush;
    PHWDBHASDRIVERW HwdbHasDriver;
    PHWDBHASANYDRIVERW HwdbHasAnyDriver;
} HWDB_ENTRY_POINTSW, *PHWDB_ENTRY_POINTSW;

#ifdef UNICODE

#define S_HWDBAPI_HWDBINITIALIZE        S_HWDBAPI_HWDBINITIALIZE_W
#define PHWDBINITIALIZE                 PHWDBINITIALIZEW
#define S_HWDBAPI_HWDBOPEN              S_HWDBAPI_HWDBOPEN_W
#define PHWDBOPEN                       PHWDBOPENW
#define S_HWDBAPI_HWDBAPPENDINFS        S_HWDBAPI_HWDBAPPENDINFS_W
#define PHWDBAPPENDINFS                 PHWDBAPPENDINFSW
#define S_HWDBAPI_HWDBFLUSH             S_HWDBAPI_HWDBFLUSH_W
#define PHWDBFLUSH                      PHWDBFLUSHW
#define S_HWDBAPI_HWDBHASDRIVER         S_HWDBAPI_HWDBHASDRIVER_W
#define PHWDBHASDRIVER                  PHWDBHASDRIVERW
#define S_HWDBAPI_HWDBHASANYDRIVER      S_HWDBAPI_HWDBHASANYDRIVER_W
#define PHWDBHASANYDRIVER               PHWDBHASANYDRIVERW
#define HWDBINF_ENUM                    HWDBINF_ENUMW
#define PHWDBINF_ENUM                   PHWDBINF_ENUMW
#define HwdbEnumFirstInf                HwdbEnumFirstInfW
#define HwdbEnumNextInf                 HwdbEnumNextInfW
#define HwdbAbortEnumInf                HwdbAbortEnumInfW
#define HWDB_ENTRY_POINTS               HWDB_ENTRY_POINTSW
#define PHWDB_ENTRY_POINTS              PHWDB_ENTRY_POINTSW

#else

#define S_HWDBAPI_HWDBINITIALIZE        S_HWDBAPI_HWDBINITIALIZE_A
#define PHWDBINITIALIZE                 PHWDBINITIALIZEA
#define S_HWDBAPI_HWDBOPEN              S_HWDBAPI_HWDBOPEN_A
#define PHWDBOPEN                       PHWDBOPENA
#define S_HWDBAPI_HWDBAPPENDINFS        S_HWDBAPI_HWDBAPPENDINFS_A
#define PHWDBAPPENDINFS                 PHWDBAPPENDINFSA
#define S_HWDBAPI_HWDBFLUSH             S_HWDBAPI_HWDBFLUSH_A
#define PHWDBFLUSH                      PHWDBFLUSHA
#define S_HWDBAPI_HWDBHASDRIVER         S_HWDBAPI_HWDBHASDRIVER_A
#define PHWDBHASDRIVER                  PHWDBHASDRIVERA
#define S_HWDBAPI_HWDBHASANYDRIVER      S_HWDBAPI_HWDBHASANYDRIVER_A
#define PHWDBHASANYDRIVER               PHWDBHASANYDRIVERA
#define HWDBINF_ENUM                    HWDBINF_ENUMA
#define PHWDBINF_ENUM                   PHWDBINF_ENUMA
#define HwdbEnumFirstInf                HwdbEnumFirstInfA
#define HwdbEnumNextInf                 HwdbEnumNextInfA
#define HwdbAbortEnumInf                HwdbAbortEnumInfA
#define HWDB_ENTRY_POINTS               HWDB_ENTRY_POINTSA
#define PHWDB_ENTRY_POINTS              PHWDB_ENTRY_POINTSA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inc\hwlog.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    ntsetup\inc\hwlog.h

Abstract:

    Logging some aspects of the hardware configuration to winnt32.log.
    Esp. disk drive by connection, and map drive letters to disk drives.

Author:

    Jay Krell (JayKrell) April 2001, May 2001

Revision History:

Environment:

    winnt32.dll -- Win9x ANSI (down to Win95gold) or NT Unicode
                   libcmt statically linked in, _tcs* ok
                   actually only built for Unicode/NT, and does nothing
                   if run on less than Windows 2000

    setup.exe -newsetup -- guimode setup
--*/

struct _SP_LOG_HARDWARE_IN;

#include "setupapi.h"

typedef struct _SP_LOG_HARDWARE_IN {
    PCTSTR MachineName OPTIONAL;
    HANDLE LogFile OPTIONAL;
    BOOL (WINAPI  * SetupLogError)(PCTSTR MessageString, LogSeverity) OPTIONAL;
    BOOL (__cdecl * SetuplogError)(
        IN  LogSeverity         Severity,
        IN  LPCTSTR             MessageString,
        IN  UINT                MessageId,      OPTIONAL
        ...
        ) OPTIONAL;
} SP_LOG_HARDWARE_IN, *PSP_LOG_HARDWARE_IN;
typedef CONST SP_LOG_HARDWARE_IN* PCSP_LOG_HARDWARE_IN;

VOID
SpLogHardware(
    PSP_LOG_HARDWARE_IN In
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inc\spidgen.h ===
/*
These routines are used so that syssetup and winnt32 will be able
to call PIDGen with a hardcoded pid for the appropriate select
version.
//marrq want the bottom line?
This header should only be included if pidgen.h was also included
*/

#if defined(WIN32) || defined(_WIN32)

    #ifdef UNICODE
        #define SetupPIDGen  SetupPIDGenW
    #else
        #define SetupPIDGen  SetupPIDGenA
    #endif // UNICODE

#else

    #include <string.h>
    #include <compobj.h>

    typedef BOOL NEAR *PBOOL;
    typedef BOOL FAR *LPBOOL;

    typedef FILETIME FAR *LPFILETIME;

    #define SetupPIDGenA SetupPIDGen
    #define lstrlenA lstrlen
    #define lstrcpyA lstrcpy
    #define wsprintfA wsprintf

    #define TEXT(s) __T(s)

    #define ZeroMemory(pb, cb) memset(pb, 0, cb)
    #define CopyMemory(pb, ab, cb) memcpy(pb, ab, cb)


#endif // defined(WIN32) || defined(_WIN32)


BOOL STDAPICALLTYPE SetupPIDGenW(
    LPWSTR  lpstrSecureCdKey,   // [IN] 25-character Secure CD-Key (gets U-Cased)
    LPCWSTR lpstrMpc,           // [IN] 5-character Microsoft Product Code
    LPCWSTR lpstrSku,           // [IN] Stock Keeping Unit (formatted like 123-12345)
    BOOL   fOem,                // [IN] is this an OEM install?
    LPWSTR lpstrPid2,           // [OUT] PID 2.0, pass in ptr to 24 character array
    LPBYTE  lpbDigPid,          // [IN/OUT] pointer to DigitalPID buffer. First DWORD is the length
    LPBOOL  pfCCP);              // [OUT] optional ptr to Compliance Checking flag (can be NULL)


BOOL STDAPICALLTYPE SetupPIDGenA(
    LPSTR   lpstrSecureCdKey,   // [IN] 25-character Secure CD-Key (gets U-Cased)
    LPCSTR  lpstrMpc,           // [IN] 5-character Microsoft Product Code
    LPCSTR  lpstrSku,           // [IN] Stock Keeping Unit (formatted like 123-12345)
    BOOL    fOem,               // [IN] is this an OEM install?
    LPSTR   lpstrPid2,          // [OUT] PID 2.0, pass in ptr to 24 character array
    LPBYTE  lpbDigPid,          // [IN/OUT] pointer to DigitalPID buffer. First DWORD is the length
    LPBOOL  pfCCP);              // [OUT] optional ptr to Compliance Checking flag (can be NULL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inc\wsdu.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    wsdu.h

Abstract:

    Interface to a Dynamic Update support control for Winnt32.

Author:

    Ovidiu Temereanca (ovidiut) 06-Jul-2000

Revision History:

    <alias>  <date>      <comment>

--*/

BOOL
WINAPI
DuIsSupported (
    VOID
    );

typedef
BOOL
(WINAPI* PDUISSUPPORTED) (
    VOID
    );


#define SETUPQUERYID_PNPID          1

typedef struct {
    BOOL Handled;
    BOOL Unsupported;
} PNPID_INFO, *PPNPID_INFO;

#define SETUPQUERYID_DOWNLOADDRIVER 2

// Dynamic Update Custom Error Codes
#define DU_ERROR_MISSING_DLL        12001L
#define DU_NOT_INITIALIZED          12002L
#define DU_ERROR_ASYNC_FAIL         12003L


typedef BOOL (WINAPI* PWINNT32QUERY) (
    IN      DWORD SetupQueryId,
    IN      PVOID InData,
    IN      DWORD InDataSize,
    IN OUT  PVOID OutData,          OPTIONAL
    IN OUT  PDWORD OutDataSize
    );


HANDLE
WINAPI
DuInitializeA (
    IN      PCSTR BaseDir,
    IN      PCSTR TempDir,
    IN      POSVERSIONINFOEXA TargetOsVersion,
    IN      PCSTR TargetPlatform,                 // "i386", "ia64"
    IN      LCID TargetLCID,
    IN      BOOL Unattend,
    IN      BOOL Upgrade,
    IN      PWINNT32QUERY Winnt32QueryCallback
	);

typedef
HANDLE
(WINAPI* PDUINITIALIZEA) (
    IN      PCSTR BaseDir,
    IN      PCSTR TempDir,
    IN      POSVERSIONINFOEXA TargetOsVersion,
    IN      PCSTR TargetPlatform,                 // "i386", "ia64"
    IN      LCID TargetLCID,
    IN      BOOL Unattend,
    IN      BOOL Upgrade,
    IN      PWINNT32QUERY Winnt32QueryCallback
	);


HANDLE
WINAPI
DuInitializeW (
    IN      PCWSTR BaseDir,
    IN      PCWSTR TempDir,
    IN      POSVERSIONINFOEXW TargetOsVersion,
    IN      PCWSTR TargetPlatform,                 // "i386", "ia64"
    IN      LCID TargetLCID,
    IN      BOOL Unattend,
    IN      BOOL Upgrade,
    IN      PWINNT32QUERY Winnt32QueryCallback
	);

typedef
HANDLE
(WINAPI* PDUINITIALIZEW) (
    IN      PCWSTR BaseDir,
    IN      PCWSTR TempDir,
    IN      POSVERSIONINFOEXW TargetOsVersion,
    IN      PCWSTR TargetPlatform,                 // "i386", "ia64"
    IN      LCID TargetLCID,
    IN      BOOL Unattend,
    IN      BOOL Upgrade,
    IN      PWINNT32QUERY Winnt32QueryCallback
	);

#ifdef UNICODE
#define DuInitialize        DuInitializeW
#define PDUINITIALIZE       PDUINITIALIZEW
#else
#define DuInitialize        DuInitializeA
#define PDUINITIALIZE       PDUINITIALIZEA
#endif


BOOL
WINAPI
DuDoDetection (
    IN      HANDLE hConnection,
    OUT     PDWORD TotalEstimatedTime,
    OUT     PDWORD TotalEstimatedSize
    );

typedef
BOOL
(WINAPI* PDUDODETECTION) (
    IN      HANDLE hConnection,
    OUT     PDWORD TotalEstimatedTime,
    OUT     PDWORD TotalEstimatedSize
    );

BOOL
WINAPI
DuQueryUnsupportedDriversA (
    IN      HANDLE hConnection,
    IN      PCSTR* ListOfUnsupportedDrivers,
    OUT     PDWORD TotalEstimatedTime,
    OUT     PDWORD TotalEstimatedSize
    );

typedef
BOOL
(WINAPI* PDUQUERYUNSUPDRVSA) (
    IN      HANDLE hConnection,
    IN      PCSTR* ListOfUnsupportedDrivers,
    OUT     PDWORD TotalEstimatedTime,
    OUT     PDWORD TotalEstimatedSize
    );

BOOL
WINAPI
DuQueryUnsupportedDriversW (
    IN      HANDLE hConnection,
    IN      PCWSTR* ListOfUnsupportedDrivers,
    OUT     PDWORD TotalEstimatedTime,
    OUT     PDWORD TotalEstimatedSize
    );

typedef
BOOL
(WINAPI* PDUQUERYUNSUPDRVSW) (
    IN      HANDLE hConnection,
    IN      PCWSTR* ListOfUnsupportedDrivers,
    OUT     PDWORD TotalEstimatedTime,
    OUT     PDWORD TotalEstimatedSize
    );

#ifdef UNICODE
#define DuQueryUnsupportedDrivers   DuQueryUnsupportedDriversW
#define PDUQUERYUNSUPDRVS           PDUQUERYUNSUPDRVSW
#else
#define DuQueryUnsupportedDrivers   DuQueryUnsupportedDriversA
#define PDUQUERYUNSUPDRVS           PDUQUERYUNSUPDRVSA
#endif

BOOL
WINAPI
DuBeginDownload (
    IN      HANDLE hConnection,
    IN      HWND hwndNotify
    );

typedef
BOOL
(WINAPI* PDUBEGINDOWNLOAD) (
    IN      HANDLE hConnection,
    IN      HWND hwndNotify
    );

VOID
WINAPI
DuAbortDownload (
    IN      HANDLE hConnection
    );

typedef
VOID
(WINAPI* PDUABORTDOWNLOAD) (
    IN      HANDLE hConnection
    );

DWORD
WINAPI
DuUninitialize (
    IN      HANDLE hConnection
    );

typedef
DWORD
(WINAPI* PDUUNINITIALIZE) (
    IN      HANDLE hConnection
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inc\pidgen.h ===
/*++

Copyright (c) 1998-1999, Microsoft Corporation

Module Name:


    PIDGen.h

Abstract:

    public header

--*/

#ifdef __cplusplus
extern "C" {
#endif

#if defined(WIN32) || defined(_WIN32)

    #ifdef UNICODE
        #define PIDGen  PIDGenW
        #define PIDGenSimp  PIDGenSimpW
    #else
        #define PIDGen  PIDGenA
        #define PIDGenSimp  PIDGenSimpA
    #endif // UNICODE

#else

    #include <string.h>
    #include <compobj.h>

    typedef BOOL NEAR *PBOOL;
    typedef BOOL FAR *LPBOOL;

    typedef FILETIME FAR *LPFILETIME;

    #define PIDGenA PIDGen
    #define lstrlenA lstrlen
    #define lstrcpyA lstrcpy
    #define wsprintfA wsprintf

    #define TEXT(s) __T(s)

    #define ZeroMemory(pb, cb) memset(pb, 0, cb)
    #define CopyMemory(pb, ab, cb) memcpy(pb, ab, cb)


#endif // defined(WIN32) || defined(_WIN32)

#define DIGITALPIDMAXLEN 256 // Max length of digital PID 3.0 data blob

#define INVALID_PID 0xFFFFFFFF

// PidGenSimp error code values

enum PidGenError { // pge

    //  Call succeded
    pgeSuccess = 0,

    //  Unable to validate product key.  Most likely causes:
    //      * Product Key was mistyped by user
    //      * Product Key not compatable with this .dll (wrong GroupId)
    pgeProductKeyInvalid = 1,

    //  Product Key's sequence number is not allowed by this .dll.
    //  Most likely causes:
    //      * Using Select or MSDN key with a PidGen/PidCa
    //        that specifically excludes them
    pgeProductKeyExcluded = 2,

    //  NULL was passed in for the required Product Key. (Must
    //  point to valid Product key.)
    pgeProductKeyNull = 3,

    //  Product Key is wrong length.  After removing any dashes, the length
    //  is required to be 25 characters
    pgeProductKeyBadLen = 4,

    //  NULL was passed in for the required SKU. (Must point to
    //  valid SKU.)
    pgeSkuNull = 5,

    //  SKU is wrong length (too long).
    pgeSkuBadLen = 6,


    //  NULL was passed in for the required PID2. (Must
    //  point to buffer for return PID.)
    pgePid2Null = 7,

    //  NULL was passed in for the required DigPid. (Must
    //  point to buffer for generated DigitalPID.)
    pgeDigPidNull = 8,

    //  DigPid is wrong length (too small).
    pgeDigPidBadLen = 9,

    //  NULL was passed in for the required MPC.
    pgeMpcNull = 10,

    //  MPC is wrong length. Must be exactly 5 characters.
    pgeMpcBadLen = 11,

    //  OemId is bad. If passed (it's not required) it must
    //  be 4 characters.
    pgeOemIdBadLen = 12,

    //  Local char set is bad. If provided, must be 24 characters.
    pgeLocalBad = 13,
};

/*++

Routine Description:

    This routine will determine if a sequence is valid for a particular sku.

Return Value:

    pgeSuccess if sequence is in range.
    pgeProductKeyExcluded if sequence is not in range.
    pgeProductKeyInvalid if range table not found.

--*/
DWORD STDAPICALLTYPE VerifyPIDSequenceW( 
    IN BOOL  fOem,              // [IN] is this an OEM install?
    IN DWORD dwSeq,             // [IN] Sequence to check.
    IN PCWSTR pszSKU             // [IN] Null terminated string for the SKU
    );

// Original, outdated, interface to PidGen

BOOL STDAPICALLTYPE PIDGenA(
    LPSTR   lpstrSecureCdKey,   // [IN] 25-character Secure CD-Key (gets U-Cased)
    LPCSTR  lpstrMpc,           // [IN] 5-character Microsoft Product Code
    LPCSTR  lpstrSku,           // [IN] Stock Keeping Unit (formatted like 123-12345)
    LPCSTR  lpstrOemId,         // [IN] 4-character OEM ID or NULL
    LPSTR   lpstrLocal24,       // [IN] 24-character ordered set to use for decode base conversion or NULL for default set (gets U-Cased)
    LPBYTE  lpbPublicKey,       // [IN] pointer to optional public key or NULL
    DWORD   dwcbPublicKey,      // [IN] byte length of optional public key
    DWORD   dwKeyIdx,           // [IN] key pair index optional public key
    BOOL    fOem,               // [IN] is this an OEM install?

    LPSTR   lpstrPid2,          // [OUT] PID 2.0, pass in ptr to 24 character array
    LPBYTE  lpbDigPid,          // [IN/OUT] pointer to DigitalPID buffer. First DWORD is the length
    LPDWORD lpdwSeq,            // [OUT] optional ptr to sequence number (can be NULL)
    LPBOOL  pfCCP,              // [OUT] optional ptr to Compliance Checking flag (can be NULL)
    LPBOOL  pfPSS);             // [OUT] optional ptr to 'PSS Assigned' flag (can be NULL)


// Simplified interface to PidGen

DWORD STDAPICALLTYPE PIDGenSimpA(
    LPSTR   lpstrSecureCdKey,   // [IN] 25-character Secure CD-Key (gets U-Cased)
    LPCSTR  lpstrMpc,           // [IN] 5-character Microsoft Product Code
    LPCSTR  lpstrSku,           // [IN] Stock Keeping Unit (formatted like 123-12345)
    LPCSTR  lpstrOemId,         // [IN] 4-character OEM ID or NULL
    BOOL    fOem,               // [IN] is this an OEM install?

    LPSTR   lpstrPid2,          // [OUT] PID 2.0, pass in ptr to 24 character array
    LPBYTE  lpbDigPid,          // [IN/OUT] pointer to DigitalPID buffer. First DWORD is the length
    LPDWORD lpdwSeq,            // [OUT] optional ptr to sequence number or NULL
    LPBOOL  pfCCP);             // [OUT] ptr to Compliance Checking flag or NULL

#if defined(WIN32) || defined(_WIN32)


// Original, outdated, interface to PidGen

BOOL STDAPICALLTYPE PIDGenW(
    LPWSTR  lpstrSecureCdKey,   // [IN] 25-character Secure CD-Key (gets U-Cased)
    LPCWSTR lpstrMpc,           // [IN] 5-character Microsoft Product Code
    LPCWSTR lpstrSku,           // [IN] Stock Keeping Unit (formatted like 123-12345)
    LPCWSTR lpstrOemId,         // [IN] 4-character OEM ID or NULL
    LPWSTR  lpstrLocal24,       // [IN] 24-character ordered set to use for decode base conversion or NULL for default set (gets U-Cased)
    LPBYTE lpbPublicKey,        // [IN] pointer to optional public key or NULL
    DWORD  dwcbPublicKey,       // [IN] byte length of optional public key
    DWORD  dwKeyIdx,            // [IN] key pair index optional public key
    BOOL   fOem,                // [IN] is this an OEM install?

    LPWSTR lpstrPid2,           // [OUT] PID 2.0, pass in ptr to 24 character array
    LPBYTE  lpbDigPid,          // [IN/OUT] pointer to DigitalPID buffer. First DWORD is the length
    LPDWORD lpdwSeq,            // [OUT] optional ptr to sequence number (can be NULL)
    LPBOOL  pfCCP,              // [OUT] optional ptr to Compliance Checking flag (can be NULL)
    LPBOOL  pfPSS);             // [OUT] optional ptr to 'PSS Assigned' flag (can be NULL)


// Simplified interface to PidGen

DWORD STDAPICALLTYPE PIDGenSimpW(
    LPWSTR  lpstrSecureCdKey,   // [IN] 25-character Secure CD-Key (gets U-Cased)
    LPCWSTR lpstrMpc,           // [IN] 5-character Microsoft Product Code
    LPCWSTR lpstrSku,           // [IN] Stock Keeping Unit (formatted like 123-12345)
    LPCWSTR lpstrOemId,         // [IN] 4-character OEM ID or NULL
    BOOL    fOem,               // [IN] is this an OEM install?

    LPWSTR  lpstrPid2,          // [OUT] PID 2.0, pass in ptr to 24 character array
    LPBYTE  lpbDigPid,          // [IN/OUT] pointer to DigitalPID buffer. First DWORD is the length
    LPDWORD lpdwSeq,            // [OUT] optional ptr to sequence number or NULL
    LPBOOL  pfCCP);             // [OUT] ptr to Compliance Checking flag or NULL

#endif // defined(WIN32) || defined(_WIN32)

extern HINSTANCE g_hinst;

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inc\setupsxs.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    SetupSxs.h

Abstract:

    Shared declarations for setup's Side by Side support.

Author:

    Jay Krell (a-JayK) May 2000

Revision History:

--*/

/* These strings appear in .inf/.inx files, so you can't just change them
here and rebuild and expect it to work. */
#define SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A (     "AssemblyDirectories" )

/* that's all we need for 16bit winnt.exe and the rest doesn't all compile with it */
#if (_MSC_VER > 800)
#pragma once
#define SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_W (    L"AssemblyDirectories" )
#define SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME   (TEXT("AssemblyDirectories"))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1989


Revision History:

    Terence Kwan (terryk) 13-Aug-1992
	add make_inf

!ENDIF

MAJORCOMP=inf
MINORCOMP=inf

INCLUDES=.

TARGETNAME=inf
TARGETPATH=obj
TARGETEXT=cpl
TARGETTYPE=notarget

SOURCES=

NTTARGETFILE0=make_inf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\daytona\makefile.inc ===
# Combine the logical section of the inf files with the file list section
# of the inf file together and put them into newinf directory
#
# Terence Kwan (terryk)         12-Aug-1992     Created


#
# Variables
#
# FILELIST      - file list directory
# NEWINF        - new inf directory
# i386inf       - inf files under inf\beta\i386 which need to add file
#                 list section
# amd64inf      - inf files under inf\beta\amd64 which need to add file list
#                 section
# ia64inf       - inf files under inf\beta\ia64 which need to add file list
#                 section
# betafile      - files under inf\beta which do not need to add file list
#                 section
# betainf       - inf files under inf\beta which need to add file list
#                 section
# mediainf      - inf files which need only a [Source Media Description]
#

!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

!IFDEF LINKONLY
make_inf:
!ELSE
NTCD=1
LMCD=1
W_DIR  = ntcd\$(TARGET_DIRECTORY)
S_DIR  = lmcd\$(TARGET_DIRECTORY)

FILELIST=..\filelist
NEWINF=..\newinf\daytona
MEDIAINP=$(LANGUAGE)media.inp
BETA=beta

!IFDEF LMCD
LOCATION=\lmcd\i386\$(O)
SOURCE_LOCATION=\lmcd\i386
!INCLUDE "..\inf.mk"
!INCLUDE "..\i386inf.mk"
LOCATION=\lmcd\amd64\$(O)
SOURCE_LOCATION=\lmcd\amd64
!INCLUDE "..\amd64inf.mk"
!INCLUDE "..\inf.mk"
LOCATION=\lmcd\ia64\$(O)
SOURCE_LOCATION=\lmcd\ia64
!INCLUDE "..\ia64inf.mk"
!INCLUDE "..\inf.mk"
!ENDIF

!IFDEF NTCD
LOCATION=\ntcd\i386\$(O)
SOURCE_LOCATION=\ntcd\i386
!INCLUDE "..\inf.mk"
!INCLUDE "..\i386inf.mk"
LOCATION=\ntcd\amd64\$(O)
SOURCE_LOCATION=\ntcd\amd64
!INCLUDE "..\amd64inf.mk"
!INCLUDE "..\inf.mk"
LOCATION=\ntcd\ia64\$(O)
SOURCE_LOCATION=\ntcd\ia64
!INCLUDE "..\ia64inf.mk"
!INCLUDE "..\inf.mk"
!ENDIF

all: make_inf

cleansrc:
        $(_NTDRIVE)
        cd $(PROJECT_ROOT)\ntsetup

        -del /q inf\filelist\ntcd\i386\*.*
        -del /q inf\filelist\lmcd\i386\*.*
        -del /q inf\filelist\ntcd\amd64\*.*
        -del /q inf\filelist\lmcd\amd64\*.*
        -del /q inf\filelist\ntcd\ia64\*.*
        -del /q inf\filelist\lmcd\ia64\*.*

make_inf: make_log localize make_fil

make_log:
        $(_NTDRIVE)
        cd $(PROJECT_ROOT)\ntsetup

        -mkdir inf\filelist\ntcd\i386\$(O)
        -mkdir inf\filelist\lmcd\i386\$(O)
        -mkdir inf\filelist\ntcd\amd64\$(O)
        -mkdir inf\filelist\lmcd\amd64\$(O)
        -mkdir inf\filelist\ntcd\ia64\$(O)
        -mkdir inf\filelist\lmcd\ia64\$(O)

        -mkdir inf\newinf\daytona\ntcd\i386\$(O)
        -mkdir inf\newinf\daytona\lmcd\i386\$(O)
        -mkdir inf\newinf\daytona\ntcd\amd64\$(O)
        -mkdir inf\newinf\daytona\lmcd\amd64\$(O)
        -mkdir inf\newinf\daytona\ntcd\ia64\$(O)
        -mkdir inf\newinf\daytona\lmcd\ia64\$(O)

!IFNDEF MERGEONLY

        cd bom
        -mkdir $(O)
        copy bom.txt $(O)\cdbom.txt
        size $(O)\cdlog.log $(O)\cdbom.txt . . z

        size $(O)\cdlog.log $(O)\cdbom.txt #S+$(LANGUAGE) . z
        size $(O)\cdlog.log $(O)\cdbom.txt #F-* . z

!IF "$(LANGUAGE)" == "FIN"
        size $(O)\cdlog.log $(O)\cdbom.txt #P+FIN . z
!ELSE
        size $(O)\cdlog.log $(O)\cdbom.txt #P-FIN . z
!ENDIF

        size $(O)\cdlog.log $(O)\cdbom.txt #L+$(LANGUAGE) . z

        layout $(O)\cdlog.log $(O)\cdbom.txt $(O)\lay.txt ntcd 500000000
        infs $(O)\cdlog.log $(O)\lay.txt ..\inf\filelist\ntcd

        layout $(O)\cdlog.log $(O)\cdbom.txt $(O)\lay.txt lmcd 500000000
        infs $(O)\cdlog.log $(O)\lay.txt ..\inf\filelist\lmcd
!ENDIF

localize:
        cd $(PROJECT_ROOT)\ntsetup\inf\$(BETA)
        local.exe $(LANGUAGE)_ansi.txt ..\filelist\ntcd\$(_OBJ_DIR)
        local.exe $(LANGUAGE)_ansi.txt ..\filelist\lmcd\$(_OBJ_DIR)
        local.exe $(LANGUAGE)_net.txt ..\filelist\ntcd\$(_OBJ_DIR)
        local.exe $(LANGUAGE)_net.txt ..\filelist\lmcd\$(_OBJ_DIR)
        local.exe $(LANGUAGE)_dev.txt ..\filelist\ntcd\$(_OBJ_DIR)
        local.exe $(LANGUAGE)_dev.txt ..\filelist\lmcd\$(_OBJ_DIR)
        local.exe $(LANGUAGE)_con.txt ..\filelist\ntcd\$(_OBJ_DIR)
        local.exe $(LANGUAGE)_con.txt ..\filelist\lmcd\$(_OBJ_DIR)


make_fil: dobetainf dobetafile dopatchinf doamd64inf doi386inf doia64inf
        cd $(PROJECT_ROOT)\ntsetup\inf\$(BETA)

        copy $(FILELIST)\lmcd\i386\$(MEDIAINP)+$(FILELIST)\lmcd\i386\$(O)\mmdriver.inf $(NEWINF)\lmcd\i386\$(O)\mmdriver.inf /B
        copy $(FILELIST)\ntcd\i386\$(MEDIAINP)+$(FILELIST)\ntcd\i386\$(O)\mmdriver.inf $(NEWINF)\ntcd\i386\$(O)\mmdriver.inf /B
        copy $(FILELIST)\ntcd\amd64\$(MEDIAINP)+$(FILELIST)\ntcd\amd64\$(O)\mmdriver.inf $(NEWINF)\ntcd\amd64\$(O)\mmdriver.inf /B
        copy $(FILELIST)\lmcd\amd64\$(MEDIAINP)+$(FILELIST)\lmcd\amd64\$(O)\mmdriver.inf $(NEWINF)\lmcd\amd64\$(O)\mmdriver.inf /B
        copy $(FILELIST)\ntcd\ia64\$(MEDIAINP)+$(FILELIST)\ntcd\ia64\$(O)\mmdriver.inf $(NEWINF)\ntcd\ia64\$(O)\mmdriver.inf /B
        copy $(FILELIST)\lmcd\ia64\$(MEDIAINP)+$(FILELIST)\lmcd\ia64\$(O)\mmdriver.inf $(NEWINF)\lmcd\ia64\$(O)\mmdriver.inf /B

        copy ipinfo.inf $(NEWINF)\ntcd\i386\$(O)
        copy ipinfo.inf $(NEWINF)\lmcd\i386\$(O)
        copy ipinfo.inf $(NEWINF)\ntcd\amd64\$(O)
        copy ipinfo.inf $(NEWINF)\lmcd\amd64\$(O)
        copy ipinfo.inf $(NEWINF)\ntcd\ia64\$(O)
        copy ipinfo.inf $(NEWINF)\lmcd\ia64\$(O)

        copy ipinfor.inf $(NEWINF)\ntcd\i386\$(O)
        copy ipinfor.inf $(NEWINF)\lmcd\i386\$(O)
        copy ipinfor.inf $(NEWINF)\ntcd\amd64\$(O)
        copy ipinfor.inf $(NEWINF)\lmcd\amd64\$(O)
        copy ipinfor.inf $(NEWINF)\ntcd\ia64\$(O)
        copy ipinfor.inf $(NEWINF)\lmcd\ia64\$(O)

        cd $(NEWINF)

!IFDEF _NTTREE
        binplace -R $(_NTTREE)           $(W_DIR)\$(O)\*.inf
        binplace -R $(_NTTREE) -b srvinf $(S_DIR)\$(O)\*.inf

!if !$(WIN64)
        binplace -R $(_NTTREE)           $(W_DIR)\*.inf
        binplace -R $(_NTTREE) -b srvinf $(S_DIR)\*.inf
!endif

        binplace -R $(_NTTREE)           $(W_DIR)\txtsetup.wdl
        binplace -R $(_NTTREE) -b srvinf $(S_DIR)\txtsetup.wdl
!ENDIF

#
# do each files
#

cdinfbeta:
        cd $(PROJECT_ROOT)\ntsetup\inf\$(BETA)

cdamd64inf:
        cd $(PROJECT_ROOT)\ntsetup\inf\$(BETA)\amd64

cdi386inf:
        cd $(PROJECT_ROOT)\ntsetup\inf\$(BETA)\i386

cdia64inf:
        cd $(PROJECT_ROOT)\ntsetup\inf\$(BETA)\ia64

dobetainf:cdinfbeta doeachbetainf

dobetafile:cdinfbeta doeachbetafile

dopatchinf:cdinfbeta doeachpatchfile

!IFDEF NTCD
doamd64inf:cdamd64inf doeachamd64inf
doia64inf:cdia64inf doeachia64inf
!ELSE
!IFDEF LMCD
doamd64inf:cdamd64inf doeachamd64inf
doia64inf:cdia64inf doeachia64inf
!ELSE
doamd64inf:
doia64inf:
!ENDIF
!ENDIF

doi386inf:cdi386inf doeachi386inf


!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\win4\tools\sources.inc ===
USE_MSVCRT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\win4\tools\cabcheck\cabcheck.h ===
#include <stdio.h>
#include <windows.h>
#include <conio.h>
#include <process.h>
#include <tchar.h>
#include <objbase.h>
#include <sputils.h>
#include <inflib.h>
#include <string.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\win4\tools\cabcheck\cabcheck.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cabcheck.c

Abstract:

    Program to access/dump information contained in Layout INFs in a readable
    format. It also supports various forms of querying of the layout INF.

Author:

    Vijesh Shetty (vijeshs)

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


// By default process the [SourceDisksFiles] section and not the platform
// specific sections.

DWORD Platform = LAYOUTPLATFORMS_COMMON;


//Make the 3 essential arguments global

TCHAR LayoutFileName[MAX_PATH];
TCHAR SortedList[MAX_PATH];
TCHAR OutputIndexFile[MAX_PATH];


BOOL
FindSingleFile( PLAYOUT_CONTEXT LayoutContext,
                PCTSTR FileName )
{

    BOOL ret=FALSE;
    FILE_LAYOUTINFORMATION LayoutInformation;
    MEDIA_INFO MediaInfo;

    ret = FindFileInLayoutInf( LayoutContext,
                               FileName,
                               &LayoutInformation,
                               NULL,
                               NULL,
                               &MediaInfo);
      

    return( ret );



}





BOOL
ProcessCommandLine( int ArgCount, TCHAR *ArgArray[] )
/*
    Function to process the command line and seperate out options into tokens
*/
{

    int i;
    LPTSTR Arg;
    BOOL ret=TRUE;


    if(ArgCount < 4 )
        return FALSE;

    // First check if we are trying to do the Compare of drvindex files.

    

    // Get the Layout filename

    lstrcpy( LayoutFileName, ArgArray[1] );

    // Get the Sorted List filename

    lstrcpy( SortedList, ArgArray[2] );
    
    // Get the Output Index filename

    lstrcpy( OutputIndexFile, ArgArray[3] );

    for ( i=4;i < ArgCount;i++ ){ //Go through each directive


        Arg = ArgArray[i];

        if( (Arg[0] != TEXT('/')) && (Arg[0] != TEXT('-')))
            continue;

        if(_istlower(Arg[1]))
            Arg[1] = _toupper(Arg[1]);

        switch( Arg[1] ){
        
        case TEXT('?'):
            break;
        
        case TEXT('A'):
            Platform |= LAYOUTPLATFORMS_AMD64;
            break;

        case TEXT('I'):
            Platform |= LAYOUTPLATFORMS_X86;
            break;

        case TEXT('M'):
            Platform |= LAYOUTPLATFORMS_IA64;
            break;

        default:
            break;
        }
        




    }// for

    
    
    return( TRUE );


}


void
VerifyDriverList( 
    PLAYOUT_CONTEXT LayoutContext
)
/*

    This function takes in the sorted list of drivers and crosschecks each file against the layout.inf.
    It also generates a drvindex stle output file based on this.
    
    Arguments :
    
        LayoutContext - Pointer to an already built layout inf context.
        
    Return value:
    
        None.        

*/
{
    FILE *SortedFile, *IndexFile;
    TCHAR PreviousFile[MAX_PATH], FileName[MAX_PATH];
    PTCHAR i;


    //OPen the sorted driver list

    if( !(SortedFile = _tfopen( SortedList, TEXT("r") )) ){
        _ftprintf( stderr, TEXT("ERROR: Could not open %s"), SortedList);
        return;
    }

    if( !(IndexFile = _tfopen( OutputIndexFile, TEXT("w") )) ){
        _ftprintf( stderr, TEXT("ERROR: Could not open %s"), OutputIndexFile);
        fclose(SortedFile);
        return;
    }

    //Write the header info to the file

    _ftprintf( IndexFile, TEXT("[Version]\n"));
    _ftprintf( IndexFile, TEXT("signature=\"$Windows NT$\"\n"));
    _ftprintf( IndexFile, TEXT("CabFiles=driver\n\n\n"));
    _ftprintf( IndexFile, TEXT("[driver]\n"));


    lstrcpy( PreviousFile, TEXT("$$$.#$$") );
     
    // HAck because of bug that doesn't allow the use of _TEOF. Bcoz of the bug
    // fscanf returns EOF but fwscanf returns 0 when it should return 0xffff. So _TEOF
    // is useless and causes us to loop.


    while(TRUE){
    

#ifdef UNICODE

        if( (_ftscanf( SortedFile, TEXT("%s"), FileName )) == 0 )
#else  

        if( (_ftscanf( SortedFile, TEXT("%s"), FileName )) == _TEOF )
#endif 
        break;

        
        if(lstrcmpi( PreviousFile, FileName )){

            // Cross check against layout context

            if (FindFileInLayoutInf( LayoutContext,FileName,NULL,NULL,NULL,NULL)){

                for( i = FileName; i < FileName + lstrlen( FileName ); i++ )   {
                    *i = (TCHAR)towlower( *i );
                }

                // File present - Write it out
                _ftprintf( IndexFile, TEXT("%s\n"), _tcslwr(FileName) );


            }


        }
        
        lstrcpy( PreviousFile, FileName );


    }
    clearerr(SortedFile);
    fflush(SortedFile);
    fclose(SortedFile);

    _ftprintf( IndexFile, TEXT("\n\n\n[Cabs]\n"));
    _ftprintf( IndexFile, TEXT("driver=driver.cab\n"));
    

    _flushall();
    _fcloseall();

    return;
}



void 
CmdLineHelp( )
/*
    This routine displays the CmdLine help.
*/
{

    _putts(TEXT("Program to process a sorted list of drivers and cross-check their existance in layout.inf\n")
           TEXT("This is to be used in the build process to cross-check the driver cab's contents against layout.inf\n\n" )
           TEXT("Usage: Cabcheck <Inf Filename> <Sorted driver list> <Output Index File> [arguments]  \n" )
           TEXT("<Inf Filename> - Path to Layout File to examine (ex.layout.inf)\n")
           TEXT("<Sorted driver file> - File containing sorted list of drivers\n")
           TEXT("<Output Index File> - Output index filename\n\n")
           TEXT("Process Platform specific SourceDisksFiles section. Defaults to the [SourceDisksFiles] section only\n")
           TEXT("/i - Process for Intel i386\n")
           TEXT("/a - Process for AMD AMD64\n")
           TEXT("/m - Process for Intel IA64\n")
           TEXT("\n\n" ));
    return;
}


int
_cdecl _tmain( int argc, TCHAR *argv[ ], char *envp[ ] )
{

    PLAYOUT_CONTEXT LayoutContext;
    LPTSTR CommandLine;
    LPWSTR *CmdlineV;
    int CmdlineC;
    
    if(!pSetupInitializeUtils()) {
        _tprintf(TEXT("Initialize failure\n") );
        return 1;
    }
    
    if( !ProcessCommandLine( argc, argv ) ){
        CmdLineHelp();
        return 1;
    }
    
    _ftprintf( stderr, TEXT("\nParsing Layout file...wait...\n"));
    LayoutContext = BuildLayoutInfContext( LayoutFileName, Platform, 0);
    if( !LayoutContext ){
        _ftprintf(stderr,TEXT("\nError - Could not build Layout Inf context\n"));
        return 1;
    }

    VerifyDriverList( LayoutContext );
        
    CloseLayoutInfContext( LayoutContext );

    pSetupUninitializeUtils();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\win4\tools\cabcheck\precomp.h ===
#include "cabcheck.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\win4\tools\inc\inflib.h ===
//
//  Header file for inflib.lib
//



#define MAX_PLATFORMS 5
#define MAX_SOURCEIDWIDTH 3

#define LAYOUTPLATFORMS_ALL    0x0000001F // - (default) - Grovels through all the platform-specific section
#define LAYOUTPLATFORMS_X86    0x00000001 // - Grovels through the SourcedisksFiles.x86 section
#define LAYOUTPLATFORMS_AMD64  0x00000002 // - Grovels through the SourcedisksFiles.amd64 section
#define LAYOUTPLATFORMS_IA64   0x00000004 // - Grovels through the SourcedisksFiles.ia64 section
#define LAYOUTPLATFORMS_FREE   0x00000008 // - Grovels through the SourcedisksFiles.obsolete section
#define LAYOUTPLATFORMS_COMMON 0x00000010 // - Grovels through the SourcedisksFiles section

#define LAYOUTPLATFORMINDEX_X86    0 // - The platform index for x86
#define LAYOUTPLATFORMINDEX_AMD64  1 // - The platform index for AMD64
#define LAYOUTPLATFORMINDEX_IA64   2 // - The platform index for IA64
#define LAYOUTPLATFORMINDEX_FREE   3 // - The platform index for obsolete
#define LAYOUTPLATFORMINDEX_COMMON 4 // - The platform index for Common


// BUGBUG: Should make this opaque at some time

typedef struct _LAYOUT_CONTEXT{

    PVOID Context;
    UINT ExtraDataSize;
    PVOID MediaInfo[MAX_PLATFORMS];


}LAYOUT_CONTEXT, *PLAYOUT_CONTEXT;



typedef struct _FILE_LAYOUTINFORMATION{

    TCHAR TargetFileName[MAX_PATH];
    TCHAR Directory[MAX_PATH];
    ULONG Size;
    int Directory_Code;
    int BootMediaNumber;
    int UpgradeDisposition;
    int CleanInstallDisposition;
    TCHAR Media_tagID[MAX_SOURCEIDWIDTH];
    BOOL Compression;
    UINT SectionIndex;
    int Count;


}FILE_LAYOUTINFORMATION, *PFILE_LAYOUTINFORMATION;


typedef struct _MEDIA_INFO{

    TCHAR MediaName[MAX_PATH];
    TCHAR TagFilename[MAX_PATH];
    TCHAR RootDir[MAX_PATH];

}MEDIA_INFO, *PMEDIA_INFO;

typedef BOOL
(CALLBACK *PLAYOUTENUMCALLBACK) (
    IN PLAYOUT_CONTEXT Context,
    IN PCTSTR FileName,
    IN PFILE_LAYOUTINFORMATION LayoutInformation,
    IN PVOID ExtraData,
    IN UINT ExtraDataSize,
    IN OUT DWORD_PTR Param
    );


PLAYOUT_CONTEXT
BuildLayoutInfContext(
    IN PCTSTR LayoutInfName,
    IN DWORD PlatformMask,
    IN UINT MaxExtraSize
    );
/*
    Function to generate a internal representation of files listed in a layout INF file.
    It returns an opaque context that can be used with other APIs to
    manipulate/query this representation. The internal representation builds a structure
    associated with each file that lists its attributes.
    
    Arguments :
    
        LayoutInfName - Full path to Layout file.
        
        PlatFormMask - Can be one of the following....
        
            LAYOUTPLATFORMS_ALL (default) - Grovels through all the platform-specific section
            
            LAYOUTPLATFORMS_X86 - Grovels through the SourcedisksFiles.x86 section
            
            LAYOUTPLATFORMS_AMD64 - Grovels through the SourcedisksFiles.amd64 section
            
            LAYOUTPLATFORMS_IA64 - Grovels through the SourcedisksFiles.ia64 section
            
            LAYOUTPLATFORMS_COMMON - Grovels through the SourcedisksFiles section
        
        MaxExtraSize  - Largest possible extra-data size that we may want to associate with
                        each file
                  
    Return value :
    
                 
        An opaque LAYOUT_HANDLE used to access the data structure in other calls.
        Returns NULL if we had a failure.


*/

BOOL
EnumerateLayoutInf(
    IN PLAYOUT_CONTEXT LayoutContext,
    IN PLAYOUTENUMCALLBACK LayoutEnumCallback,
    IN DWORD_PTR Param
    );
/*
  This function calls the specified callback function for each 
  element in the SourceDisksFilesSection associated with the 
  Layout Inf Context specified.
  
    It is required that the user has a LayoutInfContext open from a call to
    BuildLayoutInfContext.
    
    Arguments:
    
        Context - A LAYOUT_CONTEXT returned by BuildLayoutInfContext
        
        LayoutEnumCallback - specifies a callback function called for each file in the SourceDisksFile section

        CallerContext - An opaque context pointer passed on to the callback function
        
        
The callback is of the form:

typedef BOOL
(CALLBACK *PLAYOUTENUMCALLBACK) (
    IN PLAYOUT_CONTEXT Context,
    IN PCTSTR FileName,
    IN PFILE_LAYOUTINFORMATION LayoutInformation,
    IN PVOID ExtraData,
    IN UINT ExtraDataSize,
    IN OUT DWORD_PTR Param
    );

    where

    Context            - Pointer to open LAYOUT_CONTEXT
    
    FileName           - Specifies the individual filename
                           
                           
    LayoutInformation  - Pointer to Layout Information for this file. User should not modify this directly.
    
    ExtraData          - Pointer to the ExtraData that the caller may have stored. User should not modify this directly.
    
    ExtraDataSize      - Size in bytes of the ExtraData
        
    Param            - the opaque param passed into this function is passed
                           into the callback function        
        
        
   Return value:
   
        TRUE if all the elements were enumerated. If not it returns
        FALSE and GetLastError() returns ERROR_CANCELLED. If the callback 
        returns FALSE then the enumeration stops but this API returns TRUE.

*/


BOOL
FindFileInLayoutInf(
    IN PLAYOUT_CONTEXT LayoutContext,
    IN PCTSTR Filename,
    OUT PFILE_LAYOUTINFORMATION LayoutInformation, OPTIONAL
    OUT PVOID ExtraData,   OPTIONAL
    OUT PUINT ExtraDataSize, OPTIONAL
    OUT PMEDIA_INFO Media_Info OPTIONAL
    );
/*
    This function finds the file information for a given filename inside a 
    built layout context. It returns the layout information as well as the
    extra data (if any) associated with the file.
    
    Arguments:

        Context            - Pointer to open LAYOUT_CONTEXT
    
        Filename           - Specifies the filename to search for
        
        LayoutInformation  - Pointer to Layout Information for this file.  User should not modify this directly.
        
        ExtraData          - Pointer to the ExtraData that the caller may have stored. User should not modify this directly.
        
        ExtraDataSize      - Size in bytes of the ExtraData returned.
        
        Media_Info         - Pointer to MEDIA_INFO structure that will get filled
                             with the file's corresponding Media information.
        
     Return value;
     
        TRUE if the file is found - False otherwise.
        

*/


BOOL
CloseLayoutInfContext(
    IN PLAYOUT_CONTEXT LayoutContext);
/*
    This function closes a Layout Inf Context and frees all memory
    associated with it.
    
    Arguments :
    
        LayoutContext   -  LayoutContext to close
        
    Return values :
    
        TRUE if it succeeds, else FALSE        

*/

VOID
MyConcatenatePaths(
    IN OUT PTSTR   Path1,
    IN     LPCTSTR Path2,
    IN     DWORD   BufferSizeChars
    );

/*++

Routine Description:

    Concatenate two path strings together, supplying a path separator
    character (\) if necessary between the 2 parts.

Arguments:

    Path1 - supplies prefix part of path. Path2 is concatenated to Path1.

    Path2 - supplies the suffix part of path. If Path1 does not end with a
        path separator and Path2 does not start with one, then a path sep
        is appended to Path1 before appending Path2.

    BufferSizeChars - supplies the size in chars (Unicode version) or
        bytes (Ansi version) of the buffer pointed to by Path1. The string
        will be truncated as necessary to not overflow that size.

Return Value:

    None.

--*/

BOOL ValidateTextmodeDirCodesSection( 
    PCTSTR LayoutFile, 
    PCTSTR WinntdirSection 
    );
/*
    Routine to validate the [WinntDirectories] section for a setup layout INF. This checks for errors that maybe encountered
    when people add/remove stuff from this section.
    
    Arguments:
    
    LayoutInf       - Name of setup layout INF that contains the specified section
    
    WinntdirSection - Section that contains dir codes
        
        Checks - 
            1) Looks for duplicate or reused dir codes
            
    Return value: 
        TRUE - Validation succeeded
        FALSE- Validation failed     
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\win4\tools\inc\wild.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    wild.c

Abstract:

    This module implements functions to process wildcard specifiers.

Author:

    Vijesh

Revision History:

--*/





//
//  These following bit values are set in the FsRtlLegalDbcsCharacterArray
//

#define FSRTL_FAT_LEGAL         0x01
#define FSRTL_HPFS_LEGAL        0x02
#define FSRTL_NTFS_LEGAL        0x04
#define FSRTL_WILD_CHARACTER    0x08
#define FSRTL_OLE_LEGAL         0x10
#define FSRTL_NTFS_STREAM_LEGAL (FSRTL_NTFS_LEGAL | FSRTL_OLE_LEGAL)


//
//  The global static legal ANSI character array.  Wild characters
//  are not considered legal, they should be checked seperately if
//  allowed.
//


#define _FAT_  FSRTL_FAT_LEGAL
#define _HPFS_ FSRTL_HPFS_LEGAL
#define _NTFS_ FSRTL_NTFS_LEGAL
#define _OLE_  FSRTL_OLE_LEGAL
#define _WILD_ FSRTL_WILD_CHARACTER

static const UCHAR LocalLegalAnsiCharacterArray[128] = {

    0                                   ,   // 0x00 ^@
                                   _OLE_,   // 0x01 ^A
                                   _OLE_,   // 0x02 ^B
                                   _OLE_,   // 0x03 ^C
                                   _OLE_,   // 0x04 ^D
                                   _OLE_,   // 0x05 ^E
                                   _OLE_,   // 0x06 ^F
                                   _OLE_,   // 0x07 ^G
                                   _OLE_,   // 0x08 ^H
                                   _OLE_,   // 0x09 ^I
                                   _OLE_,   // 0x0A ^J
                                   _OLE_,   // 0x0B ^K
                                   _OLE_,   // 0x0C ^L
                                   _OLE_,   // 0x0D ^M
                                   _OLE_,   // 0x0E ^N
                                   _OLE_,   // 0x0F ^O
                                   _OLE_,   // 0x10 ^P
                                   _OLE_,   // 0x11 ^Q
                                   _OLE_,   // 0x12 ^R
                                   _OLE_,   // 0x13 ^S
                                   _OLE_,   // 0x14 ^T
                                   _OLE_,   // 0x15 ^U
                                   _OLE_,   // 0x16 ^V
                                   _OLE_,   // 0x17 ^W
                                   _OLE_,   // 0x18 ^X
                                   _OLE_,   // 0x19 ^Y
                                   _OLE_,   // 0x1A ^Z
                                   _OLE_,   // 0x1B ESC
                                   _OLE_,   // 0x1C FS
                                   _OLE_,   // 0x1D GS
                                   _OLE_,   // 0x1E RS
                                   _OLE_,   // 0x1F US
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x20 space
    _FAT_ | _HPFS_ | _NTFS_              ,  // 0x21 !
                            _WILD_| _OLE_,  // 0x22 "
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x23 #
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x24 $
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x25 %
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x26 &
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x27 '
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x28 (
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x29 )
                            _WILD_| _OLE_,  // 0x2A *
            _HPFS_ | _NTFS_       | _OLE_,  // 0x2B +
            _HPFS_ | _NTFS_       | _OLE_,  // 0x2C ,
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x2D -
    _FAT_ | _HPFS_ | _NTFS_              ,  // 0x2E .
    0                                    ,  // 0x2F /
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x30 0
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x31 1
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x32 2
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x33 3
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x34 4
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x35 5
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x36 6
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x37 7
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x38 8
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x39 9
                     _NTFS_              ,  // 0x3A :
            _HPFS_ | _NTFS_       | _OLE_,  // 0x3B ;
                            _WILD_| _OLE_,  // 0x3C <
            _HPFS_ | _NTFS_       | _OLE_,  // 0x3D =
                            _WILD_| _OLE_,  // 0x3E >
                            _WILD_| _OLE_,  // 0x3F ?
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x40 @
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x41 A
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x42 B
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x43 C
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x44 D
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x45 E
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x46 F
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x47 G
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x48 H
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x49 I
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x4A J
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x4B K
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x4C L
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x4D M
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x4E N
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x4F O
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x50 P
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x51 Q
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x52 R
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x53 S
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x54 T
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x55 U
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x56 V
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x57 W
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x58 X
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x59 Y
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x5A Z
            _HPFS_ | _NTFS_       | _OLE_,  // 0x5B [
    0                                    ,  // 0x5C backslash
            _HPFS_ | _NTFS_       | _OLE_,  // 0x5D ]
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x5E ^
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x5F _
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x60 `
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x61 a
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x62 b
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x63 c
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x64 d
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x65 e
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x66 f
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x67 g
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x68 h
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x69 i
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x6A j
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x6B k
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x6C l
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x6D m
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x6E n
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x6F o
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x70 p
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x71 q
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x72 r
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x73 s
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x74 t
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x75 u
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x76 v
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x77 w
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x78 x
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x79 y
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x7A z
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x7B {
    0                             | _OLE_,  // 0x7C |
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x7D }
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x7E ~
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x7F 
};

UCHAR const* const FsRtlLegalAnsiCharacterArray = &LocalLegalAnsiCharacterArray[0];

#define LEGAL_ANSI_CHARACTER_ARRAY        (FsRtlLegalAnsiCharacterArray)

#define  mQueryBits(uFlags, uBits)      ((uFlags) & (uBits))
#define FlagOn(uFlags, uBit)    (mQueryBits(uFlags, uBit) != 0)
#define IsUnicodeCharacterWild(C) (                                \
      (((C) >= 0x40) ? FALSE : FlagOn( LEGAL_ANSI_CHARACTER_ARRAY[(C)], \
                                       FSRTL_WILD_CHARACTER ) )         \
)

typedef struct _UNICODE_STRING {
        USHORT Length;
        USHORT MaximumLength;
        PWSTR  Buffer;
    } UNICODE_STRING, *PUNICODE_STRING;


#define DOS_STAR        TEXT('<')
#define DOS_QM          TEXT('>')
#define DOS_DOT         TEXT('"')


BOOLEAN
DoesNameContainWildCards (
    IN PTSTR Name
    )

/*++

Routine Description:

    This routine simply scans the input Name string looking for any Nt
    wild card characters.

Arguments:

    Name - The string to check.

Return Value:

    BOOLEAN - TRUE if one or more wild card characters was found.

--*/
{
    PTCHAR p;

    
    //
    //  Check each character in the name to see if it's a wildcard
    //  character.
    //

    if( lstrlen(Name) ) {
        for( p = Name + lstrlen(Name) - 1;
             p >= Name && *p != TEXT('\\') ;
             p-- ) {

            //
            //  check for a wild card character
            //

            if (IsUnicodeCharacterWild( *p )) {

                //
                //  Tell caller that this name contains wild cards
                //

                return TRUE;
            }
        }
    }

    //
    //  No wildcard characters were found, so return to our caller
    //

    return FALSE;
}



BOOLEAN
IsNameInExpressionPrivate (
    IN PCTSTR Expression,
    IN PCTSTR Name
    )

/*++

Routine Description:

    This routine compares a Dbcs name and an expression and tells the caller
    if the name is in the language defined by the expression.  The input name
    cannot contain wildcards, while the expression may contain wildcards.

    Expression wild cards are evaluated as shown in the nondeterministic
    finite automatons below.  Note that ~* and ~? are DOS_STAR and DOS_QM.


             ~* is DOS_STAR, ~? is DOS_QM, and ~. is DOS_DOT


                                       S
                                    <-----<
                                 X  |     |  e       Y
             X * Y ==       (0)----->-(1)->-----(2)-----(3)


                                      S-.
                                    <-----<
                                 X  |     |  e       Y
             X ~* Y ==      (0)----->-(1)->-----(2)-----(3)



                                X     S     S     Y
             X ?? Y ==      (0)---(1)---(2)---(3)---(4)



                                X     .        .      Y
             X ~.~. Y ==    (0)---(1)----(2)------(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^


                                X     S-.     S-.     Y
             X ~?~? Y ==    (0)---(1)-----(2)-----(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^



         where S is any single character

               S-. is any single character except the final .

               e is a null character transition

               EOF is the end of the name string

    In words:

        * matches 0 or more characters.

        ? matches exactly 1 character.

        DOS_STAR matches 0 or more characters until encountering and matching
            the final . in the name.

        DOS_QM matches any single character, or upon encountering a period or
            end of name string, advances the expression to the end of the
            set of contiguous DOS_QMs.

        DOS_DOT matches either a . or zero characters beyond name string.

Arguments:

    Expression - Supplies the input expression to check against
        (Caller must already upcase if passing CaseInsensitive TRUE.)

    Name - Supplies the input name to check for.

    CaseInsensitive - TRUE if Name should be Upcased before comparing.

Return Value:

    BOOLEAN - TRUE if Name is an element in the set of strings denoted
        by the input Expression and FALSE otherwise.

--*/

{
    USHORT NameOffset;
    USHORT ExprOffset;

    ULONG SrcCount;
    ULONG DestCount;
    ULONG PreviousDestCount;
    ULONG MatchesCount;

    TCHAR NameChar, ExprChar;

    USHORT LocalBuffer[16 * 2];

    USHORT *AuxBuffer = NULL;
    USHORT *PreviousMatches;
    USHORT *CurrentMatches;

    USHORT MaxState;
    USHORT CurrentState;

    BOOLEAN NameFinished = FALSE;

    ULONG NameLen, ExpressionLen;

    //
    //  The idea behind the algorithm is pretty simple.  We keep track of
    //  all possible locations in the regular expression that are matching
    //  the name.  If when the name has been exhausted one of the locations
    //  in the expression is also just exhausted, the name is in the language
    //  defined by the regular expression.
    //

    NameLen = lstrlen(Name)*sizeof(TCHAR);
    ExpressionLen = lstrlen(Expression)*sizeof(TCHAR);

    
    //
    //  If one string is empty return FALSE.  If both are empty return TRUE.
    //

    if ( (NameLen == 0) || (ExpressionLen == 0) ) {

        return (BOOLEAN)(!(NameLen + ExpressionLen));
    }

    //
    //  Special case by far the most common wild card search of *
    //

    if ((ExpressionLen == 2) && (Expression[0] == TEXT('*'))) {

        return TRUE;
    }

    
    //
    //  Also special case expressions of the form *X.  With this and the prior
    //  case we have covered virtually all normal queries.
    //

    if (Expression[0] == TEXT('*')) {

        TCHAR LocalExpression[MAX_PATH];
        ULONG LocalExpressionLen;

        lstrcpy( LocalExpression, Expression+1);
        LocalExpressionLen = lstrlen( LocalExpression )*sizeof(TCHAR);

        
        //
        //  Only special case an expression with a single *
        //

        if ( !DoesNameContainWildCards( LocalExpression ) ) {

            ULONG StartingNameOffset;

            if (NameLen < (USHORT)(ExpressionLen-sizeof(TCHAR))) {

                return FALSE;
            }

            StartingNameOffset = ( NameLen -
                                   LocalExpressionLen )/sizeof(TCHAR);

            //
            //  Do a simple memory compare if case sensitive, otherwise
            //  we have got to check this one character at a time.
            //

        

            return (BOOLEAN) RtlEqualMemory( LocalExpression,
                                             Name + StartingNameOffset,
                                             LocalExpressionLen );

        
        }
    }

    //
    //  Walk through the name string, picking off characters.  We go one
    //  character beyond the end because some wild cards are able to match
    //  zero characters beyond the end of the string.
    //
    //  With each new name character we determine a new set of states that
    //  match the name so far.  We use two arrays that we swap back and forth
    //  for this purpose.  One array lists the possible expression states for
    //  all name characters up to but not including the current one, and other
    //  array is used to build up the list of states considering the current
    //  name character as well.  The arrays are then switched and the process
    //  repeated.
    //
    //  There is not a one-to-one correspondence between state number and
    //  offset into the expression.  This is evident from the NFAs in the
    //  initial comment to this function.  State numbering is not continuous.
    //  This allows a simple conversion between state number and expression
    //  offset.  Each character in the expression can represent one or two
    //  states.  * and DOS_STAR generate two states: ExprOffset*2 and
    //  ExprOffset*2 + 1.  All other expreesion characters can produce only
    //  a single state.  Thus ExprOffset = State/2.
    //
    //
    //  Here is a short description of the variables involved:
    //
    //  NameOffset  - The offset of the current name char being processed.
    //
    //  ExprOffset  - The offset of the current expression char being processed.
    //
    //  SrcCount    - Prior match being investigated with current name char
    //
    //  DestCount   - Next location to put a matching assuming current name char
    //
    //  NameFinished - Allows one more itteration through the Matches array
    //                 after the name is exhusted (to come *s for example)
    //
    //  PreviousDestCount - This is used to prevent entry duplication, see coment
    //
    //  PreviousMatches   - Holds the previous set of matches (the Src array)
    //
    //  CurrentMatches    - Holds the current set of matches (the Dest array)
    //
    //  AuxBuffer, LocalBuffer - the storage for the Matches arrays
    //

    //
    //  Set up the initial variables
    //

    PreviousMatches = &LocalBuffer[0];
    CurrentMatches = &LocalBuffer[16];

    PreviousMatches[0] = 0;
    MatchesCount = 1;

    NameOffset = 0;

    MaxState = (USHORT)(ExpressionLen * 2);

    while ( !NameFinished ) {

        if ( NameOffset < NameLen ) {

            NameChar = Name[NameOffset / sizeof(TCHAR)];

            NameOffset += sizeof(TCHAR);;

        } else {

            NameFinished = TRUE;

            //
            //  if we have already exhasted the expression, cool.  Don't
            //  continue.
            //

            if ( PreviousMatches[MatchesCount-1] == MaxState ) {

                break;
            }
        }


        //
        //  Now, for each of the previous stored expression matches, see what
        //  we can do with this name character.
        //

        SrcCount = 0;
        DestCount = 0;
        PreviousDestCount = 0;

        while ( SrcCount < MatchesCount ) {

            USHORT Length;

            //
            //  We have to carry on our expression analysis as far as possible
            //  for each character of name, so we loop here until the
            //  expression stops matching.  A clue here is that expression
            //  cases that can match zero or more characters end with a
            //  continue, while those that can accept only a single character
            //  end with a break.
            //

            ExprOffset = (USHORT)((PreviousMatches[SrcCount++] + 1) / 2);


            Length = 0;

            while ( TRUE ) {

                if ( ExprOffset == ExpressionLen ) {

                    break;
                }

                //
                //  The first time through the loop we don't want
                //  to increment ExprOffset.
                //

                ExprOffset += Length;
                Length = sizeof(TCHAR);

                CurrentState = (USHORT)(ExprOffset * 2);

                if ( ExprOffset == ExpressionLen ) {

                    CurrentMatches[DestCount++] = MaxState;
                    break;
                }

                ExprChar = Expression[ExprOffset / sizeof(TCHAR)];

        
                //
                //  Before we get started, we have to check for something
                //  really gross.  We may be about to exhaust the local
                //  space for ExpressionMatches[][], so we have to allocate
                //  some pool if this is the case.  Yuk!
                //

                if ( (DestCount >= 16 - 2) &&
                     (AuxBuffer == NULL) ) {

                    ULONG ExpressionChars;

                    ExpressionChars = ExpressionLen / sizeof(TCHAR);

                    AuxBuffer = malloc( (ExpressionChars+1) * sizeof(USHORT)*2*2 );

                    RtlCopyMemory( AuxBuffer,
                                   CurrentMatches,
                                   16 * sizeof(USHORT) );

                    CurrentMatches = AuxBuffer;

                    RtlCopyMemory( AuxBuffer + (ExpressionChars+1)*2,
                                   PreviousMatches,
                                   16 * sizeof(USHORT) );

                    PreviousMatches = AuxBuffer + (ExpressionChars+1)*2;
                }

                //
                //  * matches any character zero or more times.
                //

                if (ExprChar == TEXT('*')) {

                    CurrentMatches[DestCount++] = CurrentState;
                    CurrentMatches[DestCount++] = CurrentState + 3;
                    continue;
                }

                //
                //  DOS_STAR matches any character except . zero or more times.
                //

                if (ExprChar == DOS_STAR) {

                    BOOLEAN ICanEatADot = FALSE;

                    //
                    //  If we are at a period, determine if we are allowed to
                    //  consume it, ie. make sure it is not the last one.
                    //

                    if ( !NameFinished && (NameChar == TEXT('.')) ) {

                        USHORT Offset;

                        for ( Offset = NameOffset;
                              Offset < NameLen;
                              Offset += Length ) {

                            if (Name[Offset / sizeof(TCHAR)] == TEXT('.')) {

                                ICanEatADot = TRUE;
                                break;
                            }
                        }
                    }

                    if (NameFinished || (NameChar != TEXT('.')) || ICanEatADot) {

                        CurrentMatches[DestCount++] = CurrentState;
                        CurrentMatches[DestCount++] = CurrentState + 3;
                        continue;

                    } else {

                        //
                        //  We are at a period.  We can only match zero
                        //  characters (ie. the epsilon transition).
                        //

                        CurrentMatches[DestCount++] = CurrentState + 3;
                        continue;
                    }
                }

                //
                //  The following expreesion characters all match by consuming
                //  a character, thus force the expression, and thus state
                //  forward.
                //

                CurrentState += (USHORT)(sizeof(TCHAR) * 2);

                //
                //  DOS_QM is the most complicated.  If the name is finished,
                //  we can match zero characters.  If this name is a '.', we
                //  don't match, but look at the next expression.  Otherwise
                //  we match a single character.
                //

                if ( ExprChar == DOS_QM ) {

                    if ( NameFinished || (NameChar == TEXT('.')) ) {

                        continue;
                    }

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  A DOS_DOT can match either a period, or zero characters
                //  beyond the end of name.
                //

                if (ExprChar == DOS_DOT) {

                    if ( NameFinished ) {

                        continue;
                    }

                    if (NameChar == TEXT('.')) {

                        CurrentMatches[DestCount++] = CurrentState;
                        break;
                    }
                }

                //
                //  From this point on a name character is required to even
                //  continue, let alone make a match.
                //

                if ( NameFinished ) {

                    break;
                }

                //
                //  If this expression was a '?' we can match it once.
                //

                if (ExprChar == TEXT('?')) {

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  Finally, check if the expression char matches the name char
                //

                if (ExprChar == (TCHAR)(NameChar)) {

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  The expression didn't match so go look at the next
                //  previous match.
                //

                break;
            }


            //
            //  Prevent duplication in the destination array.
            //
            //  Each of the arrays is montonically increasing and non-
            //  duplicating, thus we skip over any source element in the src
            //  array if we just added the same element to the destination
            //  array.  This guarentees non-duplication in the dest. array.
            //

            if ((SrcCount < MatchesCount) &&
                (PreviousDestCount < DestCount) ) {

                while (PreviousDestCount < DestCount) {

                    while ( PreviousMatches[SrcCount] <
                         CurrentMatches[PreviousDestCount] ) {

                        SrcCount += 1;
                    }

                    PreviousDestCount += 1;
                }
            }
        }

        //
        //  If we found no matches in the just finished itteration, it's time
        //  to bail.
        //

        if ( DestCount == 0 ) {

            if (AuxBuffer != NULL) { free( AuxBuffer ); }

            return FALSE;
        }

        //
        //  Swap the meaning the two arrays
        //

        {
            USHORT *Tmp;

            Tmp = PreviousMatches;

            PreviousMatches = CurrentMatches;

            CurrentMatches = Tmp;
        }

        MatchesCount = DestCount;
    }


    CurrentState = PreviousMatches[MatchesCount-1];

    if (AuxBuffer != NULL) { free( AuxBuffer ); }


    return (BOOLEAN)(CurrentState == MaxState);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\win4\tools\infdump\infdump.h ===
#include <stdio.h>
#include <windows.h>
#include <conio.h>
#include <process.h>
#include <tchar.h>
#include <objbase.h>
#include <inflib.h>
#include <string.h>
#include <sputils.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\win4\tools\escpeinf\escpeinf.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    escpeinf.c

Abstract:

    This module filters an inf for use by the ESCAPE tool. Default file
    security can be set in the inx file using wildcard rules, and this
    program expands them, creating a valid file for ESCAPE. This is
    necessary because ESCAPE does not support wildcards in the file section

    See below for more information.

    Note: ESCAPE was the proposed name of the Security Configuration Engine when this
          was written, but that name too was dropped. They still haven't come up with
          a good name for it.

Author:

    Sandy Coyne (scoyne) February 29, 2000

Revision History:

--*/


/*
    Usage: escpeinf.exe <U|C> <codepage> <input file> <output file> <layout.inf>

    Parameter info is printed when you run the program without all the right arguments

    layout.inf is the system-wide layout.inf, already built for the local
    language, arch., etc.

    The input file to this program consists of an inf, already sent through
    the filters for architecture, language and product. This inf is an input
    file for ESCAPE, with one exception: In the [File Security] section, some
    entries may have wildcards for filenames. Following those lines, if
    desired, is a list of files that should be excluded from matching that
    wildcard. This list is in the form of exception lines.
    Example:
            [File Security]
            "%SystemDirectory%\*",2,"D:P(A;;GRGX;;;BU)(A;;GRGX;;;PU)(A;;GA;;;BA)(A;;GA;;;SY)"
            Exception="*.ini"
            Exception="config.nt"
    This wildcard line will be replaced with an enumeration of all matching files
    that are copied by text-mode setup, as specified by the listing in layout.inf

*/


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <string.h>
#include <locale.h>
#include <mbctype.h>
#include <inflib.h>
#include <sputils.h>

#include <wild.c>



// Define program result codes (returned from main()).
#define SUCCESS 0
#define FAILURE 1

#define MAX_INF_LINE_LENGTH 256
#define MAX_EXCEPTIONS 256

#define ESCPEINF_VERSION "1.4"

//#define ESCPEINF_DEBUG


enum {
    UPGRADE,
    CLEAN_INSTALL
    } GlobalMode;

typedef struct _EXCEPTIONS {
    TCHAR s[MAX_INF_LINE_LENGTH];
    } EXCEPTIONS;

typedef struct _MYPARAM {
    FILE        *OutputFile;
    EXCEPTIONS  *ExceptionList;
    DWORD       Num;
    PTSTR       WildCard,
                RealPath,
                LayoutPath,
                SecurityString;
    }  MYPARAM, *PMYPARAM;

BOOL ProcessFileSecuritySection(FILE *InputFile, FILE *OutputFile,
                                PLAYOUT_CONTEXT LayoutContexta);
BOOL GetFields(PTSTR InfLine, PTSTR FileName, DWORD *Num, PTSTR SecurityString);
void ExpandWildCard(PTSTR FileName, DWORD Num, PTSTR SecurityString,
                    EXCEPTIONS ExceptionList[], FILE *OutputFile,
                    PLAYOUT_CONTEXT LayoutContext);
void FindExceptions(FILE *InputFile, EXCEPTIONS ExceptionList[]);

void PrintUsage(LPTSTR FileName)
    {
    _ftprintf(stderr, TEXT("ESCAPE Inf file pre-processor, version %s\n"),
              TEXT(ESCPEINF_VERSION));
    _ftprintf(stderr, TEXT("\tFor Microsoft internal use only. "));
    _ftprintf(stderr, TEXT("Contact Sandy Coyne with questions.\n"));
    _ftprintf(stderr,
        TEXT("Usage: %s <U|C> <codepage> <input file> <output file> <layout.inf>\n"),
        FileName);
    _ftprintf(stderr, TEXT("\tU = Upgrade\n"));
    _ftprintf(stderr, TEXT("\tC = Clean Install\n"));
    _ftprintf(stderr, 
        TEXT("\t<codepage> specifies the codepage to use when accessing input and\n"));
    _ftprintf(stderr, 
        TEXT("\t\toutput files. Translation of layout.inf is not affected by\n"));
    _ftprintf(stderr, 
        TEXT("\t\tthis option. You may specify \"none\" to open the input\n"));
    _ftprintf(stderr, 
        TEXT("\t\tand output files as Unicode files with no codepage translation.\n"));
    _ftprintf(stderr, TEXT("\tAll fields are required.\n"));
    }


int __cdecl _tmain(IN int argc, IN LPTSTR argv[])
    {
    FILE    *InputFile,
            *OutputFile;
    LPTSTR  LocaleString;
    TCHAR   InfLine[MAX_INF_LINE_LENGTH],
            CodePage[10];
    PLAYOUT_CONTEXT LayoutContext;
    BOOL    bUnicodeIO;
    int     result = FAILURE;

    if(!pSetupInitializeUtils()) {
        _ftprintf(stderr, TEXT("Initialize failed\n"));
        return FAILURE;
    }

    // Print Usage information
    if (argc != 6)
        {
        PrintUsage(argv[0]);
        goto fail;
        }

    if (_tcsicmp(argv[1], TEXT("U")) == 0)
        {
        GlobalMode = UPGRADE;
        }
    else if (_tcsicmp(argv[1], TEXT("C")) == 0)
        {
        GlobalMode = CLEAN_INSTALL;
        }
    else
        {
        PrintUsage(argv[0]);
        goto fail;
        }

    if (_tcsicmp(argv[2], TEXT("None")) == 0)
        {
        bUnicodeIO = TRUE;
        #ifdef ESCPEINF_DEBUG
        _ftprintf(stderr, TEXT("Using Unicode I/O\n"));
        #endif
        }
    else
        {
        _stprintf(CodePage, TEXT(".%.7s"), argv[2]);
        LocaleString = _tsetlocale(LC_ALL, CodePage);
        if (LocaleString == NULL)
            {
            _ftprintf(stderr, TEXT("Invalid CodePage: \"%s\"\n"), argv[2]);
            #ifdef ESCPEINF_DEBUG
            _ftprintf(stderr, TEXT("Invalid argument to setlocale: \"%s\"\n"), CodePage);
            #endif
            goto fail;
            }
        else
            {
            #ifdef ESCPEINF_DEBUG
            _ftprintf(stderr, TEXT("Locale set to: \"%s\"\n"), LocaleString);
            #endif
            bUnicodeIO = FALSE;
            }
        }

    // Begin to Open Input, Output and Layout files
    if (bUnicodeIO)
        {
        InputFile = _tfopen(argv[3], TEXT("rb"));
        }
    else
        {
        InputFile = _tfopen(argv[3], TEXT("rt"));
        }

    if (InputFile == NULL)
        {
        _ftprintf(stderr, TEXT("Error opening Input file: %s\n"), argv[3]);
        goto fail;
        }
    #ifdef ESCPEINF_DEBUG
    _ftprintf(stderr, TEXT("Opened Input file: %s\n"), argv[3]);
    #endif
    rewind(InputFile);

    if (bUnicodeIO)
        {
        OutputFile = _tfopen(argv[4], TEXT("wb"));
        }
    else
        {
        OutputFile = _tfopen(argv[4], TEXT("wt"));
        }

    if (OutputFile == NULL)
        {
        _ftprintf(stderr, TEXT("Error opening Output file: %s\n"), argv[4]);
        fclose(InputFile);
        goto fail;
        }
    #ifdef ESCPEINF_DEBUG
    _ftprintf(stderr, TEXT("Opened Output file: %s\n"), argv[4]);
    #endif

    LayoutContext = BuildLayoutInfContext(argv[5], LAYOUTPLATFORMS_ALL, 0);
    if (LayoutContext == NULL)
        {
        _ftprintf(stderr, TEXT("Error opening Layout file: %s\n"), argv[5]);
        _ftprintf(stderr, TEXT("Did you remember to specify a path to the file\n"));
        fclose(InputFile); fclose(OutputFile);
        goto fail;
        }
    else
        {
        #ifdef ESCPEINF_DEBUG
        _ftprintf(stderr, TEXT("Opened Layout file: %s\n"), argv[5]);
        #endif
        }
    // Input, Output and Layout files are open

    while ((_fgetts(InfLine, MAX_INF_LINE_LENGTH, InputFile)) != NULL)
        {
        _fputts(InfLine, OutputFile);
        if (!_tcscmp(InfLine, TEXT("[File Security]\n")))
            if (!ProcessFileSecuritySection(InputFile, OutputFile,
                                            LayoutContext))
                {
                // If this happens, ProcessFileSecuritySection() has already
                // printed an error.
                fclose(InputFile); fclose(OutputFile);
                CloseLayoutInfContext(LayoutContext);
                goto fail;
                }
        }
    if (!feof(InputFile))
        {
        _ftprintf(stderr, TEXT("Error: Did not reach Input EOF.\n"));
        fclose(InputFile); fclose(OutputFile); 
        CloseLayoutInfContext(LayoutContext);
        goto fail;
        }
    fclose(InputFile);
    fclose(OutputFile);
    CloseLayoutInfContext(LayoutContext);
    #ifdef ESCPEINF_DEBUG
    _ftprintf(stderr, TEXT("escpeinf.exe completed successfully\n"));
    #endif

    result = SUCCESS;

fail:

    pSetupUninitializeUtils();
    return result;
    }


BOOL CALLBACK MyCallback(IN PLAYOUT_CONTEXT Context,
                         IN PCTSTR FileName,
                         IN PFILE_LAYOUTINFORMATION LayoutInformation,
                         IN PVOID ExtraData,
                         IN UINT ExtraDataSize,
                         IN OUT DWORD_PTR vpParam)
    {
    PMYPARAM    Param;
    BOOL        bIsException = FALSE;
    int         i = 0;
    TCHAR       FileName_l[MAX_INF_LINE_LENGTH],
                TargetFileName_l[MAX_INF_LINE_LENGTH];

    if (vpParam)
        Param = (PMYPARAM)vpParam;

    // Quit now if we don't need to worry about this file at all.
    if ((GlobalMode == UPGRADE) &&
        (LayoutInformation->UpgradeDisposition == 3))
        return TRUE;
    if ((GlobalMode == CLEAN_INSTALL) &&
        (LayoutInformation->CleanInstallDisposition == 3))
        return TRUE;

    // Since wildcard compares are case sensitive, I lowercase everything
    // before comparing. Wildcard compares happen between the two filename
    // variables modified here, WildCard, and ExceptionList. WildCard and
    // ExceptionList were previouslt lowercased.
    _tcscpy(FileName_l, FileName);
    _tcscpy(TargetFileName_l, LayoutInformation->TargetFileName);
    _tcslwr(FileName_l);
    _tcslwr(TargetFileName_l);

    if (_tcslen(TargetFileName_l) > 0) // Do we use the long name?
        {
        if (_tcsicmp(Param->LayoutPath, LayoutInformation->Directory) == 0)
            { // Then it's a file in the right directory
            if (IsNameInExpressionPrivate(Param->WildCard, TargetFileName_l))
                { // Then it matches our wildcard
                while ((_tcslen(Param->ExceptionList[i].s) > 0) && !bIsException)
                    { // Checking to see if it's an exception...
                    if (IsNameInExpressionPrivate(Param->ExceptionList[i].s,
                                                  TargetFileName_l))
                        {
                        bIsException = TRUE; // This must be initialized FALSE
                        }
                    i += 1;
                    }
                if (!bIsException)
                    { // Then we actually want to put it in our output
                    #ifdef ESCPEINF_DEBUG
                    _ftprintf(stderr, TEXT("Match: %s(%s) in %s\n"),
                              FileName, LayoutInformation->TargetFileName,
                              LayoutInformation->Directory);
                    #endif
                    _ftprintf(Param->OutputFile, TEXT("\"%s\\%s\",%d,%s\n"),
                              Param->RealPath,
                              LayoutInformation->TargetFileName, Param->Num,
                              Param->SecurityString);
                    }
                }
            }
        }
    else // We use the short name
        {
        if (_tcsicmp(Param->LayoutPath, LayoutInformation->Directory) == 0)
            { // Then it's a file in the right directory
            if (IsNameInExpressionPrivate(Param->WildCard, FileName_l))
                { // Then it matches our wildcard
                while ((_tcslen(Param->ExceptionList[i].s) > 0) && !bIsException)
                    { // Checking to see if it's an exception...
                    if (IsNameInExpressionPrivate(Param->ExceptionList[i].s,
                                                  FileName_l))
                        {
                        bIsException = TRUE; // This must be initialized FALSE
                        }
                    i += 1;
                    }
                if (!bIsException)
                    { // Then we actually want to put it in our output
                    #ifdef ESCPEINF_DEBUG
                    _ftprintf(stderr, TEXT("Match: %s in %s\n"),
                              FileName, LayoutInformation->Directory);
                    #endif
                    _ftprintf(Param->OutputFile, TEXT("\"%s\\%s\",%d,%s\n"),
                              Param->RealPath, FileName, Param->Num,
                              Param->SecurityString);
                    }
                }
            }
        }

    return TRUE;
    }


BOOL ProcessFileSecuritySection(FILE *InputFile, FILE *OutputFile,
                                PLAYOUT_CONTEXT LayoutContext)
    {
    TCHAR   InfLine[MAX_INF_LINE_LENGTH],
            FileName[MAX_INF_LINE_LENGTH],
            SecurityString[MAX_INF_LINE_LENGTH];
    BOOL    bValidFields;
    DWORD   Num;
    int     i;

    EXCEPTIONS      ExceptionList[MAX_EXCEPTIONS];


    #ifdef ESCPEINF_DEBUG
    _ftprintf(stderr, TEXT("Found [File Security] section.\n"));
    #endif

    while ((_fgetts(InfLine, MAX_INF_LINE_LENGTH, InputFile)) != NULL)
        {
        if (GetFields(InfLine, FileName, &Num, SecurityString) &&
            DoesNameContainWildCards(FileName))
            { // We found a line containing proper formatting and a wildcard
              // in the filename
            #ifdef ESCPEINF_DEBUG
            _ftprintf(stderr, TEXT("Wildcard line: %s"), InfLine);
            #endif
            // First find the exceptions to the wildcard
            FindExceptions(InputFile, ExceptionList);
            ExpandWildCard(FileName, Num, SecurityString, ExceptionList,
                           OutputFile, LayoutContext);
            }
        else
            {
            _fputts(InfLine, OutputFile);
            if (_tcsncmp(InfLine, TEXT("["), 1) == 0)
                {
                #ifdef ESCPEINF_DEBUG
                _ftprintf(stderr, TEXT("End of File Security section.\n"));
                #endif
                return TRUE;
                }
            }
        }

    return TRUE; // No Error
    }



// GetFields assumes the input line is in this format:
//      "filename",number,"securitystring"\n
// It extracts the filename and stores it in FileName. The quotes are removed
// from filename. It extracts and stores the number and security string if
// the filename is found. Quotes are not stripped from the security string.
// On error, it sets FileName to zero length, and returns FALSE.
BOOL GetFields(PTSTR InfLine, PTSTR FileName, DWORD *Num, PTSTR SecurityString)
    {
    int i = 0; // Pointer to current location in FileName

    // Leave now if the line does not contain a filename
    if ((InfLine[0] == (TCHAR)'[')  ||
        (InfLine[0] == (TCHAR)'\n') ||
        (InfLine[0] == (TCHAR)';'))
        {
        FileName[0] = (TCHAR)'\0'; // Set the end-of-string NULL marker to clear the string
        return FALSE;
        }

    // Check if line starts with a quotation mark
    if (InfLine[0] == (TCHAR)'\"')
        {
        // Copy everything until the next quotation mark
        while ((InfLine[i+1] != (TCHAR)'\"') && (InfLine[i+1] != (TCHAR)'\0'))
            {
            FileName[i] = InfLine[i+1];
            i += 1;
            }
        FileName[i] = (TCHAR)'\0'; // Set the end-of-string NULL marker
        i += 1; //  So we can use i without the +1 to access InfLine from now on
        }
    else // if the filename is not in quotes
        {
        FileName[0] = (TCHAR)'\0'; // Set the end-of-string NULL marker to clear the string
        return FALSE;
        }

    // It is posible that we left the above while loop because of premature end-of-line condtion.
    // If this is the case, clear the filename string and return.
    if (InfLine[i] == (TCHAR)'\0')
        {
        #ifdef ESCPEINF_DEBUG
        _ftprintf(stderr, TEXT("Reached End-of-Line without finding a filename\n"));
        _ftprintf(stderr, TEXT("Problem line is <%s>\n"), InfLine);
        _ftprintf(stderr, TEXT("Problem filename is <%s>\n"), FileName);
        #endif
        FileName[0] = (TCHAR)'\0'; // Set the end-of-string NULL marker to clear the string
        return FALSE;
        }
    else i++;   // Once we know that we aren't at the end-of-string, we can do this safely.
                // Now, however, we may be pointing to a zero-length string.

    if (_tcslen(FileName) <= 3)
        {
        #ifdef ESCPEINF_DEBUG
        _ftprintf(stderr, TEXT("Unexpected Result: Filename \"%s\" is only %d characters.\n"), FileName, i);
        #endif
        return FALSE;
        }

    #ifdef ESCPEINF_DEBUG
    //_ftprintf(stderr, TEXT("Found filename : %s\n"), FileName);
    #endif

    // Read the other two fields. If we got this far, we must have found a valid filename,
    // so we just assume that the other two are there.
    if (_stscanf(&InfLine[i], TEXT(",%ld,%s"), Num, SecurityString) != 2)
        { // then there was an error
        #ifdef ESCPEINF_DEBUG
        _ftprintf(stderr, TEXT("Error reading Num and Security String from line.\n"));
        _ftprintf(stderr, TEXT("Problem line is: %s\n"), &InfLine[i]);
        #endif
        FileName[0] = (TCHAR)'\0'; // Set the end-of-string NULL marker to clear the string
        return FALSE;
        }

    #ifdef ESCPEINF_DEBUG
    //_ftprintf(stderr, TEXT("Found rest of line : %lu,%s\n"), *Num, SecurityString);
    #endif

    return TRUE;
    }


void ExpandWildCard(PTSTR FileName, DWORD Num, PTSTR SecurityString,
                    EXCEPTIONS ExceptionList[], FILE *OutputFile,
                    PLAYOUT_CONTEXT LayoutContext)
    {
    MYPARAM Param;
    int     PathPos = 0;
    int     NamePos = 0;
    int     LastSlash = 0;
    TCHAR   WildCard[MAX_INF_LINE_LENGTH],
            RealPath[MAX_INF_LINE_LENGTH],
            LayoutPath[MAX_INF_LINE_LENGTH];


    while (FileName[NamePos] != (TCHAR)'\0')
        {
        if (FileName[NamePos] == (TCHAR)'\\')
            {
            LastSlash = NamePos;
            }
        NamePos += 1;
        }

    if (NamePos == (LastSlash + 1))
        return; // What? No filename? This should never happen.

    _tcsncpy(RealPath, FileName, LastSlash);
    RealPath[LastSlash] = (TCHAR)'\0';
    _tcscpy(WildCard, &FileName[LastSlash + 1]);
    _tcslwr(WildCard);

    #ifdef ESCPEINF_DEBUG
    _ftprintf(stderr, TEXT("Looking up Wildcard: %s\nin: %s\n"),
              WildCard, RealPath);
    #endif


    if (_tcsnicmp(RealPath, TEXT("%SystemDirectory%"), 17) == 0)
        {
        _tcscpy(LayoutPath, TEXT("System32"));
        _tcscpy(&LayoutPath[8], &RealPath[17]);
        }
    else if (_tcsnicmp(RealPath, TEXT("%SystemDir%"), 11) == 0)
        {
        _tcscpy(LayoutPath, TEXT("System32"));
        _tcscpy(&LayoutPath[8], &RealPath[11]);
        }
    else if (_tcsnicmp(RealPath, TEXT("%SystemRoot%"), 12) == 0)
        {
        if (LastSlash == 12)
            _tcscpy(LayoutPath, TEXT("\\"));
        else
            _tcscpy(LayoutPath, &RealPath[13]);
        }
    else
        {
        _ftprintf(stderr, TEXT("Path is unlikely to be in Layout.inf: %s\n"),
                  RealPath);
        _tcscpy(LayoutPath, RealPath);
        }

    #ifdef ESCPEINF_DEBUG
    _ftprintf(stderr, TEXT("Path in Layout.inf terms is: %s\n"), LayoutPath);
    #endif

    Param.OutputFile    = OutputFile;
    Param.ExceptionList = ExceptionList;
    Param.Num           = Num;
    Param.WildCard      = WildCard;
    Param.RealPath      = RealPath,
    Param.LayoutPath    = LayoutPath;
    Param.SecurityString= SecurityString;

    EnumerateLayoutInf(LayoutContext, MyCallback, (DWORD_PTR)&Param);

    return;
    }


void FindExceptions(FILE *InputFile, EXCEPTIONS ExceptionList[])
    {
    long    FilePosition;
    int     NumExceptions = 0,
            i;
    TCHAR   InfLine[MAX_INF_LINE_LENGTH];

    do
        {
        i = 0;
        FilePosition = ftell(InputFile); // Save file pointer
        if (_fgetts(InfLine, MAX_INF_LINE_LENGTH, InputFile) != NULL)
            {
            if ((_tcsnicmp(InfLine, TEXT("Exception=\""),  11) == 0) ||
                (_tcsnicmp(InfLine, TEXT("Exception:\""),  11) == 0))
                {
                while ((InfLine[i+11] != (TCHAR)'\"') &&
                    (InfLine[i+11] != (TCHAR)'\0'))
                    {
                    ExceptionList[NumExceptions].s[i] = InfLine[i+11];
                    i += 1;
                    }
                ExceptionList[NumExceptions].s[i] = (TCHAR)'\0';
                _tcslwr(ExceptionList[NumExceptions].s);

                #ifdef ESCPEINF_DEBUG
                _ftprintf(stderr, TEXT("Exception found: %s\n"),
                        ExceptionList[NumExceptions].s);
                #endif

                if (InfLine[i+11] == (TCHAR)'\0')
                    { // then we hit end of line without closing our quotes
                    _ftprintf(stderr, TEXT("Warning: Invalid Exception line.\n"));
                    _ftprintf(stderr, TEXT("Problem line is: %s\n"), InfLine);
                    }
                else NumExceptions += 1;
                }
            }
        }
    while (i > 0);
    ExceptionList[NumExceptions].s[0] = (TCHAR)'\0';
    if (fseek(InputFile, FilePosition, SEEK_SET) != 0) // Restore file pointer
        {
        _ftprintf(stderr, TEXT("Warning: Cannot seek within INF file! "));
        _ftprintf(stderr, TEXT("One line may be lost!\n"), InfLine);
        }
    // File pointer now points to the first line that is not an Exception line.

    return;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\win4\tools\infdump\infdump.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    infdump.c

Abstract:

    Program to access/dump information contained in Layout INFs in a readable
    format. It also supports various forms of querying of the layout INF.

Author:

    Vijesh Shetty (vijeshs)

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <wild.c>


#define DIRCODE TEXT("DirCode=")
#define DIRNAME TEXT("DirName=")
#define UPGATTR TEXT("UpgAttr=")
#define CLNATTR TEXT("CleanAttr=")
#define BOOTFIL TEXT("BootFile=")
#define COMPRESS TEXT("Compress=")
#define TARGNAME TEXT("TargetName=")
#define SIZEEQV TEXT("SizeEQ")
#define SIZEGRT TEXT("SizeGT")
#define SIZELESS TEXT("SizeLT")

#define DISPLAY TEXT("Display=")


typedef enum _SCOPE{
    AllFiles, //This means that we do it for every file present
    FileSpec  // This means we do this on every file that matches the filespec (with wildcard matching too)
}SCOPE, *PSCOPE;

typedef enum _QUERYTYPE{
    QUERYON_DIRCODE,
    QUERYON_DIRNAME,
    QUERYON_UPGRADEATTR,
    QUERYON_CLEANINSTALLATTR,
    QUERYON_BOOTFILE,
    QUERYON_COMPRESS,
    QUERYON_TARGETNAME,
    QUERYON_SIZEEQV,
    QUERYON_SIZEGRT,
    QUERYON_SIZELESS
}QUERYTYPE, *PQUERYTYPE;


typedef struct _QUERYPARAM{

    QUERYTYPE QueryType;
    BYTE Param[MAX_PATH];

}QUERYPARAM, *PQUERYPARAM;


typedef enum _DISPLAYOPTIONS{
    Default,
    TagInfo,
    FileOnly
} DISPLAYOPTIONS, *PDISPLAYOPTIONS;

typedef struct _QUERYSET{
    TCHAR LayoutFileName[MAX_PATH];
    TCHAR FileNameSpec[MAX_PATH];
    SCOPE Scope;
    int QueryClauses;
    QUERYPARAM QueryParam[20];
    DISPLAYOPTIONS DisplayOption;

} QUERYSET, *PQUERYSET;

QUERYSET GlobalQuerySet;


void
OutputFileInfo( PFILE_LAYOUTINFORMATION LayoutInformation,
                PCTSTR FileName,
                DISPLAYOPTIONS DispType,
                PMEDIA_INFO Media_Info );


BOOL
CALLBACK
MyCallback(
    IN PLAYOUT_CONTEXT Context,
    IN PCTSTR FileName,
    IN PFILE_LAYOUTINFORMATION LayoutInformation,
    IN PVOID ExtraData,
    IN UINT ExtraDataSize,
    IN OUT DWORD_PTR Param
    )
{

    PQUERYSET QuerySet;
    int i;
    BOOL Display=TRUE;


    if( GlobalQuerySet.Scope == FileSpec ){

        //Check if it matches wildcard..if not ignore this file

        if(!IsNameInExpressionPrivate(GlobalQuerySet.FileNameSpec, FileName))
            return( TRUE );
    }


    if( Param  ){

        QuerySet = (PQUERYSET)Param;


        //Process each clause

        for( i=0; i<QuerySet->QueryClauses;i++){

            Display=FALSE;
            switch( QuerySet->QueryParam[i].QueryType ){

            case QUERYON_DIRCODE:
                if( LayoutInformation->Directory_Code == (_ttoi((PTCHAR)(QuerySet->QueryParam[i].Param))))
                    Display = TRUE;

            case QUERYON_DIRNAME:
                if( !_tcsicmp( LayoutInformation->Directory,(PTCHAR)(QuerySet->QueryParam[i].Param)))
                    Display = TRUE;
                break;

            case QUERYON_UPGRADEATTR:
                if( LayoutInformation->UpgradeDisposition == (_ttoi((PTCHAR)(QuerySet->QueryParam[i].Param))))
                    Display = TRUE;
                break;

            case QUERYON_CLEANINSTALLATTR:
                if( LayoutInformation->CleanInstallDisposition == (_ttoi((PTCHAR)(QuerySet->QueryParam[i].Param))))
                    Display = TRUE;
                break;

            case QUERYON_BOOTFILE:
                if( LayoutInformation->BootMediaNumber && (LayoutInformation->BootMediaNumber != -1)){
                    if( !_tcsicmp((PTCHAR)(QuerySet->QueryParam[i].Param), TEXT("*")) )
                        Display = TRUE;
                    else if( LayoutInformation->BootMediaNumber == (_ttoi((PTCHAR)(QuerySet->QueryParam[i].Param))))
                        Display = TRUE;
                }
                break;

            case QUERYON_COMPRESS:
                if( !_tcsicmp((PTCHAR)(QuerySet->QueryParam[i].Param), TEXT("YES")) ){
                    if( LayoutInformation->Compression == TRUE )
                        Display = TRUE;
                }else if( !_tcsicmp((PTCHAR)(QuerySet->QueryParam[i].Param), TEXT("NO")) ){
                    if( LayoutInformation->Compression == FALSE )
                        Display = TRUE;
                }

                break;

            case QUERYON_TARGETNAME:
                if( IsNameInExpressionPrivate( (PTCHAR)(QuerySet->QueryParam[i].Param), LayoutInformation->TargetFileName))
                    Display = TRUE;
                break;


                //
                //  Have to fix so that we don't overflow.
                //


            case QUERYON_SIZEEQV:
                if( LayoutInformation->Size == (ULONG)(_ttol((PTCHAR)(QuerySet->QueryParam[i].Param))))
                    Display = TRUE;
                break;

            case QUERYON_SIZEGRT:
                if( LayoutInformation->Size > (ULONG)(_ttol((PTCHAR)(QuerySet->QueryParam[i].Param))))
                    Display = TRUE;
                break;

            case QUERYON_SIZELESS:
                if( LayoutInformation->Size < (ULONG)(_ttol((PTCHAR)(QuerySet->QueryParam[i].Param))))
                    Display = TRUE;
                break;


            default:
                Display = FALSE;
                break;

            }

            if( !Display )
                break;


        }

        if( Display  == TRUE ){
            if( QuerySet->DisplayOption == TagInfo ){
    
                BOOL ret=FALSE;
                MEDIA_INFO MediaInfo;
    
    
                ret = FindFileInLayoutInf( Context,
                                   FileName,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &MediaInfo);
                if (ret)
                    OutputFileInfo( LayoutInformation, FileName, QuerySet->DisplayOption, &MediaInfo );
    
    
            }else
                OutputFileInfo( LayoutInformation, FileName, QuerySet->DisplayOption, NULL );
    
        }


    }


    

    return( TRUE );




}



void
FindSingleFile( PLAYOUT_CONTEXT LayoutContext,
                PCTSTR FileName )
{

    BOOL ret=FALSE;
    FILE_LAYOUTINFORMATION LayoutInformation;
    MEDIA_INFO MediaInfo;

    ret = FindFileInLayoutInf( LayoutContext,
                               FileName,
                               &LayoutInformation,
                               NULL,
                               NULL,
                               &MediaInfo);


    if (ret)
        OutputFileInfo( &LayoutInformation, FileName, Default, &MediaInfo );
    else
        _ftprintf(stderr, TEXT("\nError: File Not Found\n"));


    return;



}



void
OutputFileInfo( PFILE_LAYOUTINFORMATION LayoutInformation,
                PCTSTR FileName,
                DISPLAYOPTIONS DispType,
                PMEDIA_INFO Media_Info )
{
    TCHAR Disposition[][50]={ TEXT("Always Copy"),
                             TEXT("Copy if present"),
                             TEXT("Copy if not present"),
                             TEXT("Never copy - Copied via INF")


    };

    if( DispType == FileOnly )
        _tprintf(TEXT("%s\n"),FileName);
    else
        _tprintf(TEXT("Filename         - %s\n"),FileName);

    if( DispType == FileOnly )
        return;

    _tprintf(TEXT("Dir Name         - %s(%d)\n"), LayoutInformation->Directory, LayoutInformation->Directory_Code);


    _tprintf(TEXT("On Upgrade       - %s(%d)\n"), Disposition[LayoutInformation->UpgradeDisposition], LayoutInformation->UpgradeDisposition);
    _tprintf(TEXT("On Clean Install - %s(%d)\n"), Disposition[LayoutInformation->CleanInstallDisposition], LayoutInformation->CleanInstallDisposition);

    _tprintf(TEXT("Media Tag ID     - %s\n"),LayoutInformation->Media_tagID);

    if( *(LayoutInformation->TargetFileName))
        _tprintf(TEXT("Target Filename  - %s\n"),LayoutInformation->TargetFileName);
    if( LayoutInformation->BootMediaNumber && (LayoutInformation->BootMediaNumber != -1))
        _tprintf(TEXT("Boot Media       - %d\n"),LayoutInformation->BootMediaNumber);
    if( !LayoutInformation->Compression )
        _tprintf(TEXT("No Compression\n"));
    if( LayoutInformation->Size > 0 )
        _tprintf(TEXT("Uncompressed Size- %d\n"),LayoutInformation->Size);
    if( LayoutInformation->Count > 1 )
        _tprintf(TEXT("Occurrences      - %d\n"),LayoutInformation->Count);



    if( Media_Info ){

        _tprintf(TEXT("Media Name       - %s\n"),Media_Info->MediaName);
        _tprintf(TEXT("Media Tagfile    - %s\n"),Media_Info->TagFilename);
        _tprintf(TEXT("Media Rootdir    - %s\n"),Media_Info->RootDir);


    }

    if( DispType != FileOnly )
        _tprintf( TEXT("\n"));


    return;

}


BOOL
ProcessCommandLine( int ArgCount, TCHAR *ArgArray[] )
/*
    Function to process the command line and seperate out options into tokens
*/
{

    int i, Next;
    LPTSTR Arg;
    TCHAR Temp[MAX_PATH];
    QUERYTYPE QType;

    ZeroMemory( &GlobalQuerySet, sizeof(QUERYSET));

    GlobalQuerySet.Scope = FileSpec;
    lstrcpy( GlobalQuerySet.FileNameSpec, TEXT("*") );
    GlobalQuerySet.DisplayOption = Default;
    lstrcpy( GlobalQuerySet.LayoutFileName, ArgArray[1] );



    Next = 0;
    for ( i=2;i < ArgCount;i++ ){ //Go through each directive


        Arg = ArgArray[i];

        if( Arg[0] != TEXT('/') )
            continue;

        switch( _toupper(Arg[1]) ){

        case TEXT('A'):
            GlobalQuerySet.Scope = AllFiles;
            break;

        case TEXT('S'):             //Query Clause ?

            //_tprintf(TEXT("S  -- %s"),Arg);

            if( Arg[2] != TEXT(':')) {
                return FALSE;
            }

            //Dir Code case

            if( ! _tcsnicmp( Arg+3, DIRCODE, lstrlen(DIRCODE))){

               lstrcpy( Temp, DIRCODE );
               QType = QUERYON_DIRCODE;
            }

            if( ! _tcsnicmp( Arg+3, DIRNAME, lstrlen(DIRNAME))){

               lstrcpy( Temp, DIRNAME );
               QType = QUERYON_DIRNAME;
            }

            if( ! _tcsnicmp( Arg+3, UPGATTR, lstrlen(UPGATTR))){

               lstrcpy( Temp, UPGATTR );
               QType = QUERYON_UPGRADEATTR;
            }

            if( ! _tcsnicmp( Arg+3, CLNATTR, lstrlen(CLNATTR))){

               lstrcpy( Temp, CLNATTR );
               QType = QUERYON_CLEANINSTALLATTR;
            }

            if( ! _tcsnicmp( Arg+3, BOOTFIL, lstrlen(BOOTFIL))){

               lstrcpy( Temp, BOOTFIL );
               QType = QUERYON_BOOTFILE;
            }

            if( ! _tcsnicmp( Arg+3, COMPRESS, lstrlen(COMPRESS))){

               lstrcpy( Temp, COMPRESS );
               QType = QUERYON_COMPRESS;
            }

            if( ! _tcsnicmp( Arg+3, TARGNAME, lstrlen(TARGNAME))){

               lstrcpy( Temp, TARGNAME );
               QType = QUERYON_TARGETNAME;
            }

            if( ! _tcsnicmp( Arg+3, DIRCODE, lstrlen(DIRCODE))){

               lstrcpy( Temp, DIRCODE );
               QType = QUERYON_DIRCODE;
            }

            if( ! _tcsnicmp( Arg+3, SIZEEQV, lstrlen(SIZEEQV))){
               lstrcpy( Temp, SIZEEQV );
               QType = QUERYON_SIZEEQV;
            }

            if( ! _tcsnicmp( Arg+3, SIZEGRT, lstrlen(SIZEGRT))){
               lstrcpy( Temp, SIZEGRT );
               QType = QUERYON_SIZEGRT;
            }

            if( ! _tcsnicmp( Arg+3, SIZELESS, lstrlen(SIZELESS))){
               lstrcpy( Temp, SIZELESS );
               QType = QUERYON_SIZELESS;
            }

            GlobalQuerySet.QueryParam[Next].QueryType = QType;
            GlobalQuerySet.QueryClauses++;
            if( *(Arg+3+lstrlen(Temp)) == TEXT('\0'))
                return FALSE;
            lstrcpy((LPTSTR)GlobalQuerySet.QueryParam[Next++].Param, Arg+3+lstrlen(Temp));
            break;

        case TEXT('D'):

            //_tprintf(TEXT("D  -- %s"),Arg);

            if( Arg[2] != TEXT(':'))
                return FALSE;


            if( !_tcsicmp( Arg+3, TEXT("DEFAULT")))
                GlobalQuerySet.DisplayOption = Default;
            else if( !_tcsicmp( Arg+3, TEXT("ALL")))
                GlobalQuerySet.DisplayOption = TagInfo;
            else if( !_tcsicmp( Arg+3, TEXT("FILEONLY")))
                GlobalQuerySet.DisplayOption = FileOnly;

            break;

        default:
            break;
        }
    }// for

    if( (GlobalQuerySet.Scope == FileSpec) && (ArgArray[2][0] != TEXT('/'))){
        lstrcpy( GlobalQuerySet.FileNameSpec, ArgArray[2] );
    }

    return( TRUE );
}

_cdecl _tmain( int argc, TCHAR *argv[ ], char *envp[ ] )
{
    PTSTR p;
    PWSTR InfName;
    PLAYOUT_CONTEXT LayoutContext;
    int StrLen;
    TCHAR LayoutFileName[MAX_PATH], FileName[MAX_PATH];
    LPWSTR *CmdlineV;
    int CmdlineC;
    BOOL ans = FALSE;
    int Result = 1;

    if(!pSetupInitializeUtils()) {
        _tprintf(TEXT("Initialize failure\n") );
        return 1;
    }

    //
    // Check Params.
    //
    if( argc < 3 ) {
        _tprintf(
               TEXT("Program to process layout inf file to gather information on file(s)\n\n")
               TEXT("Usage: %s <Inf Filename> [file specifier] [flags] [arguments]  \n")
               TEXT("<Inf Filename> - Layout File to examine\n")
               TEXT("[file specifier] - File name to query (accepts wildcards) - default is *\n")
               TEXT("/a - Enumerates information for all files (overrides file specifier)\n\n" )
               TEXT("/s:<property>=<value> - Query based on a property\n" )
               TEXT("    There could be multiple /s options and they are \"anded\"\n")
               TEXT("    /s:dircode=<value>  Looks for files that match the directory code specified\n")
               TEXT("    /s:dirname=<value>  Looks for files that match the directory path specified\n")
               TEXT("    /s:upgattr=<attr>   Looks for files that match the action attribute in the upgrade case\n")
               TEXT("    /s:cleanattr=<attr> Looks for files that match the action attribute in the clean install case\n")
               TEXT("       Valid <attr> values:\n")
               TEXT("          0 - Always Copy\n")
               TEXT("          1 - Copy if present\n")
               TEXT("          2 - Copy if not present\n")
               TEXT("          3 - Never copy - Copied via INF\n")
               TEXT("    /s:bootfile=<#>         Looks for files that reside on bootdisk # - * for any bootdisk\n")
               TEXT("    /s:compress=<yes/no>    Looks for files that match the compression flag. Default is Yes.\n")
               TEXT("    /s:targetname=<name>    Looks for files are renamed to \"name\" on copy\n\n")
               TEXT("    /s:size{EQ/LT/GT}<value>    Looks for files that satisfy the size condition specified (<= or >= not supported)\n")
               TEXT("                EQ#   - Equal to (No Space around operator)\n")
               TEXT("                LT#   - Lesser than (No Space around operator)\n")
               TEXT("                GT#   - Greater than (No Space around operator)\n")
               TEXT("/d:<display type> - The display format for files that match\n" )
               TEXT("   /d:default   - Display standard fields - no media tag info\n" )
               TEXT("   /d:fileonly  - Display filename only\n" )
               TEXT("   /d:all       - Display standard fields + media tag info\n" )
               TEXT("\n")
               , argv[0] );
        Result = 1;
        goto cleanup;
    }

    if( !ProcessCommandLine( argc, argv ) ) {
        Result = 0;
        goto cleanup;
    }

    _ftprintf( stderr, TEXT("\nParsing Layout file...wait...\n"));
    LayoutContext = BuildLayoutInfContext( GlobalQuerySet.LayoutFileName, LAYOUTPLATFORMS_ALL, 0);
    if( !LayoutContext ){
        _ftprintf(stderr,TEXT("\nError - Could not build Layout Inf context\n"));
        Result = -1;
        goto cleanup;
    }

    if( argc < 3 ){
        //DoMenu( LayoutContext );
        Result = 0;
        goto cleanup;
    }

    EnumerateLayoutInf( LayoutContext, MyCallback, (DWORD_PTR)&GlobalQuerySet );

    CloseLayoutInfContext( LayoutContext );

    Result = 0;

cleanup:

    pSetupUninitializeUtils();

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\win4\tools\inftest\precomp.h ===
#include "inftest.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\win4\tools\inftest\inftest.h ===
#include <stdio.h>
#include <windows.h>
#include <conio.h>
#include <process.h>
#include <tchar.h>
#include <objbase.h>
#include <inflib.h>
#include <string.h>
#include <sputils.h>

#define NOSPEW 0
#define BRIEF 1
#define DETAIL 2

#define WINNT32_PHASE 1
#define LOADER_PHASE 2
#define TEXTMODE_PHASE 4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\win4\tools\infdump\precomp.h ===
#include "infdump.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\win4\tools\inftest\inftest.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    myapp.c

Abstract:

    This module implements functions to access the parsed INF.

Author:

    Vijesh Shetty (vijeshs)

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <wild.c>

#define PRINT( msg, param ) \
    {  _tprintf( TEXT(msg), param ); \
       if(g_Display == Default ){ \
            _tprintf( TEXT("\n")); \
       }else if(g_Display == FileOnly ){ \
            _tprintf( TEXT(" - ")); }\
    }


#define ERROROUT  \
        { g_Pass = FALSE; \
        OutputFileInfo( LayoutInformation, FileName, g_Display ); \
        return TRUE;}
        
extern BOOL Verbose;

extern DWORD
LoadInfFile(
   IN  LPCTSTR Filename,
   IN  BOOL    OemCodepage,
   OUT PVOID  *InfHandle,
   DWORD      Phase
   );

BOOL
CALLBACK
MyCallback(
    IN PLAYOUT_CONTEXT Context,
    IN PCTSTR FileName,
    IN PFILE_LAYOUTINFORMATION LayoutInformation,
    IN PVOID ExtraData,
    IN UINT ExtraDataSize,
    IN OUT DWORD_PTR Param
    );

typedef enum _DISPLAYOPTIONS{
    Default,
    FileOnly
} DISPLAYOPTIONS, *PDISPLAYOPTIONS;

typedef enum _CHECKSUITE{
    Deflt,
    Build
} CHECKSUITE, *PCHECKSUITE;

DISPLAYOPTIONS g_Display = Default;
CHECKSUITE g_CheckSuite = Deflt;
TCHAR g_LayoutFileName[MAX_PATH];
DWORD g_Platform=LAYOUTPLATFORMS_COMMON;
BOOLEAN g_Warning = FALSE;
BOOLEAN g_Pass = TRUE;
DWORD g_Phase = TEXTMODE_PHASE;
PLAYOUTENUMCALLBACK g_Callback = (PLAYOUTENUMCALLBACK) MyCallback;

BOOLEAN
IsNameInExpressionPrivate (
    IN PCTSTR Expression,
    IN PCTSTR Name
    );

void
OutputFileInfo( PFILE_LAYOUTINFORMATION LayoutInformation,
                PCTSTR FileName,
                DISPLAYOPTIONS DispType );



/*******************************************************************************/

//  Validation Check Functions
//



BOOL
Validate8Dot3(
    IN PCTSTR FileName )
/*
    Function to check if a file satisfies 8.3
    
    Arguments:
    
        FileName - Filename to validate
        
    Return value:
        
        TRUE  - Passes validation
        FALSE - Fails validation        
  
*/
{

    //
    //  Check for 8.3 validation
    //


    if( (g_Platform & LAYOUTPLATFORMS_IA64) ||
        (g_Platform & LAYOUTPLATFORMS_AMD64) )
        return TRUE;

    if( FileName && (lstrlen(FileName) > 12)){
        PRINT( "%s : Error E0000 : !!! - Filename too long (8.3 required)", g_LayoutFileName );
        return FALSE;
    }

    return TRUE;


}


BOOL
ValidateMissingDirCodes(
    IN PFILE_LAYOUTINFORMATION LayoutInformation )
/*
    Function to check if a file is missing Directory Information when it is needed by textmode
    
    Arguments:
    
        LayoutInformation - Pointer to PFILE_LAYOUTINFORMATION structure for file
        
    Return value:
        
        TRUE  - Passes validation
        FALSE - Fails validation        
  
*/
{

    //
    //  Check for Directory codes
    //

    if( ((LayoutInformation->CleanInstallDisposition <= 2) || (LayoutInformation->UpgradeDisposition <= 2))
        && !(*LayoutInformation->Directory)){
        PRINT( "%s : Error E0000 : !!! - Missing directory for textmode setup", g_LayoutFileName );
        return FALSE;
    }

    return TRUE;

}

BOOL
ValidateBootMediaFields(
    IN PFILE_LAYOUTINFORMATION LayoutInformation )
/*
    Function to check if the Boot Media fields are set right
    
    Arguments:
    
        LayoutInformation - Pointer to PFILE_LAYOUTINFORMATION structure for file
        
    Return value:
        
        TRUE  - Passes validation
        FALSE - Fails validation        
  
*/
{

    if( (LayoutInformation->BootMediaNumber < 0) || (LayoutInformation->BootMediaNumber > 6)
        || (LayoutInformation->BootMediaNumber == -1) ){

        PRINT( "%s : Error E0000 : !!! - Bad Boot media number", g_LayoutFileName );
        return FALSE;
    }

    return TRUE;


}


BOOL
ValidateSingleInstance(
    IN PFILE_LAYOUTINFORMATION LayoutInformation )
/*
    Function to check if there is only a single instance of this file
    
    Arguments:
    
        LayoutInformation - Pointer to PFILE_LAYOUTINFORMATION structure for file
        
    Return value:
        
        TRUE  - Passes validation
        FALSE - Fails validation        
  
*/
{

    if( LayoutInformation->Count > 1 ){
        PRINT( "%s : Error E0000 : !!! - Filename present in more than one place", g_LayoutFileName );
        return FALSE;
    }

    return TRUE;

}


BOOL
CheckForTurdDirCodes(
    IN PFILE_LAYOUTINFORMATION LayoutInformation )
/*
    Function to check if the dir code is present but doesn't make sense with respect to dispositions
    
    Arguments:
    
        LayoutInformation - Pointer to PFILE_LAYOUTINFORMATION structure for file
        
    Return value:
        
        TRUE  - Not a Turd
        FALSE - Presence of a turd
  
*/
{

    if( ((LayoutInformation->CleanInstallDisposition == 3) && (LayoutInformation->UpgradeDisposition == 3)) \
            && (*LayoutInformation->Directory)){
            PRINT( "%s : Warning W0000 : !!! - Directory code specified but not used", g_LayoutFileName );
            return FALSE;
    }

    return TRUE;
            

}


/***********End Validation Check Functions*****************************************/

/***********Callback Routines*************************************/

BOOL
CALLBACK
MyCallback(
    IN PLAYOUT_CONTEXT Context,
    IN PCTSTR FileName,
    IN PFILE_LAYOUTINFORMATION LayoutInformation,
    IN PVOID ExtraData,
    IN UINT ExtraDataSize,
    IN OUT DWORD_PTR Param
    )
{
    BOOL Error=FALSE;



    //  Check for missing filename

    if( !FileName || !(*FileName) ){
        PRINT( "%s : Error E0000 :!!! - Line missing filename\n", FileName );
        ERROROUT;
    }
        

    
    //
    //  Check for 8.3 validation
    //

    if( !Validate8Dot3( FileName ))
        ERROROUT;

    //
    //  Check for Directory codes
    //

    if( !ValidateMissingDirCodes( LayoutInformation))
        ERROROUT;

    //
    //  Check for Boot Media validity
    //

    if (!ValidateBootMediaFields( LayoutInformation))
        ERROROUT;

    //
    // Check for duplicates
    //


    if (!ValidateSingleInstance( LayoutInformation ))
        ERROROUT;

    
    
    if( g_Warning ){            
        if( !CheckForTurdDirCodes( LayoutInformation ))
            OutputFileInfo( LayoutInformation, FileName, g_Display );

    }


    return( TRUE );




}

CALLBACK
BuildCheckCallback(
    IN PLAYOUT_CONTEXT Context,
    IN PCTSTR FileName,
    IN PFILE_LAYOUTINFORMATION LayoutInformation,
    IN PVOID ExtraData,
    IN UINT ExtraDataSize,
    IN OUT DWORD_PTR Param
    )
{
    BOOL Error=FALSE;



    //  Check for missing filename

    if( !FileName || !(*FileName) ){
        PRINT( "%s : Error E0000 :!!! - Line missing filename\n", FileName );
        ERROROUT;
    }
        

    
    //
    //  Check for 8.3 validation
    //

    if( !Validate8Dot3( FileName ))
        ERROROUT;

    //
    //  Check for Directory codes
    //

    if( !ValidateMissingDirCodes( LayoutInformation))
        ERROROUT;

    //
    //  Check for Boot Media validity
    //

    if (!ValidateBootMediaFields( LayoutInformation))
        ERROROUT;

    //
    // Check for duplicates
    //


    if (!ValidateSingleInstance( LayoutInformation ))
        ERROROUT;

    
    
    if( g_Warning ){            
        if( !CheckForTurdDirCodes( LayoutInformation ))
            OutputFileInfo( LayoutInformation, FileName, g_Display );

    }


    return( TRUE );




}


/******************End Callback Routines**********************************************/



void
FindSingleFile( PLAYOUT_CONTEXT LayoutContext,
                PCTSTR FileName )
{

    BOOL ret=FALSE;
    FILE_LAYOUTINFORMATION LayoutInformation;
    MEDIA_INFO MediaInfo;

    ret = FindFileInLayoutInf( LayoutContext,
                               FileName,
                               &LayoutInformation,
                               NULL,
                               NULL,
                               &MediaInfo);


    if (ret)
        OutputFileInfo( &LayoutInformation, FileName, Default );
    else
        _ftprintf(stderr, TEXT("\nError: File Not Found\n"));


    return;



}



void
OutputFileInfo( PFILE_LAYOUTINFORMATION LayoutInformation,
                PCTSTR FileName,
                DISPLAYOPTIONS DispType
                )
{
    TCHAR Disposition[][50]={ TEXT("Always Copy"),
                             TEXT("Copy if present"),
                             TEXT("Copy if not present"),
                             TEXT("Never copy - Copied via INF")


    };

    if( DispType == FileOnly )
        _tprintf(TEXT("%s\n"),FileName);
    else
        _tprintf(TEXT("Filename         - %s\n"),FileName);

    if( DispType == FileOnly )
        return;

    _tprintf(TEXT("Dir Name         - %s(%d)\n"), LayoutInformation->Directory, LayoutInformation->Directory_Code);


    _tprintf(TEXT("On Upgrade       - %s(%d)\n"), Disposition[LayoutInformation->UpgradeDisposition], LayoutInformation->UpgradeDisposition);
    _tprintf(TEXT("On Clean Install - %s(%d)\n"), Disposition[LayoutInformation->CleanInstallDisposition], LayoutInformation->CleanInstallDisposition);

    _tprintf(TEXT("Media Tag ID     - %s\n"),LayoutInformation->Media_tagID);

    if( *(LayoutInformation->TargetFileName))
        _tprintf(TEXT("Target Filename  - %s\n"),LayoutInformation->TargetFileName);
    if( LayoutInformation->BootMediaNumber && (LayoutInformation->BootMediaNumber != -1))
        _tprintf(TEXT("Boot Media       - %d\n"),LayoutInformation->BootMediaNumber);
    if( !LayoutInformation->Compression )
        _tprintf(TEXT("No Compression\n"));


    if( DispType != FileOnly )
        _tprintf( TEXT("\n"));


    return;

}


BOOL
ProcessCommandLine( int ArgCount, TCHAR *ArgArray[] )
/*
    Function to process the command line and seperate out options into tokens
*/
{

    int i;
    LPTSTR Arg;

    if( ArgCount >= 1)
        lstrcpy( g_LayoutFileName, ArgArray[1] );

    if( !_tcsrchr( g_LayoutFileName, TEXT('\\'))){
        GetCurrentDirectory( MAX_PATH, g_LayoutFileName );
        MyConcatenatePaths(g_LayoutFileName,ArgArray[1],MAX_PATH);

    }


    for ( i=2;i < ArgCount;i++ ){ //Go through each directive


        Arg = ArgArray[i];

        if( (Arg[0] != TEXT('/')) && (Arg[0] != TEXT('-')))
            continue;

        if(_istlower(Arg[1]))
            Arg[1] = _toupper(Arg[1]);

        switch( Arg[1] ){

        case TEXT('F'):
            g_Display = FileOnly;
            break;

        case TEXT('A'):
            g_Platform |= LAYOUTPLATFORMS_AMD64;
            break;

        case TEXT('I'):
            g_Platform |= LAYOUTPLATFORMS_X86;
            break;

        case TEXT('M'):
            g_Platform |= LAYOUTPLATFORMS_IA64;
            break;

        case TEXT('W'):
            g_Warning = TRUE;
            break;

        case TEXT('V'):
            if( _ttoi(Arg+2) == BRIEF )
                Verbose = BRIEF;
            else if(_ttoi(Arg+2) == DETAIL )
                Verbose = DETAIL;
            else
                Verbose = BRIEF;
            break;

        case TEXT('D'):
            g_Phase = WINNT32_PHASE;
            break;

        case TEXT('L'):
            g_Phase = LOADER_PHASE;
            break;

        case TEXT('T'):
            g_Phase = TEXTMODE_PHASE;
            break;

        case TEXT('B'):
            g_CheckSuite = Build;
            break;



        default:
            break;
        }





    }// for

    return( TRUE );


}



void 
BuildValidations( void )
/*

    Main processing routine while using the /B - Build switch
    Runs the suite of validations for this situation

*/
{
    BOOL LayoutInf = FALSE;
    PLAYOUT_CONTEXT LayoutContext;
    PVOID InfHandle;
    DWORD Error;

    // Set the globals accordingly

    g_Display = FileOnly;


    // We set LayoutInf if we are validating it. In the build case
    // we only validate layout info for layout.inf. All others should be only
    // syntax checks.

    if(_tcsstr( g_LayoutFileName, TEXT("layout.inf")))          
        LayoutInf = TRUE;

    
    // Run the sematic validation tests only for layout.inf in the build case

    if( LayoutInf ){

        g_Phase = 0;
    
        LayoutContext = BuildLayoutInfContext( g_LayoutFileName, g_Platform, 0);
        if( !LayoutContext ){
            g_Pass = FALSE;
            _tprintf(TEXT("%s : Error E0000 : Could not build Layout Inf context\n"), g_LayoutFileName);
            return;
        }

        
    
        //Callback will set the right value of g_pass on error.
    
        EnumerateLayoutInf( LayoutContext, BuildCheckCallback, 0 );
    
        CloseLayoutInfContext( LayoutContext );

        if(!ValidateTextmodeDirCodesSection( g_LayoutFileName, TEXT("WinntDirectories") ))
            g_Pass = FALSE;

    }
    
    if (g_Phase & TEXTMODE_PHASE){

        _tprintf( TEXT("Checking %s for compliance with the textmode setup INF parser\n"),g_LayoutFileName);
        if( (Error=LoadInfFile(g_LayoutFileName,FALSE,&InfHandle,TEXTMODE_PHASE)) != NO_ERROR ){
            _tprintf( TEXT("%s : Error E0000 : Not compliant with Textmode Setup's parser - %i\n"), g_LayoutFileName, Error );
            g_Pass = FALSE;
        }else
            _tprintf( TEXT("Compliant with Textmode Setup's Parser\n"), Error );
    }
    if (g_Phase & LOADER_PHASE){

        _tprintf( TEXT("Checking %s for compliance with the Loader's INF parser\n\n"),g_LayoutFileName);
        if( (Error=LoadInfFile(g_LayoutFileName,FALSE,&InfHandle,LOADER_PHASE)) != NO_ERROR ){
            _tprintf( TEXT("%s : Error E0000 : Not compliant with Loader's parser - %i\n"), g_LayoutFileName, Error );
            g_Pass = FALSE;
        }else
            _tprintf( TEXT("Compliant with Loader's Parser\n"), Error );

    }
        
    if (g_Phase & WINNT32_PHASE) {

        _tprintf( TEXT("Checking %s for compliance with the Winnt32 INF parser\n\n"),g_LayoutFileName);
        if( (Error=LoadInfFile(g_LayoutFileName,FALSE,&InfHandle,WINNT32_PHASE)) != NO_ERROR ){
            _tprintf( TEXT("%s : Error E0000 : Not compliant with Winnt32's parser - %i\n"), g_LayoutFileName, Error );
            g_Pass = FALSE;
        }else
            _tprintf( TEXT("Compliant with Winnt32's Parser\n"), Error );

    }
        

    





}



void 
DefaultValidations( void )
/*

    Main processing routine while using the /B - Build switch
    Runs the suite of validations for this situation

*/
{
    BOOL TxtSetupSif = FALSE;
    PLAYOUT_CONTEXT LayoutContext;
    PVOID InfHandle;
    DWORD Error;


    // We set TxtSetupSif if we are validating it. That is the only case where we need to 
    // do syntax checks with loader and textmode along with Layout validation.

    if(_tcsstr( g_LayoutFileName, TEXT("txtsetup.sif")) 
       || _tcsstr( g_LayoutFileName, TEXT("layout.inf"))){
        TxtSetupSif = TRUE;
    }
        



    if( TxtSetupSif ){
    
        // Run the semantic validation tests
    
        LayoutContext = BuildLayoutInfContext( g_LayoutFileName, g_Platform, 0);
        if( !LayoutContext ){
            g_Pass = FALSE;
            _tprintf(TEXT("\nError - Could not build Layout Inf context\n"));
            return;
        }
    
        //Callback will set the right value of g_pass on error.
    
        EnumerateLayoutInf( LayoutContext, MyCallback, 0 );
    
        CloseLayoutInfContext( LayoutContext );

        if(!ValidateTextmodeDirCodesSection( g_LayoutFileName, TEXT("WinntDirectories") ))
            g_Pass = FALSE;

    }
    

    


    if ((g_Phase & TEXTMODE_PHASE) || TxtSetupSif){

        _ftprintf( stderr, TEXT("\nChecking %s for compliance with the textmode setup INF parser\n\n"),g_LayoutFileName);
        if( (Error=LoadInfFile(g_LayoutFileName,FALSE,&InfHandle,TEXTMODE_PHASE)) != NO_ERROR ){
            _tprintf( TEXT("%s : Not compliant with Textmode Setup's parser - %i\n"), g_LayoutFileName, Error );
            g_Pass = FALSE;
        }else
            _tprintf( TEXT("Compliant with Textmode Setup's Parser\n"), Error );
    }
    if (g_Phase & LOADER_PHASE  || TxtSetupSif){

        _ftprintf( stderr, TEXT("\nChecking %s for compliance with the Loader's INF parser\n\n"),g_LayoutFileName);
        if( (Error=LoadInfFile(g_LayoutFileName,FALSE,&InfHandle,LOADER_PHASE)) != NO_ERROR ){
            _tprintf( TEXT("%s : Not compliant with Loader's parser - %i\n"), g_LayoutFileName, Error );
            g_Pass = FALSE;
        }else
            _tprintf( TEXT("Compliant with Loader's Parser\n"), Error );

    }
        
    if (g_Phase & WINNT32_PHASE) {

        _ftprintf( stderr, TEXT("\nChecking %s for compliance with the Winnt32 INF parser\n\n"),g_LayoutFileName);
        if( (Error=LoadInfFile(g_LayoutFileName,FALSE,&InfHandle,WINNT32_PHASE)) != NO_ERROR ){
            _tprintf( TEXT("%s : Not compliant with Winnt32's parser - %i\n"), g_LayoutFileName, Error );
            g_Pass = FALSE;
        }else
            _tprintf( TEXT("Compliant with Winnt32's Parser\n"), Error );

    }



    

}

_cdecl _tmain( int argc, TCHAR *argv[ ], char *envp[ ] )
{
    LPWSTR *CmdlineV;
    int CmdlineC;

    if(!pSetupInitializeUtils()) {
        return 1;
    }

    //
    // Check Params.
    //
    if( (argc < 2) || !_tcscmp(argv[1],TEXT("/?")) ) {
        _tprintf(TEXT("Program to validate/verify the given layout inf file\n\n")
                 TEXT("Usage: %s <Inf Filename> [options]\n")
                 TEXT("<Inf Filename> - Layout File to examine\n")
                 TEXT("Options for layout.inf and txtsetup.sif (automatically checks loader and textmode syntax):-\n")
                 TEXT("/W - Enable warnings too\n\n")
                 TEXT("Checking of Platform specific SourceDisksFiles section\n")
                 TEXT("/F - Display only filenames\n")
                 TEXT("/I - Process for Intel i386\n")
                 TEXT("/A - Process for AMD AMD64\n")
                 TEXT("/M - Process for Intel IA64\n")
                 TEXT("By default the parser will check for compliance with the textmode setup parser\n\n")
                 TEXT("The below checks only perform a syntax check and don't check semantics.\n")
                 TEXT("/D - Checks for compliance with winnt32 parser - use with dosnet.inf,mblclean.inf etc.\n")
                 TEXT("/L - Checks for compliance with the loader - use for infs used by loader - biosinfo.inf, migrate.inf etc.\n")
                 TEXT("/T - Checks for compliance with the textmode setup - use for hive*.inf etc.\n\n")
                 TEXT("/B - Does the layout information checks for setup infs and uses build.exe compliant error reporting\n\n")
                  , argv[0] );
        goto cleanup;
    }

    if( !ProcessCommandLine( argc, argv ) ) {
        g_Pass = FALSE;
        goto cleanup;
    }

    switch( g_CheckSuite ){
    
    
    case Build:
        BuildValidations();
        break;

    case Deflt:
        DefaultValidations();
        break;

    default:
        //Shouldn't get here as g_CheckSuite is initialized to Default
        _tprintf( TEXT("\nUnexpected error \n"));
        g_Pass=FALSE;
        break;


    }

    if( g_Pass )
        _tprintf( TEXT("\nNo problems found with %s\n"), g_LayoutFileName);
    else
        _tprintf( TEXT("\nErrors were encountered with %s.\n"), g_LayoutFileName);
    
cleanup:

    pSetupUninitializeUtils();

    return (g_Pass ? 0:1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\win4\tools\ocinf\ocinf.c ===
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <setupapi.h>
#include <crt\string.h>
#include <sputils.h>
#include <tchar.h>

/*
============================================================================

Compute the disk space requirements for all OC components.

============================================================================
*/



//
// Handle to the inf we're operating on.
//
HINF    hInputinf;
HINF    hLayoutinf;


//
// Initialize input parameters.
//
BOOL    Verbose     = FALSE;
TCHAR   InfPath[MAX_PATH];
PCWSTR  InputInf    = NULL;
PCWSTR  LayoutPath  = NULL;

//
// backward-compatible SetupGetInfSections
//
#undef SetupGetInfSections
BOOL
SetupGetInfSections (
    IN  HINF        InfHandle,
    OUT PTSTR       Buffer,         OPTIONAL
    IN  UINT        Size,           OPTIONAL
    OUT UINT        *SizeNeeded     OPTIONAL
    );



//
// ============================================================================
//
// Find out what the user wants us to do.
//
// ============================================================================
//
BOOL GetParams(
    int argc,
    char *argv[ ]
    )
{
char    *p;
int     i;
PTSTR   tstr_ptr = NULL;


    for( i = 0; i < argc; i++ ) {
        if( *argv[i] == '-' ) {
            p = argv[i];


            //
            // Verbose?
            //
            if( !_strcmpi( p, "-v" ) ) {
                Verbose = TRUE;
                continue;
            }


            //
            // Inf file?
            //
            if( !_strnicmp( p, "-inf:", 5 ) ) {
                p = p + 5;
                InputInf = pSetupAnsiToUnicode(p);

                //
                // Now extract the path for this inf.
                //
                lstrcpy( InfPath, InputInf );
                tstr_ptr = wcsrchr( InfPath, TEXT( '\\' ) );
                if( tstr_ptr ) {
                    *tstr_ptr = 0;
                }

                continue;
            }



            //
            // Files location location?
            //
            if( !_strnicmp( p, "-layout:", 8 ) ) {
                p = p + 8;
                LayoutPath = pSetupAnsiToUnicode(p);
                continue;
            }

        }
    }

    //
    // Check Params.
    //
    if( InfPath == NULL ) {
        return FALSE;
    }


    if( LayoutPath == NULL ) {
        return FALSE;
    }


    return TRUE;
}

//
// ============================================================================
//
// Tell the user how to use us.
//
// ============================================================================
//
void Usage( )
{
    printf( "Compute disk space requirements for files listed in an inf\n" );
    printf( "\n" );
    printf( "\n" );
    printf( "    -inf:<path>   This is the path to the inf (including the\n" );
    printf( "                  inf file name).  E.g. -inf:c:\\dosnet.inf\n" );
    printf( "\n" );
    printf( "    -layout:<path> This is the path to layout.inf (including the\n" );
    printf( "                  inf file name).  E.g. -inf:c:\\layout.inf\n" );
    printf( "\n" );
    printf( "    -v            Run in verbose mode.\n" );
    printf( "\n" );
    printf( "\n" );
}




//
// ============================================================================
//
// Process a single section in the inf.
//
// ============================================================================
//
VOID
ProcessInf(
    HINF    hInputinf,
    PTSTR   TargetInfPath
    )
/*

    Process the inf.  Look at each section and ask SetupApi to give us the
    disk space requirements for installing this section.  If we get input
    back from setupapi, then update the SizeApproximation entry in this
    section.

*/
{


DWORD       SizeNeeded = 0;
PTSTR       Sections,CurrentSection;
HDSKSPC     hDiskSpace;
BOOL        b;
TCHAR       CurrentDrive[MAX_PATH];
LONGLONG    SpaceRequired;
DWORD       dwError;


    //
    // get a list of all the sections in this inf.
    //
    if( !SetupGetInfSections(hInputinf, NULL, 0, &SizeNeeded) ) {
        fprintf( stderr, "Unable to get section names, ec=0x%08x\n", GetLastError());
        return;
    }

    if( SizeNeeded == 0 ) {
        fprintf( stderr, "There are no sections in this file.\n");
        return;
    }

    Sections = pSetupMalloc (SizeNeeded + 1);
    if (!Sections) {
        fprintf( stderr, "Unable to allocate memory, ec=0x%08x\n", GetLastError());
        return;
    }

    if(!SetupGetInfSections(hInputinf, Sections, SizeNeeded, NULL) ) {
        fprintf( stderr, "Unable to get section names, ec=0x%08x\n", GetLastError());
        return;
    }


    if( Verbose ) {
        fprintf( stderr, "\nProcessing inf file: %ws.\n", TargetInfPath );
    }

    //
    // Now process each section.
    //
    CurrentSection = Sections;
    while( *CurrentSection ) {


        if( Verbose ) {
            fprintf( stderr, "\tProcessing Section: %ws.\n", CurrentSection );
        }



        //
        // Get a diskspace structure.
        //
        hDiskSpace = SetupCreateDiskSpaceList( NULL, 0, SPDSL_IGNORE_DISK );

        if( !hDiskSpace ) {
            fprintf( stderr, "\t\tUnable to allocate a DiskSpace structure. ec=0x%08x\n", GetLastError());
            continue;
        }


        b = SetupAddInstallSectionToDiskSpaceList( hDiskSpace,
                                                   hInputinf,
                                                   hLayoutinf,
                                                   CurrentSection,
                                                   0,
                                                   0 );



        if( b ) {

            //
            // There must have been a copyfile section and we got some info.
            //


            //
            // Figure out which drive we're running on.  we're going to
            // assume that this disk has a reasonable cluster-size and just
            // use it.
            //
            if( !GetWindowsDirectory( CurrentDrive, MAX_PATH ) ) {
                fprintf( stderr, "\t\tUnable to retrieve current directory. ec=0x%08x\n", GetLastError());
                continue;
            }

            CurrentDrive[2] = 0;

            if( Verbose ) {
                fprintf( stderr, "\t\tChecking space requirements on drive %ws.\n", CurrentDrive );
            }


            //
            // Now query the disk space requirements against this drive.
            //
            SpaceRequired = 0;
            b = SetupQuerySpaceRequiredOnDrive( hDiskSpace,
                                                CurrentDrive,
                                                &SpaceRequired,
                                                NULL,
                                                0 );


            if( !b ) {
                //
                // This probably happened because there was no CopyFiles section.
                //
                dwError = GetLastError();
                if( dwError != ERROR_INVALID_DRIVE ) {
                    fprintf( stderr, "\t\tUnable to query space requirements. ec=0x%08x\n", GetLastError());
                } else {
                    if( Verbose ) {
                        fprintf( stderr, "\t\tI don't think this section has a CopyFiles entry.\n");
                    }
                }
            }


            //
            // We got the space requirements.  now all we have to do is spew them into the inf.
            //

            if( Verbose ) {
                fprintf( stderr, "\t\tRequired space: %I64d\n", SpaceRequired );
            }


            if( SpaceRequired > 0 ) {

                swprintf( CurrentDrive, TEXT("%I64d"), SpaceRequired );

                b = WritePrivateProfileString( CurrentSection,
                                               TEXT("SizeApproximation"),
                                               CurrentDrive,
                                               TargetInfPath );

                if( !b ) {
                    fprintf( stderr, "\t\tUnable to write space requirements to %ws. ec=0x%08x\n", InfPath, GetLastError());
                    continue;
                }
            }
        }

        //
        // Free that diskspace structure.
        //
        SetupDestroyDiskSpaceList( hDiskSpace );

        CurrentSection += lstrlen(CurrentSection) + 1;

    }

    pSetupFree( Sections );

}


int
__cdecl
main( int argc, char *argv[ ], char *envp[ ] )
{
INFCONTEXT  InputContext;
LONG        i, LineCount;
BOOL        b;
TCHAR       TargetInfPath[MAX_PATH];
TCHAR       FileName[MAX_INF_STRING_LENGTH];
HINF        hTargetInf;
int         Result = 1;

    //
    // Check Params.
    //
    if(!pSetupInitializeUtils()) {
        fprintf( stderr, "Initialization failed\n" );
        return 1;
    }

    if( !GetParams( argc, argv ) ) {
        Usage();
        Result = 1;
        goto cleanup;
    }

    //
    // Open the inf file.
    //
    hInputinf = SetupOpenInfFileW( InputInf, NULL, INF_STYLE_WIN4, NULL );
    if( hInputinf == INVALID_HANDLE_VALUE ) {
        if( Verbose ) {
            fprintf( stderr, "The file %ws was not opened!\n", InputInf );
        }
        Result = 1;
        goto cleanup;
    }

    //
    // Open the specified layout.inf file.
    //
    hLayoutinf = SetupOpenInfFileW( LayoutPath, NULL, INF_STYLE_WIN4, NULL );
    if( hLayoutinf == INVALID_HANDLE_VALUE ) {
        if( Verbose ) {
           fprintf( stderr, "The file %ws was not opened!\n", LayoutPath );
        }
        Result = 1;
        goto cleanup;
    }


    //
    // Now loop through all the entries in the "components"
    // section and process their infs.
    //
    LineCount = SetupGetLineCount( hInputinf,
                                   TEXT("Components") );

    for( i = 0; i < LineCount; i++ ) {

        //
        // Get this line.
        //
        b = SetupGetLineByIndex( hInputinf,
                                 TEXT("Components"),
                                 i,
                                 &InputContext );

        if( b ) {
            //
            // got it.  Get the inf name for this component (there
            // may not be one).
            //
            if(SetupGetStringField(&InputContext, 3,FileName,MAX_INF_STRING_LENGTH,NULL) &&
                FileName[0] != TEXT('\0')) {

                //
                // Yep, there's an inf that we need to look at.
                // Build a path to it and open a handle to it.
                //
                lstrcpy( TargetInfPath, InfPath );
                lstrcat( TargetInfPath, TEXT("\\") );
                lstrcat( TargetInfPath, FileName );

                hTargetInf = SetupOpenInfFileW( TargetInfPath, NULL, INF_STYLE_WIN4, NULL );
                if( hTargetInf == INVALID_HANDLE_VALUE ) {
                    if( Verbose ) {
                        fprintf( stderr, "The file %ws was not opened!\n", TargetInfPath );
                    }
                    continue;
                }

                //
                // Now process it.
                //
                ProcessInf( hTargetInf, TargetInfPath );

            } else {
                //
                // There must not have been an inf in this
                // line.
                //
                if( Verbose ) {
                    fprintf( stderr, "I didn't find an inf entry on this line.\n");
                }
            }
        }
    }

    SetupCloseInfFile( hInputinf );
    SetupCloseInfFile( hLayoutinf );

    Result = 0;

cleanup:

    pSetupUninitializeUtils();

    return Result;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\win4\tools\inftest\syntax.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    inf.c

Abstract:

    This module implements functions to access the INF using the same
    parser as the loader and textmode setup.

Author:

    Vijesh Shetty

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
//#include <string.h>
//#include <ctype.h>

#define ISSPACE(x)          (((x) == TEXT(' ')) || ((x) == TEXT('\t')) || ((x) == TEXT('\r')))
#define STRNCPY(s1,s2,n)    CopyMemory((s1),(s2),(n)*sizeof(WCHAR))



//
//   EXPORTED BY THE PARSER AND USED BY BOTH THE PARSER AND
//   THE INF HANDLING COMPONENTS
//


// typedefs exported
//

DWORD Verbose=NOSPEW;



PTCHAR EmptyValue;

typedef struct _value {
    struct _value *pNext;
    PTSTR  pName;
    BOOL   IsStringId;
} XVALUE, *PXVALUE;

typedef struct _line {
    struct _line *pNext;
    PTSTR   pName;
    PXVALUE  pValue;
} LINE, *PLINE;

typedef struct _section {
    struct _section *pNext;
    PTSTR    pName;
    PLINE    pLine;
} SECTION, *PSECTION;

typedef struct _inf {
    PSECTION pSection;
} INF, *PINF;


DWORD
ParseInfBuffer(
    PTSTR Buffer,
    DWORD Size,
    PVOID *Handle,
    DWORD Phase
    );

//
// DEFINES USED FOR THE PARSER INTERNALLY
//
//
// typedefs used
//

typedef enum _tokentype {
    TOK_EOF,
    TOK_EOL,
    TOK_LBRACE,
    TOK_RBRACE,
    TOK_STRING,
    TOK_STRING_ID,
    TOK_EQUAL,
    TOK_COMMA,
    TOK_ERRPARSE,
    TOK_ERRNOMEM
    } TOKENTYPE, *PTOKENTTYPE;

//
// We often need an empty string while processing the inf files.  Rather
// than incur the overhead of allocating memory for an empty string, we'll
// just point to this empty string for all cases.
//
PTSTR  CommonStrings[11] =
    { (PTSTR)(TEXT("0")),
      (PTSTR)(TEXT("1")),
      (PTSTR)(TEXT("2")),
      (PTSTR)(TEXT("3")),
      (PTSTR)(TEXT("4")),
      (PTSTR)(TEXT("5")),
      (PTSTR)(TEXT("6")),
      (PTSTR)(TEXT("7")),
      (PTSTR)(TEXT("8")),
      (PTSTR)(TEXT("9")),
      (PTSTR)(TEXT(""))
    };



typedef struct _token {
    TOKENTYPE Type;
    PTSTR     pValue;
    } TOKEN, *PTOKEN;


//
// Routine defines
//

DWORD
DnAppendSection(
    IN PTSTR pSectionName
    );

DWORD
DnAppendLine(
    IN PTSTR pLineKey
    );

DWORD
DnAppendValue(
    IN PTSTR pValueString,
    IN BOOL IsStringId
    );

TOKEN
DnGetToken(
    IN OUT PTSTR *Stream,
    IN PTSTR     MaxStream,
    IN DWORD      Phase
    );

BOOL
IsStringTerminator(
   IN TCHAR ch
   );

BOOL
IsQStringTerminator(
   IN TCHAR ch,
   IN TCHAR term
   );

// what follows was alinf.c

//
// Internal Routine Declarations for freeing inf structure members
//

VOID
FreeSectionList (
   IN PSECTION pSection
   );

VOID
FreeLineList (
   IN PLINE pLine
   );

VOID
FreeValueList (
   IN PXVALUE pValue
   );


//
// Internal Routine declarations for searching in the INF structures
//


PXVALUE
SearchValueInLine(
   IN PLINE pLine,
   IN unsigned ValueIndex
   );

PLINE
SearchLineInSectionByKey(
   IN PSECTION pSection,
   IN LPCTSTR  Key
   );

PLINE
SearchLineInSectionByIndex(
   IN PSECTION pSection,
   IN unsigned    LineIndex
   );

PSECTION
SearchSectionByName(
   IN PINF    pINF,
   IN LPCTSTR SectionName
   );

BOOL
ProcessStringSection(
    PINF pINF
    );

LPTSTR
DupString(
    IN LPCTSTR String
    );



DWORD
UnmapFile(
    IN HANDLE MappingHandle,
    IN PVOID  BaseAddress
    );

DWORD
MapFileForRead(
    IN  LPCTSTR  FileName,
    OUT PDWORD   FileSize,
    OUT PHANDLE  FileHandle,
    OUT PHANDLE  MappingHandle,
    OUT PVOID   *BaseAddress
    );




DWORD
LoadInfFile(
   IN  LPCTSTR Filename,
   IN  BOOL    OemCodepage,
   OUT PVOID  *InfHandle,
   IN  DWORD Phase
   )

/*++

Routine Description:

Arguments:

    Filename - supplies win32 filename of inf file to be loaded.

    OemCodepage - if TRUE amd the file named by Filename is not
        Unicode text, then the file is assumed to be in the OEM
        codepage (otherwise it's in the ANSI codepage).

    InfHandle - if successful, receives a handle to be used with
        subsequent inf operations.

Return Value:

    ERROR_FILE_NOT_FOUND - file does not exist or error opening it.
    ERROR_INVALID_DATA - syntax error in inf file.
    ERROR_READ_FAULT - unable to read file.
    ERROR_NOT_ENOUGH_MEMORY - mem alloc failed
    NO_ERROR - file read and parsed.

--*/

{
    DWORD err;
    DWORD FileSize;
    HANDLE FileHandle;
    HANDLE MappingHandle;
    PVOID BaseAddress;
    BOOL IsUnicode;

    DWORD ParseCount;
    PVOID ParseBuffer;

    //
    // Open and map the inf file.
    //
    err = MapFileForRead(Filename,&FileSize,&FileHandle,&MappingHandle,&BaseAddress);
    if(err != NO_ERROR) {
        err = ERROR_FILE_NOT_FOUND;
        goto c0;
    }

    //
    // Determine whether the file is unicode. If it's got the byte order mark
    // then it's unicode, otherwise call the IsTextUnicode API. We do it this way
    // because IsTextUnicode always returns FALSE on Win95 so we need to break out
    // the BOM to detect Unicode files on Win95.
    //
    if((FileSize >= sizeof(WCHAR)) && (*(PWCHAR)BaseAddress == 0xfeff)) {
        IsUnicode = 2;
    } else {
        IsUnicode = IsTextUnicode(BaseAddress,FileSize,NULL) ? 1 : 0;
    }

#ifdef UNICODE
    if(IsUnicode) {
        //
        // Copy into local buffer, skipping BOM if necessary.
        //
        ParseBuffer = malloc(FileSize);
        if(!ParseBuffer) {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto c1;
        }

        try {

            CopyMemory(
                ParseBuffer,
                (PTCHAR)BaseAddress + ((IsUnicode == 2) ? sizeof(WCHAR) : 0),
                FileSize - ((IsUnicode == 2) ? sizeof(WCHAR) : 0)
                );

        } except(EXCEPTION_EXECUTE_HANDLER) {
            err = ERROR_READ_FAULT;
        }

        ParseCount = (FileSize / sizeof(WCHAR)) - ((IsUnicode == 2) ? 1 : 0);

    } else {
        //
        // Convert to Unicode.
        //
        // Allocate a buffer large enough to hold the maximum sized unicode
        // equivalent of the multibyte text.  This size occurs when all chars
        // in the file are single-byte and thus double in size when converted.
        //
        ParseBuffer = malloc(FileSize * sizeof(WCHAR));
        if(!ParseBuffer) {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto c1;
        }

        try {
            ParseCount = MultiByteToWideChar(
                            OemCodepage ? CP_OEMCP : CP_ACP,
                            MB_PRECOMPOSED,
                            BaseAddress,
                            FileSize,
                            ParseBuffer,
                            FileSize
                            );

            if(!ParseCount) {
                //
                // Assume inpage i/o error
                //
                err = ERROR_READ_FAULT;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            err = ERROR_READ_FAULT;
        }
    }
#else
    if(IsUnicode) {
        //
        // Text is unicode but internal routines want ansi. Convert here.
        //
        // Maximum required buffer is when each unicode char ends up as
        // a double-byte char.
        //
        ParseBuffer = malloc(FileSize);
        if(!ParseBuffer) {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto c1;
        }

        try {
            ParseCount = WideCharToMultiByte(
                            CP_ACP,
                            0,
                            (PWCHAR)BaseAddress + ((IsUnicode == 2) ? 1 : 0),
                            (FileSize / sizeof(WCHAR)) - ((IsUnicode == 2) ? 1 : 0),
                            ParseBuffer,
                            FileSize,
                            NULL,
                            NULL
                            );

            if(!ParseCount) {
                //
                // Assume inpage i/o error
                //
                err = ERROR_READ_FAULT;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            err = ERROR_READ_FAULT;
        }
    } else {
        //
        // Text is not unicode. It might be OEM though and could thus still
        // require translation.
        //
        ParseCount = FileSize;
        ParseBuffer = malloc(FileSize);
        if(!ParseBuffer) {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto c1;
        }

        try {
            CopyMemory(ParseBuffer,BaseAddress,FileSize);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            err = ERROR_READ_FAULT;
        }

        if(err != NO_ERROR) {
            goto c2;
        }

        if(OemCodepage && (GetOEMCP() != GetACP())) {
            OemToCharBuff(ParseBuffer,ParseBuffer,ParseCount);
        }
    }
#endif

    if(err != NO_ERROR) {
        goto c2;
    }

    /*_tprintf(TEXT("\nCalling ParseInfBuffer..\n"));*/
    err = ParseInfBuffer(ParseBuffer,ParseCount,InfHandle,Phase);

    /*_tprintf(TEXT("\nErr=%d\n"),err);*/

    

c2:
    free(ParseBuffer);
c1:
    UnmapFile(MappingHandle,BaseAddress);
    CloseHandle(FileHandle);
c0:
    return(err);
}


VOID
UnloadInfFile(
   IN PVOID InfHandle
   )

/*++

Routine Description:

    Unload a file previously loaded by LoadInfFile().

Arguments:

    InfHandle - supplies a habdle previously returned by a successful
        call to LoadInfFile().

Return Value:

    None.

--*/

{
   PINF pINF;

   pINF = InfHandle;

   FreeSectionList(pINF->pSection);
   free(pINF);
}


VOID
FreeSectionList (
   IN PSECTION pSection
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PSECTION Next;

    while(pSection) {
        Next = pSection->pNext;
        FreeLineList(pSection->pLine);
        if(pSection->pName) {
            free(pSection->pName);
        }
        free(pSection);
        pSection = Next;
    }
}


VOID
FreeLineList(
   IN PLINE pLine
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PLINE Next;

    while(pLine) {
        Next = pLine->pNext;
        FreeValueList(pLine->pValue);
        if(pLine->pName) {
            free(pLine->pName);
        }
        free(pLine);
        pLine = Next;
    }
}

VOID
FreeValueList (
   IN PXVALUE pValue
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PXVALUE Next;

    while(pValue) {
        Next = pValue->pNext;
        if(pValue->pName) {
            free(pValue->pName);
        }
        free(pValue);
        pValue = Next;
    }
}


//
// searches for the existance of a particular section,
// returns line count (-1 if not found)
//
LONG
InfGetSectionLineCount(
   IN PVOID INFHandle,
   IN PTSTR SectionName
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;
   PLINE pLine;
   LONG count;

   //
   // if search for section fails return failure
   //
   if ((pSection = SearchSectionByName(INFHandle,SectionName)) == NULL) {
       return(-1);
   }

   for(count=0,pLine=pSection->pLine; pLine; pLine=pLine->pNext) {
       count++;
   }

   return(count);
}




//
// given section name, line number and index return the value.
//
LPCTSTR
InfGetFieldByIndex(
   IN PVOID    INFHandle,
   IN LPCTSTR  SectionName,
   IN unsigned LineIndex,
   IN unsigned ValueIndex
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;
   PLINE    pLine;
   PXVALUE   pValue;

   if((pSection = SearchSectionByName(
                    (PINF)INFHandle,
                    SectionName
                    ))
                == NULL)
        return(NULL);

   if((pLine = SearchLineInSectionByIndex(
                    pSection,
                    LineIndex
                    ))
                == NULL)
        return(NULL);

   if((pValue = SearchValueInLine(
                    pLine,
                    ValueIndex
                    ))
                == NULL)
        return(NULL);

   return (pValue->pName);
}


BOOL
InfDoesLineExistInSection(
   IN PVOID   INFHandle,
   IN LPCTSTR SectionName,
   IN LPCTSTR Key
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;

   if((pSection = SearchSectionByName(
              (PINF)INFHandle,
              SectionName
              ))
              == NULL) {
       return( FALSE );
   }

   if (SearchLineInSectionByKey(pSection, Key) == NULL) {
       return( FALSE );
   }

   return( TRUE );
}


LPCTSTR
InfGetLineKeyName(
    IN PVOID    INFHandle,
    IN LPCTSTR  SectionName,
    IN unsigned LineIndex
    )
{
    PSECTION pSection;
    PLINE    pLine;

    pSection = SearchSectionByName((PINF)INFHandle,SectionName);
    if(pSection == NULL) {
        return(NULL);
    }

    pLine = SearchLineInSectionByIndex(pSection,LineIndex);
    if(pLine == NULL) {
        return(NULL);
    }

    return(pLine->pName);
}



//
// given section name, key and index return the value
//
LPCTSTR
InfGetFieldByKey(
   IN PVOID    INFHandle,
   IN LPCTSTR  SectionName,
   IN LPCTSTR  Key,
   IN unsigned ValueIndex
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;
   PLINE    pLine;
   PXVALUE   pValue;

   if((pSection = SearchSectionByName(
              (PINF)INFHandle,
              SectionName
              ))
              == NULL)
       return(NULL);

   if((pLine = SearchLineInSectionByKey(
              pSection,
              Key
              ))
              == NULL)
       return(NULL);

   if((pValue = SearchValueInLine(
              pLine,
              ValueIndex
              ))
              == NULL)
       return(NULL);

   return (pValue->pName);

}




PXVALUE
SearchValueInLine(
   IN PLINE pLine,
   IN unsigned ValueIndex
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PXVALUE pValue;
   unsigned  i;

   if (pLine == NULL)
       return (NULL);

   pValue = pLine->pValue;
   for (i = 0; (i < ValueIndex) && (pValue = pValue->pNext); i++)
      ;

   return pValue;

}

PLINE
SearchLineInSectionByKey(
   IN PSECTION pSection,
   IN LPCTSTR  Key
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PLINE pLine;

   if (pSection == NULL || Key == NULL) {
       return (NULL);
   }

   pLine = pSection->pLine;
   while(pLine && ((pLine->pName == NULL) || lstrcmpi(pLine->pName, Key))) {
       pLine = pLine->pNext;
   }

   return pLine;

}


PLINE
SearchLineInSectionByIndex(
   IN PSECTION pSection,
   IN unsigned    LineIndex
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PLINE pLine;
   unsigned  i;

   //
   // Validate the parameters passed in
   //

   if(pSection == NULL) {
       return (NULL);
   }

   //
   // find the start of the line list in the section passed in
   //

   pLine = pSection->pLine;

   //
   // traverse down the current line list to the LineIndex th line
   //

   for (i = 0; (i < LineIndex) && (pLine = pLine->pNext); i++) {
      ;
   }

   //
   // return the Line found
   //

   return pLine;

}


PSECTION
SearchSectionByName(
   IN PINF    pINF,
   IN LPCTSTR SectionName
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;

   //
   // validate the parameters passed in
   //

   if (pINF == NULL || SectionName == NULL) {
       return (NULL);
   }

   //
   // find the section list
   //
   pSection = pINF->pSection;

   //
   // traverse down the section list searching each section for the section
   // name mentioned
   //

   while (pSection && lstrcmpi(pSection->pName, SectionName)) {
       pSection = pSection->pNext;
   }

   //
   // return the section at which we stopped (either NULL or the section
   // which was found
   //

   return pSection;

}


// what follows was alparse.c


//
//  Globals used to make building the lists easier
//

PINF     pINF;
PSECTION pSectionRecord;
PLINE    pLineRecord;
PXVALUE  pValueRecord;


//
// Globals used by the token parser
//

// string terminators are the whitespace characters (isspace: space, tab,
// linefeed, formfeed, vertical tab, carriage return) or the chars given below

TCHAR  StringTerminators[] = {  TEXT('['),
                                TEXT(']'),
                                TEXT('='),
                                TEXT(','),
                                TEXT('\"'),
                                TEXT(' '),
                                TEXT('\t'),
                                TEXT('\n'),
                                TEXT('\f'),
                                TEXT('\v'),
                                TEXT('\r'),
                                TEXT('\032')
                             };

unsigned NumberOfTerminators = sizeof(StringTerminators)/sizeof(TCHAR);


// string terminators are the whitespace characters (isspace: space, tab,
// linefeed, formfeed, vertical tab, carriage return) or the chars given below - For the loader and textmode

TCHAR  LStringTerminators[] = {  TEXT('['),
                                TEXT(']'),
                                TEXT('='),
                                TEXT(','),
                                TEXT('\"'),
                                TEXT(' '),
                                TEXT('\t'),
                                TEXT('\n'),
                                TEXT('\f'),
                                TEXT('\v'),
                                TEXT('\r')
                             };


//
// quoted string terminators allow some of the regular terminators to
// appear as characters

TCHAR  QStringTerminators[] = { TEXT('\n'),
                                TEXT('\f'),
                                TEXT('\v'),
                                TEXT('\r'),
                                TEXT('\032')
                              };

unsigned QNumberOfTerminators = sizeof(QStringTerminators)/sizeof(TCHAR);

//
// quoted string terminators allow some of the regular terminators to
// appear as characters - This is for the Loader & Textmode

TCHAR  LQStringTerminators[] = { TEXT('\"'),
                                 TEXT('\n'),
                                 TEXT('\f'),
                                 TEXT('\v'),
                                 TEXT('\r')
                               };


//
// Main parser routine
//

DWORD
ParseInfBuffer(
    PTSTR Buffer,
    DWORD Size,
    PVOID *Handle,
    DWORD Phase
    )

/*++

Routine Description:

   Given a character buffer containing the INF file, this routine parses
   the INF into an internal form with Section records, Line records and
   Value records.

   If this module is compiler for unicode, the input is assumed to be
   a bufferful of unicode characters.

Arguments:

   Buffer - contains to ptr to a buffer containing the INF file

   Size - contains the size of the buffer in characters.

   Handle - receives INF handle ptr to be used in subsequent INF calls.

Return Value:

   Win32 error code indicating outcome. One of NO_ERROR, ERROR_INVALID_DATA,
   or ERROR_NOT_ENOUGH_MEMORY.

--*/

{
    LPTSTR Stream, MaxStream, pchSectionName, pchValue;
    unsigned State, InfLine;
    TOKEN Token;
    BOOL Done;
    BOOL Error;
    DWORD ErrorCode;
    BOOL IsStringId;
    PTSTR NearestValue=NULL;

    //
    // Initialise the globals
    //
    pINF            = NULL;
    pSectionRecord  = NULL;
    pLineRecord     = NULL;
    pValueRecord    = NULL;

    //
    // Need EmptyValue to point at a nul character
    //
    EmptyValue = StringTerminators + lstrlen(StringTerminators);

    //
    // Get INF record
    //
    pINF = malloc(sizeof(INF));
    if(!pINF) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    pINF->pSection = NULL;

    //
    // Set initial state
    //
    State      = 1;
    InfLine    = 1;
    Stream     = Buffer;
    MaxStream  = Buffer + Size;
    Done       = FALSE;
    Error      = FALSE;
    ErrorCode  = NO_ERROR;
    IsStringId = FALSE;

    pchSectionName = NULL;
    pchValue = NULL;

    //
    // Enter token processing loop
    //

    while (!Done)       {

       Token = DnGetToken(&Stream, MaxStream, Phase);

       if(Token.pValue){
           NearestValue = Token.pValue;
           if( Verbose >= DETAIL)
            _tprintf(TEXT("Token - %s\n"), Token.pValue);
       }

       

       switch (State) {
       //
       // STATE1: Start of file, this state remains till first
       //         section is found
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_LBRACE
       //

       case 1:
           switch (Token.Type) {
              case TOK_EOL:
                  break;
              case TOK_EOF:
                  Done = TRUE;
                  break;
              case TOK_LBRACE:
                  State = 2;
                  break;
              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  _tprintf(TEXT("Error in line %i, Nearest string - %s\n"), InfLine, NearestValue);
                  _tprintf(TEXT("Syntax Error - Expecting a section left brace\n"));
                  if(Verbose >= BRIEF)
                    _tprintf(TEXT("Expecting End of line, End of File or Left Brace - \nSTATE1: Start of file, this state remains until first section is found\n"));
                  break;
           }
           break;

       //
       // STATE 2: Section LBRACE has been received, expecting STRING
       //
       // Valid Tokens: TOK_STRING
       //
       case 2:
           switch (Token.Type) {
              case TOK_STRING:
                  State = 3;
                  pchSectionName = Token.pValue;
                  break;

              case TOK_RBRACE:
                  if( Phase == TEXTMODE_PHASE){
                      State = 4;
                      pchSectionName = CommonStrings[10];
                      break;
                  }
                  

              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  _tprintf(TEXT("Error in line %i, Nearest string - %s\n"), InfLine, NearestValue);
                  _tprintf(TEXT("Syntax Error - Expecting the section name\n"));
                  if(Verbose >= BRIEF)
                    _tprintf(TEXT("Expecting String - \nSTATE 2: Section LBRACE has been received, expecting STRING\n"));
                  break;

           }
           break;

       //
       // STATE 3: Section Name received, expecting RBRACE
       //
       // Valid Tokens: TOK_RBRACE
       //
       case 3:
           switch (Token.Type) {
              case TOK_RBRACE:
                State = 4;
                break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  _tprintf(TEXT("Error in line %i, Nearest string - %s\n"), InfLine, NearestValue);
                  _tprintf(TEXT("Syntax Error - Expecting a section right Brace after Section Name\n"));
                  if(Verbose >= BRIEF)
                    _tprintf(TEXT("Expecting Right Brace - \nSTATE 3: Section Name received, expecting RBRACE\n"));
                  break;
           }
           break;
       //
       // STATE 4: Section Definition Complete, expecting EOL
       //
       // Valid Tokens: TOK_EOL, TOK_EOF
       //
       case 4:
           switch (Token.Type) {
              case TOK_EOL:
                  //_tprintf(TEXT("pchSectionName - %s\n"), pchSectionName);
                  if ((ErrorCode = DnAppendSection(pchSectionName)) != NO_ERROR)
                    Error = Done = TRUE;
                  else {
                    pchSectionName = NULL;
                    State = 5;
                  }
                  break;

              case TOK_EOF:
                  _tprintf(TEXT("pchSectionName - %s\n"), pchSectionName);
                  if ((ErrorCode = DnAppendSection(pchSectionName)) != NO_ERROR)
                    Error = Done = TRUE;
                  else {
                    pchSectionName = NULL;
                    Done = TRUE;
                  }
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  _tprintf(TEXT("Error in line %i, Nearest string - %s\n"), InfLine, NearestValue);
                  _tprintf(TEXT("Syntax Error - Expecting End of line after Section Definition\n"));
                  if(Verbose >= BRIEF)
                    _tprintf(TEXT("Expecting End of line or End of File - \nSTATE 4: Section Definition Complete, expecting EOL\n"));
                  break;
           }
           break;

       //
       // STATE 5: Expecting Section Lines
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_STRING, TOK_LBRACE
       //
       case 5:
           switch (Token.Type) {
              case TOK_EOL:
                  break;
              case TOK_EOF:
                  Done = TRUE;
                  break;
              case TOK_STRING_ID:
                  if( Phase == WINNT32_PHASE )
                    IsStringId = TRUE;
              case TOK_STRING:
                  pchValue = Token.pValue;
                  State = 6;
                  break;
              case TOK_LBRACE:
                  State = 2;
                  break;
              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  _tprintf(TEXT("Error in line %i, Nearest string - %s\n"), InfLine, NearestValue);
                  _tprintf(TEXT("Syntax Error - Expecting Section lines - Did not find End of line, End of File, String/StringID, or Left Brace\n"));
                  if(Verbose >= BRIEF)
                    _tprintf(TEXT("Expecting End of line, End of File, String/StringID, or Left Brace - \nSTATE 5: Expecting Section Lines\n"));
                  break;
           }
           break;

       //
       // STATE 6: String returned, not sure whether it is key or value
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA, TOK_EQUAL
       //
       case 6:
           switch (Token.Type) {
              case TOK_EOL:
                  if ( (ErrorCode = DnAppendLine(NULL)) != NO_ERROR ||
                       (ErrorCode = DnAppendValue(pchValue,IsStringId)) !=NO_ERROR ) {
                      Error = Done = TRUE;
                  } else {
                      pchValue = NULL;
                      State = 5;
                  }
                  break;

              case TOK_EOF:
                  if ( (ErrorCode = DnAppendLine(NULL)) != NO_ERROR ||
                       (ErrorCode = DnAppendValue(pchValue,IsStringId)) !=NO_ERROR ) {
                      Error = Done = TRUE;
                  } else {
                      pchValue = NULL;
                      Done = TRUE;
                  }
                  break;

              case TOK_COMMA:
                  if ( (ErrorCode = DnAppendLine(NULL)) != NO_ERROR ||
                       (ErrorCode = DnAppendValue(pchValue,IsStringId)) !=NO_ERROR ) {
                      Error = Done = TRUE;
                  } else {
                      pchValue = NULL;
                      State = 7;
                  }
                  break;

              case TOK_EQUAL:
                  if ( (ErrorCode = DnAppendLine(pchValue)) !=NO_ERROR)
                      Error = Done = TRUE;
                  else {
                      pchValue = NULL;
                      State = 8;
                  }
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  _tprintf(TEXT("Error in line %i, Nearest string - %s\n"), InfLine, NearestValue);
                  _tprintf(TEXT("Syntax Error - Processing a section line - Expecting End of line, End of File, Comma or Equals\n"));
                  if(Verbose >= BRIEF)
                    _tprintf(TEXT("Expecting End of line, End of File, Comma or Equals - \nSTATE 6: String returned, not sure whether it is key or value\n"));  

                  break;
           }
           if( Phase == WINNT32_PHASE )
                IsStringId = FALSE;
           break;

       //
       // STATE 7: Comma received, Expecting another string
       //
       // Valid Tokens: TOK_STRING
       //
       case 7:
           switch (Token.Type) {
              case TOK_COMMA:
                  Token.pValue = EmptyValue;
                  ErrorCode = DnAppendValue(Token.pValue,FALSE);
                  if(ErrorCode != NO_ERROR) {
                      Error = Done = TRUE;
                  }
                  break;

              case TOK_STRING_ID:
                  if( Phase == WINNT32_PHASE )
                        IsStringId = TRUE;
              case TOK_STRING:
                  if ((ErrorCode = DnAppendValue(Token.pValue,IsStringId)) != NO_ERROR) {
                      Error = Done = TRUE;
                  } else {
                     State = 9;
                  }
                  if(Phase == WINNT32_PHASE)
                    IsStringId = FALSE;
                  break;

              case TOK_EOL:
              case TOK_EOF:
                  Token.pValue = EmptyValue;
                  if ((ErrorCode = DnAppendValue(Token.pValue, IsStringId)) != NO_ERROR)
                      Error = Done = TRUE;
                  else
                     State = 9;

                  break;


              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  _tprintf(TEXT("Error in line %i, Nearest string - %s\n"), InfLine, NearestValue);
                  _tprintf(TEXT("Syntax Error - Comma received on section line  - Expecting Comma, String/StringID, End of Line or End of File\n"));
                  if(Verbose >= BRIEF)
                    _tprintf(TEXT("Expecting Comma or String/StringID - \nSTATE 7: Comma received, Expecting another string\n"));

                  break;
           }
           break;
       //
       // STATE 8: Equal received, Expecting another string
       //
       // Valid Tokens: TOK_STRING TOK_EOL, TOK_EOF
       //
       case 8:
           switch (Token.Type) {
              case TOK_STRING_ID:
                  if(Phase == WINNT32_PHASE)
                    IsStringId = TRUE;
              case TOK_STRING:
                  if ((ErrorCode = DnAppendValue(Token.pValue,IsStringId)) != NO_ERROR) {
                      Error = Done = TRUE;
                  } else {
                      State = 9;
                  }
                  if(Phase == WINNT32_PHASE)
                    IsStringId = FALSE;
                  break;

              case TOK_EOF:
                  if( Phase != WINNT32_PHASE){
                      Token.pValue = EmptyValue;
                      if ((ErrorCode = DnAppendValue(Token.pValue,FALSE)) != NO_ERROR) {
                          Error = TRUE;
                      }
                      Done = TRUE;
                      break;
                  }
              case TOK_EOL:   
                  Token.pValue = EmptyValue;
                  if ((ErrorCode = DnAppendValue(Token.pValue,FALSE)) != NO_ERROR) {
                      Error = Done = TRUE;
                  } else {
                      State = 5;
                  }
                  if(Phase == WINNT32_PHASE)
                    IsStringId = FALSE;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  _tprintf(TEXT("Error in line %i, Nearest string - %s - %d\n"), InfLine, NearestValue, Token.Type);
                  _tprintf(TEXT("Syntax Error - Equals received on Section line - Expecting String/StringID, End of line or End of File\n\n"));
                  if(Verbose >= BRIEF)
                      _tprintf(TEXT("Expecting String/StringID, End of line or End of File - \nSTATE 8: Equal received, Expecting another string\n"));
                  break;
           }
           break;
       //
       // STATE 9: String received after equal, value string
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA
       //
       case 9:
           switch (Token.Type) {
              case TOK_EOL:
                  State = 5;
                  break;

              case TOK_EOF:
                  Done = TRUE;
                  break;

              case TOK_COMMA:
                  State = 7;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  _tprintf(TEXT("Error in line %i, Nearest string - %s\n"), InfLine, NearestValue);
                  _tprintf(TEXT("Syntax Error - Recieved string on line - Expecting End of line, End of File or Comma\n"));
                  if(Verbose >= BRIEF)
                    _tprintf(TEXT("Expecting End of line, End of File or Comma - \nSTATE 9: String received after equal, value string\n"));
                  break;
           }
           break;
       //
       // STATE 10: Value string definitely received
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA
       //
       case 10:
           _tprintf(TEXT("Was Here\n"));
           switch (Token.Type) {
              case TOK_EOL:
                  State =5;
                  break;

              case TOK_EOF:
                  Done = TRUE;
                  break;

              case TOK_COMMA:
                  State = 7;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  _tprintf(TEXT("Error in line %i, Nearest string - %s\n"), InfLine, NearestValue);
                  _tprintf(TEXT("Syntax Error - Expecting End of line, End of File or Comma - \nSTATE 10: Value string definitely received\n"));
                  if(Verbose >= BRIEF)
                      _tprintf(TEXT("Expecting End of line, End of File or Comma - \nSTATE 10: Value string definitely received\n"));
                  break;
           }
           break;

       default:
           Error = Done = TRUE;
           ErrorCode = ERROR_INVALID_DATA;
           _tprintf(TEXT("Error in line %i, Nearest string - %s\n"), InfLine, NearestValue);
           break;

       } // end switch(State)


       if (Error) {

           UnloadInfFile(pINF);
           if(pchSectionName) {
               free(pchSectionName);
           }

           if(pchValue) {
               free(pchValue);
           }

           pINF = NULL;
       }
       else {

          //
          // Keep track of line numbers so that we can display Errors
          //

          if (Token.Type == TOK_EOL)
              InfLine++;
       }

    } // End while

    if(!Error && (Phase == WINNT32_PHASE)) {
        ProcessStringSection( pINF );
        *Handle = pINF;
    }
    
    return(Error ? ErrorCode : NO_ERROR);
}



DWORD
DnAppendSection(
    IN PTSTR pSectionName
    )

/*++

Routine Description:

    This appends a new section to the section list in the current INF.
    All further lines and values pertain to this new section, so it resets
    the line list and value lists too.

Arguments:

    pSectionName - Name of the new section. ( [SectionName] )

Return Value:

    NO_ERROR - if successful.
    ERROR_INVALID_DATA   - if invalid parameters passed in or the INF buffer not
               initialised

--*/

{
    PSECTION pNewSection;

    //
    // See if we already have a section by this name. If so we want
    // to merge sections.
    //
    for(pNewSection=pINF->pSection; pNewSection; pNewSection=pNewSection->pNext) {
        if(pNewSection->pName && !lstrcmpi(pNewSection->pName,pSectionName)) {
            break;
        }
    }
    if(pNewSection) {
        //
        // Set pLineRecord to point to the list line currently in the section.
        //
        for(pLineRecord = pNewSection->pLine;
            pLineRecord && pLineRecord->pNext;
            pLineRecord = pLineRecord->pNext)
            ;
    } else {

        //
        // Allocate memory for the new section
        //

        pNewSection = malloc(sizeof(SECTION));
        if(!pNewSection) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        //
        // initialise the new section
        //
        pNewSection->pNext = NULL;
        pNewSection->pLine = NULL;
        pNewSection->pName = pSectionName;

        //
        // link it in
        //
        pNewSection->pNext = pINF->pSection;
        pINF->pSection = pNewSection;

        //
        // reset the current line record
        //
        pLineRecord = NULL;
    }

    pSectionRecord = pNewSection;
    pValueRecord   = NULL;

    return NO_ERROR;

}


DWORD
DnAppendLine(
    IN PTSTR pLineKey
    )

/*++

Routine Description:

    This appends a new line to the line list in the current section.
    All further values pertain to this new line, so it resets
    the value list too.

Arguments:

    pLineKey - Key to be used for the current line, this could be NULL.

Return Value:

    NO_ERROR - if successful.
    ERROR_INVALID_DATA   - if invalid parameters passed in or current section not
               initialised


--*/


{
    PLINE pNewLine;

    //
    // Allocate memory for the new Line
    //
    pNewLine = malloc(sizeof(LINE));
    if(!pNewLine) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Link it in
    //
    pNewLine->pNext  = NULL;
    pNewLine->pValue = NULL;
    pNewLine->pName  = pLineKey;

    if (pLineRecord == NULL) {
        pSectionRecord->pLine = pNewLine;
    }
    else {
        pLineRecord->pNext = pNewLine;
    }

    pLineRecord  = pNewLine;

    //
    // Reset the current value record
    //

    pValueRecord = NULL;

    return NO_ERROR;
}



DWORD
DnAppendValue(
    IN PTSTR pValueString,
    IN BOOL IsStringId
    )

/*++

Routine Description:

    This appends a new value to the value list in the current line.

Arguments:

    pValueString - The value string to be added.

Return Value:

    NO_ERROR - if successful.
    ERROR_INVALID_DATA   - if invalid parameters passed in or current line not
               initialised.

--*/

{
    PXVALUE pNewValue;

    //
    // Allocate memory for the new value record
    //
    pNewValue = malloc(sizeof(XVALUE));
    if(!pNewValue) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Link it in.
    //

    pNewValue->pNext       = NULL;
    pNewValue->pName       = pValueString;
    pNewValue->IsStringId  = IsStringId;

    if (pValueRecord == NULL)
        pLineRecord->pValue = pNewValue;
    else
        pValueRecord->pNext = pNewValue;

    pValueRecord = pNewValue;
    return NO_ERROR;
}

TOKEN
DnGetToken(
    IN OUT PTSTR *Stream,
    IN PTSTR      MaxStream,
    IN DWORD      Phase
    )

/*++

Routine Description:

    This function returns the Next token from the configuration stream.

Arguments:

    Stream - Supplies the address of the configuration stream.  Returns
        the address of where to start looking for tokens within the
        stream.

    MaxStream - Supplies the address of the last character in the stream.


Return Value:

    TOKEN - Returns the next token

--*/

{

    PTSTR pch, pchStart, pchNew;
    unsigned  Length, QuotedQuotes;
    TOKEN Token;

    //
    //  Skip whitespace (except for eol)
    //

    pch = *Stream;
    while (pch < MaxStream && *pch != TEXT('\n') && (ISSPACE(*pch) || (*pch == TEXT('\032'))))
        pch++;


    //
    // Check for comments and remove them
    //

    if (pch < MaxStream &&
        ((*pch == TEXT(';')) || (*pch == TEXT('#'))
            || (*pch == TEXT('/') && pch+1 < MaxStream && *(pch+1) == TEXT('/'))))
        while (pch < MaxStream && *pch != TEXT('\n'))
            pch++;

    //
    // Check to see if EOF has been reached, set the token to the right
    // value
    //

    if (( pch >= MaxStream ) || 
        (!(Phase == WINNT32_PHASE) && 
           (*pch == 26)) ){
        *Stream = pch;
        Token.Type  = TOK_EOF;
        Token.pValue = NULL;
        return Token;
    }


    switch (*pch) {

    case TEXT('[') :
        pch++;
        Token.Type  = TOK_LBRACE;
        Token.pValue = NULL;
        break;

    case TEXT(']') :
        pch++;
        Token.Type  = TOK_RBRACE;
        Token.pValue = NULL;
        break;

    case TEXT('=') :
        pch++;
        Token.Type  = TOK_EQUAL;
        Token.pValue = NULL;
        break;

    case TEXT(',') :
        pch++;
        Token.Type  = TOK_COMMA;
        Token.pValue = NULL;
        break;

    case TEXT('\n') :
        pch++;
        Token.Type  = TOK_EOL;
        Token.pValue = NULL;
        break;

    case TEXT('\"'):
        pch++;
        //
        // determine quoted string
        //
        pchStart = pch;
        QuotedQuotes = 0;

morequotedstring:

        if(Phase == WINNT32_PHASE){
            while (pch < MaxStream && *pch && !IsQStringTerminator(*pch,TEXT('\"'))) {
                pch++;
            }
        }else{
            while (pch < MaxStream && (_tcschr(LQStringTerminators,*pch) == NULL)) {
                pch++;
            }
        }

        if(Phase == TEXTMODE_PHASE){
            if(((pch+1) < MaxStream) && (*pch == TEXT('\"')) && ((*(pch+1)) == TEXT('\"'))) {
                QuotedQuotes++;
                //_tprintf( TEXT("Quoted Quotes found - %d\n"), QuotedQuotes);
                pch += 2;
                goto morequotedstring;
            }
        }
    
        if (pch >=MaxStream || (*pch && (*pch != TEXT('\"')))) {
            Token.Type   = TOK_ERRPARSE;
            Token.pValue = NULL;
        }
        else {
            
            if(Phase == LOADER_PHASE){

                //
                // We require a quoted string to end with a double-quote.
                // (If the string ended with anything else, the if() above
                // would not have let us into the else clause.) The quote
                // character is irrelevent, however, and can be overwritten.
                // So we'll save some heap and use the string in-place.
                // No need to make a copy.
                //
                // Note that this alters the image of txtsetup.sif we pass
                // to setupdd.sys. Thus the inf parser in setupdd.sys must
                // be able to treat a nul character as if it were a terminating
                // double quote. In this tool we call this function with LOADER_PHASE
                // before we call it with TEXTMODE_PHASE.
                //
                *pch++ = 0;
                Token.Type = TOK_STRING;
                Token.pValue = pchStart;
    
            }else if( Phase == TEXTMODE_PHASE ){

                Length = (unsigned)(pch - pchStart);
                //_tprintf( TEXT("L - %d pch %x pchstart %x - Q - %d\n"), Length, pch, pchStart, QuotedQuotes);
                if ((pchNew = malloc(((Length + 1) - QuotedQuotes) * sizeof(TCHAR) )) == NULL) {
                    Token.Type = TOK_ERRNOMEM;
                    Token.pValue = NULL;
                } else{
                    if(Length) {    // Null quoted strings are allowed
                        if(QuotedQuotes) {
                            for(Length=0; pchStart<pch; pchStart++) {
                                if((pchNew[Length++] = *pchStart) == TEXT('\"')) {
                                    //
                                    // The only way this could happen is if there's
                                    // another double-quote char after this one, since
                                    // otherwise this would have terminated the string.
                                    //
                                    pchStart++;
                                }
                            }
                        } else {
                            _tcsncpy(pchNew,pchStart,Length);
                        }
                    }
                    pchNew[Length] = 0;
                    Token.Type = TOK_STRING;
                    Token.pValue = pchNew;
                }
                pch++;   // advance past the quote
            }else if( Phase == WINNT32_PHASE ){
            

                Length = (unsigned)(pch - pchStart);
                if (pchNew = malloc((Length + 1) * sizeof(TCHAR))){
                    _tcsncpy(pchNew,pchStart,Length);
                    pchNew[Length] = 0;
                    Token.Type = TOK_STRING;
                    Token.pValue = pchNew;
                    pch++;   // advance past the quote
                }else{
                    Token.Type   = TOK_ERRNOMEM;
                    Token.pValue = NULL;
                }   

            }
        }
        break;


    case TEXT('%'):
        if(Phase == WINNT32_PHASE){
            pch++;
            //
            // determine percented string
            //
            pchStart = pch;
            while (pch < MaxStream && !IsQStringTerminator(*pch,TEXT('%'))) {
                pch++;
            }
    
            if (pch >=MaxStream || *pch != TEXT('%')) {
                Token.Type   = TOK_ERRPARSE;
                Token.pValue = NULL;
            }
            else {
                Length = (unsigned)(pch - pchStart);
                if( pchNew = malloc((Length+1) * sizeof(TCHAR))){
                    _tcsncpy(pchNew,pchStart,Length);
                    pchNew[Length] = 0;
                    Token.Type = TOK_STRING_ID;
                    Token.pValue = pchNew;
                    pch++;   // advance past the percent
                }else{
                    Token.Type   = TOK_ERRNOMEM;
                    Token.pValue = NULL;
                }
    
            }
            break;
        }// if not WINNT32_PHASE go on with default processing


    default:

        pchStart = pch;
        
        /*  -- We don't implement line continuation checks for now.
        if(Phase == TEXTMODE_PHASE ){

            //
            // Check to see if we have a line continuation,
            // which is \ followed by only whitespace on the line
            //

            if((*pch == L'\\')) {
                pch++;
                //
                // Keep skipping until we hit the end of the file,
                // or the newline, or a non-space character.
                //
                while((pch < MaxStream) && (*pch != L'\n') && ISSPACE(*pch)) {
                    pch++;
                }
            
                if(*pch == L'\n') {
                    //
                    // No non-space chars between the \ and the end of the line.
                    // Ignore the newline.
                    //
                    pch++;
                    *LineNumber = *LineNumber + 1;
                    goto restart;
                } else {
                    if(pch < MaxStream) {
                        //
                        // Not line continuation.
                        // Reset the input to the start of the field.
                        //
                        pch = pchStart;
                    }
                }
            }

        } */



        //
        // determine regular string
        //
        pchStart = pch;
        if( Phase == WINNT32_PHASE ){
            while (pch < MaxStream && !IsStringTerminator(*pch))
                pch++;    
        }else{
            while (pch < MaxStream && (_tcschr(LStringTerminators,*pch) == NULL)) {
                pch++;
            }
        }

        if (pch == pchStart) {
            pch++;
            Token.Type  = TOK_ERRPARSE;
            Token.pValue = NULL;
        }
        else {

            Length = (unsigned)((pch - pchStart));
            //_tprintf( TEXT("L - %d pch %x pchstart %x\n"), Length, pch, pchStart);
            if( (Phase == WINNT32_PHASE) || (Phase == LOADER_PHASE)){
                if(pchNew = malloc((Length + 1) * sizeof(TCHAR))){
                    _tcsncpy(pchNew,pchStart,Length);
                    pchNew[Length] = 0;
                    Token.Type = TOK_STRING;
                    Token.pValue = pchNew;
                }else{
                    Token.Type   = TOK_ERRNOMEM;
                    Token.pValue = NULL;
                }
            }else if (Phase == TEXTMODE_PHASE) {
                ULONG i;
                //
                // Check for a common string...
                //
                for( i = 0; i < sizeof(CommonStrings)/sizeof(PTSTR); i++ ) {
                    if( !_tcsnicmp( pchStart, CommonStrings[i], Length) ) {
                        break;
                    }
                }
                if( i < sizeof(CommonStrings)/sizeof(PTSTR) ) {
                    //
                    // Hit...
                    //
                    Token.Type = TOK_STRING;
                    Token.pValue = CommonStrings[i];
                } else if((pchNew = malloc((Length + 1) * sizeof(TCHAR))) == NULL) {
                    Token.Type = TOK_ERRNOMEM;
                    Token.pValue = NULL;
                }
                else {
                    _tcsncpy(pchNew, pchStart, Length);
                    pchNew[Length] = 0;
                    //_tprintf( TEXT("Token2 - %s\n"), pchNew);
                    Token.Type = TOK_STRING;
                    Token.pValue = pchNew;
                }


            }

  
        }
        break;
    }

    *Stream = pch;
    return (Token);
}



BOOL
IsStringTerminator(
    TCHAR ch
    )
/*++

Routine Description:

    This routine tests whether the given character terminates a quoted
    string.

Arguments:

    ch - The current character.

Return Value:

    TRUE if the character is a quoted string terminator, FALSE otherwise.

--*/

{
    unsigned i;

    //
    // one of the string terminator array
    //

    for (i = 0; i < NumberOfTerminators; i++) {
        if (ch == StringTerminators[i]) {
            return (TRUE);
        }
    }

    return FALSE;
}



BOOL
IsQStringTerminator(
    TCHAR ch,
    TCHAR term
    )

/*++

Routine Description:

    This routine tests whether the given character terminates a quoted
    string.

Arguments:

    ch - The current character.


Return Value:

    TRUE if the character is a quoted string terminator, FALSE otherwise.


--*/


{
    unsigned i;
    //
    // one of quoted string terminators array
    //
    for (i = 0; i < QNumberOfTerminators; i++) {

        if (ch == QStringTerminators[i] || ch == term) {
            return (TRUE);
        }
    }

    return FALSE;
}


typedef struct _STRING_ENTRY {
    LPCTSTR     StringId;
    LPCTSTR     StringValue;
} STRING_ENTRY, *PSTRING_ENTRY;

BOOL
ProcessStringSection(
    PINF pINF
    )

/*++

Routine Description:

    This routine processes the strings sections on the
    specified inf file.  The processing scans all values
    in the inf and replaces any string ids that are
    referenced.

Arguments:

    pINF - pointer to the specified inf structure

Return Value:

    TRUE if the strings section is processed properly

--*/

{
    PSTRING_ENTRY StringTable;
    DWORD StringTableCount;
    DWORD LineCount;
    DWORD i;
    LPCTSTR StringId;
    LPCTSTR StringValue;
    PSECTION pSection;
    PLINE pLine;
    PXVALUE pValue;


    LineCount = InfGetSectionLineCount( pINF, TEXT("Strings") );
    if (LineCount == 0 || LineCount == 0xffffffff) {
        _tprintf(TEXT("Warning - No strings section\n"));
        return FALSE;
    }

    StringTable = (PSTRING_ENTRY) malloc( LineCount * sizeof(STRING_ENTRY) );
    if (StringTable == NULL) {
        _tprintf(TEXT("Error - Out of Memory processing Strings section\n"));
        return FALSE;
    }

    StringTableCount = 0;

    for (i=0; i<LineCount; i++) {
        StringId = InfGetLineKeyName( pINF, TEXT("Strings"), i );
        StringValue = InfGetFieldByIndex( pINF, TEXT("Strings"), i, 0 );
        if (StringId && StringValue) {
            StringTable[i].StringId = StringId;
            StringTable[i].StringValue = StringValue;
            StringTableCount += 1;
        }
    }

    pSection = pINF->pSection;
    while(pSection) {
        pLine = pSection->pLine;
        while(pLine) {
            pValue = pLine->pValue;
            while(pValue) {
                if (pValue->IsStringId) {
                    for (i=0; i<StringTableCount; i++) {
                        if (_tcsicmp( StringTable[i].StringId, pValue->pName ) == 0) {
                            free(pValue->pName);
                            pValue->pName = DupString( (PTSTR)StringTable[i].StringValue );
                            break;
                        }
                    }
                }
                pValue = pValue->pNext;
            }
            pLine = pLine->pNext;
        }
        pSection = pSection->pNext;
    }

    free( StringTable );

    return TRUE;
}






DWORD
MapFileForRead(
    IN  LPCTSTR  FileName,
    OUT PDWORD   FileSize,
    OUT PHANDLE  FileHandle,
    OUT PHANDLE  MappingHandle,
    OUT PVOID   *BaseAddress
    )

/*++

Routine Description:

    Open and map an entire file for read access. The file must
    not be 0-length or the routine fails.

Arguments:

    FileName - supplies pathname to file to be mapped.

    FileSize - receives the size in bytes of the file.

    FileHandle - receives the win32 file handle for the open file.
        The file will be opened for generic read access.

    MappingHandle - receives the win32 handle for the file mapping
        object.  This object will be for read access.  This value is
        undefined if the file being opened is 0 length.

    BaseAddress - receives the address where the file is mapped.  This
        value is undefined if the file being opened is 0 length.

Return Value:

    NO_ERROR if the file was opened and mapped successfully.
        The caller must unmap the file with UnmapFile when
        access to the file is no longer desired.

    Win32 error code if the file was not successfully mapped.

--*/

{
    DWORD rc;

    //
    // Open the file -- fail if it does not exist.
    //
    *FileHandle = CreateFile(
                    FileName,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );

    if(*FileHandle == INVALID_HANDLE_VALUE) {

        rc = GetLastError();

    } else {
        //
        // Get the size of the file.
        //
        *FileSize = GetFileSize(*FileHandle,NULL);
        if(*FileSize == (DWORD)(-1)) {
            rc = GetLastError();
        } else {
            //
            // Create file mapping for the whole file.
            //
            *MappingHandle = CreateFileMapping(
                                *FileHandle,
                                NULL,
                                PAGE_READONLY,
                                0,
                                *FileSize,
                                NULL
                                );

            if(*MappingHandle) {

                //
                // Map the whole file.
                //
                *BaseAddress = MapViewOfFile(
                                    *MappingHandle,
                                    FILE_MAP_READ,
                                    0,
                                    0,
                                    *FileSize
                                    );

                if(*BaseAddress) {
                    return(NO_ERROR);
                }

                rc = GetLastError();
                CloseHandle(*MappingHandle);
            } else {
                rc = GetLastError();
            }
        }

        CloseHandle(*FileHandle);
    }

    return(rc);
}



DWORD
UnmapFile(
    IN HANDLE MappingHandle,
    IN PVOID  BaseAddress
    )

/*++

Routine Description:

    Unmap and close a file.

Arguments:

    MappingHandle - supplies the win32 handle for the open file mapping
        object.

    BaseAddress - supplies the address where the file is mapped.

Return Value:

    NO_ERROR if the file was unmapped successfully.

    Win32 error code if the file was not successfully unmapped.

--*/

{
    DWORD rc;

    rc = UnmapViewOfFile(BaseAddress) ? NO_ERROR : GetLastError();

    if(!CloseHandle(MappingHandle)) {
        if(rc == NO_ERROR) {
            rc = GetLastError();
        }
    }

    return(rc);
}

LPTSTR
DupString(
    IN LPCTSTR String
    )

/*++

Routine Description:

    Make a duplicate of a nul-terminated string.

Arguments:

    String - supplies pointer to nul-terminated string to copy.

Return Value:

    Copy of string or NULL if OOM. Caller can free with FREE().

--*/

{
    LPTSTR p;

    if(p = malloc((lstrlen(String)+1)*sizeof(TCHAR))) {
        lstrcpy(p,String);
    }

    return(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\win4\tools\infmerge\infmerge.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    infmerge.c

Abstract:

    This module implements a program that merge two inf files
    to one inf file.

    See below for more information.

Author:

    Katsumi Yokomichi (Katsumiy) 22-May-2000

Revision History:

--*/


/*
*/


#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <shellapi.h>

#include <setupapi.h>
#include <spapip.h>


CHAR Buffer[1024];
CHAR Buffer2[1024];
CHAR Section[1024];
CHAR Section2[1024];
FILE    *InFile1;
FILE    *InFile2;
FILE    *OutFile;
CHAR PrevSection[1024];

/* Extract Section name (inside of []) from Line text. */

BOOL GetSection(CHAR *p, CHAR *SectionName, INT SectionSize)
{
    CHAR *cp;
    CHAR *sp1;
    CHAR *sp2;
    CHAR *q1;
    CHAR *q2 = 0;

    cp = strchr(p, ';');
    sp1 = strchr(p, '[');
    sp2 = strchr(p, ']');
    q1  = strchr(p, '"');
    if ( q1 ) {
      q2 = strchr(q1+1, '"');
    }

    if ((sp1 == NULL)            ||
        (sp2 == NULL)            ||
        (sp1 > sp2)              ||
        (cp != NULL && cp < sp1) ||
        (q1 < sp1 && q2 > sp1))  {
        return FALSE;
    }

    strncpy(SectionName, sp1, (sp2 - sp1)+1 );
    *(SectionName + (sp2 - sp1)+1) = '\0';
    return TRUE;
}

/* Read 1 section from 2nd file and merge into Output file. */

VOID Merge(VOID)
{
    BOOL InSection2;

    fseek(InFile2, 0, SEEK_SET);
    InSection2 = FALSE;
    while (fgets(Buffer2, sizeof(Buffer2), InFile2)) {
        if (GetSection(Buffer2,Section2, sizeof(Section2))) {
            if (InSection2) {
                break;
            } else {
                if (0 == strcmp(Section2, PrevSection)) {
                    InSection2 = TRUE;
                    continue;
                }
            }
        }
        if (InSection2) {
            fputs(Buffer2, OutFile);
        }
    }
}

int
__cdecl
main(
    IN int   argc,
    IN CHAR *argv[]
    )
{
    BOOL InSection;

    if (argc != 4) {
        goto ErrorExit;
    }

    if ((InFile1 = fopen(argv[1], "r")) == NULL) {
        fprintf(stderr, "Can't open %s.\n", argv[1]);
        goto ErrorExit;
    }

    if ((InFile2 = fopen(argv[2], "r")) == NULL) {
        fprintf(stderr, "Can't open %s.\n", argv[2]);
        goto ErrorExit;
    }

    if ((OutFile = fopen(argv[3], "w")) == NULL) {
        fprintf(stderr, "Can't open %s.\n", argv[3]);
        goto ErrorExit;
    }

    InSection = FALSE;
    while (fgets(Buffer, sizeof(Buffer), InFile1)) {
        if (GetSection(Buffer,Section, sizeof(Section))) {
            if (InSection) {
                Merge();
                strcpy(PrevSection, Section);
            } else {
                InSection = TRUE;
                strcpy(PrevSection, Section);
            }
        }
        fputs(Buffer, OutFile);

    }

    if (InSection) {
        Merge();
    }

    return 0;

ErrorExit:
    fprintf(stderr, "Usage: %s InputFile1 InputFile2 OutputFile.\n", argv[0]);
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\win4\tools\inflib\inflib.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    inflib.c

Abstract:

    Source for inflib.lib that implements functions designed to build a
    layout context given a layout INF file. This sets up an infrastructure
    to build tools that will need to reference a layout inf file.

Author:

    Vijesh Shetty (vijeshs)

Revision History:

--*/

#include <stdio.h>
#include <windows.h>
#include <conio.h>
#include <process.h>
#include <tchar.h>
#include <objbase.h>
#include <io.h>
#include <setupapi.h>
#include <sputils.h>
#include <inflib.h>
#include <string.h>

//#define DEBUG 1

#define LAYOUT_DIR_SECTION TEXT("WinntDirectories")
#define MAX_TEMP 500

//Structure to pass parameters to the enumeration callback

typedef struct _CALLBACK_PACKAGE{

    PLAYOUT_CONTEXT Context;
    PLAYOUTENUMCALLBACK Callback;
    DWORD_PTR Param;


}CALLBACK_PACKAGE, *PCALLBACK_PACKAGE;


//Structure to pass parameters to the enumeration callback

typedef struct _WINNT_DIRCODES{

    TCHAR Dir[MAX_PATH];


}WINNT_DIRCODES, *PWINNT_DIRCODES;


#if DBG

VOID
AssertFail(
    IN PSTR FileName,
    IN UINT LineNumber,
    IN PSTR Condition
    )
{
    int i;
    CHAR Name[MAX_PATH];
    PCHAR p;
    CHAR Msg[4096];

    //
    // Use dll name as caption
    //
    GetModuleFileNameA(NULL,Name,MAX_PATH);
    if(p = strrchr(Name,'\\')) {
        p++;
    } else {
        p = Name;
    }

    wsprintfA(
        Msg,
        "Assertion failure at line %u in file %s: %s\n\nCall DebugBreak()?",
        LineNumber,
        FileName,
        Condition
        );

    OutputDebugStringA(Msg);

    i = MessageBoxA(
                NULL,
                Msg,
                p,
                MB_YESNO | MB_TASKMODAL | MB_ICONSTOP | MB_SETFOREGROUND
                );

    if(i == IDYES) {
        DebugBreak();
    }
}

#define MYASSERT(x)     if(!(x)) { AssertFail(__FILE__,__LINE__,#x); }

#else

#define MYASSERT( exp )

#endif // DBG



BOOL
InternalEnumRoutine(
    IN PVOID StringTable,
    IN LONG StringId,
    IN PCTSTR String,
    IN PFILE_LAYOUTINFORMATION LayoutInfo,
    IN UINT LayoutInfoSize,
    IN LPARAM Param
    );


BOOL ValidateTextmodeDirCodesSection( 
    PCTSTR LayoutFile, 
    PCTSTR WinntdirSection 
    )
/*
    Routine to validate the [WinntDirectories] section for a setup layout INF. This checks for errors that maybe encountered
    when people add/remove stuff from this section.
    
    Arguments:
    
    LayoutInf       - Name of setup layout INF that contains the specified section
    
    WinntdirSection - Section that contains dir codes
        
        Checks - 
            1) Looks for duplicate or reused dir codes
            
    Return value: 
        TRUE - Validation succeeded
        FALSE- Validation failed     
*/
{

    //OPen up the layout file.

    HINF LayoutInf;
    PVOID StringTable=NULL;
    INFCONTEXT LineContext;
    WINNT_DIRCODES WinntDirs, Buffer;
    BOOL ret = TRUE;
    LONG StrID, Size;
    TCHAR DirCode[4];
    
    LayoutInf = SetupOpenInfFile( LayoutFile, NULL, INF_STYLE_WIN4 | INF_STYLE_CACHE_ENABLE, NULL);

    if( !LayoutInf || (LayoutInf == INVALID_HANDLE_VALUE)){
        _tprintf(TEXT("%s : Error E0000 : Could not open %s\n"), LayoutFile);
        return FALSE;
    }

    //Grovel through the specified section and populate our WINNT_DIRCODES structure

    if( !SetupFindFirstLine(LayoutInf,WinntdirSection,NULL,&LineContext)){
        _tprintf(TEXT("%s : Error E0000 : Can't find section [%s]\n"), LayoutFile, WinntdirSection);
        return(FALSE);
    }
        



    // Create a stringtable for hashing of the SourceDisksNames section.

    if( (StringTable=pSetupStringTableInitializeEx( sizeof(WINNT_DIRCODES), 0 )) == NULL ){
        _tprintf(TEXT("%s : Error E0000 : Internal error processing [%s] section (1)\n"), LayoutFile, WinntdirSection);
        return(FALSE);
    }
    

    do{

        ZeroMemory( &WinntDirs, sizeof(WINNT_DIRCODES));

        if( SetupGetStringField( &LineContext, 0, NULL, 0, &Size) ){
    
    
                if( SetupGetStringField( &LineContext, 0, DirCode, Size, NULL )){
    
                    //
                    //  Add the Filename to the StringTable. Look for its presence so that the Count is updated
                    //

                    if(!SetupGetStringField( &LineContext, 1, WinntDirs.Dir, MAX_PATH, NULL)){
                        _tprintf(TEXT("%s : Error E0000 : Directory missing for Dir ID %s\n"), LayoutFile, DirCode);
                        ret = FALSE;
                        break;

                    }
                        
    
    
                    if( pSetupStringTableLookUpStringEx( StringTable,
                                       DirCode,
                                       STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                       &Buffer,
                                       sizeof(WINNT_DIRCODES)) != -1 ){

                        _tprintf(TEXT("%s : Error E0000 : Duplicate Dir ID found in [%s] section - Dir ID %s reused by %s, %s\n"), LayoutFile, WinntdirSection, DirCode, Buffer.Dir, WinntDirs.Dir);
                        
                    }
                    else{

                        StrID = pSetupStringTableAddString( StringTable, 
                                                            DirCode,
                                                            STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE);
                        
                        if( StrID == -1 ){
                           _tprintf(TEXT("%s : Error E0000 : Internal error processing [%s] section (2)\n"), LayoutFile, WinntdirSection);
                           ret = FALSE;
                           break;
                        }


                        if(!pSetupStringTableSetExtraData( StringTable, StrID, (PVOID)&WinntDirs, sizeof(WINNT_DIRCODES))){
                            _tprintf(TEXT("%s : Error E0000 : Internal error processing [%s] section (3)\n"), LayoutFile, WinntdirSection);
                            ret = FALSE;
                            break;
                        }

                    }
                        
                }else
                    _tprintf(TEXT("%s : Error E0000 : Internal error processing [%s] section (4)\n"), LayoutFile, WinntdirSection);

        }else
            _tprintf(TEXT("%s : Error E0000 : Internal error processing [%s] section (5)\n"), LayoutFile, WinntdirSection);
    }while(SetupFindNextLine(&LineContext, &LineContext));


    // If we are here and ret=TRUE that means we are done and have suceeded.

    if( StringTable )
        pSetupStringTableDestroy( StringTable );

    return ret;



}



DWORD
BuildMediaTagsInformation(
    IN HINF LayoutInf,
    IN LPCTSTR SectionName,
    IN PLAYOUT_CONTEXT LayoutContext,
    IN UINT Platform_Index)

/*
    Function to populate the stringtable given a handle to the inf and the name of the
    SourceDisksFiles Section.

    Arguments :

        LayoutInf - Handle to a layout file that has the SourceDisksNames Section

        SectionName - Name of the SourceDisksNames Section (this is so that we can specify decorated sections)

        LayoutContext - Layout Context that we want to build

        Platform_Index - Index in the MEDIA_INFO Array

*/
{
    DWORD Err = 0;
    INFCONTEXT LineContext;
    MEDIA_INFO Media_Info;
    TCHAR TempStr[500];
    LONG StrID;



    //Grovel through the specified section and populate our MEDIA_TAGS structure

    if( !SetupFindFirstLine(LayoutInf,SectionName,NULL,&LineContext))
        return(ERROR_NOT_ENOUGH_MEMORY);   //BUGBUG - Fix error code



    //StringTableSetConstants( 4096000, 4096000 );



    // Create a stringtable for hashing of the SourceDisksNames section.

    if( (LayoutContext->MediaInfo[Platform_Index]=pSetupStringTableInitializeEx( sizeof(MEDIA_INFO), 0 )) == NULL )
        return(ERROR_NOT_ENOUGH_MEMORY);   //BUGBUG - Fix error code


    // Now populate it

    do{

        ZeroMemory( &Media_Info, sizeof(MEDIA_INFO));


        if( SetupGetStringField( &LineContext, 0, TempStr, MAX_TEMP, NULL )){

            StrID = pSetupStringTableAddString( LayoutContext->MediaInfo[Platform_Index],
                                  TempStr,
                                  STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE);

            if( StrID == -1 ){
               Err = ERROR_NOT_ENOUGH_MEMORY;
               _tprintf(TEXT("\nERROR-Could not add string to table\n"));
               break;
            }
        }else
            return( ERROR_NOT_ENOUGH_MEMORY ); //BUGBUG - Fix error code

        //_tprintf( TEXT("\nTagID - %s\n"), TempStr );


        if( SetupGetStringField( &LineContext, 1, TempStr, MAX_TEMP, NULL) )
            lstrcpy(Media_Info.MediaName, TempStr);

        if( SetupGetStringField( &LineContext, 2, TempStr, MAX_TEMP, NULL) )
            lstrcpy(Media_Info.TagFilename, TempStr);

        if( SetupGetStringField( &LineContext, 4, TempStr, MAX_TEMP, NULL) )
            lstrcpy(Media_Info.RootDir, TempStr);

        /*
        _tprintf( TEXT("\nMediaName - %s\n"), Media_Info.MediaName );
        _tprintf( TEXT("TagFilename - %s\n"), Media_Info.TagFilename );
        _tprintf( TEXT("RootDir - %s\n"), Media_Info.RootDir );
       */

        //
        // Now add the information to the string table.
        //

        if(!pSetupStringTableSetExtraData( LayoutContext->MediaInfo[Platform_Index], StrID, (PVOID)&Media_Info, sizeof(MEDIA_INFO))){

            Err = ERROR_NOT_ENOUGH_MEMORY; //BUGBUG - Fix error code
            _tprintf(TEXT("\nERROR-Could not set extra data for Media Info\n"));
            break;
        }



    }while(SetupFindNextLine(&LineContext, &LineContext));


    return Err;

}





DWORD
BuildStringTableForSection(
    IN HINF LayoutInf,
    IN LPCTSTR SectionName,
    IN PLAYOUT_CONTEXT LayoutContext,
    IN UINT Platform_Index)

/*
    Function to populate the stringtable given a handle to the inf and the name of the
    SourceDisksFiles Section.

    Arguments :

        LayoutInf - Handle to a layout file that has the SourceDisksFiles Section

        SectionName - Name of the SourceDisksFilesSection (this is so that we can specify decorated sections)

        LayoutContext - Layout Context that we want to build



*/
{
    DWORD Err = 0;
    INFCONTEXT LineContext, TempContext;
    DWORD Size;
    int Temp;
    LONG StrID;
    LPTSTR p;
    TCHAR TempString[MAX_PATH];
    FILE_LAYOUTINFORMATION FileInformation;
    TCHAR FileName[MAX_PATH];
    TCHAR Buffer[10];
    PVOID LookupBuffer=NULL;
    PFILE_LAYOUTINFORMATION Lookup;

#ifdef DEBUG

    int count=0;

#endif


    LookupBuffer = pSetupMalloc( LayoutContext->ExtraDataSize );
    if( !LookupBuffer ){
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }


    //Grovel through the specified section and populate our FILE_LAYOUTINFORMATION structure for each file

    if( !SetupFindFirstLine(LayoutInf,SectionName,NULL,&LineContext)){
        Err = ERROR_NOT_ENOUGH_MEMORY;   //BUGBUG - Fix error code
        goto cleanup;
    }



    do{

        ZeroMemory( &FileInformation, sizeof(FILE_LAYOUTINFORMATION));

        FileInformation.Compression = TRUE;

        if( SetupGetStringField( &LineContext, 0, NULL, 0, &Size) ){


            if( SetupGetStringField( &LineContext, 0, FileName, Size, NULL )){

                //
                //  Add the Filename to the StringTable. Look for its presence so that the Count is updated
                //


                if( pSetupStringTableLookUpStringEx( LayoutContext->Context,
                                   FileName,
                                   STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                   LookupBuffer,
                                   LayoutContext->ExtraDataSize) != -1 ){

                    Lookup = (PFILE_LAYOUTINFORMATION)(LookupBuffer);

                    // Check for same platform section

                    if( (Lookup->SectionIndex == Platform_Index) || (Lookup->SectionIndex == LAYOUTPLATFORMINDEX_COMMON))
                        FileInformation.Count = Lookup->Count + 1;

                }
                else
                    FileInformation.Count = 1;

                StrID = pSetupStringTableAddString( LayoutContext->Context,
                                      FileName,
                                      STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE);

                if( StrID == -1 ){
                   Err = ERROR_NOT_ENOUGH_MEMORY;
                   _tprintf(TEXT("\nERROR-Could not add string to table\n"));
                   break;
                }



                //
                //  Now add the other related info for the file as ExtraData
                //

                // Get the directory code

                if( SetupGetIntField( &LineContext, 8, &Temp )){

                    FileInformation.Directory_Code = Temp;

                    _itot( Temp,Buffer, 10);

                    //Now retrieve the directory Information through a lookup of [WinntDirectories]

                    if( Temp && SetupFindFirstLine( LayoutInf, LAYOUT_DIR_SECTION, Buffer, &TempContext) ){

                        if( SetupGetStringField( &TempContext, 1, TempString, MAX_PATH, NULL )){
                            lstrcpy( FileInformation.Directory, TempString );
                        }


                    }

                }

                //
                // Get the Upgrade and Clean Install Dispositions
                //


                FileInformation.UpgradeDisposition = 3;  //Default is don't copy

                if( SetupGetStringField( &LineContext, 9, TempString, MAX_PATH, NULL )){
                
                    if( (TempString[0] >= 48) &&  (TempString[0] <= 57)){
                        Temp = _ttoi( TempString );
                        FileInformation.UpgradeDisposition = Temp;
                    }
                    
                }

                if( (FileInformation.UpgradeDisposition < 0) || (FileInformation.UpgradeDisposition > 3))
                    _ftprintf(stderr, TEXT("%s - Bad Upgrade disposition value - Inf maybe corrupt\n"),FileName);

                FileInformation.CleanInstallDisposition = 3; //Default is don't copy
                if( SetupGetStringField( &LineContext, 10, TempString, MAX_PATH, NULL )){
                    
                    if( (TempString[0] >= 48) &&  (TempString[0] <= 57)){
                        Temp = _ttoi( TempString );
                        FileInformation.CleanInstallDisposition = Temp;
                    }
                    
                }

                if( (FileInformation.CleanInstallDisposition < 0) || (FileInformation.CleanInstallDisposition > 3))
                    _ftprintf(stderr, TEXT("%s - Bad Clean Install disposition value - Inf maybe corrupt\n"),FileName);

                if( SetupGetStringField( &LineContext, 11, TempString, MAX_PATH, NULL )){
                    lstrcpy( FileInformation.TargetFileName, TempString );
                }

                if( SetupGetStringField( &LineContext, 7, TempString, MAX_PATH, NULL )){

                    if( *TempString && !_tcschr(TempString, TEXT('_'))){
                        _ftprintf(stderr, TEXT("\nERROR-Bad Media ID - No _ qualifier - %s\n"), FileName);
                        FileInformation.BootMediaNumber = -1;  //Indicates error
                    }else{


                        // Check for Compression


                        if( TempString[0] == TEXT('_') )
                            FileInformation.Compression = FALSE;

                        // Look for Boot Media Numbers
                        p = TempString;

                        while( (p[0] == TEXT('_')) ){
                            p++;
                        }
                        FileInformation.BootMediaNumber = _ttoi(p);

                    }

                }

                //Add the Media tag information

                if( SetupGetStringField( &LineContext, 1, TempString, MAX_PATH, NULL ))
                    lstrcpy(FileInformation.Media_tagID, TempString);

                FileInformation.SectionIndex = Platform_Index;


                //Get the file sizes if present

                if( SetupGetIntField( &LineContext, 3, &Temp )){
                    FileInformation.Size = (ULONG)Temp;
                }

                //
                // Now add the information to the string table.
                //

                if(!pSetupStringTableSetExtraData( LayoutContext->Context, StrID, (PVOID)&FileInformation, sizeof(FILE_LAYOUTINFORMATION))){

                    Err = ERROR_NOT_ENOUGH_MEMORY; //BUGBUG - Fix error code
                    _tprintf(TEXT("\nERROR-Could not set extra data\n"));
                    break;
                }


                /*

                _tprintf(TEXT("File - %s\n"),FileName);
                _tprintf(TEXT("Dir Code %d - Dir - %s\n"),FileInformation.Directory_Code, FileInformation.Directory);
                _tprintf(TEXT("Upgrade Disposition - %d\n"),FileInformation.UpgradeDisposition);
                _tprintf(TEXT("Textmode Disposition - %d\n"),FileInformation.CleanInstallDisposition);
                _tprintf(TEXT("Media ID - %s\n"),FileInformation.Media_tagID);
                if( *(FileInformation.TargetFileName))
                    _tprintf(TEXT("Target Filename - %s\n"),FileInformation.TargetFileName);
                if( !FileInformation.Compression )
                    _tprintf(TEXT("No Compression\n"));
                if( FileInformation.BootMediaNumber )
                    _tprintf(TEXT("Boot Media - %d\n"),FileInformation.BootMediaNumber);

                */

            }


        }
#ifdef DEBUG
        count++;
        if( (count % 100) == 0)
            _ftprintf(stderr,TEXT("\b\b\b\b\b%5d"),count);
#endif


    }while(SetupFindNextLine(&LineContext, &LineContext));// while


cleanup:

    if( LookupBuffer )
        pSetupFree(LookupBuffer);



    return Err;

}










PLAYOUT_CONTEXT
BuildLayoutInfContext(
    IN PCTSTR LayoutInfName,
    IN DWORD PlatformMask,
    IN UINT MaxExtraSize
    )

/*
    Function to generate a internal representation of files listed in a layout INF file.
    It returns an opaque context that can be used with other APIs to
    manipulate/query this representation. The internal representation builds a structure
    associated with each file that lists its attributes.

    Arguments :

        LayoutInfName - Full path to Layout file.

        PlatFormMask - Can be one of the following....

            LAYOUTPLATFORMS_ALL (default) - Grovels through all the platform-specific section

            LAYOUTPLATFORMS_X86 - Grovels through the SourcedisksFiles.x86 section

            LAYOUTPLATFORMS_AMD64 - Grovels through the SourcedisksFiles.amd64 section

            LAYOUTPLATFORMS_IA64 - Grovels through the SourcedisksFiles.ia64 section

            LAYOUTPLATFORMS_COMMON - Grovels through the SourcedisksFiles section

        MaxExtraSize  - Largest possible extra-data size that we may want to associate with
                        each file

    Return value :


        An opaque LAYOUT_CONTEXT used to access the data structure in other calls.
        Returns NULL if we had a failure.


*/

{

    PLAYOUT_CONTEXT LayoutContext;
    PVOID StringTable;
    HINF LayoutInf;
    DWORD Err;



    // Initialize the string table and set the max extra data size

    if( (StringTable=pSetupStringTableInitializeEx( (MaxExtraSize+sizeof(FILE_LAYOUTINFORMATION)), 0 )) == NULL )
        return NULL;


    //OPen up the layout file.

    LayoutInf = SetupOpenInfFile( LayoutInfName, NULL, INF_STYLE_WIN4 | INF_STYLE_CACHE_ENABLE, NULL);

    if( !LayoutInf || (LayoutInf == INVALID_HANDLE_VALUE)){
        pSetupStringTableDestroy( StringTable );
        return NULL;
    }


    LayoutContext = pSetupMalloc( sizeof(LAYOUT_CONTEXT));
    if( !LayoutContext )
        goto done;

    ZeroMemory( LayoutContext, sizeof(LAYOUT_CONTEXT));



    LayoutContext->Context = StringTable;
    LayoutContext->ExtraDataSize = (MaxExtraSize+sizeof(FILE_LAYOUTINFORMATION));






    //
    //Now we need to grovel throught the [SourceDisksFiles] sections
    //

    //
    // Grovel through the decorated sections first as specfied by PlatformMask
    //

    if(!PlatformMask)
        PlatformMask = LAYOUTPLATFORMS_ALL;

    //
    //
    //



#ifdef DEBUG
    _tprintf( TEXT("\nBuilding x86 section\n"));
#endif
    if( PlatformMask & LAYOUTPLATFORMS_X86 ){


        //
        //  Build up the [SourceDisksNames.x86] Information
        //

        Err = BuildMediaTagsInformation( LayoutInf, TEXT("SourceDisksNames.x86"), LayoutContext, LAYOUTPLATFORMINDEX_X86);


        // Process [SourceDisksFiles.x86]

        Err = BuildStringTableForSection( LayoutInf, TEXT("SourceDisksFiles.x86"), LayoutContext, LAYOUTPLATFORMINDEX_X86 );


    }
#ifdef DEBUG
    _tprintf( TEXT("\nBuilding amd64 section\n"));
#endif
    if( PlatformMask & LAYOUTPLATFORMS_AMD64 ){

        //
        //  Build up the [SourceDisksNames.amd64] Information
        //

        Err = BuildMediaTagsInformation( LayoutInf, TEXT("SourceDisksNames.amd64"), LayoutContext, LAYOUTPLATFORMINDEX_AMD64);


        // Process [SourceDisksFiles.amd64]

        Err = BuildStringTableForSection( LayoutInf, TEXT("SourceDisksFiles.amd64"), LayoutContext, LAYOUTPLATFORMINDEX_AMD64 );


    }
#ifdef DEBUG
    _tprintf( TEXT("\nBuilding ia64 section\n"));
#endif
    if( PlatformMask & LAYOUTPLATFORMS_IA64 ){

        //
        //  Build up the [SourceDisksNames.ia64] Information
        //

        Err = BuildMediaTagsInformation( LayoutInf, TEXT("SourceDisksNames.ia64"), LayoutContext, LAYOUTPLATFORMINDEX_IA64);

        // Process [SourceDisksFiles.ia64]

        Err = BuildStringTableForSection( LayoutInf, TEXT("SourceDisksFiles.ia64"), LayoutContext, LAYOUTPLATFORMINDEX_IA64 );


    }
#ifdef DEBUG
    _tprintf( TEXT("\nBuilding common section\n"));
#endif
    if( PlatformMask & LAYOUTPLATFORMS_COMMON ){

        //
        //  Build up the [SourceDisksNames] Information. In this case we have
        //  currently set it to the same as x86. Should fix this to do something better - BUGBUG
        //

        Err = BuildMediaTagsInformation( LayoutInf, TEXT("SourceDisksNames"), LayoutContext, LAYOUTPLATFORMINDEX_COMMON);

        // Process [SourceDisksFiles]

        Err = BuildStringTableForSection( LayoutInf, TEXT("SourceDisksFiles"), LayoutContext, LAYOUTPLATFORMINDEX_COMMON);


    }




done:

    SetupCloseInfFile( LayoutInf);
    return(LayoutContext) ;


}


BOOL
EnumerateLayoutInf(
    IN PLAYOUT_CONTEXT LayoutContext,
    IN PLAYOUTENUMCALLBACK LayoutEnumCallback,
    IN DWORD_PTR Param
    )
/*
  This function calls the specified callback function for each
  element in the SourceDisksFilesSection associated with the
  Layout Inf Context specified.

    It is required that the user has a LayoutInfContext open from a call to
    BuildLayoutInfContext.

    Arguments:

        Context - A LAYOUT_CONTEXT returned by BuildLayoutInfContext

        LayoutEnumCallback - specifies a callback function called for each file in the SourceDisksFile section

        CallerContext - An opaque context pointer passed on to the callback function


The callback is of the form:

typedef BOOL
(CALLBACK *PLAYOUTENUMCALLBACK) (
    IN PLAYOUT_CONTEXT Context,
    IN PCTSTR FileName,
    IN PFILE_LAYOUTINFORMATION LayoutInformation,
    IN PVOID ExtraData,
    IN UINT ExtraDataSize,
    IN OUT DWORD_PTR Param
    );

    where

    Context            - Pointer to open LAYOUT_CONTEXT

    FileName           - Specifies the individual filename


    LayoutInformation  - Pointer to Layout Information for this file.  User should not modify this directly.

    ExtraData          - Pointer to the ExtraData that the caller may have stored. User should not modify this directly.

    ExtraDataSize      - Size in bytes of the ExtraData

    Param            - the opaque param passed into this function is passed
                           into the callback function


   Return value:

        TRUE if all the elements were enumerated. If not it returns
        FALSE and GetLastError() returns ERROR_CANCELLED. If the callback
        returns FALSE then the enumeration stops but this API returns TRUE.

*/

{

    PVOID Buffer;
    CALLBACK_PACKAGE Package;
    BOOL ret;


    if( !LayoutContext ||
        !LayoutContext->Context ||
        !LayoutContext->ExtraDataSize ||
        !LayoutEnumCallback){
        SetLastError( ERROR_INVALID_PARAMETER );
        return( FALSE );
    }


    Buffer = pSetupMalloc( LayoutContext->ExtraDataSize );

    if( !Buffer ){
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return(FALSE);

    }

    //We use Package to send across parameters to the Callback

    Package.Context = LayoutContext;
    Package.Callback = LayoutEnumCallback;
    Package.Param = Param;

    ret = pSetupStringTableEnum( LayoutContext->Context,
                           Buffer,
                           LayoutContext->ExtraDataSize,
                           InternalEnumRoutine,
                           (LPARAM) &Package);

    pSetupFree( Buffer );

    return( ret );



}




BOOL
InternalEnumRoutine(
    IN PVOID StringTable,
    IN LONG StringId,
    IN PCTSTR String,
    IN PFILE_LAYOUTINFORMATION LayoutInfo,
    IN UINT LayoutInfoSize,
    IN LPARAM Param
    )
/*

    This is the enum callback routine that we provide to setupapi. We
    in turn have to call the callers callback routine each time we are called.
    The callback routine of the caller is in Package.

    For now, we don't care about the StringID and don't tell the caller
    about it.

    */

{

    PVOID ExtraData;
    UINT  ExtraDataSize;
    PCALLBACK_PACKAGE Package = (PCALLBACK_PACKAGE)Param;
    BOOL ret;

    MYASSERT( Package->Callback );


    ExtraData = LayoutInfo+sizeof(FILE_LAYOUTINFORMATION);
    ExtraDataSize = LayoutInfoSize-(sizeof(FILE_LAYOUTINFORMATION));

    //BUGBUG :  Should probably put this in a try/except block

    ret = Package->Callback( Package->Context,
                             String,
                             LayoutInfo,
                             ExtraData,
                             ExtraDataSize,
                             Package->Param );


    //
    // If the user's callback returns false we stop enumeration. However the
    // toplevel EnumerateLayoutInf function still returns TRUE as it was not an
    // error in itself.
    //

    if( !ret ){
        SetLastError(ERROR_INVALID_PARAMETER);
        return( FALSE );
    }



    return( TRUE );



}



BOOL
FindFileInLayoutInf(
    IN PLAYOUT_CONTEXT LayoutContext,
    IN PCTSTR Filename,
    OUT PFILE_LAYOUTINFORMATION LayoutInformation, OPTIONAL
    OUT PVOID ExtraData,   OPTIONAL
    OUT PUINT ExtraDataSize, OPTIONAL
    OUT PMEDIA_INFO Media_Info OPTIONAL
    )
/*
    This function finds the file information for a given filename inside a
    built layout context. It returns the layout information as well as the
    extra data (if any) associated with the file.

    Arguments:

        Context            - Pointer to open LAYOUT_CONTEXT

        Filename           - Specifies the filename to search for

        LayoutInformation  - Pointer to caller supplied buffer that gets Layout Information for this file.

        ExtraData          - Pointer to the a caller supplied buffer that gets ExtraData that the caller may have stored. 

        ExtraDataSize      - Size in bytes of the ExtraData returned.

        Media_Info         - Pointer to MEDIA_INFO structure that will get filled
                             with the file's corresponding Media information.

     Return value;

        TRUE if the file is found - False otherwise.


*/
{
    PVOID Buffer;
    MEDIA_INFO TagInfo;
    PFILE_LAYOUTINFORMATION Temp;
    BOOL Err = TRUE;
    TCHAR filename[MAX_PATH];


    if( !LayoutContext ||
        !LayoutContext->Context ||
        !LayoutContext->ExtraDataSize ||
        !Filename){
        SetLastError( ERROR_INVALID_PARAMETER );
        return( FALSE );
    }

    lstrcpy( filename, Filename ); //To get around constness problem

    Buffer = pSetupMalloc( LayoutContext->ExtraDataSize );

    if( !Buffer ){
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return(FALSE);

    }

    if( pSetupStringTableLookUpStringEx( LayoutContext->Context,
                                   filename,
                                   STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                   Buffer,
                                   LayoutContext->ExtraDataSize) == -1 ){
        Err = FALSE;
        goto cleanup;
    }

    if( LayoutInformation )
        CopyMemory( LayoutInformation, Buffer, sizeof(FILE_LAYOUTINFORMATION));

    if( ExtraData ){

        CopyMemory( ExtraData,
                    ((PFILE_LAYOUTINFORMATION)Buffer+sizeof(FILE_LAYOUTINFORMATION)),
                    ((LayoutContext->ExtraDataSize)-(sizeof(FILE_LAYOUTINFORMATION))) );
    }

    if( ExtraDataSize )
        *ExtraDataSize = (LayoutContext->ExtraDataSize)-(sizeof(FILE_LAYOUTINFORMATION));


    //
    // Now get the Media Information for the file if needed
    //


    if( Media_Info ){

        Temp = (PFILE_LAYOUTINFORMATION)Buffer;

        if( pSetupStringTableLookUpStringEx( LayoutContext->MediaInfo[Temp->SectionIndex],
                                   Temp->Media_tagID,
                                   STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                   Media_Info,
                                   sizeof(MEDIA_INFO)) == -1 ){

            _tprintf( TEXT("\nError - Could not get Media Info for tag %s\n"), Temp->Media_tagID);

        }


    }


cleanup:

    if( Buffer )
        pSetupFree( Buffer );

    return Err;


}


BOOL
CloseLayoutInfContext(
    IN PLAYOUT_CONTEXT LayoutContext)
/*
    This function closes a Layout Inf Context and frees all memory
    associated with it.

    Arguments :

        LayoutContext   -  LayoutContext to close

    Return values :

        TRUE if it succeeds, else FALSE

*/
{
    int i;

    if( !LayoutContext ){
        SetLastError( ERROR_INVALID_PARAMETER );
        return( FALSE );
    }else{

        if( LayoutContext->Context )
            pSetupStringTableDestroy( LayoutContext->Context );

        for( i=0; i<MAX_PLATFORMS; i++ ){
            if( LayoutContext->MediaInfo[i] )
                pSetupStringTableDestroy( LayoutContext->MediaInfo[i] );
        }


        pSetupFree( LayoutContext );

    }

    return TRUE;

}




VOID
MyConcatenatePaths(
    IN OUT PTSTR   Path1,
    IN     LPCTSTR Path2,
    IN     DWORD   BufferSizeChars
    )

/*++

Routine Description:

    Concatenate two path strings together, supplying a path separator
    character (\) if necessary between the 2 parts.

Arguments:

    Path1 - supplies prefix part of path. Path2 is concatenated to Path1.

    Path2 - supplies the suffix part of path. If Path1 does not end with a
        path separator and Path2 does not start with one, then a path sep
        is appended to Path1 before appending Path2.

    BufferSizeChars - supplies the size in chars (Unicode version) or
        bytes (Ansi version) of the buffer pointed to by Path1. The string
        will be truncated as necessary to not overflow that size.

Return Value:

    None.

--*/

{
    BOOL NeedBackslash = TRUE;
    DWORD l;

    if(!Path1)
        return;

    l = lstrlen(Path1);

    if(BufferSizeChars >= sizeof(TCHAR)) {
        //
        // Leave room for terminating nul.
        //
        BufferSizeChars -= sizeof(TCHAR);
    }

    //
    // Determine whether we need to stick a backslash
    // between the components.
    //
    if(l && (Path1[l-1] == TEXT('\\'))) {

        NeedBackslash = FALSE;
    }

    if(Path2 && *Path2 == TEXT('\\')) {

        if(NeedBackslash) {
            NeedBackslash = FALSE;
        } else {
            //
            // Not only do we not need a backslash, but we
            // need to eliminate one before concatenating.
            //
            Path2++;
        }
    }

    //
    // Append backslash if necessary and if it fits.
    //
    if(NeedBackslash && (l < BufferSizeChars)) {
        lstrcat(Path1,TEXT("\\"));
    }

    //
    // Append second part of string to first part if it fits.
    //
    if(Path2 && ((l+lstrlen(Path2)) < BufferSizeChars)) {
        lstrcat(Path1,Path2);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\win4\tools\recab\recab.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    recab.c

Abstract:

    This module implements a program that determines the files in an INF that
    are newer than the a given file and writes these into a file.

    The input consists of a target inf (drvindex.inf), and a target file;
    the output consists of an inf file.

Author:

    Andrew Ritz (andrewr) 2-Feb-1999

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <setupapi.h>
#define PULONGLONG PDWORDLONG
#include <sputils.h>


//
// Define program result codes (returned from main()).
//
#define SUCCESS 0
#define FAILURE 1


//
// Keep statistics...
//
INT     ProcessedLines = 0;

BOOL
ParseArgs(
    IN int   argc,
    IN char *argv[]
    )
{
    return(argc == 5);
}


BOOL
IsFileNewer(
    IN PCWSTR SourceName,
    IN PWIN32_FIND_DATAW TargetFileData
    )
{
    WIN32_FIND_DATAW SourceFileData;
    HANDLE SourceHandle;
    LARGE_INTEGER SourceFileTime,TargetFileTime;

    SourceHandle = FindFirstFileW( SourceName, &SourceFileData );
    if (SourceHandle == INVALID_HANDLE_VALUE) {
    fprintf(stderr, TEXT("Error finding file %ws (%d)\n"), SourceName, GetLastError() );
        return(FALSE);
    }

    SourceFileTime.LowPart  = SourceFileData.ftLastWriteTime.dwLowDateTime;
    SourceFileTime.HighPart = SourceFileData.ftLastWriteTime.dwHighDateTime;
    TargetFileTime.LowPart  = TargetFileData->ftLastWriteTime.dwLowDateTime;
    TargetFileTime.HighPart = TargetFileData->ftLastWriteTime.dwHighDateTime;

    FindClose(SourceHandle);

    return (SourceFileTime.QuadPart > TargetFileTime.QuadPart) ;

}



BOOL
DoSection(
    IN HINF    hInputInf,
    IN PCWSTR  InputSectionName,
    IN FILE   *OutFile,
    IN PWIN32_FIND_DATAW TargetFileData
    )
{
    DWORD SectionCount, i;
    INFCONTEXT InputContext;
    UCHAR      line[4096];
    WCHAR      SourceFileName[MAX_PATH];

    SectionCount = SetupGetLineCountW(hInputInf,InputSectionName);

    for (i = 0; i < SectionCount; i++) {
        if (SetupGetLineByIndexW(hInputInf, InputSectionName, i, &InputContext)) {
            if(SetupGetStringFieldW(&InputContext,0,SourceFileName,MAX_PATH,NULL)) {
                if (IsFileNewer(SourceFileName,TargetFileData)) {
                    WideCharToMultiByte(
                        CP_OEMCP,
                        0,
                        SourceFileName,
                        -1,
                        line,
                        sizeof(line),
                        NULL,
                        NULL
                        );

                    fprintf(OutFile, TEXT("%s\n"),line);
                 } else if (GetLastError() != NO_ERROR) {
                    fprintf(stderr, TEXT("IsFileNewer failed\n"));
                    return(FALSE);
                 }
             } else {
                 fprintf(stderr, TEXT("SetupGetStringField failed, ec = %d\n"), GetLastError());
                 return(FALSE);
             }
        } else {
            fprintf(stderr, TEXT("SetupGetLineByIndex failed, ec = %d\n"), GetLastError());
            return(FALSE);
        }
        ProcessedLines += 1;
    }

    return(TRUE);
}

BOOL
DoIt(
    IN char *InfName,
    IN char *TargetFileNameA,
    IN char *cwd,
    IN FILE *OutFile
    )
{
    PCWSTR infFilename;
    PCWSTR TargetFileName;
    HINF hInputinf;
    BOOL b;
    WCHAR sectionName[256];
    PWSTR p;
    INFCONTEXT InfContext;
    WIN32_FIND_DATAW TargetFileData;
    HANDLE TargetHandle;

    b = FALSE;

    infFilename = pSetupAnsiToUnicode(InfName);
    TargetFileName = pSetupAnsiToUnicode(TargetFileNameA);

    //
    // Only proceed if we've got a file to work with.
    //
    if( infFilename ) {
        hInputinf = SetupOpenInfFileW(infFilename,NULL,INF_STYLE_WIN4,NULL);
        if(hInputinf != INVALID_HANDLE_VALUE) {

            SetCurrentDirectory(cwd);

            TargetHandle = FindFirstFileW( TargetFileName, &TargetFileData );
            if ( TargetHandle == INVALID_HANDLE_VALUE ) {
                fprintf( stderr, TEXT(" couldn't findfirstfile %ws, %d\n "),TargetFileName,GetLastError());
                    SetupCloseInfFile(hInputinf);
                return(FALSE);
            }

        fprintf(OutFile,"[Version]\n");
        fprintf(OutFile,"signature=\"$Windows NT$\"\n\n");
                fprintf(OutFile,"[Files]\n");
        p = wcsrchr( TargetFileName, L'\\' );
        if (!p) {
            p = (PWSTR)TargetFileName;
        } else {
            p++;
        }
        wcscpy(sectionName,p);
        p=wcsrchr(sectionName,L'.');
        if (p) {
           *p = 0;
        }

                b = DoSection( hInputinf,
                               sectionName,
                               OutFile,
                               &TargetFileData );

                //
                // Print Statistics...
                //
                fprintf( stderr, "                               Total lines processed: %6d\n", ProcessedLines );

                //
                // Close up our inf handles.
                //
                SetupCloseInfFile(hInputinf);

            } else {
                fprintf(stderr,"Unable to open inf file %ws %d\n",infFilename, GetLastError());
            }

        } else {
            fprintf(stderr,"Unable to convert filename %s to Unicode %d\n",InfName, GetLastError());
        }
        pSetupFree(infFilename);

    return(b);
}


int
__cdecl
main(
    IN int   argc,
    IN char *argv[]
    )
{
    FILE *OutputFile;
    BOOL b;

    //
    // Assume failure.
    //
    b = FALSE;

    if(!pSetupInitializeUtils()) {
        return FAILURE;
    }

    if(ParseArgs(argc,argv)) {

        //
        // Open the output file.
        //
        OutputFile = fopen(argv[4],"wt");
        if(OutputFile) {

            fprintf(stdout,"%s: creating %s from %s and %s\n",argv[0],argv[4],argv[1],argv[2]);
            b = DoIt( argv[1],
                      argv[2],
                      argv[3],
                      OutputFile
                    );

            fclose(OutputFile);

        } else {
            fprintf(stderr,"%s: Unable to create output file %s\n",argv[0],argv[3]);
        }
    } else {
        fprintf( stderr,"generate file with newer dependencies.  Usage:\n" );
        fprintf( stderr,"%s  <inf file> <file> <directory> <output file>\n", argv[0] );
        fprintf( stderr,"\n" );
        fprintf( stderr,"  <inf file>    - inf containing list of dependencies\n" );
        fprintf( stderr,"  <file>        - contains the file to compare against.\n" );
        fprintf( stderr,"  <directory>   - directory where the files live.\n" );
        fprintf( stderr,"  <output file> - output inf with newer dependencies\n" );
        fprintf( stderr,"\n" );
        fprintf( stderr,"\n" );

    }

    pSetupUninitializeUtils();

    return(b ? SUCCESS : FAILURE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\win4\tools\prodfilt\prodfilt.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    prodfilt.c

Abstract:

    This module implements a program that filters text files
    to produce a product-specific output file.

    See below for more information.

Author:

    Ted Miller (tedm) 20-May-1995

Revision History:

--*/


/*
    The input file to this program consists of a series of lines.
    Each line may be prefixed with one or more directives that
    indicate which product the line is a part of. Lines that are
    not prefixed are part of all products.

    The command line is as follows:

    prodfilt <input file> <output file> +tag

    For example,

    [Files]
    @w:wksprog1.exe
    @w:wksprog2.exe
    @s:srvprog1.exe
    @s:srvprog2.exe
    comprog1.exe
    @@:comprog2.exe


    The files wksprog1.exe and wksprog2.exe are part of product w
    and the files srvprog1.exe and srvprog2.exe are part of product s.
    Comprpg1.exe and comprog2.exe are part of both products.

    Specifying +w on the command line produces

    [Files]
    wksprog1.exe
    wksprog2.exe
    comprog1.ee
    comprog2.exe

    in the output.
*/


#include <windows.h>
#include <stdio.h>
#include <tchar.h>

//
// Define program result codes (returned from main()).
//
#define SUCCESS 0
#define FAILURE 1

//
// Tag definitions.
//
LPCTSTR TagPrefixStr = TEXT("@");
TCHAR   TagPrefix    = TEXT('@');
TCHAR   EndTag       = TEXT(':');
TCHAR   ExcludeTag   = TEXT('!');
TCHAR   IncAllTag    = TEXT('@');
TCHAR   NoIncTag     = TEXT('*');

#define TAG_PREFIX_LENGTH       1
#define MIN_TAG_LEN             3
#define EXCLUDE_PREFIX_LENGTH   2               // ! Prefix Length (!n)

//
// Here is the translation for the character symbols used in IncludeTag
// and SynonymTag.
//
//      products:
//          @w -> wks
//          @s -> srv
//          @p -> personal (NOT professional)
//          @b -> blade server
//	    @l -> small business server
//          @e -> enterprise
//          @d -> datacenter
//
//      architectures:
//          @i -> intel (i386)
//          @n -> intel (nec98)
//          @m -> intel (ia64)
//          @a -> AMD64 (amd64)
//
//      Note that @n is a subset of @i.  If @i is specified then you also
//          get the file include for @n unless you explicitly exclude them
//          with a token like @i!n
//
//          @3 -> 32 bit  (i386+?)
//          @6 -> 64 bit  (ia64+amd64)
//
TCHAR IncludeTag[][3] =   {{ TEXT('i'), TEXT('n'), 0   },   // @i -> i or n, @i!n -> only i
                           { TEXT('s'), TEXT('e'), 0   },   // @s -> s or e, @s!e -> only s
                           { TEXT('s'), TEXT('b'), 0   },   // @s -> s or b, @s!b -> only s
                           { TEXT('s'), TEXT('d'), 0   },
                           { TEXT('s'), TEXT('l'), 0   },
			   { TEXT('e'), TEXT('d'), 0   },
                           { TEXT('w'), TEXT('p'), 0   },
                           { 0        , 0        , 0   }
                          };


TCHAR SynonymTag[][2]   = {{ TEXT('3'), TEXT('i') },
                           { TEXT('6'), TEXT('a') },
                           { TEXT('6'), TEXT('m') },
                           { 0, 0     }
                          };

LPCTSTR InName,OutName;
TCHAR Filter;

BOOL
FileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATA findData;
    HANDLE FindHandle;
    UINT OldMode;
    DWORD Error;

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFile(FileName,&findData);
    if(FindHandle == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
    } else {
        FindClose(FindHandle);
        if(FindData) {
            *FindData = findData;
        }
        Error = NO_ERROR;
    }

    SetErrorMode(OldMode);

    SetLastError(Error);
    return (Error == NO_ERROR);
}

void
StripCommentsFromLine(
    TCHAR *Line
    )
/*

Routine Description:

    Strips comments (; Comment) from a line respecting ; inside quotes

Arguments:

    Line - POinter to Line to process


*/
{
    PWSTR p;

    BOOL Done = FALSE, InQuotes = FALSE;

    //
    // we need to insert a  NULL at the first ';' we find,
    // thereby stripping the comments
    //

    p = Line;

    if( !p )
        return;

    while(*p && !Done){

        switch(*p){
        case TEXT(';'):
            if( !InQuotes ){
                *p=L'\r';
                *(p+1)=L'\n';
                *(p+2)=L'\0';
                Done = TRUE;
            }
            break;

        case TEXT('\"'):
            if( *(p+1) && (*(p+1) == TEXT('\"'))) // Ignore double-quoting as inside quotes
                p++;
            else
                InQuotes = !InQuotes;

        default:
            ;

        }

        p++;


    }// while

    return;

}




DWORD
MakeSurePathExists(
    IN PCTSTR FullFilespec
    )

/*++

Routine Description:

    This routine ensures that a multi-level path exists by creating individual
    levels one at a time. It is assumed that the caller will pass in a *filename*
    whose path needs to exist. Some examples:

    c:\x                        - C:\ is assumes to always exist.

    c:\x\y\z                    - Ensure that c:\x\y exists.

    \x\y\z                      - \x\y on current drive

    x\y                         - x in current directory

    d:x\y                       - d:x

    \\server\share\p\file       - \\server\share\p

Arguments:

    FullFilespec - supplies the *filename* of a file that the caller wants to
        create. This routine creates the *path* to that file, in other words,
        the final component is assumed to be a filename, and is not a
        directory name. (This routine doesn't actually create this file.)
        If this is invalid, then the results are undefined (for example,
        passing \\server\share, C:\, or C:).

Return Value:

    Win32 error code indicating outcome. If FullFilespec is invalid,
    *may* return ERROR_INVALID_NAME.

--*/

{
    TCHAR Buffer[MAX_PATH];
    PTCHAR p,q;
    BOOL Done;
    DWORD d;
    WIN32_FIND_DATA FindData;

    //
    // The first thing we do is locate and strip off the final component,
    // which is assumed to be the filename. If there are no path separator
    // chars then assume we have a filename in the current directory and
    // that we have nothing to do.
    //
    // Note that if the caller passed an invalid FullFilespec then this might
    // hose us up. For example, \\x\y will result in \\x. We rely on logic
    // in the rest of the routine to catch this.
    //
    lstrcpyn(Buffer,FullFilespec,MAX_PATH);
    if(Buffer[0] && (p = _tcsrchr(Buffer,TEXT('\\'))) && (p != Buffer)) {
        *p = 0;
    } else {
        return(NO_ERROR);
    }

    if(Buffer[0] == TEXT('\\')) {
        if(Buffer[1] == TEXT('\\')) {
            //
            // UNC. Locate the second component, which is the share name.
            // If there's no share name then the original FullFilespec
            // was invalid. Finally locate the first path-sep char in the
            // drive-relative part of the name. Note that there might not
            // be such a char (when the file is in the root). Then skip
            // the path-sep char.
            //
            if(!Buffer[2] || (Buffer[2] == TEXT('\\'))) {
                return(ERROR_INVALID_NAME);
            }
            p = _tcschr(&Buffer[3],TEXT('\\'));
            if(!p || (p[1] == 0) || (p[1] == TEXT('\\'))) {
                return(ERROR_INVALID_NAME);
            }
            if(q = _tcschr(p+2,TEXT('\\'))) {
                q++;
            } else {
                return(NO_ERROR);
            }
        } else {
            //
            // Assume it's a local root-based local path like \x\y.
            //
            q = Buffer+1;
        }
    } else {
        if(Buffer[1] == TEXT(':')) {
            //
            // Assume c:x\y or maybe c:\x\y
            //
            q = (Buffer[2] == TEXT('\\')) ? &Buffer[3] : &Buffer[2];
        } else {
            //
            // Assume path like x\y\z
            //
            q = Buffer;
        }
    }

    //
    // Ignore drive roots.
    //
    if(*q == 0) {
        return(NO_ERROR);
    }

    //
    // If it already exists do nothing.
    //
    if(FileExists(Buffer,&FindData)) {
        return((FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? NO_ERROR : ERROR_DIRECTORY);
    }

    Done = FALSE;
    do {
        //
        // Locate the next path sep char. If there is none then
        // this is the deepest level of the path.
        //
        if(p = _tcschr(q,TEXT('\\'))) {
            *p = 0;
        } else {
            Done = TRUE;
        }

        //
        // Create this portion of the path.
        //
        if(CreateDirectory(Buffer,NULL)) {
            d = NO_ERROR;
        } else {
            d = GetLastError();
            if(d == ERROR_ALREADY_EXISTS) {
                d = NO_ERROR;
            }
        }

        if(d == NO_ERROR) {
            //
            // Put back the path sep and move to the next component.
            //
            if(!Done) {
                *p = TEXT('\\');
                q = p+1;
            }
        } else {
            Done = TRUE;
        }

    } while(!Done);

    return(d);
}

BOOL
ParseArgs(
    IN  int   argc,
    IN  TCHAR *argv[],
    OUT BOOL  *Unicode,
    OUT BOOL  *StripComments
    )
{
    int argoffset = 0;
    int loopcount;

    *Unicode = FALSE;
    *StripComments = FALSE;

    if (argc == 5) {
        //
        // 1 switch possible
        //
        argoffset = 1;
        loopcount = 1;
    } else if (argc == 6) {
        //
        // 2 switches possible
        //
        argoffset = 2;
        loopcount = 2;
    } else if (argc != 4) {
        return(FALSE);
    } else {
        argoffset = 0;
    }

    if((argc == 5) || (argc == 6)) {
        int i;
        for (i=0; i< loopcount; i++) {
            if (!_tcsicmp(argv[i+1],TEXT("/u")) || !_tcsicmp(argv[i+1],TEXT("-u"))) {
                *Unicode = TRUE;
            }

            if(!_tcsicmp(argv[i+1],TEXT("/s")) || !_tcsicmp(argv[i+1],TEXT("-s"))) {
                *StripComments = TRUE;
            }
        }

    }

    InName = argv[1+argoffset];
    OutName = argv[2+argoffset];
    Filter = argv[3+argoffset][1];

    if (argv[3+argoffset][0] != TEXT('+')) {
        return(FALSE);
    }

    return(TRUE);
}


BOOL
DoTagsMatch(
    IN TCHAR LineChar,
    IN TCHAR Tag
    )
{
int     i, j;
BOOL    ReturnValue = FALSE;
BOOL    TagIsInList = FALSE;
BOOL    LineCharIsInList = FALSE;

    //
    // If they match, we're done.
    //
    if( LineChar == Tag ) {
        ReturnValue = TRUE;
    } else {

        //
        // Nope.  See if we can match a synonym tag.
        //
        i = 0;
        while( SynonymTag[i][0] ) {

            TagIsInList = FALSE;
            LineCharIsInList = FALSE;

            for( j = 0; j < 2; j++ ) {
                if( Tag == SynonymTag[i][j] ) {
                    TagIsInList = TRUE;
                }

                if( LineChar == SynonymTag[i][j] ) {
                    LineCharIsInList = TRUE;
                }
            }

            if( TagIsInList && LineCharIsInList ) {
                ReturnValue = TRUE;
            }

            i++;
        }
    }

    return ReturnValue;
}

BOOL
DoFilter(
    IN FILE *InputFile,
    IN FILE *OutputFile,
    IN TCHAR  Tag,
    IN BOOL UnicodeFileIO,
    IN BOOL StripComments
    )
{
    TCHAR Line[1024];
    TCHAR *OutputLine;
    BOOL  FirstLine=TRUE;
    BOOL  WriteUnicodeHeader = TRUE;

    while(!feof(InputFile)) {
        //
        // read a line of data.  if we're doing unicode IO, we just read the
        // data and use it otherwise we need to read the data and
        //
        if (UnicodeFileIO) {
            if (!fgetws(Line,sizeof(Line)/sizeof(Line[0]),InputFile)) {
                if (ferror(InputFile)) {
                    _ftprintf(stderr,TEXT("Error reading from input file\n"));
                    return(FALSE);
                } else {
                    return(TRUE);
                }
            }

            //
            // Skip byte order mark if present
            //
            if(FirstLine) {
                if(Line[0] == 0xfeff) {
                    MoveMemory(Line,Line+1,sizeof(Line)-sizeof(TCHAR));
                }
            }

        } else {
            char LineA[1024];
            if (!fgets(LineA,sizeof(LineA),InputFile)) {
                if (ferror(InputFile)) {
                    _ftprintf(stderr,TEXT("Error reading from input file\n"));
                    return(FALSE);
                } else {
                    return(TRUE);
                }
            }

            if (!MultiByteToWideChar(
                    CP_ACP,
                    MB_PRECOMPOSED,
                    LineA,
                    -1,
                    Line,
                    sizeof(Line)/sizeof(WCHAR)
                    )) {
                _ftprintf(stderr,TEXT("Error reading input file\n"));
                return(FALSE);
            }

        }

        //
        // ok, we've retreived the line.  now let's see if we want to output
        // the line.
        //
        OutputLine = Line;

        //
        // if the line is too short, then we just want to include it no matter
        // what.
        //
        if(_tcslen(Line) >= MIN_TAG_LEN) {

            int i;

            //
            // if the line starts with our tag, then we need to look further
            // to see if it should be filtered.
            //
            if(!_tcsncmp(Line,TagPrefixStr,TAG_PREFIX_LENGTH)) {

                //
                // is the symbol string an @<char>: combination?
                //
                if(Line[TAG_PREFIX_LENGTH+1] == EndTag) {

                    OutputLine = NULL;

                    //
                    // Do we have @@: or @<char>:, where <char> matches the tag
                    // prodfilt was invoked with?
                    //
                    if( (Line[TAG_PREFIX_LENGTH] == IncAllTag)  ||
                         DoTagsMatch(Line[TAG_PREFIX_LENGTH],Tag) ||
                         (Tag == IncAllTag &&
                         (Line[TAG_PREFIX_LENGTH] != NoIncTag)) ) {

                        //
                        // Yes.  Include this line.
                        //

                        OutputLine = Line+MIN_TAG_LEN;
                    } else {

                        //
                        // we don't have an explicit match, so let's look to
                        // see if we have a match by virtue of another tag
                        // including our tag
                        //
                        // To do this, we look at the include tag list to see
                        // if the line matches the head of an include tag
                        // entry.  If we have a match, then we check if we have
                        // a match in the specified inclusion entry for our tag
                        // (or one if it's synonyms)
                        //
                        //
                        int j;
                        i = 0;
                        while(IncludeTag[i][0] && !OutputLine) {
                            j = 1;
                            if(DoTagsMatch(Line[TAG_PREFIX_LENGTH],
                                           IncludeTag[i][0])) {
                                //
                                // we found a match at the start of an include
                                // entry.
                                //
                                while (IncludeTag[i][j]) {
                                    if (DoTagsMatch(
                                            IncludeTag[i][j],
                                            Tag)) {
                                        //
                                        // We found an included match for our
                                        // tag.  Include this line.
                                        //

                                        OutputLine = Line+MIN_TAG_LEN;
                                        break;
                                    }

                                    j++;

                                }
                            }
                            i++;
                        }
                    }

                //
                // is the line long enough to have an @<char>!<char> sequence?
                //
                } else if(_tcslen(Line) >=
                          (MIN_TAG_LEN+EXCLUDE_PREFIX_LENGTH)) {

                    //
                    // Does the line have @<char>!<char> syntax?
                    //
                    if(Line[TAG_PREFIX_LENGTH+1] == ExcludeTag) {
                        TCHAR *  tmpPtr = &Line[TAG_PREFIX_LENGTH+1];

                        OutputLine = NULL;
                        //
                        // We have @<char_a>!<char_b> syntax.  We first need to
                        // see if the line is included by virtue of <char_a>.
                        //
                        // If that succeeds, then we proceed onto reading the
                        // !<char>!<char> block, looking for another hit.
                        //

                        //
                        // do we have an explicit match?
                        //
                        if( Line[TAG_PREFIX_LENGTH] == IncAllTag ||
                            DoTagsMatch(Line[TAG_PREFIX_LENGTH],Tag) ||
                            (Tag == IncAllTag &&
                             Line[TAG_PREFIX_LENGTH] != NoIncTag) ) {

                            //
                            // Yes, we have an explicit match.  Remember this
                            // so we can parse the !<char> sequence.
                            //

                            OutputLine = Line+MIN_TAG_LEN;
                        } else {

                            //
                            // we don't have an explicit match, so let's look to
                            // see if we have a match by virtue of another tag
                            // including our tag
                            //
                            // To do this, we look at the include tag list to
                            // see if the line matches the head of an include
                            // tag entry.  If we have a match, then we check if
                            // we have a match in the specified inclusion entry
                            // for our tag (or one if it's synonyms)
                            //
                            //
                            int j;
                            i = 0;
                            while(IncludeTag[i][0] && !OutputLine) {
                                j = 1;
                                if(DoTagsMatch(Line[TAG_PREFIX_LENGTH],
                                               IncludeTag[i][0])) {
                                    //
                                    // we found a match at the start of an
                                    // include entry.
                                    //
                                    while (IncludeTag[i][j]) {
                                        if (DoTagsMatch(
                                                IncludeTag[i][j],
                                                Tag)) {
                                            //
                                            // We found an included match for
                                            // our tag.  Include this line.
                                            //

                                            OutputLine = Line+MIN_TAG_LEN;
                                            break;
                                        }

                                        j++;

                                    }
                                }
                                i++;
                            }
                        }


                        if (!OutputLine) {
                            //
                            // We didn't match teh initial @<char> sequence, so
                            // there is no need to check further.  goto the
                            // next line.
                            //
                            goto ProcessNextLine;

                        }


                        //
                        // The line has !<char>[!<char>] combination
                        // Loop through the chain of exclude chars and see if
                        // we have any hits.  if we do, then we go onto the
                        // next line.
                        //
                        while (tmpPtr[0] == ExcludeTag) {

                            //
                            // do we have an explicit match?
                            //
                            if( (tmpPtr[TAG_PREFIX_LENGTH] == IncAllTag) ||
                                DoTagsMatch(tmpPtr[TAG_PREFIX_LENGTH],Tag) ) {

                                //
                                // We have an explicit match, so we know we
                                // do not want to include this line.
                                //
                                //
                                OutputLine = NULL;
                                goto ProcessNextLine;
                            } else {

                                //
                                // we don't have an explicit match, so let's
                                // look to see if we have a match by virtue
                                // of another tag including our tag
                                //
                                // To do this, we look at the include tag list
                                // to see if the line matches the head of an
                                // include tag entry.  If we have a match, then
                                // we check if we have a match in the specified
                                // inclusion entry for our tag (or one if it's
                                // synonyms)
                                //
                                //
                                int j;
                                i = 0;
                                while(IncludeTag[i][0]) {
                                    j = 1;
                                    if(DoTagsMatch(
                                            tmpPtr[TAG_PREFIX_LENGTH],
                                            IncludeTag[i][0])) {
                                        //
                                        // we found a match at the start of an
                                        // include entry.
                                        //
                                        while (IncludeTag[i][j]) {

                                            if (DoTagsMatch(
                                                    IncludeTag[i][j],
                                                    Tag)) {
                                                //
                                                // We found an included match
                                                // for our tag, so we know we
                                                // do not want to include this
                                                // line.
                                                //

                                                OutputLine = NULL;
                                                goto ProcessNextLine;
                                            }

                                            j++;

                                        }
                                    }
                                    i++;
                                }
                            }

                            tmpPtr += 2;

                        }

                        //
                        // Done parsing the @<char>!<char>!<char>!... tokens.
                        // Look for the terminator
                        //

                        if (tmpPtr[0] != EndTag) {

                            //
                            // Malformed tokens.  Let's error on the
                            // conservative side and include the whole line.
                            //

                            OutputLine = Line;

                        } else {

                            //
                            // Didn't find any exclusions, so include the tag.
                            //

                            OutputLine = &tmpPtr[1];
                        }
                    }
                }
            }
        }

ProcessNextLine:

        //
        // write out the line if we're supposed to.  for unicode io we just
        // write the file.  for ansi i/o we have to convert back to ansi
        //
        if(OutputLine) {

            if (StripComments) {
                StripCommentsFromLine( OutputLine );
            }

            if (UnicodeFileIO) {

                if (WriteUnicodeHeader) {
                    fputwc(0xfeff,OutputFile);
                    WriteUnicodeHeader = FALSE;
                }

                if(fputws(OutputLine,OutputFile) == EOF) {
                    _ftprintf(stderr,TEXT("Error writing to output file\n"));
                    return(FALSE);
                }
            } else {
                CHAR OutputLineA[1024];

                if (!WideCharToMultiByte(
                                CP_ACP,
                                0,
                                OutputLine,
                                -1,
                                OutputLineA,
                                sizeof(OutputLineA)/sizeof(CHAR),
                                NULL,
                                NULL)) {
                    _ftprintf(
                        stderr,
                        TEXT("Error translating string for output file\n") );
                    return(FALSE);
                }

                if (!fputs(OutputLineA,OutputFile) == EOF) {
                    _ftprintf(stderr,TEXT("Error writing to output file\n"));
                    return(FALSE);
                }

            }

        }
    }

    if(ferror(InputFile)) {
        _ftprintf(stderr,TEXT("Error reading from input file\n"));
        return(FALSE);
    }

    return(TRUE);
}

int
__cdecl
_tmain(
    IN int   argc,
    IN TCHAR *argv[]
    )
{
    FILE *InputFile;
    FILE *OutputFile;
    BOOL b;
    BOOL Unicode,StripComments;

    //
    // Assume failure.
    //
    b = FALSE;

    if(ParseArgs(argc,argv,&Unicode,&StripComments)) {

        //
        // Open the files. Have to open in binary mode or else
        // CRT converts unicode text to mbcs on way in and out.
        //
        if(InputFile = _tfopen(InName,TEXT("rb"))) {

            if(MakeSurePathExists(OutName) == NO_ERROR) {

                if(OutputFile = _tfopen(OutName,TEXT("wb"))) {

                    //
                    // Do the filtering operation.
                    //
                    _ftprintf(stdout,
                              TEXT("%s: filtering %s to %s\n"),
                              argv[0],
                              InName,
                              OutName);

                    b = DoFilter(InputFile,
                                 OutputFile,
                                 Filter,
                                 Unicode,
                                 StripComments);

                    fclose(OutputFile);

                } else {
                    _ftprintf(stderr,
                              TEXT("%s: Unable to create output file %s\n"),
                              argv[0],
                              OutName);
                }

            } else {
                _ftprintf(stderr,
                          TEXT("%s: Unable to create output path %s\n"),
                          argv[0],
                          OutName);
            }

            fclose(InputFile);

        } else {
            _ftprintf(stderr,
                      TEXT("%s: Unable to open input file %s\n"),
                      argv[0],
                      InName);
        }
    } else {
        _ftprintf(stderr,
                  TEXT("Usage: %s [-u (unicode IO)] [-s (strip comments)] <input file> <output file> +<prodtag>\n"),
                  argv[0]);
    }

    return(b ? SUCCESS : FAILURE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\win4\tools\sizes\sizes.c ===
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <setupapi.h>
#include <crt\string.h>
#define PULONGLONG PDWORDLONG
#include <spapip.h>

/*
============================================================================

Compute the disk space requirements for the product.

The program runs in 2 modes:
1. Compute disk space requirements to the %windir% (run with -w)
   Computed by adding up the sizes for all files in layout.inf.  Note
   that the files should be uncompressed.

2. Compute disk space requirements for the local source (run with -l)
   Computed by adding up the sizes for all the files in dosnet.inf.  Note
   that the files should be compressed.

For each of these modes, the various size requirements for cluster size
are generated.

============================================================================
*/


//
// Initialize final space requirements.
//
ULONG   Running_RawSize = 0;
ULONG   Running_512 = 0;
ULONG   Running_1K = 0;
ULONG   Running_2K = 0;
ULONG   Running_4K = 0;
ULONG   Running_8K = 0;
ULONG   Running_16K = 0;
ULONG   Running_32K = 0;
ULONG   Running_64K = 0;
ULONG   Running_128K = 0;
ULONG   Running_256K = 0;

ULONG   LineCount = 0;
ULONG   MissedFiles = 0;

//
// This structure will be used to hold link lists
// of file names, section names, or whatever.  It's
// just a linked list of strings.
//
typedef struct _NAMES {
    struct _NAMES   *Next;
    PCWSTR          String;
} NAMES;


//
// Initialize input parameters.
//
BOOL    LocalSource = FALSE;
BOOL    Windir      = FALSE;
BOOL    Verbose     = FALSE;
PCWSTR  InfPath    = NULL;
NAMES   SectionNames;
NAMES   FilePath;
ULONG   Slop = 0;



//
// ============================================================================
//
// Add a string to the end of our NAMES linked list.
//
// ============================================================================
//
BOOL AddName(
    char *IncomingString,
    NAMES   *NamesStruct
    )
{
NAMES   *Names = NamesStruct;

    //
    // The very first entry may be free.
    //
    if( Names->String ) {
        //
        // Get to the end of the list.
        //
        while( Names->Next != NULL ) {
            Names = Names->Next;
        }

        //
        // make room for a new entry.
        //
        Names->Next = MyMalloc(sizeof(NAMES));
        if( Names->Next == NULL ) {
            printf( "AddName - Out of memory!\n" );
            return FALSE;
        }

        Names = Names->Next;
    }

    //
    // Assign
    //
    Names->Next = NULL;
    Names->String = AnsiToUnicode(IncomingString);

    return TRUE;
}

//
// ============================================================================
//
// Find out what the user wants us to do.
//
// ============================================================================
//
BOOL GetParams(
    int argc,
    char *argv[ ]
    )
{
char    *p;
int     i;


    for( i = 0; i < argc; i++ ) {
        if( *argv[i] == '-' ) {
            p = argv[i];

            //
            // local source?
            //
            if( !_strcmpi( p, "-l" ) ) {
                LocalSource = TRUE;

                if( Windir ) {
                    return FALSE;
                }
                continue;
            }

            //
            // windir?
            //
            if( !_strcmpi( p, "-w" ) ) {
                Windir = TRUE;

                if( LocalSource ) {
                    return FALSE;
                }
                continue;
            }

            //
            // Verbose?
            //
            if( !_strcmpi( p, "-v" ) ) {
                Verbose = TRUE;
                continue;
            }

            //
            // Slop (in Mbytes)?
            //
            if( !_strnicmp( p, "-slop:", 6 ) ) {
                p = p + 6;
                Slop = atoi(p);
                Slop = Slop * (1024*1024);
                continue;
            }

            //
            // Inf file?
            //
            if( !_strnicmp( p, "-inf:", 5 ) ) {
                p = p + 5;
                InfPath = AnsiToUnicode(p);
                continue;
            }

            //
            // Inf section?
            //
            if( !_strnicmp( p, "-section:", 9 ) ) {
                p = p + 9;
                if( AddName( p, &SectionNames ) ) {
                    continue;
                } else {
                    return FALSE;
                }
            }

            //
            // Files location location?
            //
            if( !_strnicmp( p, "-files:", 7 ) ) {
                p = p + 7;
                if( AddName( p, &FilePath ) ) {
                    continue;
                } else {
                    return FALSE;
                }
            }

        }
    }

    //
    // Check Params.
    //
    if( !(LocalSource || Windir) ){
        return FALSE;
    }

    if( InfPath == NULL ) {
        return FALSE;
    }

    if( SectionNames.String == NULL ) {
        return FALSE;
    }

    if( FilePath.String == NULL ) {
        return FALSE;
    }

    return TRUE;
}

//
// ============================================================================
//
// Tell the user how to use us.
//
// ============================================================================
//
void Usage( )
{
    printf( "Compute disk space requirements for files listed in an inf\n" );
    printf( "\n" );
    printf( "    -[l|w]        l indicates we're computing space requirements\n" );
    printf( "                    for the local source directory, inwhich case\n" );
    printf( "                    we'll be processing dosnet.inf and computing\n" );
    printf( "                    file sizes for compressed files.\n" );
    printf( "                  w indicates we're computing space requirements\n" );
    printf( "                    for the %windir%, inwhich case we'll be\n" );
    printf( "                    processing layout.inf and computing file\n" );
    printf( "                    sizes for uncompressed files.\n" );
    printf( "\n" );
    printf( "    -v            Execute in Verbose mode.\n" );
    printf( "\n" );
    printf( "    -slop:<num>   This is the error (in Mb) that should be added onto\n" );
    printf( "                  the final disk space requirements.\n" );
    printf( "\n" );
    printf( "    -inf:<path>   This is the path to the inf (including the\n" );
    printf( "                  inf file name).  E.g. -inf:c:\\dosnet.inf\n" );
    printf( "\n" );
    printf( "    -section:<inf_section_name> This is the section name in the inf\n" );
    printf( "                  that needs to be processed.  The user may specify\n" );
    printf( "                  this parameter multiple times inorder to have multiple\n" );
    printf( "                  sections processed.\n" );
    printf( "\n" );
    printf( "    -files:<path> Path to the source files (e.g. install sharepoint or\n" );
    printf( "                  CD).  The user may specify multiple paths here, and\n" );
    printf( "                  they will be checked in the order given.\n" );
    printf( "\n" );
    printf( "\n" );
}


//
// ============================================================================
//
// Round to the nearest clustersize.
//
// ============================================================================
//
ULONG
RoundIt(
    ULONG FileSize,
    ULONG ClusterSize
    )
{

    if( FileSize <= ClusterSize ) {
        return( ClusterSize );
    } else {
        return( ClusterSize * ((FileSize / ClusterSize) + 1) );
    }
}


//
// ============================================================================
//
// Compute file sizes.  Note that we keep track of how much space
// the file will require for a variety of different clusters.
//
// ============================================================================
//
VOID
ComputeSizes(
    PCWSTR FileName,
    ULONG FileSize
    )
{
    
    Running_RawSize += FileSize;
    Running_512     += RoundIt( FileSize, 512 );
    Running_1K      += RoundIt( FileSize, (1   * 1024) );
    Running_2K      += RoundIt( FileSize, (2   * 1024) );
    Running_4K      += RoundIt( FileSize, (4   * 1024) );
    Running_8K      += RoundIt( FileSize, (8   * 1024) );
    Running_16K     += RoundIt( FileSize, (16  * 1024) );
    Running_32K     += RoundIt( FileSize, (32  * 1024) );
    Running_64K     += RoundIt( FileSize, (64  * 1024) );
    Running_128K    += RoundIt( FileSize, (128 * 1024) );
    Running_256K    += RoundIt( FileSize, (256 * 1024) );

    //
    // HACK.
    //
    // If the file is an inf, then we'll be creating an .pnf file
    // during gui-mode setup.  The .pnf file is going to take about
    // 2X the original file size, so we need to fudge this
    //
    if( wcsstr( FileName, L".inf" ) && Windir ) {
        //
        // It's an inf.  Add in size for .pnf file too.
        //
        Running_RawSize += FileSize;
        Running_512     += RoundIt( FileSize*2, 512 );
        Running_1K      += RoundIt( FileSize*2, (1   * 1024) );
        Running_2K      += RoundIt( FileSize*2, (2   * 1024) );
        Running_4K      += RoundIt( FileSize*2, (4   * 1024) );
        Running_8K      += RoundIt( FileSize*2, (8   * 1024) );
        Running_16K     += RoundIt( FileSize*2, (16  * 1024) );
        Running_32K     += RoundIt( FileSize*2, (32  * 1024) );
        Running_64K     += RoundIt( FileSize*2, (64  * 1024) );
        Running_128K    += RoundIt( FileSize*2, (128 * 1024) );
        Running_256K    += RoundIt( FileSize*2, (256 * 1024) );
    }

    if( Verbose ) {
        //
        // Print data for each file.
        //
        printf( "%15ws    %10d    %10d    %10d    %10d    %10d    %10d    %10d    %10d    %10d    %10d    %10d\n",
                FileName,
                FileSize,
                RoundIt( FileSize, 512 ),
                RoundIt( FileSize, (1   * 1024) ),
                RoundIt( FileSize, (2   * 1024) ),
                RoundIt( FileSize, (4   * 1024) ),
                RoundIt( FileSize, (8   * 1024) ),
                RoundIt( FileSize, (16  * 1024) ),
                RoundIt( FileSize, (32  * 1024) ),
                RoundIt( FileSize, (64  * 1024) ),
                RoundIt( FileSize, (128 * 1024) ),
                RoundIt( FileSize, (256 * 1024) ) );
    }

}


//
// ============================================================================
//
// Process a single section in the inf.
//
// ============================================================================
//
DoSection(
    HINF     hInputinf,
    PCWSTR   SectionName
    )
{
#define     GOT_IT() {                                                      \
                        ComputeSizes( FileName, FindData.nFileSizeLow );    \
                        FindClose( tmpHandle );                             \
                        Found = TRUE;                                       \
                     }

INFCONTEXT  InputContext;
PCWSTR      Inputval = NULL;
BOOL        Found;
NAMES       *FileLocations;
WCHAR       CompleteFilePath[MAX_PATH*2];
PCWSTR      FileName;
WCHAR       LastChar;
WIN32_FIND_DATAW FindData;
HANDLE      tmpHandle;

    if( SetupFindFirstLineW( hInputinf, SectionName, NULL, &InputContext ) ) {

        do {

            LineCount++;
            fprintf( stderr, "\b\b\b\b\b%5d", LineCount );

            //
            // Cast the return value from pSetupGetField to PCWSTR, since we're linking
            // with the UNICODE version of the Setup APIs, but this app doesn't have
            // UNICODE defined (thus the PCTSTR return value becomes a PCSTR).
            //
            // Note that if we're doing LocalSource, then we're processing
            // dosnet, which means we want the second field.  If we're doing
            // windir, then we're processing layout, which means we want the 1st
            // field.
            //
            if(FileName = (PCWSTR)pSetupGetField(&InputContext, LocalSource ? 2 : 0)) {

                //
                // We're ready to actually look for the file.
                // Look in each path specified.
                //
                Found = FALSE;
                FileLocations = &FilePath;
                while( FileLocations && !Found ) {
                    wcscpy( CompleteFilePath, FileLocations->String );
                    wcscat( CompleteFilePath, L"\\" );
                    wcscat( CompleteFilePath, FileName );

                    //
                    // Try compressed name first.
                    //
                    LastChar = CompleteFilePath[lstrlenW(CompleteFilePath)-1];
                    CompleteFilePath[lstrlenW(CompleteFilePath)-1] = L'_';

                    tmpHandle = FindFirstFileW(CompleteFilePath, &FindData);
                    if( tmpHandle != INVALID_HANDLE_VALUE ) {

                        GOT_IT();
                    } else {
                        //
                        // We missed.  Try the uncompressed name.
                        //
                        CompleteFilePath[wcslen(CompleteFilePath)-1] = LastChar;
                        tmpHandle = FindFirstFileW(CompleteFilePath, &FindData);
                        if( tmpHandle != INVALID_HANDLE_VALUE ) {

                            GOT_IT();
                        } else {
                            //
                            // Missed again.  This may be a file with a funky
                            // extension (not 8.3).
                            //

                            //
                            // Try and find entries that are of the form
                            // 8.<less-than-3>
                            //
                            wcscat( CompleteFilePath, L"_" );
                            tmpHandle = FindFirstFileW(CompleteFilePath, &FindData);
                            if( tmpHandle != INVALID_HANDLE_VALUE ) {

                                GOT_IT();
                            } else {
                                //
                                // Try and find entries with no extension.
                                //
                                CompleteFilePath[wcslen(CompleteFilePath)-1] = 0;
                                wcscat( CompleteFilePath, L"._" );
                                tmpHandle = FindFirstFileW(CompleteFilePath, &FindData);
                                if( tmpHandle != INVALID_HANDLE_VALUE ) {

                                    GOT_IT();
                                } else {
                                    //
                                    // Give up...
                                    //
                                }
                            }                        
                        }
                    }

                    if( Verbose ) {
                        if( Found ) {
                            printf( "Processed file: %ws\n", CompleteFilePath );
                        } else {
                            printf( "Couldn't find %ws in path %s\n", FileName, FileLocations->String );
                        }
                    }

                    FileLocations = FileLocations->Next;

                } // while( FileLocations && !Found )

                if( Found == FALSE ) {
                    //
                    // We missed the file!  Error.
                    //
                    printf( " ERROR: Couldn't find %ws\n", FileName );
                    MissedFiles++;
                }

            }

        } while( SetupFindNextLine(&InputContext, &InputContext) );

    } else {
        fprintf(stderr,"Section %ws is empty or missing\n", SectionName);
        return(FALSE);
    }

    return(TRUE);





}


int
__cdecl
main( int argc, char *argv[ ], char *envp[ ] )
{
NAMES   *Sections = &SectionNames;
char    *char_ptr;
HINF    hInputinf;
ULONG   i;

    //
    // Check Params.
    //
    if( !GetParams( argc, argv ) ) {
        Usage();
        return 1;
    }

    LineCount = 0;
    fprintf( stderr, "Files processed:      " );

    //
    // Open the inf file.
    //
    hInputinf = SetupOpenInfFileW( InfPath, NULL, INF_STYLE_WIN4, NULL );
    if( hInputinf == INVALID_HANDLE_VALUE ) {
        printf( "The file %s was not opened!\n", InfPath );
        return 1;
    }

    //
    // For each section the user specified...
    //
    while( Sections ) {



        DoSection( hInputinf, Sections->String );

        //
        // Now process the next section.
        //
        Sections = Sections->Next;

    }

    SetupCloseInfFile( hInputinf );


    

    //
    // Print totals.
    //
    printf( "\n\n==================================================\n\n" );
    printf( "%d files processed\n", LineCount );
    if( MissedFiles > 0 ) {
        printf( "%d files were not found\n", MissedFiles );
    }

    if( LocalSource ) {
        char_ptr = "TempDirSpace";

        //
        // TempDirSpace is given in bytes.
        //
        i = 1;
    } else {
        char_ptr = "WinDirSpace";

        //
        // WinDir space is given in KBytes.
        //
        i = 1024;
    }

    printf( "Raw size: %12d\n", Running_RawSize+Slop );
    printf( "%s512  = %12d\n", char_ptr, (Running_512+Slop)/i );
    printf( "%s1K   = %12d\n", char_ptr, (Running_1K+Slop)/i );
    printf( "%s2K   = %12d\n", char_ptr, (Running_2K+Slop)/i );
    printf( "%s4K   = %12d\n", char_ptr, (Running_4K+Slop)/i );
    printf( "%s8K   = %12d\n", char_ptr, (Running_8K+Slop)/i );
    printf( "%s16K  = %12d\n", char_ptr, (Running_16K+Slop)/i );
    printf( "%s32K  = %12d\n", char_ptr, (Running_32K+Slop)/i );
    printf( "%s64K  = %12d\n", char_ptr, (Running_64K+Slop)/i );
    printf( "%s128K = %12d\n", char_ptr, (Running_128K+Slop)/i );
    printf( "%s256K = %12d\n", char_ptr, (Running_256K+Slop)/i );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\win4\tools\unitext\makefile.inc ===
$(O)\unitext.res: utmsgs.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\win4\tools\stampinf\stampinf.h ===
typedef struct _DRIVER_VER_DATA {

    char InfName[MAX_PATH];
    char SectionName[64];
    char DateString[11];
    char VersionString[20];
    int  RawVersion [4];    

}DRIVER_VER_DATA, *PDRIVER_VER_DATA;

BOOLEAN GetArgs (int argc, char **argv);

BOOLEAN ValidateDate (char *datestring);

BOOLEAN StampInf (VOID);

VOID DisplayHelp (VOID);

BOOLEAN ProcessNtVerP (char *VersionString);

typedef enum _ARGTYPE {
    
    ArgSwitch,
    ArgFileName,
    ArgDate,
    ArgVersion,
    ArgSection    

} ARGTYPE;

#define FOUND_NOTHING 0
#define FOUND_SECTION 1 
#define FOUND_ENTRY 2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\win4\tools\stampinf\stampinf.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "stampinf.h"

DRIVER_VER_DATA dvdata;
BOOLEAN HaveDate = FALSE;
BOOLEAN HaveVersion = FALSE;

int _cdecl main (int argc, char **argv)
{

    char *StampInfEnv;
    //
    // Zero out our main data structure
    //

    ZeroMemory (&dvdata, sizeof (DRIVER_VER_DATA));

    //
    // Process and validate the arguments
    //

    lstrcpy (dvdata.SectionName, "Version");

    if (StampInfEnv = getenv("STAMPINF_DATE")) {
        if (ValidateDate (StampInfEnv)) {
            lstrcpy (dvdata.DateString, StampInfEnv);
            HaveDate = TRUE;
        }
        else printf ("Date error\n");
    }

    if (StampInfEnv = getenv("STAMPINF_VERSION")) {
        lstrcpyn (dvdata.VersionString, StampInfEnv, 20);
        HaveVersion = TRUE;
    }

    if (!GetArgs (argc, argv)) {
        DisplayHelp ();
        return 1;
    }

    //
    // Write the DriverVer key to the inf
    //

    if (!StampInf ()) {
        printf ("Error writing to inf!\n");
        return 1;
    }

    return 0;
}

BOOLEAN GetArgs (int argc, char **argv)
{
    int args;
    char *arg;
    ARGTYPE argtype = ArgSwitch;


    //
    // Loop through the arguments, the filename is required
    // but version and date are optional.
    //


    for (args = 1; args < argc; args++) {

        arg = argv[args];


        //
        // switch based on the type of argument
        // we are expecting.
        //

        switch (argtype) {
            case ArgSwitch:

                //
                // better be a switch prefix
                //

                if (*arg != '-') return FALSE;
                else arg++;

                switch (toupper(*arg)) {

                    case 'F':
                        argtype = ArgFileName;
                        break;

                    case 'D':
                        argtype = ArgDate;
                        break;

                    case 'V':
                        argtype = ArgVersion;
                        break;

                    case 'S':
                        argtype = ArgSection;
                        break;

                    default:
                        printf ("Invalid argument %s\n", arg);
                }
                break;

            case ArgFileName:

                //
                // See if the provided filename includes any
                // path separators.  If it doesn't prepend .\
                // because the WritePrivateProfile api
                // defaults to the Windows dir unless
                // you specify a path.
                //

                if (strchr (arg, '\\') == NULL) {
                    lstrcpy (dvdata.InfName, ".\\");
                }

                //
                // concatenate the actual file name
                //

                lstrcat (dvdata.InfName, arg);
                argtype = ArgSwitch;
                break;

            case ArgDate:

                //
                // If the user specified a date, do some basic validation.
                //

                if (ValidateDate (arg)) {
                    lstrcpy (dvdata.DateString, arg);
                    HaveDate = TRUE;
                }
                else printf ("Date error\n");
                argtype = ArgSwitch;

                break;

            case ArgVersion:

                //
                // If the user specified a version override, use it.
                //

                lstrcpyn (dvdata.VersionString, arg, 20);
                argtype = ArgSwitch;
                HaveVersion = TRUE;
                break;

            case ArgSection:

                lstrcpyn (dvdata.SectionName, arg, 64);
                argtype = ArgSwitch;
                break;
        }
    }

    if (!HaveDate) {

        //
        // Get the date in xx/yy/zzzz format.
        //

        GetDateFormat (LOCALE_SYSTEM_DEFAULT, 0, NULL, "MM'/'dd'/'yyyy", dvdata.DateString, 11);
    }

    if (!HaveVersion) {

        //
        // If the user didn't provide a version override, then open and read
        // ntverp.h and figure out what the version stamp should be.
        //

        if (!ProcessNtVerP (dvdata.VersionString)) {
            return FALSE;
        }
    }

    //
    // Must have a name.
    //

    return (dvdata.InfName[0] != '\0');
}

BOOLEAN ValidateDate (char *datestring)
{
    ULONG Month, Day, Year;

    if (lstrlen (datestring) != 10) return FALSE;

    Month = atoi(&datestring[0]);

    if (Month < 1 || Month > 12) return FALSE;

    Day = atoi (&datestring[3]);

    if (Day < 1 || Day > 31) return FALSE;

    Year = atoi (&datestring[6]);

    if (Year < 1980 || Year > 2099) return FALSE;

    return TRUE;
}

ULONG GetLengthOfLine (WCHAR *Pos, WCHAR *LastChar)
{
    ULONG Length=0;

    if (Pos == NULL) return 0;

    while ( (Pos < LastChar) && (*Pos != 0x00D) ) {
        Pos++;
        Length++;
    }

    if (Pos < LastChar) Length+=2;

    return Length;
}

WCHAR *GetNextLine (WCHAR *CurPos, WCHAR *LastChar)
{
    LastChar--;

    for (;CurPos < LastChar;CurPos++) {
        if ( (CurPos[0] == 0x00D) && (CurPos[1] == 0x00A) ) break;
    }

    return ( (&(CurPos[2]) <= LastChar) ? &(CurPos[2]) : NULL );
}

BOOLEAN DoesLineMatch (WCHAR *Target, WCHAR *Sample, WCHAR *LastChar)
{
    USHORT LineLength = 0;
    WCHAR *Pos = Sample;
    WCHAR *buffer;
    BOOLEAN result;
    ULONG TargetLength;

    if (Pos == NULL) return FALSE;

    while ( (Pos <= LastChar) && (*Pos != 0x00D) ) {
        LineLength++;
        Pos++;
    }

    TargetLength = lstrlenW (Target);

    if (TargetLength > LineLength) {
        return FALSE;
    }

    return (BOOLEAN)(!memcmp (Target, Sample, TargetLength));
}

USHORT FindEntry (WCHAR *FileStart, WCHAR *FileEnd, WCHAR *SectionNameW, WCHAR **Entry)
{
    WCHAR *FilePos=FileStart;
    WCHAR FixedSectionNameW[64+2];
    BOOLEAN FoundMatch = FALSE;
    ULONG iter = 0;

    wsprintfW (FixedSectionNameW, L"[%s]", SectionNameW);

    for (FilePos = FileStart; FilePos; FilePos = GetNextLine (FilePos, FileEnd)) {

        if (DoesLineMatch (FixedSectionNameW, FilePos, FileEnd)) {
            FoundMatch = TRUE;
            break;
        }
    }

    if (FoundMatch) {

        FoundMatch = FALSE;

        while ( ((FilePos = GetNextLine (FilePos, FileEnd)) != NULL) && (*FilePos != L'[') ) {

            if (DoesLineMatch (L"DriverVer", FilePos, FileEnd)) {
                FoundMatch = TRUE;
                break;
            }
        }
        if (FoundMatch) {
            *Entry = FilePos;
            return FOUND_ENTRY;
        }
        if (FilePos) {
            *Entry = FilePos;
            return FOUND_SECTION;
        }
    }

    *Entry = NULL;
    return FOUND_NOTHING;
}


UINT UniWPPS (char *SectionName, char *Stamp, char *InfName)
{
    WCHAR SectionNameW [64];
    WCHAR *NextLinePtr;
    WCHAR NewEntryW [64];
    WCHAR StampW [32];
    WCHAR InfNameW [MAX_PATH];
    HANDLE hFile, hMapping;
    WCHAR *MappedBuffer;
    ULONG filesize;
    WCHAR *LastChar;
    WCHAR *Entry = NULL;
    ULONG result;
    ULONG StampLength;
    ULONG numwritten;
    ULONG deleted;

    MultiByteToWideChar (CP_ACP,
                         MB_PRECOMPOSED,
                         SectionName,
                         (int)-1,
                         SectionNameW,
                         64);

    MultiByteToWideChar (CP_ACP,
                         MB_PRECOMPOSED,
                         Stamp,
                         (int)-1,
                         StampW,
                         32);

    MultiByteToWideChar (CP_ACP,
                         MB_PRECOMPOSED,
                         InfName,
                         (int)-1,
                         InfNameW,
                         MAX_PATH);

    StampLength = lstrlenW (StampW);

    hFile = CreateFile (InfName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        printf ("Create file failed!\n");
        return 0;
    }

    filesize = GetFileSize (hFile, NULL);

    hMapping = CreateFileMapping (hFile, NULL, PAGE_READWRITE, 0, filesize+128, NULL);

    if (!hMapping) {
        printf ("Map file failed!\n");
        CloseHandle (hFile);
        return 0;
    }

    MappedBuffer = MapViewOfFile (hMapping, FILE_MAP_ALL_ACCESS, 0, 0, 0);

    if (!MappedBuffer) {
        printf ("MapView Failed!\n");
        CloseHandle (hMapping);
        CloseHandle (hFile);
        return 0;
    }

    LastChar = (WCHAR *)((ULONG_PTR)MappedBuffer+filesize-sizeof(WCHAR));

    result = FindEntry (MappedBuffer, LastChar, SectionNameW, &Entry);

    wsprintfW (NewEntryW, L"DriverVer=%s\r\n",StampW);
    StampLength = lstrlenW (NewEntryW);

    switch (result) {

        case FOUND_SECTION:

            MoveMemory ((WCHAR *)((ULONG_PTR)Entry+(StampLength*sizeof(WCHAR))), Entry, (ULONG_PTR)LastChar-(ULONG_PTR)Entry+sizeof(WCHAR));
            CopyMemory (Entry, NewEntryW, StampLength*sizeof(WCHAR));
            UnmapViewOfFile (MappedBuffer);
            CloseHandle (hMapping);
            SetFilePointer (hFile, filesize+StampLength*sizeof(WCHAR), NULL, FILE_BEGIN);
            SetEndOfFile (hFile);
            break;

        case FOUND_ENTRY:

            deleted = GetLengthOfLine (Entry, LastChar);
            deleted *=sizeof(WCHAR);
            NextLinePtr = GetNextLine (Entry, LastChar);
            MoveMemory ((WCHAR *)((ULONG_PTR)Entry+(StampLength*sizeof(WCHAR))), NextLinePtr, (ULONG_PTR)LastChar-(ULONG_PTR)NextLinePtr+sizeof(WCHAR));
            CopyMemory (Entry, NewEntryW, StampLength*sizeof(WCHAR));
            UnmapViewOfFile (MappedBuffer);
            CloseHandle (hMapping);
            SetFilePointer (hFile, filesize+StampLength*sizeof(WCHAR)-deleted, NULL, FILE_BEGIN);
            SetEndOfFile (hFile);
            break;

        case FOUND_NOTHING:

            UnmapViewOfFile (MappedBuffer);
            CloseHandle (hMapping);
            SetFilePointer (hFile, filesize, NULL, FILE_BEGIN);
            SetEndOfFile (hFile);
            break;
    }

    CloseHandle (hFile);
    return 1;
}

BOOLEAN IsInfUnicode (VOID)
{
    HANDLE hFile, hMapping;
    char *MappedBuffer;
    ULONG filesize;
    BOOLEAN unicode = FALSE;

    hFile = CreateFile (dvdata.InfName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        printf ("Create file failed!\n");
        return FALSE;
    }

    hMapping = CreateFileMapping (hFile, NULL, PAGE_READONLY, 0, 0, NULL);

    if (!hMapping) {
        printf ("Map file failed!\n");
        CloseHandle (hFile);
        return FALSE;
    }

    MappedBuffer = MapViewOfFile (hMapping, FILE_MAP_READ, 0, 0, 0);

    if (!MappedBuffer) {
        printf ("MapView Failed!\n");
        CloseHandle (hMapping);
        CloseHandle (hFile);
        return FALSE;
    }

    filesize = GetFileSize (hFile, NULL);

    if (filesize < sizeof (WCHAR)) return 0;

    if ( *((WCHAR *)MappedBuffer) == 0xFEFF ) {
        unicode = TRUE;
    }
    if ( IsTextUnicode (MappedBuffer, filesize, NULL) ) {
        unicode = TRUE;
    }


    UnmapViewOfFile (MappedBuffer);
    CloseHandle (hMapping);
    CloseHandle (hFile);

    return unicode;
}

BOOLEAN StampInf (VOID)
{

    char DateVerStamp[32];

    wsprintf (DateVerStamp, "%s,%s",dvdata.DateString,dvdata.VersionString);

    printf ("Stamping %s [%s] section with DriverVer=%s\n",dvdata.InfName, dvdata.SectionName, DateVerStamp);

    //
    // Let WritePrivateProfile do all of our work!
    //

    if (IsInfUnicode()) {

        printf ("Unicode Inf Detected\n");

        if (UniWPPS (dvdata.SectionName, DateVerStamp, dvdata.InfName) == 0) {
            printf ("Error\n");
            return FALSE;
        }

    }
    else {

        if (WritePrivateProfileString (dvdata.SectionName, "DriverVer", DateVerStamp, dvdata.InfName) == 0) {
            printf ("Error\n");
            return FALSE;
        }
    }

    return TRUE;

}

VOID DisplayHelp (VOID)
{
    printf ("\tUSAGE:\n");
    printf ("\tstampinf -f filename [-s section] [-d xx/yy/zzzz] [-v w.x.y.z]\n");
}

DWORD NextInterestingCharacter (DWORD CurFilePos, DWORD Size, char *MappedBuffer)
{
    char thischar;
    DWORD NewPos;

    //
    // Find the next character that is not whitespace, EOL, or within a comment block.
    // Return the offset into the buffer for that character, or Size if there is no
    // such character.
    //

    while (CurFilePos < Size) {

        thischar = MappedBuffer[CurFilePos];

        if ( (thischar == 0x0A) || (thischar == 0x0D) || (thischar == ' ') ) {
            CurFilePos++;
            continue;
        }

        if (CurFilePos == Size-1)
	    break;
        if ( (thischar == '/') && (MappedBuffer[CurFilePos+1] == '*') ) {


            //
            // Skip past the comment char's and search for the end of the comment block
            //


            NewPos = CurFilePos+2;
            while (NewPos < (Size-1)) {

                if ( (MappedBuffer[NewPos] == '*') && (MappedBuffer[NewPos+1] == '/') ) {

                    CurFilePos = NewPos+1;
                    break;
                }
                NewPos++;
            }
        }
        else if ( (thischar == '/') && (MappedBuffer[CurFilePos+1] == '/') ) {

	    // Search for newline or EOF

	    CurFilePos += 2;
            while (CurFilePos < (Size-1)) {
	        if ( (MappedBuffer[CurFilePos] == 0x0A) || (MappedBuffer[CurFilePos] == 0x0D)) {
                    break;
                }
                CurFilePos++;
            }
        }
        else {
            break;
        }
        CurFilePos++;
    }

    return CurFilePos;
}

DWORD FindLengthOfInterestingCharacters (DWORD CurFilePos, DWORD Size, char *MappedBuffer)
{
    DWORD Pos = CurFilePos;
    char thischar;

    //
    // Find the length of a string.  Return the length.
    //

    while (Pos < Size) {

        thischar = MappedBuffer[Pos];

        if ( (thischar == 0x0A) || (thischar == 0x0D) || (thischar == ' ') || (thischar == '/') ) {
            return (Pos-CurFilePos);
        }

        Pos++;

    }
    printf ("How did we get here?\n");
    return 0;
}

BOOLEAN ProcessNtVerP (char *VersionString)
{
    HANDLE hFile, hMapping;
    char *MappedBuffer, *location;
    DWORD pos;
    DWORD qfelen,buildlen,majorverlen,minorverlen;
    char qfe[5]={'0','0','0','0',0};
    char build[5]={'0','0','0','0',0};
    char majorversion[5]={'0','0','0','0',0};
    char minorversion[5]={'0','0','0','0',0};
    DWORD filesize;
    char *p;
    TCHAR ntroot[MAX_PATH];

    if ( GetEnvironmentVariable ("_NTDRIVE", ntroot, 3) == 0 ) {
        printf ("Unable to evaluate _NTDRIVE!\n");
        return FALSE;
    }

    if ( GetEnvironmentVariable ("_NTROOT", &(ntroot[2]), MAX_PATH-2) == 0 ) {
        printf ("Unable to evaluate _NTROOT!\n");
        return FALSE;
    }

    lstrcat (ntroot, "\\public\\sdk\\inc\\ntverp.h");

    printf ("Using version information from %s\n",ntroot);

    //
    // Create a memory mapped image of ntverp.h
    //

    hFile = CreateFile (ntroot, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        printf ("Create file failed!\n");
        return FALSE;
    }

    filesize = GetFileSize (hFile, NULL);
    hMapping = CreateFileMapping (hFile, NULL, PAGE_READONLY, 0, 0, NULL);

    if (!hMapping) {
        printf ("Map file failed!\n");
        CloseHandle (hFile);
        return FALSE;
    }

    MappedBuffer = MapViewOfFile (hMapping, FILE_MAP_READ, 0, 0, 0);

    if (!MappedBuffer) {
        printf ("MapView Failed!\n");
        CloseHandle (hMapping);
        CloseHandle (hFile);
        return FALSE;
    }

    //
    // The version is made up of a.b.c.d where a.b is the Product Version.
    // c is the Build and d is the QFE level.  (e.g. 5.0.1922.1)
    //

    location = strstr (MappedBuffer, "#define VER_PRODUCTMAJORVERSION ");
    pos = NextInterestingCharacter ((DWORD)(location-MappedBuffer+32), filesize, MappedBuffer);
    majorverlen = FindLengthOfInterestingCharacters (pos, filesize, MappedBuffer);
    lstrcpyn (majorversion, &(MappedBuffer[pos]), majorverlen+1);

    location = strstr (MappedBuffer, "#define VER_PRODUCTMINORVERSION ");
    pos = NextInterestingCharacter ((DWORD)(location-MappedBuffer+32), filesize, MappedBuffer);
    minorverlen = FindLengthOfInterestingCharacters (pos, filesize, MappedBuffer);
    lstrcpyn (minorversion, &(MappedBuffer[pos]), minorverlen+1);

    location = strstr (MappedBuffer, "#define VER_PRODUCTBUILD ");
    pos = NextInterestingCharacter ((DWORD)(location-MappedBuffer+25), filesize, MappedBuffer);
    buildlen = FindLengthOfInterestingCharacters (pos, filesize, MappedBuffer);
    lstrcpyn (build, &(MappedBuffer[pos]), buildlen+1);

    location = strstr (MappedBuffer, "#define VER_PRODUCTBUILD_QFE ");
    pos = NextInterestingCharacter ((DWORD)(location-MappedBuffer+29), filesize, MappedBuffer);
    qfelen = FindLengthOfInterestingCharacters (pos, filesize, MappedBuffer);
    lstrcpyn (qfe, &(MappedBuffer[pos]), qfelen+1);

    wsprintf (VersionString, "%s.%s.%s.%s",majorversion, minorversion, build, qfe);

    UnmapViewOfFile (MappedBuffer);
    CloseHandle (hMapping);
    CloseHandle (hFile);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\win4\tools\unitext\unitext.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    Unitext.c

Abstract:

    Main module for unicode <--> ansi/oem text file translator.

    This program converts files between unicode and multibyte
    character sets (ansi or oem).  Usage is a follows:

    unitext [-m|-u] [-o|-a|-<nnn>] [-z] <src_file> <dst_file>

Author:

    Ted Miller (tedm) 16-June-1993

Revision History:

--*/

#include "unitext.h"
#include <wchar.h>


//
// Globals and prototypes for use within this module.
//

//
// Unicode argc/argv.
//
int     _argcW;
PWCHAR *_argvW;

//
// Codepage for multibyte file.
//
DWORD CodePage = (DWORD)(-1);

//
// File handles.
//
HANDLE SourceFileHandle,TargetFileHandle;

//
// Size of source file.
//
DWORD SourceFileSize;

//
// Type of the multibyte file (source or destination).
//
DWORD MultibyteType = TFILE_NONE;

//
// Conversion type.
//
DWORD ConversionType = CONVERT_NONE;
DWORD ConversionOption = CHECK_NONE;
DWORD ConversionCheck = CHECK_NONE;

//
// Filenames.
//
LPWSTR SourceFilename = NULL,
       TargetFilename = NULL;






BOOL
_ParseCommandLineArgs(
    VOID
    );

VOID
_CheckFilesAndOpen(
    VOID
    );


VOID
__cdecl
main(
    VOID
    )
{
    //
    // Get command line arguments.
    //
    if(!InitializeUnicodeArguments(&_argcW,&_argvW)) {
        ErrorAbort(MSG_INSUFFICIENT_MEMORY);
    }

    //
    // Parse command line arguments.
    //
    if(!_ParseCommandLineArgs()) {
        ErrorAbort(MSG_USAGE);
    }

    //
    // Check source and destination files.
    //
    _CheckFilesAndOpen();


    //
    // Perform conversion.
    //
    switch(ConversionType) {

    case MB_TO_UNICODE:

        MultibyteTextFileToUnicode(
            SourceFilename,
            TargetFilename,
            SourceFileHandle,
            TargetFileHandle,
            SourceFileSize,
            CodePage
            );

        break;

    case UNICODE_TO_MB:

        UnicodeTextFileToMultibyte(
            SourceFilename,
            TargetFilename,
            SourceFileHandle,
            TargetFileHandle,
            SourceFileSize,
            CodePage
            );

        break;
    }

    CloseHandle(SourceFileHandle);
    CloseHandle(TargetFileHandle);

    //
    // Clean up and exit.
    //
    FreeUnicodeArguments(_argcW,_argvW);
}




BOOL
_ParseCommandLineArgs(
    VOID
    )

/*++

Routine Description:

    Parse command line arguments.

Arguments:

    None.  Uses globals _argcW and _argvW.

Return Value:

    FALSE if invalid arguments specified.

--*/

{
    int     argc;
    PWCHAR *argv;
    PWCHAR arg;


    //
    // Initialize local variables.
    //
    argc = _argcW;
    argv = _argvW;

    //
    // Skip argv[0] (the program name).
    //
    if(argc) {
        argc--;
        argv++;
    }

    while(argc) {

        arg = *argv;

        if((*arg == L'-') || (*arg == L'/')) {

            switch(*(++arg)) {

            case L'a':
            case L'A':

                // if already specifed, error
                if(MultibyteType != TFILE_NONE) {
                    return(FALSE);
                }
                MultibyteType = TFILE_ANSI;
                break;

            case L'o':
            case L'O':

                // if already specifed, error
                if(MultibyteType != TFILE_NONE) {
                    return(FALSE);
                }
                MultibyteType = TFILE_OEM;
                break;

            case L'm':
            case L'M':

                if(ConversionType != CONVERT_NONE) {
                    return(FALSE);
                }

                ConversionType = MB_TO_UNICODE;
                break;

            case L'u':
            case L'U':

                if(ConversionType != CONVERT_NONE) {
                    return(FALSE);
                }

                ConversionType = UNICODE_TO_MB;
                break;
	
            case L'z':
            case L'Z':
        
	        if(ConversionCheck != CHECK_NONE) {
                    return(FALSE);
                }

                ConversionCheck = CHECK_CONVERSION;
                break;

            default:

                if(iswdigit(*arg)) {

                    if((CodePage != (DWORD)(-1)) || (MultibyteType != TFILE_NONE)) {
                        return(FALSE);
                    }

                    swscanf(arg,L"%u",&CodePage);

                    MultibyteType = TFILE_USERCP;

                } else {

                    return(FALSE);
                }

                break;
            }

        } else {

            if(SourceFilename == NULL) {

                SourceFilename = arg;

            } else if(TargetFilename == NULL) {

                TargetFilename = arg;

            } else {

                return(FALSE);
            }

        }

        argv++;
        argc--;
    }

    //
    // Must have source, destination filenames.
    //
    if(!SourceFilename || !TargetFilename) {
        return(FALSE);
    }

    return(TRUE);
}




VOID
_CheckFilesAndOpen(
    VOID
    )

/*++

Routine Description:

    Open the source and destination files, and try to make a guess
    about the type of the source file.  If we think the source file is
    a different type than the user specified, print a warning.

    Also check the codepage given by the user.

Arguments:

    None.

Return Value:

    None.  Does not return if a serious error occurs.

--*/

{
    DWORD SourceFileType;
    UCHAR FirstPartOfSource[256];
    DWORD ReadSize;

    //
    // Determine and check codepage.  Default to oem.
    //
    switch(MultibyteType) {
    case TFILE_ANSI:
        CodePage = GetACP();
    case TFILE_USERCP:
        break;
    default:                    // oem or none.
        CodePage = GetOEMCP();
        break;
    }

    if(!IsValidCodePage(CodePage)) {
        ErrorAbort(MSG_BAD_CODEPAGE,CodePage);
    }

    //
    // Try to open the source file.
    //
    SourceFileHandle = CreateFileW(
                            SourceFilename,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL
                            );


    if(SourceFileHandle == INVALID_HANDLE_VALUE) {
        ErrorAbort(MSG_CANT_OPEN_SOURCE,SourceFilename,GetLastError());
    }

    //
    // Attempt to determine to determine the size of the source file.
    //
    SourceFileSize = GetFileSize(SourceFileHandle,NULL);
    if(SourceFileSize == -1) {
        ErrorAbort(MSG_CANT_GET_SIZE,SourceFilename,GetLastError());
    }

    //
    // Filter out 0-length files here.
    //
    if(!SourceFileSize) {
        ErrorAbort(MSG_ZERO_LENGTH,SourceFilename);
    }

    //
    // Assume multibyte.
    //
    SourceFileType = TFILE_MULTIBYTE;

    //
    // Read first 256 bytes of file and call win32 api
    // to determine if the text is probably unicode.
    //
    ReadSize = min(SourceFileSize,256);
    MyReadFile(SourceFileHandle,FirstPartOfSource,ReadSize,SourceFilename);
    if(IsTextUnicode(FirstPartOfSource,ReadSize,NULL)) {
        SourceFileType = TFILE_UNICODE;
    }

    //
    // If the user did not specify a conversion type, set it here
    // based on the above test.
    //
    if(ConversionType == CONVERT_NONE) {

        ConversionType = (SourceFileType == TFILE_UNICODE)
                       ? UNICODE_TO_MB
                       : MB_TO_UNICODE;
    } else {

	if(ConversionCheck == CHECK_CONVERSION) {
		if(ConversionType == UNICODE_TO_MB) {
			ConversionOption = CHECK_IF_NOT_UNICODE;
		}
		else if(ConversionType == MB_TO_UNICODE) {
			ConversionOption = CHECK_ALREADY_UNICODE;
		}
		else {
			ConversionOption = CHECK_NONE;
		}
	}

	//
	// check if the file is UNICODE and we are trying to convert from MB_TO_UNICODE
	// then issue an warning and exit

     		if((ConversionType == MB_TO_UNICODE) && 
		   (SourceFileType == TFILE_UNICODE) &&
		   (ConversionOption == CHECK_ALREADY_UNICODE)) {
			CloseHandle(SourceFileHandle);
			MsgPrintfW(MSG_ERR_SRC_IS_UNICODE,SourceFilename);
			FreeUnicodeArguments(_argcW,_argvW);
			exit(0);
		}

	//
	// check if the file is not unicode and if we are trying to convert from 
	// unicode to MB, then issue an warning and exit

		if((ConversionType == UNICODE_TO_MB) && 
                  (SourceFileType != TFILE_UNICODE) &&
		  (ConversionOption == CHECK_IF_NOT_UNICODE)) {
			CloseHandle(SourceFileHandle);
			MsgPrintfW(MSG_ERR_SRC_IS_MB,SourceFilename);
	    		FreeUnicodeArguments(_argcW,_argvW);
			exit(0);
        	}
        //
        // Check to see if what we guessed is what the user asked for.
        // If not, issue a warning.
        //

        if((ConversionType == UNICODE_TO_MB) && (SourceFileType != TFILE_UNICODE)) {
            MsgPrintfW(MSG_WARN_SRC_IS_MB,SourceFilename);
        } else {
            if((ConversionType == MB_TO_UNICODE) && (SourceFileType == TFILE_UNICODE)) {
                MsgPrintfW(MSG_WARN_SRC_IS_UNICODE,SourceFilename);
            }
        }
    }

    //
    // Try to create target file.
    //
    TargetFileHandle = CreateFileW(
                            TargetFilename,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );

    if(TargetFileHandle == INVALID_HANDLE_VALUE) {
        ErrorAbort(MSG_CANT_OPEN_TARGET,TargetFilename,GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\win4\tools\unitext\utu2mb.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    Utmb2u.c

Abstract:

    Module that contains code to convert a unicode file
    to multibyte.

Author:

    Ted Miller (tedm) 17-June-1993

Revision History:

--*/

#include "unitext.h"




VOID
UnicodeTextFileToMultibyte(
    IN LPWSTR SourceFileName,
    IN LPWSTR TargetFileName,
    IN HANDLE SourceFileHandle,
    IN HANDLE TargetFileHandle,
    IN DWORD  SourceFileSize,
    IN UINT   TargetCodePage
    )

/*++

Routine Description:

    Convert an open unicode text file to a multibyte text file,
    whose characters are in a given codepage.

Arguments:

    SourceFileName - name of source (unicode) text file.

    TargetFileName - name of target (multibyte) text file.

    SourceFileHandle - win32 handle to the open source file.
        The file pointer should be fully rewound.

    TargetFileHandle - win32 handle to the open target file.
        The file pointer should be fully rewound.

    SourceFileSize - size in bytes of the source file.

    SourceCodePage - codepage for the target file.

Return Value:

    None.  Does not return if error.

--*/

{
    HANDLE SourceMapping,TargetMapping;
    LPWSTR SourceView;
    LPSTR  TargetView;
    int    BytesWritten;
    DWORD  MaxTargetSize;
    BOOL   UsedDefaultChar;

    //
    // Tell the user what we're doing.
    //
    MsgPrintfW(MSG_CONV_UNICODE_TO_MB,SourceFileName,TargetFileName,TargetCodePage);

    //
    // Create a file mapping object that maps the entire source file.
    //
    SourceMapping = CreateFileMapping(
                        SourceFileHandle,
                        NULL,
                        PAGE_READONLY,
                        0,
                        SourceFileSize,
                        NULL
                        );

    if(SourceMapping == NULL) {
        ErrorAbort(MSG_CANT_MAP_FILE,SourceFileName,GetLastError());
    }

    //
    // Calculate the maximum target file size.  This is the same as
    // source file size (instead of half its size) because there
    // could be double-byte characters in the target file.
    //
    MaxTargetSize = SourceFileSize;

    //
    // Create a file mapping object that maps the maximum size of
    // the target file.
    //
    TargetMapping = CreateFileMapping(
                        TargetFileHandle,
                        NULL,
                        PAGE_READWRITE,
                        0,
                        MaxTargetSize,
                        NULL
                        );

    if(TargetMapping == NULL) {
        CloseHandle(SourceMapping);
        ErrorAbort(MSG_CANT_MAP_FILE,TargetFileName,GetLastError());
    }


    //
    // Map views of the two files.
    //
    SourceView = MapViewOfFile(
                    SourceMapping,
                    FILE_MAP_READ,
                    0,0,
                    SourceFileSize
                    );

    if(SourceView == NULL) {
        CloseHandle(SourceMapping);
        CloseHandle(TargetMapping);
        ErrorAbort(MSG_CANT_MAP_FILE,SourceFileName,GetLastError());
    }

    TargetView = MapViewOfFile(
                    TargetMapping,
                    FILE_MAP_WRITE,
                    0,0,
                    MaxTargetSize
                    );

    if(TargetView == NULL) {
        UnmapViewOfFile(SourceView);
        CloseHandle(SourceMapping);
        CloseHandle(TargetMapping);
        ErrorAbort(MSG_CANT_MAP_FILE,TargetFileName,GetLastError());
    }

    //
    // If the first character in the source file is the byte-order mark,
    // skip over it.
    //
    if(*SourceView == BYTE_ORDER_MARK) {
        SourceView++;
        SourceFileSize -= sizeof(WCHAR);
    }

    //
    // If the first character is reversed byte-order mark, bail.
    //
    if(*SourceView == SWAPPED_BYTE_ORDER_MARK) {
        ErrorAbort(MSG_ERROR_BYTES_SWAPPED);
    }

    //
    // Do the conversion in one fell swoop.
    //
    BytesWritten = WideCharToMultiByte(
                       TargetCodePage,
                       0,
                       SourceView,
                       SourceFileSize / sizeof(WCHAR),
                       TargetView,
                       MaxTargetSize,
                       NULL,
                       &UsedDefaultChar
                       );

    //
    // Do some cleanup.
    //
    UnmapViewOfFile(SourceView);
    UnmapViewOfFile(TargetView);
    CloseHandle(SourceMapping);
    CloseHandle(TargetMapping);

    //
    // Check for error in conversion.
    //
    if(!BytesWritten) {
        ErrorAbort(MSG_CONVERT_FAILED,GetLastError());
    }

    //
    // We know how many bytes there are in the target file now,
    // so set the target file size accordingly.
    //
    if(SetFilePointer(TargetFileHandle,BytesWritten,NULL,FILE_BEGIN) != (DWORD)BytesWritten) {
        ErrorAbort(MSG_SEEK_ERROR,TargetFileName,GetLastError());
    }

    if(!SetEndOfFile(TargetFileHandle)) {
        ErrorAbort(MSG_ERROR_SET_EOF,TargetFileName,GetLastError());
    }

    MsgPrintfW(UsedDefaultChar ? MSG_USED_DEFAULT_CHAR : MSG_CONVERT_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\win4\tools\unitext\utmb2u.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    Utmb2u.c

Abstract:

    Module that contains code to convert a multibyte file
    to unicode.

Author:

    Ted Miller (tedm) 17-June-1993

Revision History:

--*/

#include "unitext.h"




VOID
MultibyteTextFileToUnicode(
    IN LPWSTR SourceFileName,
    IN LPWSTR TargetFileName,
    IN HANDLE SourceFileHandle,
    IN HANDLE TargetFileHandle,
    IN DWORD  SourceFileSize,
    IN UINT   SourceCodePage
    )

/*++

Routine Description:

    Convert an open multibyte text file to a unicode text file,
    interpreting the data in the multibyte text file as a stream
    of characters in a given codepage.

Arguments:

    SourceFileName - name of source (multibyte) text file.

    TargetFileName - name of target (unicode) text file.

    SourceFileHandle - win32 handle to the open source file.
        The file pointer should be fully rewound.

    TargetFileHandle - win32 handle to the open target file.
        The file pointer should be fully rewound.

    SourceFileSize - size in bytes of the source file.

    SourceCodePage - codepage for the source file.

Return Value:

    None.  Does not return if error.

--*/

{
    HANDLE SourceMapping,TargetMapping;
    LPSTR  SourceView;
    LPWSTR TargetView;
    int    CharsConverted;
    DWORD  MaxTargetSize;
    DWORD  EndOfFile;
    DWORD  err;

    //
    // Tell the user what we're doing.
    //
    MsgPrintfW(MSG_CONV_MB_TO_UNICODE,SourceFileName,TargetFileName,SourceCodePage);

    //
    // Create a file mapping object that maps the entire source file.
    //
    SourceMapping = CreateFileMapping(
                        SourceFileHandle,
                        NULL,
                        PAGE_READONLY,
                        0,
                        SourceFileSize,
                        NULL
                        );

    if(SourceMapping == NULL) {
        ErrorAbort(MSG_CANT_MAP_FILE,SourceFileName,GetLastError());
    }

    //
    // Calculate the maximum target file size.  This is twice the
    // source file size, plus one wchar for the byte order mark.
    // The file could be smaller if there are double-byte characters
    // in the source file.
    //
    MaxTargetSize = (SourceFileSize+1)*sizeof(WCHAR);

    //
    // Create a file mapping object that maps the maximum size of
    // the target file.
    //
    TargetMapping = CreateFileMapping(
                        TargetFileHandle,
                        NULL,
                        PAGE_READWRITE,
                        0,
                        MaxTargetSize,
                        NULL
                        );

    if(TargetMapping == NULL) {
        CloseHandle(SourceMapping);
        ErrorAbort(MSG_CANT_MAP_FILE,TargetFileName,GetLastError());
    }


    //
    // Map views of the two files.
    //
    SourceView = MapViewOfFile(
                    SourceMapping,
                    FILE_MAP_READ,
                    0,0,
                    SourceFileSize
                    );

    if(SourceView == NULL) {
        CloseHandle(SourceMapping);
        CloseHandle(TargetMapping);
        ErrorAbort(MSG_CANT_MAP_FILE,SourceFileName,GetLastError());
    }

    TargetView = MapViewOfFile(
                    TargetMapping,
                    FILE_MAP_WRITE,
                    0,0,
                    MaxTargetSize
                    );

    if(TargetView == NULL) {
        UnmapViewOfFile(SourceView);
        CloseHandle(SourceMapping);
        CloseHandle(TargetMapping);
        ErrorAbort(MSG_CANT_MAP_FILE,TargetFileName,GetLastError());
    }

    //
    // Write the byte-order mark into the target file.
    //
    *TargetView++ = BYTE_ORDER_MARK;

    //
    // Do the conversion in one fell swoop.
    //
    CharsConverted = MultiByteToWideChar(
                        SourceCodePage,
                        MB_PRECOMPOSED,
                        SourceView,
                        SourceFileSize,
                        TargetView,
                        MaxTargetSize
                        );

    if(!CharsConverted) {
        err = GetLastError();
    }

    //
    // Do some cleanup.
    //
    UnmapViewOfFile(SourceView);
    UnmapViewOfFile(TargetView);
    CloseHandle(SourceMapping);
    CloseHandle(TargetMapping);

    //
    // Check for error in conversion.
    //
    if(!CharsConverted) {
        ErrorAbort(MSG_CONVERT_FAILED,err);
    }

    //
    // We know how many characters there are in the target file now,
    // so set the target file size accordingly.
    //
    EndOfFile = (CharsConverted+1)*sizeof(WCHAR);

    if(SetFilePointer(TargetFileHandle,EndOfFile,NULL,FILE_BEGIN) != EndOfFile) {
        ErrorAbort(MSG_SEEK_ERROR,TargetFileName,GetLastError());
    }

    if(!SetEndOfFile(TargetFileHandle)) {
        ErrorAbort(MSG_ERROR_SET_EOF,TargetFileName,GetLastError());
    }

    MsgPrintfW(MSG_CONVERT_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\win4\tools\unitext\unitext.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    Unitext.h

Abstract:

    Main header file for unicode <--> ansi/oem text file translator.

Author:

    Ted Miller (tedm) 16-March-1993

Revision History:

--*/


#define UNICODE

//
// Include files
//

#include <windows.h>
#include <stdarg.h>
#include <process.h>
#include "utmsgs.h"
#include "wargs.h"



//
// Unicode byte order marks.
//
#define BYTE_ORDER_MARK         0xfeff
#define SWAPPED_BYTE_ORDER_MARK 0xfffe

//
// Define flags for a type of text file.
//
#define TFILE_NONE       0
#define TFILE_UNICODE    0x0001
#define TFILE_ANSI       0x0010
#define TFILE_OEM        0x0020
#define TFILE_USERCP     0x0040
#define TFILE_MULTIBYTE  0x00f0

//
// Define conversion types.
//
#define CONVERT_NONE    0
#define UNICODE_TO_MB   1
#define MB_TO_UNICODE   2

//
// Define conversion options
//
#define CHECK_NONE		3
#define CHECK_ALREADY_UNICODE	4
#define CHECK_IF_NOT_UNICODE	5
#define CHECK_CONVERSION	6

//
//
// Function prototypes
//

//
// From ututil.c
//
VOID
MsgPrintfW(
    IN DWORD MessageId,
    ...
    );

VOID
vMsgPrintfW(
    IN DWORD   MessageId,
    IN va_list arglist
    );

VOID
ErrorAbort(
    IN DWORD MessageId,
    ...
    );

VOID
MyReadFile(
    IN  HANDLE FileHandle,
    OUT PVOID  Buffer,
    IN  DWORD  BytesToRead,
    IN  LPWSTR Filename
    );


//
// From utmb2u.c
//
VOID
MultibyteTextFileToUnicode(
    IN LPWSTR SourceFileName,
    IN LPWSTR TargetFileName,
    IN HANDLE SourceFileHandle,
    IN HANDLE TargetFileHandle,
    IN DWORD  SourceFileSize,
    IN UINT   SourceCodePage
    );


//
// From utu2mb.c
//
VOID
UnicodeTextFileToMultibyte(
    IN LPWSTR SourceFileName,
    IN LPWSTR TargetFileName,
    IN HANDLE SourceFileHandle,
    IN HANDLE TargetFileHandle,
    IN DWORD  SourceFileSize,
    IN UINT   TargetCodePage
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\win4\tools\unitext\ututil.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    ututil.c

Abstract:

    Miscellaneous utility functions for unitext.exe.

Author:

    Ted Miller (tedm) 16-June-1993

Revision History:

--*/


#include "unitext.h"
#include <process.h>


//
//  BOOL
//  IsConsoleHandle(
//      IN HANDLE ConsoleHandle
//      );
//

#define IsConsoleHandle( h )    \
    ((( DWORD_PTR )( h )) & 1 )


VOID
MsgPrintfW(
    IN DWORD MessageId,
    ...
    )

/*++

Routine Description:

    Print a formatted message from the applications's resources.

Arguments:

    MessageId - supplies id of the message to print.

    ... - supplies arguments to be substituted in the message.

Return Value:

    None.

--*/

{
    va_list arglist;

    va_start(arglist,MessageId);
    vMsgPrintfW(MessageId,arglist);
    va_end(arglist);
}


VOID
vMsgPrintfW(
    IN DWORD   MessageId,
    IN va_list arglist
    )

/*++

Routine Description:

    Print a formatted message from the applications's resources.

Arguments:

    MessageId - supplies id of the message to print.

    arglist - supplies arguments to be substituted in the message.

Return Value:

    None.

--*/

{
    WCHAR MessageBuffer[2048];
    HANDLE StdOut;
    DWORD WrittenCount;
    DWORD CharCount;

    CharCount = FormatMessageW(
                    FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,
                    MessageId,
                    0,
                    MessageBuffer,
                    sizeof(MessageBuffer)/sizeof(MessageBuffer[0]),
                    &arglist
                    );

    if(!CharCount) {
        ErrorAbort(MSG_BAD_MSG,MessageId);
    }

    if((StdOut = GetStdHandle(STD_OUTPUT_HANDLE)) == INVALID_HANDLE_VALUE) {
        return;
    }

    //
    // If the standard output handle is a console handle, write the string.
    //

    if(IsConsoleHandle(StdOut)) {

        WriteConsoleW(
            StdOut,
            MessageBuffer,
            CharCount,
            &WrittenCount,
            NULL
            );

    } else {

        CHAR  TmpBuffer[2048];
        DWORD ByteCount;

        ByteCount = WideCharToMultiByte(
                        CP_OEMCP,
                        0,
                        MessageBuffer,
                        CharCount,
                        TmpBuffer,
                        sizeof(TmpBuffer),
                        NULL,
                        NULL
                        );

        WriteFile(
            StdOut,
            TmpBuffer,
            ByteCount,
            &WrittenCount,
            NULL
            );
    }
}




VOID
ErrorAbort(
    IN DWORD MessageId,
    ...
    )

/*++

Routine Description:

    Print a message and exit.

Arguments:

    MessageId - supplies id of the message to print.

    ... - supplies arguments to be substituted in the message.

Return Value:

    None.

--*/

{
    va_list arglist;

    va_start(arglist,MessageId);
    vMsgPrintfW(MessageId,arglist);
    va_end(arglist);

    exit(0);
}



VOID
MyReadFile(
    IN  HANDLE FileHandle,
    OUT PVOID  Buffer,
    IN  DWORD  BytesToRead,
    IN  LPWSTR Filename
    )

/*++

Routine Description:

    Read from a file and don't return if an error occurs.

Arguments:

    FileHandle - supplies handle of open file.

    Buffer - supplies buffer into which data will be read.

    BytesToRead - supplies number of bytes to read from the file.

    Filename - supplies name of file being read.

Return Value:

    None.

--*/

{
    DWORD BytesRead;
    BOOL  b;

    b = ReadFile(
            FileHandle,
            Buffer,
            BytesToRead,
            &BytesRead,
            NULL
            );

    if(!b || (BytesRead != BytesToRead)) {
        ErrorAbort(MSG_READ_ERROR,Filename,GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\win4\tools\unitext\wargs.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    wargs.c

Abstract:

    Routines to process unicode command line arguments
    into argc and argv.

Author:

    Ted Miller (tedm) 16-June-1993

Revision History:

--*/


#include <windows.h>
#include <wargs.h>
#include <wchar.h>



LPWSTR
_NextToken(
    IN OUT LPWSTR *CurrentPosition
    )

/*++

Routine Description:

    Get the next token from the command line.

Arguments:

    argcW - receives the number of arguments.

    argvW - receives pointer to array of wide char strings.

Return Value:

    TRUE if the command line was parsed and stored successfully.
    FALSE if not.

--*/

{
    BOOL InQuote;
    LPWSTR Start;
    UINT Length;
    LPWSTR p;
    LPWSTR Token;

    //
    // Skip leading whitespace.
    //
    Start = *CurrentPosition;
    while(*Start && iswspace(*Start)) {
        Start++;
    }

    //
    // If first char is a quote, skip it.
    //
    if(*Start == '\"') {
        InQuote = TRUE;
        Start++;
    } else {
        InQuote = FALSE;
    }

    //
    // Scan until we find the end of the token.
    //
    p = Start;
    while(*p) {

        if(iswspace(*p) && !InQuote) {
           break;
        }

        if((*p == '\"') && InQuote) {
            p++;
            break;
        }

        p++;
    }

    //
    // p is the first character that is not part of the token.
    //
    Length = (UINT)(p-Start);
    if(InQuote) {
        Length--;       // compensate for terminating quote.
    }

    //
    // Skip past trailing whitespace.
    //
    while(*p && iswspace(*p)) {
        p++;
    }

    //
    // Copy the token.
    //
    if(Token = LocalAlloc(LPTR,(Length+1)*sizeof(WCHAR))) {
        CopyMemory(Token,Start,Length*sizeof(WCHAR));
    }

    *CurrentPosition = p;
    return(Token);
}



BOOL
InitializeUnicodeArguments(
    OUT int     *argcW,
    OUT PWCHAR **argvW
    )

/*++

Routine Description:

    Fetch the unicode command line and process it into argc/argv-like
    global variables.

Arguments:

    argcW - receives the number of arguments.

    argvW - receives pointer to array of wide char strings.

Return Value:

    TRUE if the command line was parsed and stored successfully.
    FALSE if not.

--*/

{
    LPWSTR  CommandLine;
    LPWSTR  CurrentPosition;
    int     ArgCount;
    LPWSTR  Arg;
    PWCHAR *Args=NULL;


    CommandLine = GetCommandLineW();

    CurrentPosition=CommandLine;
    ArgCount = 0;

    while(*CurrentPosition) {

        Arg = _NextToken(&CurrentPosition);
        if(Arg) {

            if(Args) {
                Args = LocalReAlloc((HLOCAL)Args,(ArgCount+1)*sizeof(PWCHAR),LMEM_MOVEABLE);
            } else {
                Args = LocalAlloc(LPTR,sizeof(PWCHAR));
            }

            if(Args == NULL) {
                return(FALSE);
            }

            Args[ArgCount++] = Arg;

        } else {

            return(FALSE);
        }
    }

    *argcW = ArgCount;
    *argvW = Args;
    return(TRUE);
}




VOID
FreeUnicodeArguments(
    IN int     argcW,
    IN PWCHAR *argvW
    )

/*++

Routine Description:

    Free any resources used by the global unicode argc/argv.

Arguments:

    None.

Return Value:

    TRUE if the command line was parsed and stored successfully.
    The global variables argcW and argvW will be filled in.

--*/

{
    int i;

    for(i=0; i<argcW; i++) {
        if(argvW[i]) {
            LocalFree((HLOCAL)argvW[i]);
        }
    }

    LocalFree((HLOCAL)argvW);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\win4\tools\unitext\wargs.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    args.c

Abstract:

    Header file for routines to process unicode command line arguments
    into argc and argv.

Author:

    Ted Miller (tedm) 16-June-1993

Revision History:

--*/



//
// Function protypes.
//

BOOL
InitializeUnicodeArguments(
    OUT int     *argcW,
    OUT PWCHAR **argvW
    );


VOID
FreeUnicodeArguments(
    IN int     argcW,
    IN PWCHAR *argvW
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\win4\tools\wowlist\wowlist.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    wowlist.c

Abstract:

    This module implements a program that determines which files in an NT
    product INF should be installed as wow files.  It then builds a list
    of these files that can be appended to other sections in a master inf.

    The input to the program consists of a filtered NT product INF (for example
    the layout.inf for i386, all products), and a control INF that specifies
    mappings and rules about how to migrate files.

Author:

    Andrew Ritz (andrewr) 24-Nov-1999   Created It.

Revision History:
    ATM Shafiqul Khalid(askhalid) 27-April-2001
        Make changes in HandleSetupapiQuotingForString() to add double 
        quote if the string contains ','.


--*/

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <setupapi.h>
#include <sputils.h>
#include <shlwapi.h>

#if DBG

VOID
AssertFail(
    IN PSTR FileName,
    IN UINT LineNumber,
    IN PSTR Condition
    )
{
    int i;
    CHAR Name[MAX_PATH];
    PCHAR p;
    CHAR Msg[MAX_INF_STRING_LENGTH];

    //
    // Use dll name as caption
    //
    GetModuleFileNameA(NULL,Name,MAX_PATH);
    if(p = strrchr(Name,'\\')) {
        p++;
    } else {
        p = Name;
    }

    wsprintfA(
        Msg,
        "Assertion failure at line %u in file %s: %s\n\nCall DebugBreak()?",
        LineNumber,
        FileName,
        Condition
        );

    OutputDebugStringA(Msg);

    i = MessageBoxA(
                NULL,
                Msg,
                p,
                MB_YESNO | MB_TASKMODAL | MB_ICONSTOP | MB_SETFOREGROUND
                );

    if(i == IDYES) {
        DebugBreak();
    }
}

#define MYASSERT(x)     if(!(x)) { AssertFail(__FILE__,__LINE__,#x); }

#else

#define MYASSERT( exp )

#endif // DBG

//
// backward-compatible depreciated export from setupapi.dll
//

BOOL
SetupGetInfSections (
    IN  HINF        InfHandle,
    OUT PTSTR       Buffer,         OPTIONAL
    IN  UINT        Size,           OPTIONAL
    OUT UINT        *SizeNeeded     OPTIONAL
    );

//
// Define program result codes (returned from main()).
//
#define SUCCESS 0
#define FAILURE 1

typedef enum _WOWLISTACTION {
    BuildCopyList,
    BuildOLEList,
    BuildSetupINF,
    WowListMax
} WOWLISTACTION;

#define KEYWORD_COPYFILES      0x00000001
#define KEYWORD_DELFILES       0x00000002
#define KEYWORD_RENFILES       0x00000004
#define KEYWORD_REGISTERDLLS   0x00000008
#define KEYWORD_UNREGISTERDLLS 0x00000010
#define KEYWORD_ADDREG         0x00000020
#define KEYWORD_DELREG         0x00000040

#define KEYWORD_NEEDDESTDIRS   (KEYWORD_COPYFILES | KEYWORD_DELFILES | KEYWORD_RENFILES)
#define KEYWORD_NEEDLAYOUTDATA (KEYWORD_COPYFILES)
#define KEYWORD_NEEDFILENAME   (KEYWORD_COPYFILES)


PCTSTR KeywordArray[] = {
    TEXT("CopyFiles"),
    TEXT("DelFiles"),
    TEXT("RenFiles"),
    TEXT("RegisterDlls"),
    TEXT("UnRegisterDlls"),
    TEXT("AddReg"),
    TEXT("DelReg")
} ;

#define INDEX_COPYFILES        0
#define INDEX_DELFILES         1
#define INDEX_RENFILES         2
#define INDEX_REGISTERDLLS     3
#define INDEX_UNREGISTERDLLS   4
#define INDEX_ADDREG           5
#define INDEX_DELREG           6

typedef struct _PERSECTION_CONTEXT {
    //
    // remember the destinationdir that we're outputting to
    //
    DWORD DestinationDir;

    //
    // remember the keywords we're processing
    //
    DWORD KeywordVector;
} PERSECTION_CONTEXT, *PPERSECTION_CONTEXT;


typedef struct _SETUPINF_CONTEXT {
    FILE * OutFile;
    FILE * OutLayoutFile;
    FILE * OutInfLayoutFile;
    HINF hControlInf;
    HINF hInputInf;
    BOOL AlreadyOutputKeyword;
} SETUPINF_CONTEXT, *PSETUPINF_CONTEXT;

typedef struct _SUBST_STRING {
    PTSTR InputString;
    PTSTR SourceInputString;
    PTSTR OutputString;
} SUBST_STRING,*PSUBST_STRING;

//
// note that WOW64 does file system redirection of system32, but it does NOT do
// redirection of program files, etc.  So we must substitute in the 32 bit
// environment variables in those cases where WOW64 does not do it for us
// automatically
//
SUBST_STRING StringArray[] = {
    //
    // order of these 2 is important!
    //
    { NULL, TEXT("%SystemRoot%\\system32"),      TEXT("%16425%")   },
    { NULL, TEXT("%SystemRoot%"),               TEXT("%10%")   },
    //
    // order of these 2 is important!
    //
    { NULL, TEXT("%CommonProgramFiles%"),  TEXT("%16428%") },
    { NULL, TEXT("%ProgramFiles%"),        TEXT("%16426%")       },
    { NULL, TEXT("%SystemDrive%"),              TEXT("%30%")        }
} ;

PSUBST_STRING StringList;

//
// Keep statistics...
//
INT     ProcessedLines = 0;

TCHAR   InputInf[MAX_PATH];
TCHAR   ControlInf[MAX_PATH];
TCHAR   OLEInputInf[MAX_PATH];
PCTSTR  OutputFile;
PCTSTR  OutputLayoutFile = NULL;
PCTSTR  HeaderText;
PCTSTR  OLESection;
PCTSTR  FilePrefix;
PCTSTR  SectionDecoration;
PCTSTR  ThisProgramName;
WOWLISTACTION Action = WowListMax;
BOOL    fDoAnsiOutput = TRUE;
PCTSTR  OutputInfLayoutFile = NULL;

//
// a global scratch buffer for getting a decorated sectionname
//
TCHAR   DecoratedSectionName[MAX_PATH];

//
// global scratch buffer for line data
//
TCHAR LineText[MAX_INF_STRING_LENGTH];
TCHAR ScratchText[MAX_INF_STRING_LENGTH];
TCHAR ScratchTextEnv[MAX_INF_STRING_LENGTH];


PTSTR
MyGetDecoratedSectionName(
    HINF ControlInfHandle,
    PCTSTR String
    )
{
    INFCONTEXT Context;

    _tcscpy(DecoratedSectionName,String);

    if (SectionDecoration){
        _tcscat(DecoratedSectionName,TEXT("."));
        _tcscat(DecoratedSectionName,SectionDecoration);

        if( !SetupFindFirstLine(
            ControlInfHandle,
            DecoratedSectionName,
            NULL,
            &Context)){
            _tcscpy(DecoratedSectionName,String);
        }

    }
        
    return DecoratedSectionName;
    
        
}

BOOL
ParseArgs(
    IN int   argc,
    IN TCHAR *argv[]
    )
/*++

Routine Description:

    This function reads the cmdline, translating arguments into the appropriate
    global variable.

Arguments:

    argc - number of arguments from main().
    argv - argument array.

Return Value:

    Boolean value, true indicates that the cmdline arguments are valid.

--*/

{
    int i;
    PTSTR p;
    ThisProgramName = argv[0];


    if(argc < 4) {
        return(FALSE);
    }

    for (i = 0; i < argc; i++) {
        if (argv[i][0] == TEXT('-')) {
            switch (tolower(argv[i][1])) {
                case TEXT('i'):
                    GetFullPathName(argv[i+1],sizeof(InputInf)/sizeof(TCHAR),InputInf,&p);
                    break;
                case TEXT('c'):
                    GetFullPathName(argv[i+1],sizeof(ControlInf)/sizeof(TCHAR),ControlInf,&p);
                    break;
                case TEXT('l'):
                    GetFullPathName(argv[i+1],sizeof(OLEInputInf)/sizeof(TCHAR),OLEInputInf,&p);
                    break;
                case TEXT('s'):
                    OLESection = argv[i+1];
                    break;
                case TEXT('o'):
                    OutputFile = argv[i+1];
                    break;
                case TEXT('g'):
                    SectionDecoration = argv[i+1];
                    break;
                case TEXT('d'):
                    OutputLayoutFile = argv[i+1];
                    break;
                case TEXT('u'):
                    fDoAnsiOutput = FALSE;
                    break;
                case TEXT('h'):
                    HeaderText = argv[i+1];
                    break;
                case TEXT('f'):
                    FilePrefix = argv[i+1];
                    break;
                case TEXT('n'):
                    OutputInfLayoutFile = argv[i+1];
                    break;
                case TEXT('a'):
                    switch(tolower(argv[i][2])) {
                        case TEXT('c'):
                            Action = BuildCopyList;
                            break;
                        case TEXT('o'):
                            Action = BuildOLEList;
                            break;
                        case TEXT('s'):
                            Action = BuildSetupINF;
                            break;
                        default:
                            _ftprintf(stderr, TEXT("unknown arg %s\n"),argv[i]);
                            return(FALSE);
                    }
                    break;
                default:
                    _ftprintf(stderr, TEXT("unknown arg %s\n"),argv[i]);
                    return(FALSE);
            }
        }
    }

    _ftprintf(stderr, TEXT("%s\n"),InputInf);
    if (Action == WowListMax) {
        return(FALSE);
    }

    return(TRUE);
}

int
myftprintf(
    FILE * FileHandle,
    BOOL AnsiOutput,
    PCTSTR FormatString,
    ...
    )
{
    va_list arglist;
    TCHAR text[MAX_INF_STRING_LENGTH];
    DWORD d;
    int retval;



    va_start(arglist,FormatString);

    _vstprintf(text,FormatString,arglist);


#ifdef UNICODE

    if (AnsiOutput) {
        PCSTR TextA = pSetupUnicodeToAnsi(text);
        retval = fputs(TextA,FileHandle);
        pSetupFree(TextA);
    } else {
        PWSTR p,q;
        // Assume we opened the file in binary mode for Unicode stream I/O
        p = text;
        while(1){
            if( q = wcschr( p, L'\n' )){
                *q=L'\0';
                retval = fputws(p,FileHandle);
                retval = fputws(L"\r\n", FileHandle);
                if( *(q+1) )
                    p = q+1;
                else
                    break;
            }else{
                retval = fputws(p,FileHandle);
                break;
            }
        }
        
    }

#else

    if (AnsiOutput) {
        retval = fputs(text,FileHandle);
    } else{
        PCWSTR TextW = pSetupAnsiToUnicode(text);
        retval = fputws(TextW,FileHandle);
        pSetupFree(TextW);
    }

#endif


    return(retval);
}

BOOL
AppendWowFileToCopyList(
    IN HINF  hControlInf,
    IN PINFCONTEXT LineContext,
    IN FILE   *OutFile
    )
/*++

Routine Description:

    This routine appends the file specified by LineContext to the output file,
    writing the data in a form required by textmode setup.  see layout.inx for
    a detailed description of this syntax.

Arguments:

    hControlInf - inf handle that contains control directives.
    LineContext - inf context from layout.inf for the file we want to output.
    OutFile - file handle to write the data into

Return Value:

    Boolean value, true indicates the file was properly written.

--*/
{
    TCHAR LineText[MAX_INF_STRING_LENGTH];
    TCHAR FileName[40];
    BOOL RetVal;

    DWORD EntryCount,i;


    ZeroMemory(LineText,sizeof(LineText));

    if (FilePrefix) {
       _tcscpy(FileName, FilePrefix);
    } else {
       FileName[0] = (TCHAR)NULL;
    }

    //
    // get the filename
    //
    if (!SetupGetStringField(
                    LineContext,
                    0,
                    &FileName[_tcslen(FileName)],
                    (sizeof(FileName)-(_tcslen(FileName)*sizeof(TCHAR)))/sizeof(TCHAR),
                    NULL)) {
        _ftprintf(stderr, TEXT("SetupGetStringField failed, ec = 0x%08x\n"),GetLastError());
        RetVal = FALSE;
        goto exit;
    }

    EntryCount = SetupGetFieldCount(LineContext);

    for (i = 1; i<=EntryCount; i++) {
        TCHAR Entry[40];
        INFCONTEXT ControlContext;

        //
        // get the current text to be appended
        //
        if (!SetupGetStringField(LineContext,i,Entry,sizeof(Entry)/sizeof(TCHAR),NULL)) {
            _ftprintf(stderr, TEXT("SetupGetStringField [%s] failed, ec = 0x%08x\n"),FileName,GetLastError());
            RetVal = FALSE;
            goto exit;
        }

        //
        // now do any necessary substitutions
        //

        //
        // SourceDisksNames substitution
        //
        if (i == 1) {
            //
            // look in the appropriate control inf section for the data
            //
            if (!SetupFindFirstLine(
                            hControlInf,
                            TEXT("NativeDataToWowData.SourceInfo"),
                            Entry,
                            &ControlContext)) {
                _ftprintf(stderr, TEXT("SetupFindFirstLine [%s] failed, ec = 0x%08x\n"),FileName,GetLastError());
                RetVal = FALSE;
                goto exit;
            }

            if (!SetupGetStringField(&ControlContext,1,Entry,sizeof(Entry)/sizeof(TCHAR),NULL)) {
                _ftprintf(stderr, TEXT("SetupGetStringField [%s] failed, ec = 0x%08x\n"),FileName,GetLastError());
                RetVal = FALSE;
                goto exit;
            }

        }

        //
        // Directory Id substitution
        //
        if (i == 8) {
            //
            // look in the appropriate control inf section for the data
            //
            if (!SetupFindFirstLine(
                            hControlInf,
                            TEXT("NativeDataToWowData.DirectoryInformation.Textmode"),
                            Entry,
                            &ControlContext)) {
                _ftprintf(stderr, TEXT("SetupFindFirstLine [%s] failed, ec = 0x%08x\n"),FileName,GetLastError());
                RetVal = FALSE;
                goto exit;
            }

            if (!SetupGetStringField(&ControlContext,1,Entry,sizeof(Entry)/sizeof(TCHAR),NULL)) {
                _ftprintf(stderr, TEXT("SetupGetStringField [%s] failed, ec = 0x%08x\n"),FileName,GetLastError());
                RetVal = FALSE;
                goto exit;
            }

        }

        //
        // filename rename
        //
        if (i == 11) {
            //
            // if there was already a renaming to be done, then just use that.
            // otherwise we may have to add a rename entry if there was a
            // filename prefix
            //
            if (Entry[0] == (TCHAR)NULL) {
               if (FilePrefix) {
                  _tcscpy(Entry, (TCHAR *) FileName + _tcslen(FilePrefix));
               }
            }
        }

        _tcscat(LineText, Entry);

        //
        // now append a comma if necessary
        //
        if (i !=EntryCount) {
            _tcscat(LineText, TEXT(","));
        }

        //
        // filename rename
        //
        if (EntryCount < 11 && i == EntryCount) {
            //
            // if there is no renaming to be done, we may have to add a rename
            // entry if there was a filename prefix
            //
            if (FilePrefix) {
               DWORD j;
               for (j=i;j<11;j++) {
                  _tcscat(LineText, TEXT(","));
               }
               _tcscat(LineText, (TCHAR *) FileName + _tcslen(FilePrefix));
            }
        }



    }

    myftprintf(OutFile, fDoAnsiOutput, TEXT("%s=%s\n"),FileName,LineText);

    RetVal = TRUE;

exit:
    return(RetVal);
}

BOOL
AppendWowFileToOLEList(
    IN HINF  hControlInf,
    IN HINF  hOLEInputInf,
    IN PINFCONTEXT LineContext,
    IN FILE   *OutFile
    )
/*++

Routine Description:

    This routine appends the file specified by LineContext to the output file,
    writing the data in OLE Registration form.

    OLE Registration form is as follows:

    <DIRID>,<subdir>,filename,[flags]

    where <DIRID> is a standard setupapi DIRID; <subdir> is optional and
    represents a subdir of the given directory; filename is the name
    of the dll.


Arguments:

    hControlInf - inf handle that contains control directives.
    hOLEInputInf - inf handle that contains OLE list information.
    LineContext - inf context from layout.inf for the file we want to output.
    OutFile - file handle to write the data into

Return Value:

    Boolean value, true indicates the file was properly written.

--*/
{
    TCHAR LineText[MAX_INF_STRING_LENGTH];
    BOOL RetVal;
    INFCONTEXT OLEContext;

    DWORD EntryCount,i;


    ZeroMemory(LineText,sizeof(LineText));

    EntryCount = SetupGetFieldCount(LineContext);

    for (i = 1; i<=EntryCount; i++) {
        TCHAR Entry[40];
        INFCONTEXT ControlContext;

        //
        // get the current text to be appended
        //
        if (!SetupGetStringField(LineContext,i,Entry,sizeof(Entry)/sizeof(TCHAR),NULL)) {
            _ftprintf(stderr, TEXT("SetupGetStringField failed, ec = 0x%08x\n"),GetLastError());
            RetVal = FALSE;
            goto exit;
        }

        //
        // now do any necessary substitutions
        //

        //
        // DIRID substitution
        //
        if (i == 1) {
            //
            // look in the appropriate control inf section for the data
            //
            if (!SetupFindFirstLine(
                            hControlInf,
                            TEXT("NativeDataToWowData.DirectoryInformation.SetupAPI"),
                            Entry,
                            &ControlContext)) {
                _ftprintf(stderr, TEXT("SetupFindFirstLine failed, ec = 0x%08x\n"),GetLastError());
                RetVal = FALSE;
                goto exit;
            }

            if (!SetupGetStringField(&ControlContext,1,Entry,sizeof(Entry)/sizeof(TCHAR),NULL)) {
                _ftprintf(stderr, TEXT("SetupGetStringField failed, ec = 0x%08x\n"),GetLastError());
                RetVal = FALSE;
                goto exit;
            }

        }

        _tcscat(LineText, Entry);

        //
        // now append a comma if necessary
        //
        if (i !=EntryCount) {
            _tcscat(LineText, TEXT(","));
        }

    }

    myftprintf(OutFile, TRUE, TEXT("%s\n"),LineText);

    RetVal = TRUE;

exit:
    return(RetVal);
}


BOOL
IsWowFile(
    IN HINF  hControlInf,
    IN PINFCONTEXT LineContext
    )
/*++

Routine Description:

    This routine determines if the specified file is to be installed for
    as a wow file.

    This is determined by comparing directives in the control inf with
    the installation information in file inf context.


Arguments:

    hControlInf - inf handle that contains control directives.
    LineContext - inf context from layout.inf for the file we want to examine.

Return Value:

    Boolean value, true indicates the file is a wow file.

--*/
{
    BOOL RetVal = FALSE;
    TCHAR FileName[40];
    DWORD Disposition,DirectoryId;
    PTSTR p;

    INFCONTEXT ControlContext;
    TCHAR Extension[8];
    DWORD ExtensionCount,i;
    DWORD ControlDirId;

    //
    // get the filename
    //
    if (!SetupGetStringField(LineContext,0,FileName,sizeof(FileName)/sizeof(TCHAR),NULL)) {
        _ftprintf(stderr, TEXT("SetupGetStringField failed, ec = 0x%08x\n"),GetLastError());
        RetVal = FALSE;
        goto e0;
    }

    //
    // see if the file is in our "exclusion list"
    //
    if(SetupFindFirstLine(
                    hControlInf,
                    TEXT("WowData.Files.Exclude"),
                    FileName,
                    &ControlContext)) {
        _ftprintf(stderr,
                TEXT("filtering %ws because it's in our exclusion list\n"),
                FileName);
        RetVal = FALSE;
        SetLastError(ERROR_SUCCESS);
        goto e0;
    }

    //
    // see if the file is in our "inclusion list"
    //
    if(SetupFindFirstLine(
                    hControlInf,
                    TEXT("WowData.Files.Include"),
                    FileName,
                    &ControlContext)) {
        _ftprintf(stderr,
                TEXT("force inclusion of [%ws] because it's in our inclusion list\n"),
                FileName);
        RetVal = TRUE;
        SetLastError(ERROR_SUCCESS);
        goto e0;
    }

    //
    // see if the file is installed by textmode setup
    //
    if (!SetupGetIntField(LineContext,9,&Disposition)) {
        _ftprintf(stderr, TEXT("SetupGetIntField (%ws) failed, ec = 0x%08x\n"),FileName,GetLastError());
        RetVal = FALSE;
        goto e0;
    }

    if (Disposition == 3) {
        _ftprintf(stderr, TEXT("[%ws] is not an installed file\n"),FileName);
        SetLastError(ERROR_SUCCESS);
        RetVal = FALSE;
        goto e0;
    }

    //
    // get the extension of the file and compare it to the list of extensions
    // we're trolling for
    //
    p = _tcsrchr( FileName, TEXT('.') );
    if (p) {
        p+=1;
    } else {
        _ftprintf(stderr, TEXT("[%ws] does not have a file extension\n"),FileName);
        p = TEXT("");
    }



    if(!SetupFindFirstLine(
                        hControlInf,
                        TEXT("WowData.Filter"),
                        TEXT("FileExtensions"),
                        &ControlContext
                        )) {
        _ftprintf(stderr, TEXT("SetupFindFirstLine (ControlInf) failed\n"));
        RetVal = FALSE;
        goto e0;
    }

    RetVal = FALSE;
    

    do{

        ExtensionCount = SetupGetFieldCount(&ControlContext);
        //
        // this is a 1-based index
        //
        for (i = 1; i <= ExtensionCount ; i++) {
            if (SetupGetStringField(&ControlContext,i,Extension,sizeof(Extension)/sizeof(TCHAR),NULL)) {
                if (_tcsicmp(Extension,p)==0) {
                   RetVal = TRUE;
                   break;
                }
            }else{
                _ftprintf(stderr, TEXT("SetupGetStringField failed, ec = 0x%08x\n"),GetLastError());
                RetVal = FALSE;
                goto e0;

            }
        }

    }while(SetupFindNextMatchLine(&ControlContext, TEXT("FileExtensions"), &ControlContext));

    if (!RetVal) {
        _ftprintf(stderr, TEXT("%ws does not match extension list\n"),FileName);
        SetLastError(ERROR_SUCCESS);
        goto e0;
    }



    //
    // get the directory the file is installed into and see if it's in our list
    // of directories we're trolling for.
    //
    if (!SetupGetIntField(LineContext,8,&DirectoryId)) {
        _ftprintf(stderr, TEXT("SetupGetIntField (%ws) failed, ec = 0x%08x\n"),FileName,GetLastError());
        RetVal = FALSE;
        goto e0;
    }

    RetVal = FALSE;
    if(!SetupFindFirstLine(
                        hControlInf,
                        TEXT("WowData.Filter"),
                        TEXT("DirectoryToMap"),
                        &ControlContext
                        )) {
        _ftprintf(stderr, TEXT("SetupFindFirstLine failed, ec = 0x%08x\n"),GetLastError());
        RetVal = FALSE;
        goto e0;
    }

    do {

        if (!SetupGetIntField(&ControlContext,1,&ControlDirId)) {
            _ftprintf(stderr, TEXT("SetupGetIntField (\"DirectoryToMap\") (%ws) failed, ec = 0x%08x\n"),FileName,GetLastError());
            RetVal = FALSE;
            goto e0;
        }

        if (ControlDirId == DirectoryId) {
            RetVal = TRUE;
            break;
        }

    } while ( SetupFindNextMatchLine(&ControlContext,TEXT("DirectoryToMap"),&ControlContext ));

    if (!RetVal) {
        _ftprintf(stderr, TEXT("directory id %d for [%ws] is not in list\n"),DirectoryId,FileName);
        SetLastError(ERROR_SUCCESS);
        goto e0;
    }

e0:
    return(RetVal);
}

BOOL
IsWowOLEFile(
    IN HINF  hControlInf,
    IN HINF  hInputInf,
    IN PINFCONTEXT LineContext
    )
/*++

Routine Description:

    This routine determines if the specified file requires OLE self
    registration.

    This is determined by comparing directives in the control inf with
    the installation information in file inf context.


Arguments:

    hControlInf - inf handle that contains control directives.
    hInputInf   - inf handle that contains layout information.
    LineContext - inf context from syssetup.inf for the file we want to examine.

Return Value:

    Boolean value, true indicates the file is a wow file.

--*/
{
    BOOL RetVal = FALSE;
    TCHAR FileName[40];
    PTSTR p;
    TCHAR SourceArchitecture[10];
    TCHAR SourceDiskFiles[80];
    BOOL FirstTime;

    INFCONTEXT ControlContext,InfContext;
    INFCONTEXT InputContext;


    //
    // get the filename
    //
    FileName[0] = L'\0';
    if (!SetupGetStringField(LineContext,3,FileName,sizeof(FileName)/sizeof(TCHAR),NULL)) {
        _ftprintf(stderr, TEXT("SetupGetStringField [%s] failed, ec = 0x%08x\n"),FileName,GetLastError());
        RetVal = FALSE;
        goto e0;
    }


    MYASSERT(FileName[0] != (TCHAR)NULL);

    //
    // see if the file is in our "exclusion list"
    //
    if(SetupFindFirstLine(
                    hControlInf,
                    TEXT("WowData.OLEList.Exclude"),
                    FileName,
                    &ControlContext)) {
        _ftprintf(stderr,
                TEXT("filtering %ws because it's in our exclusion list\n"),
                FileName);
        SetLastError(ERROR_SUCCESS);
        RetVal = FALSE;
        goto e0;
    }

    //
    // see if the file is in our "inclusion list"
    //
    if(SetupFindFirstLine(
                    hControlInf,
                    TEXT("WowData.OLELIst.Include"),
                    FileName,
                    &ControlContext)) {
        _ftprintf(stderr,
                TEXT("force inclusion of [%ws] because it's in our inclusion list\n"),
                FileName);
        SetLastError(ERROR_SUCCESS);
        RetVal = TRUE;
        goto e0;
    }

    //
    // see if the file is in the layout file and if it is,
    // we have success
    //
    //
    // get the required architecture decoration
    //
    if (!SetupFindFirstLine(
                    hControlInf,
                    TEXT("WowData.Filter"),
                    TEXT("SourceArchitecture"),
                    &InfContext) ||
        !SetupGetStringField(
                    &InfContext,
                    1,
                    SourceArchitecture,
                    sizeof(SourceArchitecture)/sizeof(TCHAR),
                    NULL)) {
        _ftprintf(stderr,TEXT("Unable to get SourceArchitecture\n"));
        goto e0;
    }

    FirstTime = TRUE;
    _tcscpy(SourceDiskFiles, TEXT("SourceDisksFiles"));

    while (TRUE) {
        DWORD FileCount;

        if (!FirstTime) {
            _tcscat(SourceDiskFiles,TEXT("."));
            _tcscat(SourceDiskFiles,SourceArchitecture);
        }

        if(SetupFindFirstLine(
                        hInputInf,
                        SourceDiskFiles,
                        FileName,
                        &InputContext) &&
           IsWowFile(hControlInf,&InputContext)) {
            RetVal = TRUE;
            break;
        }

        if (!FirstTime) {
            RetVal = FALSE;
            break;
        }

        FirstTime = FALSE;

    }

e0:
    SetLastError(ERROR_SUCCESS);
    return(RetVal);
}



BOOL
DoCopyListSection(
    IN PCTSTR  InputSectionName,
    IN HINF    hInputInf,
    IN HINF    hControlInf,
    IN FILE   *OutFile
    )
{
    DWORD SectionCount, i;
    INFCONTEXT InputContext;
    UCHAR      line[MAX_INF_STRING_LENGTH];
    TCHAR      SourceFileName[MAX_PATH];

    if(!SetupFindFirstLine(
                        hInputInf,
                        InputSectionName,
                        NULL,
                        &InputContext)){
        _ftprintf(stderr, TEXT("%s: Warning - Section %s not present: Ignoring Section\n"), ThisProgramName, InputSectionName);
        return(TRUE);

    }

    SectionCount = SetupGetLineCount(hInputInf,InputSectionName);

    

    for (i = 0; i < SectionCount; i++) {
        if (SetupGetLineByIndex(hInputInf, InputSectionName, i, &InputContext)) {
            if (IsWowFile(hControlInf,&InputContext)) {

                AppendWowFileToCopyList(hControlInf,&InputContext, OutFile);

            } else if (GetLastError() != NO_ERROR) {
                _ftprintf(stderr, TEXT("IsWowFile failed\n"));
                return(FALSE);
            }
        } else {
            _ftprintf(stderr, TEXT("SetupGetLineByIndex failed, ec = %d\n"), GetLastError());
            return(FALSE);
        }

        ProcessedLines += 1;
    }

    return(TRUE);
}

BOOL
DoCopyList(
    IN PCTSTR InputInfA,
    IN PCTSTR ControlInfA,
    IN FILE *OutFile
    )
{
    PCWSTR InputInf;
    PCWSTR ControlInf;
    HINF hInputInf;
    HINF hControlInf;
    INFCONTEXT InfContext;
    FILE *HeaderFile;

    TCHAR SourceArchitecture[10];
    TCHAR SourceDiskFiles[80];
    BOOL FirstTime;


    BOOL b;

    b = TRUE;

    //
    // initialize and open the infs
    //
#ifdef UNICODE
    InputInf = InputInfA;
#else
    InputInf = pSetupAnsiToUnicode(InputInfA);
#endif
    if (!InputInf) {
        _ftprintf(stderr,TEXT("Unable to convert %s to Unicode %d\n"),InputInfA, GetLastError());
        goto e0;
    }

#ifdef UNICODE
    ControlInf = ControlInfA;
#else
    ControlInf = pSetupAnsiToUnicode(ControlInfA);
#endif

    if (!ControlInf) {
        _ftprintf(stderr,TEXT("Unable to convert %s to Unicode %d\n"),ControlInfA, GetLastError());
        goto e1;
    }

    hInputInf = SetupOpenInfFileW(InputInf,NULL,INF_STYLE_WIN4,NULL);
    if(hInputInf == INVALID_HANDLE_VALUE) {
        _ftprintf(stderr,TEXT("Unable to open Inf %ws, ec=0x%08x\n"),InputInf, GetLastError());
        goto e2;
    }

    hControlInf = SetupOpenInfFileW(ControlInf,NULL,INF_STYLE_WIN4,NULL);
    if(hControlInf == INVALID_HANDLE_VALUE) {
        _ftprintf(stderr,TEXT("Unable to open Inf %ws, ec=0x%08x\n"),ControlInf, GetLastError());
        goto e3;
    }

    myftprintf(OutFile, fDoAnsiOutput, TEXT("\n\n"));

    //
    // write the output file header
    //
    HeaderFile = _tfopen(HeaderText,TEXT("rt"));
    if (HeaderFile) {
      while (!feof(HeaderFile)) {
         TCHAR Buffer[100];
         DWORD CharsRead;

         CharsRead = fread(Buffer,sizeof(TCHAR),sizeof(Buffer)/sizeof(TCHAR),HeaderFile);

         if (CharsRead) {
            fwrite(Buffer,sizeof(TCHAR),CharsRead,OutFile);
         }
      }
      fclose(HeaderFile);
    }
    myftprintf(OutFile, fDoAnsiOutput, TEXT("\n"));

    //
    // get the required architecture decoration
    //
    if (!SetupFindFirstLine(
                    hControlInf,
                    TEXT("WowData.Filter"),
                    TEXT("SourceArchitecture"),
                    &InfContext) ||
        !SetupGetStringField(
                    &InfContext,
                    1,
                    SourceArchitecture,
                    sizeof(SourceArchitecture)/sizeof(TCHAR),
                    NULL)) {
        _ftprintf(stderr,TEXT("Unable to get SourceArchitecture\n"));
        goto e4;
    }

    FirstTime = TRUE;
    _tcscpy(SourceDiskFiles, TEXT("SourceDisksFiles"));

    while (TRUE) {
        DWORD FileCount;

        if (!FirstTime) {
            _tcscat(SourceDiskFiles,TEXT("."));
            _tcscat(SourceDiskFiles,SourceArchitecture);
        }

        DoCopyListSection(
            SourceDiskFiles,
            hInputInf,
            hControlInf,
            OutFile
            );

        if (FirstTime) {
            FirstTime = FALSE;
        } else {
            break;
        }

    }


e4:
    SetupCloseInfFile( hControlInf );
e3:
    SetupCloseInfFile( hInputInf );
e2:
#ifndef UNICODE
    pSetupFree(ControlInf);
#endif
e1:
#ifndef UNICODE
    pSetupFree(InputInf);
#endif
e0:
    return(b);
}



BOOL
DoOLEListSection(
    IN HINF    hInputInf,
    IN HINF    hOLEInputInf,
    IN HINF    hControlInf,
    IN FILE   *OutFile
    )
/*++

Routine Description:

    This routine iterates through all files in the input inf specified by the
    section name.  If the specified file is a WOW file, then we check if it
    is in the ole registration list.  If it is, then we do the appropriate
    transform on the data and output the data to our data file.

Arguments:

    hInputInf        - inf handle with file list in it.
    hOLEInputInf     - inf handle with ole lists in it.
    hControlInf      - inf handle for control inf that drives our filters
    OutFile          - file handle where the output data gets placed into

Return Value:

    Boolean value, true indicates the file is a wow file.

--*/
{
    DWORD SectionCount, i;
    INFCONTEXT InputContext;
    UCHAR      line[MAX_INF_STRING_LENGTH];
    TCHAR      SourceFileName[MAX_PATH];

    SetupFindFirstLine(
                        hOLEInputInf,
                        OLESection,
                        NULL,
                        &InputContext);

    SectionCount = SetupGetLineCount(hOLEInputInf,OLESection);

    for (i = 0; i < SectionCount; i++) {
        if (SetupGetLineByIndex(hOLEInputInf, OLESection, i, &InputContext)) {
            if (IsWowOLEFile(hControlInf,hInputInf, &InputContext)) {

                AppendWowFileToOLEList(hControlInf,hOLEInputInf,&InputContext, OutFile);

            } else if (GetLastError() != NO_ERROR) {
                _ftprintf(stderr, TEXT("IsWowOLEFile failed\n"));
                return(FALSE);
            }
        } else {
            _ftprintf(stderr, TEXT("SetupGetLineByIndex failed, ec = %d\n"), GetLastError());
            return(FALSE);
        }

        ProcessedLines += 1;
    }

    return(TRUE);
}

BOOL
DoOLEList(
    IN PCTSTR InputInfA,
    IN PCTSTR OLEInputInfA,
    IN PCTSTR ControlInfA,
    IN FILE *OutFile
    )
/*++

Routine Description:

    This routine runs through the list of specified files in the input inf
    and feeds them into a worker routine which will build the list of OLE
    Control dlls.

Arguments:

    InputInfA -    name of input inf containing the files to be run through
                   our "filter"
    OLEInputInfA - name of input inf containing the ole directives to be
                   processed
    ControlInfA  - name of the control inf that tells us how to parse the
                   input infs
    OutFile      - file pointer for the file to be written

Return Value:

    Boolean value, true indicates the file is a wow file.

--*/
{
    PCWSTR InputInf;
    PCWSTR OLEInputInf;
    PCWSTR ControlInf;
    HINF hInputInf;
    HINF hControlInf;
    HINF hOLEInputInf;
    INFCONTEXT InfContext;
    FILE *HeaderFile;

    BOOL b = FALSE;

    //
    // initialize and open the infs
    //
#ifdef UNICODE
    InputInf = InputInfA;
#else
    InputInf = pSetupAnsiToUnicode(InputInfA);
#endif
    if (!InputInf) {
        _ftprintf(stderr,TEXT("Unable to convert %s to Unicode %d\n"),InputInfA, GetLastError());
        goto e0;
    }
#ifdef UNICODE
    ControlInf = ControlInfA;
#else
    ControlInf = pSetupAnsiToUnicode(ControlInfA);
#endif
    if (!ControlInf) {
        _ftprintf(stderr,TEXT("Unable to convert %s to Unicode %d\n"),ControlInf, GetLastError());
        goto e1;
    }

#ifdef UNICODE
    OLEInputInf = OLEInputInfA;
#else
    OLEInputInf = pSetupAnsiToUnicode(OLEInputInfA);
#endif

    if (!OLEInputInf) {
        _ftprintf(stderr,TEXT("Unable to convert %s to Unicode %d\n"),OLEInputInfA, GetLastError());
        goto e2;
    }

    hInputInf = SetupOpenInfFileW(InputInf,NULL,INF_STYLE_WIN4,NULL);
    if(hInputInf == INVALID_HANDLE_VALUE) {
        _ftprintf(stderr,TEXT("Unable to open Inf %ws, ec=0x%08x\n"),InputInf, GetLastError());
        goto e3;
    }

    hOLEInputInf = SetupOpenInfFileW(OLEInputInf,NULL,INF_STYLE_WIN4,NULL);
    if(hOLEInputInf == INVALID_HANDLE_VALUE) {
        _ftprintf(stderr,TEXT("Unable to open Inf %ws, ec=0x%08x\n"),OLEInputInf, GetLastError());
        goto e4;
    }

    hControlInf = SetupOpenInfFileW(ControlInf,NULL,INF_STYLE_WIN4,NULL);
    if(hControlInf == INVALID_HANDLE_VALUE) {
        _ftprintf(stderr,TEXT("Unable to open Inf %ws, ec=0x%08x\n"),ControlInf, GetLastError());
        goto e5;
    }

    myftprintf(OutFile, TRUE, TEXT("\n\n"));

    //
    // write the output file header
    //
    HeaderFile = _tfopen(HeaderText,TEXT("rt"));
    if (HeaderFile) {
      while (!feof(HeaderFile)) {
         TCHAR Buffer[100];
         DWORD CharsRead;

         CharsRead = fread(Buffer,sizeof(TCHAR),sizeof(Buffer)/sizeof(TCHAR),HeaderFile);

         if (CharsRead) {
            fwrite(Buffer,sizeof(TCHAR),CharsRead,OutFile);
         }
      }
    }

    myftprintf(OutFile, TRUE, TEXT("\n"));


    b = DoOLEListSection(
             hInputInf,
             hOLEInputInf,
             hControlInf,
             OutFile
             );

    SetupCloseInfFile( hControlInf );
e5:
    SetupCloseInfFile( hOLEInputInf );
e4:
    SetupCloseInfFile( hInputInf );
e3:
#ifndef UNICODE
    pSetupFree(OLEInputInf);
#endif
e2:
#ifndef UNICODE
    pSetupFree(ControlInf);
#endif
e1:
#ifndef UNICODE
    pSetupFree(InputInf);
#endif
e0:
    return(b);
}

BOOL
pFilterSetupInfSection(
    PVOID FilteredSectionsStringTable,
    PCTSTR SectionName,
    PSETUPINF_CONTEXT Context
    )
/*++

Routine Description:

    This routine determines if a given section should be filtered by
    looking in the control inf for the directives that we're interested
    in.

Arguments:

    FilteredSectionsStringTable - pointer to a string table which we'll
        add our filtered section name to if we find a hit

    SectionName - name of the section in the INF we're interested in

    Context - contains context information for this function, like
              input infs name, etc.

Return Value:

    Boolean value, true indicates the file is a wow file.

--*/
{
    BOOL RetVal;
    TCHAR KeywordList[MAX_PATH];
    PCTSTR CurrentKeyword;
    DWORD KeywordBitmap;
    INFCONTEXT ControlInfContext;
    DWORD i;
    BOOL AlreadyOutputSectionName,AlreadyOutputKeyword;

    //
    // get the keywords that we're supposed to map.
    //
    // bugbug look at having a per-inf extension to this
    //
    if (!SetupFindFirstLine(
                        Context->hControlInf,
                        MyGetDecoratedSectionName(Context->hControlInf, TEXT("NativeDataToWowData.SetupINF.Keyword")),
                        TEXT("Keywords"),
                        &ControlInfContext)) {
        _ftprintf(stderr, TEXT("Could not get Keywords line in [NativeDataToWowData.SetupINF.Keyword]: SetupFindFirstLine failed, ec = 0x%08x\n"),GetLastError());
        RetVal = FALSE;
        goto exit;
    }

    //
    // now look for each keyword
    //
    SetupGetIntField(&ControlInfContext,1,&KeywordBitmap);

    AlreadyOutputSectionName = FALSE;
    AlreadyOutputKeyword = FALSE;
    CurrentKeyword = NULL;
    for (i = 0; i < 32;i++) {
        INFCONTEXT InputInfContext;
        INFCONTEXT ContextDirId;
        BOOL LookatDirIds;
        DWORD FieldCount,Field;
        TCHAR ActualSectionName[LINE_LEN];

        if (KeywordBitmap & (1<<i)) {
            CurrentKeyword = KeywordArray[i];
            MYASSERT( CurrentKeyword != NULL);
        }

        if (!CurrentKeyword) {
            continue;
        }

        if (!SetupFindFirstLine(
                          Context->hControlInf,
                          MyGetDecoratedSectionName(Context->hControlInf, TEXT("NativeDataToWowData.SetupINF.Keyword")),
                          CurrentKeyword,
                          &ContextDirId)) {
            _ftprintf(stderr, TEXT("Could not get %s line in [NativeDataToWowData.SetupINF.Keyword]: SetupFindFirstLine failed, ec = 0x%08x\n"), CurrentKeyword, GetLastError());
            RetVal = FALSE;
            goto exit;
        }

        //
        // field 2 is "MapDirId".  If it's specified, then we
        // need to look at the destinationdirs keyword
        //
        LookatDirIds = (SetupGetFieldCount(&ContextDirId)>=2) ? TRUE : FALSE;

        //
        // look for specified keyword in our section
        //
        if (SetupFindFirstLine(
                          Context->hInputInf,
                          SectionName,
                          CurrentKeyword,
                          &InputInfContext
                          )) {
            //
            // we found a hit.  see if we need to map this keyword
            //
            do {

                //
                // each field is a section name.
                //
                FieldCount = SetupGetFieldCount(&InputInfContext);
                for(Field=1; Field<=FieldCount; Field++) {
                    BOOL MapThisSection = FALSE;
                    TCHAR DirId[LINE_LEN];
                    DWORD MappedDirId = 0;
                    INFCONTEXT InputDirId,ControlDirId;

                    SetupGetStringField(&InputInfContext,Field,ActualSectionName,LINE_LEN,NULL);

                    //
                    // if we need to look at the destination dirs keyword,
                    // then look it up and compare it against the control inf
                    // mapper
                    //
                    if (LookatDirIds) {
                        if(!SetupFindFirstLine(
                                        Context->hInputInf,
                                        TEXT("DestinationDirs"),
                                        ActualSectionName,
                                        &InputDirId)) {
                            //_ftprintf(stderr, TEXT("SetupFindFirstLine failed, ec = 0x%08x finding %s in %s \n"),GetLastError(), ActualSectionName, TEXT("DestinationDirs"));

                            if(!SetupFindFirstLine(
                                        Context->hInputInf,
                                        TEXT("DestinationDirs"),
                                        TEXT("DefaultDestDir"),
                                        &InputDirId)) {
                                _ftprintf(stderr, TEXT("SetupFindFirstLine failed, ec = 0x%08x finding %s in %s\n"),GetLastError(), TEXT("DefaultDestDir"), TEXT("DestinationDirs"));
                                RetVal = FALSE;
                                goto exit;
                            }
                        }

                        if(SetupGetStringField(&InputDirId,1,DirId,LINE_LEN,NULL) &&
                                SetupFindFirstLine(
                                               Context->hControlInf,
                                               MyGetDecoratedSectionName(Context->hControlInf, TEXT("NativeDataToWowData.SetupINF.DestinationDirsToMap")),
                                               DirId,
                                               &ControlDirId)) {
                            //
                            // we found a hit, thus we should map this section
                            //
                            MapThisSection = TRUE;
                            SetupGetIntField(&ControlDirId,1,&MappedDirId);
                            //_ftprintf(stderr, TEXT("Mapping %s to %lu\n"), DirId, MappedDirId);

                        }
                    } else {
                        MapThisSection = TRUE;
                    }

                    if (MapThisSection) {
                        DWORD StringId;
                        PERSECTION_CONTEXT SectionContext;
                        BOOL AddNewEntry;
                        //
                        // output the toplevel section name if we haven't done
                        // so already.  this section name is not decorated
                        //
                        if (!AlreadyOutputSectionName) {
                            myftprintf(Context->OutFile, fDoAnsiOutput, TEXT("\n[%s]\n"),SectionName);
                            AlreadyOutputSectionName = TRUE;
                        }

                        //
                        // output the keyword and decorated section name
                        // note that we need to separate the section names
                        // by a comma
                        //
                        if (!AlreadyOutputKeyword) {
                            myftprintf(Context->OutFile, fDoAnsiOutput, TEXT("%s="), CurrentKeyword);
                            myftprintf(Context->OutFile, fDoAnsiOutput, TEXT("%s%s"),FilePrefix,ActualSectionName);
                            AlreadyOutputKeyword = TRUE;
                        } else {
                            myftprintf(Context->OutFile, fDoAnsiOutput, TEXT(",%s%s"),FilePrefix,ActualSectionName);
                        }

                        //
                        // now append the section to the string table
                        //
                        StringId = pSetupStringTableLookUpString(
                                            FilteredSectionsStringTable,
                                            (PTSTR)ActualSectionName,
                                            STRTAB_CASE_INSENSITIVE);

                        if (StringId != -1) {
                            pSetupStringTableGetExtraData(
                                            FilteredSectionsStringTable,
                                            StringId,
                                            &SectionContext,
                                            sizeof(SectionContext));
                            AddNewEntry = FALSE;
                        } else {
                            RtlZeroMemory(&SectionContext,sizeof(SectionContext));
                            AddNewEntry = TRUE;
                        }

                        SectionContext.DestinationDir = MappedDirId;
                        SectionContext.KeywordVector |= (1<<i);

                        if (AddNewEntry) {

                            //_ftprintf(stderr, TEXT("Adding %s to string table\n"), ActualSectionName);

                            if ( -1 == pSetupStringTableAddStringEx(
                                            FilteredSectionsStringTable,
                                            (PTSTR)ActualSectionName,
                                            STRTAB_CASE_SENSITIVE | STRTAB_NEW_EXTRADATA,
                                            &SectionContext,
                                            sizeof(SectionContext))){

                                _ftprintf(stderr, TEXT("Could not add %s to string table\n"), ActualSectionName);


                            }
                        } else {

                            //_ftprintf(stderr, TEXT("Adding %s to string table\n"), ActualSectionName);

                            if ( !pSetupStringTableSetExtraData(
                                            FilteredSectionsStringTable,
                                            StringId,
                                            &SectionContext,
                                            sizeof(SectionContext))){

                                _ftprintf(stderr, TEXT("Could not add %s to string table\n"), ActualSectionName);}
                        }
                    }
                }

            } while ( SetupFindNextMatchLine(&InputInfContext,
                                             CurrentKeyword,
                                             &InputInfContext ));

        }

        if (AlreadyOutputKeyword) {
            myftprintf(Context->OutFile, fDoAnsiOutput, TEXT("\n"));
        }
        //
        // reset this for the next keyword
        //
        AlreadyOutputKeyword = FALSE;
        CurrentKeyword = NULL;

    }

exit:
    return(RetVal);
}

BOOL
AppendSetupInfDataToLayoutFile(
    IN FILE  *OutFile,
    IN FILE  *OutInfFile,
    IN HINF  hControlInf,
    IN HINF  hInputInf,
    IN PINFCONTEXT LineContext
    )
/*++

Routine Description:

    This routine filters and outputs a layout line.

    We only need to filter "Copyfiles" sections, and since the files are
    not installed by textmode setup, the line which we output is largely
    hardcoded.


Arguments:

    OutFile      - output file handle
    
    OutInfFile   - output file handle for layout information within INF

    hControlInf  - inf handle to the inf with the control directives

    LineContext  - inf context to the input line we want to filter.

Return Value:

    Boolean indicating outcome.

--*/
{
    TCHAR FileName[MAX_PATH],InfField[MAX_PATH],Entry[50];
    INFCONTEXT ControlContext;
    BOOL RetVal;
    INT SourceID = 1;
    TCHAR SourceIDStr[6], DefaultIDStr[6];
    BOOL LayoutWithinInf = FALSE;

    DWORD EntryCount,i;


    ZeroMemory(Entry,sizeof(Entry));

    if (FilePrefix) {
       _tcscpy(FileName, FilePrefix);
    } else {
       FileName[0] = (TCHAR)NULL;
    }

    //
    // get the source filename
    //
    EntryCount = SetupGetFieldCount(LineContext);
    if ((((EntryCount <= 1)
        || !SetupGetStringField(LineContext,2,InfField,MAX_PATH,NULL)
        || !InfField[0]))
        && (!SetupGetStringField(LineContext,1,InfField,MAX_PATH,NULL)
                || !InfField[0])) {
        //
        // bad line?
        //
        MYASSERT(0);
    }

    _tcscat(FileName,InfField);


    //
    // see if the file is in our "SetupInf exclusion list"
    //
    if(SetupFindFirstLine(
                    hControlInf,
                    MyGetDecoratedSectionName(hControlInf, TEXT("WowData.SetupInfLayout.Exclude")),
                    InfField,
                    &ControlContext) ||
        SetupFindFirstLine(
                    hControlInf,
                    MyGetDecoratedSectionName(hControlInf, TEXT("NativeDataToWowData.SetupINF.FilesToExclude")),
                    InfField,
                    &ControlContext)) {
        _ftprintf(stderr,
                TEXT("filtering %ws because it's in our SetupInf exclusion list\n"),
                InfField);
        RetVal = FALSE;
        goto exit;
    }

    //
    // Get Default Source ID
    // By default this means the Source ID that is processed for dosnet.inf, txtsetup.sif etc.
    // i.e layout.inf today only has = 1,,,,,,, type of entries that translate to = 55,,,,,
    // Currently we can support only one such mapping as the default translation
    // That means that we will take SourceDisksFiles entries pertaining to the default and always output it into the layout.inf stub
    // so that dosnet.inf gets it.
    //


    if (!SetupFindFirstLine(
                    hControlInf,
                    TEXT("NativeDataToWowData.SourceInfo"),
                    TEXT("Default"), //bugbug need a way to get this for other source disks
                    &ControlContext) ||

        !SetupGetStringField(&ControlContext,1,DefaultIDStr,sizeof(DefaultIDStr)/sizeof(TCHAR),NULL)) {
        _ftprintf(stderr, TEXT("SetupFindFirstLine to get default SourceID for file %s failed - Using %s, ec = 0x%08x\n"),FileName,DefaultIDStr,GetLastError());
        // As last resort use 1
        lstrcpy( DefaultIDStr, TEXT("1"));
    }


    if( !SetupGetSourceFileLocation(hInputInf,
                               LineContext,
                               NULL,
                               &SourceID,
                               NULL,
                               0,
                               NULL)){


        _ftprintf(stderr, TEXT("SetupGetSourceFileLocation [%s] failed - Using SourceID 1, ec = 0x%08x\n"),FileName,GetLastError());
        //Assume Default
        lstrcpy( SourceIDStr, DefaultIDStr);
        LayoutWithinInf = FALSE;
    }else{
        LayoutWithinInf = TRUE;;
        _itot( SourceID, SourceIDStr, 10);
    }
    


    //
    // look in the appropriate control inf section for the data
    //
    if (!SetupFindFirstLine(
                    hControlInf,
                    TEXT("NativeDataToWowData.SourceInfo"),
                    SourceIDStr, 
                    &ControlContext)) {
        _ftprintf(stderr, TEXT("SetupFindFirstLine [%s] failed, ec = 0x%08x finding %s key in [NativeDataToWowData.SourceInfo]\n"),FileName,GetLastError(), SourceIDStr);
        RetVal = FALSE;
        goto exit;
    }

    if (!SetupGetStringField(&ControlContext,1,Entry,sizeof(Entry)/sizeof(TCHAR),NULL)) {
        _ftprintf(stderr, TEXT("SetupGetStringField [%s] failed, ec = 0x%08x\n"),FileName,GetLastError());
        RetVal = FALSE;
        goto exit;
    }

    if( LayoutWithinInf && OutInfFile){
        //If we found SourceFileInfo within this file and we were
        //asked to add the WOW equivalent to the same INF then do so.
        myftprintf(OutInfFile, fDoAnsiOutput, TEXT("%s=%s,,,,,,,,3,3\n"),FileName,Entry);

        //Also if the SourceID matches the default we want to output to the layout.inf stub as well so 
        //that it makes it into dosnet.inf. See earlier comments about the DefaultIDStr

        if( !lstrcmpi( SourceIDStr, DefaultIDStr )){
            myftprintf(OutFile, TRUE, TEXT("%s=%s,,,,,,,,3,3\n"),FileName,Entry);
        }

    }else{
        myftprintf(OutFile, TRUE, TEXT("%s=%s,,,,,,,,3,3\n"),FileName,Entry);
    }
    
    RetVal = TRUE;

exit:
    return(RetVal);
}

PSUBST_STRING InitializeStringList(
    VOID
    )
{
    DWORD SizeNeeded,i;
    PSUBST_STRING StringList;

    SizeNeeded = (sizeof(StringArray)/sizeof(SUBST_STRING)) *
                 (sizeof(SUBST_STRING)+(MAX_PATH*sizeof(TCHAR)));

    StringList = pSetupMalloc( SizeNeeded );

    if (!StringList) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    RtlCopyMemory( StringList, &StringArray, sizeof(StringArray) );

    for (i = 0; i < sizeof(StringArray)/sizeof(SUBST_STRING); i++) {
        StringList[i].InputString = (PTSTR) ((PBYTE)StringList + (ULONG_PTR)sizeof(StringArray)+(i*sizeof(TCHAR)*MAX_PATH));

        ExpandEnvironmentStrings( StringList[i].SourceInputString, StringList[i].InputString, MAX_PATH );
    }

    return StringList;

}

BOOL
pSubstituteEnvVarsForActualPaths(
    IN OUT PTSTR String
    )
/*++

Routine Description:

    This routine filters and outputs the input line.  It looks for a string
    pattern that matches one of a known list of strings, and replaces the
    known string with a substitution string.

Arguments:

    String       - input string to be searched.  We edit this string
                   in-place if we find a match.

Return Value:

    Boolean indicating outcome.

--*/

{
    BOOL RetVal = TRUE;

    if (!StringList) {
        StringList = InitializeStringList();
        if (!StringList) {
            RetVal = FALSE;
        }
    }

    if (RetVal) {
        DWORD i;
        PTSTR p,q;
        TCHAR c;

        MYASSERT( StringList != NULL );

        for (i = 0; i< sizeof(StringArray)/sizeof(SUBST_STRING); i++) {
            if (p = StrStrI(String,StringList[i].InputString)) {
                //
                // if we found a hit, then find the end of the string
                // and concatenate that to our source string, which gives
                // the resultant string with substitutions.
                //
                q = p + _tcslen(StringList[i].InputString);
                c = *p;
                *p = TEXT('\0');
                _tcscpy(ScratchTextEnv,String);
                *p = c;
                _tcscat(ScratchTextEnv,StringList[i].OutputString);
                _tcscat(ScratchTextEnv,q);
                _tcscpy(String,ScratchTextEnv);
                //
                // recursively call in case there are more strings.
                //
                pSubstituteEnvVarsForActualPaths(String);
                break;
            }
        }
    }

    return(RetVal);
}

void
HandleSetupapiQuotingForString( 
    IN OUT PTSTR String 
    )
/*++

Routine Description:

    This routine looks at the passed in line and does the right quoting and handling of
    the string to handle characters that may have been stripped off by setupapi.
    
    It first scans through the string looking for characters <= 0x20, '\"','%','\\'
    If it finds any of these then it places a " at the beginning and end of the string. Additionally it doubles
    every quote within.
    
    
Arguments:

    String       - input string to be searched.  We edit this string
                   in-place if we find a match.

Return Value:

    Boolean indicating outcome.

--*/
{
    PTCHAR p,q;
    BOOL Pass2Needed = FALSE;

    

    if( !String || !String[0] )
        return;

    p = String;

    //
    // [askhalid] ',' Need to be considered as well
    //
    while( *p ){
        if( (*p <= 0x20) || (*p == TEXT('\"')) || (*p == TEXT(',')) || (*p == TEXT(';')) ||(*p == TEXT('%')) || (*p == TEXT('\\')))
            Pass2Needed = TRUE;
        p++;
    }// while

    if( Pass2Needed ){
        // Quote the start
        p = String;
        q = ScratchTextEnv+1;

        ZeroMemory(ScratchTextEnv,sizeof(ScratchTextEnv));

        ScratchTextEnv[0] = TEXT('\"');
        
        while( *p && (q < (ScratchTextEnv+MAX_INF_STRING_LENGTH-3)) ){
        
            // If we have a quote in the string double it

            if (*p == TEXT('\"')) {
                *(q++) = TEXT('\"');
            }
            *q = *p;
    
            p++;q++;

        }// while

        // Quote the end
        *(q++) = TEXT('\"');
        *q = 0;

        lstrcpy( String, ScratchTextEnv );
    }

    return;

}

void
FixupSetupapiPercents(
    IN OUT PTSTR String
    )
/*++

Routine Description:

    This routine doubles up the '%' char if present in the input string.
    
    
    
Arguments:

    String       - input string to be searched.  We edit this string
                   in-place if we find a match.

Return Value:

    Boolean indicating outcome.

--*/
{

    PTCHAR p,q;

    if( !String || !String[0] )
        return;

    p = String;
    q = ScratchTextEnv;

    ZeroMemory(ScratchTextEnv,sizeof(ScratchTextEnv));

    while( *p && (q < (ScratchTextEnv+MAX_INF_STRING_LENGTH-1)) ){

        if (*p == TEXT('%')) {
            *(q++) = TEXT('%');
         }
         *q = *p;

         p++;
         q++;
    }
    *q = 0;

    lstrcpy( String, ScratchTextEnv );

    return;

}

BOOL
AppendSetupInfDataToSection(
    IN FILE *OutFile,
    IN HINF hControlInf,
    IN PINFCONTEXT InputContext,
    IN PCTSTR KeywordName
    )
/*++

Routine Description:

    This routine filters and outputs an input line.  The control inf
    lists the syntax for the specified keyword.  We filter the keywords
    we know about and let the other ones just fall through.

Arguments:

    OutFile      - output file handle

    hControlInf  - inf handle to the inf with the control directives

    InputContext - inf context to the input line we want to filter.

    KeywordName  - string indicating the keyword associated with the section
                   we are filtering.

Return Value:

    Boolean indicating outcome.

--*/
{
    TCHAR FileName[40];
    TCHAR KeyName[LINE_LEN];
    TCHAR Cmd[LINE_LEN];
    BOOL RetVal;
    DWORD EntryCount,i;
    INFCONTEXT ControlContext,KeywordContext;

    //
    // ISSUE-2000/06/27-JamieHun Appears to be no error checking here, someone should fix this
    //
    SetupFindFirstLine(
                hControlInf,
                MyGetDecoratedSectionName(hControlInf, TEXT("NativeDataToWowData.SetupINF.Keyword")),
                KeywordName,
                &ControlContext);

    if(SetupGetStringField(&ControlContext,1,KeyName,LINE_LEN,NULL)) {
        SetupFindFirstLine(
                    hControlInf,
                    MyGetDecoratedSectionName(hControlInf, TEXT("NativeDataToWowData.SetupINF.Syntax")),
                    KeyName,
                    &KeywordContext);
    }

    ZeroMemory(LineText,sizeof(LineText));
    FileName[0] = TEXT('\0');

    EntryCount = SetupGetFieldCount(InputContext);

    for (i = 1; i<=EntryCount; i++) {
        TCHAR ScratchEntry[MAX_PATH];

        //
        // get the current text to be appended
        //
        if (!SetupGetStringField(InputContext,i,ScratchText,sizeof(ScratchText)/sizeof(TCHAR),NULL)) {
            _ftprintf(stderr, TEXT("SetupGetStringField [%s] failed, ec = 0x%08x\n"),FileName,GetLastError());
            RetVal = FALSE;
            goto exit;
        }


        //_ftprintf(stderr, TEXT("ScratchText (1)- %s\n"),ScratchText);
        FixupSetupapiPercents(ScratchText);
        //_ftprintf(stderr, TEXT("ScratchText (2)- %s\n"),ScratchText);
        pSubstituteEnvVarsForActualPaths(ScratchText);

        //_ftprintf(stderr, TEXT("ScratchText (3)- %s\n"),ScratchText);

        //
        // now do any necessary substitutions
        //
        if(SetupGetStringField(&KeywordContext,i,Cmd,LINE_LEN,NULL)
            && Cmd[0]) {

            //
            // dirid substitution
            //
            if (!_tcsicmp(Cmd,TEXT("MapDirId"))) {
                //
                // look in the appropriate control inf section for the data
                //
                if (!SetupFindFirstLine(
                                hControlInf,
                                MyGetDecoratedSectionName(hControlInf, TEXT("NativeDataToWowData.SetupINF.DestinationDirsToMap")),
                                ScratchText,
                                &ControlContext)) {
                    _ftprintf(stderr, TEXT("SetupFindFirstLine [%s] failed, ec = 0x%08x\n"),FileName,GetLastError());
                    RetVal = FALSE;
                    goto exit;
                }

                if (!SetupGetStringField(&ControlContext,1,ScratchText,sizeof(ScratchText)/sizeof(TCHAR),NULL)) {
                    _ftprintf(stderr, TEXT("SetupGetStringField [%s] failed, ec = 0x%08x\n"),FileName,GetLastError());
                    RetVal = FALSE;
                    goto exit;
                }
            }

            //
            // source name substitution
            //
            if (!_tcsicmp(Cmd,TEXT("srcname"))) {
                lstrcpy(ScratchEntry,FilePrefix);
                if (ScratchText[0]) {
                    lstrcat(ScratchEntry,ScratchText);
                } else {
                    lstrcat(ScratchEntry,FileName);
                }

                lstrcpy(ScratchText,ScratchEntry);
            }

            //_ftprintf(stderr, TEXT("ScratchText(2) - %s\n"),ScratchText);

            if (!_tcsicmp(Cmd,TEXT("RegistryFlags"))) {
                DWORD RegVal,CurrentRegVal;
                //
                // look in the appropriate control inf section for the data
                //
                if (!SetupFindFirstLine(
                                hControlInf,
                                MyGetDecoratedSectionName(hControlInf, TEXT("NativeDataToWowData.SetupINF.RegistryInformation")),
                                TEXT("RegistryFlags"),
                                &ControlContext)) {
                    _ftprintf(stderr, TEXT("SetupFindFirstLine [%s] failed, ec = 0x%08x\n"),FileName,GetLastError());
                    RetVal = FALSE;
                    goto exit;
                }

                CurrentRegVal = 0;
                RegVal = 0;
                SetupGetIntField(&ControlContext,1,&RegVal);
                SetupGetIntField(InputContext,i,&CurrentRegVal);

                CurrentRegVal |= RegVal;

                _stprintf(ScratchText, TEXT("0x%08x"), CurrentRegVal);

            }


            if (!_tcsicmp(Cmd,TEXT("dstname"))) {
                lstrcpy(FileName,ScratchText);
            }

            

        }


        HandleSetupapiQuotingForString(ScratchText); 

        _tcscat(LineText, ScratchText);
        

        //
        // now append a comma if necessary
        //
        if (i !=EntryCount) {
            _tcscat(LineText, TEXT(","));
        }

    }

    //_ftprintf(stderr, TEXT("LineText - %s\n"),LineText);


    //
    // Check if we need to exclude the DLL
    //

    if (KeywordName == KeywordArray[INDEX_COPYFILES] ||
        KeywordName == KeywordArray[INDEX_DELFILES] ||
        KeywordName == KeywordArray[INDEX_RENFILES] ||
        KeywordName == KeywordArray[INDEX_REGISTERDLLS]){

    
        // Check if we need to exclude this file from processing

        if( SetupFindFirstLine(
                hControlInf,
                MyGetDecoratedSectionName(hControlInf, TEXT("NativeDataToWowData.SetupINF.FilesToExclude")),
                FileName,
                &ControlContext)){

            return TRUE;
        }

    }

    
    if (KeywordName == KeywordArray[INDEX_COPYFILES]) {

        //
        // if we didn't have a file rename in copyfiles, we add it now.
        //
    
        i -= 1;
        if (i < SetupGetFieldCount(&ControlContext)) {
            _tcscat(LineText, TEXT(","));
            if (FilePrefix) {
                _tcscat(LineText, FilePrefix);
            }
            _tcscat(LineText, FileName);
        }
        //_ftprintf(stderr, TEXT("LineText(2) - %s\n"),LineText);

    } else if (KeywordName == KeywordArray[INDEX_ADDREG] ||
               KeywordName == KeywordArray[INDEX_DELREG]) {
        //
        // we need to pad out AddReg or DelReg if necessary.
        //
        DWORD count;
        TCHAR Entry[MAX_PATH];
        count = SetupGetFieldCount(&KeywordContext);
        if (count > i ) {
            while (i <= count) {
                if(SetupGetStringField(&KeywordContext,i,Cmd,LINE_LEN,NULL)
                    && Cmd[0]) {
                    if (!_tcsicmp(Cmd,TEXT("RegistryFlags"))) {
                        //
                        // look in the appropriate control inf section for the data
                        //
                        if (!SetupFindFirstLine(
                                        hControlInf,
                                        MyGetDecoratedSectionName(hControlInf, TEXT("NativeDataToWowData.SetupINF.RegistryInformation")),
                                        TEXT("RegistryFlags"),
                                        &ControlContext)) {
                            _ftprintf(stderr, TEXT("SetupFindFirstLine [%s] failed, ec = 0x%08x\n"),FileName,GetLastError());
                            RetVal = FALSE;
                            goto exit;
                        }

                        if (!SetupGetStringField(&ControlContext,1,Entry,sizeof(Entry)/sizeof(TCHAR),NULL)) {
                            _ftprintf(stderr, TEXT("SetupGetStringField [%s] failed, ec = 0x%08x\n"),FileName,GetLastError());
                            RetVal = FALSE;
                            goto exit;
                        }

                        _tcscat(LineText, TEXT(","));
                        _tcscat(LineText, Entry);

                    }
                }

                if (i != count) {
                    _tcscat(LineText, TEXT(","));
                }

                i +=1;

            }

        }
    }else if (KeywordName == KeywordArray[INDEX_REGISTERDLLS]) {

        // Check if we need to exclude this file from RegisterDlls
        if( SetupFindFirstLine(
                hControlInf,
                MyGetDecoratedSectionName(hControlInf, TEXT("NativeDataToWowData.SetupINF.FilesToExcludeFromRegistration")),
                FileName,
                &ControlContext)){

            return TRUE;
        }


    }

    myftprintf(OutFile, fDoAnsiOutput, TEXT("%s\n"),LineText);

    RetVal = TRUE;

exit:
    return(RetVal);

}


BOOL
pOutputSectionData(
    IN PVOID                    StringTable,
    IN LONG                     StringId,
    IN PCTSTR                   String,
    IN PPERSECTION_CONTEXT      SectionContext,
    IN UINT                     SectionContextSize,
    IN LPARAM                   cntxt
    )

/*++

Routine Description:

    String table callback.

    This routine outputs the contents of the specified section to both the
    system layout file and the output file.

Arguments:

    Standard string table callback args.

Return Value:

    Boolean indicating outcome. If FALSE, an error will have been logged.
    FALSE also stops the string table enumeration and causes pSetupStringTableEnum()
    to return FALSE. There is a bug in setupapi where we will jump into 
    the next hash_bucket and may process few more entries.

--*/
{
    TCHAR LineText[MAX_INF_STRING_LENGTH];
    BOOL RetVal;
    INFCONTEXT LineContext;

    DWORD EntryCount,i,SectionCount;
    INFCONTEXT InputContext;
    UCHAR      line[MAX_INF_STRING_LENGTH];
    PSETUPINF_CONTEXT  Context = (PSETUPINF_CONTEXT)cntxt;


    //_ftprintf(stderr, TEXT("Enumerating Section %s\n"), String);

    
    //
    // output the decorated section header
    //
    myftprintf(Context->OutFile, fDoAnsiOutput, TEXT("[%s%s]\n"),FilePrefix,String);

    //
    // get the section context
    //
    if(! SetupFindFirstLine(
                Context->hInputInf,
                String,
                NULL,
                &InputContext)){

        _ftprintf(stderr, TEXT("Could not find lines in Section %s\n"), String);

        //continue with next section

        return TRUE;
    }

    //_ftprintf(stderr, TEXT("Output Section %s\n"), String);

    do {

        SectionCount = SetupGetLineCount(Context->hInputInf,String);

        for (i = 0; i < SectionCount; i++) {
            if (SetupGetLineByIndex(
                                Context->hInputInf,
                                String,
                                i,&InputContext)) {
                //
                // get the keyword for the section we're mapping
                //
                PCTSTR KeywordName = NULL;
                DWORD j=0;
                MYASSERT(SectionContext->KeywordVector != 0);
                while (!KeywordName) {
                    if (SectionContext->KeywordVector & (1<<j)) {
                        KeywordName = KeywordArray[j];
                        break;
                    }

                    j += 1;
                }

                MYASSERT(KeywordName != NULL);

                //
                // filter and output the data
                //
                AppendSetupInfDataToSection(
                                    Context->OutFile,
                                    Context->hControlInf,
                                    &InputContext,
                                    KeywordName );

                //_ftprintf(stderr, TEXT("Got back from AppendSetupInfDataToSection\n"));


                //
                // output the data to the layout file if we need to
                //
                if ((SectionContext->KeywordVector & KEYWORD_NEEDLAYOUTDATA) && Context->OutLayoutFile) {

                    //_ftprintf(stderr, TEXT("Calling AppendSetupInfDataToLayoutFile\n"));

                    AppendSetupInfDataToLayoutFile(
                                            Context->OutLayoutFile,
                                            Context->OutInfLayoutFile,
                                            Context->hControlInf,
                                            Context->hInputInf,
                                            &InputContext );

                    //_ftprintf(stderr, TEXT("Got back from AppendSetupInfDataToLayoutFile\n"));

                }

            } else {
                _ftprintf(stderr, TEXT("SetupGetLineByIndex failed, ec = %d\n"), GetLastError());
                return(FALSE);
            }
        }

    } while (SetupFindNextLine( &InputContext,
                                &InputContext)); // bugbug is this really
                                                 // necessary ??

    myftprintf(Context->OutFile, fDoAnsiOutput, TEXT("\n"));
    RetVal = TRUE;
    return(RetVal);
}


BOOL
pOutputDestinationDirs(
    IN PVOID                    StringTable,
    IN LONG                     StringId,
    IN PCTSTR                   String,
    IN PPERSECTION_CONTEXT      SectionContext,
    IN UINT                     SectionContextSize,
    IN LPARAM                   cntxt
    )
/*++

Routine Description:

    String table callback.

    This routine outputs the destination dirs keyword
    followed by the decorated section name and dirid mapping.

Arguments:

    Standard string table callback args.

Return Value:

    Boolean indicating outcome. If FALSE, an error will have been logged.
    FALSE also stops the string table enumeration and causes pSetupStringTableEnum()
    to return FALSE.

--*/
{
    TCHAR LineText[MAX_INF_STRING_LENGTH];
    BOOL RetVal;
    INFCONTEXT LineContext;

    DWORD EntryCount,i;
    PSETUPINF_CONTEXT        Context = (PSETUPINF_CONTEXT)cntxt;

    //
    // only process this entry if it need destination dirs
    //

    if (0 == (SectionContext->KeywordVector & (KEYWORD_NEEDDESTDIRS))) {
        RetVal = TRUE;
        goto exit;
    }

    
    //
    // first output "destinationdirs" if we haven't done so already
    //
    if (!Context->AlreadyOutputKeyword) {
         myftprintf(Context->OutFile, fDoAnsiOutput, TEXT("[DestinationDirs]\n"));
         Context->AlreadyOutputKeyword = TRUE;
    }

    //
    // now get the unfiltered data so that we can filter it
    //
    if( !SetupFindFirstLine(
                    Context->hInputInf,
                    TEXT("DestinationDirs"),
                    String,
                    &LineContext)){

        SetupFindFirstLine(
                    Context->hInputInf,
                    TEXT("DestinationDirs"),
                    TEXT("DefaultDestDir"),
                    &LineContext);

    }


    ZeroMemory(LineText,sizeof(LineText));

    EntryCount = SetupGetFieldCount(&LineContext);

    for (i = 1; i<=EntryCount; i++) {
        TCHAR Entry[40];
        INFCONTEXT ControlContext;

        //
        // get the current text to be appended
        //
        if (!SetupGetStringField(&LineContext,i,Entry,sizeof(Entry)/sizeof(TCHAR),NULL)) {
            _ftprintf(stderr, TEXT("SetupGetStringField failed, ec = 0x%08x\n"),GetLastError());
            RetVal = FALSE;
            goto exit;
        }

        //
        // now do any necessary substitutions
        //
        if (i == 1) {
            _stprintf(Entry, TEXT("%d"), SectionContext->DestinationDir);
        }

        _tcscat(LineText, Entry);

        //
        // now append a comma if necessary
        //
        if (i !=EntryCount) {
            _tcscat(LineText, TEXT(","));
        }

        //_ftprintf(stderr, TEXT("LineText = %s\n"), LineText, SectionContext->DestinationDir);

    }

    //
    // output the filtered data
    //
    myftprintf(Context->OutFile, fDoAnsiOutput, TEXT("%s%s=%s\n"),FilePrefix,String,LineText);

    RetVal = TRUE;

exit:
    return(RetVal);
}


BOOL
DoSetupINF(
    IN PCTSTR InputInfA,
    IN PCTSTR ControlInfA,
    IN FILE *OutFile,
    IN FILE *OutLayoutFile,
    IN FILE *OutInfLayoutFile
    )
/*++

Routine Description:

    Filters a setupapi-based INF.

Arguments:

    InputInfA     - name of the inf to be filtered.
    ControlInfA   - name of the control directive inf
    OutFile       - output file handle
    OutLayoutFile - output file handle for layout information
    OutInfLayoutFile - output file handle for layout information contained in this INF

Return Value:

    NONE.

--*/
{
    PCWSTR InputInf;
    PCWSTR ControlInf;
    HINF hInputInf;
    HINF hControlInf;
    INFCONTEXT InfContext;
    SETUPINF_CONTEXT Context;
    PERSECTION_CONTEXT SectionContext;
    FILE *HeaderFile;

    TCHAR SourceArchitecture[10];
    TCHAR SourceDiskFiles[80];
    BOOL FirstTime;
    PTSTR Sections,Current;
    DWORD SizeNeeded;
    PVOID FilteredSectionsStringTable;

    BOOL b;

    b = FALSE;

    //
    // initialize and open the infs
    //
#ifdef UNICODE
    InputInf = InputInfA;
#else
    InputInf = pSetupAnsiToUnicode(InputInfA);
#endif
    if (!InputInf) {
        _ftprintf(stderr,TEXT("Unable to convert %s to Unicode %d\n"),InputInfA, GetLastError());
        goto e0;
    }
#ifdef UNICODE
    ControlInf = ControlInfA;
#else
    ControlInf = pSetupAnsiToUnicode(ControlInfA);
#endif
    if (!ControlInf) {
        _ftprintf(stderr,TEXT("Unable to convert %s to Unicode %d\n"),ControlInfA, GetLastError());
        goto e1;
    }

    hInputInf = SetupOpenInfFileW(InputInf,NULL,INF_STYLE_WIN4,NULL);
    if(hInputInf == INVALID_HANDLE_VALUE) {
        _ftprintf(stderr,TEXT("Unable to open Inf %ws, ec=0x%08x\n"),InputInf, GetLastError());
        goto e2;
    }

    hControlInf = SetupOpenInfFileW(ControlInf,NULL,INF_STYLE_WIN4,NULL);
    if(hControlInf == INVALID_HANDLE_VALUE) {
        _ftprintf(stderr,TEXT("Unable to open Inf %ws, ec=0x%08x\n"),ControlInf, GetLastError());
        goto e3;
    }


    myftprintf(OutFile, fDoAnsiOutput, TEXT("\n\n"));

    //
    // write the output file header
    //
    HeaderFile = _tfopen(HeaderText,TEXT("rt"));
    if (HeaderFile) {
      while (!feof(HeaderFile)) {
         TCHAR Buffer[100];
         DWORD CharsRead;

         CharsRead = fread(Buffer,sizeof(TCHAR),sizeof(Buffer)/sizeof(TCHAR),HeaderFile);

         if (CharsRead) {
            fwrite(Buffer,sizeof(TCHAR),CharsRead,OutFile);
         }
      }
      fclose(HeaderFile);
    }

    myftprintf(OutFile, fDoAnsiOutput, TEXT("\n"));

    //
    // get all of the section names
    //
    if (!SetupGetInfSections(hInputInf, NULL, 0, &SizeNeeded)) {
        _ftprintf(stderr,TEXT("Unable to get section names, ec=0x%08x\n"), GetLastError());
        goto e4;
    }
    if (SizeNeeded == 0) {
        b= TRUE;
        goto e4;
    }

    Sections = pSetupMalloc (SizeNeeded + 1);
    if (!Sections) {
        _ftprintf(stderr,TEXT("Unable to allocate memory, ec=0x%08x\n"), GetLastError());
        goto e4;
    }

    if (!SetupGetInfSections(hInputInf, Sections, SizeNeeded, NULL)) {
        _ftprintf(stderr,TEXT("Unable to allocate memory, ec=0x%08x\n"), GetLastError());
        goto e5;
    }

    FilteredSectionsStringTable = pSetupStringTableInitializeEx( sizeof(PERSECTION_CONTEXT),0);
    if (!FilteredSectionsStringTable) {
        _ftprintf(stderr,TEXT("Unable to create string table, ec=0x%08x\n"), GetLastError());
        goto e5;
    }

    Current = Sections;
    Context.OutFile = OutFile;
    Context.OutLayoutFile = OutLayoutFile;
    Context.OutInfLayoutFile = OutInfLayoutFile;
    Context.hControlInf = hControlInf;
    Context.hInputInf = hInputInf;
    Context.AlreadyOutputKeyword = FALSE;

    //
    // process each section, which will output the
    // sections names and keywords that we want to filter
    //
    while (*Current) {

        //_ftprintf(stderr,TEXT("Processing section %s\n"), Current );

        pFilterSetupInfSection(
                    FilteredSectionsStringTable,
                    Current,
                    &Context);

        Current += lstrlen(Current)+1;
    }

    myftprintf(Context.OutFile, fDoAnsiOutput, TEXT("\n"));

    //
    // for each section that we decided to filter, we now need to output the
    // actual section
    //
    pSetupStringTableEnum(
        FilteredSectionsStringTable,
        &SectionContext,
        sizeof(PERSECTION_CONTEXT),
        pOutputSectionData,
        (LPARAM)&Context
        );


    //
    // now we need to output the destination dirs section
    //
    pSetupStringTableEnum(
        FilteredSectionsStringTable,
        &SectionContext,
        sizeof(PERSECTION_CONTEXT),
        pOutputDestinationDirs,
        (LPARAM)&Context
        );

    b = TRUE;

    pSetupStringTableDestroy(FilteredSectionsStringTable);
e5:
    pSetupFree(Sections);
e4:
    SetupCloseInfFile( hControlInf );
e3:
    SetupCloseInfFile( hInputInf );
e2:
#ifndef UNICODE
    pSetupFree(ControlInf);
#endif
e1:
#ifndef UNICODE
    pSetupFree(InputInf);
#endif
e0:
    return(b);
}


void
Usage(
    VOID
    )
/*++

Routine Description:

    Prints the usage to stderr.

Arguments:

    NONE.

Return Value:

    NONE.

--*/
{
    _ftprintf( stderr,TEXT("generate list of wow files. Usage:\n") );
    _ftprintf( stderr,TEXT("%s <options> <inf file> -c <control inf> -l <ole inf> -o <output file> -a{cos} -h <header file> -g <section> -d <output layout> -f <file prefix>\n"), ThisProgramName );
    _ftprintf( stderr,TEXT("\n") );
    _ftprintf( stderr,TEXT("  -i <inf file>      - input inf containing list of dependencies\n") );
    _ftprintf( stderr,TEXT("  -c <control inf>   - contains directives for creating list.\n") );
    _ftprintf( stderr,TEXT("  -l <OLE inf>       - contains ole registration directives.\n") );
    _ftprintf( stderr,TEXT("  -o <output file>   - output list\n") );
    _ftprintf( stderr,TEXT("  -g <section>       - SetupAPI INF filtering decoration for per-inf filtering\n") );
    _ftprintf( stderr,TEXT("  -h <header file>   - append this to top of the output list\n") );
    _ftprintf( stderr,TEXT("  -s <section name>  - specifies section in OLE Inf to process\n") );
    _ftprintf( stderr,TEXT("  -d <output layout> - output layout.inf information for SetupAPI INF filtering\n") );
    _ftprintf( stderr,TEXT("  -f <file prefix>   - specifies the decoration to be prepended to filtered files.\n") );
    _ftprintf( stderr,TEXT("  -a <c|o|s>         - specifies filter action\n") );
    _ftprintf( stderr,TEXT("  -u                 - create UNICODE output list (only with /o)\n") );
    _ftprintf( stderr,TEXT("  -n <file>          - create layout file for SourceDisksFiles within the INF (to be appended to INF itself)\n") );
    _ftprintf( stderr,TEXT("\tc - Create copy list.\n") );
    _ftprintf( stderr,TEXT("\to - Create OLE list.\n") );
    _ftprintf( stderr,TEXT("\ts - Create SetupINF list.\n") );
    _ftprintf( stderr,TEXT("\n") );
    _ftprintf( stderr,TEXT("\n") );
}

int
__cdecl
_tmain(
    IN int   argc,
    IN TCHAR *argv[]
    )
{
    FILE *hFileOut,*hFileLayoutOut = NULL, *hFileInfLayoutOut=NULL;
    BOOL b;


    //
    // Assume failure.
    //
    b = FALSE;

    if(!pSetupInitializeUtils()) {
        return FAILURE;
    }

    if(!ParseArgs(argc,argv)) {
        Usage();
        goto exit;
    }

    //
    // Open the output file.
    //
    if( fDoAnsiOutput )
        hFileOut = _tfopen(OutputFile,TEXT("wt"));
    else
        hFileOut = _tfopen(OutputFile,TEXT("wb"));
    if(hFileOut) {

        if (Action == BuildCopyList) {

            _ftprintf(stdout,TEXT("%s: creating copy list %s from %s and %s\n"),
                    ThisProgramName,
                    OutputFile,
                    InputInf,
                    ControlInf);
            b = DoCopyList(
                      InputInf,
                      ControlInf,
                      hFileOut );

        } else if (Action == BuildOLEList) {

            _ftprintf(stdout,
                    TEXT("%s: creating OLE list %s from %s, %s, and %s\n"),
                    ThisProgramName,
                    OutputFile,
                    InputInf,
                    OLEInputInf,
                    ControlInf);

            b = DoOLEList(
                      InputInf,
                      OLEInputInf,
                      ControlInf,
                      hFileOut );

        } else if (Action == BuildSetupINF) {

            if( OutputLayoutFile )
                hFileLayoutOut = _tfopen(OutputLayoutFile,TEXT("wt"));

            // Check if we want to process layout information that needs to be added
            // to the INF itself. This is used for INFs that have their own layout information.
            // This file will get the layout information for thunked files which had 
            // SourceDisksFiles entries within this INF.

            if(OutputInfLayoutFile){

                if( fDoAnsiOutput )
                    hFileInfLayoutOut = _tfopen(OutputInfLayoutFile,TEXT("wt"));
                else
                    hFileInfLayoutOut = _tfopen(OutputInfLayoutFile,TEXT("wb"));

            }

            _ftprintf(stdout,
                    TEXT("%s: creating SetupINF list %s (layout %s) from %s and %s\n"),
                    ThisProgramName,
                    OutputFile,
                    OutputLayoutFile,
                    InputInf,
                    ControlInf);

            b = DoSetupINF(
                      InputInf,
                      ControlInf,
                      hFileOut,
                      hFileLayoutOut, 
                      hFileInfLayoutOut);

            if( hFileLayoutOut )
                fclose( hFileLayoutOut );

            if( hFileInfLayoutOut )
                fclose( hFileInfLayoutOut );

        } else {
            _ftprintf(stderr,TEXT("unknown action."));
            MYASSERT(FALSE);
        }

        fclose(hFileOut);

    } else {
        _ftprintf(stderr,TEXT("%s: Unable to create output file %s\n"),ThisProgramName,OutputFile);
    }


exit:

    pSetupUninitializeUtils();

    return(b ? SUCCESS : FAILURE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\assert1.c ===
#include "precomp.h"
#pragma hdrstop

/***************************************************************************/
/***** Common Library Component - Debug Assert - 1 *************************/
/***************************************************************************/

#if DBG

/*
**  Purpose:
**      Generate a message box with the file name and line number for an
**      Assert() that failed.
**  Arguments:
**      szFile: non-NULL pointer to string containing the name of the source
**          file where the Assert occurred.
**      usLine: the line number where the Assert occurred.
**  Returns:
**      fTrue for success, fFalse otherwise.
**
***************************************************************************/
BOOL  APIENTRY AssertSzUs(SZ szFile,USHORT usLine)
{
    CHP szText[129];

    AssertDataSeg();

    ChkArg(szFile != (SZ)NULL, 1, fFalse);

    wsprintf((LPSTR)szText, (LPSTR)"Assert Failed: File: %.60s, Line: %u",
            (LPSTR)szFile, (INT)usLine);
    MessBoxSzSz("Assertion Failure", szText);

    return(fTrue);
}


/*
**  Purpose:
**      Generate a message box with the file name and line number for a
**      PreCondition() that failed.
**  Arguments:
**      szFile: non-NULL pointer to string containing the name of the source
**          file where the PreCondition occurred.
**      usLine: the line number where the PreCondition occurred.
**  Returns:
**      fTrue if successful, fFalse otherwise.
**
***************************************************************************/
BOOL  APIENTRY PreCondSzUs(SZ szFile,USHORT usLine)
{
    CHP szText[129];

    AssertDataSeg();

    ChkArg(szFile != (SZ)NULL, 1, fFalse);

    wsprintf((LPSTR)szText, (LPSTR)"PreCondition Failed: File: %.60s, Line: %u",
            (LPSTR)szFile, (INT)usLine);
    MessBoxSzSz("PreCondition Failure", szText);

    return(fTrue);
}


/*
**  Purpose:
**      Generate a message box with the argument number that was bad.
**  Arguments:
**      iArg:   the index of the bad argument.
**      szFile: non-NULL string containing name of source file where error
**          occurred.
**      usLine: line number in source file where error occurred.
**  Returns:
**      fTrue if successful, fFalse otherwise.
**
***************************************************************************/
BOOL APIENTRY BadParamUs(USHORT iArg,SZ szFile,USHORT usLine)
{
    CHP szText[129];

    AssertDataSeg();

    ChkArg(szFile != (SZ)NULL, 2, fFalse);

    wsprintf((LPSTR)szText, (LPSTR)"Bad Argument Value:\nNumber %u\n"
          "File: %.60s, Line: %u", (unsigned int)iArg, (LPSTR)szFile,
          (unsigned int)usLine);
    MessBoxSzSz("Bad Argument Value", szText);

    return(fTrue);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\cf.c ===
#include "precomp.h"
#pragma hdrstop
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    cf.c

Abstract:

    1. Contains code to perform simple text substitutions on a text file.
    2. Contains code to append text entries to a text file.

    This module has no external dependencies and is not statically linked
    to any part of Setup.

Author:

    Ted Miller (tedm) July 1991

--*/

BOOL WriteData(HANDLE Handle,PVOID Data,DWORD DataSize);

BOOL
ConfigFileSubstWorker(
    IN LPSTR File,
    IN DWORD NumSubsts,
    IN LPSTR *Substs
    )
{
    LPSTR  CharPtr,old;
    LPSTR  FileBuf=NULL,FileBufEnd;
    DWORD  *StrLenArray;
    DWORD  FileLength = 0xffffffff;
    HANDLE FileHandle = (HANDLE)(-1);
    DWORD  rcID;
    BOOL   Match;
    DWORD  x,i;
    char   CRLF[2];
    BOOL   IsCFGFile;

    #define     ORIGINAL_TEXT(i)            Substs[(2*i)]
    #define     REPLACEMENT_TEXT(i)         Substs[(2*i)+1]
    #define     ORIGINAL_TEXT_LENGTH(i)     StrLenArray[i]

    CRLF[0] = '\r';
    CRLF[1] = '\n';

    if((StrLenArray = SAlloc(NumSubsts * sizeof(DWORD))) == NULL) {
        SetErrorText(IDS_ERROR_DLLOOM);
        return(FALSE);
    }

    for(i=0; i<NumSubsts; i++) {
        ORIGINAL_TEXT_LENGTH(i) = lstrlen(ORIGINAL_TEXT(i));
    }

    if(((FileHandle = CreateFile(File,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,0,NULL)) == (HANDLE)(-1))
    || ((FileLength = GetFileSize(FileHandle,NULL)) == 0xffffffff)
    || ((FileBuf = SAlloc(FileLength+1)) == NULL)
    ||  (ReadFile(FileHandle,FileBuf,FileLength,&i,NULL) == FALSE))
    {
        if(FileBuf != NULL) {
            rcID = IDS_ERROR_READFAILED;
            SFree(FileBuf);
        } else if(FileLength != 0xffffffff) {
            rcID = IDS_ERROR_DLLOOM;
        } else if(FileHandle != (HANDLE)-1) {
            rcID = IDS_ERROR_NOSIZE;
        } else {
            rcID = IDS_ERROR_BADFILE;
        }
        if(rcID != IDS_ERROR_BADFILE) {
            CloseHandle(FileHandle);
        }
        SFree(StrLenArray);
        SetErrorText(rcID);
        return(FALSE);
    }
    CloseHandle(FileHandle);

    if((FileHandle = CreateFile(File,GENERIC_WRITE,0,NULL,TRUNCATE_EXISTING,0,NULL)) == (HANDLE)(-1)) {              // truncate
        SFree(StrLenArray);
        SFree(FileBuf);
        SetErrorText(IDS_ERROR_BADFILE);
        return(FALSE);
    }

    FileBufEnd = FileBuf + FileLength - 1;

    if(*FileBufEnd != '\n') {
        *(FileBufEnd+1) = '\n';
    }

    for(CharPtr = FileBuf; CharPtr <= FileBufEnd; CharPtr++) {
        if(*CharPtr == '\n') {
            *CharPtr = '\0';
        }
    }

    if((x = lstrlen(File)) > 4) {
        IsCFGFile = !lstrcmpi(&File[x-4],".cfg");
    }

    CharPtr = FileBuf-1;

    while(++CharPtr <= FileBufEnd) {         // skips NUL
        while(*CharPtr) {

            if(*CharPtr == '\r') {
                CharPtr++;
                continue;
            }

            // ignore comments in .cfg files

            if(IsCFGFile && (*CharPtr == '/') && (*(CharPtr+1) == '/')) {
                old = CharPtr;
                while(*CharPtr && (*CharPtr != '\r')) {
                    CharPtr++;
                }
                if(!WriteData(FileHandle,old,(DWORD)(CharPtr - old))) {
                    goto xxx_err1;
                }
                if(*CharPtr == '\r') {
                    CharPtr++;
                }
                continue;
            }

            Match = FALSE;

            for(i=0; i<NumSubsts && !Match; i++) {

                if(!strncmp(ORIGINAL_TEXT(i),CharPtr,ORIGINAL_TEXT_LENGTH(i))) {

                    Match = TRUE;

                    if(!WriteData(FileHandle,REPLACEMENT_TEXT(i),lstrlen(REPLACEMENT_TEXT(i)))) {
                        goto xxx_err1;
                    }

                    CharPtr += ORIGINAL_TEXT_LENGTH(i);
                }
            }

            if(!Match) {
                if(!WriteData(FileHandle,CharPtr,1)) {
                    goto xxx_err1;
                }
                CharPtr++;
            }

        }
        if(!WriteData(FileHandle,CRLF,sizeof(CRLF))) {
            goto xxx_err1;
        }
    }

xxx_err1:
    FlushFileBuffers(FileHandle);
    CloseHandle(FileHandle);
    SFree(StrLenArray);
    SFree(FileBuf);

    return(TRUE);
}


BOOL
BinaryFileSubstWorker(
    IN LPSTR File,
    IN DWORD NumSubsts,
    IN LPSTR *Substs
    )
{
    LPSTR  CharPtr;
    LPSTR  FileBuf=NULL;
    DWORD  *StrLenArray;
    DWORD  FileLength = 0xffffffff;
    HANDLE FileHandle = (HANDLE)(-1);
    DWORD  rcID;
    BOOL   Match;
    DWORD  i;

    if((StrLenArray = SAlloc(NumSubsts * sizeof(DWORD))) == NULL) {
        SetErrorText(IDS_ERROR_DLLOOM);
        return(FALSE);
    }

    // make sure original and replacement text are the same length
    // within a given pair

    for(i=0; i<NumSubsts; i++) {
        ORIGINAL_TEXT_LENGTH(i) = lstrlen(ORIGINAL_TEXT(i));
        if(ORIGINAL_TEXT_LENGTH(i) != (DWORD)lstrlen(REPLACEMENT_TEXT(i))) {
            SFree(StrLenArray);
            SetErrorText(IDS_ERROR_BADARGS);
            return(FALSE);
        }
    }

    if(((FileHandle = CreateFile(File,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,0,NULL)) == (HANDLE)(-1))
    || ((FileLength = GetFileSize(FileHandle,NULL)) == 0xffffffff)
    || ((FileBuf = SAlloc(FileLength)) == NULL)
    ||  (ReadFile(FileHandle,FileBuf,FileLength,&i,NULL) == FALSE))
    {
        if(FileBuf != NULL) {
            rcID = IDS_ERROR_READFAILED;
            SFree(FileBuf);
        } else if(FileLength != 0xffffffff) {
            rcID = IDS_ERROR_DLLOOM;
        } else if(FileHandle != (HANDLE)-1) {
            rcID = IDS_ERROR_NOSIZE;
        } else {
            rcID = IDS_ERROR_BADFILE;
        }
        if(rcID != IDS_ERROR_BADFILE) {
            CloseHandle(FileHandle);
        }
        SFree(StrLenArray);
        SetErrorText(rcID);
        return(FALSE);
    }
    CloseHandle(FileHandle);

    if((FileHandle = CreateFile(File,GENERIC_WRITE,0,NULL,TRUNCATE_EXISTING,0,NULL)) == (HANDLE)(-1)) {              // truncate
        SFree(StrLenArray);
        SFree(FileBuf);
        SetErrorText(IDS_ERROR_BADFILE);
        return(FALSE);
    }

    for(CharPtr=FileBuf; CharPtr<FileBuf+FileLength; ) {

        for(Match=FALSE,i=0; i<NumSubsts && !Match; i++) {

            if(!strncmp(ORIGINAL_TEXT(i),CharPtr,ORIGINAL_TEXT_LENGTH(i))) {

                Match = TRUE;

                if(!WriteData(FileHandle,REPLACEMENT_TEXT(i),lstrlen(REPLACEMENT_TEXT(i)))) {
                    goto xxx_err2;
                }

                CharPtr += ORIGINAL_TEXT_LENGTH(i);
            }
        }

        if(!Match) {
            if(!WriteData(FileHandle,CharPtr,1)) {
                goto xxx_err2;
            }
            CharPtr++;
        }
    }

xxx_err2:
    FlushFileBuffers(FileHandle);
    CloseHandle(FileHandle);
    SFree(StrLenArray);
    SFree(FileBuf);

    return(TRUE);
}


BOOL
ConfigFileAppendWorker(
    IN LPSTR File,
    IN DWORD NumSubsts,
    IN LPSTR *Substs
    )
{
    HANDLE    FileHandle;
    DWORD     rcID;
    DWORD     i;
    char      CRLF[2];
    DWORD     OriginalAttributes;
    OFSTRUCT  ReOpen;

    CRLF[0] = '\r';
    CRLF[1] = '\n';


    // See if file exists, if it doesn't open it with create option. else
    // Open existing after modifying attributes to FILE_ATTRIBUTE_NORMAL

    if (OpenFile(File,&ReOpen,OF_EXIST) == -1) {
       OriginalAttributes = FILE_ATTRIBUTE_NORMAL;
       FileHandle = CreateFile(
                       File,
                       GENERIC_READ | GENERIC_WRITE,
                       0,
                       NULL,
                       CREATE_NEW,
                       OriginalAttributes,
                       NULL
                       );

       if (FileHandle == (HANDLE)-1) {
           SetErrorText(IDS_ERROR_BADFILE);
           return(FALSE);
       }
    }
    else {
       // 1. Modify Attributes

       if (!(
             ((OriginalAttributes = GetFileAttributes(File)) != -1L)
             &&
             (
             OriginalAttributes == FILE_ATTRIBUTE_NORMAL
             ||
			    SetFileAttributes(File, FILE_ATTRIBUTE_NORMAL)
             )
            )
          ) {
          SetErrorText(IDS_ERROR_BADFILE);
          return(FALSE);
       }

       // 2. Open the file

       if((FileHandle = CreateFile(
                            File,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL
                            )) == (HANDLE)(-1)) {
          rcID = IDS_ERROR_BADFILE;
          SetErrorText(rcID);
          return(FALSE);
       }

       // 3. Shift file pointer to end

       if(SetFilePointer(
              FileHandle,                  // The File Handle
              0L,                          // Distance to move, low  dword
              0L,                          // Distance to move, high dword
              FILE_END                     // Move Method, (relative to eof)
              ) == (DWORD)-1L){
          rcID = IDS_ERROR_BADFILE;
          CloseHandle(FileHandle);
          SetErrorText(rcID);
          return(FALSE);
       }

    }     // end of else


    // Append all the text entries to the end of the file

    for (i = 0; i < NumSubsts; i++)
        if(!WriteData (FileHandle, Substs[i], lstrlen(Substs[i])) ||
           !WriteData(FileHandle,CRLF,sizeof(CRLF)))
            break;

    // Clean up

    FlushFileBuffers(FileHandle);
    CloseHandle(FileHandle);

    // reset the attributes to the previous attributes

    if(!(OriginalAttributes == FILE_ATTRIBUTE_NORMAL ||
         SetFileAttributes(File, OriginalAttributes)))
          SetErrorText(IDS_ERROR_BADFILE);

    return(TRUE);
}


BOOL
WriteData(
    IN HANDLE Handle,
    IN PVOID  Data,
    IN DWORD  DataSize
    )
{
    BOOL  rc;
    DWORD bw;

    if(!(rc = WriteFile(Handle,Data,DataSize,&bw,NULL))) {
        SetErrorText(IDS_ERROR_WRITE);
    }
    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\billproc.c ===
#include "precomp.h"
#pragma hdrstop
/***************************************************************************/
/****************** Basic Class Dialog Handlers ****************************/
/***************************************************************************/


/*
**  Purpose:
**      Billboard Dialog procedure.
**  Initialization:
**      Post STF_SHL_INTERP to carry on with INF script
**  Termination:
**      None
**
*****************************************************************************/
INT_PTR APIENTRY FGstBillboardDlgProc(HWND hdlg, UINT wMsg, WPARAM wParam,
        LPARAM lParam)
{
    SZ     sz;
    RGSZ   rgsz;
    PSZ    psz;

    Unused(lParam);
    Unused(wParam);

    switch (wMsg) {
    case STF_REINITDIALOG:
    case WM_INITDIALOG:
        AssertDataSeg();

        if( wMsg == WM_INITDIALOG ) {
            FCenterDialogOnDesktop(hdlg);
        }

        //
        // Handle all the text fields in the dialog
        //

        if ((sz = SzFindSymbolValueInSymTab("TextFields")) != (SZ)NULL) {
           WORD idcStatus;

           while ((psz = rgsz = RgszFromSzListValue(sz)) == (RGSZ)NULL) {
              if (!FHandleOOM(hdlg)) {
                    DestroyWindow(GetParent(hdlg));
                    return(fTrue);
              }
           }

           idcStatus = IDC_TEXT1;
           while (*psz != (SZ)NULL && GetDlgItem(hdlg, idcStatus)) {
              SetDlgItemText (hdlg, idcStatus++,*psz++);
           }

           EvalAssert(FFreeRgsz(rgsz));
        }

        return(fTrue);

    case STF_DESTROY_DLG:
        PostMessage(GetParent(hdlg), (WORD)STF_INFO_DLG_DESTROYED, 0, 0L);
        DestroyWindow(hdlg);
        return(fTrue);

    }

    return(fFalse);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\inf\win4\tools\xdosnet\xdosnet.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    dosnet.c

Abstract:

    This module implements a program that generates the [Files]
    section of dosnet.inf.

    The input consists of the layout inf; the output consists of
    an intermediary form of dosnet.inf.

Author:

    Ted Miller (tedm) 20-May-1995

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <setupapi.h>
#include <sputils.h>


//
// Define program result codes (returned from main()).
//
#define SUCCESS 0
#define FAILURE 1


//
// Keep statistics...
//
INT     ProcessedLines = 0;
INT     RemovedEntries = 0;
INT     DuplicateEntries = 0;
INT     PassThroughEntries = 0;

HINF    hExclusionInf = INVALID_HANDLE_VALUE;

BOOL
ParseArgs(
    IN int   argc,
    IN char *argv[]
    )
{
    return(argc > 5);
}


BOOL
IsEntryInFilterFile(
    IN HINF    hFilterinf,
    IN PCWSTR  Inputval
    )
{
INFCONTEXT Context,SectionContext;
PCWSTR     CabName;
WCHAR      SectionName[LINE_LEN];
UINT       Field,
           FieldCount;

    //
    // First make sure we actually have a filter inf.
    // If not, then the entry certainly isn't in there.
    //
    if( !hFilterinf ) {
        return( FALSE );
    }

    //
    // Now get the section names that we have to search.
    //
    if (!SetupFindFirstLineW( hFilterinf, L"Version", L"CabFiles", &SectionContext)) {
        return( FALSE );
    }

    //
    // Search the sections for our entry.
    //
    do {

        FieldCount = SetupGetFieldCount(&SectionContext);
        for( Field=1; Field<=FieldCount; Field++ ) {
            if(SetupGetStringFieldW(&SectionContext,Field,SectionName,LINE_LEN,NULL)
               && SetupFindFirstLineW(hFilterinf, SectionName, Inputval, &Context)) {
                //
                // we found a match
                //
                return( TRUE );
            }
        }

    } while (SetupFindNextMatchLine(&SectionContext,TEXT("CabFiles"),&SectionContext));

    //
    // If we get here, we didn't find a match.
    //
    return( FALSE );
}

void
AddToTempFile(
    PCWSTR FileName,
    PINFCONTEXT InfContext,
    FILE   *TempFile
    ){

    WCHAR BootFloppyval[LINE_LEN];
    UCHAR      line[MAX_INF_STRING_LENGTH];

    if(SetupGetStringFieldW(InfContext,7,BootFloppyval,LINE_LEN,NULL)
            && BootFloppyval[0]){

        WideCharToMultiByte(
                        CP_OEMCP,
                        0,
                        FileName,
                        -1,
                        line,
                        sizeof(line),
                        NULL,
                        NULL
                        );

        fprintf(TempFile,"%s\n",line);
        //fprintf(stderr,"xdosnet: Writing file %s\n",FileName);
    }

    return;

}


BOOL
InExclusionList(
    PCWSTR FileName,
    PINFCONTEXT InfContext
    )
{
    WCHAR BootFloppyval[LINE_LEN];
    INFCONTEXT Ctxt;


    //
    // first look in our global hardcoded exclusion list for the file
    //
    if (hExclusionInf != INVALID_HANDLE_VALUE) {
        if (SetupFindFirstLineW(hExclusionInf, L"Files", FileName, &Ctxt)) {
//            printf("excluding via inf file %ws\n",FileName);
            return(TRUE);
        }
    }

    //
    // now we need to see if this is a boot-disk file, which must be
    // excluded
    //
    if (SetupGetStringFieldW(InfContext,7,BootFloppyval,LINE_LEN,NULL)
            && !BootFloppyval[0]) {
        return(FALSE);
    }

//    printf("excluding boot file %ws\n",FileName);

    return(TRUE);

}

// Returns the DiskId of the file.  This is basically
// 1 or 2 for now.
void pGetDiskIdStr(
	IN INFCONTEXT InputContext,
	IN DWORD DiskID,
	IN PSTR StrDiskID,
	IN DWORD  StrLen
	)
{
	WCHAR      Tmp[20];

    if ( DiskID == -1 )
	{
		if(SetupGetStringFieldW(&InputContext,1,Tmp,sizeof(Tmp)/sizeof(WCHAR),NULL)) 
		{
            // Hack to make the CHS, CHT & KOR builds working.  They use 7 as the
            // diskid for some reason.  This means unless we do this hack the binaries
            // are marked to be on the 7th disk and that creates havoc with winnt.exe
            // not being able to copy stuff etc.
            // The hack is to see if the diskid is 7 and if it is then reset it to
            // 1.  This is what would have happened before the 2CD changes to
            // xdosnet.exe,  makefile.inc in MergedComponents\SetupInfs

            // The hacks continue - 100 is for Service Pack stuff
            if ( ! lstrcmpW(Tmp,L"7") || ! lstrcmpW(Tmp,L"100") )
                lstrcpyW(Tmp, L"1");
		}
		else
		{
			// say it is d1 if the above fails
			lstrcpyW(Tmp,L"1");
		}
	}
	else
	{
		swprintf(Tmp, L"%d", DiskID);
	}
	
	WideCharToMultiByte(
		CP_OEMCP,
		0,
		Tmp,
		-1,
		StrDiskID,
		StrLen,
		NULL,
		NULL
		);
}

BOOL
DoSection(
    IN HINF    hInputinf,
    IN PCWSTR  InputSectionName,
    IN HINF    hFilterinf,
    IN DWORD   DiskID,
    IN FILE   *OutFile,
    IN FILE   *ExcludeFile,
    IN FILE   *TempFile
    )
{
#define VERBOSE 1
INFCONTEXT InputContext;
UCHAR      line[MAX_INF_STRING_LENGTH];
WCHAR      Inputval[MAX_INF_STRING_LENGTH];
BOOL       WriteEntry = TRUE;
UCHAR      StrDiskID[20];


    if(SetupFindFirstLineW(hInputinf,InputSectionName,NULL,&InputContext)) {

        do {

        //
        // Keep track of how many lines we process from the original inf (layout.inf)
        //
        ProcessedLines++;

            if(SetupGetStringFieldW(&InputContext,0,Inputval,MAX_INF_STRING_LENGTH,NULL)) {

                //
                // Assume the entry is good unless proven otherwise.
                //
                WriteEntry = TRUE;

                if( TempFile ) {
                    AddToTempFile( Inputval, &InputContext, TempFile );
                }
                    


                //
                // See if it's in the filter file.
                //
                if( IsEntryInFilterFile( hFilterinf, Inputval ) ) {
                    if (!InExclusionList(Inputval, &InputContext )) {
                        //
                        // It's in the exclusion list.  Skip it.
                        //
                        RemovedEntries++;
                        WriteEntry = FALSE;

                        if (ExcludeFile) {

                            if( WideCharToMultiByte(
                                CP_OEMCP,
                                0,
                                Inputval,
                                -1,
                                line,
                                sizeof(line),
                                NULL,
                                NULL
                                ) ){

                                fprintf(ExcludeFile,"%s\n",line);

                            }

                            

                        }
                    } else {
                        //
                        // It's a boot file.  Keep it.  Note that it's a
                        // duplicate and will appear both inside and outside
                        // the CAB.
                        //
                        DuplicateEntries++;
                    }
                } else {
                    //
                    // It's not even in the filter file.  Log it for
                    // statistics.
                    //
                    PassThroughEntries++;
                }

                //
                // Write the entry out only if it's not supposed to
                // be filtered out.
                //
                if( WriteEntry ) {
                    //
                    // Dosnet.inf is in OEM chars.
                    //
                    WideCharToMultiByte(
                        CP_OEMCP,
                        0,
                        Inputval,
                        -1,
                        line,
                        sizeof(line),
                        NULL,
                        NULL
                        );

					// We need to find the disk this file is on and add that
					// to the file description.
					pGetDiskIdStr(InputContext, DiskID, StrDiskID, sizeof(StrDiskID));

                    fprintf(OutFile,"d%s,%s\n",StrDiskID,line);
                }


            } else {
                fprintf(stderr,"A line in section %ws has no key\n",InputSectionName);
                return(FALSE);
            }
        } while(SetupFindNextLine(&InputContext,&InputContext));

    } else {
        fprintf(stderr,"Section %ws is empty or missing\n",InputSectionName);
        return(FALSE);
    }

    return(TRUE);
}

BOOL
DoIt(
    IN char *InFilename,
    IN char *FilterFilename,
    IN DWORD DiskID,
    IN FILE *OutFile,
    IN FILE *ExcludeFile,
    IN char *PlatformExtension,
    IN FILE *TempFile
    )
{
    PCWSTR inFilename;
    PCWSTR filterFilename;
    PCWSTR extension;
    HINF hInputinf,
         hFilterinf;
    BOOL b;
    WCHAR sectionName[256];
    INFCONTEXT Ctxt;

    b = FALSE;

    inFilename = pSetupAnsiToUnicode(InFilename);
    filterFilename = pSetupAnsiToUnicode(FilterFilename);

    //
    // Only proceed if we've got a file to work with.
    //
    if( inFilename ) {

        //
        // Only proceed if we've got a filter file to work with.
        //
        if( filterFilename ) {

            hInputinf = SetupOpenInfFileW(inFilename,NULL,INF_STYLE_WIN4,NULL);
            if(hInputinf != INVALID_HANDLE_VALUE) {

                //
                // If the filter-file fails, just keep going.  This will
                // result in a big dosnet.inf, which means we'll have files
                // present both inside and outside the driver CAB, but
                // that's not fatal.
                //
                hFilterinf = SetupOpenInfFileW(filterFilename,NULL,INF_STYLE_WIN4,NULL);
                if(hFilterinf == INVALID_HANDLE_VALUE) {
                    fprintf(stderr,"Unable to open inf file %s\n",FilterFilename);
                    hFilterinf = NULL;
                }


                //
                // We're actually ready to process the sections!
                //
                fprintf(OutFile,"[Files]\n");

                if (ExcludeFile) {
                    fprintf(ExcludeFile,"[Version]\n");
                    fprintf(ExcludeFile,"signature=\"$Windows NT$\"\n");
                    fprintf(ExcludeFile,"[Files]\n");
                }


                b = DoSection( hInputinf,
                               L"SourceDisksFiles",
                               hFilterinf,
                               DiskID,
                               OutFile,
                               ExcludeFile,
                               TempFile );

                if( b ) {

                    //
                    // Now process the x86-or-Alpha-specific section.
                    //
                    if(extension = pSetupAnsiToUnicode(PlatformExtension)) {

                        lstrcpyW(sectionName,L"SourceDisksFiles");
                        lstrcatW(sectionName,L".");
                        lstrcatW(sectionName,extension);
                        b = DoSection( hInputinf,
                                       sectionName,
                                       hFilterinf,
                                       DiskID,
                                       OutFile,
                                       ExcludeFile,
                                       TempFile );

                        pSetupFree(extension);
                    } else {
                        fprintf(stderr,"Unable to convert string %s to Unicode\n",PlatformExtension);
                    }
                }

                //Write the files in the input exclude INF to the [ForceCopyDriverCabFiles] section

                if (hExclusionInf != INVALID_HANDLE_VALUE) {

                    WCHAR Filename[LINE_LEN];
                    UCHAR line[MAX_INF_STRING_LENGTH];


                    if (SetupFindFirstLineW(hExclusionInf, L"Files", NULL, &Ctxt)){


                        fprintf(OutFile,"\n\n[ForceCopyDriverCabFiles]\n");


                        do{

                            if( SetupGetStringFieldW( &Ctxt, 1, Filename, LINE_LEN, NULL )){


                                //
                                // Dosnet.inf is in OEM chars.
                                //
                                WideCharToMultiByte(
                                    CP_OEMCP,
                                    0,
                                    Filename,
                                    -1,
                                    line,
                                    sizeof(line),
                                    NULL,
                                    NULL
                                    );

                                
                                fprintf(OutFile,"%s\n",line);

                            }


                        }while( SetupFindNextLine( &Ctxt, &Ctxt ));

                    }else{

                        fprintf(stderr,"Could not find the Files section in the Exclude INF file\n");
                    }

                    

                }


                //
                // Print Statistics...
                //
                fprintf( stderr, "                               Total lines processed: %6d\n", ProcessedLines );
                fprintf( stderr, "                     Entries removed via filter file: %6d\n", RemovedEntries );
                fprintf( stderr, "Entries appearing both inside and outside driver CAB: %6d\n", DuplicateEntries );
                fprintf( stderr, "                Entries not appearing in filter file: %6d\n", PassThroughEntries );

                //
                // Close up our inf handles.
                //
                if( hFilterinf ) {
                    SetupCloseInfFile( hFilterinf );
                }
                SetupCloseInfFile(hInputinf);

            } else {
                fprintf(stderr,"Unable to open inf file %s\n",InFilename);
            }

            pSetupFree( filterFilename );

        } else {
            fprintf(stderr,"Unable to convert filename %s to Unicode\n",FilterFilename);
        }
        pSetupFree(inFilename);
    } else {
        fprintf(stderr,"Unable to convert filename %s to Unicode\n",InFilename);
        return(FALSE);
    }

    return(b);
}


int
__cdecl
main(
    IN int   argc,
    IN char *argv[]
    )
{
    FILE *OutputFile,*ExcludeFile, *TempFile;
    BOOL b;
    DWORD DiskID;
    char input_filename_fullpath[MAX_PATH];
    char *p;

    //
    // Assume failure.
    //
    b = FALSE;

    if(!pSetupInitializeUtils()) {
        return FAILURE;
    }

    if(ParseArgs(argc,argv)) {

        //
        // Open the output file.
        //
        OutputFile = fopen(argv[4],"wt");
        
        if (argc >= 7) {
            ExcludeFile = fopen(argv[6],"wt");
        } else {
            ExcludeFile = NULL;
        }

        if (argc >= 8) {
            hExclusionInf = SetupOpenInfFileA(argv[7],NULL,INF_STYLE_WIN4,NULL);
            if (hExclusionInf != INVALID_HANDLE_VALUE) {
                fprintf(stderr,"xdosnet: Opened file %s\n",argv[7]);
            }
            
        } else {
            hExclusionInf = INVALID_HANDLE_VALUE;
        }

        if (argc >= 9) {
            TempFile = fopen(argv[8],"wt");
            if( !TempFile )
                fprintf(stderr,"%s: Unable to create temp file %s\n",argv[0],argv[8]);
            //fprintf(stderr,"xdosnet: Created file %s\n",argv[8]);
        }else{
            TempFile = NULL;
        }

		// Special case handling Disk 1, Disk 2 etc. for x86.  Since we want to process
		// all lines - this just means ignore the disk id specified on the command line
		// and pick up the Disk ID that is specified in the layout.inx entry itself.
        if ( argv[3][0] == '*' )
			DiskID = -1;
		else
			DiskID = atoi(argv[3]);

        GetFullPathName(
                argv[1],
                sizeof(input_filename_fullpath),
                input_filename_fullpath,
                &p);


        if(OutputFile) {

            fprintf(
                stdout,
                "%s: creating %s from %s and %s for %s (%s)\n",
                argv[0],
                argv[4],
                input_filename_fullpath,
                argv[2],
                argv[5],
                argv[6]);

            b = DoIt( input_filename_fullpath,
                      argv[2],
                      DiskID,
                      OutputFile,
                      ExcludeFile,
                      argv[5],
                      TempFile);

            fclose(OutputFile);

        } else {
            fprintf(stderr,"%s: Unable to create output file %s\n",argv[0],argv[3]);
        }

        if (ExcludeFile) {
	    fclose(ExcludeFile);
        }
        if (TempFile) {
	    fclose(TempFile);
        }

    } else {
        fprintf( stderr,"Merge 3 inf files.  Usage:\n" );
        fprintf( stderr,"%s  <input file1> <filter file> <diskid> <output file> <platform extension> <optional output exclude file> <optional input exclusion inf>\n", argv[0] );
        fprintf( stderr,"\n" );
        fprintf( stderr,"  <input file1> - original inf file (i.e. layout.inf)\n" );
        fprintf( stderr,"  <filter file> - contains a list of entries to be excluded\n" );
        fprintf( stderr,"                  from the final output file\n" );
        fprintf( stderr,"  <disk id>     - output disk id (i.e. 1 or 2)\n" );
        fprintf( stderr,"  <output file> - output inf (i.e. dosnet.inf)\n" );
        fprintf( stderr,"  <platform extension>\n" );
        fprintf( stderr,"  <output exclude file> - optional output file containing files that were filtered\n" );
        fprintf( stderr,"  <input exclusion inf> - optional input inf containing files that should never be filtered\n" );
        fprintf( stderr,"  <temp file> - optional file to be used to write boot file list into (IA64 temporary workaround)\n");
        fprintf( stderr,"\n" );
        fprintf( stderr,"\n" );

    }

    pSetupUninitializeUtils();

    return(b ? SUCCESS : FAILURE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\chckproc.c ===
#include "precomp.h"
#pragma hdrstop
/***************************************************************************/
/****************** Basic Class Dialog Handlers ****************************/
/***************************************************************************/



/*
**  Purpose:
**      CheckBox Dialog procedure for templates with one to ten checkbox
**      controls.
**  Control IDs:
**      The Checkbox controls must have sequential ids starting with IDC_B1
**          and working up to a maximum of IDC_B10.
**      Pushbuttons recognized are IDC_O, IDC_C, IDC_M, IDC_H, IDC_X, and IDC_B.
**  Initialization:
**      The symbol $(CheckItemsIn) is evaluated as a list of elements of
**          either 'ON' or 'OFF'.  So examples for a template with four
**          checkbox controls would include {ON, ON, ON, ON},
**          {ON, OFF, ON, OFF} and {OFF, OFF, OFF, OFF}.  These elements
**          determine if the initial state of the corresponding checkbox
**          control is checked (ON) or unchecked (OFF).  If there are more
**          controls than elements, the extra controls will be initialized
**          as unchecked.  If there are more elements than controls, the
**          extra elements are ignored.
**      The symbol $(OptionsGreyed) is evaluated as a list of indexes
**          (one-based) of check boxes to be disabled (greyed).  Default is
**          none.
**  Termination:
**      The state of each checkbox is queried and a list with the same format
**          as the initialization list is created and stored in the symbol
**          $(CheckItemsOut).
**      The id of the Pushbutton (eg IDC_C) which caused termination is
**          converted to a string and stored in the symbol $(ButtonPressed).
**
*****************************************************************************/
INT_PTR APIENTRY FGstCheckDlgProc(HWND   hdlg,
                                  UINT   wMsg,
                                  WPARAM wParam,
                                  LPARAM lParam)
{
    CHP  rgchNum[10];
    WORD idc;
    RGSZ rgsz;
    PSZ  psz;
    SZ   sz;

    Unused(lParam);

    switch (wMsg) {
    case STF_REINITDIALOG:
        return(fTrue);

    case WM_INITDIALOG:
        AssertDataSeg();

        if( wMsg == WM_INITDIALOG ) {
            FCenterDialogOnDesktop(hdlg);
        }

        if ((sz = SzFindSymbolValueInSymTab("CheckItemsIn")) == (SZ)NULL)
            {
            PreCondition(fFalse, fTrue);
            return(fTrue);
            }

        while ((psz = rgsz = RgszFromSzListValue(sz)) == (RGSZ)NULL)
            if (!FHandleOOM(hdlg))
                {
                DestroyWindow(GetParent(hdlg));
                return(fTrue);
                }

        idc = IDC_B1;
        while (*psz != (SZ)NULL)
            {
            WORD wCheck = 0;

            if (CrcStringCompare(*(psz++), "ON") == crcEqual)
                wCheck = 1;
            CheckDlgButton(hdlg, idc++, wCheck);
            }

        EvalAssert(FFreeRgsz(rgsz));

        if ((sz = SzFindSymbolValueInSymTab("OptionsGreyed")) == (SZ)NULL)
            {
            PreCondition(fFalse, fTrue);
            return(fTrue);
            }

        while ((psz = rgsz = RgszFromSzListValue(sz)) == (RGSZ)NULL)
            if (!FHandleOOM(hdlg))
                {
                DestroyWindow(GetParent(hdlg));
                return(fTrue);
                }

        while (*psz != (SZ)NULL)
            {
            SZ  sz = *(psz++);
            INT i  = atoi(sz);

            if (i > 0 && i <= 10)
                EnableWindow(GetDlgItem(hdlg, IDC_B0 + i), 0);
            else if (*sz != '\0')
                PreCondition(fFalse, fTrue);
            }

        EvalAssert(FFreeRgsz(rgsz));
        return(fTrue);


    case WM_CLOSE:
        PostMessage(
            hdlg,
            WM_COMMAND,
            MAKELONG(IDC_X, BN_CLICKED),
            0L
            );
        return(fTrue);

    case WM_COMMAND:
        switch (LOWORD(wParam))
            {
        case IDC_B1:
        case IDC_B2:
        case IDC_B3:
        case IDC_B4:
        case IDC_B5:
        case IDC_B6:
        case IDC_B7:
        case IDC_B8:
        case IDC_B9:
        case IDC_B10:
            CheckDlgButton(hdlg, LOWORD(wParam),
                    (UINT)!IsDlgButtonChecked(hdlg, (UINT)wParam));
            break;

        case IDCANCEL:
            if (LOWORD(wParam) == IDCANCEL) {

                if (!GetDlgItem(hdlg, IDC_B) || HIWORD(GetKeyState(VK_CONTROL)) || HIWORD(GetKeyState(VK_SHIFT)) || HIWORD(GetKeyState(VK_MENU)))
                {
                    break;
                }
                wParam = IDC_B;

            }
        case IDC_O:
        case IDC_C:
        case IDC_M:
        case IDC_B:
        case IDC_X:
        case IDC_BTN0:
        case IDC_BTN1: case IDC_BTN2: case IDC_BTN3:
        case IDC_BTN4: case IDC_BTN5: case IDC_BTN6:
        case IDC_BTN7: case IDC_BTN8: case IDC_BTN9:
            _itoa((INT)wParam, rgchNum, 10);
            while (!FAddSymbolValueToSymTab("ButtonPressed", rgchNum))
                if (!FHandleOOM(hdlg))
                    {
                    DestroyWindow(GetParent(hdlg));
                    return(fTrue);
                    }

            while ((psz = rgsz = (RGSZ)SAlloc((CB)(11 * sizeof(SZ)))) ==
                    (RGSZ)NULL)
                if (!FHandleOOM(hdlg))
                    {
                    DestroyWindow(GetParent(hdlg));
                    return(fTrue);
                    }

            for (idc = IDC_B1; GetDlgItem(hdlg, idc); psz++, idc++)
                {
                BOOL fChecked = IsDlgButtonChecked(hdlg, idc);

                while ((*psz = SzDupl(fChecked ? "ON" : "OFF")) == (SZ)NULL)
                    if (!FHandleOOM(hdlg))
                        {
                        DestroyWindow(GetParent(hdlg));
                        return(fTrue);
                        }
                }
            *psz = (SZ)NULL;

            while ((sz = SzListValueFromRgsz(rgsz)) == (SZ)NULL)
                if (!FHandleOOM(hdlg))
                    {
                    DestroyWindow(GetParent(hdlg));
                    return(fTrue);
                    }
            while (!FAddSymbolValueToSymTab("CheckItemsOut", sz))
                if (!FHandleOOM(hdlg))
                    {
                    DestroyWindow(GetParent(hdlg));
                    return(fTrue);
                    }

            SFree(sz);
            EvalAssert(FFreeRgsz(rgsz));
            PostMessage(GetParent(hdlg), (WORD)STF_UI_EVENT, 0, 0L);
            break;
            }
        break;

    case STF_DESTROY_DLG:
        PostMessage(GetParent(hdlg), (WORD)STF_CHECK_DLG_DESTROYED, 0, 0L);
        DestroyWindow(hdlg);
        return(fTrue);

    }


    return(fFalse);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\cmnds.h ===
/* File: cmnds.h */
/**************************************************************************/
/*  Install: Commands Header File.
/**************************************************************************/


#define szNull ((SZ)NULL)

/*  Returns the number of lines in the given section
*/
#define CLinesFromInfSection(szSect)    CKeysFromInfSection((szSect), fTrue)



/*  CoMmand Options
*/
typedef BYTE CMO;
#define cmoVital     1
#define cmoOverwrite 2
#define cmoAppend    4
#define cmoPrepend   8
#define cmoNone   0x00
#define cmoAll    0xFF

  /* filecm.c */
extern BOOL  APIENTRY FCopyFilesInCopyList(HANDLE);

#ifdef UNUSED
extern BOOL  APIENTRY FBackupSectionFiles(SZ, SZ);
extern BOOL  APIENTRY FBackupSectionKeyFile(SZ, SZ, SZ);
extern BOOL  APIENTRY FBackupNthSectionFile(SZ, USHORT, SZ);
extern BOOL  APIENTRY FRemoveSectionFiles(SZ, SZ);
extern BOOL  APIENTRY FRemoveSectionKeyFile(SZ, SZ, SZ);
extern BOOL  APIENTRY FRemoveNthSectionFile(SZ, USHORT, SZ);
#endif // UNUSED


extern BOOL  APIENTRY FCreateDir(SZ, CMO);
extern BOOL  APIENTRY FRemoveDir(SZ, CMO);

/* inicm.c */
extern BOOL  APIENTRY FCreateIniSection(SZ, SZ, CMO);
extern BOOL  APIENTRY FReplaceIniSection(SZ, SZ, SZ, CMO);
extern BOOL  APIENTRY FRemoveIniSection(SZ, SZ, CMO);
extern BOOL  APIENTRY FCreateIniKeyNoValue(SZ, SZ, SZ, CMO);
extern BOOL  APIENTRY FCreateIniKeyValue(SZ, SZ, SZ, SZ, CMO);
extern BOOL  APIENTRY FReplaceIniKeyValue(SZ, SZ, SZ, SZ, CMO);
extern BOOL  APIENTRY FAppendIniKeyValue(SZ, SZ, SZ, SZ, CMO);
extern BOOL  APIENTRY FRemoveIniKey(SZ, SZ, SZ, CMO);
extern BOOL  APIENTRY FCreateSysIniKeyValue(SZ, SZ, SZ, SZ, CMO);
extern BOOL  APIENTRY FAddDos5Help(SZ, SZ, CMO);


/* progcm.c */
extern BOOL  APIENTRY FCreateProgManGroup(SZ, SZ, CMO, BOOL);
extern BOOL  APIENTRY FRemoveProgManGroup(SZ, CMO, BOOL);
extern BOOL  APIENTRY FShowProgManGroup(SZ, SZ, CMO, BOOL);
extern BOOL  APIENTRY FCreateProgManItem(SZ, SZ, SZ, SZ, INT, CMO, BOOL);
extern BOOL  APIENTRY FRemoveProgManItem(SZ, SZ, CMO, BOOL);
// extern BOOL  APIENTRY EndProgmanDde(VOID);

/* misccm.c */

extern BOOL  APIENTRY FSetEnvVariableValue(SZ, SZ, SZ, CMO);
#ifdef UNUSED
extern BOOL  APIENTRY FAddMsgToSystemHelpFile(SZ, SZ, CMO);
#endif /* UNUSED */
extern BOOL  APIENTRY FStampFile(SZ, SZ, SZ, WORD, WORD, SZ, WORD);
extern BOOL  APIENTRY FStampResource(SZ, SZ, SZ, WORD, WORD, SZ, CB);  // 1632

/* extprog.c */

       BOOL FLoadLibrary(SZ DiskName,SZ File,SZ INFVar);
       BOOL FFreeLibrary(SZ INFVar);
       BOOL FLibraryProcedure(SZ INFVar,SZ HandleVar,SZ EntryPoint,RGSZ Args);
       BOOL FRunProgram(SZ,SZ,SZ,SZ,RGSZ);
       BOOL FStartDetachedProcess(SZ,SZ,SZ,SZ,RGSZ);
       BOOL FInvokeApplet(SZ);

/* event.c */
       BOOL FWaitForEvent(IN LPSTR InfVar,IN LPSTR EventName,IN DWORD Timeout);
       BOOL FSignalEvent(IN LPSTR InfVar,IN LPSTR EventName);
       BOOL FSleep(IN DWORD Milliseconds);

/* registry.c */

#define REGLASTERROR    "RegLastError"

       BOOL FCreateRegKey( SZ szHandle, SZ szKeyName, UINT TitleIndex, SZ szClass,
                           SZ Security, UINT Access, UINT Options, SZ szNewHandle,
                           CMO cmo );
       BOOL FOpenRegKey( SZ szHandle, SZ szMachineName, SZ szKeyName, UINT Access, SZ szNewHandle, CMO cmo );
       BOOL FFlushRegKey( SZ szHandle, CMO cmo );
       BOOL FCloseRegKey( SZ szHandle, CMO cmo );
       BOOL FDeleteRegKey( SZ szHandle, SZ szKeyName, CMO cmo );
       BOOL FDeleteRegTree( SZ szHandle, SZ szKeyName, CMO cmo );
       BOOL FEnumRegKey( SZ szHandle, SZ szInfVar, CMO cmo );
       BOOL FSetRegValue( SZ szHandle, SZ szValueName, UINT TitleIndex, UINT ValueType,
                          SZ szValueData, CMO cmo );
       BOOL FGetRegValue( SZ szHandle, SZ szValueName, SZ szInfVar, CMO cmo );
       BOOL FDeleteRegValue( SZ szHandle, SZ szValueName, CMO cmo );
       BOOL FEnumRegValue( SZ szHandle, SZ szInfVar, CMO cmo );


/* bootini.c */

       BOOL FChangeBootIniTimeout(INT Timeout);


/* restore.c */

//       BOOL SaveRegistryHives();
//       BOOL GenerateRepairDisk(PCHAR Drive);
//       BOOL CopyFilesToRepairDisk(PCHAR Drive);
//       BOOL SaveVdmFiles();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\dcmds.h ===
/* File: dcmds.h */

/**************************************************************************/
/***** DETECT COMPONENT - Header file for detect commands
/**************************************************************************/

/* Null pointer defs */
#define pbNull ((PB)NULL)
#define szNull ((SZ)NULL)
#define rgszNull ((RGSZ)NULL)
#define pfhNull ((PFH)NULL)
#define hNull ((HANDLE)NULL)

/* Size of buffer for receive ltoa() strings */
#define cbLongStrMax 33

/* Detect command Return Code */
typedef USHORT DRC;

/* From: files.c */
CB  APIENTRY CbBoolResultStr(BOOL, SZ, CB);
CB  APIENTRY CbLongResultStr(LONG, SZ, CB);

/* From: sys1.c */
SZ FAR PASCAL SzGetEnv(SZ);
CCHP FAR PASCAL CchpStrDelim(SZ, SZ);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\dcmpstub.c ===
#include "precomp.h"
#pragma hdrstop
/*
 * Stubs for decompression routines.  They just copy the file instead of
 * decompressing it.
 *
 * Only routines actually used by the toolkit are included.
 */


#define     MIN_BUFFER_SIZE             2048        // must be a multiple of 2
#define     MAX_BUFFER_SIZE             (2*65536)   // must be a multiple of 2

LONG
LcbCopyFile(
    HANDLE    fhSrc,
    HANDLE    fhDest,
    PFNWFROMW pfn,
    INT       cProgTicks
    )
{
    BYTE  StaticBuffer[MIN_BUFFER_SIZE],*CopyBuffer;
    DWORD br,bw;
    DWORD BufferSize,FileSize,TicksPerCycle=0;
    LONG  DistanceHigh = 0L;
    LONG  RC;

    if((FileSize = GetFileSize(fhSrc,NULL)) == (DWORD)(-1)) {
        return(rcReadError);
    }

    //
    // Rewind to beginning of file
    //

    if(SetFilePointer(fhSrc, 0L, &DistanceHigh, FILE_BEGIN) == 0xFFFFFFFF) {
        return (rcReadSeekError);
    }

    BufferSize = MAX_BUFFER_SIZE;
    while((BufferSize > MIN_BUFFER_SIZE)
    && ((CopyBuffer = SAlloc(BufferSize)) == NULL))
    {
        BufferSize /= 2;
    }
    if(CopyBuffer == NULL) {
        CopyBuffer = StaticBuffer;
        BufferSize = sizeof(StaticBuffer);
    }

    if(FileSize) {
        TicksPerCycle = BufferSize*(DWORD)cProgTicks/FileSize;
    }
    if(TicksPerCycle > (DWORD)cProgTicks) {
        TicksPerCycle = (DWORD)cProgTicks;
    }

    while(1) {

        if(!ReadFile(fhSrc,CopyBuffer,BufferSize,&br,NULL)) {
            RC = rcReadError;
            break;
        } else if(!br) {        // ReadFile returned TRUE and bytesread = 0
            RC = rcNoError;
            break;
        }

        FYield();
        if ( fUserQuit ) {
            RC = rcUserQuit;
            break;
        }

        if(!WriteFile(fhDest,CopyBuffer,br,&bw,NULL) || (br != bw)) {
            // the !RC test guesses that br != bw means disk full
            if(((RC = GetLastError()) == ERROR_DISK_FULL) || !RC) {
                RC = rcDiskFull;
            } else {
                RC = rcWriteError;
            }
            break;
        }

        FYield();
        if ( fUserQuit ) {
            RC = rcUserQuit;
            break;
        }

        if(pfn != NULL) {
            pfn(TicksPerCycle);
        }
    }
    if(CopyBuffer != StaticBuffer) {
        SFree(CopyBuffer);
    }
    return(RC);
}


LONG
LcbDecompFile(
    HANDLE    fhSrc,
    HANDLE    fhDest,
    PFNWFROMW pfn,
    INT       cProgTicks
    )
{
    BYTE  StaticBuffer[MIN_BUFFER_SIZE],*CopyBuffer;
    DWORD br,bw;
    DWORD BufferSize,FileSize,TicksPerCycle=0;
    LONG  RC;


    //
    // Use seek to determine file length
    //

    if(( RC = LZSeek( HandleToUlong(fhSrc), 0L, 2 ) )  < 0) {
        return (rcReadSeekError);
    }

    FileSize = (DWORD)RC;

    //
    // Rewind to beginning of file
    //

    if(( RC = LZSeek( HandleToUlong(fhSrc), 0L, 0 ) )  < 0) {
        return (rcReadSeekError);
    }

    //
    // Copy source file to destination file BufferSize at a time
    //

    BufferSize = MAX_BUFFER_SIZE;
    while((BufferSize > MIN_BUFFER_SIZE)
    && ((CopyBuffer = SAlloc(BufferSize)) == NULL))
    {
        BufferSize /= 2;
    }
    if(CopyBuffer == NULL) {
        CopyBuffer = StaticBuffer;
        BufferSize = sizeof(StaticBuffer);
    }

    if(FileSize) {
        TicksPerCycle = BufferSize*(DWORD)cProgTicks/FileSize;
    }
    if(TicksPerCycle > (DWORD)cProgTicks) {
        TicksPerCycle = (DWORD)cProgTicks;
    }

    while(1) {

        if((RC = LZRead( HandleToUlong(fhSrc),CopyBuffer,BufferSize) ) < 0) {
            RC = rcReadError;
            break;
        } else if(!RC) {        // No error and bytesread = 0
            RC = rcNoError;
            break;
        }

        br = (DWORD)RC;

        FYield();
        if ( fUserQuit ) {
            RC = rcUserQuit;
            break;
        }

        if(!WriteFile(fhDest,CopyBuffer,br,&bw,NULL) || (br != bw)) {
            // the !RC test guesses that br != bw means disk full
            if(((RC = GetLastError()) == ERROR_DISK_FULL) || !RC) {
                RC = rcDiskFull;
            } else {
                RC = rcWriteError;
            }
            break;
        }

        FYield();
        if ( fUserQuit ) {
            RC = rcUserQuit;
            break;
        }

        if(pfn != NULL) {
            pfn(TicksPerCycle);
        }
    }
    if(CopyBuffer != StaticBuffer) {
        SFree(CopyBuffer);
    }
    return(RC);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\context.c ===
#include "precomp.h"
#pragma hdrstop
/*********************************************************************/
/***** Common Library Component - Context Handling Routines 1 ********/
/*********************************************************************/



//
//  Global variables
//
PINFCONTEXT     pContextTop      = NULL;
PINFCONTEXT     pContextBottom   = NULL;
PINFPERMINFO    pInfPermInfoHead = NULL;
PINFPERMINFO    pInfPermInfoTail = NULL;
PPARSED_INF     pParsedInfCache  = NULL;
INT             ParsedInfCached  = 0;


//
//  Maximum number of parsed INFs that we keep in the cache
//
#define INF_CACHE_THRESHOLD     4



/*
**  Purpose:
**      Pushes INF context onto stack
**
**  Arguments:
**      Context to push
**
**  Returns:
**      True if pushed.
**
**
**************************************************************************/
BOOL    APIENTRY    PushContext( PINFCONTEXT pContext )
{

    SZ      szHelpContext;
    BOOL    fOkay           =   fTrue;


    //
    //  Set the per-context information
    //
    if ( pContextTop ) {

        if ( pContextTop->szHelpFile ) {
            while ((pContext->szHelpFile = SzDupl(pContextTop->szHelpFile )) == (SZ)NULL) {
                if (!FHandleOOM(hWndShell)) {
                    pContext->szHelpFile = NULL;
                    return fFalse;
                }
            }
        } else {
            pContext->szHelpFile = NULL;
        }

        pContext->pseflHead      =   NULL;
        pContext->dwLowContext   =   pContextTop->dwLowContext;
        pContext->dwHighContext  =   pContextTop->dwHighContext;
        pContext->dwHelpIndex    =   pContextTop->dwHelpIndex;
        pContext->bHelpIsIndexed =   pContextTop->bHelpIsIndexed;
        szHelpContext            =   SzFindSymbolValueInSymTab("HelpContext");

    } else {

        pContext->pseflHead      =   NULL;
        pContext->szHelpFile     =   NULL;
        pContext->dwLowContext   =   0;
        pContext->dwHighContext  =   0;
        pContext->dwHelpIndex    =   0;
        pContext->bHelpIsIndexed =   fFalse;
        szHelpContext            =   NULL;
    }



    //
    //  Allocate the local symbol table
    //

    if ( !(pContext->SymTab  = SymTabAlloc()) ) {
        if ( pContext->szHelpFile ) {
            SFree( pContext->szHelpFile );
            pContext->szHelpFile = NULL;
        }

        return fFalse;
    }


    //
    //  Push context onto stack
    //
    pContext->pNext = pContextTop;
    pContextTop     = pContext;

    if ( !pContextBottom ) {
        pContextBottom = pContextTop;
    }


    //
    //  Add to the symbol table any per-context values.
    //
    if ( szHelpContext ) {
        while (!FAddSymbolValueToSymTab("HelpContext", szHelpContext)) {
            if (!FHandleOOM(hWndShell)) {
                PopContext();
                fOkay = fFalse;
                break;
            }
        }
    }

    while (!FAddSymbolValueToSymTab("$ShellCode", "0")) {
        if (!FHandleOOM(hWndShell)) {
            PopContext();
            fOkay = fFalse;
            break;
        }
    }

    return fOkay;
}




/*
**  Purpose:
**      Pops a context off the stack
**
**  Arguments:
**      none
**
**  Returns:
**      Popped context
**
**
**************************************************************************/
PINFCONTEXT APIENTRY    PopContext( VOID )
{
    PINFCONTEXT pContext = pContextTop;

    pContextTop = pContext->pNext;

    return pContext;
}




/*
**  Purpose:
**      Frees memory of a context
**
**  Arguments:
**      Pointer to context
**
**  Returns:
**      nothing
**
**
**************************************************************************/
VOID    APIENTRY    FreeContext( PINFCONTEXT pContext )
{
    //
    //  Free per-context information
    //
    if ( pContext->pseflHead ) {

        PSEFL   psefl = pContext->pseflHead;
        PSEFL   pseflNext;

        while ( psefl ) {
            pseflNext = psefl->pseflNext;
            FFreePsefl(psefl);
            psefl = pseflNext;
        }
    }

    if ( pContext->szHelpFile ) {
        SFree( pContext->szHelpFile );
    }

    if ( pContext->szShlScriptSection ) {
        SFree( pContext->szShlScriptSection );
    }

    //
    //  Free local symbol table
    //
    FFreeSymTab( pContext->SymTab );

    //
    //  Free context
    //
    SFree( pContext );
}




/*
**  Purpose:
**      Given an INF name, returns a pointer to the corresponding
**      INF permanent information block. It creates a new permanent
**      information block if none exists for the name provided.
**
**  Arguments:
**      INF name
**
**  Returns:
**      Pointer to INF permanent information block.
**
**
**************************************************************************/
PINFPERMINFO APIENTRY NameToInfPermInfo( SZ szName , BOOL AllocIfNotPresent)
{
    PINFPERMINFO  pInfo;

    if ( pInfPermInfoHead ) {

        pInfo = pInfPermInfoHead;

        while ( pInfo ) {

            if (CrcStringCompare( szName, pInfo->szName ) == crcEqual) {
                return pInfo;
            }
            pInfo = pInfo->pNext;
        }
    }

    if( AllocIfNotPresent ) {
        return AddInfPermInfo( szName );
    }
    else {
        return (PINFPERMINFO)NULL;
    }
}




/*
**  Purpose:
**      Adds a new INF permanent information block with the given INF
**      name.
**
**  Arguments:
**      INF name
**
**  Returns:
**      Pointer to the INF permanent information block.
**
**
**************************************************************************/
PINFPERMINFO APIENTRY AddInfPermInfo( SZ szName )
{

    PINFPERMINFO    pInfo;
    SZ              szInfName;

    if ( (pInfo = (PINFPERMINFO)SAlloc( sizeof( INFPERMINFO ) )) != NULL ) {

        if ( (szInfName = (SZ)SAlloc( lstrlen( szName ) + 1 )) != NULL) {

            strcpy( szInfName, szName );


            pInfo->szName     = szInfName;
            pInfo->psdleHead  = NULL;
            pInfo->psdleCur   = NULL;
            pInfo->pclnHead   = NULL;
            pInfo->ppclnTail  = &(pInfo->pclnHead);
            pInfo->pNext      = NULL;
            pInfo->pstfHead   = NULL;

            if ( pInfPermInfoTail ) {

                pInfo->InfId            = pInfPermInfoTail->InfId+1;
                pInfPermInfoTail->pNext = pInfo;
                pInfPermInfoTail        = pInfo;

            } else {

                pInfo->InfId = 0;
                pInfPermInfoHead = pInfPermInfoTail = pInfo;
            }

            return pInfo;
        }

        SFree( pInfo);
    }

    return NULL;
}



/*
**  Purpose:
**      Given the path of an INF file, obtains the INF name (i.e. the
**      name of the file without extension.
**
**  Arguments:
**      Path to inf file
**      Pointer to buffer where the INF name will be stored
**
**  Returns:
**      TRUE if name obtained.
**
**
**************************************************************************/
BOOL APIENTRY PathToInfName( SZ szPath, SZ szName )
{
    PCHAR p,r,q;

    p = r = szPath + strlen(szPath) - 1;
    while ( (p >= szPath) && (*p != '\\') && (*p != ':') ) {
        p--;
    }
    p++;
    q = p;
    while ( (q <= r) && (*q != '.') && (*q != '\0') ) {
        q++;
    }
    memcpy( szName, p, (size_t)(q-p) );
    szName[q-p] = '\0';
    SzStrUpper( szName );

    return fTrue;

}



/*
**  Purpose:
**      Determines what symbol table to use for a given symbol
**
**  Arguments:
**      szSymbol: non-NULL, non-empty zero terminated string containing
**          the value of the symbol to be searched for.
**
**
**
**      Syntax:
**
**      VarName  := [![<Modifier>:]]Name
**
**      Modifier := L | G | P | S
**
**
**      L = Local   (this context)
**      G = Global  (top context)
**      P = Parent  (parent context)
**      S = Static  (INF temp. info)
**
**
**
**  Returns:
**      Pointer to the context in which to look for the symbol
**
**
**************************************************************************/
PSYMTAB  APIENTRY PInfSymTabFind( SZ szSymbol, SZ *szRealSymbol )
{


    SZ          p;
    PSYMTAB     pSymTab = NULL;

    p = szSymbol;

    if ( p && *p != '\0' ) {

        if ( *p == '!' ) {

            p++;

            if ( (strlen(p) > 2) && (*(p+1) == ':') ) {

                switch ( *p ) {

                case 'G':
                case 'g':
                    //
                    //  Global
                    //
                    pSymTab         = pGlobalContext()->SymTab;
                    *szRealSymbol   = p+2;
                    break;

                case 'L':
                case 'l':
                    //
                    //  Local
                    //
                    pSymTab         = pLocalContext()->SymTab;
                    *szRealSymbol   = p+2;
                    break;

                case 'P':
                case 'p':
                    //
                    //  Parent
                    //
                    pSymTab         = pLocalContext()->pNext->SymTab;
                    *szRealSymbol   = p+2;
                    break;

                case 'S':
                case 's':
                    //
                    //  Static
                    //
                    pSymTab         = pLocalContext()->pInfTempInfo->SymTab;
                    *szRealSymbol   = p+2;
                    break;

                default:
                    //
                    //  Invalid
                    //
                    pSymTab         = NULL;
                    *szRealSymbol   = NULL;
                    break;
                }

            } else {

                //
                //  Global variable
                //
                pSymTab      = pGlobalContext()->SymTab;
                *szRealSymbol = p;

            }

        } else {

            //
            //  Local variable
            //
            pSymTab       = pLocalContext()->SymTab;
            *szRealSymbol = p;

        }
    }

    return pSymTab;
}



PPARSED_INF
APIENTRY
ParsedInfAlloc(
    PINFPERMINFO    pInfPermInfo
    )
{
    PPARSED_INF     pParsedInf = NULL;


    //
    //  If the cache is not empty, see if this INF is already in
    //  the cache.
    //
    if ( ParsedInfCached > 0 ) {

        pParsedInf = pParsedInfCache;

        while ( pParsedInf ) {

            if ( pParsedInf->pInfPermInfo == pInfPermInfo ) {

                //
                //  Found the parsed INF in the cache.
                //  Take it out of the cache.
                //
                if (pParsedInf->pPrev) {
                    (pParsedInf->pPrev)->pNext = pParsedInf->pNext;
                }

                if (pParsedInf->pNext) {
                    (pParsedInf->pNext)->pPrev = pParsedInf->pPrev;
                }

                if ( pParsedInfCache == pParsedInf ) {
                    pParsedInfCache = pParsedInf->pNext;
                }

                pParsedInf->pPrev = NULL;
                pParsedInf->pNext = NULL;

                ParsedInfCached--;

                break;
            }

            pParsedInf = pParsedInf->pNext;
        }
    }


    //
    //  If the parsed INF was not in the cache, we allocate space for a
    //  new one.
    //
    if ( pParsedInf == NULL ) {

        if ( pParsedInf = (PPARSED_INF)SAlloc( sizeof( PARSED_INF ) ) ) {

            pParsedInf->pPrev           = NULL;
            pParsedInf->pNext           = NULL;
            pParsedInf->pInfPermInfo    = pInfPermInfo;
            pParsedInf->MasterLineArray = NULL;
            pParsedInf->MasterLineCount = 0;
            pParsedInf->MasterFile      = NULL;
            pParsedInf->MasterFileSize  = 0;
        }
    }

    return pParsedInf;
}



extern
BOOL
APIENTRY
FFreeParsedInf(
    PPARSED_INF     pParsedInf
    )
{
    PPARSED_INF     pInf;


    //
    //  We will put this Parsed INF in the cache. If the number of cached
    //  INFs is above the threshold we will free the least recently used
    //  one.
    //

    if (pParsedInfCache) {
        pParsedInfCache->pPrev = pParsedInf;
    }
    pParsedInf->pNext = pParsedInfCache;
    pParsedInfCache   = pParsedInf;


    if ( ParsedInfCached++ >= INF_CACHE_THRESHOLD ) {

        //
        //  There are too many INFs in the cache, look for the last one
        //  and free it.
        //
        pInf = pParsedInf;

        while ( pInf->pNext ) {
            pInf = pInf->pNext;
        }

        if (pInf->pPrev) {
            (pInf->pPrev)->pNext = pInf->pNext;
        }

        if (pInf->pNext) {
            (pInf->pNext)->pPrev = pInf->pPrev;
        }

        if ( pParsedInfCache == pInf ) {
            pParsedInfCache = pInf->pNext;
        }

        pInf->pPrev = NULL;
        pInf->pNext = NULL;

        ParsedInfCached--;

        if ( pInf->MasterLineArray ) {
            SFree( pInf->MasterLineArray);
        }

        if ( pInf->MasterFile ) {
            SFree( pInf->MasterFile );
        }

        SFree( pInf);

    }

    return TRUE;
}


extern
BOOL
APIENTRY
FFlushInfParsedInfo(
    SZ szInfName
    )
{
    CHAR            szName[cchlFullPathMax];
    PINFPERMINFO    pPermInfo;
    PPARSED_INF     pInf;

    //
    // Convert the inf path passed in to an inf name
    //

    PathToInfName( szInfName, szName );

    //
    // Find the perminfo for this inf. If none exists then return
    //

    if( !( pPermInfo = NameToInfPermInfo( szName , FALSE ) ) ) {
        return ( TRUE );
    }

    //
    // Go through the parsed inf cache, see if inf exists in the cache.
    // if it does, flush it.
    //

    if (pParsedInfCache) {
        pInf = pParsedInfCache;
        while ( pInf ) {
            if( pInf->pInfPermInfo == pPermInfo ) {

                if (pInf->pPrev) {
                    (pInf->pPrev)->pNext = pInf->pNext;
                }

                if (pInf->pNext) {
                    (pInf->pNext)->pPrev = pInf->pPrev;
                }

                if ( pParsedInfCache == pInf ) {
                    pParsedInfCache = pInf->pNext;
                }

                pInf->pPrev = NULL;
                pInf->pNext = NULL;

                ParsedInfCached--;

                if ( pInf->MasterLineArray ) {
                    SFree( pInf->MasterLineArray );
                }

                if ( pInf->MasterFile ) {
                    SFree( pInf->MasterFile );
                }

                SFree( pInf );
                break;
            }

            pInf = pInf->pNext;
        }

    }
    return ( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\delnode.c ===
#include "precomp.h"
#pragma hdrstop
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    delnode.c

Abstract:

    Delnode routine for Setup.

Author:

    Ted Miller (tedm) August 1992

--*/


//
// Bug whereby \$win_nt$.~ls\os2 directory is not deleted
//
//#define BUG_1818
#ifdef BUG_1818
char auxbuf[256];
#endif


//
// Put these out here so we don't consume huge stack space as we recurse.
//

TCHAR Pattern[MAX_PATH];
WIN32_FIND_DATA FindData;

VOID
DelnodeRoutine(
    VOID
    )
{
    LPTSTR PatternEnd;
    HANDLE FindHandle;

    //
    // Delete each file in the directory, then remove the directory itself.
    // If any directories are encountered along the way recurse to delete
    // them as they are encountered.
    //

    PatternEnd = Pattern+lstrlen(Pattern);

    lstrcat(Pattern,TEXT("\\*"));
    FindHandle = FindFirstFile(Pattern,&FindData);

    if(FindHandle != INVALID_HANDLE_VALUE) {

        do {

            //
            // Form the full name of the file we just found.
            //

            lstrcpy(PatternEnd+1,FindData.cFileName);

            //
            // Remove read-only atttribute if it's there.
            //

            if(FindData.dwFileAttributes & FILE_ATTRIBUTE_READONLY) {
                SetFileAttributes(Pattern,FILE_ATTRIBUTE_NORMAL);
            }

            if(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                //
                // The current match is a directory.  Recurse into it unless
                // it's . or ...
                //

                if(lstrcmp(FindData.cFileName,TEXT("." ))
                && lstrcmp(FindData.cFileName,TEXT("..")))
                {
                    DelnodeRoutine();
                }

            } else {

                //
                // The current match is not a directory -- so delete it.
                //

                DeleteFile(Pattern);
            }

            *(PatternEnd+1) = 0;

        } while(FindNextFile(FindHandle,&FindData));

        FindClose(FindHandle);
    }

    //
    // Remove the directory we just emptied out.
    //

    *PatternEnd = 0;
#ifdef BUG_1818
    if(!RemoveDirectory(Pattern)) {

        ULONG err = GetLastError();

        MessageBox(
            NULL,
            "Leave the machine exactly as it is now and get tedm (x63482).",
            "Trying to catch bug 1818",
            MB_TASKMODAL | MB_OK | MB_ICONSTOP
            );

        wsprintf(auxbuf,"Dir: %s\nErr: %lu",Pattern,err);
        MessageBox(
            NULL,
            auxbuf,
            "",
            MB_TASKMODAL | MB_OK
            );

        DbgBreakPoint();
    }
#endif
    RemoveDirectory(Pattern);
}





VOID
DoDelnode(
    IN PCHAR Directory
    )
{
    lstrcpy(Pattern,Directory);

    DelnodeRoutine();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\decomp.h ===
/*******************************************************************
*****  Header for Decompression Library (condensed from API.H and RETCODES.H)
********************************************************************/

/*** API.H:  Extern procs for the decompression library. ***/

typedef int (far * PFNWFROMW)(int);


LONG
LcbCopyFile(
    HANDLE    fhSrc,
    HANDLE    fhDest,
    PFNWFROMW pfn,
    INT       cProgTicks
    );

LONG
LcbDecompFile(
    HANDLE    fhSrc,
    HANDLE    fhDest,
    PFNWFROMW pfn,
    INT       cProgTicks
    );

//
// Diamond routines.
//

BOOL
InitDiamond(
    VOID
    );

VOID
TermDiamond(
    VOID
    );

BOOL
IsDiamondFile(
    IN PSTR FileName
    );

LONG
DecompDiamondFile(
    PSTR      SourceFileName,
    HANDLE    TargetFileHandle,
    PFNWFROMW ProgressCallback,
    INT       NumberOfTicks
    );


  /* global variables for file header info before writing or after reading */
extern  SHORT   vwAlgType;
extern  LONG    vlcbSrcLength;
extern  BOOL    vfChecksum;
extern  USHORT  vusChecksum;
extern  USHORT  vcbArgs;
extern  BYTE *  vrgbArgs;
extern  CHAR    vszBaseName[9];
extern  CHAR    vszExtension[4];
extern  SZ      vszText;
extern  USHORT  vcbText;



/*** RETCODES.H:  Return Codes for compression module for Setup Toolkit. ***/


  /* error codes - quick check is anything less than rcNoError */
#define  rcNoError                 0     /* no errors */
#define  rcNoHeader              (-1)    /* no header (eg no magic value) */
#define  rcUnknownAlgType        (-2)    /* wAlgType doesn't match knowns */
#define  rcBadHeader             (-3)    /* header too short or bad value */
#define  rcFilenamesTooLong      (-4)    /* filenames bigger than 8.3 */

#define  rcReadError             (-5)    /* reading error with fhSrc */
#define  rcReadSeekError         (-6)    /* seeking error with fhSrc */

#define  rcWriteError            (-7)    /* writing error with fhDest */
#define  rcWriteSeekError        (-8)    /* seeking error with fhDest */
#define  rcDestPatchError        (-9)    /* patching error with fhDest */

#define  rcCompChecksumBad      (-10)    /* compressed checksums mismatch */
#define  rcDecompChecksumBad    (-11)    /* decompressed checksums mismatch */
#define  rcCompLengthBad        (-12)    /* compressed length mismatch */
#define  rcDecompLengthBad      (-13)    /* decompressed length mismatch */

#define  rcGenericCompError     (-14)    /* internal compression error */
#define  rcGenericDecompError   (-15)    /* internal decompression error */

#define  rcSplitSizeTooSmall    (-16)    /* split size too small for header */

#define  rcOutOfMemory          (-17)    /* unable to alloc a buffer */

#define  rcDiskFull             (-18)    /* target is full */
#define  rcUserQuit             (-19)    /* user quit during decomp */

  /* each code below here has a standard header */
#define  wAlgTypeNil             (-1)    /* no algorithm type (never found) */
#define  wAlgTypeZK1               2     /* Steve Zeck compression algorithm */
#define  wAlgTypeJJJ1              3     /* Jeff J. Johnson algorithm */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\comstf.h ===
/************************************************/
/* Common Library Component public include file */
/************************************************/


#if !defined (COMSTF_INCLUDED )

#define COMSTF_INCLUDED

// avoid warnings on every file from including stdlib.h
#if defined(min)
#undef min
#undef max
#endif /* min */

extern HANDLE MyDllModuleHandle;



/*
**      Global variable macro for DLL portability
*/

#define GLOBAL(x)  (x)


/*      standard datatypes
*/
typedef  BYTE *          PB;

typedef  unsigned        CB;

typedef  LONG *          PLONG_STF;


/*      BOOLean datatype
*/
#define  fFalse  ((BOOL)0)

#define  fTrue   ((BOOL)1)


/*      To avoid compiler warnings for unused parameters
*/
#define  Unused(x)      (x)=(x)


/*  If new GRCs are added, they should as well be handled
        in EercErrorHandler() in ERROR1.C */
/*
**      General Return Code datatype
*/
typedef  USHORT  GRC;

#define  grcFirst                   ((GRC)0)

#define  grcLast                    ((GRC)52)

#define  grcOkay                    ((GRC)0)
#define  grcNotOkay                 ((GRC)1)
#define  grcOutOfMemory             ((GRC)2)
#define  grcInvalidStruct           ((GRC)3)
#define  grcOpenFileErr             ((GRC)4)
#define  grcCreateFileErr           ((GRC)5)
#define  grcReadFileErr             ((GRC)6)
#define  grcWriteFileErr            ((GRC)7)
#define  grcRemoveFileErr           ((GRC)8)
#define  grcRenameFileErr           ((GRC)9)
#define  grcReadDiskErr             ((GRC)10)
#define  grcCreateDirErr            ((GRC)11)
#define  grcRemoveDirErr            ((GRC)12)
#define  grcBadINF                  ((GRC)13)
#define  grcINFBadSectionLabel      ((GRC)14)
#define  grcINFBadLine              ((GRC)15)
#define  grcINFBadKey               ((GRC)16)
#define  grcCloseFileErr            ((GRC)17)
#define  grcChangeDirErr            ((GRC)18)
#define  grcINFSrcDescrSect         ((GRC)19)
#define  grcTooManyINFKeys          ((GRC)20)
#define  grcWriteInf                ((GRC)21)
#define  grcInvalidPoer             ((GRC)22)
#define  grcINFMissingLine          ((GRC)23)
#define  grcINFBadFDLine            ((GRC)24)
#define  grcINFBadRSLine            ((GRC)25)
#define  grcInvalidPathErr          ((GRC)26)
#define  grcWriteIniValueErr        ((GRC)27)
#define  grcReplaceIniValueErr      ((GRC)28)
#define  grcIniValueTooLongErr      ((GRC)29)
#define  grcDDEInitErr              ((GRC)30)
#define  grcDDEExecErr              ((GRC)31)
#define  grcBadWinExeFileFormatErr  ((GRC)32)
#define  grcResourceTooLongErr      ((GRC)33)
#define  grcMissingSysIniSectionErr ((GRC)34)
#define  grcDecompGenericErr        ((GRC)35)
#define  grcDecompUnknownAlgErr     ((GRC)36)
#define  grcMissingResourceErr      ((GRC)37)
#define  grcLibraryLoadErr          ((GRC)38)
#define  grcBadLibEntry             ((GRC)39)
#define  grcApplet                  ((GRC)40)
#define  grcExternal                ((GRC)41)
#define  grcSpawn                   ((GRC)42)
#define  grcDiskFull                ((GRC)43)
#define  grcDDEAddItem              ((GRC)44)
#define  grcDDERemoveItem           ((GRC)45)
#define  grcINFMissingSection       ((GRC)46)
#define  grcRunTimeParseErr         ((GRC)47)
#define  grcOpenSameFileErr         ((GRC)48)
#define  grcGetVolInfo              ((GRC)49)
#define  grcGetFileSecurity         ((GRC)50)
#define  grcSetFileSecurity         ((GRC)51)
#define  grcVerifyFileErr           ((GRC)52)

/**************************************/
/* common library function prototypes */
/**************************************/


/*      CHaracter Physical representation datatype
*/
typedef  BYTE            CHP;
typedef  CHP *           PCHP;
typedef  CB              CCHP;


#define  CbFromCchp(cchp)  ((CB)(cchp))


/*      CHaracter Logical representation datatype
*/
typedef  CHP             CHL;
typedef  CHL *           PCHL;
typedef  PCHL *          PPCHL;
typedef  CB              CCHL;
typedef  CB              ICHL;


#define  cbFullPathMax    ((CB)(MAX_PATH-1))
#define  cchlFullPathMax  ((CCHL)(MAX_PATH-1))
#define  cchlFullDirMax   cchlFullPathMax
#define  cchpFullPathMax  ((CCHP)(MAX_PATH-1))



#define  cbFullPathBuf    ((CB)(cbFullPathMax + 1))

#define  cchlFullPathBuf  ((CCHL)(cchlFullPathMax + 1))

#define  cchpFullPathBuf  ((CCHP)(cchpFullPathMax + 1))


/*      String Zero terminated datatype
*/
typedef  PCHL   SZ;
#define PSZ PPSZ
typedef  PPCHL  PSZ;
typedef  PPCHL  RGSZ;


/*      Comparison Return Code datatype
*/
typedef INT CRC;


#define  crcError         ((CRC)(-2))


#define  crcEqual         ((CRC)0)


#define  crcFirstHigher   ((CRC)1)


#define  crcSecondHigher  ((CRC)(-1))


  /* String manipulation routines */
extern  SZ      APIENTRY SzDupl(SZ);
extern  CRC     APIENTRY CrcStringCompare(SZ, SZ);
extern  CRC     APIENTRY CrcStringCompareI(SZ, SZ);
extern  SZ      APIENTRY SzLastChar(SZ);


/*
**      Purpose:
**              Advances a string pointer to the beginning of the next valid
**              character.  This may include skipping a double-byte character.
**      Arguments:
**              sz: the string pointer to advance.  It can be NULL or empty, or else
**                      it must point at the beginning of a valid character.
**      Returns:
**              NULL if sz was NULL.
**              sz unchanged if it was an empty string (*sz == '\0').
**              sz advanced past the current character and to the beginning of the
**                      next valid character.
*/

#define  SzNextChar(sz)            ((SZ)AnsiNext(sz))


/*
**      Purpose:
**              Retreats a string pointer to the beginning of the previous valid
**              character.  This may include skipping a double-byte character.
**      Arguments:
**              szStart: string pointer to the beginning of a valid character that
**                      equals or preceeds the character szCur.
**              szCur:   string pointer to retreat.  It can be NULL or empty, or
**                      can point to any byte in a valid character.
**      Returns:
**              NULL if szCur was NULL.
**              sz unchanged if szStart was NULL or if szCur equaled szStart.
**              sz retreated past the current character and to the beginning of the
**                      previous valid character.
*/

#define  SzPrevChar(szStart, szCur) ((SZ)AnsiPrev(szStart,szCur))


/*
**      Purpose:
**              Appends a string from one buffer to another.
**      Arguments:
**              szDst: string pointer to destination buffer.  This can be NULL or
**                      else it must contain a zero terminated string (can be empty)
**                      and enough storage to append szSrc with its terminating zero
**                      character.
**              szSrc: string pointer to source buffer.  This can be NULL or else
**                      must point to a zero terminated string (can be empty).
**      Returns:
**              NULL if either szDst or szSrc is NULL.
**              szDst signifying the operation succeeded.
*/

#define  SzStrCat(szDst, szSrc)     ((SZ)lstrcat((LPSTR)szDst,(LPSTR)szSrc))


/*
**      Purpose:
**              Determines whether the current character is a single Physical
**              Character.
**      Arguments:
**              sz: string pointer which can be NULL, empty, or pointing to the
**                      beginning of a valid character.
**      Returns:
**              fFalse if sz is NULL or points to the beginning of a multiple
**                      Physical Character character.
**              fTrue if sz is empty or points to the beginning of a single
**                      Physical Character character.
*/

#define  FSingleByteCharSz(sz)      (!IsDBCSLeadByte(*sz))


/*
**      Purpose:
**              Determines whether a character is an End-Of-Line character.
**      Arguments:
**              chp: Physical Character (eg a single byte Logical Character).
**      Returns:
**              fFalse if chp is not either a '\n' or a '\r' character.
**              fTrue if chp is either a '\n' or a '\r' character.
*/

#define FEolChp(chp)         ((BOOL)((chp) == '\n' || (chp) == '\r'))


/*
**      Purpose:
**              Determines whether a character is whitespace.
**      Arguments:
**              chp: Physical Character (eg a single byte Logical Character).
**      Returns:
**              fFalse if chp is not either a space or a tab character.
**              fTrue if chp is either a space or a tab character.
*/

#define FWhiteSpaceChp(chp)  ((BOOL)((chp) == ' '  || (chp) == '\t'))


/*
**      Purpose:
**              Converts a zero-terminated string to upper case.
**      Arguments:
**              sz: the string to convert to upper case.  sz must be non-NULL though
**                      it can be empty.
**      Returns:
**              A pointer to the converted string.
*/

#define SzStrUpper(sz)  (SZ)(AnsiUpper((LPSTR)(sz)))

/*
**      Purpose:
**              Converts a zero-terminated string to lower case.
**      Arguments:
**              sz: the string to convert to lower case.  sz must be non-NULL though
**                      it can be empty.
**      Returns:
**              A pointer to the converted string.
*/

#define SzStrLower(sz)  (SZ)(AnsiLower((LPSTR)(sz)))


#define cbSymbolMax (64*1024)
#define cbAllocMax (65520*5)
#define cbIntStrMax 16

PVOID
SAlloc(
    IN DWORD Size
    );

PVOID
SRealloc(
    IN PVOID Block,
    IN DWORD NewSize
    );

VOID
SFree(
    IN PVOID Block
    );

BOOL
SInit(
    IN BOOL Init
    );


/*      Long File Address datatype
*/
typedef unsigned long LFA;


#define  lfaSeekError   ((LFA)-1)


/*
**      File Handle structure
**      Fields:
**              iDosfh: DOS file handle.
**              ofstruct: OFSTRUCT used when the file was opened.
*/
typedef struct _fh
        {
        INT      iDosfh;
        OFSTRUCT ofstruct;
        } FH;


/*      File Handle datatype
*/
typedef  FH *  PFH;


/*      Open File Mode datatype
*/
typedef USHORT OFM;


#define  ofmExistRead      ((OFM)OF_EXIST | OF_READ)

#define  ofmExistReadWrite ((OFM)OF_EXIST | OF_READWRITE)

//#define  ofmRead           ((OFM)OF_READ | OF_SHARE_DENY_WRITE)


#define  ofmRead           ((OFM)OF_READ)

#define  ofmWrite          ((OFM)OF_WRITE | OF_SHARE_EXCLUSIVE)

#define  ofmReadWrite      ((OFM)OF_READWRITE | OF_SHARE_EXCLUSIVE)

#define  ofmCreate         ((OFM)OF_CREATE | OF_SHARE_EXCLUSIVE)


/*      Seek File Mode datatype
*/
typedef WORD SFM;


#define  sfmSet   ((SFM)0)


#define  sfmCur   ((SFM)1)


#define  sfmEnd   ((SFM)2)


  /* File handling routines */
extern  PFH     APIENTRY PfhOpenFile(SZ, OFM);
extern  BOOL    APIENTRY FCloseFile(PFH);
extern  CB      APIENTRY CbReadFile(PFH, PB, CB);
extern  CB      APIENTRY CbWriteFile(PFH, PB, CB);
extern  LFA     APIENTRY LfaSeekFile(PFH, LONG, SFM);
extern  BOOL    APIENTRY FEndOfFile(PFH);
extern  BOOL    APIENTRY FRemoveFile(SZ);
extern  BOOL    APIENTRY FWriteSzToFile(PFH, SZ);
extern  BOOL    APIENTRY FFileExists(SZ);
extern  SZ      APIENTRY szGetFileName(SZ szPath);
extern  VOID    APIENTRY FreePfh(PFH pfh);



  /* Path manipulation routines */

BOOL  FMakeFATPathFromDirAndSubPath(SZ, SZ, SZ, CCHP);
#define FValidFATDir(sz)        fTrue
#define FValidFATPath(sz)       fTrue
#define CchlValidFATSubPath(sz) strlen(sz)        // no checking for WIN32
#define ISUNC(sz) ((BOOL)(sz != NULL && lstrlen(sz) > 3 && *sz == '\\' && *(sz+1) == '\\'))


/*
**      Purpose:
**              Determines if a path is a valid FAT directory.
**      Arguments:
**              szDir: the directory string to check.
**      Returns:
**              fTrue if the szDir is a valid FAT directory.
**              fFalse if the szDir is an invalid FAT directory.
*/

#define  FValidDir(szDir)  FValidFATDir(szDir)


/*
**      Purpose:
**              Determines if a string is a valid FAT SubPath (eg subdirs and filename).
**      Arguments:
**              szSubPath: the SubPath string to check.
**      Returns:
**              zero if the string is an invalid FAT subPath.
**              non-zero count of characters in sz if it is a valid FAT subPath.
*/

#define  CchlValidSubPath(szSubPath)  CchlValidFATSubPath(szSubPath)


/*
**      Purpose:
**              Determines if a path is a valid FAT path.
**      Arguments:
**              szPath: the path to check.
**      Returns:
**              fTrue if the szPath is a valid FAT path.
**              fFalse if the szPath is an invalid FAT path.
*/

#define  FValidPath(szPath)  FValidFATPath(szPath)



/*
**      Purpose:
**              Creates a valid path from subpath, and filename arguments if possible
**              and stores it in a supplied buffer.
**      Arguments:
**              szDir:      string containing the volume and subdirs.
**              szSubPath:  string containing subdirs and the filename.
**              szBuf:      the buffer in which to store the newly created path.
**              cchpBufMax: the maximum number of physical characters (including the
**                      terminating zero) that can be stored in the buffer.
**      Returns:
**              fTrue if a valid FAT path can be created and stored in szBuf.
**              fFalse if szDir is NULL or invalid (first character must be in the
**                      'a' to 'z' or 'A' to 'Z', the second character must be either
**                      a ':' or a terminating zero, and the third character must be
**                      a '\\' and the rest must conform to 8.3 format), if szSubPath is
**                      NULL, empty or invalid (first character cannot be a '\\' and it must
**                      conform to 8.3 format), if szBuf is NULL, or if cchpBufMax is not
**                      large enough to hold the resultant path.
*/

#define  FMakePathFromDirAndSubPath(szDir, szSubPath, szBuffer, cchpBufMax) \
                        FMakeFATPathFromDirAndSubPath(szDir,szSubPath,szBuffer,cchpBufMax)




#define AssertDataSeg()

#if DBG

#define  Assert(f)              \
         ((f) ? (void)0 : (void)AssertSzUs(__FILE__,__LINE__))

#define  AssertRet(f, retVal)   \
         {if (!(f)) {AssertSzUs(__FILE__,__LINE__); return(retVal);}}

#define  EvalAssert(f)          \
         ((f) ? (void)0 : (void)AssertSzUs(__FILE__,__LINE__))

#define  EvalAssertRet(f, retVal) \
         {if (!(f)) {AssertSzUs(__FILE__,__LINE__); return(retVal);}}

#define  PreCondition(f, retVal) \
         {if (!(f)) {PreCondSzUs(__FILE__,__LINE__); return(retVal);}}

#define  ChkArg(f, iArg, retVal) \
         {if (!(f)) {BadParamUs(iArg, __FILE__, __LINE__); return(retVal);}}

#else

#define  Assert(f)                 ((void)0)
#define  AssertRet(f, retVal)      ((void)0)
#define  EvalAssert(f)             ((void)(f))
#define  EvalAssertRet(f, retVal)  ((void)(f))
#define  PreCondition(f, retVal)   ((void)0)
#define  ChkArg(f, iArg, retVal)   ((void)0)

#endif


/*
**      Purpose:
**              Generates a task modal message box.
**      Arguments:
**              szTitle: title for message box.
**              szText:  text for message box.
**      Returns:
**              none
*/

#define  MessBoxSzSz(szTitle, szText) \
                MessageBox((HWND)NULL, (LPSTR)szText, (LPSTR)szTitle, \
                                MB_TASKMODAL | MB_ICONHAND | MB_OK)


extern  BOOL    APIENTRY AssertSzUs(SZ, USHORT);
extern  BOOL    APIENTRY PreCondSzUs(SZ, USHORT);
extern  BOOL    APIENTRY BadParamUs(USHORT, SZ, USHORT);


/*
**      Inf Data Block structure
**
**      Fields:
**              pidbNext:      next IDB in linked list.
**              pchpBuffer:    character buffer.
**              cchpBuffer:    number of useful characters in pchpBuffer.
**              cchpAllocated: number of characters actually allocated with
**                      pchpBuffer.  May be zero.
*/
typedef struct _idb
        {
        struct _idb * pidbNext;
        PCHP          pchpBuffer;
        CCHP          cchpBuffer;
        CCHP          cchpAllocated;
        }  IDB;


/*      Inf Data Block datatypes
*/
typedef  IDB *  PIDB;
typedef  PIDB * PPIDB;

/*
    The following equate is used because of a situation like
    "abcd"+
    "efgh"
    When parsed, this will be "abcdefgh"  -- is this two strings or
    one string with a double quote in the middle?  If it's the latter,
    we'll actually store "abcd.efgh" where . is DOUBLE_QUOTE.
*/

#define     DOUBLE_QUOTE                '\001'

#define     INFLINE_SECTION             0x01
#define     INFLINE_KEY                 0x02

  /* INF File Handling routines */
GRC  APIENTRY GrcOpenInf(SZ IniFileName, PVOID pInfTempInfo);

BOOL APIENTRY FFreeInf(void);

UINT APIENTRY CKeysFromInfSection(SZ Section, BOOL IncludeAllLines);
BOOL APIENTRY FKeyInInfLine(INT Line);

RGSZ APIENTRY RgszFromInfLineFields(INT Line,UINT StartField,UINT NumFields);
BOOL APIENTRY FFreeRgsz(RGSZ);

UINT APIENTRY CFieldsInInfLine(INT Line);

INT  APIENTRY FindInfSectionLine(SZ Section);
INT  APIENTRY FindNthLineFromInfSection(SZ Section,UINT n);
INT  APIENTRY FindLineFromInfSectionKey(SZ Section,SZ Key);
INT  APIENTRY FindNextLineFromInf(INT Line);

SZ   APIENTRY SzGetNthFieldFromInfLine(INT Line,UINT n);
SZ   APIENTRY SzGetNthFieldFromInfSectionKey(SZ Section,SZ Key,UINT n);

BOOL APIENTRY FUpdateInfSectionUsingSymTab(SZ);

SZ   APIENTRY InterpretField(SZ);

#define  RgszFromInfScriptLine(Line,NumFields) \
         RgszFromInfLineFields(Line,1,NumFields)

#define  FindFirstLineFromInfSection(Section) FindNthLineFromInfSection(Section,1)

/*
**      Option-Element Flags datatype for SFD
*/
typedef WORD OEF;


#define oefVital       ((OEF)0x0001)

#define oefCopy        ((OEF)0x0002)

#define oefUndo        ((OEF)0x0004)

#define oefRoot        ((OEF)0x0008)

#define oefDecompress  ((OEF)0x0010)

#define oefTimeStamp   ((OEF)0x0020)

#define oefReadOnly    ((OEF)0x0040)

#define oefBackup      ((OEF)0x0080)

#define oefUpgradeOnly ((OEF)0x0100)

//
// The following oef means that the source file should not be deleted
// after it is copied, even if the source is the DOS setup local source.
// (Files coming from anywhere below that directory are usually deleted
// after they are copied).
//

#define oefNoDeleteSource    ((OEF)0x0200)

//
// The following means that the file should not be put into the setup log
// file that tracks all files copied by setup.
//
#define oefNoLog       ((OEF)0x0400)


//
// The following means that the file is a third party file
//
#define oefThirdPartyFile       ((OEF)0x0800)

//
// The following means that the file is from a CSD install
//
#define oefCsdInstall       ((OEF)0x1000)



#define oefNone        ((OEF)0x0000)

#define oefAll         ((OEF)0xFFFF)


/*
**      Copy-Time Unit datatype for SFD
*/
typedef WORD CTU;


/*
**      OverWrite Mode datatype for SFD
*/
typedef WORD OWM;


#define owmNever              ((OWM)0x0001)

#define owmAlways             ((OWM)0x0002)

#define owmUnprotected        ((OWM)0x0004)

#define owmOlder              ((OWM)0x0008)

#define owmVerifySourceOlder  ((OWM)0x0010)

/*
**      Option-Element Record for SFD
*/
typedef struct _oer
        {
        OEF   oef;
        CTU   ctuCopyTime;
        OWM   owm;
        LONG  lSize;
        SZ    szRename;
        SZ    szAppend;
        SZ    szBackup;
        SZ    szDescription;
        ULONG ulVerMS;
        ULONG ulVerLS;
        SZ    szDate;
        SZ    szDest;
        }  OER;


/*
**      Option-Element Record datatype for SFD
*/
typedef OER *   POER;
typedef POER *  PPOER;


#define poerNull ((POER)NULL)


/*
**      Disk ID datatype for SFD
*/
typedef WORD DID;


#define didMin    1


#define didMost 999


/*
**      Section-File Description structure
**      Fields:
*/
typedef struct _sfd
        {
    DID     did;
    UINT    InfId;
    SZ      szFile;
    OER     oer;
        } SFD;


/*
**      Section-File Description datatype
*/
typedef  SFD *  PSFD;
typedef  PSFD * PPSFD;

#define psfdNull ((PSFD)NULL)


extern  POER    APIENTRY PoerAlloc(VOID);
extern  BOOL    APIENTRY FFreePoer(POER);
extern  BOOL    APIENTRY FPrintPoer(PFH, POER);
extern  BOOL    APIENTRY FValidPoer(POER);

extern  PSFD    APIENTRY PsfdAlloc(VOID);
extern  BOOL    APIENTRY FFreePsfd(PSFD);
extern  GRC     APIENTRY GrcGetSectionFileLine(INT, PPSFD, POER);
extern  BOOL    APIENTRY FPrintPsfd(PFH, PSFD);
#if DBG
extern  BOOL    APIENTRY FValidPsfd(PSFD);
#endif

extern  BOOL    APIENTRY FValidOerDate(SZ);
extern  BOOL    APIENTRY FParseVersion(SZ, PULONG, PULONG);

extern  BOOL    APIENTRY FListIncludeStatementLine(INT Line);
extern  GRC     APIENTRY GrcGetListIncludeSectionLine(INT, PSZ, PSZ);



/*
**      Source Description List Element data structure
*/
typedef  struct _sdle
        {
        struct _sdle *  psdleNext;
    DID             did;           // disk id as specified in the inf
    DID             didGlobal;     // a universal id across infs
        SZ              szLabel;
        SZ              szTagFile;
        SZ              szNetPath;
        }  SDLE;

typedef SDLE *   PSDLE;
typedef PSDLE *  PPSDLE;


extern  PSDLE  APIENTRY PsdleAlloc(VOID);
extern  BOOL   APIENTRY FFreePsdle(PSDLE);

extern  GRC    APIENTRY GrcFillSrcDescrListFromInf(VOID);



/*
**      Copy List Node data structure
*/
typedef struct _cln
        {
        SZ            szSrcDir;
        SZ            szDstDir;
        PSFD          psfd;
        struct _cln * pclnNext;
        } CLN;
typedef CLN *   PCLN;
typedef PCLN *  PPCLN;
typedef PPCLN * PPPCLN;


/*
**      Section Files Operation data structure
**      REVIEW -- not really used
*/
typedef WORD SFO;

#define sfoCopy   1

#define sfoBackup 2

#define sfoRemove 3

  /* in LIST.C */
extern PCLN  pclnHead;
extern PPCLN ppclnTail;



extern GRC   APIENTRY GrcFillPoerFromSymTab(POER);
extern BOOL  APIENTRY FSetPoerToEmpty(POER);

extern GRC   APIENTRY GrcAddSectionFilesToCopyList(SZ, SZ, SZ);
extern GRC   APIENTRY GrcAddSectionKeyFileToCopyList(SZ, SZ, SZ, SZ);
extern GRC   APIENTRY GrcAddNthSectionFileToCopyList(SZ, UINT, SZ, SZ);
extern GRC   APIENTRY GrcAddSectionFilesToCList(SFO, SZ, SZ, SZ, SZ, POER);
extern GRC   APIENTRY GrcAddLineToCList(INT, SFO, SZ, SZ, POER);
extern GRC   APIENTRY GrcAddPsfdToCList(SZ, SZ, PSFD);

extern PCLN  APIENTRY PclnAlloc(VOID);
extern BOOL  APIENTRY FFreePcln(PCLN);

extern BOOL  APIENTRY FPrintPcln(PFH, PCLN);
#if DBG
extern BOOL  APIENTRY FValidPcln(PCLN);
#endif



/*      Symbol Table constants */
#define  cchpSymMax   ((CCHP)255)
#define  cchpSymBuf   (cchpSymMax + 1)

  /* Symbol Table routines */
extern  BOOL            APIENTRY FAddSymbolValueToSymTab(SZ, SZ);
extern  GRC             APIENTRY GrcAddSymsFromInfSection(SZ);


        /* Message Box Routine */
extern int APIENTRY ExtMessageBox(HANDLE, HWND, WORD, WORD, WORD);



/*
**      Purpose:
**              Determines whether a symbol is defined in the symbol table.
**      Arguments:
**              szSymbol: symbol to search for.  szSymbol must be non-NULL, non-empty,
**                      and start with a non-whitespace character.
**      Returns:
**              fTrue if szSymbol is defined in the symbol table (even if the associated
**                      is an empty string).
**              fFalse if szSymbol is not defined in the symbol table.
*/

#define  FSymbolDefinedInSymTab(szSymbol) \
                                        ((BOOL)(SzFindSymbolValueInSymTab(szSymbol)!=(SZ)NULL))


extern  SZ      APIENTRY SzFindSymbolValueInSymTab(SZ);
extern  BOOL    APIENTRY FRemoveSymbolFromSymTab(SZ);
extern  RGSZ    APIENTRY RgszFromSzListValue(SZ);
extern  SZ      APIENTRY SzListValueFromRgsz(RGSZ);
extern  BOOL    APIENTRY FFreeInfTempInfo(PVOID);
extern  BOOL    APIENTRY FCheckSymTabIntegrity(VOID);
extern  SZ      APIENTRY SzGetSubstitutedValue(SZ);
extern  SZ      APIENTRY SzProcessSzForSyms(HWND, SZ);

BOOL
DumpSymbolTableToFile(
    IN PCSTR Filename
    );

/*      String Parse Code
*/
typedef unsigned SPC;

typedef SPC *  PSPC;


/*
**      String-Code Pair structure
**      Fields:
**              sz:  string.
**              spc: String Parse Code to associate with string.
*/
typedef struct _scp
        {
        SZ  sz;
        SPC spc;
        } SCP;


/*      String-Code Pair datatype
*/
typedef  SCP *  PSCP;


/*  String Parse Table datatypes
*/
///////////////////////////////////
// typedef  SCP    SPT;
///////////////////////////////////

typedef  struct _pspt
    {
    PSCP pscpSorted ;   //  Generated for binary search
    long cItems ;       //  Number of items in table
    PSCP pscpBase ;     //  Original as given to PsptInitParsingTable()
    SPC spcDelim ;      //  Table delimiter entry
    } SPT ;

typedef  SPT *  PSPT;


/* Symbol Table routines */
extern  PSPT    APIENTRY PsptInitParsingTable(PSCP);
extern  SPC     APIENTRY SpcParseString(PSPT, SZ);
extern  BOOL    APIENTRY FDestroyParsingTable(PSPT);

/* Flow handling routines */

  /* external program, library */

BOOL APIENTRY FParseLoadLibrary(INT Line, UINT *pcFields);
BOOL APIENTRY FParseFreeLibrary(INT Line, UINT *pcFields);
BOOL APIENTRY FParseLibraryProcedure(INT Line,UINT *pcFields);
BOOL APIENTRY FParseRunExternalProgram(INT Line,UINT *pcFields);
BOOL APIENTRY FParseInvokeApplet(INT Line, UINT *pcFields);
BOOL APIENTRY FParseStartDetachedProcess(INT Line, UINT *pcFields);

  /* registry */

BOOL APIENTRY FParseRegistrySection(INT Line, UINT *pcFields, SPC spc);
BOOL APIENTRY FParseCreateRegKey(INT Line, UINT *pcFields, SZ szHandle);
BOOL APIENTRY FParseOpenRegKey(INT Line, UINT *pcFields, SZ szHandle);
BOOL APIENTRY FParseFlushRegKey(INT Line, UINT *pcFields, SZ szHandle);
BOOL APIENTRY FParseCloseRegKey(INT Line, UINT *pcFields, SZ szHandle);
BOOL APIENTRY FParseDeleteRegKey(INT Line, UINT *pcFields, SZ szHandle);
BOOL APIENTRY FParseDeleteRegTree(INT Line, UINT *pcFields, SZ szHandle);
BOOL APIENTRY FParseEnumRegKey(INT Line, UINT *pcFields, SZ szHandle);
BOOL APIENTRY FParseSetRegValue(INT Line, UINT *pcFields, SZ szHandle);
BOOL APIENTRY FParseGetRegValue(INT Line, UINT *pcFields, SZ szHandle);
BOOL APIENTRY FParseDeleteRegValue(INT Line, UINT *pcFields, SZ szHandle);
BOOL APIENTRY FParseEnumRegValue(INT Line, UINT *pcFields, SZ szHandle);

BOOL APIENTRY FParseAddFileToDeleteList(INT Line, UINT *pcFields);
BOOL APIENTRY FParseWaitOnEvent(INT Line,UINT *pcFields);
BOOL APIENTRY FParseSignalEvent(INT Line,UINT *pcFields);
BOOL APIENTRY FParseSleep(INT Line, UINT *pcFields);
BOOL APIENTRY FParseFlushInf(INT Line, UINT *pcFields);

/*
**      String Parse Codes for Flow Handling
*/
#define spcError                 0
#define spcUnknown               1
#define spcSet                   2
#define spcIfStr                 3
#define spcIfStrI                4
#define spcIfInt                 5
#define spcIfContains            6
#define spcIfContainsI           7
#define spcIfFirst               spcIfStr
#define spcIfLast                spcIfContainsI
#define spcEndIf                 8
#define spcElse                  9
#define spcElseIfStr            10
#define spcElseIfStrI           11
#define spcElseIfInt            12
#define spcElseIfContains       13
#define spcElseIfContainsI      14
#define spcEQ                   15
#define spcNE                   16
#define spcLT                   17
#define spcLE                   18
#define spcGT                   19
#define spcGE                   20
#define spcIn                   21
#define spcNotIn                22
#define spcGoTo                 23
#define spcForListDo            24
#define spcEndForListDo         25
#define spcSetSubst             26
#define spcSetSubsym            27
#define spcDebugMsg             28
#define spcHourglass            29
#define spcArrow                30
#define spcSetInstructionText   31
#define spcSetHelpFile          32
#define spcCreateRegKey         33
#define spcOpenRegKey           34
#define spcFlushRegKey          35
#define spcCloseRegKey          36
#define spcDeleteRegKey         37
#define spcDeleteRegTree        38
#define spcEnumRegKey           39
#define spcSetRegValue          40
#define spcGetRegValue          41
#define spcDeleteRegValue       42
#define spcEnumRegValue         43
#define spcSetAdd               50
#define spcSetSub               51
#define spcSetMul               52
#define spcSetDiv               53
#define spcGetDriveInPath       54
#define spcGetDirInPath         55
#define spcLoadLibrary          56
#define spcFreeLibrary          57
#define spcLibraryProcedure     58
#define spcRunExternalProgram   59
#define spcInvokeApplet         60
#define spcDebugOutput          61
#define spcSplitString          62
#define spcQueryListSize        63
#define spcSetOr                64
#define spcAddFileToDeleteList  65
#define spcInitRestoreDiskLog   66
#define spcStartDetachedProcess 67
#define spcWaitOnEvent          68
#define spcSignalEvent          69
#define spcSleep                70
#define spcSetHexToDec          71
#define spcSetDecToHex          72
#define spcFlushInf             73
#define spcBmpShow              74
#define spcBmpHide              75
#define spcTermRestoreDiskLog   76

extern  PSPT   psptFlow;
extern  SCP    rgscpFlow[];

extern  BOOL    APIENTRY FHandleFlowStatements(INT *, HWND, SZ, UINT *,RGSZ *);
extern  BOOL    APIENTRY FInitFlowPspt(VOID);
extern  BOOL    APIENTRY FDestroyFlowPspt(VOID);


/*
**      Expanded Error Return Code
*/
 typedef  unsigned  EERC;

#define  eercAbort  ((EERC)0)

#define  eercRetry  ((EERC)1)

#define  eercIgnore ((EERC)2)

        EERC    __cdecl EercErrorHandler(HWND, GRC, BOOL, ...);
extern  BOOL    APIENTRY FHandleOOM(HWND);

extern  BOOL    APIENTRY FGetSilent(VOID);
extern  BOOL    APIENTRY FSetSilent(BOOL);


VOID SetSupportLibHandle(HANDLE Handle);

extern HCURSOR CurrentCursor;


//
// Utility functions for dealing with multisz's.
//

RGSZ
MultiSzToRgsz(
    IN PVOID MultiSz
    );

PCHAR
RgszToMultiSz(
    IN RGSZ rgsz
    );


BOOL AddFileToDeleteList(PCHAR Filename);

// floppy operations/repair diskette stuff

BOOL
InitializeFloppySup(
    VOID
    );

VOID
TerminateFloppySup(
    VOID
    );

BOOL
FormatFloppyDisk(
    IN  CHAR  DriveLetter,
    IN  HWND  hwndOwner,
    OUT PBOOL Fatal
    );

BOOL
CopyFloppyDisk(
    IN CHAR  DriveLetter,
    IN HWND  hwndOwner,
    IN DWORD SourceDiskPromptId,
    IN DWORD TargetDiskPromptId
    );

UINT
xMsgBox(
    HWND hwnd,
    UINT CaptionResId,
    UINT MessageResId,
    UINT MsgBoxFlags,
    ...
    );


   //  Bit map control variables.

#define BMP_MAX 10

extern HBITMAP  hbmAdvertList [ BMP_MAX + 1 ] ;
extern INT      cAdvertIndex ;
extern INT      cAdvertCycleSeconds ;
extern INT      cyAdvert ;
extern INT      cxAdvert ;

extern PSTR SETUP_LOG_FILE;
extern PSTR SETUP_REPAIR_DIRECTORY;

//
// This flag tells us whether we were invoked as a standalone process
// or whether we were called to interpret a legacy inf from within a process.
//
extern BOOL OwnProcess;

//
// The following two globals are only valid if 'OwnProcess' is FALSE.
//
extern LPSTR ServicesModified;
extern DWORD ServicesModifiedSize;

#endif // COMSTF_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\defdproc.c ===
#include "precomp.h"
#pragma hdrstop

extern HWND hWndShell;

/* LONG APIENTRY LDefSetupDlgProc(HWND hDlg, UINT wMsg, WORD wParam,
 *                                LPARAM lParam);
 *
 * Function acts as setup's DefDialogProc(). We use this to process Help and
 * Exit button usage so that we don't have to put code into each of our dialog
 * procs to do this. The way it works is we filter all the dialog message for
 * WM_COMMAND - IDC_H/ID_EXIT messages, these we process right here. The rest
 * of the messages are passed on to DefDialogProc().
 *
 * ENTRY: hDlg   - Handle to dialog box who received the focus.
 *        wMsg    - Message.
 *        wParam - Message dependent.
 *        lParam - Message dependent.
 *
 * EXIT:
 *
 */

INT_PTR APIENTRY
LDefSetupDlgProc(
    HWND   hDlg,
    UINT   wMsg,
    WPARAM wParam,
    LPARAM lParam
    )

{
    switch(wMsg) {

    case WM_KEYDOWN:

        switch(wParam) {

        case VK_F1:

            SendMessage(
                hDlg,
                WM_COMMAND,
                MAKELONG(IDC_H, BN_CLICKED),
                lParam
                );

            return ( 0L );

        case VK_F3:

            SendMessage(
                hDlg,
                WM_COMMAND,
                MAKELONG(IDC_X, BN_CLICKED),
                lParam
                );

            return ( 0L );

        default:

            break;
        }

        break;


    case WM_COMMAND:

        switch (LOWORD(wParam)) {

        case IDC_H:

            PostMessage(
                hWndShell,
                WM_COMMAND,
                MAKELONG(ID_HELPBUTTON, BN_CLICKED),
                0L
                );

            return( 0L );


        default:

            break;
        }

    default:

        break;


    }

    return( DefDlgProc( hDlg, wMsg, wParam, lParam ) );

}


BOOL
DlgDefClassInit(
    IN HANDLE hInst,
    IN BOOL   Init
    )

{
    WNDCLASS wc;

    if(Init) {

        /*  Register setup's own personal dialog class. We do this so that we
        *  can have generic help and exit buttons on all the setup dialogs
        *  that need them.
        */

        wc.hCursor       = LoadCursor(NULL,IDC_ARROW);
        wc.hIcon         = NULL;
        wc.lpszMenuName  = NULL;
        wc.lpszClassName = CLS_MYDLGS;
        wc.hbrBackground = NULL;
        wc.hInstance     = hInst;
        wc.style         = CS_DBLCLKS | CS_SAVEBITS | CS_BYTEALIGNWINDOW | CS_GLOBALCLASS;
        wc.lpfnWndProc   = LDefSetupDlgProc;
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = DLGWINDOWEXTRA;

        return ( RegisterClass(&wc) );

    } else {

        return(UnregisterClass(CLS_MYDLGS,hInst));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\copy.c ===
#include "precomp.h"
#pragma hdrstop
/* File: filecm.c */
/*************************************************************************
**  Install: File Copying commands.
**************************************************************************/

extern HWND   hwndFrame;
extern HANDLE hinstShell;

extern HWND hwndProgressGizmo;
extern CHP rgchBufTmpLong[];


/* Globals */
CHP szFullPathSrc[cchpFullPathBuf] = "\0";
CHP szFullPathDst[cchpFullPathBuf] = "\0";
CHP szFullPathBak[cchpFullPathBuf] = "\0";

CHAR GaugeText1[50], GaugeText2[50];
BOOL fNTUpgradeSetup,fInitialSetup;

SZ APIENTRY SzGetSrcDollar(SZ szFullPathSrc,CHAR ch);

PSTR LOCAL_SOURCE_DIRECTORY = "\\$WIN_NT$.~LS";

int
DetermineDriveType(
    IN CHAR DriveLetter
    );

BOOL
FGetFileSecurity(
    PCHAR File,
    PSECURITY_DESCRIPTOR *SdBuf,
    CB *SdLen
    );

BOOL
FSetFileSecurity(
    PCHAR File,
    PSECURITY_DESCRIPTOR SdBuf
    );

VOID
ValidateAndChecksumFile(
    IN  PSTR     Filename,
    OUT PBOOLEAN IsNtImage,
    OUT PULONG   Checksum,
    OUT PBOOLEAN Valid
    );

BOOL
DoesFileReplaceThirdPartyFile(
    SZ  szFullPathDst
    );


/*
**  Purpose:
**      Copies all files in the current copy list and resets the list to
**      empty.  Copying is sorted by source disk to limit potential disk
**      swapping.
**  Arguments:
**      hInstance:  non-NULL instance handle for getting strings from
**          resources for SwapDisk message Box.
**  Returns:
**      Returns fTrue if all copies successful, fFalse otherwise.
**
**************************************************************************/
BOOL APIENTRY FCopyFilesInCopyList(hInstance)
HANDLE hInstance;
{
    DID             did;
    PCLN            pclnCur;
    PPCLN           ppclnPrev;
    LONG            lTotalSize;
    PPCLN           ppclnHead;
    PPPCLN          pppclnTail;
    PSDLE           psdle;
    BOOL            fSilentSystem = FGetSilent();
    UINT            fuModeSav;
    PINFPERMINFO    pPermInfo;
    PSDLE           psdleGlobalHead = (PSDLE)NULL;
    PSDLE           psdleGlobalEnd  = (PSDLE)NULL;
    PSDLE           psdleGlobal;
    DID             didGlobalCur;
    BOOL            fCopyStatus = fFalse;
    SZ              sz;


    if(!InitDiamond()) {
        return(fFalse);
    }

    fInitialSetup = fFalse;
    fNTUpgradeSetup = fFalse;

    if (!fSilentSystem) {
        ProOpen(hwndFrame, 0);
        ProSetBarRange(10000);
    }

    //
    // Determine if we are in initial setup
    //

    if ((sz = SzFindSymbolValueInSymTab("!STF_INSTALL_TYPE")) != (SZ)NULL &&
        (CrcStringCompareI(sz, "SETUPBOOTED") == crcEqual)) {

        fInitialSetup = fTrue;
    }

    //
    // Determine if we are an NT upgrade setup
    //

    if (fInitialSetup
        && (sz = SzFindSymbolValueInSymTab("!STF_NTUPGRADE")) != (SZ)NULL
        && (CrcStringCompareI(sz, "YES") == crcEqual)) {

        fNTUpgradeSetup = fTrue;
    }

    //
    // Go through all the disk media descriptions and assign universal
    // ids for all source media.  This is necessary because two infs
    // may refer to the same disk using different ids.
    //

    pPermInfo    = pInfPermInfoHead;
    didGlobalCur = didMin;
    while ( pPermInfo ) {

        //
        // If the INF has a source media description list, go through list
        //

        psdle = pPermInfo->psdleHead;
        while ( psdle ) {

            //
            // search all the global psdles for a match with the current
            // disk.  search based on disk label ( which is hopefully unique )
            //

            psdleGlobal     = psdleGlobalHead;
            while ( psdleGlobal ) {
                if( !CrcStringCompareI( psdleGlobal->szLabel, psdle->szLabel ) ) {
                    break;
                }
                psdleGlobal     = psdleGlobal->psdleNext;
            }

            if ( psdleGlobal == NULL ) {
                PSDLE   psdleNew;
                if ((psdleNew = PsdleAlloc()) == (PSDLE)NULL ||
                    (psdleNew->szLabel   = SzDupl(psdle->szLabel))  == (SZ)NULL ||
                    (psdle->szTagFile != NULL && ((psdleNew->szTagFile = SzDupl(psdle->szTagFile)) == (SZ)NULL)) ||
                    (psdle->szNetPath != NULL && ((psdleNew->szNetPath = SzDupl(psdle->szNetPath)) == (SZ)NULL))) {
                    goto CopyFailed;
                }
                psdleNew->psdleNext = (PSDLE)NULL;
                if ( !psdleGlobalHead ) {
                    psdleGlobalHead = psdleGlobalEnd  = psdleNew;
                }
                else {
                    psdleGlobalEnd->psdleNext = psdleNew;
                    psdleGlobalEnd            = psdleNew;
                }
                psdleGlobal = psdleNew;
                psdleGlobal->didGlobal = didGlobalCur++;
            }
            psdle->didGlobal = psdleGlobal->didGlobal;
            psdle = psdle->psdleNext;
        }
        pPermInfo = pPermInfo->pNext;
    }

    //
    // Go through the copy list of all infs and calculate total copy
    // list cost
    //

    pPermInfo  = pInfPermInfoHead;
    lTotalSize = 0L;
    while ( pPermInfo ) {

        //
        //  If the INF has a source media description list, look at the
        //  copy list
        //

        if ( pPermInfo->psdleHead ) {

            Assert(FValidCopyList( pPermInfo ));

            ppclnHead  = PpclnHeadList( pPermInfo );
            pppclnTail = PppclnTailList( pPermInfo );

#if DBG
            *pppclnTail = NULL;   /* for FValidCopyList() calls */
#endif
            pclnCur    = *ppclnHead;
            //
            //  Traverse the copy list and determine the total size of the
            //  files to copy.
            //
            while (pclnCur != (PCLN)NULL) {

                if (pclnCur->psfd->oer.ctuCopyTime > 0) {
                    lTotalSize += pclnCur->psfd->oer.ctuCopyTime;
                } else {
                    lTotalSize += pclnCur->psfd->oer.lSize;
                }
                pclnCur = pclnCur->pclnNext;
            }
        }
        pPermInfo = pPermInfo->pNext;
    }

    if (lTotalSize == 0L) {
        lTotalSize = 1L;
    }

    //
    //  Show gauge stuff if not in silent mode.
    //

    if (!fSilentSystem) {

        SZ  szText;

        ProSetBarPos(0);

        szText = SzFindSymbolValueInSymTab("ProText1");
        if( szText ) {
            strcpy(GaugeText1, szText);
        }
        else {
            strcpy(GaugeText1, "");
        }

        szText = SzFindSymbolValueInSymTab("ProText2");
        if( szText ) {
            strcpy(GaugeText2, szText);
        }
        else {
            strcpy(GaugeText2, "");
        }


        ProSetText(ID_STATUS3, "");
        ProSetText(ID_STATUS4, "");
    }


    //
    // Copy the files
    //

    psdleGlobal = psdleGlobalHead;
    while (psdleGlobal ) {

        didGlobalCur = psdleGlobal->didGlobal;
        pPermInfo  = pInfPermInfoHead;
        while ( pPermInfo ) {

            //
            // Verify that this INF has a copy list
            //

            if ((psdle = pPermInfo->psdleHead) == (PSDLE)NULL ) {
                Assert( !*PpclnHeadList( pPermInfo ) );
                pPermInfo = pPermInfo->pNext;
                continue;
            }
            Assert(FValidCopyList( pPermInfo ));

            //
            // If it does, go through its source media descriptions finding
            // all disks that match the current global disk id and copy all
            // files which are described by the disks found
            //

            while ( psdle ) {

                if( psdle->didGlobal != didGlobalCur ) {
                    psdle = psdle->psdleNext;
                    continue;
                }
                did = psdle->did;

                ppclnHead  = PpclnHeadList( pPermInfo );
                pppclnTail = PppclnTailList( pPermInfo );

#if DBG
                *pppclnTail = NULL;   /* for FValidCopyList() calls */
#endif
                ppclnPrev        = ppclnHead;
                pclnCur          = *ppclnHead;

                //
                //  Now traverse the copy list, copying all
                //  the files that match the disk id
                //

                while (pclnCur != (PCLN)NULL) {

                    if ( (pclnCur->psfd->did != did) ||
                         (pclnCur->psfd->InfId != pPermInfo->InfId ) ) {
                        ppclnPrev = &(pclnCur->pclnNext);
                        pclnCur   = pclnCur->pclnNext;
                        continue;
                    }


                    fuModeSav = SetErrorMode(
                                   SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX
                                   );

                    if(!FCopyListFile(hInstance,pclnCur,psdle,lTotalSize)) {

                        SetErrorMode(fuModeSav);
                        goto CopyFailed;
                    }

                    SetErrorMode(fuModeSav);

                    //
                    //  File copied, delete its entry from the copy list
                    //
                    *ppclnPrev = pclnCur->pclnNext;
                    EvalAssert(FFreePcln(pclnCur));
                    pclnCur = *ppclnPrev;

                    Assert(FValidCopyList( pPermInfo ));
                }

                psdle = psdle->psdleNext;
            }
            pPermInfo = pPermInfo->pNext;
        }
        psdleGlobal = psdleGlobal->psdleNext;
    }
    if (!fSilentSystem) {
        ProSetBarPos(10000 - 1);
    }
    fCopyStatus = fTrue;

CopyFailed:

    if (!fSilentSystem) {
        ProClose(hwndFrame);
        UpdateWindow(hwndFrame);
    }

    pPermInfo    = pInfPermInfoHead;
    while ( pPermInfo ) {
        EvalAssert(FFreeCopyList( pPermInfo ));
        pPermInfo = pPermInfo->pNext;
    }

    psdleGlobal = psdleGlobalHead;
    while ( psdleGlobal ) {
        PSDLE psdleNext = psdleGlobal->psdleNext;
        FFreePsdle( psdleGlobal );
        psdleGlobal = psdleNext;
    }

    TermDiamond();
    RestoreDiskLoggingDone();

    return(fCopyStatus);

}



/*
**  Purpose:
**      To determine if the given file is read only.
**  Arguments:
**      szFullPathDst : a non-Null, zero-terminated string containing the fully
**          qualified valid path (including the drive) to the file in
**          question.  File must exist.
**  Returns:
**      ynrcYes if the file is read only, ynrcNo otherwise.
**
**************************************************************************/
YNRC APIENTRY YnrcFileReadOnly(szFullPathDst)
SZ szFullPathDst;
{
    BOOL     fOkay = fTrue;
    unsigned uiAttrib;

    ChkArg(szFullPathDst != (SZ)NULL && FValidPath(szFullPathDst) &&
            FFileFound(szFullPathDst), 1, ynrcErr1);

    if ((uiAttrib = GetFileAttributes(szFullPathDst)) == -1)
        fOkay = fFalse;

    if (!fOkay)
        return(ynrcErr1);

    return((uiAttrib & FILE_ATTRIBUTE_READONLY) ? ynrcYes : ynrcNo);
}


/*
**  Purpose:
**      To set the read only status of a file to either read only or normal.
**  Arguments:
**      szFullPathDst:  a non-Null, zero-terminated string containing the fully
**          qualified valid path (including drive) whose status is to be
**          set.  File must already exist.
**      fReadOnly:      fTrue if the status is to be set to read only, fFalse
**          if the status is to be set to normal
**  Returns:
**      fTrue if the function succeeds in setting the status as specified,
**      fFalse otherwise.
**
**************************************************************************/
BOOL APIENTRY FSetFileReadOnlyStatus(SZ szFullPathDst,BOOL fReadOnly)
{
    BOOL  fRet = fFalse;
    DWORD uiAttrib;
    DWORD newAttrib;

    ChkArg(szFullPathDst != (SZ)NULL && FValidPath(szFullPathDst) &&
            FFileFound(szFullPathDst), 1, fFalse);

    if ((uiAttrib = GetFileAttributes(szFullPathDst)) != -1) {

        if(fReadOnly) {
            newAttrib = uiAttrib | FILE_ATTRIBUTE_READONLY;
        } else {
            newAttrib = uiAttrib & ~FILE_ATTRIBUTE_READONLY;
        }

        if((newAttrib == uiAttrib) || SetFileAttributes(szFullPathDst, newAttrib)) {
            fRet = fTrue;
        }
    }

    return(fRet);
}


/*
**  Purpose:
**      To determine if there is already a destination file that is "newer" than
**      the source file.
**  Arguments:
**      dateSrc: valid date value in unsigned int form extracted from INF.
**      szFullPathDst: a non-Null, zero terminated string containing the fully
**          qualified valid path (including disk drive) to the destination
**          file.  File must exist.
**      dwVerSrcMS: Most significant 32 bits of source file version stamp.
**      dwVerSrcLS: Least significant 32 bits of source file version stamp.
**  Returns:
**      ynrcYes if the destination file already exists and is newer than
**          the source file.
**      ynrcErr1, ynrcErr2, or ynrcErr3 in errors.
**      ynrcNo otherwise.
**
**************************************************************************/
YNRC APIENTRY YnrcNewerExistingFile(USHORT dateSrc,
        SZ szFullPathDst, DWORD dwVerSrcMS, DWORD dwVerSrcLS)
{
    USHORT   dateDst, timeDst;
    PFH      pfhDst;
    FILETIME WriteTime;
    DWORD    dwVerDstMS;
    DWORD    dwVerDstLS;


    ChkArg(szFullPathDst != (SZ)NULL && FValidPath(szFullPathDst) &&
            FFileFound(szFullPathDst), 2, ynrcErr1);


    if ( (dwVerSrcMS != 0L || dwVerSrcLS != 0L) &&
         FGetFileVersion(szFullPathDst, &dwVerDstMS, &dwVerDstLS)) {

        if (dwVerDstMS > dwVerSrcMS  ||
            (dwVerDstMS == dwVerSrcMS && dwVerDstLS > dwVerSrcLS)) {

            return(ynrcYes);
        }
        else {
            return(ynrcNo);
        }

    }
    else {
        if ((pfhDst = PfhOpenFile(szFullPathDst, ofmRead)) == NULL) {
            return(ynrcErr1);
        }

        if (!GetFileTime((HANDLE)LongToHandle(pfhDst->iDosfh), NULL, NULL, &WriteTime) ||
            !FileTimeToDosDateTime(&WriteTime, &dateDst, &timeDst)) {

            FCloseFile(pfhDst);
            return(ynrcErr2);
        }

        if (!FCloseFile(pfhDst)) {
            return(ynrcErr3);
        }

        if (dateDst > dateSrc) {
            return(ynrcYes);
        }
    }

    return(ynrcNo);
}

/*
**  Purpose:
**      Gets the file version values from the given file and sets the
**      given pdwMS/pdwLS variables.
**  Arguments:
**      szFullPath: a zero terminated character string containing the fully
**          qualified path (including disk drive) to the file.
**      pdwMS: Most significant 32 bits of source file version stamp.
**      pdwLS: Least significant 32 bits of source file version stamp.
**  Returns:
**      fTrue if file and file version resource found and retrieved,
**      fFalse if not.
+++
**  Implementation:
**************************************************************************/
BOOL APIENTRY FGetFileVersion(szFullPath, pdwMS, pdwLS)
SZ      szFullPath;
DWORD * pdwMS;
DWORD * pdwLS;
{
    BOOL  fRet = fFalse;
    DWORD dwHandle;
    DWORD dwLen;
    LPSTR lpData;

    ChkArg(szFullPath != (SZ)NULL,       1, fFalse);
    ChkArg(pdwMS      != (DWORD *)NULL,  2, fFalse);
    ChkArg(pdwLS      != (DWORD *)NULL,  3, fFalse);

    //
    // Get the file version info size
    //

    if ((dwLen = GetFileVersionInfoSize((LPSTR)szFullPath, &dwHandle)) == 0) {
        return (fRet);
    }

    //
    // Allocate enough size to hold version info
    //

    while ((lpData = (LPSTR)SAlloc((CB)dwLen)) == (LPSTR)NULL) {
        if (!FHandleOOM(hwndFrame)) {
            return (fRet);
        }
    }

    //
    // Get the version info
    //

    fRet = GetFileVersionInfo((LPSTR)szFullPath, dwHandle, dwLen, lpData);

    if (fRet) {
        VS_FIXEDFILEINFO *pvsfi;
        DWORD            dwLen;

        fRet = VerQueryValue(
                   (LPVOID)lpData,
                   (LPSTR)"\\",
                   (LPVOID *)&pvsfi,
                   &dwLen
                   );

        if (fRet) {
            *pdwMS = pvsfi->dwFileVersionMS;
            *pdwLS = pvsfi->dwFileVersionLS;
        }
    }

    SFree(lpData);
    return (fRet);


}

/*
**  Purpose:
**      Renames the given destination file as a backup file based on
**      the backup file name given.  If a backup file with the given
**      name already exists, the function does nothing and returns.
**  Arguments:
**      szDst:    a zero terminated  char string containing the fully
**          qualified path to the file to be backed up.
**      szBackup: a zero terminated char string containing the file name
**          of the file that will be the backup copy of szDst.  This is
**          not a fully qualified path, or subpath, it is only the filename
**          (i.e. primary.ext).
**      psfd:     pointer to the Section-File Description(SFD) structure of
**          the file being backed up.
**  Returns:
**      ynrcNo:   if the backup file name is invalid or if unable to create
**          the backup and user chooses to abort.
**      ynrcErr1: if unable to create the backup and the user chooses ignore.
**      ynrcYes:  if the backup is successfully created or already exists.
**
**************************************************************************/
YNRC APIENTRY YnrcBackupFile(szDst, szBackup, psfd)
SZ   szDst;
SZ   szBackup;
PSFD psfd;
{
    YNRC ynrcRet = ynrcYes;

    Unused(szBackup);

    Assert(psfd->oer.szAppend == (SZ)NULL);

    if (!FBuildFullBakPath(szFullPathBak, szDst, psfd) ||
            !FValidPath(szFullPathBak))
        return(ynrcNo);

    /* If the backup file already exists, leave the existing backup
    ** and return.  (Either the user made it and we don't want to kill
    ** his, or we made it and we don't need to make another one.)
    */
    if (FFileFound(szFullPathBak))
        return(ynrcYes);

    while (rename(szFullPathDst, szFullPathBak))
        {
        EERC eerc;

        if ((eerc = EercErrorHandler(hwndFrame, grcRenameFileErr,
                psfd->oer.oef & oefVital, szFullPathDst, szFullPathBak, 0))
                == eercAbort)
            {
            ynrcRet = ynrcNo;
            break;
            }
        else if (eerc == eercIgnore)
            {
            ynrcRet = ynrcErr1;
            break;
            }
        Assert(eerc == eercRetry);
        }

    return(ynrcRet);
}


/*
**************************************************************************/
USHORT APIENTRY DateFromSz(SZ sz)
{
    USHORT usAns, usYear, usMonth, usDay;

    ChkArg(sz == (SZ)NULL || FValidOerDate(sz), 1, 0);

    if (sz == (SZ)NULL)
        {
        usYear  = 1980;
        usMonth = 1;
        usDay   = 1;
        }
    else
        {
        usYear  = (USHORT)atoi(sz);
        usMonth = (USHORT)atoi(sz + 5);
        usDay   = (USHORT)atoi(sz + 8);
        }

    Assert(usYear  >= 1980 && usYear  <= 2099);
    Assert(usMonth >= 1    && usMonth <= 12);
    Assert(usDay   >= 1    && usDay   <= 31);

    usAns = usDay + (usMonth << 5) + ((usYear - (USHORT)1980) << 9);

    return(usAns);
}


BOOL
CreateTargetAsLinkToMaster(
   IN SZ FullSourceFilename,
   IN SZ FullTargetFilename,
   IN BOOL TargetExists
   )
{
    //BUGBUG: handle case of target file in use.
    //BUGBUG: handle case of target already exists.
    //BUGBUG: handle owm modes

    //BUGBUG: The following code is written to work with the prototype COW
    //        server, not with the real SIS server.  If the target file
    //        exists, we assume it is the correct version (in the master
    //        tree) and don't do the copy.
    //
    if ( TargetExists ) {
        //DbgPrint( "SIS: Target %s exists; not copying\n", FullTargetFilename );
        return NO_ERROR;            // target exists; don't copy
    }
    //DbgPrint( "SIS: Target %s doesn't exist; copying\n", FullTargetFilename );
    return ERROR_FILE_NOT_FOUND;    // target doesn't exist; copy by usual means
}


/*
**  Purpose:
**      Performs the copy defined by the given copy list node.
**  Arguments:
**      hInstance:  non-NULL instance handle for getting strings from
**          resources for SwapDisk message Box.
**      pcln:       pointer to the Copy List Node (CLN) of the file to be
**          copied.
**      psdle:      non-NULL Source-Description-List-Element pointer to be
**          used by FPromptForDisk().
**      lTotalSize: the total of all of the sizes (i.e. oer.ctuCopyTime or
**          oer.lSize) for all of the files on the disk currently being copied.
**  Returns:
**      fTrue if the copy was successful, fFalse otherwise.
**
**************************************************************************/
BOOL APIENTRY
FCopyListFile(
    HANDLE hInstance,
    PCLN   pcln,
    PSDLE  psdle,
    LONG   lTotalSize
    )
{
    PSFD   psfd = pcln->psfd;
    POER   poer = &(psfd->oer);
    BOOL   fDstExists, fCompressedName;
    SZ     szSrcDollar = NULL;
    BOOL   fVital = poer->oef & oefVital;
    EERC   eerc;
    int    Removable;
    LONG   lSize;
    USHORT dateSrc = DateFromSz(poer->szDate);
    PSECURITY_DESCRIPTOR Sd = NULL;
    CB     SdLen;
    CHP    szNonCompressedFullPathSrc[cchpFullPathBuf] = "\0";
    SZ     SymbolValue;
    CHAR   szSrcDrive[10];

    ChkArg(pcln  != (PCLN)NULL,  1, fFalse);
    ChkArg(psdle != (PSDLE)NULL, 2, fFalse);

    //
    // Only if a drive is removable do we check for the tagfile, in the case
    // of a net drive the error is caught later on when we look for the src
    // file.  Note that the tag file is relative to the root of the removable
    // drive.
    //
    // Because of a bug in 3.51 there are CD's which expect the tagfile to be
    // locatable in a subdirectory. We'll use a hack based on STF_CWDDIR
    // to make that work.
    //
    Removable = DetermineDriveType(*(pcln->szSrcDir));
    if((Removable < 0) && psdle->szTagFile) {

        strcpy(szSrcDrive,"?:\\");
        szSrcDrive[0] = *(pcln->szSrcDir);

        if(!FBuildFullSrcPath(szFullPathSrc,szSrcDrive,psdle->szTagFile,NULL)) {
            EercErrorHandler(hwndFrame,grcInvalidPathErr,fVital,szSrcDrive,psdle->szTagFile,0);
            return(!fVital);
        }

        if((Removable == -2) && (SymbolValue = SzFindSymbolValueInSymTab("!STF_CWDDIR"))) {
            if(!FBuildFullSrcPath(szFullPathDst,SymbolValue,psdle->szTagFile,NULL)) {
                szFullPathDst[0] = 0;
            }
        } else {
            szFullPathDst[0] = 0;
        }

        //
        // Strip the backslash off the drive letter.
        //
        szSrcDrive[2] = '\0';

        //
        // If we can't find the tag file at the root then also look in
        // STF_CWDDIR, if there is one.
        //
        while(!FFileFound(szFullPathSrc) && (!szFullPathDst[0] || !FFileFound(szFullPathDst))) {

            MessageBeep(0);
            ShowOwnedPopups(hwndFrame,FALSE);
            if(FPromptForDisk(hInstance, psdle->szLabel, szSrcDrive)) {
                ShowOwnedPopups(hwndFrame,TRUE);
            } else {

                HWND hwndSav = GetFocus();
                BOOL b;
                CCHL szTmpText[cchpBufTmpLongMax];

                //
                // Make sure this is what he *really* wants to do.
                //

                LoadString(hInstance, IDS_SURECANCEL, rgchBufTmpLong, cchpBufTmpLongMax);
                LoadString(hInstance, IDS_ERROR, (LPSTR)szTmpText, cchpBufTmpLongMax);
                b = (MessageBox(hwndFrame, rgchBufTmpLong, (LPSTR)szTmpText, MB_YESNO|MB_TASKMODAL) == IDYES);
                ShowOwnedPopups(hwndFrame,TRUE);
                SetFocus(hwndSav);
                SendMessage(hwndFrame, WM_NCACTIVATE, 1, 0L);
                if(b) {
                    return(fFalse);
                }
            }
        }
    }


    if (!FBuildFullSrcPath(szFullPathSrc, pcln->szSrcDir, psfd->szFile,
            (Removable < 0) ? NULL : psdle->szNetPath)) {
        EvalAssert(EercErrorHandler(hwndFrame, grcInvalidPathErr, fVital,
                pcln->szSrcDir, psfd->szFile, 0) == eercAbort);
        return(!fVital);
    }

    //
    // Determine the source file name:
    // Check to see if source file exists as the regular name or
    // a compressed name
    //

    lstrcpy( szNonCompressedFullPathSrc, szFullPathSrc );
    fCompressedName = fFalse;
    while (!FFileFound( szFullPathSrc )) {
        if (szSrcDollar == (SZ)NULL) {
            while ((szSrcDollar = SzGetSrcDollar(szFullPathSrc,'_')) == (SZ)NULL) {
                if (!FHandleOOM(hwndFrame)) {
                    return(!fVital);
                }
            }
        }

        if (FFileFound( szSrcDollar )) {
            lstrcpy( szFullPathSrc, szSrcDollar );
            fCompressedName = fTrue;
            break;
        }

#define DOLLAR_NAME
#ifdef DOLLAR_NAME
        SFree(szSrcDollar);
        while((szSrcDollar = SzGetSrcDollar(szFullPathSrc,'$')) == (SZ)NULL) {
            if (!FHandleOOM(hwndFrame)) {
                return(!fVital);
            }
        }
        if(FFileFound(szSrcDollar)) {
            lstrcpy(szFullPathSrc,szSrcDollar);
            fCompressedName = fTrue;
            break;
        }
#endif

        SFree( szSrcDollar);
        szSrcDollar = NULL;

        //
        // Unable to locate the source file.
        // If we are supposed to skip missing files, ignore it.
        // Text setup sets a symbol called SMF to YES if we are
        // supposed to skip missing files.
        //
        if((SymbolValue = SzFindSymbolValueInSymTab("!SMF")) && !lstrcmpi(SymbolValue,"YES")) {
            return(fTrue);
        }

        //
        // If the file exists on the target and this is a winnt
        // non-upgrade setup, just assume the file was already copied.
        //
        if(/*fInitialSetup &&*/ !fNTUpgradeSetup
        && !_strnicmp(szFullPathSrc+2,LOCAL_SOURCE_DIRECTORY,lstrlen(LOCAL_SOURCE_DIRECTORY)))
        {
            if(!FBuildFullDstPath(szFullPathDst, pcln->szDstDir, psfd, FALSE)) {
                if (!FHandleOOM(hwndFrame)) {
                    return(!fVital);
                }
            }

            if(FFileExists(szFullPathDst)) {
                return(fTrue);
            }
        }

        if ((eerc = EercErrorHandler(hwndFrame, grcOpenFileErr, fVital,
                szFullPathSrc, 0, 0)) != eercRetry) {
            return(eerc == eercIgnore);
        }

    }
    if (szSrcDollar) {
        SFree( szSrcDollar);
        szSrcDollar = (SZ)NULL;
    }

    //
    // Determine the destination file name:
    //

    if (!FBuildFullDstPath(szFullPathDst, pcln->szDstDir, psfd, fCompressedName) ||
            !FValidPath(szFullPathDst)) {
        EvalAssert(EercErrorHandler(hwndFrame, grcInvalidPathErr, fVital,
                pcln->szDstDir, psfd->szFile, 0) == eercAbort);
        return(!fVital);
    }

    fDstExists = FFileFound(szFullPathDst);

#ifdef REMOTE_BOOT
    if (1) { //BUGBUG: how to turn on SIS check here?
        DWORD rc;
        if (!fCompressedName) {
            rc = CreateTargetAsLinkToMaster(
                    szFullPathSrc,
                    szFullPathDst,
                    fDstExists
                    );
            if (rc == NO_ERROR) {
                return TRUE;
            }
        }
    }
#endif

    if (fDstExists != fFalse) {
        OWM  owm;
        YNRC ynrc;

        //
        // Check overwrite mode.  The overwrite mode can be:
        //
        // 1. Never      : No further checking.  The file is not copied
        //
        // 2. Unprotected: Check to see if file on destination is readonly.
        //
        // 3. Older      : The release version / date is checked against the
        //                 the destination file
        //
        // 4. VerifySourceOlder: The checking is postponed till we have actually
        //                       found the source file.  The source time is then
        //                       compared against the destination time and only
        //                       if the destination is older the file is copied.

        if ((owm = poer->owm) & owmNever) {

            return(fTrue);

        }
        else if (owm & owmUnprotected) {

            while ((ynrc = YnrcFileReadOnly(szFullPathDst)) == ynrcErr1) {
                if ((eerc = EercErrorHandler(hwndFrame, grcReadFileErr, fVital,
                        szFullPathDst, 0, 0)) != eercRetry) {
                    return(eerc == eercIgnore);
                }
            }

            if (ynrc == ynrcYes) {
                return(fTrue);
            }

        }
        else if (owm & owmOlder) {

            while ((ynrc = YnrcNewerExistingFile(dateSrc, szFullPathDst,
                        poer->ulVerMS, poer->ulVerLS)) != ynrcYes
                    && ynrc != ynrcNo) {
                if (ynrc == ynrcErr1 &&
                        (eerc = EercErrorHandler(hwndFrame, grcOpenFileErr,
                                fVital, szFullPathDst, 0, 0)) != eercRetry)
                    return(eerc == eercIgnore);
                else if (ynrc == ynrcErr2 &&
                        (eerc = EercErrorHandler(hwndFrame, grcReadFileErr,
                                fVital, szFullPathDst, 0, 0)) != eercRetry)
                    return(eerc == eercIgnore);
                else if (ynrc == ynrcErr3 &&
                        (eerc = EercErrorHandler(hwndFrame, grcCloseFileErr,
                                fVital, szFullPathDst, 0, 0)) != eercRetry)
                    return(eerc == eercIgnore);
            }

            if (ynrc == ynrcYes)
                return(fTrue);
            Assert(ynrc == ynrcNo);

        }

    }
    else {

        //
        // Destination doesn't exist, check to see if we are in upgradeonly
        // mode, in which case we need not copy the file and we can just
        // return.

        OEF oef = poer->oef;

        if ( oef & oefUpgradeOnly ) {
            return( fTrue );
        }

    }

    //
    // If destination exists then we need to preserve the security that is
    // there on the file.  We read the security on the existing file
    // and once the new file is copied over then we set the security read
    // on the new file.  Note that we don't do this for initial setup since
    // we are going to fix permissions on the file anyway.
    //

    if(fDstExists && !fInitialSetup) {
        if(!FGetFileSecurity(szFullPathDst, &Sd, &SdLen)) {
            return( fFalse );
        }
    }

    if (fDstExists &&
            poer->szBackup != NULL)
        {
        YNRC ynrc;

        if ((ynrc = YnrcBackupFile(szFullPathDst, poer->szBackup, psfd)) !=
                ynrcYes)
            return(ynrc != ynrcNo);
        fDstExists = FFileFound(szFullPathDst);
        }

    if (fDstExists)
        {
        while (!FSetFileReadOnlyStatus(szFullPathDst, fOff))
            {
            if ((eerc = EercErrorHandler(hwndFrame, grcWriteFileErr, fVital,
                    szFullPathDst, 0, 0)) != eercRetry)
                return(eerc == eercIgnore);
            }
        }

    if(!fSilentSystem) {

        LPSTR p;
        CHAR  chSave;

        EvalAssert((p = SzFindFileFromPath(szFullPathSrc)) != NULL);
        if(!p) {
            p = szFullPathSrc;
        }
        wsprintf(rgchBufTmpLong,"%s %s",GaugeText1,p);
        ProSetText(ID_STATUS1,rgchBufTmpLong);

        EvalAssert((p = SzFindFileFromPath(szFullPathDst)) != NULL);
        if(p) {
            if(!ISUNC(szFullPathDst) && (p - szFullPathDst != 3)) {    // account for file in root
                p--;
            }
            chSave = *p;
            *p = '\0';
            wsprintf(rgchBufTmpLong,"%s %s",GaugeText2,szFullPathDst);
            *p = chSave;
        } else {
            rgchBufTmpLong[0] = '\0';
        }
        ProSetText(ID_STATUS2,rgchBufTmpLong);
    }

    lSize = (poer->ctuCopyTime > 0) ? (LONG)(poer->ctuCopyTime) : poer->lSize;
    if (!FCopy(szFullPathSrc, szFullPathDst, poer->oef, poer->owm,
            (poer->szAppend != NULL),
            (int)((DWORD)10000 * lSize / lTotalSize), dateSrc,psdle,szNonCompressedFullPathSrc))
        return(fFalse);

    if( Sd ) {
        //
        //    BUGBUG -
        //
        //  Preservation of file security is broken, since the most files
        //  were overwritten during textmode setup.
        //  So this is currently disabled.
        //
        // BOOL Status;
        // Status = FSetFileSecurity(szFullPathDst, Sd);
        SFree(Sd);
        // return(Status);
    }

    return(fTrue);
}


/*
**  Purpose:
**      Uses the Compression DollarSign translation algorithm on its argument.
**      If the file has no extension, then '._' is added.  If the extension
**      has less than 3 characters, then a '_' is appended.  Otherwise, the
**      third character of the extension is replaced by a dollarsign.
**  Arguments:
**      szFullPathSrc:  a zero terminated character string containing the fully
**          qualified path (including drive) for the source file.
**  Returns:
**
**************************************************************************/
SZ APIENTRY SzGetSrcDollar(SZ szFullPathSrc,CHAR ch)
{
    SZ szDot = (SZ)NULL;
    SZ szCur = szFullPathSrc;
    CHAR dotch[3];

    dotch[0] = '.';
    dotch[1] = ch;
    dotch[2] = 0;

    ChkArg(szFullPathSrc != (SZ)NULL, 1, (SZ)NULL);

    while (*szCur != '\0')
        {
        if (*szCur == '.')
            szDot = szCur;
        else if (*szCur == '\\')
            szDot = (SZ)NULL;
        szCur = SzNextChar(szCur);
        }

    Assert(szDot == (SZ)NULL || *szDot == '.');
    if (szDot == (SZ)NULL)
        {
        if ((szDot = (SZ)SAlloc(strlen(szFullPathSrc) + 3)) != (SZ)NULL)
            {
            EvalAssert(strcpy(szDot, szFullPathSrc) == szDot);
            EvalAssert(SzStrCat(szDot, dotch) == szDot);
            }
        }
    else
        {
        CHP chpSav = '\0';
        SZ  szRest;
        CB  cb;

        if (*(szCur = ++szDot) != '\0' &&
                *(szCur = SzNextChar(szCur)) != '\0' &&
                *(szCur = SzNextChar(szCur)) != '\0')
            {
            chpSav = *szCur;
            szRest = SzNextChar(szCur);
            *szCur = '\0';
            }

        cb = strlen(szFullPathSrc) + 2;
        if (chpSav != '\0')
            {
            Assert(szRest != (SZ)NULL);
            cb += strlen(szRest);
            }

        if ((szDot = (SZ)SAlloc(cb)) != (SZ)NULL)
            {
            EvalAssert(strcpy(szDot, szFullPathSrc) == szDot);
            EvalAssert(SzStrCat(szDot, &dotch[1]) == szDot);

            if (chpSav != '\0')
                {
                Assert(szRest != (SZ)NULL);
                EvalAssert(SzStrCat(szDot, szRest) == szDot);
                *szCur = chpSav;
                }
            }
        }

    return(szDot);
}

static int iTickMax = 0;
static int iTickCur = 0;

int far WFromW(int iTick)
{
    if (iTick > iTickMax - iTickCur)
        iTick = iTickMax - iTickCur;

    if (iTick > 0)
        {
        ProDeltaPos(iTick);
        iTickCur += iTick;
        }

    return(1);
}


/*
**  Purpose:
**      To physically copy the source file to the destination file.  This
**      can include several options including appending, open and closing src
**      and dst files, but not actually copying the contents of the files,
**      decompressing, timestamping the dst file, and setting the read only
**      status of the dst file.
**  Arguments:
**      szFullPathSrc:  a zero terminated character string containing the fully
**          qualified path (including drive) for the source file.
**      szFullPathDst: a zero terminated character string containing the fully
**          qualified path (including drive) for the destination file.
**      oef:            option element flags for the Section-File Description
**          The valid flags include oefVital, oefCopy, oefUndo,
**          oefRoot, oefDecompress, oefTimeStamp, oefReadOnly,
**          oefNone and oefAll.
**      fAppend:        fTrue if the contents of szFullPathSrc are to be
**          appended to the contents of szFullPathDst.
**      cProgTicks:     number of ticks to advance Progress Gizmo.
**      dateSrc:        DATE value from INF for src file.
**  Returns:
**      fTrue if the copy is successfully completed, fFalse otherwise.
**
**************************************************************************/
BOOL APIENTRY
FCopy(
    SZ szFullPathSrc,
    SZ szFullPathDst,
    OEF oef,
    OWM owm,
    BOOL fAppend,
    int cProgTicks,
    USHORT dateSrc,
    PSDLE psdle,
    SZ szNonCompressedFullPathSrc
    )
{
#if 0
    CB      cbSize;
    CB      cbActual;
#endif
    PB      pbBuffer = NULL;
    PFH     pfhSrc = NULL;
    PFH     pfhDst = NULL;
    LFA     lfaDst = 0L;
    HANDLE  hSource = NULL;
    BOOL    fVital = oef & oefVital;
    BOOL    fDecomp = oef & oefDecompress;
    BOOL    fRet = !fVital;
    BOOL    fRemovePartialFile = fFalse;
    EERC    eerc;
    YNRC    ynrc;
    FILETIME CreateTime, AccessTime, WriteTime;
    BOOL    fSilentSystem = FGetSilent();
    LONG    lRet;
    ULONG   Checksum = 0;
    BOOL    fThirdPartyFile = oef & oefThirdPartyFile;
    BOOL    OnLocalSource;
    BOOLEAN IsValid;
    BOOLEAN IsNtImage;
    BOOL    fCsdInstall = oef & oefCsdInstall;
    SZ      szActiveFileTmpName = NULL;

    if( fCsdInstall &&
        DoesFileReplaceThirdPartyFile( szFullPathDst+2 ) ) {
        return( TRUE );
    }

    OnLocalSource = (_strnicmp(szFullPathSrc+2,LOCAL_SOURCE_DIRECTORY,lstrlen(LOCAL_SOURCE_DIRECTORY)) == 0);

    do {
        while ((pfhSrc = PfhOpenFile(szFullPathSrc, ofmRead)) == (PFH)NULL) {

            if ((eerc = EercErrorHandler(hwndFrame, grcOpenFileErr, fVital,
                    szFullPathSrc, 0, 0)) != eercRetry) {
                fRet = (eerc == eercIgnore);
                goto LCopyError;
            }
        }

        while (!GetFileTime((HANDLE)LongToHandle(pfhSrc->iDosfh), &CreateTime, &AccessTime,
                &WriteTime)) {
            if ((eerc = EercErrorHandler(hwndFrame, grcReadFileErr, fVital,
                    szFullPathSrc, 0, 0)) != eercRetry) {
                fRet = (eerc == eercIgnore);
                goto LCopyError;
            }
        }


        if (!(oef & oefCopy))
            {
            if (!FCloseFile(pfhSrc))
                while ((eerc = EercErrorHandler(hwndFrame, grcCloseFileErr, fVital,
                        szFullPathSrc, 0, 0)) != eercRetry)
                    {
                    fRet = (eerc == eercIgnore);
                    goto LCopyError;
                    }
            pfhSrc = NULL;

            if (cProgTicks > 0 && !fSilentSystem)
                ProDeltaPos(cProgTicks);

            fRet = fTrue;
            goto DelSrc;
            }

        if(FFileFound(szFullPathDst)) {

            //
            // We need to check if we have been asked to compare actual file times
            //

            if ( owm & owmVerifySourceOlder ) {

                PFH      pfh;
                FILETIME DstWriteTime;
                BOOL     Older = fFalse;

                if ((pfh = PfhOpenFile(szFullPathDst, ofmRead)) != NULL) {

                    if (GetFileTime((HANDLE)LongToHandle(pfh->iDosfh), NULL, NULL, &DstWriteTime)) {

                        if( CompareFileTime( &DstWriteTime, &WriteTime ) == -1 ) {
                            Older = fTrue;
                        }

                    }
                    FCloseFile(pfh);
                }

                if( !Older ) {

                    FCloseFile(pfhSrc);
                    pfhSrc = NULL;

                    if (cProgTicks > 0 && !fSilentSystem)
                        ProDeltaPos(cProgTicks);

                    fRet = fTrue;
                    goto DelSrc;
                }
            }

            //
            // if this is a CSD, then we need to back up the old file in case
            // the copy fails for some reason.  (We also gotta make sure that
            // the files aren't the same, otherwise we'll get a bogus error)
            //
            if( fCsdInstall && lstrcmpi(szFullPathSrc, szFullPathDst) ) {
                //
                // We don't want to back up the file again, if we're retrying
                //
                if(!szActiveFileTmpName) {
                    while(!(szActiveFileTmpName = FRenameActiveFile(szFullPathDst))) {

                        //
                        // Error opening, present critical error to user
                        //

                        if ((eerc = EercErrorHandler(hwndFrame, grcOpenFileErr, fVital,
                            szFullPathDst, 0, 0)) != eercRetry) {

                            fRet = (eerc == eercIgnore);
                            goto LCopyError;
                        }
                    }
                }
            }
        }


        if ((ynrc = YnrcEnsurePathExists(szFullPathDst, fVital, NULL)) != ynrcYes)
            {
            fRet = (ynrc == ynrcErr1);
            goto LCopyError;
            }

        while ((pfhDst = PfhOpenFile(szFullPathDst,
                (OFM)(fAppend ? ofmReadWrite : ofmCreate))) == NULL) {

            DWORD dw;

            dw = GetLastError();

            //
            // if it is a sharing violation and this is because both the source
            // and destination are the same, then present the error to the user.
            //

            if (dw == ERROR_SHARING_VIOLATION && !lstrcmpi(szFullPathSrc, szFullPathDst)) {
                if ((eerc = EercErrorHandler(hwndFrame, grcOpenSameFileErr, fFalse,
                    szFullPathDst, 0, 0)) != eercRetry) {

                    fRet = (eerc == eercIgnore);
                    goto LCopyError;
                }
                else {
                    continue;
                }
            }

            //
            // For active files access will be denied
            //

            if(((dw == ERROR_ACCESS_DENIED) || (dw == ERROR_SHARING_VIOLATION) || (dw == ERROR_USER_MAPPED_FILE))
            && !fAppend) {
                //
                // make sure we don't already have a backup (if this is a retry)
                //
                if((szActiveFileTmpName) || (szActiveFileTmpName = FRenameActiveFile(szFullPathDst))) {
                    continue;
                }
            }

            //
            // Error opening, present critical error to user
            //

            if ((eerc = EercErrorHandler(hwndFrame, grcOpenFileErr, fVital,
                szFullPathDst, 0, 0)) != eercRetry) {

                fRet = (eerc == eercIgnore);
                goto LCopyError;
            }

        }

        fRemovePartialFile = fTrue;

        if (fAppend) {
            USHORT dateDst, timeDst;

            while(!GetFileTime((HANDLE)LongToHandle(pfhDst->iDosfh), NULL, NULL, &WriteTime)
                    || !FileTimeToDosDateTime(&WriteTime, &dateDst, &timeDst)) {
                if ((eerc = EercErrorHandler(hwndFrame, grcReadFileErr, fVital,
                        szFullPathDst, 0, 0)) != eercRetry) {
                    fRet = (eerc == eercIgnore);
                    goto LCopyError;
                }
            }

            if (dateDst != dateSrc || timeDst != 0) {
                fRet = fTrue;
                fRemovePartialFile = fFalse;
                goto LCopyError;
            }

            while ((lfaDst =  LfaSeekFile(pfhDst, 0, sfmEnd)) == (LFA)(-1)) {
                if ((eerc = EercErrorHandler(hwndFrame, grcReadFileErr, fVital,
                        szFullPathDst, 0, 0)) != eercRetry) {
                    fRet = (eerc == eercIgnore);
                    goto LCopyError;
                }
            }
        }

        if (fDecomp) {
            INT rc;
            while ((rc = LZInit( pfhSrc->iDosfh) ) < 0) {
                GRC grc;

                switch (rc) {

                case LZERROR_UNKNOWNALG:
                    grc = grcDecompUnknownAlgErr;
                    break;

                case LZERROR_GLOBLOCK:
                case LZERROR_READ:
                case LZERROR_BADINHANDLE:
                    grc = grcReadFileErr;
                    break;

                case LZERROR_GLOBALLOC:
                    grc = grcOutOfMemory;
                    break;

                default:
                    grc = grcDecompGenericErr;
                    break;

                }

                if ((eerc = EercErrorHandler(hwndFrame, grc, fVital, szFullPathSrc,
                        0, 0)) != eercRetry) {
                    fRet = (eerc == eercIgnore);
                    hSource = NULL;
                    goto LCopyError;
                }
            }
            hSource = (HANDLE)LongToHandle(rc);
        }
        else {
            hSource = (HANDLE)LongToHandle(pfhSrc->iDosfh);
        }

        if (fDecomp) {

            BOOL isDiamondFile;

            iTickMax = cProgTicks;
            iTickCur = 0;

            //
            // Determine whether the file is a diamond cabinet/compressed file.
            // If it is, we'll call a separate diamond decompressor.  If it isn't,
            // we'll call the lz routine, which will decompress an lz file or copy
            // a non-lz (and non-diamond) file.
            //
            isDiamondFile = IsDiamondFile(szFullPathSrc);

            do {

                if(isDiamondFile) {
                    lRet = DecompDiamondFile(
                                szFullPathSrc,
                                (HANDLE)LongToHandle(pfhDst->iDosfh),
                                fSilentSystem ? NULL: WFromW,
                                cProgTicks
                                );
                } else {
                    lRet = LcbDecompFile(
                                hSource,
                                (HANDLE)LongToHandle(pfhDst->iDosfh),
                                fSilentSystem ? NULL: WFromW,
                                cProgTicks
                                );
                }

                if(lRet < 0) {

                    GRC grc;
                    SZ  sz = szFullPathSrc;

                    switch (lRet) {

                    case rcReadError:
                    case rcReadSeekError:
                        grc = grcReadFileErr;
                        break;

                    case rcWriteError:
                    case rcWriteSeekError:
                        grc = grcWriteFileErr;
                        sz = szFullPathDst;
                        break;

                    case rcOutOfMemory:
                        grc = grcOutOfMemory;
                        break;
                    case rcDiskFull:
                        grc = grcDiskFull;
                        fVital = TRUE;
                        break;

                    case rcUserQuit:
                        fRet = fFalse;
                        goto LCopyError;
                        break;

                    default:
                        grc = grcDecompGenericErr;
                        break;
                    }

                    if ((eerc = EercErrorHandler(hwndFrame, grc, fVital, sz)) !=
                            eercRetry)
                    {
                        fRet = (eerc == eercIgnore);
                        goto LCopyError;
                    }

                    //
                    // Before retrying we need to rewind the destination pointer to
                    // the place where we began the write
                    //

                    while (LfaSeekFile(pfhDst, lfaDst, sfmSet) == (LFA)(-1)) {
                        if ((eerc = EercErrorHandler(hwndFrame, grcReadFileErr, fVital,
                                szFullPathDst, 0, 0)) != eercRetry) {
                            fRet = (eerc == eercIgnore);
                            goto LCopyError;
                        }
                    }
                }
            } while(lRet < 0);

            Assert(iTickCur <= cProgTicks);
            cProgTicks -= iTickCur;
        }
        else {
            iTickMax = cProgTicks;
            iTickCur = 0;
            while ((lRet = LcbCopyFile(
                               hSource,
                               (HANDLE)LongToHandle(pfhDst->iDosfh),
                               fSilentSystem ? NULL: WFromW,
                               cProgTicks
                               )) < 0) {

                GRC grc;
                SZ  sz = szFullPathSrc;

                switch (lRet) {

                case rcReadError:
                case rcReadSeekError:
                    grc = grcReadFileErr;
                    break;

                case rcWriteError:
                case rcWriteSeekError:
                    grc = grcWriteFileErr;
                    sz = szFullPathDst;
                    break;

                case rcOutOfMemory:
                    grc = grcOutOfMemory;
                    break;
                case rcDiskFull:
                    grc = grcDiskFull;
                    fVital = TRUE;
                    break;

                case rcUserQuit:
                    fRet = fFalse;
                    goto LCopyError;
                    break;

                default:
                    grc = grcDecompGenericErr;
                    break;
                }

                if ((eerc = EercErrorHandler(hwndFrame, grc, fVital, sz)) !=
                        eercRetry)
                {
                    fRet = (eerc == eercIgnore);
                    goto LCopyError;
                }

                //
                // Before retrying we need to rewind the destination pointer to
                // the place where we began the write
                //

                while (LfaSeekFile(pfhDst, lfaDst, sfmSet) == (LFA)(-1)) {
                    if ((eerc = EercErrorHandler(hwndFrame, grcReadFileErr, fVital,
                            szFullPathDst, 0, 0)) != eercRetry) {
                        fRet = (eerc == eercIgnore);
                        goto LCopyError;
                    }
                }
            }


            Assert(iTickCur <= cProgTicks);
            cProgTicks -= iTickCur;

        }


        if (oef & oefTimeStamp)
            while (!SetFileTime((HANDLE)LongToHandle(pfhDst->iDosfh), &CreateTime, &AccessTime,
                    &WriteTime))
                if ((eerc = EercErrorHandler(hwndFrame, grcWriteFileErr, fVital,
                        szFullPathDst, 0, 0)) != eercRetry)
                    {
                    fRet = (eerc == eercIgnore);
                    goto LCopyError;
                    }

        if (fDecomp) {
            LZClose ( HandleToUlong(hSource) );
            FreePfh ( pfhSrc );
            hSource = NULL;
            pfhSrc  = NULL;

        }
        else {
            while (!FCloseFile(pfhSrc)) {
                if ((eerc = EercErrorHandler(hwndFrame, grcCloseFileErr, fVital,
                        szFullPathSrc, 0, 0)) != eercRetry)
                {
                    fRet = (eerc == eercIgnore);
                    goto LCopyError;
                }
            }
            pfhSrc = NULL;
        }

        //
        // If we get here, the file was copied successfully.
        // Close the file before we get the checksum
        //

        while (!FCloseFile(pfhDst)) {
            if ((eerc = EercErrorHandler(hwndFrame, grcCloseFileErr, fVital,
                    szFullPathDst, 0, 0)) != eercRetry)
            {
                fRet = (eerc == eercIgnore);
                goto LCopyError;
            }
        }
        pfhDst = NULL;

        ValidateAndChecksumFile( szFullPathDst,
                                 &IsNtImage,
                                 &Checksum,
                                 &IsValid );

        if(!IsValid) {
            if ((eerc = EercErrorHandler(hwndFrame, grcVerifyFileErr, fVital,
                    szFullPathDst, 0, 0)) != eercRetry)
            {
                fRet = (eerc == eercIgnore);
                goto LCopyError;
            }
        }

    } while(!IsValid);

    fRemovePartialFile = fFalse;

    //
    // At this point, we can delete the backup file we made (if we made one)
    //
    if(szActiveFileTmpName) {
        if(!FRemoveFile(szActiveFileTmpName)) {
            //
            // It must be locked, so set it to be deleted on reboot
            //
            AddFileToDeleteList(szActiveFileTmpName);
        }
        free(szActiveFileTmpName);
        szActiveFileTmpName = NULL;
    }

    if (oef & oefReadOnly)
        while (!FSetFileReadOnlyStatus(szFullPathDst, fOn))
            {
            if ((eerc = EercErrorHandler(hwndFrame, grcWriteFileErr, fVital,
                    szFullPathDst, 0, 0)) != eercRetry)
                {
                fRet = (eerc == eercIgnore);
                goto LCopyError;
                }
            }

    fRet = fTrue;


LCopyError:

    //
    // Log the file.
    //

    if(psdle && !(oef & oefNoLog) && !fCsdInstall) {
        LogOneFile( szNonCompressedFullPathSrc,
                    szFullPathDst,
                    psdle->szLabel,
                    Checksum,
                    psdle->szTagFile,
                    fThirdPartyFile
                  );
    }

    if (pbBuffer != (PB)NULL) {
        SFree(pbBuffer);
    }

    if (fDecomp && hSource != (HANDLE)NULL) {
        LZClose (HandleToUlong(hSource));
        FreePfh (pfhSrc);
    }
    else if (pfhSrc != (PFH)NULL) {
        EvalAssert(FCloseFile(pfhSrc));
    }

    if (pfhDst != (PFH)NULL) {
        EvalAssert(FCloseFile(pfhDst));
    }

    if (fRemovePartialFile) {

        FRemoveFile(szFullPathDst);

        if(szActiveFileTmpName) {
            MoveFile(szActiveFileTmpName, szFullPathDst);
            free(szActiveFileTmpName);
        }
    }

    //
    // If we have any remaining ticks on the gauge for this file,
    // go ahead and do them.  This could happen if the file copy was
    // aborted part way through.
    //
    if (cProgTicks > 0 && !fSilentSystem) {
        ProDeltaPos(cProgTicks);
    }

DelSrc:

    //
    // Determine whether we are supposed to delete the source file.  This
    // is the case when it is coming from a local source as created by the
    // DOS Setup program, and is not marked oefNoDeleteSource.
    //

    if(!fNTUpgradeSetup && OnLocalSource && !(oef & oefNoDeleteSource))
    {
        if (NULL == SzFindSymbolValueInSymTab("!STF_NETDELETEOVERIDE"))
        {
            DeleteFile(szFullPathSrc);
        }
    }

    return(fRet);
}


/*
**  Purpose:
**      To find a pointer to the beginning of the file name (i.e. primary.ext)
**      at the end of a fully qualified pathname.
**  Arguments:
**      szFullPath: a non-Null, zero-terminated string containing a
**          pathname ending in a file name.
**  Returns:
**      an SZ which is a pointer to the beginning of the file name within the
**      argument SZ.
**
**************************************************************************/
SZ APIENTRY SzFindFileFromPath(szFullPath)
SZ szFullPath;
{
    SZ sz;
    SZ szSave = szFullPath;

    ChkArg(szFullPath != (SZ)NULL && *szFullPath != '\0'
                && *SzLastChar(szFullPath) != '\\', 1, (SZ)NULL);

    for (sz = szFullPath; *sz != '\0'; sz = SzNextChar(sz))
        if (*sz == '\\')
            szSave = sz;

    Assert(szSave != NULL);
    if (*szSave == '\\')
        szSave = SzNextChar(szSave);
    Assert(szSave != NULL && *szSave != '\0');

    return(szSave);
}


/*
**  Purpose:
**      To find the beginning the beginning of the extension part of the file
**      name within a string containing a file name (without the preceeding
**      path name).
**  Arguments:
**      szFile: a zero terminated character string containing a valid file
**          name (without the preceeding path name).
**  Returns:
**      an SZ that points to the '.' that begins the extension or '\0' if the
**          file has no extension.
**
**************************************************************************/
SZ APIENTRY SzFindExt(szFile)
SZ szFile;
{
    ChkArg(szFile != (SZ)NULL, 1, (SZ)NULL);

    for ( ; *szFile != '\0' && *szFile != '.'; szFile = SzNextChar(szFile))
        ;

    return(szFile);
}


/*
**  Purpose:
**      Build full path (check for ROOT and RENAME options)
**  Arguments:
**      szPath: non-NULL buffer to fill with full path.
**      szDst:  non-NULL string for szDstDir supplied on script line.
**      psfd:   non-NULL pointer to the Section-File Description structure(SFD).
**  Assumes:
**      szPath large enough for result.
**  Returns:
**      fTrue if successfully able to create the path, fFalse otherwise.
**
**************************************************************************/
BOOL APIENTRY
FBuildFullDstPath(
    SZ   szPath,
    SZ   szDst,
    PSFD psfd,
    BOOL fCompressedName
    )
{
    SZ   szFile;
    SZ   szFileDollar = NULL;
    POER poer = &(psfd->oer);
    BOOL bStatus;

    ChkArg(szPath != (SZ)NULL, 1, fFalse);
    ChkArg(szDst  != (SZ)NULL && FValidDir(szDst), 2, fFalse);
    ChkArg(psfd != (PSFD)NULL, 3, fFalse);

    if (poer->szDest != NULL) {
        szDst = poer->szDest;
    }

    if (poer->szAppend != NULL) {
        szFile = poer->szAppend;
    }
    else if (poer->szRename != NULL) {
        szFile = poer->szRename;
    }
    else {
        if (poer->oef & oefRoot) {
            szFile = SzFindFileFromPath(psfd->szFile);
        }
        else {
            szFile = psfd->szFile;
        }

        if (!(poer->oef & oefDecompress) && fCompressedName) {
            while ((szFileDollar = SzGetSrcDollar(szFile,'_')) == (SZ)NULL) {
                if (!FHandleOOM(hwndFrame)) {
                    return(fFalse);
                }
            }
            szFile = szFileDollar;
        }
    }
    bStatus = FMakePathFromDirAndSubPath(szDst, szFile, szPath, cchpFullPathBuf);
    if ( szFileDollar ) {
        SFree( szFileDollar);
    }
    return(bStatus);
}

/*
**  Purpose:
**      Build full source path
**  Arguments:
**      szPath:    non-NULL buffer to store result in.
**      szDst:     non-NULL valid subpath for dest.
**      szFile:    non-NULL file name.
**      szNetPath: string pointer for netpath to use; NULL to ignore.
**  Assumes:
**      szPath large enough for result.
**  Returns:
**      fTrue if the path is built correctly, fFalse otherwise.
**
**************************************************************************/
BOOL APIENTRY FBuildFullSrcPath(szPath, szDst, szFile, szNetPath)
SZ szPath;
SZ szDst;
SZ szFile;
SZ szNetPath;
{
    CHP szPathTmp[cchpFullPathBuf];

    ChkArg(szPath != (SZ)NULL, 1, fFalse);
    ChkArg(szDst  != (SZ)NULL, 2, fFalse);
    ChkArg(szFile != (SZ)NULL, 3, fFalse);

    if (szNetPath == NULL)
        return(FMakePathFromDirAndSubPath(szDst, szFile, szPath,
            cchpFullPathBuf));
    else if (FMakePathFromDirAndSubPath(szDst, szNetPath, szPathTmp,
                cchpFullPathBuf) &&
            FMakePathFromDirAndSubPath(szPathTmp, szFile, szPath,
                cchpFullPathBuf))
        return(fTrue);
    else
        return(fFalse);
}


/*
**  Purpose:
**      Build full BackupPath
**  Arguments:
**      szPath: non-NULL buffer to store result in.
**      szDst:  non-NULL valid subpath for dest.
**      psfd:   non-NULL SFD pointer.
**  Assumes:
**      szPath large enough for result.
**  Returns:
**      fTrue if successful; fFalse otherwise.
**
**************************************************************************/
BOOL APIENTRY FBuildFullBakPath(szPath, szDst, psfd)
SZ   szPath;
SZ   szDst;
PSFD psfd;
{
    SZ sz;

    ChkArg(szPath != (SZ)NULL, 1, fFalse);
    ChkArg(szDst != (SZ)NULL && *szDst != '\0', 2, fFalse);
    ChkArg(psfd != (PSFD)NULL && (psfd->oer).szBackup != NULL, 3, fFalse);

    EvalAssert(szPath == szDst || strcpy(szPath, szDst) == szPath);
    sz = SzFindFileFromPath(szPath);
    Assert(sz != NULL && *sz != '\0');

    if (*((psfd->oer).szBackup) == '*')
        {
        sz = SzFindExt(szPath);
        *sz++ = '.';
        *sz++ = 'B';   /* REVIEW INTL */
        *sz++ = 'A';
        *sz++ = 'K';
        *sz++ = '\0';
        return(fTrue);
        }

    *sz = '\0';
    return(FMakePathFromDirAndSubPath(szPath, (psfd->oer).szBackup, szPath,
                cchpFullPathBuf));
}


/*
**  Purpose:
**      Verifies given file actually exists.
**  Arguments:
**  Returns:
**
**************************************************************************/
BOOL APIENTRY FFileFound(szPath)
SZ szPath;
{
    WIN32_FIND_DATA ffd;
    HANDLE          SearchHandle;

    ChkArg(szPath != (SZ)NULL &&
            *szPath != '\0', 1, fFalse);

    if ( (SearchHandle = FindFirstFile( szPath, &ffd )) == INVALID_HANDLE_VALUE ) {
        return( fFalse );
    }
    else {
        FindClose( SearchHandle );
        return( fTrue );
    }
}


/*
**  Purpose:
**  Arguments:
**  Returns:
**
**************************************************************************/
BOOL APIENTRY FYield(VOID)
{
    MSG  msg;
    BOOL fRet = fTrue;

    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
        if (hwndProgressGizmo != NULL
                && IsDialogMessage(hwndProgressGizmo, &msg))
            continue;

        if (msg.message == WM_QUIT)
            fRet = fFalse;

//        if (CheckSpecialKeys(&msg))
//            continue;

        TranslateMessage(&msg);
        DispatchMessage(&msg);
        }

    return(fRet);
}


/*
**  Purpose:
**      To check and see if the directory specified in szFullPathDst exists.
**      If not, it will create the directory (including any intermediate
**      directories).  For example if szFullPathDst = "c:\\a\\b\\File" and
**      none of these directories exist (i.e. a or b) they will all be
**      created so that the complete path exists (File is not created).
**  Arguments:
**      szFullPathDst: The complete pathname (including drive) of the directory
**          in question.
**      fCritical:     if fTrue success of this operation is required for
**          success of the setup program as a whole. Setup will be terminated
**          if fCritical is fTrue and this function fails.
**      szMsg:         The complete pathname (including drive) of the directory
**          to display in an error.  If NULL use szFullPathDst.
**  Returns:
**      a YNRC error code (see _filecm.h) indicating the outcome of this
**      function.
**
**************************************************************************/
YNRC APIENTRY YnrcEnsurePathExists(szFullPathDst, fCritical, szMsg)
SZ   szFullPathDst;
BOOL fCritical;
SZ   szMsg;
{
    CHP     szTmp[cchpFullPathBuf];
    SZ      sz;
    DWORD   Attr;
    EERC    eerc;
    YNRC    ynrc = ynrcYes;

    ChkArg(FValidPath(szFullPathDst),1,ynrcNo);

    if (szMsg == (SZ)NULL) {
        szMsg = szFullPathDst;
    }

    EvalAssert(strcpy((SZ)szTmp, szFullPathDst) ==
            (SZ)szTmp);

    EvalAssert((sz = SzFindFileFromPath(szTmp)) != (SZ)NULL);
    EvalAssert((sz = SzPrevChar(szTmp, sz)) != (SZ)NULL);
    Assert(*sz == '\\');
    *sz = '\0';

    while ( !( ((Attr = GetFileAttributes(szTmp)) != 0xFFFFFFFF  && (Attr & FILE_ATTRIBUTE_DIRECTORY ))
               || CreateDirectory( szTmp, NULL )
             )
          ) {
        if ((eerc = EercErrorHandler(hwndFrame, grcCreateDirErr, fCritical,
                szMsg, 0, 0)) != eercRetry) {
            ynrc = (eerc == eercIgnore) ? ynrcErr1 : ynrcNo;
            break;
        }
    }
    return( ynrc );
}


int
DetermineDriveType(
    IN CHAR DriveLetter
    )

/*++

Routine Description:

    Determine whether a drive is removable media -- which can be
    a floppy or a CD-ROM. Removeable hard drives are NOT considered
    removeable by this routine.

Arguments:

    DriveLetter - supplies drive letter of drive to check. If this
        is not a valid alpha char, FALSE is returned.

Return Value:

    -2 - Drive is a CD-ROM
    -1 - Drive is some other removeable type (such as floppy)
     0 - Drive is not removeable (or we couldn't tell)

--*/

{
    CHAR Name[4];
    UINT DriveType;
    CHAR DevicePath[MAX_PATH];

    Name[0] = DriveLetter;
    Name[1] = ':';
    Name[2] = '\\';
    Name[3] = 0;

    DriveType = GetDriveType(Name);

    if(DriveType == DRIVE_REMOVABLE) {

        Name[2] = 0;

        if(QueryDosDevice(Name,DevicePath,MAX_PATH)) {
            CharUpper(DevicePath);
            if(strstr(DevicePath,"HARDDISK")) {
                DriveType = DRIVE_FIXED;
            }
        }
    }

    if(DriveType == DRIVE_REMOVABLE) {
        return(-1);
    }

    if(DriveType == DRIVE_CDROM) {
        return(-2);
    }

    return(0);
}


/*
**  Purpose:
**  Arguments:
**      hInstance:  non-NULL instance handle for getting strings from
**          resources for SwapDisk message Box.
**      szLabel:  non-Null zero-terminated ANSI string to display as the
**          label of the diskette to prompt for.
**      szSrcDir: non-Null zero-terminated ANSI string to display as the
**          drive/directory the user is to insert the diskette into.
**  Returns:
**
**************************************************************************/
BOOL APIENTRY FPromptForDisk(hInstance, szLabel, szSrcDir)
HANDLE hInstance;
SZ     szLabel;
SZ     szSrcDir;
{
    CHAR szTmpText[cchpBufTmpLongMax];
    CHAR rgchBuf[3*cchpFullPathBuf];
    BOOL fRet;
    HWND hwndSav;

    ChkArg(hInstance,1,fFalse);
    ChkArg(szLabel && *szLabel &&
            strlen(szLabel) <= cchpFullPathMax, 2, fFalse);
    ChkArg(szSrcDir &&
            *szSrcDir &&
            strlen(szSrcDir) <= cchpFullPathMax, 3, fFalse);

    EvalAssert(LoadString(hInstance, IDS_INS_DISK, rgchBuf,3*cchpFullPathBuf));
    EvalAssert(SzStrCat(rgchBuf, szLabel) == rgchBuf);
    EvalAssert(LoadString(hInstance, IDS_INTO, szTmpText,
            cchpBufTmpLongMax));
    EvalAssert(SzStrCat(rgchBuf, szTmpText) == rgchBuf);
    EvalAssert(SzStrCat(rgchBuf, szSrcDir) == rgchBuf);

    EvalAssert(LoadString(hInstance, IDS_ERROR, szTmpText,
            cchpBufTmpLongMax));

    hwndSav = GetFocus();
    fRet = (MessageBox(hwndFrame,rgchBuf,szTmpText,MB_OKCANCEL|MB_TASKMODAL) == IDOK);
    SetFocus(hwndSav);
    SendMessage(hwndFrame, WM_NCACTIVATE, 1, 0L);

    return(fRet);
}


/*
**  Purpose:
**      To rename an active file as an del????.tmp file which will be deleted if
**      the new file is copied successfully.
**  Arguments:
**      szFullPath: Full pathname of active file
**  Returns:
**      The name of the renamed file, or NULL if unsuccessful.
**
**************************************************************************/
SZ APIENTRY
FRenameActiveFile(
    SZ szFullPath
    )
{
    SZ      szTmpName;
    CHP     szDir[MAX_PATH];
    SZ      sz;

    ChkArg ( szFullPath != NULL, 1, NULL);

    //
    // Try to find a temp filename we can use in the destination directory
    //

    lstrcpy( szDir, szFullPath );
    if( !(sz = strrchr( szDir, '\\')) ) {
        return NULL;
    }
    *sz = '\0';

    if(!(szTmpName = malloc((lstrlen(szDir) + 14) * sizeof(CHP)))) {
        return NULL;
    }

    if(!GetTempFileName( szDir, "del", 0, szTmpName )) {
        goto FileRenameFailed;
    }

    //
    // GetTempFileName creates the temp file.  It needs to be deleted
    //

    if (FFileFound(szTmpName) && !FRemoveFile(szTmpName)) {
        goto FileRenameFailed;
    }

    //
    // Rename the original file to this filename
    //

    if( MoveFile( szFullPath, szTmpName ) ) {
        return szTmpName;
    }

FileRenameFailed:

    free(szTmpName);
    return NULL;
}


BOOL
FGetFileSecurity(
    PCHAR File,
    PSECURITY_DESCRIPTOR *SdBuf,
    CB *SdLen
    )
{
    #define CBSDBUF 1024
    SECURITY_INFORMATION Si;
    PSECURITY_DESCRIPTOR Sd, SdNew;
    DWORD cbSd = CBSDBUF;
    DWORD cbSdReq;
    BOOL  FirstTime = fTrue;
    DWORD dw1, dw2;
    EERC    eerc;

    static CHAR  Root[MAX_PATH] = "\0";
    static BOOL  IsNtfs = FALSE;
    CHAR  VolumeFSName[MAX_PATH];

    //
    // Initialize
    //
    *SdBuf = NULL;

    //
    // Check if the volume information is in the cache, if not so get the
    // volume information and put it in the cache
    //

    if( Root[0] == '\0' ) {
        if( !ISUNC( File ) ) {
            strncpy( Root, File, 3 );
            Root[3] = '\0';
        } else {
            PCHAR   p;
            ULONG   n;

            p = File + 2;
            if( ( ( p = strchr( p, '\\' ) ) == NULL ) ||
                ( ( p = strchr( p + 1, '\\' ) ) == NULL ) ) {
                return( FALSE );
            }
            n = (ULONG)(p - File + 1);
            strncpy( Root, File, n );
            Root[ n ] = '\0';
        }
        while(!GetVolumeInformation( Root, NULL, 0, NULL, &dw1, &dw2, VolumeFSName, MAX_PATH )) {
            if ((eerc = EercErrorHandler(hwndFrame, grcGetVolInfo, FALSE, Root, File, 0)) != eercRetry) {
                return(eerc == eercIgnore);
            }
        }
        IsNtfs = !lstrcmpi( VolumeFSName, "NTFS" );
    }

    if(!IsNtfs) {
        return(TRUE);
    }

    //
    // Allocate memory for the security descriptor
    //
    while ((Sd = SAlloc(cbSd)) == NULL ) {
        if (!FHandleOOM(hwndFrame)) {
            return(fFalse);
        }
    }

    //
    // Get the security information from the source file
    //

    Si = OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION;
    while(!GetFileSecurity(File,Si,Sd,cbSd,&cbSdReq)) {
        if( FirstTime && (cbSdReq > cbSd) ) {
            while(!(SdNew = SRealloc(Sd,cbSdReq))) {
                if (!FHandleOOM(hwndFrame)) {
                    SFree(Sd);
                    return(fFalse);
                }
            }
            cbSd      = cbSdReq;
            Sd        = SdNew;
        }
        else {
            if ((eerc = EercErrorHandler(hwndFrame, grcGetFileSecurity, FALSE, File, 0, 0)) != eercRetry) {
                SFree(Sd);
                return(eerc == eercIgnore);
            }
        }
        FirstTime = fFalse;
    }

    *SdBuf = Sd;
    *SdLen = cbSd;
    return(TRUE);
}

BOOL
FSetFileSecurity(
    PCHAR File,
    PSECURITY_DESCRIPTOR SdBuf
    )
{
    EERC    eerc;
    SECURITY_INFORMATION Si;

    //
    // Set the Security on the dest file
    //
    Si = OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION;
    while(!SetFileSecurity(File, Si, SdBuf)) {
#if 0
        //
        //  BUGBUG - This is to find an error in DaveC's machine
        //
        CHAR    DbgBuffer[256];
        ULONG   Error;

        Error = GetLastError();
        sprintf( DbgBuffer, "SetFileSecurity() failed. \nFile = %s. \nError = %d \n\nPlease contact JaimeS at x65903", File, Error );
        MessageBox(NULL, DbgBuffer, "Debug Message",
                                MB_OK | MB_ICONHAND);
#endif

        if ((eerc = EercErrorHandler(hwndFrame, grcSetFileSecurity, FALSE, File, 0, 0)) != eercRetry) {
            return(eerc == eercIgnore);
        }
    }
    return(TRUE);
}

BOOL
DoesFileReplaceThirdPartyFile(
    SZ  szFullPathDst
    )

{
    CHAR    SetupLogFilePath[ MAX_PATH ];
    PSTR    SectionName;
    CHAR    ReturnBuffer[512];
    PSTR    DefaultString = "";
    PSTR    SectionsToSearch[] = {
                                 "Files.WinNt",
                                 "Files.SystemPartition"
                                 };
    ULONG   Count;
    BOOL    ReplaceThirdParty;

    *SetupLogFilePath = '\0';
    GetWindowsDirectory( SetupLogFilePath, sizeof( SetupLogFilePath ) );
    strcat( SetupLogFilePath, SETUP_REPAIR_DIRECTORY );
    strcat( SetupLogFilePath, SETUP_LOG_FILE );

    for( Count = 0;
         Count < sizeof( SectionsToSearch ) / sizeof( PSTR );
         Count++ ) {

        SectionName = SectionsToSearch[Count];
        *ReturnBuffer = '\0';
        GetPrivateProfileString( SectionName,
                                 szFullPathDst,
                                 DefaultString,
                                 ReturnBuffer,
                                 sizeof( ReturnBuffer ),
                                 SetupLogFilePath );

        if( *ReturnBuffer != '\0' ) {
            break;
        }
    }

    ReplaceThirdParty = FALSE;
    if( *ReturnBuffer != 0  ) {
        PSTR    SourceFileName;
        PSTR    ChkSumString;
        PSTR    DirectoryOnSourceDevice;
        PSTR    DiskDescription;
        PSTR    DiskTag;
        PSTR    Delimiters = "\" ,";

        SourceFileName = strtok( ReturnBuffer, Delimiters );
        SourceFileName = strtok( NULL, Delimiters );
        ChkSumString = strtok( NULL, Delimiters );
        DirectoryOnSourceDevice = strtok( NULL, Delimiters );
        DiskDescription = strtok( NULL, Delimiters );
        DiskTag = strtok( NULL, Delimiters );

        if( ( DiskDescription != NULL ) || ( DiskTag != NULL ) ) {
            ReplaceThirdParty = TRUE;
        }
    }
    return( ReplaceThirdParty );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\detect.h ===
/* File: detect.h */

/**************************************************************************/
/***** DETECT COMPONENT - Header file for detect commands.
/**************************************************************************/

extern BOOL  APIENTRY FDetectEntryPoint(HANDLE, HWND, RGSZ, USHORT);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\det_vol.c ===
#include "precomp.h"
#pragma hdrstop
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    det_vol.c

Abstract:

    Disk/volume related detect operations for Win32 PDK Setup.
    This module has no external dependencies and is not statically linked
    to any part of Setup.

Author:

    Ted Miller (tedm) June-August 1991

--*/

#define SPACE_FREE  1
#define SPACE_TOTAL 2


#define DRIVE_TYPE_REMOVABLE    "RMV"
#define DRIVE_TYPE_FIXED        "FIX"
#define DRIVE_TYPE_REMOTE       "REM"
#define DRIVE_TYPE_CDROM        "CDR"
#define DRIVE_TYPE_RAMDISK      "RAM"
#define DRIVE_TYPE_UNKNOWN      "?"


#define GET_TIME_CREATION       1
#define GET_TIME_LASTACCESS     2
#define GET_TIME_LASTWRITE      3


CB    GetTimeOfFile(RGSZ,USHORT,SZ,CB,DWORD);
CB    GetDrivesWorker(RGSZ,USHORT,SZ,CB,DWORD);
DWORD AreDrivesACertainType(DWORD,BOOL *);
VOID  ConstructDiskList(BOOL *,LPSTR);
CB    GetSpaceWorker(SZ,CB,DWORD);


//
// Routine to get a drive type.  Like GetDriveType() win32 api except
// it attempts to differentiate between removable hard drives and floppies.
// Removeable hard drives will returned as DRIVE_FIXED so we can use
// DRIVE_REMOVABLE as a symonym for "floppy."
//
UINT
MyGetDriveType(
    IN PSTR DriveName
    )
{
    CHAR DriveNameNt[MAX_PATH];
    UINT rc;

    //
    // First, get the win32 drive type.  If it tells us DRIVE_REMOVABLE,
    // then we need to see whether it's a floppy or hard disk.  Otherwise
    // just believe the api.
    //
    if((rc = GetDriveType(DriveName)) == DRIVE_REMOVABLE) {

        if(DosPathToNtPathWorker(DriveName,DriveNameNt)) {

            CharLower(DriveNameNt);

            if(!strstr(DriveNameNt,"floppy")) {
                rc = DRIVE_FIXED;
            }
        }
    }

    return(rc);
}



//
//  Gets unused drives
//

CB
GetUnusedDrives(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    SZ      sz;
    RGSZ    rgsz;
    DWORD   Disk;
    CHAR    szRoot[4] = "?:\\";
    CHAR    szDrive[3] = "?:";
    CB      cbRet;


    Unused( Args );
    Unused( cArgs );
    Unused( cbReturnBuffer );

    rgsz = RgszAlloc(1);
    for( Disk = 26; Disk > 0; Disk-- ) {

        szRoot[0] = (CHAR)(Disk - 1) + (CHAR)'A';
        if ( MyGetDriveType( szRoot ) == 1 ) {
            szDrive[0] = szRoot[0];
            RgszAdd( &rgsz, SzDup( szDrive ) );
        }
    }

    sz = SzListValueFromRgsz( rgsz );
    lstrcpy( ReturnBuffer, sz );
    cbRet = lstrlen( sz );

    SFree( sz );
    RgszFree( rgsz );

    return( cbRet + 1 );
}



//
//  Gets the type of a drive
//
CB
GetTypeOfDrive(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    SZ      szType;
    CHAR    szRoot[ MAX_PATH];
    SZ      sz;

    Unused( cbReturnBuffer );



    if ( (cArgs >= 1)  && (*(Args[0]) != '\0') ) {

        lstrcpy( szRoot, Args[0] );
        sz = szRoot + strlen(szRoot) -1;
        if ( *sz != '\\' ) {
            strcat( szRoot, "\\" );
        }

        switch (MyGetDriveType( szRoot )) {

        case 0:
        case 1:
            return 0;

        case DRIVE_REMOVABLE:
            szType = DRIVE_TYPE_REMOVABLE;
            break;

        case DRIVE_FIXED:
            szType = DRIVE_TYPE_FIXED;
            break;

        case DRIVE_REMOTE:
            szType = DRIVE_TYPE_REMOTE;
            break;

        case DRIVE_CDROM:
            szType = DRIVE_TYPE_CDROM;
            break;

        case DRIVE_RAMDISK:
            szType = DRIVE_TYPE_RAMDISK;
            break;

        default:
            szType = DRIVE_TYPE_UNKNOWN;
            break;

        }

    } else {
        szType= DRIVE_TYPE_UNKNOWN;
    }

    lstrcpy( ReturnBuffer, szType );
    return lstrlen( ReturnBuffer )+1;
}



//
//  Determines the existence of a directory
//
CB
DoesDirExist(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    DWORD   Attr;

    Unused( cbReturnBuffer );

    if ( cArgs == 0 ) {

        ReturnBuffer[0] = '\0';
        return 0;

    } else {

        Attr = GetFileAttributes( Args[0] );

        if ((Attr != -1) && ( Attr & FILE_ATTRIBUTE_DIRECTORY )) {
            lstrcpy( ReturnBuffer, "YES" );
        } else {
            lstrcpy( ReturnBuffer, "NO" );
        }
    }

    return lstrlen(ReturnBuffer)+1;
}


//
//  Determines the existence of a file
//
CB
DoesFileExist(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    DWORD   Attr;

    Unused( cbReturnBuffer );

    if ( cArgs == 0 ) {

        ReturnBuffer[0] = '\0';
        return 0;

    } else {

        Attr = GetFileAttributes( Args[0] );

        if ((Attr != -1) && !( Attr & FILE_ATTRIBUTE_DIRECTORY )) {
            lstrcpy( ReturnBuffer, "YES" );
        } else {
            lstrcpy( ReturnBuffer, "NO" );
        }
    }

    return lstrlen(ReturnBuffer)+1;
}



//
//  Get file size
//
CB
GetSizeOfFile(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{

    HANDLE          hff;
    WIN32_FIND_DATA ffd;
    DWORD           Size  = 0;

    #define ZERO_SIZE "0"

    Unused( cbReturnBuffer );
    ReturnBuffer[0] = '\0';

    if (cArgs > 0) {

        //
        // get find file information and get the size information out of
        // that
        //

        if ((hff = FindFirstFile(Args[0], &ffd)) != INVALID_HANDLE_VALUE) {
            Size = ffd.nFileSizeLow;
            _ltoa(Size, ReturnBuffer, 10);
            FindClose(hff);
            return lstrlen(ReturnBuffer)+1;
        }
    }

    //
    // If file not specified or file not found default return 0 size
    //

    lstrcpy( ReturnBuffer, ZERO_SIZE );
    return lstrlen(ReturnBuffer)+1;
}



//
//  Obtains creation time of a file
//
CB
GetFileCreationTime(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    return GetTimeOfFile( Args, cArgs, ReturnBuffer, cbReturnBuffer, GET_TIME_CREATION );
}



//
//  Obtains last access time of a file
//
CB
GetFileLastAccessTime(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    return GetTimeOfFile( Args, cArgs, ReturnBuffer, cbReturnBuffer, GET_TIME_LASTACCESS );
}



//
//  Obtains last write time of a file
//
CB
GetFileLastWriteTime(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    return GetTimeOfFile( Args, cArgs, ReturnBuffer, cbReturnBuffer, GET_TIME_LASTWRITE );
}




//
//  Obtains any time of a file
//
CB
GetTimeOfFile(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer,
    IN  DWORD   WhatTime
    )
{
    HANDLE      Handle;
    FILETIME    TimeCreation;
    FILETIME    TimeLastAccess;
    FILETIME    TimeLastWrite;
    FILETIME    WantedTime;

    Unused( cbReturnBuffer );

    ReturnBuffer[0] = '\0';

    if ( ( cArgs > 0)                    &&
         (WhatTime >= GET_TIME_CREATION) &&
         (WhatTime <= GET_TIME_LASTWRITE) ) {

        Handle = CreateFile( Args[0],
                             GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             0,
                             NULL );

        if ( Handle != INVALID_HANDLE_VALUE ) {

            if ( GetFileTime( Handle, &TimeCreation, &TimeLastAccess, &TimeLastWrite ) ) {

                switch( WhatTime ) {

                case GET_TIME_CREATION:
                    WantedTime = TimeCreation;
                    break;

                case GET_TIME_LASTACCESS:
                    WantedTime = TimeLastAccess;
                    break;

                case GET_TIME_LASTWRITE:
                    WantedTime = TimeLastWrite;
                    break;

                default:
                    break;

                }
            }

            CloseHandle( Handle );

            wsprintf( ReturnBuffer, "{\"%lu\",\"%lu\"}", WantedTime.dwLowDateTime,
                      WantedTime.dwHighDateTime );
            return lstrlen(ReturnBuffer)+1;
        }
    }

    return 0;
}



/*
    Return a list of floppy drive letters
*/
CB
GetFloppyDriveLetters(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    return(GetDrivesWorker(Args,
                           cArgs,
                           ReturnBuffer,
                           cbReturnBuffer,
                           DRIVE_REMOVABLE
                          )
          );
}


/*
    Return a list of hard drive letters
*/
CB
GetHardDriveLetters(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    return(GetDrivesWorker(Args,
                           cArgs,
                           ReturnBuffer,
                           cbReturnBuffer,
                           DRIVE_FIXED
                          )
          );
}


/*
    Return a list of filesystems on all hard drive volumes.
*/
CB
GetHardDriveFileSystems(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    BOOL  HardDisk[26];
    DWORD Disk;
    LPSTR InsertPoint = ReturnBuffer;
    char  DiskName[4] = { 'x',':','\\','\0' };
    char  FileSys[MAX_PATH];
    DWORD SizeSoFar;
    UINT    ErrorMode;


    Unused(Args);
    Unused(cArgs);

    AreDrivesACertainType(DRIVE_FIXED,HardDisk);

    *InsertPoint++ = '{';
    SizeSoFar = 2;

    ErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX );
    for(Disk=0; Disk<26; Disk++) {

        if(HardDisk[Disk]) {

            DiskName[0] = (char)Disk + (char)'A';
            if(!GetVolumeInformation(DiskName,NULL,0,NULL,NULL,NULL,FileSys,sizeof(FileSys))) {
                *FileSys = '\0';
        } else if(!lstrcmpi(FileSys,"raw")) {
        *FileSys = '\0';
        }

            SizeSoFar += lstrlen(FileSys)+3;            // 3 is for "",
            if(SizeSoFar > cbReturnBuffer) {
                SetErrorMode( ErrorMode );
                return(SizeSoFar);
            }
            *InsertPoint++ = '"';
            lstrcpy(InsertPoint,FileSys);
            InsertPoint = strchr(InsertPoint,0);
            *InsertPoint++ = '"';
            *InsertPoint++ = ',';
        }
    }
    if(*(InsertPoint-1) == ',') {
        *(InsertPoint-1)   = '}';           // overwrite final comma
    } else {
        if(++SizeSoFar > cbReturnBuffer) {
            SetErrorMode( ErrorMode );
            return(SizeSoFar);
        }
        *InsertPoint++ = '}';
    }

    *InsertPoint = '\0';
    SetErrorMode( ErrorMode );
    return(lstrlen(ReturnBuffer)+1);
}


/*
    Return a list of ASCII representations of free space on all
    hard disk volumes
*/
CB
GetHardDriveFreeSpace(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    CB      Size;
    UINT    ErrorMode;

    Unused(Args);
    Unused(cArgs);

    ErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX );
    Size = GetSpaceWorker(ReturnBuffer,cbReturnBuffer,SPACE_FREE);
    SetErrorMode( ErrorMode );
    return(Size);
}

/*
    Return a list of ASCII representations of total space on all
    hard disk volumes
*/
CB
GetHardDriveTotalSpace(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    CB      Size;
    UINT    ErrorMode;

    Unused(Args);
    Unused(cArgs);

    ErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX );
    Size = GetSpaceWorker(ReturnBuffer,cbReturnBuffer,SPACE_TOTAL);
    SetErrorMode( ErrorMode );
    return(Size);
}


/******************************************************************
    Subroutines
*/

CB
GetDrivesWorker(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer,
    IN  DWORD   TypeOfDrive
    )
{
    char  DriveName[4] = { 'x',':','\\','\0' };
    BOOL  IsValid[26];
    DWORD NumMatches;
    DWORD SpaceRequired;

    Unused(Args);
    Unused(cArgs);

    NumMatches = AreDrivesACertainType(TypeOfDrive,IsValid);

    SpaceRequired = (NumMatches * 5) + 3 - 1;
    if(cbReturnBuffer < SpaceRequired) {
        return(SpaceRequired);
    } else {
        ConstructDiskList(IsValid,ReturnBuffer);
        return(lstrlen(ReturnBuffer)+1);
    }
}


DWORD
AreDrivesACertainType(
    IN DWORD TypeWereLookingFor,
    IN BOOL  *Results
    )
{
    char  DriveLetter;
    char  DriveName[4] = { 'x',':','\\','\0' };
    DWORD NumMatches = 0;
    DWORD DriveNumber = 0;

    for(DriveLetter='A'; DriveLetter <= 'Z'; DriveLetter++)
    {
        DriveName[0] = DriveLetter;
        Results[DriveNumber] = (MyGetDriveType(DriveName) == TypeWereLookingFor);
        if(Results[DriveNumber]) {
            NumMatches++;
        }
        DriveNumber++;
    }
    return(NumMatches);
}


VOID
ConstructDiskList(
    IN BOOL  *ValidDisk,
    IN LPSTR TextOut
    )
{
    DWORD DriveNumber;
    LPSTR InsertPoint = TextOut;

    *InsertPoint++ = '{';

    for(DriveNumber=0; DriveNumber<26; DriveNumber++) {

        if(ValidDisk[DriveNumber]) {

            *InsertPoint++ = '"';
            *InsertPoint++ = (char)DriveNumber + (char)'A';
            *InsertPoint++ = ':';
            *InsertPoint++ = '"';
            *InsertPoint++ = ',';
        }
    }

    if(*(InsertPoint-1) == ',') {
        *(InsertPoint-1)   = '}';           // overwrite final comma
    } else {
        *InsertPoint++ = '}';
    }

    *InsertPoint = '\0';
}


CB
GetSpaceWorker(
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer,
    IN  DWORD   TypeOfSpace
    )
{
    BOOL  HardDisk[26];
    DWORD Disk;
    LPSTR InsertPoint = ReturnBuffer;
    char  DiskName[4] = { 'x',':','\\','\0' };
    DWORD SizeSoFar;
    DWORD SectorsPerCluster,BytesPerSector,FreeClusters,TotalClusters;
    DWORD Space;
    char  SpaceSTR[15];

    AreDrivesACertainType(DRIVE_FIXED,HardDisk);

    *InsertPoint++ = '{';
    SizeSoFar = 2;

    for(Disk=0; Disk<26; Disk++) {

        if(HardDisk[Disk]) {

            DiskName[0] = (char)Disk + (char)'A';
            if(GetDiskFreeSpace(DiskName,
                                &SectorsPerCluster,
                                &BytesPerSector,
                                &FreeClusters,
                                &TotalClusters))
            {
                Space = SectorsPerCluster * BytesPerSector
                      * (TypeOfSpace == SPACE_FREE ? FreeClusters : TotalClusters)
                      / (1024*1024);        // converts # to megabytes

            } else {
                // assume unformatted
                Space = GetPartitionSize(DiskName);
            }

            wsprintf(SpaceSTR,"%lu",Space);

            SizeSoFar += lstrlen(SpaceSTR)+3;            // 3 is for "",
            if(SizeSoFar > cbReturnBuffer) {
                return(SizeSoFar);
            }
            *InsertPoint++ = '"';
            lstrcpy(InsertPoint,SpaceSTR);
            InsertPoint = strchr(InsertPoint,0);
            *InsertPoint++ = '"';
            *InsertPoint++ = ',';
        }
    }
    if(*(InsertPoint-1) == ',') {
        *(InsertPoint-1)   = '}';           // overwrite final comma
    } else {
        if(++SizeSoFar > cbReturnBuffer) {
            return(SizeSoFar);
        }
        *InsertPoint++ = '}';
    }

    *InsertPoint = '\0';
    return(lstrlen(ReturnBuffer)+1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\dinterp.c ===
#include "precomp.h"
#pragma hdrstop
/* File: dinterp.c */

/**************************************************************************/
/***** DETECT COMPONENT - Detect Interpreter
/**************************************************************************/

/* Detect component return code symbol table variable name */
CHP szStfRCSym[] = "STF_DETECT_OUTCOME";
HANDLE hInstCaller = NULL;

/* Component error variable detect error values
** (ordered by priority)
*/
SZ rgszDrc[] =
    {
    "DLLNOTFOUND",
    "OUTOFMEM",
    "CMDNOTFOUND",
    "CMDFAILED",
    "OKAY"
    };
#define drcDllNotFound 0
#define drcOutOfMem    1
#define drcCmdNotFound 2
#define drcCmdFailed   3
#define drcOkay   4
#define drcMin 0
#define drcMax 5

#if DBG
/*** REVIEW: Out of memory TEST functions (from _comstf.h) ***/
extern CB      APIENTRY CbSetAllocOpsCur(CB);
extern CB      APIENTRY CbGetAllocOpsCur(VOID);
extern CB      APIENTRY CbSetAllocOpsForceFailure(CB);
extern CB      APIENTRY CbGetAllocOpsForceFailure(VOID);
#endif /* DBG */


/*
**  Purpose:
**      Shell interpreter detect command handler.
**      Called by Shell interpreter.
**  Arguments:
**      hinst, hwnd : Windows stuff
**      rgsz        : array of arguments (NULL terminated)
**      cItems      : count of arguments (must be 1)
**  Returns:
**      fFalse if a vital detect operation fails or if a referrenced
**          detect command DLL cannot be loaded,
**      fTrue otherwise.
**************************************************************************/
BOOL  APIENTRY FDetectEntryPoint(HANDLE hInst,HWND hWnd,RGSZ rgsz,USHORT cItems)
{
    if (hInst == (HANDLE)NULL
        || hWnd == (HWND)NULL
        || rgsz == (RGSZ)NULL
        || *rgsz == (SZ)NULL
        || cItems != 1
        || *(rgsz + 1) != (SZ)NULL)
        {
        Assert(fFalse);
        return(fFalse);
        }
    hInstCaller = hInst;
    return(FDetectInfSection(hWnd, rgsz[0]));
}


/*
**  Purpose:
**      Traverses the given section evaluating any detect commands
**      found and setting the associated symbol in the symbol table.
**      Also sets the detect outcome variable (STF_DETECT_OUTCOME)
**      in the symbol table to one of the following (in order of
**      priority):
**
**          "DLLNOTFOUND"     Requested detect command DLL not found
**          "OUTOFMEM"        Out of memory error occured
**          "CMDNOTFOUND"     Requested detect command not found
**          "CMDFAILED"       Requested detect command failed
**          "OKAY"            All detect commands completed okay
**
**  Arguments:
**      szSection: non-NULL, non-empty section name.
**  Notes:
**      Requires that the current INF structure was initialized with a
**      successful call to GrcOpenInf().
**      Requires that the Symbol Table was initialized with a successful
**      call to FInitSymTab().
**  Returns:
**      fFalse if a vital detect operation fails or if a referrenced
**          detect command DLL cannot be loaded,
**      fTrue otherwise.
**************************************************************************/
BOOL  APIENTRY FDetectInfSection(HWND hwnd,SZ szSection)
{
    RGSZ rgsz = rgszNull;
    SZ szKey = szNull;
    SZ szValue = szNull;
    CHP szLibCur[cchpFullPathBuf];
    HANDLE hLibCur = hNull;
    PFNCMD pfncmd;
    INT Line;
    BOOL fOkay = fTrue;
    UINT cFields;
    DRC drcSet = drcOkay;
    DRC drc;

    AssertDataSeg();
//  PreCondSymTabInit(fFalse);  *** REVIEW: can't use with dll ***
//  PreCondInfOpen(fFalse);
    ChkArg(szSection != (SZ)NULL &&
            *szSection != '\0' &&
            !FWhiteSpaceChp(*szSection), 1, fFalse);

    *szLibCur = '\0';
    Line = FindFirstLineFromInfSection(szSection);
    while(Line != -1)
        {
        SdAtNewLine(Line);
        if(FKeyInInfLine(Line)
            && (cFields = CFieldsInInfLine(Line)) >= cFieldDetMin)
            {
            drc = drcOkay;

            if((rgsz = RgszFromInfScriptLine(Line,cFields)) == rgszNull)
                {
                drc = drcOutOfMem;
                goto NextCmd;
                }
            if(CrcStringCompare(rgsz[iszDetSym], szDetSym) != crcEqual)
                goto NextCmd;
            if(!FLoadDetectLib(rgsz[iszLib], szLibCur, &hLibCur))
                {
                drc = drcDllNotFound;
                fOkay = fFalse;
                goto NextCmd;
                }
            if((pfncmd = (PFNCMD)GetProcAddress(hLibCur, rgsz[iszCmd]))
                    == pfncmdNull)
                {
#if DBG
                MessBoxSzSz("Unknown Detect Command", rgsz[iszCmd]);
#endif
                drc = drcCmdNotFound;
                goto NextCmd;
                }
            if((drc = DrcGetDetectValue(&szValue, pfncmd,
                    rgsz+iszArg, cFields-iszArg)) != drcOkay)
                {
#if DBG
                if(drc == drcCmdFailed)
                    MessBoxSzSz("Detect Command Failed", rgsz[iszCmd]);
#endif
                goto NextCmd;
                }
            if((szKey = SzGetNthFieldFromInfLine(Line,0)) == szNull)
                {
                drc = drcOutOfMem;
                goto NextCmd;
                }
            if(!FAddSymbolValueToSymTab(szKey, szValue))
                drc = drcOutOfMem;
NextCmd:
            if(drc < drcSet)
                drcSet = drc;
            if(szValue != szNull)
                SFree(szValue);
            if(szKey != szNull)
                SFree(szKey);
            if(rgsz != (RGSZ)szNull)
                FFreeRgsz(rgsz);
            szValue = szKey = szNull;
            rgsz = rgszNull;
            if(!fOkay)
                break;
            }
        Line = FindNextLineFromInf(Line);
        }
    if(hLibCur >= hLibMin)
      if(*szLibCur != '|')
        FreeLibrary(hLibCur);

    while(!FAddSymbolValueToSymTab(szStfRCSym, rgszDrc[drcSet]))
        {
        if(!FHandleOOM(hwnd))
            fOkay = fFalse;
        }
    return(fOkay);
}


HANDLE APIENTRY StfLoadLibrary(SZ szLib)
{
    INT    cchp;
    SZ     szCWD, szCur;
    SZ     szLastBackSlash = (SZ)NULL;
    HANDLE hDll;

    if ((szCur = szCWD = (SZ)SAlloc((CB)4096)) == (SZ)NULL)
        return(0);

    if ((cchp = GetModuleFileName(hInstCaller, (LPSTR)szCur, 4095)) >= 4095)
        {
        SFree(szCur);
        return((HANDLE)2);
        }
    *(szCur + cchp) = '\0';

    while (*szCur != '\0')
        if (*szCur++ == '\\')
            szLastBackSlash = szCur;

    if (szLastBackSlash == (SZ)NULL)
        {
        SFree(szCWD);
        return((HANDLE)2);
        }

    *szLastBackSlash = '\0';

    EvalAssert(SzStrCat(szCWD, szLib) == szCWD);

    hDll = LoadLibrary((PfhOpenFile(szCWD, ofmExistRead) != NULL) ? szCWD
            : szLib);

    SFree(szCWD);

    return(hDll);
}


/*
**  Purpose:
**      Loads the given detect DLL if not already loaded, and
**      frees the previously loaded DLL, if any.
**  Arguments:
**      szLib       : name of library to load (must be non-szNull)
**      szLibCurBuf : pointer into string buffer conatining name of
**          library currently loaded, if any (empty string if none
**          loaded).
**      phLibCir    : handle to currently loaded library.
**  Notes:
**      Assumes szLibCurBuf buffer is large enough for any DLL name.
**  Returns:
**      fTrue if given detect DLL loaded okay, fFalse if not.
**      Modifies szLibCurBuf and phLibCur if new library is loaded.
**************************************************************************/
BOOL  APIENTRY FLoadDetectLib(szLib, szLibCurBuf, phLibCur)
SZ szLib;
SZ szLibCurBuf;
HANDLE *phLibCur;
{
    ChkArg(szLib != szNull &&
            *szLib != '\0' &&
            !FWhiteSpaceChp(*szLib), 1, fFalse);
    ChkArg(szLibCurBuf != szNull, 2, fFalse);
    ChkArg(phLibCur != (HANDLE *)NULL, 3, fFalse);

    if(*szLib == '|') {     // lib name is really a handle
        *phLibCur = LongToHandle(atol(szLib+1));
        *szLibCurBuf = '|';
        return(fTrue);
    }
    if(*szLibCurBuf == '\0'
        || CrcStringCompareI(szLibCurBuf, szLib) != crcEqual)
        {
            if(*phLibCur >= hLibMin)
                FreeLibrary(*phLibCur);
            *szLibCurBuf = '\0';
            if((*phLibCur = StfLoadLibrary(szLib)) < hLibMin)
                return(fFalse);
            Assert(strlen(szLib) < cchpFullPathBuf);
            EvalAssert(strcpy(szLibCurBuf, szLib) != szNull);
        }
    Assert(*phLibCur >= hLibMin);
    return(fTrue);
}


/*
**  Purpose:
**      Gets the value of a detect command and returns it in
**      an allocated, zero terminated string.
**  Arguments:
**      psz    : pointer to be set to result value string
**      pfncmd : address of detect command function
**      rgsz   : array of command arguments (may be empty)
**      cArgs  : number of args in rgsz
**  Returns:
**      drcCmdFailed if detect command failed (returned 0)
**      drcOutOfMem if out of memory error
**      drcOkay if no error
**************************************************************************/
DRC  APIENTRY DrcGetDetectValue(psz, pfncmd, rgsz, cArgs)
SZ *psz;
PFNCMD pfncmd;
RGSZ rgsz;
CB cArgs;           // 1632
{
    SZ szValue, szT;
    CB cbBuf = cbValBufDef;
    CB cbVal;

    if((szValue = (SZ)SAlloc(cbBuf)) == szNull)
        return(drcOutOfMem);
    Assert(cbBuf > 0);
    while((cbVal = (*pfncmd)(rgsz, (USHORT)cArgs, szValue, cbBuf)) > cbBuf)  // 1632
        {
        if(cbVal > cbAllocMax)
            {
            SFree(szValue);
            return(drcCmdFailed);
            }
        if((szT = SRealloc((PB)szValue, cbVal)) == NULL)
            {
            SFree(szValue);
            return(drcOutOfMem);
            }
        szValue = szT;
        cbBuf = cbVal;
        }
    if(cbVal == 0)
        {
        SFree(szValue);
        return(drcCmdFailed);
        }
    Assert(szValue != szNull
        && (strlen(szValue)+1) == cbVal
        && cbVal <= cbBuf);
    if(cbVal < cbBuf)
        szValue = SRealloc(szValue,cbBuf);
    *psz = szValue;
    return(drcOkay);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\diamond.c ===
#include "precomp.h"
#pragma hdrstop

//#define MY_FDI_MEM_STATS

HFDI FdiContext;
ERF FdiError;

LONG MyLastDiamondWriteError,MyLastDiamondIoError;

INT_PTR CurrentTargetFileHandle;
INT TicksForThisFile;

DWORD CurrentTargetFileSize;

PFNWFROMW GaugeTicker;

extern HWND hwndFrame;

#ifdef MY_FDI_MEM_STATS
DWORD DiAllocCount,DiFreeCount;
LONG DiCurrentAllocation,DiPeakAllocation;
#endif


INT_PTR
DIAMONDAPI
DiamondNotifyFunction(
    IN FDINOTIFICATIONTYPE Operation,
    IN PFDINOTIFICATION    Parameters
    )
{
    switch(Operation) {

    case fdintCABINET_INFO:
    case fdintNEXT_CABINET:
    case fdintPARTIAL_FILE:
    default:

        //
        // Cabinet management functions which we don't use.
        // Return success.
        //
        return(0);

    case fdintCOPY_FILE:

        //
        // Diamond is asking us whether we want to copy the file.
        // The name for the destination is stored as the
        // user parameter; open the file.
        //

        CurrentTargetFileSize = Parameters->cb;

        //
        // Target file handle is the user data value.
        //
        return((INT_PTR)Parameters->pv);

    case fdintCLOSE_FILE_INFO:

        //
        // Diamond is done with the target file and wants us to close it.
        // (ie, this is the counterpart to fdint_COPY_FILE).
        // However our target file open/close operations are controlled
        // in copy.c so we do nothing here.
        //
        //_lclose(Parameters->hf);
        return(TRUE);
    }
}



PVOID
DIAMONDAPI
SpdFdiAlloc(
    IN ULONG NumberOfBytes
    )

/*++

Routine Description:

    Callback used by FDICopy to allocate memory.

Arguments:

    NumberOfBytes - supplies desired size of block.

Return Value:

    Returns pointer to a block of memory or NULL
    if memory cannot be allocated.

--*/

{
#ifdef MY_FDI_MEM_STATS

    PDWORD p;

    p = SAlloc(NumberOfBytes+sizeof(DWORD));
    if(p) {
        *p++ = NumberOfBytes;
        DiAllocCount++;

        DiCurrentAllocation += (LONG)NumberOfBytes;
        if(DiCurrentAllocation > DiPeakAllocation) {
            DiPeakAllocation = DiCurrentAllocation;
        }
    }

    return(p);
#else
    return(SAlloc(NumberOfBytes));
#endif
}


VOID
DIAMONDAPI
SpdFdiFree(
    IN PVOID Block
    )

/*++

Routine Description:

    Callback used by FDICopy to free a memory block.
    The block must have been allocated with SpdFdiAlloc().

Arguments:

    Block - supplies pointer to block of memory to be freed.

Return Value:

    None.

--*/

{
#ifdef MY_FDI_MEM_STATS
    PDWORD p = (PDWORD)Block - 1;

    DiCurrentAllocation -= (LONG)*p;
    DiFreeCount++;

    SFree(p);

#else
    SFree(Block);
#endif
}


INT_PTR
DIAMONDAPI
SpdFdiOpen(
    IN PSTR FileName,
    IN int  oflag,
    IN int  pmode
    )

/*++

Routine Description:

    Callback used by FDICopy to open files.

Arguments:

    FileName - supplies name of file to be opened.

    oflag - supplies flags for open.

    pmode - supplies additional flags for open.

Return Value:

    Handle to open file or -1 if error occurs.

--*/

{
    HFILE h;
    int OpenMode;

    if(oflag & _O_WRONLY) {
        OpenMode = OF_WRITE;
    } else {
        if(oflag & _O_RDWR) {
            OpenMode = OF_READWRITE;
        } else {
            OpenMode = OF_READ;
        }
    }

    h = _lopen(FileName,OpenMode | OF_SHARE_DENY_WRITE);

    if(h == HFILE_ERROR) {
        //
        // Want to return an open error, but there is none.
        //
        MyLastDiamondIoError = rcReadError;
        return(-1);
    }

    return((INT_PTR)h);
}


UINT
DIAMONDAPI
SpdFdiRead(
    IN  INT_PTR Handle,
    OUT PVOID pv,
    IN  UINT  ByteCount
    )

/*++

Routine Description:

    Callback used by FDICopy to read from a file.

Arguments:

    Handle - supplies handle to open file to be read from.

    pv - supplies pointer to buffer to receive bytes we read.

    ByteCount - supplies number of bytes to read.

Return Value:

    Number of bytes read (ByteCount) or -1 if an error occurs.

--*/

{
    UINT rc;

    FYield();
    if(fUserQuit) {

        rc = (UINT)(-1);

    } else {

        rc = _lread((HFILE)Handle,pv,ByteCount);

        if(rc == HFILE_ERROR) {
            rc = (UINT)(-1);
            MyLastDiamondIoError = rcReadError;
        }
    }
    FYield();

    return(rc);
}


UINT
DIAMONDAPI
SpdFdiWrite(
    IN INT_PTR Handle,
    IN PVOID pv,
    IN UINT  ByteCount
    )

/*++

Routine Description:

    Callback used by FDICopy to write to a file.

Arguments:

    Handle - supplies handle to open file to be written to.

    pv - supplies pointer to buffer containing bytes to write.

    ByteCount - supplies number of bytes to write.

Return Value:

    Number of bytes written (ByteCount) or -1 if an error occurs.

--*/

{
    UINT rc;

    //
    // Assume failure.
    //
    rc = (UINT)(-1);

    FYield();
    if(!fUserQuit) {

        rc = _lwrite((HFILE)Handle,pv,ByteCount);

        if(rc == HFILE_ERROR) {

            MyLastDiamondIoError = (GetLastError() == ERROR_DISK_FULL) ? rcDiskFull : rcWriteError;
            MyLastDiamondWriteError = MyLastDiamondWriteError;

        } else {

            if(rc == ByteCount) {

                if((Handle == CurrentTargetFileHandle) && GaugeTicker) {

                    //
                    // Update gauge.
                    //
                    GaugeTicker(ByteCount * TicksForThisFile / CurrentTargetFileSize);
                }

            } else {
                MyLastDiamondIoError = rcDiskFull;
                MyLastDiamondWriteError = rcDiskFull;
                rc = (UINT)(-1);
            }
        }
    }
    FYield();

    return(rc);
}


int
DIAMONDAPI
SpdFdiClose(
    IN INT_PTR Handle
    )

/*++

Routine Description:

    Callback used by FDICopy to close files.

Arguments:

    Handle - handle of file to close.

Return Value:

    0 (success).

--*/

{
    //
    // Don't close the target file because it screws up logic in FCopy().
    //
    if(Handle != CurrentTargetFileHandle) {
        _lclose((HFILE)Handle);
    }

    return(0);
}


LONG
DIAMONDAPI
SpdFdiSeek(
    IN INT_PTR Handle,
    IN long Distance,
    IN int  SeekType
    )

/*++

Routine Description:

    Callback used by FDICopy to seek files.

Arguments:

    Handle - handle of file to close.

    Distance - supplies distance to seek. Interpretation of this
        parameter depends on the value of SeekType.

    SeekType - supplies a value indicating how Distance is to be
        interpreted; one of SEEK_SET, SEEK_CUR, SEEK_END.

Return Value:

    New file offset or -1 if an error occurs.

--*/

{
    LONG rc;

    FYield();
    if(fUserQuit) {
        rc = -1L;
    } else {

        rc = _llseek((HFILE)Handle,Distance,SeekType);

        if(rc == HFILE_ERROR) {
            MyLastDiamondIoError = (Handle == CurrentTargetFileHandle)
                                 ? rcWriteSeekError
                                 : rcReadSeekError;
            rc = -1L;
        }
    }

    return(rc);
}


LONG
DecompDiamondFile(
    PSTR      SourceFileName,
    HANDLE    TargetFileHandle,
    PFNWFROMW ProgressCallback,
    INT       NumberOfTicks
    )
{
    BOOL b;
    LONG rc;

    if(!FdiContext) {
        return(rcGenericDecompError);
    }

    MyLastDiamondWriteError = rcNoError;
    MyLastDiamondIoError = rcNoError;

    CurrentTargetFileHandle = (INT_PTR)TargetFileHandle;
    TicksForThisFile = NumberOfTicks;
    GaugeTicker = ProgressCallback;

    CurrentTargetFileSize = 0;

    fUserQuit = FALSE;

    //
    // The target file is opened exclusive by FCopy().
    // To avoid changing too much code this routine is passed the
    // open file handle instead of the target file name.
    // We can then return this file handle in the fdintCOPY_FILE
    // case in the fdi notification function (see above).
    //

    b = FDICopy(
            FdiContext,
            SourceFileName,             // pass the whole path as the name
            "",                         // don't bother with the path part
            0,                          // flags
            DiamondNotifyFunction,
            NULL,                       // no decryption
            (PVOID)TargetFileHandle     // user data is target file handle
            );

    if(b) {

        rc = rcNoError;

    } else {

        if(fUserQuit) {
            rc = rcUserQuit;
        } else {

            switch(FdiError.erfOper) {

            case FDIERROR_CORRUPT_CABINET:
                rc = MyLastDiamondIoError;
                break;

            case FDIERROR_ALLOC_FAIL:
                rc = rcOutOfMemory;
                break;

            case FDIERROR_UNKNOWN_CABINET_VERSION:
            case FDIERROR_BAD_COMPR_TYPE:
                rc = rcUnknownAlgType;
                break;

            case FDIERROR_TARGET_FILE:
                rc = MyLastDiamondWriteError;
                break;

            case FDIERROR_USER_ABORT:
                rc = MyLastDiamondIoError;
                break;

            default:
                //
                // The rest of the errors are not handled specially.
                //
                rc = rcGenericDecompError;
                break;
            }
        }
    }

    return(rc);
}


BOOL
IsDiamondFile(
    IN PSTR FileName
    )
{
    FDICABINETINFO CabinetInfo;
    BOOL b;
    INT_PTR h;

    if(!FdiContext) {
        return(FALSE);
    }

    //
    // Open the file such that the handle is valid for use
    // in the diamond context (ie, seek, read routines above).
    //
    h = SpdFdiOpen(FileName,_O_RDONLY,0);
    if(h == -1) {
        return(FALSE);
    }

    b = FDIIsCabinet(FdiContext,h,&CabinetInfo);

    _lclose((HFILE)h);

    return(b);
}


BOOL
InitDiamond(
    VOID
    )
{
    if(FdiContext) {
        return(fTrue);
    }

#ifdef MY_FDI_MEM_STATS
    DiAllocCount = DiFreeCount = 0;
    DiCurrentAllocation = DiPeakAllocation = 0;
#endif

    //
    // Initialize a diamond context.
    //
    while((FdiContext = FDICreate(
                            SpdFdiAlloc,
                            SpdFdiFree,
                            SpdFdiOpen,
                            SpdFdiRead,
                            SpdFdiWrite,
                            SpdFdiClose,
                            SpdFdiSeek,
                            cpuUNKNOWN,
                            &FdiError
                            )) == NULL)
    {
        if (!FHandleOOM(hwndFrame)) {
            return(FALSE);
        }
    }

    return(TRUE);
}


VOID
TermDiamond(
    VOID
    )
{
    if(FdiContext) {
        FDIDestroy(FdiContext);
        FdiContext = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\dll.c ===
#include "precomp.h"
#pragma hdrstop

HANDLE MyDllModuleHandle;

//
// Called by CRT when _DllMainCRTStartup is the DLL entry point
//
BOOL
WINAPI
DllMain(
    IN HANDLE DllHandle,
    IN DWORD  Reason,
    IN LPVOID Reserved
    )
{
    BOOL b;

    UNREFERENCED_PARAMETER(Reserved);

    b = TRUE;

    switch(Reason) {

    case DLL_PROCESS_ATTACH:

        MyDllModuleHandle = DllHandle;
        b = SInit(TRUE);
        break;

    case DLL_PROCESS_DETACH:

        CreateShellWindow(hInst,0,TRUE);
        b = SInit(FALSE);
        break;
    }

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\dir.c ===
#include "precomp.h"
#pragma hdrstop
/* File: dir.c */
/*************************************************************************
**  Install: Directory commands.
**************************************************************************/

extern HWND hwndFrame;



/*
**  Purpose:
**      Creates a new directory at the given path.
**  Arguments:
**      szDir: non-NULL dir path pointer.
**      Valid command options:
**          cmoVital
**          cmoNone
**  Returns:
**      Returns fTrue if the directory is successfully created, or if
**      it already exists.  Returns fFalse otherwise.
**
**************************************************************************/
BOOL APIENTRY FCreateDir(SZ szDir,CMO cmo)
{
    CB   cb;
    SZ   szDirPlus;
    EERC eerc;
    DWORD   Attr;
    BOOL fRet = fTrue;

    ChkArg(szDir != (SZ)NULL && *szDir != '\0', 1, fFalse);
    ChkArg(cmo == cmoNone || cmo == cmoVital, 2, fFalse);

    //
    // Create directory
    //

    while ( !((( Attr = GetFileAttributes(szDir) ) != 0xFFFFFFFF  && (Attr & FILE_ATTRIBUTE_DIRECTORY ))
              || CreateDirectory( szDir, NULL )) ) {
        if ((eerc = EercErrorHandler(hwndFrame, grcCreateDirErr, cmo == cmoVital,
                szDir, 0, 0)) != eercRetry) {
            fRet = (eerc == eercIgnore) ? fTrue : fFalse;
            break;
        }
    }
    return(fRet);
}


/*
**  Purpose:
**      Removes the existing directory at the given path.
**  Arguments:
**      szDir: non-NULL dir path pointer.
**      Valid command options:
**          cmoVital
**          cmoNone
**  Returns:
**      Returns fTrue if the directory is successfuly removed,
**      or if did not exist.  Returns fFalse otherwise.
**
**************************************************************************/
BOOL APIENTRY FRemoveDir(SZ szDir,CMO cmo)
{
    SZ    szLast;
    EERC  eerc;
    DWORD Attr;

    ChkArg(szDir != (SZ)NULL, 1, fFalse);
    ChkArg(cmo == cmoNone || cmo == cmoVital, 2, fFalse);

    if (!FValidDir(szDir) ||
            (szLast = SzLastChar(szDir)) == (SZ)NULL)
        return(fFalse);
    Assert(*szLast != '\0');

    if (*szLast == '\\')
        *szLast = '\0';

    while (!RemoveDirectory(szDir) && (( Attr = GetFileAttributes(szDir) ) != 0xFFFFFFFF) && (Attr & FILE_ATTRIBUTE_DIRECTORY )) {
        if ((eerc = EercErrorHandler(hwndFrame, grcRemoveDirErr, cmo & cmoVital,
                szDir, 0, 0)) != eercRetry) {
            if (*szLast == '\0')
                *szLast = '\\';
            return(eerc == eercIgnore);
        }
    }

    if (*szLast == '\0')
        *szLast = '\\';

    return(fTrue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\detect1.c ===
#include "precomp.h"
#pragma hdrstop
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    detect1.c

Abstract:

    Detect module for Win32 PDK Setup.
    This module has no external dependencies and is not statically linked
    to any part of Setup.

Author:

    Ted Miller (tedm) June 1991

--*/

#define PROCESSOR_NONE    ""
#define PROCESSOR_I386    "I386"
#define PROCESSOR_I486    "I486"
#define PROCESSOR_I586    "I586"
#define PROCESSOR_R4000   "R4000"
#define PROCESSOR_ALPHA   "Alpha_AXP"
#define PROCESSOR_PPC601  "PPC601"
#define PROCESSOR_PPC603  "PPC603"
#define PROCESSOR_PPC604  "PPC604"
#define PROCESSOR_PPC620  "PPC620"

#define PLATFORM_NONE    ""
#define PLATFORM_I386    "I386"
#define PLATFORM_MIPS    "Mips"
#define PLATFORM_ALPHA   "Alpha"
#define PLATFORM_PPC     "ppc"

//
//  Local prototypes
//
BOOL MatchNtPathToDosPath( PUNICODE_STRING, PUNICODE_STRING, SZ, SZ, CB );
VOID ConvertUnicodeToAnsi( PUNICODE_STRING, SZ );

/*
    oemcp as a string
*/
CB
GetOemCodepage(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    UINT cp;

    Unused(Args);
    Unused(cArgs);
    Unused(cbReturnBuffer);

    cp = GetOEMCP();

    wsprintf(ReturnBuffer,"%u",cp);
    return(lstrlen(ReturnBuffer)+1);
}

/*
    ansicp as a string
*/
CB
GetAnsiCodepage(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    UINT cp;

    Unused(Args);
    Unused(cArgs);
    Unused(cbReturnBuffer);

    cp = GetACP();

    wsprintf(ReturnBuffer,"%u",cp);
    return(lstrlen(ReturnBuffer)+1);
}

/*
    langauge type as a string
*/
CB
GetLanguage(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
//
//  bugbug ramonsa - enable when GetQualifiedLocale returns something
//                   meaningful
#ifdef LOCALE_STUFF

    LCID       LcId = {0,0,0};
    LCSTRINGS  LcStrings;

    Unused(Args);
    Unused(cArgs);
    Unused(cbReturnBuffer);

    ReturnBuffer[0] = '\0';

    if ( GetQualifiedLocale( QF_LCID,
                             &LcId,
                             NULL,
                             &LcStrings ) ) {

        lstrcpy(ReturnBuffer,LcStrings.szLanguage);
        return(lstrlen(ReturnBuffer)+1);
    }

    return 0;
#else
    #define TEMP_LANGUAGE "ENG"
    Unused(Args);
    Unused(cArgs);
    Unused(cbReturnBuffer);

    lstrcpy(ReturnBuffer,TEMP_LANGUAGE);
    return(lstrlen(ReturnBuffer)+1);

#endif
}

/*
 * GetSystemDate - returns a list of date information in the following
 *      order:
 *      sec after 1-1-1970, year, month, day, hour, minute, second, millisecond
 *
 */

CB
GetSystemDate(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    SYSTEMTIME systime;
    time_t timet;

    Unused( Args );
    Unused( cArgs );
    Unused( cbReturnBuffer );

    GetSystemTime( &systime );
    time( &timet );

    wsprintf(ReturnBuffer, "{\"%d\",\"%d\",\"%d\",\"%d\",\"%d\",\"%d\",\"%d\",\"%d\"}",
        timet,
        systime.wYear,
        systime.wMonth,
        systime.wDay,
        systime.wHour,
        systime.wMinute,
    systime.wSecond,
    systime.wMilliseconds
        );

    return(lstrlen(ReturnBuffer)+1);
}



/*
    Country type as a string
*/
CB
GetCountry(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
//
//  bugbug ramonsa - enable when GetQualifiedLocale returns something
//                   meaningful
#ifdef LOCALE_STUFF

    LCID       LcId = {0,0,0};
    LCSTRINGS  LcStrings;

    Unused(Args);
    Unused(cArgs);
    Unused(cbReturnBuffer);

    ReturnBuffer[0] = '\0';

    if ( GetQualifiedLocale( QF_LCID,
                             &LcId,
                             NULL,
                             &LcStrings ) ) {

        lstrcpy(ReturnBuffer,LcStrings.szCountry);
        return(lstrlen(ReturnBuffer)+1);
    }

    return 0;

#else
    #define TEMP_COUNTRY "US"
    Unused(Args);
    Unused(cArgs);
    Unused(cbReturnBuffer);

    lstrcpy(ReturnBuffer,TEMP_COUNTRY);
    return(lstrlen(ReturnBuffer)+1);


#endif
}



CB
GetProcessor(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    SYSTEM_INFO SystemInfo;
    SZ          szProcessor;

    Unused(Args);
    Unused(cArgs);
    Unused(cbReturnBuffer);

    GetSystemInfo( &SystemInfo );

    switch ( SystemInfo.wProcessorArchitecture ) {

        case PROCESSOR_ARCHITECTURE_INTEL:
            if (SystemInfo.wProcessorLevel == 3) {
                szProcessor = PROCESSOR_I386;
            } else
            if (SystemInfo.wProcessorLevel == 4) {
                szProcessor = PROCESSOR_I486;
            } else {
                szProcessor = PROCESSOR_I586;
            }
            break;

        case PROCESSOR_ARCHITECTURE_MIPS:
            szProcessor = PROCESSOR_R4000;
            break;

        case PROCESSOR_ARCHITECTURE_ALPHA:
            szProcessor = PROCESSOR_ALPHA;
            break;

        case PROCESSOR_ARCHITECTURE_PPC:
            if (SystemInfo.wProcessorLevel == 1) {
                szProcessor = PROCESSOR_PPC601;
            } else
            if (SystemInfo.wProcessorLevel == 3) {
                szProcessor = PROCESSOR_PPC603;
            } else
            if (SystemInfo.wProcessorLevel == 4) {
                szProcessor = PROCESSOR_PPC604;
            } else
            if (SystemInfo.wProcessorLevel == 6) {
                szProcessor = PROCESSOR_PPC603;
            } else
            if (SystemInfo.wProcessorLevel == 7) {
                szProcessor = PROCESSOR_PPC603;
            } else
            if (SystemInfo.wProcessorLevel == 9) {
                szProcessor = PROCESSOR_PPC604;
            } else
            if (SystemInfo.wProcessorLevel == 20) {
                szProcessor = PROCESSOR_PPC620;
                }
            else {
                szProcessor = PROCESSOR_PPC601;
            }
            break;

        default:
            //
            // There could be processors we don't know about.
            // Try to make sure we'll at least set up on them
            // by defaulting to a known processor. This also eliminates
            // the need to keep updating the INFs to know about all the
            // processors we support.
            //
            szProcessor = PROCESSOR_NONE;
#ifdef _X86_
            //
            // Probably a P6 or greater.
            //
            szProcessor = PROCESSOR_I586;
#endif

#ifdef _MIPS_
            //
            // Probably something that came after the R4000.
            // Assume R4000 to be safe.
            //
            szProcessor = PROCESSOR_R4000;
#endif

#ifdef _ALPHA_
            //
            // Just recognize that it's an Alpha.
            //
            szProcessor = PROCESSOR_ALPHA;
#endif

#ifdef _PPC_
            //
            // Just call it a 601, which is assumed to be
            // the lowest common denominator.
            //
            szProcessor = PROCESSOR_PPC601;
#endif

            break;
    }

    lstrcpy( ReturnBuffer, szProcessor );
    return lstrlen( ReturnBuffer)+1;
}

CB
GetPlatform(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    SYSTEM_INFO SystemInfo;
    SZ          szPlatform;

    Unused(Args);
    Unused(cArgs);
    Unused(cbReturnBuffer);

    GetSystemInfo( &SystemInfo );

    switch ( SystemInfo.wProcessorArchitecture ) {

        case PROCESSOR_ARCHITECTURE_INTEL:
            szPlatform = PLATFORM_I386;
            break;

        case PROCESSOR_ARCHITECTURE_MIPS:
            szPlatform = PLATFORM_MIPS;
            break;

        case PROCESSOR_ARCHITECTURE_ALPHA:
            szPlatform = PLATFORM_ALPHA;
            break;

        case PROCESSOR_ARCHITECTURE_PPC:
            szPlatform = PLATFORM_PPC;
            break;

        default:
            szPlatform = PLATFORM_NONE;

            //
            // Try really hard to return a reasonable value by
            // assuming that the code is running on a machine of the
            // platform for which the it was compiled.
            // This lets us run on processors we haven't invented yet
            // and whose ids are thus not accounted for in the aboce
            // cases.
            //
#ifdef _X86_
            szPlatform = PLATFORM_I386;
#endif

#ifdef _MIPS_
            szPlatform = PLATFORM_MIPS;
#endif

#ifdef _ALPHA_
            szPlatform = PLATFORM_ALPHA;
#endif

#ifdef _PPC_
            szPlatform = PLATFORM_PPC;
#endif

            break;
    }

    lstrcpy( ReturnBuffer, szPlatform );
    return lstrlen( ReturnBuffer)+1;
}



/*
    Memory size as an ASCII string (Kb)
*/
CB
GetMemorySize(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    MEMORYSTATUS MemoryStatus;

    Unused(Args);
    Unused(cArgs);
    Unused(cbReturnBuffer);

    GlobalMemoryStatus(&MemoryStatus);
    _ultoa((ULONG)(MemoryStatus.dwTotalPhys/1024),ReturnBuffer,10);
    return(lstrlen(ReturnBuffer)+1);
}


/*
    Minimum pagefile size necessary for crash dump support (MB)
*/
CB
GetCrashDumpSize(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    MEMORYSTATUS ms;
    SYSTEM_INFO si;

    Unused(Args);
    Unused(cArgs);
    Unused(cbReturnBuffer);

    GlobalMemoryStatus(&ms);
    GetSystemInfo(&si);
    //
    // We need a pagefile as large as physical memory + 1 page.
    //
    _ultoa(
        (ULONG)((ms.dwTotalPhys + si.dwPageSize + 0xFFFFF) >> 20),
        ReturnBuffer,
        10);
    return(lstrlen(ReturnBuffer)+1);
}


/*
    list of paths on which a given file appears.
*/

CB
FindFileInstances(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    CB     rc = 0;
    SZ     sz;
    RGSZ   rgszFiles;
    HANDLE hff;
    WIN32_FIND_DATA FindFileData;

    Unused(cbReturnBuffer);

    //
    // If no file specified then return 0
    //

    if (cArgs != 1) {
        return rc;
    }

    //
    // If invalid filename then return 0

    if ((lstrlen(Args[0]) + 1) > MAX_PATH) {
        return rc;
    }

    //
    // Allocate just the NULL terminator for the rgsz structure
    //

    rgszFiles = RgszAlloc(1);
    if (!rgszFiles) {
       return rc;
    }

    //
    // Do find first, find next adding files found to the rgsz structure
    //

    if ((hff = FindFirstFile( Args[0], &FindFileData )) != (HANDLE)-1) {

        do {
            if (!RgszAdd( &rgszFiles, SzDup( (SZ)FindFileData.cFileName ) )) {
               FindClose( hff );
               return rc;
            }
        }
        while (FindNextFile(hff, &FindFileData));

        FindClose( hff );
    }

    //
    // Convert the rgsz structure to a sz list value and copy this over
    // to the return buffer.
    //

    sz = SzListValueFromRgsz( rgszFiles );

    if ( sz ) {

        lstrcpy( ReturnBuffer, sz );
        rc = lstrlen(sz) + 1;
        SFree( sz );

    }

    RgszFree( rgszFiles );

    return ( rc );
}



//
//  Get Windows version
//
CB
GetWindowsNtVersion(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{

    DWORD   Version;
    DWORD   WinMaj;
    DWORD   WinMin;
    DWORD   OsMaj;
    DWORD   OsMin;

    Unused(Args);
    Unused(cArgs);
    Unused(cbReturnBuffer);

    Version = GetVersion();

    WinMaj =  FIRSTBYTE(Version);
    WinMin =  SECONDBYTE(Version);
    OsMin  =  THIRDBYTE(Version);
    OsMaj  =  FOURTHBYTE(Version);

    sprintf(ReturnBuffer, "{%lu,%lu,%lu,%lu}", WinMaj, WinMin, OsMaj, OsMin );
    return(lstrlen(ReturnBuffer)+1);

}



//
//  Get Windows directory
//
CB
GetWindowsNtDir(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    DWORD   cbRet;

    Unused(Args);
    Unused(cArgs);

    cbRet =  GetWindowsDirectory( ReturnBuffer, cbReturnBuffer );

    if ( (cbRet == 0) || (cbRet > cbReturnBuffer) ) {
        ReturnBuffer[0] = '\0';
        return 0;
    }

    return cbRet + 1;

}





//
//  Get Windows system directory
//
CB
GetWindowsNtSysDir(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    DWORD   cbRet;

    Unused(Args);
    Unused(cArgs);

    cbRet =  GetSystemDirectory( ReturnBuffer, cbReturnBuffer );

    if ( (cbRet == 0) || (cbRet > cbReturnBuffer) ) {
        ReturnBuffer[0] = '\0';
        return 0;
    }

    return cbRet + 1;

}



//
//  Get NT directory
//
CB
GetNtDir(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{

    #define SYSTEMROOT      "\\SystemRoot"
    #define DRIVEROOT       "\\DosDevices\\?:"
    #define LINKBUFFERSIZE  (MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR))

    ANSI_STRING   SystemRoot;
    ANSI_STRING   DriveRoot;
    WCHAR   SysLinkBuffer[LINKBUFFERSIZE];
    WCHAR   DrvLinkBuffer[LINKBUFFERSIZE];
    WCHAR   DriveLetter;
    CHAR    DriveBuffer[] = DRIVEROOT;
    NTSTATUS    Status;

    UNICODE_STRING  SystemRootU;
    UNICODE_STRING  SystemRootLinkU;
    UNICODE_STRING  DriveRootU;
    UNICODE_STRING  DriveRootLinkU;

    Unused(Args);
    Unused(cArgs);
    Unused(cbReturnBuffer);
    ReturnBuffer[0] = '\0';

    SystemRootLinkU.Length        = 0;
    SystemRootLinkU.MaximumLength = LINKBUFFERSIZE;
    SystemRootLinkU.Buffer        = SysLinkBuffer;

    DriveRootLinkU.Length         = 0;
    DriveRootLinkU.MaximumLength  = LINKBUFFERSIZE;
    DriveRootLinkU.Buffer         = DrvLinkBuffer;



    RtlInitAnsiString(&SystemRoot, SYSTEMROOT);

    Status = RtlAnsiStringToUnicodeString(
                 &SystemRootU,
                 &SystemRoot,
                 TRUE
                 );

    //
    //  Get the value of the "SystemRoot" symbolic link.
    //
    if ( GetSymbolicLinkTarget( &SystemRootU, &SystemRootLinkU ) ) {


        for ( DriveLetter = (WCHAR)'A';
              DriveLetter <= (WCHAR)'Z';
              DriveLetter++ ) {

            DriveBuffer[12] = (CHAR)DriveLetter;

            RtlInitAnsiString(&DriveRoot, DriveBuffer);

            Status = RtlAnsiStringToUnicodeString(
                         &DriveRootU,
                         &DriveRoot,
                         TRUE
                         );

            //
            //  If there is a symbolic link for the drive, see if it
            //  matches the symbolic link of "SystemRoot"
            //
            if ( GetSymbolicLinkTarget( &DriveRootU, &DriveRootLinkU ) ) {

                if ( MatchNtPathToDosPath( &SystemRootLinkU,
                                      &DriveRootLinkU,
                                      &DriveBuffer[12],
                                      ReturnBuffer,
                                      cbReturnBuffer ) ) {

                    return lstrlen(ReturnBuffer)+1;
                }
            }

            RtlFreeUnicodeString(&DriveRootU);
        }
    }

    RtlFreeUnicodeString(&SystemRootU);

    return 0;
}


//
//  Convert an NT path to a DOS path
//
BOOL
MatchNtPathToDosPath(
    IN  PUNICODE_STRING     NtPathU,
    IN  PUNICODE_STRING     DosLinkU,
    IN  SZ                  DosPath,
    OUT SZ                  ReturnBuffer,
    IN  CB                  cbBuffer
    )
{

    CHAR    NtPath[MAX_PATH];
    CHAR    DosLink[MAX_PATH];
    SZ      p;

    Unused( cbBuffer );

    ConvertUnicodeToAnsi( NtPathU,  NtPath );
    ConvertUnicodeToAnsi( DosLinkU, DosLink );

    //
    //  If DosLink is a substring of NtPath, then subsitute that substring by
    //  the given DosPath.
    //
    p = strstr( NtPath, DosLink );

    if ( p == NtPath ) {

        strcpy( ReturnBuffer, DosPath );
        p = NtPath + strlen(DosLink);
        strcat( ReturnBuffer, p );

        return fTrue;

    }

    return fFalse;
}




//
//  Convert Unicode string to ansi string
//
VOID
ConvertUnicodeToAnsi(
    IN  PUNICODE_STRING     UnicodeString,
    OUT SZ                  AnsiString
    )
{
    WCHAR   *pw;
    SZ      pa;

    pw = UnicodeString->Buffer;
    pa = AnsiString;

    while ( *pw != (WCHAR)0 ) {
        *pa++ = (CHAR)(*pw++);
    }

    *pa = '\0';
}



//
//  Get NT drive
//
CB
GetNtDrive(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{

    if ( GetNtDir( Args, cArgs, ReturnBuffer, cbReturnBuffer ) > 0 ) {

        ReturnBuffer[2] = '\0';
        return 3;

    }

    return 0;
}



#if i386


//
//  Get NT Boot Info - I386 version
//
CB
GetNtBootInfo(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{

    #define BOOT_INI        "C:\\BOOT.INI"
    #define MULTIBOOT_SCT   "multiboot"
    #define FLEXBOOT_SCT    "flexboot"
    #define OS_SCT          "operating systems"
    #define TIMEOUT         "timeout"
    #define DEFAULT         "default"

    PTAGGEDFILE pBootTxt;
    PTFSECTION  pSection;
    PTFKEYWORD  pTimeout;
    PTFKEYWORD  pDefault;
    PTFKEYWORD  pKey;
    BOOL        fOkay = fFalse;
    RGSZ        rgszInfo;
    RGSZ        rgszTmp;
    SZ          sz;
    INT         cCount = 3;


    Unused( Args );
    Unused( cArgs );
    Unused( cbReturnBuffer );

    rgszInfo = RgszAlloc(cCount);
    rgszTmp  = RgszAlloc(3);

    if ( rgszInfo && rgszTmp ) {
        //
        //  Get Boot.txt
        //
        if ( pBootTxt = GetTaggedFile( BOOT_INI ) ) {

            //
            //  Get multiboot section
            //
            if ( ( pSection = GetSection( pBootTxt, MULTIBOOT_SCT )) ||
                 ( pSection = GetSection( pBootTxt, FLEXBOOT_SCT  ))
               ) {

                //
                //  Get timeout and default
                //
                pTimeout = GetKeyword( pSection, TIMEOUT );
                pDefault = GetKeyword( pSection, DEFAULT );

                if ( pTimeout && pDefault ) {

                    //
                    //  Get Operating systems section
                    //
                    if ( pSection = GetSection( pBootTxt, OS_SCT ) ) {

                        rgszInfo[0] = SzDup( pTimeout->szValue );
                        rgszInfo[1] = SzDup( pDefault->szValue );
                        rgszInfo[2] = NULL;

                        if ( rgszInfo[0] && rgszInfo[1] ) {

                            fOkay = fTrue;
                            pKey  = NULL;

                            while ( pKey = GetNextKeyword( pSection, pKey )) {

                                rgszTmp[0] = pKey->szName;
                                rgszTmp[1] = pKey->szValue;
                                rgszTmp[2] = NULL;

                                sz = SzListValueFromRgsz( rgszTmp );

                                if ( !sz ||
                                     !RgszAdd( &rgszInfo, sz ) ) {

                                    fOkay = fFalse;
                                    if ( sz ) {
                                        SFree( sz );
                                    }
                                    break;
                                }
                            }
                        }

                    }
                }
            }

            CloseTaggedFile( pBootTxt );
        }
    }

    if ( fOkay ) {

        sz = SzListValueFromRgsz( rgszInfo );

        if ( sz ) {

            strcpy( ReturnBuffer, sz );

            SFree( sz );

        } else {

            fOkay = fFalse;
        }
    }


    if ( rgszTmp ) {
        rgszTmp[0] = NULL;
        RgszFree( rgszTmp );
    }

    if ( rgszInfo ) {
        RgszFreeCount( rgszInfo, cCount );
    }

    if ( fOkay ) {
        return lstrlen(ReturnBuffer)+1;
    } else {
        return 0;
    }

}



#else // if i386



//
//  Get NT Boot Info - MIPS version
//
CB
GetNtBootInfo(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{

    //
    //  BUGBUG ramonsa - For MIPS currently we fail
    //

    Unused( Args );
    Unused( cArgs );
    Unused( ReturnBuffer );
    Unused( cbReturnBuffer );

    return 0;

}


#endif // if i386

//
//  Get value of an environment variable. Returns the value in list form. If the
//  value is a path (semicolon-separated components) each component is an element
//  of the list.
//

CB
GetLoadedEnvVar(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{

    CHAR    EnvValue[ MAX_PATH ];
    SZ      sz;

    Unused( cbReturnBuffer );

    ReturnBuffer[0] = '\0';

    if (cArgs > 0) {

        if ( GetEnvironmentVariable( Args[0], EnvValue, MAX_PATH ) == 0 ) {

            //
            //  Env. Variable not defined, return empty list
            //
            #define UNDEF_VAR_VALUE "{}"

            lstrcpy( ReturnBuffer, UNDEF_VAR_VALUE );
            return lstrlen( ReturnBuffer )+1;

        } else if ( sz = SzListValueFromPath( EnvValue ) ) {

            lstrcpy( ReturnBuffer, sz );
            SFree( sz );
            return lstrlen( ReturnBuffer)+1;
        }
    }

    return 0;
}


CB
IsUniprocessorSystem(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    CHAR Value[256];
    HKEY hkey;
    LONG l;
    DWORD size;
    BOOL IsUp;
    SYSTEM_INFO SysInfo;

    Unused(Args);
    Unused(cArgs);
    Unused(cbReturnBuffer);

    ReturnBuffer[0] = 0;

    //
    // Look in the registry.
    //
    l = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            "Software\\Microsoft\\Windows NT\\CurrentVersion",
            0,
            KEY_QUERY_VALUE,
            &hkey
            );

    if(l == NO_ERROR) {

        size = sizeof(Value);

        l = RegQueryValueEx(
                hkey,
                "CurrentType",
                NULL,
                NULL,
                Value,
                &size
                );

        RegCloseKey(hkey);
    }

    if(l == NO_ERROR) {

        //
        // It's UP if the string starts with Uni
        // and not Multi
        //
        IsUp = (Value[0] == 'U');

    } else {

        //
        // Registry didn't tell us for some reason; fall back on
        // the # of processors.
        //
        GetSystemInfo(&SysInfo);

        IsUp = (SysInfo.dwNumberOfProcessors == 1);
    }

    lstrcpy(ReturnBuffer,IsUp ? "YES" : "NO");

    return lstrlen(ReturnBuffer)+1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\dialogs.c ===
#include "precomp.h"
#pragma hdrstop
/***************************************************************************/
/************************ dialog handling routines  ************************/
/***************************************************************************/


/*
**  Purpose:
**      Creates a dialog on the screen.  Called by HdlgPushDbcb
**  Arguments:
**      hinst:      Handle to instance of the APP (i.e. the shell)
**      szDlg:      Name of dialog template
**      hwndParent: Handle to parent window (i.e. the shell)
**      lpproc:     Procedure-instance address for the dialog procedure
**      lParam:     32-bit initialization value that will be passed to the
**                      dialog procedure when the dialog box is created.
**                      Currently unused by our general dialog procedures.
**  Returns:
**      The window handle of the dialog box if window creation succeeds,
**      otherwise NULL.
**
****************************************************************************/
HDLG APIENTRY HdlgCreateDialog(hinst, szDlg, hwndParent, lpproc,
        lParam)
HANDLE  hinst;
SZ      szDlg;
HWND    hwndParent;
WNDPROC lpproc;
DWORD   lParam;
{
    WNDPROC lpfnDlgProc;
   HDLG hdlgResult ;

#ifdef DLL
    lpfnDlgProc = lpproc;
#else  /* !DLL */
    lpfnDlgProc = MakeProcInstance(lpproc, hinst);
#endif /* !DLL */
    Assert(lpfnDlgProc != NULL);

    hdlgResult = CreateDialogParam(hinst, (LPCSTR)szDlg, hwndParent, (DLGPROC)lpfnDlgProc,
                                  (LONG)lParam);
   if ( hdlgResult == NULL )
   {
#if DEVL
       OutputDebugString("SETUP: dialog load failed on [");
       OutputDebugString( szDlg );
       OutputDebugString( "].\n" );
#endif
   }
   return hdlgResult ;
}


/*
**  Purpose:
**      To destroy a dialog
**  Arguments:
**      hdlg: A window handle to the dialog.
**  Returns:
**      fFalse if the window handle to the dialog is NULL, fTrue otherwise
**
****************************************************************************/
BOOL APIENTRY FCloseDialog(hdlg)
HDLG hdlg;
{
    HWND hwndShell;

    ChkArg(hdlg != NULL, 1, fFalse);

    hwndShell = GetParent(hdlg);
    SendMessage(hdlg, (WORD)STF_DESTROY_DLG, 0, 0L);
    if (hwndShell != NULL)
        UpdateWindow(hwndShell);

    return(fTrue);
}


/*
**  Purpose:
**      To make a dialog that has already been created invisible.
**  Arguments:
**      hdlg: non-NULL window handle to the dialog
**  Returns:
**      Nonzero if the dialog was previously visible, 0 if it was
**      previously hidden.
**
***************************************************************************/
BOOL APIENTRY FHideDialog(hdlg)
HDLG hdlg;
{
    ChkArg(hdlg != NULL, 1, fFalse);

    ShowWindow(hdlg, SW_HIDE);

    return(fTrue);
}


/*
**  Purpose:
**      To show a dialog in either its active or inactive state.
**  Arguments:
**      hdlg:   A window handle to the dialog
**      fActive:    a boolean value that specifies whether the dialog should be
**                  shown as active (fTrue) or inactive (fFalse);
**  Returns:
**      fTrue
**
****************************************************************************/
BOOL APIENTRY FShowDialog(hdlg, fActive)
HDLG hdlg;
BOOL fActive;
{

//***** REMOVED FOR NEW ACTIVATION SCHEME ******************************
//    if (fActive)
//        EvalAssert(FActivateDialog(hdlg));
//    else
//        EvalAssert(FInactivateDialog(hdlg));
//
//    //
//    // And then show it
//    //
//
//    SetWindowPos(hdlg, NULL, 0,0,0,0, SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE);
//***** REMOVED FOR NEW ACTIVATION SCHEME ******************************

    if (fActive) {
        ShowWindow(hdlg, SW_SHOWNORMAL);
    }
    else {
        ShowWindow(hdlg, SW_SHOWNOACTIVATE);
    }

    return(fTrue);
}


/*
**  Purpose:
**      To activate a dialog.  That is, set the title bar color to the active
**      color and restore the sysmenu.
**  Arguments:
**      hdlg: The window handle to the dialog
**  Returns:
**      fTrue
**
*****************************************************************************/
BOOL APIENTRY FActivateDialog(hdlg)
HDLG hdlg;
{
    LONG lStyle;

    ChkArg(hdlg != NULL, 1, fFalse);

    lStyle = GetWindowLong(hdlg, GWL_STYLE);
    lStyle = lStyle | WS_SYSMENU;
    SetWindowLong(hdlg, GWL_STYLE, lStyle);

//***** REMOVED FOR NEW ACTIVATION SCHEME ******************************
//    SendMessage(hdlg, WM_NCACTIVATE, 1, 0L);
//***** REMOVED FOR NEW ACTIVATION SCHEME ******************************

    return(fTrue);
}


/*
**  Purpose:
**      To inactivate the dialog.  That is, change the title bar color to the
**      inactive color and remove the sysmenu.
**  Arguments:
**      hdlg: The non-NULL window handle to the dialog.
**  Returns:
**      fTrue
**
*****************************************************************************/
BOOL APIENTRY FInactivateDialog(hdlg)
HDLG hdlg;
{
    LONG lStyle;

    ChkArg(hdlg != NULL, 1, fFalse);

    lStyle = GetWindowLong(hdlg, GWL_STYLE);
    lStyle = lStyle & (~WS_SYSMENU);
    SetWindowLong(hdlg, GWL_STYLE, (DWORD)lStyle);

//***** REMOVED FOR NEW ACTIVATION SCHEME ******************************
//    SendMessage(hdlg, WM_NCACTIVATE, 0, 0L);
//***** REMOVED FOR NEW ACTIVATION SCHEME ******************************

    return(fTrue);
}


/*
**  Purpose:
**      To enable all mouse and keyboard input to the dialog.
**  Arguments:
**      hdlg: The window handle to the dialog.
**  Returns:
**      fFalse is hdlg is NULL. Otherwise it returns 0 if the attempt to
**      enable the dialog fails, nonzero if it succeeds.
**
****************************************************************************/
BOOL APIENTRY FEnableDialog(hdlg)
HDLG hdlg;
{
    ChkArg(hdlg != NULL, 1, fFalse);

    return(EnableWindow(hdlg, fTrue));
}


/*
**  Purpose:
**      To disable all mouse and keyboard input to the dialog.
**  Arguments:
**      hdlg: The window handle to the dialog.
**  Returns:
**      fFalse is hdlg is NULL. Otherwise it returns 0 if the attempt to
**      disable the dialog fails, nonzero if it succeeds.
**
****************************************************************************/
BOOL APIENTRY FDisableDialog(hdlg)
HDLG hdlg;
{
    ChkArg(hdlg != NULL, 1, fFalse);

    return(EnableWindow(hdlg, fFalse));
}


/*
**  Purpose:
**      To substitute the text in a dialog control with a value from the symbol
**      table.  If the text is of the form "@Key" then if there is an entry in
**      the symbol table with the key "Key" its value is substitued for the text
**      in the control.  If no such symbol is found then a blank string is
**      substituted.
**  Arguments:
**      hwnd:   The window handle of the control whose text is to be
**              substituted
**      lParam: Currently unused.
**  Notes:
**      This function must be exported.
**  Returns:
**      fTrue always
**
****************************************************************************/
BOOL APIENTRY TextSubst(hwnd, lParam)
HWND  hwnd;
DWORD lParam;
{
    CHP  rgch[cchpSymBuf + 1];
    CCHP cchpLength;
    SZ   sz = 0;

    Unused(lParam);

    cchpLength = (CCHP)GetWindowText(hwnd, (LPSTR)rgch, cchpSymMax + 1);
    rgch[cchpLength] = '\0';
    if (rgch[0] == '@')
    {
        if ((sz = SzFindSymbolValueInSymTab(rgch + 1)) != NULL)
        {
            if (0 == lstrcmpi( rgch, "@ProCancel" ))
            {
                if (NULL != SzFindSymbolValueInSymTab("!STF_NETCANCELOVERIDE"))
                {
                    // no cancel buttons on progress indicators
                    EnableWindow( hwnd, FALSE );
                    ShowWindow( hwnd, SW_HIDE );
                }
            }
            SetWindowText(hwnd, sz);
        }
        else
        {
            SetWindowText(hwnd, "");
        }
    }

    return(fTrue);
}


/*
**  Purpose:
**      To fill any appropriate controls in the dialog with text from the INF.
**      Any control containing text of the form "@Key" will be filled with
**      text from the INF associated with "Key" if it exists.  No such
**      substitution occurs for a control if "Key" doesn't exist.
**  Arguments:
**      hdlg:       The window handle to the dialog.
**      hinst:      Handle to instance of the APP (i.e. the shell)
**  Returns:
**      Nonzero if all of the child windows have been substituted
**      (if necessary), 0 otherwise.
**
****************************************************************************/
BOOL APIENTRY FFillInDialogTextFromInf(hdlg, hinst)
HDLG   hdlg;
HANDLE hinst;
{
    FARPROC lpproc;
    CHP     rgch[cchpSymBuf + 1];
    CCHP    cchpLength;
    SZ      sz = NULL;

    Unused(hinst);

    cchpLength = GetWindowText(hdlg, (LPSTR)rgch, cchpSymMax + 1);
    rgch[cchpLength] = '\0';
    if (rgch[0] == '@')
        {
        if ((sz = SzFindSymbolValueInSymTab(rgch + 1)) != NULL)
            SetWindowText(hdlg, sz);
        else
            SetWindowText(hdlg, "");
        }

#ifdef DLL
    lpproc = (FARPROC)TextSubst;
#else  /* !DLL */
    lpproc = MakeProcInstance((FARPROC)TextSubst, hinst);
#endif /* !DLL */

    return((EnumChildWindows(hdlg, (WNDENUMPROC)lpproc, (LPARAM)0L)));
}


/*
**  Purpose:
**      To create a dialog, fill any appropriate control with text from the INF
**      and make the dialog visible.
**  Arguments:
**      hinst:      Handle to instance of the APP (i.e. the shell)
**      szDlg:      Name of dialog template
**      hwndParent: Handle to parent window (i.e. the shell)
**      lpproc:     Procedure-instance address for the dialog procedure
**      lParam:     32-bit initialization value that will be passed to the
**                      dialog procedure when the dialog box is created.
**  Returns:
**      Window handle of the dialog if window creation succeeds, NULL otherwise.
**
****************************************************************************/
HDLG APIENTRY HdlgCreateFillAndShowDialog(hinst, szDlg, hwndParent,
        lpproc, lParam)
HANDLE  hinst;
SZ      szDlg;
HWND    hwndParent;
WNDPROC lpproc;
DWORD   lParam;
{
    HDLG hdlg;
    CHAR Class[MAX_PATH];

    if ((hdlg = HdlgCreateDialog(hinst, szDlg, hwndParent, lpproc, lParam)) !=
            (HDLG)NULL) {

        //
        // If the dialog has no exit button, diable the close option
        // on the system menu
        //

        if (    ( GetDlgItem ( hdlg, IDC_X ) == (HWND)NULL      )
             && ( GetWindowLong( hdlg, GWL_STYLE ) & WS_SYSMENU )
             && ( GetClassName( hdlg, Class, MAX_PATH )         )
             && ( !lstrcmpi( Class, (LPSTR)CLS_MYDLGS )         )
           ) {
            EnableMenuItem(
                GetSystemMenu(hdlg, FALSE),
                SC_CLOSE,
                MF_BYCOMMAND | MF_GRAYED | MF_DISABLED
                );
        }

        //
        // Do dialog text replacement from the inf.  All @Var values
        // get replaced by the value of Var
        //

        EvalAssert(FFillInDialogTextFromInf(hdlg, hinst));
        EvalAssert(FShowDialog(hdlg, fTrue));
    }

    return(hdlg);
}


/*
**  Purpose:
**      To center a dialog on the desktop window.
**  Arguments:
**      hdlg:      Handle to the dialog being centered
**  Returns:
**      fTrue:     Centering succeeded.
**      fFalse:    Error condition.
**
****************************************************************************/

BOOL
FCenterDialogOnDesktop(
    HWND hdlg
    )

{

   RECT DesktopRect, DlgRect;
   BOOL bStatus;
   HWND hwMaster ;
   POINT pt,
         ptCtr,
         ptMax,
         ptDlgSize ;
   LONG l ;

   ptMax.x = GetSystemMetrics( SM_CXFULLSCREEN ) ;
   ptMax.y = GetSystemMetrics( SM_CYFULLSCREEN ) ;

   //
   // Determine area of shell and of dlg
   //
   // Center dialog over the "pseudo parent" if there is one.
   //

   hwMaster = hwPseudoParent
            ? hwPseudoParent
            : GetDesktopWindow() ;

   if ( ! GetWindowRect( hwMaster, & DesktopRect ) )
       return fFalse ;

   if ( ! GetWindowRect( hdlg, & DlgRect ) )
       return fFalse ;

   ptDlgSize.x = DlgRect.right - DlgRect.left ;
   ptDlgSize.y = DlgRect.bottom - DlgRect.top ;

   //  Attempt to center our dialog on top of the "master" window.

   ptCtr.x = DesktopRect.left + ((DesktopRect.right  - DesktopRect.left) / 2) ;
   ptCtr.y = DesktopRect.top  + ((DesktopRect.bottom - DesktopRect.top)  / 2) ;
   pt.x = ptCtr.x - (ptDlgSize.x / 2) ;
   pt.y = ptCtr.y - (ptDlgSize.y / 2) ;

   //  Force upper left corner back onto screen if necessary.

   if ( pt.x < 0 )
       pt.x = 0 ;
   if ( pt.y < 0 )
       pt.y = 0 ;

   //  Now check to see if the dialog is getting clipped
   //  to the right or bottom.

   if ( (l = pt.x + ptDlgSize.x) > ptMax.x )
      pt.x -= l - ptMax.x ;
   if ( (l = pt.y + ptDlgSize.y) > ptMax.y )
      pt.y -= l - ptMax.y ;

   if ( pt.x < 0 )
        pt.x = 0 ;
   if ( pt.y < 0 )
        pt.y = 0 ;

   //
   // center the dialog window in the shell window.  Specify:
   //
   // SWP_NOSIZE     : To ignore the cx,cy params given
   // SWP_NOZORDER   : To ignore the HwndInsert after parameter and retain the
   //                  current z ordering.
   // SWP_NOACTIVATE : To not activate the window.
   //

   bStatus = SetWindowPos
                 (
                 hdlg,
                 (HWND) NULL,
                 pt.x,
                 pt.y,
                 0,
                 0,
                 SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE
                 );

   //
   // return Status of operation
   //

   return(bStatus);

}



#define MAX_SIZE_STRING 20

/* MySetDlgItemInt
 *
 * This implements the equivalent of SetDlgItemInt for long integers
 * The reason why we cannot use SetDlgItemInt is that Setup is supposed
 * to be able to do long on Win 16 as well
 *
 * ENTRY: hdlg  - handle to the dialog which has the text control
 *        nId   - Text Control ID
 *        nVal  - Integer decimal value
 *
 * EXIT: None.
 *
 */

VOID
MySetDlgItemInt(
    HDLG  hdlg,
    INT   nId,
    LONG  nVal
    )
{
    CHP  rgchSrcStr[MAX_SIZE_STRING];
    CHP  rgchDestStr[MAX_SIZE_STRING];

    NumericFormat ( _ltoa(nVal, rgchSrcStr, 10), (SZ)rgchDestStr );
    SetDlgItemText(
        hdlg,
        nId,
        (LPSTR)rgchDestStr
        );

    return;

}


/* NumericFormat
 *
 * This function will format a numeric string using comma seperators for
 * the thousands. The seperator used will be one specified in win.ini in
 * the [intl] section via the sThousand=, profile.
 *
 * ENTRY: szSrcBuf - Pointer to string in it's "raw" form.
 *
 *        szDispBuf - Pointer to buffer that will be returned with the thousands
 *                    seperated numeric string.
 *
 * EXIT: None.
 *
 */
VOID
NumericFormat(
    SZ szSrcBuf,
    SZ szDispBuf
    )
{
#define INTL   "intl"
#define THOU   "sThousand"
#define WININI "win.ini"

   SZ    szIndex = szSrcBuf;
   SZ    szDispBufHead = szDispBuf;
   INT   i = 0;
   CHP   rgchThouSep[2];
   CHP   chThouSep;

   if ( !szSrcBuf || !szSrcBuf[0] ) {
       szDispBuf[0] = '\0';
       return;
   }

   GetPrivateProfileString(INTL, THOU, ",", rgchThouSep, 2, WININI);
   chThouSep = rgchThouSep[0];

   /* if thousand seperator is NULL, just return szSrcBuf. */
   if (!chThouSep)
   {
      lstrcpy(szDispBuf, szSrcBuf);
      return;
   }

   while( *szIndex ) {    // seek end of string and increment the display buffer
      szIndex++;          // because were going to fill it up in reverse order.
      szDispBuf++;
   }
   szIndex--;                     // Back up to last digit of src.

   i = (lstrlen(szSrcBuf) / 3);          // This code calculates how many thousand
   if (! (lstrlen(szSrcBuf) % 3) && i )  // seperators will be needed.
      szDispBuf += (i-1);
   else
      szDispBuf += i;

   *szDispBuf-- = '\0';           // Terminate display buffer and back up.

   i = 0;
   while( fTrue ) {
      while( (szIndex != szSrcBuf) && (i < 3) ) {
         *szDispBuf-- = *szIndex--;
         ++i;
      }
      if ( szDispBuf != szDispBufHead ) {
         *szDispBuf-- = chThouSep;
         i=0;
      }
      else {
         *szDispBuf = *szIndex;      // Last char.
         break;
      }
   }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\dospif.c ===
#include "precomp.h"
#pragma hdrstop
/***************************************************************************

MODULE: DOSPIF.c

   This file contains procedures that create Program Information Files
   (PIFs) for DOS apps using information contained in the APPS.INF file.

   Copyright (C) Microsoft, 1991

HISTORY:

   Modified by:      Date:       Comment:

   PAK               11/2/90     Created

   PAK               8/18/91     Major Clean-up, rewrite, and bug fixes.

   SUNILP            2/04/92     Changed for Win 32 GUI Setup use

DESCRIPTION:


***************************************************************************/

extern HWND hwndFrame;

//
// This is common between dospif and search, so should go in an include file
//
#define EXE_WIN16_SZ    "WIN16"
#define EXE_WIN32_SZ    "WIN32"
#define EXE_DOS_SZ      "DOS"

/* Globals (App Modules) */
CB      cbAllPIF = 0;
LPVOID  lpAllPIF = NULL;
static  SZ szDOTPIF  = ".PIF";
static  SZ szProgman = "PROGMAN.EXE";

/* Globals (This Module) */
static BOOL bNoTrpHRGrfx = fTrue;
static BOOL bIs386 = fTrue;

/* statics which are global to this module. */
static LPPIFNEWSTRUCT   lpDfltPIF    = NULL;
static LPPIFNEWSTRUCT   lpCurrPIF    = NULL;
static LPPIFEXTHEADER   lpStdExtHdr  = NULL;
static LPPIF286EXT30    lpDfltStd    = NULL;
static LPPIF286EXT30    lpCurrStd    = NULL;
static LPPIFEXTHEADER   lpEnhaExtHdr = NULL;
static LPPIF386EXT      lpDfltEnha   = NULL;
static LPPIF386EXT      lpCurrEnha   = NULL;

/***************************************************************************

AddWinItem
----------

DESCRIPTION:

   This processes an Win16 | Win 32 App item in the App List.  The app rgsz
   structure is documented below:

   rgszApp[nEXETYPE=  0]   :   WIN16 | WIN32
   rgszApp[nNAME   =  1]   :   App Name
   rgszApp[nEXE    =  2]   :   App Exe (full path to the exe)


HISTORY:

   Modified by:      Date:       Comment:

   PAK               11/2/90     Created

   PAK               3/22/91     GenerateProgmanPath is no longer called
                                 since the PIFs all go in the same directory
                                 and will always be found.

   SUNILP            2/5/92      Modified extensively for GUI Setup toolkit

***************************************************************************/
ADDAPP_STATUS
AddWinItem(
    IN RGSZ rgszApp,
    IN SZ   szGroup
    )
{
   ADDAPP_STATUS  Status = ADDAPP_SUCCESS;

   SZ        szIconFile = "";
   INT       nIcon = 0;    /* default icon */
   CMO       cmo = cmoVital;
   BOOL      bStatus;



   bStatus = FCreateProgManItem(
                 szGroup,              // Group to add
                 rgszApp[nNAME],       // Item name
                 rgszApp[nEXE],        // Command field
                 szIconFile,           // Icon file
                 nIcon,                // Icon number
                 cmo,                  // vital?
                 TRUE                  // common group
                 );

   if (!bStatus) {
       Status = ADDAPP_GRPFAIL;
   }

   return (Status);

}

/***************************************************************************

AddDosAppItem
--------------

DESCRIPTION:

   This processes a DOS App item in the App List.  The app rgsz structure
   is documented below:

   rgszApp[nEXETYPE=  0]   :   DOS
   rgszApp[nNAME   =  1]   :   App Name
   rgszApp[nEXE    =  2]   :   App Exe (full path to the exe)
   rgszApp[nDIR    =  3]   :   App Directory
   rgszApp[nPIF    =  4]   :   App PIF Name
   rgszApp[nDEFDIR =  5]   :   App Default Directory ("" means user App Direct)
   rgszApp[nCWE    =  6]   :   App CWE field ("" means no, "cwe" means close)
   rgszApp[nSTDOPT =  7]   :   App Standard mode options ({} for no section)
   rgszApp[nENHOPT =  8]   :   App Enhanced mode options ({} for no section)
   rgszApp[nICOFIL =  9]   :   App Icon File ("" means use default)
   rgszApp[nICONUM = 10]   :   App Icon Num  ("" means use default)


HISTORY:

   Modified by:      Date:       Comment:

   PAK               11/2/90     Created

   PAK               3/22/91     GenerateProgmanPath is no longer called
                                 since the PIFs all go in the same directory
                                 and will always be found.

   SUNILP            2/5/92      Modified extensively for GUI Setup toolkit

***************************************************************************/
ADDAPP_STATUS
AddDosAppItem(
    IN RGSZ rgszApp,
    IN SZ   szPifDir,
    IN SZ   szGroup
    )
{
   ADDAPP_STATUS  Status = ADDAPP_GENFAIL;

   CHP       szPIFPath[cchlFullPathBuf];
   SZ        szIconFile = rgszApp[nICOFIL];
   INT       nIcon = 0;    /* default icon */
   CMO       cmo = cmoVital;
   BOOL      bStatus;


   // Build the PIF file.

   if ( FDeterminePIFName(rgszApp, szPifDir, szPIFPath)   &&
        FCreatePIF(rgszApp, szPIFPath)
      ) {

       //
       // Check IconFile
       //

       if (CrcStringCompareI(szIconFile, "") == crcEqual) {
           szIconFile = szProgman;
       }

       //
       //  Check icon number
       //

       if (CrcStringCompareI(rgszApp[nICONUM], "") != crcEqual) {
           nIcon = atoi(rgszApp[nICONUM]);
       }


       bStatus = FCreateProgManItem(
                     szGroup,              // Group to add
                     rgszApp[nNAME],       // Item name
                     szPIFPath,            // Command field
                     szIconFile,           // Icon file
                     nIcon,                // Icon number
                     cmo,                  // vital?
                     TRUE                  // common group
                     );

       if (bStatus) {
           Status = ADDAPP_SUCCESS;
       }
       else {
           Status = ADDAPP_GRPFAIL;
       }

   }

   return (Status);
}



/***************************************************************************

DeterminePIFName
----------------

DESCRIPTION:

   This procedure will determine a name (possibly with user interaction)
   for the PIF which is to be created.  If the proposed PIF name already
   exists and the user does not wish to replace it, an alternative name
   will be sought.  The alternative name is obtained by adding 2 digits
   to the end of the file name (if possible) and assertaining whether the
   new PIF exists.  If the filename is already seven or eight characters
   in length the last two characters are replaced with digits.

   E.G. filename.PIF becomes filena00.PIF
        file.PIF     becomes file00.PIF

   The last two digits of the filename are incremented to 99 until a
   non-existant file is found.

   The user will be asked to replace the PIF if we determine that the PIF
   we are about to create is for the same EXE name and contains the same
   description string in the prexisting PIF.


HISTORY:

   Modified by:      Date:       Comment:

   PAK               7/31/91     Created
   SUNILP            2/6/92      Removed questioning user for alternate PIF
                                 Changed to use Setup file functions.

***************************************************************************/
BOOL
FDeterminePIFName(
    IN     RGSZ rgszApp,
    IN     SZ   szPifDir,
    IN OUT SZ   szPIFPath
    )
{
   PFH      pfh;
   SZ       szName[PIFNAMESIZE+1];
   SZ       szExe[PIFSTARTLOCSIZE+1];
   int      i = 0, iLen;
   char     sub_char1 = '0';
   char     sub_char2 = '0';
   BOOL     bConcat, bInitialConcat = fTrue;
   BOOL     bCouldntDelete = fFalse, bCouldntRead = fFalse;


   // We need to find out if the proposed pif already exists
   // If it does we need to open it for reading and extract
   // the name and description fields to make sure that the
   // PIF is for the same app.
   //

   //
   // Build the fully qualified Pif file
   //

   lstrcpy(szPIFPath, szPifDir);
   lstrcat(szPIFPath, rgszApp[nPIF]);
   lstrcat(szPIFPath, szDOTPIF);


   //
   // Does the PIF already exist, if yes open for reading. if no then
   // return because we already have the PIF Path we need.
   //

   if ((pfh = PfhOpenFile(szPIFPath, ofmRead)) == (PFH)NULL) {
      return (fTrue);
   }

   // The Proposed PIF already exists
   // Can we extract the Description and Exe Name?
   // If NO, create new PIF since if we cant read it we probably won't
   // be able to replace it.
   //

   if ( (LfaSeekFile(pfh, 2L, sfmSet) != 2L)                          ||
        (CbReadFile(pfh, (PB)szName, (CB)PIFNAMESIZE) != PIFNAMESIZE) ||
        (LfaSeekFile(pfh, 4L, sfmCur) != (CB)PIFNAMESIZE + 2L + 4L)   ||
        (CbReadFile(pfh, (PB)szExe, (CB)PIFSTARTLOCSIZE) != PIFSTARTLOCSIZE)
      ) {

      bCouldntRead = fTrue;
   }


   // Close Preexisting PIF as we no longer require info from it

   FCloseFile(pfh);
   pfh = (PFH)NULL;


   if (!bCouldntRead) {
        ExtractStrFromPIF((LPSTR)szName, PIFNAMESIZE);
        if (!lstrcmpi((LPSTR)szExe,  rgszApp[nEXE]) &&
            !lstrcmpi((LPSTR)szName, rgszApp[nNAME])
           ) {

           // No asking the user, just delete.

           if (FRemoveFile(szPIFPath)) {
               return (fTrue);
           }

       }
   }


   /* see if PIF specified in szPIFPath already exists.  If it does
      we change the name, looking for a name that doesn't exist.
   */

   if (lstrlen(szGetFileName(szPIFPath)) < 11) {
      bConcat = fTrue;
   }
   else {
      bConcat = fFalse;
   }

   iLen = lstrlen(szPIFPath);

   i = 0;
   while (FFileExists(szPIFPath))
   {
      if (i == 100) {
         return fFalse;
      }

      if (bConcat)
      {
         if (bInitialConcat)
         {
            bInitialConcat = fFalse;
            szPIFPath[iLen-2] = '.';
            szPIFPath[iLen-1] = 'P';
            szPIFPath[iLen]   = 'I';
            szPIFPath[iLen+1] = 'F';
            szPIFPath[iLen+2] = '\0';
         }
         szPIFPath[iLen-4] = sub_char1;
         szPIFPath[iLen-3] = sub_char2;
      }
      else
      {
         szPIFPath[iLen-6] = sub_char1;
         szPIFPath[iLen-5] = sub_char2;
      }

      if (sub_char2 == '9')
      {
         sub_char1++;
         sub_char2 = '0';
      }
      else
         sub_char2++;
      i++;
   }

   return( fTrue );
}


/***************************************************************************

FCreatePIF
----------

DESCRIPTION:

   This code creates the PIF file.

   For the 286 product only the 286 PIF extensions are added.
   For the 386 product both 286 and the 386 extension are added.

   The PIF file looks like this

        PIFNEWSTRUCT    +---------------+
                        |               |
                        |               |
                        |               |
                        | PIFEXTHEADER  |
                        +---------------+
        PIFEXTHEADER    +---------------+
                        | for Standard  |
                        |               |
                        +---------------+
        PIF286EXT30     +---------------+
                        |               |
                        |               |
                        +---------------+
        PIFEXTHEADER    +---------------+ this only present for 386 product
                        | for Enhanced  |                |
                        |               |                v
                        +---------------+
        PIF386EXT       +---------------+
                        |               |
                        |               |
                        +---------------+

HISTORY:

   Modified by:      Date:       Comment:

   PAK               11/2/90     Created

   SUNILP            2/5/92      Modified to use Setup File functions.

***************************************************************************/
BOOL
FCreatePIF(
    RGSZ  rgszApp,
    SZ    szPIFPath
    )
{
   PFH  pfh = (PFH)NULL;
   CB   cbActual;
   BOOL bStatus;
   PACKED_PIFNEWSTRUCT PPif;

   // Create PIF, at this point it does not exist

   if (!(pfh = PfhOpenFile(szPIFPath, ofmCreate))) {
      return (fFalse);
   }

   // Copy Default PIF to current PIF

   memmove((PVOID)lpCurrPIF, (PVOID)lpDfltPIF, sizeof(PIFNEWSTRUCT));
   memmove((PVOID)lpCurrStd, (PVOID)lpDfltStd, sizeof(PIF286EXT30));

   if (bIs386) {
      memmove((PVOID)lpCurrEnha, (PVOID)lpDfltEnha, sizeof(PIF386EXT));
   }


   // Process information common to both standard and enhanced mode PIFs

   ProcessCommonInfo( rgszApp, lpCurrPIF );

   // Write information particular to standard mode PIFs to Current PIF

   bStatus = FProcessStdModeInfo(rgszApp[nSTDOPT], lpCurrPIF, lpCurrStd);
   if (!bStatus) {
       return (fFalse);
   }


   //
   // write PIF struct, and 286 extension header and extension.
   //

   PackPif(lpCurrPIF, &PPif);
   cbActual = sizeof(PACKED_PIFNEWSTRUCT);
   if (cbActual != CbWriteFile(pfh, (PB)&PPif, (CB)cbActual)) {
       return (fFalse);
   }

   cbActual = sizeof(PIFEXTHEADER);
   if (cbActual != CbWriteFile(pfh, (PB)lpStdExtHdr, (CB)cbActual)) {
       return (fFalse);
   }

   cbActual = sizeof(PIF286EXT30);
   if (cbActual != CbWriteFile(pfh, (PB)lpCurrStd, (CB)cbActual)) {
       return (fFalse);
   }

   //
   // Write information particular to enhanced mode PIFs to Current PIF
   //

   if (bIs386) {

      bStatus = FProcessEnhaModeInfo( rgszApp[nENHOPT], lpCurrEnha);
      if (!bStatus) {
           return (fFalse);
      }

      cbActual = sizeof(PIFEXTHEADER);
      if (cbActual != CbWriteFile(pfh, (PB)lpEnhaExtHdr, (CB)cbActual)) {
          return (fFalse);
      }

      cbActual = sizeof(PIF386EXT);
      if (cbActual != CbWriteFile(pfh, (PB)lpCurrEnha, (CB)cbActual)) {
          return (fFalse);
      }

   }

   bStatus = FCloseFile(pfh);
   return (bStatus);
}


/***************************************************************************

ProcessCommonInfo
------------------

DESCRIPTION:

   This procedure will set the Common PIF settings.


HISTORY:

   Modified by:      Date:       Comment:

   SUNILP            2/4/92      Changed to use INF Vars from symbol table

***************************************************************************/
VOID
ProcessCommonInfo(
     RGSZ rgszApp,
     LPPIFNEWSTRUCT lpPNS
     )
{

   // Write information common to both standard and enhanced mode PIFs
   // to Current PIF

   // 1. App Filename

   lstrcpy( lpPNS->startfile, rgszApp[nEXE]  );

   // 2. App Title

   lstrcpy( lpPNS->name, rgszApp[nNAME] );

   // 3. Default Startup Dir

   if (!lstrcmpi(rgszApp[nDEFDIR], "")) {
       lstrcpy(lpPNS->defpath, rgszApp[nDIR] );
   }
   else {
       lstrcpy(lpPNS->defpath, rgszApp[nDEFDIR] );
   }
   if ( (lpPNS->defpath)[lstrlen(lpPNS->defpath) - 1] == '\\' ) {
       (lpPNS->defpath)[lstrlen(lpPNS->defpath) - 1] = '\0';
   }

   // 4. Close Window on exit

   if (!lstrcmpi(rgszApp[nCWE], CLOSE_ON_EXIT)) {
      lpPNS->MSflags |= EXITMASK;
   }

   return;

}

/***************************************************************************

FProcessStdModeInfo
-------------------

DESCRIPTION:

   This procedure will set the Standard Mode PIF settings according to the
   information given in APPS.INF.


HISTORY:

   Modified by:      Date:       Comment:

   PAK               11/2/90     Created
   SUNILP            2/4/92      Changed to use INF Vars from symbol table

***************************************************************************/
BOOL
FProcessStdModeInfo(
    SZ szStdOptions,
    LPPIFNEWSTRUCT lpPNS,
    LPPIF286EXT30 lpPStd
    )
{
   PSZ   pszStdOptions;
   SZ    szOption;
   RGSZ  rgszStdOptions, rgszOption, rgszVal;
   int   iOption;

   //
   // szStdOptions: {{Var1, Val1}, {Var2, Val2}, {Var3, Val3}}
   //

   while ((pszStdOptions = rgszStdOptions = RgszFromSzListValue(szStdOptions)) == (RGSZ)NULL) {
       if (!FHandleOOM(hwndFrame)) {
           return(fFalse);
       }
   }

   //
   // For all options found
   //

   while ((szOption = *pszStdOptions++) != NULL) {

       //
       // Find the Var, Val pair
       //

       while ((rgszOption = RgszFromSzListValue(szOption)) == (RGSZ)NULL) {
           if (!FHandleOOM(hwndFrame)) {
               EvalAssert(FFreeRgsz(rgszStdOptions));
               return(fFalse);
           }
       }

       //
       // Check validity of option
       //

       if (rgszOption[0] == NULL || rgszOption[1] == NULL) {
           EvalAssert(FFreeRgsz(rgszOption));
           continue;
       }

       //
       // Examine Option Variable
       //

       iOption = GetExtOption(rgszOption[0]);

       switch (iOption) {

       case PARAMS:
          lstrcpy(lpPNS->params, rgszOption[1]);
          break;

       case MINCONVMEM:
          if (!lstrcmp(rgszOption[1], "-1")) {
             lpPNS->minmem = 0xFFFF;
          }
          else {
             lpPNS->minmem = (WORD)atoi(rgszOption[1]);
          }
          break;

       case VIDEOMODE:
          if (!lstrcmpi(rgszOption[1], TEXT_OPT))
          {
             lpPNS->MSflags &= TEXTMASK;
             lpPNS->sysmem = 7;
          }
          else if (!lstrcmpi(rgszOption[1], GRAF_MULTXT))
          {
             lpPNS->MSflags |= GRAPHMASK;
             lpPNS->sysmem = 23;
          }
          break;

       case XMSMEM:
          while ((rgszVal = RgszFromSzListValue(rgszOption[1])) == (RGSZ)NULL) {
              if (!FHandleOOM(hwndFrame)) {
                  EvalAssert(FFreeRgsz(rgszOption));
                  EvalAssert(FFreeRgsz(rgszStdOptions));
                  return (fFalse);
              }
          }

          if (rgszVal[0] == NULL || rgszVal[1] == NULL) {
            EvalAssert(FFreeRgsz(rgszVal));
            break;
          }

          lpPStd->PfMinXmsK = (WORD)atoi(rgszVal[0]);

          if (!lstrcmp(rgszVal[1], "-1")) {
             lpPStd->PfMaxXmsK = 0xFFFF;
          }
          else {
             lpPStd->PfMaxXmsK = (WORD)atoi(rgszVal[1]);
          }
          EvalAssert(FFreeRgsz(rgszVal));
          break;

       case CHECKBOXES:
          while ((rgszVal = RgszFromSzListValue(rgszOption[1])) == (RGSZ)NULL) {
              if (!FHandleOOM(hwndFrame)) {
                  EvalAssert(FFreeRgsz(rgszOption));
                  EvalAssert(FFreeRgsz(rgszStdOptions));
                  return (fFalse);
              }
          }

          ProcessCheckBoxSwitches(rgszVal, lpPNS, lpPStd);
          EvalAssert(FFreeRgsz(rgszVal));
          break;

       default:
          break;

       }
       EvalAssert(FFreeRgsz(rgszOption));
   }
   EvalAssert(FFreeRgsz(rgszStdOptions));
   return (fTrue);
}

/***************************************************************************

ProcessCheckBoxSwitches
-----------------------

DESCRIPTION:

   This procedure will process the "checkboxes = ..." line from the given
   standard PIF section of APPS.INF.  The various fields of the line will
   affect the pif and pif286 structures.


HISTORY:

   Modified by:      Date:       Comment:

   PAK               11/2/90     Created
   SUNILP            2/4/92      Modified to use RGSZ list

***************************************************************************/
VOID
ProcessCheckBoxSwitches(
    RGSZ rgsz,
    LPPIFNEWSTRUCT lpPNS,
    LPPIF286EXT30 lpPStd
    )
{
   int   i;
   SZ    szStr;

   /* If this gets called we are not using defaults for "checkboxes"
      so reset all bits that "checkboxes =" can set.
   */


   lpPNS->MSflags &= ~(PSMASK | SGMASK | COM1MASK | COM2MASK);
   lpPNS->behavior &= ~KEYMASK;
   lpPStd->PfW286Flags &= ~(fALTTABdis286 | fALTESCdis286 | fALTPRTSCdis286 |
                           fPRTSCdis286 | fCTRLESCdis286 | fNoSaveVid286 |
                           fCOM3_286 | fCOM4_286);
   i = 0;
   while ((szStr = rgsz[i++]) != (SZ)NULL) {

      if (!lstrcmpi(szStr, COM1)) {
          lpPNS->MSflags |= COM1MASK;
      }

      else if (!lstrcmpi(szStr, COM2)) {
          lpPNS->MSflags |= COM2MASK;
      }

      else if (!lstrcmpi(szStr, COM3)) {
          lpPStd->PfW286Flags |= fCOM3_286;
      }

      else if (!lstrcmpi(szStr, COM4)) {
          lpPStd->PfW286Flags |= fCOM4_286;
      }

      else if (!lstrcmpi(szStr, NO_SCRN_EXCHANGE)) {
          lpPNS->MSflags |= SGMASK;
      }

      else if (!lstrcmpi(szStr, KEYB)) {
          lpPNS->behavior |= KEYMASK;
      }

      else if (!lstrcmpi(szStr, PREVENT_PROG_SW)) {
          lpPNS->MSflags |= PSMASK;
      }

      else if (!lstrcmpi(szStr, ALT_TAB)) {
          lpPStd->PfW286Flags |= fALTTABdis286;
      }

      else if (!lstrcmpi(szStr, ALT_ESC)) {
          lpPStd->PfW286Flags |= fALTESCdis286;
      }

      else if (!lstrcmpi(szStr, CTRL_ESC)) {
          lpPStd->PfW286Flags |= fCTRLESCdis286;
      }

      else if (!lstrcmpi(szStr, PRSCRN)) {
          lpPStd->PfW286Flags |= fPRTSCdis286;
      }

      else if (!lstrcmpi(szStr, ALT_PRSCRN)) {
         lpPStd->PfW286Flags |= fALTPRTSCdis286;
      }

      else if (!lstrcmpi(szStr, NO_SAVE_SCREEN)) {
         lpPStd->PfW286Flags |= fNoSaveVid286;
      }
   }
}

/***************************************************************************

FProcessEnhaModeInfo
-------------------

DESCRIPTION:

   This procedure will set the Standard Mode PIF settings according to the
   information given in APPS.INF.

HISTORY:

   Modified by:      Date:       Comment:

   PAK               11/2/90     Created
   SUNILP            2/4/92      Modified for Win32 GUI Setup.

***************************************************************************/
BOOL
FProcessEnhaModeInfo(
    SZ szEnhOptions,
    LPPIF386EXT lpPEnha
    )
{
   PSZ   pszEnhOptions;
   SZ    szOption, szVal;
   RGSZ  rgszEnhOptions, rgszOption, rgszVal;
   int   i, iOption;

   //
   // szEnhOptions: {{Var1, Val1}, {Var2, Val2}, {Var3, Val3}}
   //

   while ((pszEnhOptions = rgszEnhOptions = RgszFromSzListValue(szEnhOptions)) == (RGSZ)NULL) {
       if (!FHandleOOM(hwndFrame)) {
           return (fFalse);
       }
   }

   //
   // For all options found
   //

   while ((szOption = *pszEnhOptions++) != NULL) {

       //
       // Find the Var, Val pair
       //

       while ((rgszOption = RgszFromSzListValue(szOption)) == (RGSZ)NULL) {
           if (!FHandleOOM(hwndFrame)) {
               EvalAssert(FFreeRgsz(rgszEnhOptions));
               return (fFalse);
           }
       }

       //
       // Check validity of option
       //

       if (rgszOption[0] == NULL || rgszOption[1] == NULL) {
           EvalAssert(FFreeRgsz(rgszOption));
           continue;
       }

       //
       // Examine Option Variable
       //

       iOption = GetExtOption(rgszOption[0]);

       switch (iOption) {

       case PARAMS:
          lstrcpy(lpPEnha->params, rgszOption[1]);
          break;

       case CONVMEM:
          while ((rgszVal = RgszFromSzListValue(rgszOption[1])) == (RGSZ)NULL) {
              if (!FHandleOOM(hwndFrame)) {
                  EvalAssert(FFreeRgsz(rgszOption));
                  EvalAssert(FFreeRgsz(rgszEnhOptions));
                  return (fFalse);
              }
          }

          if (rgszVal[0] == NULL || rgszVal[1] == NULL) {
            EvalAssert(FFreeRgsz(rgszVal));
            break;
          }

          if (!lstrcmp(rgszVal[0], "-1")) {
             lpPEnha->minmem = 0xFFFF;
          }
          else {
             lpPEnha->minmem = (WORD)atoi(rgszVal[0]);
          }

          if (!lstrcmp(rgszVal[1], "-1")) {
             lpPEnha->maxmem = 0xFFFF;
          }
          else {
             lpPEnha->maxmem = (WORD)atoi(rgszVal[1]);
          }

          EvalAssert(FFreeRgsz(rgszVal));

          break;

       case DISPLAY_USAGE:

          if (!lstrcmpi(rgszOption[1], FULL_SCREEN)) {
             lpPEnha->PfW386Flags |= fFullScrn;
          }
          else if (!lstrcmpi(rgszOption[1], WINDOWED_OPT)) {
             lpPEnha->PfW386Flags &= ~fFullScrn;
          }
          break;

       case EXEC_FLAGS:

          /* Reset bits that this case addresses. */

          lpPEnha->PfW386Flags &= ~(fBackground | fExclusive);

          while ((rgszVal = RgszFromSzListValue(rgszOption[1])) == (RGSZ)NULL) {
              if (!FHandleOOM(hwndFrame)) {
                  EvalAssert(FFreeRgsz(rgszOption));
                  EvalAssert(FFreeRgsz(rgszEnhOptions));
                  return (fFalse);
              }
          }

          i = 0;
          while ((szVal = rgszVal[i++]) != (SZ)NULL) {

             if (!lstrcmpi(szVal, BACKGROUND)) {
                lpPEnha->PfW386Flags |= fBackground;
             }
             else if (!lstrcmpi(szVal, EXCLUSIVE)) {
                lpPEnha->PfW386Flags |= fExclusive;
             }

          }

          EvalAssert(FFreeRgsz(rgszVal));
          break;

       case MULTASK_OPT:

          while ((rgszVal = RgszFromSzListValue(rgszOption[1])) == (RGSZ)NULL) {
              if (!FHandleOOM(hwndFrame)) {
                  EvalAssert(FFreeRgsz(rgszOption));
                  EvalAssert(FFreeRgsz(rgszEnhOptions));
                  return(fFalse);
              }
          }

          if (rgszVal[0] == NULL || rgszVal[1] == NULL) {
            EvalAssert(FFreeRgsz(rgszVal));
            break;
          }


          lpPEnha->PfBPriority = (WORD)atoi(rgszVal[0]);
          lpPEnha->PfFPriority = (WORD)atoi(rgszVal[1]);

          EvalAssert(FFreeRgsz(rgszVal));
          break;

       case EMSMEM:

          while ((rgszVal = RgszFromSzListValue(rgszOption[1])) == (RGSZ)NULL) {
              if (!FHandleOOM(hwndFrame)) {
                  EvalAssert(FFreeRgsz(rgszOption));
                  EvalAssert(FFreeRgsz(rgszEnhOptions));
                  return(fFalse);
              }
          }

          if (rgszVal[0] == NULL || rgszVal[1] == NULL) {
              EvalAssert(FFreeRgsz(rgszVal));
              break;
          }


          lpPEnha->PfMinEMMK = (WORD)atoi(rgszVal[0]);

          if (!lstrcmp(rgszVal[1], "-1")) {
              lpPEnha->PfMaxEMMK = 0xFFFF;
          }
          else {
              lpPEnha->PfMaxEMMK = (WORD)atoi(rgszVal[1]);
          }

          EvalAssert(FFreeRgsz(rgszVal));
          break;

       case XMSMEM:

          while ((rgszVal = RgszFromSzListValue(rgszOption[1])) == (RGSZ)NULL) {
              if (!FHandleOOM(hwndFrame)) {
                  EvalAssert(FFreeRgsz(rgszOption));
                  EvalAssert(FFreeRgsz(rgszEnhOptions));
                  return (fFalse);
              }
          }

          if (rgszVal[0] == NULL || rgszVal[1] == NULL) {
            EvalAssert(FFreeRgsz(rgszVal));
            break;
          }

          lpPEnha->PfMinXmsK = (WORD)atoi(rgszVal[0]);

          if (!lstrcmp(rgszVal[1], "-1")) {
             lpPEnha->PfMaxXmsK = 0xFFFF;
          }
          else {
             lpPEnha->PfMaxXmsK = (WORD)atoi(rgszVal[1]);
          }

          EvalAssert(FFreeRgsz(rgszVal));
          break;

       case PROC_MEM_FLAGS:

          /* Reset bits that this case addresses. */

          lpPEnha->PfW386Flags |= fNoHMA;
          lpPEnha->PfW386Flags &= ~(fPollingDetect | fEMSLocked |
                                    fXMSLocked | fVMLocked);

          while ((rgszVal = RgszFromSzListValue(rgszOption[1])) == (RGSZ)NULL) {
              if (!FHandleOOM(hwndFrame)) {
                  EvalAssert(FFreeRgsz(rgszOption));
                  EvalAssert(FFreeRgsz(rgszEnhOptions));
                  return (fFalse);
              }
          }

          i = 0;
          while ((szVal = rgszVal[i++]) != (SZ)NULL) {

              if (!lstrcmpi(szVal, DETECT_IDLE_TIME)) {
                  lpPEnha->PfW386Flags |= fPollingDetect;
              }

              else if (!lstrcmpi(szVal, EMS_LOCKED)) {
                  lpPEnha->PfW386Flags |= fEMSLocked;
              }

              else if (!lstrcmpi(szVal, XMS_LOCKED)) {
                  lpPEnha->PfW386Flags |= fXMSLocked;
              }

              else if (!lstrcmpi(szVal, USE_HIMEM_AREA)) {
                  lpPEnha->PfW386Flags &= ~fNoHMA;
              }

              else if (!lstrcmpi(szVal, LOCK_APP_MEM)) {
                  lpPEnha->PfW386Flags |= fVMLocked;
              }
          }

          EvalAssert(FFreeRgsz(rgszVal));
          break;

       case DISP_OPT_VIDEO:

          if (!lstrcmpi(rgszOption[1], TEXT_OPT)) {
             lpPEnha->PfW386Flags2 |= fVidTextMd;
             lpPEnha->PfW386Flags2 &= ~(fVidLowRsGrfxMd | fVidHghRsGrfxMd);
          }
          else if (!lstrcmpi(rgszOption[1], LO_RES_GRAPH)) {
             lpPEnha->PfW386Flags2 |= fVidLowRsGrfxMd;
             lpPEnha->PfW386Flags2 &= ~(fVidTextMd | fVidHghRsGrfxMd);
          }
          else if (!lstrcmpi(rgszOption[1], HI_RES_GRAPH)) {
             lpPEnha->PfW386Flags2 |= fVidHghRsGrfxMd;
             lpPEnha->PfW386Flags2 &= ~(fVidLowRsGrfxMd | fVidTextMd);
          }
          break;

       case DISP_OPT_PORTS:
          /* Reset bits that this case addresses. */
          lpPEnha->PfW386Flags2 |= fVidNoTrpTxt | fVidNoTrpLRGrfx |
                                   fVidNoTrpHRGrfx;

          while ((rgszVal = RgszFromSzListValue(rgszOption[1])) == (RGSZ)NULL) {
              if (!FHandleOOM(hwndFrame)) {
                  EvalAssert(FFreeRgsz(rgszOption));
                  EvalAssert(FFreeRgsz(rgszEnhOptions));
                  return(fFalse);
              }
          }

          i = 0;
          while ((szVal = rgszVal[i++]) != (SZ)NULL) {

             if (!lstrcmpi(szVal, TEXT_OPT)) {
                lpPEnha->PfW386Flags2 &= ~fVidNoTrpTxt;
             }

             else if (!lstrcmpi(szVal, LO_RES_GRAPH)) {
                lpPEnha->PfW386Flags2 &= ~fVidNoTrpLRGrfx;
             }

             else if (!lstrcmpi(szVal, HI_RES_GRAPH)) {
                lpPEnha->PfW386Flags2 &= ~fVidNoTrpHRGrfx;
             }
          }

          EvalAssert(FFreeRgsz(rgszVal));
          break;

       case DISP_OPT_FLAGS:
          /* Reset bits that this case addresses. */
          lpPEnha->PfW386Flags2 &= ~(fVidTxtEmulate | fVidRetainAllo);

          while ((rgszVal = RgszFromSzListValue(rgszOption[1])) == (RGSZ)NULL) {
              if (!FHandleOOM(hwndFrame)) {
                  EvalAssert(FFreeRgsz(rgszOption));
                  EvalAssert(FFreeRgsz(rgszEnhOptions));
                  return(fFalse);
              }
          }

          i = 0;
          while ((szVal = rgszVal[i++]) != (SZ)NULL) {

             if (!lstrcmpi(szVal, EMULATE_TEXT_MODE)) {
                lpPEnha->PfW386Flags2 |= fVidTxtEmulate;
             }
             else if (!lstrcmpi(szVal, RETAIN_VIDEO_MEM)) {
                lpPEnha->PfW386Flags2 |= fVidRetainAllo;
             }
          }

          EvalAssert(FFreeRgsz(rgszVal));
          break;

       case OTHER_OPTIONS:
          /* Reset bits that this case addresses. */
          lpPEnha->PfW386Flags &= ~(fINT16Paste | fEnableClose |
                                    fALTTABdis | fALTESCdis |
                                    fCTRLESCdis | fPRTSCdis |
                                    fALTPRTSCdis | fALTSPACEdis |
                                    fALTENTERdis);


          while ((rgszVal = RgszFromSzListValue(rgszOption[1])) == (RGSZ)NULL) {
              if (!FHandleOOM(hwndFrame)) {
                  EvalAssert(FFreeRgsz(rgszOption));
                  EvalAssert(FFreeRgsz(rgszEnhOptions));
                  return (fFalse);
              }
          }

          i = 0;
          while ((szVal = rgszVal[i++]) != (SZ)NULL) {

             if (!lstrcmpi(szVal, ALLOW_FAST_PASTE))
                lpPEnha->PfW386Flags |= fINT16Paste;

             else if (!lstrcmpi(szVal, ALLOW_CLOSE_ACTIVE))
                lpPEnha->PfW386Flags |= fEnableClose;

             else if (!lstrcmpi(szVal, ALT_TAB))
                lpPEnha->PfW386Flags |= fALTTABdis;

             else if (!lstrcmpi(szVal, ALT_ESC))
                lpPEnha->PfW386Flags |= fALTESCdis;

             else if (!lstrcmpi(szVal, CTRL_ESC))
                lpPEnha->PfW386Flags |= fCTRLESCdis;

             else if (!lstrcmpi(szVal, PRSCRN))
                lpPEnha->PfW386Flags |= fPRTSCdis;

             else if (!lstrcmpi(szVal, ALT_PRSCRN))
                lpPEnha->PfW386Flags |= fALTPRTSCdis;

             else if (!lstrcmpi(szVal, ALT_SPACE))
                lpPEnha->PfW386Flags |= fALTSPACEdis;

             else if (!lstrcmpi(szVal, ALT_ENTER))
                lpPEnha->PfW386Flags |= fALTENTERdis;
          }
          EvalAssert(FFreeRgsz(rgszVal));
          break;

       default:
          break;
       }
       EvalAssert(FFreeRgsz(rgszOption));
   }
   EvalAssert(FFreeRgsz(rgszEnhOptions));

   if (bNoTrpHRGrfx) {
      lpPEnha->PfW386Flags2 |= fVidNoTrpHRGrfx;
   }

   return (fTrue);
}

/***************************************************************************

GetExtOption
------------

DESCRIPTION:

   This procedure will return an ID which defines the string switch
   from the APPS.INF line which was passed in.


HISTORY:

   Modified by:      Date:       Comment:

   PAK               11/2/90     Created

***************************************************************************/
INT
GetExtOption(
    LPSTR lpsz
    )
{
   if (!lstrcmpi(lpsz, "params")) {
      return PARAMS;
   }
   else if (!lstrcmpi(lpsz, "minconvmem")) {
      return MINCONVMEM;
   }
   else if (!lstrcmpi(lpsz, "videomode")) {
      return VIDEOMODE;
   }
   else if (!lstrcmpi(lpsz, "xmsmem")) {
      return XMSMEM;
   }
   else if (!lstrcmpi(lpsz, "checkboxes")) {
      return CHECKBOXES;
   }
   else if (!lstrcmpi(lpsz, "emsmem")) {
      return EMSMEM;
   }
   else if (!lstrcmpi(lpsz, "convmem")) {
      return CONVMEM;
   }
   else if (!lstrcmpi(lpsz, "dispusage")) {
      return DISPLAY_USAGE;
   }
   else if (!lstrcmpi(lpsz, "execflags")) {
      return EXEC_FLAGS;
   }
   else if (!lstrcmpi(lpsz, "multaskopt")) {
      return MULTASK_OPT;
   }
   else if (!lstrcmpi(lpsz, "procmemflags")) {
      return PROC_MEM_FLAGS;
   }
   else if (!lstrcmpi(lpsz, "dispoptvideo")) {
      return DISP_OPT_VIDEO;
   }
   else if (!lstrcmpi(lpsz, "dispoptports")) {
      return DISP_OPT_PORTS;
   }
   else if (!lstrcmpi(lpsz, "dispflags")) {
      return DISP_OPT_FLAGS;
   }
   else if (!lstrcmpi(lpsz, "otheroptions")) {
      return OTHER_OPTIONS;
   }
   else {
      return UNKNOWN_OPTION;
   }
}


/***************************************************************************

FInitializePIFStructs
--------------------

DESCRIPTION:

   This procedure will allocate and initialize all PIF structures required
   to set up DOS applications.

HISTORY:

   Modified by:      Date:       Comment:

   PAK               8/18/91     Created
   SUNILP            2/04/92     Modified to fit into Win32 GUI Setup

***************************************************************************/
BOOL
FInitializePIFStructs(
    BOOL bIsEnhanced,
    SZ   szDfltStdOpt,
    SZ   szDfltEnhOpt
    )
{
   HDC   hdc;
   BOOL  bStatus;

   /* Initialize for enhanced/standard mode pifs */

   bIs386 = bIsEnhanced;

   /* Allcate a BIG block to contain all necessary PIF structures. This
      block will be freed during ExitProcessing
   */

   cbAllPIF = bIs386 ? sizeof(PIF386Combined) : sizeof(PIF286Combined);

   while ((lpAllPIF = SAlloc(cbAllPIF)) == NULL) {
       if (!FHandleOOM(hwndFrame)) {
           DestroyWindow(GetParent(hwndFrame));
           return(fFalse);
           }
   }
   memset( lpAllPIF, 0, cbAllPIF );


   if (bIs386) {
        lpDfltPIF     =  &(((LPPIF386Combined)lpAllPIF)->DfltPIF   );
        lpDfltStd     =  &(((LPPIF386Combined)lpAllPIF)->DfltStd   );
        lpDfltEnha    =  &(((LPPIF386Combined)lpAllPIF)->DfltEnha  );
        lpCurrPIF     =  &(((LPPIF386Combined)lpAllPIF)->CurrPIF   );
        lpStdExtHdr   =  &(((LPPIF386Combined)lpAllPIF)->StdExtHdr );
        lpCurrStd     =  &(((LPPIF386Combined)lpAllPIF)->CurrStd   );
        lpEnhaExtHdr  =  &(((LPPIF386Combined)lpAllPIF)->EnhaExtHdr);
        lpCurrEnha    =  &(((LPPIF386Combined)lpAllPIF)->CurrEnha  );
   }
   else {
        lpDfltPIF     =  &(((LPPIF286Combined)lpAllPIF)->DfltPIF   );
        lpDfltStd     =  &(((LPPIF286Combined)lpAllPIF)->DfltStd   );
        lpCurrPIF     =  &(((LPPIF286Combined)lpAllPIF)->CurrPIF   );
        lpStdExtHdr   =  &(((LPPIF286Combined)lpAllPIF)->StdExtHdr );
        lpCurrStd     =  &(((LPPIF286Combined)lpAllPIF)->CurrStd   );
   }


   /* Intialize PIF structure headers, these will be used by all created
      PIFs. */

   lstrcpy(lpDfltPIF->stdpifext.extsig, STDHDRSIG);
   lpDfltPIF->stdpifext.extfileoffset = 0;
   lpDfltPIF->stdpifext.extsizebytes = sizeof(PACKED_PIFNEWSTRUCT) -
                                       sizeof(PIFEXTHEADER);
   lpDfltPIF->stdpifext.extnxthdrfloff = sizeof(PACKED_PIFNEWSTRUCT);

   lstrcpy(lpStdExtHdr->extsig, W286HDRSIG30);
   lpStdExtHdr->extfileoffset = sizeof(PACKED_PIFNEWSTRUCT) + sizeof(PIFEXTHEADER);
   lpStdExtHdr->extsizebytes = sizeof(PIF286EXT30);

   if (!bIs386) {
      lpStdExtHdr->extnxthdrfloff = LASTHEADERPTR;
   }
   else {
      lpStdExtHdr->extnxthdrfloff = sizeof(PACKED_PIFNEWSTRUCT) +
                                    sizeof(PIFEXTHEADER) +
                                    sizeof(PIF286EXT30);

      lpEnhaExtHdr->extfileoffset  = sizeof(PACKED_PIFNEWSTRUCT) +
                                     sizeof(PIFEXTHEADER) +
                                     sizeof(PIF286EXT30)  +
                                     sizeof(PIFEXTHEADER);

      lstrcpy(lpEnhaExtHdr->extsig, W386HDRSIG);
      lpEnhaExtHdr->extsizebytes = sizeof(PIF386EXT);
      lpEnhaExtHdr->extnxthdrfloff = LASTHEADERPTR;
   }

   /* Initialize values that will never change and are probably obsolete.
      These values cannot be changed by the PIF editor, but probably have
      some historical significance. */

   lpDfltPIF->maxmem = 640;
   lpDfltPIF->screen = 0x7f;
   lpDfltPIF->cPages = 1;
   lpDfltPIF->highVector = 0xff;
   lpDfltPIF->rows = 25;
   lpDfltPIF->cols = 80;


   /* Set default standard and enhanced mode PIF settings from the
      appropriate default sections contained in APPS.INF. */

   bStatus = FProcessStdModeInfo(szDfltStdOpt, lpDfltPIF, lpDfltStd);
   if (!bStatus) {
       return (fFalse);
   }

   if (bIs386) {
      bStatus = FProcessEnhaModeInfo(szDfltEnhOpt, lpDfltEnha);
      if (!bStatus) {
          return (fFalse);
      }
   }

   /* Special case hack for VGA & 8514:

      - Always disable hires graphics trapping

      This is code from 3.0. This code means that if APPS.INF contains an
      entry that enables Hires graphics trapping, this portion of code
      will set a flag that will cause it to be disabled if a VGA or 8514
      are present.
   */

   hdc = GetDC(NULL);
   if ( GetDeviceCaps(hdc,VERTRES) == 350 ) {
      bNoTrpHRGrfx = fFalse;
   }

   ReleaseDC(NULL,hdc);
   return (fTrue);
}

/***************************************************************************

FreePIFstructs
--------------

DESCRIPTION:

   This procedure will allocate and initialize all PIF structures required
   to set up DOS applications.

HISTORY:

   Modified by:      Date:       Comment:

   PAK               8/18/91     Created
   SUNILP            2/04/92     Modified to fit into Win32 GUI Setup

***************************************************************************/
VOID
FreePIFStructs(
    VOID
    )
{
   if (lpAllPIF) {

      SFree(lpAllPIF);
      //
      // Reset all the pointers to this global memory to NULL
      //
      cbAllPIF     = 0;
      lpAllPIF     = NULL;
      lpDfltPIF    = NULL;
      lpCurrPIF    = NULL;
      lpStdExtHdr  = NULL;
      lpDfltStd    = NULL;
      lpCurrStd    = NULL;
      lpEnhaExtHdr = NULL;
      lpDfltEnha   = NULL;
      lpCurrEnha   = NULL;
   }

   return;

}

/***************************************************************************

ExtractStrFromPIF
-----------------

DESCRIPTION:

   This procedure will remove trailing spaces from a descritpion string.
   It is needed because PIFs created with the PIF editor have their
   description string padded with spaces (' ').

HISTORY:

   Modified by:      Date:       Comment:

   PAK               8/6/91      Created
   SUNILP            2/4/92      Modified to remove DBCS.

***************************************************************************/
VOID
ExtractStrFromPIF(
    LPSTR lpsz,
    int n
    )
{
   int   i = 0;
   int   iSpace = 0;
   BOOL  bSpaceFound = fFalse;

   while ((i < n) && (lpsz[i] != '\0')) {
      if (lpsz[i] == ' ') {
         if (!bSpaceFound) {
            bSpaceFound = fTrue;
            iSpace = i;
         }
      }
      else {
         bSpaceFound = fFalse;
      }

      i++;
   }

   if (bSpaceFound) {
      lpsz[iSpace] = '\0';
   }
   else {
      lpsz[i] = '\0';
   }

   return;
}

/***************************************************************************

FInstallDOSPifs
---------------

   This is the main install routine which handles dos app installation.
   The routine:

   1. Initialises PIF Structs with the defaults given

   2. Processes a DOS App list trying to create PIF For the app and adding
      an item to the progman group for the app.

   3. Creating some base pifs. (NOT IMPLEMENTED)

   4. Cleaning up after everything is done.


ENTRY:

   1.  szAppList:          This is a list of all the app entries to be set up.
   2.  szWinMode:          ENHANCED | STANDARD
   3.  szDefltStdValues:   The defaults for standard mode options
   4.  szDefltEnhValues:   The defaults for enhanced mode options
   5.  szPifDir:           The directory for creating PIFs (e.g. d:\nt\)
   6.  szGroup:            The progman group which is to receive all the
                           DOS App items.

EXIT: BOOL: fTrue if successful

HISTORY:

   Modified by:      Date:       Comment:

   SUNILP            2/5/92      Created.

***************************************************************************/
BOOL APIENTRY
FInstallDOSPifs(
    SZ szAppList,
    SZ szWinMode,
    SZ szDefltStdValues,
    SZ szDefltEnhValues,
    SZ szPifDir,
    SZ szGroup
    )
{

   ADDAPP_STATUS rc;

   BOOL  bIsEnhanced, bStatus;
   RGSZ  rgszGroupList, rgszAppList, rgszApp;
   PSZ   pszAppList;
   SZ    szApp;
   INT   nGroupFromList = 0;

   //
   // Since the "Applications" group may be full the szGroup is actually
   // a list of possible group names including "Applications".  We should
   // try alternate group names in case the current one fails.
   //

   while ((rgszGroupList = RgszFromSzListValue(szGroup)) == (RGSZ)NULL) {
       if (!FHandleOOM(hwndFrame)) {
           return(fFalse);
       }
   }

   Assert (rgszGroupList[nGroupFromList] != NULL);

   // See Windows Mode we are operating in
   //

   bIsEnhanced = !lstrcmpi((LPSTR)szWinMode, (LPSTR)MODE_ENHANCED);

   bStatus = FInitializePIFStructs(
                 bIsEnhanced,
                 szDefltStdValues,
                 szDefltEnhValues
                 );

   if (!bStatus) {
       EvalAssert(FFreeRgsz(rgszGroupList));
       FreePIFStructs();
       return fFalse;
   }


   //
   // Process App List.
   //

   while ((pszAppList = rgszAppList = RgszFromSzListValue(szAppList)) == (RGSZ)NULL) {
       if (!FHandleOOM(hwndFrame)) {
           EvalAssert(FFreeRgsz(rgszGroupList));
           FreePIFStructs();
           return(fFalse);
       }
   }

   while ((szApp = *pszAppList++) != (SZ)NULL) {
       while ((rgszApp = RgszFromSzListValue(szApp)) == (RGSZ)NULL) {
           if (!FHandleOOM(hwndFrame)) {
               EvalAssert(FFreeRgsz(rgszGroupList));
               EvalAssert(FFreeRgsz(rgszAppList));
               FreePIFStructs();
               return(fFalse);
           }
       }

       //
       // Check the app type, whether it is a win16/win32 or dos app
       //

       if ( (CrcStringCompareI(rgszApp[nEXETYPE], EXE_WIN16_SZ) == crcEqual) ||
            (CrcStringCompareI(rgszApp[nEXETYPE], EXE_WIN32_SZ) == crcEqual)
          ) {
           while ((rc = AddWinItem(
                            rgszApp,
                            rgszGroupList[nGroupFromList]
                            )) != ADDAPP_SUCCESS) {
              if ( rc == ADDAPP_GRPFAIL &&
                   rgszGroupList[++nGroupFromList] != NULL
                 ) {
              }
              else {
                   bStatus = fFalse;
                   break;
              }
           }
       }
       else if (CrcStringCompareI(rgszApp[nEXETYPE], EXE_DOS_SZ) == crcEqual) {
           while ((rc = AddDosAppItem(
                            rgszApp,
                            szPifDir,
                            rgszGroupList[nGroupFromList]
                            )) != ADDAPP_SUCCESS) {

              if ( rc == ADDAPP_GRPFAIL &&
                   rgszGroupList[++nGroupFromList] != NULL
                 ) {
              }
              else {
                   bStatus = fFalse;
                   break;
              }
           }

       }

       EvalAssert(FFreeRgsz(rgszApp));

       if (!bStatus) {
           break;
       }
   }

   //
   // Minimize application groups, just in case one of them
   // has overlaid a main group.
   //
   if(bStatus) {

      INT  i;
      CHAR min[10];

      wsprintf(min,"%u",SW_MINIMIZE);

      for(i=0; i<=nGroupFromList; i++) {

         FShowProgManGroup(
            rgszGroupList[i],
            min,
            cmoNone,
            TRUE
            );
      }
   }

   //
   // Clean Up
   //

   EvalAssert(FFreeRgsz(rgszGroupList));
   EvalAssert(FFreeRgsz(rgszAppList));

   FreePIFStructs();


   return(bStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\eisa.c ===
#include "precomp.h"
#pragma hdrstop

extern CHAR ReturnTextBuffer[1024];

/*

GetEisaSlotInformation - Get EISA information.
    The user must passed 3 arguments to the function.
    1st argument - bus number
    2nd argument - registry field name, i.e. "Configuration Data"
    3rd argument - Compressed ID.
    4th argument - Compressed ID Mask. (optional)

    The function will look through the bus's configuration data value
    and return a list of slot number which contains the hardware with the
    same compressed ID.
*/

BOOL
GetEisaSlotInformation(
    IN DWORD cArgs,
    IN LPSTR Args[],
    OUT LPSTR *TextOut
    )

{
    PCM_FULL_RESOURCE_DESCRIPTOR pFullResourceDescriptor;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pPartialDescriptor;

    ULONG ulID;
    DWORD dwMask = 0xffffff;
    BOOL fFirst = TRUE;
    CHAR szNum[10];

    BOOL    fOkay;
    HKEY    hKey;
    DWORD   cbData;
    DWORD   ValueType;
    PVOID   ValueData;
    LONG    Status;

    char        szKClass[ MAX_PATH ];
    DWORD       cbKClass;
    DWORD       KSubKeys;
    DWORD       cbKMaxSubKeyLen;
    DWORD       cbKMaxClassLen;
    DWORD       KValues;
    DWORD       cbKMaxValueNameLen;
    DWORD       SizeSecurityDescriptor;
    FILETIME    KLastWriteTime;

    USHORT Count = 0;
    UCHAR Function, Slot = 0;
    PCM_EISA_SLOT_INFORMATION SlotInformation;
    ULONG DataLength;
    PUCHAR DataPointer,EndingAddress, BinaryPointer = NULL;

	 /*
	 *  Make sure we have 4 variables
	 */
    if ( cArgs < 3 )
    {
        SetErrorText(IDS_ERROR_BADARGS);
        return( FALSE );
    }

    ulID = atol( Args[2] );
    if ( cArgs > 3 )
    {
        dwMask = atol( Args[3] );
    }

    lstrcpy( ReturnTextBuffer, "{" );

    hKey = (HKEY)LongToHandle(atol( &(Args[0][1]) ));

    cbKClass = MAX_PATH;

	 /*
	 ** Get the registry handle information
	 */
	
    fOkay = !( Status = RegQueryInfoKey ( hKey,
                                          szKClass,
                                          &cbKClass,
                                          NULL,
                                          &KSubKeys,
                                          &cbKMaxSubKeyLen,
                                          &cbKMaxClassLen,
                                          &KValues,
                                          &cbKMaxValueNameLen,
                                          &cbData,
                                          &SizeSecurityDescriptor,
                                          &KLastWriteTime ) );

    if ( !fOkay ) {
        lstrcat( ReturnTextBuffer, "}" );
        *TextOut = ReturnTextBuffer;
        OutputDebugString("RegQueryInfoKey error.\n\r");
        return(FALSE);

    } else {

        //
        //  Allocate the buffer and get the data
        //
        //  add some space for the margin

        while ( (ValueData = (PVOID)SAlloc( (CB)( cbData+10 ))) == NULL ) {
				lstrcat( ReturnTextBuffer, "}" );
				*TextOut = ReturnTextBuffer;
				OutputDebugString("Malloc error.\n\r");
			return(FALSE);
        }

        if ( fOkay ) {

            fOkay = !( Status = RegQueryValueEx( hKey,
                                                 Args[1],
                                                 NULL,
                                                 &ValueType,
                                                 ValueData,
                                                 &cbData ) );
            if ( !fOkay ) {
					SFree( ValueData );
               lstrcat( ReturnTextBuffer, "}" );
               *TextOut = ReturnTextBuffer;
               OutputDebugString("RegQueryValueEx error.\n\r");
               return(FALSE);

            }
			}

    }

    pFullResourceDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR) ValueData;
    if ( pFullResourceDescriptor->PartialResourceList.Count != 0 )
    {
        pPartialDescriptor = ( PCM_PARTIAL_RESOURCE_DESCRIPTOR ) &pFullResourceDescriptor->PartialResourceList.PartialDescriptors;

        DataPointer = (PUCHAR)pPartialDescriptor + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
        DataLength = pPartialDescriptor->u.DeviceSpecificData.DataSize;

        if ( DataLength != 0 )
        {

	     /*
             ** Go through the data one by one to find the compressed ID
	     */
	
            EndingAddress = DataPointer + DataLength;
            SlotInformation = (PCM_EISA_SLOT_INFORMATION)DataPointer;
            while ((ULONG_PTR)BinaryPointer < (ULONG_PTR)EndingAddress) {
                if (SlotInformation->ReturnCode != EISA_EMPTY_SLOT) {
                    BinaryPointer = (PUCHAR)SlotInformation;
	
                    if (( SlotInformation->CompressedId & dwMask ) == ulID ) {
                        if (!fFirst) {
                            lstrcat( ReturnTextBuffer,"," );
                        }
                        fFirst = FALSE;
                        wsprintf( szNum, "\"%d\"", Slot );
                        lstrcat( ReturnTextBuffer, szNum );
                        OutputDebugString(ReturnTextBuffer);
                    }
                    BinaryPointer += sizeof(CM_EISA_SLOT_INFORMATION);
                    Function = 0;
                    while (SlotInformation->NumberFunctions > Function) {
                        BinaryPointer += sizeof(CM_EISA_FUNCTION_INFORMATION);
                        Function++;
                    }
                } else {
                    BinaryPointer += sizeof(CM_EISA_SLOT_INFORMATION);
                }
                Slot++;
                SlotInformation = (PCM_EISA_SLOT_INFORMATION)BinaryPointer;
            }
        }
    }
    lstrcat( ReturnTextBuffer, "}" );
    *TextOut = ReturnTextBuffer;
    SFree( ValueData );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\event.c ===
#include "precomp.h"
#pragma hdrstop
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    event.c

Abstract:

    Routines related to event manipulation.

Author:

    Sunil Pai (sunilp) 26-May-1992

Revision History:

--*/

extern BOOL FYield(VOID);

#define EVENT_SIGNALLED "EventSignalled"
#define EVENT_NOT_FOUND "EventNotFound"
#define EVENT_SET       "EventSet"
#define EVENT_NOT_SET   "EventNotSet"
#define EVENT_TIMEOUT   "EventTimeout"
#define EVENT_FAILED    "EventFailed"
#define EVENT_NO_FAIL   "EventNoFailEvent"

#define EVENT_NAME_SETUP_FAILED "\\SETUP_FAILED"


HANDLE
FOpenOrCreateEvent(
    IN LPSTR EventNameAscii,
    BOOL bCreateAllowed
    )
/*
    Open or create an event; return a handle to the event.
 */
{
    HANDLE            EventHandle;
    OBJECT_ATTRIBUTES EventAttributes;
    UNICODE_STRING    EventName;
    NTSTATUS          NtStatus;
    ANSI_STRING       EventName_A;

    RtlInitAnsiString( & EventName_A, EventNameAscii );
    NtStatus = RtlAnsiStringToUnicodeString(
                   &EventName,
                   &EventName_A,
                   TRUE
                   );

    if ( ! NT_SUCCESS(NtStatus) )
        return NULL ;

    InitializeObjectAttributes( & EventAttributes, & EventName, 0, 0, NULL );

    //  First try to open the event; if failure, create it.

    NtStatus = NtOpenEvent(
                   &EventHandle,
                   SYNCHRONIZE | EVENT_MODIFY_STATE,
                   &EventAttributes
                   );

    if ( (! NT_SUCCESS( NtStatus )) && bCreateAllowed )
    {
        NtStatus = NtCreateEvent(
                       &EventHandle,
                       SYNCHRONIZE | EVENT_MODIFY_STATE,
                       &EventAttributes,
                       NotificationEvent,
                       FALSE                // The event is initially not signaled
                       );
    }

    RtlFreeUnicodeString( & EventName );

    return NT_SUCCESS( NtStatus )
         ? EventHandle
         : NULL ;
}

//
// Number of milliseconds we will wait before yielding.
//
// The value below is 10 ms expressed as a relative NT time.
//
#define TIME_SLICE  (-100000)

VOID
WaitForEventOrFailure(
    IN LPSTR EventName,
    IN BOOL  WaitForFailureAlso,
    IN DWORD Timeout,
    IN LPSTR InfVar
    )
{
    SZ                EventStatus;
    HANDLE            EventHandles[2];
    TIME              timeSlice;
    LARGE_INTEGER     timeRemaining;
    NTSTATUS          NtStatus;

    //
    // Create a local variable containing the timeslice value
    // (ie, max wait time before a yield and rewait).
    //
    timeSlice.QuadPart = (LONGLONG)TIME_SLICE;

    if(EventHandles[0] = FOpenOrCreateEvent(EventName,FALSE)) {

        if(!WaitForFailureAlso || (EventHandles[1] = FOpenOrCreateEvent(EVENT_NAME_SETUP_FAILED,TRUE))) {

            //
            // If the timeout passed by the caller is 0, then we want to keep waiting
            // until one of the events becomes signalled.
            //
            // The multiplication of the caller's supplied Timeout value by -10000
            // converts milliseconds to a relative NT time.
            //
            for(timeRemaining.QuadPart = Int32x32To64(Timeout,-10000);
                !Timeout || (timeRemaining.QuadPart < 0);
                timeRemaining.QuadPart -= timeSlice.QuadPart)
            {
                NtStatus = NtWaitForMultipleObjects(
                                WaitForFailureAlso ? 2 : 1,
                                EventHandles,
                                WaitAny,
                                TRUE,
                                &timeSlice
                                );

                if(NtStatus != STATUS_TIMEOUT) {
                    break;
                }

                FYield();
            }

            switch(NtStatus) {

            case STATUS_TIMEOUT:
                EventStatus = EVENT_TIMEOUT;
                break;

            case STATUS_WAIT_0:
                EventStatus = EVENT_SET;
                break;

            case STATUS_WAIT_1:
            default:
                EventStatus = EVENT_FAILED;
                break;
            }

            if(WaitForFailureAlso) {
                NtClose(EventHandles[1]);
            }

        } else {
            EventStatus = EVENT_NO_FAIL;
        }

        NtClose(EventHandles[0]);

    } else {
        EventStatus = EVENT_NOT_FOUND;
    }

    FAddSymbolValueToSymTab(InfVar,EventStatus);
}


BOOL
FWaitForEventOrFailure(
    IN LPSTR InfVar,
    IN LPSTR Event,
    IN DWORD Timeout
    )
{
    WaitForEventOrFailure(Event,TRUE,Timeout,InfVar);

    return TRUE;
}


BOOL
FWaitForEvent(
    IN LPSTR InfVar,
    IN LPSTR Event,
    IN DWORD Timeout
    )
{
    WaitForEventOrFailure(Event,FALSE,Timeout,InfVar);

    return TRUE;
}


//  Never allow a "Sleep" command of greater than a minute.

#define SLEEP_MS_MAXIMUM   (60000)
#define SLEEP_MS_INTERVAL  (10)

BOOL FSleep(
    DWORD dwMilliseconds
    )
{
    DWORD dwCycles;

    if(dwMilliseconds > SLEEP_MS_MAXIMUM) {
        dwMilliseconds = SLEEP_MS_MAXIMUM;
    }

    for(dwCycles = dwMilliseconds/SLEEP_MS_INTERVAL; dwCycles--; ) {
        Sleep(SLEEP_MS_INTERVAL);
        FYield();
    }

    return TRUE;
}

BOOL
FSignalEvent(
    IN LPSTR InfVar,
    IN LPSTR Event
    )
{
    SZ                EventStatus = EVENT_SIGNALLED;
    HANDLE            EventHandle;

    //
    // Open the event
    //
    EventHandle  = FOpenOrCreateEvent( Event, FALSE ) ;
    if (  EventHandle == NULL )
    {
        EventStatus = EVENT_NOT_FOUND;
    }
    else
    {
        if ( ! NT_SUCCESS( NtSetEvent( EventHandle, NULL ) ) )
            EventStatus = EVENT_NOT_SET ;

        NtClose( EventHandle );
    }

    FAddSymbolValueToSymTab(InfVar, EventStatus);
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\dualproc.c ===
#include "precomp.h"
#pragma hdrstop
/***************************************************************************/
/****************** Basic Class Dialog Handlers ****************************/
/***************************************************************************/


BOOL fFillListBoxFromSzList (HWND, WORD, SZ);
BOOL fFreeListBoxEntries (HWND, WORD);
BOOL fUpdateStatus(HWND, WORD, INT);
SZ   szGetSzListFromListBox (HWND, WORD);
/*
** Author:
**    Sunil Pai, 8/21/91, Adapted from Win3.1 setup code.
**
**  Purpose:
**      Dual Listbox Dialog procedure for templates with two listboxes
**    exchanging selection items.  This is implemented with owner draw
**    list boxes.
**
**  Control IDs:
**      The Listbox controls must have the id IDC_LIST1 and IDC_LIST2.
**    Pushbuttons recognized are IDC_O, IDC_C, IDC_M, IDC_H, IDC_X, and IDC_B.
**    In addition to these the following IDs are processed:
**    - IDC_A: To move a selected item(s) in listbox1 to listbox2
**    - IDC_R: To move a selected item(s) in listbox2 to listbox1
**    - IDC_S: To move all items in listbox1 to listbox2
**
**  Initialization:
**      The symbol $(ListItemsIn) is a list of strings to insert into the
**      listbox 1.  The symbol $(ListItemOut) is a list of strings to insert
**    into listbox 2.  Items can be added to listbox2 or removed to
**    listbox1.  All items can be shifted to listbox2 using the Add All
**    button.
**
**    The $(ListItemsIn) and $(ListItemsOut can be:
**
**    a) A Simple List:
**    {$(ListElem1), $(ListElem2)...}
**
**    b) A Compound List:
**
**    { {$(ListItem1Data), $(ListItem1Aux1), $(ListItem1Aux2)...},
**      {$(ListItem2Data), $(ListItem2Aux1), $(ListItem2Aux2)...},
**      ...
**    }
**
**    In the case of a compound list the $(ListItemnData) field is displayed
**    in the listbox.  When any item is selected the selection displays the
**    fields in the selection in the status fields in the dialog.
**    - ListItemnData is displayed in the IDC_TEXT1 field if present
**    - ListItemnAux1 is displayed in the IDC_TEXT2 field if present
**    - ListItemnAux2 is displayed in the IDC_TEXT3 field if present
**    ...
**
**  Termination:
**      The items in listbox2 are returned in
**      $(ListItemsOut).  The id of the Pushbutton (eg IDC_C) which caused
**      termination is converted to a string and stored in the symbol
**
*****************************************************************************/
INT_PTR APIENTRY FGstDualDlgProc(HWND hdlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
   CHP    rgchNum[10];
   SZ     szList;
   INT    i, nCount;
   WORD   idc, idcSrc, idcDst;
   LONG   lItem;
   RGSZ   rgszItem;
   PSZ    pszItem;


    switch (wMsg)
        {
    case WM_INITDIALOG:
        AssertDataSeg();

        if( wMsg == WM_INITDIALOG ) {
            FCenterDialogOnDesktop(hdlg);
        }

        // Find the List Items In and initialise the first list box

        if ((szList = SzFindSymbolValueInSymTab("ListItemsIn")) == (SZ)NULL)
           {
           Assert(fFalse);
           return(fTrue);
           }
        if(!fFillListBoxFromSzList (hdlg, IDC_LIST1, szList))
           {
           EvalAssert(fFreeListBoxEntries (hdlg, IDC_LIST1));
           Assert(fFalse);
           return(fTrue);
           }


        // Find the List Items Out and initialise the second list box

        if ((szList = SzFindSymbolValueInSymTab("ListItemsOut")) == (SZ)NULL)
           {
           Assert(fFalse);
           return(fTrue);
           }
        if(!fFillListBoxFromSzList (hdlg, IDC_LIST2, szList))
           {
           EvalAssert(fFreeListBoxEntries (hdlg, IDC_LIST1));
           EvalAssert(fFreeListBoxEntries (hdlg, IDC_LIST2));
           Assert(fFalse);
           return(fTrue);
           }

        // The following are done in the windows code, but I believe some of
        // them restrict us when we are building a general procedure like this

        // Initialise state of controls in the dialog

//      SendMessage(GetDlgItem(hdlg, IDC_LIST1), LB_SETCURSEL, 0, 0L);
//      EvalAssert(fUpdateStatus(hdlg, IDC_LIST1, 0));



//      EnableWindow(GetDlgItem(hdlg,IDC_C), fFalse);
      EnableWindow(GetDlgItem(hdlg,IDC_A), fFalse);
      EnableWindow(GetDlgItem(hdlg,IDC_R), fFalse);

//      SetFocus(GetDlgItem(hdlg, IDC_S));
//      SendMessage(hdlg, DM_SETDEFID, IDC_S, 0L);

      //
      // Return
      //

      return(fTrue);

    case STF_REINITDIALOG:
        return(fTrue);

//    case STF_DLG_ACTIVATE:
//    case WM_MOUSEACTIVATE:
//        if (FActiveStackTop())
//            break;
//        EvalAssert(FInactivateHelp());
//        SetWindowPos(hdlg, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
//        /* fall through */
//    case STF_UILIB_ACTIVATE:
//        EvalAssert(FActivateStackTop());
//        return(fTrue);

    case WM_CLOSE:
        PostMessage(
            hdlg,
            WM_COMMAND,
            MAKELONG(IDC_X, BN_CLICKED),
            0L
            );
        return(fTrue);

    case WM_COMMAND:
        switch(idc = LOWORD(wParam))
            {
         case IDC_LIST1:
         case IDC_LIST2:
            nCount = (INT)SendDlgItemMessage(hdlg, idc, LB_GETSELCOUNT, 0, 0L);

            EnableWindow(GetDlgItem(hdlg, (idc == IDC_LIST1) ? IDC_A : IDC_R),
                         nCount ? fTrue : fFalse
                        );

            switch (HIWORD(wParam))
            {
               case LBN_SELCHANGE:
                  i = (INT)SendDlgItemMessage(hdlg, idc, LB_GETCURSEL, 0, 0L);
                  if (i >= 0)
                     EvalAssert(fUpdateStatus(hdlg, idc, i));
                  break;

               default:
                  return fFalse;
            }
            break;

         case IDC_A:
         case IDC_R:
         {
            #define MAXSEL 500       // if memory allocation fails
            PINT sel,sels;
            INT lowmemsels[MAXSEL];

            if (idc == IDC_A)
               {
               idcSrc = IDC_LIST1;
               idcDst = IDC_LIST2;
               }
            else
               {
               idcSrc = IDC_LIST2;
               idcDst = IDC_LIST1;
               }

            nCount = (INT)SendDlgItemMessage(hdlg,idcSrc,LB_GETSELCOUNT,0,0);
            if(nCount <= 0) {
                break;
            }

            if(sels = SAlloc(nCount*sizeof(INT))) {
                sel = sels;
            } else {
                sel = lowmemsels;
                nCount = MAXSEL;
            }

            nCount = (INT)SendDlgItemMessage(hdlg,
                                             idcSrc,
                                             LB_GETSELITEMS,
                                             nCount,
                                             (LPARAM)sel
                                             );

            if(nCount <= 0) {
                if(sels) {
                    SFree(sels);
                    sels = NULL;
                }
                break;
            }

            // dup everything over to the other list

            SendDlgItemMessage(hdlg, idcSrc, WM_SETREDRAW, fFalse, 0L);
            SendDlgItemMessage(hdlg, idcDst, WM_SETREDRAW, fFalse, 0L);

            for (i = 0; i < nCount; i++)
            {
               SendDlgItemMessage(hdlg, idcSrc, LB_GETTEXT, sel[i],
                                                      (LPARAM)&lItem);
               SendDlgItemMessage(hdlg, idcDst, LB_ADDSTRING, 0,
                                                      (LPARAM)lItem);
            }

            SendDlgItemMessage(hdlg, idcDst, WM_SETREDRAW, fTrue, 0L);
            InvalidateRect(GetDlgItem(hdlg, idcDst), NULL, fTrue);

            // and delete the source stuff (backwards to get order right)

            for (i = nCount - 1; i >= 0; i--)
               SendDlgItemMessage(hdlg, idcSrc, LB_DELETESTRING,
                                                              sel[i], 0L);
            SendDlgItemMessage(hdlg, idcSrc, WM_SETREDRAW, fTrue, 0L);
            InvalidateRect(GetDlgItem(hdlg, idcSrc), NULL, fTrue);

            if (idc == IDC_A)
            {
               if ((INT)SendDlgItemMessage(hdlg, IDC_LIST1,
                                        LB_GETCOUNT, 0, 0L) <= 0)
               {
                  EnableWindow(GetDlgItem(hdlg,IDC_S),fFalse);
               }
               else
                  EnableWindow(GetDlgItem(hdlg,IDC_S),fTrue);
            }
            else
               EnableWindow(GetDlgItem(hdlg,IDC_S),fTrue);

            if ((INT)SendDlgItemMessage(hdlg, IDC_LIST2,
                                        LB_GETCOUNT, 0, 0L) <= 0)
            {
               EnableWindow(GetDlgItem(hdlg,IDC_C),fFalse);
               SetFocus(GetDlgItem(hdlg, IDC_S));
               SendMessage(hdlg, DM_SETDEFID, IDC_S, 0L);
            }
            else
            {
               EnableWindow(GetDlgItem(hdlg,IDC_C),fTrue);
               SetFocus(GetDlgItem(hdlg, IDC_C));
               SendMessage(hdlg, DM_SETDEFID, IDC_C, 0L);
            }

            EnableWindow(GetDlgItem(hdlg,idc),fFalse);

            if(sels) {
                SFree(sels);
                sels = NULL;
            }

            return fFalse;
         }

         case IDC_S:
            nCount = (INT)SendDlgItemMessage(hdlg, IDC_LIST1, LB_GETCOUNT, 0, 0L);

            SendDlgItemMessage(hdlg, IDC_LIST2, WM_SETREDRAW, fFalse, 0L);

            for (i = 0; i < nCount; i++)
               {
               SendDlgItemMessage(hdlg, IDC_LIST1, LB_GETTEXT, i,
                                                      (LPARAM)&lItem);
               SendDlgItemMessage(hdlg, IDC_LIST2, LB_ADDSTRING, 0,
                                                      (LPARAM)lItem);
               }

            SendDlgItemMessage(hdlg, IDC_LIST1, LB_RESETCONTENT, 0, 0L);
            SendDlgItemMessage(hdlg, IDC_LIST2, WM_SETREDRAW, fTrue, 0L);
            InvalidateRect(GetDlgItem(hdlg, IDC_LIST2), NULL, fFalse);

            EnableWindow(GetDlgItem(hdlg,IDC_C),fTrue);
            EnableWindow(GetDlgItem(hdlg,IDC_A),fFalse);
            EnableWindow(GetDlgItem(hdlg,IDC_S),fFalse);

            SetFocus(GetDlgItem(hdlg, IDC_C));
            SendMessage(hdlg, DM_SETDEFID, IDC_C, 0L);

            return fFalse;



         case IDCANCEL:
            if (LOWORD(wParam) == IDCANCEL) {

                if (!GetDlgItem(hdlg, IDC_B) || HIWORD(GetKeyState(VK_CONTROL)) || HIWORD(GetKeyState(VK_SHIFT)) || HIWORD(GetKeyState(VK_MENU)))
                {
                    break;
                }
                wParam = IDC_B;

            }
         case IDC_O:
         case IDC_C:
         case IDC_M:
         case IDC_B:
         case IDC_X:
         case IDC_BTN0:
         case IDC_BTN1: case IDC_BTN2: case IDC_BTN3:
         case IDC_BTN4: case IDC_BTN5: case IDC_BTN6:
         case IDC_BTN7: case IDC_BTN8: case IDC_BTN9:
            // Indicate the Button selected.

            _itoa((INT)wParam, rgchNum, 10);
            while (!FAddSymbolValueToSymTab("ButtonPressed", rgchNum))
               if (!FHandleOOM(hdlg))
                  {
                  DestroyWindow(GetParent(hdlg));
                  return(fTrue);
                  }

             // Fetch the list from first list and put it into ListItemsIn
                 EvalAssert((szList = szGetSzListFromListBox(hdlg, IDC_LIST1)) != (SZ) NULL) ;
             while (!FAddSymbolValueToSymTab("ListItemsIn", szList))
                if (!FHandleOOM(hdlg))
                   {
                   DestroyWindow(GetParent(hdlg));
                   return(fTrue);
                   }

             // Fetch the list from second list and put it into ListItemsIn
                 EvalAssert((szList = szGetSzListFromListBox(hdlg, IDC_LIST2)) != (SZ) NULL) ;
             while (!FAddSymbolValueToSymTab("ListItemsOut", szList))
                if (!FHandleOOM(hdlg))
                   {
                   DestroyWindow(GetParent(hdlg));
                   return(fTrue);
                   }


            PostMessage(GetParent(hdlg), (WORD)STF_UI_EVENT, 0, 0L);
             break;
         }
         break;

      case WM_COMPAREITEM:

         #define lpci ((LPCOMPAREITEMSTRUCT)lParam)

         return(CrcStringCompareI((SZ) *((RGSZ)lpci->itemData1),
                                  (SZ) *((RGSZ)lpci->itemData2)
                                 )
               );

      case WM_CHARTOITEM:
      {
         HWND hLB;
         INT  i, j, nCount;
         LONG_PTR lItem;
         CHP  chpBuf1[2], chpBuf2[2];  //used because we only have str cmp

         chpBuf1[1] = chpBuf2[1] = 0;

         chpBuf1[0] = (CHAR)LOWORD(wParam);

         // See if we need to process this character at all

         if (CrcStringCompareI(chpBuf1, " ") == crcSecondHigher)
            return -1;  //tell windows to do its default key processing

         // Extract the list box handle and the index of the current
         // selection item

         hLB = (HWND)lParam;
         i   = HIWORD(wParam);

         // Find the number of items in the list

         nCount = (INT)SendMessage(hLB, LB_GETCOUNT, 0, 0L);

         // From the next item downwards (circularly) look at all the
         // items to see if the char is the same as the first char in the
         // list box display item.

         for (j = 1; j < nCount; j++)
            {
            // get the data here
            SendMessage(hLB, LB_GETTEXT, (i + j) % nCount, (LPARAM)&lItem);

            // make a dummy string
            chpBuf2[0] = (*((RGSZ) lItem))[0];

            // do a case insensitive cmp of key and string
            if (CrcStringCompareI(chpBuf1, chpBuf2) == crcEqual)
               break;
            }

         return ((j == nCount) ? -2 : (i +j) % nCount);

         break;
      }

      case WM_DRAWITEM:

         #define lpDrawItem ((LPDRAWITEMSTRUCT)lParam)

         if (lpDrawItem->itemState & ODS_SELECTED) {
            SetTextColor(lpDrawItem->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
            SetBkColor(lpDrawItem->hDC, GetSysColor(COLOR_HIGHLIGHT));
         }
         else{
            SetTextColor(lpDrawItem->hDC, GetSysColor(COLOR_WINDOWTEXT));
            SetBkColor(lpDrawItem->hDC, GetSysColor(COLOR_WINDOW));
         }

         if (lpDrawItem->itemID != (UINT)-1){

            if (pszItem = rgszItem = (RGSZ) lpDrawItem->itemData ) {
                ExtTextOut(lpDrawItem->hDC,
                            lpDrawItem->rcItem.left,
                            lpDrawItem->rcItem.top,
                            ETO_OPAQUE, &lpDrawItem->rcItem,
                            (SZ)(*pszItem), lstrlen((SZ)(*pszItem)), NULL);
            }

            if (lpDrawItem->itemState & ODS_FOCUS) {
               DrawFocusRect(lpDrawItem->hDC, &lpDrawItem->rcItem);
            }

         }
         else {
            RECT rc;

            if ( (lpDrawItem->itemAction & ODA_FOCUS) &&
                 (SendMessage( GetDlgItem( hdlg, (int)wParam ), LB_GETITEMRECT, (WPARAM)0, (LPARAM)&rc ) != LB_ERR)
               ) {
                DrawFocusRect(lpDrawItem->hDC, &rc);
            }

         }
         return( fTrue );


    case STF_DESTROY_DLG:
      EvalAssert(fFreeListBoxEntries (hdlg, IDC_LIST1));
      EvalAssert(fFreeListBoxEntries (hdlg, IDC_LIST2));
        PostMessage(GetParent(hdlg), (WORD)STF_DUAL_DLG_DESTROYED, 0, 0L);
        DestroyWindow(hdlg);
        return(fTrue);
        }

    return(fFalse);
}

/*
** Author:
**    Sunil Pai
**
**  Purpose:
**      To fill an owner draw listbox from a simple/compound list
**
**  Arguments:
**    hdlg:     The handle to the dialog having the owner draw listbox
**    idc:      The ID of the listbox
**    szList:   A simple/compound list
**
**  Returns:
**    fTrue:    If Initialization succeeds.
**    fFalse:   If Initialization fails.
**
****************************************************************************/
BOOL fFillListBoxFromSzList (HWND hdlg, WORD idc, SZ szList)
{
   RGSZ rgszList, rgszElement;
   PSZ   pszList,  pszElement;

// List Value is {{...}, {...}, {...}...}
//

// 1. First construct a ptr array to all the list elements
//
   while ((pszList = rgszList = RgszFromSzListValue(szList)) == (RGSZ)NULL)
      if (!FHandleOOM(hdlg))
         {
         DestroyWindow(GetParent(hdlg));
         return(fFalse);
         }

//  2. Each array element in turn could be a list.  So for each element
//    construct an ptr array and use this ptr array to initialise the
//    the list box elements.

   while (*pszList)
      {
      while ((pszElement = rgszElement = RgszFromSzListValue(*pszList)) == (RGSZ)NULL)
         if (!FHandleOOM(hdlg))
            {
            EvalAssert(FFreeRgsz(rgszList));
            DestroyWindow(GetParent(hdlg));
            return(fFalse);
            }

      SendDlgItemMessage(hdlg, idc, LB_ADDSTRING, 0,
                            (LPARAM)pszElement);

      pszList++;
      }

// 3. Free the list array and then exit.
//
   EvalAssert(FFreeRgsz(rgszList));
    return(fTrue);
}

/*
** Author:
**    Sunil Pai
**
**  Purpose:
**      To extract the listbox elements from the listbox and free the memory
**    used to build the elements.
**
**  Arguments:
**    hdlg:     The handle to the dialog having the owner draw listbox
**    idc:      The ID of the listbox
**
**  Returns:
**    fTrue:    If freeing succeeds.
**    fFalse:   If freeing fails.
**
****************************************************************************/

BOOL fFreeListBoxEntries (HWND hdlg, WORD idc)
{
   INT  i, nCount;
   LONG_PTR lItem;

// 1. Get count of the entries in the list box
//
   nCount = (INT)SendDlgItemMessage(hdlg, idc, LB_GETCOUNT, 0,  0L);

// 2. For each element in the list box, fetch the element and free
//    the rgsz structure associated with it.

   for (i = 0; i < nCount; i++)
       {
        EvalAssert(SendDlgItemMessage(hdlg, idc, LB_GETTEXT,
                                       (WPARAM)i, (LPARAM)&lItem) != LB_ERR);
      EvalAssert(FFreeRgsz((RGSZ)lItem));
      }
   return(fTrue);
}

/*
** Author:
**    Sunil Pai
**
**  Purpose:
**      To fill the status fields whenever a selection is made in either of
**    the list boxes
**
**  Arguments:
**    hdlg:     The handle to the dialog having the owner draw listbox
**    idc:      The ID of the listbox
**    n:        The selected elements position in the listbox
**
**  Returns:
**    fTrue:    If the Update succeeds.
**    fFalse:   If the Update fails.
**
****************************************************************************/

BOOL fUpdateStatus(HWND hdlg, WORD idc, INT n)
{
   LONG_PTR lItem;
   RGSZ rgszElement;
    PSZ  pszElement;
   WORD idcStatus;

   SendDlgItemMessage(hdlg, idc, LB_GETTEXT, n, (LPARAM)&lItem);
   pszElement = rgszElement = (RGSZ)lItem;

   idcStatus = IDC_STATUS1;
   while (*pszElement != (SZ)NULL && GetDlgItem(hdlg, idcStatus))
         SetDlgItemText (hdlg, idcStatus++,*pszElement++);

   return fTrue;

}


/*
** Author:
**    Sunil Pai
**
**  Purpose:
**      To build a list from all the elements in the specified owner draw
**    listbox
**
**  Arguments:
**    hdlg:     The handle to the dialog having the owner draw listbox
**    idc:      The ID of the listbox
**
**  Returns:
**    SZ        Pointer to list (can be empty {})
**    NULL      if error occured.
**
****************************************************************************/

SZ szGetSzListFromListBox (HWND hdlg, WORD idc)
{
   HWND hLB;
   INT  i, nCount;
   LONG_PTR lItem;
   RGSZ rgsz;
   SZ   szList;

   // Get the number of items in the list box and the handle to the list box

   nCount = (INT) SendDlgItemMessage(hdlg, idc, LB_GETCOUNT, 0, 0L);
   hLB = GetDlgItem(hdlg, idc);

   // Allocate a rgsz structure to hold all the items from the list box
   // and initialize it

   while ((rgsz = (RGSZ)SAlloc((nCount + 1) * sizeof(SZ)))
          == (RGSZ)NULL)
      if (!FHandleOOM(hdlg))
         {
         DestroyWindow(GetParent(hdlg));
         return((SZ)NULL);
         }

   rgsz[nCount] = (SZ)NULL;

   // For all the items in the list box get the item involved.  Each item
   // is itself an RGSZ structure which needs to be converted into a list
   // before we put it into the RGSZ structure initialized above.

   for (i = 0; i < nCount; i++)
      {
      SendMessage(hLB, LB_GETTEXT, i, (LPARAM)&lItem);
      while ((rgsz[i] = SzListValueFromRgsz((RGSZ)lItem)) == (SZ)NULL)
         if (!FHandleOOM(hdlg))
            {
            DestroyWindow(GetParent(hdlg));
            return((SZ)NULL);
            }

      }


   // Construct a list from the RGSZ list structure, free the rgsz structure
   // and return the list formed

   while ((szList = SzListValueFromRgsz(rgsz)) == (SZ)NULL)
      if (!FHandleOOM(hdlg))
         {
         DestroyWindow(GetParent(hdlg));
         return((SZ)NULL);
         }

   EvalAssert(FFreeRgsz(rgsz));

    return (szList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\dllmain.c ===
#include "precomp.h"
#pragma hdrstop
/**************************************************************************/
/***** Shell Component - WinMain, ShellWndProc routines *******************/
/**************************************************************************/

//
// Reentrancy control.
//
BOOL
EnterInterpreter(
    VOID
    );

#define EXIT_CODE   "Exit_Code"

extern HWND hwndProgressGizmo;

//
// This flag tells us whether we were invoked as a standalone process
// or whether we were called to interpret a legacy inf from within a process.
//
BOOL OwnProcess;

//
// The following two globals are only valid if 'OwnProcess' is FALSE.  They are
// used to keep track of what services have been modified during an INF 'run'.
// Refer to sc.c!LegacyInfGetModifiedSvcList() for more details.
//
LPSTR ServicesModified;
DWORD ServicesModifiedSize;


/*
**      Shell Global Variables
*/
HANDLE   hInst = (HANDLE)NULL;
HWND     hWndShell = (HWND)NULL;
HANDLE   SupportLibHandle = NULL;
HWND     hwParam = NULL ;
HWND     hwPseudoParent = NULL ;
static      BOOL     fParamFlashOn = FALSE ;

// SZ       szShlScriptSection = (SZ)NULL;
//
// No longer used (we never try to abort a shutdown)
//
// BOOL     fIgnoreQueryEndSession = fTrue;

CHP      rgchBufTmpLong[cchpBufTmpLongBuf] = "long";
CHP      rgchBufTmpShort[cchpBufTmpShortBuf] = "short";

HBITMAP  hbmAdvertList [ BMP_MAX + 1 ] ;
INT      cAdvertIndex = -1 ;
INT      cAdvertCycleSeconds = 0 ;
INT      cyAdvert = 0 ;
INT      cxAdvert = 0 ;
INT      dyChar = 0;
INT      dxChar = 0;
BOOL     bTimerEnabled = FALSE ;

RECT     rcBmpMax = {-1,-1,-1,-1} ;

extern BOOL   fFullScreen;
extern INT    gaugeCopyPercentage ;

extern PSTR LastShellReturn;
extern DWORD LastShellReturnSize;

SCP    rgscp[] = {
        { "UI",                 spcUI },
        { "READ-SYMS",          spcReadSyms },
        { "DETECT",             spcDetect },
        { "INSTALL",            spcInstall },
        { "UPDATE-INF",         spcUpdateInf },
        { "WRITE-INF",          spcWriteInf },
        { "EXIT",               spcExit },
        { "WRITE-SYMTAB",       spcWriteSymTab },
        { "SET-TITLE",          spcSetTitle },

        { "EXIT-AND-EXEC",      spcExitAndExec },
        { "ENABLEEXIT",         spcEnableExit },
        { "DISABLEEXIT",        spcDisableExit },
        { "SHELL",              spcShell },
        { "RETURN",             spcReturn },
        { NULL,                 spcUnknown },
        };
PSPT   psptShellScript = (PSPT)NULL;


VOID
RebootMachineIfNeeded(
    );

#define TimerInterval  500   // 1/2 second
#define TimerId        1

VOID FSetTimer ( VOID ) ;
VOID FHandleBmpTimer ( VOID ) ;

VOID FFlashParentActive ( VOID ) ;
VOID FPaintBmp ( HWND hwnd, HDC hdc ) ;

#define POINTSIZE_WASHTEXT 24
#define X_WASHTEXT 5
#define Y_WASHTEXT 5
#define CR_BLACK  RGB(0, 0, 0)
#define CR_DKBLUE RGB(0, 0, 128)

UINT ScreenWidth,ScreenHeight;


int
real_dll_main(
    IN int   argc,
    IN char *argv[],
    IN char *CommandLine    OPTIONAL
    )
{
    HANDLE hInst;
    HANDLE hPrevInst  = NULL;
    LPSTR  lpCmdLine;
    INT    nCmdShow   = SW_SHOWNORMAL;
    USHORT _argc      = (USHORT)argc;
    CHAR   **_argv    = argv;

    MSG msg;
    SZ  szInfSrcPath;
    SZ  szDestDir;
    SZ  szSrcDir;
    SZ  szCWD;
    PSTR sz;
    INT wModeSetup;
    INT rc;

    hInst = MyDllModuleHandle;

    lpCmdLine  = CommandLine ? CommandLine : GetCommandLine();
    //
    // Strip off the first string (program name).
    //
    if(sz = strchr(lpCmdLine,' ')) {
        do {
            sz++;
        } while(*sz == ' ');
        lpCmdLine = sz;
    } else {
        // no spaces, program name is alone on cmd line.
        lpCmdLine += lstrlen(lpCmdLine);
    }

    ScreenWidth = GetSystemMetrics(SM_CXSCREEN);
    ScreenHeight = GetSystemMetrics(SM_CYSCREEN);

    //
    // We check for the -f parameter here because we have to create (and display)
    //  the Seup window before calling the FParseCmdLine function.
    //

    if( _argc < 2 ) {

        //
        // No parameters on setup command line.  If setup has been run from
        // the windows system direcotry then we conclude that setup has been
        // run in maintenance mode
        //

        CHAR szSystemDir[MAX_PATH];
        CHAR szCWD[MAX_PATH];

        if ( GetSystemDirectory( szSystemDir, MAX_PATH ) &&
             GetModuleFileName(hInst, szCWD, MAX_PATH)
           ) {
            SZ szFileSpec;

            //
            // Extract the directory of the module file spec and compare it
            // with the system directory.  If the two are the same assume
            // we are maintenance mode

            if( szFileSpec = strrchr( szCWD, '\\' ) ) {
                *szFileSpec = '\0';

                if( !lstrcmpi( szSystemDir, szCWD ) ) {
                    fFullScreen = fFalse;
                }
            }
        }

    }
    else {

        //
        // Check to see if blue wash has been explicitly disabled or
        // if a primary parent window handle has been passed in.
        //

        while ( --argc ) {
            if ( (_argv[argc][0] == '/') || (_argv[argc][0] == '-')) {
                switch ( _argv[argc][1] )
                {
                case 'F':
                case 'f':
                    fFullScreen = fFalse;
                    break;
                case 'w':
                case 'W':
                    hwParam = (HWND) LongToHandle(atol( _argv[argc+1] )) ;
                    break ;
                default:
                    break ;
                }
            }
        }
        _argv = argv;
    }


    CurrentCursor = LoadCursor(NULL,IDC_ARROW);

    if(!CreateShellWindow(hInst,nCmdShow,FALSE)) {
        return( SETUP_ERROR_GENERAL );
    }

    rc = ParseCmdLine(
             hInst,
             (SZ)lpCmdLine,
             &szInfSrcPath,
             &szDestDir,
             &szSrcDir,
             &szCWD,
             &wModeSetup
             );

    if( rc != CMDLINE_SUCCESS) {
        FDestroyShellWindow() ;
        return( ( rc == CMDLINE_SETUPDONE ) ?
                      SETUP_ERROR_SUCCESS : SETUP_ERROR_GENERAL );
    }

    if(!FInitApp(hInst, szInfSrcPath, szDestDir, szSrcDir, szCWD,
                wModeSetup)) {
        FDestroyShellWindow() ;
        return(SETUP_ERROR_GENERAL);
    }

    //  Start the timer ticking

    FSetTimer() ;

    //
    // Set the parent app, if any, to *appear* enabled
    //
    if(OwnProcess) {
        FFlashParentWindow(TRUE);
    }

    while (GetMessage(&msg, NULL, 0, 0)) {
        if(FUiLibFilter(&msg) &&
            (hwndProgressGizmo == NULL ||
            !IsDialogMessage(hwndProgressGizmo,&msg))) {

            TranslateMessage(&msg);
            DispatchMessage(&msg);

        }
    }

    return (int)(msg.wParam);
}


int
dll_main(
    IN int argc,
    IN char *argv[]
    )
{
    if(!EnterInterpreter()) {
        return(SETUP_ERROR_GENERAL);
    }

    OwnProcess = TRUE;

    //
    // Set the modified service list buffer to empty, so we won't be fooled into
    // using it should someone mistakenly call LegacyInfGetModifiedSvcList().
    // This buffer is only valid when used after a successful call to
    // LegacyInfInterpret().
    //
    ServicesModified = NULL;
    ServicesModifiedSize = 0;

    return(real_dll_main(argc,argv,NULL));
}

/*
**      Purpose:
**              ??
**      Arguments:
**              none
**      Returns:
**              none
**
***************************************************************************/
LRESULT APIENTRY ShellWndProc(HWND hWnd, UINT wMsg, WPARAM wParam,
                LPARAM lParam)
{
    PAINTSTRUCT ps;
    HDC         hdc;
    RECT        rc;
    INT         ExitCode = SETUP_ERROR_GENERAL;
    SZ          szExitCode;

    static LPSTR  HelpContext = NULL;

    switch (wMsg) {

    case WM_CREATE:
        break;

    case WM_ERASEBKGND:
        break;

    case WM_PAINT:
        hdc = BeginPaint(hWnd, &ps);
        if ( fFullScreen ) {
            HBITMAP hbmBackground;
            HDC hdcMem;
            BITMAP bm;
            BOOL Drawn;
            LOGFONT LogFont;
            HFONT hFont,hFontOld;
            COLORREF crBk,crTx;

            Drawn = FALSE;
            GetClientRect(hWnd, &rc);

            if(hbmBackground = LoadBitmap(MyDllModuleHandle,MAKEINTRESOURCE(IDB_BACKGROUND))) {
                if(hdcMem = CreateCompatibleDC(ps.hdc)) {

                    crBk = SetBkColor(ps.hdc,CR_DKBLUE);
                    crTx = SetTextColor(ps.hdc,CR_BLACK);

                    SelectObject(hdcMem,hbmBackground);
                    GetObject(hbmBackground,sizeof(BITMAP),&bm);

                    StretchBlt(
                        ps.hdc,
                        0,0,
                        ScreenWidth+1,
                        ScreenHeight+1,
                        hdcMem,
                        0,0,
                        bm.bmWidth,bm.bmHeight,
                        SRCCOPY
                        );

                    DeleteDC(hdcMem);

                    SetBkColor(ps.hdc, crBk);
                    SetTextColor(ps.hdc, crTx);

                    Drawn = TRUE;
                }
                DeleteObject(hbmBackground);
            }

            if(!Drawn) {
                PatBlt(ps.hdc,0,0,ScreenWidth,ScreenHeight,BLACKNESS);
            }

            ZeroMemory(&LogFont,sizeof(LOGFONT));
            LogFont.lfHeight = -1 * (GetDeviceCaps(ps.hdc,LOGPIXELSY) * POINTSIZE_WASHTEXT / 72);
            LogFont.lfWeight = FW_DONTCARE;
            //LogFont.lfItalic = TRUE;
            LogFont.lfCharSet = DEFAULT_CHARSET;
            LogFont.lfQuality = PROOF_QUALITY;
            LogFont.lfPitchAndFamily = DEFAULT_PITCH | FF_ROMAN;
            lstrcpy(LogFont.lfFaceName,"MS Serif");
            if(hFont = CreateFontIndirect(&LogFont)) {

                TCHAR Buffer[128];
                UINT i;

                i = LoadString(MyDllModuleHandle,IDS_WINDOWS_NT_SETUP,Buffer,sizeof(Buffer)/sizeof(TCHAR));
                hFontOld = SelectObject(ps.hdc,hFont);
                SetTextColor(ps.hdc, RGB(255,255,255));
                SetBkMode(ps.hdc, TRANSPARENT);

                ExtTextOut(ps.hdc,X_WASHTEXT,Y_WASHTEXT,ETO_CLIPPED,&rc,Buffer,i,NULL);

                SelectObject(ps.hdc, hFontOld);
                DeleteObject(hFont);
            }
            if(cAdvertIndex >= 0) {
                FPaintBmp( hWnd, hdc ) ;
            }
        }
        EndPaint(hWnd, &ps);
        break;

    case WM_ACTIVATEAPP:
        if (wParam != 0) {
            SetWindowPos(
                hWnd,
                NULL,
                0, 0, 0, 0,
                SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE
                );
        }

        return(DefWindowProc(hWnd, wMsg, wParam, lParam));


    case WM_NCHITTEST: {

        extern BOOL WaitingOnChild;

        if(WaitingOnChild) {
            return(HTERROR);
        } else {
            return(DefWindowProc(hWnd, wMsg, wParam, lParam));
        }
    }

    case WM_TIMER:
        if ( wParam == TimerId && cAdvertIndex >= 0 ){
            FHandleBmpTimer() ;
        }
        break ;

    case WM_CLOSE:
        if (HdlgStackTop() != NULL) {

            SendMessage(HdlgStackTop(), WM_CLOSE, 0, 0L);
        } else {
            MessageBeep(0);
        }
        break;

    case STF_UI_EVENT:
        if (!FGenericEventHandler(hInst, hWnd, wMsg, wParam, lParam)) {
            if (hWndShell != NULL) {
                SendMessage(hWndShell, (WORD)STF_ERROR_ABORT, 0, 0);
            }
        }
        break;

    case STF_SHL_INTERP:
        if (!FInterpretNextInfLine(wParam, lParam)) {
            if (hWndShell != NULL) {
                SendMessage(hWndShell, (WORD)STF_ERROR_ABORT, 0, 0);
            }
        }
        break;

    case STF_HELP_DLG_DESTROYED:
    case STF_INFO_DLG_DESTROYED:
    case STF_EDIT_DLG_DESTROYED:
    case STF_RADIO_DLG_DESTROYED:
    case STF_LIST_DLG_DESTROYED:
    case STF_MULTI_DLG_DESTROYED:
    case STF_QUIT_DLG_DESTROYED:
    case STF_COMBO_DLG_DESTROYED:
    case STF_MULTICOMBO_DLG_DESTROYED:
    case STF_MULTICOMBO_RADIO_DLG_DESTROYED:
    case STF_DUAL_DLG_DESTROYED:
    case STF_MAINT_DLG_DESTROYED:
        break;

    case WM_ENTERIDLE:

        if(wParam == MSGF_DIALOGBOX) {
            SendMessage((HWND)lParam,WM_ENTERIDLE,wParam,lParam);
        }
        return(0);

    case WM_SETCURSOR:
        SetCursor(CurrentCursor);
        return(TRUE);

    case WM_DESTROY:

        if ( pGlobalContext() ) {
            szExitCode = SzFindSymbolValueInSymTab( EXIT_CODE );

            if ( szExitCode && (szExitCode[0] != '\0')) {
                ExitCode = atoi( szExitCode );
            } else {
                ExitCode = SETUP_ERROR_GENERAL;
            }
            FCloseWinHelp(hWnd);
        }

        FTermHook();

        PostQuitMessage(ExitCode);
        break;

    case STF_ERROR_ABORT:

        FCloseWinHelp(hWnd);
        RebootMachineIfNeeded();
        FFlashParentActive() ;
        if(OwnProcess) {
            ExitProcess(ExitCode);
        } else {
            FDestroyShellWindow();
        }
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case ID_HELPBUTTON:
            FProcessWinHelp(hWnd);
            break;
        default:
            return(DefWindowProc(hWnd, wMsg, wParam, lParam));
        }
        break;

    default:
        return(DefWindowProc(hWnd, wMsg, wParam, lParam));
    }

    return(0L);
}



VOID
SetSupportLibHandle(
    IN HANDLE Handle
    )

{
        SupportLibHandle = Handle;
}

VOID
RebootMachineIfNeeded(
    )
{
    SZ       sz;
    BOOLEAN  OldState;
    NTSTATUS Status;

    if ( pGlobalContext()
         && ( sz = SzFindSymbolValueInSymTab("!STF_INSTALL_TYPE") ) != (SZ)NULL
         && !lstrcmpi( sz, "SETUPBOOTED" ) ) {

        Status = RtlAdjustPrivilege(
            SE_SHUTDOWN_PRIVILEGE,
            TRUE,
            FALSE,
            &OldState);

        if( NT_SUCCESS( Status ) ) {
            if(OwnProcess) {
                ExitWindowsEx(EWX_REBOOT, 0);
            }
        }
    }
}

VOID FDestroyShellWindow ( VOID )
{
    if ( bTimerEnabled ) {
        KillTimer( hWndShell, TimerId ) ;
    }

    if ( hwParam ) {
        EnableWindow( hwParam, TRUE );
        SetActiveWindow( hwParam ) ;
    }

    DestroyWindow( hWndShell ) ;  // needed to kill bootstrapper
}

//  Set the parent app's window, if any, to appear
//  active or inactive, according to 'On'.

VOID FFlashParentWindow ( BOOL On )
{
    if ( hwParam == NULL || On == fParamFlashOn )
        return ;

    fParamFlashOn = On ;
    FlashWindow( hwParam, fTrue ) ;
}

VOID FFlashParentActive ( VOID )
{
    if ( hwParam == NULL )
        return ;

    //  We don't know what state the parent is in.  If
    //  we flash and find that it WAS active, do it again.

    if ( FlashWindow( hwParam, fTrue ) )
         FlashWindow( hwParam, fTrue ) ;
}

//  Start the timer sending WM_TIMER messages to the
//  main window.

VOID FSetTimer ( VOID )
{
    bTimerEnabled = (SetTimer( hWndShell, TimerId, TimerInterval, NULL ) != 0);
}

//   This routine maintains a RECT structure defining the
//   largest rectangle modified by an "advertising" bitmap.
//   Its value is used to invalidate only the exact portions
//   of the shell window.

static void computeBmpUpdateRect ( HBITMAP hbmNext )
{
    BITMAP bm ;
    RECT rc ;
    int ix, iy ;

    //  Get info about this bitmap

    GetObject( hbmNext, sizeof bm, & bm ) ;

    //  Compute the rectangle it will occupy

    GetClientRect( hWndShell, & rc ) ;
    ix = (rc.right - rc.left) / 100 ;
    ix *= cxAdvert ;
    iy = (rc.bottom - rc.top) / 100 ;
    iy *= cyAdvert ;

    rc.left   = ix ;
    rc.right  = ix + bm.bmWidth ;
    rc.top    = iy ;
    rc.bottom = iy + bm.bmHeight ;

    //  Compute the max rect of this and prior history

    if ( rcBmpMax.left == -1 ) {
        rcBmpMax = rc ;
    } else {
        if ( rc.left < rcBmpMax.left )
            rcBmpMax.left = rc.left ;
        if ( rc.top < rcBmpMax.top )
            rcBmpMax.top = rc.top ;
        if ( rc.right > rcBmpMax.right )
            rcBmpMax.right = rc.right ;
        if ( rc.bottom > rcBmpMax.bottom )
            rcBmpMax.bottom = rc.bottom ;
    }
}

    /*
     *  Update the BMP being displayed unless the cycle is zero seconds.
     *
     *  The logic works as follows:  If the cycle time is > 1, then
     *  the bitmaps just cycle in a loop, with each bitmap being
     *  displayed for the time given.
     *
     *  If the cycle type is == 1, then the display is synchronized
     *  with the copy dialogs completion percentage.  The global variable
     *  "gaugeCopyPercentage" is monitored, and each time it moves
     *  into a new "band", the bit map is updated.  Band size is determined
     *  by dividing the 100% level by the number of bitmaps.   The
     *  routine guarantees that no bitmap will appear for less than 15
     *  seconds.  When the copy operation complets, it sets gaugeCopyPercentage
     *  back to -1 and the INF is responsible for calling BmpHide to tear
     *  down the bitmaps.
     */

VOID FHandleBmpTimer ( VOID )
{
#define MINIMUM_BITMAP_CYCLE 15

    static DWORD dwFirstTime = 0;
    static DWORD dwLastTime = 0 ;
    static INT cIndexLast = -1 ;

    if ( cAdvertIndex >= 0 && cAdvertCycleSeconds != 0 ) {
        INT     cIndexMax;
        INT     iBmp = cIndexLast;
        DWORD   dwCurrTime = GetCurrentTime();
        DWORD   dwElapsedCycles;

        //  Count the number of bitmaps

        for ( cIndexMax = 0 ;
              hbmAdvertList[cIndexMax] ;
              cIndexMax++ ) ;

        //  See if we're based on percentages or timing

        if ( cAdvertCycleSeconds == 1 ) {
            //  Percentages: check percentage complete of copy operation.
            //  Don't update display if gauge isn't active yet

            if ( gaugeCopyPercentage >= 0 ) {
                if ( gaugeCopyPercentage >= 100 )
                    gaugeCopyPercentage = 99 ;
                iBmp = gaugeCopyPercentage / (100 / cIndexMax) ;
                if ( iBmp >= cIndexMax )
                    iBmp = cIndexMax - 1 ;
            }
        } else {
            // Timing: see if the current bitmap has expired

            if ( dwFirstTime == 0 )
                dwFirstTime = dwCurrTime ;

            dwElapsedCycles = (dwCurrTime - dwFirstTime)
                            / (cAdvertCycleSeconds * TimerInterval) ;

            iBmp = dwElapsedCycles % cIndexMax ;
        }

        if (    iBmp != cIndexLast
             && (dwLastTime + MINIMUM_BITMAP_CYCLE) < dwCurrTime  ) {

            cAdvertIndex = iBmp ;
            computeBmpUpdateRect( hbmAdvertList[ cAdvertIndex ] ) ;
            InvalidateRect( hWndShell, & rcBmpMax, FALSE ) ;
            UpdateWindow( hWndShell ) ;
            dwLastTime = dwCurrTime ;
        }
    } else if ( cAdvertIndex < 0 && cIndexLast >= 0 ) {
        //  Reset last cycle timer.
        dwLastTime = dwFirstTime = 0 ;

        //  Reset largest BMP rectangle.
        rcBmpMax.top =
           rcBmpMax.left =
              rcBmpMax.right =
                 rcBmpMax.bottom = -1 ;
    }
    cIndexLast = cAdvertIndex ;
}

VOID FPaintBmp ( HWND hwnd, HDC hdc )
{
    HDC hdcBits;
    BITMAP bm;
    RECT rect ;
    INT ix, iy ;
    HDC hdcLocal = NULL ;

    if ( hdc == NULL )
    {
        hdcLocal = hdc = GetDC( hwnd ) ;
        if ( hdc == NULL )
            return ;
    }

    GetClientRect( hwnd, & rect ) ;
    ix = (rect.right - rect.left) / 100 ;
    ix *= cxAdvert ;
    iy = (rect.bottom - rect.top) / 100 ;
    iy *= cyAdvert ;

    hdcBits = CreateCompatibleDC( hdc ) ;
    if (hdcBits) {

       GetObject(hbmAdvertList[cAdvertIndex], sizeof (BITMAP), & bm ) ;
       SelectObject( hdcBits, hbmAdvertList[cAdvertIndex] ) ;
       BitBlt( hdc, ix, iy,
               bm.bmWidth,
               bm.bmHeight,
               hdcBits,
               0, 0, SRCCOPY ) ;
       DeleteDC( hdcBits ) ;

    }

    if ( hdcLocal )
    {
        ReleaseDC( hwnd, hdcLocal ) ;
    }
}


//
// NOTE: This function is NOT NOT NOT serially reentrant!
// It relies on the caller to free this module and then reload it
// in between calls!!!
//
BOOL
LegacyInfInterpret(
    IN  HWND  OwnerWindow,
    IN  PCSTR InfFilename,
    IN  PCSTR InfSection,       OPTIONAL
    IN  PCHAR ExtraVariables,
    OUT PSTR  InfResult,
    IN  DWORD BufferSize,
    OUT int   *InterpResult,
    IN  PCSTR InfSourceDir      OPTIONAL
    )
{
    PSTR    CommandLine;
    PSTR    ArgvLine;
    PSTR    ptr;
    PSTR    Source;
    PSTR    Sym;
    PSTR    Val;
    PVOID   p;
    UINT    Length;
    UINT    RequiredLength;
    BOOL    b;
    int     argvsize;
    int     argc;
    char    **argv;
    CHAR    Window[24];
    #define CLINE_SIZE 32768

    b = FALSE;

    //
    // Reentrancy control.
    //
    if(!EnterInterpreter()) {
        return(FALSE);
    }

    //
    // Initialize the buffer that may be used to contain list of services modified during
    // this INF run.  (This will only be used if !LEGACY_DODEVINSTALL is set.)
    //
    ServicesModified = NULL;
    ServicesModifiedSize = 0;

    //
    // Allocate memory for the command line
    //
    CommandLine = SAlloc(CLINE_SIZE);
    if(!CommandLine) {
        return(FALSE);
    }
    CommandLine[0] = L'\0';

    //
    // Allocate memory for the "-s <filename>" part
    //
    Source = SAlloc(MAX_PATH + 5);
    if(!Source) {
        SFree(CommandLine);
        return (FALSE);
    }
    Source[0] = L'\0';

    if(IsWindow(OwnerWindow)) {
        wsprintf(Window," -w %u",OwnerWindow);
    } else {
        Window[0] = 0;
        Window[1] = 0;
    }

    if(InfSourceDir) {
        _snprintf(
            Source,
            (MAX_PATH + 5),
            " -s %s",
            InfSourceDir);
    }

    //
    // Create the minimum sized command line that need be parsed in an
    // argc/argv format
    //
    _snprintf(
        CommandLine,
        CLINE_SIZE - 1,
        "setup -f%s",
        Window);

    CommandLine[CLINE_SIZE-1] = 0;

    //
    // Create a dummy argv list -> required to be parse compatible with
    // dll_main()
    //
    ArgvLine = SAlloc ( strlen(CommandLine) + 1 );
    if(!ArgvLine) {
        SFree(CommandLine);
        SFree(Source);
        return (FALSE);
    }

    //
    // Allocate storage for the argv
    //
    argvsize = 8;
    argv = SAlloc( argvsize * sizeof( char * ) );
    if(!argv) {
        SFree(CommandLine);
        SFree(Source);
        SFree(ArgvLine);
        return (FALSE);
    }

    //
    // Create the argv list
    //
    strcpy(ArgvLine,CommandLine);
    ptr = ArgvLine;
    argv[0] = ptr;
    argc = 1;

    while(*ptr != '\0') {
        if(argc == argvsize) {
            argvsize += 8;
            argv = SRealloc( argv, argvsize * sizeof( char * ) );
            if(!argv) {
                SFree(CommandLine);
                SFree(Source);
                SFree(ArgvLine);
                return (FALSE);
            }
        }
        if(*ptr == ' ') {
            while(*ptr == ' ') {
                *ptr++ = '\0';
            }
            argv[argc++] = ptr;
        } else {
            ptr++;
        }

    }

    //
    // Create the real command line now. If the caller specified an inf section,
    // then he wants to call a particular section in an inf, via legacy.inf.
    // If the caller did not specify an inf section, then he wants to invoke
    // [Shell Commands] in the given inf, directly (ie, not via legacy.inf).
    //
    _snprintf(
        CommandLine,
        CLINE_SIZE - 1,
        "setup -f -i %s%s%s -t LEGACY_TARGET_INF = %s -t LEGACY_TARGET_SECTION = %s",
        InfSection ? "legacy.inf" : InfFilename,
        Window,
        Source,
        InfFilename,
        InfSection ? InfSection : "\"Shell Commands\""
        );

    CommandLine[CLINE_SIZE-1] = 0;

    //
    // Now add the extra symbols to the command line.
    //
    Sym = ExtraVariables;
    while(*Sym) {

        Val = Sym + strlen(Sym) + 1;

        Length = strlen(Sym) + strlen(Val) + 8;
        if(strlen(CommandLine) + Length <= CLINE_SIZE) {

            strcat(CommandLine," -t ");
            strcat(CommandLine,Sym);
            strcat(CommandLine," = ");
            strcat(CommandLine,Val);
        }

        Sym = Val + strlen(Val) + 1;
    }

    //
    // Set a global pointer to the area and size of the return buffer
    //
    LastShellReturn = InfResult;
    LastShellReturnSize = BufferSize;

    if(p = SRealloc(CommandLine,strlen(CommandLine)+1)) {

        //
        // OK, let 'er rip.
        //
        OwnProcess = FALSE;
        CommandLine = p;
        *InterpResult = real_dll_main(argc,argv,CommandLine);
        b = TRUE;

    }

    //
    // The caller is not going to call our LegacyInfGetModifiedSvcList() API
    // if this routine returns failure.  So we need to clean up the buffer now,
    // if we failed.
    //
    if((!b || (*InterpResult != SETUP_ERROR_SUCCESS)) && ServicesModified) {
        SFree(ServicesModified);
        ServicesModified = NULL;
        ServicesModifiedSize = 0;
    }

    LastShellReturn = NULL;
    LastShellReturnSize = 0;

    SFree(Source);
    SFree(CommandLine);
    return(b);
}


BOOL
EnterInterpreter(
    VOID
    )
{
    static LONG InInterpreter = -1;

    //
    // The InInterpreter flag starts out at -1. The first increment
    // makes it 0; subsequent increments make it > 0. Only the first
    // increment will allow entry into the module.
    //
    return(InterlockedIncrement(&InInterpreter) == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\editproc.c ===
#include "precomp.h"
#pragma hdrstop
/***************************************************************************/
/****************** Basic Class Dialog Handlers ****************************/
/***************************************************************************/


#define cchpMax 511



/*
**  Purpose:
**      Edit Dialog procedure for templates with exactly one edit control.
**  Control IDs:
**      The Edit control must have an id of IDC_EDIT1.
**      Pushbuttons recognized are IDC_O, IDC_C, IDC_M, IDC_H, IDC_X, and IDC_B.
**  Initialization:
**      The symbol $(EditTextIn) is used to set the initial text in the Edit
**      control.  It is set to the empty string if the symbol is not found.
**      The symbol $(EditFocus) is used to set what portion of the initial
**      string is selected.  Supported values are 'END' (default), 'ALL', or
**      'START'.
**  Termination:
**      The string in the Edit control is stored in the symbol $(EditTextOut).
**      The id of the Pushbutton (eg IDC_C) which caused termination is
**      converted to a string and stored in the symbol $(ButtonPressed).
**
*****************************************************************************/
INT_PTR APIENTRY FGstEditDlgProc(HWND   hdlg,
                                 UINT   wMsg,
                                 WPARAM wParam,
                                 LPARAM lParam)
{
    static WPARAM wSelStart = 0;
    static WPARAM wSelEnd   = 0;
    CHP  rgchNum[10];
    CHP  rgchText[cchpMax + 1];
    SZ   sz;
    CCHP cchp;

    Unused(lParam);

    switch (wMsg)
        {
    case WM_INITDIALOG:
        AssertDataSeg();

        if( wMsg == WM_INITDIALOG ) {
            FCenterDialogOnDesktop(hdlg);
        }

        cchp = cchpMax;
        if ((sz = SzFindSymbolValueInSymTab("EditTextLim")) != (SZ)NULL)
            cchp = (CCHP) atoi(sz);
          SendDlgItemMessage(hdlg, IDC_EDIT1, EM_LIMITTEXT, cchp, 0L);

        if ((sz = SzFindSymbolValueInSymTab("EditTextIn")) == (SZ)NULL)
            sz = "";
        Assert(sz != NULL);
        SetDlgItemText(hdlg, IDC_EDIT1, (LPSTR)sz);

        cchp = strlen(sz);
        if ((sz = SzFindSymbolValueInSymTab("EditFocus")) == (SZ)NULL)
            sz = "END";

          /* default == END */
        wSelStart = (WPARAM)cchp;
        wSelEnd   = (WPARAM)cchp;
        if (CrcStringCompare(sz, "END") == crcEqual)
            ;
        else if (CrcStringCompare(sz, "ALL") == crcEqual)
            {
            wSelStart = 0;
            wSelEnd   = INT_MAX;
            }
        else if (CrcStringCompare(sz, "START") == crcEqual)
            {
            wSelStart = 0;
            wSelEnd   = 0;
            }


        return(fTrue);

    case STF_REINITDIALOG:
        SetFocus( GetDlgItem(hdlg, IDC_EDIT1 ) );
        return(fTrue);

//    case STF_DLG_ACTIVATE:
//    case WM_MOUSEACTIVATE:
//        if (FActiveStackTop())
//            break;
//        EvalAssert(FInactivateHelp());
//        SetWindowPos(hdlg, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
//        /* fall through */
//    case STF_UILIB_ACTIVATE:
//        EvalAssert(FActivateStackTop());
//        return(fTrue);

    case WM_CLOSE:
        PostMessage(
            hdlg,
            WM_COMMAND,
            MAKELONG(IDC_X, BN_CLICKED),
            0L
            );
        return(fTrue);


    case WM_COMMAND:
        switch(LOWORD(wParam))
            {
        case IDC_EDIT1:
           if (HIWORD(wParam) == EN_SETFOCUS)
                SendDlgItemMessage(hdlg, IDC_EDIT1, EM_SETSEL, wSelStart,
                        wSelEnd);
            else if (HIWORD(wParam) == EN_KILLFOCUS)
                SendDlgItemMessage(hdlg, IDC_EDIT1, EM_GETSEL, (WPARAM)&wSelStart,
                        (LPARAM)&wSelEnd);
            break;

        case IDCANCEL:
            if (LOWORD(wParam) == IDCANCEL) {

                if (!GetDlgItem(hdlg, IDC_B) || HIWORD(GetKeyState(VK_CONTROL)) || HIWORD(GetKeyState(VK_SHIFT)) || HIWORD(GetKeyState(VK_MENU)))
                {
                    break;
                }
                wParam = IDC_B;

            }
        case IDC_C:
        case IDC_B:
        case IDC_O:
        case IDC_M:
        case IDC_X:
        case IDC_BTN0:
        case IDC_BTN1: case IDC_BTN2: case IDC_BTN3:
        case IDC_BTN4: case IDC_BTN5: case IDC_BTN6:
        case IDC_BTN7: case IDC_BTN8: case IDC_BTN9:

            _itoa((INT)wParam, rgchNum, 10);
            while (!FAddSymbolValueToSymTab("ButtonPressed", rgchNum))
                if (!FHandleOOM(hdlg))
                    {
                    DestroyWindow(GetParent(hdlg));
                    return(fTrue);
                    }
            SendDlgItemMessage(hdlg, IDC_EDIT1, (WORD)WM_GETTEXT, cchpMax + 1,
                    (LPARAM)rgchText);
            while (!FAddSymbolValueToSymTab("EditTextOut", rgchText))
                if (!FHandleOOM(hdlg))
                    {
                    DestroyWindow(GetParent(hdlg));
                    return(fTrue);
                    }
            PostMessage(GetParent(hdlg), (WORD)STF_UI_EVENT, 0, 0L);
            break;
            }
        break;

    case STF_DESTROY_DLG:
        PostMessage(GetParent(hdlg), (WORD)STF_EDIT_DLG_DESTROYED, 0, 0L);
        DestroyWindow(hdlg);
        return(fTrue);
    }

    return(fFalse);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\dospif.h ===
/***************************************************************************

   This file contains definitions (#define, #typedef, external variable and
   function declarations) used in Windows Setup for setting up DOS PIFs.

   *********  IMPORTANT  **********

   This file contains typedefs and bit masks which were copied from the pif
   editor include files.  Do not change before consulting with pif editor
   sources.

   Copyright (C) Microsoft, 1991

HISTORY:

   Modified by:      Date:       Comment:

   PAK               8/21/91     Created
   SUNILP            2/6/92      Modified, retained just PIF stuff.
                                 Added rgszApp fields ENUM.

***************************************************************************/

/* lengths of certain PIF entries */

#define PIFNAMESIZE        30
#define PIFSTARTLOCSIZE    63
#define PIFDEFPATHSIZE     64
#define PIFPARAMSSIZE      64
#define PIFSHPROGSIZE      64
#define PIFSHDATASIZE      64
#define PIFEXTSIGSIZE      16

/* Miscellaneous defines */

#define LASTHEADERPTR      0xFFFF
#define STDHDRSIG          "MICROSOFT PIFEX"
#define W386HDRSIG         "WINDOWS 386 3.0"
#define W286HDRSIG30       "WINDOWS 286 3.0"
#define DFLT_ICON_FILE     "PROGMAN.EXE"

/* Standard and enhanced modes */

#define MODE_STANDARD   "STANDARD"
#define MODE_ENHANCED   "ENHANCED"


/* String switches used in APPS.INF to set PIF options */

#define GRAF_MULTXT        "gra"
#define COM1               "c1"
#define COM2               "c2"
#define COM3               "c3"
#define COM4               "c4"
#define NO_SCRN_EXCHANGE   "nse"
#define KEYB               "kbd"
#define PREVENT_PROG_SW    "pps"
#define FULL_SCREEN        "fs"
#define WINDOWED_OPT       "win"
#define BACKGROUND         "bgd"
#define EXCLUSIVE          "exc"
#define DETECT_IDLE_TIME   "dit"
#define EMS_LOCKED         "eml"
#define XMS_LOCKED         "xml"
#define USE_HIMEM_AREA     "hma"
#define LOCK_APP_MEM       "lam"
#define LO_RES_GRAPH       "lgr"
#define HI_RES_GRAPH       "hgr"
#define EMULATE_TEXT_MODE  "emt"
#define RETAIN_VIDEO_MEM   "rvm"
#define ALLOW_FAST_PASTE   "afp"
#define ALLOW_CLOSE_ACTIVE "cwa"
#define ALT_SPACE          "asp"
#define ALT_ENTER          "aen"
#define NO_SAVE_SCREEN     "nss"
#define TEXT_OPT           "txt"
#define CLOSE_ON_EXIT      "cwe"
#define ALT_TAB            "ata"
#define ALT_ESC            "aes"
#define CTRL_ESC           "ces"
#define PRSCRN             "psc"
#define ALT_PRSCRN         "aps"

/* Standard and Enhanced section options */

#define UNKNOWN_OPTION     -1
#define PARAMS             1
#define MINCONVMEM         2
#define VIDEOMODE          3
#define XMSMEM             4
#define CHECKBOXES         5
#define EMSMEM             6
#define CONVMEM            7
#define DISPLAY_USAGE      8
#define EXEC_FLAGS         9
#define MULTASK_OPT        10
#define PROC_MEM_FLAGS     11
#define DISP_OPT_VIDEO     12
#define DISP_OPT_PORTS     13
#define DISP_OPT_FLAGS     14
#define OTHER_OPTIONS      15


/* Bit masks for MSFlags field of PIFNEWSTRUCT */

#define GRAPHMASK       0x02
#define TEXTMASK        0xfd
#define PSMASK          0x04
#define SGMASK          0x08
#define EXITMASK        0x10
#define COM2MASK        0x40
#define COM1MASK        0x80

/* Bit masks for behavior field of PIFNEWSTRUCT */

#define KEYMASK         0x10

/* Bit masks for PfW286Flags field of PIF286EXT30 */

#define fALTTABdis286   0x0001
#define fALTESCdis286   0x0002
#define fALTPRTSCdis286 0x0004
#define fPRTSCdis286    0x0008
#define fCTRLESCdis286  0x0010
#define fNoSaveVid286   0x0020
#define fCOM3_286       0x4000
#define fCOM4_286       0x8000

/* Bit masks for PfW386Flags field of PIF386EXT */

#define fEnableClose    0x00000001L
#define fBackground     0x00000002L
#define fExclusive      0x00000004L
#define fFullScrn       0x00000008L
#define fALTTABdis      0x00000020L
#define fALTESCdis      0x00000040L
#define fALTSPACEdis    0x00000080L
#define fALTENTERdis    0x00000100L
#define fALTPRTSCdis    0x00000200L
#define fPRTSCdis       0x00000400L
#define fCTRLESCdis     0x00000800L
#define fPollingDetect  0x00001000L
#define fNoHMA          0x00002000L
#define fHasHotKey      0x00004000L
#define fEMSLocked      0x00008000L
#define fXMSLocked      0x00010000L
#define fINT16Paste     0x00020000L
#define fVMLocked       0x00040000L

/* Bit masks for PfW386Flags2 field of PIF386EXT */

#define fVidTxtEmulate  0x00000001L
#define fVidNoTrpTxt    0x00000002L
#define fVidNoTrpLRGrfx 0x00000004L
#define fVidNoTrpHRGrfx 0x00000008L
#define fVidTextMd      0x00000010L
#define fVidLowRsGrfxMd 0x00000020L
#define fVidHghRsGrfxMd 0x00000040L
#define fVidRetainAllo  0x00000080L


/* PIF Extension Header */
typedef struct {
    char extsig[PIFEXTSIGSIZE];
    WORD extnxthdrfloff;
    WORD extfileoffset;
    WORD extsizebytes;
    } PIFEXTHEADER, *LPPIFEXTHEADER;

/* PIF Structure */
typedef struct {
    char          unknown;
    char          id;
    char          name[PIFNAMESIZE];
    WORD          maxmem;
    WORD          minmem;
    char          startfile[PIFSTARTLOCSIZE];
    char          MSflags;
    char          reserved;
    char          defpath[PIFDEFPATHSIZE];
    char          params[PIFPARAMSSIZE];
    char          screen;
    char          cPages;
    BYTE          lowVector;
    BYTE          highVector;
    char          rows;
    char          cols;
    char          rowoff;
    char          coloff;
    WORD          sysmem;
    char          shprog[PIFSHPROGSIZE];
    char          shdata[PIFSHDATASIZE];
    BYTE          behavior;
    BYTE          sysflags;
    PIFEXTHEADER  stdpifext;
    } PIFNEWSTRUCT, *LPPIFNEWSTRUCT;

/* WINDOWS/286 3.0 PIF Extension */
typedef struct {
    WORD          PfMaxXmsK;
    WORD          PfMinXmsK;
    WORD          PfW286Flags;
    } PIF286EXT30, *LPPIF286EXT30;

/* WINDOWS/386 3.0 PIF Extension */
typedef struct {
    WORD      maxmem;
    WORD      minmem;
    WORD      PfFPriority;
    WORD      PfBPriority;
    WORD      PfMaxEMMK;
    WORD      PfMinEMMK;
    WORD      PfMaxXmsK;
    WORD      PfMinXmsK;
    DWORD     PfW386Flags;
    DWORD     PfW386Flags2;
    WORD      PfHotKeyScan;
    WORD      PfHotKeyShVal;
    WORD      PfHotKeyShMsk;
    BYTE      PfHotKeyVal;
    BYTE      PfHotKeyPad[9];
    char      params[PIFPARAMSSIZE];
    } PIF386EXT, *LPPIF386EXT;

typedef struct {
    PIFNEWSTRUCT DfltPIF;
    PIF286EXT30  DfltStd;
    PIF386EXT    DfltEnha;
    PIFNEWSTRUCT CurrPIF;
    PIFEXTHEADER StdExtHdr;
    PIF286EXT30  CurrStd;
    PIFEXTHEADER EnhaExtHdr;
    PIF386EXT    CurrEnha;
    } PIF386Combined, *LPPIF386Combined;

typedef struct {
    PIFNEWSTRUCT DfltPIF;
    PIF286EXT30  DfltStd;
    PIF386EXT    DfltEnha;
    PIFNEWSTRUCT CurrPIF;
    PIFEXTHEADER StdExtHdr;
    PIF286EXT30  CurrStd;
    } PIF286Combined, *LPPIF286Combined;

#pragma pack(1)
/* PIF Structure */
typedef struct {
    char          unknown;
    char          id;
    char          name[PIFNAMESIZE];
    WORD          maxmem;
    WORD          minmem;
    char          startfile[PIFSTARTLOCSIZE];
    char          MSflags;
    char          reserved;
    char          defpath[PIFDEFPATHSIZE];
    char          params[PIFPARAMSSIZE];
    char          screen;
    char          cPages;
    BYTE          lowVector;
    BYTE          highVector;
    char          rows;
    char          cols;
    char          rowoff;
    char          coloff;
    WORD          sysmem;
    char          shprog[PIFSHPROGSIZE];
    char          shdata[PIFSHDATASIZE];
    BYTE          behavior;
    BYTE          sysflags;
    PIFEXTHEADER  stdpifext;
    } PACKED_PIFNEWSTRUCT, *LPPACKED_PIFNEWSTRUCT;
#pragma pack()

//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in the PIFNEWSTRUCT
//

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

#define CopyUchar1(Dst,Src) {                                \
    ((PUCHAR1)(Dst))->Uchar[0] = ((PUCHAR1)(Src))->Uchar[0]; \
}

#define CopyUchar2(Dst,Src) {                                \
    ((PUCHAR2)(Dst))->Uchar[0] = ((PUCHAR2)(Src))->Uchar[0]; \
    ((PUCHAR2)(Dst))->Uchar[1] = ((PUCHAR2)(Src))->Uchar[1]; \
}

#define CopyUchar4(Dst,Src) {                                \
    ((PUCHAR4)(Dst))->Uchar[0] = ((PUCHAR4)(Src))->Uchar[0]; \
    ((PUCHAR4)(Dst))->Uchar[1] = ((PUCHAR4)(Src))->Uchar[1]; \
    ((PUCHAR4)(Dst))->Uchar[2] = ((PUCHAR4)(Src))->Uchar[2]; \
    ((PUCHAR4)(Dst))->Uchar[3] = ((PUCHAR4)(Src))->Uchar[3]; \
}

#define CopyUcharn(Dst, Src, n) {                            \
    memmove((PVOID)Dst, (PVOID)Src, n);                      \
}


#define PackPif(Pif,PPif) {                                                        \
    CopyUchar1(&((PPif)->unknown)    ,&((Pif)->unknown)                         ); \
    CopyUchar1(&((PPif)->id)         ,&((Pif)->id)                              ); \
    CopyUcharn(&((PPif)->name)       ,&((Pif)->name)      , PIFNAMESIZE         ); \
    CopyUchar2(&((PPif)->maxmem)     ,&((Pif)->maxmem)                          ); \
    CopyUchar2(&((PPif)->minmem)     ,&((Pif)->minmem)                          ); \
    CopyUcharn(&((PPif)->startfile)  ,&((Pif)->startfile) , PIFSTARTLOCSIZE     ); \
    CopyUchar1(&((PPif)->MSflags)    ,&((Pif)->MSflags)                         ); \
    CopyUchar1(&((PPif)->reserved)   ,&((Pif)->reserved)                        ); \
    CopyUcharn(&((PPif)->defpath)    ,&((Pif)->defpath)   , PIFDEFPATHSIZE      ); \
    CopyUcharn(&((PPif)->params)     ,&((Pif)->params)    , PIFPARAMSSIZE       ); \
    CopyUchar1(&((PPif)->screen)     ,&((Pif)->screen)                          ); \
    CopyUchar1(&((PPif)->cPages)     ,&((Pif)->cPages)                          ); \
    CopyUchar1(&((PPif)->lowVector)  ,&((Pif)->lowVector)                       ); \
    CopyUchar1(&((PPif)->highVector) ,&((Pif)->highVector)                      ); \
    CopyUchar1(&((PPif)->rows)       ,&((Pif)->rows)                            ); \
    CopyUchar1(&((PPif)->cols)       ,&((Pif)->cols)                            ); \
    CopyUchar1(&((PPif)->rowoff)     ,&((Pif)->rowoff)                          ); \
    CopyUchar1(&((PPif)->coloff)     ,&((Pif)->coloff)                          ); \
    CopyUchar2(&((PPif)->sysmem)     ,&((Pif)->sysmem)                          ); \
    CopyUcharn(&((PPif)->shprog)     ,&((Pif)->shprog)    , PIFSHPROGSIZE       ); \
    CopyUcharn(&((PPif)->shdata)     ,&((Pif)->shdata)    , PIFSHDATASIZE       ); \
    CopyUchar1(&((PPif)->behavior)   ,&((Pif)->behavior)                        ); \
    CopyUchar1(&((PPif)->sysflags)   ,&((Pif)->sysflags)                        ); \
    CopyUcharn(&((PPif)->stdpifext)  ,&((Pif)->stdpifext) , sizeof(PIFEXTHEADER));  \
}


enum tagAppRgszFields {
    nEXETYPE,
    nNAME,
    nEXE,
    nDIR,
    nPIF,
    nDEFDIR,
    nCWE,
    nSTDOPT,
    nENHOPT,
    nICOFIL,
    nICONUM
    };

typedef enum {
    ADDAPP_SUCCESS,
    ADDAPP_GENFAIL,
    ADDAPP_GRPFAIL
    } ADDAPP_STATUS;

/* Make New Long Pointer MACRO */
#define MKNLP(lp,w) (LONG)((DWORD)lp + (DWORD)w)

/* DOS PIF INTERNAL ROUTINE DECLARATIONS */

ADDAPP_STATUS
AddDosAppItem(
    IN RGSZ rgszApp,
    IN SZ   szPifDir,
    IN SZ   szGroup
    );

ADDAPP_STATUS
AddWinItem(
    IN RGSZ rgszApp,
    IN SZ   szGroup
    );


BOOL
FDeterminePIFName(
    IN     RGSZ rgszApp,
    IN     SZ   szPifDir,
    IN OUT SZ   szPIFPath
    );

BOOL
FCreatePIF(
    RGSZ  rgszApp,
    SZ    szPIFPath
    );

VOID
ProcessCommonInfo(
    RGSZ rgszApp,
    LPPIFNEWSTRUCT fpPNS
    );

BOOL
FProcessStdModeInfo(
    SZ szStdOptions,
    LPPIFNEWSTRUCT fpPNS,
    LPPIF286EXT30 fpPStd
    );

VOID
ProcessCheckBoxSwitches(
    RGSZ rgsz,
    LPPIFNEWSTRUCT fpPNS,
    LPPIF286EXT30 fpPStd
    );

BOOL
FProcessEnhaModeInfo(
    SZ szEnhOptions,
    LPPIF386EXT fpPEnha
    );

INT
GetExtOption(
    LPSTR lpsz
    );

BOOL
FInitializePIFStructs(
    BOOL bIsEnhanced,
    SZ   szDfltStdOpt,
    SZ   szDfltEnhOpt
    );

VOID
FreePIFStructs(
    VOID
    );

VOID
ExtractStrFromPIF(
    LPSTR lpsz,
    int n
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\err_32.c ===
#include "precomp.h"
#pragma hdrstop
/***************************************************************************/
/***** Common Library Component - File Management - 1 **********************/
/***************************************************************************/


INT_PTR APIENTRY ErrDlgProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);



/*
**      Purpose:
**              Sets Silent Mode.
**      Arguments:
**              fMode: new setting for Silent Mode.
**      Returns:
**              The old mode setting.
*/
BOOL  APIENTRY FSetSilent(fMode)
BOOL fMode;
{
        BOOL fOld = fSilentSystem;

        fSilentSystem = fMode;

        return(fOld);
}


/*
**      Purpose:
**              Gets current Silent Mode.
**      Arguments:
**              none.
**      Returns:
**              The current mode setting.
*/
BOOL  APIENTRY FGetSilent(VOID)
{
        return(fSilentSystem);
}


typedef struct tagETABELEM {
#if DBG
    unsigned    ArgumentCount;
    GRC         GRC;
#endif
    WORD        ResourceID;
    BOOL        ForceNonCritical;
}   ETABELEM;

#if DBG
#define ETABLE_ELEM(grc,ResID,cArgs,f)    { cArgs,grc,ResID,f }
#else
#define ETABLE_ELEM(grc,ResID,cArgs,f)    { ResID,f }
#endif

// keep the following table in sync with shellrc.rc (esp. arg counts)

ETABELEM ErrorTable[] = {

//                 |error code being     |resource ID for text    |required # of  |whether to force
//                 |reported to the      |that comprises the      |supplemental   |non-critical err
//                 |error handler        |sprintf format string   |text strings   |
//                 |                     |for this error          |for insertion  |
//                 |                     |                        |into message   |

        ETABLE_ELEM(grcOkay                ,0                              ,0     ,FALSE),
        ETABLE_ELEM(grcNotOkay             ,0                              ,0     ,FALSE),
        ETABLE_ELEM(grcOutOfMemory         ,IDS_ERROR_OOM                  ,0     ,FALSE),
        ETABLE_ELEM(grcInvalidStruct       ,0                              ,0     ,FALSE),
        ETABLE_ELEM(grcOpenFileErr         ,IDS_ERROR_OPENFILE             ,1     ,TRUE ),
        ETABLE_ELEM(grcCreateFileErr       ,IDS_ERROR_CREATEFILE           ,1     ,TRUE ),
        ETABLE_ELEM(grcReadFileErr         ,IDS_ERROR_READFILE             ,1     ,TRUE ),
        ETABLE_ELEM(grcWriteFileErr        ,IDS_ERROR_WRITEFILE            ,1     ,TRUE ),
        ETABLE_ELEM(grcRemoveFileErr       ,IDS_ERROR_REMOVEFILE           ,1     ,TRUE ),
        ETABLE_ELEM(grcRenameFileErr       ,IDS_ERROR_RENAMEFILE           ,2     ,TRUE ),
        ETABLE_ELEM(grcReadDiskErr         ,IDS_ERROR_READDISK             ,1     ,TRUE ),
        ETABLE_ELEM(grcCreateDirErr        ,IDS_ERROR_CREATEDIR            ,1     ,TRUE ),
        ETABLE_ELEM(grcRemoveDirErr        ,IDS_ERROR_REMOVEDIR            ,1     ,TRUE ),
        ETABLE_ELEM(grcBadINF              ,IDS_ERROR_GENERALINF           ,1     ,FALSE),
        ETABLE_ELEM(grcINFBadSectionLabel  ,IDS_ERROR_INFBADSECTION        ,1     ,FALSE),
        ETABLE_ELEM(grcINFBadLine          ,IDS_ERROR_INFBADLINE           ,1     ,FALSE),
        ETABLE_ELEM(grcINFBadKey           ,IDS_ERROR_GENERALINF           ,1     ,FALSE),
        ETABLE_ELEM(grcCloseFileErr        ,IDS_ERROR_CLOSEFILE            ,1     ,TRUE ),
        ETABLE_ELEM(grcChangeDirErr        ,IDS_ERROR_CHANGEDIR            ,1     ,TRUE ),
        ETABLE_ELEM(grcINFSrcDescrSect     ,IDS_ERROR_INFSMDSECT           ,1     ,FALSE),
        ETABLE_ELEM(grcTooManyINFKeys      ,IDS_ERROR_INFXKEYS             ,1     ,FALSE),
        ETABLE_ELEM(grcWriteInf            ,IDS_ERROR_WRITEINF             ,1     ,FALSE),
        ETABLE_ELEM(grcInvalidPoer         ,IDS_ERROR_INVALIDPOER          ,0     ,FALSE),
        ETABLE_ELEM(grcINFMissingLine      ,IDS_ERROR_INFMISSINGLINE       ,2     ,FALSE),
        ETABLE_ELEM(grcINFBadFDLine        ,IDS_ERROR_INFBADFDLINE         ,2     ,FALSE),
        ETABLE_ELEM(grcINFBadRSLine        ,IDS_ERROR_INFBADRSLINE         ,0     ,FALSE),
        ETABLE_ELEM(grcInvalidPathErr      ,IDS_ERROR_INVALIDPATH          ,2     ,TRUE ),
        ETABLE_ELEM(grcWriteIniValueErr    ,IDS_ERROR_WRITEINIVALUE        ,3     ,TRUE ),
        ETABLE_ELEM(grcReplaceIniValueErr  ,IDS_ERROR_REPLACEINIVALUE      ,3     ,TRUE ),
        ETABLE_ELEM(grcIniValueTooLongErr  ,IDS_ERROR_INIVALUETOOLONG      ,0     ,TRUE ),
        ETABLE_ELEM(grcDDEInitErr          ,IDS_ERROR_DDEINIT              ,0     ,TRUE ),
        ETABLE_ELEM(grcDDEExecErr          ,IDS_ERROR_DDEEXEC              ,1     ,TRUE ),
        ETABLE_ELEM(grcBadWinExeFileFormatErr,IDS_ERROR_BADWINEXEFILEFORMAT,1     ,TRUE ),
        ETABLE_ELEM(grcResourceTooLongErr  ,IDS_ERROR_RESOURCETOOLONG      ,1     ,TRUE ),
        ETABLE_ELEM(grcMissingSysIniSectionErr,IDS_ERROR_MISSINGSYSINISECTION,2   ,TRUE ),
        ETABLE_ELEM(grcDecompGenericErr    ,IDS_ERROR_DECOMPGENERIC        ,1     ,TRUE ),
        ETABLE_ELEM(grcDecompUnknownAlgErr ,IDS_ERROR_DECOMPUNKNOWNALG     ,2     ,TRUE ),
        ETABLE_ELEM(grcMissingResourceErr  ,IDS_ERROR_MISSINGRESOURCE      ,1     ,TRUE ),
        ETABLE_ELEM(grcLibraryLoadErr      ,IDS_ERROR_LOADLIBRARY          ,1     ,TRUE ),
        ETABLE_ELEM(grcBadLibEntry         ,IDS_ERROR_BADLIBENTRY          ,1     ,TRUE ),
        ETABLE_ELEM(grcApplet              ,IDS_ERROR_INVOKEAPPLET         ,1     ,TRUE ),
        ETABLE_ELEM(grcExternal            ,IDS_ERROR_EXTERNALERROR        ,2     ,TRUE ),
        ETABLE_ELEM(grcSpawn               ,IDS_ERROR_SPAWN                ,1     ,TRUE ),
        ETABLE_ELEM(grcDiskFull            ,IDS_ERROR_DISKFULL             ,0     ,TRUE ),
        ETABLE_ELEM(grcDDEAddItem          ,IDS_ERROR_DDEADDITEM           ,2     ,TRUE ),
        ETABLE_ELEM(grcDDERemoveItem       ,IDS_ERROR_DDEREMOVEITEM        ,2     ,TRUE ),
        ETABLE_ELEM(grcINFMissingSection   ,IDS_ERROR_INFMISSINGSECT       ,2     ,FALSE),
        ETABLE_ELEM(grcRunTimeParseErr     ,IDS_ERROR_RUNTIMEPARSE         ,2     ,FALSE),
        ETABLE_ELEM(grcOpenSameFileErr     ,IDS_ERROR_OPENSAMEFILE         ,1     ,TRUE ),
        ETABLE_ELEM(grcGetVolInfo          ,IDS_ERROR_GETVOLINFO           ,2     ,TRUE ),
        ETABLE_ELEM(grcGetFileSecurity     ,IDS_ERROR_GETFILESECURITY      ,1     ,TRUE ),
        ETABLE_ELEM(grcSetFileSecurity     ,IDS_ERROR_SETFILESECURITY      ,1     ,TRUE ),
        ETABLE_ELEM(grcVerifyFileErr       ,IDS_ERROR_VERIFYFILE           ,1     ,TRUE )
};


/*
**      Purpose:
**              Handles an Out Of Memory Error.
**      Arguments:
**              hwndParent: handle to window to pass to message boxes.
**      Returns:
**              fTrue if the user pressed RETRY (eg thinks it was handled).
**              fFalse if it could not be handled or the user pressed ABORT.
*/
BOOL  APIENTRY FHandleOOM(hwndParent)
HWND hwndParent;
{
        return(EercErrorHandler(hwndParent, grcOutOfMemory, fTrue, 0, 0, 0) ==
                        eercRetry);
}


/*
**      Purpose:
**              Handles an error by using a message box.  grcNotOkay is too
**              general and never produces a MessageBox, but returns either
**              eercAbort or eercIgnore depending on fCritical.
**      Arguments:
**              hwndParent:    handle to window to pass to message boxes.
**              grc:           type of error to handle (cannot be grcOkay).
**              fCritical:     whether the failed operation can be ignored.
**              sz1, sz2, sz3: supplemental information to display in MessageBox.
**                      case grcOutOfMemory:        none
**                      case grcOpenFileErr:        sz1 = filename
**                      case grcCreateFileErr:      sz1 = filename
**                      case grcReadFileErr:        sz1 = filename
**                      case grcWriteFileErr:       sz1 = filename
**                      case grcRemoveFileErr:      sz1 = filename
**                      case grcRenameFileErr:      sz1 = old filename, sz2 = new filename
**                      case grcReadDiskErr:        sz1 = disk
**                      case grcCreateDirErr:       sz1 = dirname
**                      case grcRemoveDirErr:       sz1 = dirname
**                      case grcBadINF:             sz1 = INF filename
**          case grcINFBadKey:          sz1 = INF filename
**                      case grcINFBadSectionLabel: sz1 = INF filename
**          case grcINFBadLine:         sz1 = INF filename
**          case grcTooManyINFKeys:     sz1 = INF filename
**                      case grcINFSrcDescrSect:    sz1 = INF filename
**          case grcWriteInf:           sz1 = INF filename
**          case grcInvalidPoer:        none
**          case grcINFMissingLine:     sz1 = INF filename  , sz2 = INF Section
**          case grcINFMissingSection:  sz1 = INF filename  , sz2 = INF Section
**          case grcINFBadFDLine:       sz1 = INF filename  , sz2 = INF Section
**          case grcLibraryLoadErr:     sz1 = library pathname
**          case grcBadLibEntry:        sz1 = entry point name
**          case grcApplet:             sz1 = library pathname
**          case grcExternal:           sz1 = entry point, sz2 = text returned from dll
**          case grcRunTimeParseErr:    sz1 = INF filename  , sz2 = INF Line
**          case grcOpenSameFileErr:    sz1 = INF filename
**      Notes:
**              Action depends on the the global variable fSilentSystem.
**      Returns:
**              eercAbort if the caller should abort its execution.
**              eercRetry if the caller should retry the operation.
**              eercIgnore if the caller should fail this non-critical operation
**                      but continue with the next.
**
***************************************************************************/
EERC __cdecl EercErrorHandler(HWND hwndParent,GRC grc,BOOL fCritical,...)
{
    EERC eerc;
    SZ   szMessage = NULL;
    INT_PTR  intRet;
    SZ   szTemplate,
         szCritErrTemplate,
         szNonCritErrTemplate ;
    va_list arglist;
#if DBG
    unsigned arg;
#endif
    CHP  rgchBufTmpLong[256];
    HWND aw;

    //
    // Get rid of annoying critical errors
    //
    if(ErrorTable[grc].ForceNonCritical) {
        fCritical = FALSE;
    }
    szTemplate = fCritical ? "CritErr" : "NonCritErr";
    eerc = fCritical ? eercAbort : eercIgnore;

    //
    //  See if there are non-empty global overrides to the standard
    //  error dialog templates.
    //

    szCritErrTemplate    = SzFindSymbolValueInSymTab("!STF_TEMPLATE_CRITERR");
    szNonCritErrTemplate = SzFindSymbolValueInSymTab("!STF_TEMPLATE_NONCRITERR");

    if ( fCritical && szCritErrTemplate && strlen( szCritErrTemplate ) )
    {
        szTemplate = szCritErrTemplate ;
    }
    else
    if ( ! fCritical && szNonCritErrTemplate && strlen( szNonCritErrTemplate ) )
    {
        szTemplate = szNonCritErrTemplate ;
    }

    Assert(grc <= grcLast);
    Assert((grc != grcOkay) && (grc != grcInvalidStruct));

    if (fSilentSystem || grc == grcNotOkay || grc == grcCloseFileErr) {
        return(eerc);
    }

    if (grc != grcOutOfMemory) {

        while ((szMessage = (SZ)SAlloc((CB)1024)) == (SZ)NULL) {
            if (EercErrorHandler(hwndParent, grcOutOfMemory, fTrue, 0, 0, 0)
                                        == eercAbort) {
                return(eerc);  /* REVIEW eercAbort? */
            }
            *szMessage = '\0';
        }
    }


    // debug sanity checks.

    Assert(ErrorTable[grc].GRC == grc);
    Assert(ErrorTable[grc].ResourceID);     // otherwise the error should have
                                            // been handled by code above

    EvalAssert(LoadString(hInst,ErrorTable[grc].ResourceID,rgchBufTmpLong,255));
    if(grc == grcOutOfMemory) {
        szMessage = rgchBufTmpLong;
    } else {
        va_start(arglist,fCritical);
#if DBG
        for(arg=0; arg<ErrorTable[grc].ArgumentCount; arg++) {
            ChkArg(va_arg(arglist,SZ) != NULL, (USHORT)(3+arg), eerc);
        }
        va_start(arglist,fCritical);
#endif
        wvsprintf(szMessage,rgchBufTmpLong,arglist);
        va_end(arglist);
    }

    AssertRet(szMessage != (SZ)NULL, eerc);

    MessageBeep(0);

    //
    // Make sure setup / active dialog in setup is in the foreground
    //

    aw = GetLastActivePopup( hWndShell );
    if ( aw == NULL ) {
        aw = hWndShell;
    }
    SetForegroundWindow( aw );

    //
    // Put up the error dialog box
    //
    if(aw == hWndShell) {
        ShowOwnedPopups(aw,FALSE);
    }

    if((intRet = DialogBoxParam(hInst,(LPCSTR)szTemplate, aw,(DLGPROC)ErrDlgProc,(LPARAM)szMessage)) == -1) {
        LoadString(hInst,IDS_ERROR_OOM,rgchBufTmpLong,255);
        LoadString(hInst,IDS_ERROR_DIALOGCAPTION,rgchBufTmpShort,63);
        MessageBox(aw, rgchBufTmpLong, rgchBufTmpShort,
                                MB_ICONHAND | MB_SYSTEMMODAL);
        if (grc != grcOutOfMemory) {
            SFree(szMessage);
        }
        if(aw == hWndShell) {
            ShowOwnedPopups(aw,TRUE);
        }
        return(eerc);
    } else {
        if(aw == hWndShell) {
            ShowOwnedPopups(aw,TRUE);
        }
    }

    if (intRet == IDIGNORE) {
        AssertRet(!fCritical, eercAbort);
                eerc = eercIgnore;
    } else if (intRet == IDRETRY) {
                eerc = eercRetry;
    } else {
        SendMessage(hWndShell,(WORD)STF_ERROR_ABORT,0,0);
        eerc = eercAbort;
    }

    if (grc != grcOutOfMemory) {
        SFree(szMessage);
    }

    return(eerc);
}


INT_PTR APIENTRY ErrDlgProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    int i;

    switch(message) {

    case WM_INITDIALOG:
        FCenterDialogOnDesktop(hDlg);
        SetDlgItemText(hDlg,IDC_TEXT1,(SZ)lParam);
        return(TRUE);

    case WM_CLOSE:
        PostMessage(
            hDlg,
            WM_COMMAND,
            MAKELONG(IDC_X, BN_CLICKED),
            0L
            );
        return(TRUE);

    case WM_COMMAND:
        switch(LOWORD(wParam)) {
        case IDC_R:      // retry
            EndDialog(hDlg,IDRETRY);
            return(TRUE);
        case IDC_X:      // exit setup
            EvalAssert(LoadString(hInst, IDS_ERROR_DIALOGCAPTION, rgchBufTmpShort,
                    cchpBufTmpShortMax));
            EvalAssert(LoadString(hInst, IDS_NOTDONE, rgchBufTmpLong,
                    cchpBufTmpLongMax));
            i = MessageBox(hDlg, rgchBufTmpLong, rgchBufTmpShort,
                           MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION | MB_APPLMODAL);
            if ( i == IDYES ) {
                EndDialog(hDlg,IDABORT);
            }
            return(TRUE);
        case IDC_C:      // ignore
            EndDialog(hDlg,IDIGNORE);
            return(TRUE);
        }
        break;
    }
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\extprog.c ===
#include "precomp.h"
#pragma hdrstop
extern HWND hwndFrame;
extern HANDLE hinstShell;
extern BOOL FYield(VOID);

BOOL WaitingOnChild = FALSE;

/*
    Code to support RunExternalProgram, InvokeLibraryProcedure install commands

    LoadLibrary          <diskname>,<libraryname>,<INFvar-for-handle>
    FreeLibrary          <libhandle>
    LibraryProcedure     <infvar>,<libhandle>,<entrypoint>[,<arg>]*
    RunProgram           <var>,<diskname>,<libhandle>,<programfile>[,<arg>]*
    StartDetachedProcess <var>,<diskname>,<libhandle>,<programfile>[,<arg>]*
    InvokeApplet         <libraryname>
*/

#define NO_RETURN_VALUE  (-1)
#define HANDLER_ENTRY    "RegHandler"

typedef enum {
    PRESENT,
    NOT_PRESENT,
    NOT_PRESENT_IGNORE
} PRESENCE;

typedef BOOL (*PFNICMD)(DWORD, RGSZ, LPSTR*);

/*
 *  MakeSureDiskIsAvailable
 *
 *  Given a fully qualified pathname, prompt the user to put the named
 *  disk into the drive specified in the pathname.  If the disk is not
 *  removable, instead flash an error to let the user retry.
 *
 *  Arguments:
 *
 *  Diskname    -   name of disk to prompt for (literal string)
 *  File        -   fully qualified filename of file to make present
 *  fVital      -   whether non-presence of file is critical
 *
 *  returns:  PRESENT            if File is now accessible
 *            NOT_PRESENT        if not (ie, user CANCELed at error popup)
 *            NOT_PRESENT_IGNORE if user IGNOREd error
 *
 */

PRESENCE MakeSureFileIsAvailable(SZ DiskName,SZ File,BOOL fVital)
{
    UINT  DriveType;
    EERC eerc;
    char disk[4];

    disk[0] = *File;
    disk[1] = ':';
    disk[2] = '\\';
    disk[3] = 0;

    DriveType = GetDriveType(disk);
    disk[2] = 0;

    while(!FFileFound(File)) {

        if((DriveType == DRIVE_REMOVABLE) || (DriveType == DRIVE_CDROM)) {
            if(!FPromptForDisk(hinstShell,DiskName,disk)) {
                return(NOT_PRESENT);                   // user canceled
            }
        } else if((eerc = EercErrorHandler(hwndFrame,grcOpenFileErr,fVital,File))
                       != eercRetry)
        {
            return((eerc == eercIgnore)
                  ? NOT_PRESENT_IGNORE
                  : NOT_PRESENT);
        }
    }
    return(PRESENT);
}


/*
 *  FLoadLibrary
 *
 *  Load a fully-qualified library and place the handle in an INF var.
 *
 *  Arguments:
 *
 *  DiskName    -   name of disk to prompt for
 *  File        -   fully qualified filename of dll to load
 *  LibHandle   -   INF var that gets library's handle
 *
 *  returns:  TRUE/FALSE.  If FALSE, user ABORTED from an error dialog.
 *                         If TRUE, library is loaded.
 */

BOOL FLoadLibrary(SZ DiskName,SZ File,SZ INFVar)
{
    HANDLE LibraryHandle;
    char   LibraryHandleSTR[25];

    if(!DiskName || !File) {
        return(FALSE);
    }

    if(MakeSureFileIsAvailable(DiskName,File,TRUE) != PRESENT) {
        return(FALSE);          // not possible to ignore
    }
    while((LibraryHandle = LoadLibrary(File)) == NULL)
    {
        switch(EercErrorHandler(hwndFrame,grcLibraryLoadErr,fTrue,File)) {
        case eercRetry:
            break;
        case eercAbort:
            return(FALSE);
#if DBG
        case eercIgnore:        // illegal because error is critical
        default:                // bogus return value
            Assert(0);
#endif
        }
    }
    LibraryHandleSTR[0] = '|';

    if (!LibraryHandle) {
       return(FALSE);
    }

#if defined(_WIN64)
    _ui64toa((DWORD_PTR)LibraryHandle,LibraryHandleSTR+1,20);
#else
    _ultoa((DWORD)LibraryHandle,LibraryHandleSTR+1,10);
#endif

    if(INFVar) {
        while(!FAddSymbolValueToSymTab(INFVar,LibraryHandleSTR)) {
            if(!FHandleOOM(hwndFrame)) {
                FreeLibrary(LibraryHandle);
                return(FALSE);
            }
        }
    }
    return(TRUE);
}


/*
 *  FFreeLibrary
 *
 *  Free a library given its handle.
 *
 *  Arguments:
 *
 *  Hnadle - dle
 *
 *  returns: TRUE
 *
 */

BOOL FFreeLibrary(SZ Handle)
{
    char buff1[100],buff2[100],buff3[500];
    HANDLE hMod;

    Assert(Handle);

    //
    // Prevent an INF from errantly unloading the interpreter!
    //
    hMod = LongToHandle(atol(Handle+1));
    if(hMod == MyDllModuleHandle) {
        return(TRUE);
    }

    if(!FreeLibrary(hMod)) {

        LoadString(hinstShell,IDS_SETUP_WARNING,buff1,sizeof(buff1)-1);
        LoadString(hinstShell,IDS_BAD_LIB_HANDLE,buff2,sizeof(buff2)-1);
        wsprintf(buff3,buff2,Handle+1);
        MessBoxSzSz(buff1,buff3);
    }
    return(TRUE);
}


/*
 * FLibraryProcedure
 *
 * Arguments:   INFVar - variable to get string result of callout
 *
 *              HandleVar - library's handle
 *
 *              EntryPoint - name of routine in library to be called
 *
 *              Args - argv to be passed to the routine.  The vector must
 *                     be terminated with a NULL entry.
 *
 */

BOOL APIENTRY FLibraryProcedure(SZ INFVar,SZ Handle,SZ EntryPoint,RGSZ Args)
{
    DWORD  cArgs;
    HANDLE LibraryHandle;
    PFNICMD Proc;
    LPSTR  TextOut;
    BOOL   rc = FALSE;
    EERC   eerc;
    SZ     szErrCtl ;

    LibraryHandle = LongToHandle(atol(Handle+1));

    while((Proc = (PFNICMD)GetProcAddress(LibraryHandle,EntryPoint)) == NULL) {
        if((eerc = EercErrorHandler(hwndFrame,grcBadLibEntry,FALSE,EntryPoint))
           == eercAbort)
        {
            return(FALSE);
        } else if(eerc == eercIgnore) {
            goto FLP;
        }
        Assert(eerc == eercRetry);
    }

    for(cArgs = 0; Args[cArgs]; cArgs++);       // count arguments

    while(!(rc = Proc(cArgs,Args,&TextOut))) {

        //  If the symbol "FLibraryErrCtl" is found and its value is non-zero,
        //  the INF file will handle all error conditions.

        if ( (szErrCtl = SzFindSymbolValueInSymTab("FLibraryErrCtl"))
              && atoi(szErrCtl) > 0  )
        {
           rc = 1 ;
           break ;
        }

        if((eerc = EercErrorHandler(hwndFrame,grcExternal,FALSE,EntryPoint,TextOut)) == eercAbort) {
            return(FALSE);
        } else if(eerc == eercIgnore) {
            break;
        }
        Assert(eerc == eercRetry);
    }

    FLP:
    if((INFVar != NULL) && (*INFVar != '\0')) {
        FAddSymbolValueToSymTab(INFVar,rc ? TextOut : "ERROR");
    }

    return(TRUE);
}


/*
 * FRunProgram
 *
 * Arguments:   INFVar - an INF variable which will get the rc of the
 *                       exec'ed program.
 *
 *              DiskName - string used in prompting the user to insert
 *                         a disk
 *
 *              ProgramFile - qualified name of program to be run
 *
 *              Args - argv to be passed directly to spawn (so must
 *                     include argv[0] filled in).
 *
 */

BOOL APIENTRY FRunProgram(SZ   INFVar,
                          SZ   DiskName,
                          SZ   LibHand,
                          SZ   ProgramFile,
                          RGSZ Args)
{
    char    Number[15];
    DWORD   rc;
    HANDLE  ProcID = NULL;
    EERC    eerc;
    MSG     msg;
    int     iWaitState = P_NOWAIT;
    SZ      szWaitState;

    switch(MakeSureFileIsAvailable(DiskName,ProgramFile,FALSE)) {
    case PRESENT:
        break;
    case NOT_PRESENT:
        return(fFalse);
    case NOT_PRESENT_IGNORE:
        goto FRP;
#if DBG
    default:
        Assert(0);      // illegal PRESENCE value
#endif
    }

    if((LibHand != NULL) && (*LibHand != '\0')) {
        SetSupportLibHandle(LongToHandle(atol(LibHand+1)));     // skip the leading |
    }

    WaitingOnChild = TRUE;

    if ( (szWaitState = SzFindSymbolValueInSymTab("FWaitForProcess"))
              && atoi(szWaitState) > 0  )
    {
        iWaitState = P_WAIT;
        rc=(DWORD)_spawnv(iWaitState,ProgramFile,Args);
    } else
    {
        while((ProcID=(HANDLE)_spawnv(iWaitState,ProgramFile,Args)) == (HANDLE)(-1)) {
            if((eerc = EercErrorHandler(hwndFrame,
                                    grcSpawn,
                                    FALSE,
                                    ProgramFile)
                ) == eercAbort
            )
            {
                WaitingOnChild = FALSE;
                return(FALSE);
            } else if(eerc == eercIgnore) {
                goto FRP;
            }
            Assert(eerc == eercRetry);
        }

        while(WaitForSingleObject(ProcID,350)) {
            FYield();
        }
    }

    //
    // Process any pending messages so the user can do stuff like move the
    // gauge around the screen if he wants to.
    //

    while(PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
        DispatchMessage(&msg);
    }

    FRP:
    WaitingOnChild = FALSE;
    if((INFVar != NULL) && (*INFVar != '\0')) {
        FAddSymbolValueToSymTab(INFVar,
                                ((szWaitState != NULL ) && (atoi(szWaitState)>0)) ? _itoa(rc,Number,10):
                                (GetExitCodeProcess(ProcID,&rc) ? _itoa(rc,
                                                                      Number,
                                                                      10
                                                                     )
                                                               : "ERROR")
                               );
    }

    CloseHandle(ProcID);

    SetForegroundWindow(hwndFrame);     // reactivate ourselves

    return(fTrue);
}



/*
 * FStartDetachedProcess
 *
 * Arguments:   INFVar - an INF variable which will get the rc of the
 *                       exec'ed program.
 *
 *              DiskName - string used in prompting the user to insert
 *                         a disk
 *
 *              ProgramFile - qualified name of program to be run
 *
 *              Args - argv to be passed directly to spawn (so must
 *                     include argv[0] filled in).
 *
 */

BOOL APIENTRY
FStartDetachedProcess(
    SZ   INFVar,
    SZ   DiskName,
    SZ   LibHand,
    SZ   ProgramFile,
    RGSZ Args
    )
{
    CHAR    Number[15];
    CHAR    App[MAX_PATH];
    DWORD   rc;
    HANDLE  ProcID = NULL;
    EERC    eerc;
    BOOL    Status = FALSE;
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    INT     i;

    //
    // Make sure the file is available, prompt the user if necessary
    //

    switch(MakeSureFileIsAvailable(DiskName,ProgramFile,FALSE)) {
    case PRESENT:
        break;
    case NOT_PRESENT:
        return(fFalse);
    case NOT_PRESENT_IGNORE:
        goto FRP;
#if DBG
    default:
        Assert(0);      // illegal PRESENCE value
#endif
    }

    if((LibHand != NULL) && (*LibHand != '\0')) {
        SetSupportLibHandle(LongToHandle(atol(LibHand+1)));     // skip the leading |
    }

    //
    // Initialise Startup info
    //

    si.cb           = sizeof(STARTUPINFO);
    si.lpReserved   = NULL;
    si.lpDesktop    = NULL;
    si.lpDesktop    = NULL;
    si.lpTitle      = NULL;
    si.dwX = si.dwY = si.dwXSize = si.dwYSize = si.dwFlags = 0L;
    si.wShowWindow  = 0;
    si.lpReserved2  = NULL;
    si.cbReserved2  = 0;

    //
    // Create the app command line
    //

    *App = '\0';
    for(i = 0; Args[i]; i++){
        lstrcat( App, Args[i] );
        lstrcat( App, " " );
    }


    //
    // Use Create Process to create a detached process
    //

    while (!CreateProcess(
                (LPSTR)NULL,                  // lpApplicationName
                App,                          // lpCommandLine
                (LPSECURITY_ATTRIBUTES)NULL,  // lpProcessAttributes
                (LPSECURITY_ATTRIBUTES)NULL,  // lpThreadAttributes
                FALSE,                        // bInheritHandles
                DETACHED_PROCESS,             // dwCreationFlags
                (LPVOID)NULL,                 // lpEnvironment
                (LPSTR)NULL,                  // lpCurrentDirectory
                (LPSTARTUPINFO)&si,           // lpStartupInfo
                (LPPROCESS_INFORMATION)&pi    // lpProcessInformation
                )) {


        if((eerc = EercErrorHandler(hwndFrame,grcSpawn,FALSE,ProgramFile)
           ) == eercAbort){
            return(FALSE);
        } else if(eerc == eercIgnore) {
            goto FRP;
        }

        Assert(eerc == eercRetry);
    }

    Status = TRUE;

    //
    // Since we are execing a detached process we don't care about when it
    // exits.  To do proper book keeping, we should close the handles to
    // the process handle and thread handle
    //

    CloseHandle( pi.hThread );
    CloseHandle( pi.hProcess );

FRP:
    if((INFVar != NULL) && (*INFVar != '\0')) {
        FAddSymbolValueToSymTab(
            INFVar,
            Status ? _itoa(0, Number, 10) : "ERROR"
            );
    }

    CloseHandle(ProcID);
    return(fTrue);
}


PRESENCE SendMessageToApplet(PROC Proc,HWND hwnd,DWORD msg,LONG p1,LONG p2,LONG rcDesired,SZ Libname)
{
#if 0
    LONG    rcActual;

    rcActual = Proc(hwnd,msg,p1,p2);

    if((rcDesired == NO_RETURN_VALUE) || (rcActual == rcDesired)) {
        return(PRESENT);
    }

    while(Proc(hwnd,msg,p1,p2) != rcDesired) {
        switch(EercErrorHandler(hwndFrame, grcApplet,fFalse,Libname,NULL,NULL)) {
        case eercRetry:
            break;
        case eercIgnore:
            return(NOT_PRESENT_IGNORE);
        case eercAbort:
            return(NOT_PRESENT);
#if DBG
        default:
            Assert(0);          // illegal case
#endif
        }
    }
    return(PRESENT);
#else
    Unused(Proc);
    Unused(hwnd);
    Unused(msg);
    Unused(p1);
    Unused(p2);
    Unused(rcDesired);
    Unused(Libname);
    return(NOT_PRESENT);
#endif
}


/*
 * FInvokeApplet
 *
 * Arguments:   LibraryFile - qualified name of library to load
 *
 *              Args - argv to be passed to the routine. The vector must
 *                     be terminated with a NULL entry.
 *
 */

// BUGBUG -- also need some way to specify the sub-handler

BOOL APIENTRY FInvokeApplet(SZ LibraryFile)
{
#if 0
    HANDLE   LibraryHandle;
    PROC     Proc;
    CFGINFO  cfginfo;
    PRESENCE p;

    switch(FLoadLibrary(LibraryFile,HANDLER_ENTRY,&LibraryHandle,&Proc)) {
    case PRESENT:
        break;
    case NOT_PRESENT:
        return(fFalse);         // user wants to exit setup
    case NOT_PRESENT_IGNORE:
        return(fTrue);
#if DBG
    default:
        Assert(0);      // illegal PRESENCE value
#endif
    }

    if((p = SendMessageToApplet(Proc,hwndFrame,CFG_INIT,0,0,TRUE)) == PRESENT) {

        if((p = SendMessageToApplet(Proc,
                                    hwndFrame,
                                    CFG_INQUIRE,
                                    subhandler#,
                                    &cfginfo,
                                    TRUE,
                                    LibraryFile)) == PRESENT)
        {
            SendMessageToApplet(Proc,
                                hwndFrame,
                                CFG_DBLCLK,
                                registry handle,
                                cfginfo.lData,
                                -1,
                                LibraryFile);

            // it's activated -- now what?

            SendMessageToApplet(Proc,
                                hwndFrame,
                                CFG_STOP,
                                subhandler#,
                                cfginfo.lData,
                                -1,
                                LibraryFile);

            SendMessageToApplet(Proc,hwndFrame,CFG_EXIT,0,0,-1,LibraryFile);
        }
    }
    FreeLibrary(LibraryHandle);
    return(p != NOT_PRESENT);
#else
    Unused(LibraryFile);

    MessBoxSzSz("Stub","InvokeApplet called");
    return(fTrue);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\files.c ===
#include "precomp.h"
#pragma hdrstop
/***************************************************************************/
/***** Common Library Component - File Management - 1 **********************/
/***************************************************************************/


/*
**  Purpose:
**      Opens a file with the mode supplied or checks for its existance.
**  Arguments:
**      szFile: non-NULL, non-empty path to a file to be opened.
**      ofm:    mode for opening the file.  Sharing modes only apply to
**          other processes.  Allowable modes are: ofmExistRead,
**          ofmReadWrite, ofmCreate, ofmRead, ofmWrite and ofmReadWrite.
**  Returns:
**      NULL if a PFH could not be allocated or if the file could not be
**          opened in the mode specified.
**      A PFH for the successfully opened file.  This PFH can be used in
**          other Common Library file routines unless ofm was one of the
**          existance flags.
**
***************************************************************************/
PFH APIENTRY PfhOpenFile(SZ szFile, OFM ofm)
{
    PFH pfh;

    AssertDataSeg();
    ChkArg(szFile != (SZ)NULL && *szFile != '\0', 1, (PFH)NULL);
    ChkArg(ofm == ofmExistRead || ofm == ofmExistReadWrite || ofm == ofmRead ||
            ofm == ofmWrite || ofm == ofmReadWrite || ofm == ofmCreate, 2,
            (PFH)NULL);

    if ((pfh = (PFH)SAlloc((CB)sizeof(FH))) == (PFH)NULL)
        return((PFH)NULL);

    if ((pfh->iDosfh = OpenFile(szFile, &(pfh->ofstruct), ofm)) == -1)
        {
        SFree(pfh);
        return((PFH)NULL);
        }

    return(pfh);
}



/*
**  Purpose:
**      Closes a PFH and frees it.
**  Arguments:
**      pfh: a valid PFH from PfhOpenFile() of the file to be closed.
**  Returns:
**      fFalse if the PFH could not be closed and/or freed.
**      fTrue if the PFH could be closed and freed.
**
***************************************************************************/
BOOL APIENTRY FCloseFile(pfh)
PFH pfh;
{
    BOOL fReturn;

    AssertDataSeg();
    ChkArg(pfh != (PFH)NULL, 1, fFalse);

    fReturn = (_lclose(pfh->iDosfh) != -1);
    SFree(pfh);

    return(fReturn);
}

/*
**  Purpose:
**      Frees a pfh.
**  Arguments:
**      pfh: a PFH, no handle to close.
**  Returns:
**      fFalse if the PFH is
**      fTrue if the PFH could be closed and freed.
**
***************************************************************************/
VOID APIENTRY
FreePfh(
    PFH pfh
    )
{
    AssertDataSeg();

    if (pfh != (PFH)NULL) {
        SFree(pfh);
    }

    return;
}



/*
**  Purpose:
**      Reads bytes from a file.
**  Arguments:
**      pfh:   valid PFH from a successful PfhOpenFile() call with a
**          readable mode.
**      pbBuf: non-NULL buffer to store the bytes read.  This must be at
**          cbMax bytes in length.
**      cbMax: maximum number of bytes to read.  This must be greater than
**          zero but not (CB)(-1).
**  Returns:
**      (CB)(-1) if error occurred.
**      The number of bytes actually read and stored in pbBuf.  This will
**          be greater than zero.  It will be less than cbMax if EOF was
**          encountered.  If it is equal to cbMax, it might have reached
**          EOF.
**
***************************************************************************/
CB APIENTRY CbReadFile(pfh, pbBuf, cbMax)
PFH pfh;
PB  pbBuf;
CB  cbMax;
{
    AssertDataSeg();

    ChkArg(pfh != (PFH)NULL, 1, (CB)(-1));
    ChkArg(pbBuf != (PB)NULL, 2, (CB)(-1));
    ChkArg(cbMax > (CB)0 && cbMax != (CB)(-1), 3, (CB)(-1));

    return((CB)_lread(pfh->iDosfh, pbBuf, cbMax));
}




/*
**   Purpose:
**       Write bytes from a buffer to a file.
**   Arguments:
**       pfh:   valid PFH previously returned from PfhOpenFile() with
**           write mode set.
**       pbBuf: non-NULL buffer of bytes to be read.  Must contain cbMax
**           legitimate bytes to write.
**       cbMax: number of bytes to write from pbBuf.  This must be greater
**           than zero and not equal to (CB)(-1).
**   Returns:
**       The number of bytes actually written.  Anything less than cbMax
**       indicates an error occurred.
**
***************************************************************************/
CB APIENTRY CbWriteFile(pfh, pbBuf, cbMax)
PFH pfh;
PB  pbBuf;
CB  cbMax;
{
    CB cbReturn;

    AssertDataSeg();
    ChkArg(pfh != (PFH)NULL, 1, (CB)0);
    ChkArg(pbBuf != (PB)NULL, 2, (CB)0);
    ChkArg(cbMax != (CB)0 && cbMax != (CB)(-1), 3, (CB)0);

    if ((cbReturn = (CB)_lwrite(pfh->iDosfh, pbBuf, cbMax)) == (CB)(-1))
        return(0);

    return(cbReturn);
}



/*
**  Purpose:
**      Moves the current read/write location within a file.
**  Arguments:
**      pfh: valid PFH returned from a successful PfhOpenFile() call.
**      l:   a signed long number of bytes to move the read/write location.
**      sfm: the Seek File Mode.  This can be either sfmSet, sfmCur, or
**          sfmEnd.  If sfmSet then l must be non-negative.  If sfmEnd then
**          l must be non-positive.
**  Returns:
**      (LFA)(-1) if an error occurred.
**      The LFA of the new read/write location.
**
****************************************************************************/
LFA APIENTRY LfaSeekFile(PFH pfh,LONG l,SFM sfm)
{
    AssertDataSeg();
    ChkArg(pfh != (PFH)NULL, 1, (LFA)(-1));
    ChkArg(sfm == sfmSet || sfm == sfmCur || sfm == sfmEnd, 3, (LFA)(-1));
    ChkArg(sfm != sfmSet || l >= 0L, 203, (LFA)(-1));
    ChkArg(sfm != sfmEnd || l <= 0L, 203, (LFA)(-1));

    return((LFA)_llseek(pfh->iDosfh, l, sfm));
}



/*
**  Purpose:
**      Determines whether the current read/write location is at the EOF.
**  Arguments:
**      pfh: valid PFH returned from a successful PfhOpenFile() call.
**  Returns:
**      fFalse if error or current read/write location is NOT at the EOF.
**      fTrue if current read/write location IS at the EOF.
**
****************************************************************************/
BOOL APIENTRY FEndOfFile(pfh)
PFH pfh;
{
    LFA lfaCur, lfaEnd;

    AssertDataSeg();
    ChkArg(pfh != (PFH)NULL, 1, fFalse);

    lfaCur = LfaSeekFile(pfh, (LONG)0, sfmCur);
    AssertRet(lfaCur != (LFA)(-1), fFalse);

    lfaEnd = LfaSeekFile(pfh, (LONG)0, sfmEnd);
    AssertRet(lfaEnd != (LFA)(-1), fFalse);

    if (lfaCur == lfaEnd)
        return(fTrue);

    lfaEnd = LfaSeekFile(pfh, (LONG)lfaCur, sfmSet);
    Assert(lfaEnd == lfaCur);

    return(fFalse);
}


/*
**  Purpose:
**      Removes a file.
**  Arguments:
**      szFileName: valid path to a file to be removed.  The file does not
**          have to exist.
**  Returns:
**      fFalse if an error occurred and szFileName still exists after the
**          operation.
**      fTrue if file does not exist after the operation.
**
****************************************************************************/
BOOL APIENTRY FRemoveFile(szFileName)
SZ szFileName;
{
    OFSTRUCT ofs;

    AssertDataSeg();

    ChkArg(szFileName != (SZ)NULL && *szFileName != '\0', 1, fFalse);

    _chmod(szFileName, S_IREAD | S_IWRITE);
    OpenFile((LPSTR)szFileName, &ofs, OF_DELETE);

    return(PfhOpenFile(szFileName, ofmExistRead) == (PFH)NULL);
}



/*
**  Purpose:
**      Write a zero terminated string to a file (without writing the
**      zero.
**  Arguments:
**      pfh: valid PFH from a successful PfhOpenFile() call.
**      sz:  non-NULL string to write.
**  Returns:
**      fFalse if the write operation fails to write all strlen(sz)
**          bytes to the file.
**      fTrue if the write operation writes all strlen(sz) bytes to
**          the file.
**
**************************************************************************/
BOOL APIENTRY FWriteSzToFile(PFH pfh, SZ sz)
{
    CB cb;

    AssertDataSeg();
    ChkArg(pfh != (PFH)NULL, 1, fFalse);
    ChkArg(sz != (SZ)NULL, 2, fFalse);

    return((cb = strlen(sz)) == (CB)0 ||
            (cb != (CB)(-1) && CbWriteFile(pfh, (PB)sz, cb) == cb));
}

/*
**  Purpose:
**      To check for the existance of a file.
**  Arguments:
**      szFile: fully qualified path to filename to check for existance
**  Returns:
**      fFalse if File doesn't exist
**      fTrue  if File exists
**
**************************************************************************/
BOOL APIENTRY FFileExists(SZ szFile)
{
    OFSTRUCT of;

    AssertDataSeg();
    ChkArg(szFile != (SZ)NULL, 2, fFalse);

    return(OpenFile(szFile,&of,OF_EXIST) != -1);
}



/*
**  Purpose:
**      Take a fully qualified path and return the position of the final
**      file name.
**  Arguments:
**      szPath:
**  Returns:
**      SZ return position of filename in string.
**
**************************************************************************/
SZ APIENTRY szGetFileName(SZ szPath)
{
   SZ   sz;

   ChkArg(szPath != (SZ)NULL, 1, (SZ)NULL);

   for (sz=szPath; *sz; sz++) {
   }

   for (; (sz >= szPath) && (*sz != '\\') && (*sz !=':'); sz--) {
   }

   return ++sz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\gauge.h ===
#define VALID      0
#define INVALID    1
#define POSTPONE   2
#define DOCANCEL   3

extern BOOL fUserQuit;

#define PRO_CLASS        "PRO"
#define ID_CANCEL        2
#define ID_STATUS0       4000
#define ID_STATUS1       (ID_STATUS0 + 1)
#define ID_STATUS2       (ID_STATUS0 + 2)
#define ID_STATUS3       (ID_STATUS0 + 3)
#define ID_STATUS4       (ID_STATUS0 + 4)
#define DLG_PROGRESS     400
#define ID_BAR           401


INT_PTR APIENTRY ProDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT APIENTRY ProBarProc(HWND, UINT, WPARAM, LPARAM);

BOOL
ControlInit(
    IN BOOL Init
    );

BOOL
ProInit(
    IN BOOL Init
    );

VOID    APIENTRY ProClear(HWND hDlg);
HWND    APIENTRY ProOpen(HWND,INT);
BOOL    APIENTRY ProClose(HWND);
BOOL    APIENTRY ProSetCaption (LPSTR);
BOOL    APIENTRY ProSetBarRange(INT);
BOOL    APIENTRY ProSetBarPos(INT);
BOOL    APIENTRY ProDeltaPos(INT);
BOOL    APIENTRY ProSetText(INT, LPSTR);
LRESULT APIENTRY fnText(HWND, UINT, WPARAM, LPARAM);
VOID    APIENTRY wsDlgInit(HWND);
BOOL    APIENTRY fnErrorMsg(INT);


#define BAR_RANGE 0
#define BAR_POS   2

#define BAR_SETRANGE  WM_USER+BAR_RANGE
#define BAR_SETPOS    WM_USER+BAR_POS
#define BAR_DELTAPOS  WM_USER+4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\hook.c ===
#include "precomp.h"
#pragma hdrstop

#if 0
    if(lpMsg->message == WM_CLOSE) {
        DbgPrint("HOOK: got WM_CLOSE");
        if(GetWindowLong(lpMsg->hwnd,GWL_STYLE) & WS_SYSMENU) {
            UINT State = GetMenuState( GetSystemMenu(lpMsg->hwnd,FALSE),
                                       1,
                                       MF_BYPOSITION
                                     );

            DbgPrint("; sysmenu state = %lx",State);
        }
        DbgPrint("\n");
    }
#endif

#ifdef SYMTAB_STATS
extern void SymTabStatDump(void);
#endif

HHOOK MsgFilterHook,GetMsgHook;


LRESULT
GetMsgHookProc(
    int    nCode,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Hook procedure to filter out alt+f4 when the close option in the
    system menu is disabled. Alt+f4 is handled in the default window
    procedure, and sends a WM_SYSCOMMAND message to the window even
    if the close option is disabled.  The doc for EnableMenuItem says
    that an app that disables items in the system menu must process
    the WM_SYSCOMMAND message.  This is arguably a bug in user but
    what the heck.

Arguments:

    MainInfHandle - supplies handle open txtsetup.inf

Return Value:

    None.

--*/


{
    if(nCode == HC_ACTION) {

        LPMSG lpMsg = (LPMSG)lParam;
        UINT State;

        if((lpMsg->message == WM_SYSCOMMAND)
        && ((lpMsg->wParam & 0xfff0) == SC_CLOSE)
        && (GetWindowLong(lpMsg->hwnd,GWL_STYLE) & WS_SYSMENU)) {

            State =  GetMenuState(
                        GetSystemMenu(lpMsg->hwnd,FALSE),
                        SC_CLOSE,
                        MF_BYCOMMAND
                        );

            if((State != 0xffffffff) && (State & MF_DISABLED)) {
                lpMsg->message = WM_NULL;
            }
        }

        return(0L);

    } else {
        return(CallNextHookEx(GetMsgHook,nCode,wParam,lParam));
    }
}



LRESULT
MsgFilterHookProc(
    int    nCode,
    WPARAM wParam,
    LPARAM lParam
    )

{

    LPMSG lpMsg = (LPMSG)lParam;
    HWND  hWnd = NULL;
    CHAR  szClassName[25];

    //
    // Examine type of action indicated.  We need to process only positive
    // valued actions.
    //

    if ( nCode < 0 ) {
        return ( CallNextHookEx(MsgFilterHook,nCode,wParam,lParam) );
    }

    if((lpMsg->message == WM_KEYDOWN) && (lpMsg->wParam == VK_F6)) {
        if(GetKeyState(VK_LCONTROL) & GetKeyState(VK_RCONTROL) & (USHORT)0x8000) {
            SdBreakNow();
        } else if(GetKeyState(VK_LSHIFT) & GetKeyState(VK_RSHIFT) & (USHORT)0x8000) {
            SdTracingOn();
        }
    }

    //
    // First check that we received a keyboard message and whether the
    // message is for a dialog box
    //

    if ( lpMsg->message != WM_KEYDOWN  ||  nCode != MSGF_DIALOGBOX) {
       return ( fFalse );
    }

    //
    // Now we have to detetrmine handle of current dialog window.
    // We know that class name of all our dialogs is MYDLG so
    // I am going through the chain of parent windows for current
    // focus windows until I will find parent dialog or NULL.
    //

//    hWnd = lpMsg->hwnd;
//    while ( hWnd ) {
//
//        *szClassName = '\0';
//
//        GetClassName(
//            hWnd,
//            (LPSTR)szClassName,
//            sizeof(szClassName)
//            );
//
//        if ( lstrcmpi((LPSTR)szClassName,(LPSTR)CLS_MYDLGS ) == 0 ) {
//            break;
//        }
//
//        hWnd = GetParent( hWnd );
//    }


    //
    // We only want to respond if we are in a child window of the dialog
    //

    hWnd = lpMsg->hwnd;

    if( hWnd && (hWnd = GetParent( hWnd))) {
        *szClassName = '\0';

        GetClassName(
            hWnd,
            (LPSTR)szClassName,
            sizeof(szClassName)
            );

        if ( lstrcmpi((LPSTR)szClassName,(LPSTR)CLS_MYDLGS ) != 0 ) {
            return ( fFalse );
        }

    }
    else {
        return ( fFalse );
    }

//    //
//    // Did we find anything ???
//    //
//
//    if ( ! hWnd ) {
//        return ( fFalse );
//    }

    //
    // Convert keyboard messages came into WM_COMMANDs to
    // the found dialog. Return TRUE because we procecessed
    //
    switch (lpMsg->wParam) {

    case VK_F1:
        if ( GetDlgItem ( hWnd, IDC_H ) != (HWND)NULL ) {
            PostMessage(
                hWnd,
                WM_COMMAND,
                MAKELONG(IDC_H, BN_CLICKED),
                (LONG)lpMsg->lParam
                );

        }
        return ( fTrue );



    case VK_F3:
        if ( GetDlgItem ( hWnd, IDC_X ) != (HWND)NULL ) {
            PostMessage(
                hWnd,
                WM_COMMAND,
                MAKELONG(IDC_X, BN_CLICKED),
                (LONG)lpMsg->lParam
                );
        }
        return ( fTrue );


#ifdef SYMTAB_STATS
    case VK_F2:
        SymTabStatDump();
        return ( fTrue );

#endif

#if DBG
#ifdef MEMORY_CHECK
    case VK_F4:
        MemDump();
        return ( fTrue );

#endif
#endif

    default:
        break;
    }

    return ( fFalse );
}


BOOL
FInitHook(
    VOID
    )

{
    GetMsgHook = SetWindowsHookEx(
                    WH_GETMESSAGE,
                    GetMsgHookProc,
                    NULL,
                    GetCurrentThreadId()
                    );

    MsgFilterHook = SetWindowsHookEx(
                        WH_MSGFILTER,
                        MsgFilterHookProc,
                        NULL,
                        GetCurrentThreadId()
                        );

    return ( fTrue );
}


BOOL
FTermHook(
    VOID
    )

{
    UnhookWindowsHookEx(GetMsgHook);
    UnhookWindowsHookEx(MsgFilterHook);
    return ( fTrue );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\globvars.c ===
#include "precomp.h"
#pragma hdrstop
/***************************************************************************/
/***** Common Library Component - Global Variables *************************/
/***************************************************************************/


PSTE  psteUnused           = (PSTE)NULL;
PSTEB pstebAllocatedBlocks = (PSTEB)NULL;



/*  Error Global Variable
*/
BOOL fSilentSystem = fFalse;


HCURSOR CurrentCursor;



//
//  fFullScreen is fFalse if the /b command line parameter is specified.
//
BOOL    fFullScreen = fTrue;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\gauge.c ===
#include "precomp.h"
#pragma hdrstop
/* file gauge.c */


HWND  hwndProgressGizmo = NULL;
static INT     iCnt = 0;
static WNDPROC fpxProDlg;
static DWORD   rgbFG;
static DWORD   rgbBG;

extern HWND    hwndFrame;
extern HANDLE  hinstShell;
extern BOOL    fMono;

BOOL fUserQuit     = fFalse;
static BOOL fInsideGizmosQuitCode = fFalse;
extern BOOL APIENTRY FYield(VOID);

INT gaugeCopyPercentage = -1 ;

#ifndef COLOR_HIGHLIGHT
  #define COLOR_HIGHLIGHT      (COLOR_APPWORKSPACE + 1)
  #define COLOR_HIGHLIGHTTEXT  (COLOR_APPWORKSPACE + 2)
#endif

#define COLORBG  rgbBG
#define COLORFG  rgbFG


BOOL
ProInit(
    IN BOOL Init
    )
{
    WNDCLASS rClass;
    BOOL b;

    if(Init) {

        rClass.hCursor       = LoadCursor(NULL, IDC_ARROW);
        rClass.hIcon         = NULL;
        rClass.lpszMenuName  = NULL;
        rClass.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
        rClass.hInstance     = hInst;
        rClass.style         = CS_HREDRAW | CS_VREDRAW;
        rClass.lpfnWndProc   = ProBarProc;
        rClass.cbClsExtra    = 0;
        rClass.cbWndExtra    = 2 * sizeof(WORD);
    }

    rClass.lpszClassName = PRO_CLASS;

    if(Init) {

        if(fMono) {
            rgbBG = RGB(  0,   0,   0);
            rgbFG = RGB(255, 255, 255);
        } else {
            rgbBG = RGB(  0,   0, 255);
            rgbFG = RGB(255, 255, 255);
        }

        b = RegisterClass(&rClass);
    } else {

        b = UnregisterClass(rClass.lpszClassName,hInst);
    }

    return(b);
}


/***************************************************************************/
VOID APIENTRY ProClear(HWND hdlg)
{
    AssertDataSeg();

    if (!hdlg)
        hdlg = hwndProgressGizmo;

    SetDlgItemText(hdlg, ID_STATUS1, "");
    SetDlgItemText(hdlg, ID_STATUS2, "");
    SetDlgItemText(hdlg, ID_STATUS3, "");
    SetDlgItemText(hdlg, ID_STATUS4, "");
}


BOOL
ControlInit(
    IN BOOL Init
    )
{
    WNDCLASS cls;

    if(Init) {

        cls.hCursor        = LoadCursor(NULL, IDC_ARROW);
        cls.hIcon          = NULL;
        cls.lpszMenuName   = NULL;
        cls.hbrBackground  = (HBRUSH)(COLOR_BTNFACE + 1);
        cls.hInstance      = hInst;
        cls.style          = CS_HREDRAW | CS_VREDRAW;
        cls.lpfnWndProc    = fnText;
        cls.cbClsExtra     = 0;
        cls.cbWndExtra     = 0;
    }

    cls.lpszClassName  = "stext";

    return(Init ? RegisterClass(&cls) : UnregisterClass(cls.lpszClassName,hInst));
}


static int getNumericSymbol ( SZ szSymName )
{
    SZ sz = SzFindSymbolValueInSymTab( szSymName ) ;
    return sz ? atoi( sz ) : -1 ;
}

#define SYM_NAME_CTR_X "!G:STF_DLG_PRO_CTR_X"
#define SYM_NAME_CTR_Y "!G:STF_DLG_PRO_CTR_Y"

static void centerOnDesktop ( HWND hdlg )
{
    RECT rc ;
    POINT pt, ptDlgSize ;
    int ixBias = getNumericSymbol( SYM_NAME_CTR_X ),
        iyBias = getNumericSymbol( SYM_NAME_CTR_Y ),
        cx = GetSystemMetrics( SM_CXFULLSCREEN ),
        cy = GetSystemMetrics( SM_CYFULLSCREEN ),
        l ;

    //  Get specified or default bias

    if ( ixBias <= 0 || ixBias >= 100 )
        ixBias = 50 ;  //  default value is 1/2 across

    if ( iyBias <= 0 || iyBias >= 100 )
        iyBias = 50 ;  //  default value is 1/3 down

    // Compute logical center point

    pt.x = (cx * ixBias) / 100 ;
    pt.y = (cy * iyBias) / 100 ;

    GetWindowRect( hdlg,  & rc ) ;
    ptDlgSize.x = rc.right - rc.left ;
    ptDlgSize.y = rc.bottom - rc.top ;

    pt.x -= ptDlgSize.x / 2 ;
    pt.y -= ptDlgSize.y / 2 ;

    //  Force upper left corner back onto screen if necessary.

    if ( pt.x < 0 )
        pt.x = 0 ;
    if ( pt.y < 0 )
        pt.y = 0 ;

    //  Now check to see if the dialog is getting clipped
    //  to the right or bottom.

    if ( (l = pt.x + ptDlgSize.x) > cx )
       pt.x -= l - cx ;
    if ( (l = pt.y + ptDlgSize.y) > cy )
       pt.y -= l - cy ;

    if ( pt.x < 0 )
         pt.x = 0 ;
    if ( pt.y < 0 )
         pt.y = 0 ;

    SetWindowPos( hdlg, NULL,
                  pt.x, pt.y,
          0, 0, SWP_NOSIZE | SWP_NOACTIVATE ) ;
}



/*
**   ProDlgProc(hWnd, wMessage, wParam, lParam)
**
**   Description:
**       The window proc for the Progress dialog box
**   Arguments:
**       hWnd      window handle for the dialog
**       wMessage  message number
**       wParam    message-dependent
**       lParam    message-dependent
**   Returns:
**       0 if processed, nonzero if ignored
***************************************************************************/
INT_PTR APIENTRY ProDlgProc(HWND hdlg, UINT wMessage, WPARAM wParam, LPARAM lParam)
{
    static SZ szProCancelMsg;
    static SZ szProCancelCap;

    Unused(lParam);      // GET_WM_COMMAND does not use the lParam

    AssertDataSeg();

    switch (wMessage)
        {
    case WM_INITDIALOG:
        if ((szProCancelMsg = SzFindSymbolValueInSymTab("ProCancelMsg")) == (SZ)NULL ||
            (szProCancelCap = SzFindSymbolValueInSymTab("ProCancelCap")) == (SZ)NULL   ) {

            PreCondition(fFalse, fTrue);
            return(fTrue);

        }

        ProClear(hdlg);
        /* BLOCK */ /* centered on the screen - we really want this to be
                       a WS_CHILD instead of WS_POPUP so we can do something
                       intelligent inside the frame window */

                centerOnDesktop( hdlg ) ;
                gaugeCopyPercentage = 0 ;
        return(fTrue);

//    case WM_ACTIVATE:
//        if (wParam != 0)
//            SendMessage(hwndFrame, WM_NCACTIVATE, 1, 0L);
//        break;

    case WM_CLOSE:
        gaugeCopyPercentage = -1 ;

        PostMessage(
            hdlg,
            WM_COMMAND,
            MAKELONG(IDC_X, BN_CLICKED),
            0L
            );
        return(fTrue);


    case WM_COMMAND:
        if (!fInsideGizmosQuitCode
                && (LOWORD(wParam) == IDCANCEL || LOWORD(wParam) == IDC_B))
            {

            fInsideGizmosQuitCode = fTrue;

            if (!FYield())
                {
                fInsideGizmosQuitCode = fFalse;
                DestroyWindow(hwndFrame);
                }

            if ( MessageBox(
                     hdlg,
                     (LPSTR)szProCancelMsg,
                     (LPSTR)szProCancelCap,
                     MB_YESNO | MB_ICONEXCLAMATION
                     ) == IDYES ) {

                fUserQuit = fTrue;
                fInsideGizmosQuitCode = fFalse;
                return(fFalse);
            }

            fInsideGizmosQuitCode = fFalse;
            SendMessage(hwndFrame, WM_NCACTIVATE, 1, 0L);
            }
        break;
        }

    return(fFalse);
}


/*
**   ProBarProc(hWnd, wMessage, wParam, lParam)
**
**   Description:
**       The window proc for the Progress Bar chart
**   Arguments:
**       hWnd      window handle for the dialog
**       wMessage  message number
**       wParam    message-dependent
**       lParam    message-dependent
**   Returns:
**       0 if processed, nonzero if ignored
***************************************************************************/
LRESULT APIENTRY ProBarProc(HWND hWnd, UINT wMessage, WPARAM wParam, LPARAM lParam)
{
    PAINTSTRUCT rPS;
    RECT        rc1, rc2;
    INT         dx, dy, x;
    WORD        iRange, iPos;
    CHP         rgch[30];
    INT         iHeight = 0, iWidth = 0;
    HFONT        hfntSav = NULL;
    static HFONT hfntBar = NULL;
    SIZE        size;

    AssertDataSeg();

    switch (wMessage)
        {
        case WM_CREATE:
        SetWindowWord(hWnd, BAR_RANGE, 10);
        SetWindowWord(hWnd, BAR_POS,    0);
        return(0L);

    case BAR_SETRANGE:
    case BAR_SETPOS:
        SetWindowWord(hWnd, wMessage - WM_USER, (WORD)wParam);
        InvalidateRect(hWnd, NULL, fFalse);
        UpdateWindow(hWnd);
        return(0L);

    case BAR_DELTAPOS:
        iRange = (WORD)GetWindowWord(hWnd, BAR_RANGE);
        iPos   = (WORD)GetWindowWord(hWnd, BAR_POS);

        if (iRange <= 0)
            iRange = 1;

        if (iPos > iRange)
            iPos = iRange;

        if (iPos + wParam > iRange)
            wParam = iRange - iPos;

        SetWindowWord(hWnd, BAR_POS, (WORD)(iPos + wParam));
                if ((iPos * 100 / iRange) < ((iPos + (WORD)wParam) * 100 / iRange))
            {
            InvalidateRect(hWnd, NULL, fFalse);
            UpdateWindow(hWnd);
            }
        return(0L);

    case WM_SETFONT:
                hfntBar = (HFONT)wParam;
        if (!lParam)
            return(0L);
        InvalidateRect(hWnd, NULL, fTrue);

    case WM_PAINT:
        BeginPaint(hWnd, &rPS);
        if (hfntBar)
            hfntSav = SelectObject(rPS.hdc, hfntBar);
        GetClientRect(hWnd, &rc1);
        {
            HGDIOBJ hStockObject = GetStockObject(BLACK_BRUSH);
            if (hStockObject) {
               FrameRect(rPS.hdc, &rc1, hStockObject);
               InflateRect(&rc1, -1, -1);
            }
        }
        rc2 = rc1;
                iRange = GetWindowWord(hWnd, BAR_RANGE);
                iPos   = GetWindowWord(hWnd, BAR_POS);

        if (iRange <= 0)
            iRange = 1;

        if (iPos > iRange)
            iPos = iRange;

        dx = rc1.right;
        dy = rc1.bottom;
        x  = (WORD)((DWORD)iPos * dx / iRange) + 1;

        if (iPos < iRange)
            iPos++;

                gaugeCopyPercentage = ((DWORD) iPos) * 100 / iRange ;

        wsprintf(rgch, "%3d%%", (WORD) gaugeCopyPercentage );
        GetTextExtentPoint(rPS.hdc, rgch, strlen(rgch), &size);
        iWidth  = size.cx;
        iHeight = size.cy;

        rc1.right = x;
        rc2.left  = x;

        SetBkColor(rPS.hdc, COLORBG);
        SetTextColor(rPS.hdc, COLORFG);
        ExtTextOut(rPS.hdc, (dx-iWidth)/2, (dy-iHeight)/2,
                ETO_OPAQUE | ETO_CLIPPED, &rc1, rgch, strlen(rgch), NULL);

        SetBkColor(rPS.hdc, COLORFG);
        SetTextColor(rPS.hdc, COLORBG);
        ExtTextOut(rPS.hdc, (dx-iWidth)/2, (dy-iHeight)/2,
                ETO_OPAQUE | ETO_CLIPPED, &rc2, rgch, strlen(rgch), NULL);

        if (hfntSav)
            SelectObject(rPS.hdc, hfntSav);
        EndPaint(hWnd, (LPPAINTSTRUCT)&rPS);
        return(0L);
        }

    return(DefWindowProc(hWnd, wMessage, wParam, lParam));
}


/*
**   ProOpen ()
**
**   Returns:
**       0 if processed, nonzero if ignored
***************************************************************************/
HWND APIENTRY ProOpen(HWND hwnd, INT id)
{
    CHP szTmpText[cchpBufTmpLongMax];

    Unused(id);

    AssertDataSeg();

    //
    // Maintain the number of times the progress guage is opened
    //

    iCnt++;

    //
    // Check if progress guage still present
    //

    if (!hwndProgressGizmo)
        {

        //
        // Get Progress Dialog procedure instance
        //

#ifdef DLL
        fpxProDlg = ProDlgProc;
#else  /* !DLL */
        fpxProDlg = (WNDPROC)MakeProcInstance(ProDlgProc, hinstShell);
#endif /* !DLL */

        //
        // Fetch dialog resource name
        //

        if (!LoadString(hinstShell, IDS_PROGRESS, szTmpText, cchpBufTmpLongMax)) {
           strcpy( szTmpText, "Progress" );
        }

        //
        // Create the Progress dialog
        //

        hwndProgressGizmo = CreateDialog(hinstShell, (LPCSTR)szTmpText, hwnd, (DLGPROC)fpxProDlg);

        //
        // Fill in @ items with text from the INF
        //

        EvalAssert(FFillInDialogTextFromInf(hwndProgressGizmo, hinstShell));

        //
        // Show the guage and paint it
        //

        ShowWindow(hwndProgressGizmo, SHOW_OPENWINDOW);
        UpdateWindow(hwndProgressGizmo);

        EnableWindow(hwndFrame, fFalse);
//        SendMessage(hwndFrame, WM_NCACTIVATE, 1, 0L);
        }

    return(hwndProgressGizmo);
}


/*
**   ProClose(hwndFrame)
**
**   Returns:
**       0 if processed, nonzero if ignored
***************************************************************************/
BOOL APIENTRY ProClose(HWND hwndFrame)
{
    AssertDataSeg();

    iCnt--;
    if (hwndProgressGizmo && iCnt == 0)
        {
        EnableWindow(hwndFrame, fTrue);
        DestroyWindow(hwndProgressGizmo);
        FreeProcInstance(fpxProDlg);
        hwndProgressGizmo = NULL;
        }

    return(fTrue);
}


/***************************************************************************/
BOOL APIENTRY ProSetText(INT i, LPSTR sz)
{
    AssertDataSeg();

    if (hwndProgressGizmo)
        {
        SetDlgItemText(hwndProgressGizmo, i, sz);
        return(fTrue);
        }

    return(fFalse);
}


/***************************************************************************/
BOOL APIENTRY ProSetCaption(LPSTR szCaption)
{
    if (hwndProgressGizmo)
        {
        SetWindowText(hwndProgressGizmo, szCaption);
        return(fTrue);
        }

    return(fFalse);
}


/***************************************************************************/
BOOL APIENTRY ProSetBarRange(INT i)
{
    AssertDataSeg();

    if (hwndProgressGizmo)
        {
        SendDlgItemMessage(hwndProgressGizmo, ID_BAR, BAR_SETRANGE, i, 0L);
        return(fTrue);
        }

    return(fFalse);
}


/***************************************************************************/
BOOL APIENTRY ProSetBarPos(INT i)
{
    AssertDataSeg();

    if (hwndProgressGizmo)
        {
        SendDlgItemMessage(hwndProgressGizmo, ID_BAR, BAR_SETPOS, i, 0L);
        return(fTrue);
        }

    return(fFalse);
}


/***************************************************************************/
BOOL APIENTRY ProDeltaPos(INT i)
{
    AssertDataSeg();

    if (hwndProgressGizmo)
        {
        SendDlgItemMessage(hwndProgressGizmo, ID_BAR, BAR_DELTAPOS, i, 0L);
        return(fTrue);
        }

    return(fFalse);
}


/*
**  text control that uses ExtTextOut() IE no flicker!
****************************************************************************/
LRESULT APIENTRY fnText(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    PAINTSTRUCT ps;
    RECT        rc;
    CHP         rgch[256];
    INT         len;
    HFONT        hfntSav = NULL;
    static HFONT hfntText = NULL;
    SIZE        size;

    switch (wMsg)
        {
    case WM_SETTEXT:
        DefWindowProc(hwnd, wMsg, wParam, lParam);
        InvalidateRect(hwnd,NULL,fFalse);
        UpdateWindow(hwnd);
        return(0L);

    case WM_ERASEBKGND:
        return(0L);

    case WM_SETFONT:
        hfntText = (HFONT)wParam;
        if (!lParam)
            return(0L);
        InvalidateRect(hwnd, NULL, fTrue);

    case WM_PAINT:
        BeginPaint(hwnd, &ps);
        if (hfntText)
            hfntSav = SelectObject(ps.hdc, hfntText);
        GetClientRect(hwnd,&rc);

        len = GetWindowText(hwnd, rgch, sizeof(rgch));
        SetBkColor(ps.hdc, GetSysColor(COLOR_BTNFACE));
        SetTextColor(ps.hdc, GetSysColor(COLOR_WINDOWTEXT));
        ExtTextOut(ps.hdc, 0, 0, ETO_OPAQUE, &rc, rgch, len, NULL);

        // see if text was too long.  If so, place '...' at end of field.

        if(GetTextExtentPoint(ps.hdc,rgch,len,&size)) {

            if((size.cx > rc.right - rc.left + 1)
            && GetTextExtentPoint(ps.hdc,"...",3,&size))
            {
                ExtTextOut(ps.hdc,rc.right-size.cx+1,0,0,NULL,"...",3,NULL);
            }
        }

        if (hfntSav)
            SelectObject(ps.hdc, hfntSav);
        EndPaint(hwnd, &ps);
        return(0L);
        }

    return(DefWindowProc(hwnd, wMsg, wParam, lParam));
}


#ifdef UNUSED
/*
**   wsDlgInit(hdlg)
**
**   Handle the init message for a dialog box
***************************************************************************/
VOID APIENTRY wsDlgInit(HWND hdlg)
{
    AssertDataSeg();

    /* Center the dialog.  */

        centerOnDesktop( hdlg ) ;
}
#endif /* UNUSED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\hardware.c ===
#include "precomp.h"
#pragma hdrstop
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    hardware.c

Abstract:

    Registry hardware detection

Author:

    Sunil Pai (sunilp) April 1992

--*/


#define IDENTIFIER          "Identifier"

PCHAR    AdaptersTable[] = {
                           "EisaAdapter",
                           "MultifunctionAdapter"
                           };



//=====================================================================
// The following funtions detect information from the registry hardware
// node
//=====================================================================

BOOL
SearchControllerForPeripheral(
    IN  LPSTR Controller,
    IN  LPSTR Peripheral,
    OUT LPSTR PeripheralPath
    )
{
    HKEY        hKey, hSubKey;
    CHAR        KeyName[ MAX_PATH ];
    CHAR        SubKeyName[ MAX_PATH ];
    CHAR        Class[ MAX_PATH ];
    DWORD       cbSubKeyName;
    DWORD       cbClass;
    FILETIME    FileTime;
    UINT        Index;
    LONG        Status;


    //
    // Open the controller key
    //

    lstrcpy( KeyName, "Hardware\\Description\\System\\MultifunctionAdapter\\0\\");
    lstrcat( KeyName, Controller );

    Status = RegOpenKeyEx (
                 HKEY_LOCAL_MACHINE,
                 KeyName,
                 0,
                 KEY_READ,
                 &hKey
                 );

    //
    // If failed to open it then check for an eisa adapter node
    //

    if (Status != ERROR_SUCCESS) {

        lstrcpy( KeyName, "Hardware\\Description\\System\\EisaAdapter\\0\\");
        lstrcat( KeyName, Controller );

        Status = RegOpenKeyEx (
                     HKEY_LOCAL_MACHINE,
                     KeyName,
                     0,
                     KEY_READ,
                     &hKey
                     );
    }

    //
    // If the controller wasn't found at all then return FALSE

    if ( Status != ERROR_SUCCESS ) {
        return FALSE;
    }

    //
    // Enumerate the subkeys for the controller and search the subkeys
    // for the peripheral indicated
    //

    for ( Index = 0 ; ; Index++ ) {

        cbSubKeyName = MAX_PATH;
        cbClass      = MAX_PATH;

        Status = RegEnumKeyEx(
                     hKey,
                     Index,
                     SubKeyName,
                     &cbSubKeyName,
                     NULL,
                     Class,
                     &cbClass,
                     &FileTime
                     );

        if ( Status != ERROR_SUCCESS ) {
            break;
        }

        //
        // Combine the subkey name with the peripheral name and see if it
        // exists
        //

        lstrcat (SubKeyName, "\\");
        lstrcat (SubKeyName, Peripheral);
        lstrcat (SubKeyName, "\\0");

        Status = RegOpenKeyEx (
                     hKey,
                     SubKeyName,
                     0,
                     KEY_READ,
                     &hSubKey
                     );


        if (Status == ERROR_SUCCESS) {

            RegCloseKey( hSubKey );
            RegCloseKey( hKey    );

            //
            //  path already has the controller\key entry

            lstrcpy (PeripheralPath, Controller);
            lstrcat (PeripheralPath, "\\"      );
            lstrcat (PeripheralPath, SubKeyName);

            return( TRUE );
        }

    }

    RegCloseKey( hKey );
    return( FALSE );
}



BOOL
GetTypeOfHardware(
    LPSTR HardwareAdapterEntry,
    LPSTR HardwareType
    )
{
    BOOL  bReturn = FALSE;
    PVOID ConfigurationData = NULL;
    LPSTR Type = NULL;
    CHAR  SubKey[MAX_PATH];

    LONG   Status;
    HKEY   hKey;

    //
    // Open the controller key for a multifunction adapter
    //

    lstrcpy( SubKey, "Hardware\\Description\\System\\MultifunctionAdapter\\0\\");
    lstrcat( SubKey, HardwareAdapterEntry );

    Status = RegOpenKeyEx (
                 HKEY_LOCAL_MACHINE,
                 SubKey,
                 0,
                 KEY_READ,
                 &hKey
                 );

    //
    // If failed to open it then check for an eisa adapter node
    //

    if (Status != ERROR_SUCCESS) {

        lstrcpy( SubKey, "Hardware\\Description\\System\\EisaAdapter\\0\\");
        lstrcat( SubKey, HardwareAdapterEntry );

        Status = RegOpenKeyEx (
                     HKEY_LOCAL_MACHINE,
                     SubKey,
                     0,
                     KEY_READ,
                     &hKey
                     );
    }

    if ( Status == ERROR_SUCCESS ) {

        Type = GetValueEntry( hKey, "Identifier" );


        if(Type != NULL) {

            //
            // Parse the type field to return type
            //

            lstrcpy ( HardwareType, Type );
            SFree( Type );
            bReturn = TRUE;

        }

        RegCloseKey( hKey );

    }
    return (bReturn);
}


/*
    Computer type as a string
*/
CB
GetMyComputerType(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    CB     Length;
    HKEY   hKey;
    LPSTR  Type = NULL;
    LONG   Status;

    Unused(Args);
    Unused(cArgs);
    Unused(cbReturnBuffer);

#if i386
    #define TEMP_COMPUTER "AT/AT COMPATIBLE"
#else
    #define TEMP_COMPUTER "JAZZ"
#endif

    lstrcpy(ReturnBuffer,TEMP_COMPUTER);
    Length = lstrlen(TEMP_COMPUTER) + 1;

    //
    // Open hardware node
    //

    Status = RegOpenKeyEx (
                 HKEY_LOCAL_MACHINE,
                 "Hardware\\Description\\System",
                 0,
                 KEY_READ,
                 &hKey
                 );


    if ( Status == ERROR_SUCCESS ) {

        Type = GetValueEntry( hKey, "Identifier" );


        if(Type != NULL) {
            //
            // Parse the type field to return computer type
            //

            lstrcpy ( ReturnBuffer, Type );
            Length = lstrlen( Type ) + 1;
            SFree( Type );
        }

        RegCloseKey( hKey );
    }
    return( Length );
}


/*
    Video type as a string
*/

CB
GetMyVideoType(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    CHAR  HardwareType[80];
    INT   Length;

    Unused(Args);
    Unused(cArgs);
    Unused(cbReturnBuffer);


    #define TEMP_VIDEO "VGA"

    if ( GetTypeOfHardware(
             "DisplayController\\0",
             (LPSTR)HardwareType
             )
       ) {

        //
        // Parse the type field to return Video type
        //

        lstrcpy ( ReturnBuffer, HardwareType );
        Length = lstrlen ( HardwareType ) + 1;

    }
    else {

        //
        // In case we cannot detect
        //

        lstrcpy(ReturnBuffer,TEMP_VIDEO);
        Length = lstrlen(TEMP_VIDEO)+1;

    }
    return (Length);
}

/*
    Bus type as a string
*/

CB
GetMyBusType(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    CHAR  HardwareType[80];
    INT   Length;

    Unused(Args);
    Unused(cArgs);
    Unused(cbReturnBuffer);


    #define TEMP_BUS "ISA"

    if ( GetTypeOfHardware(
             "",
             (LPSTR)HardwareType
             )
       ) {

        //
        // Parse the type field to return Video type
        //

        lstrcpy ( ReturnBuffer, HardwareType );
        Length = lstrlen ( HardwareType ) + 1;

    }
    else {

        //
        // In case we cannot detect
        //

        lstrcpy(ReturnBuffer,TEMP_BUS);
        Length = lstrlen(TEMP_BUS)+1;

    }
    return (Length);
}


/*
    Pointer type as a string
*/

CB
GetMyPointerType(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    CHAR HardwareType[80];
    CHAR PeripheralPath[MAX_PATH];
    CHAR *Controller[] = {"PointerController", "KeyboardController", "SerialController", NULL};
    BOOL PointerNotFound = TRUE;

    INT  Length, i;

    Unused(Args);
    Unused(cArgs);
    Unused(cbReturnBuffer);

    #define TEMP_POINTER "NONE"

    for (i = 0; Controller[i] != NULL && PointerNotFound; i++ ) {
        if ( SearchControllerForPeripheral(
                 Controller[i],
                 "PointerPeripheral",
                 PeripheralPath
                 )
           ) {
            PointerNotFound = FALSE;
        }
    }

    if ( (PointerNotFound)     ||
         (!GetTypeOfHardware(
               PeripheralPath,
               (LPSTR)HardwareType
               ))
       ) {

        //
        // In case we cannot detect
        //

        lstrcpy(ReturnBuffer,TEMP_POINTER);
        Length = lstrlen( TEMP_POINTER )+1;

    }
    else {

        //
        // Parse the type field to return display type
        //

        lstrcpy ( ReturnBuffer, HardwareType );
        Length = lstrlen ( HardwareType ) + 1;

    }

    return (Length);

}



/*
    Keyboard type as a string
*/

CB
GetMyKeyboardType(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    CHAR  HardwareType[80];
    INT    Length;

    Unused(Args);
    Unused(cArgs);
    Unused(cbReturnBuffer);

    #define TEMP_KEYBOARD "PCAT_ENHANCED"

    if ( GetTypeOfHardware(
             "KeyboardController\\0\\KeyboardPeripheral\\0",
             (LPSTR)HardwareType
             )
       ) {

        //
        // Parse the type field to return keyboard type
        //

        lstrcpy ( ReturnBuffer, HardwareType );
        Length = lstrlen ( HardwareType ) + 1;

    }
    else {

        //
        // In case we cannot detect
        //

        lstrcpy( ReturnBuffer, TEMP_KEYBOARD );
        Length = lstrlen( TEMP_KEYBOARD )+1;

    }
    return (Length);

}


BOOL
GetSetupEntryForHardware(
    IN  LPSTR Hardware,
    OUT LPSTR SelectedHardwareOption
    )
{
    HKEY   hKey;
    LONG   Status;
    LPSTR  ValueData;

    //
    // Open the setup key in the current control set
    //

    Status = RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 "SYSTEM\\CurrentControlSet\\control\\setup",
                 0,
                 KEY_READ,
                 &hKey
                 );

    if( Status != ERROR_SUCCESS ) {
        return( FALSE );
    }

    //
    // Get the value data of interest
    //

    if ( ValueData = GetValueEntry( hKey, Hardware ) ) {
        lstrcpy( SelectedHardwareOption, ValueData );
        SFree( ValueData );
        RegCloseKey( hKey );
        return( TRUE );
    }
    else {
        RegCloseKey( hKey );
        return( FALSE );
    }
}


CB
GetSelectedVideo(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    Unused(Args);
    Unused(cArgs);
    Unused(cbReturnBuffer);

    #define SELECTED_VIDEO ""

    if( GetSetupEntryForHardware( "Video", ReturnBuffer ) ) {
        return( lstrlen( ReturnBuffer ) + 1 );
    }
    else {
        lstrcpy( ReturnBuffer, SELECTED_VIDEO );
        return( lstrlen( SELECTED_VIDEO ) + 1 );
    }
}


CB
GetSelectedPointer(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    Unused(Args);
    Unused(cArgs);
    Unused(cbReturnBuffer);

    #define SELECTED_POINTER ""

    if( GetSetupEntryForHardware( "Pointer", ReturnBuffer ) ) {
        return( lstrlen( ReturnBuffer ) + 1 );
    }
    else {
        lstrcpy( ReturnBuffer, SELECTED_POINTER );
        return( lstrlen( SELECTED_POINTER ) + 1 );
    }
}


CB
GetSelectedKeyboard(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    Unused(Args);
    Unused(cArgs);
    Unused(cbReturnBuffer);

    #define SELECTED_KEYBOARD ""

    if( GetSetupEntryForHardware( "Keyboard", ReturnBuffer ) ) {
        return( lstrlen( ReturnBuffer ) + 1 );
    }
    else {
        lstrcpy( ReturnBuffer, SELECTED_KEYBOARD );
        return( lstrlen( SELECTED_KEYBOARD ) + 1 );
    }
}


CB
GetDevicemapValue(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    CB     rc = 0;
    CHAR   DeviceEntry[ MAX_PATH ];
    HKEY   hKey;
    LONG   Status;
    LPSTR  ServicesEntry;

    Unused( cbReturnBuffer );

    #define DEFAULT_ENTRY     ""


    if (cArgs != 2) {
        return( rc );
    }

    lstrcpy (ReturnBuffer, DEFAULT_ENTRY);
    rc = lstrlen( DEFAULT_ENTRY ) + 1;

    //
    // HACK FOR VIDEO
    // To make inf files from release 1.0 work properly, always return VGA
    // so that the old driver is not disabled by the inf file.
    //

    if (!lstrcmp( Args[ 0 ], "Video" )) {

        return rc;

    }

    //
    // Open the devicemap key for the hardware indicated
    //

    lstrcpy( DeviceEntry, "hardware\\devicemap\\" );
    lstrcat( DeviceEntry, Args[ 0 ] );

    Status = RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 DeviceEntry,
                 0,
                 KEY_READ,
                 &hKey
                 );

    if( Status != ERROR_SUCCESS ) {
        return( rc );
    }

    //
    // Read the value entry associated with the hardware
    //

    lstrcpy( DeviceEntry, Args[1] );

    //
    // Get the value data associated with this entry
    //

    if (ServicesEntry = GetValueEntry (hKey, DeviceEntry)) {
        LPSTR Entry;

        if( (Entry = strstr( ServicesEntry, "Services\\")) != NULL &&
            (Entry = strchr( Entry, '\\' )) != NULL                &&
            *++Entry != '\0'
          ) {
            LPSTR EndOfEntry;
            if( (EndOfEntry = strchr( Entry, '\\' )) != NULL ) {
                *EndOfEntry = '\0';
            }
        }
        else {
            Entry = ServicesEntry;
        }

        lstrcpy( ReturnBuffer, Entry );
        rc = lstrlen( Entry ) + 1;
        SFree( ServicesEntry );

    }

    RegCloseKey( hKey );
    return( rc );

}



/*
    Bus type as a string
*/


BOOLEAN
IsKeyNameInAdaptersTable(
    IN  PSTR    KeyName
    )

{
    ULONG   Index;

    for( Index = 0;
         Index < sizeof( AdaptersTable ) / sizeof( PCHAR );
         Index++ ) {
        if( _stricmp( KeyName, AdaptersTable[ Index ] ) == 0 ) {
            return( TRUE );
        }
    }
    return( FALSE );
}



LONG
QueryMyBusTypeListWorker(
    IN  HKEY    ParentKey,
    IN  PSTR    CompleteParentKeyName,
    IN  BOOLEAN FirstTimeCalled,
    IN  BOOLEAN GetIdentifierFromParentKey,
    OUT PSTR*   pReturnBuffer
    )
{
    ULONG   Index;
    LONG    Status;
    PSTR    BusTypeList;

    *pReturnBuffer = NULL;
    BusTypeList = NULL;

    if( !GetIdentifierFromParentKey && !IsKeyNameInAdaptersTable( strrchr( CompleteParentKeyName, '\\' ) + 1 ) ) {
        return( ERROR_SUCCESS );
    }

    if( GetIdentifierFromParentKey && !FirstTimeCalled ) {
        PSTR    TmpString;
        ULONG   TmpStringSize;

        TmpString = GetValueEntry( ParentKey, IDENTIFIER );

        if( ( TmpString != NULL ) &&
            ( ( TmpStringSize = strlen( TmpString ) ) != 0 ) ) {
            BusTypeList = SAlloc( TmpStringSize + 3 );
            if( BusTypeList == NULL ) {
                SFree( TmpString );
                return( ERROR_OUTOFMEMORY );
            }
            lstrcpy( BusTypeList, "\"" );
            lstrcat( BusTypeList, TmpString );
            lstrcat( BusTypeList, "\"" );
            SFree( TmpString );
        }

    }


    //
    //  Find out whether or not this key has subkeys
    //
    {
        CHAR        szClass[ MAX_PATH + 1 ];
        ULONG       cchClass;
        ULONG       cSubKeys;
        ULONG       cchMaxSubkey;
        ULONG       cchMaxClass;
        ULONG       cValues;
        ULONG       cchMaxValueName;
        ULONG       cbMaxValueData;
        ULONG       cbSecurityDescriptor;
        FILETIME    ftLastWriteTime;

        cchClass = sizeof( szClass );
        Status = RegQueryInfoKey( ParentKey,
                                  szClass,
                                  &cchClass,
                                  NULL,
                                  &cSubKeys,
                                  &cchMaxSubkey,
                                  &cchMaxClass,
                                  &cValues,
                                  &cchMaxValueName,
                                  &cbMaxValueData,
                                  &cbSecurityDescriptor,
                                  &ftLastWriteTime );

        if( Status != ERROR_SUCCESS ) {
            if( BusTypeList != NULL ) {
                SFree( BusTypeList );
            }
            return( Status );
        }

        // check for PCMCIA bus first
        {
            SC_HANDLE hSCManager = OpenSCManager( NULL, SERVICES_ACTIVE_DATABASEA, GENERIC_READ );
            if ( hSCManager != NULL )
            {
                SC_HANDLE hService = OpenService( hSCManager, "Pcmcia", GENERIC_READ );
                if ( hService != NULL )
                {
                    SERVICE_STATUS sStatus;
                    if (QueryServiceStatus( hService, &sStatus ))
                    {
                        if ( sStatus.dwCurrentState == SERVICE_RUNNING )
                        {
                            PSTR    TmpBuffer;
                            ULONG   TmpStringSize;

                            TmpBuffer = SAlloc( lstrlen("PCMCIA") + 3 );
                            lstrcpy( TmpBuffer, "\"" );
                            lstrcat( TmpBuffer, "PCMCIA" );
                            lstrcat( TmpBuffer, "\"" );
                            TmpStringSize = strlen( TmpBuffer );

                            if( BusTypeList == NULL ) {
                                BusTypeList = TmpBuffer;
                            } else if( strlen( BusTypeList ) == 0 ) {
                                SFree( BusTypeList );
                                BusTypeList = TmpBuffer;
                            } else {
                                BusTypeList = SRealloc( BusTypeList, strlen( BusTypeList ) + TmpStringSize + 2 );
                                strcat( BusTypeList, "," );
                                strcat( BusTypeList, TmpBuffer );
                                SFree( TmpBuffer );
                            }
                        }
                    }

                    CloseServiceHandle(hService);
                }

                CloseServiceHandle(hSCManager);
            }
        }

        for( Index = 0; Index < cSubKeys; Index++ ) {
            HKEY    ChildKey;
            CHAR    ChildKeyName[ MAX_PATH + 1];
            CHAR    CompleteChildKeyName[ 2*MAX_PATH + 1 ];
            PSTR    TmpBuffer;
            ULONG   TmpStringSize;

            Status = RegEnumKey( ParentKey,
                                 Index,
                                 ChildKeyName,
                                 sizeof( ChildKeyName ) );

            if( Status != ERROR_SUCCESS ) {
                continue;
            }

            //
            //  Open the child key
            //

            Status = RegOpenKeyEx( ParentKey,
                                   ChildKeyName,
                                   0,
                                   KEY_READ,
                                   &ChildKey );


            if( Status != ERROR_SUCCESS ) {
                continue;
            }

            lstrcpy( CompleteChildKeyName, CompleteParentKeyName );
            lstrcat( CompleteChildKeyName, "\\" );
            lstrcat( CompleteChildKeyName, ChildKeyName );

            //
            //  Get the identifier from all subkeys, and traverse the subkeys if necessary
            //

            TmpBuffer = NULL;
            Status = QueryMyBusTypeListWorker( ChildKey,
                                               CompleteChildKeyName,
                                               FALSE,
                                               ( BOOLEAN )!GetIdentifierFromParentKey,
                                               &TmpBuffer );

            if( ( Status == ERROR_SUCCESS ) &&
                ( TmpBuffer != NULL ) &&
                ( ( TmpStringSize = strlen( TmpBuffer ) )!= 0 ) ) {
                if( BusTypeList == NULL ) {
                    BusTypeList = TmpBuffer;
                } else if( strlen( BusTypeList ) == 0 ) {
                    SFree( BusTypeList );
                    BusTypeList = TmpBuffer;
                } else {
                    BusTypeList = SRealloc( BusTypeList, strlen( BusTypeList ) + TmpStringSize + 2 );
                    strcat( BusTypeList, "," );
                    strcat( BusTypeList, TmpBuffer );
                    SFree( TmpBuffer );
                }
            }

            RegCloseKey( ChildKey );
        }
    }
    *pReturnBuffer = BusTypeList;
    return( Status );
}

int __cdecl
CompareFunction( const void *  String1,
                 const void *  String2
                 )
{
    return( lstrcmpi( *( PSTR * )String1, *( PSTR * )String2 ) );
}

LONG
RemoveDuplicateNamesFromList(
    IN  PCSTR    List,
    OUT PSTR*    TrimmedList
    )

{
    PSTR    TmpList;
    ULONG   ElementsInList;
    PSTR    Pointer;
    PSTR*   TmpBuffer;
    ULONG   i;
    PSTR    p1;

    //
    //  Make a duplicate of the original list.
    //  This is necessary, since strtok() modifies
    //  the contents of the buffer that is passed
    //  as parameter.
    //
    TmpList = SzDup( (SZ)List );
    if( TmpList == NULL ) {
        return( ERROR_OUTOFMEMORY );
    }

    //
    //  Find out how many items the list contains
    //
    ElementsInList = 0;
    for( Pointer = strtok( TmpList, "," );
         Pointer != NULL;
         ElementsInList++, Pointer = strtok( NULL, "," ) );

    if( ElementsInList < 2 ) {
        //
        //  If list contains less than two items, than there is
        //  no duplicate item to remove. In this case, just return
        //  a copy of the original list.
        //
        *TrimmedList = SzDup( (SZ)List );
        if( *TrimmedList == NULL ) {
            SFree( TmpList );
            return( ERROR_OUTOFMEMORY );
        }
        return( ERROR_SUCCESS );
    }

    //
    //  If the list has more than one item, then it may have duplicates.
    //  To remove the duplicates, we first need to sort the items in the
    //  list. The items are sorted using the C runtime qsort().
    //
    TmpBuffer = SAlloc( ElementsInList*sizeof( PSTR ) );
    if( TmpBuffer == NULL ) {
        SFree( TmpList );
        return( ERROR_OUTOFMEMORY );
    }
    Pointer = TmpList;
    for( i = 0; i < ElementsInList; i++ ) {
        TmpBuffer[ i ] = Pointer;
        Pointer += strlen( Pointer ) + 1;
    }
    qsort( TmpBuffer, ElementsInList, sizeof( PSTR ), CompareFunction );
    //
    //  TmpBuffer is now a sorted array of pointers to the items
    //  in the list.
    //  Using this array, we build a sorted list of items.
    //  Since we now that this list's size will allways be less or
    //  of the original list's size, we allocate a buffer assuming
    //  maximum size.
    //
    p1 = SAlloc( lstrlen( List ) + 1 );
    if( p1 == NULL ) {
        SFree( TmpList );
        SFree( TmpBuffer );
        return( ERROR_OUTOFMEMORY );
    }
    //
    //  Remove the duplicates from the array
    //
    for( i = 0; i < ElementsInList - 1; i++ ) {
        if( lstrcmpi( TmpBuffer[ i ], TmpBuffer[ i + 1] ) == 0 ) {
            TmpBuffer[ i ]  = NULL;
        }
    }

    //
    //  Copy the remaining items to the new list
    //
    *p1 = '\0';
    for( i = 0; i < ElementsInList; i++ ) {
        if( TmpBuffer[ i ] != NULL ) {
            if( lstrlen( p1 ) != 0 ) {
                lstrcat( p1, "," );
            }
            lstrcat( p1, TmpBuffer[i] );
        }
    }
    SFree( TmpList );
    SFree( TmpBuffer );
    *TrimmedList = p1;
    return( ERROR_SUCCESS );
}


CB
GetMyBusTypeList(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    ULONG   Status;
    HKEY    Key;
    PSTR    KeyName = "HARDWARE\\DESCRIPTION\\System";
    PSTR    Pointer = NULL;
    ULONG   ListSize;
    PSTR    TrimmedList;


    Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           KeyName,
                           0,
                           KEY_READ,
                           &Key );

    if( Status == ERROR_SUCCESS ) {
        Pointer = NULL;
        Status = QueryMyBusTypeListWorker( Key,
                                           KeyName,
                                           TRUE,
                                           TRUE,
                                           &Pointer );
    }

    if((Status != ERROR_SUCCESS) || !Pointer
    || (RemoveDuplicateNamesFromList(Pointer,&TrimmedList) != ERROR_SUCCESS)) {

        //
        // Failure case.
        //
        if(cbReturnBuffer >= 3) {
            lstrcpy(ReturnBuffer,"{}");
            ListSize = 3;
        } else {
            if(cbReturnBuffer) {
                ListSize = 1;
                *ReturnBuffer = 0;
            } else {
                ListSize = 0;
            }
        }

        if(Pointer) {
            SFree(Pointer);
        }
        return(ListSize);
    }

    SFree(Pointer);

    ListSize = lstrlen(TrimmedList) + 3;

    if(ListSize <= cbReturnBuffer) {

        ReturnBuffer[0] = '{';
        lstrcpy(&ReturnBuffer[1],TrimmedList);
        ReturnBuffer[ListSize-2] = '}';
        ReturnBuffer[ListSize-1] = 0;
    }

    SFree(TrimmedList);
    return(ListSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\iinterp.c ===
#include "precomp.h"
#pragma hdrstop
/* File: iinterp.c */
/**************************************************************************/
/*  Install: INF Install section interpreter
/**************************************************************************/


INT APIENTRY EncryptCDData(UCHAR *, UCHAR *, UCHAR *, INT, INT, INT, UCHAR *);
BOOL APIENTRY FGetCmo(INT Line, UINT *pcFields, CMO * pcmo);


/**/
#define cmoNil                      ((CMO)0)

/**/
#define spcNil                      ((SPC)0)

#define spcUndoActionsAndExit       ((SPC)13)
#define spcAddSectionFilesToCopyList    ((SPC)14)
#define spcAddSectionKeyFileToCopyList  ((SPC)15)
#define spcAddNthSectionFileToCopyList  ((SPC)16)
#define spcBackupSectionFiles       ((SPC)17)
#define spcBackupSectionKeyFile     ((SPC)18)
#define spcBackupNthSectionFile     ((SPC)19)
#define spcRemoveSectionFiles       ((SPC)20)
#define spcRemoveSectionKeyFile     ((SPC)21)
#define spcRemoveNthSectionFile     ((SPC)22)
#define spcCreateDir                ((SPC)23)
#define spcRemoveDir                ((SPC)24)
#define spcCreateIniSection         ((SPC)26)
#define spcReplaceIniSection        ((SPC)30)
#define spcRemoveIniSection         ((SPC)31)
#define spcCreateIniKeyNoValue      ((SPC)32)
#define spcCreateIniKeyValue        ((SPC)33)
#define spcReplaceIniKeyValue       ((SPC)34)
#define spcRemoveIniKeyValue        ((SPC)35)
#define spcRemoveIniKey             ((SPC)36)
#define spcSetEnvVariableValue      ((SPC)37)
#define spcCreateProgManGroup       ((SPC)38)
#define spcRemoveProgManGroup       ((SPC)39)
#define spcCreateProgManItem        ((SPC)40)
#define spcRemoveProgManItem        ((SPC)41)
#define spcStampResource            ((SPC)44)
#define spcExt                      ((SPC)47)
#define spcCopyFilesInCopyList      ((SPC)48)
#define spcCloseSys                 ((SPC)49)
#define spcShowProgManGroup         ((SPC)50)
#define spcDumpCopyList             ((SPC)51)
#define spcCreateSysIniKeyValue     ((SPC)52)
#define spcClearCopyList            ((SPC)53)
#define spcGetCopyListCost          ((SPC)54)
#define spcSetupGetCopyListCost     ((SPC)55)
#define spcParseSharedAppList       ((SPC)56)
#define spcInstallSharedAppList     ((SPC)57)
#define spcSearchDirList            ((SPC)58)
#define spcSetupDOSApps             ((SPC)59)
#define spcChangeBootIniTimeout     ((SPC)60)

#define spcCreateCommonProgManGroup ((SPC)63)
#define spcRemoveCommonProgManGroup ((SPC)64)
#define spcShowCommonProgManGroup   ((SPC)65)
#define spcCreateCommonProgManItem  ((SPC)66)
#define spcRemoveCommonProgManItem  ((SPC)67)

#define spcAppend      1
#define spcOverwrite   5
#define spcPrepend     6
#define spcVital       7


static SCP rgscpCommands[] =
    {
        { "CREATEDIR",                   spcCreateDir },
        { "REMOVEDIR",                   spcRemoveDir },
        { "ADDSECTIONFILESTOCOPYLIST",   spcAddSectionFilesToCopyList },
        { "ADDSECTIONKEYFILETOCOPYLIST", spcAddSectionKeyFileToCopyList },
        { "ADDNTHSECTIONFILETOCOPYLIST", spcAddNthSectionFileToCopyList },
        { "COPYFILESINCOPYLIST",         spcCopyFilesInCopyList },
        { "CREATEINISECTION",            spcCreateIniSection },
        { "REPLACEINISECTION",           spcReplaceIniSection },
        { "REMOVEINISECTION",            spcRemoveIniSection },
        { "CREATEINIKEYNOVALUE",         spcCreateIniKeyNoValue },
        { "CREATEINIKEYVALUE",           spcCreateIniKeyValue },
        { "REPLACEINIKEYVALUE",          spcReplaceIniKeyValue },
        { "REMOVEINIKEYVALUE",           spcRemoveIniKeyValue },
        { "REMOVEINIKEY",                spcRemoveIniKey },
        { "CREATESYSINIKEYVALUE",        spcCreateSysIniKeyValue },
        { "CREATEPROGMANGROUP",          spcCreateProgManGroup },
        { "CREATEPROGMANITEM",           spcCreateProgManItem },
        { "REMOVEPROGMANITEM",           spcRemoveProgManItem },
        { "SHOWPROGMANGROUP",            spcShowProgManGroup},
        { "STAMPRESOURCE",               spcStampResource },
        { "CLOSE-SYSTEM",                spcCloseSys },
        { "EXIT",                        spcExt },
        { "DUMPCOPYLIST",                spcDumpCopyList },
        { "CLEARCOPYLIST",               spcClearCopyList },
        { "GETCOPYLISTCOST",             spcGetCopyListCost },
        { "SETUPGETCOPYLISTCOST",        spcSetupGetCopyListCost },

        { "SEARCHDIRLIST",               spcSearchDirList },
        { "SETUPDOSAPPS",                spcSetupDOSApps },
        { "CHANGEBOOTINITIMEOUT",        spcChangeBootIniTimeout },
        { "REMOVEPROGMANGROUP",          spcRemoveProgManGroup },

        { "CREATECOMMONPROGMANGROUP",    spcCreateCommonProgManGroup },
        { "REMOVECOMMONPROGMANGROUP",    spcRemoveCommonProgManGroup },
        { "SHOWCOMMONPROGMANGROUP",      spcShowCommonProgManGroup },
        { "CREATECOMMONPROGMANITEM",     spcCreateCommonProgManItem },
        { "REMOVECOMMONPROGMANITEM",     spcRemoveCommonProgManItem },

#ifdef UNUSED
        { "BACKUPSECTIONFILES",          spcBackupSectionFiles },
        { "BACKUPSECTIONKEYFILE",        spcBackupSectionKeyFile },
        { "BACKUPNTHSECTIONFILE",        spcBackupNthSectionFile },
        { "REMOVESECTIONFILES",          spcRemoveSectionFiles },
        { "REMOVESECTIONKEYFILE",        spcRemoveSectionKeyFile },
        { "REMOVENTHSECTIONFILE",        spcRemoveNthSectionFile },
        { "SETENVVARIABLEVALUE",         spcSetEnvVariableValue },
        { "UNDOACTIONSANDEXIT",          spcUndoActionsAndExit },
        { "PARSESHAREDAPPLIST",          spcParseSharedAppList },
        { "INSTALLSHAREDAPPLIST",        spcInstallSharedAppList },
#endif /* UNUSED */
        {  NULL,                         spcNil }
    };


static SCP rgscpOptions[] =
    {
        { "A",         spcAppend },
        { "APPEND",    spcAppend },
        { "O",         spcOverwrite },
        { "OVERWRITE", spcOverwrite },
        { "P",         spcPrepend },
        { "PREPEND",   spcPrepend },
        { "V",         spcVital },
        { "VITAL",     spcVital },
        {  NULL,       spcNil }
    };

/**/
static PSPT psptCommands = NULL, psptOptions = NULL;


/**/
UINT iFieldCur = 0;


static BOOL fParseError = fFalse;
CHP rgchInstBufTmpShort[cchpBufTmpShortBuf] = "short";
CHP rgchInstBufTmpLong[cchpBufTmpLongBuf]   = "long";



// REVIEW: global window handle for shell
HWND    hwndFrame = NULL;
HANDLE  hinstShell = NULL;
BOOL    fMono = fFalse;



/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FGetArgSz(INT Line,UINT *pcFields, SZ *psz)
{
    if (iFieldCur <= *pcFields)
        return((*psz = SzGetNthFieldFromInfLine(Line,iFieldCur++)) != (SZ)NULL);

    return(fFalse);
}


/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FGetArgUINT(INT Line, UINT *pcFields, UINT *pu)
{
    SZ sz;

    if (FGetArgSz(Line,pcFields,&sz))
        {
        *pu = atoi(sz);
        SFree(sz);
        return(fTrue);
        }

    return(fFalse);
}


/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FParseSectionFiles(INT Line, UINT *pcFields, PFNSF pfnsf)
{
    BOOL fOkay = fFalse;
    SZ   szSection, szSrc;

    fParseError = fTrue;
    if (FGetArgSz(Line,pcFields, &szSection))
        {
        if (FGetArgSz(Line,pcFields, &szSrc))
            {
            Assert(szSection != NULL && szSrc != NULL);
            if (*szSection != '\0' && FValidDir(szSrc))
                {
                fParseError = fFalse;
                fOkay = (*pfnsf)(szSection, szSrc);
                }
            SFree(szSrc);
            }
        SFree(szSection);
        }
    return(fOkay);
}



/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FParseCopySection(INT Line, UINT *pcFields)
{
    BOOL fOkay = fFalse;
    SZ   szSection, szSrc, szDest;

    fParseError = fTrue;
    if (FGetArgSz(Line,pcFields, &szSection))
        {
        if (FGetArgSz(Line,pcFields, &szSrc))
            {
            if (FGetArgSz(Line,pcFields, &szDest))
                {
                Assert(szSection != NULL && szSrc != NULL && szDest != NULL);
                if (*szSection != '\0' && FValidDir(szSrc) && FValidDir(szDest))
                    {
                    GRC grc;

                    fParseError = fFalse;
                    while ((grc = GrcAddSectionFilesToCopyList(szSection, szSrc,
                            szDest)) != grcOkay) {

                        SZ szParam1 = NULL, szParam2 = NULL;
                        switch ( grc ) {
                        case grcINFBadFDLine:
                        case grcINFMissingLine:
                        case grcINFMissingSection:
                            szParam1 = pLocalInfPermInfo()->szName;
                            szParam2 = szSection;
                            break;
                        default:
                            break;
                        }

                        if (EercErrorHandler(hwndFrame, grc, fTrue, szParam1, szParam2, 0) ==
                                eercAbort)
                            break;
                    }

                    fOkay = ((grc == grcOkay) ? fTrue : fFalse);
                    }
                SFree(szDest);
                }
            SFree(szSrc);
            }
        SFree(szSection);
        }
    return(fOkay);
}


/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FParseCopySectionKey(INT Line, UINT *pcFields)
{
    BOOL fOkay = fFalse;
    SZ   szSection, szKey, szSrc, szDest;

    fParseError = fTrue;
    if (FGetArgSz(Line,pcFields, &szSection))
        {
        if (FGetArgSz(Line,pcFields, &szKey))
            {
            if (FGetArgSz(Line,pcFields, &szSrc))
                {
                if (FGetArgSz(Line,pcFields, &szDest))
                    {
                    Assert(szSection != NULL && szKey != NULL && szSrc != NULL
                            && szDest != NULL);
                    if (*szSection != '\0' && *szKey != '\0' && FValidDir(szSrc)
                            && FValidDir(szDest))
                        {
                        GRC grc;

                        fParseError = fFalse;
                        while ((grc = GrcAddSectionKeyFileToCopyList(szSection,
                                szKey, szSrc, szDest)) != grcOkay) {

                            SZ szParam1 = NULL, szParam2 = NULL;
                            switch ( grc ) {
                            case grcINFBadFDLine:
                            case grcINFMissingLine:
                            case grcINFMissingSection:
                                szParam1 = pLocalInfPermInfo()->szName;
                                szParam2 = szSection;
                                break;
                            default:
                                break;
                            }

                            if (EercErrorHandler(hwndFrame, grc, fTrue, szParam1, szParam2, 0)
                                    == eercAbort)
                                break;
                        }

                        fOkay = ((grc == grcOkay) ? fTrue : fFalse);
                        }
                    SFree(szDest);
                    }
                SFree(szSrc);
                }
            SFree(szKey);
            }
        SFree(szSection);
        }
    return(fOkay);
}


/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FParseCopyNthSection(INT Line, UINT *pcFields)
{
    BOOL   fOkay = fFalse;
    SZ     szSection, szSrc, szDest;
    UINT   n;

    fParseError = fTrue;
    if (FGetArgSz(Line,pcFields, &szSection))
        {
        if (FGetArgUINT(Line,pcFields, &n))
            {
            if (FGetArgSz(Line,pcFields, &szSrc))
                {
                if (FGetArgSz(Line,pcFields, &szDest))
                    {
                    Assert(szSection != NULL && szSrc != NULL && szDest !=NULL);
                    if (*szSection != '\0' && n > 0 && FValidDir(szSrc)
                            && FValidDir(szDest))
                        {
                        GRC grc;

                        fParseError = fFalse;
                        while ((grc = GrcAddNthSectionFileToCopyList(szSection,
                                n, szSrc, szDest)) != grcOkay) {

                            SZ szParam1 = NULL, szParam2 = NULL;
                            switch ( grc ) {
                            case grcINFBadFDLine:
                            case grcINFMissingLine:
                            case grcINFMissingSection:
                                szParam1 = pLocalInfPermInfo()->szName;
                                szParam2 = szSection;
                                break;
                            default:
                                break;
                            }

                            if (EercErrorHandler(hwndFrame, grc, fTrue, szParam1, szParam2, 0)
                                    == eercAbort)
                                break;
                        }

                        fOkay = ((grc == grcOkay) ? fTrue : fFalse);
                        }
                    SFree(szDest);
                    }
                SFree(szSrc);
                }
            }
        SFree(szSection);
        }
    return(fOkay);
}



/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FParseDirectory(INT Line, UINT *pcFields, PFND pfnd)
{
    BOOL fOkay = fFalse;
    SZ   szDirectory;

    fParseError = fTrue;
    if (FGetArgSz(Line,pcFields, &szDirectory))
        {
        CMO cmo = cmoNil;
        SZ szOption;

        fOkay = fTrue;
        while (fOkay && FGetArgSz(Line,pcFields, &szOption))
            {
            switch (SpcParseString(psptOptions, szOption))
                {
            default:
                fOkay = fFalse;
                break;

            case spcVital:
                cmo |= cmoVital;
                break;
                }
            SFree(szOption);
            }
        Assert(szDirectory != NULL);
        if (fOkay && FValidDir(szDirectory))
            {
            fParseError = fFalse;
            fOkay = (*pfnd)(szDirectory, cmo);
            }
        SFree(szDirectory);
        }
    return(fOkay);
}


/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FParseCreateIniSection(INT Line, UINT *pcFields, SZ szIniFile,
        SZ szSection)
{
    CMO  cmo = cmoNil;
    SZ   szOption;
    BOOL fOkay = fTrue;

    fParseError = fTrue;
    while (fOkay && FGetArgSz(Line,pcFields, &szOption))
        {
        switch (SpcParseString(psptOptions, szOption))
            {
        default:
            fOkay = fFalse;
            break;

        case spcOverwrite:
            cmo |= cmoOverwrite;
            break;

        case spcVital:
            cmo |= cmoVital;
            break;
            }
        SFree(szOption);
        }
    Assert(szIniFile != NULL && szSection != NULL);
    if (fOkay)
        {
        fParseError = fFalse;
        fOkay = FCreateIniSection(szIniFile, szSection, cmo);
        }
    return(fOkay);
}


/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FParseReplaceIniSection(INT Line, UINT *pcFields, SZ szIniFile,
        SZ szSection)
{
    CMO  cmo = cmoNil;
    BOOL fOkay = fFalse;
    SZ   szNewSection;

    fParseError = fTrue;
    if (FGetArgSz(Line,pcFields, &szNewSection))
        {
        SZ szOption;

        fOkay = fTrue;
        while (fOkay && FGetArgSz(Line,pcFields, &szOption))
            {
            switch (SpcParseString(psptOptions, szOption))
                {
            default:
                fOkay = fFalse;
                break;

            case spcVital:
                cmo |= cmoVital;
                break;
                }
            SFree(szOption);
            }
        Assert(szIniFile != NULL && szSection != NULL && szNewSection != NULL);
        if (fOkay && *szNewSection != '\0')
            {
            fParseError = fFalse;
            fOkay = FReplaceIniSection(szIniFile, szSection, szNewSection, cmo);
            }
        SFree(szNewSection);
        }
    return(fOkay);
}


/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FParseRemoveIniSection(INT Line, UINT *pcFields, SZ szIniFile,
        SZ szSection)
{
    CMO  cmo = cmoNil;
    SZ   szOption;
    BOOL fOkay = fTrue;

    fParseError = fTrue;
    while (fOkay && FGetArgSz(Line,pcFields, &szOption))
        {
        switch (SpcParseString(psptOptions, szOption))
            {
        default:
            fOkay = fFalse;
            break;

        case spcVital:
            cmo |= cmoVital;
            break;
            }
        SFree(szOption);
        }
    Assert(szIniFile != NULL && szSection != NULL);
    if (fOkay)
        {
        fParseError = fFalse;
        fOkay = FRemoveIniSection(szIniFile, szSection, cmo);
        }
    return(fOkay);
}


/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FParseCreateIniKeyValue(INT Line, UINT *pcFields, SZ szIniFile,
        SZ szSection)
{
    CMO  cmo = cmoNil;
    BOOL fOkay = fFalse;
    SZ   szKey, szValue;

    fParseError = fTrue;
    if (FGetArgSz(Line,pcFields, &szKey))
        {
        if (FGetArgSz(Line,pcFields, &szValue))
            {
            SZ szOption;

            fOkay = fTrue;
            while (fOkay && FGetArgSz(Line,pcFields, &szOption))
                {
                switch (SpcParseString(psptOptions, szOption))
                    {
                default:
                    fOkay = fFalse;
                    break;

                case spcOverwrite:
                    cmo |= cmoOverwrite;
                    break;

                case spcVital:
                    cmo |= cmoVital;
                    break;
                    }
                SFree(szOption);
                }
            Assert(szIniFile != NULL && szSection != NULL && szKey != NULL
                    && szValue != NULL);
            if (fOkay && *szKey != '\0')
                {
                fParseError = fFalse;
                fOkay = FCreateIniKeyValue(szIniFile, szSection, szKey, szValue,
                        cmo);
                }
            SFree(szValue);
            }
        SFree(szKey);
        }
    return(fOkay);
}


/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FParseCreateSysIniKeyValue(INT Line, UINT *pcFields, SZ szIniFile,
        SZ szSection)
{
    CMO  cmo = cmoNil;
    BOOL fOkay = fFalse;
    SZ   szKey, szValue;

    fParseError = fTrue;
    if (FGetArgSz(Line,pcFields, &szKey))
        {
        if (FGetArgSz(Line,pcFields, &szValue))
            {
            SZ szOption;

            fOkay = fTrue;
            while (fOkay && FGetArgSz(Line,pcFields, &szOption))
                {
                switch (SpcParseString(psptOptions, szOption))
                    {
                default:
                    fOkay = fFalse;
                    break;

                case spcOverwrite:
                    cmo |= cmoOverwrite;
                    break;

                case spcVital:
                    cmo |= cmoVital;
                    break;
                    }
                SFree(szOption);
                }
            Assert(szIniFile != NULL && szSection != NULL && szKey != NULL
                    && szValue != NULL);
            if (fOkay && *szKey != '\0')
                {
                fParseError = fFalse;
                fOkay = FCreateSysIniKeyValue(szIniFile, szSection, szKey,
                        szValue, cmo);
                }
            SFree(szValue);
            }
        SFree(szKey);
        }
    return(fOkay);
}


/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FParseCreateIniKeyNoValue(INT Line, UINT *pcFields, SZ szIniFile,
        SZ szSection)
{
    CMO  cmo = cmoNil;
    BOOL fOkay = fFalse;
    SZ   szKey;

    fParseError = fTrue;
    if (FGetArgSz(Line,pcFields, &szKey))
        {
        SZ szOption;

        fOkay = fTrue;
        while (fOkay && FGetArgSz(Line,pcFields, &szOption))
            {
            switch (SpcParseString(psptOptions, szOption))
                {
            default:
                fOkay = fFalse;
                break;

            case spcOverwrite:
                cmo |= cmoOverwrite;
                break;

            case spcVital:
                cmo |= cmoVital;
                break;
                }
            SFree(szOption);
            }
        Assert(szIniFile != NULL && szSection != NULL && szKey != NULL);
        if (fOkay && *szKey != '\0')
            {
            fParseError = fFalse;
            fOkay = FCreateIniKeyNoValue(szIniFile, szSection, szKey, cmo);
            }
        SFree(szKey);
        }
    return(fOkay);
}


/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FParseReplaceIniKeyValue(INT Line, UINT *pcFields, SZ szIniFile,
        SZ szSection)
{
    CMO  cmo = cmoNil;
    BOOL fOkay = fFalse;
    SZ   szKey, szValue;

    fParseError = fTrue;
    if (FGetArgSz(Line,pcFields, &szKey))
        {
        if (FGetArgSz(Line,pcFields, &szValue))
            {
            SZ szOption;

            fOkay = fTrue;
            while (fOkay && FGetArgSz(Line,pcFields, &szOption))
                {
                switch (SpcParseString(psptOptions, szOption))
                    {
                default:
                    fOkay = fFalse;
                    break;

                case spcVital:
                    cmo |= cmoVital;
                    break;
                    }
                SFree(szOption);
                }
            Assert(szIniFile != NULL && szSection != NULL && szKey != NULL
                    && szValue != NULL);
            if (fOkay && *szKey != '\0')
                {
                fParseError = fFalse;
                fOkay = FReplaceIniKeyValue(szIniFile, szSection, szKey,
                        szValue, cmo);
                }
            SFree(szValue);
            }
        SFree(szKey);
        }
    return(fOkay);
}



/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FParseAppendIniKeyValue(INT Line, UINT *pcFields, SZ szIniFile,
        SZ szSection)
{
    CMO  cmo = cmoNil;
    BOOL fOkay = fFalse;
    SZ   szKey, szValue;

    fParseError = fTrue;
    if (FGetArgSz(Line,pcFields, &szKey))
        {
        if (FGetArgSz(Line,pcFields, &szValue))
            {
            SZ szOption;

            fOkay = fTrue;
            while (fOkay && FGetArgSz(Line,pcFields, &szOption))
                {
                switch (SpcParseString(psptOptions, szOption))
                    {
                default:
                    fOkay = fFalse;
                    break;

                case spcVital:
                    cmo |= cmoVital;
                    break;
                    }
                SFree(szOption);
                }
            Assert(szIniFile != NULL && szSection != NULL && szKey != NULL
                    && szValue != NULL);
            if (fOkay && *szKey != '\0')
                {
                fParseError = fFalse;
                fOkay = FAppendIniKeyValue(szIniFile, szSection, szKey,
                        szValue, cmo);
                }
            SFree(szValue);
            }
        SFree(szKey);
        }
    return(fOkay);
}




/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FParseRemoveIniKey(INT Line, UINT *pcFields, SZ szIniFile, SZ szSection)
{
    CMO  cmo = cmoNil;
    BOOL fOkay = fFalse;
    SZ   szKey;

    fParseError = fTrue;
    if (FGetArgSz(Line,pcFields, &szKey))
        {
        SZ szOption;

        fOkay = fTrue;
        while (fOkay && FGetArgSz(Line,pcFields, &szOption))
            {
            switch (SpcParseString(psptOptions, szOption))
                {
            default:
                fOkay = fFalse;
                break;

            case spcVital:
                cmo |= cmoVital;
                break;
                }
            SFree(szOption);
            }
        Assert(szIniFile != NULL && szSection != NULL && szKey != NULL);
        if (fOkay && *szKey != '\0')
            {
            fParseError = fFalse;
            fOkay = FRemoveIniKey(szIniFile, szSection, szKey, cmo);
            }
        SFree(szKey);
        }
    return(fOkay);
}


/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FParseIniSection(INT Line, UINT *pcFields, SPC spc)
{
    BOOL fOkay = fFalse;
    SZ   szIniFile, szIniSection;

    fParseError = fTrue;
    if (FGetArgSz(Line,pcFields, &szIniFile))
        {
        if (FGetArgSz(Line,pcFields, &szIniSection))
            {
            Assert(szIniFile != NULL && szIniSection != NULL);
            if (*szIniFile != '\0'
                    && (FValidPath(szIniFile)
                        || CrcStringCompareI(szIniFile, "WIN.INI") == crcEqual)
                    && *szIniSection != '\0')
                {
                fParseError = fFalse;
                switch (spc)
                    {
                default:
                    fParseError = fTrue;
                    Assert(fFalse);
                    break;

                case spcCreateIniSection:
                    fOkay = FParseCreateIniSection(Line, pcFields, szIniFile,
                            szIniSection);
                    break;

                case spcRemoveIniSection:
                    fOkay = FParseRemoveIniSection(Line, pcFields, szIniFile,
                            szIniSection);
                    break;

                case spcReplaceIniSection:
                    fOkay = FParseReplaceIniSection(Line, pcFields, szIniFile,
                            szIniSection);
                    break;

                case spcCreateIniKeyNoValue:
                    fOkay = FParseCreateIniKeyNoValue(Line, pcFields, szIniFile,
                            szIniSection);
                    break;

                case spcCreateIniKeyValue:
                    fOkay = FParseCreateIniKeyValue(Line, pcFields, szIniFile,
                            szIniSection);
                    break;

                case spcReplaceIniKeyValue:
                    fOkay = FParseReplaceIniKeyValue(Line, pcFields, szIniFile,
                            szIniSection);
                    break;

            case spcRemoveIniKey:
                fOkay = FParseRemoveIniKey(Line, pcFields, szIniFile, szIniSection);
                break;

            case spcCreateSysIniKeyValue:
                fOkay = FParseCreateSysIniKeyValue(Line, pcFields, szIniFile,
                        szIniSection);
                break;
                }
            }
            SFree(szIniSection);
            }
        SFree(szIniFile);
        }
    return(fOkay);
}


/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FParseSetEnv(INT Line, UINT *pcFields)
{
    BOOL fOkay = fFalse;
    SZ   szFile, szVar, szVal;
    CMO  cmo = cmoNil;

    fParseError = fTrue;
    if (FGetArgSz(Line,pcFields, &szFile))
        {
        if (FGetArgSz(Line,pcFields, &szVar))
            {
            if (FGetArgSz(Line,pcFields, &szVal))
                {
                SZ szOption;

                fOkay = fTrue;
                while (fOkay && FGetArgSz(Line,pcFields, &szOption))
                    {
                    switch (SpcParseString(psptOptions, szOption))
                        {
                    default:
                        fOkay = fFalse;
                        break;

                    case spcAppend:
                        cmo |= cmoAppend;
                        break;

                    case spcPrepend:
                        cmo |= cmoPrepend;
                        break;
                        }
                    SFree(szOption);
                    }
                Assert(szFile != NULL && szVar != NULL && szVal != NULL);
                if (fOkay)
                    {
                    fParseError = fFalse;
                    fOkay = FSetEnvVariableValue(szFile, szVar, szVal, cmo);
                    }
                SFree(szVal);
                }
            SFree(szVar);
            }
        SFree(szFile);
        }
    return(fOkay);
}


/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FParseCreateProgManGroup(INT Line, UINT *pcFields, BOOL CommonGroup)
{
    BOOL fOkay = fFalse;
    SZ   szDescription;

    fParseError = fTrue;
    if (FGetArgSz(Line,pcFields, &szDescription))
        {
        SZ szFile;

        if (FGetArgSz(Line,pcFields, &szFile))
            {
            CMO cmo = cmoNil;
            SZ  szOption;

            fOkay = fTrue;
            while (fOkay && FGetArgSz(Line,pcFields, &szOption))
                {
                switch (SpcParseString(psptOptions, szOption))
                    {
                default:
                    fOkay = fFalse;
                    break;

                case spcVital:
                    cmo |= cmoVital;
                    break;
                    }
                SFree(szOption);
                }
            Assert(szDescription != NULL && szFile != NULL);
            if (fOkay && *szDescription != '\0')
                {
                fParseError = fFalse;
                fOkay = FCreateProgManGroup(szDescription, szFile, cmo, CommonGroup);
                }
            SFree(szFile);
            }
        SFree(szDescription);
        }
    return(fOkay);
}


/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FParseRemoveProgManGroup(INT Line, UINT *pcFields, BOOL CommonGroup)
{
    BOOL fOkay = fFalse;
    SZ   szDescription;

    fParseError = fTrue;
    if (FGetArgSz(Line,pcFields, &szDescription))
        {
        CMO cmo = cmoNil;
        SZ  szOption;

        fOkay = fTrue;
        while (fOkay && FGetArgSz(Line,pcFields, &szOption))
            {
            switch (SpcParseString(psptOptions, szOption))
                {
            default:
                fOkay = fFalse;
                break;

            case spcVital:
                cmo |= cmoVital;
                break;
                }
            SFree(szOption);
            }
        Assert(szDescription != NULL);
        if (fOkay && *szDescription != '\0')
            {
            fParseError = fFalse;
            fOkay = FRemoveProgManGroup(szDescription, cmo, CommonGroup);
            }
        SFree(szDescription);
        }
    return(fOkay);
}


/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FParseShowProgManGroup(INT Line, UINT *pcFields, BOOL CommonGroup)
{
    BOOL fOkay = fFalse;
    SZ   szGroup;

    fParseError = fTrue;
    if (FGetArgSz(Line,pcFields, &szGroup))
        {
        SZ szCommand;

        if (FGetArgSz(Line,pcFields, &szCommand))
            {
            SZ  szOption;
            CMO cmo = cmoNil;

            fOkay = fTrue;
            while (fOkay && FGetArgSz(Line,pcFields, &szOption))
                {
                switch (SpcParseString(psptOptions, szOption))
                    {
                default:
                    fOkay = fFalse;
                    break;

                case spcVital:
                    cmo |= cmoVital;
                    break;
                    }
                SFree(szOption);
                }
            Assert(szGroup != NULL && szCommand != NULL);
            if (fOkay && *szGroup != '\0' && *szCommand != '\0')
                {
                fParseError = fFalse;
                fOkay = FShowProgManGroup(szGroup, szCommand, cmo, CommonGroup);
                }
            SFree(szCommand);
            }
        SFree(szGroup);
        }
    return(fOkay);
}


/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FParseCreateProgManItem(INT Line, UINT *pcFields, BOOL CommonGroup)
{
    BOOL fOkay = fFalse;
    SZ   szGroup;

    fParseError = fTrue;
    if (FGetArgSz(Line,pcFields, &szGroup))
        {
        SZ szDescription;

        if (FGetArgSz(Line,pcFields, &szDescription))
            {
            SZ szCmdLine;

            if (FGetArgSz(Line,pcFields, &szCmdLine))
                {
                SZ szIconFile;

                if (FGetArgSz(Line, pcFields, &szIconFile))
                    {
                    SZ szIconNum;

                    if (FGetArgSz(Line, pcFields, &szIconNum))
                        {
                        SZ  szOption;
                        CMO cmo = cmoNil;

                        fOkay = fTrue;
                        while (fOkay && FGetArgSz(Line,pcFields, &szOption))
                            {
                            switch (SpcParseString(psptOptions, szOption))
                                {
                            default:
                                fOkay = fFalse;
                                break;

                            case spcOverwrite:
                                cmo |= cmoOverwrite;
                                break;

                            case spcVital:
                                cmo |= cmoVital;
                                break;
                                }
                            SFree(szOption);
                            }
                        Assert(
                            szGroup       != NULL &&
                            szDescription != NULL &&
                            szCmdLine     != NULL &&
                            szIconFile    != NULL &&
                            szIconNum     != NULL
                            );

                        if (    fOkay
                             && *szGroup       != '\0'
                             && *szDescription != '\0'
                             && *szCmdLine     != '\0'
                           ) {



                            fParseError = fFalse;
                            while( !FCreateProgManItem(
                                         szGroup,
                                         szDescription,
                                         szCmdLine,
                                         szIconFile,
                                         atoi(szIconNum),
                                         cmo,
                                         CommonGroup
                                         )
                                 ) {

                                EERC eerc;

                                if ((eerc = EercErrorHandler(hwndFrame, grcDDEAddItem, cmo & cmoVital, szDescription, szGroup,
                                        0)) != eercRetry) {
                                    fOkay = (eerc == eercIgnore);
                                    break;
                                }
                            }

                        }
                        SFree(szIconNum);
                    }
                    SFree(szIconFile);
                }
                SFree(szCmdLine);
            }
            SFree(szDescription);
        }
        SFree(szGroup);
    }
    return(fOkay);
}


/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FParseRemoveProgManItem(INT Line, UINT *pcFields, BOOL CommonGroup)
{
    BOOL fOkay = fFalse;
    SZ   szGroup;

    fParseError = fTrue;
    if (FGetArgSz(Line,pcFields, &szGroup)) {
        SZ szDescription;

        if (FGetArgSz(Line,pcFields, &szDescription)) {
            SZ  szOption;
            CMO cmo = cmoNil;

            fOkay = fTrue;
            while (fOkay && FGetArgSz(Line,pcFields, &szOption))
                {
                switch (SpcParseString(psptOptions, szOption))
                    {
                default:
                    fOkay = fFalse;
                    break;

                case spcVital:
                    cmo |= cmoVital;
                    break;
                    }
                SFree(szOption);
                }

            Assert(szGroup != NULL && szDescription != NULL);

            if (fOkay) {
                fParseError = fFalse;
                FRemoveProgManItem( szGroup, szDescription, cmo, CommonGroup );
            }
            SFree(szDescription);
        }
        SFree(szGroup);
    }
    return(fOkay);
}


/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FParseSearchDirList(INT Line, UINT *pcFields)
{

    BOOL    fOkay   =   fFalse;
    SZ      szInfVar = NULL;
    SZ      szDirList = NULL;
    SZ      szRecurse = NULL;
    SZ      szSilent = NULL;
    SZ      szSearchList = NULL;
    SZ      szWin16Restr = NULL;
    SZ      szWin32Restr = NULL;
    SZ      szDosRestr = NULL;
    BOOL    fRecurse;
    BOOL    fSilent;


    if ( *pcFields >= 9 ) {

        FGetArgSz( Line, pcFields, &szInfVar );

        if ( szInfVar ) {

            FGetArgSz( Line, pcFields, &szDirList );

            if ( szDirList ) {

                FGetArgSz( Line, pcFields, &szRecurse );

                if ( szRecurse ) {

                    FGetArgSz( Line, pcFields, &szSilent );

                    if ( szSilent ) {

                        FGetArgSz( Line, pcFields, &szSearchList );

                        if ( szSearchList ) {

                            FGetArgSz( Line, pcFields, &szWin16Restr );

                            if ( szWin16Restr ) {

                                FGetArgSz( Line, pcFields, &szWin32Restr );

                                if ( szWin32Restr ) {

                                    FGetArgSz( Line, pcFields, &szDosRestr );

                                    if ( szDosRestr ) {


                                        fRecurse = (CrcStringCompare(szRecurse, "YES") == crcEqual);
                                        fSilent  = (CrcStringCompare(szSilent,  "YES") == crcEqual);

                                        fOkay = FSearchDirList( szInfVar,
                                                                szDirList,
                                                                fRecurse,
                                                                fSilent,
                                                                szSearchList,
                                                                szWin16Restr,
                                                                szWin32Restr,
                                                                szDosRestr );


                                        SFree( szDosRestr );
                                    }

                                    SFree( szWin32Restr );
                                }

                                SFree( szWin16Restr );
                            }

                            SFree( szSearchList );
                        }

                        SFree( szSilent );
                    }

                    SFree( szRecurse );
                }

                SFree( szDirList );
            }

            SFree( szInfVar );
        }
    }

    return fOkay;
}


/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FParseSetupDOSAppsList(INT Line, UINT *pcFields)
{
    BOOL fOkay     = fFalse;
    SZ   szAppList = NULL;
    SZ   szWinMode = NULL;
    SZ   szDefltStdValues = NULL;
    SZ   szDefltEnhValues = NULL;
    SZ   szPifDir = NULL;
    SZ   szGroup = NULL;


    if(*pcFields >= 7) {

        FGetArgSz( Line, pcFields, &szAppList );

        if ( szAppList ) {

            FGetArgSz( Line, pcFields, &szWinMode );

            if ( szWinMode ) {

                FGetArgSz( Line, pcFields, &szDefltStdValues );

                if ( szDefltStdValues ) {

                    FGetArgSz( Line, pcFields, &szDefltEnhValues );

                    if ( szDefltEnhValues ) {

                        FGetArgSz( Line, pcFields, &szPifDir );

                        if ( szPifDir ) {

                            FGetArgSz( Line, pcFields, &szGroup );

                            if ( szGroup ) {

                                fOkay = FInstallDOSPifs(
                                            szAppList,
                                            szWinMode,
                                            szDefltStdValues,
                                            szDefltEnhValues,
                                            szPifDir,
                                            szGroup
                                            );



                                SFree( szGroup );
                            }

                            SFree( szPifDir );
                        }

                        SFree( szDefltEnhValues );
                    }

                    SFree( szDefltStdValues );
                }

                SFree( szWinMode );
            }

            SFree( szAppList );
        }

    }
    return(fOkay);
}


BOOL
FParseChangeBootIniTimeout(INT Line, UINT *pcFields)
{
    BOOL fOkay = fFalse;
    SZ   szTimeout = NULL;

    if(*pcFields == 2) {
        FGetArgSz(Line,pcFields,&szTimeout);
        if(szTimeout) {
            fOkay = FChangeBootIniTimeout(atoi(szTimeout));
            SFree(szTimeout);
        }
    }
    return(fOkay);
}



/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FGetCmo(INT Line, UINT *pcFields, CMO * pcmo)
{
    BOOL    fOkay   = fFalse;
    CMO     cmo     = cmoNil;
    SZ      szOption;

    fOkay = fTrue;
    while (fOkay && FGetArgSz(Line,pcFields, &szOption)) {
        switch (SpcParseString(psptOptions, szOption))
            {
        default:
            fOkay = fFalse;
            break;

        case spcOverwrite:
            cmo |= cmoOverwrite;
            break;

        case spcVital:
            cmo |= cmoVital;
            break;
        }
        SFree(szOption);
    }

    *pcmo = cmo;

    return fOkay;
}







/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FParseStampResource(INT Line, UINT *pcFields)
{
    BOOL fOkay = fFalse;
    SZ   szSect, szKey, szDst, szData;
    UINT wResType, wResId, cbData;

    fParseError = fTrue;
    if (FGetArgSz(Line,pcFields, &szSect))
        {
        if (FGetArgSz(Line,pcFields, &szKey))
            {
            if (FGetArgSz(Line,pcFields, &szDst))
                {
                if (FGetArgUINT(Line,pcFields, &wResType))
                    if (FGetArgUINT(Line,pcFields, &wResId))
                        if (FGetArgSz(Line,pcFields, &szData))
                            {
                            if (FGetArgUINT(Line,pcFields, &cbData))
                                {
                                Assert(szSect != NULL && szKey != NULL
                                        && szDst != NULL && szData != NULL);
                                if (*szSect != '\0' && *szKey != '\0'
                                        && FValidDir(szDst))
                                    {
                                    fParseError = fFalse;
                                    fOkay = FStampResource(szSect, szKey, szDst,
                                            (WORD)wResType, (WORD)wResId, szData, cbData);
                                    }
                                }
                            SFree(szData);
                            }
                SFree(szDst);
                }
            SFree(szKey);
            }
        SFree(szSect);
        }
    return(fOkay);
}


/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FStrToDate(SZ szDate, PUSHORT pwYear, PUSHORT pwMonth,
        PUSHORT pwDay)
{
    if (!isdigit(*(szDate + 0)) ||
            !isdigit(*(szDate + 1)) ||
            !isdigit(*(szDate + 2)) ||
            !isdigit(*(szDate + 3)) ||
            *(szDate + 4) != '-' ||
            !isdigit(*(szDate + 5)) ||
            !isdigit(*(szDate + 6)) ||
            *(szDate + 7) != '-' ||
            !isdigit(*(szDate + 8)) ||
            !isdigit(*(szDate + 9)) ||
            *(szDate + 10) != '\0')
        return(fFalse);

    *pwYear = (USHORT)(((*(szDate + 0) - '0') * 1000) + ((*(szDate + 1) - '0') * 100) +
            ((*(szDate + 2) - '0') * 10) + (*(szDate + 3) - '0'));

    *pwMonth = (USHORT)(((*(szDate + 5) - '0') * 10) + (*(szDate + 6) - '0'));

    *pwDay = (USHORT)(((*(szDate + 8) - '0') * 10) + (*(szDate + 9) - '0'));

    if (*pwMonth < 1 || *pwMonth > 12 || *pwDay < 1 || *pwDay > 31)
        return(fFalse);

    return(fTrue);
}


/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FParseCloseSystem(INT Line, UINT *pcFields)
{
    BOOL   fOkay = fFalse;
    SZ     szSect, szKey, szDst;
    UINT   wResType, wResId;
    SZ     szName, szOrg, szDate, szSer;
    USHORT wYear, wMonth, wDay;
    CHP    szData[149];

    if ((szSect = SzFindSymbolValueInSymTab("STF_SYS_INIT")) == (SZ)NULL ||
            (CrcStringCompare(szSect, "YES") != crcEqual &&
             CrcStringCompare(szSect, "NET") != crcEqual) ||
            (szName = SzFindSymbolValueInSymTab("STF_CD_NAME")) == (SZ)NULL ||
            (szOrg  = SzFindSymbolValueInSymTab("STF_CD_ORG"))  == (SZ)NULL ||
            (szDate = SzFindSymbolValueInSymTab("STF_CD_DATE")) == (SZ)NULL ||
            (szSer  = SzFindSymbolValueInSymTab("STF_CD_SER"))  == (SZ)NULL ||
            !FStrToDate(szDate, &wYear, &wMonth, &wDay) ||
            EncryptCDData(szData, szName, szOrg, wYear, wMonth, wDay, szSer))
        return(fFalse);

    fParseError = fTrue;
    if (FGetArgSz(Line,pcFields, &szSect))
        {
        if (FGetArgSz(Line,pcFields, &szKey))
            {
            if (FGetArgSz(Line,pcFields, &szDst))
                {
                if (FGetArgUINT(Line, pcFields, &wResType))
                    if (FGetArgUINT(Line, pcFields, &wResId))
                        {
                        Assert(szSect != NULL && szKey != NULL && szDst !=NULL);
                        if (*szSect != '\0' && *szKey != '\0'
                                && FValidDir(szDst))
                            {
                            fParseError = fFalse;
                            fOkay = FStampResource(szSect, szKey, szDst,
                                    (WORD)wResType, (WORD)wResId, szData, 149);
                            }
                        }
                SFree(szDst);
                }
            SFree(szKey);
            }
        SFree(szSect);
        }

    return(fOkay);
}


/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FUndoActions(VOID)
{
    /* REVIEW STUB */
    Assert(fFalse);
    return(fFalse);
}


/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FParseGetCopyListCost(INT Line,UINT cFields)
{
    BOOL fOkay;
    SZ   szAdditionalNeeded = (SZ)NULL;
    SZ   szTotalFree        = (SZ)NULL;
    SZ   szTotalNeeded      = (SZ)NULL;
    SZ   szFreePerDisk      = (SZ)NULL;
    SZ   szClusterPerDisk   = (SZ)NULL;
    SZ   szTroublePairs     = (SZ)NULL;
    SZ   szNeededPerDisk    = (SZ)NULL;
    SZ   szExtraCosts       = (SZ)NULL;

    ChkArg(cFields >= 3, 1, fFalse);
    Assert(FValidCopyList( pLocalInfPermInfo() ));

    fParseError = fTrue;
    if (!FGetArgSz(Line, &cFields, &szAdditionalNeeded) || *szAdditionalNeeded == '\0'
            || !FGetArgSz(Line, &cFields, &szTotalFree) || *szTotalFree == '\0'
            || !FGetArgSz(Line, &cFields, &szTotalNeeded) || *szTotalNeeded == '\0'
            || (cFields >= 5 && !FGetArgSz(Line, &cFields, &szFreePerDisk))
            || (cFields >= 6 && !FGetArgSz(Line, &cFields, &szClusterPerDisk))
            || (cFields >= 7 && !FGetArgSz(Line, &cFields, &szTroublePairs))
            || (cFields >= 8 && !FGetArgSz(Line, &cFields, &szNeededPerDisk))
            || (cFields == 9 && !FGetArgSz(Line, &cFields, &szExtraCosts)))
        fOkay = fFalse;
    else
        {
        fParseError = fFalse;
        fOkay = FGetCopyListCost(szAdditionalNeeded, szTotalFree, szTotalNeeded,
                szFreePerDisk, szClusterPerDisk, szTroublePairs,
                szNeededPerDisk, szExtraCosts);
        }

    if(szAdditionalNeeded) {
        SFree(szAdditionalNeeded);
    }

    if(szTotalFree) {
        SFree(szTotalFree);
    }

    if(szTotalNeeded) {
        SFree(szTotalNeeded);
    }

    if(szFreePerDisk) {
        SFree(szFreePerDisk);
    }

    if(szClusterPerDisk) {
        SFree(szClusterPerDisk);
    }

    if(szTroublePairs) {
        SFree(szTroublePairs);
    }

    if(szNeededPerDisk) {
        SFree(szNeededPerDisk);
    }

    if(szExtraCosts) {
        SFree(szExtraCosts);
    }

    return(fOkay);
}

BOOL APIENTRY FInitParsingTables( void )
{

    psptCommands = PsptInitParsingTable(rgscpCommands);
    if (!psptCommands) {
       return(fFalse);
    }
    psptOptions = PsptInitParsingTable(rgscpOptions);
    if (!psptOptions) {
       FDestroyParsingTable(psptCommands);
       psptCommands = NULL;
       return(fFalse);
    }

    return(fTrue);
}



/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FParseInstallSection(HANDLE hInstance, SZ szSection)
{
    BOOL fDone = fFalse;
    BOOL fOkay = fTrue;
    INT  Line;

    if((Line = FindInfSectionLine(szSection)) == -1)
        return(fFalse);

    psptCommands = PsptInitParsingTable(rgscpCommands);
    if (!psptCommands) {
       return(fFalse);
    }
    psptOptions = PsptInitParsingTable(rgscpOptions);
    if (!psptOptions) {
       FDestroyParsingTable(psptCommands);
       psptCommands = NULL;
       return(fFalse);
    }

    while (fOkay && (!fDone) && ((Line = FindNextLineFromInf(Line)) != -1) &&
            FHandleFlowStatements(&Line,hwndFrame, szSection, NULL, NULL))
        {
        UINT cFields = CFieldsInInfLine(Line);

        if (cFields)
            {
            SZ szCommand;

            iFieldCur = 1;
            fParseError = fFalse;
            if ((fOkay = FGetArgSz(Line,&cFields, &szCommand)) != fFalse)
                {
                SPC spc = SpcParseString(psptCommands, szCommand);

                switch (spc)
                    {
                default:
                    fParseError = fTrue;
                    fOkay = fFalse;
                    break;

#ifdef UNUSED
                case spcUndoActionsAndExit:
                    fOkay = FUndoActions();
                    fDone = fTrue;
                    break;
#endif /* UNUSED */

                case spcAddSectionFilesToCopyList:
                    fOkay = FParseCopySection(Line, &cFields);
                    break;

                case spcAddSectionKeyFileToCopyList:
                    fOkay = FParseCopySectionKey(Line, &cFields);
                    break;

                case spcAddNthSectionFileToCopyList:
                    fOkay = FParseCopyNthSection(Line, &cFields);
                    break;

                case spcCopyFilesInCopyList:
                    fOkay = FCopyFilesInCopyList(hInstance);
                    if (!fOkay && fUserQuit)
                        fOkay = fDone = fTrue;
                    Assert(*(PpclnHeadList(pLocalInfPermInfo())) == (PCLN)NULL);
                    break;

#ifdef UNUSED
                case spcBackupSectionFiles:
                    fOkay = FParseSectionFiles(Line, &cFields, FBackupSectionFiles);
                    break;

                case spcBackupSectionKeyFile:
                    fOkay = FParseSectionKeyFile(Line, &cFields,
                            FBackupSectionKeyFile);
                    break;

                case spcBackupNthSectionFile:
                    fOkay = FParseSectionNFile(Line, &cFields, FBackupNthSectionFile);
                    break;

                case spcRemoveSectionFiles:
                    fOkay = FParseSectionFiles(Line, &cFields, FRemoveSectionFiles);
                    break;

                case spcRemoveSectionKeyFile:
                    fOkay = FParseSectionKeyFile(Line, &cFields,
                            FRemoveSectionKeyFile);
                    break;

                case spcRemoveNthSectionFile:
                    fOkay = FParseSectionNFile(Line, &cFields, FRemoveNthSectionFile);
                    break;
#endif /* UNUSED */

                case spcCreateDir:
                    fOkay = FParseDirectory(Line, &cFields, FCreateDir);
                    break;

                case spcRemoveDir:
                    fOkay = FParseDirectory(Line, &cFields, FRemoveDir);
                    break;

                case spcCreateIniSection:
                case spcReplaceIniSection:
                case spcRemoveIniSection:
                case spcCreateIniKeyNoValue:
                case spcCreateIniKeyValue:
                case spcReplaceIniKeyValue:
                case spcRemoveIniKey:
                case spcCreateSysIniKeyValue:
                    fOkay = FParseIniSection(Line, &cFields, spc);
                    break;

#ifdef UNUSED
                case spcSetEnvVariableValue:
                    fOkay = FParseSetEnv(Line, &cFields);
                    break;
#endif /* UNUSED */

                case spcCreateProgManGroup:
                    fOkay = FParseCreateProgManGroup(Line, &cFields, FALSE);
                    break;
                case spcCreateCommonProgManGroup:
                    fOkay = FParseCreateProgManGroup(Line, &cFields, TRUE);
                    break;

                case spcRemoveProgManGroup:
                    fOkay = FParseRemoveProgManGroup(Line, &cFields, FALSE);
                    break;
                case spcRemoveCommonProgManGroup:
                    fOkay = FParseRemoveProgManGroup(Line, &cFields, TRUE);
                    break;

                case spcRemoveProgManItem:
                    fOkay = FParseRemoveProgManItem(Line, &cFields,FALSE);
                    break;
                case spcRemoveCommonProgManItem:
                    fOkay = FParseRemoveProgManItem(Line, &cFields,TRUE);
                    break;

                case spcCreateProgManItem:
                    fOkay = FParseCreateProgManItem(Line, &cFields,FALSE);
                    break;
                case spcCreateCommonProgManItem:
                    fOkay = FParseCreateProgManItem(Line, &cFields,TRUE);
                    break;

                case spcShowProgManGroup:
                    fOkay = FParseShowProgManGroup(Line, &cFields, FALSE);
                    break;
                case spcShowCommonProgManGroup:
                    fOkay = FParseShowProgManGroup(Line, &cFields, TRUE);
                    break;

                case spcStampResource:
                    fOkay = FParseStampResource(Line, &cFields);
                    break;

                case spcCloseSys:
                    fOkay = FParseCloseSystem(Line, &cFields);
                    break;

                case spcClearCopyList:
                    if (cFields != 1)
                        fParseError = fTrue;
                    else
                        {
                        if (*(PpclnHeadList( pLocalInfPermInfo() )) != (PCLN)NULL)
                            EvalAssert(FFreeCopyList( pLocalInfPermInfo() ));
                        fOkay = fTrue;
                        }
                    break;

                case spcSetupGetCopyListCost:
                    if (cFields != 4)
                        fParseError = fTrue;
                    else
                        {
                        SZ szFree    = (SZ)NULL;
                        SZ szCluster = (SZ)NULL;
                        SZ szTotal   = (SZ)NULL;

                        fParseError = fTrue;
                        if (!FGetArgSz(Line, &cFields, &szFree) || *szFree == '\0'
                                || !FGetArgSz(Line, &cFields, &szCluster)
                                || !FGetArgSz(Line, &cFields, &szTotal)
                                || *szCluster == '\0' || *szTotal == '\0')
                            fOkay = fFalse;
                        else
                            {
                            fParseError = fFalse;
                            fOkay = FSetupGetCopyListCost(szFree, szCluster,
                                    szTotal);
                            }

                        if(szFree) {
                            SFree(szFree);
                        }

                        if(szCluster) {
                            SFree(szCluster);
                        }

                        if(szTotal) {
                            SFree(szTotal);
                        }
                    }
                    break;

                case spcGetCopyListCost:
                    if (cFields < 3)
                        fParseError = fTrue;
                    else
                        {
                        Assert(FValidCopyList( pLocalInfPermInfo() ));
                        fOkay = FParseGetCopyListCost(Line, cFields);
                        }
                    break;

#ifdef UNUSED
                case spcParseSharedAppList:
                    Assert(cFields == 2);
                    /* BLOCK */
                        {
                        SZ szList = (SZ)NULL;

                        if (!FGetArgSz(Line, &cFields, &szList))
                            fOkay = fFalse;
                        else
                            fOkay = FParseSharedAppList(szList);

                        if(szList) {
                            SFree(szList);
                        }
                    }
                    break;

                case spcInstallSharedAppList:
                    Assert(cFields == 2);
                    /* BLOCK */
                        {
                        SZ szList = (SZ)NULL;

                        if (!FGetArgSz(Line, &cFields, &szList))
                            fOkay = fFalse;
                        else
                            fOkay = FInstallSharedAppList(szList);

                        if(szList) {
                            SFree(szList);
                        }
                    }
                    break;
#endif /* UNUSED */

                case spcDumpCopyList:
#if DBG
                    /* BLOCK */
                        {
                        PCLN pclnCur;
                        PFH  pfh;

                        /* REVIEW BUG - take a filename as an arg */
                        EvalAssert((pfh = PfhOpenFile("c:copylist.txt",
                                ofmCreate)) != (PFH)NULL);
                        FWriteSzToFile(pfh, "*** COPY LIST ***\r\n");
                        Assert(FValidCopyList( pLocalInfPermInfo() ));
                        pclnCur = *(PpclnHeadList( pLocalInfPermInfo() ));
                        while (pclnCur != (PCLN)NULL)
                            {
                            PCLN pcln = pclnCur;

                            FPrintPcln(pfh, pclnCur);
                            pclnCur = pclnCur->pclnNext;
                            }

                        FWriteSzToFile(pfh, "\r\n*** END OF COPY LIST ***\r\n");
                        EvalAssert(FCloseFile(pfh)); /*** REVIEW: TEST ***/
                        }
#endif /* DBG */
                    break;

                case spcExt:
                    fDone = fTrue;
                    break;

                case spcSearchDirList:
                    fOkay = FParseSearchDirList(Line, &cFields);
                    break;

                case spcSetupDOSApps:
                    fOkay = FParseSetupDOSAppsList(Line, &cFields);
                    break;

                case spcChangeBootIniTimeout:
                    fOkay = FParseChangeBootIniTimeout(Line, &cFields);
                    break;

                    }


                SFree(szCommand);
                }
            }
        if (fParseError)
            fOkay = fFalse;
        }

    EvalAssert(FDestroyParsingTable(psptCommands));
    EvalAssert(FDestroyParsingTable(psptOptions));

    if (!fParseError)
        return(fOkay);

    LoadString(hinstShell, IDS_ERROR, rgchInstBufTmpShort, cchpBufTmpShortMax);
    LoadString(hinstShell, IDS_SHL_CMD_ERROR, rgchInstBufTmpLong,
            cchpBufTmpLongMax);

    /* BLOCK */
        {
        UINT   cFields;
        RGSZ   rgsz;
        UINT   iszCur = 0;
        SZ     szCur;

        EvalAssert((cFields = CFieldsInInfLine(Line)) != 0);

        while ((rgsz = RgszFromInfScriptLine(Line,cFields)) == (RGSZ)NULL)
            if (!FHandleOOM(hwndFrame))
                return(fFalse);

        EvalAssert((szCur = *rgsz) != (SZ)NULL);
        while (szCur != (SZ)NULL)
            {
            if (iszCur == 0)
                EvalAssert(SzStrCat(rgchInstBufTmpLong, "\n'")
                        == rgchInstBufTmpLong);
            else
                EvalAssert(SzStrCat(rgchInstBufTmpLong, " ")
                        == rgchInstBufTmpLong);

            if (strlen(rgchInstBufTmpLong) + strlen(szCur) >
                    (cchpBufTmpLongMax - 7))
                {
                Assert(strlen(rgchInstBufTmpLong) <= (cchpBufTmpLongMax - 5));
                EvalAssert(SzStrCat(rgchInstBufTmpLong, "...")
                        == rgchInstBufTmpLong);
                break;
                }
            else
                EvalAssert(SzStrCat(rgchInstBufTmpLong, szCur)
                        == rgchInstBufTmpLong);

            szCur = rgsz[++iszCur];
            }

        EvalAssert(FFreeRgsz(rgsz));

        EvalAssert(SzStrCat(rgchInstBufTmpLong, "'") == rgchInstBufTmpLong);
        }

    MessageBox(hwndFrame, rgchInstBufTmpLong, rgchInstBufTmpShort,
            MB_OK | MB_ICONHAND);

    return(fFalse);
}


/*
**  Purpose:
**      The Install entry point.  Interprets the commands
**      in the specified Install Commands INF section.
**  Arguments:
**      hinst, hwnd : Windows stuff
**      rgsz        : array of arguments (NULL terminated)
**      csz         : count of arguments (must be 1)
**  Returns:
**      fTrue if successful
**      fFalse if not
*************************************************************************/
BOOL APIENTRY FInstallEntryPoint(HANDLE hinst, HWND hwnd, RGSZ rgsz,
        UINT csz)
{
    BOOL fOkay;
    HDC  hdc;

    ChkArg(hinst != (HANDLE)NULL, 1, fFalse);
    ChkArg(hwnd != (HWND)NULL, 2, fFalse);
    ChkArg(rgsz != (RGSZ)NULL
        && *rgsz != (SZ)NULL
        && *(rgsz + 1) == (SZ)NULL, 3, fFalse);
    ChkArg(csz == 1, 4, fFalse);

    FInitFreeTable(pLocalInfPermInfo());  /* do not check return value! */

    //REVIEW: these are globals that are being used for progress gizmo.
    hwndFrame  = hwnd;
    hinstShell = hinst;
    hdc   = GetDC(NULL);
    if (hdc) {
       fMono = (GetDeviceCaps(hdc, NUMCOLORS) == 2);
       ReleaseDC(NULL, hdc);
    }

    fUserQuit = fFalse;

    fOkay = FParseInstallSection(hinst, rgsz[0]);

    // EndProgmanDde();

    if (fUserQuit)
        return(FAddSymbolValueToSymTab(INSTALL_OUTCOME, USERQUIT));
    else if (fOkay == fFalse)
        return(FAddSymbolValueToSymTab(INSTALL_OUTCOME, FAILURE));
    else
        return(FAddSymbolValueToSymTab(INSTALL_OUTCOME, SUCCESS));
}


/* REVIEW should be in a separate DLL */
/*
**  Purpose:
**      ??
**  Arguments:
**      none
**  Returns:
**      none
**
***************************************************************************/
INT APIENTRY EncryptCDData(pchBuf, pchName, pchOrg, wYear, wMonth,
        wDay, pchSer)
UCHAR * pchBuf;
UCHAR * pchName;
UCHAR * pchOrg;
INT    wYear;
INT    wMonth;
INT    wDay;
UCHAR * pchSer;
{
    UCHAR   ch, pchTmp[149];
    UCHAR * pchCur;
    UCHAR * szGarbageCur;
    UCHAR * szGarbage = "LtRrBceHabCT AhlenN";
    INT    cchName, cchOrg, i, j, chksumName, chksumOrg;
    time_t timet;

    if (pchBuf == (UCHAR *)NULL)
        return(1);

    if (pchName == (UCHAR *)NULL || (cchName = lstrlen(pchName)) == 0 ||
            cchName > 52)
        return(2);

    for (i = cchName, chksumName = 0; i > 0; )
        if ((ch = *(pchName + --i)) < ' ')
            return(2);
        else
            chksumName += ch;

    if (pchOrg == (UCHAR *)NULL || (cchOrg = lstrlen(pchOrg)) == 0 ||
            cchOrg > 52)
        return(3);

    for (i = cchOrg, chksumOrg = 0; i > 0; )
        if ((ch = *(pchOrg + --i)) < ' ')
            return(3);
        else
            chksumOrg += ch;

    if (wYear < 1900 || wYear > 4096)
        return(4);

    if (wMonth < 1 || wMonth > 12)
        return(5);

    if (wDay < 1 || wDay > 31)
        return(6);

    if (pchSer == (UCHAR *)NULL || lstrlen(pchSer) != 20)
        return(7);

    time(&timet);
    *(pchTmp + 0)  = (UCHAR)(' ' + (timet & 0x0FF));

    *(pchTmp + 1)  = (UCHAR)('e' + (cchName & 0x0F));
    *(pchTmp + 2)  = (UCHAR)('e' + ((cchName >> 4) & 0x0F));

    *(pchTmp + 3)  = (UCHAR)('e' + (cchOrg & 0x0F));
    *(pchTmp + 4)  = (UCHAR)('e' + ((cchOrg >> 4) & 0x0F));

    *(pchTmp + 5)  = (UCHAR)('e' + (chksumName & 0x0F));
    *(pchTmp + 6)  = (UCHAR)('e' + ((chksumName >> 4) & 0x0F));

    *(pchTmp + 7)  = (UCHAR)('e' + (chksumOrg & 0x0F));
    *(pchTmp + 8)  = (UCHAR)('e' + ((chksumOrg >> 4) & 0x0F));

    *(pchTmp + 9)  = (UCHAR)('e' + (wDay & 0x0F));
    *(pchTmp + 10) = (UCHAR)('e' + ((wDay >> 4) & 0x0F));

    *(pchTmp + 11) = (UCHAR)('e' + (wMonth & 0x0F));

    *(pchTmp + 12) = (UCHAR)('e' + (wYear & 0x0F));
    *(pchTmp + 13) = (UCHAR)('e' + ((wYear >>  4) & 0x0F));
    *(pchTmp + 14) = (UCHAR)('e' + ((wYear >>  8) & 0x0F));

    pchCur = pchTmp + 15;
    while ((*pchCur++ = *pchName++) != '\0')
        ;
    pchCur--;
    while ((*pchCur++ = *pchOrg++) != '\0')
        ;
    pchCur--;

    szGarbageCur = szGarbage;
    for (i = 112 - cchName - cchOrg; i-- > 0; )
        {
        if (*szGarbageCur == '\0')
            szGarbageCur = szGarbage;
        *pchCur++ = *szGarbageCur++;
        }

    pchTmp[127] = 'k';
    for (i = 0; i < 126; i++)
        pchTmp[i + 1] = pchTmp[i] ^ pchTmp[i + 1];

    for (i = 0, j = 110; i < 127; )
        {
        pchBuf[j] = pchTmp[i++];
        j = (j + 111) & 0x7F;
        }
    pchBuf[127] = '\0';

    lstrcpy(pchBuf + 128, pchSer);

    return(0);
}





#ifdef UNUSED

/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FParseSectionKeyFile(INT Line, UINT *pcFields, PFNSKF pfnskf)
{
    BOOL fOkay = fFalse;
    SZ   szSection, szKey, szSrc;

    fParseError = fTrue;
    if (FGetArgSz(Line,pcFields, &szSection))
        {
        if (FGetArgSz(Line,pcFields, &szKey))
            {
            if (FGetArgSz(Line,pcFields, &szSrc))
                {
                Assert(szSection != NULL && szKey != NULL && szSrc != NULL);
                if (*szSection != '\0' && *szKey != '\0' && FValidDir(szSrc))
                    {
                    fParseError = fFalse;
                    fOkay = (*pfnskf)(szSection, szKey, szSrc);
                    }
                SFree(szSrc);
                }
            SFree(szKey);
            }
        SFree(szSection);
        }
    return(fOkay);
}


/*
**  Purpose:
**  Arguments:
**  Returns:
**
*************************************************************************/
BOOL APIENTRY FParseSectionNFile(INT Line, UINT *pcFields, PFNSNF pfnsnf)
{
    BOOL   fOkay = fFalse;
    SZ     szSection, szSrc;
    UINT   n;

    fParseError = fTrue;
    if (FGetArgSz(Line,pcFields, &szSection))
        {
        if (FGetArgUINT(Line,pcFields, &n))
            if (FGetArgSz(Line,pcFields, &szSrc))
                {
                Assert(szSection != NULL && szSrc != NULL);
                if (*szSection != '\0' && FValidDir(szSrc) && n > 0)
                    {
                    fParseError = fFalse;
                    fOkay = (*pfnsnf)(szSection, n, szSrc);
                    }
                SFree(szSrc);
                }
        SFree(szSection);
        }
    return(fOkay);
}

#endif /* UNUSED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\inf2.c ===
#include "precomp.h"
#pragma hdrstop
/**************************************************************************/
/***** Common Library Component - INF File Handling Routines 19 ***********/
/**************************************************************************/


/*
**  Purpose:
**      Prints the contents of an Option Element Record to a file.
**  Arguments:
**      pfh: non-NULL file handle pointer returned from a successful call
**          to PfhOpenFile() with write privileges.
**      poer: OER to print.
**  Returns:
**      fFalse if error.
**      fTrue if successful.
**
**************************************************************************/
BOOL APIENTRY FPrintPoer(pfh, poer)
PFH  pfh;
POER poer;
{
    BOOL fOkay = fTrue;
    CHP  rgchp[40];

    AssertDataSeg();

    ChkArg(pfh  != (PFH)NULL,  1, fFalse);
    ChkArg(poer != (POER)NULL, 2, fFalse);

    fOkay &= FWriteSzToFile(pfh, "\r\n\r\n  Flag          Value\r\n----------------------------------");

    if (poer->szAppend == (SZ)NULL)
        fOkay &= FWriteSzToFile(pfh, "\r\n  APPEND        NULL");
    else
        {
        fOkay &= FWriteSzToFile(pfh, "\r\n  APPEND        ");
        fOkay &= FWriteSzToFile(pfh, (poer->szAppend));
        }

    if (poer->szBackup == (SZ)NULL)
        fOkay &= FWriteSzToFile(pfh, "\r\n  BACKUP        NULL");
    else
        {
        fOkay &= FWriteSzToFile(pfh, "\r\n  BACKUP        ");
        fOkay &= FWriteSzToFile(pfh, (poer->szBackup));
        }

    if (poer->oef & oefCopy)
        fOkay &= FWriteSzToFile(pfh, "\r\n  COPY          ON");
    else
        fOkay &= FWriteSzToFile(pfh, "\r\n  COPY          OFF");

    if (poer->szDate == (SZ)NULL)
        fOkay &= FWriteSzToFile(pfh, "\r\n  DATE          NULL");
    else
        {
        fOkay &= FWriteSzToFile(pfh, "\r\n  DATE          ");
        fOkay &= FWriteSzToFile(pfh, (poer->szDate));
        }

    if (poer->oef & oefDecompress)
        fOkay &= FWriteSzToFile(pfh, "\r\n  DECOMPRESS    ON");
    else
        fOkay &= FWriteSzToFile(pfh, "\r\n  DECOMPRESS    OFF");

    if (poer->szDescription == (SZ)NULL)
        fOkay &= FWriteSzToFile(pfh, "\r\n  DESCRIPTION   NULL");
    else
        {
        fOkay &= FWriteSzToFile(pfh, "\r\n  DESCRIPTION   ");
        fOkay &= FWriteSzToFile(pfh, (poer->szDescription));
        }

    if (poer->szDest == (SZ)NULL)    /* REVIEW EBU */
        fOkay &= FWriteSzToFile(pfh, "\r\n  DESTINATION   NULL");
    else
        {
        fOkay &= FWriteSzToFile(pfh, "\r\n  DESTINATION   ");
        fOkay &= FWriteSzToFile(pfh, (poer->szDest));
        }

    fOkay &= FWriteSzToFile(pfh, "\r\n  OVERWRITE     ");
    if (poer->owm == owmAlways)
        fOkay &= FWriteSzToFile(pfh, "ALWAYS");
    else if (poer->owm == owmNever)
        fOkay &= FWriteSzToFile(pfh, "NEVER");
    else if (poer->owm == owmUnprotected)
        fOkay &= FWriteSzToFile(pfh, "UNPROTECTED");
    else if (poer->owm == owmOlder)
        fOkay &= FWriteSzToFile(pfh, "OLDER");
    else if (poer->owm == owmVerifySourceOlder)
        fOkay &= FWriteSzToFile(pfh, "VERIFYSOURCEOLDER");
    else
        fOkay = fFalse;

    if (poer->oef & oefUpgradeOnly) {
        fOkay &= FWriteSzToFile(pfh, "\r\n  UPGRADEONLY      ON");
    }
    else {
        fOkay &= FWriteSzToFile(pfh, "\r\n  UPGRADEONLY      OFF");
    }

    if (poer->oef & oefReadOnly)
        fOkay &= FWriteSzToFile(pfh, "\r\n  READONLY      ON");
    else
        fOkay &= FWriteSzToFile(pfh, "\r\n  READONLY      OFF");

    if (poer->szRename == (SZ)NULL)
        fOkay &= FWriteSzToFile(pfh, "\r\n  RENAME        NULL");
    else
        {
        fOkay &= FWriteSzToFile(pfh, "\r\n  RENAME        ");
        fOkay &= FWriteSzToFile(pfh, (poer->szRename));
        }

    if (poer->oef & oefRoot)
        fOkay &= FWriteSzToFile(pfh, "\r\n  ROOT          ON");
    else
        fOkay &= FWriteSzToFile(pfh, "\r\n  ROOT          OFF");

    if (poer->oef & oefTimeStamp)
        fOkay &= FWriteSzToFile(pfh, "\r\n  SETTIMESTAMP  ON");
    else
        fOkay &= FWriteSzToFile(pfh, "\r\n  SETTIMESTAMP  OFF");

    fOkay &= FWriteSzToFile(pfh, "\r\n  SIZE          ");
    fOkay &= (_ltoa(poer->lSize, (LPSTR)rgchp, 10) == (LPSTR)rgchp);
    fOkay &= FWriteSzToFile(pfh, rgchp);

    fOkay &= FWriteSzToFile(pfh, "\r\n  TIME          ");
    fOkay &= (_ltoa((LONG)(poer->ctuCopyTime), (LPSTR)rgchp,10) == (LPSTR)rgchp);
    fOkay &= FWriteSzToFile(pfh, rgchp);

    if (poer->oef & oefUndo)
        fOkay &= FWriteSzToFile(pfh, "\r\n  UNDO          ON");
    else
        fOkay &= FWriteSzToFile(pfh, "\r\n  UNDO          OFF");

    fOkay &= FWriteSzToFile(pfh, "\r\n  VERSION       ");
    fOkay &= (_ltoa((poer->ulVerMS) >> 16, (LPSTR)rgchp, 10) == (LPSTR)rgchp);
    fOkay &= FWriteSzToFile(pfh, rgchp);
    fOkay &= FWriteSzToFile(pfh, ",");
    fOkay &= (_ltoa((poer->ulVerMS) & 0xFFFF, (LPSTR)rgchp, 10) == (LPSTR)rgchp);
    fOkay &= FWriteSzToFile(pfh, rgchp);
    fOkay &= FWriteSzToFile(pfh, ",");
    fOkay &= (_ltoa((poer->ulVerLS) >> 16, (LPSTR)rgchp, 10) == (LPSTR)rgchp);
    fOkay &= FWriteSzToFile(pfh, rgchp);
    fOkay &= FWriteSzToFile(pfh, ",");
    fOkay &= (_ltoa((poer->ulVerLS) & 0xFFFF, (LPSTR)rgchp, 10) == (LPSTR)rgchp);
    fOkay &= FWriteSzToFile(pfh, rgchp);

    if (poer->oef & oefVital)
        fOkay &= FWriteSzToFile(pfh, "\r\n  VITAL         ON");
    else
        fOkay &= FWriteSzToFile(pfh, "\r\n  VITAL         OFF");

    return(fOkay);
}


/*
**  Purpose:
**      Prints the contents of a Section File Descriptor to a file.
**  Arguments:
**      pfh: non-NULL file handle pointer returned from a successful call
**          to PfhOpenFile() with write privileges.
**      psfd: SFD to print.
**  Returns:
**      fFalse if error.
**      fTrue if successful.
**
**************************************************************************/
BOOL APIENTRY FPrintPsfd(pfh, psfd)
PFH  pfh;
PSFD psfd;
{
    BOOL fOkay = fTrue;
    PCHP rgchp;

    AssertDataSeg();

    ChkArg(pfh != (PFH)NULL, 1, fFalse);
    ChkArg(psfd != (PSFD)NULL, 2, fFalse);

    if (psfd->did < didMin ||
            psfd->did > didMost ||
            psfd->szFile == (SZ)NULL)
        return(fFalse);

    if ((rgchp = (PCHP)SAlloc((CB)(40 * sizeof(CHP)))) == (PCHP)NULL)
        return(fFalse);

    fOkay &= FWriteSzToFile(pfh, "\r\n\r\nDID    = ");
    fOkay &= (_itoa((INT)(psfd->did), rgchp, 10) == rgchp);
    fOkay &= FWriteSzToFile(pfh, rgchp);

    fOkay &= FWriteSzToFile(pfh, "\r\nszFile = ");
    fOkay &= FWriteSzToFile(pfh, psfd->szFile);

    fOkay &= FPrintPoer(pfh, &(psfd->oer));

    SFree(rgchp);

    return(fOkay);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\inf1.c ===
#include "precomp.h"
#pragma hdrstop
/**************************************************************************/
/***** Common Library Component - INF File Handling Routines 1  ***********/
/**************************************************************************/


BOOL APIENTRY FMatchPrefix(PSZ, SZ, BOOL);
GRC  APIENTRY GrcHandleSfdOption(INT, POER, UINT);


/*
**  Purpose:
**      Allocates an Object Element Record and initializes it as empty.
**  Arguments:
**      none
**  Returns:
**      NULL if allocation fails.
**      non-NULL pointer to the empty (initialized) Object Element Record.
**
**************************************************************************/
POER APIENTRY PoerAlloc(VOID)
{
    POER poer;

    AssertDataSeg();

    if ((poer = (POER)SAlloc((CB)sizeof(OER))) != (POER)NULL)
        {
        poer->oef           = oefNone;
        poer->ctuCopyTime   = (CTU)0;
        poer->owm           = owmAlways;
        poer->lSize         = 0L;
        poer->szRename      = (SZ)NULL;
        poer->szAppend      = (SZ)NULL;
        poer->szBackup      = (SZ)NULL;
        poer->szDescription = (SZ)NULL;
        poer->ulVerMS       = 0L;
        poer->ulVerLS       = 0L;
        poer->szDate        = (SZ)NULL;
        poer->szDest        = (SZ)NULL;  /* REVIEW EBU */
        }

    return(poer);
}


/*
**  Purpose:
**      Free an Object Element Record and any non-empty string fields.
**  Arguments:
**      poer: non-NULL Object Element Record to be freed.
**  Returns:
**      fFalse if a freeing error occurs.
**      fTrue for success.
**
**************************************************************************/
BOOL APIENTRY FFreePoer(poer)
POER poer;
{
    AssertDataSeg();

    ChkArg(poer != (POER)NULL, 1, fFalse);

    if (poer->szRename != (SZ)NULL)
        SFree(poer->szRename);

    if (poer->szAppend != (SZ)NULL)
        SFree(poer->szAppend);

    if (poer->szBackup != (SZ)NULL)
        SFree(poer->szBackup);

    if (poer->szDescription != (SZ)NULL)
        SFree(poer->szDescription);

    if (poer->szDate != (SZ)NULL)
        SFree(poer->szDate);

    if (poer->szDest != (SZ)NULL)    /* REVIEW EBU */
        SFree(poer->szDest);

    SFree(poer);

    return(fTrue);
}


/*
**  Purpose:
**      Validates an Option Element Record.
**  Arguments:
**      poer: non-Null pointer to OER to validate.
**  Returns:
**      fFalse if not valid.
**      fTrue if valid.
**
**************************************************************************/
BOOL APIENTRY FValidPoer(poer)
POER poer;
{
    AssertDataSeg();

    ChkArg(poer != (POER)NULL, 1, fFalse);

    if (poer->szBackup != (SZ)NULL &&
            poer->szAppend != (SZ)NULL)
        return(fFalse);

    if (poer->szRename != (SZ)NULL &&
            poer->szAppend != (SZ)NULL)
        return(fFalse);

    if (poer->szRename != (SZ)NULL &&
            poer->oef & oefRoot)
        return(fFalse);

    if (poer->szAppend != (SZ)NULL &&
            poer->oef & oefRoot)
        return(fFalse);

    if (poer->szRename != (SZ)NULL &&
            CchlValidSubPath(poer->szRename) == (CCHL)0)
        return(fFalse);

    if (poer->szAppend != (SZ)NULL &&
            CchlValidSubPath(poer->szAppend) == (CCHL)0)
        return(fFalse);

    if (poer->szBackup != (SZ)NULL &&
            (*(poer->szBackup) != '*' ||
             *(poer->szBackup + 1) != '\0') &&
            CchlValidSubPath(poer->szBackup) == (CCHL)0)
        return(fFalse);

    if (poer->szDate != (SZ)NULL &&
            !FValidOerDate(poer->szDate))
        return(fFalse);

    if (poer->lSize < 0L)
        return(fFalse);

    if (poer->owm != owmNever           &&
            poer->owm != owmAlways      &&
            poer->owm != owmUnprotected &&
            poer->owm != owmOlder       &&
            poer->owm != owmVerifySourceOlder)
        return(fFalse);

    /* REVIEW EBU - no checking for szDest field */

    return(fTrue);
}


/*
**  Purpose:
**      Allocates a Section File Descriptor and initializes it as empty.
**  Arguments:
**      none
**  Returns:
**      NULL if allocation fails.
**      non-NULL pointer to the empty (initialized) Section File Descriptor.
**
**************************************************************************/
PSFD APIENTRY PsfdAlloc(VOID)
{
    PSFD psfd;

    AssertDataSeg();

    if ((psfd = (PSFD)SAlloc((CB)sizeof(SFD))) != (PSFD)NULL)
        {
        POER poer = &(psfd->oer);

        psfd->did    = didMin;
        psfd->szFile = (SZ)NULL;

        poer->oef           = oefNone;
        poer->ctuCopyTime   = (CTU)0;
        poer->owm           = owmAlways;
        poer->lSize         = 0L;
        poer->szRename      = (SZ)NULL;
        poer->szAppend      = (SZ)NULL;
        poer->szBackup      = (SZ)NULL;
        poer->szDescription = (SZ)NULL;
        poer->ulVerMS       = 0L;
        poer->ulVerLS       = 0L;
        poer->szDate        = (SZ)NULL;
        poer->szDest        = (SZ)NULL;   /* REVIEW EBU */
        }

    return(psfd);
}


/*
**  Purpose:
**      Free a Section File Descriptor and any non-empty string fields.
**  Arguments:
**      psfd: non-NULL Section File Descriptor to be freed.
**  Returns:
**      fFalse if a freeing error occurs.
**      fTrue for success.
**
**************************************************************************/
BOOL APIENTRY FFreePsfd(psfd)
PSFD psfd;
{
    AssertDataSeg();

    ChkArg(psfd != (PSFD)NULL, 1, fFalse);

    if (psfd->szFile != (SZ)NULL)
        SFree(psfd->szFile);

    if ((psfd->oer).szRename != (SZ)NULL)
        SFree((psfd->oer).szRename);

    if ((psfd->oer).szAppend != (SZ)NULL)
        SFree((psfd->oer).szAppend);

    if ((psfd->oer).szBackup != (SZ)NULL)
        SFree((psfd->oer).szBackup);

    if ((psfd->oer).szDescription != (SZ)NULL)
        SFree((psfd->oer).szDescription);

    if ((psfd->oer).szDate != (SZ)NULL)
        SFree((psfd->oer).szDate);

    if ((psfd->oer).szDest != (SZ)NULL)
        SFree((psfd->oer).szDest);

    SFree(psfd);

    return(fTrue);
}


#if DBG
/*
**  Purpose:
**      Validates a Section File Descriptor.
**  Arguments:
**      psfd: non-Null pointer to SFD to validate.
**  Returns:
**      fFalse if not valid.
**      fTrue if valid.
**
**************************************************************************/
BOOL APIENTRY FValidPsfd(psfd)
PSFD psfd;
{
    AssertDataSeg();

    ChkArg(psfd != (PSFD)NULL, 1, fFalse);

    if (psfd->did < didMin ||
            psfd->did > didMost ||
            psfd->szFile == (SZ)NULL ||
            CchlValidSubPath(psfd->szFile) == (CCHP)0)
        return(fFalse);

    return(FValidPoer(&(psfd->oer)));
}
#endif

/*
**  Purpose:
**      Validates a Section File Descriptor Date string of the form
**      "YYYY-MM-DD" where YYYY is >= 1980 and <= 2099, MM in [01..12],
**      and DD in [01..31].
**  Arguments:
**      sz: non-Null Date string to validate.
**  Returns:
**      fFalse if invalid.
**      fTrue if valid.
**
**************************************************************************/
BOOL APIENTRY FValidOerDate(sz)
SZ sz;
{
    AssertDataSeg();

    ChkArg(sz != (SZ)NULL, 1, fFalse);

    if (*sz == '\0' ||
            strlen(sz) != (CCHP)10 ||
            !isdigit(*(sz + 0)) ||
            !isdigit(*(sz + 1)) ||
            !isdigit(*(sz + 2)) ||
            !isdigit(*(sz + 3)) ||
            !isdigit(*(sz + 5)) ||
            !isdigit(*(sz + 6)) ||
            !isdigit(*(sz + 8)) ||
            !isdigit(*(sz + 9)) ||
            *(sz + 4) != '-' ||
            *(sz + 7) != '-')
        return(fFalse);

    if (*sz == '0' ||
            *sz > '2' ||
            (*sz == '1' &&
             (*(sz + 1) != '9' ||
              *(sz + 2) < '8')) ||
            (*sz == '2' &&
             *(sz + 1) != '0'))
        return(fFalse);

    if (*(sz + 5) > '1' ||
            (*(sz + 5) == '0' &&
             *(sz + 6) == '0') ||
            (*(sz + 5) == '1' &&
             *(sz + 6) > '2'))
        return(fFalse);

    if (*(sz + 8) > '3' ||
            (*(sz + 8) == '0' &&
             *(sz + 9) == '0') ||
            (*(sz + 8) == '3' &&
             *(sz + 9) > '1'))
        return(fFalse);

    return(fTrue);
}


/*
**  Purpose:
**      Ensures rest of SFD option string matches (case insensitive compare)
**      and consumes option string through matching portion and a trailing
**      equals sign (if required).
**  Arguments:
**      psz:       non-NULL pointer to non-NULL option string to match.
**      szToMatch: non-Null uppercase string to match.
**      fEquals:   whether string must be terminated by an equals sign.
**  Returns:
**      fFalse for mismatch or bad format of option.
**      fTrue otherwise.
**
**************************************************************************/
BOOL APIENTRY FMatchPrefix(PSZ psz,SZ szToMatch,BOOL fEquals)
{
    AssertDataSeg();

    ChkArg(psz != (PSZ)NULL &&
            *psz != (SZ)NULL, 1, fFalse);
    ChkArg(szToMatch != (SZ)NULL &&
            *szToMatch >= 'A' &&
            *szToMatch <= 'Z', 2, fFalse);

    while (**psz != '\0' &&
            **psz != '=' &&
            !FWhiteSpaceChp(**psz) &&
            *szToMatch != '\0')
        {
        if (**psz != *szToMatch)
            return(fFalse);
        (*psz)++;
        szToMatch++;
        }

    if (fEquals)
        {
        if (**psz != '=')
            return(fFalse);
        else
            (*psz)++;
        }
    else if (**psz != '\0')
        return(fFalse);

    return(fTrue);
}


/*
**  Purpose:
**      Parses a string representation of a version into two unsigned
**      long values - the most significant and the least significant.
**  Arguments:
**      szVer: non-Null SZ of the form "a,b,c,d" where each field is
**          an unsigned word.  Omitted fields are assumed to be the least
**          significant (eg d then c then b then a) and are parsed as zeros.
**          So "a,b" is equivalent to "a,b,0,0".
**      pulMS: non-Null location to store the Most Significant long value
**          built from a,b
**      pulLS: non-Null location to store the Least Significant long value
**          built from c,d
**  Returns:
**      fFalse if szVer is of a bad format.
**      fTrue otherwise.
**
**************************************************************************/
BOOL APIENTRY FParseVersion(szVer, pulMS, pulLS)
SZ     szVer;
PULONG pulMS;
PULONG pulLS;
{
    USHORT rgus[4];
    USHORT ius;
    ULONG  ulTmp;

    AssertDataSeg();

    ChkArg(szVer != (SZ)NULL, 1, fFalse);
    ChkArg(pulMS != (PULONG)NULL, 2, fFalse);
    ChkArg(pulLS != (PULONG)NULL, 3, fFalse);

    *pulMS = *pulLS = 0L;

    for (ius = 0; ius < 4; ius++) {

        rgus[ius] = (USHORT) atoi(szVer);

        while (*szVer != '\0' && *szVer != ',') {
            if (!isdigit(*szVer++)) {
                return(fFalse);
            }
        }

        if (*szVer == ',') {
            szVer++;
        }
    }

    ulTmp = rgus[0];
    *pulMS = (ulTmp << 16) + rgus[1];
    ulTmp = rgus[2];
    *pulLS = (ulTmp << 16) + rgus[3];

    return(fTrue);


//    // no versioning in WIN32
//    Unused(szVer);
//    Unused(pulMS);
//    Unused(pulLS);
//    return(fTrue);
}


/*
**  Purpose:
**      Handles one option field from a file description line.
**  Arguments:
**      poer:   non-NULL valid OER to fill.
**      iField: index of existing field to read.
**  Notes:
**      Requires that the current INF structure was initialized with a
**      successful call to GrcOpenInf() and that the current Read location
**      is valid.
**  Returns:
**      grcOkay for success.
**      grcOutOfMemory for out of memory.
**      grcINFBadFDLine for bad format.
**      grcNotOkay otherwise.
**
**************************************************************************/
GRC APIENTRY GrcHandleSfdOption(INT Line,POER poer,UINT iField)
{
    SZ   sz, szCur;
    GRC  grc = grcOkay;
    BOOL fNot = fFalse;

    AssertDataSeg();

    PreCondInfOpen(grcNotOkay);

    ChkArg(poer != (POER)NULL, 1, grcNotOkay);
    ChkArg(FValidPoer(poer), 1, grcNotOkay);
    ChkArg(iField >= 1 && CFieldsInInfLine(Line) >= iField, 2, grcNotOkay);

    if ((szCur = sz = SzGetNthFieldFromInfLine(Line,iField)) == (SZ)NULL)
        return(grcOutOfMemory);

    if (*szCur == '!')
        {
        fNot = fTrue;
        szCur++;
        }

    switch (*szCur)
        {
    case 'A':
        if (!FMatchPrefix(&szCur, "APPEND", !fNot))
            grc = grcINFBadFDLine;
        else if (fNot)
            poer->szAppend = (SZ)NULL;
        else if ((poer->szAppend = SzDupl(szCur)) == (SZ)NULL)
            grc = grcOutOfMemory;
        else if (CchlValidSubPath(poer->szAppend) == (CCHP)0 ||
                poer->szBackup != (SZ)NULL ||
                poer->szRename != (SZ)NULL ||
                (poer->oef & oefRoot) == oefRoot)
            grc = grcINFBadFDLine;
        break;

    case 'B':
        if (!FMatchPrefix(&szCur, "BACKUP", !fNot))
            grc = grcINFBadFDLine;
        else if (fNot)
            poer->szBackup = (SZ)NULL;
        else if ((poer->szBackup = SzDupl(szCur)) == (SZ)NULL)
            grc = grcOutOfMemory;
        else if ((*(poer->szBackup) != '*' ||
                 *(poer->szBackup + 1) != '\0') &&
                CchlValidSubPath(poer->szBackup) == (CCHP)0)
            grc = grcINFBadFDLine;
        else if (poer->szAppend != (SZ)NULL)
            grc = grcINFBadFDLine;
        break;

    case 'C':
        if (!FMatchPrefix(&szCur, "COPY", fFalse))
            grc = grcINFBadFDLine;
        else if (fNot)
            poer->oef &= ~oefCopy;
        else
            poer->oef |= oefCopy;
        break;

    case 'D':   /* Date, Decompress, Description */
        if (*(szCur + 1) == 'A')
            {
            if (!FMatchPrefix(&szCur, "DATE", !fNot))
                grc = grcINFBadFDLine;
            else if (fNot)
                poer->szDate = (SZ)NULL;
            else if ((poer->szDate = SzDupl(szCur)) == (SZ)NULL)
                grc = grcOutOfMemory;
            else if (!FValidOerDate(poer->szDate))
                grc = grcINFBadFDLine;
            }
        else if (*(szCur + 1) == 'E')
            {
            if (*(szCur + 2) == 'C')
                {
                if (!FMatchPrefix(&szCur, "DECOMPRESS", fFalse))
                    grc = grcINFBadFDLine;
                else if (fNot)
                    poer->oef &= ~oefDecompress;
                else
                    poer->oef |= oefDecompress;
                }
            else if (*(szCur + 2) == 'S')
                {
                if (*(szCur + 3) == 'C')
                    {
                    if (!FMatchPrefix(&szCur, "DESCRIPTION", !fNot))
                        grc = grcINFBadFDLine;
                    else if (fNot)
                        poer->szDescription = (SZ)NULL;
                    else if ((poer->szDescription = SzDupl(szCur)) == (SZ)NULL)
                        grc = grcOutOfMemory;
                    }
                else if (*(szCur + 3) == 'T')   /* REVIEW EBU */
                    {
                    if (!FMatchPrefix(&szCur, "DESTINATION", !fNot))
                        grc = grcINFBadFDLine;
                    else if (fNot)
                        poer->szDest = (SZ)NULL;
                    else if ((poer->szDest = SzDupl(szCur)) == (SZ)NULL)
                        grc = grcOutOfMemory;
                    }
                else
                    grc = grcINFBadFDLine;
                }
            else
                grc = grcINFBadFDLine;
            }
        else
            grc = grcINFBadFDLine;
        break;

    case 'N':   /* NoDeleteSource, NoLog */

        if(*(szCur + 1) == 'O') {
            if(*(szCur + 2) == 'D') {
                if(!FMatchPrefix(&szCur, "NODELETESOURCE", fFalse)) {
                    grc = grcINFBadFDLine;
                } else if (fNot) {
                    poer->oef &= ~oefNoDeleteSource;
                } else {
                    poer->oef |= oefNoDeleteSource;
                }
            } else if(*(szCur + 2) == 'L') {
                if(!FMatchPrefix(&szCur, "NOLOG", fFalse)) {
                    grc = grcINFBadFDLine;
                } else if (fNot) {
                    poer->oef &= ~oefNoLog;
                } else {
                    poer->oef |= oefNoLog;
                }
            }
        } else {
            grc = grcINFBadFDLine;
        }
        break;

    case 'O':
        if (!FMatchPrefix(&szCur, "OVERWRITE", !fNot))
            grc = grcINFBadFDLine;
        else if (fNot)
            poer->owm = owmNever;
        else
            {
            switch (*szCur)
                {
            case 'A':
                if (!FMatchPrefix(&szCur, "ALWAYS", fFalse))
                    grc = grcINFBadFDLine;
                poer->owm = owmAlways;
                break;

            case 'N':
                if (!FMatchPrefix(&szCur, "NEVER", fFalse))
                    grc = grcINFBadFDLine;
                poer->owm = owmNever;
                break;

            case 'O':
                if (!FMatchPrefix(&szCur, "OLDER", fFalse))
                    grc = grcINFBadFDLine;
                poer->owm = owmOlder;
                break;

            case 'V':
                if (!FMatchPrefix(&szCur, "VERIFYSOURCEOLDER", fFalse))
                    grc = grcINFBadFDLine;
                poer->owm = owmVerifySourceOlder;
                break;

            case 'U':
                if (!FMatchPrefix(&szCur, "UNPROTECTED", fFalse))
                    grc = grcINFBadFDLine;
                poer->owm = owmUnprotected;
                break;

            default:
                grc = grcINFBadFDLine;
                }
            }
        break;

    case 'R':   /* ReadOnly, Rename, Root */
        if (*(szCur + 1) == 'E')
            {
            if (*(szCur + 2) == 'A')
                {
                if (!FMatchPrefix(&szCur, "READONLY", fFalse))
                    grc = grcINFBadFDLine;
                else if (fNot)
                    poer->oef &= ~oefReadOnly;
                else
                    poer->oef |= oefReadOnly;
                }
            else if (*(szCur + 2) == 'N')
                {
                if (!FMatchPrefix(&szCur, "RENAME", !fNot))
                    grc = grcINFBadFDLine;
                else if (fNot)
                    poer->szRename = (SZ)NULL;
                else if ((poer->szRename = SzDupl(szCur)) == (SZ)NULL)
                    grc = grcOutOfMemory;
                else if (CchlValidSubPath(poer->szRename) == (CCHP)0 ||
                        poer->szAppend != (SZ)NULL ||
                        (poer->oef & oefRoot) == oefRoot)
                    grc = grcINFBadFDLine;
                }
            else
                grc = grcINFBadFDLine;
            }
        else if (*(szCur + 1) == 'O')
            {
            if (!FMatchPrefix(&szCur, "ROOT", fFalse))
                grc = grcINFBadFDLine;
            else if (fNot)
                poer->oef &= ~oefRoot;
            else if (poer->szAppend != (SZ)NULL ||
                    poer->szRename != (SZ)NULL)
                grc = grcINFBadFDLine;
            else
                poer->oef |= oefRoot;
            }
        else
            grc = grcINFBadFDLine;
        break;

    case 'S':   /* SetTimeStamp, Size */
        if (*(szCur + 1) == 'E')
            {
            if (!FMatchPrefix(&szCur, "SETTIMESTAMP", fFalse))
                grc = grcINFBadFDLine;
            else if (fNot)
                poer->oef &= ~oefTimeStamp;
            else
                poer->oef |= oefTimeStamp;
            }
        else if (*(szCur + 1) == 'I')
            {
            if (!FMatchPrefix(&szCur, "SIZE", !fNot))
                grc = grcINFBadFDLine;
            else if (fNot)
                poer->lSize = 0L;
            else if ((poer->lSize = ((LONG)atol(szCur) / 100 )) < 0L)
                grc = grcINFBadFDLine;
            else
                poer->lSize = poer->lSize + 1; // make size atleast one
            }
        else
            grc = grcINFBadFDLine;
        break;

    case 'T':
        if (!FMatchPrefix(&szCur, "TIME", !fNot))
            grc = grcINFBadFDLine;
        else if (fNot)
            poer->ctuCopyTime = (CTU)0;
        else
            {
            LONG l = (LONG)atol(szCur);

            if (l < 0L)
                grc = grcINFBadFDLine;
            else
                poer->ctuCopyTime = (CTU)l;
            }
        break;

    case 'U':
        if (FMatchPrefix(&szCur, "UNDO", fFalse)) {
            if (fNot) {
                poer->oef &= ~oefUndo;
            }
            else {
                poer->oef |= oefUndo;
            }
        }
        else if (FMatchPrefix(&szCur, "UPGRADEONLY", fFalse)) {
            if (fNot) {
                poer->oef &= ~oefUpgradeOnly;
            }
            else {
                poer->oef |= oefUpgradeOnly;
            }
        }
        else {
            grc = grcINFBadFDLine;
        }
        break;

    case 'V':   /* Version, Vital */
        if (*(szCur + 1) == 'E')
            {
            if (!FMatchPrefix(&szCur, "VERSION", !fNot))
                grc = grcINFBadFDLine;
            else if (fNot)
                {
                poer->ulVerMS = 0L;
                poer->ulVerLS = 0L;
                }
            else if (!FParseVersion(szCur, &(poer->ulVerMS), &(poer->ulVerLS)))
                grc = grcINFBadFDLine;
            }
        else if (*(szCur + 1) == 'I')
            {
            if (!FMatchPrefix(&szCur, "VITAL", fFalse))
                grc = grcINFBadFDLine;
            else if (fNot)
                poer->oef &= ~oefVital;
            else
                poer->oef |= oefVital;
            }
        else
            grc = grcINFBadFDLine;
        break;

    default:
        grc = grcINFBadFDLine;
        }

    SFree(sz);
    Assert(grc != grcOkay || FValidPoer(poer));

    return(grc);
}


/*
**  Purpose:
**      Allocates a new Section File Descriptor and fills it by reading and
**      parsing the given INF read line.
**  Arguments:
**      ppsfd: non-Null location to store PSFD if successful.
**      poer:  non-Null valid filled OER pointer.
**  Notes:
**      Requires that the current INF structure was initialized with a
**      successful call to GrcOpenInf().
**  Returns:
**      grcOkay if successful.
**      grcOutOfMemory if out of memory.
**      grcINFBadFDLine if the current line has a bad format.
**      grcNotOkay otherwise.
**
**************************************************************************/
GRC APIENTRY GrcGetSectionFileLine(INT Line,PPSFD ppsfd,POER poer)
{
    PSFD  psfd;
    UINT  cFields, iField;
    SZ    sz;

    AssertDataSeg();

    PreCondInfOpen(grcNotOkay);

    ChkArg(ppsfd != (PPSFD)NULL, 1, grcNotOkay);
    ChkArg(poer  != (POER)NULL,  2, grcNotOkay);
    ChkArg(FValidPoer(poer),     2, grcNotOkay);

    *ppsfd = (PSFD)NULL;

    if ((cFields = CFieldsInInfLine(Line)) < 2)
        return(grcINFBadFDLine);

    if ((psfd = PsfdAlloc()) == (PSFD)NULL)
        return(grcOutOfMemory);

    if ((sz = SzGetNthFieldFromInfLine(Line,1)) == (SZ)NULL)
        {
        EvalAssert(FFreePsfd(psfd));
        return(grcOutOfMemory);
        }

    if ((psfd->did = (DID)atoi(sz)) < didMin ||
            psfd->did > didMost)
        {
        SFree(sz);
        EvalAssert(FFreePsfd(psfd));
        return(grcINFBadFDLine);
        }

    psfd->InfId = pLocalInfPermInfo()->InfId;

    SFree(sz);

    if ((psfd->szFile = SzGetNthFieldFromInfLine(Line,2)) == (SZ)NULL)
        {
        EvalAssert(FFreePsfd(psfd));
        return(grcOutOfMemory);
        }

    if (CchlValidSubPath(psfd->szFile) == (CCHP)0)
        {
        EvalAssert(FFreePsfd(psfd));
        return(grcINFBadFDLine);
        }

    psfd->oer = *poer;

    for (iField = 3; iField <= cFields; iField++)
        {
        GRC grc;

        if ((grc = GrcHandleSfdOption(Line, &(psfd->oer), iField)) != grcOkay)
            {
            /* REVIEW - could just reset all and leave a few strings! */
            if ((psfd->oer).szAppend == poer->szAppend)
                (psfd->oer).szAppend = (SZ)NULL;
            if ((psfd->oer).szBackup == poer->szBackup)
                (psfd->oer).szBackup = (SZ)NULL;
            if ((psfd->oer).szDate == poer->szDate)
                (psfd->oer).szDate = (SZ)NULL;
            if ((psfd->oer).szDescription == poer->szDescription)
                (psfd->oer).szDescription = (SZ)NULL;
            if ((psfd->oer).szDest == poer->szDest)   /* REVIEW EBU */
                (psfd->oer).szDest = (SZ)NULL;
            if ((psfd->oer).szRename == poer->szRename)
                (psfd->oer).szRename = (SZ)NULL;
            EvalAssert(FFreePsfd(psfd));
            return(grc);
            }
        }

    AssertRet(FValidPsfd(psfd), grcNotOkay);

    *ppsfd = psfd;

    return(grcOkay);
}


/*
**  Purpose:
**      Determines if the given INF line is a list-include statement of
**      the form: [ <Key> = ] @( <Section> ) [, @( <Key> ) ]
**  Arguments:
**      none
**  Notes:
**      Requires that the current INF structure was initialized with a
**      successful call to GrcOpenInf() and that the current Read location
**      is valid.
**  Returns:
**      fTrue if current INF line conforms to above format.
**      fFalse if it does not.
**
**************************************************************************/
BOOL APIENTRY FListIncludeStatementLine(INT Line)
{
    UINT cFields;
    SZ   sz, szLast;

    AssertDataSeg();

    PreCondInfOpen(fFalse);

    if ((cFields = CFieldsInInfLine(Line)) < 1 ||
            cFields > 2 ||
            (sz = SzGetNthFieldFromInfLine(Line,1)) == (SZ)NULL)
        return(fFalse);

    if (*sz != '@' ||
            *(sz + 1) != '(' ||
            (szLast = SzLastChar(sz)) == (SZ)NULL ||
            *szLast != ')')
        goto L_FLISL_ERROR;

    SFree(sz);

    if (cFields == 1)
        return(fTrue);

    if ((sz = SzGetNthFieldFromInfLine(Line,2)) == (SZ)NULL)
        return(fFalse);

    if (*sz != '@' ||
            *(sz + 1) != '(' ||
            (szLast = SzLastChar(sz)) == (SZ)NULL ||
            *szLast != ')')
        goto L_FLISL_ERROR;

    SFree(sz);

    return(fTrue);

L_FLISL_ERROR:
    if (sz != (SZ)NULL)
        SFree(sz);

    return(fFalse);
}


/*
**  Purpose:
**      Parses a list-include-statement from an INF file description section.
**  Arguments:
**      pszSection: non-Null pointer to a currently Null string which this
**          routine will replace with a pointer to an allocated buffer
**          containing the section name on the line.
**      pszKey:     non-Null pointer to a currently Null string which this
**          routine will replace with a pointer to an allocated buffer
**          containing the key name on the line if one exists.
**  Notes:
**      Requires that the current INF structure was initialized with a
**      successful call to GrcOpenInf() and that the current Read location
**      is valid and that it points to a valid list-include statement.
**  Returns:
**      grcOkay if successful.
**      grcOutOfMemory if out of memory.
**      grcNotOkay otherwise.
**
**************************************************************************/
GRC APIENTRY GrcGetListIncludeSectionLine(INT Line,
                                                     PSZ pszSection,
                                                     PSZ pszKey)
{
    UINT   cFields;
    SZ     sz, szLast;

    AssertDataSeg();

    PreCondInfOpen(grcNotOkay);
    PreCondition(FListIncludeStatementLine(Line), grcNotOkay);

    ChkArg(pszSection != (PSZ)NULL && *pszSection == (SZ)NULL, 1, grcNotOkay);
    ChkArg(pszKey     != (PSZ)NULL && *pszKey     == (SZ)NULL, 2, grcNotOkay);

    EvalAssert((cFields = CFieldsInInfLine(Line)) == 1 || cFields == 2);
    if ((sz = SzGetNthFieldFromInfLine(Line,1)) == (SZ)NULL)
        return(grcOutOfMemory);

    Assert(*sz == '@' && *(sz + 1) == '(');
    EvalAssert((szLast = SzLastChar(sz)) != (SZ)NULL);
    Assert(*szLast == ')');

    *szLast = '\0';
    *pszSection = SzDupl(sz + 2);
    *szLast = ')';

    if (*pszSection == (SZ)NULL)
        goto L_GGLISL_ERROR;

    SFree(sz);
    sz = (SZ)NULL;

    if (cFields == 1)
        return(grcOkay);

    Assert(cFields == 2);
    if ((sz = SzGetNthFieldFromInfLine(Line,2)) == (SZ)NULL)
        goto L_GGLISL_ERROR;

    Assert(*sz == '@' && *(sz + 1) == '(');
    EvalAssert((szLast = SzLastChar(sz)) != (SZ)NULL);
    Assert(*szLast == ')');

    *szLast = '\0';
    *pszKey = SzDupl(sz + 2);
    *szLast = ')';

    if (*pszKey == (SZ)NULL)
        goto L_GGLISL_ERROR;

    SFree(sz);

    return(grcOkay);

L_GGLISL_ERROR:
    if (sz != (SZ)NULL)
        SFree(sz);
    if (*pszSection != (SZ)NULL)
        SFree(*pszSection);
    if (*pszKey != (SZ)NULL)
        SFree(*pszKey);

    return(grcOutOfMemory);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\inf3.c ===
#include "precomp.h"
#pragma hdrstop
/**************************************************************************/
/***** Common Library Component - INF File Handling Routines 8 ************/
/**************************************************************************/


/*
**  Purpose:
**      Frees the memory used by an RGSZ.
**  Arguments:
**      rgsz: the array of string pointers to free.  Must be non-NULL though
**          it may be empty.  The first NULL string pointer in rgsz must be
**          in the last location of the allocated memory for rgsz.
**  Returns:
**      fFalse if any of the free operations fail.
**      fTrue if all the free operations succeed.
**
**************************************************************************/
BOOL  APIENTRY FFreeRgsz(rgsz)
RGSZ rgsz;
{
    BOOL   fAnswer = fTrue;
    USHORT cItems  = 0;

    AssertDataSeg();

    ChkArg(rgsz != (RGSZ)NULL, 1, fFalse);

    while (*(rgsz + cItems) != (SZ)NULL)
        {
        SFree(*(rgsz + cItems));
        cItems++;
        }

    SFree(rgsz);

    return(fAnswer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\infdebug.c ===
#include "precomp.h"
#pragma hdrstop
#if DEVL
typedef enum {
    CmdNone,
    CmdHelp,
    CmdGo,
    CmdList,
    CmdTrace,
    CmdSymbol,
    CmdTraceback,
    CmdCurrent,
    CmdNearestLabel,
    CmdBreak
} InfCmd;

BOOL StopAtLine = FALSE;
CHAR CmdBuffer[256];
#endif

BOOL
SdpReconstructLine(
    IN  PINFLINE MasterLineArray,
    IN  UINT     MasterLineCount,
    IN  UINT     Line,
    OUT PUCHAR   Buffer,
    IN  UINT     BufferSize
    )

/*++

Routine Description:

    Reconstruct a pseudo-line in an inf file, placing it into the
    global temporary buffer.

Arguments:

    MasterLineArray - supplies master line array for inf in question

    MasterLineCount - supplies # of pseudo-lines in the inf

    Line - supplies pseudo-line # of line to dump

    Buffer - supplies output buffer

    BufferSize - supplies max # characters that fit into Buffer

Return Value:

    None.

--*/

{
    PCHAR pIn;
    PCHAR pOut = Buffer;
    PINFLINE InfLine;
    UCHAR c;

    InfLine = &MasterLineArray[Line];

    pIn = InfLine->text.addr;

    memset(Buffer,0,BufferSize);

    if(InfLine->flags & INFLINE_SECTION) {

        *pOut++ = '[';
        lstrcpy(pOut,pIn);
        lstrcat(pOut,"]");

    } else {

        if(InfLine->flags & INFLINE_KEY) {
            lstrcpy(pOut,pIn);
            lstrcat(pOut," = ");
            pOut += lstrlen(pOut);
            pIn += lstrlen(pIn);
        }

        while(pIn < MasterLineArray[Line+1].text.addr) {

            switch(c = *pIn++) {

            case TOKEN_VARIABLE:
                *pOut++ = '$';
                *pOut++ = '(';
                break;

            case TOKEN_LIST_FROM_SECTION_NTH_ITEM:
                *pOut++ = '^';
                *pOut++ = '(';
                break;

            case TOKEN_LOCATE_ITEM_IN_LIST:
                *pOut++ = '~';
                *pOut++ = '(';
                break;

            case TOKEN_NTH_ITEM_FROM_LIST:
                *pOut++ = '*';
                *pOut++ = '(';
                break;

            case TOKEN_FIELD_ADDRESSOR:
                *pOut++ = '#';
                *pOut++ = '(';
                break;

            case TOKEN_APPEND_ITEM_TO_LIST:
                *pOut++ = '>';
                *pOut++ = '(';
                break;

            case TOKEN_LIST_START:
                *pOut++ = '{';
                break;

            case TOKEN_LIST_END:
                *pOut++ = '}';
                break;

            case TOKEN_SPACE:
                *pOut++ = ' ';
                break;

            case TOKEN_COMMA:
                *pOut++ = ',';
                break;

            case TOKEN_RIGHT_PAREN:
                *pOut++ = ')';
                break;

            default:

                if(IS_STRING_TOKEN(c)) {

                    ULONG len;

                    switch(c) {
                    case TOKEN_STRING:
                        len = (ULONG)(*pIn++) + 100;
                        break;
                    case TOKEN_LONG_STRING:
                        len = (ULONG)((*pIn++) << 8) + (ULONG)(*pIn++);
                        break;
                    default:
                        // short string
                        len = c - TOKEN_SHORT_STRING;
                        break;
                    }

                    strncpy(pOut,pIn,len);
                    pOut += len;
                    pIn += len;
                }
                break;
            }
        }
    }
    return(TRUE);
}

#if DEVL
VOID
SdTracingOn(
    VOID
    )

/*++

Routine Description:

    Turn inf tracing on.

Arguments:

    None.

Return Value:

    None.

--*/

{
    StopAtLine = !StopAtLine;
    DbgPrint("SETUP: INF Tracing %s.\n",StopAtLine ? "on; will break at next line" : "off");
}



InfCmd
SdGetCmd(
    PCHAR *CharAfterCmd
    )

/*++

Routine Description:

    Fetch a command from the user.

Arguments:

    CharAfterCmd - receives a pointer to the character that terminated
        the command string.

Return Value:

    member of InfCmd enum indicating which command the user entered

--*/

{
    PCHAR p;

    while(1) {
        DbgPrompt("setup>",CmdBuffer,sizeof(CmdBuffer));

        if(CmdBuffer[0]) {

            p = strpbrk(CmdBuffer," \t");
            *CharAfterCmd = p ? p : strchr(CmdBuffer,'\0');

            switch(tolower(CmdBuffer[0])) {
            case 'd':
                return(CmdSymbol);
            case 'g':
                return(CmdGo);
            case 'h':
            case '?':
                return(CmdHelp);
            case 'k':
                return(CmdTraceback);
            case 'l':
                if(tolower(CmdBuffer[1]) == 'n') {
                    return(CmdNearestLabel);
                }
                break;
            case 'r':
                return(CmdCurrent);
            case 't':
                return(CmdTrace);
            case 'u':
                return(CmdList);
            case 'x':
                return(CmdBreak);
            }
            DbgPrint("%s: unknown command\n",CmdBuffer);
        }
    }
}


PCHAR
SdpFindSection(
    IN PPARSED_INF ParsedInf,
    IN UINT        Line
    )

/*++

Routine Description:

    Determine the section name of given pseudo-line.

Arguments:

    ParsedInf - supplies a pointer to the inf parse structure for the
        inf file in which the line is located.

    Line - supplies the pseudo-line.

Return Value:

    Name of the section, or NULL if it can't be determined

--*/

{
    INT L;
    PCHAR Section = NULL;

    for(L=(INT)Line; L>=0; --L) {
        if(ParsedInf->MasterLineArray[L].flags & INFLINE_SECTION) {
            Section = ParsedInf->MasterLineArray[L].text.addr;
            break;
        }
    }
    return(Section);
}

VOID
SdpCurrentLineOut(
    IN UINT Line
    )

/*++

Routine Description:

    Dump out a line in the current context.

Arguments:

    Line - supplies pseudo-line number of line to dump

Return Value:

    None.

--*/

{
    PCHAR Section;
    CHAR buf[1024];

    //
    // Determine the current section name by searching backwards for
    // a line with its section flag set.
    //

    Section = SdpFindSection(pLocalInfTempInfo()->pParsedInf,Line);

    DbgPrint("%s.INF:[%s]\n",pLocalInfPermInfo()->szName,Section ? Section : "???");

    SdpReconstructLine( pLocalInfTempInfo()->pParsedInf->MasterLineArray,
                        pLocalInfTempInfo()->pParsedInf->MasterLineCount,
                        Line,
                        buf,
                        1024
                      );

    DbgPrint("%s\n",buf);
}


VOID
SdpInfDebugPrompt(
    IN UINT Line
    )

/*++

Routine Description:

    Debug prompt.  Accept a command from the user and act on it.

    If we got here via SdBreakNow, then not all commands will function
    as one might expect -- for example, tracing won't return until the
    next line is actually interpreted.

Arguments:

    None.

Return Value:

    None.

--*/

{
    CHAR buf[1024];
    PCHAR Section;
    INT L;
    UINT UL;
    PCHAR NextChar;
    BOOL looping = TRUE;
    InfCmd cmd;
    PINFCONTEXT Context;
    BOOL Found;
    PPARSED_INF ParsedInf;

    if(!StopAtLine) {
        return;
    }

    DbgPrint("\n");

    SdpCurrentLineOut(Line);

    while(looping) {
        switch(cmd = SdGetCmd(&NextChar)) {
        case CmdHelp:
            DbgPrint("d <symbol> - print current value of <symbol>\n");
            DbgPrint("g - go\n");
            DbgPrint("h,? - print this message\n");
            DbgPrint("k - crude traceback\n");
            DbgPrint("ln - list nearest preceding line in section with a key\n");
            DbgPrint("r - list current line again\n");
            DbgPrint("t - trace one line\n");
            DbgPrint("u - list a few lines starting at current line\n");
            DbgPrint("x - break into debugger\n");
            DbgPrint("\n");
            break;
        case CmdGo:
            StopAtLine = FALSE;
            looping = FALSE;
            break;
        case CmdTrace:
            StopAtLine = TRUE;
            looping = FALSE;
            break;
        case CmdList:
            //
            // List out a few lines.
            //
            for(UL=Line+1; (UL<pLocalInfTempInfo()->pParsedInf->MasterLineCount) && (UL<Line+6); UL++) {
                SdpReconstructLine( pLocalInfTempInfo()->pParsedInf->MasterLineArray,
                                    pLocalInfTempInfo()->pParsedInf->MasterLineCount,
                                    UL,
                                    buf,
                                    1024
                                  );
                DbgPrint("%s\n",buf);
            }
            DbgPrint("\n");
            break;
        case CmdBreak:
            DbgUserBreakPoint();
            break;
        case CmdSymbol:
            //
            // Look up a symbol.
            //
            if(*NextChar) {
                PCHAR Value = SzFindSymbolValueInSymTab(NextChar+1);
                if(Value) {
                    DbgPrint("Value = %s\n",Value);
                } else {
                    DbgPrint("Symbol not found.\n");
                }
            } else {
                DbgPrint("No symbol given.\n");
            }
            DbgPrint("\n");
            break;
        case CmdTraceback:
            //
            // Perform a sort of crude traceback.
            //
            Context = pLocalContext()->pNext;
            while(Context) {
                Section = SdpFindSection(Context->pInfTempInfo->pParsedInf,Context->CurrentLine-1);
                DbgPrint("%s.INF:[%s]\n",Context->pInfTempInfo->pInfPermInfo->szName,Section ? Section : "???");
                SdpReconstructLine( Context->pInfTempInfo->pParsedInf->MasterLineArray,
                                    Context->pInfTempInfo->pParsedInf->MasterLineCount,
                                    Context->CurrentLine-1,
                                    buf,
                                    1024
                                  );
                DbgPrint("    %s\n",buf);
                Context = Context->pNext;
            }
            DbgPrint("\n");
            break;
        case CmdNearestLabel:
            //
            // Search backwards for the nearest line w/ a key.
            //
            ParsedInf = pLocalInfTempInfo()->pParsedInf;
            for(Found=FALSE,L=(INT)Line; L>=0; --L) {
                if(ParsedInf->MasterLineArray[L].flags & INFLINE_KEY) {
                    Found = TRUE;
                    break;
                }
                if(ParsedInf->MasterLineArray[L].flags & INFLINE_SECTION) {
                    break;
                }
            }
            if(Found) {
                SdpReconstructLine( ParsedInf->MasterLineArray,
                                    ParsedInf->MasterLineCount,
                                    (UINT)L,
                                    buf,
                                    1024
                                  );
                DbgPrint("%s\n",buf);
            } else {
                DbgPrint("Key not found in this section.\n");
            }
            DbgPrint("\n");
            break;
        case CmdCurrent:
            //
            // Print the current line again
            //
            SdpCurrentLineOut(Line);
            DbgPrint("\n");
            break;
        }
    }
}


VOID
SdAtNewLine(
    IN UINT Line
    )

/*++

Routine Description:

    This routine should be called just before execution of a new line.

Arguments:

    None.

Return Value:

    None.

--*/

{
    SdpInfDebugPrompt(Line);
}


VOID
SdBreakNow(
    VOID
    )

/*++

Routine Description:

    Break into the inf debug prompt now.

Arguments:

    None.

Return Value:

    None.

--*/

{
    StopAtLine = TRUE;
    SdpInfDebugPrompt(pLocalContext()->CurrentLine-1);
}

#endif // DEVL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\infload1.c ===
#include "precomp.h"
#pragma hdrstop
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    infload1.c

Abstract:

    Routines to load an INF file and proprocess it, eliminating
    comments and line continuations, and collapsing adjacent WS
    and NLs.

    The result is a series of NUL-terminated lines, with no blank lines
    or lines with only comments or whitespace, etc.

Author:

    Ted Miller (tedm) 9-Spetember-1991

--*/

/*
    The purpose of the preprocessing step is to create a series of
    significant lines, with comments stripped out.

    The file is read from disk into a single large buffer.  A destination
    buffer is allocated to hold the preprocessed file.  This buffer
    is initially the size of the file image but will be reallocated
    when proprocessing is completed.

    The input image is considered to be a sequence of LF or CR/LF
    separated lines.  One line in the input file is equivalent to
    one line in the output unless the lines are logically joined with
    line continuation characters.

        - A line continuation character is a non-quoted + which has no
          non-space, non-tab, or non-comment text after it on the line.
          Line continuation is accomplished by eliminating all characters
          from the + through adjacent spaces, tabs, comments, and EOLs.

        - Two consecutive double quote characters inside a quoted
          string are replaced by a single double quote.

        - Semantic double quuote chars (ie, those that begin and
          end strings) are replaced by DQUOTE.  Double quotes
          that are actually part of the string (see first rule) are
          emitted as actual double quote chars.  This is so that later
          steps can tell the difference between two adjacent quoted
          strings and a string containing a quoted double quote.

        - All strings of consecutive spaces and tabs are replaced
          by a single space.  A single space is in turn eliminated
          if it occurs immediately adjacent to a comma.

        - All comments are eliminated.  A comment is an unquoted
          semi-colon and consists of the rest of the line (to EOL).

        - CR/LF or LF are replaced by NUL.  The EOL does not result
          in any implied actions being carried out -- ie, a terminating
          double quote being supplied if none exists in the input.

        - Adjacent NULs are never stored in the output.  There will
          be at most a single consecutive NUL character in the output.
          Also, a space following a NUL is eliminated, as is a space
          preceeding a NUL.

    No syntax errors are reported from this step.
*/


PUCHAR CurrentOut;      // points to next cell in output image
BOOL   InsideQuotes;    // self-explanatory flag

#define IsWS(x)         (((x) == ' ') || ((x) == '\t'))
#define SkipWS(x)       Preprocess_SkipChars(x," \t")
#define SkipWSEOL(x)    Preprocess_SkipChars(x," \t\r\n");
#define SkipComment(x)  Preprocess_SkipChars(x,"");

#define  CtN  0               //   Normal char; NOTE: same as ZERO!
#define  CtS  1               //   Space
#define  CtE  2               //   EOL
#define  CtC  3               //   Comma
#define  CtF  4               //   EOF

static BYTE charTypeTable [256] =
{
    //        00   01   02   03   04   05   06   07   08   09   0a   0b   0c   0d   0e   0f
    //         0    1    2    3    4    5    6    7    8    9   11   12   13   13   14   15
    /////////////////////////////////////////////////////////////////////////////////////////
    /* 00 */ CtE,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    /* 10 */   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, CtF,   0,   0,   0,   0,   0,
    /* 20 */ CtS,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, CtC,   0,   0,   0,
    /* 30 */   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    /* 40 */   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    /* 50 */   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    /* 60 */   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    /* 70 */   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    /* 80 */   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    /* 90 */   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    /* 0a */   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    /* 0b */   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    /* 0c */   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    /* 0d */   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    /* 0e */   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    /* 0f */   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0
};

/*
    In: pointer to a char
        list of chars to skip
    Out: pointer to first char not in the skip list

    Also: skips comments.
*/

VOID
Preprocess_SkipChars(
    LPBYTE *StartingLoc,
    LPSTR  CharList
    )
{
    UCHAR  c;
    PUCHAR p = *StartingLoc;
    PUCHAR pch;
    BOOL   InList;

    while(1) {

        c = *p;

        InList = FALSE;
        for(pch=CharList; *pch; pch++) {
            if(*pch == c) {
                InList = TRUE;
                break;
            }
        }

        if(!InList) {

            /*
                We don't need to bother with seeing if we're in quotes
                because this routine is never called when we are.
            */

            if(c == ';') {

                while(*(++p) != NL) {
                    ;
                }           // at loop exit, p points to NL

            } else {        // not in skip list and not a comment

                *StartingLoc = p;
                return;
            }

        } else {            // c is in the list, so skip it

            p++;
        }
    }
}


/*
    Create a preprocessed in-memory version of an inf file as follows:

    The result is a series of NUL-terminated lines, with no blank lines
    or lines with only comments or whitespace, etc.
*/

GRC
PreprocessINFFile(
    LPSTR  FileName,
    LPBYTE *ResultBuffer,
    UINT   *ResultBufferSize
    )
{
    HANDLE FileHandle;
    LONG   FileSize;
    LPBYTE FileBuffer;      // the input
    LPBYTE INFBuffer;       // the output
    LPBYTE p,q;             // current char in file image
    UCHAR  c;
    register int iEmit ;
    int iEmit2 ;
    static UCHAR  PreviousChar = EOL;
    static PUCHAR PreviousPos;


    if((FileHandle = (HANDLE)LongToHandle(_lopen(FileName,OF_READ))) == (HANDLE)(-1)) {
        return(grcBadINF);
    }

    FileSize = _llseek(HandleToUlong(FileHandle),0,2);    // move to end of file
    _llseek(HandleToUlong(FileHandle),0,0);               // move back to start of file

    if((FileBuffer = SAlloc(FileSize+2)) == NULL) {
        _lclose(HandleToUlong(FileHandle));
        return(grcOutOfMemory);
    }

    if(_lread(HandleToUlong(FileHandle),FileBuffer,(UINT)FileSize) == -1) {
        _lclose(HandleToUlong(FileHandle));
        SFree(FileBuffer);
        return(grcBadINF);
    }

    _lclose(HandleToUlong(FileHandle));
    FileBuffer[FileSize] = NL;      // in case last line is incomplete
    FileBuffer[FileSize+1] = 0;     // to terminate the image

    if((INFBuffer = SAlloc(FileSize)) == NULL) {
        SFree(FileBuffer);
        return(grcOutOfMemory);
    }

    p = FileBuffer;
    CurrentOut = INFBuffer;

    InsideQuotes = FALSE;

    iEmit  = -1 ;
    iEmit2 = -1 ;

    while(c = *p)
    {
        if(c == CR) {

            p++;
            continue;

        } else if(c == NL) {

            iEmit = 0 ;
            p++;

        } else if(c == '"') {

            if(InsideQuotes && (*(p+1) == '"')) {
                // we've got a quoted quote
                iEmit = '"' ;
                p++;                // skip first quote
            } else {
                InsideQuotes = !InsideQuotes;
                iEmit = DQUOTE ;
            }
            p++;

        } else if(InsideQuotes) {

            // just spit out the character

            iEmit = c ;
            p++;

        } else if (c == '+') {  // line continuation

            p++;                // skip the +

            q = p;

            SkipWS(&p);

            if((*p == CR) || (*p == NL)) {      // line continuation

                SkipWSEOL(&p);

            } else {                            // ordinary character

                iEmit = '+' ;                   // p already advanced (above)

                if(p != q) {                    // preserve ws between + and
                    iEmit2 = ' ' ;              // char that follows
                }
            }

        } else if(IsWS(c)) {

            iEmit = ' ' ;
            SkipWS(&p);

        } else if(c == ';') {

            SkipComment(&p);

        } else {

            iEmit = c ;                            // plain old character
            p++;
        }

        /*
            Store a character in the output stream.

            Control-z's are eliminated.
            Consecutive NL's after the first are eliminated.
            WS immediately following a NL is eliminated.
            NL immediately following a WS is stored over the WS, eliminating it.
            WS immediately before and after a comma is eliminated.
        */

        if ( iEmit >= 0 )
        {
            switch ( charTypeTable[iEmit] )
            {
            case CtN: // Normal stuff
                break ;

            case CtS: //  Space
                if(  PreviousChar == EOL
                   ||(!InsideQuotes && (PreviousChar == ',')))
                {                                   // don't store WS after NL's or ,'s
                    iEmit = -1 ;
                }
                break ;

            case CtE: // EOL
                if(PreviousChar == EOL) {
                    iEmit = -1 ;                    // don't store adjacent NL's
                } else if(PreviousChar == ' ') {    // WS/NL ==> collapse to NL
                    CurrentOut = PreviousPos;       // back up over the space first
                }
                InsideQuotes = FALSE;               // reset quotes status
                break ;

            case CtC:  // Comma
                if ( !InsideQuotes && (PreviousChar == ' ')) {
                    CurrentOut = PreviousPos;
                }
                break ;

            case CtF: // 0x1a or Ctrl-Z
                iEmit= -1 ;
                break ;
            }

            if ( iEmit >= 0 )
            {
                PreviousChar = (UCHAR)iEmit ;
                PreviousPos = CurrentOut;
                *CurrentOut++ = (UCHAR)iEmit;

                if ( iEmit2 >= 0 )
                {
                    PreviousChar = (UCHAR)iEmit2 ;
                    PreviousPos = CurrentOut;
                    *CurrentOut++ = (UCHAR)iEmit2 ;
                    iEmit2 = -1 ;
                }
                iEmit = -1 ;
            }
        }
    }

    SFree(FileBuffer);

    *ResultBufferSize = (UINT)(CurrentOut - INFBuffer) ;

    *ResultBuffer = SRealloc(INFBuffer,*ResultBufferSize);
    Assert(*ResultBuffer);              // it was shrinking!

    return(grcOkay);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\infload.c ===
#include "precomp.h"
#pragma hdrstop
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    infload.c

Abstract:

    Top-level routines to load and process an INF file.

Author:

    Ted Miller (tedm) 10-Spetember-1991

--*/




GRC
LoadINFFile(
    LPSTR     FileName,
    PUCHAR   *PreparsedFile,
    UINT     *PreparsedSize,
    PINFLINE *LineArray,
    UINT     *LineArrayCount
    )
{
    LPBYTE   PreprocessedFile;
    UINT     PreprocessedSize;
    GRC      rc;

    rc = PreprocessINFFile(FileName,&PreprocessedFile,&PreprocessedSize);

    if(rc == grcOkay) {

        rc = PreparseINFFile(PreprocessedFile,
                             PreprocessedSize,
                             PreparsedFile,
                             PreparsedSize,
                             LineArray,
                             LineArrayCount
                            );

        SFree(PreprocessedFile);
    }
    return(rc);
}


GRC
APIENTRY
GrcOpenInf(
    SZ      FileName,
    PVOID   pInfTempInfo
    )
{

    PPARSED_INF    pParsedInf = ((PINFTEMPINFO)pInfTempInfo)->pParsedInf;

    pParsedInf->MasterFile       = NULL;
    pParsedInf->MasterFileSize   = 0;
    pParsedInf->MasterLineArray  = NULL;
    pParsedInf->MasterLineCount  = 0;

    return(LoadINFFile(FileName,
                       &(pParsedInf->MasterFile),
                       &(pParsedInf->MasterFileSize),
                       &(pParsedInf->MasterLineArray),
                       &(pParsedInf->MasterLineCount)
                      )
           );
}


BOOL
InfIsOpen(
    VOID
    )
{
    return(! (   !pLocalInfTempInfo()->pParsedInf->MasterLineArray
              && !pLocalInfTempInfo()->pParsedInf->MasterLineCount
              && !pLocalInfTempInfo()->pParsedInf->MasterFile
              && !pLocalInfTempInfo()->pParsedInf->MasterFileSize
             )
          );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\infload2.c ===
#include "precomp.h"
#pragma hdrstop
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    infload2.c

Abstract:

    Routines to lex and preparse a preprocessed INF file, breaking it up
    into a series of tokens and overlaying a field-oriented structure
    on top of it.

Author:

    Ted Miller (tedm) 10-Spetember-1991

--*/


/*
    The purpose of this step is to create a tokenized description of
    an INF file and to overlay an indexing structure on top of it.

    The input is a preprocessed INF file (see infload1.c).  Items
    referenced in the input in the discussion below are assumed to be
    items in the preprocessed version of an INF file.  The output
    is a buffer with a series of NUL-terminated byte strings that
    represent fields, and an array with line indexing information.

    The indexing structure is a array of structures.  Each struct contains
    a pointer to the first field on the line and some flags.  The flags and
    their functions are described below.  Fields are stored such that all
    the characters in the output between the pointer to line n and the
    pointer to line n+1 are part of line n.  Thus locating field x on line
    n is a matter of locating the pointer to line n from the indexing array,
    and counting x NULs between that pointer and the pointer to line n+1.
    A dummy line is placed at the end of the output to eliminate a special
    case for the last line in the file.

    A field is delineated by a space or comma not inside an operator or
    quotes, or by the EOL.  Fields thus may not span lines in the input.
    A field may contain one or more syntactic structures (operators with
    arguments or strings) which are considered logically concatenated.

    An operator is a reserved character followed by a left parenthesis,
    followed by one or more comma- or space- delineated arguements,
    followed by a right parenthesis.  This step does not check for the
    correct number of arguments.  See IsOperatorChar() and GetToken()
    below for the current list of reserved characters/operators.

    A syntax error will be reported if EOL is encountered before the
    operator structure is complete (ie before the balancing right paren).
    A right paren that doesn't close an operator has no special semantics.
    It's a regular character like any other, as are operators chars that
    are not followed by a left parenthesis.

    A list is a curly-bracket enclosed set of comma or space-delineated
    items (operators and text).

    A text string is any sequence of characters that does not include
    operator or other reserved characters.  Strings, operators, and lists
    may be arbitrarily concatenated within fields, list items, and operator
    arguments.

    The parsing is fully recursive such that lists and operators may
    enclose each other to arbitrary depths.

    Operators, lists, commas, spaces, right parenthesis, list terminator
    characters, and strings are tokenized.  There are certain exceptions
    which work in concert with the flags in the indexing array to allow
    efficient section lookups and key searching.

    A section title line is recognized when the first character in an input
    line is the left bracket.  All characters through the terminating
    right bracket form the section name.  The sewction name is not
    tokenized and there are no special semantics associated with any character
    in a section name (including double quotes).  A syntax error is
    reported if there is no right bracket on the line or if there are
    characters on the line beyond the terminating right bracket.  This scheme
    allows for striaght string compares between a section being searched for
    and the strings pointed to by entries in the indexing array marked as
    section lines.

    A key line is recognized when an unquoted equals sign is seen as the final
    character of the first field on a line, or as the first character
    of the second field on the line if the fields are separated by a
    space.  The equals sign is discarded and the text from the beginning of
    the line to the character preceeding the equals sign is (literally)
    the key.  This scheme allows for striaght string compares between a
    key being searched for and the strings pointed to by entries in the
    indexing array marked as key lines.

    The output buffer grows as necessary to hold the preparsed image.
*/

#define  CtO  1               //   Operator
#define  CtT  2               //   String terminator
#define  CtS  4               //   Separator
#define  CtB  (CtO|CtT|CtS)   //   String Terminator composite
static BYTE charTypeTable [256] =
{
    //        00   01   02   03   04   05   06   07   08   09   0a   0b   0c   0d   0e   0f
    //         0    1    2    3    4    5    6    7    8    9   11   12   13   13   14   15
    /////////////////////////////////////////////////////////////////////////////////////////
    /* 00 */   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    /* 10 */   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    /* 20 */ CtS,   0,   0, CtO, CtO,   0,   0,   0, CtT, CtT, CtO,   0, CtS,   0,   0,   0,
    /* 30 */   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, CtT,   0,
    /* 40 */   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    /* 50 */   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, CtO,   0,
    /* 60 */   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    /* 70 */   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, CtT, CtO,   0,
    /* 80 */   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    /* 90 */   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    /* 0a */   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    /* 0b */   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    /* 0c */   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    /* 0d */   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    /* 0e */   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    /* 0f */   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0
};

#define OPERATOR_CHAR(c)   (charTypeTable[c] & CtO)
#define SEPARATOR_CHAR(c)  (charTypeTable[c] & CtS)
#define STRING_TERMINATOR(c,cNext) (\
           (OPERATOR_CHAR(c) && (cNext == '(')) \
       ||  SEPARATOR_CHAR(c)                    \
       ||  (InOp && (c == ')'))                 \
       ||  (InList && (c == '}')) )


#define  TkVA  TOKEN_VARIABLE                    // $
#define  TkLN  TOKEN_LIST_FROM_SECTION_NTH_ITEM  // ^
#define  TkFA  TOKEN_FIELD_ADDRESSOR             // #
#define  TkAI  TOKEN_APPEND_ITEM_TO_LIST         // >
#define  TkNI  TOKEN_NTH_ITEM_FROM_LIST          // *
#define  TkLI  TOKEN_LOCATE_ITEM_IN_LIST         // ~
#define  TkLS  TOKEN_LIST_START                  // {
#define  TkLE  TOKEN_LIST_END                    // }
#define  TkSP  TOKEN_SPACE                       // ' '
#define  TkCM  TOKEN_COMMA                       // ,
#define  TkRP  TOKEN_RIGHT_PAREN                 // )
#define  Tk__  TOKEN_UNKNOWN                     // 255
#define  TkEL  TOKEN_EOL                         // NUL

    //  Table used for general token determination

static BYTE tokTypeTable1 [256] =
{
    //        00   01   02   03   04   05   06   07   08   09   0a   0b   0c   0d   0e   0f
    //         0    1    2    3    4    5    6    7    8    9   11   12   13   13   14   15
    /////////////////////////////////////////////////////////////////////////////////////////
    /* 00 */TkEL,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,
    /* 10 */Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,
    /* 20 */TkSP,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,TkRP,Tk__,Tk__,TkCM,Tk__,Tk__,Tk__,
    /* 30 */Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,
    /* 40 */Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,
    /* 50 */Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,
    /* 60 */Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,
    /* 70 */Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,TkLS,Tk__,TkLE,Tk__,Tk__,
    /* 80 */Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,
    /* 90 */Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,
    /* 0a */Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,
    /* 0b */Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,
    /* 0c */Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,
    /* 0d */Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,
    /* 0e */Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,
    /* 0f */Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__
};

  //  Table used for operator determination

static BYTE tokTypeTable2 [256] =
{
    //        00   01   02   03   04   05   06   07   08   09   0a   0b   0c   0d   0e   0f
    //         0    1    2    3    4    5    6    7    8    9   11   12   13   13   14   15
    /////////////////////////////////////////////////////////////////////////////////////////
    /* 00 */TkEL,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,
    /* 10 */Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,
    /* 20 */Tk__,Tk__,Tk__,TkFA,TkVA,Tk__,Tk__,Tk__,Tk__,Tk__,TkNI,Tk__,Tk__,Tk__,Tk__,Tk__,
    /* 30 */Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,TkAI,Tk__,
    /* 40 */Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,
    /* 50 */Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,TkLN,Tk__,
    /* 60 */Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,
    /* 70 */Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,TkLI,Tk__,
    /* 80 */Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,
    /* 90 */Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,
    /* 0a */Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,
    /* 0b */Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,
    /* 0c */Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,
    /* 0d */Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,
    /* 0e */Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,
    /* 0f */Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__,Tk__
};

#define PREPARSE_MAX_TOKEN   10000

/*
    Values used in creating and enlarging the preparse output buffer.
*/

#define     PREPARSE_BUFFER_INITIAL     65536
#define     PREPARSE_BUFFER_DELTA       8192

UINT     OutputBufferSize;
UINT     OutputImageSize;
PUCHAR   OutputBuffer;
UINT     INFLineCount;
PINFLINE INFLineArray;
GRC      Preparse_Error;

PUCHAR Inputp;

UINT   InOp;
UINT   InList;

/*
    necessary function prototypes
*/

BYTE   GetToken(VOID);
BYTE   PreparseSectionNameLine(VOID);
BYTE   PreparseString(VOID);
BYTE   PreparseOperator(BYTE OpToken);
BYTE   PreparseNextToken(VOID);
BYTE   PreparseList(VOID);
USHORT TraverseCountAndEmitString( PUCHAR *pp, PUCHAR pbuff );
BYTE   HandleKey(UINT Line);


/*
    Set up the output buffer by allocating it to its initial size
    and setting up size vars.

    Also initialize global vars.
*/

BOOL
InitPreparsing(
    VOID
    )
{
    BOOL rc = FALSE;

    if((OutputBuffer = SAlloc(PREPARSE_BUFFER_INITIAL)) != NULL) {
        rc = TRUE;
        OutputBufferSize = PREPARSE_BUFFER_INITIAL;
        OutputImageSize = 0;
        InOp = 0;
        InList = 0;
    } else {
        Preparse_Error = grcOutOfMemory;
    }
    return(rc);
}

VOID
Preparse_ErrorTermination(
    VOID
    )
{
    SFree(INFLineArray);
    SFree(OutputBuffer);
    return;
}


/*
    Place a character in the output buffer, making sure that the
    output buffer grows as necessary.
*/
#define EMIT(c)     Preparse_StoreChar(c)

BOOL
Preparse_StoreChar(
    UCHAR c
    )
{
    PUCHAR p;

    if(OutputBufferSize == OutputImageSize) {

        p = SRealloc(OutputBuffer,
                      OutputBufferSize + PREPARSE_BUFFER_DELTA
                      );

        if(p == NULL) {
            SFree(OutputBuffer);
            Preparse_Error = grcOutOfMemory;
            return(FALSE);
        }

        OutputBufferSize += PREPARSE_BUFFER_DELTA;
        OutputBuffer = p;
    }

    OutputBuffer[OutputImageSize++] = c;
    return(TRUE);
}


/*
    Count the # of NULs in an image.  If the image is a preprocessed
    INF file (from PreprocessINFFile), then this counts lines.
*/

UINT
CountNULs(
    PUCHAR  Image,
    UINT    ImageSize
    )
{
    PUCHAR p;
    UINT   NULCount = 0;

    for(p=Image; p<Image+ImageSize; p++) {
        if(*p == '\0') {
            NULCount++;
        }
    }
    return(NULCount);
}


GRC
PreparseINFFile(
    PUCHAR    INFFile,
    UINT      INFFileSize,
    PUCHAR   *PreparsedINFFile,
    UINT     *PreparsedINFFileBufferSize,
    PINFLINE *LineArray,
    UINT     *LineCount
    )
{
    UINT     Line;                  // current line being processed
    BYTE     Token;

    INFLineCount = CountNULs(INFFile,INFFileSize);

    if((INFLineArray = (PINFLINE)SAlloc((INFLineCount+1) * sizeof(INFLINE))) == NULL) {
        return(grcOutOfMemory);
    }

    if(!InitPreparsing()) {
        return(Preparse_Error);
    }

    Inputp = INFFile;

    for(Line = 0; Line < INFLineCount; Line++) {

        INFLineArray[Line].flags = INFLINE_NORMAL;
        INFLineArray[Line].text.offset = OutputImageSize;

        if(*Inputp == '[') {
            INFLineArray[Line].flags |= INFLINE_SECTION;
            if(PreparseSectionNameLine() == TOKEN_ERROR) {
                Preparse_ErrorTermination();
                return(Preparse_Error);
            } else {
                continue;           // EOL will have been skipped.
            }
        } else if(HandleKey(Line) == TOKEN_ERROR) {
            Preparse_ErrorTermination();
            return(Preparse_Error);
        }

        while(((Token = PreparseNextToken()) != TOKEN_EOL)
           &&  (Token != TOKEN_ERROR))
        {
            if((Token == TOKEN_COMMA) || (Token == TOKEN_SPACE)) {
                if(!EMIT(NUL)) {                    // terminate field
                    Preparse_ErrorTermination();
                    return(Preparse_Error);
                }
            }
        }
        if(Token == TOKEN_ERROR) {
            Preparse_ErrorTermination();
            return(Preparse_Error);
        }
        Assert(Token == TOKEN_EOL);
        if(!EMIT(NUL)) {                            // terminate field
            Preparse_ErrorTermination();
            return(Preparse_Error);
        }
    }                       // for Line

    // place dummy section at end

    INFLineArray[INFLineCount].flags = INFLINE_SECTION;
    INFLineArray[INFLineCount].text.offset = OutputImageSize;
    if(!EMIT(EOL)) {
        Preparse_ErrorTermination();
        return(Preparse_Error);
    }

    OutputBuffer = SRealloc(OutputBuffer,OutputImageSize);

    Assert(OutputBuffer != NULL);       // it was shrinking!

    // now xlate offsets into pointers
    for(Line = 0; Line < INFLineCount+1; Line++) {
        INFLineArray[Line].text.addr = INFLineArray[Line].text.offset + OutputBuffer;
    }

    *PreparsedINFFileBufferSize = OutputImageSize;
    *PreparsedINFFile = OutputBuffer;
    *LineArray = INFLineArray;
    *LineCount = INFLineCount;
    return(grcOkay);
}


BYTE
GetToken(
    VOID
    )
{
    register BYTE Token = TOKEN_UNKNOWN;

    if(*Inputp == '\0') {
        Inputp++;
        return(TOKEN_EOL);
    }

    //   See if it's an operator

    if(*(Inputp+1) == '(')
    {
        Token = tokTypeTable2[*Inputp] ;
    }
    if(Token != TOKEN_UNKNOWN)
    {
        Inputp += 2;                    // skip operator
        if(*Inputp == ' ') {
            Inputp++;                   // preprocess is supposed to eliminate
            Assert(*Inputp != ' ');     // multiple spaces
        }
    } else {
        Assert(*Inputp);

        switch ( Token = tokTypeTable1[*Inputp++] )
        {
        case TOKEN_UNKNOWN:             // fast break for most common case
            break ;

        case TOKEN_LIST_START:
            if(*Inputp == ' ') {        // eliminate space after {
                Inputp++;
                Assert(*Inputp != ' '); // preprocess is supposed to eliminate
            }                           // multiple spaces
            break;
        case TOKEN_RIGHT_PAREN:
            if(!InOp)
                Token = TOKEN_UNKNOWN;
           break;
        case TOKEN_LIST_END:
            if(!InList)
                Token = TOKEN_UNKNOWN;
            break;
        }

        if ( Token == TOKEN_UNKNOWN )
        {
            Token = TOKEN_STRING ;
            Inputp-- ;
        }
    }

    Assert(Token != TOKEN_UNKNOWN);
    return(Token);
}


BYTE
PreparseNextToken(
    VOID
    )
{
    BYTE Token;

    Token = GetToken();

    if(IS_OPERATOR_TOKEN(Token)) {

        if((Token = PreparseOperator(Token)) == TOKEN_ERROR) {
            return(TOKEN_ERROR);
        }

    } else if(Token == TOKEN_STRING) {

        if((Token = PreparseString()) == TOKEN_ERROR) {
            return(TOKEN_ERROR);
        }

    } else {
        switch(Token) {

        case TOKEN_LIST_START:
            if((Token = PreparseList()) == TOKEN_ERROR) {
                return(TOKEN_ERROR);
            }
            break;

        case TOKEN_LIST_END:
        case TOKEN_RIGHT_PAREN:
        case TOKEN_SPACE:
        case TOKEN_COMMA:
            if(!EMIT(Token)) {
                return(TOKEN_ERROR);
            }
            break;
        }
    }
    return(Token);
}


BYTE
PreparseOperator(
    BYTE OpToken
    )
{
    BYTE Token;

    if(!EMIT(OpToken)) {
        return(TOKEN_ERROR);
    }

    InOp++;

    Token = PreparseNextToken();

    while((Token != TOKEN_ERROR) && (Token != TOKEN_EOL) && (Token != TOKEN_RIGHT_PAREN)) {
        Token = PreparseNextToken();
    }
    if(Token == TOKEN_RIGHT_PAREN) {
        InOp--;
    } else if(Token == TOKEN_EOL) {
        Preparse_Error = grcBadINF;
    }
    return((BYTE)(((Token == TOKEN_ERROR) || (Token == TOKEN_EOL))
                  ? TOKEN_ERROR
                  : !TOKEN_ERROR
                 )
          );
}


BYTE
PreparseList(
    VOID
    )
{
    BYTE Token;

    if(!EMIT(TOKEN_LIST_START)) {
        return(TOKEN_ERROR);
    }

    InList++;

    Token = PreparseNextToken();

    while((Token != TOKEN_ERROR) && (Token != TOKEN_EOL) && (Token != TOKEN_LIST_END)) {
        Token = PreparseNextToken();
    }
    if(Token == TOKEN_LIST_END) {
        InList--;
    } else if(Token == TOKEN_EOL) {
        Preparse_Error = grcINFBadLine;
    }
    return((BYTE)(((Token == TOKEN_ERROR) || (Token == TOKEN_EOL))
                  ? TOKEN_ERROR
                  : !TOKEN_ERROR
                 )
          );
}


BYTE
PreparseString(
    VOID
    )
{
    PUCHAR p = Inputp;
    USHORT StringOutputLength;
    int    cMarker = 1 ;
    int    cMark ;
    UINT   NewImageSize ;
    BYTE   MarkerBuffer [4] ;

    static BYTE StringBuffer [ PREPARSE_MAX_TOKEN ] ;

    StringOutputLength = TraverseCountAndEmitString(&p,StringBuffer);

    if(StringOutputLength == (USHORT)(-1)) {

        return(TOKEN_ERROR);

    } else if(StringOutputLength < 100) {

        MarkerBuffer[0] = (BYTE)TOKEN_SHORT_STRING + (BYTE)StringOutputLength;

    } else if (StringOutputLength <= 355) {     // actually 100-355

        MarkerBuffer[0] = TOKEN_STRING;
        MarkerBuffer[1] = (BYTE)(StringOutputLength - (USHORT)100);
        cMarker = 2 ;

    } else {

        MarkerBuffer[0] = TOKEN_LONG_STRING;
        MarkerBuffer[1] = (BYTE)(StringOutputLength / 256);
        MarkerBuffer[2] = (BYTE)(StringOutputLength % 256);
        cMarker = 3 ;
    }

    //  See if we can do it the fast way

    if ( (NewImageSize = OutputImageSize + StringOutputLength + cMarker) < OutputBufferSize )
    {
       BYTE * pOut = & OutputBuffer[OutputImageSize] ;

       for ( cMark = 0 ; cMark < cMarker ; )
          *pOut++ = MarkerBuffer[cMark++] ;

       memcpy( pOut, StringBuffer, StringOutputLength ) ;

       OutputImageSize = NewImageSize ;

       Inputp = p ;
    }
    else  //  Otherwise, let's do it the slow way
    {
       for ( cMark = 0 ; cMark < cMarker ; )
       {
           if ( ! EMIT( MarkerBuffer[cMark++] ) )
              return(TOKEN_ERROR);
       }

       EvalAssert( TraverseCountAndEmitString( & Inputp, NULL ) == StringOutputLength ) ;
    }

    return(TOKEN_STRING);
}


USHORT
TraverseCountAndEmitString(
    PUCHAR *pp,
    PUCHAR pbuff
    )
{
    BOOL   InsideQuotes = FALSE;
    BOOL   Overrun = FALSE ;
    USHORT OutputCount = 0;
    PUCHAR pbufflimit ;
    PUCHAR p = *pp;

    if ( pbuff )
    {
       pbufflimit = pbuff + PREPARSE_MAX_TOKEN ;
    }

    while((*p != EOL) && (InsideQuotes || !STRING_TERMINATOR(*p,*(p+1))))
    {
        if(*p == DQUOTE) {
            if(InsideQuotes && (*(p+1) == DQUOTE)) {
                p += 2;
            } else {
                InsideQuotes = !InsideQuotes;
                p++;
            }
        } else {
            // ordinary character
            if(!pbuff)
            {
                if(!EMIT(*p)) {
                    return((USHORT)(-1));
                }
            }
            else
            {
               *pbuff = *p ;
               if ( ++pbuff >= pbufflimit )
               {
                   Overrun = TRUE ;
                   break ;
               }
            }
            OutputCount++;
            p++;
        }
    }

    *pp = p;

    if ( InsideQuotes || Overrun )
    {
        Preparse_Error = grcBadINF;
    }
    return(InsideQuotes ? (USHORT)(-1) : OutputCount);
}


/*
    A section name does not use tokens.  The name is emitted without the
    surrounding [], and terminated by a NUL.
*/

BYTE
PreparseSectionNameLine(
    VOID
    )
{
    Assert(*Inputp == '[');

    Inputp++;                   // skip [

    while((*Inputp != EOL) && (*Inputp != ']')) {
        if(!EMIT(*Inputp)) {
            return(TOKEN_ERROR);
        }
        Inputp++;
    }
    if(*Inputp == EOL) {
        Preparse_Error = grcINFBadSectionLabel;
        return(TOKEN_ERROR);
    }
    Assert(*Inputp == ']');

    if(*(++Inputp) == EOL) {
        Inputp++;
        if(!EMIT(EOL)) {
            return(TOKEN_ERROR);
        }
        return(!TOKEN_ERROR);
    } else {
        Preparse_Error = grcINFBadSectionLabel;
        return(TOKEN_ERROR);
    }
}


BYTE
HandleKey(
    UINT Line
    )
{
    BOOL   InsideQuotes = FALSE;
    UCHAR  c;
    PUCHAR e,
           p = Inputp;

    while(c = *p++) {

        if(InsideQuotes && (c != DQUOTE)) {
            continue;
        }

        if(c == DQUOTE) {
            InsideQuotes = !InsideQuotes;
            continue;
        }

        if(((c == ' ') && (*p == '=')) || (c == '=')) {
            INFLineArray[Line].flags |= INFLINE_KEY;

            for(e=Inputp; e<=p-2; e++) {
                if(*e != DQUOTE) {
                    if(!EMIT(*e)) {
                        return(TOKEN_ERROR);
                    }
                }
            }
            if(!EMIT(NUL)) {
                return(TOKEN_ERROR);
            }
            if(c == ' ') {
                p++;            // p now is one char beyond = in either case
            }
            if(*p == ' ') {
                p++;            // skip trailing space if any
            }
            Inputp = p;
            return(!TOKEN_ERROR);
        }

        if((c == ' ') || (c == ',')) {
            return(!TOKEN_ERROR);       // success but no key
        }
    }
    return(!TOKEN_ERROR);               // don't bother with syntax checks here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\infoproc.c ===
#include "precomp.h"
#pragma hdrstop
/***************************************************************************/
/****************** Basic Class Dialog Handlers ****************************/
/***************************************************************************/



/*
**  Purpose:
**      Information Dialog procedure.
**  Control IDs:
**      Pushbuttons recognized are IDC_O, IDC_C, IDC_M, IDC_H, IDC_X, and IDC_B.
**  Initialization:
**      none.
**  Termination:
**      The id of the Pushbutton (eg IDC_C) which caused termination is
**      converted to a string and stored in the symbol $(ButtonPressed).
**
*****************************************************************************/
INT_PTR APIENTRY FGstInfoDlgProc(HWND hdlg, UINT wMsg, WPARAM wParam,
        LPARAM lParam)
{
    CHP rgchNum[10];

    Unused(lParam);

    switch (wMsg) {
    case STF_REINITDIALOG:
        return(fTrue);

    case WM_INITDIALOG:
        AssertDataSeg();
        if( wMsg == WM_INITDIALOG ) {
            FCenterDialogOnDesktop(hdlg);
        }
        return(fTrue);

    case WM_CLOSE:
        PostMessage(
            hdlg,
            WM_COMMAND,
            MAKELONG(IDC_X, BN_CLICKED),
            0L
            );
        return(fTrue);

    case WM_COMMAND:
        switch (LOWORD(wParam))
            {
        case IDCANCEL:
            if (LOWORD(wParam) == IDCANCEL) {

                if (!GetDlgItem(hdlg, IDC_B) || HIWORD(GetKeyState(VK_CONTROL)) || HIWORD(GetKeyState(VK_SHIFT)) || HIWORD(GetKeyState(VK_MENU)))
                {
                    break;
                }
                wParam = IDC_B;

            }
        case IDC_O:
        case IDC_C:
        case IDC_M:
        case IDC_B:
        case IDC_X:
        case IDC_BTN0:
        case IDC_BTN1: case IDC_BTN2: case IDC_BTN3:
        case IDC_BTN4: case IDC_BTN5: case IDC_BTN6:
        case IDC_BTN7: case IDC_BTN8: case IDC_BTN9:

            _itoa((INT)wParam, rgchNum, 10);
            while (!FAddSymbolValueToSymTab("ButtonPressed", rgchNum))
                if (!FHandleOOM(hdlg))
                    {
                    DestroyWindow(GetParent(hdlg));
                    return(fTrue);
                    }
            PostMessage(GetParent(hdlg), (WORD)STF_UI_EVENT, 0, 0L);
            break;
            }
        break;

    case STF_DESTROY_DLG:
        PostMessage(GetParent(hdlg), (WORD)STF_INFO_DLG_DESTROYED, 0, 0L);
        DestroyWindow(hdlg);
        return(fTrue);
    }

    return(fFalse);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\inf_rt2.c ===
#include "precomp.h"
#pragma hdrstop
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    inf_rt2.c

Abstract:

    INF file runtime field interpreter.

    A given string is interpreted as a tokenized field and an output
    buffer containing the result is constructed.

Author:

    Ted Miller (tedm) 10-Spetember-1991

--*/


/* Input stuff */

LPBYTE Interpret_Inputp;

#define GETTOKEN()    (*Interpret_Inputp++)
#define PEEKTOKEN()   (*Interpret_Inputp)
#define UNGETTOKEN(t) (*(--Interpret_Inputp) = t)
#define VERIFY_SIZE(s)                      \
    if ( SpaceLeftInFieldBuffer < (s) ) {   \
        GrowBuffer(s);                      \
    }


/* end input stuff */

/* Output stuff */

#define MAX_FIELD_LENGTH    4096

PUCHAR InterpretedFieldBuffer;
UINT   SpaceLeftInFieldBuffer;
UINT   BufferSize;
PUCHAR Interpret_OutputLoc;

/* end output stuff */

SZ Interpret_GetField(VOID);

BOOL DoVariable(VOID);
BOOL DoListFromSectionNthItem(VOID);
BOOL DoFieldAddressor(VOID);
BOOL DoAppendItemToList(VOID);
BOOL DoNthItemFromList(VOID);
BOOL DoLocateItemInList(VOID);
BOOL DoList(VOID);
BOOL DoString(BYTE StringToken);

/* Run time error field */
GRC grcRTLastError = grcOkay;

VOID GrowBuffer(UINT Size);
SZ
APIENTRY
InterpretField(
    SZ Field
    )
{
    SZ ReturnString,
       InputSave = Interpret_Inputp;

    Interpret_Inputp = Field;

    ReturnString = Interpret_GetField();

    Interpret_Inputp = InputSave;
    return(ReturnString);
}



SZ
Interpret_GetField(
    VOID
    )
{
    LPSTR OldOutputBuffer = InterpretedFieldBuffer;
    LPSTR OldInterpretLoc = Interpret_OutputLoc;
    UINT  OldSpaceLeft = SpaceLeftInFieldBuffer;
    LPSTR ReturnString = NULL;
    BYTE  Token;

    if((InterpretedFieldBuffer
         = SAlloc(SpaceLeftInFieldBuffer = MAX_FIELD_LENGTH))
      == NULL)
    {
        grcRTLastError = grcOutOfMemory;
        return(NULL);
    }
    BufferSize = MAX_FIELD_LENGTH;
    Interpret_OutputLoc = InterpretedFieldBuffer;

    VERIFY_SIZE(1);
    SpaceLeftInFieldBuffer--;               // leave space for terminating NUL

    while((Token = GETTOKEN())
       && (Token != TOKEN_COMMA)
       && (Token != TOKEN_SPACE)
       && (Token != TOKEN_RIGHT_PAREN)
       && (Token != TOKEN_LIST_END))
    {
        if(IS_STRING_TOKEN(Token)) {
            if(!DoString(Token)) {
                SFree(InterpretedFieldBuffer);
                goto Cleanup;
            }
        } else {
            switch(Token) {

            case TOKEN_VARIABLE:

                if(!DoVariable()) {
                    SFree(InterpretedFieldBuffer);
                    goto Cleanup;
                }
                break;

            case TOKEN_LIST_FROM_SECTION_NTH_ITEM:

                if(!DoListFromSectionNthItem()) {
                    SFree(InterpretedFieldBuffer);
                    goto Cleanup;
                }
                break;

            case TOKEN_FIELD_ADDRESSOR:

                if(!DoFieldAddressor()) {
                    SFree(InterpretedFieldBuffer);
                    goto Cleanup;
                }
                break;

            case TOKEN_APPEND_ITEM_TO_LIST:

                if(!DoAppendItemToList()) {
                    SFree(InterpretedFieldBuffer);
                    goto Cleanup;
                }
                break;

            case TOKEN_NTH_ITEM_FROM_LIST:

                if(!DoNthItemFromList()) {
                    SFree(InterpretedFieldBuffer);
                    goto Cleanup;
                }
                break;

            case TOKEN_LOCATE_ITEM_IN_LIST:

                if(!DoLocateItemInList()) {
                    SFree(InterpretedFieldBuffer);
                    goto Cleanup;
                }
                break;

            case TOKEN_LIST_START:

                if(!DoList()) {
                    SFree(InterpretedFieldBuffer);
                    goto Cleanup;
                }
                break;

            default:

#if DBG
                {
                    char str[100];
                    wsprintf(str,"Bogus token: %u",Token);
                    MessBoxSzSz("Interpret_GetField",str);
                }
#endif
                break;
            } // switch
        } // if-else
    } // while

    /*
        The following is because we want the routines DoOperator()
        and DoList() (below) to have access to their terminators.
    */

    if((Token == TOKEN_RIGHT_PAREN) || (Token == TOKEN_LIST_END)) {
        UNGETTOKEN(Token);
    }

    Assert((LONG)SpaceLeftInFieldBuffer >= 0);      // space provided for above
    *Interpret_OutputLoc = NUL;

    ReturnString = SRealloc(InterpretedFieldBuffer,
                             BufferSize - SpaceLeftInFieldBuffer
                            );

    Assert(ReturnString);       // buffer was shrinking;

    Cleanup:
    Interpret_OutputLoc = OldInterpretLoc;
    InterpretedFieldBuffer = OldOutputBuffer;
    SpaceLeftInFieldBuffer = OldSpaceLeft;
    return(ReturnString);
}


/*
    This routine gets the fields of an operator into an rgsz.
*/

RGSZ
DoOperator(
    UINT  FieldCount
    )
{
    UINT    x;
    RGSZ    rgsz;

    Assert(FieldCount);

    if((rgsz = (RGSZ)SAlloc((FieldCount+1)*sizeof(SZ))) == NULL) {
        grcRTLastError = grcOutOfMemory;
        return(NULL);
    }

    rgsz[FieldCount] = NULL;

    for(x=0; x<FieldCount-1; x++) {

        if((rgsz[x] = Interpret_GetField()) == NULL) {
            FFreeRgsz(rgsz);
            return(NULL);
        }
        if(PEEKTOKEN() == TOKEN_RIGHT_PAREN) {
            FFreeRgsz(rgsz);
            grcRTLastError = grcNotOkay;
            return(NULL);
        }
    }

    if((rgsz[FieldCount-1] = Interpret_GetField()) == NULL) {
        FFreeRgsz(rgsz);
        return(NULL);
    }

    Assert(PEEKTOKEN() != NUL);

    if(GETTOKEN() != TOKEN_RIGHT_PAREN) {     // skips )
        FFreeRgsz(rgsz);
        grcRTLastError = grcNotOkay;
        return(NULL);
    }
    return(rgsz);
}


BOOL
DoVariable(
    VOID
    )
{
    RGSZ rgsz;
    SZ   SymbolValue;
    UINT x,SymbolValueLength;
    BOOL rc = TRUE;

    if((rgsz = DoOperator(1)) == NULL) {
        return(FALSE);
    }

    if((SymbolValue = SzFindSymbolValueInSymTab(rgsz[0])) == NULL) {
        SymbolValue = "";
    }

    SymbolValueLength = lstrlen(SymbolValue);

    VERIFY_SIZE(SymbolValueLength);

    if(SpaceLeftInFieldBuffer >= SymbolValueLength) {
        SpaceLeftInFieldBuffer -= SymbolValueLength;
        for(x=0; x<SymbolValueLength; x++) {
            *Interpret_OutputLoc++ = *SymbolValue++;
        }
    } else {
        grcRTLastError = grcNotOkay;
        rc = FALSE;
    }

    FFreeRgsz(rgsz);
    return(rc);
}


BOOL
DoListFromSectionNthItem(
    VOID
    )
{
    RGSZ rgsz,rgszList = NULL;
    UINT LineCount,n,x,LineNo;
    BOOL rc = FALSE;
    SZ   List,ListSave;

    if((rgsz = DoOperator(2)) == NULL) {
        return(FALSE);
    }

    grcRTLastError = grcNotOkay;
    n = atoi(rgsz[1]);

    LineCount = CKeysFromInfSection(rgsz[0],TRUE);

    if((rgszList = (RGSZ)SAlloc((LineCount+1)*sizeof(SZ))) != NULL) {

        LineNo = FindInfSectionLine(rgsz[0]);

        for(x=0; x<LineCount; x++) {
            LineNo = FindNextLineFromInf(LineNo);
            Assert(LineNo != -1);
            rgszList[x] = SzGetNthFieldFromInfLine(LineNo,n);
        }
        rgszList[LineCount] = NULL;
        if((List = SzListValueFromRgsz(rgszList)) != NULL) {
            ListSave = List;
            x = lstrlen(List);
            VERIFY_SIZE(x);
            if(SpaceLeftInFieldBuffer >= x) {
                SpaceLeftInFieldBuffer -= x;
                for(n=0; n<x; n++) {
                    *Interpret_OutputLoc++ = *List++;
                }
                grcRTLastError = grcOkay;
                rc = TRUE;
            }
            SFree(ListSave);
        } else {
            grcRTLastError = grcOutOfMemory;
        }
    } else {
        grcRTLastError = grcOutOfMemory;
    }

    if(rgszList != NULL) {
        FFreeRgsz(rgszList);
    }
    FFreeRgsz(rgsz);
    return(rc);
}


BOOL
DoFieldAddressor(
    VOID
    )
{
    RGSZ rgsz;
    UINT x,n;
    SZ   Result,ResultSave;
    BOOL rc = FALSE;

    if((rgsz = DoOperator(3)) == NULL) {
        return(FALSE);
    }

    grcRTLastError = grcNotOkay;
    n = atoi(rgsz[2]);

    // rgsz[0] has section, rgsz[1] has key

    if((Result = SzGetNthFieldFromInfSectionKey(rgsz[0],rgsz[1],n)) != NULL) {

        ResultSave = Result;
        n = lstrlen(Result);
        VERIFY_SIZE(n);
        if(SpaceLeftInFieldBuffer >= n) {
            SpaceLeftInFieldBuffer -= n;
            for(x=0; x<n; x++) {
                *Interpret_OutputLoc++ = *Result++;
            }
            grcRTLastError = grcOkay;
            rc = TRUE;
        }
        SFree(ResultSave);
    }
    FFreeRgsz(rgsz);
    return(rc);
}


BOOL
DoAppendItemToList(
    VOID
    )
{
    RGSZ rgsz,rgszList1,rgszList2;
    UINT RgszSize,x,y;
    SZ   ListValue,ListTemp;

    if((rgsz = DoOperator(2)) == NULL) {
        return(FALSE);
    }

    // rgsz[0] has list, rgsz[1] has item

    if((rgszList1 = RgszFromSzListValue(rgsz[0])) == NULL) {
        FFreeRgsz(rgsz);
        grcRTLastError = grcOutOfMemory;
        return(FALSE);
    }

    for (RgszSize = 0; rgszList1[RgszSize] != NULL; RgszSize++) {
        ;
    }

    if ((rgszList2 = (RGSZ)SRealloc(rgszList1, (RgszSize+2)*sizeof(SZ)
                        )) == NULL)
    {
        FFreeRgsz(rgszList1);
        FFreeRgsz(rgsz);
        grcRTLastError = grcOutOfMemory;
        return(FALSE);
    }

    rgszList2[RgszSize] = SzDupl(rgsz[1]);
    rgszList2[RgszSize+1] = NULL;

    ListValue = SzListValueFromRgsz(rgszList2);

    FFreeRgsz(rgszList2);

    if(ListValue == NULL) {
        FFreeRgsz(rgsz);
        grcRTLastError = grcOutOfMemory;
        return(FALSE);
    }

    x = lstrlen(ListValue);
    VERIFY_SIZE(x);
    if(x > SpaceLeftInFieldBuffer) {
        SFree(ListValue);
        FFreeRgsz(rgsz);
        grcRTLastError = grcNotOkay;
        return(FALSE);
    }
    ListTemp = ListValue;
    for(y=0; y<x; y++) {
        *Interpret_OutputLoc++ = *ListTemp++;
    }
    SpaceLeftInFieldBuffer -= x;

    SFree(ListValue);
    FFreeRgsz(rgsz);
    return(TRUE);
}


BOOL
DoNthItemFromList(
    VOID
    )
{
    RGSZ   rgsz,
           rgszList = NULL;
    UINT   n,x,y,ListSize;
    PUCHAR Item;
    BOOL   rc = FALSE;

    if((rgsz = DoOperator(2)) == NULL) {
        return(FALSE);
    }

    grcRTLastError = grcNotOkay;
    n = atoi(rgsz[1]);

    if((rgszList = RgszFromSzListValue(rgsz[0])) != NULL) {

        for(ListSize=0; rgszList[ListSize]; ListSize++) {
            ;
        }                   // count list items
        if(!n || (n > ListSize)) {
            Item = "";
        } else {
            Item = rgszList[n-1];
        }
        x = lstrlen(Item);
        VERIFY_SIZE(x);
        if(SpaceLeftInFieldBuffer >= x) {
            SpaceLeftInFieldBuffer -= x;
            for(y=0; y<x; y++) {
                *Interpret_OutputLoc++ = *Item++;
            }
            grcRTLastError = grcOkay;
            rc = TRUE;
        }
    } else {
        grcRTLastError = grcOutOfMemory;
    }
    if(rgszList != NULL) {
        FFreeRgsz(rgszList);
    }
    FFreeRgsz(rgsz);
    return(rc);
}


BOOL
DoLocateItemInList(         // 1-based, 0 if not found
    VOID
    )
{
    RGSZ rgsz,rgszList;
    UINT Item = 0,
         x,y;
    BOOL rc = FALSE;
    char szItem[25];         // arbitrary length
    char *szItemTemp;

    if((rgsz = DoOperator(2)) == NULL) {
        return(FALSE);
    }

    grcRTLastError = grcNotOkay;
    // rgsz[0] has list, rgsz[1] has item to locate

    if((rgszList = RgszFromSzListValue(rgsz[0])) != NULL) {

        for(x=0; rgszList[x]; x++) {

            if(!lstrcmpi(rgsz[1],rgszList[x])) {
                Item = x+1;
                break;
            }
        }
        FFreeRgsz(rgszList);

        wsprintf(szItem,"%u",Item);
        x = lstrlen(szItem);
        VERIFY_SIZE(x);
        if( x <= SpaceLeftInFieldBuffer) {

            SpaceLeftInFieldBuffer -= x;
            szItemTemp = szItem;
            for(y=0; y<x; y++) {
                *Interpret_OutputLoc++ = *szItemTemp++;
            }
            rc = TRUE;
            grcRTLastError = grcOkay;
        }
    } else {
        grcRTLastError = grcOutOfMemory;
    }
    FFreeRgsz(rgsz);
    return(rc);
}


BOOL
DoList(
    VOID
    )
{
    RGSZ    rgsz;
    LPVOID  r;
    UINT    RgszSize;
    UINT    ItemCount;
    UINT    ListLength,x;
    SZ      List,ListSave;
    BOOL    rc;

    if((rgsz = (RGSZ)SAlloc(10 * sizeof(SZ))) == NULL) {
        grcRTLastError = grcOutOfMemory;
        return(FALSE);
    }
    RgszSize = 10;
    ItemCount = 1;              // reserve space for the NULL entry

    while(PEEKTOKEN() != TOKEN_LIST_END) {
        if(ItemCount == RgszSize) {
            if((r = SRealloc(rgsz,
                              (RgszSize + 10) * sizeof(SZ)
                             )
               )
            == NULL)
            {
                rgsz[ItemCount-1] = NULL;   // for FFreeRgsz
                FFreeRgsz(rgsz);
                grcRTLastError = grcOutOfMemory;
                return(FALSE);
            }
            RgszSize += 10;
            rgsz = r;
        }
        if((rgsz[ItemCount-1] = Interpret_GetField()) == NULL) {
            FFreeRgsz(rgsz);
            return(FALSE);
        }
        ItemCount++;
    }

    EvalAssert(GETTOKEN() == TOKEN_LIST_END);       // skip list end

    Assert(ItemCount <= RgszSize);
    rgsz[ItemCount-1] = NULL;     // space for this reserved above

    rgsz = (RGSZ)SRealloc(rgsz,ItemCount * sizeof(SZ));
    Assert(rgsz);       // it was shrinking

    List = SzListValueFromRgsz(rgsz);
    FFreeRgsz(rgsz);
    if(List == NULL) {
        grcRTLastError = grcOutOfMemory;
        return(FALSE);
    }
    ListLength = lstrlen(List);
    ListSave = List;
    VERIFY_SIZE(ListLength);
    if(SpaceLeftInFieldBuffer >= ListLength) {
        SpaceLeftInFieldBuffer -= ListLength;
        for(x=0; x<ListLength; x++) {
            *Interpret_OutputLoc++ = *List++;
        }
        rc = TRUE;
    } else {
        grcRTLastError = grcNotOkay;
        rc = FALSE;
    }
    SFree(ListSave);
    return(rc);
}


BOOL
DoString(
    BYTE StringToken
    )
{
    USHORT StringLength;
    UINT   x;

    Assert(IS_STRING_TOKEN(StringToken));

    if(StringToken < TOKEN_STRING)  {               // test for short string
        StringLength = (USHORT)StringToken - (USHORT)TOKEN_SHORT_STRING;
    } else if (StringToken == TOKEN_STRING) {       // test for regular string
        StringLength = (USHORT)GETTOKEN() + (USHORT)100;
    } else {                                        // long string
        Assert(StringToken == TOKEN_LONG_STRING);
        StringLength =  (USHORT)GETTOKEN() << 8;
        StringLength |= (USHORT)GETTOKEN();
    }
    VERIFY_SIZE( StringLength );
    if(SpaceLeftInFieldBuffer >= StringLength) {
        SpaceLeftInFieldBuffer -= StringLength;
        for(x=0; x<StringLength; x++) {
            *Interpret_OutputLoc++ = GETTOKEN();
        }
    } else {
        grcRTLastError = grcNotOkay;
        return(FALSE);
    }
    return(TRUE);
}


VOID
GrowBuffer( UINT Size )
{

    while ( SpaceLeftInFieldBuffer < Size ) {

        //
        //  Reallocate buffer
        //
        PUCHAR   p;
        UINT_PTR Offset = Interpret_OutputLoc - InterpretedFieldBuffer;

        p = (PUCHAR)SRealloc( InterpretedFieldBuffer,
                               BufferSize + MAX_FIELD_LENGTH);

        if ( p ) {

            InterpretedFieldBuffer  = p;
            Interpret_OutputLoc     = InterpretedFieldBuffer + Offset;
            SpaceLeftInFieldBuffer += MAX_FIELD_LENGTH;
            BufferSize             += MAX_FIELD_LENGTH;

        } else {

            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\inf_rt1.c ===
#include "precomp.h"
#pragma hdrstop
EERC
DisplayParseLineError(
    INT  Line,
    GRC  grc
    );

/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    inf_rt1.c

Abstract:

    Function set to access the contents of the INF file and provide
    various statistics about it.

Author:

    Ted Miller (tedm) 10-Spetember-1991

--*/

/*
    Section         - names the section
    IncludeAllLines - whether to include lines without a key in the count

    returns number of lines in the section with keys or total # lines in
    the section, depending on IncludeAllLines.
*/

extern GRC  grcRTLastError;
extern HWND hWndShell;

UINT
APIENTRY
CKeysFromInfSection(
    SZ   Section,
    BOOL IncludeAllLines    // ie, not only those w/ keys
    )
{
    UINT        Count = 0;
    INT         Line;
    PINFLINE    MasterLineArray;

    MasterLineArray = pLocalInfTempInfo()->pParsedInf->MasterLineArray;

    if((Line = FindInfSectionLine(Section)) != -1) {

        while((Line = FindNextLineFromInf(Line)) != -1) {

            if(IncludeAllLines || (MasterLineArray[Line].flags & INFLINE_KEY)) {

                Count++;
            }
        }
    }
    return(Count);
}


BOOL
APIENTRY
FKeyInInfLine(
    INT Line
    )
{
    Assert((UINT)Line < pLocalInfTempInfo()->pParsedInf->MasterLineCount);

    return(pLocalInfTempInfo()->pParsedInf->MasterLineArray[Line].flags & INFLINE_KEY);
}



RGSZ
APIENTRY
RgszFromInfLineFields(
    INT  Line,
    UINT StartField,
    UINT NumFields
    )
{
    UINT u;
    RGSZ rgsz;

    Assert((UINT)Line < pLocalInfTempInfo()->pParsedInf->MasterLineCount);

    if((rgsz = (RGSZ)SAlloc((NumFields+1) * sizeof(SZ))) == NULL) {
        return(NULL);
    }

    for(u=0; u<NumFields; u++) {

        if((rgsz[u] = SzGetNthFieldFromInfLine(Line,u+StartField)) == NULL) {

            FFreeRgsz(rgsz);
            return(NULL);
        }
    }
    rgsz[NumFields] = NULL;
    return(rgsz);
}



UINT
APIENTRY
CFieldsInInfLine(
    INT Line
    )
{
    UINT        cFields = 0;
    LPSTR       p;
    PINFLINE    MasterLineArray;

    MasterLineArray = pLocalInfTempInfo()->pParsedInf->MasterLineArray;

    Assert((UINT)Line < pLocalInfTempInfo()->pParsedInf->MasterLineCount);

    for(p=MasterLineArray[Line].text.addr; p<MasterLineArray[Line+1].text.addr; p++) {

        if(!(*p)) {
            cFields++;
        }
    }
    if(MasterLineArray[Line].flags & INFLINE_KEY) {
        cFields--;
    }
    return(cFields);
}


/*
    Section - names the section

    returns a pointer to the section header line (ie, the [xxx] line) or -1
    if it doesn't exist
*/

INT
APIENTRY
FindInfSectionLine(
    SZ Section
    )
{
    UINT        u;
    UINT        MasterLineCount;
    PINFLINE    MasterLineArray;

    MasterLineCount = pLocalInfTempInfo()->pParsedInf->MasterLineCount;
    MasterLineArray = pLocalInfTempInfo()->pParsedInf->MasterLineArray;

    for(u=0; u<MasterLineCount; u++) {

        if((MasterLineArray[u].flags & INFLINE_SECTION)
        && !lstrcmpi(Section,MasterLineArray[u].text.addr))
        {
            return(u);
        }
    }
    return(-1);
}


/*
    Section - names the section
    N       - 1-based number of line in section to find

    returns the line # or -1 if not that many lines in the section.
*/

INT
APIENTRY
FindNthLineFromInfSection(
    SZ   Section,
    UINT N
    )
{
    UINT        u;
    UINT        Line;
    UINT        MasterLineCount;
    PINFLINE    MasterLineArray;

    MasterLineCount = pLocalInfTempInfo()->pParsedInf->MasterLineCount;
    MasterLineArray = pLocalInfTempInfo()->pParsedInf->MasterLineArray;

    Assert(N);

    if(((Line = FindInfSectionLine(Section)) == -1)
    || (Line+N >= MasterLineCount))
    {
        return(-1);
    }

    for(u=Line+1; u<=Line+N; u++) {

        if(MasterLineArray[u].flags & INFLINE_SECTION) {
            return(-1);
        }
    }
    return(Line+N);
}

INT
APIENTRY
FindNextLineFromInf(
    INT Line
    )
{
    return((pLocalInfTempInfo()->pParsedInf->MasterLineArray[Line+1].flags & INFLINE_SECTION) ? -1 : Line+1);
}

INT
APIENTRY
FindLineFromInfSectionKey(
    SZ Section,
    SZ Key
    )
{
    INT         Line;
    PINFLINE    MasterLineArray;

    MasterLineArray = pLocalInfTempInfo()->pParsedInf->MasterLineArray;

    if((Line = FindFirstLineFromInfSection(Section)) != -1) {

        while(!(MasterLineArray[Line].flags & INFLINE_SECTION)) {

            if((MasterLineArray[Line].flags & INFLINE_KEY)
            && !lstrcmpi(Key,MasterLineArray[Line].text.addr))
            {
                return(Line);
            }
            Line++;
        }
    }
    return(-1);
}


SZ
APIENTRY
SzGetNthFieldFromInfLine(
    INT  Line,
    UINT N
    )
{
    UINT        u;
    LPSTR       p;
    PINFLINE    MasterLineArray;
    SZ          sz;
    EERC        eerc;


    MasterLineArray = pLocalInfTempInfo()->pParsedInf->MasterLineArray;

    if(MasterLineArray[Line].flags & INFLINE_KEY) {
        if(!N) {        // we want the key.  It's not tokenized.
            return(SzDupl(MasterLineArray[Line].text.addr));
        }
    } else {            // don't want the key -- adjust N to be 0-based.
        if(!N) {
            return(NULL);
        } else {
            N--;
        }
    }
    for(u=0,p=MasterLineArray[Line].text.addr;
        p<MasterLineArray[Line+1].text.addr;
        p+=lstrlen(p)+1
       )
    {
        if(u++ == N) {
            grcRTLastError = grcOkay;
            while(!(sz = InterpretField(p))) {
                if( grcRTLastError == grcNotOkay ) {
                    eerc = DisplayParseLineError( Line, grcRTLastError );
                    if (eerc != eercRetry) {
                        SendMessage(hWndShell, (WORD)STF_ERROR_ABORT, 0, 0);
                        break;
                    }
                }
                else {
                    break;
                }
                grcRTLastError = grcOkay;
            }
            return( sz );
        }
    }
    return(NULL);
}

SZ
APIENTRY
SzGetNthFieldFromInfSectionKey(
    SZ   Section,
    SZ   Key,
    UINT N
    )
{
    INT Line;

    return(((Line = FindLineFromInfSectionKey(Section,Key)) == -1)
           ? NULL
           : SzGetNthFieldFromInfLine(Line,N)
          );
}


EERC
DisplayParseLineError(
    INT  Line,
    GRC  grc
    )
{

    CHAR buf[1024];
    SZ   InfFile;
    SZ   DisplayLine;
    EERC eerc;

    //
    // Reconstruct the line which has the error
    //

    SdpReconstructLine( pLocalInfTempInfo()->pParsedInf->MasterLineArray,
                        pLocalInfTempInfo()->pParsedInf->MasterLineCount,
                        Line,
                        buf,
                        1024
                      );

    //
    // Limit the line length to a certain number of chars
    //

    DisplayLine = buf;
    while( isspace( *DisplayLine ) ) {
        DisplayLine++;
    }
    DisplayLine[47] = DisplayLine[48] = DisplayLine[49] = '.';
    DisplayLine[50] = '\0';

    //
    // Get the inf file in which this happened
    //

    InfFile = pLocalInfPermInfo()->szName;

    //
    // Display the error, the inf in which the error happened

    eerc = EercErrorHandler(hWndShell, grcRunTimeParseErr, TRUE,  InfFile, DisplayLine );
    return( eerc );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\inicm.c ===
#include "precomp.h"
#pragma hdrstop
/* File: inicm.c */
/**************************************************************************
**  Install: .INI file commands.
**************************************************************************/


extern HWND hwndFrame;


/*
**  Purpose:
**      To Create a section in the given ini file.  If the file does not
**      already exist it will be created.  If the section already exists it
**      may or may not be erased (including key/value pairs) based upon the
**      value of the cmo parameter (see below).
**  Arguments:
**      szFile: a non-Null zero terminated string containing the file name
**          for the ini file.  This must either be a fully qualified path
**          or the string "WIN.INI" to signify the Windows' file.
**      szSect: a zero terminated string containing the name of the section
**          to be created.
**      cmo:    valid command options:
**          cmoNone:      no effect
**          cmoOverwrite: Causes the entire section (including key/value
**              pairs) to be erased before creating the section again (without
**              any key/value pairs).
**          cmoVital:     causes the Vital command handler to be called
**              if the function fails for any reason.
**  Returns:
**      fTrue if the function succeeds, fFalse otherwise.
**
****************************************************************************/
BOOL APIENTRY FCreateIniSection(SZ szFile, SZ szSect, CMO cmo)
{
    EERC eerc;
    BOOL fVital = cmo & cmoVital;

    ChkArg(szFile != (SZ)NULL && *szFile != '\0', 1, fFalse);
    ChkArg(szSect != (SZ)NULL && *szSect != '\0', 2, fFalse);
    PreCondition(FValidPath(szFile) ||
            CrcStringCompareI(szFile, "WIN.INI") == crcEqual, fFalse);

    if (cmo & cmoOverwrite &&
            !FRemoveIniSection(szFile, szSect, cmo))
        return(!fVital);

    if (CrcStringCompareI(szFile, "WIN.INI") == crcEqual)
        {
        while (!WriteProfileString(szSect, "", NULL))
            if ((eerc = EercErrorHandler(hwndFrame, grcWriteIniValueErr, fVital,
                    szFile, szSect, "")) != eercRetry)
                return(eerc == eercIgnore);

        SendMessage((HWND)(-1), WM_WININICHANGE, 0, (LPARAM)szSect);
        }
    else while (!WritePrivateProfileString(szSect, "", NULL, szFile))
        if ((eerc = EercErrorHandler(hwndFrame, grcWriteIniValueErr, fVital,
                szFile, szSect, "")) != eercRetry)
            return(eerc == eercIgnore);

    return(fTrue);
}


/*
**  Purpose:
**      To replace an existing section in an ini file with a new section.
**      Replacing the section will also remove any of the key/value pairs
**      contained in the section being replaced.  This function will fail if
**      the section doesn't already exist (unlike   FRemoveIniSection).
**  Arguments:
**      szFile:     a non-NULL zero terminated string containing the file name
**          for the ini file.  This must either be a fully qualified path
**          or the string "WIN.INI" to signify the Windows' file.
**      szSect:     a non-NULL zero terminated string containing the name of
**          the section to be replaced.
**      szNewSect:  a non-NULL zero terminated string containing the name of
**          the section that will replace the section in szSect.
**      cmo:        valid command options:
**          cmoNone:   no effect
**          cmoVital:  causes the Vital command handler to be called
**              if the function fails for any reason.
**  Notes: This function is unable to distinguish between a section with no
**      keys and a section that does not exist.
**  Returns:
**      fTrue if the function succeeds, fFalse otherwise.
**
****************************************************************************/
BOOL APIENTRY FReplaceIniSection(SZ szFile, SZ szSect, SZ szNewSect,
        CMO cmo)
{
    EERC eerc;
    CHP  rgch[10];
    BOOL fVital = cmo & cmoVital;

    ChkArg(szFile    != (SZ)NULL, 1, fFalse);
    ChkArg(szSect    != (SZ)NULL, 2, fFalse);
    ChkArg(szNewSect != (SZ)NULL, 3, fFalse);
    PreCondition(FValidPath(szFile) ||
            CrcStringCompareI(szFile, "WIN.INI") == crcEqual, fFalse);

    if (CrcStringCompareI(szFile, "WIN.INI") == crcEqual)
        {
        while (GetProfileString(szSect, NULL, "a", rgch, 10) == 1)
            if ((eerc = EercErrorHandler(hwndFrame, grcReplaceIniValueErr,
                    fVital, szFile, szSect, "")) != eercRetry)
                return(eerc == eercIgnore);
        }
    else while (GetPrivateProfileString(szSect, NULL, "a", rgch,10,szFile) == 1)
        if ((eerc = EercErrorHandler(hwndFrame, grcReplaceIniValueErr, fVital,
                szFile, szSect, "")) != eercRetry)
            return(eerc == eercIgnore);

    if (!FRemoveIniSection(szFile, szSect, cmo) ||
            !FCreateIniSection(szFile, szNewSect, cmo))
        return(!fVital);

    return(fTrue);
}


/*
**  Purpose:
**      To remove a section (including all key/value pairs in the section)
**      from an ini file.  No attempt is made to determine if the section
**      already exists or not.
**  Arguments:
**      szFile:     a non-NULL zero terminated string containing the file name
**          for the ini file.  This must either be a fully qualified path
**          or the string "WIN.INI" to signify the Windows' file.
**      szSect:     a non-NULL zero terminated string containing the name of
**          the section to be removed.
**      cmo:        valid command options:
**          cmoNone:      no effect
**          cmoVital:     causes the Vital command handler to be called
**              if the function fails for any reason.
**  Returns:
**      fTrue if the function succeeds, fFalse otherwise.
**
****************************************************************************/
BOOL APIENTRY FRemoveIniSection(SZ szFile, SZ szSect, CMO cmo)
{
    EERC eerc;
    BOOL fVital = cmo & cmoVital;

    ChkArg(szFile != (SZ)NULL, 1, fFalse);
    ChkArg(szSect != (SZ)NULL, 2, fFalse);
    PreCondition(FValidPath(szFile) ||
            CrcStringCompareI(szFile, "WIN.INI") == crcEqual, fFalse);

    if (CrcStringCompareI(szFile, "WIN.INI") == crcEqual)
        {
        while (!WriteProfileString(szSect, NULL, NULL))
            if ((eerc = EercErrorHandler(hwndFrame, grcWriteIniValueErr, fVital,
                    szFile, szSect, "")) != eercRetry)
                return(eerc == eercIgnore);

        SendMessage((HWND)(-1), WM_WININICHANGE, 0, (LPARAM)szSect);
        }
    else while (!WritePrivateProfileString(szSect, NULL, NULL, szFile))
        if ((eerc = EercErrorHandler(hwndFrame, grcWriteIniValueErr, fVital,
                szFile, szSect, "")) != eercRetry)
            return(eerc == eercIgnore);

    return(fTrue);
}


/*
**  Purpose:
**      To Create a Key (with no value) in the given ini file and section.
**      If the file does not already exist it will be created.  If the section
**      does not already exist it will also be created.
**  Arguments:
**      szFile:     a non-NULL zero terminated string containing the file name
**          for the ini file.  This must either be a fully qualified path
**          or the string "WIN.INI" to signify the Windows' file.
**      szSect: a non-NULL zero terminated string containing the name of the
**          section in which the key will be created.
**      szKey:  non-NULL, non-empty name of the key to be created in the
**          section szSect.
**      cmo:        valid command options:
**          cmoNone:      no effect
**          cmoOverwrite: causes the key (and value if it exists) to be
**              removed if it already exists before creating the key.
**          cmoVital:     causes the Vital command handler to be called
**              if the function fails for any reason.
**  Returns:
**      fTrue if the function succeeds, fFalse otherwise.
**
****************************************************************************/
BOOL APIENTRY FCreateIniKeyNoValue(SZ szFile, SZ szSect, SZ szKey,
        CMO cmo)
{
    EERC eerc;
    CHP  rgch[2];
    BOOL fVital = cmo & cmoVital;

    ChkArg(szFile != (SZ)NULL, 1, fFalse);
    ChkArg(szSect != (SZ)NULL, 2, fFalse);
    ChkArg(szKey  != (SZ)NULL && *szKey != '\0', 3, fFalse);
    PreCondition(FValidPath(szFile) ||
            CrcStringCompareI(szFile, "WIN.INI") == crcEqual, fFalse);

    if (CrcStringCompareI(szFile, "WIN.INI") == crcEqual)
        {
        if (!(cmo & cmoOverwrite) &&
                GetProfileString(szSect, szKey, "", rgch, 2))
            return(fTrue);

        while (!WriteProfileString(szSect, szKey, ""))
            if ((eerc = EercErrorHandler(hwndFrame, grcWriteIniValueErr, fVital,
                    szFile, szSect, szKey)) != eercRetry)
                return(eerc == eercIgnore);

        SendMessage((HWND)(-1), WM_WININICHANGE, 0, (LPARAM)szSect);
        }
    else
        {
        if (!(cmo & cmoOverwrite) &&
                GetPrivateProfileString(szSect, szKey, "", rgch, 2, szFile))
            return(fTrue);

        while (!WritePrivateProfileString(szSect, szKey, "", szFile))
            if ((eerc = EercErrorHandler(hwndFrame, grcWriteIniValueErr, fVital,
                    szFile, szSect, szKey)) != eercRetry)
                return(eerc == eercIgnore);
        }

    return(fTrue);
}


/*
**  Purpose:
**      To Create a Key/value pair in the given ini file and section.
**      If the file does not already exist it will be created.  If the section
**      does not already exist it will also be created.
**  Arguments:
**      szFile:     a non-NULL zero terminated string containing the file name
**          for the ini file.  This must either be a fully qualified path
**          or the string "WIN.INI" to signify the Windows' file.
**      szSect: a non-NULL zero terminated string containing the name of the
**          section in which the key/value pair will be created.
**      szKey:  non-NULL, non-empty name of the key to be created in the
**          section szSect.
**      szValue:    the name of the value to be created in conjunction with the
**          key szKey in the section szSect.
**      cmo:        valid command options:
**          cmoNone:      no effect
**          cmoOverwrite: causes the key/value pair to be removed if it
**              already exists before creating the key.
**          cmoVital:     causes the Vital command handler to be called
**              if the function fails for any reason.
**  Returns:
**      fTrue if the function succeeds, fFalse otherwise.
**
****************************************************************************/
BOOL APIENTRY FCreateIniKeyValue(SZ szFile, SZ szSect, SZ szKey,
        SZ szValue, CMO cmo)
{
    EERC eerc;
    CHP  rgch[2];
    BOOL fVital = cmo & cmoVital;

    ChkArg(szFile  != (SZ)NULL, 1, fFalse);
    ChkArg(szSect  != (SZ)NULL, 2, fFalse);
    ChkArg(szKey   != (SZ)NULL && *szKey != '\0', 3, fFalse);
    ChkArg(szValue != (SZ)NULL, 4, fFalse);
    PreCondition(FValidPath(szFile) ||
            CrcStringCompareI(szFile, "WIN.INI") == crcEqual, fFalse);

    if (CrcStringCompareI(szFile, "WIN.INI") == crcEqual)
        {
        if (!(cmo & cmoOverwrite) &&
                GetProfileString(szSect, szKey, "", rgch, 2))
            return(fTrue);

        while (!WriteProfileString(szSect, szKey, szValue))
            if ((eerc = EercErrorHandler(hwndFrame, grcWriteIniValueErr, fVital,
                    szFile, szSect, szKey)) != eercRetry)
                return(eerc == eercIgnore);

        SendMessage((HWND)(-1), WM_WININICHANGE, 0, (LPARAM)szSect);
        }
    else
        {
        if (!(cmo & cmoOverwrite) &&
                GetPrivateProfileString(szSect, szKey, "", rgch, 2, szFile))
            return(fTrue);

        while (!WritePrivateProfileString(szSect, szKey, szValue, szFile))
            if ((eerc = EercErrorHandler(hwndFrame, grcWriteIniValueErr, fVital,
                    szFile, szSect, szKey)) != eercRetry)
                return(eerc == eercIgnore);
        }

    return(fTrue);
}


/*
**  Purpose:
**      To replace an existing key/value pair in an ini file with a new pair.
**      Replacing the key/value pair will also remove any of the key/value pairs
**      contained in the section being replaced.
**  Arguments:
**      szFile:  a non-NULL zero terminated string containing the file name
**          for the ini file.  This must either be a fully qualified path
**          or the string "WIN.INI" to signify the Windows' file.
**      szSect:  a zero terminated string containing the name of the section
**          in which the key/value pair is to be replaced.
**      szKey:   non-NULL, non-empty name of the key to
**          be replaced in the section szSect.
**      szValue: a zero terminated string containing the name of the value
**          to be replaced in conjunction with the key szKey in the
**          section szSect.
**      cmo:     valid command options:
**          cmoNone:  no effect
**          cmoVital: causes the Vital command handler to be called
**              if the function fails for any reason.
**  Returns:
**      fTrue if the function succeeds, fFalse otherwise.
**
****************************************************************************/
BOOL APIENTRY FReplaceIniKeyValue(SZ szFile, SZ szSect, SZ szKey,
        SZ szValue, CMO cmo)
{
    BOOL fVital = cmo & cmoVital;

    ChkArg(szFile  != (SZ)NULL, 1, fFalse);
    ChkArg(szSect  != (SZ)NULL, 2, fFalse);
    ChkArg(szKey   != (SZ)NULL && *szKey != '\0', 3, fFalse);
    ChkArg(szValue != (SZ)NULL, 4, fFalse);
    PreCondition(FValidPath(szFile) ||
            CrcStringCompareI(szFile, "WIN.INI") == crcEqual, fFalse);

    if (!FCreateIniKeyValue(szFile, szSect, szKey, szValue,
                (CMO)(cmoOverwrite | cmo)))
        return(!fVital);

    return(fTrue);
}


/*
**  Purpose:
**      To append a value to an existing key/value pair in an ini file.
**  Arguments:
**      szFile:     a non-NULL zero terminated string containing the file name
**          for the ini file.  This must either be a fully qualified path
**          or the string "WIN.INI" to signify the Windows' file.
**      szSect:     a zero terminated string containing the name of the section
**          in which the key/value pair is to be appended.
**      szKey:      non-NULL, non-empty name of the key
**          whose value will be appended in the section szSect.
**      szValue:    a zero terminated string containing the value
**          to be appended in conjunction with the key szKey in the
**          section szSect.
**      cmo:            valid command options:
**          cmoNone:   no effect
**          cmoVital:  causes the Vital command handler to be called
**              if the function fails for any reason.
**  Returns:
**      fTrue if the function succeeds, fFalse otherwise.
**
****************************************************************************/
BOOL APIENTRY FAppendIniKeyValue(SZ szFile, SZ szSect, SZ szKey,
        SZ szValue, CMO cmo)
{
    CHP  rgch[256];
    BOOL fVital = cmo & cmoVital;

    ChkArg(szFile  != (SZ)NULL, 1, fFalse);
    ChkArg(szSect  != (SZ)NULL, 2, fFalse);
    ChkArg(szKey   != (SZ)NULL && *szKey != '\0', 3, fFalse);
    ChkArg(szValue != (SZ)NULL, 4, fFalse);
    PreCondition(FValidPath(szFile) ||
            CrcStringCompareI(szFile, "WIN.INI") == crcEqual, fFalse);

    if (CrcStringCompareI(szFile, "WIN.INI") == crcEqual)
        GetProfileString(szSect, szKey, "", rgch, 255);
    else
        GetPrivateProfileString(szSect, szKey, "", rgch, 255, szFile);

    if (rgch[0] != '\0')
        {
        if (strlen(rgch) + strlen(szValue) + 1 >= 255)
            {
            EvalAssert(EercErrorHandler(hwndFrame, grcIniValueTooLongErr,
                    fVital, 0, 0, 0) == eercAbort);
            return(!fVital);
            }

        EvalAssert(SzStrCat((LPSTR)rgch, " ") == (LPSTR)rgch);
        }

    EvalAssert(SzStrCat((LPSTR)rgch, szValue) == (LPSTR)rgch);

    if (!FCreateIniKeyValue(szFile, szSect, szKey, rgch,
                (CMO)(cmoOverwrite | cmo)))
        return(!(cmo & cmoVital));

    return(fTrue);
}


/*
**  Purpose:
**      To remove a key/value pair from a section in an ini file.
**      No attempt is made to determine if the key already exists.
**  Arguments:
**      szFile:     a non-NULL zero terminated string containing the file name
**          for the ini file.  This must either be a fully qualified path
**          or the string "WIN.INI" to signify the Windows' file.
**      szSect:     a zero terminated string containing the name of the section
**          to be from which the key/value pair is to be removed.
**      szKey:      non-NULL, non-empty key of the key/value pair to be
**          removed from the section szSect.
**      cmo:        valid command options:
**          cmoNone:      no effect
**          cmoVital:     causes the Vital command handler to be called
**              if the function fails for any reason.
**  Returns:
**      fTrue if the function succeeds, fFalse otherwise.
**
****************************************************************************/
BOOL APIENTRY FRemoveIniKey(SZ szFile, SZ szSect, SZ szKey, CMO cmo)
{
    EERC eerc;
    BOOL fVital = cmo & cmoVital;

    ChkArg(szFile != (SZ)NULL, 1, fFalse);
    ChkArg(szSect != (SZ)NULL, 2, fFalse);
    ChkArg(szKey  != (SZ)NULL && *szKey != '\0', 3, fFalse);
    PreCondition(FValidPath(szFile) ||
            CrcStringCompareI(szFile, "WIN.INI") == crcEqual, fFalse);

    if (CrcStringCompareI(szFile, "WIN.INI") == crcEqual)
        {
        while (!WriteProfileString(szSect, szKey, NULL))
            if ((eerc = EercErrorHandler(hwndFrame, grcWriteIniValueErr, fVital,
                    szFile, szSect, szKey)) != eercRetry)
                return(eerc == eercIgnore);

        SendMessage((HWND)(-1), WM_WININICHANGE, 0, (LPARAM)szSect);
        }
    else while (!WritePrivateProfileString(szSect, szKey, NULL, szFile))
        if ((eerc = EercErrorHandler(hwndFrame, grcWriteIniValueErr, fVital,
                szFile, szSect, szKey)) != eercRetry)
            return(eerc == eercIgnore);

    return(fTrue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\list1.c ===
#include "precomp.h"
#pragma hdrstop
/* File: list.c */
/*************************************************************************
**  Common: Copy List building commands.
**************************************************************************/


//
//  BUGBUG  Ramonsa - pclnTail points to the end of the copy list, and it is
//                    used (and updated) when adding items to the list.
//                    However, it is NOT updated when removing elements from
//                    the list. This means that once an element is removed,
//                    the list gets corrupted and it is not safe to add
//                    new elements to the list.
//

extern PSTF APIENTRY PstfAlloc(VOID);
extern BOOL APIENTRY FFreePstf(PSTF);



/*
**  Purpose:
**      Adds all files in the section to the current copy list with
**      the given source and destination paths.
**  Arguments:
**      szSect:   non-Null, non-empty string which specifies the INF section
**          to include.
**      szSrcDir: non-Null, non-empty valid dir string (drive, colon, root
**          slash, and optional subdirs) for the location to find the source
**          files.
**      szDstDir: non-Null, non-empty valid dir string for the location to
**          write resulting files.
**  Notes:
**      Requires that the current INF structure was initialized with a
**      successful call to GrcOpenInf().
**      Requires that the Symbol Table was initialized with a successful
**      call to FInitSymTab() and that the file-description-option-symbols
**      (eg STF_BACKUP) are set appropriately.
**  Returns:
**      grcOkay if successful.
**      grcINFBadFDLine if any lines had invalid formats.
**      grcINFMissingLine if section line not found.
**      grcINFMissingSection if section not found
**      grcOutOfMemory if we ran out of memory while trying to add to the list.
**      grcNotOkay otherwise.
**
**************************************************************************/
GRC APIENTRY GrcAddSectionFilesToCopyList(szSect, szSrcDir,
        szDstDir)
SZ  szSect;
SZ  szSrcDir;
SZ  szDstDir;
{
    POER            poer;
    GRC             grc;
    SZ              szSrcDirNew;
    SZ              szDstDirNew;
    PINFPERMINFO    pPermInfo = pLocalInfPermInfo();

    ChkArg(szSect   != (SZ)NULL && *szSect != '\0',     1, grcNotOkay);
//  ChkArg(szSrcDir != (SZ)NULL && FValidDir(szSrcDir), 2, grcNotOkay);
    ChkArg(szSrcDir != (SZ)NULL, 2, grcNotOkay);
    ChkArg(szDstDir != (SZ)NULL && FValidDir(szDstDir), 3, grcNotOkay);

    PreCondSymTabInit(grcNotOkay);
    PreCondInfOpen(grcNotOkay);

    if ((szSrcDirNew = SzDupl(szSrcDir)) == (SZ)NULL)
        return(grcOutOfMemory);
    if (!FAddSzToFreeTable(szSrcDirNew, pPermInfo ))
        {
        SFree(szSrcDirNew);
        return(grcOutOfMemory);
        }

    if ((szDstDirNew = SzDupl(szDstDir)) == (SZ)NULL)
        return(grcOutOfMemory);
    if (!FAddSzToFreeTable(szDstDirNew, pPermInfo))
        {
        SFree(szDstDirNew);
        return(grcOutOfMemory);
        }

    if ((poer = PoerAlloc()) == (POER)NULL)
        return(grcOutOfMemory);

    if ((grc = GrcFillPoerFromSymTab(poer)) == grcOkay)
        grc = GrcAddSectionFilesToCList(sfoCopy, szSect, (SZ)NULL, szSrcDirNew,
                szDstDirNew, poer);

    EvalAssert(FSetPoerToEmpty(poer));
    EvalAssert(FFreePoer(poer));

    return(grc);
}


/*
**  Purpose:
**      Adds the file identified by the key in given section to
**      the copy list.
**  Arguments:
**      szSect:   non-Null, non-empty string which specifies the INF section
**          to include.
**      szKey:    non-Null, non-empty string to search for as a key in the
**          specified section.
**      szSrcDir: non-Null, non-empty valid dir string (drive, colon, root
**          slash, and optional subdirs) for the location to find the source
**          files.
**      szDstDir: non-Null, non-empty valid dir string for the location to
**          write resulting files.
**  Notes:
**      Requires that the current INF structure was initialized with a
**      successful call to GrcOpenInf().
**      Requires that the Symbol Table was initialized with a successful
**      call to FInitSymTab() and that the file-description-option-symbols
**      (eg STF_BACKUP) are set appropriately.
**  Returns:
**      grcOkay if successful.
**      grcINFBadFDLine if line had an invalid format.
**      grcINFMissingLine if section line not found.
**      grcINFMissingSection if section not found
**      grcOutOfMemory if we ran out of memory while trying to add to the list.
**      grcNotOkay otherwise.
**
**************************************************************************/
GRC APIENTRY GrcAddSectionKeyFileToCopyList(szSect, szKey,
        szSrcDir, szDstDir)
SZ  szSect;
SZ  szKey;
SZ  szSrcDir;
SZ  szDstDir;
{
    POER            poer;
    GRC             grc;
    SZ              szSrcDirNew;
    SZ              szDstDirNew;
    PINFPERMINFO    pPermInfo = pLocalInfPermInfo();

    ChkArg(szSect   != (SZ)NULL && *szSect != '\0',     1, grcNotOkay);
    ChkArg(szKey    != (SZ)NULL && *szKey  != '\0',     2, grcNotOkay);
    ChkArg(szSrcDir != (SZ)NULL, 3, grcNotOkay);
    ChkArg(szDstDir != (SZ)NULL && FValidDir(szDstDir), 4, grcNotOkay);

    PreCondSymTabInit(grcNotOkay);
    PreCondInfOpen(grcNotOkay);

    if ((szSrcDirNew = SzDupl(szSrcDir)) == (SZ)NULL)
        return(grcOutOfMemory);
    if (!FAddSzToFreeTable(szSrcDirNew, pPermInfo))
        {
        SFree(szSrcDirNew);
        return(grcOutOfMemory);
        }

    if ((szDstDirNew = SzDupl(szDstDir)) == (SZ)NULL)
        return(grcOutOfMemory);
    if (!FAddSzToFreeTable(szDstDirNew, pPermInfo))
        {
        SFree(szDstDirNew);
        return(grcOutOfMemory);
        }

    if ((poer = PoerAlloc()) == (POER)NULL)
        return(grcOutOfMemory);

    if ((grc = GrcFillPoerFromSymTab(poer)) == grcOkay)
        grc = GrcAddSectionFilesToCList(sfoCopy, szSect, szKey, szSrcDirNew,
                    szDstDirNew, poer);

    EvalAssert(FSetPoerToEmpty(poer));
    EvalAssert(FFreePoer(poer));

    return(grc);
}


/*
**  Purpose:
**      Adds the Nth file in given section to the current copy list.
**  Arguments:
**      szSect:   non-Null, non-empty string which specifies the INF section
**          to include.
**      nLine:    positive integer specifying which line of the above section
**          to include in the list.
**      szSrcDir: non-Null, non-empty valid dir string (drive, colon, root
**          slash, and optional subdirs) for the location to find the source
**          files.
**      szDstDir: non-Null, non-empty valid dir string for the location to
**          write resulting files.
**  Notes:
**      Requires that the current INF structure was initialized with a
**      successful call to GrcOpenInf().
**      Requires that the Symbol Table was initialized with a successful
**      call to FInitSymTab() and that the file-description-option-symbols
**      (eg STF_BACKUP) are set appropriately.
**  Returns:
**      grcOkay if successful.
**      grcINFBadFDLine if line did not exist or had an invalid format.
**      grcINFMissingLine if section line not found.
**      grcINFMissingSection if section not found.
**      grcOutOfMemory if we ran out of memory while trying to add to the list.
**      grcNotOkay otherwise.
**
**************************************************************************/
GRC APIENTRY GrcAddNthSectionFileToCopyList(SZ   szSect,
                                                       UINT nLine,
                                                       SZ   szSrcDir,
                                                       SZ   szDstDir)
{
    POER            poer;
    GRC             grc;
    SZ              szSrcDirNew;
    SZ              szDstDirNew;
    INT             Line;
    PINFPERMINFO    pPermInfo = pLocalInfPermInfo();

    ChkArg(szSect   != (SZ)NULL && *szSect != '\0',     1, grcNotOkay);
    ChkArg(nLine > 0,                                   2, grcNotOkay);
    ChkArg(szSrcDir != (SZ)NULL, 3, grcNotOkay);
    ChkArg(szDstDir != (SZ)NULL && FValidDir(szDstDir), 4, grcNotOkay);

    PreCondSymTabInit(grcNotOkay);
    PreCondInfOpen(grcNotOkay);

    if ((szSrcDirNew = SzDupl(szSrcDir)) == (SZ)NULL)
        return(grcOutOfMemory);
    if (!FAddSzToFreeTable(szSrcDirNew, pPermInfo))
        {
        SFree(szSrcDirNew);
        return(grcOutOfMemory);
        }

    if ((szDstDirNew = SzDupl(szDstDir)) == (SZ)NULL)
        return(grcOutOfMemory);
    if (!FAddSzToFreeTable(szDstDirNew, pPermInfo))
        {
        SFree(szDstDirNew);
        return(grcOutOfMemory);
        }

    if ((poer = PoerAlloc()) == (POER)NULL)
        return(grcOutOfMemory);

    if ((grc = GrcFillPoerFromSymTab(poer)) == grcOkay){
        if ( FindInfSectionLine(szSect) == -1 )
            grc = grcINFMissingSection;
        else if ((Line = FindNthLineFromInfSection(szSect, nLine)) != -1)
            grc = GrcAddLineToCList(Line,sfoCopy, szSrcDirNew, szDstDirNew, poer);
        else
            grc = grcINFMissingLine;
    }

    EvalAssert(FSetPoerToEmpty(poer));
    EvalAssert(FFreePoer(poer));

    return(grc);
}


/*
**  Purpose:
**      Adds a section of file lines to the Copy List.
**  Arguments:
**      sfo:      currently unused - reserved for future use.
**      szSect:   non-Null, non-empty string which specifies the INF section
**          to include.
**      szKey:    string to search for as a key in szSect.  If this is Null
**          then all the lines of szSect are included.
**      szSrcDir: non-Null, non-empty valid dir string (drive, colon, root
**          slash, and optional subdirs) for the location to find the source
**          files.
**      szDstDir: non-Null, non-empty valid dir string for the location to
**          write resulting files.
**      poer:     non-Null record of default options to be used if the
**          particular INF line does not explicitly specify an option.
**  Notes:
**      Requires that the current INF structure was initialized with a
**      successful call to GrcOpenInf().
**      Requires that the Symbol Table was initialized with a successful
**      call to FInitSymTab().
**  Returns:
**      grcOkay              if successful.
**      grcINFBadFDLine      if any lines had invalid formats.
**      grcINFMissingSection if section not found.
**      grcINFMissingLine    if section line not found
**      grcOutOfMemory if we ran out of memory while trying to add to the list.
**      grcNotOkay otherwise.
**
**************************************************************************/
GRC APIENTRY GrcAddSectionFilesToCList(SFO  sfo,
                                                  SZ   szSect,
                                                  SZ   szKey,
                                                  SZ   szSrcDir,
                                                  SZ   szDstDir,
                                                  POER poer)
{
    GRC grc;
    INT Line;

    ChkArg(szSect   != (SZ)NULL && *szSect != '\0',     2, grcNotOkay);
    ChkArg(szSrcDir != (SZ)NULL, 4, grcNotOkay);
    ChkArg(szDstDir != (SZ)NULL && FValidDir(szDstDir), 5, grcNotOkay);
    ChkArg(poer   != (POER)NULL && FValidPoer(poer),    6, grcNotOkay);

    PreCondSymTabInit(grcNotOkay);
    PreCondInfOpen(grcNotOkay);

    Unused(sfo);

    if (szKey != (SZ)NULL)
        {
        if ((Line = FindLineFromInfSectionKey(szSect, szKey)) != -1)
            grc = GrcAddLineToCList(Line, sfo, szSrcDir, szDstDir, poer);
        else
            grc = grcINFMissingLine;
        }
    else if ( FindInfSectionLine(szSect) == -1 )
        grc = grcINFMissingSection;
    else if (CKeysFromInfSection(szSect, fTrue) == 0)
        grc = grcOkay;
    else if ((Line = FindFirstLineFromInfSection(szSect)) == -1)
        grc = grcINFMissingLine;
    else
        {
        while ((grc = GrcAddLineToCList(Line, sfo, szSrcDir, szDstDir, poer)) ==
                    grcOkay &&
                ((Line = FindNextLineFromInf(Line)) != -1))
            ;
        }

    return(grc);
}


/*
**  Purpose:
**      Adds the given INF file line to the Copy List.
**  Arguments:
**      sfo:      currently unused - reserved for future use.
**      szSrcDir: non-Null, non-empty valid dir string (drive, colon, root
**          slash, and optional subdirs) for the location to find the source
**          files.
**      szDstDir: non-Null, non-empty valid dir string for the location to
**          write resulting files.
**      poer:     non-Null record of default options to be used if the
**          particular INF line does not explicitly specify an option.
**  Notes:
**      Requires that the current INF structure was initialized with a
**      successful call to GrcOpenInf() and that the current INF read
**      location is defined.
**      Requires that the Symbol Table was initialized with a successful
**      call to FInitSymTab().
**  Returns:
**      grcOkay if successful.
**      grcINFBadFDLine if any lines had invalid formats.
**      grcOutOfMemory if we ran out of memory while trying to add to the list.
**      grcNotOkay otherwise.
**  Assumes:
**      Current .INF line is a section file line.
**      No circular list-include-statements.
**
**************************************************************************/
GRC APIENTRY GrcAddLineToCList(INT  Line,
                                          SFO  sfo,
                                          SZ   szSrcDir,
                                          SZ   szDstDir,
                                          POER poer)
{
    ChkArg(szSrcDir != (SZ)NULL, 1, grcNotOkay);
    ChkArg(szDstDir != (SZ)NULL && FValidDir(szDstDir), 2, grcNotOkay);
    ChkArg(poer   != (POER)NULL && FValidPoer(poer),    3, grcNotOkay);

    PreCondSymTabInit(grcNotOkay);
    PreCondInfOpen(grcNotOkay);

    Unused(sfo);

    if (FListIncludeStatementLine(Line))
        {
        SZ  szSect = (SZ)NULL;
        SZ  szKey = (SZ)NULL;
        GRC grc;

        if ((grc = GrcGetListIncludeSectionLine(Line, &szSect, &szKey)) != grcOkay)
            return(grc);

        Assert(szSect != (SZ)NULL && szSect != '\0');

        grc = GrcAddSectionFilesToCList(sfoCopy, szSect, szKey, szSrcDir,
                szDstDir, poer);

        SFree(szSect);

        if (szKey != (SZ)NULL)
            SFree(szKey);

        return(grc);
        }
    else
        {
        PSFD         psfd;
        GRC          grc;
        PINFPERMINFO pPermInfo = pLocalInfPermInfo();

        if ((grc = GrcGetSectionFileLine(Line, &psfd, poer)) != grcOkay)
            return(grc);
        if (!FAddNewSzsInPoerToFreeTable(&(psfd->oer), poer, pPermInfo))
            {
            EvalAssert(FFreePsfd(psfd));
            return(grcOutOfMemory);
            }
        if ((grc = GrcAddPsfdToCList(szSrcDir, szDstDir, psfd)) != grcOkay)
            {
            EvalAssert(FSetPoerToEmpty(&(psfd->oer)));
            EvalAssert(FFreePsfd(psfd));
            return(grc);
            }

        Assert(FValidCopyList( pPermInfo ));
        }

    return(grcOkay);
}


/*
**  Purpose:
**      Adds an Inf Section File Description record to the Copy List.
**  Arguments:
**      szSrcDir: non-Null, non-empty valid dir string (drive, colon, root
**          slash, and optional subdirs) for the location to find the source
**          files.
**      szDstDir: non-Null, non-empty valid dir string for the location to
**          write resulting files.
**      psfd:     non-Null record with all fields and options instantiated.
**  Returns:
**      grcOkay if successful.
**      grcOutOfMemory if we ran out of memory while trying to add to the list.
**      grcNotOkay otherwise.
**
**************************************************************************/
GRC APIENTRY GrcAddPsfdToCList(szSrcDir, szDstDir, psfd)
SZ   szSrcDir;
SZ   szDstDir;
PSFD psfd;
{
    PCLN pcln;

    ChkArg(szSrcDir != (SZ)NULL, 1, grcNotOkay);
    ChkArg(szDstDir != (SZ)NULL && FValidDir(szDstDir), 2, grcNotOkay);
    ChkArg(psfd   != (PSFD)NULL && FValidPsfd(psfd),    3, grcNotOkay);

    if ((pcln = PclnAlloc()) == (PCLN)NULL)
        return(grcOutOfMemory);

    pcln->szSrcDir = szSrcDir;
    pcln->szDstDir = szDstDir;
    pcln->psfd     = psfd;

    pcln->pclnNext = *(pLocalInfPermInfo()->ppclnTail);
    *(pLocalInfPermInfo()->ppclnTail) = pcln;
    pLocalInfPermInfo()->ppclnTail = &(pcln->pclnNext);

    return(grcOkay);
}


/*
**  Purpose:
**      Free all nodes in Copy List, restore List to initial empty state,
**      and free all shared strings.
**  Arguments:
**      none
**  Returns:
**      Always returns fTrue.
**
**************************************************************************/
BOOL APIENTRY FFreeCopyList( PINFPERMINFO pPermInfo )
{
    PreCondition(FValidCopyList( pPermInfo ), fFalse);

    while (pPermInfo->pclnHead != (PCLN)NULL)
        {
        PCLN pcln = pPermInfo->pclnHead;

        pPermInfo->pclnHead = pcln->pclnNext;
        EvalAssert(FFreePcln(pcln));
        }

    pPermInfo->ppclnTail = &(pPermInfo->pclnHead);

    EvalAssert(FFreeFreeTable( pPermInfo ));

    return(fTrue);
}


/*
**  Purpose:
**      Allocates a Copy List Node.
**  Arguments:
**      none
**  Returns:
**      Returns pcln if successful, NULL if not (i.e. out of mem.)
**
**************************************************************************/
PCLN APIENTRY PclnAlloc()
{
    PCLN pcln;

    if ((pcln = (PCLN)SAlloc((CB)sizeof(CLN))) != (PCLN)NULL)
        {
        pcln->szSrcDir = (SZ)NULL;
        pcln->szDstDir = (SZ)NULL;
        pcln->psfd     = (PSFD)NULL;
        pcln->pclnNext = (PCLN)NULL;
        }

    return(pcln);
}


/*
**  Purpose:
**      Frees copy list node.
**  Arguments:
**      pcln: non-Null pcln structure to be freed.
**  Returns:
**      fTrue always.
**
**************************************************************************/
BOOL APIENTRY FFreePcln(pcln)
PCLN pcln;
{
    ChkArg(pcln != (PCLN)NULL, 1, fFalse);

    if (pcln->psfd != (PSFD)NULL)
        {
        EvalAssert(FSetPoerToEmpty(&((pcln->psfd)->oer)));
        EvalAssert(FFreePsfd(pcln->psfd));
        }

    SFree(pcln);

    return(fTrue);
}


/*
**  Purpose:
**      Prints the contents of the Copy List to a specified file.
**  Arguments:
**      pfh:  non-Null valid file pointer which has been opened for writing.
**      pcln: non-Null Copy List node to print.
**  Returns:
**      fTrue if successful, fFalse if not.
**
**************************************************************************/
BOOL APIENTRY FPrintPcln(pfh, pcln)
PFH  pfh;
PCLN pcln;
{
    BOOL fOkay = fTrue;

    ChkArg(pfh  != (PFH)NULL,  1, fFalse);
    ChkArg(pcln != (PCLN)NULL, 2, fFalse);

    if (!FWriteSzToFile(pfh,"\r\nszSrcDir:  "))
        fOkay = fFalse;
    if (!FWriteSzToFile(pfh, pcln->szSrcDir))
        fOkay = fFalse;
    if (!FWriteSzToFile(pfh,"\r\nszDstDir:  "))
        fOkay = fFalse;
    if (!FWriteSzToFile(pfh, pcln->szDstDir))
        fOkay = fFalse;

    if (!FPrintPsfd(pfh, pcln->psfd))
        fOkay = fFalse;

    if (!FWriteSzToFile(pfh, "\r\n"))
        return(fFalse);

    return(fOkay);
}


#if DBG
/*
**  Purpose:
**      Validates a Copy List Node.
**  Arguments:
**      pcln: non-Null Copy List Node to validate.
**  Returns:
**      fTrue if valid; fFalse otherwise.
**
**************************************************************************/
BOOL APIENTRY FValidPcln(pcln)
PCLN pcln;
{
    if (pcln->szSrcDir == (SZ)NULL ||
            pcln->szDstDir == (SZ)NULL ||
            !FValidDir(pcln->szDstDir) ||
            !FValidPsfd(pcln->psfd))
        return(fFalse);

    return(fTrue);
}


/*
**  Purpose:
**      Validates the entire Copy List.
**  Arguments:
**      none
**  Returns:
**      fTrue if valid; fFalse otherwise.
**
**************************************************************************/
BOOL APIENTRY FValidCopyList( PINFPERMINFO pPermInfo )
{
    PCLN pcln     = pPermInfo->pclnHead;

    while (pcln != NULL) {

        if (!FValidPcln(pcln)) {
            return(fFalse);
        }
        pcln     = pcln->pclnNext;
    }

    if ( pPermInfo->ppclnTail != (PPCLN)NULL &&
         *(pPermInfo->ppclnTail) != pcln) {
        return(fFalse);
    }

    return(fTrue);
}
#endif

/*
**  Purpose:
**      Initializes the Shared String Table for strings that need to be freed
**      when the Copy List is freed.
**  Arguments:
**      none
**  Returns:
**      fTrue if successful; fFalse otherwise.
**
**************************************************************************/
BOOL APIENTRY FInitFreeTable( PINFPERMINFO pPermInfo)
{
    return( pPermInfo->pstfHead == (PSTF)NULL);
}


/*
**  Purpose:
**      Adds a shared string to the String-Table for later Freeing.
**  Arguments:
**      sz: non-Null shared string to be stored.
**  Returns:
**      fTrue if successful; fFalse otherwise.
**
**************************************************************************/
BOOL APIENTRY FAddSzToFreeTable( SZ sz, PINFPERMINFO pPermInfo )
{
    ChkArg(sz != (SZ)NULL, 1, fFalse);

    if ( (pPermInfo->pstfHead == (PSTF)NULL) ||
         (pPermInfo->pstfHead->cszFree == 0) ) {

        PSTF pstfNew;

        if ((pstfNew = PstfAlloc()) == (PSTF)NULL)
            return(fFalse);

        pstfNew->pstfNext   = pPermInfo->pstfHead;
        pPermInfo->pstfHead = pstfNew;
    }

    Assert( pPermInfo->pstfHead != (PSTF)NULL &&
            pPermInfo->pstfHead->cszFree > 0);

    pPermInfo->pstfHead->rgsz[--(pPermInfo->pstfHead->cszFree)] = sz;

    return(fTrue);
}


/*
**  Purpose:
**      Adds all the strings that are new in an OER record into the shared
**      Strings Table for later freeing.
**  Arguments:
**      poerNew: non-Null OER for the new values.
**      poer:    non-Null OER of old values.
**  Returns:
**      fTrue if each changed SZ value can be stored in the shared String-Table
**          for later Freeing; fFalse otherwise.
**
**************************************************************************/
BOOL APIENTRY FAddNewSzsInPoerToFreeTable(poerNew, poer, pPermInfo)
POER         poerNew;
POER         poer;
PINFPERMINFO pPermInfo;
{
    ChkArg(poerNew != (POER)NULL && FValidPoer(poerNew), 1, fFalse);
    ChkArg(poer    != (POER)NULL && FValidPoer(poer),    2, fFalse);

    if (poerNew->szDescription != (SZ)NULL &&
            poerNew->szDescription != poer->szDescription &&
            !FAddSzToFreeTable(poerNew->szDescription, pPermInfo))
        return(fFalse);

    if (poerNew->szDate != (SZ)NULL &&
            poerNew->szDate != poer->szDate &&
            !FAddSzToFreeTable(poerNew->szDate, pPermInfo))
        return(fFalse);

    if (poerNew->szDest != (SZ)NULL &&
            poerNew->szDest != poer->szDest &&
            !FAddSzToFreeTable(poerNew->szDest, pPermInfo))
        return(fFalse);

    if (poerNew->szRename != (SZ)NULL &&
            poerNew->szRename != poer->szRename &&
            !FAddSzToFreeTable(poerNew->szRename, pPermInfo))
        return(fFalse);

    if (poerNew->szAppend != (SZ)NULL &&
            poerNew->szAppend != poer->szAppend &&
            !FAddSzToFreeTable(poerNew->szAppend, pPermInfo))
        return(fFalse);

    if (poerNew->szBackup != (SZ)NULL &&
            poerNew->szBackup != poer->szBackup &&
            !FAddSzToFreeTable(poerNew->szBackup, pPermInfo))
        return(fFalse);

    return(fTrue);
}


/*
**  Purpose:
**      Allocates an STF structure.
**  Arguments:
**      none
**  Returns:
**      non-Null STF pointer if successful; Null otherwise.
**
**************************************************************************/
PSTF APIENTRY PstfAlloc(VOID)
{
    PSTF pstf;

    if ((pstf = (PSTF)SAlloc((CB)sizeof(STF))) != (PSTF)NULL)
        pstf->cszFree = cszPerStf;

    return(pstf);
}


/*
**  Purpose:
**      Frees an allocated STF structure.
**  Arguments:
**      pstf: non-Null, allocated STF structure.
**  Returns:
**      fTrue always.
**
**************************************************************************/
BOOL APIENTRY FFreePstf(pstf)
PSTF pstf;
{
    USHORT iszToFree;

    ChkArg(pstf != (PSTF)NULL && pstf->cszFree <= cszPerStf, 1, fFalse);

    for (iszToFree = pstf->cszFree; iszToFree < cszPerStf; iszToFree++)
        {
        Assert(pstf->rgsz[iszToFree] != (SZ)NULL);
        SFree(pstf->rgsz[iszToFree]);
        }

    SFree(pstf);

    return(fTrue);
}


/*
**  Purpose:
**      Frees the shared strings in the String-Table and the String-Table
**      itself.
**  Arguments:
**      none
**  Returns:
**      fTrue always.
**
**************************************************************************/
BOOL APIENTRY FFreeFreeTable( PINFPERMINFO pPermInfo )
{
    while ( pPermInfo->pstfHead != (PSTF)NULL)
        {
        PSTF pstfCur;

        pstfCur = pPermInfo->pstfHead;
        pPermInfo->pstfHead = pstfCur->pstfNext;
        EvalAssert(FFreePstf(pstfCur));
        }

    return(fTrue);
}


/*
**  Purpose:
**      Initializes an empty OER structure by pulling default values from
**      the Symbol Table.  (Examples of symbols are STF_VITAL, STF_ROOT.)
**  Arguments:
**      poer: non-Null OER record to fill.
**  Notes:
**      Requires that the Symbol Table was initialized with a successful
**      call to FInitSymTab().
**  Returns:
**      grcOkay if successful.
**      grcOutOfMemory if out of memory.
**      grcInvalidPoer if the file-description-option-symbols (eg STF_DATE)
**          are not set appropriately.
**      grcNotOkay otherwise.
**
**************************************************************************/
GRC APIENTRY GrcFillPoerFromSymTab(poer)
POER poer;
{
    SZ           szValue;
    PINFPERMINFO pPermInfo = pLocalInfPermInfo();
    PSTR Pointer;


    ChkArg(poer != (POER)NULL, 1, grcNotOkay);

    PreCondSymTabInit(grcNotOkay);

    if ((szValue = SzFindSymbolValueInSymTab("STF_DESCRIPTION")) == (SZ)NULL ||
            *szValue == '\0')
        poer->szDescription = (SZ)NULL;
    else if ((poer->szDescription = SzDupl(szValue)) == (SZ)NULL)
        return(grcOutOfMemory);
    else if (!FAddSzToFreeTable(poer->szDescription, pPermInfo))
        {
        SFree(poer->szDescription);
        return(grcOutOfMemory);
        }

    if ((szValue = SzFindSymbolValueInSymTab("STF_VERSION")) == (SZ)NULL)
        poer->ulVerMS = poer->ulVerLS = 0L;
    else if (!FParseVersion(szValue, &(poer->ulVerMS), &(poer->ulVerLS)))
        return(grcInvalidPoer);

    if ((szValue = SzFindSymbolValueInSymTab("STF_DATE")) == (SZ)NULL ||
            *szValue == '\0')
        szValue = "1980-01-01";
    if ((poer->szDate = SzDupl(szValue)) == (SZ)NULL)
        return(grcOutOfMemory);
    else if (!FAddSzToFreeTable(poer->szDate, pPermInfo))
        {
        SFree(poer->szDate);
        return(grcOutOfMemory);
        }

    if ((szValue = SzFindSymbolValueInSymTab("STF_DEST")) == (SZ)NULL ||
            *szValue == '\0')
        poer->szDest = (SZ)NULL;
    else if ((poer->szDest = SzDupl(szValue)) == (SZ)NULL)
        return(grcOutOfMemory);
    else if (!FAddSzToFreeTable(poer->szDest, pPermInfo))
        {
        SFree(poer->szDest);
        return(grcOutOfMemory);
        }

    if ((szValue = SzFindSymbolValueInSymTab("STF_RENAME")) == (SZ)NULL ||
            *szValue == '\0')
        poer->szRename = (SZ)NULL;
    else if ((poer->szRename = SzDupl(szValue)) == (SZ)NULL)
        return(grcOutOfMemory);
    else if (!FAddSzToFreeTable(poer->szRename, pPermInfo ))
        {
        SFree(poer->szRename);
        return(grcOutOfMemory);
        }

    if ((szValue = SzFindSymbolValueInSymTab("STF_APPEND")) == (SZ)NULL ||
            *szValue == '\0')
        poer->szAppend = (SZ)NULL;
    else if ((poer->szAppend = SzDupl(szValue)) == (SZ)NULL)
        return(grcOutOfMemory);
    else if (!FAddSzToFreeTable(poer->szAppend, pPermInfo))
        {
        SFree(poer->szAppend);
        return(grcOutOfMemory);
        }

    if ((szValue = SzFindSymbolValueInSymTab("STF_BACKUP")) == (SZ)NULL ||
            *szValue == '\0')
        poer->szBackup = (SZ)NULL;
    else if ((poer->szBackup = SzDupl(szValue)) == (SZ)NULL)
        return(grcOutOfMemory);
    else if (!FAddSzToFreeTable(poer->szBackup, pPermInfo))
        {
        SFree(poer->szBackup);
        return(grcOutOfMemory);
        }

    //
    // New attribute added which means copy the file only if it exists on
    // the target
    //

    if ((szValue = SzFindSymbolValueInSymTab("STF_UPGRADEONLY")) == (SZ)NULL ||
            *szValue == '\0') {
        poer->oef &= ~oefUpgradeOnly;
    }
    else {
        poer->oef |= oefUpgradeOnly;
    }


    if ((szValue = SzFindSymbolValueInSymTab("STF_READONLY")) == (SZ)NULL ||
            *szValue == '\0')
        poer->oef &= ~oefReadOnly;
    else
        poer->oef |= oefReadOnly;

    if ((szValue = SzFindSymbolValueInSymTab("STF_SETTIMESTAMP")) == (SZ)NULL ||
            *szValue != '\0')
        poer->oef |= oefTimeStamp;
    else
        poer->oef &= ~oefTimeStamp;

    if ((szValue = SzFindSymbolValueInSymTab("STF_ROOT")) == (SZ)NULL ||
            *szValue == '\0')
        poer->oef &= ~oefRoot;
    else
        poer->oef |= oefRoot;

    if ((szValue = SzFindSymbolValueInSymTab("STF_COPY")) == (SZ)NULL ||
            *szValue != '\0')
        poer->oef |= oefCopy;
    else
        poer->oef &= ~oefCopy;

    if ((szValue = SzFindSymbolValueInSymTab("STF_DECOMPRESS")) == (SZ)NULL ||
            *szValue != '\0')
        poer->oef |= oefDecompress;
    else
        poer->oef &= ~oefDecompress;

    if ((szValue = SzFindSymbolValueInSymTab("STF_VITAL")) == (SZ)NULL ||
            *szValue != '\0')
        poer->oef |= oefVital;
    else
        poer->oef &= ~oefVital;

    if( ( (Pointer = SzGetNthFieldFromInfSectionKey("Signature","FileType",1)) == NULL ) ||
        ( _stricmp( Pointer, "MICROSOFT_FILE" ) != 0 )
      ) {
        poer->oef |= oefThirdPartyFile;
    } else {
        poer->oef &= ~oefThirdPartyFile;
    }

    if ((szValue = SzFindSymbolValueInSymTab("STF_UNDO")) == (SZ)NULL ||
            *szValue == '\0')
        poer->oef &= ~oefUndo;
    else
        poer->oef |= oefUndo;

    if ((szValue = SzFindSymbolValueInSymTab("STF_CSDVER")) == (SZ)NULL ||
            *szValue == '\0')
        poer->oef &= ~oefCsdInstall;
    else
        poer->oef |= oefCsdInstall;

    if ((szValue = SzFindSymbolValueInSymTab("STF_SIZE")) == (SZ)NULL)
        poer->lSize = 1L;
    else
        poer->lSize = atol(szValue);

    if ((szValue = SzFindSymbolValueInSymTab("STF_TIME")) == (SZ)NULL)
        poer->ctuCopyTime = 0;
    else
        poer->ctuCopyTime = (USHORT)atoi(szValue);      // 1632

    if ((szValue = SzFindSymbolValueInSymTab("STF_OVERWRITE")) == (SZ)NULL ||
            CrcStringCompare(szValue, "ALWAYS") == crcEqual)
        poer->owm = owmAlways;
    else if (CrcStringCompare(szValue, "NEVER") == crcEqual)
        poer->owm = owmNever;
    else if (CrcStringCompare(szValue, "OLDER") == crcEqual)
        poer->owm = owmOlder;
    else if (CrcStringCompare(szValue, "VERIFYSOURCEOLDER") == crcEqual)
        poer->owm = owmVerifySourceOlder;
    else if (CrcStringCompare(szValue, "UNPROTECTED") == crcEqual)
        poer->owm = owmUnprotected;
    else
        return(grcInvalidPoer);

    if (!FValidPoer(poer))
        return(grcInvalidPoer);

    return(grcOkay);
}


/*
**  Purpose:
**      Resets an OER record to appear empty, so that shared strings are not
**      freed accidently.
**  Arguments:
**      poer: non-Null OER to reset.
**  Returns:
**      fTrue always.
**
**************************************************************************/
BOOL APIENTRY FSetPoerToEmpty(poer)
POER poer;
{
    poer->szDescription = (SZ)NULL;
    poer->szDate        = (SZ)NULL;
    poer->szDest        = (SZ)NULL;
    poer->szRename      = (SZ)NULL;
    poer->szAppend      = (SZ)NULL;
    poer->szBackup      = (SZ)NULL;

    return(fTrue);
}




/*
**  Purpose:
**      Returns a pointer to pclnHead.
**  Arguments:
**      none
**  Returns:
**      non-Null pointer to pclnHead
**
**************************************************************************/
//PPCLN APIENTRY PpclnHeadList( PINFPERMINFO pPermInfo )
//{
//    return(&(pPermInfo->pclnHead));
//}


/*
**  Purpose:
**      Returns a pointer to ppclnTail.
**  Arguments:
**      none
**  Returns:
**      non-Null pointer to ppclnTail
**
**************************************************************************/
//PPPCLN APIENTRY PppclnTailList( PINFPERMINFO pPermInfo )
//{
//    return(&(pPermInfo->ppclnTail));
//}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\install.h ===
/* File: install.h */
/**************************************************************************/
/*	Install: Install Component Public Include File
/**************************************************************************/

#ifndef __install_
#define __install_

typedef BOOL (APIENTRY *PFNSF)(SZ, SZ);
// Function pointer for {Backup|Remove}SectionFiles
typedef BOOL (APIENTRY *PFNSKF)(SZ, SZ, SZ);
// Function pointer for {Backup|Remove}SectionKeyFile
typedef BOOL (APIENTRY *PFNSNF)(SZ, UINT, SZ);
// Function pointer for {Backup|Remove}SectionNthFile
typedef BOOL (APIENTRY *PFND)(SZ, BYTE);


extern BOOL APIENTRY FInstallEntryPoint(HANDLE, HWND, RGSZ, UINT);
extern BOOL APIENTRY FPromptForDisk(HANDLE, SZ, SZ);
extern BOOL APIENTRY FFileFound(SZ);
extern BOOL APIENTRY FCopy(SZ, SZ, OEF, OWM, BOOL, int, USHORT, PSDLE, SZ);
extern BOOL APIENTRY FDiskReady(SZ, DID);

/* REVIEW these should be in a private H file */
extern BOOL APIENTRY FGetArgSz(INT Line,UINT *NumFields,SZ *ArgReturn);
extern BOOL APIENTRY FGetArgUINT(INT, UINT *, UINT *);
extern BOOL APIENTRY FParseSectionFiles(INT, UINT *, PFNSF);
extern BOOL APIENTRY FParseSectionKeyFile(INT, UINT *, PFNSKF);
extern BOOL APIENTRY FParseSectionNFile(INT, UINT *, PFNSNF);
extern BOOL APIENTRY FParseCopySection(INT, UINT *);
extern BOOL APIENTRY FParseCopySectionKey(INT, UINT *);
extern BOOL APIENTRY FParseCopyNthSection(INT, UINT *);
extern BOOL APIENTRY FParseDirectory(INT, UINT *, PFND);
extern BOOL APIENTRY FParseCreateIniSection(INT, UINT *, SZ, SZ);
extern BOOL APIENTRY FParseReplaceIniSection(INT, UINT *, SZ, SZ);
extern BOOL APIENTRY FParseRemoveIniSection(INT, UINT *, SZ, SZ);
extern BOOL APIENTRY FParseCreateIniKeyValue(INT, UINT *, SZ, SZ);
extern BOOL APIENTRY FParseCreateIniKeyNoValue(INT, UINT *, SZ, SZ);
extern BOOL APIENTRY FParseReplaceIniKeyValue(INT, UINT *, SZ, SZ);
extern BOOL APIENTRY FParseAppendIniKeyValue(INT, UINT *, SZ, SZ);
extern BOOL APIENTRY FParseRemoveIniKey(INT, UINT *, SZ, SZ);
extern BOOL APIENTRY FParseIniSection(INT, UINT *, SPC);
extern BOOL APIENTRY FParseSetEnv(INT, UINT *);
#ifdef UNUSED
extern BOOL APIENTRY FParseAddMsgToSystemHelpFile(INT, UINT *);
extern BOOL APIENTRY FParseStampFile(INT, UINT *);
extern BOOL APIENTRY FUndoActions(void);
#endif /* UNUSED */
extern BOOL APIENTRY FParseStampResource(INT, UINT *);
extern BOOL APIENTRY FInitParsingTables(void);
extern BOOL APIENTRY FParseInstallSection(HANDLE hInstance, SZ szSection);
extern BOOL APIENTRY FDdeTerminate(void);
extern LONG APIENTRY WndProcDde(HWND, UINT, WPARAM, LONG);
extern BOOL APIENTRY FDdeInit(HANDLE);
extern VOID APIENTRY DdeSendConnect(ATOM, ATOM);
extern BOOL APIENTRY FDdeConnect(SZ, SZ);
extern BOOL APIENTRY FDdeWait(void);
extern BOOL APIENTRY FDdeExec(SZ);
extern BOOL APIENTRY FActivateProgMan(void);
#ifdef UNUSED
extern INT  APIENTRY EncryptCDData(UCHAR *, UCHAR *, UCHAR *, INT, INT, INT, UCHAR *);
#endif /* UNUSED */
extern BOOL APIENTRY FParseCloseSystem(INT, UINT *);
extern BOOL APIENTRY FParseCreateSysIniKeyValue(INT, UINT *, SZ, SZ);
extern BOOL APIENTRY FParseSearchDirList(INT, UINT *);
extern BOOL APIENTRY FParseSetupDOSAppsList(INT, UINT *);
extern BOOL APIENTRY FParseRunExternalProgram(INT, UINT *);
extern BOOL APIENTRY FStrToDate(SZ, PUSHORT, PUSHORT, PUSHORT);

extern BOOL APIENTRY FParseAddDos5Help(INT, USHORT *);
extern USHORT APIENTRY DateFromSz(SZ);
extern BOOL APIENTRY FConvertAndStoreRglInSymTab(PLONG_STF, SZ, INT);


extern BOOL APIENTRY FSearchDirList( SZ, SZ, BOOL, BOOL, SZ, SZ, SZ, SZ );
extern BOOL APIENTRY FInstallDOSPifs( SZ, SZ, SZ, SZ, SZ, SZ );






#define INSTALL_OUTCOME   "STF_INSTALL_OUTCOME"
#define SUCCESS           "STF_SUCCESS"
#define FAILURE           "STF_FAILURE"
#define USERQUIT          "STF_USERQUIT"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\init.c ===
#include "precomp.h"
#pragma hdrstop
/**************************************************************************/
/***** Shell Component - Init routines ************************************/
/**************************************************************************/


//#ifdef SYMTAB_STATS
//extern void SymTabStatDump(void);
//#endif

extern SZ   SzGetNextCmdLineString(PSZ);
extern BOOL fFullScreen;
extern PSTR LOCAL_SOURCE_DIRECTORY;

extern VOID Usage(HANDLE);

//
// Helper macro to make object attribute initialization a little cleaner.
//
#define INIT_OBJA(Obja,UnicodeString,UnicodeText)           \
                                                            \
    RtlInitUnicodeString((UnicodeString),(UnicodeText));    \
                                                            \
    InitializeObjectAttributes(                             \
        (Obja),                                             \
        (UnicodeString),                                    \
        OBJ_CASE_INSENSITIVE,                               \
        NULL,                                               \
        NULL                                                \
        )

SZ  szShlScriptSection = NULL;

CHP szArcPrefix[] = "\\ArcName\\";
#define ArcPrefixLen ((sizeof(szArcPrefix) / sizeof(CHP)) - 1)

CHP szNtPrefix[]  = "\\Device\\";
#define NtPrefixLen  ((sizeof(szNtPrefix) / sizeof(CHP)) - 1)

//
// Define a work area for path manipulation (note that we make
// it large enough for Unicode as well, so it can do dual duty.)
//
CHP TemporaryPathBuffer[cchlFullPathMax * sizeof(WCHAR)];

//
// Buffer used in querying object directories
//
UCHAR ObjBuffer[1024];

SZ  szDosType = "DOS";
SZ  szUncType = "UNC";

typedef struct _INITSYMHANDLE *PINITSYMHANDLE;
typedef struct _INITSYMHANDLE {
    SZ      szName;
    HANDLE  Handle;
} INITSYMHANDLE;

typedef struct _INITSYMNUMBER *PINITSYMNUMBER;
typedef struct _INITSYMNUMBER {
    SZ      szName;
    DWORD   dwNumber;
} INITSYMNUMBER;


INITSYMHANDLE InitSymHandle[] =  {
    //
    //  Predefined registry handles
    //
    {   "REG_H_LOCAL",          HKEY_LOCAL_MACHINE          },
    {   "REG_H_CLASSES",        HKEY_CLASSES_ROOT           },
    {   "REG_H_USERS",          HKEY_USERS                  },
    {   "REG_H_CUSER",          HKEY_CURRENT_USER           },
    //
    { NULL, 0 }
    };


INITSYMNUMBER InitSymNumber[] = {
    //
    //  Registry key creation options
    //
    {   "REG_OPT_VOLATILE",              REG_OPTION_VOLATILE     },
    {   "REG_OPT_NONVOL",                REG_OPTION_NON_VOLATILE },
    //
    //  Registry value types
    //
    {   "REG_VT_NONE",                        REG_NONE                },
    {   "REG_VT_BIN",                         REG_BINARY              },
    {   "REG_VT_SZ",                          REG_SZ                  },
    {   "REG_VT_EXPAND_SZ",                   REG_EXPAND_SZ           },
    {   "REG_VT_MULTI_SZ",                    REG_MULTI_SZ            },
    {   "REG_VT_DWORD",                       REG_DWORD               },
    {   "REG_VT_RESOURCE_LIST",               REG_RESOURCE_LIST              },
    {   "REG_VT_FULL_RESOURCE_DESCRIPTOR",    REG_FULL_RESOURCE_DESCRIPTOR   },
    {   "REG_VT_RESOURCE_REQUIREMENTS_LIST",  REG_RESOURCE_REQUIREMENTS_LIST },
    //
    // Registry access mask bits
    //
    {   "REG_KEY_QUERY_VALUE",           KEY_QUERY_VALUE         },
    {   "REG_KEY_SET_VALUE",             KEY_SET_VALUE           },
    {   "REG_KEY_CREATE_SUB_KEY",        KEY_CREATE_SUB_KEY      },
    {   "REG_KEY_ENUMERATE_SUB_KEYS",    KEY_ENUMERATE_SUB_KEYS  },
    {   "REG_KEY_NOTIFY",                KEY_NOTIFY              },
    {   "REG_KEY_READ",                  KEY_READ                },
    {   "REG_KEY_WRITE",                 KEY_WRITE               },
    {   "REG_KEY_READWRITE",             KEY_READ | KEY_WRITE    },
    {   "REG_KEY_EXECUTE",               KEY_EXECUTE             },
    {   "REG_KEY_ALL_ACCESS",            KEY_ALL_ACCESS          },
    //
    // Registry errors BugBug** should replace with values from winerror.h
    //
    {   "REG_ERROR_SUCCESS",             0L                      },
    //
    // Service Types (Bit Mask)
    //
    {   "SERVICE_KERNEL_DRIVER",         SERVICE_KERNEL_DRIVER        },
    {   "SERVICE_FILE_SYSTEM_DRIVER",    SERVICE_FILE_SYSTEM_DRIVER   },
    {   "SERVICE_ADAPTER",               SERVICE_ADAPTER              },
    {   "SERVICE_WIN32_OWN_PROCESS",     SERVICE_WIN32_OWN_PROCESS    },
    {   "SERVICE_WIN32_SHARE_PROCESS",   SERVICE_WIN32_SHARE_PROCESS  },
    //
    // Start Type
    //
    {   "SERVICE_BOOT_START",            SERVICE_BOOT_START           },
    {   "SERVICE_SYSTEM_START",          SERVICE_SYSTEM_START         },
    {   "SERVICE_AUTO_START",            SERVICE_AUTO_START           },
    {   "SERVICE_DEMAND_START",          SERVICE_DEMAND_START         },
    {   "SERVICE_DISABLED",              SERVICE_DISABLED             },
    //
    // Error control type
    //
    {   "SERVICE_ERROR_IGNORE",          SERVICE_ERROR_IGNORE         },
    {   "SERVICE_ERROR_NORMAL",          SERVICE_ERROR_NORMAL         },
    {   "SERVICE_ERROR_SEVERE",          SERVICE_ERROR_SEVERE         },
    {   "SERVICE_ERROR_CRITICAL",        SERVICE_ERROR_CRITICAL       },
    //
    //  ShellCode values
    //
    {   "SHELL_CODE_OK",                SHELL_CODE_OK               },
    {   "SHELL_CODE_NO_SUCH_INF",       SHELL_CODE_NO_SUCH_INF      },
    {   "SHELL_CODE_NO_SUCH_SECTION",   SHELL_CODE_NO_SUCH_SECTION  },
    {   "SHELL_CODE_ERROR",             SHELL_CODE_ERROR            },
    //
    //  Exit_Code values
    //
    {   "SETUP_ERROR_SUCCESS",          SETUP_ERROR_SUCCESS    },
    {   "SETUP_ERROR_USERCANCEL",       SETUP_ERROR_USERCANCEL },
    {   "SETUP_ERROR_GENERAL",          SETUP_ERROR_GENERAL    },
    //
    { NULL, 0 }
    };


BOOL fCheckInfValidity = fFalse;
BOOL FMakeWindows(HANDLE hInstance);
BOOL FProcessForDriveType(SZ, SZ, SZ, SZ);
BOOL FProcessInfSrcPath( SZ szInf, SZ szCWD, SZ szProcessedDir );
HWND FindProperParent ( void ) ;


HANDLE hVerDLL = NULL;

#define FExistFile(sz)  ((BOOL)(PfhOpenFile(sz, ofmExistRead) != (PFH)NULL))


//
//  Symbols that are defined in the command line are kept in a list of
//  VALUE_BLOCKs until the symbol table is created, point at which they
//  are added to the symbol table and the VALUE_BLOCK list is destroyed.
//
typedef struct _VALUE_BLOCK *PVALUE_BLOCK;
typedef struct _VALUE_BLOCK {
    PVALUE_BLOCK    pNext;      //  Next in chain
    SZ              szSymbol;   //  Symbol
    SZ              szValue;    //  Value
} VALUE_BLOCK;


PVALUE_BLOCK    pCmdLineSymbols =   NULL;


/*
**      Purpose:
**              Generates a Usage message.
**      Arguments:
**              hInst: For retrieving string resources.
**      Returns:
**              none
***************************************************************************/
VOID Usage(hInst)
HANDLE hInst;
{
    CHP  rgch[1024];
    CCHP cchpBuf = 1024;

    CCHP cchp, cchpCurrent = 0;

    UINT wID[] = { IDS_USAGE_MSG1, IDS_USAGE_MSG2, IDS_USAGE_USAGE,
                   IDS_USAGE_F,    IDS_USAGE_I,    IDS_USAGE_C,
                   IDS_USAGE_S,    IDS_USAGE_T,    IDS_USAGE_V
                 } ;
    INT i, j;


        EvalAssert(LoadString(hInst, IDS_USAGE_TITLE, rgchBufTmpShort,
            cchpBufTmpShortMax));

    for( i = 0, j = sizeof( wID ) / sizeof( UINT ); i < j; i++ ) {
        Assert(cchpBuf > 0);
        EvalAssert((cchp = LoadString(hInst, wID[i], rgch + cchpCurrent,
                cchpBuf)) != 0);
        cchpCurrent = cchpCurrent + cchp;
        cchpBuf = cchpBuf - cchp;
    }


    while (!MessageBox(hWndShell, rgch, rgchBufTmpShort, MB_OK)) {
        if (!FHandleOOM(hWndShell)) {
            break;
        }
    }
}


/*
**      Purpose:
**              Generates a message indicating that maintenance-mode setup
**              functionality is now accessible via Control Panel applets.
**      Arguments:
**              hInst: For retrieving string resources.
**      Returns:
**              none
***************************************************************************/
VOID MaintSetupObsoleteMsg(hInst)
HANDLE hInst;
{
    CHP  rgch[1024];
    CCHP cchpBuf = 1024;

    CCHP cchp, cchpCurrent = 0;

    UINT wID[] = { IDS_MAINTOBS_MSG1 };
    INT i, j;


        EvalAssert(LoadString(hInst, IDS_WINDOWS_NT_SETUP, rgchBufTmpShort,
            cchpBufTmpShortMax));

    for( i = 0, j = sizeof( wID ) / sizeof( UINT ); i < j; i++ ) {
        Assert(cchpBuf > 0);
        EvalAssert((cchp = LoadString(hInst, wID[i], rgch + cchpCurrent,
                cchpBuf)) != 0);
        cchpCurrent = cchpCurrent + cchp;
        cchpBuf = cchpBuf - cchp;
    }


    while (!MessageBox(hWndShell, rgch, rgchBufTmpShort, MB_ICONINFORMATION | MB_OK)) {
        if (!FHandleOOM(hWndShell)) {
            break;
        }
    }
}


/*
**      Purpose:
**              Gets the next string on the Command Line.
**      Arguments:
**              pszCmdLine: Command Line argument as received in WinMain().
**      Returns:
**              SZ
***************************************************************************/
SZ SzGetNextCmdLineString(pszCmdLine)
PSZ pszCmdLine;
{
        SZ  szCur = *pszCmdLine;
        SZ  szAnswer;

        while (FWhiteSpaceChp(*szCur))
                szCur = SzNextChar(szCur);

        if (*szCur == '"')
                {
                SZ szWriteCur;
                CB cbWrite = (CB)0;

                while ((szWriteCur = szAnswer = (SZ)SAlloc((CB)4096)) == (SZ)NULL)
                        if (!FHandleOOM(hWndShell))
                                return((SZ)NULL);

                szCur = SzNextChar(szCur);
                while (fTrue)
                        {
                        SZ szNext;

                        if (*szCur == '"' &&
                                        *(szCur = SzNextChar(szCur)) != '"')
                                break;

                        if (*szCur == '\0')
                                {
                                SFree(szAnswer);
                                return((SZ)NULL);
                                }

                        szNext = SzNextChar(szCur);
                        while (szCur < szNext)
                                {
                                if (++cbWrite >= 4096)
                                        {
                                        SFree(szAnswer);
                                        return((SZ)NULL);
                                        }
                                *szWriteCur++ = *szCur++;
                                }
                        }
                *szWriteCur = '\0';

                Assert(strlen(szAnswer) == cbWrite);
                Assert(cbWrite + 1 <= (CB)4096);
                if (cbWrite + 1 < (CB)4096)
                        szAnswer = SRealloc((PB)szAnswer, cbWrite + 1);
                Assert(szAnswer != (SZ)NULL);
                }
        else if (*(*pszCmdLine = szCur) == '\0')
                return((SZ)NULL);
        else
                {
                CHP chpSav;

                while (*szCur != '\0' &&
                                !FWhiteSpaceChp(*szCur))
                        szCur = SzNextChar(szCur);

                chpSav = *szCur;
                *szCur = '\0';
                while ((szAnswer = SzDupl(*pszCmdLine)) == (SZ)NULL)
                        if (!FHandleOOM(hWndShell))
                                break;
                *szCur = chpSav;
                }

        while (*szCur != '\0' &&
                        FWhiteSpaceChp(*szCur))
                szCur = SzNextChar(szCur);

        *pszCmdLine = szCur;

        return(szAnswer);
}


/*
**      Purpose:
**              Parses the Command Line received in WinMain().
**      Arguments:
**              ??
**      Returns:
**              BOOL
***************************************************************************/
INT
ParseCmdLine(
    HANDLE hInst,
    SZ     szCmdLine,
    PSZ    pszInfSrcPath,
    PSZ    pszDestDir,
    PSZ    pszSrcDir,
    PSZ    pszCWD,
    INT *  pwModeSetup
    )

{
    BOOL fSetupInfSpecified      = fFalse;
    BOOL fScriptSectionSpecified = fFalse;
    BOOL fSourcePathSpecified    = fFalse;

    SZ   szBase;
    INT cchp;
    SZ  szCur;
    SZ  szLastBackSlash = NULL;
    CHAR szInfPath[MAX_PATH];
    BOOL bStatus;


    *pwModeSetup = wModeSetupNormal;

    while(FWhiteSpaceChp(*szCmdLine)) {
        szCmdLine = SzNextChar(szCmdLine);
    }

    while(*szCmdLine) {
        if (*szCmdLine == '-' || *szCmdLine == '/') {

            szCmdLine++;

            switch (*szCmdLine++){

            case 'c':
            case 'C':

                if(fScriptSectionSpecified
                || (szShlScriptSection = SzGetNextCmdLineString(&szCmdLine)) == NULL) {

                    Usage(hInst);
                    return(CMDLINE_ERROR);
                }

                if(*(szShlScriptSection) == '\0'
                || *(szShlScriptSection) == ']'
                || *(szShlScriptSection) == '[') {

                    LoadString(
                        hInst,
                        IDS_ERROR,
                        rgchBufTmpShort,
                        cchpBufTmpShortMax
                        );

                    LoadString(
                        hInst,
                        IDS_BAD_SHL_SCRIPT_SECT,
                        rgchBufTmpLong,
                        cchpBufTmpLongMax
                        );

                    MessageBox(
                        hWndShell,
                        rgchBufTmpLong,
                        rgchBufTmpShort,
                        MB_OK | MB_ICONHAND
                        );

                    Usage(hInst);
                    return(CMDLINE_ERROR);
                }

                fScriptSectionSpecified = fTrue;
                break;

            //
            // Allow /k but ignore it. It's processed in setup.c.
            //
            case 'f':
            case 'F':
            case 'k':
            case 'K':
                break;

            case 'w':
            case 'W':
                //
                // Since the /w parameter has already been handled
                // (see SETUP.C), eat the argument.
                //
                if(szBase = SzGetNextCmdLineString(&szCmdLine)) {
                    SFree(szBase);
                }
                break;

            case 'i':
            case 'I':
                if (fSetupInfSpecified ||
                    (*pszInfSrcPath = SzGetNextCmdLineString(&szCmdLine)) == (SZ)NULL)
                {
                    Usage(hInst);
                    return(CMDLINE_ERROR);
                }

                if (**pszInfSrcPath == '\0') {
                    LoadString(hInst, IDS_ERROR, rgchBufTmpShort,
                            cchpBufTmpShortMax);
                    LoadString(hInst, IDS_BAD_INF_SRC, rgchBufTmpLong,
                            cchpBufTmpLongMax);
                    MessageBox(hWndShell, rgchBufTmpLong, rgchBufTmpShort,
                            MB_OK | MB_ICONHAND);
                    Usage(hInst);
                    return(CMDLINE_ERROR);
                }

                fSetupInfSpecified = fTrue;
                break;

            case 'g':
            case 'G':
                if (*pwModeSetup != wModeSetupNormal)
                                        {
                                        Usage(hInst);
                    return(CMDLINE_ERROR);
                                        }
                *pwModeSetup = wModeGuiInitialSetup;
                                break;

            case 's':
            case 'S':

                *pszSrcDir = SzGetNextCmdLineString(&szCmdLine);
                if(*pszSrcDir == NULL) {
                    Usage(hInst);
                    return(CMDLINE_ERROR);
                }

                if(**pszSrcDir == '\0') {

                    LoadString(
                        hInst,
                        IDS_ERROR,
                        rgchBufTmpShort,
                        cchpBufTmpShortMax
                        );

                    LoadString(
                        hInst,
                        IDS_BAD_SRC_PATH,
                        rgchBufTmpLong,
                        cchpBufTmpLongMax
                        );

                    MessageBox(
                        hWndShell,
                        rgchBufTmpLong,
                        rgchBufTmpShort,
                        MB_OK | MB_ICONHAND
                        );

                    Usage(hInst);
                    return(CMDLINE_ERROR);
                }

                fSourcePathSpecified = fTrue;
                break;

            case 't':
            case 'T':
                {
                    SZ              szSymbol;
                    SZ              szEqual;
                    SZ              szValue;
                    PVALUE_BLOCK    pVb;


                    if ( ( szSymbol = SzGetNextCmdLineString( &szCmdLine ) ) == NULL ) {
                        Usage(hInst);
                        return CMDLINE_ERROR;
                    }

                    if ( ( szEqual = SzGetNextCmdLineString( &szCmdLine ) ) == NULL ) {
                        Usage(hInst);
                        return CMDLINE_ERROR;
                    }

                    if ( ( szValue = SzGetNextCmdLineString( &szCmdLine ) ) == NULL ) {
                        Usage(hInst);
                        return CMDLINE_ERROR;
                    }

                    if ( (*szEqual != '=') || (*(szEqual+1) != '\0' ) ) {
                        Usage(hInst);
                        return CMDLINE_ERROR;
                    }

                    while ( (pVb = (PVALUE_BLOCK)SAlloc( sizeof( VALUE_BLOCK ) )) == NULL ) {
                        if ( !FHandleOOM(hWndShell)) {
                            return CMDLINE_ERROR;
                        }
                    }

                    pVb->szSymbol = szSymbol;
                    pVb->szValue  = szValue;


                    if ( pCmdLineSymbols ) {
                        pVb->pNext      = pCmdLineSymbols;
                    } else {
                        pVb->pNext      = NULL;
                    }
                    pCmdLineSymbols = pVb;

                }


                break;

            case 'v':
            case 'V':

                fCheckInfValidity = fTrue;
                break;

            case '?':
            default:

                Usage(hInst);
                return(CMDLINE_SETUPDONE);

            } // switch

        } else {

            Usage(hInst);
            return(CMDLINE_ERROR);

        } // if we have - or /

        while (FWhiteSpaceChp(*szCmdLine)) {
            szCmdLine = SzNextChar(szCmdLine);
        }

    } // while unseen chars on cmd line

    while((szCur = *pszCWD = (SZ)SAlloc((CB)4096)) == NULL) {
        if(!FHandleOOM(hWndShell)) {
            return(CMDLINE_ERROR);
        }
    }

    //
    // Want name of exe, not name of this dll.
    //
    if ((cchp = GetModuleFileName(hInst, (LPSTR)szCur, 4095)) >= 4095) {

        LoadString(hInst, IDS_ERROR, rgchBufTmpShort, cchpBufTmpShortMax);
        LoadString(hInst, IDS_EXE_PATH_LONG, rgchBufTmpLong,cchpBufTmpLongMax);

        MessageBox(hWndShell, rgchBufTmpLong, rgchBufTmpShort,MB_OK | MB_ICONHAND);
        SFree(szCur);
        return(CMDLINE_ERROR);
    }

    if (PfhOpenFile(szCur, ofmExistRead) == NULL) {

        LoadString(hInst, IDS_INTERNAL_ERROR, rgchBufTmpShort,
                        cchpBufTmpShortMax);
        LoadString(hInst, IDS_GET_MOD_FAIL, rgchBufTmpLong,
                        cchpBufTmpLongMax);
        MessageBox(hWndShell, rgchBufTmpLong, rgchBufTmpShort,
                        MB_OK | MB_ICONHAND);
        SFree(*pszCWD);
        return(CMDLINE_ERROR);
    }

    while(*szCur) {
        if(*szCur++ == '\\') {
            szLastBackSlash = szCur;
        }
    }

    if (szLastBackSlash == (SZ)NULL) {
        LoadString(hInst, IDS_INTERNAL_ERROR, rgchBufTmpShort,
                        cchpBufTmpShortMax);
        LoadString(hInst, IDS_GET_MOD_FAIL, rgchBufTmpLong,
                        cchpBufTmpLongMax);
        MessageBox(hWndShell, rgchBufTmpLong, rgchBufTmpShort,
                        MB_OK | MB_ICONHAND);
        SFree(*pszCWD);
        return(CMDLINE_ERROR);
    }

    if(!fSetupInfSpecified) {

        szCur = szLastBackSlash;
        while (*szCur != '\0') {

            if (*szCur == '.') {
                *szCur = '\0';
                break;
            }

            szCur++;
        }

        while((szBase = SzDupl(szLastBackSlash)) == (SZ)NULL) {
            if(!FHandleOOM(hWndShell)) {
                return(CMDLINE_ERROR);
            }
        }
    }

    *szLastBackSlash = '\0';

    if(strlen(*pszCWD) + 1 < 4096) {

        *pszCWD = SRealloc(*pszCWD,strlen(*pszCWD)+1);
    }

    if(!fSourcePathSpecified) {
        while((*pszSrcDir = SzDupl(*pszCWD)) == (SZ)NULL) {
            if (!FHandleOOM(hWndShell)) {
                return(CMDLINE_ERROR);
            }
        }
    }

    //
    // if setup inf is not specified, then user is attempting to enter
    // maintenance-mode setup, which is obsolete.  Give the user a friendly
    // message informing them of this, and directing them to the new functionality
    // in the Control Panel.
    //
    if(!fSetupInfSpecified) {

        Assert(szBase);
        SFree(szBase);

        MaintSetupObsoleteMsg(hInst);

        return CMDLINE_ERROR;

/*
        LoadString(hInst,IDS_SETUP_INF,rgchBufTmpLong,cchpBufTmpLongMax);

        while((*pszInfSrcPath = SAlloc(strlen(szBase)+strlen(rgchBufTmpLong)+2)) == NULL) {
            if (!FHandleOOM(hWndShell)) {
                return( CMDLINE_ERROR );
            }
        }

        strcpy(*pszInfSrcPath,szBase);
        lstrcat(*pszInfSrcPath,".");
        lstrcat(*pszInfSrcPath,rgchBufTmpLong);
*/
    }

    //
    // Process the setup inf found ( check to see if it exists ) in the
    // cwd or in windows system .. and get a full path back to the processed
    // setup inf location
    //
    bStatus = FProcessInfSrcPath(*pszInfSrcPath,*pszCWD,szInfPath);

    if(!bStatus) {

        LoadString( hInst, IDS_ERROR, rgchBufTmpShort, cchpBufTmpShortMax );
        LoadString( hInst, IDS_BAD_INF_SRC, rgchBufTmpLong, cchpBufTmpLongMax);
        MessageBox(hWndShell, rgchBufTmpLong, rgchBufTmpShort,MB_OK | MB_ICONHAND);

        Usage(hInst);
        return(CMDLINE_ERROR);
    }

    SFree(*pszInfSrcPath);
    *pszInfSrcPath = SAlloc(strlen( szInfPath ) + 1 );
    strcpy(*pszInfSrcPath, szInfPath);

    *pszDestDir = NULL;

    if(!fScriptSectionSpecified) {

        LoadString(hInst,IDS_SHELL_CMDS_SECT,rgchBufTmpShort,cchpBufTmpShortMax);

        while((szShlScriptSection = SzDupl(rgchBufTmpShort)) == (SZ)NULL) {

            if(!FHandleOOM(hWndShell)) {
                return(CMDLINE_ERROR);
            }
        }
    }

    return(CMDLINE_SUCCESS);
}


BOOL
CreateShellWindow(
    IN HANDLE hInstance,
    IN INT    nCmdShow,
    IN BOOL   CleanUp
    )
{
    HDC        hdc;
    TEXTMETRIC tm;
    WNDCLASS   wc;
    BOOL       RegisterStatus;

    if(!CleanUp) {

        nCmdShow = SW_SHOWMAXIMIZED;
        hInst = hInstance;

        wc.style         = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
        wc.lpfnWndProc   = ShellWndProc;
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = 0;
        wc.hInstance     = hInstance;
        wc.hIcon         = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_STF_ICON));
        wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
        wc.lpszMenuName  =  NULL;
    }

    wc.lpszClassName = "Stuff-Shell";

    if(CleanUp) {
        ProInit(FALSE);
        ControlInit(FALSE);
        DlgDefClassInit(hInstance,FALSE);
        ButtonControlTerm();
        UnregisterClass(wc.lpszClassName,hInst);
        return(TRUE);
    } else {
        RegisterStatus = RegisterClass(&wc);
        RegisterStatus &= ButtonControlInit(hInstance);
        RegisterStatus &= DlgDefClassInit(hInstance,TRUE);
        RegisterStatus &= ControlInit(TRUE);
        RegisterStatus &= ProInit(TRUE);
    }

    if(!RegisterStatus) {

        LoadString(hInstance,IDS_ERROR,rgchBufTmpShort,cchpBufTmpShortMax);
        LoadString(hInstance,IDS_REGISTER_CLASS,rgchBufTmpLong,cchpBufTmpLongMax);

        MessageBox(
            NULL,
            rgchBufTmpLong,
            rgchBufTmpShort,
            MB_OK | MB_ICONHAND | MB_SYSTEMMODAL
            );

        return(fFalse);
    }

    hdc  = GetDC(NULL);
    if (hdc) {
    
       GetTextMetrics(hdc, &tm);
       dxChar = tm.tmAveCharWidth;
       dyChar = tm.tmHeight;
       ReleaseDC(NULL, hdc);

    }

    if(!FMakeWindows(hInstance)) {

        LoadString(hInstance,IDS_ERROR,rgchBufTmpShort,cchpBufTmpShortMax);
        LoadString(hInstance,IDS_CREATE_WINDOW,rgchBufTmpLong,cchpBufTmpLongMax);

        MessageBox(
            NULL,
            rgchBufTmpLong,
            rgchBufTmpShort,
            MB_OK | MB_ICONHAND | MB_SYSTEMMODAL
            );

        return(fFalse);
    }

    if ( ! fFullScreen ) {
        RECT rWind ;

        GetWindowRect( hWndShell, & rWind ) ;

        MoveWindow( hWndShell,
                    20000,
                    20000,
                    rWind.right - rWind.left,
                    rWind.bottom - rWind.top,
                    FALSE ) ;

        nCmdShow = SW_SHOWNOACTIVATE ;
    }

    ShowWindow(hWndShell,nCmdShow);
    UpdateWindow(hWndShell);

    if (!FInitHook()) {
        //
        // BUGBUG.. Do we need to process this error, or do we just lose
        // the capability to process keyboard hooks
        //
    }

    return(fTrue);
}


/*
**      Purpose:
**              Initializes structures.
**      Arguments:
**              ??
**      Returns:
**              BOOL
***************************************************************************/
BOOL
FInitApp(
    HANDLE hInstance,
    SZ     szInfSrcPath,
    SZ     szDestDir,
    SZ     szSrcDir,
    SZ     szCWD,
    INT    wModeSetup
    )

{
    GRC             grc = grcOkay;
    INT             Line;
    CHAR            szName[cchlFullPathMax];
    CHAR            szDriveType[10];
    CHAR            szProcessedDir[cchlFullPathMax];
    PINFCONTEXT     pContext;
    PINFTEMPINFO    pTempInfo;
    SZ              szInstallType;

    ChkArg(hInstance != (HANDLE)NULL, 1, fFalse);
    ChkArg(szInfSrcPath != (SZ)NULL && *szInfSrcPath != '\0', 2, fFalse);
    ChkArg(szSrcDir != (SZ)NULL && *szSrcDir != '\0', 4, fFalse);
    ChkArg(szCWD != (SZ)NULL && *szCWD != '\0', 5, fFalse);

    Assert(szShlScriptSection != (SZ)NULL && *(szShlScriptSection) != '\0');

    //
    //  Create INF permanent and temporary info.
    //

    PathToInfName( szInfSrcPath, szName );
    while ( !(pTempInfo = (PINFTEMPINFO)CreateInfTempInfo( AddInfPermInfo( szName ) )) ) {
        if (!FHandleOOM(hWndShell))
                        return(fFalse);
    }

    //
    //  Create global context.
    //
    while ( !(pContext = (PINFCONTEXT)SAlloc( (CB)sizeof(CONTEXT) )) ) {
        if (!FHandleOOM(hWndShell))
                        return(fFalse);
    }

    pContext->pInfTempInfo = pTempInfo;
    pContext->pNext        = NULL;

    PushContext( pContext );

    pLocalContext()->szShlScriptSection = szShlScriptSection;

    //
    //  Add all the symbols specified in the command line
    //
    while ( pCmdLineSymbols ) {

        PVALUE_BLOCK    p = pCmdLineSymbols;

        pCmdLineSymbols = pCmdLineSymbols->pNext;

        while (!FAddSymbolValueToSymTab(p->szSymbol, p->szValue)) {
            if (!FHandleOOM(hWndShell)) {
                return(fFalse);
            }
        }

        SFree( p->szSymbol );
        SFree( p->szValue );
        SFree( p );
    }

    FInitParsingTables();

    GetWindowsDirectory(szProcessedDir,sizeof(szProcessedDir));
    while(!FAddSymbolValueToSymTab("STF_WINDOWS_DIR",szProcessedDir)) {
        if(!FHandleOOM(hWndShell)) {
            return(fFalse);
        }
    }
    GetSystemDirectory(szProcessedDir,sizeof(szProcessedDir));
    while(!FAddSymbolValueToSymTab("STF_SYSTEM_DIR",szProcessedDir)) {
        if(!FHandleOOM(hWndShell)) {
            return(fFalse);
        }
    }

    //
    // Process SRC DIR
    //

    if (!FProcessForDriveType(szSrcDir, szDriveType, szCWD, szProcessedDir)) {
        return(fFalse);
    }

    while (!FAddSymbolValueToSymTab("STF_SRCTYPE", szDriveType)) {
        if (!FHandleOOM(hWndShell)) {
            return(fFalse);
        }
    }

    while (!FAddSymbolValueToSymTab("STF_SRCDIR", szProcessedDir)) {
        if (!FHandleOOM(hWndShell)) {
            return(fFalse);
        }
    }


    //
    // Process DEST DIR
    //

    if (szDestDir != NULL) {
        if (!FProcessForDriveType(szDestDir, szDriveType, szCWD, szProcessedDir)) {
            return(fFalse);
        }

        while (!FAddSymbolValueToSymTab("STF_DSTTYPE", szDriveType)) {
            if (!FHandleOOM(hWndShell)) {
                return(fFalse);
            }
        }

        while (!FAddSymbolValueToSymTab("STF_DSTDIR", szProcessedDir)) {
            if (!FHandleOOM(hWndShell)) {
                return(fFalse);
            }
        }
    }
    else {
        while (!FAddSymbolValueToSymTab("STF_DSTTYPE", "NONE")) {
            if (!FHandleOOM(hWndShell)) {
                return(fFalse);
            }
        }
    }

    //
    // Process INF SRC PATH
    //

    while (!FAddSymbolValueToSymTab("STF_SRCINFPATH", szInfSrcPath))
                if (!FHandleOOM(hWndShell))
                        return(fFalse);

    while (!FAddSymbolValueToSymTab("STF_CONTEXTINFNAME", szInfSrcPath))
                if (!FHandleOOM(hWndShell))
                        return(fFalse);

    //
    // Get the SETUP working directory
    //

        while (!FAddSymbolValueToSymTab("STF_CWDDIR", szCWD))
                if (!FHandleOOM(hWndShell))
                        return(fFalse);

        while (!FAddSymbolValueToSymTab("STF_SYS_INIT", "NO"))
                if (!FHandleOOM(hWndShell))
                        return(fFalse);

{
    char NumTmp[9];
    HWND hw ;

    hw = hwParam
       ? FindProperParent()
       : hWndShell ;

    wsprintf(NumTmp,"%lx",hw);

    while (!FAddSymbolValueToSymTab("STF_HWND", NumTmp))
    {
        if (!FHandleOOM(hWndShell)) {
            return(fFalse);
        }
    }
}

{
    //
    //  Registry constants
    //
    char            NumTmp[20];
    PINITSYMHANDLE  pSymHandle;
    PINITSYMNUMBER  pSymNumber;


    //
    //  Handles
    //
    pSymHandle = InitSymHandle;
    while ( pSymHandle->szName ) {

        wsprintf(NumTmp,"|%ld", pSymHandle->Handle );
        while (!FAddSymbolValueToSymTab(pSymHandle->szName, NumTmp)) {
            if (!FHandleOOM(hWndShell)) {
                return(fFalse);
            }
        }

        pSymHandle++;
    }

    //
    //  Numeric values
    //
    pSymNumber = InitSymNumber;
    while ( pSymNumber->szName ) {

        wsprintf(NumTmp,"%ld", pSymNumber->dwNumber );
        while (!FAddSymbolValueToSymTab(pSymNumber->szName, NumTmp)) {
            if (!FHandleOOM(hWndShell)) {
                return(fFalse);
            }
        }

        pSymNumber++;
    }
}

    if (wModeSetup == wModeSetupNormal) {
        szInstallType = "NORMAL";
    }
#if 0
    else if (wModeSetup == wModeSetupToShare) {
        szInstallType = "SETUPTOSHARE";
    }
#endif
    else if (wModeSetup == wModeGuiInitialSetup) {
        szInstallType = "SETUPBOOTED";
    }
    else {
        AssertRet(fFalse, fFalse);
    }

    while (!FAddSymbolValueToSymTab("STF_INSTALL_TYPE", szInstallType)) {
        if (!FHandleOOM(hWndShell)) {
            return(fFalse);
        }
    }


#if DBG
        fCheckInfValidity = fTrue;
#endif /* DBG */
    while ((grc = GrcOpenInf(szInfSrcPath, pGlobalContext()->pInfTempInfo)) != grcOkay)
                if (EercErrorHandler(hWndShell, grc, fTrue, szInfSrcPath, 0, 0)
                                != eercRetry)
                        return(fFalse);

        while ((grc = GrcFillSrcDescrListFromInf()) != grcOkay)
                if (EercErrorHandler(hWndShell, grc, fTrue, szInfSrcPath, 0, 0)
                                != eercRetry)
                        return(fFalse);

    if ((Line = FindFirstLineFromInfSection(pLocalContext()->szShlScriptSection)) == -1)
                {
                LoadString(hInstance, IDS_ERROR, rgchBufTmpShort, cchpBufTmpShortMax);
                LoadString(hInstance, IDS_CANT_FIND_SHL_SECT, rgchBufTmpLong,
                                cchpBufTmpLongMax);
                MessageBox(hWndShell, rgchBufTmpLong, rgchBufTmpShort,
                                MB_OK | MB_ICONHAND);
                return(fFalse);
                }

        if ((psptShellScript = PsptInitParsingTable(rgscp)) == (PSPT)NULL ||
                        !FInitFlowPspt())
                {
                Assert(fFalse);
                return(fFalse);
                }

    PostMessage(hWndShell, STF_SHL_INTERP, Line+1, 0L);

    return(fTrue);
}


/*
*  FMakeWindows -- create Windows used by Setup
*/
BOOL
FMakeWindows(
    IN HANDLE hInstance
    )

{
    int xSize = GetSystemMetrics(SM_CXSCREEN),
        ySize = GetSystemMetrics(SM_CYSCREEN) ;

    DWORD dwStyle = WS_POPUP | WS_CLIPCHILDREN ;

    if ( ! fFullScreen )
    {
        xSize = 2 ;
        ySize = 2 ;
        dwStyle = WS_POPUP ;
    }

    if ( hwParam )
    {
        DWORD dwThreadId = GetCurrentThreadId() ;
        DWORD dwParentThreadId = GetWindowThreadProcessId( hwParam,
                                                           NULL ) ;

        AttachThreadInput( dwThreadId,
                           dwParentThreadId,
                           TRUE ) ;
    }

    //
    // Create the main setup window
    //

    hWndShell = CreateWindowEx(
                    fFullScreen ? 0 : WS_EX_TRANSPARENT,
                    "Stuff-Shell",
                    "Setup",
                    dwStyle,
                    0,
                    0,
                    xSize,
                    ySize,
                    hwParam,
                    NULL,
                    hInstance,
                    NULL
                    );

    //
    // return status of operation
    //

    if ( hWndShell == (HWND)NULL ) {

        return( fFalse );

    }

    return( fTrue );
}

BOOL
FProcessForDriveType(
    SZ szDir,
    SZ szDriveType,
    SZ szCWD,
    SZ szProcessedDir
    )
{
    ChkArg(szDir          != (SZ)NULL, 1, fFalse);
    ChkArg(szDriveType    != (SZ)NULL, 2, fFalse);
    ChkArg(szProcessedDir != (SZ)NULL, 3, fFalse);

    //
    // Only drive types are DOS and UNC.
    //
    if(ISUNC(szDir)) {

        lstrcpy(szDriveType,szUncType);
        lstrcpy(szProcessedDir,szDir);

    } else {

        lstrcpy(szDriveType,szDosType);

        //
        // Handle drive-relative paths.
        //
        if(*szDir == '\\') {

            //
            // root relative szDir, get current drive and slap it in
            //
            *szProcessedDir = (UCHAR)_getdrive() + (UCHAR)'A' - (UCHAR)1;
            *(szProcessedDir + 1) = ':';
            *(szProcessedDir + 2) = '\0';

        } else {
            if(*(szDir + 1) == ':') {

                //
                // Drive relative path (we don't need to do anything)
                //
                *szProcessedDir = '\0';

            } else {

                //
                // No root specified, so we assume the directory is relative to
                // szCWD
                //
                lstrcpy(szProcessedDir,szCWD);
            }
        }

        lstrcat(szProcessedDir,szDir);
    }

    //
    // The szProcessedDir should be terminated by a '\\'
    //
    if (*(szProcessedDir + lstrlen(szProcessedDir) - 1) != '\\') {
        lstrcat(szProcessedDir,"\\");
    }

    return(fTrue);
}



BOOL
FProcessInfSrcPath(
    SZ szInf,
    SZ szCWD,
    SZ szProcessedDir
    )
{
    #define INF_ABSOLUTE 0
    #define INF_RELATIVE 1

    INT PathType = INF_RELATIVE;
    PFH pfh      = (PFH)NULL;

    //
    // Check to see if the inf path specified is a relative path or
    // an absolute path
    //

    if ( lstrlen( szInf ) >= 2 ) {

        //
        // See if the INF has a drive relative src path spec
        //

        if (ISUNC( szInf ) ) {
            lstrcpy(szProcessedDir, szInf);
            PathType = INF_ABSOLUTE;
        }
        else if (*szInf == '\\') {

            //
            // root relative szInf
            //

            *szProcessedDir = (UCHAR)_getdrive() + (UCHAR)'A' - (UCHAR)1;
            *(szProcessedDir + 1) = ':';
            *(szProcessedDir + 2) = '\0';
            lstrcat(szProcessedDir, szInf);
            PathType = INF_ABSOLUTE;

        }
        else if (*(szInf + 1) == ':') {

            //
            // drive relative path (we don't need to do anything)
            //

            lstrcpy(szProcessedDir, szInf);
            PathType = INF_ABSOLUTE;
        }

    }

    //
    // If it is an absolute path try opening the INF as is
    //

    if ( PathType == INF_ABSOLUTE ) {
        if (( pfh = PfhOpenFile(szProcessedDir, ofmRead)) != (PFH)NULL ) {
            EvalAssert(FCloseFile(pfh));
            return( TRUE );
        }
        else {
            return( FALSE );
        }
    }

    //
    // Path is a relative path, try first combining the szCWD and the inf.
    //

    lstrcpy( szProcessedDir, szCWD );
    lstrcat( szProcessedDir, szInf );
    if (( pfh = PfhOpenFile(szProcessedDir, ofmRead)) != (PFH)NULL ) {
        EvalAssert(FCloseFile(pfh));
        return( TRUE );
    }

    //
    // Then try combining the windows system directory and the INF
    //

    EvalAssert( GetSystemDirectory( szProcessedDir, MAX_PATH ) <= MAX_PATH );
    lstrcat( szProcessedDir, "\\"  );
    lstrcat( szProcessedDir, szInf );
    if (( pfh = PfhOpenFile(szProcessedDir, ofmRead)) != (PFH)NULL ) {
        EvalAssert(FCloseFile(pfh));
        return( TRUE );
    }

    //
    // Inf not found
    //

    return( FALSE );

}


HWND FindProperParent ( void )
{
   RECT rect ;
   HWND hwMaster, hwParent ;
   POINT ptMax ;

   hwParent = hwMaster = GetDesktopWindow() ;

   //  If we have a main window that is not the blue screen,
   //  make sure that we have a valid parent that is visible.

   if ( hwParam )
   {
       BOOL bOk = FALSE ;

       ptMax.x = GetSystemMetrics( SM_CXFULLSCREEN ) ;
       ptMax.y = GetSystemMetrics( SM_CYFULLSCREEN ) ;

       hwMaster = hwParam ;

       do
       {
           if (    IsWindow( hwMaster )
                && GetWindowRect( hwMaster, & rect ) )
           {
               bOk =  rect.left >= 0
                   && rect.left <  ptMax.x
                   && rect.top  >= 0
                   && rect.top  <  ptMax.y ;
           }

           if ( ! bOk )
           {
              hwMaster = GetParent( hwMaster ) ;
           }
       } while ( ! bOk && hwMaster != NULL ) ;

       if ( bOk )
           hwParent = hwMaster ;
   }

   return hwPseudoParent = hwParent ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\listproc.c ===
#include "precomp.h"
#pragma hdrstop
/***************************************************************************/
/****************** Basic Class Dialog Handlers ****************************/
/***************************************************************************/


/*
**  Purpose:
**      Single Choice Listbox Dialog procedure for templates with exactly one
**      listbox control.
**  Control IDs:
**      The Listbox control must have the id IDC_LIST1.  Pushbuttons
**      recognized are IDC_O, IDC_C, IDC_M, IDC_H, IDC_X, and IDC_B.
**  Initialization:
**      The symbol $(ListItemsIn) is a list of strings to insert into the
**      listbox.  The symbol $(ListItemOut) is a simple string which if it
**      matches a string in $(ListItemsIn) it sets that item as selected, or
**      else no item is selected.
**  Termination:
**      The selected item (if any) is stored in the symbol $(ListItemsOut).
**      The id of the Pushbutton (eg IDC_C) which caused termination is
**      converted to a string and stored in the symbol $(ButtonPressed).
**
*****************************************************************************/
INT_PTR APIENTRY FGstListDlgProc(HWND   hdlg,
                                 UINT   wMsg,
                                 WPARAM wParam,
                                 LPARAM lParam)
{
    CHP  rgchNum[10];
    SZ   szBuffer;
    SZ   szList;
    SZ   szTabs;
    SZ   sz;
    RGSZ rgsz;
    PSZ  psz;
    ULONG_PTR iItem;
    CB   cb;

    Unused(lParam);

    switch (wMsg) {

    case STF_REINITDIALOG:
        if ((sz = SzFindSymbolValueInSymTab("ReInit")) == (SZ)NULL ||
            (CrcStringCompareI(sz, "YES") != crcEqual)) {

            return(fTrue);
        }

    case WM_INITDIALOG:
        AssertDataSeg();
        if( wMsg == WM_INITDIALOG ) {
            FCenterDialogOnDesktop(hdlg);
        }

        //
        // Initialize the list box
        //

    SendDlgItemMessage(hdlg, IDC_LIST1, LB_RESETCONTENT, 0, 0L);

        //
        // See if tab stops have been specified for this list box
        //

        if ((szTabs = SzFindSymbolValueInSymTab("ListTabStops")) != (SZ)NULL) {
            RGSZ  rgsz;
            DWORD dwTabs[10];
            INT   nTabs = 0;
            INT   i;

            while ((rgsz = RgszFromSzListValue(szTabs)) == (RGSZ)NULL) {
                if (!FHandleOOM(hdlg)) {
                    DestroyWindow(GetParent(hdlg));
                    return(fTrue);
                }
            }

            for (i = 0; (i < 10) && (rgsz[i] != (SZ)NULL); i++) {
                dwTabs[nTabs++] = atoi(rgsz[i]);
            }

            if (nTabs) {
                SendDlgItemMessage(hdlg, IDC_LIST1, LB_SETTABSTOPS, (WPARAM)nTabs, (LPARAM)dwTabs);
            }

            EvalAssert (FFreeRgsz (rgsz));
        }


        //
        // Process the list box items
        //

        if ((szList = SzFindSymbolValueInSymTab("ListItemsIn")) == (SZ)NULL)
            {
            Assert(fFalse);
            return(fTrue);
            }

        while ((psz = rgsz = RgszFromSzListValue(szList)) == (RGSZ)NULL)
            if (!FHandleOOM(hdlg))
                {
                DestroyWindow(GetParent(hdlg));
                return(fTrue);
                }

        while (*psz != (SZ)NULL)
            SendDlgItemMessage(hdlg, IDC_LIST1, LB_ADDSTRING,0,(LPARAM)*psz++);

        iItem = 0;
        if ((szList = SzFindSymbolValueInSymTab("ListItemsOut")) == (SZ)NULL ||
                CrcStringCompareI(szList, "") == crcEqual)
            SendDlgItemMessage(hdlg, IDC_LIST1, LB_SETCURSEL, (WPARAM)-1, 0L);
        else {
            CHP  szItemCur[256];
            INT  i, nCount;

            nCount = (INT)SendDlgItemMessage(hdlg, IDC_LIST1, LB_GETCOUNT, 0,
                    0L);

            for (i = 0; i < nCount; i++) {
                if ( (SendDlgItemMessage(
                         hdlg,
                         IDC_LIST1,
                         LB_GETTEXT,
                         (WPARAM)i,
                         (LPARAM)szItemCur
                         ) != LB_ERR)
                     && (CrcStringCompareI(szItemCur, szList) == crcEqual)
                   ) {

                    iItem = i;
                    SendDlgItemMessage(hdlg, IDC_LIST1, LB_SETCURSEL, i, 0L);
                    break;

                }
            }
        }

        EvalAssert(FFreeRgsz(rgsz));

        /* REVIEW KLUDGE no way to find out how many lines in the listbox? */
        if (iItem < 4)
            iItem = 0;
        SendDlgItemMessage(hdlg, IDC_LIST1, LB_SETTOPINDEX, iItem, 0L);


        while (!FAddSymbolValueToSymTab("ListDblClick", "FALSE")) {
            if (!FHandleOOM(hdlg)) {
                DestroyWindow(GetParent(hdlg));
                return(fTrue);
            }
        }

        return(fTrue);

    case WM_CLOSE:
        PostMessage(
            hdlg,
            WM_COMMAND,
            MAKELONG(IDC_X, BN_CLICKED),
            0L
            );
        return(fTrue);

    case WM_COMMAND:
        switch(LOWORD(wParam))
            {
        case IDC_LIST1:
            if (HIWORD(wParam) != LBN_DBLCLK) {
                break;
            }

            while (!FAddSymbolValueToSymTab("ListDblClick", "TRUE")) {
                if (!FHandleOOM(hdlg)) {
                    DestroyWindow(GetParent(hdlg));
                    return(fTrue);
                }
            }

            wParam = IDC_C;
            /* Fall through */

        case IDCANCEL:
            if(LOWORD(wParam) == IDCANCEL) {
                if (!GetDlgItem(hdlg, IDC_B) || HIWORD(GetKeyState(VK_CONTROL)) || HIWORD(GetKeyState(VK_SHIFT)) || HIWORD(GetKeyState(VK_MENU)))
                {
                    break;
                }
                wParam = IDC_B;
            }

        case IDC_O:
        case IDC_C:
        case IDC_M:
        case IDC_B:
        case IDC_X:
        case IDC_BTN0:
        case IDC_BTN1: case IDC_BTN2: case IDC_BTN3:
        case IDC_BTN4: case IDC_BTN5: case IDC_BTN6:
        case IDC_BTN7: case IDC_BTN8: case IDC_BTN9:
            _itoa((INT)wParam, rgchNum, 10);
            while (!FAddSymbolValueToSymTab("ButtonPressed", rgchNum))
                if (!FHandleOOM(hdlg))
                    {
                    DestroyWindow(GetParent(hdlg));
                    return(fTrue);
                    }

            if ((iItem = SendDlgItemMessage(hdlg, IDC_LIST1, LB_GETCURSEL,
                        0, 0L)) == LB_ERR ||
                    (cb = (CB)SendDlgItemMessage(hdlg, IDC_LIST1, LB_GETTEXTLEN,
                        iItem, 0)) == LB_ERR)
                {
                while ((szBuffer = SzDupl("")) == (SZ)NULL)
                    if (!FHandleOOM(hdlg))
                        {
                        DestroyWindow(GetParent(hdlg));
                        return(fTrue);
                        }
                }
            else
                {
                while ((szBuffer = (SZ)SAlloc(cb + 1)) == (SZ)NULL)
                    if (!FHandleOOM(hdlg))
                        {
                        DestroyWindow(GetParent(hdlg));
                        return(fTrue);
                        }
                SendDlgItemMessage(hdlg, IDC_LIST1, LB_GETTEXT, iItem, (LPARAM)szBuffer);
                }
            while (!FAddSymbolValueToSymTab("ListItemsOut", (SZ)szBuffer))
                if (!FHandleOOM(hdlg))
                    {
                    DestroyWindow(GetParent(hdlg));
                    return(fTrue);
                    }

            SFree(szBuffer);
            PostMessage(GetParent(hdlg), (WORD)STF_UI_EVENT, 0, 0L);
            break;
            }
        break;

    case STF_DESTROY_DLG:
        PostMessage(GetParent(hdlg), (WORD)STF_LIST_DLG_DESTROYED, 0, 0L);
        DestroyWindow(hdlg);
        return(fTrue);
        }

    return(fFalse);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\interp.c ===
#include "precomp.h"
#pragma hdrstop
/**************************************************************************/
/***** Shell Component - Script Interpreting routine **********************/
/**************************************************************************/


#define NEWINF

extern BOOL FAddSymSectionToUpdateList(SZ);
extern BOOL FUpdateAllReadSymSections(VOID);
extern BOOL FFreeSymSectionsUpdateList(VOID);
extern BOOL FUIEntryPoint(HANDLE, HWND, RGSZ, USHORT);


int     SymTabDumpCount     = 0;

BOOL FShellCommand( RGSZ rgszArg );
BOOL FShellReturn( RGSZ rgszArg );

/*
**  Symbol Section Update List Element structure
*/
typedef struct _ssule
    {
    SZ              szSection;
    struct _ssule * pssuleNext;
    } SSULE;
typedef SSULE * PSSULE;


/*
**  Global Variable for head of list for Symbol Sections to update
*/
PSSULE pssuleSymSectionUpdateList = (PSSULE)NULL;


/*
**  Purpose:
**      ??
**  Arguments:
**      none
**  Returns:
**      none
**
*************************************************************************/
BOOL FAddSymSectionToUpdateList(szSection)
SZ szSection;
{
    PSSULE pssule;

    while ((pssule = (PSSULE)SAlloc((CB)sizeof(SSULE))) == (PSSULE)NULL)
        if (!FHandleOOM(hWndShell))
            return(fFalse);

    while ((pssule->szSection = SzDupl(szSection)) == (SZ)NULL)
        if (!FHandleOOM(hWndShell))
            return(fFalse);

    pssule->pssuleNext = pssuleSymSectionUpdateList;
    pssuleSymSectionUpdateList = pssule;

    return(fTrue);
}


/*
**  Purpose:
**      ??
**  Arguments:
**      none
**  Returns:
**      none
**
*************************************************************************/
BOOL FUpdateAllReadSymSections(VOID)
{
#ifndef NEWINF
    PSSULE pssule = pssuleSymSectionUpdateList;

    while (pssule != (PSSULE)NULL)
        {
        if (!FUpdateInfSectionUsingSymTab(pssule->szSection))
            return(fFalse);
        pssule = pssule->pssuleNext;
        }
#endif
    return(fTrue);
}


/*
**  Purpose:
**      ??
**  Arguments:
**      none
**  Returns:
**      none
**
*************************************************************************/
BOOL FFreeSymSectionsUpdateList(VOID)
{
    PSSULE pssule;

    while ((pssule = pssuleSymSectionUpdateList) != (PSSULE)NULL)
        {
        pssuleSymSectionUpdateList = pssule->pssuleNext;
        SFree(pssule->szSection);
        SFree(pssule);
        }

    return(fTrue);
}


/*
**  Purpose:
**      Reads and Interprets the current line in the INF file.
**  Arguments:
**      wParam: if not 0, line # of new current line + 1
**      lParam: cc
**  Returns:
**      fFalse
**      fTrue
**
**************************************************************************/
BOOL FInterpretNextInfLine(WPARAM wParam,LPARAM lParam)
{
    SPC  spc;
    UINT cFields;
    UINT iField;
    RGSZ rgsz = (RGSZ)NULL;
    PFH  pfh;
    GRC  grc;
    CHAR    FileName[MAX_PATH];

    Unused(lParam);

    PreCondition(psptShellScript != (PSPT)NULL, fFalse);
    PreCondition(pLocalContext()->szShlScriptSection != (SZ)NULL &&
            *(pLocalContext()->szShlScriptSection) != '\0' &&
            *(pLocalContext()->szShlScriptSection) != '[', fFalse);

    if(wParam) {
        pLocalContext()->CurrentLine = (INT)(wParam - 1);
    }
#if 0
    sprintf(FileName,"C:\\SYMTAB.%03d",SymTabDumpCount);
    OutputDebugString("SETUPDLL: ");
    OutputDebugString( FileName );
    OutputDebugString( "\n" );
    SymTabDumpCount++;
    DumpSymbolTableToFile(FileName);
#endif
    if (!FHandleFlowStatements(&(pLocalContext()->CurrentLine), hWndShell, pLocalContext()->szShlScriptSection, &cFields , &rgsz))
        return(fFalse);

    Assert(cFields);
    Assert(rgsz);

    switch ((spc = SpcParseString(psptShellScript, rgsz[0])))
        {
    case spcUI:
        SdAtNewLine(pLocalContext()->CurrentLine);

        if (!FUIEntryPoint(hInst, hWndShell, rgsz + 1, (USHORT)(cFields - 1)))
            goto LParseExitErr;
        break;

    case spcDetect:
        SdAtNewLine(pLocalContext()->CurrentLine);
        if (!FDetectEntryPoint(hInst, hWndShell, rgsz + 1,
                (USHORT)(cFields - 1)))
            goto LParseExitErr;
        break;

    case spcInstall:
        SdAtNewLine(pLocalContext()->CurrentLine);
        if (!FInstallEntryPoint(hInst, hWndShell, rgsz + 1,
                (USHORT)(cFields - 1)))
            goto LParseExitErr;
        break;

    case spcExit:
        SdAtNewLine(pLocalContext()->CurrentLine);
        if (cFields != 1)
            goto LScriptError;
        EvalAssert(FFreeRgsz(rgsz));
                FDestroyShellWindow() ;
        return(fTrue);

    case spcReadSyms:
        SdAtNewLine(pLocalContext()->CurrentLine);
        if (cFields == 1)
            goto LScriptError;
    case spcUpdateInf:
        if(spc == spcUpdateInf) {
            SdAtNewLine(pLocalContext()->CurrentLine);
        }
#ifdef NEWINF
        if(spc == spcUpdateInf) {
            MessBoxSzSz("","Update-Inf encountered, no action taken");
            break;
        }
#endif
        if (spc == spcUpdateInf &&
                 cFields > 1)
            EvalAssert(FFreeSymSectionsUpdateList());

        for (iField = 1; iField < cFields; iField++)
            {
            RGSZ rgszCur;
            PSZ  psz;

            while ((rgszCur = RgszFromSzListValue(rgsz[iField])) == (RGSZ)NULL)
                if (!FHandleOOM(hWndShell))
                    goto LParseExitErr;

            psz = rgszCur;
            while (*psz != (SZ)NULL)
                {
                if (**psz == '\0' || FWhiteSpaceChp(**psz))
                    {
                    EvalAssert(FFreeRgsz(rgszCur));
                    goto LScriptError;
                    }
                if (FindInfSectionLine(*psz) == -1)
                    {
                    LoadString(hInst, IDS_ERROR, rgchBufTmpShort,
                            cchpBufTmpShortMax);
                    LoadString(hInst, IDS_INF_SECT_REF, rgchBufTmpLong,
                            cchpBufTmpLongMax);
                    EvalAssert(SzStrCat(rgchBufTmpLong,*psz) == rgchBufTmpLong);
                    MessageBox(hWndShell, rgchBufTmpLong, rgchBufTmpShort,
                            MB_OK | MB_ICONHAND);

                    EvalAssert(FFreeRgsz(rgszCur));
                    goto LParseExitErr;
                    }

                while (spc == spcReadSyms &&
                        (grc = GrcAddSymsFromInfSection(*psz)) != grcOkay)
                    {
                    if (EercErrorHandler(hWndShell, grc, fTrue, 0, 0, 0) !=
                            eercRetry)
                        {
                        EvalAssert(FFreeRgsz(rgszCur));
                        goto LParseExitErr;
                        }
                    }

                if (!FAddSymSectionToUpdateList(*psz))
                    {
                    EvalAssert(FFreeRgsz(rgszCur));
                    goto LParseExitErr;
                    }

                psz++;
                }

            EvalAssert(FFreeRgsz(rgszCur));
            }

        if (spc == spcReadSyms)
            break;
#ifndef NEWINF
        if (!FUpdateAllReadSymSections())
            {
            LoadString(hInst, IDS_ERROR, rgchBufTmpShort, cchpBufTmpShortMax);
            LoadString(hInst, IDS_UPDATE_INF, rgchBufTmpLong,
                    cchpBufTmpLongMax);
            MessageBox(hWndShell, rgchBufTmpLong, rgchBufTmpShort,
                    MB_OK | MB_ICONHAND);
            goto LParseExitErr;
            }

        EvalAssert(FFreeSymSectionsUpdateList());
#endif
        break;

    case spcWriteInf:
        SdAtNewLine(pLocalContext()->CurrentLine);
        if (cFields != 2 ||
                *(rgsz[1]) == '\0')
            goto LScriptError;
#ifndef NEWINF
        while (!FWriteInfFile(rgsz[1]))
            if (EercErrorHandler(hWndShell, grcWriteInf, fTrue, rgsz[1], 0, 0)
                    != eercRetry)
                goto LParseExitErr;
#else
        MessBoxSzSz("","WriteInf encountered, no action taken");
#endif
        break;

    case spcWriteSymTab:
        SdAtNewLine(pLocalContext()->CurrentLine);
        if((cFields != 2) || (*rgsz[1] == '\0')) {
            goto LScriptError;
        }
        retry_dump:
        if(!DumpSymbolTableToFile(rgsz[1])) {

            EERC eerc;

            if((eerc = EercErrorHandler(hWndShell,grcWriteFileErr,fFalse,rgsz[1],0,0)) == eercAbort) {
                goto LParseExitErr;
            } else if (eerc == eercRetry) {
                goto retry_dump;
            }
        }
        break;

    case spcSetTitle:
        SdAtNewLine(pLocalContext()->CurrentLine);
        if (cFields == 1)
            SetWindowText(hWndShell, "");
        else if (cFields == 2)
            SetWindowText(hWndShell, (LPSTR)(rgsz[1]));
        else
            goto LScriptError;
        break;

    case spcEnableExit:
        SdAtNewLine(pLocalContext()->CurrentLine);
//        EnableExit(fTrue);
        break;

    case spcDisableExit:
        SdAtNewLine(pLocalContext()->CurrentLine);
//        EnableExit(fFalse);
        break;

    case spcExitAndExec:
        SdAtNewLine(pLocalContext()->CurrentLine);
        if (cFields != 2)
            goto LScriptError;

        /* BLOCK */
            {
            SZ      sz = rgsz[1];

            /* Set Working Directory for DLL loads */
            if (*sz != '\0' && *(sz + 1) == ':')
                {
                AnsiUpperBuff(sz, 1);
                if (!_chdrive(*sz - 'A' + 1))
                    {
                    SZ szLastSlash = NULL;

                    sz += 2;
                    while (*sz != '\0' && !FWhiteSpaceChp(*sz))
                        {
                        if (*sz == '\\')
                            szLastSlash = sz;
                        sz++;
                        }

                    if (szLastSlash != NULL)
                        {
                        *szLastSlash = '\0';
                        sz = rgsz[1] + 2;
                        if (*sz != '\0')
                            {
                            AnsiUpper(sz);
                            _chdir(sz);
                            }
                        *szLastSlash = '\\';
                        }
                    }
                }

            WinExec(rgsz[1], SW_SHOWNORMAL);
            /* REVIEW error handling */
            }

        EvalAssert(FFreeRgsz(rgsz));
                FDestroyShellWindow() ;
        return(fTrue);

    case spcShell:

        SdAtNewLine(pLocalContext()->CurrentLine);
        if (cFields < 3) {
            goto LScriptError;
        }

        return FShellCommand( &rgsz[1] );

    case spcReturn:
        SdAtNewLine(pLocalContext()->CurrentLine);
        return FShellReturn( &rgsz[1] );

    default:
        SdAtNewLine(pLocalContext()->CurrentLine);
        goto LScriptError;
        }

    EvalAssert(FFreeRgsz(rgsz));

    if ((pLocalContext()->CurrentLine = FindNextLineFromInf(pLocalContext()->CurrentLine)) == -1)
        {
        LoadString(hInst, IDS_ERROR, rgchBufTmpShort, cchpBufTmpShortMax);
        LoadString(hInst, IDS_NEED_EXIT, rgchBufTmpLong, cchpBufTmpLongMax);
        MessageBox(hWndShell, rgchBufTmpLong, rgchBufTmpShort,
                MB_OK | MB_ICONHAND);
        return(fFalse);
        }

    if (spc != spcUI)
        PostMessage(hWndShell, (WORD)STF_SHL_INTERP, 0, 0L);

    return(fTrue);

LScriptError:
    LoadString(hInst, IDS_ERROR, rgchBufTmpShort, cchpBufTmpShortMax);
    /* BLOCK */
        {
        USHORT iszCur = 0;
        SZ     szCur;

        LoadString(hInst, IDS_SHL_CMD_ERROR, rgchBufTmpLong, cchpBufTmpLongMax);
        Assert(rgsz != (RGSZ)NULL);
        EvalAssert((szCur = *rgsz) != (SZ)NULL);
        while (szCur != (SZ)NULL)
            {
            if (iszCur == 0)
                EvalAssert(SzStrCat(rgchBufTmpLong, "\n'") == rgchBufTmpLong);
            else
                EvalAssert(SzStrCat(rgchBufTmpLong, " ") == rgchBufTmpLong);

            if (strlen(rgchBufTmpLong) + strlen(szCur) >
                    (cchpBufTmpLongMax - 7))
                {
                Assert(strlen(rgchBufTmpLong) <= (cchpBufTmpLongMax - 5));
                EvalAssert(SzStrCat(rgchBufTmpLong, "...") == rgchBufTmpLong);
                break;
                }
            else
                EvalAssert(SzStrCat(rgchBufTmpLong, szCur) == rgchBufTmpLong);

            szCur = rgsz[++iszCur];
            }

        EvalAssert(SzStrCat(rgchBufTmpLong, "'") == rgchBufTmpLong);
        }

    MessageBox(hWndShell, rgchBufTmpLong, rgchBufTmpShort, MB_OK | MB_ICONHAND);

LParseExitErr:
    if (rgsz != (RGSZ)NULL)
        EvalAssert(FFreeRgsz(rgsz));
    return(fFalse);
}


/*
**  Purpose:
**      ??
**  Arguments:
**      none
**  Returns:
**      none
**
*************************************************************************/
BOOL FUIEntryPoint(HANDLE hInst, HWND hWnd, RGSZ rgsz,
        USHORT cItems)
{
    BOOL fRetVal;

    ChkArg(hInst != (HANDLE)NULL, 1, fFalse);
    ChkArg(hWnd != (HWND)NULL, 2, fFalse);
    ChkArg(cItems >= 2, 4, fFalse);
    ChkArg(rgsz != (RGSZ)NULL &&
            *rgsz != (SZ)NULL &&
            *(rgsz + 1) != (SZ)NULL, 3, fFalse);

    if (CrcStringCompareI(*rgsz, "START") == crcEqual) {

        HANDLE hInstRes = hInst;

        //
        // See whether there is a library handle specified
        //
        if(rgsz[2] && rgsz[2][0]) {
            if(rgsz[2][0] != '|') {
                goto err;
            }
            hInstRes = LongToPtr(atol(rgsz[2] + 1));
        }

        fRetVal = FDoDialog(*(rgsz + 1), hInstRes, hWnd);
        UpdateWindow(hWnd);
        return(fRetVal);

    } else if (CrcStringCompareI(*rgsz, "POP") == crcEqual) {

        fRetVal = FKillNDialogs((USHORT)atoi(*(rgsz + 1)), fFalse);
        UpdateWindow(hWnd);
        if (fRetVal) {
            PostMessage(hWndShell, (WORD)STF_SHL_INTERP, 0, 0L);
        }
        return(fRetVal);

    }

    err:

    LoadString(hInst, IDS_ERROR, rgchBufTmpShort, cchpBufTmpShortMax);
    LoadString(hInst, IDS_UI_CMD_ERROR, rgchBufTmpLong, cchpBufTmpLongMax);
    MessageBox(hWndShell, rgchBufTmpLong, rgchBufTmpShort,
            MB_OK | MB_ICONHAND);
    UpdateWindow(hWnd);
    return(fFalse);
}



/*
**  Purpose:
**      Pushes a new context onto the context stack and executes the
**      specified shell section of an INF file.
**
**  Arguments:
**
**  Returns:
**
**
*************************************************************************/
BOOL FShellCommand( RGSZ    rgszArg )
{
    SZ              szInfFileOrg;
    SZ              szInfFile;
    SZ              szSection;
    PINFCONTEXT     pNewContext;
    PINFTEMPINFO    pTempInfo;
    PINFPERMINFO    pPermInfo;
    GRC             grc             = grcOkay;
    CHAR            szName[cchlFullPathMax];
    CHAR            szFullName[cchlFullPathMax];
    BOOL            fCreated        = fFalse;
    INT             Line;
    INT             cArg            = 0;
    BOOL            fOkay           = fTrue;
    SZ              szNamePart;
    SZ              p;

    pLocalContext()->CurrentLine++;

    //
    //  Guarantee that $ShellCode is set correctly to !SHELL_CODE_OK.
    //
    while (!FAddSymbolValueToSymTab( "$ShellCode",
                                      SzFindSymbolValueInSymTab("!G:SHELL_CODE_OK") )) {
        if (!FHandleOOM(hWndShell)) {
            return(fFalse);
        }
    }

    //
    //  Allocate a new context
    //
    while ( !(pNewContext = (PINFCONTEXT)SAlloc( (CB)sizeof(INFCONTEXT) )) ) {
        if (!FHandleOOM(hWndShell)) {
            return(fFalse);
        }
    }

    if ( **rgszArg == '\0' ) {

        //
        //  Null INF file, use the one being used by the current context.
        //
        pTempInfo    =  pLocalInfTempInfo();
        pPermInfo    =  pLocalInfPermInfo();
        szInfFileOrg =  SzFindSymbolValueInSymTab("STF_CONTEXTINFNAME");
        szInfFile    =  szInfFileOrg;

    } else {

        //
        //  Determine if the desired INF file is already loaded.
        //
        szInfFileOrg = *rgszArg;

        PathToInfName( szInfFileOrg, szName );
        GetFullPathName( szInfFileOrg, cchlFullPathMax, szFullName, &szNamePart );
        szInfFile = szFullName;

        pPermInfo = NameToInfPermInfo( szName , fTrue );

        if ( pPermInfo ) {

            pTempInfo = pInfTempInfo( pGlobalContext() );

            while ( pTempInfo ) {

                if ( pTempInfo->pInfPermInfo == pPermInfo ) {
                    break;
                }

                pTempInfo = pTempInfo->pNext;
            }

        }  else {

            pTempInfo = NULL;
        }
    }


    rgszArg++;
    szSection = *rgszArg++;


    if ( pTempInfo ) {

        //
        //  Reuse existing INF temp info. We just increment its reference count.
        //
        pNewContext->pInfTempInfo = pTempInfo;
        pTempInfo->cRef++;

    } else {

        //
        //  We have to create a new INF temp info block for the INF.
        //
        fCreated = fTrue;

        while ( !(pNewContext->pInfTempInfo = (PINFTEMPINFO)CreateInfTempInfo( pPermInfo )) ) {
            if (!FHandleOOM(hWndShell)) {
                SFree(pNewContext);
                return(fFalse);
            }
        }

        //
        //  Parse the INF file if we don't already have it parsed.
        //
        if ( pNewContext->pInfTempInfo->pParsedInf->MasterLineArray == NULL ) {

            while ((grc = GrcOpenInf(szInfFile, pNewContext->pInfTempInfo)) != grcOkay) {

                //
                //  Could not open the INF file requested.
                //
                //  If the INF file name given does not contain a path (i.e.
                //  only the file part was given) then try to open the INF
                //  with the same name in the directory of the global INF
                //  file.  If that fails, we try to open the INF in the
                //  system directory.
                //
                szNamePart = szInfFileOrg;
                while ( p = strchr( szNamePart, '\\' ) ) {
                      szNamePart = p+1;
                }

                strcpy( szName, szNamePart );

                if ( strlen( szInfFileOrg ) == strlen( szName ) ) {

                    szInfFile = SzFindSymbolValueInSymTab("!G:STF_CONTEXTINFNAME");

                    if ( szInfFile ) {

                        strcpy( szFullName, szInfFile );

                        szInfFile   = szFullName;
                        szNamePart  = szInfFile;

                        while ( p = strchr( szNamePart, '\\' ) ) {
                            szNamePart = p+1;
                        }

                        strcpy( szNamePart, szName );

                        grc = GrcOpenInf(szInfFile, pNewContext->pInfTempInfo);
                    }

                    if ( grc != grcOkay ) {

                        //
                        //  Could not open that INF either, look for the INF in
                        //  the system directory
                        //
                        if ( GetSystemDirectory( szFullName, cchlFullPathMax ) ) {

                            if ( szFullName[ strlen(szFullName) -1 ] != '\\' ) {
                                strcat( szFullName, "\\" );
                            }

                            strcat( szFullName, szName );

                            grc = GrcOpenInf(szFullName, pNewContext->pInfTempInfo);
                        }
                    }
                }

                if ( grc != grcOkay ) {


                    FFreeInfTempInfo( pNewContext->pInfTempInfo );
                    SFree(pNewContext);

                    while (!FAddSymbolValueToSymTab( "$ShellCode",
                                                      SzFindSymbolValueInSymTab("!G:SHELL_CODE_NO_SUCH_INF") )) {
                        if (!FHandleOOM(hWndShell)) {
                            return(fFalse);
                        }
                    }

                    Line = pLocalContext()->CurrentLine;
                    goto NextLine;
                }
            }
        }
    }

    //
    //  We now have the INF Temp section in memory.
    //  Push the new context onto the stack
    //
    if ( !PushContext( pNewContext ) ) {
        FFreeInfTempInfo(pNewContext->pInfTempInfo );
        SFree(pNewContext);
        //if ( pLocalContext() == pGlobalContext() ) {
        //    return fFalse;
        //} else {
            while (!FAddSymbolValueToSymTab( "$ShellCode",
                                              SzFindSymbolValueInSymTab("!G:SHELL_CODE_ERROR") )) {
                if (!FHandleOOM(hWndShell)) {
                    return(fFalse);
                }
            }
            Line = pLocalContext()->CurrentLine;
            goto NextLine;
        //}
    }

    pLocalContext()->szShlScriptSection = SzDupl( szSection );

    //
    //  Get the media description list if there is a media description section
    //
    if ( fCreated                           &&
         !pLocalInfPermInfo()->psdleHead    &&
         FindFirstLineFromInfSection("Source Media Descriptions") != -1) {
        while ( fOkay && ((grc = GrcFillSrcDescrListFromInf()) != grcOkay)) {
            //if ( pLocalContext() == pGlobalContext() ) {
            //    if (EercErrorHandler(hWndShell, grc, fTrue, szInfFile, 0, 0)
            //            != eercRetry) {
            //            PopContext();
            //            FFreeInfTempInfo(pNewContext->pInfTempInfo );
            //            FreeContext( pNewContext );
            //            return fFalse;
            //    }
            //}

            PopContext();
            FFreeInfTempInfo(pNewContext->pInfTempInfo );
            FreeContext( pNewContext );

            while (!FAddSymbolValueToSymTab( "$ShellCode",
                                              SzFindSymbolValueInSymTab("!G:SHELL_CODE_ERROR") )) {
                if (!FHandleOOM(hWndShell)) {
                    return(fFalse);
                }
            }
            Line = pLocalContext()->CurrentLine;
            goto NextLine;

        }
    }

    while (!FAddSymbolValueToSymTab("STF_CONTEXTINFNAME", szInfFile))
        if (!FHandleOOM(hWndShell)) {
            fOkay = fFalse;
    }

    //
    //  Parameters are passed in the following symbols:
    //
    //  $# - Number of parameters
    //
    //  $0 - First parameter
    //  $1 - Second parameter
    //
    //  ... etc.
    //
    while ( fOkay && (*rgszArg != NULL) ) {
        sprintf( szName, "$%u", cArg );
        while (!FAddSymbolValueToSymTab( szName, *rgszArg)) {
            if (!FHandleOOM(hWndShell)) {
                fOkay = fFalse;
                break;
            }
        }

        cArg++;
        rgszArg++;
    }

    if ( fOkay ) {
        sprintf( szName, "%u", cArg );
        while (!FAddSymbolValueToSymTab( "$#", szName)) {
            if (!FHandleOOM(hWndShell)) {
                fOkay = fFalse;
                break;
            }
        }
    }

    if ( !fOkay ) {
        PopContext();
        FFreeInfTempInfo(pNewContext->pInfTempInfo );
        FreeContext( pNewContext );
        return fFalse;
    }


    if ((Line = FindFirstLineFromInfSection(szSection)) == -1) {

        //
        //  Pop new context off the stack
        //
        PopContext();
        FFreeInfTempInfo( pNewContext->pInfTempInfo );
        FreeContext( pNewContext );
        //if ( pLocalContext() == pGlobalContext() ) {
        //    return(fFalse);
        //} else {
            while (!FAddSymbolValueToSymTab( "$ShellCode",
                                              SzFindSymbolValueInSymTab("!G:SHELL_CODE_NO_SUCH_SECTION") )) {
                if (!FHandleOOM(hWndShell)) {
                    return(fFalse);
                }
            }
            Line = pLocalContext()->CurrentLine;
            goto NextLine;
        //}
    }

NextLine:

    //
    //  Execute the specified Section in the new context
    //
    PostMessage(hWndShell, STF_SHL_INTERP, Line+1, 0L);

    return fTrue;
}

//
// Storage for last return value
//
PSTR LastShellReturn;
DWORD LastShellReturnSize;

BOOL FShellReturn( RGSZ rgszArg )
{
    PINFCONTEXT pOldContext;
    INT         cArg        = 0;
    BOOL        fOkay       = fTrue;
    BOOL        fGlobalOkay = fTrue;
    CHAR        szName[cchlFullPathMax];
    PSTR        pwCur       = LastShellReturn;
    UINT        BufCnt      = 0;
    UINT        Temp;

    if ( pLocalContext() != pGlobalContext() ) {

        //
        //  Deallocate the INF Temp Info.
        //
        FFreeInfTempInfo( pLocalInfTempInfo() );

        //
        //  Pop Context from stack
        //
        pOldContext = PopContext();

        //
        //  Destroy poped context
        //
        FreeContext( pOldContext );

        //
        //  Results are stored in the ReturnBuffer using
        //  the format: "<$R0>\0<$R1>\0...<$Rn>\0\0"
        //
        if(LastShellReturnSize > 1 && LastShellReturn) {
            LastShellReturn[0] = '\0';
            LastShellReturn[1] = '\0';
            BufCnt = 0;
        }

        //
        //  Results are returned in the following symbols:
        //
        //  $R# - Number of returned results
        //
        //  $R0 - First result
        //  $R1 - Second result
        //
        //  ... etc.
        //
        while( rgszArg[cArg] != NULL) {

            //
            // Add element to return Buffer and update pointer to next
            // region to place an element. Make sure that element doesn't
            // overflow the buffer
            //
            Temp = strlen(rgszArg[cArg]) + 1;
            if( fGlobalOkay && (BufCnt + Temp) < LastShellReturnSize) {
                strcat( pwCur, rgszArg[cArg] );
                BufCnt += Temp;
                pwCur += Temp;
                *pwCur = '\0';
            } else {
                //
                // If we can not add an element to the buffer then we don't
                // want to just skip it, so note a reminder to stop adding
                // items into the global return buffer
                //
                fGlobalOkay = FALSE;
            }

            sprintf( szName, "$R%u",cArg);
            while (!FAddSymbolValueToSymTab( szName, rgszArg[cArg])) {
                if (!FHandleOOM(hWndShell)) {
                    fOkay = fFalse;
                    break;
                }
            }

            if ( !fOkay ) {
                break;
            }
            cArg++;
        }

        if ( fOkay ) {
            sprintf( szName, "%u", cArg );
            while (!FAddSymbolValueToSymTab( "$R#", szName)) {
                if (!FHandleOOM(hWndShell)) {
                    fOkay = fFalse;
                    break;
                }
            }
        }

        //
        //  Resume execution at the next line of the parent context.
        //
        PostMessage(hWndShell, STF_SHL_INTERP, pLocalContext()->CurrentLine+1, 0L);

    }

    return fOkay;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\mca.c ===
#include "precomp.h"
#pragma hdrstop

extern CHAR ReturnTextBuffer[1024];

/*

GetMCABusInformation - Get the real MCA bus number from the data structure.
    The user must passed 3 arguments to the function.
    1st argument - the registry key handle
    2nd argument - registry field name, i.e. "Configuration Data"
    3rd argument - the index of the MCA bus.

    The function will look at the MCA data structure and find out the
    real bus number. If it cannot find the real bus number, it will
    return the index of the MCA bus (which will match the real bus number
    in a single bus machine).
*/

BOOL
GetMCABusInformation(
    IN DWORD cArgs,
    IN LPSTR Args[],
    OUT LPSTR *TextOut
    )

{
    PCM_FULL_RESOURCE_DESCRIPTOR pFullResourceDescriptor;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pPartialDescriptor;

    CHAR szNum[10];

    BOOL    fOkay;
    HKEY    hKey;
    DWORD   cbData;
    DWORD   ValueType;
    PVOID   ValueData;
    LONG    Status;

    char        szKClass[ MAX_PATH ];
    DWORD       cbKClass;
    DWORD       KSubKeys;
    DWORD       cbKMaxSubKeyLen;
    DWORD       cbKMaxClassLen;
    DWORD       KValues;
    DWORD       cbKMaxValueNameLen;
    DWORD       SizeSecurityDescriptor;
    FILETIME    KLastWriteTime;

    lstrcpy( ReturnTextBuffer, "{" );

    hKey = (HKEY)LongToHandle(atol( &(Args[0][1])));

    cbKClass = MAX_PATH;

	 /*
	 ** Get the registry handle information
	 */
	
    fOkay = !( Status = RegQueryInfoKey ( hKey,
                                          szKClass,
                                          &cbKClass,
                                          NULL,
                                          &KSubKeys,
                                          &cbKMaxSubKeyLen,
                                          &cbKMaxClassLen,
                                          &KValues,
                                          &cbKMaxValueNameLen,
                                          &cbData,
                                          &SizeSecurityDescriptor,
                                          &KLastWriteTime ) );

    if ( !fOkay ) {
        lstrcat( ReturnTextBuffer, Args[2] );
        lstrcat( ReturnTextBuffer, "}" );
        *TextOut = ReturnTextBuffer;
        OutputDebugString("RegQueryInfoKey error.\n\r");
        return(FALSE);

    } else {

        //
        //  Allocate the buffer and get the data
        //
        //  add some space for the margin

        while ( (ValueData = (PVOID)SAlloc( (CB)( cbData+10 ))) == NULL ) {
                lstrcat( ReturnTextBuffer, Args[2] );
				lstrcat( ReturnTextBuffer, "}" );
				*TextOut = ReturnTextBuffer;
				OutputDebugString("Malloc error.\n\r");
			return(FALSE);
        }

        if ( fOkay ) {

            fOkay = !( Status = RegQueryValueEx( hKey,
                                                 Args[1],
                                                 NULL,
                                                 &ValueType,
                                                 ValueData,
                                                 &cbData ) );
                if ( !fOkay ) {
			       SFree( ValueData );
                   lstrcat( ReturnTextBuffer, Args[2] );
                   lstrcat( ReturnTextBuffer, "}" );
                   *TextOut = ReturnTextBuffer;
                   OutputDebugString("RegQueryValueEx error.\n\r");
                   return(FALSE);

                }
			}

    }

    // save the bus number and return

    pFullResourceDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR) ValueData;
    wsprintf(szNum, "\"%d\"", pFullResourceDescriptor->BusNumber);
    lstrcat( ReturnTextBuffer, szNum);
    lstrcat( ReturnTextBuffer, "}" );
    *TextOut = ReturnTextBuffer;
    SFree( ValueData );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\mantproc.c ===
#include "precomp.h"
#pragma hdrstop
/***************************************************************************/
/****************** Basic Class Dialog Handlers ****************************/
/***************************************************************************/


/*
*****************************************************************************/

PCSTR PropName = "_helpactiveprop";

INT_PTR APIENTRY
FGstMaintDlgProc(
    HWND hdlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CHP  rgchNum[10];
    WORD idc;
    PSZ  psz;
    RGSZ rgsz;
    SZ   sz;
    static HICON hiconOld = NULL;

    Unused(lParam);

    switch (wMsg) {

    case STF_REINITDIALOG:
        if ((sz = SzFindSymbolValueInSymTab("ReInit")) == (SZ)NULL ||
           (CrcStringCompareI(sz, "YES") != crcEqual)) {

            return(fTrue);

        }

    case WM_INITDIALOG:

        SetProp(hdlg,PropName,(HANDLE)FALSE);

        if( wMsg == WM_INITDIALOG ) {
            FCenterDialogOnDesktop(hdlg);
        }

        if( !hiconOld ) {
            hiconOld = (HICON)GetClassLongPtr(hdlg, GCLP_HICON);
            SetClassLongPtr(hdlg, GCLP_HICON, (LONG_PTR)LoadIcon(MyDllModuleHandle, MAKEINTRESOURCE(IDI_STF_ICON)));
            // above was GetModuleHandle(NULL)
        }

        // Handle all the text status fields in this dialog

        if ((sz = SzFindSymbolValueInSymTab("TextFields")) != (SZ)NULL) {
            WORD idcStatus;

            while ((psz = rgsz = RgszFromSzListValue(sz)) == (RGSZ)NULL) {
                if (!FHandleOOM(hdlg)) {
                    DestroyWindow(GetParent(hdlg));
                    return(fTrue);
                }
            }

            idcStatus = IDC_TEXT1;
            while (*psz != (SZ)NULL && GetDlgItem(hdlg, idcStatus)) {
                SetDlgItemText (hdlg, idcStatus++,*psz++);
            }

            EvalAssert(FFreeRgsz(rgsz));
        }

        return(fTrue);

    case WM_CLOSE:
        PostMessage(
            hdlg,
            WM_COMMAND,
            MAKELONG(IDC_X, BN_CLICKED),
            0L
            );
        return(fTrue);


    case WM_COMMAND:

        switch (idc = LOWORD(wParam)) {

        case MENU_HELPINDEX:
        case MENU_HELPSEARCH:
        case MENU_HELPONHELP:

            if(FProcessWinHelpMenu( hdlg, idc )) {
                SetProp(hdlg,PropName,(HANDLE)TRUE);
            }
            break;

        case MENU_ABOUT:

            {
                TCHAR Title[100];

                LoadString(MyDllModuleHandle,IDS_APP_TITLE,Title,sizeof(Title)/sizeof(TCHAR));
                // above was GetModuleHandle(NULL)
                ShellAbout(hdlg,Title,NULL,(HICON)GetClassLongPtr(hdlg,GCLP_HICON));
            }
            break;

        case MENU_EXIT:
            PostMessage(
                hdlg,
                WM_COMMAND,
                MAKELONG(IDC_X, BN_CLICKED),
                0L
                );
            return(fTrue);

        case IDCANCEL:
            if (LOWORD(wParam) == IDCANCEL) {

                if (!GetDlgItem(hdlg, IDC_B) || HIWORD(GetKeyState(VK_CONTROL)) || HIWORD(GetKeyState(VK_SHIFT)) || HIWORD(GetKeyState(VK_MENU)))
                {
                    break;
                }
                wParam = IDC_B;

            }
        case MENU_CHANGE:
        case IDC_O:
        case IDC_C:
        case IDC_M:
        case IDC_B:
        case IDC_X:
        case IDC_BTN0:
        case IDC_BTN1: case IDC_BTN2: case IDC_BTN3:
        case IDC_BTN4: case IDC_BTN5: case IDC_BTN6:
        case IDC_BTN7: case IDC_BTN8: case IDC_BTN9:

            _itoa((INT)wParam, rgchNum, 10);
            while (!FAddSymbolValueToSymTab("ButtonPressed", rgchNum))
                if (!FHandleOOM(hdlg))
                    {
                    DestroyWindow(GetParent(hdlg));
                    return(fTrue);
                    }

            PostMessage(GetParent(hdlg), (WORD)STF_UI_EVENT, 0, 0L);
            break;
        }
        break;



    case STF_DESTROY_DLG:
        if(GetProp(hdlg,PropName)) {
            WinHelp(hdlg,NULL,HELP_QUIT,0);
        }
        if (hiconOld) {
           SetClassLongPtr(hdlg, GCLP_HICON, (LONG_PTR)hiconOld);
           hiconOld = NULL;
        }
        PostMessage(GetParent(hdlg), (WORD)STF_MAINT_DLG_DESTROYED, 0, 0L);
        DestroyWindow(hdlg);
        return(fTrue);
    }

    return(fFalse);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\mcproc.c ===
#include "precomp.h"
#pragma hdrstop
/***************************************************************************/
/****************** Basic Class Dialog Handlers ****************************/
/***************************************************************************/

#define cchpMax 511


/*
**	Purpose:
**		Multi Edit, Checkbox, radio button & MultiComboBox Dialog procedure.
**	Control IDs:
**      The Edit controls must have IDs of IDC_EDIT1 to IDC_EDIT10.
**		Pushbuttons recognized are IDC_O, IDC_C, IDC_M, IDC_H, IDC_X, and IDC_B.
**	Initialization:
**		The symbol $(EditTextIn) is used to set the initial text in the Edit
**      controls.  The symbol $(EditTextLim) is used to set the limit of the
**      text in the edit fields.
**	Termination:
**      The strings in the Edit controls are stored in the symbol $(EditTextOut)
**		The id of the Pushbutton (eg IDC_C) which caused termination is
**		converted to a string and stored in the symbol $(ButtonPressed).
*****************************************************************************/
INT_PTR APIENTRY FGstComboRadDlgProc (HWND   hdlg,
                                      UINT   wMsg,
                                      WPARAM wParam,
                                      LPARAM lParam)
{
	CHP    rgchNum[10];
	CHP    rgchText[cchpMax + 1];
	SZ     sz, szListIn, szListOut, szEditTextIn, szEditTextLim;
	RGSZ   rgsz, rgszIn, rgszOut, rgszListIn,
           rgszEditTextIn, rgszEditTextLim ;
	PSZ    psz, pszIn, pszOut, pszListIn, pszEditTextIn, pszEditTextLim ;
    LRESULT iItem;
	WORD   idc;
	static BOOL fNotify[10];
    INT    i, nCount, nCurSel, iFocus, iEditMax, iButtonChecked;
    HWND   hctl ;
	static INT iButtonMax;
    BOOL fResult = fTrue ;

	Unused(lParam);

	switch (wMsg) {

	case STF_REINITDIALOG:
		if ((sz = SzFindSymbolValueInSymTab("ReInit")) == (SZ)NULL ||
		    (CrcStringCompareI(sz, "YES") != crcEqual)) {

			return(fResult);
		}

	case WM_INITDIALOG:

		AssertDataSeg();

        if( wMsg == WM_INITDIALOG ) {
            FCenterDialogOnDesktop(hdlg);
        }

        //
        // find the initalisers:  EditTextIn, EditTextLim
        //
        szEditTextIn  = SzFindSymbolValueInSymTab("EditTextIn");
        szEditTextLim = SzFindSymbolValueInSymTab("EditTextLim");


        if ( szEditTextIn  == (SZ)NULL ||
             szEditTextLim == (SZ)NULL    )
        {
              Assert(fFalse);
            return(fResult);

        }

        //
        // Convert initializers to rgsz structures
        //

        while ((pszEditTextIn = rgszEditTextIn = RgszFromSzListValue(szEditTextIn)) == (RGSZ)NULL)
        {
            if (!FHandleOOM(hdlg)) {
                DestroyWindow(GetParent(hdlg));
                return(fResult);
            }
        }

        while ((pszEditTextLim = rgszEditTextLim = RgszFromSzListValue(szEditTextLim)) == (RGSZ)NULL)
        {
            if (!FHandleOOM(hdlg)) {
                DestroyWindow(GetParent(hdlg));
                return(fResult);
            }
        }


        //
        // Circulate through the initialisers:  EditTextIn, EditTextLim
        // in tandem, initialising the edit boxes that
        // are there in this dialog
        //

        idc = IDC_EDIT1;

        while ( (szEditTextIn  = *pszEditTextIn++)  != (SZ)NULL  &&
                (szEditTextLim = *pszEditTextLim++) != (SZ)NULL     )
        {

            iEditMax = idc ;

            // First set the limit of the text in the edit field

            SendDlgItemMessage(
                hdlg,
                idc,
                EM_LIMITTEXT,
                atoi(szEditTextLim),
                0L
                );

            // And then set the text in the edit field

            SetDlgItemText(hdlg, idc++, (LPSTR)szEditTextIn);

        }

        EvalAssert(FFreeRgsz(rgszEditTextIn));
        EvalAssert(FFreeRgsz(rgszEditTextLim));

        //  Find which control is to receive focus.
        //  First look for a control ID in "RCCtlFocusOn";
        //  otherwise, set focus on the edit control
        //  based on the numeric value of "EditFocusOn".

        iFocus = -1 ;
        if ( sz = SzFindSymbolValueInSymTab("RCCtlFocusOn") )
        {
           iFocus = atoi( sz ) ;
        }

        if (    iFocus < 0
             && (sz = SzFindSymbolValueInSymTab("EditFocusOn")) )
        {
           iFocus = IDC_EDIT1 + atoi( sz ) - 1 ;
           if ( iFocus < IDC_EDIT1 )
           {
              iFocus = IDC_EDIT1 ;
           }
           else
           if ( iFocus > iEditMax )
           {
              iFocus = iEditMax ;
           }
        }

        //  Set focus on the chosen field (if there really is such a control)

        if ( iFocus >= 0 && (hctl = GetDlgItem( hdlg, iFocus )) )
        {
            SetFocus( hctl ) ;
            fResult = FALSE ;  // Cause dialog manager to preserve focus
        }

	if ((sz = SzFindSymbolValueInSymTab("EditFocus")) == (SZ)NULL) {
		sz = "END";
	}

	// Initialise the OPTIONAL combo boxes

	szListIn  = SzFindSymbolValueInSymTab("ComboListItemsIn");
	szListOut = SzFindSymbolValueInSymTab("ComboListItemsOut");
        if ( szListIn != (SZ)NULL && szListOut != (SZ)NULL   ) {

		    while ((pszIn = rgszIn = RgszFromSzListValue(szListIn)) == (RGSZ)NULL)
	    		if (!FHandleOOM(hdlg))
		    	{
			       DestroyWindow(GetParent(hdlg));
				return(fResult);
			    }

    		while ((pszOut =rgszOut = RgszFromSzListValue(szListOut)) == (RGSZ)NULL)
	       	if (!FHandleOOM(hdlg))
			    {
				    DestroyWindow(GetParent(hdlg));
				    return(fResult);
			    }
		   idc = IDC_COMBO1;
		   while (*pszIn != (SZ)NULL)
		   {
   			Assert(*pszOut != (SZ)NULL);

			   if ((szListIn = SzFindSymbolValueInSymTab(*pszIn)) == (SZ)NULL)
			   {
   				Assert(fFalse);
				   EvalAssert(FFreeRgsz(rgszIn));
				   EvalAssert(FFreeRgsz(rgszOut));
				   return(fResult);
			   }

			   while ((pszListIn = rgszListIn = RgszFromSzListValue(szListIn))
			       == (RGSZ)NULL)
				   if (!FHandleOOM(hdlg))
				   {
   					DestroyWindow(GetParent(hdlg));
					   return(fResult);
				   }

			   SendDlgItemMessage(hdlg, idc, CB_RESETCONTENT, 0, 0L);
			   while (*pszListIn != (SZ)NULL)
		    SendDlgItemMessage(hdlg, idc, CB_ADDSTRING, 0,
                        (LPARAM)*pszListIn++);

               //
               // Try to find out the item to select from the combo list.
               //
               // If there are no items, set nCurSel to -1 to clear the combo
               // If there are items, however the ListOut variable either doesn't
               // exist or is "" then set the nCurSel to 0 ( the first element )
               // If the ListOut var exists and is found in the list box then
               // set the nCurSel to the index of the element found
               //

               nCount  = (INT)SendDlgItemMessage(hdlg, idc, CB_GETCOUNT, 0, 0L);
               if ( nCount ) {

                   nCurSel = 0;
                   if ((szListOut = SzFindSymbolValueInSymTab(*pszOut)) != (SZ)NULL &&
                         CrcStringCompareI(szListOut, "") != crcEqual) {
                       CHP  szItemCur[256];

                       for (i = 0; i < nCount; i++) {
                           if ( (SendDlgItemMessage(
                                    hdlg,
                                    idc,
                                    CB_GETLBTEXT,
                                    (WPARAM)i,
                                    (LPARAM)szItemCur
                                    ) != CB_ERR)
                                && (CrcStringCompareI(szItemCur, szListOut) == crcEqual)
                              ) {

                               nCurSel = i;
                               break;

                           }
                       }
                   }
               }
               else {
                   nCurSel = -1;
               }
               SendDlgItemMessage(hdlg, idc, CB_SETCURSEL, (WPARAM)nCurSel, 0L);

			   EvalAssert(FFreeRgsz(rgszListIn));
			   idc++;
			   pszIn++;
			   pszOut++;
		   }

		   EvalAssert(FFreeRgsz(rgszIn));
		   EvalAssert(FFreeRgsz(rgszOut));

		   // Extract the information on which combo modifications should
           // be modified
		   for (i = 0; i < 10; i++) {
   			fNotify[i] = fFalse;
		   }

		   if ((sz = SzFindSymbolValueInSymTab("NotifyFields")) != (SZ)NULL) {

			   while ((psz = rgsz = RgszFromSzListValue(sz)) == (RGSZ)NULL) {
   				if (!FHandleOOM(hdlg)) {
					   DestroyWindow(GetParent(hdlg));
					   return(fResult);
				   }
			   }

			   for (i = 0; (i < 10) && (*psz != (SZ) NULL); i++) {
   				fNotify[i] = (CrcStringCompareI(*(psz++), "YES") == crcEqual) ?
				       fTrue : fFalse;
			   }

			   EvalAssert(FFreeRgsz(rgsz));
		   }
      }

		// Initialise the check boxes, note that check boxes are optional

		if ((sz = SzFindSymbolValueInSymTab("CheckItemsIn")) != (SZ)NULL) {
			while ((psz = rgsz = RgszFromSzListValue(sz)) == (RGSZ)NULL) {
				if (!FHandleOOM(hdlg)) {
					DestroyWindow(GetParent(hdlg));
					return(fResult);
				}
			}

			idc = IDC_B1;
			while (*psz != (SZ)NULL)
			{
				WORD wCheck = 0;

				if (CrcStringCompare(*(psz++), "ON") == crcEqual)
					wCheck = 1;
				CheckDlgButton(hdlg, idc++, wCheck);
			}

			EvalAssert(FFreeRgsz(rgsz));

			if ((sz = SzFindSymbolValueInSymTab("CBOptionsGreyed")) == (SZ)NULL)
			{
				PreCondition(fFalse, fTrue);
				return(fResult);
			}

			while ((psz = rgsz = RgszFromSzListValue(sz)) == (RGSZ)NULL)
				if (!FHandleOOM(hdlg))
				{
					DestroyWindow(GetParent(hdlg));
					return(fResult);
				}

			while (*psz != (SZ)NULL)
			{
				SZ  sz = *(psz++);
				INT i  = atoi(sz);

				if (i > 0 && i <= 10)
					EnableWindow(GetDlgItem(hdlg, IDC_B0 + i), 0);
				else if (*sz != '\0')
					PreCondition(fFalse, fTrue);
			}
			EvalAssert(FFreeRgsz(rgsz));
		}


		// Handle all the text status fields in this dialog

		if ((sz = SzFindSymbolValueInSymTab("TextFields")) != (SZ)NULL) {
			WORD idcStatus;

			while ((psz = rgsz = RgszFromSzListValue(sz)) == (RGSZ)NULL) {
				if (!FHandleOOM(hdlg)) {
					DestroyWindow(GetParent(hdlg));
					return(fResult);
				}
			}

			idcStatus = IDC_TEXT1;
			while (*psz != (SZ)NULL && GetDlgItem(hdlg, idcStatus)) {
				SetDlgItemText (hdlg, idcStatus++,*psz++);
			}

			EvalAssert(FFreeRgsz(rgsz));
		}

		// radio button initialize


		for (i = IDC_RB1; i <= IDC_RB10 && GetDlgItem(hdlg, i) != (HWND)NULL; i++)
			;
		iButtonMax = i - 1;

		if ((sz = SzFindSymbolValueInSymTab("RadioIn")) != (SZ)NULL) {

			while ((psz = rgsz = RgszFromSzListValue(sz)) == (RGSZ)NULL) {
				if (!FHandleOOM(hdlg)) {
					DestroyWindow(GetParent(hdlg));
					return(fResult);
				}
			}

			while (*psz != (SZ)NULL) {

				iButtonChecked = atoi(*(psz++));
				if (iButtonChecked < 1)
					iButtonChecked = 0;
				if (iButtonChecked > 10)
					iButtonChecked = 10;

				if (iButtonChecked != 0)
					SendDlgItemMessage(hdlg, IDC_RB0 + iButtonChecked, BM_SETCHECK,1,0L);
			}
			EvalAssert(FFreeRgsz(rgsz));
		}

		if ((sz = SzFindSymbolValueInSymTab("RadioOptionsGreyed")) != (SZ)NULL)
		{

			while ((psz = rgsz = RgszFromSzListValue(sz)) == (RGSZ)NULL)
				if (!FHandleOOM(hdlg))
				{
					DestroyWindow(GetParent(hdlg));
					return(fResult);
				}
	
			while (*psz != (SZ)NULL)
			{
				SZ  sz = *(psz++);
				INT i  = atoi(sz);
	
				if (i > 0 && i <= 10 && i != iButtonChecked)
					EnableWindow(GetDlgItem(hdlg, IDC_RB0 + i), 0);
				else if (*sz != '\0')
					PreCondition(fFalse, fTrue);
			}
	
			EvalAssert(FFreeRgsz(rgsz));
		}

		return(fResult);

	case WM_CLOSE:
		PostMessage(
		    hdlg,
		    WM_COMMAND,
		    MAKELONG(IDC_X, BN_CLICKED),
		    0L
		    );
		return(fResult);

	case WM_COMMAND:
		switch (idc = LOWORD(wParam))
		{

			// Edit Box Notification

		case IDC_EDIT1:
			break;

			// Check box Notification

		case IDC_B1:
		case IDC_B2:
		case IDC_B3:
		case IDC_B4:
		case IDC_B5:
		case IDC_B6:
		case IDC_B7:
		case IDC_B8:
		case IDC_B9:
		case IDC_B10:
			CheckDlgButton(hdlg, LOWORD(wParam),
			    (WORD)!IsDlgButtonChecked(hdlg, (int)wParam));
			break;

		case IDC_RB1:
		case IDC_RB2:
		case IDC_RB3:
		case IDC_RB4:
		case IDC_RB5:
		case IDC_RB6:
		case IDC_RB7:
		case IDC_RB8:
		case IDC_RB9:
		case IDC_RB10:
			/*
			CheckRadioButton(hdlg, IDC_RB1, iButtonMax, (INT)idc);
			*/
			if (HIWORD(wParam) != BN_DOUBLECLICKED)
				break;
			wParam = IDC_C;
			/* Fall through */

		case IDC_COMBO1:
		case IDC_COMBO2:
		case IDC_COMBO3:
		case IDC_COMBO4:
		case IDC_COMBO5:
		case IDC_COMBO6:
		case IDC_COMBO7:
		case IDC_COMBO8:
		case IDC_COMBO9:

			switch (HIWORD(wParam)) {

			case CBN_SELCHANGE:
				if (fNotify[idc-IDC_COMBO1] == fTrue) {
					break;
				}

			default:
				return fFalse;
			}

			// Other Buttons

		case IDCANCEL:
            if (LOWORD(wParam) == IDCANCEL) {

                if (!GetDlgItem(hdlg, IDC_B) || HIWORD(GetKeyState(VK_CONTROL)) || HIWORD(GetKeyState(VK_SHIFT)) || HIWORD(GetKeyState(VK_MENU)))
                {
                    break;
                }
                wParam = IDC_B;

            }
        case IDC_O:
		case IDC_C:
		case IDC_M:
		case IDC_B:
		case IDC_X:
        case IDC_BTN0:
        case IDC_BTN1: case IDC_BTN2: case IDC_BTN3:
        case IDC_BTN4: case IDC_BTN5: case IDC_BTN6:
        case IDC_BTN7: case IDC_BTN8: case IDC_BTN9:

			// Add the Button checked to the symbol table

			_itoa((INT)wParam, rgchNum, 10);
			while (!FAddSymbolValueToSymTab("ButtonPressed", rgchNum))
				if (!FHandleOOM(hdlg)) {
					DestroyWindow(GetParent(hdlg));
					return(fResult);
				}

         // Handle the multiple edit fields

         // Add EditTextOut list variable to the symbol table

         for (i = 0; i < 10; i++) {
             if (GetDlgItem(hdlg, IDC_EDIT1 + i) == (HWND)NULL) {
                 break;
             }
         }

         // i has the number of edit fields, allocate an rgsz structure
         // with i+1 entries (last one NULL TERMINATOR)

         nCount = i;
         while ((rgsz = (RGSZ)SAlloc((CB)((nCount + 1) * sizeof(SZ))))
                 == (RGSZ)NULL) {
             if (!FHandleOOM(hdlg)) {
                 DestroyWindow(GetParent(hdlg));
                 return(fResult);
             }
         }

         rgsz[nCount] = (SZ)NULL;

         // Circulate through the edit fields in the dialog box, determining
         // the text in each and storing it in the

         for (i = 0; i < nCount; i++) {

              SendDlgItemMessage(
                  hdlg,
                  IDC_EDIT1 + i,
                  (WORD)WM_GETTEXT,
                  cchpMax + 1,
                  (LPARAM)rgchText
                  );

              rgsz[i] = SzDupl(rgchText);
         }


         // Form a list out of the rgsz structure

         while ((sz = SzListValueFromRgsz(rgsz)) == (SZ)NULL) {
             if (!FHandleOOM(hdlg)) {
                 DestroyWindow(GetParent(hdlg));
                 return(fResult);
             }
         }


         // Set the EditTextOut symbol to this list

         while (!FAddSymbolValueToSymTab("EditTextOut", sz)) {
             if (!FHandleOOM(hdlg)) {
                 DestroyWindow(GetParent(hdlg));
                 return(fResult);
             }
         }

         EvalAssert(FFreeRgsz(rgsz));
         SFree(sz);



			// Extract the checkbox states.

			while ((psz = rgsz = (RGSZ)SAlloc((CB)(11 * sizeof(SZ)))) ==
			    (RGSZ)NULL)
				if (!FHandleOOM(hdlg)) {
					DestroyWindow(GetParent(hdlg));
					return(fResult);
				}

			for (idc = IDC_B1; GetDlgItem(hdlg, idc); psz++, idc++) {

				BOOL fChecked = IsDlgButtonChecked(hdlg, idc);

				while ((*psz = SzDupl(fChecked ? "ON" : "OFF")) == (SZ)NULL) {
					if (!FHandleOOM(hdlg)) {
						DestroyWindow(GetParent(hdlg));
						return(fResult);
					}
				}
			}

			*psz = (SZ)NULL;

			while ((sz = SzListValueFromRgsz(rgsz)) == (SZ)NULL) {
				if (!FHandleOOM(hdlg)) {
					DestroyWindow(GetParent(hdlg));
					return(fResult);
				}
			}

			while (!FAddSymbolValueToSymTab("CheckItemsOut", sz)) {
				if (!FHandleOOM(hdlg)) {
					DestroyWindow(GetParent(hdlg));
					return(fResult);
				}
			}

			SFree(sz);
			EvalAssert(FFreeRgsz(rgsz));

			// extract radio button

			while ((psz = rgsz = (RGSZ)SAlloc((CB)(11 * sizeof(SZ)))) ==
			    (RGSZ)NULL)
				if (!FHandleOOM(hdlg)) {
					DestroyWindow(GetParent(hdlg));
					return(fResult);
				}

			for (idc = IDC_RB1, i=1; GetDlgItem(hdlg, idc); idc++, i++) {

				if (SendDlgItemMessage(hdlg, idc, BM_GETCHECK, 0, 0L))
				{
				
					CHP chpID [10];
					wsprintf( chpID, "%d", i );
	
					while ((*psz = SzDupl( chpID ))==(SZ)NULL) {
						if (!FHandleOOM(hdlg)) {
							DestroyWindow(GetParent(hdlg));
							return(fResult);
						}
					}
					psz++;
				}
			}

			*psz = (SZ)NULL;

			while ((sz = SzListValueFromRgsz(rgsz)) == (SZ)NULL) {
				if (!FHandleOOM(hdlg)) {
					DestroyWindow(GetParent(hdlg));
					return(fResult);
				}
			}

			while (!FAddSymbolValueToSymTab("RadioOut", sz)) {
				if (!FHandleOOM(hdlg)) {
					DestroyWindow(GetParent(hdlg));
					return(fResult);
				}
			}

			SFree(sz);
			EvalAssert(FFreeRgsz(rgsz));



			// Extract the selections in the combo boxes and add them to the
            // symbol table

			if ((szListOut = SzFindSymbolValueInSymTab("ComboListItemsOut"))
			    == (SZ)NULL)
			{
				Assert(fFalse);
				break;
			}

			while ((pszOut = rgszOut = RgszFromSzListValue(szListOut))
			    == (RGSZ)NULL)
				if (!FHandleOOM(hdlg))
				{
					DestroyWindow(GetParent(hdlg));
					return(fResult);
				}

			idc = IDC_COMBO1;
			while (*pszOut != (SZ)NULL) {
                if ((iItem = SendDlgItemMessage(
                                 hdlg,
                                 idc,
                                 CB_GETCURSEL,
                                 0,
                                 0L
                                 )) == CB_ERR) {
					*rgchText = '\0';
				}
				else {
					SendDlgItemMessage(
					    hdlg,
					    idc,
					    CB_GETLBTEXT,
					    (WPARAM)iItem,
					    (LPARAM)rgchText
					    );
				}

				while (!FAddSymbolValueToSymTab(*pszOut, rgchText)) {
					if (!FHandleOOM(hdlg)) {
						DestroyWindow(GetParent(hdlg));
						return(fResult);
					}
				}

				pszOut++;
				idc++;
			}

			EvalAssert(FFreeRgsz(rgszOut));
			PostMessage(GetParent(hdlg), (WORD)STF_UI_EVENT, 0, 0L);
			break;
		}
		break;

	case STF_DESTROY_DLG:
		PostMessage(GetParent(hdlg), (WORD)STF_MULTICOMBO_RADIO_DLG_DESTROYED, 0, 0L);
		DestroyWindow(hdlg);
		return(fResult);
	}

	return(fFalse);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\mcmbproc.c ===
#include "precomp.h"
#pragma hdrstop
/***************************************************************************/
/****************** Basic Class Dialog Handlers ****************************/
/***************************************************************************/


/*
**  Purpose:
**      ComboBox Dialog procedure.
**
*****************************************************************************/
INT_PTR APIENTRY FGstMultiComboDlgProc(HWND   hdlg,
                                       UINT   wMsg,
                                       WPARAM wParam,
                                       LPARAM lParam)
{
    CHP  rgchNum[10];
    CHP  szBuffer[256];
    SZ   sz, szListIn, szListOut;
    RGSZ rgsz, rgszIn, rgszOut, rgszListIn;
    PSZ  psz, pszIn, pszOut, pszListIn;
    UINT iItem;
    WORD idc;
    INT  i, nCount, nCurSel;
    static BOOL fNotify[10];


    Unused(lParam);

    switch (wMsg)
        {
    case STF_REINITDIALOG:
      if ((sz = SzFindSymbolValueInSymTab("ReInit")) == (SZ)NULL ||
          (CrcStringCompareI(sz, "YES") != crcEqual))
           return(fTrue);

    case WM_INITDIALOG:

        AssertDataSeg();
        if( wMsg == WM_INITDIALOG ) {
            FCenterDialogOnDesktop(hdlg);
        }

        szListIn  = SzFindSymbolValueInSymTab("ComboListItemsIn");
        szListOut = SzFindSymbolValueInSymTab("ComboListItemsOut");
        if (szListIn == (SZ)NULL ||
                szListOut == (SZ)NULL)
            {
            Assert(fFalse);
            return(fTrue);
            }

        while ((pszIn = rgszIn = RgszFromSzListValue(szListIn)) == (RGSZ)NULL)
            if (!FHandleOOM(hdlg))
                {
                DestroyWindow(GetParent(hdlg));
                return(fTrue);
                }

        while ((pszOut =rgszOut = RgszFromSzListValue(szListOut)) == (RGSZ)NULL) {
            if (!FHandleOOM(hdlg)) {
                DestroyWindow(GetParent(hdlg));
                return(fTrue);
            }
        }

        idc = IDC_COMBO1;
        while (*pszIn != (SZ)NULL) {
            Assert(*pszOut != (SZ)NULL);

            if ((szListIn = SzFindSymbolValueInSymTab(*pszIn)) == (SZ)NULL) {
                Assert(fFalse);
                EvalAssert(FFreeRgsz(rgszIn));
                EvalAssert(FFreeRgsz(rgszOut));
                return(fTrue);
            }

            while ((pszListIn = rgszListIn = RgszFromSzListValue(szListIn))
                    == (RGSZ)NULL)  {
                if (!FHandleOOM(hdlg)) {
                    DestroyWindow(GetParent(hdlg));
                    return(fTrue);
                }
            }

            SendDlgItemMessage(hdlg, idc, CB_RESETCONTENT, 0, 0L);
            while (*pszListIn != (SZ)NULL) {
            SendDlgItemMessage(hdlg, idc, CB_ADDSTRING, 0,
                                   (LPARAM)*pszListIn++);
            }

            //
            // Try to find out the item to select from the combo list.
            //
            // If there are no items, set nCurSel to -1 to clear the combo
            // If there are items, however the ListOut variable either doesn't
            // exist or is "" then set the nCurSel to 0 ( the first element )
            // If the ListOut var exists and is found in the list box then
            // set the nCurSel to the index of the element found
            //

            nCount  = (INT)SendDlgItemMessage(hdlg, idc, CB_GETCOUNT, 0, 0L);
            if ( nCount ) {

                nCurSel = 0;
                if ((szListOut = SzFindSymbolValueInSymTab(*pszOut)) != (SZ)NULL &&
                      CrcStringCompareI(szListOut, "") != crcEqual) {
                    CHP  szItemCur[256];

                    for (i = 0; i < nCount; i++) {
                        if ( (SendDlgItemMessage(
                                 hdlg,
                                 idc,
                                 CB_GETLBTEXT,
                                 (WPARAM)i,
                                 (LPARAM)szItemCur
                                 ) != CB_ERR)
                             && (CrcStringCompareI(szItemCur, szListOut) == crcEqual)
                           ) {

                            nCurSel = i;
                            break;

                        }
                    }
                }
            }
            else {
                nCurSel = -1;
            }
            SendDlgItemMessage(hdlg, idc, CB_SETCURSEL, (WPARAM)nCurSel, 0L);

            EvalAssert(FFreeRgsz(rgszListIn));
            idc++;
            pszIn++;
            pszOut++;
        }

        EvalAssert(FFreeRgsz(rgszIn));
        EvalAssert(FFreeRgsz(rgszOut));

      // Extract the information on which combo modifications should
      // be modified

      for (i = 0; i < 10; i++) {
          fNotify[i] = fFalse;
      }

      if ((sz = SzFindSymbolValueInSymTab("NotifyFields")) != (SZ)NULL) {
         while ((psz = rgsz = RgszFromSzListValue(sz)) == (RGSZ)NULL) {
            if (!FHandleOOM(hdlg)) {
                  DestroyWindow(GetParent(hdlg));
                  return(fTrue);
            }
         }

         for (i = 0; (i < 10) && (*psz != (SZ) NULL); i++) {
               fNotify[i] = (CrcStringCompareI(*(psz++), "YES") == crcEqual) ?
               fTrue : fFalse;
         }

         EvalAssert(FFreeRgsz(rgsz));
      }


      // Handle all the text status fields in this dialog

      if ((sz = SzFindSymbolValueInSymTab("TextFields")) != (SZ)NULL)
         {
         WORD idcStatus;
         while ((psz = rgsz = RgszFromSzListValue(sz)) == (RGSZ)NULL)
            if (!FHandleOOM(hdlg))
               {
                  DestroyWindow(GetParent(hdlg));
                  return(fTrue);
               }

         idcStatus = IDC_TEXT1;
         while (*psz != (SZ)NULL && GetDlgItem(hdlg, idcStatus))
            SetDlgItemText (hdlg, idcStatus++,*psz++);

         EvalAssert(FFreeRgsz(rgsz));
         }
        return(fTrue);


    case WM_CLOSE:
        PostMessage(
            hdlg,
            WM_COMMAND,
            MAKELONG(IDC_X, BN_CLICKED),
            0L
            );
        return(fTrue);

    case WM_COMMAND:
        switch (idc = LOWORD(wParam)) {
        case IDC_COMBO1:
        case IDC_COMBO2:
        case IDC_COMBO3:
        case IDC_COMBO4:
        case IDC_COMBO5:
        case IDC_COMBO6:
        case IDC_COMBO7:
        case IDC_COMBO8:
        case IDC_COMBO9:

            switch (HIWORD(wParam)) {
               case CBN_SELCHANGE:
                  if (fNotify[idc-IDC_COMBO1] == fTrue)
                     break;

               default:
                  return fFalse;
            }

        case IDCANCEL:
            if (LOWORD(wParam) == IDCANCEL) {

                if (!GetDlgItem(hdlg, IDC_B) || HIWORD(GetKeyState(VK_CONTROL)) || HIWORD(GetKeyState(VK_SHIFT)) || HIWORD(GetKeyState(VK_MENU)))
                {
                    break;
                }
                wParam = IDC_B;

            }
        case IDC_O:
        case IDC_C:
        case IDC_M:
        case IDC_X:
        case IDC_B:
        case IDC_BTN0:
        case IDC_BTN1: case IDC_BTN2: case IDC_BTN3:
        case IDC_BTN4: case IDC_BTN5: case IDC_BTN6:
        case IDC_BTN7: case IDC_BTN8: case IDC_BTN9:

            _itoa((INT)wParam, rgchNum, 10);
            while (!FAddSymbolValueToSymTab("ButtonPressed", rgchNum))
            if (!FHandleOOM(hdlg)) {
                DestroyWindow(GetParent(hdlg));
                return(fTrue);
            }

            if ((szListOut = SzFindSymbolValueInSymTab("ComboListItemsOut"))
                    == (SZ)NULL) {
                Assert(fFalse);
                break;
            }

            while ((pszOut = rgszOut = RgszFromSzListValue(szListOut))
                    == (RGSZ)NULL)
                if (!FHandleOOM(hdlg))
                    {
                    DestroyWindow(GetParent(hdlg));
                    return(fTrue);
                    }

            idc = IDC_COMBO1;
            while (*pszOut != (SZ)NULL)
                {
                if( GetWindowText( GetDlgItem( hdlg, idc ),
                                   (LPSTR)szBuffer,
                                   sizeof( szBuffer ) ) == 0 ) {
                    *szBuffer = '\0';
                }
                while (!FAddSymbolValueToSymTab(*pszOut, szBuffer))
                    if (!FHandleOOM(hdlg))
                        {
                        DestroyWindow(GetParent(hdlg));
                        return(fTrue);
                        }
                pszOut++;
                idc++;
                }

            EvalAssert(FFreeRgsz(rgszOut));
            PostMessage(GetParent(hdlg), (WORD)STF_UI_EVENT, 0, 0L);
            break;
            }
        break;

    case STF_DESTROY_DLG:
        PostMessage(GetParent(hdlg), (WORD)STF_MULTICOMBO_DLG_DESTROYED, 0, 0L);
        DestroyWindow(hdlg);
        return(fTrue);
        }

    return(fFalse);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\mcntproc.c ===
#include "precomp.h"
#pragma hdrstop
/***************************************************************************/
/****************** Basic Class Dialog Handlers ****************************/
/***************************************************************************/

#define cchpMax 511


/*
**  Purpose:
**      Edit, Checkbox & MultiComboBox Dialog procedure.
**
*****************************************************************************/
INT_PTR APIENTRY FGstCombinationDlgProc (HWND   hdlg,
                                         UINT   wMsg,
                                         WPARAM wParam,
                                         LPARAM lParam)
{

    static WPARAM wSelStart = 0;
    static WPARAM wSelEnd   = 0;
    CHP    rgchNum[10];
    CHP    rgchText[cchpMax + 1];
    CCHP   cchp;
    SZ     sz, szListIn, szListOut;
    RGSZ   rgsz, rgszIn, rgszOut, rgszListIn;
    PSZ    psz, pszIn, pszOut, pszListIn;
    LRESULT iItem;
    WORD   idc;
    static BOOL fNotify[10];
    INT    i, nCount, nCurSel;

    Unused(lParam);

    switch (wMsg) {

    case STF_REINITDIALOG:
        if ((sz = SzFindSymbolValueInSymTab("ReInit")) == (SZ)NULL ||
            (CrcStringCompareI(sz, "YES") != crcEqual)) {

            return(fTrue);
        }

    case WM_INITDIALOG:

        AssertDataSeg();
        if( wMsg == WM_INITDIALOG ) {
            FCenterDialogOnDesktop(hdlg);
        }

        // Initialise the edit box

        // Find the limit on the edit box text

        cchp = cchpMax;
        if ((sz = SzFindSymbolValueInSymTab("EditTextLim")) != (SZ)NULL) {
            cchp = (CCHP) atoi(sz);
        }

        SendDlgItemMessage(hdlg, IDC_EDIT1, EM_LIMITTEXT, cchp, 0L);

        // Find the text limit

        if ((sz = SzFindSymbolValueInSymTab("EditTextIn")) == (SZ)NULL) {
            sz = "";
        }

        Assert(sz != NULL);
        SetDlgItemText(hdlg, IDC_EDIT1, (LPSTR)sz);

        // Find the focus string, default is END

        cchp = strlen(sz);
        if ((sz = SzFindSymbolValueInSymTab("EditFocus")) == (SZ)NULL) {
            sz = "END";
        }


        wSelStart = (WPARAM)cchp;
        wSelEnd   = (WPARAM)cchp;
        if (CrcStringCompare(sz, "END") == crcEqual) {
            ;
        }
        else if (CrcStringCompare(sz, "ALL") == crcEqual) {
            wSelStart = 0;
            wSelEnd   = INT_MAX;
        }
        else if (CrcStringCompare(sz, "START") == crcEqual) {
            wSelStart = 0;
            wSelEnd   = 0;
        }


        // Initialise the combo boxes

        szListIn  = SzFindSymbolValueInSymTab("ComboListItemsIn");
        szListOut = SzFindSymbolValueInSymTab("ComboListItemsOut");
        if (szListIn == (SZ)NULL ||
            szListOut == (SZ)NULL   ) {
            Assert(fFalse);
            return(fTrue);
        }

        while ((pszIn = rgszIn = RgszFromSzListValue(szListIn)) == (RGSZ)NULL)
            if (!FHandleOOM(hdlg))
                {
                DestroyWindow(GetParent(hdlg));
                return(fTrue);
                }

        while ((pszOut =rgszOut = RgszFromSzListValue(szListOut)) == (RGSZ)NULL)
            if (!FHandleOOM(hdlg))
                {
                DestroyWindow(GetParent(hdlg));
                return(fTrue);
                }

        idc = IDC_COMBO1;
        while (*pszIn != (SZ)NULL) {
            Assert(*pszOut != (SZ)NULL);

            if ((szListIn = SzFindSymbolValueInSymTab(*pszIn)) == (SZ)NULL)
                {
                Assert(fFalse);
                EvalAssert(FFreeRgsz(rgszIn));
                EvalAssert(FFreeRgsz(rgszOut));
                return(fTrue);
                }

            while ((pszListIn = rgszListIn = RgszFromSzListValue(szListIn))
                    == (RGSZ)NULL)
                if (!FHandleOOM(hdlg))
                    {
                    DestroyWindow(GetParent(hdlg));
                    return(fTrue);
                    }

            SendDlgItemMessage(hdlg, idc, CB_RESETCONTENT, 0, 0L);
            while (*pszListIn != (SZ)NULL)
                SendDlgItemMessage(hdlg, idc, CB_ADDSTRING, 0,
                        (LPARAM)*pszListIn++);

            //
            // Try to find out the item to select from the combo list.
            //
            // If there are no items, set nCurSel to -1 to clear the combo
            // If there are items, however the ListOut variable either doesn't
            // exist or is "" then set the nCurSel to 0 ( the first element )
            // If the ListOut var exists and is found in the list box then
            // set the nCurSel to the index of the element found
            //

            nCount  = (INT)SendDlgItemMessage(hdlg, idc, CB_GETCOUNT, 0, 0L);
            if ( nCount ) {

                nCurSel = 0;
                if ((szListOut = SzFindSymbolValueInSymTab(*pszOut)) != (SZ)NULL &&
                      CrcStringCompareI(szListOut, "") != crcEqual) {
                    CHP  szItemCur[256];

                    for (i = 0; i < nCount; i++) {
                        if ( (SendDlgItemMessage(
                                 hdlg,
                                 idc,
                                 CB_GETLBTEXT,
                                 (WPARAM)i,
                                 (LPARAM)szItemCur
                                 ) != CB_ERR)
                             && (CrcStringCompareI(szItemCur, szListOut) == crcEqual)
                           ) {

                            nCurSel = i;
                            break;

                        }
                    }
                }
            }
            else {
                nCurSel = -1;
            }
            SendDlgItemMessage(hdlg, idc, CB_SETCURSEL, (WPARAM)nCurSel, 0L);

            EvalAssert(FFreeRgsz(rgszListIn));
            idc++;
            pszIn++;
            pszOut++;
        }

        EvalAssert(FFreeRgsz(rgszIn));
        EvalAssert(FFreeRgsz(rgszOut));

        // Extract the information on which combo modifications should
        // be modified

        for (i = 0; i < 10; i++) {
            fNotify[i] = fFalse;
        }

        if ((sz = SzFindSymbolValueInSymTab("NotifyFields")) != (SZ)NULL) {

             while ((psz = rgsz = RgszFromSzListValue(sz)) == (RGSZ)NULL) {
                 if (!FHandleOOM(hdlg)) {
                     DestroyWindow(GetParent(hdlg));
                     return(fTrue);
                 }
             }

             for (i = 0; (i < 10) && (*psz != (SZ) NULL); i++) {
                 fNotify[i] = (CrcStringCompareI(*(psz++), "YES") == crcEqual) ?
                      fTrue : fFalse;
             }

             EvalAssert(FFreeRgsz(rgsz));
        }


        //
        // Handle all the text status fields in this dialog
        //

        if ((sz = SzFindSymbolValueInSymTab("TextFields")) != (SZ)NULL) {
           WORD idcStatus;

           while ((psz = rgsz = RgszFromSzListValue(sz)) == (RGSZ)NULL) {
              if (!FHandleOOM(hdlg)) {
                    DestroyWindow(GetParent(hdlg));
                    return(fTrue);
              }
           }

           idcStatus = IDC_TEXT1;
           while (*psz != (SZ)NULL && GetDlgItem(hdlg, idcStatus)) {
              SetDlgItemText (hdlg, idcStatus++,*psz++);
           }

           EvalAssert(FFreeRgsz(rgsz));
        }

        //
        // Initialise the check boxes, note that check boxes are optional
        //

        if ((sz = SzFindSymbolValueInSymTab("CheckItemsIn")) == (SZ)NULL) {
            return(fTrue);
        }

        while ((psz = rgsz = RgszFromSzListValue(sz)) == (RGSZ)NULL) {
            if (!FHandleOOM(hdlg)) {
                DestroyWindow(GetParent(hdlg));
                return(fTrue);
            }
        }

        idc = IDC_B1;
        while (*psz != (SZ)NULL)
            {
            WORD wCheck = 0;

            if (CrcStringCompare(*(psz++), "ON") == crcEqual)
                wCheck = 1;
            CheckDlgButton(hdlg, idc++, wCheck);
            }

        EvalAssert(FFreeRgsz(rgsz));

        if ((sz = SzFindSymbolValueInSymTab("OptionsGreyed")) == (SZ)NULL)
            {
            PreCondition(fFalse, fTrue);
            return(fTrue);
            }

        while ((psz = rgsz = RgszFromSzListValue(sz)) == (RGSZ)NULL)
            if (!FHandleOOM(hdlg))
                {
                DestroyWindow(GetParent(hdlg));
                return(fTrue);
                }

        while (*psz != (SZ)NULL)
            {
            SZ  sz = *(psz++);
            INT i  = atoi(sz);

            if (i > 0 && i <= 10)
                EnableWindow(GetDlgItem(hdlg, IDC_B0 + i), 0);
            else if (*sz != '\0')
                PreCondition(fFalse, fTrue);
            }

        EvalAssert(FFreeRgsz(rgsz));


      return(fTrue);


    case WM_CLOSE:
        PostMessage(
            hdlg,
            WM_COMMAND,
            MAKELONG(IDC_X, BN_CLICKED),
            0L
            );
        return(fTrue);

    case WM_COMMAND:
        switch (idc = LOWORD(wParam))
            {

         // Edit Box Notification

           case IDC_EDIT1:
             if (HIWORD(wParam) == EN_SETFOCUS)
                  SendDlgItemMessage(hdlg, IDC_EDIT1, EM_SETSEL, wSelStart,
                           wSelEnd);
                else if (HIWORD(wParam) == EN_KILLFOCUS)
                      SendDlgItemMessage(hdlg, IDC_EDIT1, EM_GETSEL, (WPARAM)&wSelStart,
                           (LPARAM)&wSelEnd);
             break;

         // Check box Notification

         case IDC_B1:
         case IDC_B2:
         case IDC_B3:
         case IDC_B4:
         case IDC_B5:
         case IDC_B6:
         case IDC_B7:
         case IDC_B8:
         case IDC_B9:
         case IDC_B10:
             CheckDlgButton(hdlg, LOWORD(wParam),
                (WORD)!IsDlgButtonChecked(hdlg, (int)wParam));
              break;

         case IDC_COMBO1:
         case IDC_COMBO2:
         case IDC_COMBO3:
         case IDC_COMBO4:
         case IDC_COMBO5:
         case IDC_COMBO6:
         case IDC_COMBO7:
         case IDC_COMBO8:
         case IDC_COMBO9:

             switch (HIWORD(wParam)) {

             case CBN_SELCHANGE:
                 if (fNotify[idc-IDC_COMBO1] == fTrue) {
                     break;
                 }

             default:
                 return fFalse;
             }

         // Other Buttons

         case IDCANCEL:
            if (LOWORD(wParam) == IDCANCEL) {

                if (!GetDlgItem(hdlg, IDC_B) || HIWORD(GetKeyState(VK_CONTROL)) || HIWORD(GetKeyState(VK_SHIFT)) || HIWORD(GetKeyState(VK_MENU)))
                {
                    break;
                }
                wParam = IDC_B;

            }
         case IDC_O:
         case IDC_C:
         case IDC_M:
         case IDC_B:
         case IDC_X:
         case IDC_BTN0:
         case IDC_BTN1: case IDC_BTN2: case IDC_BTN3:
         case IDC_BTN4: case IDC_BTN5: case IDC_BTN6:
         case IDC_BTN7: case IDC_BTN8: case IDC_BTN9:

             // Add the Button checked to the symbol table

             _itoa((INT)wParam, rgchNum, 10);
             while (!FAddSymbolValueToSymTab("ButtonPressed", rgchNum))
                 if (!FHandleOOM(hdlg)) {
                    DestroyWindow(GetParent(hdlg));
                    return(fTrue);
                 }


             // Extract the text from the edit box and add it to the
             // table

            SendDlgItemMessage(hdlg, IDC_EDIT1, (WORD)WM_GETTEXT, cchpMax + 1,
                    (LPARAM)rgchText);
               while (!FAddSymbolValueToSymTab("EditTextOut", rgchText))
                   if (!FHandleOOM(hdlg))
                       {
                       DestroyWindow(GetParent(hdlg));
                       return(fTrue);
                       }


            // Extract the checkbox states.

            while ((psz = rgsz = (RGSZ)SAlloc((CB)(11 * sizeof(SZ)))) ==
                     (RGSZ)NULL)
                if (!FHandleOOM(hdlg)) {
                    DestroyWindow(GetParent(hdlg));
                    return(fTrue);
                }

            for (idc = IDC_B1; GetDlgItem(hdlg, idc); psz++, idc++) {

                BOOL fChecked = IsDlgButtonChecked(hdlg, idc);

                while ((*psz = SzDupl(fChecked ? "ON" : "OFF")) == (SZ)NULL) {
                    if (!FHandleOOM(hdlg)) {
                        DestroyWindow(GetParent(hdlg));
                        return(fTrue);
                    }
                }
            }

            *psz = (SZ)NULL;

            while ((sz = SzListValueFromRgsz(rgsz)) == (SZ)NULL) {
                if (!FHandleOOM(hdlg)) {
                    DestroyWindow(GetParent(hdlg));
                    return(fTrue);
                }
            }

            while (!FAddSymbolValueToSymTab("CheckItemsOut", sz)) {
                if (!FHandleOOM(hdlg)) {
                    DestroyWindow(GetParent(hdlg));
                    return(fTrue);
                }
            }

            SFree(sz);
            EvalAssert(FFreeRgsz(rgsz));

            // Extract the selections in the combo boxes and add them to the
            // symbol table

               if ((szListOut = SzFindSymbolValueInSymTab("ComboListItemsOut"))
                    == (SZ)NULL)
                   {
                   Assert(fFalse);
                   break;
                   }

               while ((pszOut = rgszOut = RgszFromSzListValue(szListOut))
                       == (RGSZ)NULL)
                   if (!FHandleOOM(hdlg))
                       {
                       DestroyWindow(GetParent(hdlg));
                       return(fTrue);
                       }

                idc = IDC_COMBO1;
                while (*pszOut != (SZ)NULL) {
                    if ((iItem = SendDlgItemMessage(
                                     hdlg,
                                     idc,
                                     CB_GETCURSEL,
                                     0,
                                     0L
                                     )) == CB_ERR) {
                        *rgchText = '\0';
                    }
                    else {
                        SendDlgItemMessage(
                            hdlg,
                            idc,
                            CB_GETLBTEXT,
                            (WPARAM)iItem,
                            (LPARAM)rgchText
                            );
                    }

                    while (!FAddSymbolValueToSymTab(*pszOut, rgchText)) {
                        if (!FHandleOOM(hdlg)) {
                            DestroyWindow(GetParent(hdlg));
                            return(fTrue);
                        }
                    }

                    pszOut++;
                    idc++;
                }

                EvalAssert(FFreeRgsz(rgszOut));
                PostMessage(GetParent(hdlg), (WORD)STF_UI_EVENT, 0, 0L);
                break;
            }
        break;

    case STF_DESTROY_DLG:
        PostMessage(GetParent(hdlg), (WORD)STF_MULTICOMBO_DLG_DESTROYED, 0, 0L);
        DestroyWindow(hdlg);
        return(fTrue);
        }

    return(fFalse);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\mem_32.c ===
#include "precomp.h"
#pragma hdrstop

//
// This thing is COMPLETELY single-threaded.
// Use no serialize to speed things up.
//

HANDLE Heap;

//
// Define structure used to track preallocations.
//
typedef struct _PREALLOC {

    DWORD BlockSize;
    DWORD BlockCount;

    PVOID BaseAddress;
    PVOID EndAddress;

    LONG FreeIndex;

    PVOID bitmap;
    RTL_BITMAP Bitmap;

    //
    // Just for statistics
    //
    DWORD NumUsed;

} PREALLOC, *PPREALLOC;

PREALLOC Prealloc[] = { { 32,1000 },
                        { 128,1000 },
                        { 512,20 },
                        { 4096,30 },
                        { 8192,10 },
                        { 16384 , 5 },
                        { 0 }
                      };


PVOID
pAllocPreAlloc(
    IN OUT PPREALLOC Prealloc
    );

VOID
pFreePreAlloc(
    IN OUT PPREALLOC Prealloc,
    IN     PVOID     p
    );



BOOL
SInit(
    IN BOOL Init
    )
{
    BOOL b;
    unsigned u;
    PPREALLOC p;

    if(Init) {
        if(Heap) {
            b = TRUE;
        } else {
            if(Heap = HeapCreate(HEAP_NO_SERIALIZE,512*1024,0)) {

                b = TRUE;
                for(u=0; b && Prealloc[u].BlockSize; u++) {

                    p = &Prealloc[u];

                    p->BaseAddress = HeapAlloc(Heap,0,p->BlockSize*p->BlockCount);
                    if(p->BaseAddress) {

                        p->EndAddress = (PUCHAR)p->BaseAddress + (p->BlockSize*p->BlockCount);

                        p->FreeIndex = 0;

                        p->bitmap = HeapAlloc(Heap,HEAP_ZERO_MEMORY,(p->BlockCount+7) / 8);
                        if(p->bitmap) {
                            RtlInitializeBitMap(&p->Bitmap,p->bitmap,p->BlockCount);
                        } else {
                            b = FALSE;
                        }
                    } else {
                        b = FALSE;
                    }
                }
            } else {
                b = FALSE;
            }
        }
    } else {
        //
        // If heap is null this will return FALSE which is what we want.
        //
        b = HeapDestroy(Heap);
        Heap = NULL;
    }

    return(b);
}



PVOID
SAlloc(
    IN DWORD Size
    )
{
    PVOID p;
    PPREALLOC prealloc;

    if(!Heap) {
        return(NULL);
    }

    //
    // Determine which block size to use.
    //
    for(prealloc=Prealloc; prealloc->BlockSize; prealloc++) {

        if(Size < prealloc->BlockSize) {

            //
            // Found the right size block.
            //
            p = pAllocPreAlloc(prealloc);
            if(!p) {
                //
                // None available. Go to the heap.
                //
                break;
            }

            return(p);
        }
    }

    //
    // No preallocated block will suffice. Go to the heap.
    //
    return(HeapAlloc(Heap,HEAP_NO_SERIALIZE,(DWORD)Size));
}


VOID
SFree(
    IN PVOID Block
    )
{
    PPREALLOC prealloc;

    if(!Heap) {
        return;
    }

    //
    // See whether the block comes from our prealloced memory.
    //
    for(prealloc=Prealloc; prealloc->BlockSize; prealloc++) {

        if((Block >= prealloc->BaseAddress) && (Block < prealloc->EndAddress)) {

            pFreePreAlloc(prealloc,Block);
            return;
        }
    }

    //
    // Not a preallocated block. Go to the heap.
    //
    HeapFree(Heap,HEAP_NO_SERIALIZE,Block);
}


PVOID
SRealloc(
    IN PVOID Block,
    IN DWORD NewSize
    )
{
    SIZE_T u;
    PVOID p;
    BOOL b;
    PPREALLOC NewPrealloc,OldPrealloc;

    if(!Heap) {
        return(NULL);
    }

    NewPrealloc = NULL;
    OldPrealloc = NULL;
    b = FALSE;

    for(u=0; Prealloc[u].BlockSize; u++) {

        //
        // See whether the original block comes from this prealloc.
        //
        if((OldPrealloc == NULL)
        && (Block >= Prealloc[u].BaseAddress)
        && (Block < Prealloc[u].EndAddress)) {

            OldPrealloc = &Prealloc[u];
        }

        //
        // See whether we have a prealloc block appropriate
        // to satisfy the request. Only the smallest appropriate
        // size is allowed.
        //
        if(!b && (NewSize < Prealloc[u].BlockSize)) {

            //
            // Special case: the old block is from prealloc memory
            // and the same size prealloc block would satisfy the request.
            // Just reuse the existing block.
            //
            if(OldPrealloc == &Prealloc[u]) {
                return(Block);
            }

            if(Prealloc[u].FreeIndex != -1) {
                NewPrealloc = &Prealloc[u];
            }
            b = TRUE;
        }
    }

    //
    // See if the current block is from prealloc memory and we can
    // satisfy the request from a different prealloc block size.
    //
    if(OldPrealloc && NewPrealloc) {

        p = pAllocPreAlloc(NewPrealloc);
        if(!p) {
            //
            // Something is very wrong, because NewPrealloc can be set
            // only if there was a free block!
            //
            return(NULL);
        }

        CopyMemory(p,Block,__min(NewPrealloc->BlockSize,OldPrealloc->BlockSize));

        pFreePreAlloc(OldPrealloc,Block);
        return(p);
    }

    //
    // If the current block is from prealloc memory but we can't
    // satisfy the request from prealloc memory, allocate memory from
    // the heap.
    //
    if(OldPrealloc && !NewPrealloc) {

        if(p = HeapAlloc(Heap,HEAP_NO_SERIALIZE,NewSize)) {

            CopyMemory(p,Block,__min(OldPrealloc->BlockSize,NewSize));
            pFreePreAlloc(OldPrealloc,Block);
        }

        return(p);
    }

    //
    // If the current block is not from prealloc memory and we can
    // satisy the request from prealloc memory, copy the current memory
    // into the prealloc block and return the prealloc block.
    //
    if(!OldPrealloc && NewPrealloc) {

        u = HeapSize(Heap,HEAP_NO_SERIALIZE,Block);
        if(u == (SIZE_T)(-1)) {
            return(NULL);
        }

        p = pAllocPreAlloc(NewPrealloc);
        if(!p) {
            //
            // Something is very wrong, because NewPrealloc can be set
            // only if there was a free block!
            //
            return(NULL);
        }

        CopyMemory(p,Block,__min(u,NewPrealloc->BlockSize));

        HeapFree(Heap,HEAP_NO_SERIALIZE,Block);
        return(p);
    }

    //
    // The current block is not from prealloc memory and there's no
    // preallocated memory to satisfy the request. Pass the request
    // to the heap.
    //
    return(HeapReAlloc(Heap,HEAP_NO_SERIALIZE,Block,NewSize));
}


PVOID
pAllocPreAlloc(
    IN OUT PPREALLOC Prealloc
    )
{
    PVOID p;

    if(Prealloc->FreeIndex == -1) {
        return(NULL);
    }

    //
    // Calculate the address of the block.
    //
    p = (PUCHAR)Prealloc->BaseAddress + (Prealloc->FreeIndex * Prealloc->BlockSize);

    Prealloc->NumUsed++;

    //
    // Mark the block we are going to return as used.
    //
    RtlSetBits(&Prealloc->Bitmap,Prealloc->FreeIndex,1);

    //
    // Locate the next free block. This sets FreeIndex to -1
    // if there are no more free blocks of this size.
    //
    Prealloc->FreeIndex = (LONG)RtlFindClearBits(
                                    &Prealloc->Bitmap,
                                    1,
                                    Prealloc->FreeIndex
                                    );

    return(p);
}


VOID
pFreePreAlloc(
    IN OUT PPREALLOC Prealloc,
    IN     PVOID     p
    )
{
    LONG Index;

    //
    // Figure out which block this is.
    //
    Index = (LONG)((LONG_PTR)p - (LONG_PTR)Prealloc->BaseAddress) / Prealloc->BlockSize;

    Prealloc->NumUsed--;

    //
    // Mark the block free.
    //
    RtlClearBits(&Prealloc->Bitmap,Index,1);
    Prealloc->FreeIndex = Index;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\medtproc.c ===
#include "precomp.h"
#pragma hdrstop
/***************************************************************************/
/****************** Basic Class Dialog Handlers ****************************/
/***************************************************************************/

#define cchpMax 511

/*
**  Purpose:
**      Multi Edit Dialog procedure for templates with multiple edit controls.
**  Control IDs:
**      The Edit controls must have IDs of IDC_EDIT1 to IDC_EDIT10.
**      Pushbuttons recognized are IDC_O, IDC_C, IDC_M, IDC_H, IDC_X, and IDC_B.
**  Initialization:
**      The symbol $(EditTextIn) is used to set the initial text in the Edit
**      controls.  The symbol $(EditTextLim) is used to set the limit of the
**      text in the edit fields.
**  Termination:
**      The strings in the Edit controls are stored in the symbol $(EditTextOut)
**      The id of the Pushbutton (eg IDC_C) which caused termination is
**      converted to a string and stored in the symbol $(ButtonPressed).
**
*****************************************************************************/
INT_PTR APIENTRY
FGstMultiEditDlgProc(
    HWND   hdlg,
    UINT   wMsg,
    WPARAM wParam,
    LPARAM lParam
    )

{
    CHP  rgchNum[10];
    CHP  rgchText[cchpMax + 1];
    RGSZ rgsz, rgszEditTextIn, rgszEditTextLim;
    PSZ  pszEditTextIn, pszEditTextLim;
    SZ   sz, szEditTextIn, szEditTextLim;
    INT  i, nCount, idc;
    INT  DefEditCtl;
    BOOL NeedToSetFocus = FALSE;

    Unused(lParam);

    switch (wMsg) {

    case STF_REINITDIALOG:

        if ((sz = SzFindSymbolValueInSymTab("ReInit")) == (SZ)NULL ||
            (CrcStringCompareI(sz, "YES") != crcEqual)) {
             return(fTrue);
        }

        //
        // See whether we are supposed to set the focus to a certain
        // edit control.
        //

        if((sz = SzFindSymbolValueInSymTab("DefEditCtl")) != NULL) {
            NeedToSetFocus = TRUE;
            DefEditCtl = atoi(sz);
        }

    case WM_INITDIALOG:

        AssertDataSeg();

        FRemoveSymbolFromSymTab("DefEditCtl");

        if( wMsg == WM_INITDIALOG ) {
            FCenterDialogOnDesktop(hdlg);
        }

        //
        // find the initalisers:  EditTextIn, EditTextLim
        //

        szEditTextIn  = SzFindSymbolValueInSymTab("EditTextIn");
        szEditTextLim = SzFindSymbolValueInSymTab("EditTextLim");


        if ( szEditTextIn  == (SZ)NULL ||
             szEditTextLim == (SZ)NULL    ) {

            Assert(fFalse);
            return(fTrue);

        }

        //
        // Convert initializers to rgsz structures
        //

        while ((pszEditTextIn = rgszEditTextIn = RgszFromSzListValue(szEditTextIn)) == (RGSZ)NULL) {
            if (!FHandleOOM(hdlg)) {
                DestroyWindow(GetParent(hdlg));
                return(fTrue);
            }
        }

        while ((pszEditTextLim = rgszEditTextLim = RgszFromSzListValue(szEditTextLim)) == (RGSZ)NULL) {
            if (!FHandleOOM(hdlg)) {
                DestroyWindow(GetParent(hdlg));
                return(fTrue);
            }
        }


        //
        // Circulate through the initialisers:  EditTextIn, EditTextLim
        // in tandem, initialising the edit boxes that
        // are there in this dialog
        //

        idc = IDC_EDIT1;

        while ( (szEditTextIn  = *pszEditTextIn++)  != (SZ)NULL  &&
                (szEditTextLim = *pszEditTextLim++) != (SZ)NULL     ) {

            // First set the limit of the text in the edit field

            SendDlgItemMessage(
                hdlg,
                idc,
                EM_LIMITTEXT,
                atoi(szEditTextLim),
                0L
                );

            // And then set the text in the edit field

            SetDlgItemText(hdlg, idc++, (LPSTR)szEditTextIn);

        }

        EvalAssert(FFreeRgsz(rgszEditTextIn));
        EvalAssert(FFreeRgsz(rgszEditTextLim));

        if(NeedToSetFocus) {
            SetFocus(GetDlgItem(hdlg,IDC_EDIT1+DefEditCtl));
            return(FALSE);
        }

        return(fTrue);

    case WM_CLOSE:
        PostMessage(
            hdlg,
            WM_COMMAND,
            MAKELONG(IDC_X, BN_CLICKED),
            0L
            );
        return(fTrue);


    case WM_COMMAND:
        switch(LOWORD(wParam)) {

        case IDCANCEL:
            if (LOWORD(wParam) == IDCANCEL) {

                if (!GetDlgItem(hdlg, IDC_B) || HIWORD(GetKeyState(VK_CONTROL)) || HIWORD(GetKeyState(VK_SHIFT)) || HIWORD(GetKeyState(VK_MENU)))
                {
                    break;
                }
                wParam = IDC_B;

            }
        case IDC_C:
        case IDC_B:
        case IDC_O:
        case IDC_M:
        case IDC_X:
        case IDC_BTN0:
        case IDC_BTN1: case IDC_BTN2: case IDC_BTN3:
        case IDC_BTN4: case IDC_BTN5: case IDC_BTN6:
        case IDC_BTN7: case IDC_BTN8: case IDC_BTN9:

            // Add the button pressed to the symbol table

            _itoa((INT)wParam, rgchNum, 10);
            while (!FAddSymbolValueToSymTab("ButtonPressed", rgchNum)) {
                if (!FHandleOOM(hdlg)) {
                    DestroyWindow(GetParent(hdlg));
                    return(fTrue);
                }
            }


            // Add EditTextOut list variable to the symbol table

            for (i = 0; i < 10; i++) {
                if (GetDlgItem(hdlg, IDC_EDIT1 + i) == (HWND)NULL) {
                    break;
                }
            }

            // i has the number of edit fields, allocate an rgsz structure
            // with i+1 entries (last one NULL TERMINATOR)

            nCount = i;
            while ((rgsz = (RGSZ)SAlloc((CB)((nCount + 1) * sizeof(SZ))))
                    == (RGSZ)NULL) {
                if (!FHandleOOM(hdlg)) {
                    DestroyWindow(GetParent(hdlg));
                    return(fTrue);
                }
            }

            rgsz[nCount] = (SZ)NULL;

            // Circulate through the edit fields in the dialog box, determining
            // the text in each and storing it in the

            for (i = 0; i < nCount; i++) {

                 SendDlgItemMessage(
                     hdlg,
                     IDC_EDIT1 + i,
                     (WORD)WM_GETTEXT,
                     cchpMax + 1,
                     (LPARAM)rgchText
                     );

                 rgsz[i] = SzDupl(rgchText);
            }


            // Form a list out of the rgsz structure

            while ((sz = SzListValueFromRgsz(rgsz)) == (SZ)NULL) {
                if (!FHandleOOM(hdlg)) {
                    DestroyWindow(GetParent(hdlg));
                    return(fTrue);
                }
            }


            // Set the EditTextOut symbol to this list

            while (!FAddSymbolValueToSymTab("EditTextOut", sz)) {
                if (!FHandleOOM(hdlg)) {
                    DestroyWindow(GetParent(hdlg));
                    return(fTrue);
                }
            }

            EvalAssert(FFreeRgsz(rgsz));
            SFree(sz);

            PostMessage(GetParent(hdlg), (WORD)STF_UI_EVENT, 0, 0L);
            break;
        }
        break;

    case STF_DESTROY_DLG:
        PostMessage(GetParent(hdlg), (WORD)STF_EDIT_DLG_DESTROYED, 0, 0L);
        DestroyWindow(hdlg);
        return(fTrue);
    }

    return(fFalse);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\misc.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    misc.h

Abstract:

    misc stuff

Author:

    Ramon J. San Andres (ramonsa) January 1991

--*/




PVOID
MyMalloc(
    size_t  Size
    );

VOID
MyFree(
    PVOID   p
    );

PVOID
MyRelloc(
    PVOID   p,
    size_t  Size
    );

SZ
SzDup(
    SZ
    );


SZ
SzListValueFromPath(
    SZ      szPath
    );

SZ
SzListValueFromRgsz(
    RGSZ    rgsz
    );

RGSZ
RgszFromSzListValue(
    SZ szListValue
    );

PCHAR
RgszToMultiSz(
    IN RGSZ rgsz
    );

RGSZ
RgszAlloc(
    DWORD   Size
    );

RGSZ
RgszFromPath(
    SZ      szPath
    );

VOID
RgszFree(
    RGSZ    rgsz
    );


VOID
RgszFreeCount(
    RGSZ    rgsz,
    DWORD   Count
    );

BOOL
RgszAdd(
    RGSZ    *prgsz,
    SZ      sz
    );




#define BUFFER_SIZE         1024
#define USER_BUFFER_SIZE    256


typedef struct _TEXTFILE    *PTEXTFILE;
typedef struct _TEXTFILE {
    HANDLE      Handle;
    DWORD       CharsLeftInBuffer;
    SZ          NextChar;
    DWORD       UserBufferSize;
    CHAR        Buffer[BUFFER_SIZE];
    CHAR        UserBuffer[USER_BUFFER_SIZE];
} TEXTFILE;



BOOL
TextFileOpen(
    IN  SZ          szFile,
    OUT PTEXTFILE   pTextFile
    );

BOOL
TextFileClose(
    OUT PTEXTFILE   pTextFile
    );

INT
TextFileReadChar(
    OUT PTEXTFILE   pTextFile
    );

BOOL
TextFileReadLine(
    OUT PTEXTFILE   pTextFile
    );

SZ
TextFileSkipBlanks(
    IN  SZ          sz
    );


SZ
GenerateSortedIntList (
    IN SZ szList,
    BOOL bAscending,
    BOOL bCaseSens
    ) ;

#define TextFileGetLine(p)  ((p)->UserBuffer)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\misccm.c ===
#include "precomp.h"
#pragma hdrstop
/* File: misccm.c */
/**************************************************************************/
/* Install: Misc. commands.
/**************************************************************************/

extern HWND hwndFrame;
extern USHORT APIENTRY DateFromSz(SZ);


/*
**	Purpose:
**		Sets the given environment variable in the given file.
**		Always creates the file or variable if necessary.
**		Only sets the first occurance of the variable.
**	Arguments:
**		Valid command options:
**		    cmoVital
**		    cmoAppend
**		    cmoPrepend
**	Returns:
**		Returns fTrue if successful, fFalse otherwise.
**
**************************************************************************/
BOOL APIENTRY FSetEnvVariableValue(SZ  szFile,
                                               SZ  szVar,
                                               SZ  szValue,
                                               CMO cmo)
{
    Unused(szFile);
    Unused(szVar);
    Unused(szValue);
    Unused(cmo);

	/*** REVIEW: STUB ***/
	Assert(fFalse);
	return(fFalse);
}


/*
**	Purpose:
**		Converts an array of long values into a list and stores in Symbol
**		Table.
**	Arguments:
**		rgl:   full array of longs to create a list out of.
**		szSym: valid symbol name to store list value in.
**		iMax:  count of items in array.
**	Returns:
**		Returns fTrue if successful, fFalse otherwise.
**
**************************************************************************/
BOOL APIENTRY FConvertAndStoreRglInSymTab(PLONG_STF rgl, SZ szSym,
		INT iMax)
{
	RGSZ rgsz;
	INT  il;
	SZ   szList;

	while ((rgsz = (RGSZ)SAlloc((CB)((iMax + 1) * sizeof(SZ)))) == (RGSZ)NULL)
		if (!FHandleOOM(hwndFrame))
			return(fFalse);
	*(rgsz + iMax) = (SZ)NULL;

	for (il = iMax; il-- > 0; )
		{
		CHP rgch[35];

		_ltoa(*(rgl + il), rgch, 10);
		while ((*(rgsz + il) = SzDupl(rgch)) == (SZ)NULL)
			if (!FHandleOOM(hwndFrame))
				return(fFalse);
		}

	while ((szList = SzListValueFromRgsz(rgsz)) == (SZ)NULL)
		if (!FHandleOOM(hwndFrame))
			return(fFalse);
	EvalAssert(FFreeRgsz(rgsz));

	while (!FAddSymbolValueToSymTab(szSym, szList))
		if (!FHandleOOM(hwndFrame))
			return(fFalse);
	SFree(szList);

	return(fTrue);
}


/*
**	Purpose:
**		'Detects' the Free disk space and cluster sizes on all valid drives.
**	Arguments:
**		szFreePerDisk:         valid symbol to store list result in.
**		szClusterBytesPerDisk: valid symbol to store list result in.
**		szFreeTotal:           valid symbol to store result in.
**	Returns:
**		Returns fTrue if successful, fFalse otherwise.  If successful,
**		it associates new values in the Symbol Table.  These values are
**		two lists of 26 long integers and one value.
**
**************************************************************************/
BOOL APIENTRY FSetupGetCopyListCost(SZ szFreePerDisk,
                                                SZ szClusterBytesPerDisk,
                                                SZ szFreeTotal)
{
	LONG rglFree[26];
	LONG rglClusters[26];
	LONG lTotal = 0L;
	INT  il;
    CHP  rgch[35];
    char DiskPath[4] = { 'x',':','\\','\0' };

	ChkArg(szFreePerDisk != (SZ)NULL && *szFreePerDisk != '\0', 1, fFalse);
	ChkArg(szClusterBytesPerDisk != (SZ)NULL
			&& *szClusterBytesPerDisk != '\0', 2, fFalse);
	ChkArg(szFreeTotal != (SZ)NULL && *szFreeTotal != '\0', 3, fFalse);

    for (il=0; il<26; il++)
		{
        DWORD wDriveType;

        rglFree[il]     = 0;
        rglClusters[il] = 4096;

        DiskPath[0] = (CHAR)((UCHAR)il + (UCHAR)'A');

        if ((wDriveType = GetDriveType(DiskPath)) == DRIVE_FIXED
				|| wDriveType == DRIVE_REMOTE)
            {
            DWORD SectorsPerCluster,BytesPerSector,FreeClusters,TotalClusters;

            if(GetDiskFreeSpace(DiskPath,
                                &SectorsPerCluster,
                                &BytesPerSector,
                                &FreeClusters,
                                &TotalClusters))
                {
                rglClusters[il] = BytesPerSector * SectorsPerCluster;
                rglFree[il] = (DWORD)(UInt32x32To64(rglClusters[il], FreeClusters));
                lTotal += rglFree[il];
                }
            }
        }

    if (!FConvertAndStoreRglInSymTab((PLONG_STF)rglFree, szFreePerDisk, 26))
		return(fFalse);

	if (!FConvertAndStoreRglInSymTab((PLONG_STF)rglClusters,
			szClusterBytesPerDisk, 26))
		return(fFalse);

	_ltoa(lTotal, rgch, 10);
	while (!FAddSymbolValueToSymTab(szFreeTotal, rgch))
		if (!FHandleOOM(hwndFrame))
			return(fFalse);

	return(fTrue);
}


/*
**	Purpose:
**		Calculate the 'costs' to copy the current CopyList.
**	Arguments:
**		szTotalAdditionalNeeded: valid symbol to store result in.
**		szTotalNeeded:           valid symbol to store result in.
**		szFreePerDisk:           NULL or valid symbol to get values from.
**		szClusterPerDisk:        NULL or valid symbol to get values from.
**		szTroublePairs:          NULL or valid symbol to store result in.
**		szNeededPerDisk:         NULL or valid symbol to store result in.
**		szExtraCosts:            NULL or valid symbol to get values from.
**	Returns:
**		Returns fTrue if successful, fFalse otherwise.  If successful,
**		it associates new values with szSym in the Symbol Table.
**		This
**		value is a list of 27 long integers of the disk costs per drive.
**		First one is total.
**
**************************************************************************/
BOOL APIENTRY FGetCopyListCost(SZ szTotalAdditionalNeeded,
                                           SZ szFreeTotal,
                                           SZ szTotalNeeded,
                                           SZ szFreePerDisk,
                                           SZ szClusterPerDisk,
                                           SZ szTroublePairs,
                                           SZ szNeededPerDisk,
                                           SZ szExtraCosts)
{
	LONG rglCosts[26];
	LONG rglFree[26];
	LONG rglClusters[26];
	LONG lTotal;
	LONG lTotalAddit;
	LONG lFreeTotal;
	RGSZ rgsz;
	PSZ  psz;
	INT  il;
	CHP  rgchBuf[cchpFullPathBuf];
	SZ   szList;
	PCLN pcln;
	BOOL fFirst;

	ChkArg(szTotalAdditionalNeeded != (SZ)NULL
			&& *szTotalAdditionalNeeded != '\0', 1, fFalse);
	ChkArg(szFreeTotal != (SZ)NULL && *szFreeTotal != '\0', 2, fFalse);
	ChkArg(szTotalNeeded != (SZ)NULL && *szTotalNeeded != '\0', 3, fFalse);

	for (il = 26; il-- > 0; )
		{
		rglCosts[il]    = 0L;
		rglFree[il]     = 0L;
		rglClusters[il] = 4096L;
		}

	if (szFreePerDisk != (SZ)NULL
			&& (szList = SzFindSymbolValueInSymTab(szFreePerDisk)) != (SZ)NULL)
		{
		while ((psz = rgsz = RgszFromSzListValue(szList)) == (RGSZ)NULL)
			if (!FHandleOOM(hwndFrame))
				return(fFalse);

		il = 0;
		while (*psz != (SZ)NULL && il < 26)
			{
			if ((lTotal = atol(*psz++)) > 0L)
				rglFree[il] = lTotal;
			il++;
			}
		EvalAssert(FFreeRgsz(rgsz));
		}

	if (szClusterPerDisk != (SZ)NULL
			&& (szList = SzFindSymbolValueInSymTab(szClusterPerDisk)) !=
					(SZ)NULL)
		{
		while ((psz = rgsz = RgszFromSzListValue(szList)) == (RGSZ)NULL)
			if (!FHandleOOM(hwndFrame))
				return(fFalse);

		il = 0;
		while (*psz != (SZ)NULL && il < 26)
			{
			if ((lTotal = atol(*psz++)) > 15L)
				rglClusters[il] = lTotal;
			il++;
			}
		EvalAssert(FFreeRgsz(rgsz));
		}

	if (szExtraCosts != (SZ)NULL
			&& (szList = SzFindSymbolValueInSymTab(szExtraCosts)) != (SZ)NULL)
		{
		while ((psz = rgsz = RgszFromSzListValue(szList)) == (RGSZ)NULL)
			if (!FHandleOOM(hwndFrame))
				return(fFalse);

		il = 0;
		while (*psz != (SZ)NULL && il < 26)
			{
			if ((lTotal = atol(*psz++)) > 0L)
				rglCosts[il] = lTotal;
			il++;
			}
		EvalAssert(FFreeRgsz(rgsz));
		}

    pcln = *(PpclnHeadList( pLocalInfPermInfo() ));
    while (pcln != (PCLN)NULL) {
		PFH  pfh;
		POER poer = &(pcln->psfd->oer);
		LONG lcbSrc = poer->lSize;
		LONG lcbDest = 0L;
		LONG lcbC;
		CHP  ch;

        EvalAssert(FBuildFullDstPath(rgchBuf, pcln->szDstDir, pcln->psfd, fFalse));
		ch = *rgchBuf;
        if ((pfh = PfhOpenFile(rgchBuf, ofmRead)) != (PFH)NULL){
			OWM owm;

			lcbDest = _filelength(pfh->iDosfh);
            if ((owm = poer->owm) & owmNever){
				lcbSrc = lcbDest = 0L;
				goto LCloseFile;
            }
            else if (owm & owmUnprotected) {
                if (YnrcFileReadOnly(rgchBuf) == ynrcYes){
					lcbSrc = lcbDest = 0L;
					goto LCloseFile;
                }
            }
            else if (owm & owmOlder) {
				if (YnrcNewerExistingFile(DateFromSz(poer->szDate), rgchBuf,
                        poer->ulVerMS, poer->ulVerLS) == ynrcYes){
					lcbSrc = lcbDest = 0L;
					goto LCloseFile;
                }
            }

			if (poer->szBackup != (SZ)NULL
					&& FBuildFullBakPath(rgchBuf, rgchBuf, pcln->psfd)
					&& FValidPath(rgchBuf)
					&& PfhOpenFile(rgchBuf, ofmExistRead) == (PFH)NULL)
				lcbDest = 0L;

LCloseFile:
			EvalAssert(FCloseFile(pfh));
        }

        if (ch >= 'a' && ch <= 'z') {
            il = ch - 'a';
        }
        else if (ch >= 'A' && ch <= 'Z') {
            il = ch - 'A';
        }
        else {
            il = - 1;
        }

        //
        // Note that we are worrying about costs only on drives, no UNC path
        // costs are determined
        //

        if( il != -1 ) {
            /* round up with cluster size */
            lcbC = rglClusters[il];
            Assert(lcbC > 1L);

            lcbSrc  = ((lcbSrc  + lcbC - 1) / lcbC) * lcbC;
            lcbDest = ((lcbDest + lcbC - 1) / lcbC) * lcbC;
            rglCosts[il] += lcbSrc - lcbDest;
            /* REVIEW what we really want to determine is the max not the end */
        }

		pcln = pcln->pclnNext;
    }

	if (szTroublePairs != (SZ)NULL)
		{
		while ((szList = (SZ)SAlloc((CB)4096)) == (SZ)NULL)
			if (!FHandleOOM(hwndFrame))
				return(fFalse);
		EvalAssert(strcpy(szList, "{") == (LPSTR)szList);
		fFirst = fTrue;
		}

	lTotal      = 0L;
	lTotalAddit = 0L;
	lFreeTotal  = 0L;
	for (il = 0; il < 26; il++)
		{
		LONG lNeeded = rglCosts[il] - rglFree[il];

		if (rglCosts[il] != 0L)
			{
			lTotal += rglCosts[il];
			lFreeTotal += rglFree[il];
			}
		if (lNeeded > 0L)
			{
			lTotalAddit += lNeeded;
			if (szTroublePairs != (SZ)NULL)
				{
				if (!fFirst)
					EvalAssert(SzStrCat(szList, ",") == (LPSTR)szList);
				fFirst = fFalse;
				EvalAssert(SzStrCat(szList, "\"{\"\"") == (LPSTR)szList);
				rgchBuf[0] = (CHP)(il + 'A');
				rgchBuf[1] = ':';
				rgchBuf[2] = '\0';
				EvalAssert(SzStrCat(szList, rgchBuf) == (LPSTR)szList);
				EvalAssert(SzStrCat(szList, "\"\",\"\"") == (LPSTR)szList);
				_ltoa(lNeeded, rgchBuf, 10);
				EvalAssert(SzStrCat(szList, rgchBuf) == (LPSTR)szList);
				EvalAssert(SzStrCat(szList, "\"\"}\"") == (LPSTR)szList);
				}
			}
		}

	if (szTroublePairs != (SZ)NULL)
		{
		EvalAssert(SzStrCat(szList, "}") == (LPSTR)szList);
		while (!FAddSymbolValueToSymTab(szTroublePairs, szList))
			if (!FHandleOOM(hwndFrame))
				{
				SFree(szList);
				return(fFalse);
				}
		SFree(szList);
		}

	_ltoa(lTotalAddit, rgchBuf, 10);
	while (!FAddSymbolValueToSymTab(szTotalAdditionalNeeded, rgchBuf))
		if (!FHandleOOM(hwndFrame))
			return(fFalse);

	_ltoa(lFreeTotal, rgchBuf, 10);
	while (!FAddSymbolValueToSymTab(szFreeTotal, rgchBuf))
		if (!FHandleOOM(hwndFrame))
			return(fFalse);

	_ltoa(lTotal, rgchBuf, 10);
	while (!FAddSymbolValueToSymTab(szTotalNeeded, rgchBuf))
		if (!FHandleOOM(hwndFrame))
			return(fFalse);

	if (!FConvertAndStoreRglInSymTab((PLONG_STF)rglCosts, szNeededPerDisk, 26))
		return(fFalse);

	return(fTrue);
}


/*
**	Purpose:
**	Arguments:
**	Returns:
**		Returns non-NULL if successful, NULL otherwise.
**
**************************************************************************/
SZ APIENTRY SzFindNthIniField(SZ szLine,INT iField)
{
	ChkArg(szLine != (SZ)NULL, 1, (SZ)NULL);
	ChkArg(iField > 0, 2, (SZ)NULL);

LSkipWhiteSpace:
	while (FWhiteSpaceChp(*szLine))
		szLine = SzNextChar(szLine);

	if (*szLine == '\0')
		return((SZ)NULL);

	if (iField-- <= 1)
		if (*szLine == ',')
			return((SZ)NULL);
		else
			return(szLine);

	while (*szLine != ',' && *szLine != '\0')
		szLine = SzNextChar(szLine);

	if (*szLine == ',')
		szLine = SzNextChar(szLine);

	goto LSkipWhiteSpace;
}


#define szIniKey     (*rgszItem)
#define szIniSect    (*(rgszItem + 1))
#define szIniValue   (*(rgszItem + 2))
#define szListFiles  (*(rgszItem + 3))

#define szFileIndex  (*rgszFile)
#define szFileName   (*(rgszFile + 1))
#define szSubDir     (*(rgszFile + 2))
#define szFileSym    (*(rgszFile + 3))
#define szPathSym    (*(rgszFile + 4))

#define cchpIniLineMax 511

/*
**	Purpose:
**		Parses a shared app list to fill symbols with found paths.
**	Arguments:
**		szList: list of shared app structures to deal with.
**	Returns:
**		Returns fTrue if successful, fFalse otherwise.
**
**************************************************************************/
BOOL APIENTRY FParseSharedAppList(SZ szList)
{
#ifdef UNUSED
	RGSZ rgsz = NULL;
	RGSZ rgszItem = NULL;
	RGSZ rgszFiles = NULL;
	RGSZ rgszFile = NULL;
	PSZ  psz;
	CHP  rgchWinDir[154];  /* SDK Reference Volume 1 page 4-229 */
			/* 144 + "/msapps/" + NULL + 1extra */
    unsigned cchpWinDir;

	ChkArg(szList != (SZ)NULL && FListValue(szList), 1, fFalse);

    EvalAssert( ((cchpWinDir = GetWindowsDirectory(rgchWinDir, 153)) != 0)
            && (cchpWinDir < 145)
            && (rgchWinDir[cchpWinDir] == (CHP)'\0'));
	if (rgchWinDir[cchpWinDir - 1] == '\\')
		{
		Assert(cchpWinDir == 3);
		rgchWinDir[--cchpWinDir] = '\0';
		}
	Assert(cchpWinDir + strlen("\\msapps\\") + 1 <= 153);
	EvalAssert(SzStrCat(rgchWinDir, "\\msapps\\") == (LPSTR)rgchWinDir);
	cchpWinDir += 8;

	while ((psz = rgsz = RgszFromSzListValue(szList)) == (RGSZ)NULL)
		if (!FHandleOOM(hwndFrame))
			goto LParseErrorExit;

	while (*psz != (SZ)NULL)
		{
		PSZ pszFile;
		CHP rgchIniLine[cchpIniLineMax + 1];

		ChkArg(FListValue(*psz), 1, fFalse);
		while ((rgszItem = RgszFromSzListValue(*psz)) == (RGSZ)NULL)
			if (!FHandleOOM(hwndFrame))
				goto LParseErrorExit;

		ChkArg(szIniKey != NULL && szIniSect != NULL && szIniValue != NULL
				&& szListFiles != NULL && FListValue(szListFiles), 1, fFalse);

		EvalAssert(GetProfileString(szIniSect, szIniKey, "", rgchIniLine,
				cchpIniLineMax) != cchpIniLineMax);

		while ((rgszFiles = RgszFromSzListValue(szListFiles)) == (RGSZ)NULL)
			if (!FHandleOOM(hwndFrame))
				goto LParseErrorExit;

		pszFile = rgszFiles;
		while (*pszFile != (SZ)NULL)
			{
			CHP rgchPathBuf[256];
			SZ  szField;

			ChkArg(FListValue(*pszFile), 1, fFalse);
			while ((rgszFile = RgszFromSzListValue(*pszFile)) == (RGSZ)NULL)
				if (!FHandleOOM(hwndFrame))
					goto LParseErrorExit;

			ChkArg(szFileIndex != NULL && szFileName != NULL && szSubDir != NULL
					&& szFileSym != NULL && szPathSym != NULL, 1, fFalse);

			Assert(cchpWinDir + strlen(szSubDir) + 2 <= 240);
			EvalAssert(strcpy(rgchPathBuf,rgchWinDir) == (LPSTR)rgchPathBuf);
			EvalAssert(SzStrCat(rgchPathBuf, szSubDir) == (LPSTR)rgchPathBuf);

			if ((szField = SzFindNthIniField(rgchIniLine, atoi(szFileIndex)))
					!= (SZ)NULL)
				{
				SZ  szEndOfField = szField;
				CHP chpSav;

				while (*szEndOfField != ',' && *szEndOfField != '\0')
					szEndOfField = SzNextChar(szEndOfField);

				chpSav = *szEndOfField;
				*szEndOfField = '\0';

				if (FValidPath(szField)
						&& PfhOpenFile(szField, ofmExistRead) != (PFH)NULL)
					{
					SZ szSlash = (SZ)NULL;

					*szEndOfField = chpSav;
					szEndOfField = szField;

					while (*szEndOfField != ',' && *szEndOfField != '\0')
						{
						if (*szEndOfField == '\\')
							szSlash = szEndOfField;
						szEndOfField = SzNextChar(szEndOfField);
						}

					Assert(szSlash != (SZ)NULL && *szSlash == '\\');
					chpSav = *(szEndOfField = szSlash);
					*szEndOfField = '\0';

					Assert(strlen(szField) + 2 <= 240);
					EvalAssert(strcpy(rgchPathBuf, szField) ==
							(LPSTR)rgchPathBuf);
					}

				*szEndOfField = chpSav;
				}

			if (rgchPathBuf[strlen(rgchPathBuf)] != '\\')
				EvalAssert(SzStrCat(rgchPathBuf, "\\") == (LPSTR)rgchPathBuf);

			while (!FAddSymbolValueToSymTab(szPathSym, rgchPathBuf))
				if (!FHandleOOM(hwndFrame))
					goto LParseErrorExit;

			Assert(strlen(rgchPathBuf) + strlen(szFileName) + 1 <= 256);
			EvalAssert(SzStrCat(rgchPathBuf, szFileName) == (LPSTR)rgchPathBuf);

			while (!FAddSymbolValueToSymTab(szFileSym, rgchPathBuf))
				if (!FHandleOOM(hwndFrame))
					goto LParseErrorExit;

			EvalAssert(FFreeRgsz(rgszFile));
			rgszFile = NULL;
			pszFile++;
			}

		EvalAssert(FFreeRgsz(rgszFiles));
		rgszFiles = NULL;
		EvalAssert(FFreeRgsz(rgszItem));
		rgszItem = NULL;
		psz++;
		}

	EvalAssert(FFreeRgsz(rgsz));
	rgsz = NULL;

	return(fTrue);

LParseErrorExit:
	EvalAssert(rgsz      == NULL || FFreeRgsz(rgsz));
	EvalAssert(rgszFile  == NULL || FFreeRgsz(rgszFile));
	EvalAssert(rgszFiles == NULL || FFreeRgsz(rgszFiles));
	EvalAssert(rgszItem  == NULL || FFreeRgsz(rgszItem));

#endif /* UNUSED */
    Unused(szList);
	return(fFalse);
}


/*
**	Purpose:
**		Installs relevant lines from a shared app list into the WIN.INI.
**	Arguments:
**		szList: list of shared app structures to deal with.
**	Returns:
**		Returns fTrue if successful, fFalse otherwise.
**
**************************************************************************/
BOOL APIENTRY FInstallSharedAppList(SZ szList)
{
#ifdef UNUSED
	RGSZ rgsz = NULL;
	RGSZ rgszItem = NULL;
	PSZ  psz;

	ChkArg(szList != (SZ)NULL && FListValue(szList), 1, fFalse);

	while ((psz = rgsz = RgszFromSzListValue(szList)) == (RGSZ)NULL)
		if (!FHandleOOM(hwndFrame))
			goto LInstallErrorExit;

	while (*psz != (SZ)NULL)
		{
		SZ szNewLine;

		ChkArg(FListValue(*psz), 1, fFalse);
		while ((rgszItem = RgszFromSzListValue(*psz)) == (RGSZ)NULL)
			if (!FHandleOOM(hwndFrame))
				goto LInstallErrorExit;

		ChkArg(szIniKey != NULL && szIniSect != NULL && szIniValue != NULL
				&& szListFiles != NULL && FListValue(szListFiles), 1, fFalse);

		if ((szNewLine = SzProcessSzForSyms(hwndFrame, szIniValue)) == (SZ)NULL)
			goto LInstallErrorExit;

		if (!FCreateIniSection("WIN.INI", szIniSect, cmoVital)
				|| !FCreateIniKeyValue("WIN.INI", szIniSect, szIniKey,
					szNewLine, cmoOverwrite | cmoVital))
			{
			SFree(szNewLine);
			goto LInstallErrorExit;
			}

		SFree(szNewLine);
		EvalAssert(FFreeRgsz(rgszItem));
		rgszItem = NULL;
		psz++;
		}

	EvalAssert(FFreeRgsz(rgsz));
	rgsz = NULL;

	return(fTrue);

LInstallErrorExit:
	EvalAssert(rgsz      == NULL || FFreeRgsz(rgsz));
	EvalAssert(rgszItem  == NULL || FFreeRgsz(rgszItem));

#endif /* UNUSED */
    Unused(szList);
	return(fFalse);
}

#undef szIniKey
#undef szIniSect
#undef szIniValue
#undef szListFiles

#undef szFileIndex
#undef szFileName
#undef szSubDir
#undef szFileSym
#undef szPathSym
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\misc.c ===
#include "precomp.h"
#pragma hdrstop
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    misc.c

Abstract:

    Misc stuff

Author:

    Ramon J. San Andres (ramonsa) January 1991

--*/


//*************************************************************************
//
//                          Strings
//
//*************************************************************************


SZ
SzDup(
    SZ  sz
    )
{
    SZ  NewSz = NULL;

    if ( sz ) {

        if ( (NewSz = (SZ)SAlloc( strlen(sz) + 1 )) ) {

            strcpy( NewSz, sz );
        }
    }

    return NewSz;
}



SZ
SzListValueFromPath(
    SZ      szPath
    )
{
    RGSZ    rgszPath;
    SZ      szList = NULL;

    if ( rgszPath = RgszFromPath( szPath ) ) {

        szList = SzListValueFromRgsz( rgszPath );

        RgszFree( rgszPath );
    }

    return szList;
}



//*************************************************************************
//
//                      RGSZ management
//
//*************************************************************************



RGSZ
RgszAlloc(
    DWORD   Size
    )
{
    RGSZ    rgsz = NULL;
    DWORD   i;

    if ( Size > 0 ) {

        if ( (rgsz = SAlloc( Size * sizeof(SZ) )) ) {

            for ( i=0; i<Size; i++ ) {
                rgsz[i] = NULL;
            }
        }
    }

    return rgsz;
}


RGSZ
RgszFromPath(
    SZ      szPath
    )

/*
 * History: SUNILP Modified to return NULL elements and also semicolons at
 *          the end.
 */

{
    RGSZ    rgsz;
    SZ      pBegin, pLast, pEnd;
    SZ      sz;
    BOOL    fOkay = fTrue;

    if (rgsz = RgszAlloc(1)) {

        pBegin   = szPath;
        pLast    = pBegin + strlen( pBegin );

        do {

            pEnd = strchr(pBegin, ';' );

            if ( pEnd == NULL ) {
                pEnd = pBegin + strlen( pBegin );
            }
            *pEnd = '\0';

            if ( !(sz = SzDup( pBegin )) ) {
                fOkay = fFalse;
                break;
            }

            if ( !RgszAdd( &rgsz, sz ) ) {
                SFree( sz );
                fOkay = fFalse;
                break;
            }

            pBegin = pEnd+1;

        } while ( pBegin <= pLast );

        if ( !fOkay ) {
            RgszFree( rgsz );
            rgsz = NULL;
        }
    }

    return rgsz;
}





VOID
RgszFree(
    RGSZ    rgsz
    )
{

    INT i;

    for (i = 0; rgsz[i]; i++ ) {
        SFree( rgsz[i] );
    }

    SFree(rgsz);
}



VOID
RgszFreeCount(
    RGSZ    rgsz,
    DWORD   Count
    )
{

    DWORD i;

    for (i = 0; i<Count; i++ ) {
        if ( rgsz[i] ) {
            SFree( rgsz[i] );
        }
    }

    SFree(rgsz);
}

DWORD
RgszCount(
    RGSZ    rgsz
    )
    /*
        Return the number of elements in an RGSZ
     */
{
    DWORD i ;

    for ( i = 0 ; rgsz[i] ; i++ ) ;

    return i ;
}






BOOL
RgszAdd(
    RGSZ    *prgsz,
    SZ      sz
    )
{
    INT     i;
    RGSZ    rgszNew;

    for ( i=0; (*prgsz)[i]; i++ ) {
    }

    rgszNew = SRealloc( *prgsz, (i+2)*sizeof(SZ) );

    if ( rgszNew ) {

        rgszNew[i]   = sz;
        rgszNew[i+1] = NULL;

        *prgsz = rgszNew;

        return fTrue;
    }

    return fFalse;
}



#define  cListItemsMax  0x07FF
#define  cbItemMax      (CB)0x2000


//
// #ifdef'ed out: overlapped with oldexe
//
#if 0

/*
**  Purpose:
**      Determines if a string is a list value.
**  Arguments:
**      szValue: non-NULL, zero terminated string to be tested.
**  Returns:
**      fTrue if a list; fFalse otherwise.
**
**************************************************************************/
BOOL FListValue(szValue)
SZ szValue;
{

    if (*szValue++ != '{')
        return(fFalse);

    while (*szValue != '}' && *szValue != '\0')
        {
        if (*szValue++ != '"')
            return(fFalse);

        while (*szValue != '\0')
            {
            if (*szValue != '"')
                szValue = SzNextChar(szValue);
            else if (*(szValue + 1) == '"')
                szValue += 2;
            else
                break;
            }

        if (*szValue++ != '"')
            return(fFalse);

        if (*szValue == ',')
            if (*(++szValue) == '}')
                return(fFalse);
        }

    if (*szValue != '}')
        return(fFalse);

    return(fTrue);
}




""
#define  cbListMax    (CB)0x2000


/*
**  Purpose:
**      Converts an RGSZ into a list value.
**  Arguments:
**      rgsz: non-NULL, NULL-terminated array of zero-terminated strings to
**          be converted.
**  Returns:
**      NULL if an error occurred.
**      Non-NULL SZ if the conversion was successful.
**
**************************************************************************/
SZ  SzListValueFromRgsz(rgsz)
RGSZ rgsz;
{
    SZ   szValue;
    SZ   szAddPoint;
    SZ   szItem;
    BOOL fFirstItem = fTrue;

    //ChkArg(rgsz != (RGSZ)NULL, 1, (SZ)NULL);

    if ((szAddPoint = szValue = (SZ)SAlloc(cbListMax)) == (SZ)NULL)
        return((SZ)NULL);

    *szAddPoint++ = '{';
    while ((szItem = *rgsz) != (SZ)NULL)
        {
        if (fFirstItem)
            fFirstItem = fFalse;
        else
            *szAddPoint++ = ',';

        *szAddPoint++ = '"';
        while (*szItem != '\0')
            {
            if (*szItem == '"')
                {
                *szAddPoint++ = '"';
                *szAddPoint++ = '"';
                szItem++;
                }
            else
                {
                SZ szNext = SzNextChar(szItem);

                while (szItem < szNext)
                    *szAddPoint++ = *szItem++;
                }
            }

        *szAddPoint++ = '"';
        rgsz++;
        }

    *szAddPoint++ = '}';
    *szAddPoint = '\0';

    //AssertRet(strlen(szValue) < cbListMax, (SZ)NULL);
    szItem = SzDup(szValue);
    SFree(szValue);

    return(szItem);
}

/*
**  Purpose:
**      Converts a list value into an RGSZ.
**  Arguments:
**      szListValue: non-NULL, zero terminated string to be converted.
**  Returns:
**      NULL if an error occurred.
**      Non-NULL RGSZ if the conversion was successful.
**
**************************************************************************/
RGSZ  RgszFromSzListValue(szListValue)
SZ szListValue;
{
    USHORT cItems;
    SZ     szCur;
    RGSZ   rgsz;


    if (!FListValue(szListValue))
        {
        if ((rgsz = (RGSZ)SAlloc((CB)(2 * sizeof(SZ)))) == (RGSZ)NULL ||
                (rgsz[0] = SzDup(szListValue)) == (SZ)NULL)
            return((RGSZ)NULL);
        rgsz[1] = (SZ)NULL;
        return(rgsz);
        }

    if ((rgsz = (RGSZ)SAlloc((CB)((cListItemsMax + 1) * sizeof(SZ)))) ==
            (RGSZ)NULL)
        return((RGSZ)NULL);

    cItems = 0;
    szCur = szListValue + 1;

    while (*szCur != '}' &&
           *szCur != '\0' &&
            cItems < cListItemsMax)
    {
            SZ szValue;
        SZ szAddPoint;

            if( *szCur != '"' ) {
                return( (RGSZ) NULL );
            }

        szCur++;
        if ((szAddPoint = szValue = (SZ)SAlloc(cbItemMax)) == (SZ)NULL)
            {
            rgsz[cItems] = (SZ)NULL;
            RgszFree(rgsz);
            return((RGSZ)NULL);
            }

        while (*szCur != '\0')
            {
            if (*szCur == '"')
                {
                if (*(szCur + 1) != '"')
                    break;
                szCur += 2;
                *szAddPoint++ = '"';
                }
            else
                {
                SZ szNext = SzNextChar(szCur);

                while (szCur < szNext)
                    *szAddPoint++ = *szCur++;
                }
            }

        *szAddPoint = '\0';

        if (*szCur++ != '"' ||
                lstrlen(szValue) >= cbItemMax ||
                (szAddPoint = SzDup(szValue)) == (SZ)NULL)
            {
            SFree(szValue);
            rgsz[cItems] = (SZ)NULL;
            RgszFree(rgsz);
            return((RGSZ)NULL);
            }

        SFree(szValue);

        if (*szCur == ',')
            szCur++;
        rgsz[cItems++] = szAddPoint;
    }

    rgsz[cItems] = (SZ)NULL;

    if (*szCur != '}' || cItems >= cListItemsMax)
    {
        RgszFree(rgsz);
        return((RGSZ)NULL);
    }

    if (cItems < cListItemsMax)
        rgsz = (RGSZ)SRealloc((PB)rgsz, (CB)((cItems + 1) * sizeof(SZ)));

    return(rgsz);
}



LPSTR
RgszToMultiSz(
    IN RGSZ rgsz
    )
{
    ULONG Size;
    ULONG Str;
    LPSTR MultiSz;

    //
    // First determine the size of the block to hold the multisz.
    //

    Size = 0;
    Str = 0;

    while(rgsz[Str]) {

        Size += strlen(rgsz[Str++]) + 1;
    }

    Size++;     // for extra NUL to terminate the multisz.

    MultiSz = SAlloc(Size);

    if(MultiSz == NULL) {
        return(NULL);
    }

    Str = 0;
    Size = 0;

    while(rgsz[Str]) {

        lstrcpy(MultiSz + Size, rgsz[Str]);

        Size += lstrlen(rgsz[Str++]) + 1;
    }

    MultiSz[Size] = 0;

    return(MultiSz);
}
#endif


// ***************************************************************************
//
//                  Text file manipulation functions
//
// ***************************************************************************




//
//  Opens a text file
//
BOOL
TextFileOpen(
    IN  SZ          szFile,
    OUT PTEXTFILE   pTextFile
    )
{
    BOOL    fOkay = fFalse;


    pTextFile->Handle = CreateFile( szFile,
                                    GENERIC_READ,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    0,
                                    NULL );


    if ( pTextFile->Handle != INVALID_HANDLE_VALUE ) {

        pTextFile->UserBufferSize    = USER_BUFFER_SIZE;
        pTextFile->CharsLeftInBuffer = 0;
        pTextFile->NextChar          = pTextFile->Buffer;

        fOkay = fTrue;

    }

    return fOkay;
}



//
//  Closes a text file
//
BOOL
TextFileClose (
    OUT PTEXTFILE   pTextFile
    )
{

    CloseHandle( pTextFile->Handle );

    return fTrue;
}



//
//  Reads one character
//
INT
TextFileReadChar (
    OUT PTEXTFILE   pTextFile
    )
{
    //
    //  Check to see if buffer is empty
    //

    if (pTextFile->CharsLeftInBuffer == 0) {

        //
        //  Check to see if a fill of the buffer fails
        //

        if (!ReadFile (pTextFile->Handle, pTextFile->Buffer, BUFFER_SIZE, &pTextFile->CharsLeftInBuffer, NULL)) {

            //
            //  Fill failed, indicate buffer is empty and return EOF
            //

            pTextFile->CharsLeftInBuffer = 0;
            return -1;
        }

        //
        //  Check to see if nothing read
        //
        if (pTextFile->CharsLeftInBuffer == 0) {
            return -1;
        }

        pTextFile->NextChar = pTextFile->Buffer;
    }

    //
    //  Buffer has pTextFile->CharsLeftInBuffer chars left starting at
    //  pTextFile->NextChar
    //
    pTextFile->CharsLeftInBuffer--;
    return *pTextFile->NextChar++;
}


//
//  Read one line
//
BOOL
TextFileReadLine (
    OUT PTEXTFILE   pTextFile
    )
{
    PCHAR p;
    PCHAR pEnd;

    INT c;

    //
    //  Set pointer to beginning of output buffer
    //
    p    = pTextFile->UserBuffer;
    pEnd = p + pTextFile->UserBufferSize - 1;

    //
    //  read in chars, ignoring \r until buffer is full, \n, or \0
    //

    while (p < pEnd) {

        c = TextFileReadChar (pTextFile);

        if ((CHAR)c == '\r') {
            continue;
        }

        if (c == -1 || (CHAR)c == '\n') {
            break;
        }

        *p++ = (CHAR)c;
    }

    *p = '\0';

    return ( (c != -1) || (strlen (pTextFile->UserBuffer) != 0) );
}



//
//  Skip blanks
//
SZ
TextFileSkipBlanks(
    IN  SZ          sz
    )
{
    size_t  Idx;

    Idx = strspn( sz, " \t" );

    if ( Idx < strlen(sz) ) {
        return sz + Idx;
    }

    return NULL;
}


static long cvtToLong ( SZ sz )
{
    static char * chHex = "0123456789ABCDEF" ;
    static char * chDec = "0123456789" ;
    char * chTbl = chDec ;
    int base = 10 ;
    long result ;
    BOOL ok = FALSE ;

    while ( *sz == ' ' )
       sz++ ;

    if ( sz[0] == '0' && toupper( sz[1] ) == 'X' )
    {
        base = 16 ;
        chTbl = chHex ;
        sz++ ;
    }

    for ( result = 0 ; *sz ; sz++, ok = TRUE )
    {
        char * pch = strchr( chTbl, toupper( *sz ) ) ;
        if ( pch == NULL )
            break ;
        result = result * base + (long)(pch - chTbl) ;
    }

    return ok ? result : -1 ;
}

typedef struct {
    SZ  szItem ;
    DWORD dwIndex ;
    LONG lValue ;
} RGSZ_INT_SORT ;


static BOOL bQsortAscending ;
static BOOL bQsortCaseSens ;
static BOOL bQsortNumeric ;

   //  Compare two RGSZ_INT_SORT items

static int __cdecl compareRgi ( const void * p1, const void * p2 )
{
    INT i ;
    RGSZ_INT_SORT * pr1 = (RGSZ_INT_SORT *) p1 ;
    RGSZ_INT_SORT * pr2 = (RGSZ_INT_SORT *) p2 ;
    SZ sz1 = pr1->szItem ;
    SZ sz2 = pr2->szItem ;

    if ( bQsortNumeric )
    {
        i = pr1->lValue < pr2->lValue
          ? -1
          : (pr1->lValue != pr2->lValue) ;
    }
    else
    if ( bQsortCaseSens )
    {
        i = lstrcmp( sz1, sz2 ) ;
    }
    else
    {
        i = lstrcmpi( sz1, sz2 ) ;
    }

    if ( ! bQsortAscending )
        i *= -1 ;

    return i ;
}

static SZ szFromDword ( DWORD dw )
{
    char chBuffer [50] ;
    SZ szInt ;

    sprintf( chBuffer, "%ld", dw ) ;

    szInt = SAlloc( strlen( chBuffer ) + 3 ) ;

    if ( szInt == NULL )
        return NULL ;

    strcpy( szInt, chBuffer ) ;
    return szInt ;
}

SZ
GenerateSortedIntList (
    IN SZ szList,
    BOOL bAscending,
    BOOL bCaseSens
    )
 /*
    Given an INF list in standard form, return a list of its element
    numbers (1-based) as they would occur if the list were sorted.

    Sort the list as numeric (decimal or hex) if "case sensitive" is
    FALSE and EVERY list item can be converted to a valid non-empty
    number (i.e., at least one valid digit).  Hex values must be
    prefixed with "0x" or "0X".

    Algorithm:  Create an RGSZ from the list
                Create an array containing ordered pairs; one pair
                    member points to the SZ in question, and the other
                    has the number of the element in its original position.

                Use qsort and lstrcmp{i}() to sort the array.

                Generate a new RGSZ using ASCII decimal versions of the
                    integer element position.

                Convert the RGSZ result into an INF list.

                Return it.

     For example:      {"dog","cat","bird"}
      results in:      {"3","2","1"}

  */
{
    RGSZ rgszIn = NULL ;
    RGSZ rgszIntList = NULL ;
    SZ szResult = NULL ;
    DWORD dwCount, dwi, dwNumeric ;

    RGSZ_INT_SORT * prgiSort = NULL ;

    do // Pseudo loop
    {
        //  Convert the input list to RGSZ (list of strings) format

        rgszIn = RgszFromSzListValue( szList ) ;
        if ( rgszIn == NULL )
            break ;

        //  Count the number of items; return the empty list if
        //  input list is empty.

        if ( (dwCount = RgszCount( rgszIn )) == 0 )
        {
            szResult = SzListValueFromRgsz( rgszIn ) ;
            break ;
        }

        //  Allocate the intermediate sort array

        prgiSort = (RGSZ_INT_SORT *) SAlloc( dwCount * sizeof (RGSZ_INT_SORT) ) ;
        if ( prgiSort == NULL )
            break ;


        //  Fill the sort array with string pointers and indices
        //  Check to see if every entry can be converted to numbers.

        for ( dwNumeric = dwi = 0 ; dwi < dwCount ; dwi++ )
        {
            prgiSort[dwi].szItem  = rgszIn[dwi] ;
            prgiSort[dwi].dwIndex = dwi + 1 ;

            if ( ! bCaseSens )
            {
                if ( (prgiSort[dwi].lValue = cvtToLong( rgszIn[dwi] )) >= 0 )
                    dwNumeric++ ;
            }
        }

        //  Sort

        bQsortAscending = bAscending ;
        bQsortCaseSens  = bCaseSens ;
        bQsortNumeric   = dwNumeric == dwCount ;

        qsort( (PVOID) prgiSort, dwCount, sizeof *prgiSort, compareRgi ) ;

        //  Allocate an RGSZ to convert the DWORDs into an INF list

        rgszIntList = SAlloc( sizeof (SZ) * (dwCount + 1) ) ;
        if ( rgszIntList == NULL )
            break ;

        //  Fill the RGSZ with string representations of the integers.

        for ( dwi = 0 ; dwi < dwCount ; dwi++ )
        {
            rgszIntList[dwi] = szFromDword( prgiSort[dwi].dwIndex ) ;
            if ( rgszIntList[dwi] == NULL )
                break ;
        }

        //  Delimit the new RGSZ

        rgszIntList[dwi] = NULL ;

        if ( dwi < dwCount )
            break ;

        //  Convert to INF list format

        szResult = SzListValueFromRgsz( rgszIntList ) ;

    } while ( FALSE ) ;

    if ( rgszIn )
    {
        RgszFree( rgszIn ) ;
    }
    if ( rgszIntList )
    {
        RgszFree( rgszIntList ) ;
    }
    if ( prgiSort )
    {
        SFree(prgiSort);
    }

    return szResult ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\msgbox.c ===
#include "precomp.h"
#pragma hdrstop
/**************************************************************************/
/***** Common Library Component - Extended Message Box routine ************/
/**************************************************************************/


/*
**	Purpose:
**		To load strings from the string table and use them to display a
**		message box.
**	Arguments:
**		hInstance:  identifies an instance of the module whose executable
**			file contains the string resource.
**		hwndParent: identifies the window handle that owns the message box
**		idsText:    the identifier that identifies the string from the string
**			table that contains the message to be displayed. This
**			string must be less than 256 characters in length.
**		idsCaption: identifies the string from the string table that contains
**			the string that will be used as the caption.  This caption
**			must be less than 1024 characters in length. if idsCaption
**			is NULL the caption "Error" will be used.
**		wType:      specifies the contents of the message box.  See table
**			4.11 "Message Box Types" in the Win 3.0 SDK Documentation.
**		Returns:    IDABORT, IDCANCEL, IDIGNORE, IDNO, IDOK, IDRETRY, or
**			IDYES.  See the MessageBox return values in the Win 3.0
**			SDK docs.
****************************************************************************/
int APIENTRY ExtMessageBox(HANDLE hInstance, HWND hwndParent,
		WORD idsText, WORD idsCaption, WORD wType)
{
	CHL  szText[1024];
	CHL  szCaption[256];
	int  iRet;
	HWND hwndSav;

	ChkArg(hInstance , 1, -1);
	ChkArg(hwndParent, 2, -1);
	ChkArg(idsText	 , 3, -1);

	EvalAssert(LoadString(hInstance, idsText, (LPSTR)szText, 1024));
	EvalAssert(LoadString(hInstance, idsCaption, (LPSTR)szCaption, 256));

	hwndSav = GetFocus();
	iRet = MessageBox(hwndParent, (LPSTR)szText, (LPSTR)szCaption, wType);
	SetFocus(hwndSav);
	SendMessage(hwndParent, WM_NCACTIVATE, 1, 0L);

	return(iRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\nls.c ===
#include "precomp.h"
#pragma hdrstop
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    nls.c

Abstract:

    NLS related routines in the setupdll

    Detect Routines:
    ----------------

    Install Routines Workers:
    -------------------------

    1. SetCurrentLocaleWorker: To set the values associated with the
       current locale in the cpanel area of the registry.

    //
    // Fill up the current structure with the values that we need:
    //
    // Field Name       LcType                      Example
    // ----------       -------                     -------
    // sLanguage    =   LOCALE_SABBREVLANGNAME,     ENU
    // sCountry     =   LOCALE_SCOUNTRY,            United States
    // iCountry     =   LOCALE_ICOUNTRY,            1
    // sList        =   LOCALE_SLIST                ,
    // iMeasure     =   LOCALE_IMEASURE             1
    // sDecimal     =   LOCALE_SDECIMAL             .
    // sThousand    =   LOCALE_STHOUSAND            ,
    // iDigits      =   LOCALE_IDIGITS              2
    // iLZero       =   LOCALE_ILZERO               1
    // sCurrency    =   LOCALE_SCURRENCY            $
    // iCurrDigits  =   LOCALE_ICURRDIGITS          2
    // iCurrency    =   LOCALE_ICURRENCY            0
    // iNegCurr     =   LOCALE_INEGCURR             0
    // sDate        =   LOCALE_SDATE                /
    // sTime        =   LOCALE_STIME                :
    // sShortDate   =   LOCALE_SSHORTDATE           M/d/yy
    // sLongDate    =   LOCALE_SLONGDATE            dddd, MMMM dd, yyyy
    // iDate        =   LOCALE_IDATE                0
    // iTime        =   LOCALE_ITIME                0
    // iTLZero      =   LOCALE_ITLZERO              0
    // s1159        =   LOCALE_S1159                AM
    // s2359        =   LOCALE_S2359                PM

Author:

    Sunil Pai (sunilp) Sept 1992

--*/


BOOL
SetCurrentLocaleWorker(
    LPSTR Locale,
    LPSTR ModifyCPL
    )
/*++

Routine Description:

    Sets the current values for all the per locale fields associated with the
    control panel in the user tree.  Also sets the current user locale and
    system locale fields for the currently logged on session.

Arguments:

    Locale: This is the current locale we have installed.

Return value:

    Returns TRUE if successful, FALSE otherwise with the return buffer
    containing the error text.

--*/

{
    #define WORKSIZE 128        // size (in chars) of work buffer

    WCHAR    szwork[WORKSIZE];
    INT      i;
    LCID     lcid;
    LPSTR    pszTemp;
    LONG     RegStatus;
    NTSTATUS Status;
    HKEY     hKey;
    BOOL     b24Hours = FALSE;

    //
    // Table of international settings and associated lctypes.
    //
    struct {
        PWSTR  szIniKey;
        LCTYPE dwLcType;
    } IntlDataArray[] = {
                            { L"sLanguage"   , LOCALE_SABBREVLANGNAME } ,
                            { L"sCountry"    , LOCALE_SCOUNTRY        } ,
                            { L"iCountry"    , LOCALE_ICOUNTRY        } ,
                            { L"sList"       , LOCALE_SLIST           } ,
                            { L"iMeasure"    , LOCALE_IMEASURE        } ,
                            { L"sDecimal"    , LOCALE_SDECIMAL        } ,
                            { L"sThousand"   , LOCALE_STHOUSAND       } ,
                            { L"iDigits"     , LOCALE_IDIGITS         } ,
                            { L"iLZero"      , LOCALE_ILZERO          } ,
                            { L"sCurrency"   , LOCALE_SCURRENCY       } ,
                            { L"iCurrDigits" , LOCALE_ICURRDIGITS     } ,
                            { L"iCurrency"   , LOCALE_ICURRENCY       } ,
                            { L"iNegCurr"    , LOCALE_INEGCURR        } ,
                            { L"sDate"       , LOCALE_SDATE           } ,
                            { L"sTime"       , LOCALE_STIME           } ,
                            { L"sTimeFormat" , LOCALE_STIMEFORMAT     } ,
                            { L"sShortDate"  , LOCALE_SSHORTDATE      } ,
                            { L"sLongDate"   , LOCALE_SLONGDATE       } ,
                            { L"iDate"       , LOCALE_IDATE           } ,
                            { L"iTime"       , LOCALE_ITIME           } ,
                            { L"iTLZero"     , LOCALE_ITLZERO         } ,
                            { L"s1159"       , LOCALE_S1159           } ,
                            { L"s2359"       , LOCALE_S2359           }
                        };


    //
    // Check to make sure we can modify all locale components later
    //

    RegStatus = RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 "System\\CurrentControlSet\\Control\\Nls\\Language",
                 0,
                 KEY_WRITE,
                 &hKey
                 );

    if( RegStatus != ERROR_SUCCESS )  {
        SetReturnText( "ERROR_PRIVILEGE" );
        return( FALSE );
    }
    else {
        RegCloseKey( hKey );
    }

    RegStatus = RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 "System\\CurrentControlSet\\Control\\Nls\\CodePage",
                 0,
                 KEY_WRITE,
                 &hKey
                 );

    if( RegStatus != ERROR_SUCCESS )  {
        SetReturnText( "ERROR_PRIVILEGE" );
        return( FALSE );
    }
    else {
        RegCloseKey( hKey );
    }
    lcid = (LCID)strtoul( Locale, &pszTemp, 16);

    if( !lstrcmpi( ModifyCPL, "YES" ) ) {

        //
        // Update the control panel user area for new defaults for
        // current locale
        //

        for( i = 0; i < sizeof(IntlDataArray)/sizeof(IntlDataArray[0]); i++ ) {

            if(!GetLocaleInfoW(lcid,IntlDataArray[i].dwLcType,szwork,WORKSIZE)) {
                SetReturnText( "ERROR_UNSUPPORTED" );
                return( FALSE );
            }

            //
            // if the default setting is 24hours,
            // we set s1159 and s2359 with NULL.
            //
            if(IntlDataArray[i].dwLcType == LOCALE_ITIME) {
                if(szwork[0] == L'1') {
                    b24Hours = TRUE;
                }
            } else if((IntlDataArray[i].dwLcType == LOCALE_S1159)||
                      (IntlDataArray[i].dwLcType == LOCALE_S2359)  ) {
                if(b24Hours) {
                    szwork[0] = L'\0';
                }
            }

            if(!WriteProfileStringW(L"INTL",IntlDataArray[i].szIniKey,szwork)) {
                SetReturnText( "ERROR_PRIVILEGE" );
                return( FALSE );
            }
        }

        //
        // Flush win.ini
        //

        WriteProfileString( NULL, NULL, NULL );

    }

    //
    // Set the current thread current system and user locales
    //

    Status = NtSetDefaultLocale( FALSE, lcid );
    if(!NT_SUCCESS( Status )) {
        SetReturnText( "ERROR_PRIVILEGE" );
        return( FALSE );
    }

    Status = NtSetDefaultLocale( TRUE, lcid );
    if(!NT_SUCCESS( Status )) {
        SetReturnText( "ERROR_PRIVILEGE" );
        return( FALSE );
    }

    return ( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\multproc.c ===
#include "precomp.h"
#pragma hdrstop
/***************************************************************************/
/****************** Basic Class Dialog Handlers ****************************/
/***************************************************************************/


/*
**	Purpose:
**		Multiple Choice Listbox Dialog procedure for templates with exactly one
**		listbox control.
**	Control IDs:
**		The Listbox control must have the id IDC_LIST1.  Pushbuttons
**		recognized are IDC_O, IDC_C, IDC_M, IDC_H, IDC_X, and IDC_B.
**	Initialization:
**		The symbol $(ListItemsIn) is a list of strings to insert into the
**		listbox.  The symbol $(ListItemOut) is a list of strings which for
**		each that matches a string in $(ListItemsIn) it sets that item as
**		selected.
**	Termination:
**		The selected items (if any) are stored as a list in the symbol
**		$(ListItemsOut).  The id of the Pushbutton (eg IDC_C) which caused
**		termination is converted to a string and stored in the symbol
**		$(ButtonPressed).
**
*****************************************************************************/
INT_PTR APIENTRY FGstMultiDlgProc(HWND   hdlg,
                                  UINT   wMsg,
                                  WPARAM wParam,
                                  LPARAM lParam)
{
	CHP  rgchNum[10];
	INT  i, nCount;
	RGSZ rgsz, rgszSel;
	PSZ  psz, pszSel;
	SZ   szList;
	CHP  szItemCur[256];
    UINT iItemTop;

    Unused(lParam);

    switch (wMsg) {

    case WM_INITDIALOG:
		AssertDataSeg();

        if( wMsg == WM_INITDIALOG ) {
            FCenterDialogOnDesktop(hdlg);
        }

        if ((szList = SzFindSymbolValueInSymTab("ListItemsIn")) == (SZ)NULL)
			{
			Assert(fFalse);
			return(fTrue);
			}

		while ((psz = rgsz = RgszFromSzListValue(szList)) == (RGSZ)NULL)
			if (!FHandleOOM(hdlg))
				{
				DestroyWindow(GetParent(hdlg));
				return(fTrue);
				}

		nCount = 0;
		while (*psz)
			{		
			SendDlgItemMessage(hdlg, IDC_LIST1, LB_ADDSTRING, 0,
					(LPARAM)*psz++);
			nCount++;
			}	

		Assert(nCount == (INT)SendDlgItemMessage(hdlg, IDC_LIST1, LB_GETCOUNT,
				0, 0L));

        //
        // Find out the items in the multi list box to select
        //

        if ((szList = SzFindSymbolValueInSymTab("ListItemsOut")) == (SZ)NULL)
			{
			EvalAssert(FFreeRgsz(rgsz));
			return(fTrue);
			}

        while ((pszSel = rgszSel = RgszFromSzListValue(szList)) == (RGSZ)NULL)
			if (!FHandleOOM(hdlg))
				{
				EvalAssert(FFreeRgsz(rgsz));
				DestroyWindow(GetParent(hdlg));
				return(fTrue);
				}

        iItemTop = 0;
        for (i = 0; i < nCount; i++) {
            CHP  szItemCur[256];

            if ( (SendDlgItemMessage(
                     hdlg,
                     IDC_LIST1,
                     LB_GETTEXT,
                     (WPARAM)i,
                     (LPARAM)szItemCur
                     ) != LB_ERR)
               ) {
                psz = pszSel;
                while ( *psz ) {
                    if (CrcStringCompareI(*psz++, szItemCur) == crcEqual) {
                        EvalAssert(SendDlgItemMessage(hdlg, IDC_LIST1, LB_SETSEL, 1,
                                MAKELONG(i, 0)) != LB_ERR);
                        if (iItemTop == 0 || i < (INT)iItemTop) {
                            iItemTop = i;
                        }
                        break;
                    }
                }

            }
        }

		EvalAssert(FFreeRgsz(rgsz));
		EvalAssert(FFreeRgsz(rgszSel));

		/* REVIEW KLUDGE no way to find out how many lines in the listbox? */
		if (iItemTop < 4)
			iItemTop = 0;
		SendDlgItemMessage(hdlg, IDC_LIST1, LB_SETTOPINDEX, iItemTop, 0L);
        return(fTrue);

	case STF_REINITDIALOG:
		return(fTrue);

	case WM_CLOSE:
        PostMessage(
            hdlg,
            WM_COMMAND,
            MAKELONG(IDC_X, BN_CLICKED),
            0L
            );
        return(fTrue);

    case WM_COMMAND:
		switch(LOWORD(wParam))
			{
		case IDC_S:
		case IDC_L:
		  	SendDlgItemMessage(hdlg,
                            IDC_LIST1,
                            LB_SETSEL,
                            (LOWORD(wParam) == IDC_S),
					             -1L);
			break;
	
		case IDCANCEL:
            if (LOWORD(wParam) == IDCANCEL) {

                if (!GetDlgItem(hdlg, IDC_B) || HIWORD(GetKeyState(VK_CONTROL)) || HIWORD(GetKeyState(VK_SHIFT)) || HIWORD(GetKeyState(VK_MENU)))
                {
                    break;
                }
                wParam = IDC_B;

            }
        case IDC_O:
		case IDC_C:
		case IDC_M:
        case IDC_X:
		case IDC_B:
        case IDC_BTN0:
        case IDC_BTN1: case IDC_BTN2: case IDC_BTN3:
        case IDC_BTN4: case IDC_BTN5: case IDC_BTN6:
        case IDC_BTN7: case IDC_BTN8: case IDC_BTN9:

			_itoa((INT)wParam, rgchNum, 10);
			while (!FAddSymbolValueToSymTab("ButtonPressed", rgchNum))
				if (!FHandleOOM(hdlg))
					{
					DestroyWindow(GetParent(hdlg));
					return(fTrue);
					}

			nCount = (INT)SendDlgItemMessage(hdlg, IDC_LIST1, LB_GETSELCOUNT, 0,
					0L);
			while ((psz = rgsz = (RGSZ)SAlloc((CB)((nCount + 1) * sizeof(SZ))))
					== (RGSZ)NULL)
				if (!FHandleOOM(hdlg))
					{
					DestroyWindow(GetParent(hdlg));
					return(fTrue);
					}
			rgsz[nCount] = (SZ)NULL;

			/* REVIEW would be faster to use LB_GETSELITEMS */
			nCount = (INT)SendDlgItemMessage(hdlg, IDC_LIST1, LB_GETCOUNT, 0,
					0L);

			for (i = 0; i < nCount; i++)
				{
				if (SendDlgItemMessage(hdlg, IDC_LIST1, LB_GETSEL, (WORD)i, 0L))
					{
					EvalAssert(SendDlgItemMessage(hdlg, IDC_LIST1, LB_GETTEXT,
							(WPARAM)i, (LPARAM)szItemCur) != LB_ERR);
					while ((*psz = SzDupl(szItemCur)) == (SZ)NULL)
						if (!FHandleOOM(hdlg))
							{
							DestroyWindow(GetParent(hdlg));
							return(fTrue);
							}
					psz++;
					}
				}

			while ((szList = SzListValueFromRgsz(rgsz)) == (SZ)NULL)
				if (!FHandleOOM(hdlg))
					{
					DestroyWindow(GetParent(hdlg));
					return(fTrue);
					}

			while (!FAddSymbolValueToSymTab("ListItemsOut", szList))
				if (!FHandleOOM(hdlg))
					{
					DestroyWindow(GetParent(hdlg));
					return(fTrue);
					}

			SFree(szList);
			FFreeRgsz(rgsz);
            PostMessage(GetParent(hdlg), (WORD)STF_UI_EVENT, 0, 0L);
			break;
    		}
		break;

	case STF_DESTROY_DLG:
		PostMessage(GetParent(hdlg), (WORD)STF_MULTI_DLG_DESTROYED, 0, 0L);
		DestroyWindow(hdlg);
		return(fTrue);
		}

    return(fFalse);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\nt_io.c ===
#include "precomp.h"
#pragma hdrstop

ULONG
OpenDiskStatus(
    IN  PSTR    NTDeviceName,
    OUT PHANDLE Handle
    )
{
    OBJECT_ATTRIBUTES oa;
    NTSTATUS          status;
    IO_STATUS_BLOCK   status_block;
    ANSI_STRING       AnsiName;
    UNICODE_STRING    UnicodeName;

    RtlInitAnsiString(&AnsiName,NTDeviceName);
    status = RtlAnsiStringToUnicodeString(&UnicodeName,&AnsiName,TRUE);

    if(!NT_SUCCESS(status)) {
        *Handle = NULL;
        return(0);
    }

    memset(&oa, 0, sizeof(OBJECT_ATTRIBUTES));
    oa.Length = sizeof(OBJECT_ATTRIBUTES);
    oa.ObjectName = &UnicodeName;
    oa.Attributes = OBJ_CASE_INSENSITIVE;

    status = NtOpenFile(Handle,
                        SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                        &oa,
                        &status_block,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT
                       );

    RtlFreeUnicodeString(&UnicodeName);

    return((ULONG)status);
}


HANDLE
OpenDiskNT(
    IN PSTR NTDeviceName
    )
{
    NTSTATUS status;
    HANDLE   Handle = NULL;

    status = (NTSTATUS)OpenDiskStatus(NTDeviceName,&Handle);
    return(NT_SUCCESS(status) ? Handle : NULL);
}


HANDLE
OpenDisk(
    IN PSTR  DOSDriveName,
    IN BOOL WriteAccessDesired
    )
{
        OBJECT_ATTRIBUTES       oa;
    IO_STATUS_BLOCK     status_block;
    HANDLE              Handle;
    UNICODE_STRING      NTDriveNameW;
    PWSTR               DOSDriveNameW;
    BOOLEAN             b;
    NTSTATUS            status;
    unsigned            CharsInName,i;
    ACCESS_MASK         AccessMask;

    // convert byte DOS drive name to widechar DOS drive name

    CharsInName = lstrlen(DOSDriveName);
    DOSDriveNameW = SAlloc((CharsInName+1)*sizeof(WCHAR));
    if(DOSDriveNameW == NULL) {
        SetErrorText(IDS_ERROR_DLLOOM);
        return(NULL);
    }
    for(i=0; i<CharsInName; i++) {
        DOSDriveNameW[i] = (WCHAR)(UCHAR)DOSDriveName[i];
    }
    DOSDriveNameW[CharsInName] = 0;

    // convert widechar DOS drive name to widechar NT drivename

    b = RtlDosPathNameToNtPathName_U(DOSDriveNameW,
                                     &NTDriveNameW,
                                     NULL,
                                     NULL
                                    );
    SFree(DOSDriveNameW);
    if(!b) {
        SetErrorText(IDS_ERROR_INVALIDDISK);
        return(NULL);
    }

    if(NTDriveNameW.Buffer[(NTDriveNameW.Length/sizeof(WCHAR))-1] == (WCHAR)'\\')
    {
        NTDriveNameW.Buffer[(NTDriveNameW.Length/sizeof(WCHAR))-1] = 0;
        NTDriveNameW.Length -= sizeof(WCHAR);
    }

    memset(&oa, 0, sizeof(OBJECT_ATTRIBUTES));
    oa.Length = sizeof(OBJECT_ATTRIBUTES);
    oa.ObjectName = &NTDriveNameW;
    oa.Attributes = OBJ_CASE_INSENSITIVE;

    AccessMask = SYNCHRONIZE | FILE_READ_DATA;
    if(WriteAccessDesired) {
        AccessMask |= FILE_WRITE_DATA;
    }

    status = NtOpenFile(&Handle,
                        AccessMask,
                        &oa,
                        &status_block,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT
                       );
    if(!NT_SUCCESS(status)) {
        SetErrorText(IDS_ERROR_OPENFAIL);
    }
    RtlFreeUnicodeString(&NTDriveNameW);
    return(NT_SUCCESS(status) ? Handle : NULL);
}


BOOL
CloseDisk(
    IN HANDLE Handle
    )
{
    return(NT_SUCCESS(NtClose(Handle)));
}


NTSTATUS
GetDriveGeometry(
    IN HANDLE         Handle,
    IN PDISK_GEOMETRY disk_geometry
    )
{
    IO_STATUS_BLOCK status_block;

    return(NtDeviceIoControlFile(Handle,
                                 0,
                                 NULL,
                                 NULL,
                                 &status_block,
                                 IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                 NULL,
                                 0,
                                 disk_geometry,
                                 sizeof(DISK_GEOMETRY)
                                )
          );
}


ULONG
GetSectorSize(
    IN HANDLE Handle
    )
{
    NTSTATUS      nts;
    DISK_GEOMETRY disk_geometry;

    nts = GetDriveGeometry(Handle,&disk_geometry);
    if(!NT_SUCCESS(nts)) {
        SetErrorText(IDS_ERROR_IOCTLFAIL);
        return(0);
    }
    return(disk_geometry.BytesPerSector);
}




ULONG
GetPartitionSize(
    IN PSTR DiskName
    )
{
    HANDLE                DiskHandle;
    NTSTATUS              nts;
    IO_STATUS_BLOCK       status_block;
    PARTITION_INFORMATION pinfo;
    LARGE_INTEGER         PartitionSize;


    if((DiskHandle = OpenDisk(DiskName,FALSE)) == NULL) {
        return(0);
    }

    nts = NtDeviceIoControlFile(DiskHandle,
                                0,
                                NULL,
                                NULL,
                                &status_block,
                                IOCTL_DISK_GET_PARTITION_INFO,
                                NULL,
                                0,
                                &pinfo,
                                sizeof(PARTITION_INFORMATION)
                               );

    CloseDisk(DiskHandle);

    if(NT_SUCCESS(nts)) {
        PartitionSize = RtlExtendedLargeIntegerDivide(pinfo.PartitionLength,
                                                      1024*1024,
                                                      NULL);
        return(PartitionSize.LowPart);
    } else {
        return(0);
    }
}


BOOL
ReadDiskSectors(
    IN HANDLE Handle,
    IN ULONG  Sector,
    IN ULONG  NumSectors,
    IN PVOID  Buffer,
    IN ULONG  SectorSize
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    LARGE_INTEGER ByteOffset;
    NTSTATUS nts;

    ByteOffset.QuadPart = UInt32x32To64(Sector,SectorSize);

    IoStatusBlock.Status = 0;
    IoStatusBlock.Information = 0;

    nts = NtReadFile(Handle,
                     0,
                     NULL,
                     NULL,
                     &IoStatusBlock,
                     Buffer,
                     NumSectors * SectorSize,
                     &ByteOffset,
                     NULL
                    );

    return(NT_SUCCESS(nts));
}


BOOL
WriteDiskSectors(
    IN HANDLE Handle,
    IN ULONG  Sector,
    IN ULONG  NumSectors,
    IN PVOID  Buffer,
    IN ULONG  SectorSize
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    LARGE_INTEGER ByteOffset;
    NTSTATUS nts;

    ByteOffset.QuadPart = UInt32x32To64(Sector,SectorSize);

    IoStatusBlock.Status = 0;
    IoStatusBlock.Information = 0;

    nts = NtWriteFile(Handle,
                      0,
                      NULL,
                      NULL,
                      &IoStatusBlock,
                      Buffer,
                      NumSectors * SectorSize,
                      &ByteOffset,
                      NULL
                     );

    return(NT_SUCCESS(nts));
}


BOOL
ShutdownSystemWorker (
    IN BOOL Reboot
    )
{
    if(OwnProcess) {
        return ExitWindowsEx(Reboot ? EWX_REBOOT : EWX_LOGOFF, 0);
    }
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\netcon.c ===
#include "precomp.h"
#pragma hdrstop
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    netcon.c

Abstract:

    This file has the Wnet network connection routines

Author:

    Sunil Pai (sunilp) July 1991

--*/


typedef DWORD  (APIENTRY *PFWNETPROC)();

#define DRIVE_LETTER_RANGE ('Z'+1-'A')

LPSTR apUncPath [ DRIVE_LETTER_RANGE ] =
{
    NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL
};

VOID
DeleteAllConnectionsWorker(
    VOID
   )
{
    CHAR chDrive[3] = "A:" ;
    INT i ;

    for ( i = 0 ; i < DRIVE_LETTER_RANGE ; i++ )
    {
        if ( apUncPath[i] )
        {
            //  Delete the connection.  This automatically cleans up
            //    the UNC path table.

            chDrive[0] = 'A' + i ;
            DeleteNetConnectionWorker( chDrive, "TRUE" ) ;
        }
    }
}

    //
    //   Check to see if a connection is already known to the given UNC name.
    //   Return the drive letter if so or zero if not.
    //
CHAR CheckNetConnection(
    LPSTR szUNCName
    )
{
    INT i ;

    for ( i = 0 ; i < DRIVE_LETTER_RANGE ; i++ )
    {
        if ( apUncPath[i] )
        {
            if ( _strcmpi( szUNCName, apUncPath[i] ) == 0 )
                return 'A'+i ;
        }
    }

    return 0 ;
}

BOOL
GetMprProcAddr(
    LPSTR szProcName,
    PFWNETPROC * ppFunc
    )
{
    static
    HMODULE    WNetModule = NULL ;

    //
    // Load the wnet dll if necessary (first cycle)
    //

    if ( WNetModule == NULL )
    {
        if((WNetModule = LoadLibrary("mpr.dll")) == NULL) {
            SetErrorText(IDS_ERROR_NONETWORK);
            return(FALSE);
        }
    }

    //
    // Get the addresses of the WNetAddConnection entry point
    //

    *ppFunc = (PFWNETPROC)GetProcAddress( WNetModule,
                                          szProcName
                                          );

    if( *ppFunc == NULL ) {
        SetErrorText(IDS_ERROR_NONETWORK);
        return(FALSE);
    }
    return TRUE ;
}


// arg0 = Remote name
// arg1 = Password
// arg2 = Local Name

BOOL
AddNetConnectionWorker(
    LPSTR szUNCName,
    LPSTR szPassword,
    LPSTR szLocalName
    )
{
    DWORD      dwStatus;
    PFWNETPROC PFWNetAddConnection2;
    NETRESOURCE NetResource;
    LPSTR      szUNCSave ;
    INT        i ;

    if ( ! GetMprProcAddr( "WNetAddConnection2A",
                           & PFWNetAddConnection2 ) )
    {
        return FALSE ;
    }

    //
    // Build the netresource structure and call the function
    //

    NetResource.dwScope      = 0;
    NetResource.dwType       = RESOURCETYPE_DISK;
    NetResource.dwUsage      = 0;
    NetResource.lpLocalName  = szLocalName;
    NetResource.lpRemoteName = szUNCName;
    NetResource.lpComment    = NULL;
    NetResource.lpProvider   = NULL;

    dwStatus = PFWNetAddConnection2(
                   &NetResource,
                   szPassword,
                   NULL,
                   0
                   );

    switch (dwStatus) {

    case WN_SUCCESS:

        //  Success: create an entry in the UNC mapping table

        i = toupper( szLocalName[0] ) - 'A' ;

        if (    i >= 0
             && i < DRIVE_LETTER_RANGE
             && szLocalName[1] == ':'
             && (szUNCSave = SAlloc( strlen( szUNCName ) + 1 )) )
        {
            strcpy( szUNCSave, szUNCName ) ;
            apUncPath[i] = szUNCSave ;
        }
        return ( TRUE );

    case WN_BAD_NETNAME:
        SetErrorText(IDS_ERROR_BADNETNAME);
        break;

    case WN_BAD_LOCALNAME:
        SetErrorText(IDS_ERROR_BADLOCALNAME);
        break;

    case WN_BAD_PASSWORD:
        SetErrorText(IDS_ERROR_BADPASSWORD);
        break;

    case WN_ALREADY_CONNECTED:
        SetErrorText(IDS_ERROR_ALREADYCONNECTED);
        break;

    case WN_ACCESS_DENIED:
        SetErrorText(IDS_ERROR_ACCESSDENIED);
        break;

    case WN_NO_NETWORK:
    default:
        SetErrorText(IDS_ERROR_NONETWORK);
        break;
    }

    return ( FALSE );

}


//
// Arg[0]: Local Name
// Arg[1]: Force closure -- "TRUE" | "FALSE"
//

BOOL
DeleteNetConnectionWorker(
    LPSTR  szLocalName,
    LPSTR  szForceClosure
    )
{
    DWORD dwStatus;
    PFWNETPROC PFWNetCancelConnection;
    INT i ;

    if ( ! GetMprProcAddr( "WNetCancelConnectionA",
                           & PFWNetCancelConnection ) )
    {
        return FALSE ;
    }

    //  Remove the UNC path data from the table regardless of
    //  the result of the connection cancellation.

    i = toupper( szLocalName[0] ) - 'A' ;

    if (   i >= 0
        && i < DRIVE_LETTER_RANGE
        && szLocalName[1] == ':'
        && apUncPath[i] != NULL )
    {
        SFree( apUncPath[i] ) ;
        apUncPath[i] = NULL ;
    }

    dwStatus = PFWNetCancelConnection(szLocalName, !lstrcmpi(szForceClosure, "TRUE"));

    switch (dwStatus) {
    case WN_SUCCESS:
        return ( TRUE );

    case WN_OPEN_FILES:
        SetErrorText(IDS_ERROR_NETOPENFILES);
        break;

    case WN_NOT_CONNECTED:
    default:
        SetErrorText(IDS_ERROR_NOTCONNECTED);
        break;

    }

    return ( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\nt_env.c ===
#include "precomp.h"
#pragma hdrstop
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    nt_env.c

Abstract:

    1. Contains routines to get and set NVRAM variables.

Author:

    Sunil Pai (sunilp) 20-Nov-1991

--*/



#define MAX_ENV_VAR_LEN  4096


//  Detect Command: (transfer to detect1.c)
//
//  Get value of a MIPS environment variable. Returns the value in list form.
//  If the value is a path (semicolon-separated components) each component
//  is an element of the list.
//

CB
GetNVRAMVar(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{

    CHAR    EnvValue[ MAX_ENV_VAR_LEN ];
    SZ      sz;

    Unused( cbReturnBuffer );

    ReturnBuffer[0] = '\0';

    if (cArgs > 0) {

        if ( !GetEnvironmentString( Args[0], EnvValue, MAX_ENV_VAR_LEN ) ) {

            //
            //  Env. Variable not defined, return empty list
            //
            #define UNDEF_VAR_VALUE "{}"

            lstrcpy( ReturnBuffer, UNDEF_VAR_VALUE );
            return lstrlen( ReturnBuffer )+1;

        } else if ( sz = SzListValueFromPath( EnvValue ) ) {

            lstrcpy( ReturnBuffer, sz );
            SFree( sz );
            return lstrlen( ReturnBuffer)+1;
        }
    }

    return 0;
}



BOOL
GetEnvironmentString(
    IN  LPSTR  lpVar,
    OUT LPSTR  lpValue,
    IN  USHORT MaxLengthValue
    )

{
    PWSTR          wBuffer;
    USHORT         ReturnLength;

    UNICODE_STRING VarString_U, ValueString_U;
    ANSI_STRING    VarString_A, ValueString_A;

    NTSTATUS       Status;

    LONG              Privilege = SE_SYSTEM_ENVIRONMENT_PRIVILEGE;
    TOKEN_PRIVILEGES  PrevState;
    ULONG             PrevLength = sizeof( TOKEN_PRIVILEGES );


    //
    // Initialise the wide char buffer which will receive the env value
    //

    if ((wBuffer = SAlloc((MAX_ENV_VAR_LEN) * sizeof(WCHAR))) == NULL) {
        SetErrorText(IDS_ERROR_RTLOOM);
        return FALSE;
    }

    //
    // get the environment variable
    //

    RtlInitAnsiString(&VarString_A, lpVar);
    Status = RtlAnsiStringToUnicodeString(
                 &VarString_U,
                 &VarString_A,
                 TRUE
                 );

    if(!NT_SUCCESS(Status)) {
        SetErrorText(IDS_ERROR_RTLOOM);
        SFree(wBuffer);
        return(FALSE);
    }

    //
    // Enable the SE_SYSTEM_ENVIRONMENT_PRIVILEGE, if this fails we
    // cannot query the environment string
    //

    if( !AdjustPrivilege(
             Privilege,
             ENABLE_PRIVILEGE,
             &PrevState,
             &PrevLength
             )
       ) {
        SFree( wBuffer );
        return( FALSE );
    }

    //
    // Query the system environment value
    //

    Status = NtQuerySystemEnvironmentValue(
                 &VarString_U,
                 wBuffer,
                 MAX_ENV_VAR_LEN * sizeof(WCHAR),
                 &ReturnLength
                 );

    //
    // Restore the SE_SYSTEM_ENVIRONMENT_PRIVILEGE to its previous state
    //

    RestorePrivilege( &PrevState );

    //
    // Examine the query system environment value operation

    if(!NT_SUCCESS(Status)) {

        //
        // first free the resources involved
        //

        SFree(wBuffer);
        RtlFreeUnicodeString(&VarString_U);

        //
        // special handling for var not found
        //

        if (Status == STATUS_UNSUCCESSFUL) {
            lpValue[0] = 0; //Null terminate
            return(TRUE);
        }
        else {
            SetErrorText(IDS_ERROR_ENVVARREAD);
            return(FALSE);
        }
    }



    //
    // Free the Unicode var string, no longer needed
    //

    RtlFreeUnicodeString(&VarString_U);

    //
    // Convert the value to an Ansi string
    //

    RtlInitUnicodeString(&ValueString_U, wBuffer);
    Status = RtlUnicodeStringToAnsiString(
                 &ValueString_A,
                 &ValueString_U,
                 TRUE
                 );

    if (!NT_SUCCESS(Status)) {
        SetErrorText(IDS_ERROR_RTLOOM);
        SFree(wBuffer);
        return (FALSE);
    }

    //
    // Move it to the buffer passed in
    //

    if (ValueString_A.Length  >= MaxLengthValue) {
        SetErrorText(IDS_ERROR_ENVVAROVF);
        RtlFreeAnsiString(&ValueString_A);
        SFree(wBuffer);
        return FALSE;
    }

    //
    // move the ansi string to the buffer passed in
    //

    RtlMoveMemory(lpValue, ValueString_A.Buffer, ValueString_A.Length);
    lpValue[ValueString_A.Length]=0; //Null terminate

    //
    // free the value ansi string
    //

    RtlFreeAnsiString(&ValueString_A);

    //
    // return success
    //

    return TRUE;
}


BOOL
SetEnvironmentString(
    IN LPSTR lpVar,
    IN LPSTR lpValue
    )

{
    UNICODE_STRING VarString_U, ValueString_U;
    ANSI_STRING    VarString_A, ValueString_A;
    NTSTATUS       Status;

    LONG              Privilege = SE_SYSTEM_ENVIRONMENT_PRIVILEGE;
    TOKEN_PRIVILEGES  PrevState;
    ULONG             PrevLength = sizeof( TOKEN_PRIVILEGES );

    //
    // Initialise the unicode strings for the environment variable
    //

    RtlInitAnsiString(&VarString_A, lpVar);
    Status = RtlAnsiStringToUnicodeString(
                 &VarString_U,
                 &VarString_A,
                 TRUE
                 );

    if(!NT_SUCCESS(Status)) {
        SetErrorText(IDS_ERROR_RTLOOM);
        return(FALSE);
    }


    //
    // Initialise the unicode string for the environment value
    //

    RtlInitAnsiString(&ValueString_A, lpValue);
    Status = RtlAnsiStringToUnicodeString(
                 &ValueString_U,
                 &ValueString_A,
                 TRUE
                 );

    if(!NT_SUCCESS(Status)) {
        SetErrorText(IDS_ERROR_RTLOOM);
        RtlFreeUnicodeString(&VarString_U);
        return(FALSE);
    }

    //
    // Enable the SE_SYSTEM_ENVIRONMENT_PRIVILEGE, if this fails we
    // cannot query the environment string
    //

    if( !AdjustPrivilege(
             Privilege,
             ENABLE_PRIVILEGE,
             &PrevState,
             &PrevLength
             )
       ) {

        SetErrorText(IDS_ERROR_PRIVILEGE);
        RtlFreeUnicodeString(&VarString_U);
        return( FALSE );
    }

    //
    // call the NT Function to set the environment variable
    //

    Status = NtSetSystemEnvironmentValue(
                 &VarString_U,
                 &ValueString_U
                 );

    //
    // Restore the SE_SYSTEM_ENVIRONMENT_PRIVILEGE to its previous state
    //

    RestorePrivilege( &PrevState );

    //
    // free the two unicode strings
    //

    RtlFreeUnicodeString(&VarString_U);
    RtlFreeUnicodeString(&ValueString_U);

    //
    // return Success/Failure
    //

    if (!NT_SUCCESS(Status)) {
        SetErrorText(IDS_ERROR_ENVVARWRITE);
        return ( FALSE );
    }

    return ( TRUE );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\nvram.c ===
#include "precomp.h"
#pragma hdrstop
//
// x86 version (that deals with boot.ini)
// is in i386 directory.  This is the arc version, that
// deals with nv-ram.
//

#ifndef _X86_

typedef enum {
    BootVarSystemPartition,
    BootVarOsLoader,
    BootVarOsLoadPartition,
    BootVarOsLoadFilename,
    BootVarOsLoadOptions,
    BootVarLoadIdentifier,
    BootVarMax
} BOOT_VARS;

PWSTR BootVarNames[BootVarMax] = { L"SYSTEMPARTITION",
                                   L"OSLOADER",
                                   L"OSLOADPARTITION",
                                   L"OSLOADFILENAME",
                                   L"OSLOADOPTIONS",
                                   L"LOADIDENTIFIER"
                                 };

DWORD BootVarComponentCount[BootVarMax];
PWSTR *BootVarComponents[BootVarMax];
DWORD LargestComponentCount;

#define MAX_COMPONENTS 20


BOOL
SetNvRamVar(
    IN PWSTR VarName,
    IN PWSTR VarValue
    )
{
    UNICODE_STRING VarNameU,VarValueU;
    NTSTATUS Status;
    BOOLEAN OldPriv,DontCare;

    //
    // Set up unicode strings.
    //
    RtlInitUnicodeString(&VarNameU ,VarName );
    RtlInitUnicodeString(&VarValueU,VarValue);

    //
    // Make sure we have privilege to set nv-ram vars.
    // Note: ignore return value; if this fails then we'll catch
    // any problems when we actually try to set the var.
    //
    RtlAdjustPrivilege(
        SE_SYSTEM_ENVIRONMENT_PRIVILEGE,
        TRUE,
        FALSE,
        &OldPriv
        );

    Status = NtSetSystemEnvironmentValue(&VarNameU,&VarValueU);

    //
    // Restore old privilege level.
    //
    RtlAdjustPrivilege(
        SE_SYSTEM_ENVIRONMENT_PRIVILEGE,
        OldPriv,
        FALSE,
        &DontCare
        );

    return(NT_SUCCESS(Status));
}


BOOL
FChangeBootIniTimeout(
    IN INT Timeout
    )
{
    WCHAR TimeoutValue[24];

    //
    // Form the timeout value.
    //
    wsprintfW(TimeoutValue,L"%u",Timeout);

    //
    // Set the vars
    //
    if(!SetNvRamVar(L"COUNTDOWN",TimeoutValue)) {
        return(FALSE);
    }

    return(SetNvRamVar(L"AUTOLOAD",L"YES"));
}


BOOL
GetVarComponents(
    IN  PWSTR    VarValue,
    OUT PWSTR  **Components,
    OUT PDWORD   ComponentCount
    )
{
    PWSTR *components;
    DWORD componentCount;
    PWSTR p;
    PWSTR Var;
    PWSTR comp;
    DWORD len;

    components = SAlloc(MAX_COMPONENTS * sizeof(PWSTR));
    if(!components) {
        return(FALSE);
    }

    for(Var=VarValue,componentCount=0; *Var; ) {

        //
        // Skip leading spaces.
        //
        while(iswspace(*Var)) {
            Var++;
        }

        if(*Var == 0) {
            break;
        }

        p = Var;

        while(*p && (*p != L';')) {
            p++;
        }

        len = (DWORD)((PUCHAR)p - (PUCHAR)Var);

        comp = SAlloc(len + sizeof(WCHAR));
        if(!comp) {
            DWORD i;
            for(i=0; i<componentCount; i++) {
                SFree(components[i]);
            }
            SFree(components);
            return(FALSE);
        }

        len /= sizeof(WCHAR);

        wcsncpy(comp,Var,len);
        comp[len] = 0;

        components[componentCount] = comp;

        componentCount++;

        if(componentCount == MAX_COMPONENTS) {
            break;
        }

        Var = p;
        if(*Var) {
            Var++;      // skip ;
        }
    }

    //
    // array is shrinking
    //
    *Components = SRealloc(components,componentCount*sizeof(PWSTR));

    *ComponentCount = componentCount;

    return(TRUE);
}


BOOL
DoRemoveWinntBootSet(
    VOID
    )
{
    DWORD set;
    DWORD var;
    WCHAR Buffer[2048];
    BOOL rc;

    //
    // Find and remove any remnants of previously attempted
    // winnt32 runs. Such runs are identified by 'winnt32'
    // in their osloadoptions.
    //

    for(set=0; set<__min(LargestComponentCount,BootVarComponentCount[BootVarOsLoadOptions]); set++) {

        //
        // See if the os load options indicate that this is a winnt32 set.
        //
        if(!_wcsicmp(BootVarComponents[BootVarOsLoadOptions][set],L"WINNT32")) {

            //
            // Delete this boot set.
            //
            for(var=0; var<BootVarMax; var++) {

                if(set < BootVarComponentCount[var]) {

                    SFree(BootVarComponents[var][set]);
                    BootVarComponents[var][set] = NULL;
                }
            }
        }
    }

    //
    // Set each variable, constructing values by building up the
    // components into a semi-colon-delineated list.
    //
    rc = TRUE;
    for(var=0; var<BootVarMax; var++) {

        //
        // Clear out the buffer.
        //
        Buffer[0] = 0;

        //
        // Append all components that were not deleted.
        //
        for(set=0; set<BootVarComponentCount[var]; set++) {

            if(BootVarComponents[var][set]) {

                if(set) {
                    wcscat(Buffer,L";");
                }

                wcscat(Buffer,BootVarComponents[var][set]);

                //
                // Free the component, as we are done with it.
                //
                SFree(BootVarComponents[var][set]);
                BootVarComponents[var][set] = NULL;
            }
        }

        //
        // Write the var into nvram and return.
        //
        rc = rc && SetNvRamVar(BootVarNames[var],Buffer);

        //
        // Free array of components.
        //
        SFree(BootVarComponents[var]);
        BootVarComponents[var] = NULL;
    }

    return(rc);
}


BOOL
RemoveWinntBootSet(
    VOID
    )
{
    DWORD var;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    BOOLEAN OldPriv,DontCare;
    WCHAR Buffer[1024];
    BOOL b;

    //
    // Make sure we have privilege to get/set nvram vars.
    //
    RtlAdjustPrivilege(
        SE_SYSTEM_ENVIRONMENT_PRIVILEGE,
        TRUE,
        FALSE,
        &OldPriv
        );

    //
    // Get boot vars and break into components.
    //
    for(var=0; var<BootVarMax; var++) {

        RtlInitUnicodeString(&UnicodeString,BootVarNames[var]);

        Status = NtQuerySystemEnvironmentValue(
                    &UnicodeString,
                    Buffer,
                    sizeof(Buffer)/sizeof(WCHAR),
                    NULL
                    );

        b = GetVarComponents(
                NT_SUCCESS(Status) ? Buffer : L"",
                &BootVarComponents[var],
                &BootVarComponentCount[var]
                );

        if(!b) {
            return(FALSE);
        }

        //
        // Track the variable with the most number of components.
        //
        if(BootVarComponentCount[var] > LargestComponentCount) {
            LargestComponentCount = BootVarComponentCount[var];
        }
    }

    b = DoRemoveWinntBootSet();

    //
    // Restore previous privilege.
    //
    RtlAdjustPrivilege(
        SE_SYSTEM_ENVIRONMENT_PRIVILEGE,
        OldPriv,
        FALSE,
        &DontCare
        );

    return(b);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\nt_ob.c ===
#include "precomp.h"
#pragma hdrstop
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    nt_obj.c

Abstract:

    1. Contains routines to access symbolic link objects

    2. Contains routines to convert between the DOS and ARC Name space

Author:

    Sunil Pai (sunilp) 20-Nov-1991

--*/


#define BUFFER_SIZE      1024
#define SYMLINKTYPE      L"SymbolicLink"
#define ARCNAMEOBJDIR    L"\\ArcName"
#define DOSDEVOBJDIR     L"\\DosDevices"

BOOL
IsSymbolicLinkType(
    IN PUNICODE_STRING Type
    );


BOOL
DosPathToNtPathWorker(
    IN  LPSTR DosPath,
    OUT LPSTR NtPath
    )
{
    CHAR  Drive[] = "\\DosDevices\\?:";
    WCHAR NtNameDrive[MAX_PATH];

    ANSI_STRING       AnsiString;

    UNICODE_STRING    Drive_U, NtNameDrive_U;
    ANSI_STRING       NtNameDrive_A;

    BOOL              bStatus;
    NTSTATUS          Status;

    //
    // Validate the DOS Path passed in
    //

    if (lstrlen(DosPath) < 2 || DosPath[1] != ':') {
        SetErrorText(IDS_ERROR_INVALIDDISK);
        return ( FALSE );
    }

    //
    // Extract the drive
    //

    Drive[12] = DosPath[0];

    //
    // Get Unicode string for the drive
    //

    RtlInitAnsiString(&AnsiString, Drive);
    Status = RtlAnsiStringToUnicodeString(
                 &Drive_U,
                 &AnsiString,
                 TRUE
                 );

    if (!NT_SUCCESS(Status)) {
        SetErrorText(IDS_ERROR_RTLOOM);
        return ( FALSE );
    }


    //
    // Initialise Unicode string to hold the Nt Name for the Drive
    //

    NtNameDrive_U.Buffer        = NtNameDrive;
    NtNameDrive_U.Length        = 0;
    NtNameDrive_U.MaximumLength = MAX_PATH * sizeof(WCHAR);

    //
    // Query symbolic link of the drive
    //

    bStatus = GetSymbolicLinkTarget(&Drive_U, &NtNameDrive_U);
    RtlFreeUnicodeString(&Drive_U);
    if (!bStatus) {
        return ( FALSE );
    }

    //
    // Convert the Unicode NtName for drive to ansi
    //

    Status = RtlUnicodeStringToAnsiString(
                 &NtNameDrive_A,
                 &NtNameDrive_U,
                 TRUE
                 );

    if (!NT_SUCCESS(Status)) {
        SetErrorText(IDS_ERROR_RTLOOM);
        return ( FALSE );
    }

    //
    // Copy the drive to the output variable
    //

    NtNameDrive_A.Buffer[NtNameDrive_A.Length] = '\0'; //Null terminate
    lstrcpy(NtPath, NtNameDrive_A.Buffer);
    RtlFreeAnsiString(&NtNameDrive_A);

    //
    // concatenate the rest of the DosPath to this ArcPath
    //

    lstrcat(NtPath, DosPath+2);

    return(TRUE);

}


BOOL
NtPathToDosPathWorker(
    IN  LPSTR NtPath,
    OUT LPSTR DosPath
    )
{
    CHAR Drive;
    CHAR DriveStr[3] = "x:";
    CHAR NtDevicePath[MAX_PATH];
    unsigned MatchLen;

    //
    // Iterate through each potential drive letter.
    //
    for(Drive='A'; Drive<='Z'; Drive++) {

        DriveStr[0] = Drive;

        //
        // Get the equivalent NT device path, if any.
        //
        if(DosPathToNtPathWorker(DriveStr,NtDevicePath)) {

            MatchLen = lstrlen(NtDevicePath);

            //
            // If the NT Path we are trying to translate is a prefix
            // of the NT path for the current drive, we've got a match.
            //
            if(!_strnicmp(NtDevicePath,NtPath,MatchLen)) {

                lstrcpy(DosPath,DriveStr);
                lstrcat(DosPath,NtPath+MatchLen);
                return(TRUE);
            }
        }
    }

    //
    // Didn't find a drive letter that matches so there is no
    // equivalent DOS path.
    //
    return(FALSE);
}


BOOL
DosPathToArcPathWorker(
    IN  LPSTR DosPath,
    OUT LPSTR ArcPath
    )
{
    CHAR  Drive[] = "\\DosDevices\\?:";
    WCHAR NtNameDrive[MAX_PATH];
    WCHAR ArcNameDrive[MAX_PATH];

    ANSI_STRING       AnsiString;

    UNICODE_STRING    Drive_U, NtNameDrive_U, ObjDir_U, ArcNameDrive_U;
    ANSI_STRING       ArcNameDrive_A;

    BOOL              bStatus;
    NTSTATUS          Status;

    //
    // Validate the DOS Path passed in
    //

    if (lstrlen(DosPath) < 2 || DosPath[1] != ':') {
        SetErrorText(IDS_ERROR_INVALIDDISK);
        return ( FALSE );
    }

    //
    // Extract the drive
    //

    Drive[12] = DosPath[0];

    //
    // Get Unicode string for the drive
    //

    RtlInitAnsiString(&AnsiString, Drive);
    Status = RtlAnsiStringToUnicodeString(
                 &Drive_U,
                 &AnsiString,
                 TRUE
                 );

    if (!NT_SUCCESS(Status)) {
        SetErrorText(IDS_ERROR_RTLOOM);
        return ( FALSE );
    }


    //
    // Initialise Unicode string to hold the Nt Name for the Drive
    //

    NtNameDrive_U.Buffer        = NtNameDrive;
    NtNameDrive_U.Length        = 0;
    NtNameDrive_U.MaximumLength = MAX_PATH * sizeof(WCHAR);

    //
    // Initialise Unicode string to hold the ArcName for the drive
    //

    ArcNameDrive_U.Buffer        = ArcNameDrive;
    ArcNameDrive_U.Length        = 0;
    ArcNameDrive_U.MaximumLength = MAX_PATH * sizeof(WCHAR);

    //
    // Initialise Unicode string to hold the \\ArcName objdir name
    //

    RtlInitUnicodeString(&ObjDir_U, ARCNAMEOBJDIR);

    //
    // Query symbolic link of the drive
    //

    bStatus = GetSymbolicLinkTarget(&Drive_U, &NtNameDrive_U);
    RtlFreeUnicodeString(&Drive_U);
    if (!bStatus) {
        return ( FALSE );
    }

    //
    // Find the object in the arcname directory
    //

    bStatus = GetSymbolicLinkSource(&ObjDir_U, &NtNameDrive_U, &ArcNameDrive_U);
    if (!bStatus) {

        return ( FALSE );
    }

    //
    // Convert the Unicode ArcName for drive to ansi
    //

    Status = RtlUnicodeStringToAnsiString(
                 &ArcNameDrive_A,
                 &ArcNameDrive_U,
                 TRUE
                 );

    if (!NT_SUCCESS(Status)) {
        SetErrorText(IDS_ERROR_RTLOOM);
        return ( FALSE );
    }

    //
    // Copy the drive to the output variable
    //

    ArcNameDrive_A.Buffer[ArcNameDrive_A.Length] = '\0'; //Null terminate
    lstrcpy(ArcPath, ArcNameDrive_A.Buffer);
    RtlFreeAnsiString(&ArcNameDrive_A);

    //
    // concatenate the rest of the DosPath to this ArcPath
    //

    lstrcat(ArcPath, DosPath+2);

    return(TRUE);

}

BOOL
ArcPathToDosPathWorker(
    IN  LPSTR ArcPath,
    OUT LPSTR DosPath
    )
{
    CHAR  ArcDir[] = "\\ArcName\\";
    CHAR  ArcFullPath[MAX_PATH];
    SZ    ArcDrive, FilePath;

    CHAR  ArcDriveObject[MAX_PATH];
    WCHAR NtNameDrive[MAX_PATH];
    WCHAR DosNameDrive[MAX_PATH];


    ANSI_STRING       AnsiString;

    UNICODE_STRING    Drive_U, NtNameDrive_U, ObjDir_U, DosNameDrive_U;
    ANSI_STRING       DosNameDrive_A;

    BOOL              bStatus;
    NTSTATUS          Status;

    //
    // Validate the Arc Path passed in
    //

    if (lstrlen(ArcPath) >= MAX_PATH) {
        SetErrorText(IDS_ERROR_INVALIDDISK);
        return ( FALSE );
    }

    // extract the arc drive and filename

    lstrcpy (ArcFullPath, ArcPath);
    ArcDrive = ArcFullPath;
    FilePath  = strchr (ArcFullPath, '\\');
    if (FilePath != NULL) {
        *FilePath = '\0';
        FilePath++;
    }

    //
    // Form the full spec for the ArcDrive object name
    //

    lstrcpy (ArcDriveObject, ArcDir);
    lstrcat (ArcDriveObject, ArcDrive);

    //
    // Get Unicode string for the drive
    //

    RtlInitAnsiString(&AnsiString, ArcDriveObject);
    Status = RtlAnsiStringToUnicodeString(
                 &Drive_U,
                 &AnsiString,
                 TRUE
                 );

    if (!NT_SUCCESS(Status)) {
        SetErrorText(IDS_ERROR_RTLOOM);
        return ( FALSE );
    }


    //
    // Initialise Unicode string to hold the Nt Name for the Drive
    //

    NtNameDrive_U.Buffer        = NtNameDrive;
    NtNameDrive_U.Length        = 0;
    NtNameDrive_U.MaximumLength = MAX_PATH * sizeof(WCHAR);

    //
    // Initialise Unicode string to hold the ArcName for the drive
    //

    DosNameDrive_U.Buffer        = DosNameDrive;
    DosNameDrive_U.Length        = 0;
    DosNameDrive_U.MaximumLength = MAX_PATH * sizeof(WCHAR);

    //
    // Initialise Unicode string to hold the \\DosDevices objdir name
    //

    RtlInitUnicodeString(&ObjDir_U, DOSDEVOBJDIR);

    //
    // Query symbolic link of the drive
    //

    bStatus = GetSymbolicLinkTarget(&Drive_U, &NtNameDrive_U);
    RtlFreeUnicodeString(&Drive_U);
    if (!bStatus) {
        return ( FALSE );
    }

    //
    // Find the object in the dosdevices directory
    //

    bStatus = GetSymbolicLinkSource(&ObjDir_U, &NtNameDrive_U, &DosNameDrive_U);
    if (!bStatus) {

        return ( FALSE );
    }

    //
    // Convert the Unicode ArcName for drive to ansi
    //

    Status = RtlUnicodeStringToAnsiString(
                 &DosNameDrive_A,
                 &DosNameDrive_U,
                 TRUE
                 );

    if (!NT_SUCCESS(Status)) {
        SetErrorText(IDS_ERROR_RTLOOM);
        return ( FALSE );
    }

    //
    // Copy the drive to the output variable
    //

    DosNameDrive_A.Buffer[DosNameDrive_A.Length] = '\0'; //Null terminate
    lstrcpy(DosPath, DosNameDrive_A.Buffer);
    RtlFreeAnsiString(&DosNameDrive_A);

    //
    // concatenate the rest of the DosPath to this ArcPath
    //
    if (FilePath != NULL) {
        lstrcat (DosPath, "\\");
        lstrcat (DosPath, FilePath);
    }

    return(TRUE);

}

BOOL
IsDriveExternalScsi(
    IN  LPSTR DosDrive,
    OUT BOOL  *IsExternal
    )
{
    CHAR ArcNameDrive[MAX_PATH];
    BOOL bStatus;

    //
    // Set IsExternal to false
    //

    *IsExternal = FALSE;

    //
    // Query the ArcName for the DOS Drive
    //

    bStatus = DosPathToArcPathWorker(DosDrive, ArcNameDrive);
    if (!bStatus) {
        return (FALSE);
    }

    //
    // Find out if the Arcname first four letters are scsi
    //

    ArcNameDrive[4] = '\0';  // Only interested in first four letters
    if(!lstrcmpi(ArcNameDrive, "scsi")) {
        *IsExternal = TRUE;
    }

    return TRUE;
}



/*
 *  OBJECT MANAGEMENT ROUTINES
 */

BOOL
GetSymbolicLinkSource(
    IN  PUNICODE_STRING pObjDir_U,
    IN  PUNICODE_STRING pTarget_U,
    OUT PUNICODE_STRING pSource_U
    )
{
    PCHAR             Buffer, FullNameObject, ObjectLink, SavedMatch;
    UNICODE_STRING    ObjName_U, ObjLink_U;

    UNICODE_STRING    SavedMatch_U;
    BOOLEAN           IsMatchSaved = FALSE;

    OBJECT_ATTRIBUTES Attributes;

    HANDLE            DirectoryHandle;
    ULONG             Context = 0;
    ULONG             ReturnedLength;
    BOOLEAN           RestartScan = TRUE;
    BOOLEAN           ReturnSingleEntry = TRUE;  //LATER change this to FALSE

    POBJECT_DIRECTORY_INFORMATION DirInfo;

    NTSTATUS          Status;
    BOOL              bStatus;

    //
    // Open the object directory.
    //

    InitializeObjectAttributes(
        &Attributes,
        pObjDir_U,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenDirectoryObject(
                 &DirectoryHandle,
                 DIRECTORY_ALL_ACCESS,
                 &Attributes
                 );

    if (!NT_SUCCESS( Status ) ) {
        SetErrorText(IDS_ERROR_OBJDIROPEN);
        return ( FALSE );
    }


    //
    //  Find the symbolic link objects in the directory and query them for
    //  a match with the string passed in
    //

    //
    //  Allocate a buffer to query the directory objects
    //
    if ((Buffer = SAlloc(BUFFER_SIZE)) == NULL) {
        SetErrorText(IDS_ERROR_DLLOOM);
        NtClose(DirectoryHandle);
        return ( FALSE );
    }

    //
    //  Form a Unicode string object to hold the symbolic link objects found
    //  in the object directory
    //

    if ((FullNameObject = SAlloc(MAX_PATH * sizeof(WCHAR))) == NULL) {
        SetErrorText(IDS_ERROR_DLLOOM);
        SFree (Buffer);
        NtClose (DirectoryHandle);
        return ( FALSE );
    }

    ObjName_U.Buffer        = (PWSTR)FullNameObject;
    ObjName_U.Length        = 0;
    ObjName_U.MaximumLength = MAX_PATH * sizeof(WCHAR);

    //
    //  Form a Unicode string object to hold the symbolic link objects found
    //  in the object directory
    //

    if ((ObjectLink = SAlloc(MAX_PATH * sizeof(WCHAR))) == NULL) {
        SetErrorText(IDS_ERROR_DLLOOM);
        SFree (Buffer);
        SFree (FullNameObject);
        NtClose (DirectoryHandle);
        return ( FALSE );
    }

    ObjLink_U.Buffer        = (PWSTR)ObjectLink;
    ObjLink_U.Length        = 0;
    ObjLink_U.MaximumLength = MAX_PATH * sizeof(WCHAR);


    if ((SavedMatch = SAlloc(MAX_PATH * sizeof(WCHAR))) == NULL) {
        SetErrorText(IDS_ERROR_DLLOOM);
        SFree (Buffer);
        SFree (FullNameObject);
        SFree (ObjectLink);
        NtClose (DirectoryHandle);
        return ( FALSE );
    }

    SavedMatch_U.Buffer        = (PWSTR)SavedMatch;
    SavedMatch_U.Length        = 0;
    SavedMatch_U.MaximumLength = MAX_PATH * sizeof(WCHAR);

    while (TRUE) {
        //
        //  Clear the buffer
        //
        RtlZeroMemory( Buffer, BUFFER_SIZE);

        //
        // repeatedly Query the directory objects till done
        //

        Status = NtQueryDirectoryObject(
                     DirectoryHandle,
                     Buffer,
                     BUFFER_SIZE,
                     ReturnSingleEntry,  // fetch more than one entry
                     RestartScan,        // start rescan true on first go
                     &Context,
                     &ReturnedLength
                     );


        //
        //  Check the Status of the operation.
        //

        if (!NT_SUCCESS(Status) && (Status != STATUS_MORE_ENTRIES)) {
            if (Status == STATUS_NO_MORE_FILES || Status == STATUS_NO_MORE_ENTRIES) {
                SetErrorText(IDS_ERROR_INVALIDDISK);
            }
            else {
                SetErrorText(IDS_ERROR_OBJDIRREAD);
            }
            SFree(Buffer);
            SFree(FullNameObject);
            SFree(ObjectLink);
            if(IsMatchSaved) {
                RtlCopyUnicodeString (pSource_U, &SavedMatch_U);
                SFree(SavedMatch);
                return(TRUE);
            }
            SFree(SavedMatch);
            return(FALSE);
        }

        //
        // Make sure that restart scan is false for next go
        //
        RestartScan = FALSE;


        //
        //  For every record in the buffer, see if the type of the object
        //  is a symbolic link
        //

        //
        //  Point to the first record in the buffer, we are guaranteed to have
        //  one otherwise Status would have been No More Files
        //

        DirInfo = (POBJECT_DIRECTORY_INFORMATION) Buffer;

        while (TRUE) {

            //
            //  Check if there is another record.  If there isn't, break out of
            //  the loop now
            //

            if (DirInfo->Name.Length == 0) {
                break;
            }

            //
            //  See if the object type is a symbolic link
            //
            if (IsSymbolicLinkType(&(DirInfo->TypeName))) {

                //
                // get full pathname of object
                //

                //
                // Check if we will overflow our buffer
                //
                if ((
                     pObjDir_U->Length      +
                     sizeof(WCHAR)         +
                     DirInfo->Name.Length  +
                     sizeof(WCHAR)
                    ) > ObjName_U.MaximumLength )  {

                    SetErrorText(IDS_ERROR_OBJNAMOVF);
                    SFree(Buffer);
                    SFree(FullNameObject);
                    SFree(ObjectLink);

                    if(IsMatchSaved) {
                        RtlCopyUnicodeString (pSource_U, &SavedMatch_U);
                        SFree(SavedMatch);
                        return(TRUE);
                    }
                    SFree(SavedMatch);
                    return( FALSE );

                }

                //
                // Copy the current object name over the the buffer prefixing
                // it with the \ArcName\ object directory name
                //

                RtlCopyUnicodeString ( &ObjName_U, pObjDir_U );
                RtlAppendUnicodeToString ( &ObjName_U, L"\\" );
                RtlAppendUnicodeStringToString ( &ObjName_U, &(DirInfo->Name));

                //
                // query the symbolic link target
                //

                ObjLink_U.Buffer        = (PWSTR)ObjectLink;
                ObjLink_U.Length        = 0;
                ObjLink_U.MaximumLength = MAX_PATH * sizeof(WCHAR);

                bStatus = GetSymbolicLinkTarget (&ObjName_U, &ObjLink_U);
                if (bStatus != TRUE) {
                    SFree(Buffer);
                    SFree(FullNameObject);
                    SFree(ObjectLink);

                    if(IsMatchSaved) {
                        RtlCopyUnicodeString (pSource_U, &SavedMatch_U);
                        SFree(SavedMatch);
                        return(TRUE);
                    }
                    SFree(SavedMatch);
                    return FALSE;
                }

                //
                // see if it compares to the name we are looking for
                //

                if (RtlEqualUnicodeString (pTarget_U, &ObjLink_U, TRUE)) {

#if i386
                    UNICODE_STRING Multi_U;

                    RtlInitUnicodeString(&Multi_U,L"multi(");
                    if(RtlPrefixUnicodeString(&Multi_U,&DirInfo->Name,TRUE)) {

                        RtlCopyUnicodeString(&SavedMatch_U,&DirInfo->Name);
                        IsMatchSaved = TRUE;

                    } else  // scsi, just return it.  Favor scsi over multi.
#endif
                    {
                        RtlCopyUnicodeString (pSource_U, &(DirInfo->Name));
                        SFree(Buffer);
                        SFree(FullNameObject);
                        SFree(ObjectLink);
                        SFree(SavedMatch);
                        return TRUE;
                    }
                }

            }

            //
            //  There is another record so advance DirInfo to the next entry
            //

            DirInfo = (POBJECT_DIRECTORY_INFORMATION) (((PCHAR) DirInfo) +
                          sizeof( OBJECT_DIRECTORY_INFORMATION ) );

        }  // while

    } // while

    return ( FALSE );

} // getarcname



/* Checks to see if a given object type is a symbolic link type */

BOOL
IsSymbolicLinkType(
    IN PUNICODE_STRING Type
    )
{
    UNICODE_STRING  TypeName;

    //
    // Check the length of the string
    //
    if (Type->Length == 0) {
        return FALSE;
    }

    //
    // compare it to the symbolic link type name
    //
    RtlInitUnicodeString(&TypeName, SYMLINKTYPE);
    return (RtlEqualUnicodeString(Type, &TypeName, TRUE));
}





BOOL
GetSymbolicLinkTarget(
    IN     PUNICODE_STRING pSourceString_U,
    IN OUT PUNICODE_STRING pDestString_U
    )
{

    NTSTATUS          Status;

    OBJECT_ATTRIBUTES Attributes;
    HANDLE            ObjectHandle;

    //
    // Initialise the object attributes structure for the symbolic
    // link object

    InitializeObjectAttributes(
        &Attributes,
        pSourceString_U,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open the symbolic link for link_query access
    //

    Status = NtOpenSymbolicLinkObject(
                 &ObjectHandle,
                 READ_CONTROL | SYMBOLIC_LINK_QUERY,
                 &Attributes
                 );

    if (!NT_SUCCESS(Status)) {
        SetErrorText(IDS_ERROR_SYMLNKOPEN);
        return ( FALSE );
    }


    //
    // query the symbolic link target
    //

    Status = NtQuerySymbolicLinkObject(
                 ObjectHandle,
                 pDestString_U,
                 NULL
                 );

    if (!NT_SUCCESS(Status)) {
        SetErrorText(IDS_ERROR_SYMLNKREAD);
        NtClose(ObjectHandle);
        return(FALSE);
    }

    //
    // close the link object
    //

    NtClose(ObjectHandle);

    //
    // return the link target
    //
    return ( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\parse1.c ===
#include "precomp.h"
#pragma hdrstop
/**************************************************************************/
/***** Common Library Component - Parse Table Handling Routines 1 *********/
/**************************************************************************/


   //  Return the number of items in the given parse table.

static size_t countScp ( PSCP pscpTable )
{
    size_t i ;
    for (i = 0; pscpTable[i].sz ; i++) ;
    return i;
}

   //  Compare two parse table structures

static int __cdecl compareScps ( const void * scp1, const void * scp2 )
{
    return _stricmp( ((PSCP) scp1)->sz, ((PSCP) scp2)->sz );
}

   //  Allocate and initialize a sorted version of the given
   //  parse table

static PSCP reallocateSorted ( PSCP pscpTable )
{
    size_t cItems = countScp( pscpTable ) ;
    PSCP pscpSorted = (PSCP) calloc( cItems, sizeof (SCP) ) ;

    if (pscpSorted == NULL)
        return NULL;

    //  Copy and sort the new table.

    memcpy( (void *) pscpSorted,
            (void *) pscpTable,
            (size_t) cItems * sizeof (SCP) );

    qsort( pscpSorted,
           cItems,
           sizeof (SCP),
           compareScps );

    return pscpSorted ;
}

static PSPT allocateParseTable ( PSCP pscpTable )
{
    PSPT pspt = malloc( sizeof (SPT) ) ;
    if (pspt == NULL) {
        return NULL;
    }

    pspt->pscpSorted = reallocateSorted( pscpTable ) ;

    if (pspt->pscpSorted == NULL) {
        free( pspt );
        return NULL ;
    }

    pspt->pscpBase = pscpTable ;
    pspt->cItems   = countScp( pscpTable );
    pspt->spcDelim = pscpTable[ pspt->cItems ].spc ;

    return pspt ;
}

static void destroyParseTable ( PSPT parseTable )
{
    free( parseTable->pscpSorted );
    free( parseTable );
}

/*
**      Purpose:
**              Initializes a Parsing Table so a string can be searched for and its
**              corresponding code found and returned.
**      Arguments:
**              pscp: a non-NULL array of SCPs with the last one having an sz value
**                      of NULL and an SPC for indicating errors.
**      Returns:
**              NULL if an error occurs.
**              Non-NULL if the operation was successful.
**
**************************************************************************/
PSPT  APIENTRY PsptInitParsingTable(pscp)
PSCP pscp;
{
        AssertDataSeg();
        ChkArg(pscp != (PSCP)NULL, 1, (PSPT)NULL);

        return allocateParseTable( pscp ) ;
}


/*
**      Purpose:
**              Searches for a string in a String Parsing Table and returns its
**              associated code.
**      Arguments:
**              pspt: non-NULL String Parsing Table initialized by a successful
**                      call to PsptInitParsingTable()..
**              sz:   non-NULL string to search for.
**      Returns:
**              The corresponding SPC if sz is in pspt, or the SPC associated with
**                      the NULL in pspt if sz could not be found.
**
**************************************************************************/
SPC  APIENTRY SpcParseString(pspt, sz)
PSPT pspt;
SZ   sz;
{
    PSCP pscpResult ;
    SCP scpTemp ;

        AssertDataSeg();
        ChkArg(pspt != (PSPT)NULL, 1, spcError);
        ChkArg(sz != (SZ)NULL, 2, spcError);

        if (pspt == NULL || sz == NULL)
                return 0 ;

    scpTemp.sz = sz ;

    pscpResult = (PSCP) bsearch( (void *) & scpTemp,
                                 (void *) pspt->pscpSorted,
                                 pspt->cItems,
                                 sizeof (SCP),
                                 compareScps );

    return pscpResult
         ? pscpResult->spc
         : pspt->spcDelim ;
}


/*
**      Purpose:
**              Destroys a Parse Table (freeing any memory allocated).
**      Arguments:
**              pspt: non-NULL String Parsing Table to be destroyed that was
**                      initialized with a successful call to PsptInitParsingTable().
**      Returns:
**              fFalse if an error occurred.
**              fTrue if successful.
**
**************************************************************************/
BOOL  APIENTRY FDestroyParsingTable(pspt)
PSPT pspt;
{
        AssertDataSeg();
        ChkArg(pspt != (PSPT)NULL, 1, fFalse);

    destroyParseTable( pspt );

        return(fTrue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\parse2.c ===
#include "precomp.h"
#pragma hdrstop
/**************************************************************************/
/***** Common Library Component - Parse Table Handling Routines 2 *********/
/**************************************************************************/

extern BOOL APIENTRY FGetCmo(INT Line, UINT *pcFields, CMO * pcmo);

extern HWND     hWndShell;
extern UINT     iFieldCur;
extern BOOL     fFullScreen;

extern BOOL
FWaitForEventOrFailure(
    IN LPSTR InfVar,
    IN LPSTR Event,
    IN DWORD Timeout
    );

extern
BOOL
APIENTRY
FFlushInfParsedInfo(
    SZ szInfName
    );

VOID TermRestoreDiskLogging();

BOOL APIENTRY FParseBmpShow ( INT Line, UINT * pcFields ) ;
BOOL APIENTRY FParseBmpHide ( INT Line, UINT * pcFields ) ;

// PSEFL  pseflHead = (PSEFL)NULL;

/*
**      Array of String Code Pairs for initializing Flow Statement Handling
*/
SCP rgscpFlow[] = {
    { "SET",                  spcSet                  },
    { "SET-SUBSYM",           spcSetSubsym            },
    { "SET-SUBST",            spcSetSubst             },
    { "SET-ADD",              spcSetAdd               },
    { "SET-SUB",              spcSetSub               },
    { "SET-MUL",              spcSetMul               },
    { "SET-DIV",              spcSetDiv               },
    { "SET-OR",               spcSetOr                },
    { "SET-HEXTODEC",             spcSetHexToDec                  },
    { "SET-DECTOHEX",             spcSetDecToHex                  },
    { "IFSTR",                spcIfStr                },
    { "==",                   spcEQ                   },
    { "!=",                   spcNE                   },
    { "ELSE",                 spcElse                 },
    { "ENDIF",                spcEndIf                },
    { "GOTO",                 spcGoTo                 },
    { "ELSE-IFSTR",           spcElseIfStr            },
    { "IFINT",                spcIfInt                },
    { "<",                    spcLT                   },
    { "<=",                   spcLE                   },
    { "=<",                   spcLE                   },
    { ">",                    spcGT                   },
    { ">=",                   spcGE                   },
    { "=>",                   spcGE                   },
    { "ELSE-IFINT",           spcElseIfInt            },
    { "IFSTR(I)",             spcIfStrI               },
    { "ELSE-IFSTR(I)",        spcElseIfStrI           },
    { "IFCONTAINS",           spcIfContains           },
    { "IFCONTAINS(I)",        spcIfContainsI          },
    { "IN",                   spcIn                   },
    { "NOT-IN",               spcNotIn                },
    { "ELSE-IFCONTAINS",      spcElseIfContains       },
    { "ELSE-IFCONTAINS(I)",   spcElseIfContainsI      },
    { "FORLISTDO",            spcForListDo            },
    { "ENDFORLISTDO",         spcEndForListDo         },
    { "DEBUG-MSG",            spcDebugMsg             },
    { "STARTWAIT",            spcHourglass            },
    { "ENDWAIT",              spcArrow                },
    { "SETHELPFILE",          spcSetHelpFile          },
    { "CREATEREGKEY",         spcCreateRegKey         },
    { "OPENREGKEY",           spcOpenRegKey           },
    { "FLUSHREGKEY",          spcFlushRegKey          },
    { "CLOSEREGKEY",          spcCloseRegKey          },
    { "DELETEREGKEY",         spcDeleteRegKey         },
    { "DELETEREGTREE",        spcDeleteRegTree        },
    { "ENUMREGKEY",           spcEnumRegKey           },
    { "SETREGVALUE",          spcSetRegValue          },
    { "GETREGVALUE",          spcGetRegValue          },
    { "DELETEREGVALUE",       spcDeleteRegValue       },
    { "ENUMREGVALUE",         spcEnumRegValue         },
    { "GETDRIVEINPATH",       spcGetDriveInPath       },
    { "GETDIRINPATH",         spcGetDirInPath         },
    { "LOADLIBRARY",          spcLoadLibrary          },
    { "FREELIBRARY",          spcFreeLibrary          },
    { "LIBRARYPROCEDURE",     spcLibraryProcedure     },
    { "RUNPROGRAM",           spcRunExternalProgram   },
    { "INVOKEAPPLET",         spcInvokeApplet         },
    { "STARTDETACHEDPROCESS", spcStartDetachedProcess },
    { "DEBUG-OUTPUT",         spcDebugOutput          },
    { "SPLIT-STRING",         spcSplitString          },
    { "QUERYLISTSIZE",        spcQueryListSize        },
    { "ADDFILETODELETELIST",  spcAddFileToDeleteList  },
    { "INITRESTOREDISKLOG",   spcInitRestoreDiskLog   },
    { "WAITONEVENT",          spcWaitOnEvent          },
    { "SIGNALEVENT",          spcSignalEvent          },
    { "SLEEP",                spcSleep                },
    { "FLUSHINF",             spcFlushInf             },
    { "BMPSHOW",              spcBmpShow              },
    { "BMPHIDE",              spcBmpHide              },
    { "TERMRESTOREDISKLOG",   spcTermRestoreDiskLog   },
    { NULL,                   spcUnknown              }
    };
/*
**      String Parsing Table for handling Flow Statements
*/
PSPT   psptFlow = (PSPT)NULL;


/*
**      Purpose:
**              Evaluates an expression and determines whether it is valid, and if
**              so, if it is true or false.  Used by FHandleFlowStatements().
**      Arguments:
**              hwndParent: window handle to be used in MessageBoxes.
**              ecm:        Comparison Mode (eg ecmIfStr, ecmIfInt)
**              szArg1:     Non-NULL string for left argument.
**              szArg2:     Non-NULL string for right argument.
**              szOper:     Non-NULL string for operator (eg '==', '>=', etc).
**      Notes:
**              Requires that psptFlow was initialized with a successful call to
**              FInitFlowPspt().
**      Returns:
**              ercError if comparison is not valid (eg operator and ecm don't
**                      correspond).
**              ercTrue if expression evaluates to fTrue.
**              ercFalse if expression evaluates to fFalse.
**
**************************************************************************/
ERC APIENTRY ErcEvaluateCompare(HWND hwndParent,
                                            ECM  ecm,
                                            SZ   szArg1,
                                            SZ   szArg2,
                                            SZ   szOper)
{
        SPC spc;

        PreCondFlowInit(ecmError);

        ChkArg(ecm == ecmIfStr ||
                        ecm == ecmIfStrI ||
                        ecm == ecmIfInt ||
                        ecm == ecmIfContains ||
                        ecm == ecmIfContainsI, 1, ecmError);
        ChkArg(szArg1 != (SZ)NULL, 2, ecmError);
        ChkArg(szArg2 != (SZ)NULL, 3, ecmError);
        ChkArg(szOper != (SZ)NULL &&
                        *szOper != '\0', 4, ecmError);

    EvalAssert((spc = SpcParseString(psptFlow, szOper)) != spcError);

        switch (ecm)
                {
        case ecmIfStrI:
                EvalAssert(SzStrUpper(szArg1) == szArg1);
                EvalAssert(SzStrUpper(szArg2) == szArg2);
        case ecmIfStr:
                /* BLOCK */
                        {
                        CRC crc = CrcStringCompare(szArg1, szArg2);

                        switch (spc)
                                {
                        case spcEQ:
                                return ((crc == crcEqual) ? ercTrue : ercFalse);
                        case spcNE:
                                return ((crc != crcEqual) ? ercTrue : ercFalse);
                                }
                        }
                break;

        case ecmIfInt:
                /* BLOCK */
                        {
                        LONG arg1 = atol(szArg1);
                        LONG arg2 = atol(szArg2);

                        switch (spc)
                                {
                        case spcEQ:
                                return ((arg1 == arg2) ? ercTrue : ercFalse);
                        case spcNE:
                                return ((arg1 != arg2) ? ercTrue : ercFalse);
                        case spcLT:
                                return ((arg1 < arg2) ? ercTrue : ercFalse);
                        case spcLE:
                                return ((arg1 <= arg2) ? ercTrue : ercFalse);
                        case spcGT:
                                return ((arg1 > arg2) ? ercTrue : ercFalse);
                        case spcGE:
                                return ((arg1 >= arg2) ? ercTrue : ercFalse);
                                }
                        }
                break;

        case ecmIfContainsI:
                EvalAssert(SzStrUpper(szArg1) == szArg1);
                EvalAssert(SzStrUpper(szArg2) == szArg2);
        case ecmIfContains:
                switch (spc)
                        {
                case spcIn:
                case spcNotIn:
                        /* BLOCK */
                                {
                                RGSZ rgsz;
                                PSZ  psz;

                                while ((rgsz = RgszFromSzListValue(szArg2)) == (RGSZ)NULL)
                                        if (!FHandleOOM(hwndParent))
                                                return(ercError);

                                if ((psz = rgsz) != (RGSZ)NULL)
                                        {
                                        while (*psz != (SZ)NULL)
                                                {
                                                if (CrcStringCompare(szArg1, *psz) == crcEqual)
                                                        {
                                                        EvalAssert(FFreeRgsz(rgsz));
                                                        return((spc == spcIn) ? ercTrue : ercFalse);
                                                        }
                                                psz++;
                                                }

                                        EvalAssert(FFreeRgsz(rgsz));
                                        return((spc == spcIn) ? ercFalse : ercTrue);
                                        }
                                }
                        }
                break;
                }

        return(ercError);
}


/*
**      Purpose:
**              Skips Script statements until an ENDIF statement is reached.
**      Arguments:
**              hwndParent: window handle to be used in MessageBoxes.
**      Notes:
**              Requires that psptFlow was initialized with a successful call to
**              FInitFlowPspt().
**      Returns:
**              fTrue if successful.
**              fFalse if an ENDIF was not found before running out of Script
**                      statements in the current INF section.
**
**************************************************************************/
BOOL APIENTRY FSkipToEnd(INT *Line,HWND hwndParent)
{
    UINT cEndsToSkip = 1;
    UINT cFields;
    SZ   szCmd;
    SPC  spc;

        PreCondFlowInit(fFalse);

        do  {
                do {
            if ((*Line = FindNextLineFromInf(*Line)) == -1)
                                return(fTrue);  /* REVIEW */
            } while ((cFields = CFieldsInInfLine(*Line)) == 0);

        while ((szCmd = SzGetNthFieldFromInfLine(*Line,1)) == (SZ)NULL)
                        if (!FHandleOOM(hwndParent))
                                return(fFalse);

        EvalAssert((spc = SpcParseString(psptFlow, szCmd)) != spcError);
                SFree(szCmd);

                if (spc >= spcIfFirst &&
                                spc <= spcIfLast)
                        cEndsToSkip++;
                } while (spc != spcEndIf ||
                                cEndsToSkip-- != 1);

        return(fTrue);   /* REVIEW */
        return((BOOL)(cFields == 1));
}


/*
**      Purpose:
**              Skips to the next ELSE or ENDIF statement, and if it is an ELSE-IF,
**              evaluates it and possibly skips to the next ELSE statement.
**      Arguments:
**              hwndParent: window handle to be used in MessageBoxes.
**      Notes:
**              Requires that psptFlow was initialized with a successful call to
**              FInitFlowPspt().
**      Returns:
**              fTrue if successful.
**              fFalse if an ENDIF or ELSEIF was not found before running out of Script
**                      statements in the current INF section.
**
**************************************************************************/
BOOL APIENTRY FSkipToElse(INT *Line,HWND hwndParent)
{
    UINT cEndsToSkip = 0;
    UINT cFields;
        SPC    spc;

        PreCondFlowInit(fFalse);

        do  {
                ECM  ecm;
                ERC  erc;
        RGSZ rgsz;
        SZ   sz;

        if ((*Line = FindNextLineFromInf(*Line)) == -1)
            return(fTrue);

        while((sz = SzGetNthFieldFromInfLine(*Line,1)) == NULL) {
            if(!FHandleOOM(hwndParent)) {
                return(FALSE);
            }
        }

        EvalAssert((spc = SpcParseString(psptFlow, sz)) != spcError);

        if ((spc >= spcIfFirst) && (spc <= spcIfLast)) {
            cEndsToSkip++;
        }

        if (cEndsToSkip > 0) {
            SFree(sz);
                        continue;
        }

        if (spc == spcElseIfStr) {
                        ecm = ecmIfStr;
        } else if (spc == spcElseIfInt) {
                        ecm = ecmIfInt;
        } else if (spc == spcElseIfStrI) {
                        ecm = ecmIfStrI;
        } else if (spc == spcElseIfContains) {
                        ecm = ecmIfContains;
        } else if (spc == spcElseIfContainsI) {
                        ecm = ecmIfContainsI;
        } else {
            SFree(sz);
            continue;
        }

        cFields = CFieldsInInfLine(*Line);

        if (cFields != 4) {
            SFree(sz);
                        continue;   /* REVIEW */
                        return(fFalse);
        }

        SFree(sz);

        while((rgsz = RgszFromInfScriptLine(*Line,cFields)) == NULL) {
            if(!FHandleOOM(hwndParent)) {
                return(FALSE);
            }
        }

        if (spc == spcIfStrI || spc == spcIfContainsI) {

                        EvalAssert(SzStrUpper(rgsz[1]) == rgsz[1]);
                        EvalAssert(SzStrUpper(rgsz[3]) == rgsz[3]);
        }

                if ((erc = ErcEvaluateCompare(hwndParent, ecm, rgsz[1], rgsz[3],
                                rgsz[2])) == ercError)
        {
                        EvalAssert(FFreeRgsz(rgsz));
                        continue;  /* REVIEW */
                        return(fFalse);
        }

                EvalAssert(FFreeRgsz(rgsz));

                if (erc == ercTrue)
            return(fTrue);

    } while ((spc != spcEndIf || cEndsToSkip-- > 0) && (spc != spcElse || cEndsToSkip > 0));

        return(fTrue);  /* REVIEW */
        return((BOOL)(cFields == 1));
}


/*
**      Purpose:
**              Allocates a new empty SEFL struct.
**      Arguments:
**              none
**      Returns:
**              non-Null PSEFL if successful; NULL otherwise.
**
**************************************************************************/
PSEFL APIENTRY PseflAlloc(VOID)
{
        PSEFL psefl;

        if ((psefl = (PSEFL)SAlloc((CB)sizeof(SEFL))) != (PSEFL)NULL)
                {
                psefl->rgszList    = (RGSZ)NULL;
                psefl->szDollarSav = (SZ)NULL;
                psefl->szPoundSav  = (SZ)NULL;
                }

        return(psefl);
}


/*
**      Purpose:
**              Frees an SEFL struct and any non-Null fields.
**      Arguments:
**              psefl: non-Null SEFL to free.
**      Returns:
**              fTrue if successful; fFalse otherwise.
**
**************************************************************************/
BOOL APIENTRY FFreePsefl(psefl)
PSEFL psefl;
{
    ChkArg(psefl != (PSEFL)NULL, 1, fFalse);

    if(psefl->rgszList) {
        FFreeRgsz(psefl->rgszList);
    }

    if(psefl->szDollarSav) {
        SFree(psefl->szDollarSav);
    }

    if(psefl->szPoundSav) {
        SFree(psefl->szPoundSav);
    }

    SFree(psefl);

    return(fTrue);
}


/*
**      Purpose:
**              Skips Script statements until an ENDFORLISTDO statement is reached.
**      Arguments:
**              hwndParent: window handle to be used in MessageBoxes.
**      Notes:
**              Requires that psptFlow was initialized with a successful call to
**              FInitFlowPspt().
**      Returns:
**              fTrue if successful.
**              fFalse if an ENDFORLISTDO was not found before running out of Script
**                      statements in the current INF section.
**
**************************************************************************/
BOOL APIENTRY FSkipToEndOfLoop(INT *Line,HWND hwndParent)
{
    UINT cEndOfLoopsToSkip = 1;
    UINT cFields;
    SZ   szCmd;
    SPC  spc;

        PreCondFlowInit(fFalse);

        do  {
                do {
            if ((*Line = FindNextLineFromInf(*Line)) == -1)
                                return(fTrue);  /* REVIEW */
            } while ((cFields = CFieldsInInfLine(*Line)) == 0);

        while ((szCmd = SzGetNthFieldFromInfLine(*Line,1)) == (SZ)NULL)
                        if (!FHandleOOM(hwndParent))
                                return(fFalse);

        EvalAssert((spc = SpcParseString(psptFlow, szCmd)) != spcError);
                SFree(szCmd);

                if (spc == spcForListDo)
                        cEndOfLoopsToSkip++;
                } while (spc != spcEndForListDo ||
                                cEndOfLoopsToSkip-- != 1);

        return(fTrue);  /* REVIEW */
        return((BOOL)(cFields == 1));
}


/*
**      Purpose:
**              Handles a ForListDo statement by setting up the appropriate structs
**              and setting $($) and $(#).
**      Arguments:
**              hwndParent: window handle to be used in MessageBoxes.
**              szList:     non-Null list to handle in For Loop.
**      Notes:
**              Requires that psptFlow was initialized with a successful call to
**              FInitFlowPspt().
**              Requires that statements within the loop do not jump out of the loop
**              (eg no GoTo to outside the loop or If/EndIf block that straddles a loop
**              boundary).
**      Returns:
**              fTrue if successful; fFalse otherwise.
**
**************************************************************************/
BOOL APIENTRY FInitForLoop(INT *Line,HWND hwndParent,SZ szList)
{
        PSEFL psefl;
        RGSZ  rgsz;
        SZ    sz;

        ChkArg(szList != (SZ)NULL, 1, fFalse);

        PreCondFlowInit(fFalse);

        while ((rgsz = RgszFromSzListValue(szList)) == (RGSZ)NULL)
                if (!FHandleOOM(hwndParent))
                        return(fFalse);

        if (*rgsz == (SZ)NULL)
                {
                EvalAssert(FFreeRgsz(rgsz));
        return(FSkipToEndOfLoop(Line,hwndParent));
                }

        while ((psefl = PseflAlloc()) == (PSEFL)NULL)
                if (!FHandleOOM(hwndParent))
                        {
                        EvalAssert(FFreeRgsz(rgsz));
                        return(fFalse);
                        }

        psefl->rgszList = rgsz;
        psefl->iItemCur = 1;

    psefl->iStartLine = *Line;
        if ((sz = SzFindSymbolValueInSymTab("$")) != (SZ)NULL)
                while ((psefl->szDollarSav = SzDupl(sz)) == (SZ)NULL)
                        if (!FHandleOOM(hwndParent))
                                {
                                EvalAssert(FFreePsefl(psefl));
                                return(fFalse);
                                }

        if ((sz = SzFindSymbolValueInSymTab("#")) != (SZ)NULL)
                while ((psefl->szPoundSav = SzDupl(sz)) == (SZ)NULL)
                        if (!FHandleOOM(hwndParent))
                                {
                                EvalAssert(FFreePsefl(psefl));
                                return(fFalse);
                                }

        while (!FAddSymbolValueToSymTab("#", "1"))
                if (!FHandleOOM(hwndParent))
                        {
                        EvalAssert(FFreePsefl(psefl));
                        return(fFalse);
                        }

        while (!FAddSymbolValueToSymTab("$", rgsz[0]))
                if (!FHandleOOM(hwndParent))
                        {
                        EvalAssert(FFreePsefl(psefl));
                        return(fFalse);
                        }

    psefl->pseflNext = pLocalContext()->pseflHead;
    pLocalContext()->pseflHead = psefl;

        return(fTrue);
}


/*
**      Purpose:
**              Handles an EndForListDo statement by resetting $($) and $(#) and
**              jumping back to the top of the loop (if appropriate).
**      Arguments:
**              hwndParent: window handle to be used in MessageBoxes.
**      Notes:
**              Requires that a ForListDo statement was previously successfully handled.
**      Returns:
**              fTrue if successful; fFalse otherwise.
**
**************************************************************************/
BOOL APIENTRY FContinueForLoop(INT *Line,HWND hwndParent)
{
    PSEFL psefl = pLocalContext()->pseflHead;
        PCHP  rgchp = (PCHP)NULL;

        PreCondition(psefl != (PSEFL)NULL, fFalse);

        if (*(psefl->rgszList + psefl->iItemCur) == (SZ)NULL)
                {
        pLocalContext()->pseflHead = psefl->pseflNext;

                if (psefl->szDollarSav == (SZ)NULL)
                        EvalAssert(FRemoveSymbolFromSymTab("$"));
                else
                        while (!FAddSymbolValueToSymTab("$", psefl->szDollarSav))
                                if (!FHandleOOM(hwndParent))
                                        return(fFalse);

                if (psefl->szPoundSav == (SZ)NULL)
                        EvalAssert(FRemoveSymbolFromSymTab("#"));
                else
                        while (!FAddSymbolValueToSymTab("#", psefl->szPoundSav))
                                if (!FHandleOOM(hwndParent))
                                        return(fFalse);

                EvalAssert(FFreePsefl(psefl));

                return(fTrue);
                }

        while (!FAddSymbolValueToSymTab("$", *(psefl->rgszList + psefl->iItemCur)))
                if (!FHandleOOM(hwndParent))
                        return(fFalse);
        while ((rgchp = (PCHP)SAlloc((CB)(20 * sizeof(CHP)))) == (PCHP)NULL)
                if (!FHandleOOM(hwndParent))
                        return(fFalse);
        EvalAssert(_itoa(++(psefl->iItemCur), rgchp, 10) == rgchp);
        while (!FAddSymbolValueToSymTab("#", rgchp))
                if (!FHandleOOM(hwndParent))
                        {
                        SFree(rgchp);
                        return(fFalse);
                        }

        SFree(rgchp);
    *Line = psefl->iStartLine;

        return(fTrue);
}


/*
**      Purpose:
**              Processes a string and replaces symbol references ('$(SYM)').
**      Arguments:
**              hwndParent: window handle to be used in MessageBoxes.
**              sz:         non-Null string to process.
**      Returns:
**              non-Null string if successful; Null otherwise.
**
**************************************************************************/
SZ APIENTRY SzProcessSzForSyms(hwndParent, sz)
HWND hwndParent;
SZ   sz;
{
        SZ szNew, szCur;

        ChkArg(sz != (SZ)NULL, 1, (SZ)NULL);

        /* REVIEW doesn't check for running off end of buffer */
    while ((szNew = (SZ)SAlloc((CB)cbSymbolMax)) == (SZ)NULL)
                if (!FHandleOOM(hwndParent))
                        return((SZ)NULL);

        szCur = szNew;
        while (*sz != '\0')
                {
                SZ szNext;

                if (*sz == '$' && *(sz + 1) == '(')
                        {
                        szNext = sz;

                        while (*szNext != ')' && *szNext != '\0')
                                szNext++;

                        if (*szNext == ')')
                                {
                                SZ szValue;

                                *szNext = '\0';
                                sz += 2;

                                if ((szValue = SzFindSymbolValueInSymTab(sz)) != (SZ)NULL)
                                        {
                                        EvalAssert(strcpy(szCur, szValue) == szCur);
                                        while (*szCur != '\0')
                                                szCur = SzNextChar(szCur);
                                        }

                                *szNext = ')';
                                sz = szNext + 1;
                                continue;
                                }
                        }

                szNext = SzNextChar(sz);
                while (sz < szNext)
                        *szCur++ = *sz++;
                }

        *szCur = '\0';
    Assert(strlen(szNew) < (CB)(cbSymbolMax - 1));

    szCur = SRealloc(szNew,strlen(szNew)+1);
    Assert(szCur);

        return(szCur);
}


/*
**      Purpose:
**              Processes a string and replaces escape sequences (\n \r \t \###
**              where ### is an octal number) with their byte equivalent.
**      Arguments:
**              hwndParent: window handle to be used in MessageBoxes.  NULL implies
**                      no message box - just fail.
**              sz:         non-Null string to process.
**      Returns:
**              non-Null string if successful; Null otherwise.
**
**************************************************************************/
SZ APIENTRY SzProcessSz(hwndParent, sz)
HWND hwndParent;
SZ   sz;
{
        SZ szNew, szCur;

    ChkArg(sz != (SZ)NULL && strlen(sz) < cbSymbolMax, 2, (SZ)NULL);

    while ((szNew = (SZ)SAlloc(cbSymbolMax)) == (SZ)NULL)
                if (hwndParent == NULL || !FHandleOOM(hwndParent))
                        return((SZ)NULL);

        szCur = szNew;
        while (*sz != '\0')
                {
                if (*sz == '\\')
                        {
                        CHP chp1, chp2, chp3;

                        if ((chp1 = *(++sz)) == '\\')
                                *szCur++ = '\\';
                        else if (chp1 == 'n')
                                *szCur++ = '\n';
                        else if (chp1 == 'r')
                                *szCur++ = '\r';
                        else if (chp1 == 't')
                                *szCur++ = '\t';
                        else if (chp1 < '0' || chp1 > '7' ||
                                        (chp2 = *(sz + 1)) < '0' || chp2 > '7')
                                {
                                *szCur++ = '\\';
                                *szCur++ = chp1;
                                }
                        else if ((chp3 = *(sz + 2)) < '0' || chp3 > '7' ||
                                        (chp1 == '0' && chp2 == '0' && chp3 == '0'))
                                {
                                *szCur++ = '\\';
                                *szCur++ = chp1;
                                *szCur++ = chp2;
                                *szCur++ = chp3;
                                sz += 2;
                                }
                        else
                                {
                                *szCur++ = (CHP)(64*(chp1-'0') + 8*(chp2-'0') + chp3-'0');
                                sz += 2;
                                }
                        sz++;
                        }
                else
                        {
                        SZ szNext;

                        szNext = SzNextChar(sz);
                        while (sz < szNext)
                                *szCur++ = *sz++;
                        }
                }

        *szCur = '\0';
    Assert(strlen(szNew) < (CB)cbSymbolMax);

        while ((szCur = SzDupl(szNew)) == (SZ)NULL)
                if (hwndParent == NULL || !FHandleOOM(hwndParent))
                        return((SZ)NULL);

    SFree(szNew);

        return(szCur);
}


/*
**      Purpose:
**              Handles Flow Script statements (IFs, ELSEs, ENDIFs, GOTOs, SETs),
**              returning when an unrecognized statement is encountered.
**  Arguments:
**      CurrentLine: current line #, gets new line # if return value is fTrue
**              hwndParent: window handle to be used in MessageBoxes.
**      szSection:  non-NULL, non-empty section label (goto statements).
**      CallerCFields: if non-NULL, will be filled with the number of fields
**                    on the line with the unrecognized statement (if
**                    returning TRUE)
**      CallerRgsz: if non-NULL, will get a pointer to the rgsz for the line
**                  with the unrecognized statement (if returning true).
**      Notes:
**              Requires that psptFlow was initialized with a successful call to
**              FInitFlowPspt(), that an INF file was successfully opened, that
**              the INF Read location is defined and pointing at the beginning of
**              a script line to be interpreted, and that the Symbol Table was
**              successfully initialized.
**      Returns:
**      fTrue if an unrecognized statement is reached.
**          The caller must free rgsz if CallerRgsz was non-NULL.
**              fFalse if the end of the section is reached before an unrecognized
**                      statement is reached, or if a Flow statement has an invalid
**                      format.
**
**************************************************************************/
BOOL APIENTRY FHandleFlowStatements(INT  *CurrentLine,
                                               HWND hwndParent,
                                               SZ   szSection,
                                               UINT *CallerCFields,
                                               RGSZ *CallerRgsz)
{
        SPC  spc;
    RGSZ rgsz;
    INT  Line = *CurrentLine;
    CHP  rgchNum[20];

        PreCondFlowInit(fFalse);
        PreCondInfOpen(fFalse);
        PreCondSymTabInit(fFalse);

        ChkArg(szSection != (SZ)NULL &&
                        *szSection != '\0' &&
                        *szSection != '[', 1, fFalse);

        while (fTrue)
                {
        UINT cFields;
        ECM  ecm;
        ERC  erc;
        SZ   sz, sz2 ;

        if ((cFields = CFieldsInInfLine(Line)) == 0)
                        {
                        rgsz = (RGSZ)NULL;
                        spc = spcSet;
                        goto LNextFlowLine;
                        }

        while ((rgsz = RgszFromInfScriptLine(Line,cFields)) == (RGSZ)NULL)
                        if (!FHandleOOM(hwndParent))
                                return(fFalse);

        switch ((spc = SpcParseString(psptFlow, rgsz[0])))
                        {
                case spcSet:
            SdAtNewLine(Line);

            if (cFields != 4 ||
                                        *(rgsz[1]) == '\0' ||
                                        CrcStringCompare(rgsz[2], "=") != crcEqual)
                                goto LFlowParseError;

                        while (!FAddSymbolValueToSymTab(rgsz[1], rgsz[3]))
                                if (!FHandleOOM(hwndParent))
                                        goto LFlowParseExitErr;
                        break;

                case spcSetSubsym:
                case spcSetSubst:
            SdAtNewLine(Line);
            if (cFields != 4 ||
                                        *(rgsz[1]) == '\0' ||
                                        CrcStringCompare(rgsz[2], "=") != crcEqual)
                                goto LFlowParseError;

                        if ((spc == spcSetSubsym &&
                                         (sz=SzProcessSzForSyms(hwndParent,rgsz[3])) == (SZ)NULL) ||
                                        (spc == spcSetSubst &&
                                         (sz = SzProcessSz(hwndParent, rgsz[3])) == (SZ)NULL))
                                goto LFlowParseExitErr;

                        while (!FAddSymbolValueToSymTab(rgsz[1], sz))
                                if (!FHandleOOM(hwndParent))
                                        {
                                        SFree(sz);
                                        goto LFlowParseExitErr;
                                        }

                        SFree(sz);
                        break;

        case spcSetAdd:
        case spcSetSub:
        case spcSetMul:
        case spcSetDiv:
        case spcSetOr:

            SdAtNewLine(Line);
            if ( cFields != 5       ||
                 *(rgsz[1]) == '\0' ||
                 CrcStringCompare(rgsz[2], "="
                 ) != crcEqual) {

                goto LFlowParseError;
            }

            switch ( spc ) {

            case spcSetAdd:

                _ltoa ( atol(rgsz[3]) + atol(rgsz[4]), rgchNum, 10 );
                break;

            case spcSetSub:

                _ltoa ( atol(rgsz[3]) - atol(rgsz[4]), rgchNum, 10 );
                break;

            case spcSetMul:

                _ltoa ( atol(rgsz[3]) * atol(rgsz[4]), rgchNum, 10 );
                break;


            case spcSetDiv:

                _ltoa ( atol(rgsz[3]) / atol(rgsz[4]), rgchNum, 10 );
                break;

            case spcSetOr:
                _ultoa ( (ULONG)atol(rgsz[2]) | (ULONG)atol(rgsz[4]), rgchNum, 10);
                break;

            default:
                break;

            }

            while (!FAddSymbolValueToSymTab(rgsz[1], rgchNum)) {
                if (!FHandleOOM(hwndParent)) {
                                        goto LFlowParseExitErr;
                }
            }

            break;



                case spcSetHexToDec:
            SdAtNewLine(Line);
            if (cFields != 4 ||
                                        *(rgsz[1]) == '\0' ||
                                        CrcStringCompare(rgsz[2], "=") != crcEqual)
                                goto LFlowParseError;


                        _ltoa ( strtoul(rgsz[3],(char **)NULL,16), rgchNum, 10 );
                        while (!FAddSymbolValueToSymTab(rgsz[1], rgchNum))
                                if (!FHandleOOM(hwndParent))
                                        goto LFlowParseExitErr;
                        break;

                case spcSetDecToHex:
            SdAtNewLine(Line);
            if (cFields != 4 ||
                                        *(rgsz[1]) == '\0' ||
                                        CrcStringCompare(rgsz[2], "=") != crcEqual)
                                goto LFlowParseError;

                        wsprintf(rgchNum,"0x%X",atol(rgsz[3]));
                        while (!FAddSymbolValueToSymTab(rgsz[1], rgchNum))
                                if (!FHandleOOM(hwndParent))
                                        goto LFlowParseExitErr;
                        break;

                case spcDebugMsg:
#if DBG
            SdAtNewLine(Line);
            if (cFields != 2)
                                goto LFlowParseError;

                        if ((sz = SzProcessSzForSyms(hwndParent, rgsz[1])) == (SZ)NULL)
                                goto LFlowParseExitErr;

            EvalAssert(LoadString(hInst, IDS_ERROR, rgchBufTmpShort, cchpBufTmpShortMax));
            MessageBox(hwndParent, sz, rgchBufTmpShort, MB_OK | MB_TASKMODAL);

                        SFree(sz);
#endif /* DBG */
                        break;

                case spcIfStrI:
                        ecm = ecmIfStrI;
                        goto LHandleIfs;
                case spcIfInt:
                        ecm = ecmIfInt;
                        goto LHandleIfs;
                case spcIfContains:
                        ecm = ecmIfContains;
                        goto LHandleIfs;
                case spcIfContainsI:
                        ecm = ecmIfContainsI;
                        goto LHandleIfs;
                case spcIfStr:
                        ecm = ecmIfStr;
LHandleIfs:
            SdAtNewLine(Line);
            if (cFields != 4)
                                goto LFlowParseError;

                        if (spc == spcIfStrI ||
                                        spc == spcIfContainsI)
                                {
                                EvalAssert(SzStrUpper(rgsz[1]) == rgsz[1]);
                                EvalAssert(SzStrUpper(rgsz[3]) == rgsz[3]);
                                }

                        if ((erc = ErcEvaluateCompare(hwndParent, ecm, rgsz[1], rgsz[3],
                                        rgsz[2])) == ercError)
                                goto LFlowParseError;

                        if (erc == ercFalse &&
                    !FSkipToElse(&Line,hwndParent))
                                goto LFlowParseExitErr;
                        break;

                case spcEndIf:
            SdAtNewLine(Line);
            if (cFields != 1)
                                goto LFlowParseError;
                        break;

                case spcElse:
            SdAtNewLine(Line);
            if (cFields != 1)
                                goto LFlowParseError;
                case spcElseIfStr:
                case spcElseIfStrI:
                case spcElseIfInt:
                case spcElseIfContains:
                case spcElseIfContainsI:
            SdAtNewLine(Line);
            if (spc != spcElse &&
                                        cFields != 4)
                                goto LFlowParseError;

            if (!FSkipToEnd(&Line,hwndParent))
                                goto LFlowParseExitErr;
                        break;

                case spcGoTo:
            SdAtNewLine(Line);
            if (cFields != 2 ||
                                        *(rgsz[1]) == '\0' ||
                    (Line = FindLineFromInfSectionKey(szSection, rgsz[1])) == -1)
                                goto LFlowParseError;
                        break;

                case spcForListDo:
            SdAtNewLine(Line);
            if (cFields != 2)
                                goto LFlowParseError;

            if (!FInitForLoop(&Line,hwndParent, rgsz[1]))
                                goto LFlowParseExitErr;
                        break;

                case spcEndForListDo:
            SdAtNewLine(Line);
            if (cFields != 1)
                                goto LFlowParseError;

            if (!FContinueForLoop(&Line,hwndParent))
                                goto LFlowParseExitErr;
            break;

        case spcHourglass:
            SdAtNewLine(Line);
            if(cFields != 1) {
                goto LFlowParseError;
            }
            SetCursor(CurrentCursor = LoadCursor(NULL,IDC_WAIT));
            break;

        case spcArrow:
            SdAtNewLine(Line);
            if(cFields != 1) {
                goto LFlowParseError;
            }
            SetCursor(CurrentCursor = LoadCursor(NULL,IDC_ARROW));
            break;

        case spcSetHelpFile:
            SdAtNewLine(Line);

            //
            // Command is SetHelpFile "helpfilename" "locontext" "highcontext" "helpindex-optional"
            //

            if (cFields < 4) {
                goto LFlowParseError;
            }

            if (cFields == 4) {
                if ( !FInitWinHelpFile (
                          hWndShell,
                          rgsz[1],
                          rgsz[2],
                          rgsz[3],
                          (SZ)NULL
                          ) ) {
                   goto LFlowParseExitErr;
                }
            }
            else {
                if ( !FInitWinHelpFile (
                          hWndShell,
                          rgsz[1],
                          rgsz[2],
                          rgsz[3],
                          rgsz[4]
                          ) ) {
                   goto LFlowParseExitErr;
                }
            }

            break;

        case spcGetDriveInPath:

            SdAtNewLine(Line);
            {
                SZ   sz;
                CHP  chp1, chp2, rgchDrive[3];

                //
                // Command: GetDriveInPath DriveVar, Path
                //

                if (cFields != 3) {
                    goto LFlowParseError;
                }

                sz           = rgsz[2];
                rgchDrive[0] = '\0';

                if ( ((chp1 = *sz++) != '\0') &&
                     ((chp2 = *sz)   == ':')  &&
                     ((chp1 >= 'a' && chp1 <='z') || (chp1 >= 'A' && chp1 <= 'Z'))) {
                    rgchDrive[0] = chp1;
                    rgchDrive[1] = chp2;
                    rgchDrive[2] = '\0';
                }

                while (!FAddSymbolValueToSymTab(rgsz[1], rgchDrive)) {
                    if (!FHandleOOM(hwndParent)) {
                        goto LFlowParseExitErr;
                    }
                }



                break;
            }

        case spcGetDirInPath:

            SdAtNewLine(Line);
            {
                SZ   sz, sz1;
                SZ   szUNDEF = "";

                //
                // Command: GetDirInPath DirVar, Path
                //

                if (cFields != 3) {
                    goto LFlowParseError;
                }

                sz  = rgsz[2];
                sz1 = (SZ)strchr(sz, '\\');

                if (sz1 == NULL) {

                   sz1 = szUNDEF;

                }

                while (!FAddSymbolValueToSymTab(rgsz[1], sz1)) {
                    if (!FHandleOOM(hwndParent)) {
                        goto LFlowParseExitErr;
                    }
                }
                break;
            }


        case spcCreateRegKey:
        case spcOpenRegKey:
        case spcFlushRegKey:
        case spcCloseRegKey:
        case spcDeleteRegKey:
        case spcDeleteRegTree:
        case spcEnumRegKey:
        case spcSetRegValue:
        case spcGetRegValue:
        case spcDeleteRegValue:
        case spcEnumRegValue:
            SdAtNewLine(Line);
            if (!FParseRegistrySection(Line, &cFields, spc)) {
                                goto LFlowParseError;
            }
            break;

        case spcLoadLibrary:
            SdAtNewLine(Line);
            if(!FParseLoadLibrary(Line, &cFields)) {
                goto LFlowParseError;
            }
            break;

        case spcFreeLibrary:
            SdAtNewLine(Line);
            if(!FParseFreeLibrary(Line, &cFields)) {
                goto LFlowParseError;
            }
            break;

        case spcLibraryProcedure:
            SdAtNewLine(Line);
            if(!FParseLibraryProcedure(Line, &cFields)) {
                goto LFlowParseError;
            }
            break;

        case spcRunExternalProgram:
            SdAtNewLine(Line);
            if(!FParseRunExternalProgram(Line, &cFields)) {
                goto LFlowParseError;
            }
            break;

        case spcInvokeApplet:
            SdAtNewLine(Line);
            if(!FParseInvokeApplet(Line, &cFields)) {
                goto LFlowParseError;
            }
            break;

        case spcStartDetachedProcess:
            SdAtNewLine(Line);
            if(!FParseStartDetachedProcess(Line, &cFields)) {
                goto LFlowParseError;
            }
            break;

        case spcWaitOnEvent:
            SdAtNewLine(Line);
            if(!FParseWaitOnEvent(Line, &cFields)) {
                goto LFlowParseError;
            }
            break;

        case spcSignalEvent:
            SdAtNewLine(Line);
            if(!FParseSignalEvent(Line, &cFields)) {
                goto LFlowParseError;
            }
            break;

        case spcSleep:
            SdAtNewLine(Line);
            if(!FParseSleep(Line, &cFields)) {
                goto LFlowParseError;
            }
            break;

        case spcFlushInf:
            SdAtNewLine(Line);
            if(!FParseFlushInf(Line, &cFields)) {
                goto LFlowParseError;
            }
            break;

        case spcBmpShow:
            SdAtNewLine(Line);
            if(!FParseBmpShow(Line, &cFields)) {
                goto LFlowParseError;
            }
            break ;
        case spcBmpHide:
            SdAtNewLine(Line);
            if(!FParseBmpHide(Line, &cFields)) {
                goto LFlowParseError;
            }
            break ;

        case spcDebugOutput:
#if DEVL
            SdAtNewLine(Line);
            if (cFields != 2)
                   goto LFlowParseError;

            if ((sz = SzProcessSzForSyms(hwndParent, rgsz[1])) == (SZ)NULL)
                       goto LFlowParseExitErr;

            if (    (sz2 = SzFindSymbolValueInSymTab("!G:DebugOutputControl"))
                 && atol(sz2) == 0 )
               break;

            OutputDebugString( "SETUP:" );
            OutputDebugString( sz ) ;
            OutputDebugString( "\n" );

                        SFree(sz);
#endif
            break;

        case spcQueryListSize:
            SdAtNewLine(Line);
        {
                INT ListSize = 0;
                CHP rgchListSize[10];

                if( cFields != 3 )
                {
                    goto LFlowParseError;
                }
                else
                {
                    RGSZ rgszList = NULL;
                    if ((rgszList = RgszFromSzListValue( rgsz[2] )) != NULL )
                    {
                        for(ListSize=0;rgszList[ListSize]; ListSize++)
                        {
                                ;
                        }
                    }
                 }
                 while (!FAddSymbolValueToSymTab(rgsz[1], _itoa(ListSize, rgchListSize, 10))) {
                     if (!FHandleOOM(hwndParent)) {
                        goto LFlowParseExitErr;
                     }
                 }
            }
        break;

    case spcAddFileToDeleteList:
            SdAtNewLine(Line);

        if(!FParseAddFileToDeleteList(Line, &cFields)) {
            goto LFlowParseError;
        }
        break;

    case spcInitRestoreDiskLog:
            SdAtNewLine(Line);
        if( cFields != 1 ) {
            goto LFlowParseError;
        }
        InitRestoreDiskLogging(TRUE);
        break;

    case spcTermRestoreDiskLog:
            SdAtNewLine(Line);
        if( cFields != 1 ) {
            goto LFlowParseError;
        }
        TermRestoreDiskLogging();
        break;



        case spcSplitString:
            SdAtNewLine(Line);
        if( cFields != 4 )
            {
                goto LFlowParseError;
            }
            else
            {
                CHP rgchSplitString[2000];
                SZ szSource;
                SZ szSource2;
                SZ szSep;
                SZ szSep2;
                SZ szSplitString;
                INT i;
                BOOL fAddComma;
                BOOL fFind;
                BOOL fFirst;

                szSplitString = rgchSplitString;

                if ((( szSource = SzProcessSzForSyms( hwndParent, rgsz[1] ))  == (SZ)NULL) ||
                    (( szSep = SzProcessSzForSyms( hwndParent, rgsz[2] )) == (SZ)NULL ))
                {
                    goto LFlowParseExitErr;
                }

                fAddComma = FALSE;
                fFirst = TRUE;

                *szSplitString++='{';
                szSource2 = szSource;

                while( *szSource2 != '\0' )
                {
                    if ( fAddComma )
                    {
                        *szSplitString++=',';
                        fAddComma = FALSE;
                    }
                    if ( fFirst )
                    {
                        *szSplitString++='"';
                    }
                    szSep2 = szSep;
                    fFind = FALSE;
            for ( i = 0; i < (INT)strlen( szSep ); i ++ )
                    {
                        if ( FSingleByteCharSz( szSep2 ) == FSingleByteCharSz( szSource2 ))
                        {
                            if ( FSingleByteCharSz( szSep2 ))
                            {
                                if ( *szSep2 == *szSource2 )
                                {
                                    fFind = TRUE;
                                    break;
                                }
                            }
                            else
                            {
                                if (( *szSep2 == *szSource2 ) &&
                                    ( *(szSep2+1) == *(szSource2+1)))
                                {
                                    fFind = TRUE;
                                    break;
                                }
                            }
                        }
                        szSep2 = SzNextChar(szSep2);
                    }
                    if (fFind)
                    {
                        if (!fFirst)
                        {
                           *szSplitString++ = '"';
                           *szSplitString++ = ',';
                           *szSplitString++ = '"';
                        }
                        *szSplitString++ = *szSep2;
                        if ( !FSingleByteCharSz( szSep2 ))
                        {
                            *szSplitString++ = *(szSep2+1);
                        }
                        *szSplitString++ = '"';
                        fAddComma = TRUE;
                        fFirst = TRUE;
                    }
                    else
                    {
                        *szSplitString++ = *szSource2;
                        if ( !FSingleByteCharSz( szSource2 ))
                        {
                            *szSplitString++ = *(szSource2+1);
                        }
                        fFirst = FALSE;
                    }
                    szSource2 = SzNextChar( szSource2 );
                }
                if (!fFirst)
                {
                    *szSplitString++='"';
                }
                *szSplitString++='}';
                *szSplitString++='\0';

                while (!FAddSymbolValueToSymTab(rgsz[3], rgchSplitString)) {
                    if (!FHandleOOM(hwndParent)) {
                        goto LFlowParseExitErr;
                    }
                }
                SFree(szSource);
                SFree(szSep);
            }
            break;

        case spcUnknown:
            if(CallerCFields != NULL) {
                *CallerCFields = cFields;
            }
            if(CallerRgsz != NULL) {
                *CallerRgsz = rgsz;
            } else {
                EvalAssert(FFreeRgsz(rgsz));
            }
            *CurrentLine = Line;
                        return(fTrue);

        default:
                        Assert(fFalse);
                        }

LNextFlowLine:
                if (spc != spcGoTo &&
                 ((Line = FindNextLineFromInf(Line)) == -1))
                        {
                        if (rgsz != (RGSZ)NULL)
                EvalAssert(FFreeRgsz(rgsz));
                EvalAssert(LoadString(hInst, IDS_ERROR,     rgchBufTmpShort, cchpBufTmpShortMax));
                EvalAssert(LoadString(hInst, IDS_NEED_EXIT, rgchBufTmpLong,  cchpBufTmpLongMax));
                MessageBox(hwndParent, rgchBufTmpLong, rgchBufTmpShort, MB_OK | MB_ICONHAND);
                return(fFalse);
                        }

                EvalAssert(rgsz == (RGSZ)NULL ||
                                FFreeRgsz(rgsz));
                }

        Assert(fFalse); /* Should never reach here! */

LFlowParseError:
        /* BLOCK */
                {
#define  cchpBuf  (2 * cchpFullPathBuf)
                CHP rgchBuf[cchpBuf];

        EvalAssert(LoadString(hInst, IDS_SHL_CMD_ERROR, rgchBuf,  cchpBuf));
                if (rgsz != (RGSZ)NULL ||
                                *rgsz != (SZ)NULL)
                        {
                        USHORT iszCur = 0;
                        SZ     szCur;

                        while ((szCur = rgsz[iszCur++]) != (SZ)NULL)
                                {
                                if (iszCur == 1)
                                        EvalAssert(SzStrCat((SZ)rgchBuf, "\n'") == (SZ)rgchBuf);
                                else
                                        EvalAssert(SzStrCat((SZ)rgchBuf, " ") == (SZ)rgchBuf);

                                if (strlen(rgchBuf) + strlen(szCur) > (cchpBuf - 7))
                                        {
                                        Assert(strlen(rgchBuf) <= (cchpBuf - 5));
                                        EvalAssert(SzStrCat((SZ)rgchBuf, "...") == (SZ)rgchBuf);
                                        break;
                                        }
                                else
                                        EvalAssert(SzStrCat((SZ)rgchBuf, szCur) == (SZ)rgchBuf);
                                }

                        EvalAssert(SzStrCat((SZ)rgchBuf, "'") == (SZ)rgchBuf);
                        }

        EvalAssert(LoadString(hInst, IDS_ERROR, rgchBufTmpShort, cchpBufTmpShortMax));
        MessageBox(hwndParent, rgchBuf, rgchBufTmpShort, MB_OK | MB_ICONHAND);
                }

LFlowParseExitErr:
        if (rgsz != (RGSZ)NULL)
                EvalAssert(FFreeRgsz(rgsz));
        return(fFalse);
}


/*
**      Purpose:
**              Initializes the structures needed for parsing/handling Flow Script
**              statements.  Must be called before FHandleFlowStatements().
**      Arguments:
**              none
**      Returns:
**              fTrue if successful.
**              fFalse if not successful.
*/
BOOL APIENTRY FInitFlowPspt(VOID)
{
        if (psptFlow != (PSPT)NULL)
                return(fFalse);

        return((BOOL)((psptFlow = PsptInitParsingTable(rgscpFlow)) != (PSPT)NULL));
}


/*
**      Purpose:
**              Destroys the structures needed for parsing/handling Flow Script
**              statements.
**      Arguments:
**              none
**      Returns:
**              fTrue if successful.
**              fFalse if not successful.
*/
BOOL APIENTRY FDestroyFlowPspt(VOID)
{
        if (psptFlow == (PSPT)NULL ||
                        !FDestroyParsingTable(psptFlow))
                return(fFalse);

        psptFlow = (PSPT)NULL;
        return(fTrue);
}



/*
**      Purpose:
**      Arguments:
**      Returns:
**
*************************************************************************/
BOOL APIENTRY FParseRegistrySection(INT Line, UINT *pcFields, SPC spc)
{

    BOOL    fOkay       =   fFalse;
    SZ      szHandle    =   NULL;

    iFieldCur = 2;

    if ( ( *pcFields >= 1 )                     &&
         FGetArgSz( Line, pcFields, &szHandle )
       ) {


        FAddSymbolValueToSymTab( REGLASTERROR, "0" );

        switch (spc) {

        default:
            Assert(fFalse);
            break;

        case spcCreateRegKey:
            fOkay = FParseCreateRegKey( Line, pcFields, szHandle );
            break;

        case spcOpenRegKey:
            fOkay = FParseOpenRegKey( Line, pcFields, szHandle );
            break;

        case spcFlushRegKey:
            fOkay = FParseFlushRegKey( Line, pcFields, szHandle );
            break;

        case spcCloseRegKey:
            fOkay = FParseCloseRegKey( Line, pcFields, szHandle );
            break;

        case spcDeleteRegKey:
            fOkay = FParseDeleteRegKey( Line, pcFields, szHandle );
            break;

        case spcDeleteRegTree:
            fOkay = FParseDeleteRegTree( Line, pcFields, szHandle );
            break;

        case spcEnumRegKey:
            fOkay = FParseEnumRegKey( Line, pcFields, szHandle );
            break;

        case spcSetRegValue:
            fOkay = FParseSetRegValue( Line, pcFields, szHandle );
            break;

        case spcGetRegValue:
            fOkay = FParseGetRegValue( Line, pcFields, szHandle );
            break;

        case spcDeleteRegValue:
            fOkay = FParseDeleteRegValue( Line, pcFields, szHandle );
            break;

        case spcEnumRegValue:
            fOkay = FParseEnumRegValue( Line, pcFields, szHandle );
            break;
        }
    }

    if ( szHandle ) {
        SFree(szHandle);
    }

    return( fOkay );
}


/*
**      Purpose:
**      Arguments:
**      Returns:
**
*************************************************************************/
BOOL APIENTRY FParseOpenRegKey(INT Line, UINT *pcFields, SZ szHandle)
{
    BOOL    fOkay   =   fFalse;
    SZ      szMachineName = NULL;
    SZ      szKeyName = NULL;
    UINT    AccessMask;
    SZ      szNewHandle = NULL;
    CMO     cmo;

    if ( *pcFields >= 4 ) {
        if ( FGetArgSz( Line, pcFields, &szMachineName ) ) {
            if ( FGetArgSz( Line, pcFields, &szKeyName ) ) {
                if ( FGetArgUINT( Line, pcFields, &AccessMask ) ) {
                    if ( FGetArgSz( Line, pcFields, &szNewHandle ) ) {
                        if ( FGetCmo( Line, pcFields, &cmo )) {
                            fOkay = FOpenRegKey( szHandle,
                                                 szMachineName,
                                                 szKeyName,
                                                 AccessMask,
                                                 szNewHandle,
                                                 cmo );
                        }
                    }
                    SFree(szNewHandle);
                }
            }
            SFree(szKeyName);
        }
        SFree(szMachineName);
    }

    return fOkay;
}


/*
**      Purpose:
**      Arguments:
**      Returns:
**
*************************************************************************/
BOOL APIENTRY FParseFlushRegKey(INT Line, UINT *pcFields, SZ szHandle)
{
    BOOL    fOkay = fFalse;
    CMO     cmo;

    if ( FGetCmo( Line, pcFields, &cmo )) {
        fOkay = FFlushRegKey( szHandle, cmo );
    }
    return fOkay;
}


/*
**      Purpose:
**      Arguments:
**      Returns:
**
*************************************************************************/
BOOL APIENTRY FParseCloseRegKey(INT Line, UINT *pcFields, SZ szHandle)
{
    BOOL    fOkay = fFalse;
    CMO     cmo;

    if ( FGetCmo( Line, pcFields, &cmo )) {
        fOkay = FCloseRegKey( szHandle, cmo );
    }
    return fOkay;
}


/*
**      Purpose:
**      Arguments:
**      Returns:
**
*************************************************************************/
BOOL APIENTRY FParseDeleteRegKey(INT Line, UINT *pcFields, SZ szHandle)
{
    BOOL    fOkay   =   fFalse;
    SZ      szKeyName = NULL;
    CMO     cmo;

    if ( *pcFields >= 1 ) {
        if ( FGetArgSz( Line, pcFields, &szKeyName ) ) {
            if ( FGetCmo( Line, pcFields, &cmo )) {
                fOkay = FDeleteRegKey( szHandle,
                                       szKeyName,
                                       cmo );
            }
        }
        SFree(szKeyName);
    }

    return fOkay;
}


/*
**      Purpose:
**      Arguments:
**      Returns:
**
*************************************************************************/
BOOL APIENTRY FParseDeleteRegTree(INT Line, UINT *pcFields, SZ szHandle)
{
    BOOL    fOkay   =   fFalse;
    SZ      szKeyName = NULL;
    CMO     cmo;

    if ( *pcFields >= 1 ) {
        if ( FGetArgSz( Line, pcFields, &szKeyName ) ) {
            if ( FGetCmo( Line, pcFields, &cmo )) {
                fOkay = FDeleteRegTree( szHandle,
                                        szKeyName,
                                        cmo );
            }
        }
        SFree(szKeyName);
    }

    return fOkay;
}


/*
**      Purpose:
**      Arguments:
**      Returns:
**
*************************************************************************/
BOOL APIENTRY FParseEnumRegKey(INT Line, UINT *pcFields, SZ szHandle)
{
    BOOL    fOkay   =   fFalse;
    SZ      szInfVar;
    CMO     cmo;

    if ( *pcFields >= 1 ) {
        if ( FGetArgSz( Line, pcFields, &szInfVar ) ) {
            if ( FGetCmo( Line, pcFields, &cmo )) {
                fOkay = FEnumRegKey( szHandle,
                                     szInfVar,
                                     cmo );
            }
            SFree( szInfVar );
        }
    }

    return fOkay;
}


/*
**      Purpose:
**      Arguments:
**      Returns:
**
*************************************************************************/
BOOL APIENTRY FParseSetRegValue(INT Line, UINT *pcFields, SZ szHandle)
{
    BOOL    fOkay   =   fFalse;
    SZ      szValueInfo = NULL;
    SZ      szValueName = NULL;
    UINT    TitleIndex;
    UINT    ValueType;
    SZ      szValueData = NULL;
    RGSZ    rgszInfo;
    CMO     cmo;


    if ( *pcFields >= 1 ) {

        if ( FGetArgSz( Line, pcFields, &szValueInfo )) {

            if ( FListValue( szValueInfo )) {

                if ( rgszInfo = RgszFromSzListValue( szValueInfo )) {

                    if ( FGetCmo( Line, pcFields, &cmo )) {
                        if ( (rgszInfo[0] != NULL)  &&
                             (rgszInfo[1] != NULL)  &&
                             (rgszInfo[2] != NULL)  &&
                             (rgszInfo[3] != NULL) ) {

                            szValueName = rgszInfo[0];
                            TitleIndex  = atol(rgszInfo[1]);
                            ValueType   = atol(rgszInfo[2]);
                            szValueData = rgszInfo[3];

                            fOkay = FSetRegValue( szHandle,
                                                  szValueName,
                                                  TitleIndex,
                                                  ValueType,
                                                  szValueData,
                                                  cmo );
                        }
                    }
                }
                FFreeRgsz( rgszInfo );
            }
        }
        SFree( szValueInfo );
    }

    return fOkay;
}


/*
**      Purpose:
**      Arguments:
**      Returns:
**
*************************************************************************/
BOOL APIENTRY FParseGetRegValue(INT Line, UINT *pcFields, SZ szHandle)
{
    BOOL    fOkay   =   fFalse;
    SZ      szValueName = NULL;
    SZ      szInfVar = NULL;
    CMO     cmo;

    if ( *pcFields >= 2 ) {
        if ( FGetArgSz( Line, pcFields, &szValueName ) ) {
            if ( FGetArgSz( Line, pcFields, &szInfVar ) ) {
                if ( FGetCmo( Line, pcFields, &cmo )) {
                    fOkay = FGetRegValue( szHandle,
                                          szValueName,
                                          szInfVar,
                                          cmo );
                }
            }
            SFree( szInfVar );

        }
        SFree( szValueName );
    }

    return fOkay;

}


/*
**      Purpose:
**      Arguments:
**      Returns:
**
*************************************************************************/
BOOL APIENTRY FParseDeleteRegValue(INT Line, UINT *pcFields, SZ szHandle)
{
    BOOL    fOkay   =   fFalse;
    SZ      szValueName = NULL;
    CMO     cmo;

    if ( *pcFields >= 1 ) {
        if ( FGetArgSz( Line, pcFields, &szValueName ) ) {
             if ( FGetCmo( Line, pcFields, &cmo )) {
                fOkay = FDeleteRegValue( szHandle,
                                         szValueName,
                                         cmo );
            }
        }
        SFree( szValueName );
    }

    return fOkay;
}


/*
**      Purpose:
**      Arguments:
**      Returns:
**
*************************************************************************/
BOOL APIENTRY FParseEnumRegValue(INT Line, UINT *pcFields, SZ szHandle)
{
    BOOL    fOkay   =   fFalse;
    SZ      szInfVar;
    CMO     cmo;

    if ( *pcFields >= 1 ) {
        if ( FGetArgSz( Line, pcFields, &szInfVar ) ) {
            if ( FGetCmo( Line, pcFields, &cmo )) {
                fOkay = FEnumRegValue( szHandle,
                                       szInfVar,
                                       cmo );

            }
            SFree( szInfVar );
        }
    }

    return fOkay;
}

/*
**      Purpose:
**      Arguments:
**      Returns:
**
*************************************************************************/
BOOL APIENTRY FParseCreateRegKey(INT Line, UINT *pcFields, SZ szHandle)
{
    BOOL    fOkay   =   fFalse;
    SZ      szKeyInfo;
    SZ      szSecurity;
    UINT    AccessMask;
    UINT    Options;
    SZ      szNewHandle;
    SZ      szKeyName;
    UINT    TitleIndex;
    SZ      szClass;
    RGSZ    rgszInfo;
    CMO     cmo;


    if ( *pcFields >= 5 ) {
         if ( FGetArgSz( Line, pcFields, &szKeyInfo ) ) {

            //
            //  Validate the key Info.
            //
            if ( FListValue( szKeyInfo )) {

                if ( rgszInfo = RgszFromSzListValue( szKeyInfo )) {

                    if ( (rgszInfo[0] != NULL) &&
                         (rgszInfo[1] != NULL) &&
                         (rgszInfo[2] != NULL ) ) {

                        szKeyName   = rgszInfo[0];
                        TitleIndex  = atol(rgszInfo[1]);
                        szClass     = rgszInfo[2];

                        if ( FGetArgSz( Line, pcFields, &szSecurity ) ) {

                            //
                            //  BugBug At this point we should validate the security Info.
                            //

                            if ( FGetArgUINT( Line, pcFields, &AccessMask ) ) {
                                if ( FGetArgUINT( Line, pcFields, &Options ) ) {
                                    if ( FGetArgSz( Line, pcFields, &szNewHandle ) ) {
                                        if ( FGetCmo( Line, pcFields, &cmo )) {
                                            fOkay = FCreateRegKey( szHandle,
                                                                   szKeyName,
                                                                   TitleIndex,
                                                                   szClass,
                                                                   szSecurity,
                                                                   AccessMask,
                                                                   Options,
                                                                   szNewHandle,
                                                                   cmo );
                                        }
                                        SFree( szNewHandle );
                                    }
                                }
                            }
                            SFree( szSecurity );
                        }
                    }
                    FFreeRgsz( rgszInfo );
                }
            }
            SFree( szKeyInfo );
        }
    }

    return fOkay;
}



/*
**      Purpose:
**      Arguments:
**      Returns:
**
*************************************************************************/
BOOL APIENTRY FParseLoadLibrary(INT Line, UINT *pcFields)
{
    BOOL fOkay       = FALSE;
    SZ   szDiskName  = NULL,
         szLibName   = NULL,
         szHandleVar = NULL;

    iFieldCur = 2;

    if(*pcFields == 4) {
        FGetArgSz(Line,pcFields,&szDiskName);    // disk name
        FGetArgSz(Line,pcFields,&szLibName);     // library pathname
        FGetArgSz(Line,pcFields,&szHandleVar);   // INF var to get lib handle

        if((szLibName   != NULL)
        && (szHandleVar != NULL)
        && *szLibName
        && *szHandleVar)
        {
            fOkay =  FLoadLibrary(szDiskName,szLibName,szHandleVar);
        }
        if(szDiskName != NULL) {
            SFree(szDiskName);
        }
        if(szLibName != NULL) {
            SFree(szLibName);
        }
        if(szHandleVar != NULL) {
            SFree(szHandleVar);
        }
    }
    return(fOkay);
}


/*
**      Purpose:
**      Arguments:
**      Returns:
**
*************************************************************************/
BOOL APIENTRY FParseFreeLibrary(INT Line, UINT *pcFields)
{
    BOOL fOkay    = FALSE;
    SZ   szHandle = NULL;

    iFieldCur = 2;

    if(*pcFields == 2) {
        FGetArgSz(Line,pcFields,&szHandle);   // lib handle

        if((szHandle != NULL) && *szHandle)
        {
            fOkay =  FFreeLibrary(szHandle);
        }
        if(szHandle != NULL) {
            SFree(szHandle);
        }
    }
    return(fOkay);
}


/*
**      Purpose:
**      Arguments:
**      Returns:
**
*************************************************************************/
BOOL APIENTRY FParseLibraryProcedure(INT Line,UINT *pcFields)
{
    BOOL fOkay     = fFalse;
    SZ   szINFVar  = NULL,
         szLibHand = NULL,
         szRoutine = NULL;
    RGSZ rgszArgs  = NULL;

    iFieldCur = 2;

    if(*pcFields >= 4) {
        FGetArgSz(Line,pcFields,&szINFVar);      // INF var for result
        FGetArgSz(Line,pcFields,&szLibHand);     // library handle
        FGetArgSz(Line,pcFields,&szRoutine);     // entry point

        rgszArgs = RgszFromInfLineFields(Line,5,(*pcFields) - 4);

        if((szLibHand != NULL)
        && (szRoutine != NULL)
        && (rgszArgs != NULL))
        {
            fOkay = FLibraryProcedure(szINFVar,szLibHand,szRoutine,rgszArgs);
        }
        if(szINFVar != NULL) {
            SFree(szINFVar);
        }
        if(szLibHand != NULL) {
            SFree(szLibHand);
        }
        if(szRoutine != NULL) {
            SFree(szRoutine);
        }
        if(rgszArgs != NULL) {
            FFreeRgsz(rgszArgs);
        }
    }
    return(fOkay);
}


/*
**      Purpose:
**      Arguments:
**      Returns:
**
*************************************************************************/
BOOL APIENTRY FParseRunExternalProgram(INT Line,UINT *pcFields)
{
    BOOL fOkay     = fFalse;
    SZ   szVar     = NULL,
         szDisk    = NULL,
         szLibHand = NULL,
         szProgram = NULL;
    RGSZ rgszArgs  = NULL;

    iFieldCur = 2;

    if(*pcFields >= 5) {
        FGetArgSz(Line,pcFields,&szVar);         // INF variable to stuff
        FGetArgSz(Line,pcFields,&szDisk);        // disk name
        FGetArgSz(Line,pcFields,&szLibHand);     // mod with string table
        FGetArgSz(Line,pcFields,&szProgram);     // name of program

        // To be nice, we will supply argv[0].  To do this we'll
        // take advantage of placement of the program name immediately
        // before the arguments.  It ain't perfect (argv[0] doesn't
        // conventionally contain a full path) but it'll do.

        rgszArgs = RgszFromInfLineFields(Line,5,(*pcFields) - 4);

        if((szDisk != NULL) && (szProgram != NULL) && (rgszArgs != NULL)) {

            AssertRet((*szProgram != '\0'),fFalse);

            fOkay = FRunProgram(szVar,szDisk,szLibHand,szProgram,rgszArgs);
        }
        if(szVar != NULL) {
            SFree(szVar);
        }
        if(szDisk != NULL) {
            SFree(szDisk);
        }
        if(szLibHand != NULL) {
            SFree(szLibHand);
        }
        if(szProgram != NULL) {
            SFree(szProgram);
        }
        if(rgszArgs != NULL) {
            FFreeRgsz(rgszArgs);
        }
    }
    return(fOkay);
}


/*
**      Purpose:
**      Arguments:
**      Returns:
**
*************************************************************************/
BOOL APIENTRY FParseStartDetachedProcess(INT Line,UINT *pcFields)
{
    BOOL fOkay     = fFalse;
    SZ   szVar     = NULL,
         szDisk    = NULL,
         szLibHand = NULL,
         szProgram = NULL;
    RGSZ rgszArgs  = NULL;

    iFieldCur = 2;

    if(*pcFields >= 5) {
        FGetArgSz(Line,pcFields,&szVar);         // INF variable to stuff
        FGetArgSz(Line,pcFields,&szDisk);        // disk name
        FGetArgSz(Line,pcFields,&szLibHand);     // mod with string table
        FGetArgSz(Line,pcFields,&szProgram);     // name of program

        // To be nice, we will supply argv[0].  To do this we'll
        // take advantage of placement of the program name immediately
        // before the arguments.  It ain't perfect (argv[0] doesn't
        // conventionally contain a full path) but it'll do.

        rgszArgs = RgszFromInfLineFields(Line,5,(*pcFields) - 4);

        if((szDisk != NULL) && (szProgram != NULL) && (rgszArgs != NULL)) {

            AssertRet((*szProgram != '\0'),fFalse);

            fOkay = FStartDetachedProcess(szVar,szDisk,szLibHand,szProgram,rgszArgs);
        }
        if(szVar != NULL) {
            SFree(szVar);
        }
        if(szDisk != NULL) {
            SFree(szDisk);
        }
        if(szLibHand != NULL) {
            SFree(szLibHand);
        }
        if(szProgram != NULL) {
            SFree(szProgram);
        }
        if(rgszArgs != NULL) {
            FFreeRgsz(rgszArgs);
        }
    }
    return(fOkay);
}




/*
**      Purpose:
**      Arguments:
**      Returns:
**
*************************************************************************/
BOOL APIENTRY FParseInvokeApplet(INT Line, UINT *pcFields)
{
    BOOL fOkay     = fFalse;
    SZ   szLibrary = NULL;

    iFieldCur = 2;

    if(*pcFields >= 2) {

        FGetArgSz(Line,pcFields,&szLibrary);     // name of library

        if(szLibrary != NULL) {

            fOkay = FInvokeApplet(szLibrary);
            SFree(szLibrary);
        }
    }
    return(fOkay);
}


BOOL APIENTRY FParseAddFileToDeleteList(INT Line, UINT *pcFields)
{
    BOOL fOkay     = fFalse;
    SZ   szFile = NULL;

    iFieldCur = 2;

    if(*pcFields >= 2) {

        FGetArgSz(Line,pcFields,&szFile);     // filename to add

        if(szFile != NULL) {

            fOkay = AddFileToDeleteList(szFile);
            SFree(szFile);
        }
    }
    return(fOkay);
}

#define FAIL_EVENT_MARK  '*'

BOOL APIENTRY FParseWaitOnEvent(INT Line,UINT *pcFields)
{
    BOOL fOkay     = fFalse;
    SZ   szInfVar  = NULL,
         szEvent   = NULL,
         szTimeout = NULL;

    iFieldCur = 2;

    if(*pcFields >= 4) {
        FGetArgSz(Line,pcFields,&szInfVar);         // INF variable to stuff
        FGetArgSz(Line,pcFields,&szEvent);
        FGetArgSz(Line,pcFields,&szTimeout);

        //
        //  If the first character of the event name string is '*', this is a
        //  signal to call the special version of event waiting which allows the
        //  signaller to alternatively signal an event named SETUP_FAILED
        //  to indicate that the process failed and an error popup has already
        //  been presented to the user.  In this case, the result variable will
        //  contain "EventFailed".   If the SETUP_FAILED event cannot be created,
        //  the result is "EventNoFailEvent".
        //
        if ( (szInfVar != NULL) && (szEvent != NULL) && (szTimeout != NULL) )
        {
            DWORD dwTimeout = atol( szTimeout ) ;

            if ( szEvent[0] == FAIL_EVENT_MARK )
            {
                fOkay = FWaitForEventOrFailure( szInfVar, szEvent+1, dwTimeout );
            }
            else
            {
                fOkay = FWaitForEvent( szInfVar, szEvent, dwTimeout );
            }
        }

        if(szInfVar != NULL) {
            SFree(szInfVar);
        }
        if(szEvent != NULL) {
            SFree(szEvent);
        }
        if(szTimeout != NULL) {
            SFree(szTimeout);
        }
    }
    return(fOkay);
}

BOOL APIENTRY FParseSleep(INT Line,UINT *pcFields)
{
    SZ szMilliseconds = NULL;

    iFieldCur = 2 ;

    if (*pcFields >= 2) {
        FGetArgSz(Line,pcFields,&szMilliseconds);
        FSleep( atol( szMilliseconds ) ) ;
    }

    return TRUE ;
}

BOOL APIENTRY FParseFlushInf(INT Line,UINT *pcFields)
{
    SZ   szInf;
    BOOL fOkay = fFalse;

    iFieldCur = 2 ;

    if (*pcFields >= 2) {
        FGetArgSz(Line,pcFields,&szInf);
        fOkay = FFlushInfParsedInfo( szInf );
    }

    return(fOkay);
}

static VOID freeBmps ( VOID )
{
    INT i ;

    for ( i = 0 ; i < BMP_MAX && hbmAdvertList[i] ; i++ )
    {
        DeleteObject( hbmAdvertList[i] ) ;
        hbmAdvertList[i] = NULL ;

        if ( hWndShell && i == 0 )
        {
            InvalidateRect( hWndShell, NULL, FALSE ) ;
            UpdateWindow( hWndShell ) ;
        }
    }
}

  //
  //  Syntax:
  //
  //    BMPSHOW
  //         <cycle time in seconds>
  //         <relative X position, 0..100>
  //         <relative Y position, 0..100>
  //         {list of bitmap id numbers}
  //
BOOL APIENTRY FParseBmpShow ( INT Line, UINT * pcFields )
{
    SZ   sz=NULL;
    INT  iId, iCycle, cBmps, i ;
    BOOL fOkay = fFalse;
    RGSZ rgszIds ;

    iFieldCur = 2 ;

    if ( ! fFullScreen )
    {
        fOkay = fTrue ;
    }
    else
    if ( *pcFields >= 4)
    {
        freeBmps() ;

        FGetArgSz( Line, pcFields, & sz );
        iCycle = atoi( sz ) ;
        sz = NULL;
        FGetArgSz( Line, pcFields, & sz );
        cxAdvert = atoi( sz ) ;
        sz = NULL;
        FGetArgSz( Line, pcFields, & sz );
        cyAdvert = atoi( sz ) ;
        sz = NULL;
        FGetArgSz( Line, pcFields, & sz );
        rgszIds = RgszFromSzListValue( sz ) ;

        cBmps = 0 ;
        if ( rgszIds )
        {
            //  Load all the bitmaps we can fit and find.

            for ( iId = 0 ; iId < BMP_MAX && rgszIds[iId] ; iId++ )
            {
                hbmAdvertList[cBmps] = LoadBitmap( hInst,
                                                   MAKEINTRESOURCE( atoi( rgszIds[iId] ) ) ) ;
                if ( hbmAdvertList[cBmps] )
                    cBmps++ ;
            }
            FFreeRgsz( rgszIds ) ;
        }

        hbmAdvertList[cBmps] = NULL ;

        if ( cBmps )
        {
            fOkay = fTrue ;
            cAdvertCycleSeconds = iCycle ;

            // Activate BMP display: point at last bitmap (end of cycle)
            cAdvertIndex = cBmps - 1 ;
        }
    }

    return(fOkay);
}

  //
  //  Syntax:    BMPHIDE
  //
BOOL APIENTRY FParseBmpHide ( INT Line, UINT * pcFields )
{
    BOOL fOkay = fTrue ;

    iFieldCur = 2 ;

    if ( fFullScreen )
    {
        //  Turn off BMP display
        cAdvertIndex = -1 ;
        freeBmps() ;
    }

    return(fOkay);
}



BOOL APIENTRY FParseSignalEvent(INT Line,UINT *pcFields)
{
    BOOL fOkay     = fFalse;
    SZ   szInfVar  = NULL,
         szEvent   = NULL;

    iFieldCur = 2;

    if(*pcFields >= 3) {
        FGetArgSz(Line,pcFields,&szInfVar);         // INF variable to stuff
        FGetArgSz(Line,pcFields,&szEvent);

        if((szInfVar != NULL) && (szEvent != NULL)) {
            fOkay = FSignalEvent( szInfVar, szEvent );
        }

        if(szInfVar != NULL) {
            SFree(szInfVar);
        }
        if(szEvent != NULL) {
            SFree(szEvent);
        }
    }
    return(fOkay);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\partproc.c ===
#include "precomp.h"
#pragma hdrstop
/***************************************************************************/
/****************** Special Dialog Handlers ****************************/
/***************************************************************************/
																									

/*  This module contains handlers for the optional windows components dialogs.
**  Two dialog procedures are provided for doing the special check box and the
**  dual dialog box procedures.
*/


/* 1. Special Check Box Procedure to handle the Partial Install main dialog.
*/

/*
**	Purpose:
**		Special CheckBox Dialog procedure for templates with one to ten checkbox
**		controls. This handles notifications.
**	Control IDs:
**		The Checkbox controls must have sequential ids starting with IDC_B1
**			and working up to a maximum of IDC_B10.
**		Pushbuttons recognized are IDC_O, IDC_C, IDC_M, IDC_H, IDC_X, and IDC_B.
**	Initialization:
**		The symbol $(CheckItemsIn) is evaluated as a list of elements of
**			either 'ON' or 'OFF'.  So examples for a template with four
**			checkbox controls would include {ON, ON, ON, ON},
**			{ON, OFF, ON, OFF} and {OFF, OFF, OFF, OFF}.  These elements
**			determine if the initial state of the corresponding checkbox
**			control is checked (ON) or unchecked (OFF).  If there are more
**			controls than elements, the extra controls will be initialized
**			as unchecked.  If there are more elements than controls, the
**			extra elements are ignored.
**		The symbol $(OptionsGreyed) is evaluated as a list of indexes
**			(one-based) of check boxes to be disabled (greyed).  Default is
**			none.
**	Termination:
**		The state of each checkbox is queried and a list with the same format
**			as the initialization list is created and stored in the symbol
**			$(CheckItemsOut).
**		The id of the Pushbutton (eg IDC_C) which caused termination is
**			converted to a string and stored in the symbol $(ButtonPressed).
**
*****************************************************************************/
INT_PTR APIENTRY FGstCheck1DlgProc(HWND   hdlg,
                                   UINT   wMsg,
                                   WPARAM wParam,
                                   LPARAM lParam)
{
    CHP    rgchNum[10];

    static INT  nBoxes;
    static BOOL fChecked[10];
    static INT  nSize[10];
    static INT  nTotalSize;

    static INT  nMaxSize;

    WORD   idc;
    RGSZ   rgsz, rgsz1;
    PSZ    psz, psz1;
    SZ     sz, sz1, sz2;



    Unused(lParam);

    switch (wMsg)
        {
    case STF_REINITDIALOG:
      if ((sz = SzFindSymbolValueInSymTab("ReInit")) == (SZ)NULL ||
          (CrcStringCompareI(sz, "YES") != crcEqual))
		   return(fTrue);

    case WM_INITDIALOG:
		AssertDataSeg();
        if( wMsg == WM_INITDIALOG ) {
            FCenterDialogOnDesktop(hdlg);
        }

        //
        // Get the check box Checked/Not Checked variable
        //

		if ((sz = SzFindSymbolValueInSymTab("CheckItemsIn")) == (SZ)NULL)
			{
			PreCondition(fFalse, fTrue);
			return(fTrue);
			}

		while ((psz = rgsz = RgszFromSzListValue(sz)) == (RGSZ)NULL)
			if (!FHandleOOM(hdlg))
				{
				DestroyWindow(GetParent(hdlg));
				return(fTrue);
                }

        //
        // Get the sizes associated with each check box option
        //

        if ((sz1 = SzFindSymbolValueInSymTab("CheckItemsInSizes")) == (SZ)NULL)
			{
			PreCondition(fFalse, fTrue);
			return(fTrue);
			}

        while ((psz1 = rgsz1 = RgszFromSzListValue(sz1)) == (RGSZ)NULL)
			if (!FHandleOOM(hdlg))
				{
				DestroyWindow(GetParent(hdlg));
				return(fTrue);
				}

        //
        // Get the total size available
        //

        if ((sz2 = SzFindSymbolValueInSymTab("SizeAvailable")) == (SZ)NULL)
			{
			PreCondition(fFalse, fTrue);
			return(fTrue);
			}


        //
        // Get the check box states, the number of check boxes and the
        // sizes associated with each
        //

        idc        = IDC_B1;
        nBoxes     = 0;
        nTotalSize = 0;

        while (*psz != (SZ)NULL) {
            WORD wCheck = 0;
            HWND hwndItem    = GetDlgItem(hdlg, IDC_SP1 + idc - IDC_B1);

            if (CrcStringCompare(*(psz++), "ON") == crcEqual) {
                wCheck = 1;
            }

            if(!wCheck) {
                if( GetFocus() == hwndItem ) {
                    SetFocus(GetDlgItem(hdlg, IDC_C));
                }
            }
            EnableWindow(GetDlgItem(hdlg, IDC_SP1 + idc - IDC_B1), wCheck);
            CheckDlgButton(hdlg, idc++, wCheck);

            //
            // Maintain checked / not checked status
            //

            fChecked[nBoxes] = (BOOL) wCheck;

            if (*psz1 == (SZ)NULL) {
                PreCondition (fFalse, fTrue);
                return ( fTrue );
            }

            nSize[nBoxes] = atol (*(psz1++));

            nTotalSize = nTotalSize + (fChecked[nBoxes] ? nSize[nBoxes] : 0L);

            MySetDlgItemInt (
                 hdlg,
                 IDC_SIZE1 + nBoxes,
                 fChecked[nBoxes] ? nSize[nBoxes] : 0
                 );

            nBoxes++;

        }

        //
        // Update the total added size
        //

        MySetDlgItemInt (
            hdlg,
            IDC_TOTAL1,
            nTotalSize
            );

        //
        // Get the maximum size
        //

        nMaxSize = atol(sz2) * 1024L * 1024L;  // M -> Bytes


        //
        // Update the mazimum size
        //

        MySetDlgItemInt (
            hdlg,
            IDC_MAX1,
            nMaxSize
            );

        //
        // Free the structure to the check lists
        //

		EvalAssert(FFreeRgsz(rgsz));
        EvalAssert(FFreeRgsz(rgsz1));


        //
        // If items are to be disabled, do this
        //

        if ((sz = SzFindSymbolValueInSymTab("OptionsGreyed")) == (SZ)NULL) {
			PreCondition(fFalse, fTrue);
			return(fTrue);
        }

        while ((psz = rgsz = RgszFromSzListValue(sz)) == (RGSZ)NULL) {
            if (!FHandleOOM(hdlg)) {
				DestroyWindow(GetParent(hdlg));
                return(fTrue);
            }
        }

        while (*psz != (SZ)NULL) {
			SZ  sz = *(psz++);
            INT i  = atoi(sz);

            if (i > 0 && i <= 10) {
                HWND hwndItem = GetDlgItem(hdlg, IDC_B0 + i);

                if( GetFocus() == hwndItem ) {
                    //
                    // transfer focus to the continue button
                    //
                    SetFocus(GetDlgItem(hdlg, IDC_C));
                }
                EnableWindow(hwndItem, 0);
            }
            else if (*sz != '\0') {
                PreCondition(fFalse, fTrue);
            }
        }

		EvalAssert(FFreeRgsz(rgsz));


        //
        // End processing
        //

        return(fTrue);


//    case STF_DLG_ACTIVATE:
//    case WM_MOUSEACTIVATE:
//        if (FActiveStackTop())
//            break;
//        EvalAssert(FInactivateHelp());
//        SetWindowPos(hdlg, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
//        /* fall through */
//    case STF_UILIB_ACTIVATE:
//        EvalAssert(FActivateStackTop());
//        return(fTrue);
	
    case WM_CLOSE:
        PostMessage(
            hdlg,
            WM_COMMAND,
            MAKELONG(IDC_X, BN_CLICKED),
            0L
            );
        return(fTrue);

    case WM_COMMAND:
		switch (idc = LOWORD(wParam))
			{
		case IDC_B1:
		case IDC_B2:
		case IDC_B3:
		case IDC_B4:
		case IDC_B5:
		case IDC_B6:
		case IDC_B7:
		case IDC_B8:
		case IDC_B9:
        case IDC_B10:
            {
                INT nSizeItem;

                //
                // Toggle the check state
                //

                CheckDlgButton( hdlg, idc, (WORD)!IsDlgButtonChecked( hdlg, idc ) );

                //
                // Update the size of this item and the total
                //

                if (fChecked[idc - IDC_B1] = IsDlgButtonChecked (hdlg, idc )) {
                    nSizeItem  = nSize[idc - IDC_B1];
                    nTotalSize = nTotalSize + nSizeItem;
                }
                else {
                    nSizeItem = 0L;
                    if ( (nTotalSize = nTotalSize - nSize[idc - IDC_B1]) < 0 ) {
                        nTotalSize = 0;
                    }
                }

                //
                // Update the customise window
                //
                EnableWindow(
                     GetDlgItem(hdlg, IDC_SP1 + idc - IDC_B1),
                     fChecked[idc - IDC_B1]
                     );

                //
                // Update the check item size
                //

                MySetDlgItemInt (
                    hdlg,
                    IDC_SIZE1 + idc - IDC_B1,
                    nSizeItem
                    );


                //
                // Update the total added size
                //

                MySetDlgItemInt (
                    hdlg,
                    IDC_TOTAL1,
                    nTotalSize
                    );

            }
            break;

		case IDCANCEL:
            if (LOWORD(wParam) == IDCANCEL) {

                if (!GetDlgItem(hdlg, IDC_B) || HIWORD(GetKeyState(VK_CONTROL)) || HIWORD(GetKeyState(VK_SHIFT)) || HIWORD(GetKeyState(VK_MENU)))
                {
                    break;
                }
                wParam = IDC_B;

            }
        case IDC_SP1:
        case IDC_SP2:
        case IDC_SP3:
        case IDC_SP4:
        case IDC_SP5:
        case IDC_SP6:
        case IDC_SP7:
        case IDC_SP8:
        case IDC_SP9:
        case IDC_SP10:

		case IDC_O:
		case IDC_C:
		case IDC_M:
        case IDC_B:
        case IDC_X:
        case IDC_BTN0:
        case IDC_BTN1: case IDC_BTN2: case IDC_BTN3:
        case IDC_BTN4: case IDC_BTN5: case IDC_BTN6:
        case IDC_BTN7: case IDC_BTN8: case IDC_BTN9:
            _itoa((INT)wParam, rgchNum, 10);
			while (!FAddSymbolValueToSymTab("ButtonPressed", rgchNum))
				if (!FHandleOOM(hdlg))
					{
					DestroyWindow(GetParent(hdlg));
					return(fTrue);
					}

			while ((psz = rgsz = (RGSZ)SAlloc((CB)(11 * sizeof(SZ)))) ==
					(RGSZ)NULL)
				if (!FHandleOOM(hdlg))
					{
					DestroyWindow(GetParent(hdlg));
					return(fTrue);
					}

			for (idc = IDC_B1; GetDlgItem(hdlg, idc); psz++, idc++)
				{
				BOOL fChecked = IsDlgButtonChecked(hdlg, idc);

				while ((*psz = SzDupl(fChecked ? "ON" : "OFF")) == (SZ)NULL)
					if (!FHandleOOM(hdlg))
						{
						DestroyWindow(GetParent(hdlg));
						return(fTrue);
						}
				}
			*psz = (SZ)NULL;

			while ((sz = SzListValueFromRgsz(rgsz)) == (SZ)NULL)
				if (!FHandleOOM(hdlg))
					{
					DestroyWindow(GetParent(hdlg));
					return(fTrue);
					}
			while (!FAddSymbolValueToSymTab("CheckItemsOut", sz))
				if (!FHandleOOM(hdlg))
					{
					DestroyWindow(GetParent(hdlg));
					return(fTrue);
					}

			SFree(sz);
			EvalAssert(FFreeRgsz(rgsz));
            PostMessage(GetParent(hdlg), (WORD)STF_UI_EVENT, 0, 0L);
			break;
    		}
		break;

	case STF_DESTROY_DLG:
		PostMessage(GetParent(hdlg), (WORD)STF_CHECK_DLG_DESTROYED, 0, 0L);
		DestroyWindow(hdlg);
		return(fTrue);
		}

    return(fFalse);
}




/* 2. The dual list dialog box procedure to handle detailed selection of
**    optional files
*/

//
// Macros for the dual list box
//

#define nSizeOfItem(lItem) atol( ((RGSZ)lItem)[1] )

//
// External dual list box handling routines (defined in dualproc.c)
//

BOOL fFillListBoxFromSzList (HWND, WORD, SZ);
BOOL fFreeListBoxEntries (HWND, WORD);
SZ   szGetSzListFromListBox (HWND, WORD);

//
// Local function to update the status fields in the partial dual list box
//

static BOOL fUpdateStatus ( HDLG, WORD );

/*
** Author:
**    Sunil Pai, 8/21/91, Adapted from Win3.1 setup code.
**
**	Purpose:
**		Dual Listbox Dialog procedure for templates with two listboxes
**    exchanging selection items.  This is implemented with owner draw
**    list boxes.
**
**	Control IDs:
**		The Listbox controls must have the id IDC_LIST1 and IDC_LIST2.
**    Pushbuttons recognized are IDC_O, IDC_C, IDC_M, IDC_H, IDC_X, and IDC_B.
**    In addition to these the following IDs are processed:
**    - IDC_A: To move a selected item(s) in listbox1 to listbox2
**    - IDC_R: To move a selected item(s) in listbox2 to listbox1
**    - IDC_S: To move all items in listbox1 to listbox2
**
**	Initialization:
**		The symbol $(ListItemsIn) is a list of strings to insert into the
**		listbox 1.  The symbol $(ListItemOut) is a list of strings to insert
**    into listbox 2.  Items can be added to listbox2 or removed to
**    listbox1.  All items can be shifted to listbox2 using the Add All
**    button.
**
**    The $(ListItemsIn) and $(ListItemsOut can be:
**
**    a) A Simple List:
**    {$(ListElem1), $(ListElem2)...}
**
**    b) A Compound List:
**
**    { {$(ListItem1Data), $(ListItem1Aux1), $(ListItem1Aux2)...},
**      {$(ListItem2Data), $(ListItem2Aux1), $(ListItem2Aux2)...},
**      ...
**    }
**
**    In the case of a compound list the $(ListItemnData) field is displayed
**    in the listbox.  When any item is selected the selection displays the
**    fields in the selection in the status fields in the dialog.
**    - ListItemnData is displayed in the IDC_TEXT1 field if present
**    - ListItemnAux1 is displayed in the IDC_TEXT2 field if present
**    - ListItemnAux2 is displayed in the IDC_TEXT3 field if present
**    ...
**
**	Termination:
**		The items in listbox2 are returned in
**		$(ListItemsOut).  The id of the Pushbutton (eg IDC_C) which caused
**		termination is converted to a string and stored in the symbol
**
*****************************************************************************/
INT_PTR APIENTRY FGstDual1DlgProc(HWND hdlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
   CHP    rgchNum[10];
   SZ     szList;
   INT    i, nCount;
   WORD   idc, idcSrc, idcDst;
   LONG_PTR   lItem;
   RGSZ   rgszItem;
   PSZ    pszItem;


    switch (wMsg)
		{
    case WM_INITDIALOG:
		AssertDataSeg();
        FCenterDialogOnDesktop(hdlg);

      // Find the List Items In and initialise the first list box

      if ((szList = SzFindSymbolValueInSymTab("ListItemsIn")) == (SZ)NULL)
         {
         Assert(fFalse);
         return(fTrue);
         }
      if(!fFillListBoxFromSzList (hdlg, IDC_LIST1, szList))
         {
         EvalAssert(fFreeListBoxEntries (hdlg, IDC_LIST1));
         Assert(fFalse);
         return(fTrue);
         }


      // Find the List Items Out and initialise the second list box

      if ((szList = SzFindSymbolValueInSymTab("ListItemsOut")) == (SZ)NULL)
         {
         Assert(fFalse);
         return(fTrue);
         }
      if(!fFillListBoxFromSzList (hdlg, IDC_LIST2, szList))
         {
         EvalAssert(fFreeListBoxEntries (hdlg, IDC_LIST1));
         EvalAssert(fFreeListBoxEntries (hdlg, IDC_LIST2));
         Assert(fFalse);
         return(fTrue);
         }


      EnableWindow(GetDlgItem(hdlg,IDC_A), fFalse);
      EnableWindow(GetDlgItem(hdlg,IDC_R), fFalse);

      if ((INT)SendDlgItemMessage(hdlg, IDC_LIST1, LB_GETCOUNT, 0, 0L) <= 0) {
          EnableWindow(GetDlgItem(hdlg,IDC_S),fFalse);
      }
      else {
          EnableWindow(GetDlgItem(hdlg,IDC_S),fTrue);
      }

      EvalAssert (fUpdateStatus ( hdlg, IDC_LIST1 ));
      EvalAssert (fUpdateStatus ( hdlg, IDC_LIST2 ));
      EvalAssert (fUpdateStatus ( hdlg, IDC_MAX1 ));

      //
      // Return
      //

      return(fTrue);

	case STF_REINITDIALOG:
		return(fTrue);

//    case STF_DLG_ACTIVATE:
//    case WM_MOUSEACTIVATE:
//        if (FActiveStackTop())
//            break;
//        EvalAssert(FInactivateHelp());
//        SetWindowPos(hdlg, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
//        /* fall through */
//    case STF_UILIB_ACTIVATE:
//        EvalAssert(FActivateStackTop());
//        return(fTrue);

    case WM_CLOSE:
        PostMessage(
            hdlg,
            WM_COMMAND,
            MAKELONG(IDC_X, BN_CLICKED),
            0L
            );
        return(fTrue);

    case WM_COMMAND:
		switch(idc = LOWORD(wParam))
			{
         case IDC_LIST1:
         case IDC_LIST2:
            nCount = (INT)SendDlgItemMessage(hdlg, idc, LB_GETSELCOUNT, 0, 0L);

            EnableWindow(GetDlgItem(hdlg, (idc == IDC_LIST1) ? IDC_A : IDC_R),
                         nCount ? fTrue : fFalse
                        );				

            switch (HIWORD(wParam))
            {
               case LBN_SELCHANGE:
                  i = (INT)SendDlgItemMessage(hdlg, idc, LB_GETCURSEL, 0, 0L);
                  if (i >= 0) {
                     EvalAssert(fUpdateStatus( hdlg, idc ));
                  }
                  break;

               default:
                  return fFalse;
            }
            break;

         case IDC_A:
         case IDC_R:
         {
            #define MAXSEL 100       // should be big enough
            INT sel[MAXSEL];

            if (idc == IDC_A)
               {
               idcSrc = IDC_LIST1;
               idcDst = IDC_LIST2;
               }
            else
               {
               idcSrc = IDC_LIST2;
               idcDst = IDC_LIST1;
               }

            nCount = (INT)SendDlgItemMessage(hdlg,
                                             idcSrc,
                                             LB_GETSELITEMS,
                                             MAXSEL,
                                             (LPARAM)sel);
            if (nCount <= 0)
               break;

            // dup everything over to the other list

            SendDlgItemMessage(hdlg, idcSrc, WM_SETREDRAW, fFalse, 0L);
            SendDlgItemMessage(hdlg, idcDst, WM_SETREDRAW, fFalse, 0L);

            for (i = 0; i < nCount; i++)
            {
               SendDlgItemMessage(hdlg, idcSrc, LB_GETTEXT, sel[i],
                                                      (LPARAM)&lItem);
               SendDlgItemMessage(hdlg, idcDst, LB_ADDSTRING, 0,
                                                      (LPARAM)lItem);
            }

            SendDlgItemMessage(hdlg, idcDst, WM_SETREDRAW, fTrue, 0L);
            InvalidateRect(GetDlgItem(hdlg, idcDst), NULL, fTrue);

            // and delete the source stuff (backwards to get order right)

            for (i = nCount - 1; i >= 0; i--)
               SendDlgItemMessage(hdlg, idcSrc, LB_DELETESTRING,
                                                              sel[i], 0L);
            SendDlgItemMessage(hdlg, idcSrc, WM_SETREDRAW, fTrue, 0L);
            InvalidateRect(GetDlgItem(hdlg, idcSrc), NULL, fTrue);

            if (idc == IDC_A)
            {
               if ((INT)SendDlgItemMessage(hdlg, IDC_LIST1,
                                        LB_GETCOUNT, 0, 0L) <= 0)
               {
                  EnableWindow(GetDlgItem(hdlg,IDC_S),fFalse);
               }
               else
                  EnableWindow(GetDlgItem(hdlg,IDC_S),fTrue);
            }
            else
               EnableWindow(GetDlgItem(hdlg,IDC_S),fTrue);

            if ((INT)SendDlgItemMessage(hdlg, IDC_LIST2,
                                        LB_GETCOUNT, 0, 0L) <= 0)
            {
               SetFocus(GetDlgItem(hdlg, IDC_S));
               SendMessage(hdlg, DM_SETDEFID, IDC_S, 0L);
            }
            else
            {
               SetFocus(GetDlgItem(hdlg, IDC_C));
               SendMessage(hdlg, DM_SETDEFID, IDC_C, 0L);
            }

            EnableWindow(GetDlgItem(hdlg,idc),fFalse);

            EvalAssert (fUpdateStatus ( hdlg, IDC_LIST1 ));
            EvalAssert (fUpdateStatus ( hdlg, IDC_LIST2));
            EvalAssert (fUpdateStatus ( hdlg, IDC_MAX1));

            return fFalse;
         }

         case IDC_S:
            nCount = (INT)SendDlgItemMessage(hdlg, IDC_LIST1, LB_GETCOUNT, 0, 0L);

            SendDlgItemMessage(hdlg, IDC_LIST2, WM_SETREDRAW, fFalse, 0L);

            for (i = 0; i < nCount; i++)
               {
               SendDlgItemMessage(hdlg, IDC_LIST1, LB_GETTEXT, i,
                                                      (LPARAM)&lItem);
               SendDlgItemMessage(hdlg, IDC_LIST2, LB_ADDSTRING, 0,
                                                      (LPARAM)lItem);
               }

            SendDlgItemMessage(hdlg, IDC_LIST1, LB_RESETCONTENT, 0, 0L);
            SendDlgItemMessage(hdlg, IDC_LIST2, WM_SETREDRAW, fTrue, 0L);
            InvalidateRect(GetDlgItem(hdlg, IDC_LIST2), NULL, fFalse);

            EnableWindow(GetDlgItem(hdlg,IDC_A),fFalse);
            EnableWindow(GetDlgItem(hdlg,IDC_S),fFalse);

            SetFocus(GetDlgItem(hdlg, IDC_C));
            SendMessage(hdlg, DM_SETDEFID, IDC_C, 0L);

            EvalAssert (fUpdateStatus ( hdlg, IDC_LIST1 ));
            EvalAssert (fUpdateStatus ( hdlg, IDC_LIST2 ));
            EvalAssert (fUpdateStatus ( hdlg, IDC_MAX1 ));

            return fFalse;



         case IDCANCEL:
            if (LOWORD(wParam) == IDCANCEL) {

                if (!GetDlgItem(hdlg, IDC_B) || HIWORD(GetKeyState(VK_CONTROL)) || HIWORD(GetKeyState(VK_SHIFT)) || HIWORD(GetKeyState(VK_MENU)))
                {
                    break;
                }
                wParam = IDC_B;

            }

         case IDC_O:
         case IDC_C:
         case IDC_M:
         case IDC_B:
         case IDC_X:

            // Indicate the Button selected.

            _itoa((INT)wParam, rgchNum, 10);
            while (!FAddSymbolValueToSymTab("ButtonPressed", rgchNum))
               if (!FHandleOOM(hdlg))
                  {
                  DestroyWindow(GetParent(hdlg));
                  return(fTrue);
                  }

             // Fetch the list from first list and put it into ListItemsIn
				 EvalAssert((szList = szGetSzListFromListBox(hdlg, IDC_LIST1)) != (SZ) NULL) ;
             while (!FAddSymbolValueToSymTab("ListItemsIn", szList))
                if (!FHandleOOM(hdlg))
                   {
                   DestroyWindow(GetParent(hdlg));
                   return(fTrue);
                   }

             // Fetch the list from second list and put it into ListItemsIn
				 EvalAssert((szList = szGetSzListFromListBox(hdlg, IDC_LIST2)) != (SZ) NULL) ;
             while (!FAddSymbolValueToSymTab("ListItemsOut", szList))
                if (!FHandleOOM(hdlg))
                   {
                   DestroyWindow(GetParent(hdlg));
                   return(fTrue);
                   }

				
            PostMessage(GetParent(hdlg), (WORD)STF_UI_EVENT, 0, 0L);
	         break;
         }
         break;

      case WM_COMPAREITEM:

         #define lpci ((LPCOMPAREITEMSTRUCT)lParam)

         return(CrcStringCompareI((SZ) *((RGSZ)lpci->itemData1),
                                  (SZ) *((RGSZ)lpci->itemData2)
                                 )
               );

      case WM_CHARTOITEM:
      {
         HWND hLB;
         INT  i, j, nCount;
         LONG_PTR lItem;
         CHP  chpBuf1[2], chpBuf2[2];  //used because we only have str cmp

         chpBuf1[1] = chpBuf2[1] = 0;

         chpBuf1[0] = (CHAR)LOWORD(wParam);

         // See if we need to process this character at all

         if (CrcStringCompareI(chpBuf1, " ") == crcSecondHigher)
            return -1;  //tell windows to do its default key processing

         // Extract the list box handle and the index of the current
         // selection item

         hLB = (HWND)lParam;
         i   = HIWORD(wParam);

         // Find the number of items in the list

         nCount = (INT)SendMessage(hLB, LB_GETCOUNT, 0, 0L);

         // From the next item downwards (circularly) look at all the
         // items to see if the char is the same as the first char in the
         // list box display item.

         for (j = 1; j < nCount; j++)
            {
            // get the data here
            SendMessage(hLB, LB_GETTEXT, (i + j) % nCount, (LPARAM)&lItem);

            // make a dummy string
            chpBuf2[0] = (*((RGSZ) lItem))[0];

            // do a case insensitive cmp of key and string
            if (CrcStringCompareI(chpBuf1, chpBuf2) == crcEqual)
               break;
            }

         return ((j == nCount) ? -2 : (i +j) % nCount);

         break;
      }

      case WM_DRAWITEM:

         #define lpDrawItem ((LPDRAWITEMSTRUCT)lParam)

         if (lpDrawItem->itemState & ODS_SELECTED) {
            SetTextColor(lpDrawItem->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
            SetBkColor(lpDrawItem->hDC, GetSysColor(COLOR_HIGHLIGHT));
         }
         else{
            SetTextColor(lpDrawItem->hDC, GetSysColor(COLOR_WINDOWTEXT));
            SetBkColor(lpDrawItem->hDC, GetSysColor(COLOR_WINDOW));
         }

         if (lpDrawItem->itemID != (UINT)-1){

            if (pszItem = rgszItem = (RGSZ) lpDrawItem->itemData ) {
                ExtTextOut(lpDrawItem->hDC,
                            lpDrawItem->rcItem.left,
                            lpDrawItem->rcItem.top,
                            ETO_OPAQUE, &lpDrawItem->rcItem,
                            (SZ)(*pszItem), lstrlen((SZ)(*pszItem)), NULL);
            }

            if (lpDrawItem->itemState & ODS_FOCUS) {
               DrawFocusRect(lpDrawItem->hDC, &lpDrawItem->rcItem);
            }

         }
         else {
            RECT rc;

            if ( (lpDrawItem->itemAction & ODA_FOCUS) &&
                 (SendMessage( GetDlgItem( hdlg, (int)wParam ), LB_GETITEMRECT, (WPARAM)0, (LPARAM)&rc ) != LB_ERR)
               ) {
                DrawFocusRect(lpDrawItem->hDC, &rc);
            }

         }
         return( fTrue );


	case STF_DESTROY_DLG:
      EvalAssert(fFreeListBoxEntries (hdlg, IDC_LIST1));
      EvalAssert(fFreeListBoxEntries (hdlg, IDC_LIST2));
		PostMessage(GetParent(hdlg), (WORD)STF_DUAL_DLG_DESTROYED, 0, 0L);
		DestroyWindow(hdlg);
		return(fTrue);
		}

    return(fFalse);
}



BOOL
fUpdateStatus(
    HDLG hdlg,
    WORD idc
    )

{
    #define MAXSEL 100       // should be big enough
    INT    sel[MAXSEL];
    INT    nCount, i;
    INT    nSize;
    LONG_PTR   lItem;

    //
    // Find out what we need to update
    //

    switch ( idc ) {

    case IDC_LIST1:
    case IDC_LIST2:

        //
        //  Find out the selected items in the list box and the total size
        //  associated with them.
        //
        nCount = (INT)SendDlgItemMessage(
                          hdlg,
                          idc,
                          LB_GETSELITEMS,
                          MAXSEL,
                          (LPARAM)sel
                          );

        nSize = 0;
        for (i = 0; i < nCount; i++) {
            SendDlgItemMessage(hdlg, idc, LB_GETTEXT, sel[i], (LPARAM)&lItem);
            nSize = nSize + nSizeOfItem(lItem);
        }

        //
        // Update the number of files and the size associated
        //

        MySetDlgItemInt ( hdlg, IDC_STATUS1 + idc - IDC_LIST1, nCount );
        MySetDlgItemInt ( hdlg, IDC_TOTAL1 + idc - IDC_LIST1, nSize );

        break;


    case IDC_MAX1:

        //
        // find all the items associated with the list box and the size assoc
        //

        nCount = (INT)SendDlgItemMessage(hdlg, IDC_LIST2, LB_GETCOUNT, 0, 0L);

        nSize = 0;
        for (i = 0; i < nCount; i++) {
            SendDlgItemMessage(hdlg, IDC_LIST2, LB_GETTEXT, i, (LPARAM)&lItem);
            nSize = nSize + nSizeOfItem(lItem);
        }

        MySetDlgItemInt ( hdlg, idc, nSize );

        break;

    default:
        return ( fFalse );

    }

    return ( fTrue );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\path2.c ===
#include "precomp.h"
#pragma hdrstop
/***************************************************************************/
/***** Common Library Component - Path Manipulation Routines - 2 ***********/
/***************************************************************************/


/*
**  Purpose:
**      Creates a valid FAT path from two pieces - a dir string (includes
**      drive, colon, root backslash and zero or more subdirs - backslash
**      at end is optional), and a subpath string.
**  Arguments:
**      szDir:  string to a volume consisting of a drive letter (upper
**          or lower case), a colon, a root backslash, and zero or more
**          subdirs, optionally ending with a backslash.
**      szSubPath: string for a subpath of zero or more subdirs and a file
**          name separated by backslashes.  (No backslash at the beginning.)
**      szBuf:     buffer in which to store the constructed FAT path.  It
**          have room for cchpBufMax physical characters which will include
**          the zero terminator.
**      cchpBufMax: non-negative maximum number of useable physical
**          characters in szBuf.
**  Returns:
**      fFalse if any of the string buffers are NULL, if szDir does not
**          start with a valid drive letter, colon and root backslash, or
**          if szSubPath starts with a backslash or is invalid, or if there
**          is not enough space in szBuf to store the newly constructed FAT
**          path.
**      fTrue if a valid FAT path can be constructed from the pieces and
**          stored in szBuf.
**
**************************************************************************/
BOOL  APIENTRY FMakeFATPathFromDirAndSubPath(szDir, szSubPath,
        szBuf, cchpBufMax)
SZ   szDir;
SZ   szSubPath;
SZ   szBuf;
CCHP cchpBufMax;
{
    CB cbBackSlash = (CB)0;
    SZ szPathTmp;
    SZ szLastChar;
    CB cb;

    AssertDataSeg();

    ChkArg(szDir != (SZ)NULL &&
            *szDir != '\0', 1, fFalse);
    ChkArg(szSubPath != (SZ)NULL, 2, fFalse);
    ChkArg(szBuf != (SZ)NULL, 3, fFalse);
    ChkArg(cchpBufMax > (CCHP)4, 4, fFalse);

    EvalAssert((szLastChar = SzLastChar(szDir)) != (SZ)NULL);
    //
    // szLastChar could be a lead byte, but lead bytes aren't in the
    // ASCII range so we just check for the \ without checking if
    // szLastChar is a lead byte.
    //
    if(*szLastChar != '\\') {
        cbBackSlash = (CB)2;
    }

    cb = strlen(szDir) + strlen(szSubPath) + cbBackSlash + 1;
    if ((szPathTmp = SAlloc(cb)) == (SZ)NULL ||
            strcpy(szPathTmp, szDir) != szPathTmp ||
            (cbBackSlash > 0 &&
             SzStrCat(szPathTmp, "\\") != szPathTmp) ||
            SzStrCat(szPathTmp, szSubPath) != szPathTmp)
        {

        if(szPathTmp) {
            SFree(szPathTmp);
        }

        return(fFalse);
        }

    if (_fullpath(szBuf, szPathTmp, cchpBufMax) == (SZ)NULL)
        {
        SFree(szPathTmp);
        return(fFalse);
        }

    SFree(szPathTmp);

    return fTrue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\precomp.h ===
//
// Public system headers
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <ntseapi.h>
#include <ntsam.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <windows.h>
#include <imagehlp.h>
#include <winreg.h>
#include <winspool.h>
#include <lzexpand.h>
#include <diamondd.h>
#include <ddeml.h>
#include <shellapi.h>
#include <port1632.h>
#include <userenv.h>
#include <userenvp.h>

//
// Private headers
//
#include "comstf.h"
#include "uilstf.h"
#include "ui.h"
#include "install.h"
#include "detect.h"
#include "cmnds.h"
#include "decomp.h"
#include "gauge.h"
#include "misc.h"
#include "tagfile.h"
#include "dcmds.h"
#include "dospif.h"
#include "sbutton.h"
#include "secur.h"
#include "_comstf.h"
#include "_filecm.h"
#include "_uilstf.h"
#include "_shell.h"
#include "_stfinf.h"
#include "_context.h"
#include "_log.h"
#include "_dinterp.h"
#include "_infdbg.h"
#include "rc_ids.h"
#include "msg.h"
#include "setupdll.h"

//
// CRT headers
//
#include <errno.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <memory.h>
#include <direct.h>
#include <time.h>
#include <fcntl.h>
#include <limits.h>
#include <ctype.h>
#include <process.h>
#include <search.h>
#include <mbstring.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\progcm.c ===
#include "precomp.h"
#pragma hdrstop
/* File: progcm.c */
/**************************************************************************/
/*  Install: Program Manager commands.
/*  Can create groups, delete groups, add/delete items to groups
/**************************************************************************/


BOOL
FCreateProgManGroup(
    IN SZ   szGroup,
    IN SZ   szPath,
    IN CMO  cmo,
    IN BOOL CommonGroup
    )
{

    return ( CreateGroup(szGroup, CommonGroup) );

}


BOOL
FRemoveProgManGroup(
    IN SZ   szGroup,
    IN CMO  cmo,
    IN BOOL CommonGroup
    )
{
    return ( DeleteGroup(szGroup, CommonGroup) );
}


BOOL
FShowProgManGroup(
    IN SZ   szGroup,
    IN SZ   szCommand,
    IN CMO  cmo,
    IN BOOL CommonGroup
    )
{
    return(fTrue);
}


BOOL
FCreateProgManItem(
    IN SZ   szGroup,
    IN SZ   szItem,
    IN SZ   szCmd,
    IN SZ   szIconFile,
    IN INT  nIconNum,
    IN CMO  cmo,
    IN BOOL CommonGroup
    )
{

    return ( AddItem(szGroup, CommonGroup, szItem, szCmd,
                     szIconFile, nIconNum, NULL, 0, SW_SHOWNORMAL) );

}


BOOL
FRemoveProgManItem(
    IN SZ   szGroup,
    IN SZ   szItem,
    IN CMO  cmo,
    IN BOOL CommonGroup
    )
{

    return ( DeleteItem(szGroup, CommonGroup, szItem, TRUE) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\pci.c ===
#include "precomp.h"
#pragma hdrstop
typedef DWORD (APIENTRY *T_PCIINFO)(
    ULONG BusNumber,
    ULONG SlotNumber,
    ULONG Offset,
    ULONG Length,
    PVOID Data );

typedef struct _PCI_SLOT_NUMBER {
    union {
        struct {
            ULONG   DeviceNumber:5;
            ULONG   FunctionNumber:3;
            ULONG   Reserved:24;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;

extern CHAR ReturnTextBuffer[1024];

/*

GetPCISlotInformation - Get PCI information.
    The user must passed 3 arguments to the function.
    1st argument - bus number
    2rd argument - slot number

    It will return a string as:
    {VendorID, DeviceID}

*/

BOOL
GetPciInformation(
    IN DWORD cArgs,
    IN LPSTR Args[],
    OUT LPSTR *TextOut
    )

{
    static HMODULE mDtect = NULL;
    static T_PCIINFO pProc = NULL;

    ULONG BusNum = atol( Args[0] );
    ULONG Device   = atol( Args[1] );
    ULONG Function = atol( Args[2] );

    USHORT usVendor = 0;
    USHORT usDevice = 0;

    TCHAR buf[100];

    lstrcpy( ReturnTextBuffer, "{" );

    if ( mDtect == NULL )
        mDtect = LoadLibrary("netdtect.dll");

    if ( mDtect != NULL )
    {
        if ( pProc == NULL )
            pProc = (T_PCIINFO)GetProcAddress( mDtect, "DetectReadPciSlotInformation" );

        if ( pProc != NULL )
        {

            PCI_SLOT_NUMBER pciSlot;

            pciSlot.u.AsULONG = Device;
            pciSlot.u.bits.DeviceNumber = Device;
            pciSlot.u.bits.FunctionNumber = Function;


            (*(T_PCIINFO)pProc)( BusNum, pciSlot.u.AsULONG, 0, sizeof(USHORT), &usVendor);
            (*(T_PCIINFO)pProc)( BusNum, pciSlot.u.AsULONG, sizeof(USHORT), sizeof(USHORT), &usDevice);
        }
    }

    wsprintf( buf, "\"%d\",\"%d\"", usVendor, usDevice );

    lstrcat( ReturnTextBuffer, buf );
    lstrcat( ReturnTextBuffer, "}" );
    *TextOut = ReturnTextBuffer;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\printer.c ===
#include "precomp.h"
#pragma hdrstop
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    printer.c

Abstract:

    Printer module for Win32 PDK Setup.
    This module has no external dependencies and is not statically linked
    to any part of Setup.

Author:

    Sunil Pai (sunilp) March 1992

--*/


//
//  Get Windows system printer directory
//
CB
GetPrinterDriverDir(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{
    DWORD   cbRet = 0;
    SZ      szServerName  = NULL ;
    SZ      szEnvironment = NULL ;

    Unused(Args);
    Unused(cArgs);

    if ( (cArgs >= 2)   ) {

        if (*(Args[0]) != '\0') {
            szServerName  = Args[0];
        }

        if (*(Args[1]) != '\0') {
            szEnvironment = Args[1];
        }

    }

    GetPrinterDriverDirectory(
        szServerName,                 // pName
        szEnvironment,                // pEnvironment
        1,                            // Level
        ReturnBuffer,                 // pDriverDirectory
        cbReturnBuffer,               // cbBuf
        &cbRet                        // pcbNeeded
        );

    if ( cbRet == 0 ) {
        ReturnBuffer[0] = '\0';
    }

    return lstrlen(ReturnBuffer)+1;
}


BOOL
AddPrinterDriverWorker(
    IN LPSTR Model,
    IN LPSTR Environment,
    IN LPSTR Driver,
    IN LPSTR DataFile,
    IN LPSTR ConfigFile,
    IN LPSTR Server
    )
{
    DRIVER_INFO_2 DriverInfo2;

    ZeroMemory( &DriverInfo2, sizeof(DRIVER_INFO_2) );
    DriverInfo2.cVersion     = 0;
    DriverInfo2.pName        = Model;                // QMS 810
    DriverInfo2.pEnvironment = Environment;          // W32x86
    DriverInfo2.pDriverPath  = Driver;               // c:\drivers\pscript.dll
    DriverInfo2.pDataFile    = DataFile;             // c:\drivers\QMS810.PPD
    DriverInfo2.pConfigFile  = ConfigFile;           // c:\drivers\PSCRPTUI.DLL

    if(AddPrinterDriver(Server, 2, (LPBYTE)&DriverInfo2)) {
        SetReturnText( "ADDED" );
    } else {
        switch(GetLastError()) {
        case ERROR_PRINTER_DRIVER_ALREADY_INSTALLED:
            SetReturnText( "PRESENT" );
            break;
        case ERROR_ACCESS_DENIED:
            SetReturnText( "DENIED" );
            break;
        default:
            SetReturnText( "ERROR" );
            break;
        }
    }
    return (TRUE);
}


BOOL
AddPrinterWorker(
    IN LPSTR Name,
    IN LPSTR Port,
    IN LPSTR Model,
    IN LPSTR Description,
    IN LPSTR PrintProcessor,
    IN DWORD Attributes,
    IN LPSTR Server
    )
{
    PRINTER_INFO_2 PrinterInfo2;
    HANDLE         bStatus;

    ZeroMemory( &PrinterInfo2, sizeof(PRINTER_INFO_2) );
    PrinterInfo2.pServerName      = NULL;
    PrinterInfo2.pPrinterName     = Name;
    PrinterInfo2.pShareName       = NULL;
    PrinterInfo2.pPortName        = Port;
    PrinterInfo2.pDriverName      = Model;
    PrinterInfo2.pComment         = Description;
    PrinterInfo2.pLocation        = NULL;
    PrinterInfo2.pDevMode         = (LPDEVMODE)NULL;
    PrinterInfo2.pSepFile         = NULL;
    PrinterInfo2.pPrintProcessor  = PrintProcessor;
    PrinterInfo2.pDatatype        = NULL;
    PrinterInfo2.pParameters      = NULL;
    PrinterInfo2.Attributes       = Attributes;
    PrinterInfo2.Priority         = 0;
    PrinterInfo2.DefaultPriority  = 0;
    PrinterInfo2.StartTime        = 0;
    PrinterInfo2.UntilTime        = 0;
    PrinterInfo2.Status           = 0;
    PrinterInfo2.cJobs            = 0;
    PrinterInfo2.AveragePPM       = 0;

    bStatus = AddPrinter( Server, 2, (LPBYTE)&PrinterInfo2);
    if ( bStatus != (HANDLE)NULL ) {

        SetReturnText( "ADDED" );
        ClosePrinter(bStatus);
        return( TRUE );

    }
    else {

        switch(GetLastError()) {
        case ERROR_PRINTER_ALREADY_EXISTS:
            SetReturnText( "PRESENT" );
            break;
#if 0
        case ERROR_ACCESS_DENIED:
            SetReturnText( "DENIED" );
            break;
#endif
        default:
            SetReturnText( "ERROR" );
            break;
        }
        return( TRUE );
    }

}


BOOL
AddPrinterMonitorWorker(
    IN LPSTR Model,
    IN LPSTR Environment,
    IN LPSTR Driver,
    IN LPSTR Server
    )
{
    MONITOR_INFO_2 MonitorInfo2;

    ZeroMemory( &MonitorInfo2, sizeof(MONITOR_INFO_2) );
    MonitorInfo2.pName        = Model;                // Local Port
    MonitorInfo2.pEnvironment = Environment;          // W32x86
    MonitorInfo2.pDLLName  = Driver;               // c:\winnt\system32\localmon.dll

    if(AddMonitor(Server, 2, (LPBYTE)&MonitorInfo2)) {
        SetReturnText( "ADDED" );
    } else {
        switch(GetLastError()) {
        case ERROR_ALREADY_EXISTS:
            SetReturnText( "PRESENT" );
            break;
        case ERROR_ACCESS_DENIED:
            SetReturnText( "DENIED" );
            break;
        default:
            SetReturnText( "ERROR" );
            break;
        }
    }
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\rc_ids.h ===
#define IDB_BACKGROUND          150

  /* for Resource String Table */
#define IDS_NULL                     0
#define IDS_USAGE_TITLE              1
#define IDS_USAGE_MSG1               2
#define IDS_USAGE_MSG2               3
#define IDS_USAGE_USAGE              4
#define IDS_USAGE_F                  5
#define IDS_USAGE_I                  6
#define IDS_USAGE_C                  7
#define IDS_USAGE_S                  8
#define IDS_USAGE_D                  9
#define IDS_USAGE_T                 10
#define IDS_USAGE_N                 11
#define IDS_USAGE_V                 12


#define IDS_ERROR                   13
#define IDS_INTERNAL_ERROR          14
#define IDS_BAD_SHL_SCRIPT_SECT     15
#define IDS_BAD_DEST_PATH           16
#define IDS_BAD_INF_SRC             17
#define IDS_BAD_SRC_PATH            18
#define IDS_EXE_PATH_LONG           19
#define IDS_GET_MOD_FAIL            20

#define IDS_CANT_FIND_SHL_SECT      21
#define IDS_REGISTER_CLASS          22
#define IDS_CREATE_WINDOW           23

#define IDS_UPDATE_INF              24
#define IDS_UI_CMD_ERROR            25

#define IDS_SHELL_CMDS_SECT         27

#define IDS_APP_TITLE               28

#define IDS_REPAIR_BOOTCODE_MSG     29

#define IDS_SHL_CMD_ERROR           30
#define IDS_NEED_EXIT               31

#define IDS_INF_SECT_REF            32

#define IDS_CD_BLANKNAME            33
#define IDS_CD_BLANKORG             34
#define IDS_WARNING                 35
#define IDS_INSTRUCTIONS            36
#define IDS_EXITCAP                 37
#define IDS_MESSAGE                 38
#define IDS_CANT_END_SESSION        39
#define IDS_CANCEL                  40
#define IDS_PROGRESS                41
#define IDS_NOTDONE                 42

// error messages
#define IDS_ERROR_OOM               43
#define IDS_ERROR_OPENFILE          44
#define IDS_ERROR_CREATEFILE        45
#define IDS_ERROR_READFILE          46
#define IDS_ERROR_WRITEFILE         47
#define IDS_ERROR_REMOVEFILE        48
#define IDS_ERROR_RENAMEFILE        49
#define IDS_ERROR_READDISK          50
#define IDS_ERROR_CREATEDIR         51
#define IDS_ERROR_REMOVEDIR         52
#define IDS_ERROR_CHANGEDIR         53
#define IDS_ERROR_GENERALINF        54
#define IDS_ERROR_INFBADSECTION     55
#define IDS_ERROR_INFBADLINE        56
#define IDS_ERROR_CLOSEFILE         57
#define IDS_ERROR_VERIFYFILE        58
#define IDS_ERROR_INFXKEYS          59
#define IDS_ERROR_INFSMDSECT        60
#define IDS_ERROR_WRITEINF          61
#define IDS_ERROR_LOADLIBRARY       62
#define IDS_ERROR_BADLIBENTRY       63
#define IDS_ERROR_INVOKEAPPLET      64
#define IDS_ERROR_EXTERNALERROR     65
#define IDS_ERROR_DIALOGCAPTION     66
#define IDS_ERROR_INVALIDPOER       67
#define IDS_ERROR_INFMISSINGLINE    68
#define IDS_ERROR_INFBADFDLINE      69
#define IDS_ERROR_INFBADRSLINE      70

#define IDS_GAUGE_TEXT_1            71
#define IDS_GAUGE_TEXT_2            72
#define IDS_INS_DISK                73
#define IDS_INTO                    74
#define IDS_BAD_CMDLINE             75
#define IDS_SETUP_WARNING           76
#define IDS_BAD_LIB_HANDLE          77

#define IDS_ERROR_INVALIDPATH            78
#define IDS_ERROR_WRITEINIVALUE          79
#define IDS_ERROR_REPLACEINIVALUE        80
#define IDS_ERROR_INIVALUETOOLONG        81
#define IDS_ERROR_DDEINIT                82
#define IDS_ERROR_DDEEXEC                83
#define IDS_ERROR_BADWINEXEFILEFORMAT    84
#define IDS_ERROR_RESOURCETOOLONG        85
#define IDS_ERROR_MISSINGSYSINISECTION   86
#define IDS_ERROR_DECOMPGENERIC          87
#define IDS_ERROR_DECOMPUNKNOWNALG       88
#define IDS_ERROR_MISSINGRESOURCE        89
#define IDS_ERROR_SPAWN                  90
#define IDS_ERROR_DISKFULL               91
#define IDS_ERROR_DDEREMOVEITEM          92
#define IDS_ERROR_DDEADDITEM             93
#define IDS_ERROR_INFMISSINGSECT         94
#define IDS_SURECANCEL                   95
#define IDS_ERROR_RUNTIMEPARSE           96
#define IDS_ERROR_OPENSAMEFILE           97
#define IDS_ERROR_GETVOLINFO             98
#define IDS_ERROR_GETFILESECURITY        99
#define IDS_ERROR_SETFILESECURITY       100

#define IDS_WINDOWS_NT_SETUP            101

// messages related to floppy operations (format/diskcopy).

#define IDS_INSERTDISKETTE              110
#define IDS_FIRSTREPAIRDISKPROMPT       111
#define IDS_SECONDREPAIRDISKPROMPT      112
#define IDS_FORMATTINGDISK              113
#define IDS_FORMATGENERALFAILURE        114
#define IDS_CANTDETERMINEFLOPTYPE       115
#define IDS_BADFLOPPYTYPE               116
#define IDS_FLOPPYWRITEPROT             117
#define IDS_FLOPPYIOERR                 118
#define IDS_FLOPPYUNKERR                119
#define IDS_RETRYFORMATREPAIRDISK       120
#define IDS_ALLDATAWILLBELOST           121
#define IDS_CANTINITFLOPPYSUP           122

//
// Strings informing user of maint-mode setup's obsolescence
//
#define IDS_MAINTOBS_MSG1               130

//
// Old setupdll strings
//
#define IDS_ERROR_FILENOTFOUND          203
#define IDS_ERROR_INVALIDNAME           204
#define IDS_ERROR_DLLOOM                205
#define IDS_ERROR_INVALIDDISK           206
#define IDS_ERROR_OPENFAIL              207
#define IDS_ERROR_IOCTLFAIL             208
#define IDS_ERROR_COPYFILE              209
#define IDS_ERROR_READFAILED            215
#define IDS_ERROR_WRITE                 216
#define IDS_ERROR_NOSIZE                217
#define IDS_ERROR_BADFILE               218
#define IDS_ERROR_BADARGS               219
#define IDS_ERROR_RTLOOM                221
#define IDS_ERROR_OBJDIROPEN            222
#define IDS_ERROR_OBJDIRREAD            223
#define IDS_ERROR_SYMLNKOPEN            224
#define IDS_ERROR_SYMLNKREAD            225
#define IDS_ERROR_ENVVARREAD            226
#define IDS_ERROR_ENVVAROVF             227
#define IDS_ERROR_ENVVARWRITE           228
#define IDS_ERROR_OBJNAMOVF             229
#define IDS_ERROR_BADNETNAME            232
#define IDS_ERROR_BADLOCALNAME          233
#define IDS_ERROR_BADPASSWORD           234
#define IDS_ERROR_ALREADYCONNECTED      235
#define IDS_ERROR_ACCESSDENIED          236
#define IDS_ERROR_NONETWORK             237
#define IDS_ERROR_NOTCONNECTED          238
#define IDS_ERROR_NETOPENFILES          239
#define IDS_ERROR_OPENPROCESSTOKEN      240
#define IDS_ERROR_ADJUSTPRIVILEGE       241
#define IDS_ERROR_ADDPRINTER            242
#define IDS_ERROR_ADDPRINTERDRIVER      243
#define IDS_ERROR_UNSUPPORTEDPRIV       244
#define IDS_ERROR_PRIVILEGE             245
#define IDS_ERROR_REGOPEN               246
#define IDS_ERROR_REGSAVE               249
#define IDS_ERROR_REGRESTORE            250
#define IDS_ERROR_REGSETVALUE           251
#define IDS_ERROR_SETCOMPUTERNAME       252
#define IDS_BUFFER_OVERFLOW             257
#define IDS_ERROR_SHUTDOWN              268
#define IDS_ERROR_SCOPEN                269
#define IDS_ERROR_SCSCREATE             270
#define IDS_ERROR_SCSCHANGE             271
#define IDS_ERROR_SCSOPEN               272
#define IDS_ERROR_SERVDEL               273
#define IDS_ERROR_NO_MEMORY             277
#define IDS_STRING_UNKNOWN_USER         278
#define IDS_WINNT_SETUP                 279
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\quitproc.c ===
#include "precomp.h"
#pragma hdrstop
/***************************************************************************/
/****************** Basic Class Dialog Handlers ****************************/
/***************************************************************************/


/*
**	Purpose:
**		Quit Dialog procedure.
**	Control IDs:
**		Pushbuttons recognized are IDC_O, IDC_C, IDC_M, IDC_H, IDC_X, and IDC_B.
**	Initialization:
**		none.
**	Termination:
**		The id of the Pushbutton (eg IDC_C) which caused termination is
**		converted to a string and stored in the symbol $(ButtonPressed).
**
*****************************************************************************/
INT_PTR APIENTRY FGstQuitDlgProc(HWND   hdlg,
                                 UINT   wMsg,
                                 WPARAM wParam,
                                 LPARAM lParam)
    {
    CHP rgchNum[10];

    Unused(lParam);

    switch (wMsg)
		{
    case WM_INITDIALOG:
        AssertDataSeg();
        if( wMsg == WM_INITDIALOG ) {
            FCenterDialogOnDesktop(hdlg);
        }
        return(fTrue);

    case STF_REINITDIALOG:
		return(fTrue);

    case WM_CLOSE:
        PostMessage(
            hdlg,
            WM_COMMAND,
            MAKELONG(IDC_X, BN_CLICKED),
            0L
            );
        return(fTrue);


    case WM_COMMAND:
		switch(LOWORD(wParam))
			{
		case IDCANCEL:
            if (LOWORD(wParam) == IDCANCEL) {

                if (!GetDlgItem(hdlg, IDC_B) || HIWORD(GetKeyState(VK_CONTROL)) || HIWORD(GetKeyState(VK_SHIFT)) || HIWORD(GetKeyState(VK_MENU)))
                {
                    break;
                }
                wParam = IDC_B;

            }
        case IDC_O:
		case IDC_C:
		case IDC_M:
        case IDC_B:
        case IDC_X:
        case IDC_BTN0:
        case IDC_BTN1: case IDC_BTN2: case IDC_BTN3:
        case IDC_BTN4: case IDC_BTN5: case IDC_BTN6:
        case IDC_BTN7: case IDC_BTN8: case IDC_BTN9:

            _itoa((INT)wParam, rgchNum, 10);
			while (!FAddSymbolValueToSymTab("ButtonPressed", rgchNum))
				if (!FHandleOOM(hdlg))
					{
					DestroyWindow(GetParent(hdlg));
					return(fTrue);
					}
            PostMessage(GetParent(hdlg), (WORD)STF_UI_EVENT, 0, 0L);
			break;
    		}
		break;

	case STF_DESTROY_DLG:
		PostMessage(GetParent(hdlg), (WORD)STF_QUIT_DLG_DESTROYED, 0, 0L);
		DestroyWindow(hdlg);
		return(fTrue);
		}

    return(fFalse);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\rdskboot.c ===
#define REPAIR_DISK_BOOTSECTOR_SIZE 45


unsigned char REPAIR_DISK_BOOTSECTOR[] = {
51,219,142,211,142,219,188,0,124,184,3,0,205,16,232,0,
0,94,129,198,28,0,252,180,14,172,10,192,116,4,205,16,
235,245,180,2,138,211,182,25,205,16,251,235,254
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\radproc.c ===
#include "precomp.h"
#pragma hdrstop
/***************************************************************************/
/****************** Basic Class Dialog Handlers ****************************/
/***************************************************************************/


/*
**	Purpose:
**		Radio Button Group Dialog procedure for templates with one group
**		of one to ten radio button controls.
**	Control IDs:
**		The Radio button controls must have sequential ids starting with IDC_B1
**		and working up to a maximum of IDC_B10.
**		Pushbuttons recognized are IDC_O, IDC_C, IDC_M, IDC_H, IDC_X, and IDC_B.
**	Initialization:
**		The symbol $(RadioDefault) is evaluated as an index (one-based) of
**			the radio button to be set on.  Default is 1.
**		The symbol $(OptionsGreyed) is evaluated as a list of indexes
**			(one-based) of radio buttons to be disabled (greyed).  Default is
**			none.
**	Termination:
**		The index of the currently selected radio button is stored in the
**		symbol $(ButtonChecked).  The id of the Pushbutton (eg IDC_C) which
**		caused termination is converted to a string and stored in the
**		symbol $(ButtonPressed).
**
*****************************************************************************/
INT_PTR APIENTRY FGstRadioDlgProc(HWND hdlg, UINT wMsg, WPARAM wParam,
		LPARAM lParam)
    {
    CHP  rgchNum[10];
    INT  i, iButtonChecked;
    static INT iButtonMax;
    WORD idc;
    SZ   sz;
    PSZ  psz;
    RGSZ rgsz;

    Unused(lParam);

    switch (wMsg)
		{
    case WM_INITDIALOG:
		AssertDataSeg();
        if( wMsg == WM_INITDIALOG ) {
            FCenterDialogOnDesktop(hdlg);
        }

      for (i = IDC_B1; i <= IDC_B10 && GetDlgItem(hdlg, i) != (HWND)NULL; i++)
          ;
      iButtonMax = i - 1;

		if ((sz = SzFindSymbolValueInSymTab("RadioDefault")) != (SZ)NULL)
			{
			iButtonChecked = atoi(sz);
			if (iButtonChecked < 1)
				iButtonChecked = 0;
			if (iButtonChecked > 10)
				iButtonChecked = 10;
			}
		else
			iButtonChecked = 1;

		if (iButtonChecked != 0)
			SendDlgItemMessage(hdlg, IDC_B0 + iButtonChecked, BM_SETCHECK,1,0L);

		if ((sz = SzFindSymbolValueInSymTab("OptionsGreyed")) == (SZ)NULL)
			{
			PreCondition(fFalse, fTrue);
			return(fTrue);
			}

		while ((psz = rgsz = RgszFromSzListValue(sz)) == (RGSZ)NULL)
			if (!FHandleOOM(hdlg))
				{
				DestroyWindow(GetParent(hdlg));
				return(fTrue);
				}

		while (*psz != (SZ)NULL)
			{
			SZ  sz = *(psz++);
			INT i  = atoi(sz);

			if (i > 0 && i <= 10 && i != iButtonChecked)
				EnableWindow(GetDlgItem(hdlg, IDC_B0 + i), 0);
			else if (*sz != '\0')
				PreCondition(fFalse, fTrue);
			}

		EvalAssert(FFreeRgsz(rgsz));

        return(fTrue);

	case STF_REINITDIALOG:
		return(fTrue);

//    case STF_DLG_ACTIVATE:
//    case WM_MOUSEACTIVATE:
//        if (FActiveStackTop())
//            break;
//        EvalAssert(FInactivateHelp());
//        SetWindowPos(hdlg, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
//        /* fall through */
//    case STF_UILIB_ACTIVATE:
//        EvalAssert(FActivateStackTop());
//        return(fTrue);
	
    case WM_CLOSE:
        PostMessage(
            hdlg,
            WM_COMMAND,
            MAKELONG(IDC_X, BN_CLICKED),
            0L
            );
        return(fTrue);

    case WM_COMMAND:
		switch (idc = LOWORD(wParam))
			{
		case IDC_B1:
		case IDC_B2:
		case IDC_B3:
		case IDC_B4:
		case IDC_B5:
		case IDC_B6:
		case IDC_B7:
		case IDC_B8:
		case IDC_B9:
		case IDC_B10:
			CheckRadioButton(hdlg, IDC_B1, iButtonMax, (INT)idc);
			if (HIWORD(wParam) != BN_DOUBLECLICKED)
				break;
			wParam = IDC_C;
			/* Fall through */

		case IDCANCEL:
            if (LOWORD(wParam) == IDCANCEL) {

                if (!GetDlgItem(hdlg, IDC_B) || HIWORD(GetKeyState(VK_CONTROL)) || HIWORD(GetKeyState(VK_SHIFT)) || HIWORD(GetKeyState(VK_MENU)))
                {
                    break;
                }
                wParam = IDC_B;

            }
        case IDC_O:
		case IDC_C:
		case IDC_M:
        case IDC_B:
        case IDC_X:
        case IDC_BTN0:
        case IDC_BTN1: case IDC_BTN2: case IDC_BTN3:
        case IDC_BTN4: case IDC_BTN5: case IDC_BTN6:
        case IDC_BTN7: case IDC_BTN8: case IDC_BTN9:

            _itoa((INT)wParam, rgchNum, 10);
			while (!FAddSymbolValueToSymTab("ButtonPressed", rgchNum))
				if (!FHandleOOM(hdlg))
					{
					DestroyWindow(GetParent(hdlg));
					return(fTrue);
					}

			iButtonChecked = 0;
            for (i = 1; i <= 10; i++)
				if (SendDlgItemMessage(hdlg, IDC_B0 + i, BM_GETCHECK, 0, 0L))
					{
					iButtonChecked = i;
					break;
					}

			_itoa((INT)iButtonChecked, rgchNum, 10);
			while (!FAddSymbolValueToSymTab("ButtonChecked", rgchNum))
				if (!FHandleOOM(hdlg))
					{
					DestroyWindow(GetParent(hdlg));
					return(fTrue);
					}

            PostMessage(GetParent(hdlg), (WORD)STF_UI_EVENT, 0, 0L);
			break;
    		}
		break;

	case STF_DESTROY_DLG:
		PostMessage(GetParent(hdlg), (WORD)STF_RADIO_DLG_DESTROYED, 0, 0L);
		DestroyWindow(hdlg);
		return(fTrue);
		}

    return(fFalse);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\resource.c ===
#include "precomp.h"
#pragma hdrstop
/* File: progcm.c */
/**************************************************************************/
/*	Install: Resource stamping
/**************************************************************************/


extern HWND hwndFrame;



#define wExeSignature		0x5A4D
#define lNewExeOffset		0x3CL
#define wNewExeSignature	0x454E
#define lResourceOffset		0x24L

#define FTypeNumeric(wType)	(wType & 0x8000)
#define FNameNumeric(wName) (wName & 0x8000)
#define WTypeActual(wType)  (WORD)(wType & 0x7FFF)
#define WNameActual(wName)  (WORD)(wName & 0x7FFF)

/* ReSource Group */
typedef struct _rsg
	{
	WORD wType;
	WORD crsd;
	LONG lReserved;
	} RSG;

#define cbRsg	(sizeof(RSG))

/* ReSource Descriptor */
typedef struct _rsd
	{
	WORD wOffset;
	WORD wLength;
	WORD wFlags;
	WORD wName;
	LONG lReserved;
	} RSD;

#define cbRsd	(sizeof(RSD))



/*
**	Purpose:
**		Write a string into an EXE resource
**	Arguments:
**		szSection	INF section containing EXE file descriptor
**		szKey		INF key of EXE file descriptor
**		szDst		Directory where the EXE file lives
**		wResType	Resource type
**		wResId		Resource ID
**		szData		String to write into the resource
**		cbData		Number of bytes to write
**	Notes:
**		Only numeric resource types and resource IDs are supported.
**		szData must contain the entire resource data, and must
**			be formatted correctly as a resource, including all tags,
**			byte counts, flags, etc, expected of the resource type.
**			FStampResource knows nothing of individual resource formats.
**		cbData must be less than or equal to the size of the
**			resource in the file.  If it is smaller than the actual
**			resource, the remainder of the resource is left intact.
**	Returns:
**		Returns fTrue if successful, fFalse otherwise.
**
**************************************************************************/
BOOL APIENTRY FStampResource(SZ szSection, SZ szKey, SZ szDst,
        WORD wResType, WORD wResId, SZ szData, CB cbData)
/* REVIEW need fVital? */
{
#if defined(WIN16)
	PSFD   psfd = (PSFD)NULL;
	OER    oer;
	CHP    szExe[cchpFullPathBuf];
	PFH    pfh;
	LONG   lData, lNewHeader;
	WORD   wResShift;
	USHORT date, time;
    GRC    grc;
    INT    Line;

	while ((grc = GrcFillPoerFromSymTab(&oer)) != grcOkay)
		if (EercErrorHandler(hwndFrame, grc, fTrue, 0, 0, 0) != eercRetry)
			return(fFalse);

    if ((Line = FindLineFromInfSectionKey(szSection, szKey)) == -1)
		{
        EvalAssert(EercErrorHandler(hwndFrame, grcINFMissingLine, fTrue, szSection, pLocalInfPermInfo()->szName,
				0) == eercAbort);
		return(fFalse);
		}

    while ((grc = GrcGetSectionFileLine(&psfd, &oer)) != grcOkay) {
        SZ szParam1 = NULL, szParam2 = NULL;
        switch ( grc ) {
        case grcINFBadFDLine:
            szParam1 = pLocalInfPermInfo()->szName;
            szParam2 = szSection;
            break;
        default:
            break;
        }

        if (EercErrorHandler(hwndFrame, grc, fTrue, szParam1, szParam2, 0) != eercRetry) {
			return(fFalse);
        }

    }

	Assert(psfd != NULL);

    if (!FBuildFullDstPath(szExe, szDst, psfd, fFalse))
		{
		EvalAssert(FFreePsfd(psfd));
		EvalAssert(EercErrorHandler(hwndFrame, grcInvalidPathErr, fTrue,
				szDst, psfd->szFile, 0) == eercAbort);
		return(fFalse);
		}

	EvalAssert(FFreePsfd(psfd));

	while ((pfh = PfhOpenFile(szExe, ofmReadWrite)) == (PFH)NULL)
		if (EercErrorHandler(hwndFrame, grcOpenFileErr, fTrue, szExe, 0, 0)
				!= eercRetry)
			return(fFalse);

	while (_dos_getftime(pfh->iDosfh, &date, &time))
		if (EercErrorHandler(hwndFrame, grcReadFileErr, fTrue, szExe, 0, 0)
				!= eercRetry)
			goto LCloseExit;

	while (CbReadFile(pfh, (PB)&lData, 2) != 2)
		if (EercErrorHandler(hwndFrame, grcReadFileErr, fTrue, szExe, 0, 0)
				!= eercRetry)
			goto LCloseExit;

	if (LOWORD(lData) != 0x5A4D)		//'MZ'
		goto LBadExe;
	if (LfaSeekFile(pfh, 0x3CL, sfmSet) == lfaSeekError)
		goto LBadExe;
	if (CbReadFile(pfh, (PB)&lNewHeader, 4) != 4)
		goto LBadExe;
	if (LfaSeekFile(pfh, lNewHeader, sfmSet) == lfaSeekError)
		goto LBadExe;
	if (CbReadFile(pfh, (PB)&lData, 2) != 2)
		goto LBadExe;
	if (LOWORD(lData) != 0x454E)		//'NE'
		goto LBadExe;
	if (LfaSeekFile(pfh, lNewHeader + 0x24, sfmSet) == lfaSeekError)
		goto LBadExe;
	if (CbReadFile(pfh, (PB)&lData, 2) != 2)
		goto LBadExe;
	if (LfaSeekFile(pfh, lNewHeader + LOWORD(lData), sfmSet) == lfaSeekError)
		goto LBadExe;
	if (CbReadFile(pfh, (PB)&wResShift, 2) != 2)
		goto LBadExe;

	for (;;)
		{
		RSG rsg;

		if (CbReadFile(pfh, (PB)&rsg, cbRsg) != cbRsg)
			goto LBadExe;
		if (rsg.wType == 0)
			goto LMissingResource;

		while (rsg.crsd)
			{
			RSD rsd;

			if (CbReadFile(pfh, (PB)&rsd, cbRsd) != cbRsd)
				goto LBadExe;
			if (FTypeNumeric(rsg.wType) &&
                    WTypeActual(rsg.wType) == wResType &&
					FNameNumeric(rsd.wName) &&
					WNameActual(rsd.wName) == wResId)
				{
				LONG lOffset = ((LONG)rsd.wOffset) << wResShift;
				LONG lLength = ((LONG)rsd.wLength) << wResShift;

				if (LfaSeekFile(pfh, lOffset, sfmSet) == lfaSeekError)
					goto LMissingResource;
				if ((LONG)cbData > lLength)
					{
					EvalAssert(EercErrorHandler(hwndFrame,
							grcResourceTooLongErr, fTrue, 0, 0,0) == eercAbort);
					goto LCloseExit;
					}
				if (CbWriteFile(pfh, szData, cbData) != cbData)
					{
                    EvalAssert(EercErrorHandler(hwndFrame, grcWriteFileErr,
							fTrue, szExe, 0,0) == eercAbort);
					goto LCloseExit;
					}

				while (_dos_setftime(pfh->iDosfh, date, time))
					if (EercErrorHandler(hwndFrame, grcWriteFileErr, fTrue,
							szExe, 0, 0) != eercRetry)
						goto LCloseExit;

				EvalAssert(FCloseFile(pfh));
				return(fTrue);
				}
			rsg.crsd--;
			}
		}

LMissingResource:
	EvalAssert(EercErrorHandler(hwndFrame, grcMissingResourceErr, fTrue, szExe,
			0, 0) == eercAbort);
	goto LCloseExit;

LBadExe:
	EvalAssert(EercErrorHandler(hwndFrame, grcBadWinExeFileFormatErr, fTrue,
			szExe, 0, 0) == eercAbort);

LCloseExit:
	EvalAssert(FCloseFile(pfh));
    return(fFalse);

#else           // 1632BUG -- eliminate this func altogether?

    Unused(szSection);
    Unused(szKey);
    Unused(szDst);
    Unused(wResType);
    Unused(wResId);
    Unused(szData);
    Unused(cbData);

    MessBoxSzSz("FStampResource","IGNORED (Unsupported in 32-bit version)");

    return(fTrue);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\restore.c ===
#include "precomp.h"
#pragma hdrstop
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    restore.c

Abstract:

    Routines related to generating the restore diskette(s), and for
    logging files to be deleted at next boot.

Author:

    Ted Miller (tedm) 6-April-1992

Revision History:

--*/



//
// Defining this symbol causes us to not treat files in the config
// directory specially when it comes to logging files that are copied by
// GUI Setup.  We don't do anything special for them because text setup
// copies the registry hives that are relevent for the repair process.
//
#define LOG_CONFIG_DIR_FILES

extern HWND hwndFrame;
extern PSTR LOCAL_SOURCE_DIRECTORY;

PSTR SETUP_LOG_FILE = "\\setup.log";
PSTR SETUP_REPAIR_DIRECTORY = "\\repair";
CHAR _LogFileName[MAX_PATH + 1];
BOOLEAN _LogFileNameInitialized = FALSE;
BOOL    _LogStartedByCommand;

BOOL
InsertSpecialBootCode(
    IN TCHAR Drive
    );

VOID
ValidateAndChecksumFile(
    IN  PSTR     Filename,
    OUT PBOOLEAN IsNtImage,
    OUT PULONG   Checksum,
    OUT PBOOLEAN Valid
    );

VOID
InitRestoreDiskLogging(
    IN BOOL StartedByCommand
    )

/*++

Routine Description:

    Initialize the restore-diskette generation and file copy logging
    module.

Arguments:

    StartedByCommand - specifies whether this command was invoked explicitly
                       from the INF file via an InitRestoreDiskLog command.

Return Value:

    None.

--*/

{
    //
    // We need to know whether the INF file explicitly invoked this command,
    // because if it didn't, we'll need to set the S-H-R attributes on setup.log
    // ourselves.
    //
    _LogStartedByCommand = StartedByCommand;

    GetWindowsDirectory( _LogFileName, sizeof(_LogFileName) );
    strcat( _LogFileName, SETUP_REPAIR_DIRECTORY );
    strcat( _LogFileName, SETUP_LOG_FILE );
    _LogFileNameInitialized = TRUE;
}



VOID
RestoreDiskLoggingDone(
    VOID
    )
/*++

Routine Description:

    Checks to see if logging was initiated explicitly from the INF file.  If it wasn't,
    then the S-H-R attributes of the log file (setup.log) are set.  Otherwise, we leave
    the file alone (we expect the INF file to make a subsequent call to TermRestoreDiskLogging).

Arguments:

    None.

Return Value:

    None.

--*/
{
    if(_LogFileNameInitialized && !_LogStartedByCommand) {

        SetFileAttributes(_LogFileName,
                          FILE_ATTRIBUTE_HIDDEN   |
                          FILE_ATTRIBUTE_READONLY |
                          FILE_ATTRIBUTE_SYSTEM   |
                          FILE_ATTRIBUTE_ARCHIVE
                          );
    }
}


VOID
TermRestoreDiskLogging(
    VOID
    )

/*++

Routine Description:

    Terminate the log process, by logging in setup.log the following files:
    autoexec.nt and config.nt.
    Also change attributes of setup.log in the repair directory.

Arguments:

    None.

Return Value:

    None.

--*/

{
    HANDLE              Handle;
    WIN32_FIND_DATA     FindData;
    CHAR                SystemDirectory[MAX_PATH];
    CHAR                SourceFileName[MAX_PATH];
    CHAR                Buffer[ MAX_PATH ];
    BOOLEAN             IsValid;
    BOOLEAN             IsNtImage;
    ULONG               Checksum;
    ULONG               i;

    PSTR FileList[] = { "autoexec.nt",
                        "config.nt"
                      };

    Handle = FindFirstFile( _LogFileName,
                            &FindData );

    if( Handle != INVALID_HANDLE_VALUE ) {
        FindClose( Handle );

        if( !GetSystemDirectory( SystemDirectory, sizeof(SystemDirectory) )) {
            return;
        }

        for(i=0; i < sizeof(FileList)/sizeof(PSTR); i++) {
            strcpy( SourceFileName, SystemDirectory );
            strcat( SourceFileName, "\\" );
            strcat( SourceFileName, FileList[i] );

            //
            //  Log the file in a special section of setup.log
            //
            ValidateAndChecksumFile( SourceFileName,
                                     &IsNtImage,
                                     &Checksum,
                                     &IsValid );

            sprintf( Buffer,
                     "\"%s\",\"%lx\"",
                     FileList[i],
                     Checksum
                   );

            WritePrivateProfileString( "Files.InRepairDirectory",
                                       SourceFileName + 2,
                                       Buffer,
                                       _LogFileName );

        }
        SetFileAttributes(_LogFileName,
                           FILE_ATTRIBUTE_HIDDEN   |
                           FILE_ATTRIBUTE_READONLY |
                           FILE_ATTRIBUTE_SYSTEM   |
                           FILE_ATTRIBUTE_ARCHIVE
                           );

    }
}



VOID
LogOneFile(
    IN PCHAR SrcFullname,
    IN PCHAR DstFullname,
    IN PCHAR DiskDescription,
    IN ULONG Checksum,
    IN PCHAR DiskTag,
    IN BOOL  ThirdPartyFile
    )

/*++

Routine Description:

    Log a file that was just copied.  If the general copy source is a
    CD-ROM and the file is from a: or b:, it is marked 'floppy' in the
    log.  If the file is coming from the network, it is not logged.
    If the file is being copied to the boot volume and the boot volume is
    different than the NT volume, the file is not logged.

Arguments:

    SrcFullname - fully qualified name of the source file.

    DstFullname - fully qulaified name of the file as it is called on
        the target volume.

    DiskDescription - text description of the source diskette/CD containing
        the file.

    Checksum - checksum of the target file.

Return Value:

    None.

--*/

{
    static BOOL FoundSymbols = FALSE;
    static UINT GeneralSourceDriveType;
    static PCHAR GeneralSource;
    static CHAR GeneralTarget[MAX_PATH + 3];
#ifndef LOG_CONFIG_DIR_FILES
    static ConfigDir;
    static ULONG ConfigDirLen;
#endif

#if 0
    UINT ThisFileSourceDriveType;
#endif
    CHAR temp[4];
    CHAR Buffer[256];
    ULONG RetryCount;
    BOOL  Success;

    //
    // If we haven't already, locate static info, like the general source
    // and target directories, etc.
    //

    if(!FoundSymbols) {
        GeneralSource = SzFindSymbolValueInSymTab("!STF_SRCDIR");
        GetWindowsDirectory( GeneralTarget, sizeof( GeneralTarget ) / sizeof( CHAR ));
#ifndef LOG_CONFIG_DIR_FILES
        ConfigDir     = SzFindSymbolValueInSymTab("!STF_CONFIGPATH");
        ConfigDirLen = lstrlen(ConfigDir);
#endif

        strncpy(temp,GeneralSource,3);
        temp[3] = 0;
        GeneralSourceDriveType = GetDriveType(temp);

        FoundSymbols = TRUE;
    }

    //
    // Determine the full path of the setup log file, if not yet done
    //
    if( !_LogFileNameInitialized ) {
        InitRestoreDiskLogging(FALSE);
    }
    //
    // If the file is being copied from a UNC path, don't log it.
    //

    if(!strncmp(SrcFullname,"\\\\",2) ||
       (GeneralSourceDriveType == DRIVE_REMOTE) ) {
        return;
    }

    //
    // If the file is not being copied to the NT volume, don't log it.
    //

    if(toupper(*DstFullname) != toupper(GeneralTarget[0])) {
        return;
    }

#ifndef LOG_CONFIG_DIR_FILES
    //
    // If the file is being copied to the config directory, don't log it.
    //

    if(!_strnicmp(ConfigDir,DstFullname,ConfigDirLen)) {
        return;
    }
#endif

    //
    // Make sure the left hand side of the equals has quotes around it if
    // there are spaces in the filename.
    //
    if(strchr(DstFullname+2,' ')) {
        GeneralTarget[0] = '\"';
        lstrcpyn(&GeneralTarget[1],DstFullname+2,MAX_PATH);
        lstrcat(GeneralTarget,"\"");
    } else {
        lstrcpyn(GeneralTarget,DstFullname+2,MAX_PATH);
    }

    //
    // Write a line into the log file.
    //

    if( ThirdPartyFile ) {
        CHAR   FullSrcName[260];
        PCHAR  FileName;
        PCHAR  DirectoryName;
        PCHAR  p;

        //
        // This is a third party file
        //
        sprintf( FullSrcName, "%s", SrcFullname );
        CharLowerBuff( FullSrcName, lstrlen( FullSrcName ) );
        if( ( FileName = strrchr( FullSrcName, (int)'\\' ) ) == FullSrcName + 2 ) {
            DirectoryName = "\\";
        } else {
            if( FileName ) {
                *FileName = '\0';
            }
            DirectoryName = FullSrcName + 2;
            if( (p = strstr( DirectoryName, "drvlib.nic" )) != NULL ) {
                //
                //  We want to convert \...\drvlib.nic\Directory\Subdir
                //  into \Subdir
                //
                p += strlen( "drvlib.nic" ) + 1;
                p = strchr( p, '\\' );
                if( p != NULL ) {
                    DirectoryName = p;
                } else {
                    DirectoryName = "\\";
                }
            }
        }


        sprintf( Buffer,
                 "\"%s\",\"%lx\",\"%s\",\"%s\",\"%s\"",
                 FileName + 1,
                 Checksum,
                 DirectoryName,
                 DiskDescription,
                 (DiskTag)? DiskTag : ""
               );
    } else {
        sprintf( Buffer,
                 "\"%s\",\"%lx\"",
                 strrchr( SrcFullname + 2, (int)'\\' ) + 1,
                 Checksum
               );
    }

    for(RetryCount = 0, Success = FALSE;
        !Success && (RetryCount < 2);
        RetryCount++)
    {
        Success = WritePrivateProfileString("Files.WinNt",
                                            GeneralTarget,
                                            Buffer,
                                            _LogFileName
                                            );

        if(!(Success || RetryCount)) {
            //
            // The file is probably has S-H-R attributes, so we'll reset
            // these and try again
            //
            SetFileAttributes(_LogFileName, FILE_ATTRIBUTE_NORMAL);
        }
    }

}

BOOL
NotifyCB(
    IN PCHAR src,
    IN PCHAR dst,
    IN WORD code
    )
{
    UNREFERENCED_PARAMETER(src);
    UNREFERENCED_PARAMETER(dst);
    UNREFERENCED_PARAMETER(code);
    return(TRUE);
}


BOOL
AddFileToDeleteList(
    IN PCHAR Filename
    )

/*++

Routine Description:

    Add a file to the list of files to be deleted at next boot.
    This involves writing a line to the opened delete log file.

Arguments:

    Filename - full pathname of file to delete.

Return Value:

    Always true.

--*/

{
    return(MoveFileEx(Filename,NULL,MOVEFILE_REPLACE_EXISTING|MOVEFILE_DELAY_UNTIL_REBOOT));
}


//
// Bootcode to be inserted, placed into a C array.  See i386\readme.
//
#include "rdskboot.c"
#define DRIVENAME_PREFIX    "\\\\.\\"

BOOL
InsertSpecialBootCode(
    IN TCHAR Drive
    )
{
    UCHAR UBuffer[1024];
    PUCHAR Buffer = (PUCHAR)(((DWORD_PTR)UBuffer+512) & ~((INT_PTR)511));
    HANDLE Handle;
    TCHAR DriveName[(sizeof(DRIVENAME_PREFIX)/sizeof(TCHAR)) + 2];
    BOOL b;
    DWORD BytesXferred;
    DWORD Offset;
    PUCHAR MsgAddr;

    wsprintf(DriveName,"%s%c:",TEXT(DRIVENAME_PREFIX),Drive);

    //
    // Open the drive DASD
    //
    Handle = CreateFile(
                DriveName,
                FILE_READ_DATA | FILE_WRITE_DATA,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if(Handle == INVALID_HANDLE_VALUE) {
        return(FALSE);
    }

    //
    // Read and validate the first 512 bytes from the drive.
    //
    b = ReadFile(Handle,Buffer,512,&BytesXferred,NULL);
    if((b == FALSE)
    || (BytesXferred != 512)
    || (Buffer[0] != 0xeb)
    || (Buffer[2] != 0x90)
    || (Buffer[510] != 0x55)
    || (Buffer[511] != 0xaa))
    {
        CloseHandle(Handle);
        return(FALSE);
    }

    //
    // Determine the offset of the bootcode.
    //
    Offset = Buffer[1] + 2;
    if(Offset + REPAIR_DISK_BOOTSECTOR_SIZE > 510) {
        CloseHandle(Handle);
        return(FALSE);
    }

    //
    // Wipe the boot code clean and reset the signature.
    //
    ZeroMemory(Buffer+Offset,510-Offset);

    //
    // Copy the new bootcode into the sector.
    //
    CopyMemory(
        Buffer+Offset,
        REPAIR_DISK_BOOTSECTOR,
        REPAIR_DISK_BOOTSECTOR_SIZE
        );

    //
    // Calculate the offset of the message within the boot sector.
    //
    MsgAddr = Buffer+Offset+REPAIR_DISK_BOOTSECTOR_SIZE;

    //
    // Fetch the boot sector's message from our resources and
    // place it into the boot sector.
    //
    LoadStringA(
        MyDllModuleHandle,              // was GetModuleHandle(NULL),
        IDS_REPAIR_BOOTCODE_MSG,
        MsgAddr,
        510-Offset-REPAIR_DISK_BOOTSECTOR_SIZE
        );

    Buffer[509] = 0;    // just in case.

    //
    // The string in the resources will be ANSI text; we want OEM text
    // in the boot sector on the floppy.
    //
    CharToOemA(MsgAddr,MsgAddr);

    //
    // Seek back to the beginning of the disk and
    // write the bootsector back out to disk.
    //
    if(SetFilePointer(Handle,0,NULL,FILE_BEGIN)) {
        CloseHandle(Handle);
        return(FALSE);
    }

    b = WriteFile(Handle,Buffer,512,&BytesXferred,NULL);

    CloseHandle(Handle);

    return((b == TRUE) && (BytesXferred == 512));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\registr2.c ===
#include "precomp.h"
#pragma hdrstop

//
//  Uncomment the next #define line to get debug trace info about
//  Registry keys opened, created or closed.
//
//  #define DBG_REG_HANDLES
//


extern  HWND    hwndFrame;

//
//   Updated by DavidHov on 6/1/92:
//
//                Centralized error handling;
//                Eliminated "title" parameter from APIs; it's
//                   reserved now, so using it gives "invalid parameter"
//
//
//   Updated by DavidHov on 1/6/93
//
//                Chnaged FCreateRegKey and FOpenRegKey to always update
//                the desired value; a null (empty) string is used if the
//                operation has failed.
//

//
//  Local Prototypes
//

BOOL FDeleteTree( HKEY KeyHandle );
BOOL FSetRegValueSz( HKEY hKey, SZ szValueName, UINT TitleIndex,  SZ szValueData );
BOOL FSetRegValueExpandSz( HKEY hKey, SZ szValueName, UINT TitleIndex,  SZ szValueData );
BOOL FSetRegValueMultiSz( HKEY hKey, SZ szValueName, UINT TitleIndex, UINT ValueType, SZ szValueData );
BOOL FSetRegValueDword( HKEY hKey, SZ szValueName, UINT TitleIndex, SZ szValueData );
BOOL FSetRegValueBin( HKEY hKey, SZ szValueName, UINT TitleIndex, UINT ValueType, SZ szValueData );

PVOID SzToMultiSz( SZ sz, PDWORD cbData );
SZ    MultiSzToSz( PVOID Data, DWORD cbData );
PVOID SzToBin( SZ sz, PDWORD cbData );
SZ    BinToSz( PVOID Data, DWORD cbData );
SZ    ValueDataToSz( DWORD ValueType, PVOID ValueData, DWORD cbData );


  //
  //    Central error handling for all Registry processing errors.
  //
void FUpdateRegLastError ( LONG Status, SZ szOp, SZ szName )
{
    char                    RegLastError[25];

    _ltoa( Status, RegLastError, 10 );

    FAddSymbolValueToSymTab( REGLASTERROR, RegLastError );

  /*  Uncomment to display all registry errors and their origin  */

#if defined(DBG_REG_HANDLES)

    OutputDebugString( "SETUP: Reg Error in " );
    OutputDebugString( szOp );
    OutputDebugString( " = " );
    OutputDebugString( RegLastError ) ;
    if ( szName )
    {
        OutputDebugString( "; " );
        OutputDebugString( szName ) ;
    }
    OutputDebugString( "\n" );

#endif
}

  //  Debugging helper routing for finding lost Registry handles.

void FDebugRegKey ( SZ szHandle, SZ szAction, SZ szName )
{

    OutputDebugString( "SETUP: REGKEYTRACE: " );
    OutputDebugString( szHandle );
    OutputDebugString( " : " );
    OutputDebugString( szAction );
    OutputDebugString( " : " );
    if ( szName )
    {
        OutputDebugString( szName ) ;
    }
    OutputDebugString( "\n" );
}

#if defined(DBG_REG_HANDLES)
  #define DEBUGREGKEY(a,b,c) FDebugRegKey(a,b,c)
#else
  #define DEBUGREGKEY(a,b,c)
#endif

/*
 *  FCreateRegKey
 *
 *  Crates a key in the registry
 *
 *  Arguments:
 *
 */
BOOL FCreateRegKey( SZ szHandle, SZ szKeyName, UINT TitleIndex, SZ szClass,
                    SZ Security, UINT Access, UINT Options, SZ szNewHandle,
                    CMO cmo )

{
    BOOL                    fOkay;
    HKEY                    hKey;
    HKEY                    hSubKey;
    DWORD                   Disposition;
    LONG                    Status;
    char                    LibraryHandleSTR[25];
    LPSECURITY_ATTRIBUTES   SecurityAttributes;


    hKey = (HKEY)LongToHandle(atol( szHandle + 1 ));

    //
    //  If the Security parameter is specified, it must contain the
    //  string "&<Address>" where <Address> is the decimal numeric
    //  representation of the memory address of a SECURITY_ATTRIBUTES
    //  structure.
    //
    if ( !Security || Security[0] != '\0' ) {

        if ( Security[0] != '&' ) {
            return fFalse;
        }

        SecurityAttributes = (LPSECURITY_ATTRIBUTES)LongToHandle(atol( Security + 1 ));

        if ( !SecurityAttributes ||
             !IsValidSecurityDescriptor( SecurityAttributes->lpSecurityDescriptor )
           ) {
            return fFalse;
        }

    } else {

        SecurityAttributes = NULL;
    }

    //
    //  Create the key
    //
    fOkay = !( Status = RegCreateKeyEx( hKey,
                                        szKeyName,
					0,
                                        szClass,
                                        Options,
                                        Access,
                                        SecurityAttributes,
                                        &hSubKey,
                                        &Disposition ));

    //  Prepare an initial null result
    LibraryHandleSTR[0] = '\0' ;

    if ( !fOkay ) {

        FUpdateRegLastError( Status, "CreateRegKey", szKeyName );

    } else {

        //
        //  If the key already existed, we error out.
        //
        if ( Disposition == REG_OPENED_EXISTING_KEY  ) {

            RegCloseKey( hSubKey );
            FUpdateRegLastError( ERROR_CANTOPEN, "CreateRegKey", szKeyName );
            fOkay = fFalse;

        } else {

            //
            //  Put the handle in the specified variable
            //
            LibraryHandleSTR[0] = '|';

#if defined(_WIN64)
            _ui64toa( (DWORD_PTR)hSubKey, LibraryHandleSTR+1, 20 );
#else
            _ultoa( (DWORD)hSubKey, LibraryHandleSTR+1, 10 );
#endif

            DEBUGREGKEY( LibraryHandleSTR+1, "created", szKeyName ) ;
        }
    }

    //  Always add the value to the symbol table, even if null (empty).

    while ( !FAddSymbolValueToSymTab( szNewHandle, LibraryHandleSTR ) )
    {
         if ( !FHandleOOM( hwndFrame ) )
         {
              if ( fOkay )
              {
                  RegCloseKey( hSubKey );
                  RegDeleteKey( hKey, szKeyName );
                  fOkay = fFalse;
              }
              break;
         }
    }

    return (cmo & cmoVital) ? fOkay : fTrue;
}




/*
 *  FOpenRegKey
 *
 *  Opens a key in the registry
 *
 *  Arguments:
 *
 */
BOOL FOpenRegKey( SZ szHandle, SZ szMachineName, SZ szKeyName, UINT Access, SZ szNewHandle, CMO cmo )
{
    BOOL    fOkay = fTrue;
    HKEY    hKey;
    HKEY    hSubKey;
    LONG    Status;
    char    LibraryHandleSTR[25];

    hKey = (HKEY)LongToHandle(atol( szHandle + 1 ));

    //
    //  If a remote machine is specified, we connect to the remote
    //  machine and use the new handle.
    //
    if ( szMachineName[0] != '\0' ) {

        //  BUGBUG ramonsa - Until RegConnectRegistry is operational
        //
        Status = ERROR_INVALID_PARAMETER;
        fOkay  = fFalse;

        //
        //fOkay = !(Status = RegConnectRegistry( szMachineName,
        //                                       hKey,
        //                                       &hKey
        //                                       );

    } else if ( szKeyName[0] == '\0' ) {

        //
        //  If no machine name was given then a subkey name must
        //  be given!
        //
        Status  = ERROR_INVALID_PARAMETER;
        fOkay   = fFalse;
    }

    //  Prepare an initial null result
    LibraryHandleSTR[0] = '\0' ;

    if ( fOkay ) {

        //
        //  If no subkey is given, we just want a root handle of the
        //  remote machine. Otherwise we must open the subkey (and
        //  close the handle if remote).
        //
        if ( szKeyName[0] == '\0' ) {

            //
            //  The remote handle is what we want.
            //
            hSubKey = hKey;

        } else {

            //
            //  We want a subkey.
            //
            fOkay = !( Status = RegOpenKeyEx( hKey,
                                              szKeyName,
                                              0,
                                              Access,
                                              &hSubKey ));

            //
            //  If a remote machine is specified, then hkey has
            //  a remote handle and we must close it.
            //
            if ( szMachineName[0] != '\0' ) {
                RegCloseKey( hKey );
            }
        }

        if ( fOkay ) {

            //
            //  Put the handle in the specified variable
            //
            LibraryHandleSTR[0] = '|';

#if defined(_WIN64)
            _ui64toa( (DWORD_PTR)hSubKey, LibraryHandleSTR+1, 20 );
#else
            _ultoa( (DWORD)hSubKey, LibraryHandleSTR+1, 10 );
#endif

            DEBUGREGKEY( LibraryHandleSTR+1, "opened ", szKeyName ) ;
        }
    }

    if ( !fOkay ) {
        FUpdateRegLastError( Status, "OpenRegKey", szKeyName );
    }

    while ( !FAddSymbolValueToSymTab( szNewHandle, LibraryHandleSTR ) )
    {
        if ( !FHandleOOM( hwndFrame ) )
        {
            if ( fOkay )
            {
                RegCloseKey( hSubKey );
                Status  = 0;
                fOkay   = fFalse;
            }
            break ;
        }
    }

    return (cmo & cmoVital) ? fOkay : fTrue;
}





/*
 *  FFlushRegKey
 *
 *  Flushes a key in the registry
 *
 *  Arguments:
 *
 */
BOOL FFlushRegKey( SZ szHandle, CMO cmo )
{
    BOOL    fOkay;
    HKEY    hKey;

    hKey = (HKEY)LongToHandle(atol( szHandle + 1 ));

    fOkay =  !RegFlushKey( hKey );

    return (cmo & cmoVital) ? fOkay : fTrue;
}






/*
 *  FCloseRegKey
 *
 *  Close a key in the registry
 *
 *  Arguments:
 *
 */
BOOL FCloseRegKey( SZ szHandle, CMO cmo )
{
    BOOL    fOkay;
    HKEY    hKey;
    LONG    Status;

    if ( szHandle[0] != '|' )
        return fTrue;

    hKey = (HKEY)LongToHandle(atol( szHandle + 1 ));

    if ( hKey == NULL )
        return fTrue ;

    DEBUGREGKEY( szHandle+1, "closed ", NULL ) ;

    fOkay =  !( Status = RegCloseKey( hKey ) );

    if ( !fOkay ) {
        FUpdateRegLastError( Status, "CloseRegKey", NULL );
    }

    return (cmo & cmoVital) ? fOkay : fTrue;
}





/*
 *  FDeleteRegKey
 *
 *  Deletes a key from the registry
 *
 *  Arguments:
 *
 */
BOOL FDeleteRegKey( SZ szHandle, SZ szKeyName, CMO cmo )
{
    BOOL    fOkay;
    HKEY    hKey;
    LONG    Status;

    hKey = (HKEY)LongToHandle(atol( szHandle + 1 ));

    fOkay =  !( Status = RegDeleteKey( hKey, szKeyName ) );

    if ( !fOkay ) {

        FUpdateRegLastError( Status, "DeleteRegKey", NULL );
    }

    return (cmo & cmoVital) ? fOkay : fTrue;
}



/*
 *  FDeleteRegTree
 *
 *  Deletes a key and all its descentants from the registry
 *
 *  Arguments:
 *
 */
BOOL FDeleteRegTree( SZ szHandle, SZ szKeyName, CMO cmo )
{
    BOOL    fOkay;
    HKEY    hKey;
    HKEY    hSubKey;
    LONG    Status;

    hKey = (HKEY)LongToHandle(atol( szHandle + 1 ));

    //
    //  Open the key
    //
    fOkay = !( Status = RegOpenKeyEx( hKey,
                                      szKeyName,
                                      0,
                                      KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                                      &hSubKey ) );
    if ( !fOkay ) {

        FUpdateRegLastError( Status, "DeleteRegTree", szKeyName );

    } else {

        fOkay = FDeleteTree( hSubKey );
    }


    //
    //  Now delete the key
    //
    if ( fOkay ) {

        fOkay = !( Status = RegCloseKey( hSubKey ) );

        if ( !fOkay ) {

            FUpdateRegLastError( Status, "DeleteRegTree", szKeyName );

        } else {

            fOkay =  !RegDeleteKey( hKey, szKeyName );
        }
    }

    return (cmo & cmoVital) ? fOkay : fTrue;
}


/*
 *  FDeleteTree
 *
 *  Recursively deletes all the descendants of a key
 *
 *  Arguments:
 *
 */
BOOL FDeleteTree( HKEY KeyHandle )
{
    BOOL        fOkay;
    DWORD       Index;
    HKEY        ChildHandle;
    CHAR        KeyName[ cchlFullPathMax ];
    DWORD       KeyNameLength;
    CHAR        ClassName[ cchlFullPathMax ];
    DWORD       ClassNameLength;
    DWORD       TitleIndex = 0 ;
    DWORD       NumberOfSubKeys;
    DWORD       MaxSubKeyLength;
    DWORD       MaxClassLength;
    DWORD       NumberOfValues;
    DWORD       MaxValueNameLength;
    DWORD       MaxValueDataLength;
    DWORD       SizeSecurityDescriptor;
    FILETIME    LastWriteTime;
    LONG        Status;

    ClassNameLength = cchlFullPathMax;

    if ( Status = RegQueryInfoKey( KeyHandle,
                                   ClassName,
                                   &ClassNameLength,
                                   NULL,
                                   &NumberOfSubKeys,
                                   &MaxSubKeyLength,
                                   &MaxClassLength,
                                   &NumberOfValues,
                                   &MaxValueNameLength,
                                   &MaxValueDataLength,
                                   &SizeSecurityDescriptor,
                                   &LastWriteTime
                                   ) ) {

        FUpdateRegLastError( Status, "DeleteTree", NULL );
        return fFalse;
    }


    for ( Index = 0; Index < NumberOfSubKeys; Index++ ) {

        KeyNameLength = cchlFullPathMax;

        if ( Status = RegEnumKey( KeyHandle,
                                  0,
                                  KeyName,
                                  KeyNameLength
                                  ) ) {

            FUpdateRegLastError( Status, "DeleteTree", NULL );
            return fFalse;
        }


#ifdef BUGBUG

        // BUGBUG This should work when MAXIMUM_ALLOWED access works.

        if ( Status = RegOpenKey( KeyHandle,
                                  KeyName,
                                  &ChildHandle
                                  ) ) {

            FUpdateRegLastError( Status, "DeleteTree", NULL );
            return fFalse;
        }
#else

        if ( Status = RegOpenKeyEx( KeyHandle,
                                    KeyName,
                                    0,
                                    KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                                    &ChildHandle
                                    ) ) {

            FUpdateRegLastError( Status, "DeleteTree", NULL );
            return fFalse;
        }

#endif // ROBERTRE

        fOkay = FDeleteTree( ChildHandle );

        //
        //  Whether DeleteTree of the ChildHandle succeeded or not, we'll
        //  try to close it.
        //
        RegCloseKey( ChildHandle );

        if ( fOkay ) {
            if ( fOkay = !(Status = RegDeleteKey( KeyHandle, KeyName ) )) {
                FUpdateRegLastError( Status, "DeleteTree", NULL );
            }
        }

        if ( !fOkay ) {
            return fFalse;
        }
    }

    return fTrue;
}




/*
 *  FEnumRegKey
 *
 *  Obtains subkey enumeration
 *
 *  Arguments:
 *
 */
BOOL FEnumRegKey( SZ szHandle, SZ szInfVar, CMO cmo )
{
    BOOL        fOkay = fTrue;
    HKEY        hKey;
    CHAR        KeyName[ cbFullPathMax ];
    CHAR        Class[ cbFullPathMax ];
    DWORD       cbKeyName;
    DWORD       cbClass;
    DWORD       TitleIndex = 0 ;
    FILETIME    FileTime;
    RGSZ        rgszEnum;
    UINT        EnumSize;
    RGSZ        rgszKey;
    SZ          szInfo;
    char        szTitle[25];
    UINT        Index;
    LONG        Status;
    DWORD       NumberOfSubKeys;
    DWORD       MaxSubKeyLength;
    DWORD       MaxClassLength;
    DWORD       NumberOfValues;
    DWORD       MaxValueNameLength;
    DWORD       MaxValueDataLength;
    DWORD       SizeSecurityDescriptor;
    FILETIME    LastWriteTime;



    hKey = (HKEY)LongToHandle(atol( szHandle + 1 ));

    while ( (rgszEnum = (RGSZ)SAlloc( (CB)( 1 * sizeof(SZ)))) == NULL ) {
        if ( !FHandleOOM( hwndFrame ) ) {
            fOkay = fFalse;
            break;
        }
    }

    if ( fOkay ) {

        rgszEnum[0] = NULL;
        EnumSize    = 0;
        cbClass	    = cbFullPathMax;

        if ( Status = RegQueryInfoKey( hKey,
                                       Class,
                                       &cbClass,
                                       NULL,
                                       &NumberOfSubKeys,
                                       &MaxSubKeyLength,
                                       &MaxClassLength,
                                       &NumberOfValues,
                                       &MaxValueNameLength,
                                       &MaxValueDataLength,
                                       &SizeSecurityDescriptor,
                                       &LastWriteTime
                                       ) ) {

            FUpdateRegLastError( Status, "EnumRegKey", NULL );
            return fFalse;
        }

        for ( Index = 0 ; Index < NumberOfSubKeys; Index++ ) {

            cbKeyName = cbFullPathMax;
            cbClass   = cbFullPathMax;

            if ( Status = RegEnumKeyEx( hKey,
                                        Index,
                                        KeyName,
                                        &cbKeyName,
                                        NULL,
                                        (LPSTR)&Class,
                                        &cbClass,
                                        &FileTime ) ) {

                FUpdateRegLastError( Status, "EnumRegKey", NULL );
                break;
            }


            //
            //  Get a list in which to put the key information.
            //
            while ( (rgszKey = (RGSZ)SAlloc( (CB)( 4 * sizeof(SZ)))) == NULL ) {
                if ( !FHandleOOM( hwndFrame ) ) {
                    fOkay = fFalse;
                    break;
                }
            }

            if ( fOkay ) {

                //
                //  Put the information in the list
                //
                _ultoa( TitleIndex, szTitle, 10 );

                rgszKey[0] = KeyName;
                rgszKey[1] = szTitle;
                rgszKey[2] = Class;
                rgszKey[3] = NULL;

                //
                //  Transform the list into a string so that it can be added to the
                //  symbol table.
                //
                while ( (szInfo = SzListValueFromRgsz( rgszKey )) == (SZ)NULL ) {
                    if ( !FHandleOOM( hwndFrame ) ) {
                        fOkay = fFalse;
                        break;
                    }
                }

                if ( fOkay ) {

                    while ( (rgszEnum = (RGSZ)SRealloc( rgszEnum,
                                                         (CB)( (EnumSize+2) * sizeof(SZ)))
                            ) == NULL ) {

                        if ( !FHandleOOM( hwndFrame ) ) {
                            fOkay = fFalse;
                            break;
                        }
                    }

                    if ( fOkay ) {
                        rgszEnum[EnumSize] = szInfo;
                        EnumSize++;
                        rgszEnum[EnumSize] = NULL;
                    }
                }

                SFree(rgszKey);
            }
        }

        //
        //  Convert to SZ
        //
        while ( (szInfo = SzListValueFromRgsz( rgszEnum )) == (SZ)NULL ) {
            if ( !FHandleOOM( hwndFrame ) ) {
                fOkay = fFalse;
                break;
            }
        }

        if ( fOkay ) {
            //
            //  Add it to the symbol table.
            //
            while ( !FAddSymbolValueToSymTab( szInfVar, szInfo ) ) {

                if ( !FHandleOOM( hwndFrame ) ) {

                    fOkay = fFalse;
                    break;
                }
            }

            SFree(szInfo);
        }

        FFreeRgsz( rgszEnum );
    }

    return (cmo & cmoVital) ? fOkay : fTrue;
}





/*
 *  FSetRegValue
 *
 *  Sets a value under the given key
 *
 *  Arguments:
 *
 */
BOOL FSetRegValue( SZ szHandle, SZ szValueName, UINT TitleIndex,
                   UINT ValueType, SZ szValueData, CMO cmo )
{
    BOOL    fOkay;
    HKEY    hKey;

    hKey = (HKEY)LongToHandle(atol( szHandle + 1 ));

    switch ( ValueType ) {

    case REG_MULTI_SZ:
        fOkay = FSetRegValueMultiSz( hKey, szValueName, TitleIndex, REG_MULTI_SZ, szValueData );
        break;

    case REG_SZ:
        fOkay = FSetRegValueSz( hKey, szValueName, TitleIndex, szValueData );
        break;

    case REG_EXPAND_SZ:
        fOkay = FSetRegValueExpandSz( hKey, szValueName, TitleIndex, szValueData );
        break;

    case REG_DWORD:
        fOkay = FSetRegValueDword( hKey, szValueName, TitleIndex, szValueData );
        break;

    case REG_BINARY:
        fOkay = FSetRegValueBin( hKey, szValueName, TitleIndex, REG_BINARY, szValueData );
        break;

    case REG_RESOURCE_LIST:
        fOkay = FSetRegValueBin( hKey, szValueName, TitleIndex, REG_RESOURCE_LIST, szValueData );
        break;

    case REG_FULL_RESOURCE_DESCRIPTOR:
        fOkay = FSetRegValueBin( hKey, szValueName, TitleIndex, REG_FULL_RESOURCE_DESCRIPTOR, szValueData );
        break;

    case REG_RESOURCE_REQUIREMENTS_LIST:
        fOkay = FSetRegValueBin( hKey, szValueName, TitleIndex, REG_RESOURCE_REQUIREMENTS_LIST, szValueData );
        break;

    default:
        fOkay = FSetRegValueBin( hKey, szValueName, TitleIndex, ValueType, szValueData );
        break;

    }

    return (cmo & cmoVital) ? fOkay : fTrue;
}





/*
 *  FGetRegValue
 *
 *  Gets the specified value under the given key
 *
 *  Arguments:
 *
 */
BOOL FGetRegValue( SZ szHandle, SZ szValueName, SZ szInfVar, CMO cmo )
{
    BOOL    fOkay;
    HKEY    hKey;
    DWORD   cbData;
    DWORD   TitleIndex = 0 ;
    DWORD   ValueType;
    PVOID   ValueData;
    SZ      szValueData;
    RGSZ    rgszValue;
    SZ      szInfo;
    LONG    Status;
    char    szTitle[25];
    char    szValueType[25];


    char        szKClass[ MAX_PATH ];
    DWORD       cbKClass;
    DWORD       KTitleIndex = 0 ;
    DWORD       KSubKeys;
    DWORD       cbKMaxSubKeyLen;
    DWORD       cbKMaxClassLen;
    DWORD       KValues;
    DWORD       cbKMaxValueNameLen;
    DWORD       SizeSecurityDescriptor;
    FILETIME    KLastWriteTime;


    hKey = (HKEY)LongToHandle(atol( szHandle + 1 ));

    //
    //  Get the size of the buffer needed
    //
    cbKClass = MAX_PATH;
    fOkay = !( Status = RegQueryInfoKey ( hKey,
                                          szKClass,
                                          &cbKClass,
                                          NULL,
                                          &KSubKeys,
                                          &cbKMaxSubKeyLen,
                                          &cbKMaxClassLen,
                                          &KValues,
                                          &cbKMaxValueNameLen,
                                          &cbData,
                                          &SizeSecurityDescriptor,
                                          &KLastWriteTime ) );

    //cbData = 0;
    //fOkay = !RegQueryValueEx( hKey,
    //                          szValueName,
    //                          NULL,
    //                          NULL,
    //                          NULL,
    //                          &cbData );

    if ( !fOkay ) {

        FUpdateRegLastError( Status, "GetRegValue", szValueName );

    } else {

        //
        //  Allocate the buffer and get the data
        //
        while ( (ValueData = (PVOID)SAlloc( (CB)( cbData ))) == NULL ) {
            if ( !FHandleOOM( hwndFrame ) ) {
                fOkay = fFalse;
                break;
            }
        }

        if ( fOkay ) {

            fOkay = !( Status = RegQueryValueEx( hKey,
                                                 szValueName,
                                                 NULL,
                                                 &ValueType,
                                                 ValueData,
                                                 &cbData ) );
            if ( !fOkay ) {

                FUpdateRegLastError( Status, "GetRegValue", szValueName );

            } else {


                //
                //  Get a list in which to put the key information.
                //
                while ( (rgszValue = (RGSZ)SAlloc( (CB)( 5 * sizeof(SZ)))) == NULL ) {
                    if ( !FHandleOOM( hwndFrame ) ) {
                        fOkay = fFalse;
                        break;
                    }
                }

                if ( fOkay ) {

                    //
                    //  Put the information in the list
                    //
                    if ( (fOkay = (szValueData = ValueDataToSz( ValueType, ValueData, cbData)) != NULL) ) {

                        _ultoa( TitleIndex, szTitle, 10 );
                        _ultoa( ValueType, szValueType, 10 );

                        rgszValue[0] = szValueName;
                        rgszValue[1] = szTitle;
                        rgszValue[2] = szValueType;
                        rgszValue[3] = szValueData;
                        rgszValue[4] = NULL;

                        //
                        //  Transform the list into a string so that it can be added to the
                        //  symbol table.
                        //
                        while ( (szInfo = SzListValueFromRgsz( rgszValue )) == (SZ)NULL ) {
                            if ( !FHandleOOM( hwndFrame ) ) {
                                fOkay = fFalse;
                                break;
                            }
                        }

                        if ( fOkay ) {

                            //
                            //  Add it to the symbol table.
                            //
                            while ( !FAddSymbolValueToSymTab( szInfVar, szInfo ) ) {
                                if ( !FHandleOOM( hwndFrame ) ) {
                                    fOkay = fFalse;
                                    break;
                                }
                            }

                            SFree(szInfo);
                        }

                        SFree( szValueData );
                    }

                    SFree( rgszValue );
                }
            }

            SFree( ValueData );
        }
    }

    return (cmo & cmoVital) ? fOkay : fTrue;
}






/*
 *  FDeleteRegValue
 *
 *  Deletes a value under the given key
 *
 *  Arguments:
 *
 */
BOOL FDeleteRegValue( SZ szHandle, SZ szValueName, CMO cmo )
{
    BOOL    fOkay;
    HKEY    hKey;
    LONG    Status;

    hKey = (HKEY)LongToHandle(atol( szHandle + 1 ));

    fOkay =  !( Status = RegDeleteValue( hKey, szValueName ) );

    if ( !fOkay ) {

        FUpdateRegLastError( Status, "DeleteRegValue", szValueName );
    }

    return (cmo & cmoVital) ? fOkay : fTrue;

}






/*
 *  FEnumRegValue
 *
 *  Obtains information for a value  with a certain index.
 *
 *  Arguments:
 *
 */
BOOL FEnumRegValue( SZ szHandle, SZ szInfVar, CMO cmo )
{
    BOOL    fOkay;
    HKEY    hKey;
    DWORD   cbData;
    DWORD   cbName;
    DWORD   TitleIndex = 0 ;
    DWORD   ValueType;
    PVOID   ValueData;
    SZ      szValueData;
    DWORD   cbValueData;
    RGSZ    rgszValue;
    RGSZ    rgszEnum;
    UINT    EnumSize;
    SZ      szInfo;
    SZ      szValueName;
    DWORD   cbValueName;
    UINT    Index;
    LONG    Status;
    char    szTitle[25];
    char    szValueType[25];

    char        szKClass[ cchlFullPathMax ];
    DWORD       cbKClass;
    DWORD       KTitleIndex = 0 ;
    DWORD       KSubKeys;
    DWORD       cbKMaxSubKeyLen;
    DWORD       cbKMaxClassLen;
    DWORD       SizeSecurityDescriptor;
    DWORD       KValues;
    FILETIME    KLastWriteTime;

    hKey = (HKEY)LongToHandle(atol( szHandle + 1 ));

    //
    //  Get the size of the buffer needed
    //
    cbKClass = MAX_PATH;
    fOkay = !( Status = RegQueryInfoKey ( hKey,
                                          szKClass,
                                          &cbKClass,
                                          NULL,
                                          &KSubKeys,
                                          &cbKMaxSubKeyLen,
                                          &cbKMaxClassLen,
                                          &KValues,
                                          &cbName,
                                          &cbData,
                                          &SizeSecurityDescriptor,
                                          &KLastWriteTime ) );


    if ( !fOkay ) {

        FUpdateRegLastError( Status, "EnumRegValue", NULL );

    } else {

        //
        //  Allocate the buffer to get the data.
        //
        while ( (ValueData = (PVOID)SAlloc( (CB)( cbData ))) == NULL ) {
            if ( !FHandleOOM( hwndFrame ) ) {
                fOkay = fFalse;
                break;
            }
        }
        if ( fOkay ) {

            //
            //  Allocate a buffer to get the name.  Allow for the string terminator.
            //
            while ( (szValueName = (SZ)SAlloc( (CB)( ( ++cbName ) * sizeof( TCHAR ) ))) == NULL ) {
                if ( !FHandleOOM( hwndFrame ) ) {
                    fOkay = fFalse;
                    break;
                }
            }

            if ( fOkay ) {


                //
                //  Allocate empty enum list.
                //
                while ( (rgszEnum = (RGSZ)SAlloc( (CB)( 1 * sizeof(SZ)))) == NULL ) {
                    if ( !FHandleOOM( hwndFrame ) ) {
                        fOkay = fFalse;
                        break;
                    }
                }

                if ( fOkay ) {

                    rgszEnum[0] = NULL;
                    EnumSize    = 0;


                    for ( Index = 0 ; ; Index++ ) {

                        cbValueName = cbName;
                        cbValueData = cbData;

                        if ( Status = RegEnumValue( hKey,
                                                    Index,
                                                    szValueName,
                                                    &cbValueName,
                                                    NULL,
                                                    &ValueType,
                                                    ValueData,
                                                    &cbValueData ) ) {

                            FUpdateRegLastError( Status, "EnumRegValue", NULL );
                            break;
                        }


                        //
                        //  Get a list in which to put the key information.
                        //
                        while ( (rgszValue = (RGSZ)SAlloc( (CB)( 5 * sizeof(SZ)))) == NULL ) {
                            if ( !FHandleOOM( hwndFrame ) ) {
                                fOkay = fFalse;
                                break;
                            }
                        }

                        if ( fOkay ) {

                            //
                            //  Put the information in the list
                            //
                            if ( (fOkay = (szValueData = ValueDataToSz( ValueType, ValueData, cbValueData)) != NULL) ) {

                                _ultoa( TitleIndex, szTitle, 10 );
                                _ultoa( ValueType, szValueType, 10 );

                                rgszValue[0] = szValueName;
                                rgszValue[1] = szTitle;
                                rgszValue[2] = szValueType;
                                rgszValue[3] = szValueData;
                                rgszValue[4] = NULL;

                                //
                                //  Transform the list into a string so that it can be added to the
                                //  symbol table.
                                //
                                while ( (szInfo = SzListValueFromRgsz( rgszValue )) == (SZ)NULL ) {
                                    if ( !FHandleOOM( hwndFrame ) ) {
                                        fOkay = fFalse;
                                        break;
                                    }
                                }

                                if ( fOkay ) {

                                    while ( (rgszEnum = (RGSZ)SRealloc( rgszEnum,
                                                                         (CB)( (EnumSize+2) * sizeof(SZ)))
                                            ) == NULL ) {

                                        if ( !FHandleOOM( hwndFrame ) ) {
                                            fOkay = fFalse;
                                            break;
                                        }
                                    }

                                    if ( fOkay ) {
                                        rgszEnum[EnumSize] = szInfo;
                                        EnumSize++;
                                        rgszEnum[EnumSize] = NULL;
                                    }
                                }

                                SFree( szValueData );
                            }

                            SFree( rgszValue );
                        }

                    }

                    //
                    //  Convert to SZ
                    //
                    while ( (szInfo = SzListValueFromRgsz( rgszEnum )) == (SZ)NULL ) {
                        if ( !FHandleOOM( hwndFrame ) ) {
                            fOkay = fFalse;
                            break;
                        }
                    }

                    if ( fOkay ) {
                        //
                        //  Add it to the symbol table.
                        //
                        while ( !FAddSymbolValueToSymTab( szInfVar, szInfo ) ) {

                            if ( !FHandleOOM( hwndFrame ) ) {

                                fOkay = fFalse;
                                break;
                            }
                        }

                        SFree( szInfo );
                    }

                    FFreeRgsz( rgszEnum );
                }

                SFree( szValueName );
            }

            SFree( ValueData );
        }
    }

    return (cmo & cmoVital) ? fOkay : fTrue;
}






/*
 *  FSetRegValueSz
 *
 *  Sets a value under the given key for SZ type
 *
 *  Arguments:
 *
 */
BOOL FSetRegValueSz( HKEY hKey, SZ szValueName, UINT TitleIndex, SZ szValueData )
{

    LONG    Status;

    Status = RegSetValueEx( hKey,
                            szValueName,
                            0,
                            REG_SZ,
                            szValueData,
                            lstrlen( szValueData ) + 1 );

    if ( Status ) {

        FUpdateRegLastError( Status,"SetRegValueSz", szValueName );
    }

    return !Status;
}


/*
 *  FSetRegValueExpandSz
 *
 *  Sets a value under the given key for expand SZ type
 *
 *  Arguments:
 *
 */
BOOL
FSetRegValueExpandSz(
    HKEY hKey,
    SZ   szValueName,
    UINT TitleIndex,
    SZ   szValueData
    )
{

    LONG    Status;

    Status = RegSetValueEx( hKey,
                            szValueName,
                            0,
                            REG_EXPAND_SZ,
                            szValueData,
                            lstrlen( szValueData ) + 1 );

    if ( Status ) {

        FUpdateRegLastError( Status,"SetRegValueExpandSz", szValueName );
    }

    return !Status;
}


/*
 *  FSetRegValueMultiSz
 *
 *  Sets a value under the given key for REG_MULTI_SZ type
 *
 *  Arguments:
 *
 */
BOOL
FSetRegValueMultiSz(
    HKEY hKey,
    SZ szValueName,
    UINT TitleIndex,
    UINT ValueType,
    SZ szValueData
    )
{
    BOOL    fOkay = fFalse;
    PVOID   Data;
    DWORD   cbData;
    LONG    Status;

    Data = SzToMultiSz( szValueData, &cbData );

    fOkay = !( Status = RegSetValueEx( hKey,
                                       szValueName,
                                       0,
                                       ValueType,
                                       Data,
                                       cbData ) );

    if ( !fOkay ) {

        FUpdateRegLastError( Status,"SetRegValueMultiSz", szValueName );
    }

    if ( Data ) {
        SFree( Data );
    }

    return fOkay;
}




/*
 *  FSetRegValueDword
 *
 *  Sets a value under the given key for DWORD type
 *
 *  Arguments:
 *
 */
BOOL FSetRegValueDword( HKEY hKey, SZ szValueName, UINT TitleIndex, SZ szValueData )
{

    DWORD   Data;
    LONG    Status;

    Data = (DWORD)atol(szValueData );

    Status = RegSetValueEx( hKey,
                            szValueName,
                            0,
                            REG_DWORD,
                            (LPBYTE)&Data,
                            sizeof( DWORD ) );
    if ( Status ) {

        FUpdateRegLastError( Status,"SetRegValueDword", szValueName );
    }

    return !Status;
}




/*
 *  FSetRegValueBin
 *
 *  Sets a value under the given key for BINARY and unknown types
 *
 *  Arguments:
 *
 */
BOOL FSetRegValueBin( HKEY hKey, SZ szValueName, UINT TitleIndex,
                     UINT ValueType, SZ szValueData )
{
    BOOL    fOkay = fFalse;
    PVOID   Data;
    DWORD   cbData;
    LONG    Status;

    Data = SzToBin( szValueData, &cbData );

    fOkay = !( Status = RegSetValueEx( hKey,
                                       szValueName,
                                       0,
                                       ValueType,
                                       Data,
                                       cbData ) );

    if ( !fOkay ) {
        switch( ValueType ) {
            case REG_BINARY:
                FUpdateRegLastError( Status,"SetRegValueBin", szValueName );
                break;

            case REG_RESOURCE_LIST:
                FUpdateRegLastError( Status,"SetRegValueResourceList", szValueName );
                break;

            case REG_FULL_RESOURCE_DESCRIPTOR:
                FUpdateRegLastError( Status,"SetRegValueFullResourceDescriptor", szValueName );
                break;

            case REG_RESOURCE_REQUIREMENTS_LIST:
                FUpdateRegLastError( Status,"SetRegValueResourceRequirementsList", szValueName );
                break;

            default:
                FUpdateRegLastError( Status,"SetRegValueUnknownType", szValueName );
                break;
        }
    }

    if ( Data ) {
        SFree( Data );
    }

    return fOkay;
}



/*
 *  SzToMultiSz
 *
 *  Converts a list of sz strings to a single multi sz string
 *
 *  Arguments:
 *
 */
PVOID   SzToMultiSz( SZ sz, PDWORD cbData )
{
    RGSZ    rgsz;
    SZ      p = NULL, q;
    int     i, j;

    *cbData = 0;

    if ( FListValue( sz )) {

        if ( rgsz = RgszFromSzListValue( sz )) {

            //
            //  Get size of required buffer
            //

            for (i = 0, j = 0; rgsz[i] != NULL; i++ ) {
                j = j + strlen( rgsz[i] ) + 1;
            }
            j = j + 1;  // for the last null

            //
            //  Allocate buffer
            //

            while ( (p = q = (SZ)SAlloc( (CB)( j * sizeof( CHAR )))) == NULL ) {
                if ( !FHandleOOM( hwndFrame ) ) {
                    break;
                }
            }

            if ( p ) {

                for ( i=0; rgsz[i] != NULL; i++ ) {
                    lstrcpy( q, rgsz[ i ] );
                    q = q + lstrlen( rgsz[ i ] ) + 1;
                }
                *q = '\0';
                *cbData = j * sizeof( CHAR );
            }

            FFreeRgsz( rgsz );
        }
    }

    return (PVOID)p;
}


/*
 *  MultiSzToSz
 *
 *  Converts a block of memory to a list containing hex digits
 *
 *  Arguments:
 *
 */

SZ   MultiSzToSz( PVOID Data, DWORD cbData )
{
    RGSZ    rgsz;
    SZ      sz  =   NULL,  szData, szEnd;
    DWORD   i, cbList = 0;

    //
    // Count the number of list elements in the multi sz list. We do this
    // by counting the number of '0's in the string and subtracting 1 from
    // this
    //

    szData = (SZ)( Data );
    szEnd  = (SZ)( (PBYTE)Data + cbData );
    while( szData < szEnd ) {
        if (*szData++ == '\0') {
            cbList++;
        }
    }


    if( cbList > 0 ) {

        cbList--; // remove the terminating null

        //
        // Allocate a rgsz list with cbList elements;
        //

        while ( (rgsz = (RGSZ)SAlloc( (CB)( (cbList + 1) * sizeof(SZ)))) == NULL ) {
            if ( !FHandleOOM( hwndFrame ) ) {
                break;
            }
        }

        if( rgsz ) {
            //
            // Go through the szList and fill the rgsz structure
            //

            szData = (SZ)( Data );

            for ( i = 0; i < cbList; i++ ) {
                rgsz[i] = SzDupl( szData );
                szData = szData + lstrlen( szData ) + 1;
            }
            rgsz[cbList] = NULL;

            //
            //  Transform the list into a string.
            //

            while ( (sz = SzListValueFromRgsz( rgsz )) == (SZ)NULL ) {
                if ( !FHandleOOM( hwndFrame ) ) {
                    break;
                }
            }

            EvalAssert( FFreeRgsz( rgsz ) );
        }
    }

    return( sz );

}


/*
 *  SzToBin
 *
 *  Converts a list of hex digits to binary
 *
 *  Arguments:
 *
 */
PVOID   SzToBin( SZ sz, PDWORD cbData )
{
    RGSZ    rgsz;
    PBYTE   p, q =   NULL;
    int     i;

    *cbData = 0;

    if ( FListValue( sz )) {

        if ( rgsz = RgszFromSzListValue( sz )) {

            //
            //  Get size of required buffer
            //
            for (i=0; rgsz[i] != NULL; i++ );

            //
            //  Allocate buffer
            //
            while ( (p = q = (PBYTE)SAlloc( (CB)( i ))) == NULL ) {
                if ( !FHandleOOM( hwndFrame ) ) {
                    break;
                }
            }

            if ( p ) {

                for ( i=0; rgsz[i] != NULL; i++ ) {
                    *p++ = (BYTE)atoi( rgsz[i] );
                }

                *cbData = i;
            }

            FFreeRgsz( rgsz );
        }
    }

    return q;
}






/*
 *  BinToSz
 *
 *  Converts a block of memory to a list containing hex digits
 *
 *  Arguments:
 *
 */
SZ   BinToSz( PVOID Data, DWORD cbData )
{
    RGSZ    rgsz;
    SZ      sz  =   NULL;
    SZ      szElement;
    DWORD   i;
    PBYTE   pbData;


    //
    //  The list will contain cbData elements
    //
    while ( (rgsz = (RGSZ)SAlloc( (CB)( (cbData+1) * sizeof(SZ)))) == NULL ) {
        if ( !FHandleOOM( hwndFrame ) ) {
            break;
        }
    }

    if ( rgsz ) {

        //
        //  For each element of the list, allocate a buffer and convert it
        //  to a string
        //
        pbData = (PBYTE)Data;

        for (i=0; i<cbData; i++ ) {

            while ( (szElement = (SZ)SAlloc( (CB)( 25 ))) == NULL ) {
                if ( !FHandleOOM( hwndFrame ) ) {
                    break;
                }
            }

            if ( szElement ) {
                _ultoa( *(pbData + i), szElement, 10 );
                rgsz[i] = szElement;

            } else {
                rgsz[i] = NULL;
                break;
            }
        }

        if ( i == cbData ) {

            rgsz[i] = NULL;

            //
            //  Transform the list into a string.
            //
            while ( (sz = SzListValueFromRgsz( rgsz )) == (SZ)NULL ) {
                if ( !FHandleOOM( hwndFrame ) ) {
                    break;
                }
            }
        }

        FFreeRgsz( rgsz );
    }

    return sz;
}



/*
 *  ValueDataToSz
 *
 *  Converts a value data to its string form
 *
 *  Arguments:
 *
 */
SZ ValueDataToSz( DWORD ValueType, PVOID ValueData, DWORD cbData )
{
    SZ      sz = NULL;

    switch ( ValueType ) {

    case REG_SZ:
        sz = SzDupl((SZ)ValueData);
        break;

    case REG_EXPAND_SZ:
        sz = SzDupl((SZ)ValueData);
        break;

    case REG_DWORD:
        while ( (sz = (SZ)SAlloc( (CB)( 25 ))) == NULL ) {
            if ( !FHandleOOM( hwndFrame ) ) {
                break;
            }
        }

        if ( sz ) {
            _ultoa( *(PDWORD)ValueData, sz, 10 );
        }
        break;


    case REG_MULTI_SZ:
        sz = MultiSzToSz( ValueData, cbData );
        break;


    case REG_BINARY:
    default:
        sz = BinToSz( ValueData, cbData );
        break;
    }

    return sz;
}




RGSZ
MultiSzToRgsz(
    IN PVOID MultiSz
    )
{
    PCHAR p;
    ULONG Count;
    RGSZ rgsz;

    //
    // First count the number of strings in the the multisz.
    //

    Count = 0;
    p = MultiSz;

    while(*p) {
        Count++;
        p = strchr(p,'\0') + 1;
    }

    //
    // Allocate the rgsz.
    //

    rgsz = (RGSZ)SAlloc((Count + 1) * sizeof(PCHAR));

    if(rgsz == NULL) {
        return(NULL);
    }

    memset(rgsz,0,(Count + 1) * sizeof(PCHAR));

    //
    // Now place the strings in the rgsz.
    //

    p = MultiSz;
    Count = 0;

    while(*p) {

        if(rgsz[Count++] = SzDupl((SZ)p)) {

            p = strchr(p,'\0') + 1;

        } else {

            FFreeRgsz(rgsz);
            return(NULL);
        }
    }

    return(rgsz);
}



PCHAR
RgszToMultiSz(
    IN RGSZ rgsz
    )
{
    ULONG Size;
    ULONG Str;
    PCHAR MultiSz;

    //
    // First determine the size of the block to hold the multisz.
    //

    Size = 0;
    Str = 0;

    while(rgsz[Str]) {

        Size += strlen(rgsz[Str++]) + 1;
    }

    Size++;     // for extra NUL to terminate the multisz.

    MultiSz = SAlloc(Size);

    if(MultiSz == NULL) {
        return(NULL);
    }

    Str = 0;
    Size = 0;

    while(rgsz[Str]) {

        lstrcpy(MultiSz + Size, rgsz[Str]);

        Size += lstrlen(rgsz[Str++]) + 1;
    }

    MultiSz[Size] = 0;

    return(MultiSz);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\registry.c ===
#include "precomp.h"
#pragma hdrstop
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    registry.c

Abstract:

    Registry related functions in the setupdll

    Detect Routines:
    ----------------

    1. GetEnvVar <SYSTEM | USER> <VARNAME> returns
           List <ValueName, ValueTitle, ValueRegType, ValueData>
           The value data is decomposed into a list of the elements:
           e.g. val1;val2;val3 becomes {val1, val2, val3}

    2. GetMyComputerName

    Install Routines Workers:
    -------------------------

    2. SetEnvVarWorker:  To set a USER or SYSTEM environment variable

    3. ExpandSzWorker: To expand all the expand sz components in an
                       environment string.


    General Subroutines:
    --------------------

    1. GetValueEntry: To fetch a value entry given a key and a value name
                      This is useful when we don't know the size of the
                      value entry.

    2. GetMaxSizeValueInKey: This is to find the maximum size needed to
                      query a value in the key.


Author:

    Sunil Pai (sunilp) April 1992

--*/

extern CHAR ReturnTextBuffer[];

//
// Detect Routines
//

CB
GetEnvVar(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
{

    SZ      sz, sz1, szEnv;
    HKEY    hKey, hRootKey;
    DWORD   cbData;
    CB      Length;
    LONG    Status;
    DWORD   ValueType;
    PVOID   ValueData;
    CHAR    szValueType[25];
    RGSZ    rgsz;


    #define UNDEF_VAR_VALUE "{}"
    Unused( cbReturnBuffer );

    //
    // If the environment variable cannot be determine we
    // return the empty list as the value of this call.
    // Initialise this anyway to avoid doing this at a
    // a number of places.
    //

    lstrcpy( ReturnBuffer, UNDEF_VAR_VALUE );
    Length = lstrlen( UNDEF_VAR_VALUE ) + 1;


    //
    // Do parameter validation
    //

    if( cArgs < 2 ) {
        return( Length );
    }

    //
    // Check to see if the user wants a system environment variable or
    // a user environment variable.  Accordingly find out the right
    // place in the registry to look.
    //

    if ( !lstrcmpi( Args[0], "SYSTEM" ) ) {
        hRootKey = HKEY_LOCAL_MACHINE;
        szEnv    = "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment";
    }
    else if ( !lstrcmpi( Args[0], "USER" ) ) {
        hRootKey = HKEY_CURRENT_USER;
        szEnv    = "Environment";
    }
    else {
        return( Length );
    }

    //
    // Open the environment variable key.
    //

    Status = RegOpenKeyEx(
                 hRootKey,
                 szEnv,
                 0,
                 KEY_READ,
                 &hKey
                 );

    if( Status != ERROR_SUCCESS ) {
        return( Length );
    }

    //
    // Get the environment variable value
    //

    if( !GetMaxSizeValueInKey( hKey, &cbData )      ||
        ( ValueData = SAlloc( cbData ) ) == NULL
      ) {
        RegCloseKey( hKey );
        return( Length );
    }

    Status = RegQueryValueEx(
                 hKey,
                 Args[1],
                 NULL,
                 &ValueType,
                 ValueData,
                 &cbData
                 );

    RegCloseKey( hKey );

    if (Status != ERROR_SUCCESS) {
        SFree( ValueData );
        return( Length );
    }

    if ( ( sz = SzListValueFromPath( (SZ)ValueData ) ) == NULL ) {
        SFree( ValueData );
        return( Length    );
    }
    SFree( ValueData );

    _ultoa( ValueType,  szValueType, 10 );

    //
    // Allocate an Rgsz structure: (Note same style as internal registry usage)
    //
    // Field 0: EnvVarValueName
    // Field 1: EnvVarTitleIndex "0"
    // Field 2: EnvVarValueType
    // Field 3: EnvVarValue
    //

    if ( rgsz = RgszAlloc( 5 ) ) {

        rgsz[0] = Args[1];
        rgsz[1] = "0";
        rgsz[2] = szValueType;
        rgsz[3] = sz;
        rgsz[4] = NULL;

        sz1 = SzListValueFromRgsz( rgsz );
        if( sz1 ) {
            lstrcpy( ReturnBuffer, sz1 );
            Length = lstrlen( sz1 ) + 1;
            SFree( sz1 );

        }
        SFree( rgsz );
    }
    SFree( sz );

    return( Length );
}



CB
GetMyComputerName(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
/*++

Routine Description:

    DetectRoutine for GetComputerName. This finds out the computername of
    this machine in the current control set.

Arguments:

    Args   - C argument list to this detect routine (None exist)

    cArgs  - Number of arguments.

    ReturnBuffer - Buffer in which detected value is returned.

    cbReturnBuffer - Buffer Size.


Return value:

    Returns length of detected value.


--*/
{
    CHAR   ComputerName[MAX_PATH];
    DWORD  nSize = MAX_PATH;
    BOOL   bStatus = FALSE;
    CB     Length;

    #define DEFAULT_COMPUTERNAME ""

    Unused(Args);
    Unused(cArgs);
    Unused(cbReturnBuffer);


    if( GetComputerName( ComputerName, &nSize ) ) {
        lstrcpy( ReturnBuffer, ComputerName );
        Length = lstrlen( ComputerName ) + 1;
    }
    else {
        lstrcpy( ReturnBuffer, DEFAULT_COMPUTERNAME );
        Length = lstrlen( DEFAULT_COMPUTERNAME ) + 1;
    }

    return( Length );

}


//
// Install Routines
//

BOOL
SetEnvVarWorker(
    LPSTR UserOrSystem,
    LPSTR Name,
    LPSTR Title,
    LPSTR RegType,
    LPSTR Data
    )
{
    HKEY hKey, hRootKey;
    SZ   szEnv;
    LONG Status;

    Unused(Title);

    //
    // Check to see if the user wants to modify a system environment variable
    // or a user environment variable.  Accordingly find out the right
    // place in the registry to look.
    //

    if ( !lstrcmpi( UserOrSystem, "SYSTEM" ) ) {
        hRootKey = HKEY_LOCAL_MACHINE;
        szEnv    = "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment";
    }
    else if ( !lstrcmpi( UserOrSystem, "USER" ) ) {
        hRootKey = HKEY_CURRENT_USER;
        szEnv    = "Environment";
    }
    else {
        return( FALSE );
    }

    //
    // Open the environment variable key.
    //

    Status = RegOpenKeyEx(
                 hRootKey,
                 szEnv,
                 0,
                 KEY_WRITE,
                 &hKey
                 );

    if( Status != ERROR_SUCCESS ) {
        SetErrorText( IDS_ERROR_REGOPEN );
        return( FALSE );
    }

    //
    // Write the value given
    //

    Status = RegSetValueEx(
                 hKey,
                 Name,
                 0,
                 (DWORD)atol( RegType ),
                 (LPBYTE)Data,
                 lstrlen( Data ) + 1
                 );

    RegCloseKey( hKey );

    if( Status != ERROR_SUCCESS ) {
        SetErrorText( IDS_ERROR_REGSETVALUE );
        return( FALSE );
    }

    //
    // Send a WM_WININICHANGE message so that progman picks up the new
    // variable
    //

    SendMessageTimeout(
        (HWND)-1,
        WM_WININICHANGE,
        0,
        (LPARAM)"Environment",
        SMTO_ABORTIFHUNG,
        1000,
        NULL
        );

    return( TRUE );
}




BOOL
ExpandSzWorker(
    LPSTR EnvironmentString,
    LPSTR ReturnBuffer,
    DWORD cbReturnBuffer
    )
{
    DWORD cbBuffer;

    cbBuffer = ExpandEnvironmentStrings(
                   (LPCSTR)EnvironmentString,
                   ReturnBuffer,
                   cbReturnBuffer
                   );

    if ( cbBuffer > cbReturnBuffer ) {
        SetErrorText( IDS_BUFFER_OVERFLOW );
        return( FALSE );
    }

    return( TRUE );
}




BOOL
SetMyComputerNameWorker(
    LPSTR ComputerName
    )
/*++

Routine Description:

    To set the computername value in the services tree.

Arguments:

    ComputerName - Value to set as the computername


Return value:

    TRUE if successful, FALSE otherwise.

--*/
{
    if( !SetComputerName( ComputerName ) ) {
        SetErrorText(IDS_ERROR_SETCOMPUTERNAME);
        return( FALSE );
    }

    return( TRUE );
}




//=====================================================================
// The following are registry access subroutines..
//=====================================================================

BOOL
GetMaxSizeValueInKey(
    HKEY    hKey,
    LPDWORD cbData
    )
{
    LONG        Status;
    CHAR        szKClass[ MAX_PATH ];
    DWORD       cbKClass = MAX_PATH;
    DWORD       KSubKeys;
    DWORD       cbKMaxSubKeyLen;
    DWORD       cbKMaxClassLen;
    DWORD       KValues;
    DWORD       cbKMaxValueNameLen;
    DWORD       SizeSecurityDescriptor;
    FILETIME    KLastWriteTime;

    Status = RegQueryInfoKey (
                 hKey,
                 szKClass,
                 &cbKClass,
                 NULL,
                 &KSubKeys,
                 &cbKMaxSubKeyLen,
                 &cbKMaxClassLen,
                 &KValues,
                 &cbKMaxValueNameLen,
                 cbData,
                 &SizeSecurityDescriptor,
                 &KLastWriteTime
                 );

    if (Status != ERROR_SUCCESS) {
        return( FALSE );
    }

    return( TRUE );

}


PVOID
GetValueEntry(
    HKEY  hKey,
    LPSTR szValueName
    )
{
    LONG        Status;
    CHAR        szKClass[ MAX_PATH ];
    DWORD       cbKClass = MAX_PATH;
    DWORD       KSubKeys;
    DWORD       cbKMaxSubKeyLen;
    DWORD       cbKMaxClassLen;
    DWORD       KValues;
    DWORD       cbKMaxValueNameLen;
    DWORD       cbData;
    DWORD       SizeSecurityDescriptor;
    FILETIME    KLastWriteTime;
    DWORD       ValueType;


    PVOID       ValueData;

    Status = RegQueryInfoKey (
                 hKey,
                 szKClass,
                 &cbKClass,
                 NULL,
                 &KSubKeys,
                 &cbKMaxSubKeyLen,
                 &cbKMaxClassLen,
                 &KValues,
                 &cbKMaxValueNameLen,
                 &cbData,
                 &SizeSecurityDescriptor,
                 &KLastWriteTime
                 );

    if (Status != ERROR_SUCCESS) {
        return( NULL );
    }

    if ( ( ValueData = SAlloc( cbData ) ) == NULL ) {
        return( NULL );
    }

    Status = RegQueryValueEx(
                 hKey,
                 szValueName,
                 NULL,
                 &ValueType,
                 ValueData,
                 &cbData
                 );


     if (Status != ERROR_SUCCESS) {
        SFree( ValueData );
        return( NULL );
     }
     else {
        return( ValueData );
     }

}



BOOL
GenerateUniqueFileName(
    IN     LPSTR TempPath,
    IN     LPSTR Prefix,
    IN OUT LPSTR TempFile
    )
/*++

Routine Description:

    To generate a unique filename (with no extension) in the TempPath
    Directory with the Prefix given and digits from 1 to 99999

Arguments:

    TempPath - string containing a valid directory path ending
               in a backslash.

    Prefix   - a prefix string no longer than 3 characters.

    TempFile - buffer to return the full path to the temp file

Return value:

    TRUE if succeds in finding, FALSE otherwise.  If TRUE, TempFile buffer
    has the full path to the temp file.


--*/

{
    CHAR  Number[6];
    DWORD i;

    //
    // Check parameters
    //

    if ( TempPath    == (LPSTR)NULL
         || Prefix   == (LPSTR)NULL
         || TempFile == (LPSTR)NULL
         || lstrlen( Prefix ) > 3

       ) {

        return( FALSE );
    }

    //
    // go through all numbers upto 5 digits long looking
    // for file which doesn't exist
    //

    for( i = 1; i <99999; i++ ) {
        lstrcpy( TempFile, TempPath);
        lstrcat( TempFile, "\\" );
        lstrcat( TempFile, Prefix  );
        sprintf( Number, "%d", i );
        lstrcat( TempFile, Number );
        if (!FFileExist( TempFile ) ) {
            return( TRUE );
        }
    }

    //
    // not found, return false
    //

    return( FALSE );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\sbutton.c ===
#include "precomp.h"
#pragma hdrstop
/*****************************************************************************
*                                                                            *
*  SBUTTON.C                                                                 *
*                                                                            *
*  Program Description: Implements "3-D" buttons                             *
*                                                                            *
******************************************************************************
*                                                                            *
*  Revision History:  Created by Todd Laney, Munged 3/27/89 by Robert Bunney *
*		      7/25/89  - revised by Chris Guzak for transparent	     *
*				 color bitmaps.				     *
*                     7/26/89  - revised by Todd Laney to handle multi-res   *
*                                bitmaps. 				     *
*                                windows 3 support                           *
*                                                                            *
*****************************************************************************/

#define NOCOMM

//
//  if WIN2 is defined the code will work in windows 2.x and windows 3.0
//  otherwise windows 3.0 is required
//

/*****************************************************************************
*                                                                            *
*                               Defines                                      *
*                                                                            *
*****************************************************************************/

#if DBG
#define PRIV
#else
#define PRIV static
#endif

#define rgbWhite   RGB(255,255,255)
#define rgbBlack   RGB(0,0,0)
#define ISDIGIT(c)  ((c) >= '0' && (c) <= '9')
#define BEVEL   2
#define FRAME   1

#define GWW_HBM     0
#define GWW_STATE   GWW_HBM + sizeof(PVOID)
#define GWW_FLAGS   GWW_STATE + sizeof(DWORD)
#define GWW_CHECK   GWW_FLAGS + sizeof(DWORD)
#define GWW_SIZE    GWW_CHECK + sizeof(DWORD)
#define GETSTYLE(hwnd) (LOWORD(GetWindowLong(hwnd,GWL_STYLE)))
#define GETSTATE(hwnd) GetWindowLong(hwnd,GWW_STATE)
#define GETFLAGS(hwnd) GetWindowLong(hwnd,GWW_FLAGS)
#define GETCHECK(hwnd) GetWindowLong(hwnd,GWW_CHECK)
#define GETHBM(hwnd)   GetWindowLongPtr(hwnd,GWW_HBM)
#define lpCreate ((LPCREATESTRUCT)lParam)

#define DPSoa    0x00A803A9L
#define DSPDxax  0x00E20746L

#define EraseButton(hwnd,hdc,prc) ExtTextOut(hdc,0,0,ETO_OPAQUE,prc,NULL,0,NULL)
#define NearestColor(hdc,rgb) (GetNearestColor(hdc,rgb) & 0x00FFFFFFL)

/*****************************************************************************
*                                                                            *
*                               Prototypes                                   *
*                                                                            *
*****************************************************************************/

PRIV VOID     DrawGrayButton (HWND, HDC, LPRECT, WORD, WORD);
PRIV VOID     DrawButtonFace (HWND, HDC, PRECT, WORD);
PRIV BOOL     PaintButton    (HWND, HDC);
PRIV VOID     NotifyParent   (HWND);
PRIV VOID     PatB           (HDC, int, int, int, int, DWORD);
PRIV HBITMAP  LoadBitmapResource(HANDLE hInst, LPSTR lpName);
PRIV VOID     BitmapColorTranslate(HDC hdcBits, BITMAP* pbm, DWORD rgb);

/*****************************************************************************
*                                                                            *
*                               Variabls                                     *
*                                                                            *
*****************************************************************************/

HBRUSH hbrGray = NULL;                 // Gray for text
HBRUSH hbrFocus = NULL;                // focus for text

DWORD  rgbButtonFocus;
DWORD  rgbButtonFace;
DWORD  rgbButtonText;
DWORD  rgbButtonShadow;

PRIV char szColor[]  = "Colors";          // Name of color section
PRIV char szButton[] = "sbutton";

/*---------------------------------------------------------------------------*\
|   ButtonControlInit( hInst )                                           |
|                                                                              |
|   Description:                                                               |
|       This is called when the application is first loaded into               |
|       memory.  It performs all button initialization.                        |
|                                                                              |
|   Arguments:                                                                 |
|       hInst      instance handle of current instance                         |
|                                                                              |
|   Returns:                                                                   |
|       TRUE if successful, FALSE if not                                       |
|                                                                              |
\*----------------------------------------------------------------------------*/

BOOL
ButtonControlInit(
    IN HANDLE hInst
    )
{
    WNDCLASS    cls;
    UINT        patGray[8];
    HBITMAP     hbmGray;
    int         i;
    HDC         hdc;

    /* initialize the brushes */

    for (i=0; i<8; i+=2) {
        patGray[i]   = 0x0000AAAA;
        patGray[i+1] = 0x00005555;
    }

    hbmGray = CreateBitmap(8, 8, 1, 1, (LPSTR)patGray);
    hbrGray = CreatePatternBrush(hbmGray);
    if (hbmGray) {
      DeleteObject(hbmGray);
    }

    hdc = GetDC(NULL);

    if (hdc) {
    
   
       rgbButtonFace   = GetSysColor(COLOR_BTNFACE);
       rgbButtonShadow = GetSysColor(COLOR_BTNSHADOW);
       rgbButtonText   = GetSysColor(COLOR_BTNTEXT);
       rgbButtonFocus  = rgbWhite;  // ??
   
       rgbButtonFace   = NearestColor(hdc,rgbButtonFace);
       rgbButtonShadow = NearestColor(hdc,rgbButtonShadow);
       rgbButtonText   = NearestColor(hdc,rgbButtonText);
       rgbButtonFocus  = NearestColor(hdc,rgbButtonFocus);
   
       if (rgbButtonFocus == rgbButtonFace)
           rgbButtonFocus = rgbButtonText;
   
       ReleaseDC(NULL,hdc);

    }

    hbrFocus = CreateSolidBrush(rgbButtonFocus);

    cls.hCursor        = LoadCursor(NULL,IDC_ARROW);
    cls.hIcon          = NULL;
    cls.lpszMenuName   = NULL;
    cls.lpszClassName  = (LPSTR)szButton;
    cls.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);
    cls.hInstance      = hInst;
    cls.style          = CS_HREDRAW | CS_VREDRAW;
    cls.lpfnWndProc    = fnButton;
    cls.cbClsExtra     = 0;
    cls.cbWndExtra     = GWW_SIZE;

    return(RegisterClass(&cls));
}

VOID
ButtonControlTerm(
    VOID
    )
{
	if (hbrGray)
		DeleteObject(hbrGray);

	if (hbrFocus)
		DeleteObject(hbrFocus);

    UnregisterClass(szButton,hInst);
}


/*----------------------------------------------------------------------------*\
|                                                                              |
| Custom push-button                                                           |
|                                                                              |
\*----------------------------------------------------------------------------*/

PRIV BOOL  PaintButton(HWND hwnd, HDC hdc)
{
    WORD   style;
    RECT   rc;
    WORD   f;

    HDC     hdcMem;
    HBITMAP hbmMem,hbmT;

    GetClientRect(hwnd,&rc);

    if (!RectVisible(hdc,&rc))
        return TRUE;

    style  = (WORD)((DWORD)GETSTYLE(hwnd) | ((DWORD)GETFLAGS(hwnd) & 0xFF00));
    f      = (WORD)GETSTATE(hwnd);

    hdcMem = CreateCompatibleDC(hdc);
    hbmMem = CreateCompatibleBitmap(hdc,rc.right,rc.bottom);

    switch (LOBYTE(style))
    {
        case BS_PUSHBUTTON:
        case BS_DEFPUSHBUTTON:
            if (hdcMem && hbmMem)
            {
                hbmT = SelectObject(hdcMem,hbmMem);
                DrawGrayButton(hwnd, hdcMem, &rc, style, f);
                BitBlt(hdc,0,0,rc.right,rc.bottom,hdcMem,0,0,SRCCOPY);
                SelectObject(hdcMem,hbmT);
            }
            else
            {
                DrawGrayButton(hwnd, hdc, &rc, style, f);
            }
            break;
    }

    if (hbmMem)
        DeleteObject(hbmMem);
    if (hdcMem)
        DeleteDC(hdcMem);
    return TRUE;
}


/*******************
**
** Name:      ButtonState
**
** Purpose:   Compares the passed state (f) with the current state.  If
**            they differ, the button is invalidated and TRUE is
**            is returned.
**
** Arguments: hwnd - window handle of the button
**            f    - state to set
**
** Returns:   TRUE iff the current state is different than f
**
*******************/

BOOL ButtonState(HWND hwnd, WORD f)
{
    WORD state;

    state = (WORD)GETSTATE(hwnd);

    if (state != f)
    {
        SetWindowLong(hwnd,GWW_STATE,f);
        InvalidateRect(hwnd,NULL,TRUE);
        UpdateWindow(hwnd);
        return TRUE;
    }
    return FALSE;
}


/*******************
**
** Name:      fnButton
**
** Purpose:   Window proc for buttons
**
** Arguments: Standard window proc
**
*******************/

LRESULT APIENTRY fnButton(HWND hwnd,UINT message,WPARAM wParam,LPARAM lParam)
{
    HANDLE      hbm;
    PAINTSTRUCT ps;
    RECT        rc;
    LONG        l;

    switch (message)
    {
        case WM_CREATE:
	    SetWindowLongPtr(hwnd,GWW_HBM,0);
            SetWindowLong(hwnd,GWW_STATE,0);
            SetWindowLong(hwnd,GWW_FLAGS,lpCreate->style & 0x0000FF00);
            SetWindowText(hwnd,lpCreate->lpszName);
            SetWindowLong(hwnd,GWL_STYLE,lpCreate->style & 0xFFFF00FF);
            break;

        case WM_LBUTTONDOWN:
            if (!IsWindowEnabled(hwnd))
                return 0L;

            if (GetCapture() != hwnd)  /* ignore multiple DOWN's */
            {
                ButtonState(hwnd,TRUE);
                SetCapture(hwnd);
                if (!(GETFLAGS(hwnd) & BS_NOFOCUS))
                    SetFocus(hwnd);
            }
            return 0L;

        case WM_MOUSEMOVE:
            if (GetCapture() == hwnd)
            {
                POINT point;

                point.x = (LONG)(LOWORD(lParam));
                point.y = (LONG)(HIWORD(lParam));

                GetClientRect(hwnd,&rc);
                ButtonState(hwnd,(WORD)PtInRect(&rc,point));
            }
            return 0L;

        case WM_LBUTTONUP:
            if (GetCapture() == hwnd)
            {
                ReleaseCapture();
                if (ButtonState(hwnd,FALSE))
                    NotifyParent(hwnd);
            }
            return 0L;

        case WM_DESTROY:
            if (hbm = (HBITMAP)GETHBM(hwnd))
                DeleteObject(hbm);
            break;

        case WM_SETTEXT:
            if (hbm = (HBITMAP)GETHBM(hwnd))
                DeleteObject(hbm);

            if (*(LPSTR)lParam == '#')
            {
                hbm = LoadBitmapResource(
                        (HINSTANCE)GetWindowLongPtr(hwnd,GWLP_HINSTANCE),
                        (LPSTR)lParam+1
                        );
            }
            else
            {
                hbm = NULL;
            }
            SetWindowLongPtr(hwnd,GWW_HBM,(LONG_PTR)hbm);
            InvalidateRect(hwnd,NULL,TRUE);
            break;

        case WM_ENABLE:
        case WM_KILLFOCUS:
        case WM_SETFOCUS:
            InvalidateRect(hwnd,NULL,TRUE);
            break;

        case WM_KEYDOWN:
            if (wParam == VK_SPACE && IsWindowEnabled(hwnd))
                ButtonState(hwnd,TRUE);
            break;

        case WM_KEYUP:
        case WM_SYSKEYUP:
            if (wParam == VK_SPACE && IsWindowEnabled(hwnd))
            {
                if (ButtonState(hwnd,FALSE))
                    NotifyParent(hwnd);
            }
            break;

        case BM_GETSTATE:
            return((LONG)GETSTATE(hwnd));

        case BM_SETSTATE:
            if (ButtonState(hwnd,(WORD)wParam) && !wParam)
//                NotifyParent(hwnd);
            break;

        case BM_GETCHECK:
            return((LONG)GETCHECK(hwnd));

        case BM_SETCHECK:
            SetWindowLong(hwnd,GWW_CHECK,(DWORD)wParam);
            break;

        case BM_SETSTYLE:
            l = GetWindowLong(hwnd,GWL_STYLE);
            SetWindowLong(hwnd,GWL_STYLE,MAKELONG((WORD)wParam,HIWORD(l)));
            if (lParam)
                InvalidateRect(hwnd, NULL, TRUE);
            break;

        case WM_SETCURSOR:
            SetCursor(CurrentCursor);
            return(TRUE);              // don't mess with cursor

        case WM_GETDLGCODE:
            switch (LOBYTE(GETSTYLE(hwnd)))
            {
                case BS_DEFPUSHBUTTON:
                    wParam = DLGC_DEFPUSHBUTTON;
                    break;

                case BS_PUSHBUTTON:
                    wParam = DLGC_UNDEFPUSHBUTTON;
                    break;

                default:
                    wParam = 0;
            }

            return((LONG)(wParam | DLGC_BUTTON));

        case WM_ERASEBKGND:
            return 0L;

        case WM_PAINT:
            BeginPaint(hwnd, &ps);
            PaintButton(hwnd,ps.hdc);
            EndPaint(hwnd, &ps);
            return 0L;
    }
    return DefWindowProc(hwnd, message, wParam, lParam);
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  DrawGrayButton() -                                                       */
/*                                                                           */
/*---------------------------------------------------------------------------*/

PRIV VOID  DrawGrayButton(HWND hwnd,HDC hdc,RECT *lprc,WORD style,WORD fInvert)
{
    RECT        rc;
    int         dx,dy;
    HBRUSH      hbr;
    int         i;
    int         iFrame;

    SetBkColor(hdc,GetSysColor(COLOR_WINDOW));

    hbr = (HBRUSH)SendMessage(GetParent(hwnd), WM_CTLCOLORBTN, (WPARAM)hdc, (LONG_PTR)hwnd);
    FillRect(hdc, lprc, hbr);

    rc = *lprc;
    dx = rc.right  - rc.left;
    dy = rc.bottom - rc.top;

    iFrame = FRAME;

    if (LOBYTE(style) == BS_DEFPUSHBUTTON)
        iFrame *= 2;

    PatB(hdc, rc.left        , rc.top          , dx    , iFrame, rgbBlack);
    PatB(hdc, rc.left        , rc.bottom-iFrame, dx    , iFrame, rgbBlack);
    PatB(hdc, rc.left        , rc.top+1        , iFrame, dy-2,   rgbBlack);
    PatB(hdc, rc.right-iFrame, rc.top+1        , iFrame, dy-2,   rgbBlack);

    InflateRect(&rc,-iFrame,-iFrame);
    dx = rc.right  - rc.left;
    dy = rc.bottom - rc.top;

    SetBkColor(hdc,rgbButtonFace);
    EraseButton(hwnd,hdc,&rc);

    if (fInvert)
    {
        PatB(hdc, rc.left,   rc.top,   1,dy,     rgbButtonShadow);
        PatB(hdc, rc.left,   rc.top,   dx,1,     rgbButtonShadow);
        rc.left += BEVEL*2;
        rc.top  += BEVEL*2;
    }
    else
    {
        for (i=0; i<BEVEL; i++)
        {
            PatB(hdc, rc.left,   rc.top,   1,dy,     rgbWhite);
            PatB(hdc, rc.left,   rc.top,   dx,1,     rgbWhite);
            PatB(hdc, rc.right-1,rc.top+1, 1,dy-1,   rgbButtonShadow);
            PatB(hdc, rc.left+1, rc.bottom-1, dx-1,1,rgbButtonShadow);

            InflateRect(&rc,-1,-1);
            dx -= 2;
            dy -= 2;
        }
    }

    SetBkColor(hdc,rgbButtonFace);

    if (GetFocus() == hwnd)
        SetTextColor(hdc,rgbButtonFocus);
    else
        SetTextColor(hdc,rgbButtonText);

    DrawButtonFace(hwnd,hdc,&rc,style);
}

/*******************
**
** Name:      DrawButtonFace
**
** Purpose:   Responsible for the rendering of the text or bitmap on
**            on a button.
**
** Arguments: hwnd  - window handle of button
**            hdc   - hdc for window
**            prc   - clipping rect
**            sytle - button style (push button or default pushbutton)
**
*******************/


PRIV VOID  DrawButtonFace(HWND hwnd, HDC hdc, PRECT prc, WORD style)
{
    RECT        rc;
    HBITMAP     hbm;
    HDC         hdcBits;
    BITMAP      bm;
    BOOL        fMono;

    rc = *prc;

    SaveDC(hdc);

    IntersectClipRect(hdc, prc->left, prc->top, prc->right, prc->bottom);

    if ((hbm = (HBITMAP)GETHBM(hwnd)))
    {
        hdcBits = CreateCompatibleDC(hdc);
        if (hdcBits) {
           
           SelectObject(hdcBits,hbm);
           GetObject(hbm,sizeof(bm),(LPSTR)&bm);
           fMono = (bm.bmPlanes == 1) && (bm.bmBitsPixel == 1);
   
           BitmapColorTranslate(hdcBits, &bm, rgbButtonFace);
   
           if (!(style & BS_STRETCH))
           {
               // now center this thing on the button face
               rc.left += (rc.right - rc.left - (signed)bm.bmWidth) / 2;
               rc.top += (rc.bottom - rc.top - (signed)bm.bmHeight) / 2;
               rc.right  = rc.left + bm.bmWidth;
               rc.bottom = rc.top + bm.bmHeight;
   
           }
   
           SetStretchBltMode (hdc,fMono ? BLACKONWHITE : COLORONCOLOR);
   
           if (IsWindowEnabled(hwnd))
           {
               StretchBlt(hdc,rc.left,rc.top,
                   rc.right  - rc.left,
                   rc.bottom - rc.top,
                   hdcBits,0,0,
                   bm.bmWidth,bm.bmHeight, SRCCOPY);
           }
           else
           {
               SetBkColor(hdc,rgbWhite);
               SetTextColor(hdc,rgbBlack);
               SelectObject(hdc,hbrGray);
               StretchBlt(hdc,rc.left,rc.top,
                   rc.right  - rc.left,
                   rc.bottom - rc.top,
                   hdcBits,0,0,
                   bm.bmWidth,bm.bmHeight, DPSoa);
           }
           DeleteDC(hdcBits);
        }
    }

    RestoreDC(hdc, -1);
}

/*
 *  using the first pixel as the "transparent" color, make all pixels
 *  in the hdc that are equal to the "transparent" color the passed
 *  color.
 */
PRIV VOID  BitmapColorTranslate(HDC hdcBits, BITMAP* pbm, DWORD rgb)
{
    HDC     hdcMask;
    HBITMAP hbmMask, hbmT;
    HBRUSH  hbrT;
    BOOL    fMono;

    /*
     * is the bitmap mono, or the first pixel is already equal to the
     * passed color?  if so we have nothing to do.
     */

    fMono = pbm->bmPlanes == 1 && pbm->bmBitsPixel == 1;
    if (fMono || GetPixel(hdcBits, 0, 0) == rgb)
        return;

    // create a mask bitmap and associated DC

    if ((hbmMask = CreateBitmap(pbm->bmWidth, pbm->bmHeight, 1, 1, NULL)))
    {
        hdcMask = CreateCompatibleDC(hdcBits);

        // select the mask bitmap into the mono DC

        hbmT = SelectObject(hdcMask, hbmMask);

        // create the brush and select it into the bits DC

        hbrT = SelectObject(hdcBits, CreateSolidBrush(rgb));

        // do a color to mono bitblt to build the mask
        // generate 1's where the source is equal to the background is
        if (hdcMask) {
           SetBkColor(hdcBits, GetPixel(hdcBits, 0, 0));
           BitBlt(hdcMask, 0, 0, pbm->bmWidth, pbm->bmHeight, hdcBits, 0, 0, SRCCOPY);
        
           // where the mask is 1 lay down the brush, where it is 0 leave the desitnation
   
           SetBkColor(hdcBits, rgbWhite);
           SetTextColor(hdcBits, rgbBlack);
           BitBlt(hdcBits, 0, 0, pbm->bmWidth, pbm->bmHeight, hdcMask, 0, 0, DSPDxax);
   
           DeleteObject(SelectObject(hdcBits, hbrT));
           DeleteObject(SelectObject(hdcMask, hbmT));
   
           DeleteDC(hdcMask);
        }
    }
}

/*******************
**
** Name:      NotifyParent
**
*******************/

PRIV VOID  NotifyParent(HWND hwnd)
{
    PostMessage(GetParent(hwnd),WM_COMMAND,MAKELONG(GetWindowLong(hwnd,GWL_ID),BN_CLICKED),(LONG_PTR)hwnd);
}

/*******************
**
** Name:      PatB
**
** Fast Solid color PatBlt() using ExtTextOut()
**
*******************/

PRIV VOID  PatB(HDC hdc,int x,int y,int dx,int dy, DWORD rgb)
{
    RECT    rc;

    SetBkColor(hdc,rgb);
    rc.left   = x;
    rc.top    = y;
    rc.right  = x + dx;
    rc.bottom = y + dy;

    ExtTextOut(hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);
}


/*
 *  LoadBitmapResource()
 *
 *  load a bitmap from a resource file that is specific to a device.
 *
 */
PRIV HBITMAP  LoadBitmapResource(HANDLE hInst, LPSTR lpName)
{
    char    szName[80];
    HBITMAP hbm;
    DWORD   nColors = 0;
    DWORD   dxScreen = 0;
    DWORD   dyScreen = 0;
    HDC     hdc;

    hdc = GetDC(NULL);

    if (hdc) {
    
       nColors  = GetDeviceCaps(hdc,NUMCOLORS);
       dxScreen = GetSystemMetrics(SM_CXSCREEN);
       dyScreen = GetSystemMetrics(SM_CYSCREEN);
   
       ReleaseDC(NULL,hdc);
    }

    /* look for a resource of the form WxHxC */

    wsprintf(szName, "%s%dx%dx%d", lpName, dxScreen, dyScreen, nColors);

    hbm = LoadBitmap(hInst,szName);

    /* look for a resource of the form WxH */

    if (!hbm)
    {
        wsprintf(szName,"%s%dx%d", lpName, dxScreen, dyScreen);
        hbm = LoadBitmap(hInst,szName);
    }

    /* look for the default resource name */

    if (!hbm)
    {
        hbm = LoadBitmap(hInst,lpName);
    }

    return hbm;
}


#if 0

/*******************
**
** Name:      FindGray
**
** Purpose:   Responsible for finding (if possible) a dark gray
**            on the curent device.
**
** Arguments: rgb   - value for gray
**
** Returns:   RGB value for dark gray
**
*******************/

DWORD  FindGray(DWORD rgb)
{
    int r,g,b;
    HDC hdc;

    hdc = GetDC(NULL);

    rgb == NearestColor(hdc,rgb);

    r = GetRValue(rgb);
    g = GetGValue(rgb);
    b = GetBValue(rgb);

    while ((r>0 || g>0 || b>0) && rgb == NearestColor(hdc,RGB(r,g,b)))
    {
        if (r > 0) r -= 63;
        if (g > 0) g -= 63;
        if (b > 0) b -= 63;
    }

    rgb = NearestColor(hdc,RGB(r,g,b));

    ReleaseDC(NULL,hdc);
    return rgb;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\rtf.h ===
/*****************************************************************************
*                                                                            *
*  RTF.H								     *
*                                                                            *
*  Copyright (C) Microsoft Corporation 1988.                                 *
*  All Rights reserved.                                                      *
*                                                                            *
******************************************************************************
*                                                                            *
*  Program Description:                                                      *
*                                                                            *
******************************************************************************
*                                                                            *
*  Revision History:  Created 12/12/88 by Robert Bunney                      *
*		      Ported to a simple windows parser 02/14/89 ToddLa      *
*                                                                            *
*                                                                            *
******************************************************************************/

#define PUBLIC
#if DBG
#define PRIVATE
#else
#define PRIVATE static
#endif

BOOL  PUBLIC rtfPaint         (HDC hdc, LPRECT lprc, LPSTR qch);
DWORD PUBLIC rtfGetTextExtent (HDC hdc, LPSTR qch);
BOOL  PUBLIC rtfInit          (HANDLE hInst);
BOOL  PUBLIC rtfFaceName      (HWND hwnd, LPSTR qch);

LONG APIENTRY rtfWndProc(HWND hwnd, UINT msg, WPARAM wParam, LONG lParam);


#define RTF_SETHANDLE	    (WM_USER + 1)
#define RTF_GETHANDLE	    (WM_USER + 2)
#define RTF_SETDEFFACE      (WM_USER + 3)
#define RTF_SETDEFSIZE      (WM_USER + 4)
#define RTF_SETDEFFG        (WM_USER + 5)
#define RTF_SETDEFBG        (WM_USER + 6)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\sbutton.h ===
/*****************************************************************************
*                                                                            *
*  SBUTTON.C                                                                 *
*                                                                            *
*  Program Description: Implements "3-D" buttons                             *
*                                                                            *
******************************************************************************
*                                                                            *
*  Revision History:  Created by Todd Laney, Munged 3/27/89 by Robert Bunney *
*                     7/26/89  - revised by Todd Laney to handle multi-res   *
*                                bitmaps.  transparent color bitmaps         *
*                                windows 3 support                           *
*                                                                            *
*****************************************************************************/

/*
 *  WINDOW CLASS "sbutton"
 *
 *  Button ControlInit() registers a button class called "sbutton".
 *  a "sbutton" behaves exactly like a normal windows push button, with the
 *  following enhancments:
 *
 *  3D-PUSH effect.
 *
 *  COLORS:
 *
 *      The folowing colors will be read from WIN.INI to be used as the
 *      button colors. (under Win3 the approp. SYS colors will be used.)
 *
 *      [colors]
 *          ButtonText
 *          ButtonFace
 *          ButtonShadow
 *          ButtonFocus
 *
 *
 *  BITMAPS:
 *      if the window text of the button begins with a '#' and the string
 *      following names a bitmap resource, the bitmap will be displayed as
 *      the button.
 *
 *      bitmap can have color res specific versions in the resource file.
 *
 *      if the button name is "#%foo" bitmap resources will be searched
 *      for in the following order:
 *
 *          fooWxHxC
 *          fooWxH
 *          foo
 *
 *          W is the width in pixels of the current display
 *          H is the height in pixels of the current display
 *          C is the number of colors of the current display
 *
 *      for example a EGA specific resource would be named "foo640x350x8"
 *
 *      The first pixel of color bitmap's will be used as the "transparent"
 *      color.  All pixels that match the transparent color will be set
 *      equal to the button face color
 *
 *  BUTTON STYLES:
 *      BS_STRETCH    - stretch bitmaps to fit button
 *      BS_NOFOCUS    - dont steal focus on mouse messages
 *
 */

#define BS_STRETCH  0x8000L
#define BS_NOFOCUS  0x4000L


//
//  Init routine, will register class "sbutton" and "stext"
//
BOOL
ButtonControlInit(
    HANDLE hInst
    );

VOID
ButtonControlTerm(
    VOID
    );

//
// Window proc for buttons, THIS FUNCTION MUST BE EXPORTED
//
LRESULT APIENTRY fnButton (HWND, UINT, WPARAM, LPARAM);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\secur.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    security.h

Abstract:

    Internal security routine prototypes


Author:

    Sunil Pai (sunilp) April 1992

--*/


NTSTATUS
SetupGenerateUniqueSid(
    IN ULONG Seed,
    OUT PSID *Sid
    );

VOID
SetupLsaInitObjectAttributes(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService
    );

BOOL
HUserKeyToProfilePath(
    IN  HKEY       hUserKey,
    OUT LPSTR      lpProfilePath,
    IN OUT LPDWORD lpcbProfilePath
    );

PSID
CreateSidFromSidAndRid(
    PSID    DomainSid,
    ULONG   Rid
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\search.c ===
#include "precomp.h"
#pragma hdrstop
/* File: search.c */
/**************************************************************************/
/*  file search functions
/**************************************************************************/


extern PSTR LOCAL_SOURCE_DIRECTORY;

//*******************************************************************
//
//                          Exe Info
//
//*******************************************************************


typedef enum _EXETYPE {
    EXE_WIN16,
    EXE_WIN32,
    EXE_DOS,
    EXE_DUNNO
} EXETYPE;

#define EXE_WIN16_SZ    "WIN16"
#define EXE_WIN32_SZ    "WIN32"
#define EXE_DOS_SZ      "DOS"
#define EXE_DUNNO_SZ    NULL

typedef struct _EXEINFO *PEXEINFO;
typedef struct _EXEINFO {
    EXETYPE     ExeType;
    SZ          szExeType;
    SZ          szDescr;
} EXEINFO;

PEXEINFO
ExeInfoAlloc(
    SZ  szPath,
    SZ  szFile
    );

BOOL
FExeInfoInit(
    PEXEINFO    pExeInfo,
    SZ          szPath,
    SZ          szFile
    );

BOOL
FIsExeOrCom(
    SZ          szFile
    );

BOOL
FIsCom(
    SZ          szFile
    );

BOOL
FIsWin16(
    HANDLE              Handle,
    PIMAGE_DOS_HEADER   pDosHeader,
    PIMAGE_OS2_HEADER   pOs2Header
    );

BOOL
FFapi(
    HANDLE              Handle,
    PIMAGE_OS2_HEADER   pOs2Header,
    DWORD               dwOffset
    );

SZ
GetBaseName(
    SZ  szFile
    );

SZ
ReadWin16Descr(
    SZ                  szFile,
    HANDLE              Handle,
    PIMAGE_DOS_HEADER   pDosHeader,
    PIMAGE_OS2_HEADER   pOs2Header
    );

SZ
ReadWin32Descr(
    SZ                  szFile,
    HANDLE              Handle,
    PIMAGE_DOS_HEADER   pDosHeader,
    PIMAGE_NT_HEADERS   pNtHeader
    );

SZ
ReadDescr(
    HANDLE      Handle,
    DWORD       Offset,
    DWORD       Size
    );


VOID
ExeInfoFree(
    PEXEINFO    pInfo
    );


#define ExeInfoGetType(p)   ((p)->ExeType)
#define ExeInfoGetTypeSz(p) ((p)->szExeType)
#define ExeInfoGetDescr(p)  ((p)->szDescr)


//
//  Allocates an ExeInfo
//
PEXEINFO
ExeInfoAlloc(
    SZ  szPath,
    SZ  szFile
    )
{
    PEXEINFO    pExeInfo;

    if (pExeInfo = (PEXEINFO)SAlloc( sizeof(EXEINFO) )) {


        if ( !FExeInfoInit( pExeInfo, szPath, szFile ) ) {
            ExeInfoFree( pExeInfo );
            pExeInfo = NULL;
        }
    }

    return pExeInfo;
}

//
//  Initialize an ExeInfo
//
BOOL
FExeInfoInit(
    PEXEINFO    pExeInfo,
    SZ          szPath,
    SZ          szFile
    )

{

    HANDLE              Handle;
    BOOL                fOkay = fFalse;
    IMAGE_DOS_HEADER    DosHeader;
    IMAGE_OS2_HEADER    Os2Header;
    IMAGE_NT_HEADERS    NtHeader;
    DWORD               BytesRead;


    if ( !FIsExeOrCom(szFile) ) {
        pExeInfo->ExeType   = EXE_DOS;
        pExeInfo->szExeType = EXE_DOS_SZ;
        pExeInfo->szDescr   = GetBaseName( szFile );
        return fTrue;
    }


    //
    //  Initialize the pExeInfo so that it can be Freed up if something
    //  wrong happens.
    //
    pExeInfo->szDescr = NULL;


    //
    //  Open file
    //
    Handle = CreateFile( szPath,
                         GENERIC_READ,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         NULL,
                         OPEN_EXISTING,
                         0,
                         NULL );

    if ( Handle != INVALID_HANDLE_VALUE ) {

        //
        //  Read DOS header
        //
        if ( ReadFile( Handle, &DosHeader, sizeof(IMAGE_DOS_HEADER), &BytesRead, NULL ) &&
             (BytesRead == sizeof(IMAGE_DOS_HEADER)) &&
             (DosHeader.e_magic == IMAGE_DOS_SIGNATURE) ) {


            //
            // Read OS/2 header
            //
            if ( (SetFilePointer( Handle, DosHeader.e_lfanew, 0, FILE_BEGIN ) != -1)        &&
                 ReadFile( Handle, &Os2Header, sizeof(IMAGE_OS2_HEADER), &BytesRead, NULL ) &&
                 (BytesRead == sizeof(IMAGE_OS2_HEADER))                                    &&
                 FIsWin16( Handle, &DosHeader, &Os2Header )
               ) {

                //
                //  WIN16 EXE
                //
                pExeInfo->ExeType   = EXE_WIN16;
                pExeInfo->szExeType = EXE_WIN16_SZ;
                pExeInfo->szDescr   = ReadWin16Descr( szFile, Handle, &DosHeader, &Os2Header );
                fOkay = fTrue;


            } else if ( (SetFilePointer( Handle, DosHeader.e_lfanew, 0, FILE_BEGIN ) != -1)   &&
                         ReadFile( Handle, &NtHeader, sizeof(IMAGE_NT_HEADERS), &BytesRead, NULL ) &&
                         (BytesRead == sizeof(IMAGE_NT_HEADERS)) &&
                         (NtHeader.Signature == IMAGE_NT_SIGNATURE) ) {

                //
                //  Make sure that it is a WIN32 subsystem exe
                //

                if ( (NtHeader.FileHeader.SizeOfOptionalHeader >= IMAGE_SIZEOF_NT_OPTIONAL_HEADER) &&
                     ((NtHeader.OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_WINDOWS_GUI) ||
                      (NtHeader.OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_WINDOWS_CUI)) ) {


                    //
                    //  WIN32
                    //
                    pExeInfo->ExeType   = EXE_WIN32;
                    pExeInfo->szExeType = EXE_WIN32_SZ;
//                    pExeInfo->szDescr   = ReadWin32Descr( szFile, Handle, &DosHeader, &NtHeader );
                    pExeInfo->szDescr   = GetBaseName( szFile );
                    fOkay = fTrue;
                }

            } else {

                //
                //  Assume DOS
                //
                pExeInfo->ExeType   = EXE_DOS;
                pExeInfo->szExeType = EXE_DOS_SZ;
                pExeInfo->szDescr   = GetBaseName( szFile );
                fOkay = fTrue;
            }
        } else {
            //
            // Might be a DOS .com file, which wouldn't have an exe header on it.
            //
            if ( FIsCom(szFile) ) {
                pExeInfo->ExeType   = EXE_DOS;
                pExeInfo->szExeType = EXE_DOS_SZ;
                pExeInfo->szDescr   = GetBaseName( szFile );
                fOkay = fTrue;
            }
        }


        CloseHandle( Handle );

        if ( !fOkay ) {

            pExeInfo->ExeType   = EXE_DUNNO;
            pExeInfo->szExeType = EXE_DUNNO_SZ;
            pExeInfo->szDescr   = NULL;
            fOkay = fTrue;
        }
    }


    return fOkay;
}

//
//  Determines if the file is a Win16 app
//
BOOL
FIsWin16(
    HANDLE              Handle,
    PIMAGE_DOS_HEADER   pDosHeader,
    PIMAGE_OS2_HEADER   pOs2Header
    )
{

#define NE_TYPE(ne) (((BYTE *)(ne))[0x36])

    BOOL    fW16 = fFalse;

    if ( pOs2Header->ne_magic == IMAGE_OS2_SIGNATURE ) {

        switch ( NE_TYPE( pOs2Header ) ) {

        case 0:             // Unknown EXE type, may be a windows exe

              //
              // Assume this file is a Windows App iff:
              //     it has a "expected windows version" value or
              //     it test's FALSE as a FAPI app
              //
              if (pOs2Header->ne_expver != 0) {

                 fW16 = fTrue;

              } else {

                 fW16 = !FFapi( Handle, pOs2Header, pDosHeader->e_lfanew );
              }
              break;

        case 2:             // Windows EXE type
              fW16 = fTrue;
              break;

        default:            // Definitly NOT a windows EXE (DOS4 or OS/2)
              break;
        }
    }

    return fW16;
}

//
//  Determine if the app is FAPI
//
BOOL
FFapi(
    HANDLE              Handle,
    PIMAGE_OS2_HEADER   pOs2Header,
    DWORD               dwOffset
    )
{

#define szDOSCALLS  "DOSCALLS"
#define lenDOSCALLS 8

    char    buf[256];
    char   *pch;
    WORD   UNALIGNED *pw;
    int     n;
    int     i;
    BOOL    f = FALSE;
    DWORD   BytesRead;

    /*
     *	look through the imported module table for the name "DOSCALLS" if
     *	found the EXE is a FAPI app.
     *
     *  NOTE! assumes module table will fit in a 256 byte buffer
     */

    // make sure this doesn't point off the end of the buffer we will use

    if (pOs2Header->ne_modtab > sizeof(buf)) {
        return fFalse;
    }

    SetFilePointer( Handle, dwOffset, 0, FILE_BEGIN );
    ReadFile( Handle, buf, sizeof(buf), &BytesRead, NULL );

    pw = (WORD UNALIGNED *)(buf + pOs2Header->ne_modtab);

    for (i = 0; (unsigned)i < pOs2Header->ne_cmod; i++)
    {
        pch = buf + pOs2Header->ne_imptab + *pw++;

	if (pch > (buf + sizeof(buf)))	// be sure we don't go off the end
	    break;

        n = (int)*pch++;

	if (n == 0)
	    break;

    if ( (n == lenDOSCALLS) && !_strnicmp(szDOSCALLS,pch,lenDOSCALLS) )
	{
	    f = TRUE;
	    break;
	}
    }

    return f;
}


//
//  Obtains the base portion of a file name (i.e. no extension)
//
SZ
GetBaseName(
    SZ  szFile
    )
{
    SZ  szEnd;
    SZ  szLast;
    SZ  sz;
    CB  cbSize;

    szEnd = szLast = szFile + strlen( szFile ) - 1;

    //
    //  Look for last '.'
    //
    while ( (szEnd >= szFile) && (*szEnd != '.')) {
        szEnd--;
    }


    if ( szEnd < szFile ) {
        cbSize = (CB)(szLast - szFile);
    } else {
        cbSize = (CB)(szEnd - szFile);
    }


    if (sz = (SZ)SAlloc( cbSize+1 )) {

        memcpy( sz, szFile, cbSize );
        sz[cbSize] = '\0';
    }

    return sz;
}


//
//  Determines if a filename is COM
//
BOOL
FIsCom(
    SZ          szFile
    )
{
    SZ  szEnd;

    szEnd = szFile + strlen( szFile ) - 1;

    //
    //  Look for last '.'
    //
    while ( (szEnd >= szFile) && (*szEnd != '.')) {
        szEnd--;
    }


    if ( szEnd >= szFile ) {
        return (BOOL)( (CrcStringCompare( szEnd, ".COM" ) == crcEqual) );

    }

    return fFalse;
}

//
//  Determines if a filename is EXE or COM
//
BOOL
FIsExeOrCom(
    SZ          szFile
    )
{
    SZ  szEnd;

    szEnd = szFile + strlen( szFile ) - 1;

    //
    //  Look for last '.'
    //
    while ( (szEnd >= szFile) && (*szEnd != '.')) {
        szEnd--;
    }


    if ( szEnd >= szFile ) {
        return (BOOL)( (CrcStringCompare( szEnd, ".EXE" ) == crcEqual) ||
                       (CrcStringCompare( szEnd, ".COM" ) == crcEqual) );

    }

    return fFalse;
}


//
//  Gets a Win16 Description
//
SZ
ReadWin16Descr(
    SZ                  szFile,
    HANDLE              Handle,
    PIMAGE_DOS_HEADER   pDosHeader,
    PIMAGE_OS2_HEADER   pOs2Header
    )
{
    DWORD   DescrOff;
    BYTE    DescrSize;
    SZ      szDescr = NULL;
    DWORD   BytesRead;

    UNREFERENCED_PARAMETER( pDosHeader );

    //
    //  Try to get description (first entry in nonresident table).
    //
    DescrOff = pOs2Header->ne_nrestab;

    if ( !(SetFilePointer( Handle, DescrOff, 0, FILE_BEGIN) != -1)                  ||
         !ReadFile( Handle, &DescrSize, sizeof(BYTE), &BytesRead, NULL )            ||
         !(BytesRead == sizeof(BYTE))                                               ||
         !(szDescr = ReadDescr( Handle, DescrOff+1, (DWORD)DescrSize ))
       ) {

        //
        //  Could not get description, try to get module name
        //  (first entry in resident table).
        //
        DescrOff = pOs2Header->ne_restab;

        if ( !(SetFilePointer( Handle, DescrOff, 0, FILE_BEGIN) != -1)                   ||
             !ReadFile( Handle, &DescrSize, sizeof(BYTE), &BytesRead, NULL )             ||
             !(BytesRead == sizeof(BYTE))                                                ||
             !(szDescr = ReadDescr( Handle, DescrOff+1, (DWORD)DescrSize ))
           ) {

            //
            //  Could not get module name, use file base name.
            //
            szDescr = GetBaseName( szFile );
        }
    }

    return szDescr;
}


#if 0
//
//  Get Win32 Description
//
SZ
ReadWin32Descr(
    SZ                  szFile,
    HANDLE              Handle,
    PIMAGE_DOS_HEADER   pDosHeader,
    PIMAGE_NT_HEADERS   pNtHeader
    )
{
    DWORD   DescrOff;
    DWORD   DescrSize;
    SZ      szDescr = NULL;

    UNREFERENCED_PARAMETER( pDosHeader );
    //
    //  Try to get the description
    //
    DescrOff  = pNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COPYRIGHT].VirtualAddress;
    DescrSize = pNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COPYRIGHT].Size;

    if ( !(szDescr = ReadDescr( Handle, DescrOff, DescrSize ) ) ) {

        //
        //  Could not get description, try to get module name.
        //
        //  BUGBUG: Where do we find the module name?
        //

        //
        //  Could not get module name, use file base name.
        //
        szDescr = GetBaseName( szFile );
    }

    return szDescr;
}
#endif


//
//  Reads a module description
//
SZ
ReadDescr(
    HANDLE      Handle,
    DWORD       Offset,
    DWORD       Size
    )

{
    SZ      szDescr = NULL;
    DWORD   BytesRead;
    size_t  SizeUsed;
    SZ      sz;


    if ( Size > 0 ) {

        if (szDescr = (SZ)SAlloc( Size+1 )) {

            //
            //  Read description
            //
            if ( (SetFilePointer( Handle, Offset, 0, FILE_BEGIN) != -1) &&
                 ReadFile( Handle, szDescr, Size, &BytesRead, NULL)     &&
                (BytesRead == Size) ) {

                //
                //  Get rid of padding blanks
                //
                sz = szDescr+Size-1;

                while ( (sz >= szDescr) &&
                        ( (*sz == ' ') || (*sz == '\t') ) ) {
                    sz--;
                }

                sz++;
                sz = '\0';
                SizeUsed = (size_t)(sz-szDescr);

                //
                //  If description has quotes or commas, or if it is longer
                //  than 26 characters, we don't want it.
                //
                if ( (SizeUsed > 25) ||
                     (strcspn( szDescr, """," ) >= SizeUsed)
                   ) {

                    SFree(szDescr);
                    szDescr = NULL;

                } else {

                    if ( (SizeUsed < Size) &&
                         (szDescr = SRealloc( szDescr, SizeUsed))) {

                        *(szDescr+SizeUsed) = '\0';
                    }
                }

            } else {

                SFree(szDescr);
                szDescr = NULL;
            }
        }
    }

    return szDescr;
}




//
//  Frees an Exe info
//
VOID
ExeInfoFree(
    PEXEINFO    pInfo
    )
{
    if ( pInfo->szDescr ) {
        SFree(pInfo->szDescr);
    }
    SFree(pInfo);
}





//*******************************************************************
//
//                         File List
//
//*******************************************************************

typedef struct _FILELIST *PFILELIST;
typedef struct _FILELIST {
    SYMTAB  SymTab;
} FILELIST;


PFILELIST
FileListAlloc(
    SZ  szFiles
    );

BOOL
FFileListInit(
    PFILELIST   pFileList
    );

VOID
FileListFree(
    PFILELIST   pFileList
    );

VOID
FileListDealloc(
    PFILELIST   pFileList
    );

BOOL
FFileInFileList(
    SZ          szFileName,
    PFILELIST   pFileList
    );

BOOL
FFileListAdd(
    SZ          szFileName,
    PFILELIST   pFileList
    );


//
//  Allocates a file list
//
PFILELIST
FileListAlloc(
    SZ  szFiles
    )
{
    BOOL        fOkay = fFalse;
    RGSZ        rgszFile;
    PFILELIST   pFileList = NULL;
    INT         iFile;

    if (rgszFile = RgszFromSzListValue( szFiles )) {

        if (pFileList = (PFILELIST)SAlloc( sizeof(FILELIST) )) {

            FFileListInit( pFileList );

            fOkay = fTrue;

            if ( rgszFile[0] ) {

                //
                //  Add files to FileList.
                //
                for ( iFile = 0; fOkay && rgszFile[iFile]; iFile++ ) {

                    if ( !(fOkay = FFileListAdd( rgszFile[iFile], pFileList ))) {

                        FileListFree( pFileList );
                        pFileList = NULL;
                    }
                }
            }
        }

        FFreeRgsz( rgszFile );
    }

    return pFileList;
}



//
//  Initializes a File list
//
BOOL
FFileListInit(
    PFILELIST   pFileList
    )
{
    USHORT      iHashBucket;

    for (iHashBucket = 0; iHashBucket < cHashBuckets; iHashBucket++) {
        pFileList->SymTab.HashBucket[iHashBucket] = NULL;
    }

    return fTrue;
}


//
//  Frees a file list
//
VOID
FileListFree(
    PFILELIST   pFileList
    )
{
    FileListDealloc( pFileList );
    SFree(pFileList);
}


//
//  Deallocates a file list
//
VOID
FileListDealloc (
    PFILELIST   pFileList
    )
{
    USHORT  iHashBucket;

    for (iHashBucket = 0; iHashBucket < cHashBuckets; iHashBucket++) {

        PSTE pste = pFileList->SymTab.HashBucket[iHashBucket];

        while (pste != (PSTE)NULL) {

            PSTE psteSav = pste->psteNext;

            FFreePste(pste);
            pste = psteSav;
        }
    }
}

//
//  Finds a file in a file list
//
BOOL
FFileInFileList(
    SZ          szFileName,
    PFILELIST   pFileList
)
{
    PPSTE       ppste;
    PSYMTAB     pSymTab = &(pFileList->SymTab);

    if ( szFileName && (szFileName[0] != '\0') ) {

        ppste = PpsteFindSymbol( pSymTab, szFileName );

        AssertRet(ppste != (PPSTE)NULL, fFalse);

        if (*ppste == (PSTE)NULL) {
            return fFalse;
        }

        AssertRet( (*ppste)->szSymbol != (SZ)NULL &&
                   *((*ppste)->szSymbol) != '\0' &&
                  (*ppste)->szValue != (SZ)NULL, fFalse);

        if (CrcStringCompare(szFileName, (*ppste)->szSymbol) != crcEqual) {
            return fFalse;
        }

        return fTrue;
    }

    return fFalse;
}




//
//  Adds a file to the file list
//
BOOL
FFileListAdd(
    SZ          szFileData,
    PFILELIST   pFileList
    )
{

    BOOL    fOkay = fFalse;
    PPSTE   ppste;
    SZ      szFile;
    SZ      szValue;
    PSYMTAB pSymTab = &(pFileList->SymTab);


    if ( szFileData ) {

        if ( (szFile = SzDupl(szFileData)) != NULL ) {

            SzStrUpper( szFile );

            if ( (szValue = SzDupl("")) != NULL ) {

                fOkay = fTrue;

            } else {

                SFree(szFile);
            }
        }
    }


    if ( fOkay ) {

        ppste = PpsteFindSymbol( pSymTab, szFile );

        if ( *ppste != NULL &&
             CrcStringCompare( (*ppste)->szSymbol, szFile) == crcEqual) {

            if ((*ppste)->szValue == NULL) {

                SFree(szFile);
                SFree(szValue);
                fOkay = fFalse;
                goto AddExit;
            }

            SFree((*ppste)->szValue);
            SFree(szFile);

            (*ppste)->szValue = NULL;

        } else {

            PSTE    pste;

            if ( (pste = PsteAlloc()) == NULL ) {

                SFree(szFile);
                SFree(szValue);
                fOkay = fFalse;
                goto AddExit;
            }

            pste->szSymbol = szFile;

#ifdef SYMTAB_STATS
            pSymTab->BucketCount[UsHashFunction(szFile)]++;
#endif

            pste->szValue  = NULL;
            pste->psteNext = *ppste;
            *ppste = pste;
        }

        (*ppste)->szValue = szValue;

    }

AddExit:

    return fOkay;
}





//*******************************************************************
//
//                         Search List
//
//*******************************************************************

typedef struct _SEARCHLIST *PSEARCHLIST;
typedef struct _SEARCHLIST {
    DWORD       dwPatterns;
    RGSZ        rgszPattern;
    FILELIST    FileList;
} SEARCHLIST;


PSEARCHLIST
SearchListAlloc(
    SZ  szFiles
    );

VOID
SearchListFree(
    PSEARCHLIST pList
    );

BOOL
FSearchListAddPattern(
    SZ          szPattern,
    PSEARCHLIST pSearchList
    );

BOOL
FFileInSearchList(
    SZ          szFileName,
    PSEARCHLIST pSearchList
    );


BOOL
FHasWildCard(
    SZ      szFile
    );


BOOL
FPatternMatch(
    SZ      szFile,
    SZ      szPattern
    );

//
//  Allocates a search list
//
PSEARCHLIST
SearchListAlloc(
    SZ  szFiles
    )
{
    BOOL        fOkay = fTrue;
    RGSZ        rgszFile;
    PSEARCHLIST pSearchList = NULL;
    INT         iFile;


    if (rgszFile = RgszFromSzListValue( szFiles )) {

        if ( rgszFile[0] != NULL ) {

            if (pSearchList = (PSEARCHLIST)SAlloc( sizeof(SEARCHLIST) )) {

                FFileListInit( &(pSearchList->FileList) );

                if ( pSearchList->rgszPattern = (RGSZ)SAlloc( sizeof(SZ) ) ) {

                    pSearchList->rgszPattern[0] = NULL;
                    pSearchList->dwPatterns     = 0;

                    //
                    //  Add files to FileList.
                    //
                    for ( iFile = 0; fOkay && rgszFile[iFile]; iFile++ ) {


                        //
                        //  If the file has wildcards, add it to the pattern list,
                        //  otherwise add it to the file list
                        //
                        if ( FHasWildCard( rgszFile[iFile] ) ) {

                            fOkay = FSearchListAddPattern( rgszFile[iFile], pSearchList );

                        } else {

                            fOkay = FFileListAdd( rgszFile[iFile], &(pSearchList->FileList) );

                        }

                        if (!fOkay) {

                            SearchListFree( pSearchList );
                            pSearchList = NULL;
                        }
                    }

                } else {

                    SFree(pSearchList);
                    pSearchList = NULL;
                }
            }
        }

        FFreeRgsz( rgszFile );
    }

    return pSearchList;
}


//
//  Frees a search list
//
VOID
SearchListFree(
    PSEARCHLIST pSearchList
    )
{
    FileListDealloc( &(pSearchList->FileList) );
    FFreeRgsz( pSearchList->rgszPattern );
    SFree(pSearchList);
}


//
//  Adds a pattern to the search list
//
BOOL
FSearchListAddPattern(
    SZ          szPattern,
    PSEARCHLIST pSearchList
    )
{
    SZ      sz;
    RGSZ    rgsz;
    BOOL    fOkay = fFalse;

    if (sz = SzDupl( szPattern )) {

        rgsz = (RGSZ)SRealloc( pSearchList->rgszPattern,
                                ((pSearchList->dwPatterns+2)*sizeof(SZ)));

        if ( rgsz ) {

            rgsz[pSearchList->dwPatterns]      = sz;
            rgsz[pSearchList->dwPatterns+1]    = NULL;

            pSearchList->rgszPattern = rgsz;
            pSearchList->dwPatterns++;

            fOkay = fTrue;

        } else {

            SFree(sz);
        }
    }

    return fOkay;
}



//
//  Determines if a file name is in the search list
//
BOOL
FFileInSearchList(
    SZ          szFileName,
    PSEARCHLIST pSearchList
    )
{
    INT i;

    if ( FFileInFileList( szFileName, &(pSearchList->FileList) ) ) {
        return fTrue;
    } else {

        for (i=0; pSearchList->rgszPattern[i]; i++ ) {

            if ( FPatternMatch( szFileName, pSearchList->rgszPattern[i] ) ) {
                return fTrue;
            }
        }
    }

    return fFalse;
}



//
//  Determines if a file name has a wildcard
//
BOOL
FHasWildCard(
    SZ      szFile
    )
{
    return (strcspn( szFile, "*?" ) < strlen( szFile ) );
}


BOOL
FPatternMatch(
    SZ      szFile,
    SZ      szPattern
    )
{
    switch (*szPattern) {
    case '\0':
        return ( *szFile == '\0' );
    case '?':
        return ( *szFile != '\0' && FPatternMatch (szPattern + 1, szFile + 1) );
    case '*':
        do {
        if (FPatternMatch (szPattern + 1, szFile))
                return fTrue;
        } while (*szFile++);
        return fFalse;
    default:
        return ( toupper (*szFile) == toupper (*szPattern) && FPatternMatch (szPattern + 1, szFile + 1) );
    }
}


//*******************************************************************
//
//                         Found List
//
//*******************************************************************


#define FOUNDLIST_INCR      32

typedef struct _FOUNDLIST *PFOUNDLIST;
typedef struct _FOUNDLIST {
    DWORD   Index;
    DWORD   Size;
    RGSZ    rgszList;
} FOUNDLIST;


PFOUNDLIST
FoundListAlloc(
    );

VOID
FoundListFree(
    PFOUNDLIST  pList
    );

BOOL
FoundListAdd(
    SZ          szFile,
    SZ          szDirectory,
    PEXEINFO    pExeInfo,
    PFOUNDLIST  pFoundList
    );

SZ
SzFromFoundList(
    PFOUNDLIST  pFoundList
    );


//
//  Initialize a Found List
//
PFOUNDLIST
FoundListAlloc(
    )
{
    PFOUNDLIST  pFoundList;

    if ( (pFoundList = (PFOUNDLIST)SAlloc( sizeof(FOUNDLIST) )) != NULL ) {

        if ( (pFoundList->rgszList = (RGSZ)SAlloc( FOUNDLIST_INCR * sizeof(SZ) )) != NULL ) {

            pFoundList->Index       = 0;
            pFoundList->Size        = FOUNDLIST_INCR;
            pFoundList->rgszList[0] = NULL;

        } else {

            SFree(pFoundList);
            pFoundList = (PFOUNDLIST)NULL;
        }
    }

    return pFoundList;
}


//
//  Free a found list
//
VOID
FoundListFree(
    PFOUNDLIST  pFoundList
    )
{
    RGSZ    rgszList;

    rgszList = (RGSZ)SRealloc( pFoundList->rgszList,
                                ((pFoundList->Index+1)*sizeof(SZ)));

    FFreeRgsz( rgszList );
    SFree(pFoundList);
}



//
//  Add and entry to the found list
//
BOOL
FoundListAdd (
    SZ          szFile,
    SZ          szDirectory,
    PEXEINFO    pExeInfo,
    PFOUNDLIST  pFoundList
    )
{
    BOOL    fOkay = fFalse;
    RGSZ    rgszEntry;
    RGSZ    rgszList;
    SZ      szEntry;

    if (rgszEntry = (RGSZ)SAlloc( 5 * sizeof(SZ) )) {

        rgszEntry[0] = szFile;
        rgszEntry[1] = szDirectory;
        rgszEntry[2] = ExeInfoGetTypeSz( pExeInfo );
        rgszEntry[3] = ExeInfoGetDescr( pExeInfo );
        rgszEntry[4] = NULL;

        if (szEntry = SzListValueFromRgsz( rgszEntry )) {

            if ( pFoundList->Index >= (pFoundList->Size - 1) ) {

                rgszList = (RGSZ)SRealloc( pFoundList->rgszList,
                                            ((pFoundList->Size+FOUNDLIST_INCR)*sizeof(SZ)));

                if ( rgszList ) {

                    pFoundList->Size    += FOUNDLIST_INCR;
                    pFoundList->rgszList = rgszList;
                    fOkay                = fTrue;
                }

            } else {

                fOkay = fTrue;
            }

            if ( fOkay ) {

                pFoundList->rgszList[pFoundList->Index++] = szEntry;
                pFoundList->rgszList[pFoundList->Index]   = NULL;

            } else {

                SFree(szEntry);
            }
        }

        SFree(rgszEntry);

    }

    return fOkay;
}


//
//  Get SZ from found list
//
SZ
SzFromFoundList(
    PFOUNDLIST  pFoundList
    )
{
    return SzListValueFromRgsz( pFoundList->rgszList );
}


//*******************************************************************
//
//                     Application Search
//
//*******************************************************************



extern  HWND    hwndFrame;

CHAR            GaugeText1[50];
CHAR            GaugeText2[50];
CHAR            GaugeText3[50];

WIN32_FIND_DATA FindData;
#define BARRANGE       30000



//
//  Local Prototypes
//
BOOL APIENTRY FSearchDirectoryList(
    RGSZ        rgszDirs,
    BOOL        fRecurse,
    BOOL        fSilent,
    PSEARCHLIST pSearchList,
    PFILELIST   pWin16Restr,
    PFILELIST   pWin32Restr,
    PFILELIST   pDosRestr,
    PFOUNDLIST  pFoundList
    );


BOOL APIENTRY FSearchDirectory(
    SZ          szDirectory,
    BOOL        fRecurse,
    BOOL        fSilent,
    PSEARCHLIST pSearchList,
    PFILELIST   pWin16Restr,
    PFILELIST   pWin32Restr,
    PFILELIST   pDosRestr,
    PFOUNDLIST  pFoundList,
    INT         Position,
    INT         Range,
    SZ          szDisplayBuffer
    );




//
//  Purpose:
//
//      Prepares for application search.
//
//  Arguments:
//
//      szInfVar        -   Where to put the result
//      szDirList       -   List of directories to search
//      fRecurse        -   Recursive flag
//      fSilent         -   Silent mode flag
//      szSearchList    -   List of files to search, can have wildcards
//      szWin16Restr    -   Win16 restriction list
//      szWin32Restr    -   Win32 restriction list
//      szDosRestr      -   Dos restriction list
//
//  Returns:
//
//      fTrue if success.
//
BOOL APIENTRY FSearchDirList(
    SZ      szInfVar,
    SZ      szDirList,
    BOOL    fRecurse,
    BOOL    fSilent,
    SZ      szSearchList,
    SZ      szWin16Restr,
    SZ      szWin32Restr,
    SZ      szDosRestr
    )
{
    BOOL        fOkay = fFalse;
    RGSZ        rgszDirs;
    PSEARCHLIST pSearchList;
    PFILELIST   pWin16Restr;
    PFILELIST   pWin32Restr;
    PFILELIST   pDosRestr;
    PFOUNDLIST  pFoundList;
    SZ          szResult;

    SetCursor(CurrentCursor = LoadCursor(NULL,IDC_WAIT));
    fSilent = (fSilent || fSilentSystem);

    if ( rgszDirs = RgszFromSzListValue( szDirList ) ) {

        if ( pSearchList = SearchListAlloc( szSearchList )) {

            if ( pWin16Restr = FileListAlloc( szWin16Restr ) ) {

                if ( pWin32Restr = FileListAlloc( szWin32Restr ) ) {

                    if ( pDosRestr = FileListAlloc( szDosRestr ) ) {

                        if ( pFoundList = FoundListAlloc() ) {


                            SetCursor(CurrentCursor = LoadCursor(NULL,IDC_ARROW));
                            fOkay = FSearchDirectoryList( rgszDirs,
                                                          fRecurse,
                                                          fSilent,
                                                          pSearchList,
                                                          pWin16Restr,
                                                          pWin32Restr,
                                                          pDosRestr,
                                                          pFoundList );

                            if ( fOkay ) {

                                if ( szResult = SzFromFoundList( pFoundList ) ) {

                                    while (!FAddSymbolValueToSymTab( szInfVar, szResult)) {

                                        if (!FHandleOOM(hwndFrame)) {

                                            fOkay = fFalse;
                                            break;

                                        }
                                    }

                                    SFree(szResult);

                                } else {

                                    fOkay = fFalse;
                                }
                            }

                            FoundListFree( pFoundList );
                        }

                        FileListFree( pDosRestr );
                    }

                    FileListFree( pWin32Restr );
                }

                FileListFree( pWin16Restr );
            }

            SearchListFree( pSearchList );
        }

        FFreeRgsz( rgszDirs );
    }

    return fOkay;
}





//
//  Purpose:
//
//      Performs the application search.
//
//  Arguments:
//
//      rgszDirs        -   List of directories to traverse
//      fRecurse        -   Recursive flag
//      fSilent         -   Silent mode flag
//      pSearchList     -   The list of files to search
//      pWin16Restr     -   List of Win16 restrictions
//      pWin32Restr     -   List of Win32 restrictions
//      pDosRestr       -   List of DOS restrictions
//      pFoundList      -   Found list
//
//  Returns:
//
//      fTrue if success.
//
BOOL APIENTRY FSearchDirectoryList(
    RGSZ        rgszDirs,
    BOOL        fRecurse,
    BOOL        fSilent,
    PSEARCHLIST pSearchList,
    PFILELIST   pWin16Restr,
    PFILELIST   pWin32Restr,
    PFILELIST   pDosRestr,
    PFOUNDLIST  pFoundList
    )
{

    DWORD   iDir;
    DWORD   cDirs;
    INT     SubRange;
    INT     Pos;
    CHAR    szDirectory[ cchlFullPathMax ];
    CHAR    szDisplayBuffer[cchlFullPathMax ];
    BOOL    fOkay = fTrue;

    //
    //  Figure out how many directories we have to traverse
    //
    for ( cDirs = 0, iDir = 0; rgszDirs[iDir] != NULL; iDir++ ) {
        if ( *rgszDirs[iDir] != '\0' ) {
            cDirs++;
        }
    }

    //
    //  Traverse the directories
    //
    if ( cDirs > 0 ) {

        if (!fSilent) {

            SZ  szText;

            ProOpen(hwndFrame, 0);
            ProSetBarRange(BARRANGE);
            ProSetBarPos(0);

            szText = SzFindSymbolValueInSymTab("ProText1");
            if (szText) {
               strcpy(GaugeText1, szText);
            }

            szText = SzFindSymbolValueInSymTab("ProText2");
            if (szText) {
               strcpy(GaugeText2, szText);
            }

            szText = SzFindSymbolValueInSymTab("ProText3");
            if (szText) {
               strcpy(GaugeText3, szText);
            }

            ProSetText(ID_STATUS1, GaugeText1);
            ProSetText(ID_STATUS4, "");
        }

        SubRange = BARRANGE/cDirs;
        Pos      = 0;


        //
        //  Do one directory at a time
        //
        for ( iDir = 0;
              fOkay && FYield() && !fUserQuit && (iDir < cDirs);
              iDir++ ) {

            SZ      szEnd;
            BOOL    fRecursive;

            strcpy( szDirectory, rgszDirs[iDir] );
            szEnd = szDirectory + strlen( szDirectory ) - 1;

            if ( ( (szEnd - szDirectory) >= 1)   &&
                 ( szDirectory[1] == ':'  ) &&
                 ( szDirectory[2] == '\0' ) ) {

                    fRecursive = fTrue;

            } else {

                fRecursive = fRecurse;
            }

            if ( *szEnd == '\\' ) {
                *szEnd = '\0';
            }


            fOkay = FSearchDirectory( szDirectory,
                                      fRecursive,
                                      fSilent,
                                      pSearchList,
                                      pWin16Restr,
                                      pWin32Restr,
                                      pDosRestr,
                                      pFoundList,
                                      Pos,
                                      SubRange,
                                      szDisplayBuffer );

            Pos += SubRange;
        }

        if (!fSilent) {
            ProSetBarPos(BARRANGE - 1);
            ProClose(hwndFrame);
        }
    }

    return fOkay;
}





//
//  Purpose:
//
//      Performs the application search in one directory
//
//  Arguments:
//
//      szDirectory     -   Directory to traverse
//      fRecurse        -   Recursive flag
//      fSilent         -   Silent mode flag
//      pSearchList     -   The list of files to search
//      pWin16Restr     -   List of Win16 restrictions
//      pWin32Restr     -   List of Win32 restrictions
//      pDosRestr       -   List of DOS restrictions
//      pFoundList      -   Found list
//      Position        -   Gauge initial position
//      Range           -   Gauge range
//      szDisplayBuffer -   Tmp buffer.
//
//  Returns:
//
//      fTrue if success.
//
BOOL APIENTRY FSearchDirectory(
    SZ          szDirectory,
    BOOL        fRecurse,
    BOOL        fSilent,
    PSEARCHLIST pSearchList,
    PFILELIST   pWin16Restr,
    PFILELIST   pWin32Restr,
    PFILELIST   pDosRestr,
    PFOUNDLIST  pFoundList,
    INT         Position,
    INT         Range,
    SZ          szDisplayBuffer
    )
{

    SZ          pFileName;
    HANDLE      FindHandle;
    BOOL        fOkay        = fTrue;
    INT         cDirectories = 0;
    INT         SubRange;
    INT         Pos;
    PEXEINFO    pExeInfo;
    BOOL        fAdd;

    if ( !szDirectory || szDirectory[0] == '\0' || szDirectory[0] == '.') {
        return fFalse;
    }

    //
    // catch local source directory -- don't want to find files in there!
    //
    if(!_strnicmp(szDirectory+2,LOCAL_SOURCE_DIRECTORY,lstrlen(LOCAL_SOURCE_DIRECTORY))) {
        return fTrue;
    }

    if (!fSilent) {
        wsprintf(szDisplayBuffer, "%s%s", GaugeText2, szDirectory );
        ProSetText(ID_STATUS2, szDisplayBuffer);
    }

    pFileName = szDirectory + strlen( szDirectory );
    SzStrCat( szDirectory, "\\*.*" );

    FindHandle = FindFirstFile( szDirectory, &FindData );

    if ( FindHandle != INVALID_HANDLE_VALUE ) {

        //
        //  Look at all files under this directory.
        //
        do {
            if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {

                //
                //  Increment the count of directories just in case we're interactive
                //  and we want to recurse.
                //
                if ( FindData.cFileName[0] != '.' ) {
                    cDirectories++;
                }

            } else {

                //
                //  If the file is in the search list, determine if we have to add it
                //  to the found list and if so add it.
                //
                SzStrUpper( FindData.cFileName );

                if ( FFileInSearchList( FindData.cFileName, pSearchList ) ) {

                    *pFileName = '\0';
                    SzStrCat( szDirectory, "\\" );
                    SzStrCat( szDirectory, FindData.cFileName );
                    if ( ((pExeInfo = ExeInfoAlloc( szDirectory, FindData.cFileName )) != NULL) ) {

                        switch( ExeInfoGetType( pExeInfo ) ) {

                            case EXE_WIN16:
                                //
                                //  We only add if not in Win16Restr
                                //
                                fAdd = !FFileInFileList( FindData.cFileName, pWin16Restr );
                                break;

                            case EXE_WIN32:
                                //
                                //  We only add if not in Win32Restr
                                //
                                fAdd = !FFileInFileList( FindData.cFileName, pWin32Restr );
                                break;

                            case EXE_DOS:
                                //
                                //  We only add if in DosRestr
                                //
                                fAdd = FFileInFileList( FindData.cFileName, pDosRestr );
                                break;

                            default:
                                fAdd = fFalse;
                                break;
                        }

                        if ( fAdd ) {

                            if (!fSilent) {
                                wsprintf(szDisplayBuffer, "%s%s", GaugeText3, FindData.cFileName );
                                ProSetText(ID_STATUS3, szDisplayBuffer);
                            }

                            *pFileName     = '\\';
                            *(pFileName+1) = '\0';
                            fOkay = FoundListAdd( FindData.cFileName, szDirectory, pExeInfo, pFoundList );
                        }


                        ExeInfoFree( pExeInfo );
                    }
                }
            }

        } while ( fOkay && FYield() && !fUserQuit && FindNextFile( FindHandle, &FindData ));

        FindClose( FindHandle );


        //
        //  Recurse thru all the subdirectories if the fRecurse flag is set.
        //
        if ( fOkay && fRecurse && !fUserQuit && (cDirectories > 0) ) {

            *pFileName = '\0';
            SzStrCat( szDirectory, "\\*.*" );

            FindHandle   = FindFirstFile( szDirectory, &FindData );

            if ( FindHandle != INVALID_HANDLE_VALUE ) {

                SubRange = Range/cDirectories;
                Pos      = Position;

                do {

                    if ( (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                        (FindData.cFileName[0] != '.') ) {

                        *pFileName      = '\\';
                        *(pFileName+1)  = '\0';
                        SzStrCat( szDirectory, FindData.cFileName );

                        fOkay = FSearchDirectory( szDirectory,
                                                  fRecurse,
                                                  fSilent,
                                                  pSearchList,
                                                  pWin16Restr,
                                                  pWin32Restr,
                                                  pDosRestr,
                                                  pFoundList,
                                                  Pos,
                                                  SubRange,
                                                  szDisplayBuffer );

                        Pos += SubRange;

                    }

                }  while ( fOkay && FYield() && !fUserQuit && FindNextFile( FindHandle, &FindData ));

                FindClose( FindHandle );
            }
        }
    }

    if ( !fSilent && (Range > 0) ) {
        ProSetBarPos( Position + Range - 1 );
    }

    //
    //  Restore original Directory name.
    //
    *pFileName = '\0';

    return fOkay;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\sc.c ===
#include "precomp.h"
#pragma hdrstop
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    sc.c

Abstract:

    This contains all the service controller functions.

Author:

    Sunil Pai (sunilp) December 1992

--*/


//
// Private function prototypes.
//
VOID
AddServiceToModifiedServiceList(
    IN LPSTR ServiceName
    );



BOOL
TestAdminWorker(
    )
/*++

Routine Description:

    Tests for admin privileges by opening the service control manager
    with read/write/execute access.  Note that this is not a conclusive
    test that setup can do whatever it wants.  There may still be
    operations which fail for lack of security privilege.

Arguments:

    None

Return value:

    Returns TRUE always.  ReturnTextBuffer has "YES" if the current process
    has administrative privileges, "NO" otherwise.

--*/
{
    SC_HANDLE hSC;

    hSC = OpenSCManager(
              NULL,
              NULL,
              GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE
              );

    if( hSC != NULL ) {
        SetReturnText( "YES" );
        CloseServiceHandle( hSC );
    }
    else {
        SetReturnText( "NO" );
    }

    return( TRUE );
}

BOOL
SetupCreateServiceWorker(
    LPSTR   lpServiceName,
    LPSTR   lpDisplayName,
    DWORD   dwServiceType,
    DWORD   dwStartType,
    DWORD   dwErrorControl,
    LPSTR   lpBinaryPathName,
    LPSTR   lpLoadOrderGroup,
    LPSTR   lpDependencies,
    LPSTR   lpServiceStartName,
    LPSTR   lpPassword
    )
/*++

Routine Description:

    Setupdll stub for calling CreateService.  If CreateService fails with
    the error code indicating that the service already exists, this routine
    calls the Setupdll stub for ChangeServiceConfig to ensure that the
    parameters passed in are reflected in the services database.

Arguments:

    lpServiceName      - Name of service

    lpDisplayName      - Localizable name of Service or ""

    dwServiceType      - Service type, e.g. SERVICE_KERNEL_DRIVER

    dwStartType        - Service Start value, e.g. SERVICE_BOOT_START

    dwErrorControl     - Error control value, e.g. SERVICE_ERROR_NORMAL

    lpBinaryPathName   - Full Path of the binary image containing service

    lpLoadOrderGroup   - Group name for load ordering or ""

    lpDependencies     - Multisz string having dependencies.  Any dependency
                         component having + as the first character is a
                         group dependency.  The others are service
                         dependencies.

    lpServiceStartName - Service Start name ( account name in which this
                         service is run ).

    lpPassword         - Password used for starting the service.


Return value:

    Returns TRUE if successful. FALSE otherwise.

    if TRUE then ReturnTextBuffer has "SUCCESS" else it has the error text
    to be displayed by the caller.

--*/
{
    SC_HANDLE hSC;
    SC_HANDLE hSCService;
    DWORD     dwTag, dw;
    BOOL      Status = TRUE;

    //
    // Open a handle to the service controller manager
    //

    hSC = OpenSCManager(
              NULL,
              NULL,
              SC_MANAGER_ALL_ACCESS
              );

    if( hSC == NULL ) {
        Status = FALSE;
        dw = GetLastError();
        KdPrint(("SETUPDLL: OpenSCManager Last Error Code: %x", dw));
        switch( dw ) {
        case ERROR_ACCESS_DENIED:
            SetErrorText( IDS_ERROR_PRIVILEGE );
            break;

        case ERROR_DATABASE_DOES_NOT_EXIST:
        case ERROR_INVALID_PARAMETER:
        default:
            SetErrorText( IDS_ERROR_SCOPEN );
            break;
        }
        return( Status );
    }


    //
    // Create the service using the parameters passed in.  Process the optional
    // "" parameters passed in and make them NULL.
    //

    hSCService = CreateService(
                     hSC,
                     lpServiceName,
                     lstrcmpi(lpDisplayName, "")      ? lpDisplayName      : NULL,
                     0,
                     dwServiceType,
                     dwStartType,
                     dwErrorControl,
                     lpBinaryPathName,
                     lstrcmpi(lpLoadOrderGroup, "")   ? lpLoadOrderGroup   : NULL,
                     lstrcmpi(lpLoadOrderGroup, "")   ? &dwTag             : NULL,
                     lpDependencies,
                     lstrcmpi(lpServiceStartName, "") ? lpServiceStartName : NULL,
                     lstrcmpi(lpPassword, "")         ? lpPassword         : NULL
                     );


    //
    // If we were unable to create the service, check if the service already
    // exists in which case all we need to do is change the configuration
    // parameters in the service.  If it is any other error return the error
    // to the inf
    //

    if( hSCService != NULL ) {

        //
        // Note that we won't do anything with the tag.  The person calling
        // this function will have to do something intelligently with the
        // tag.  Most of our services have tag values stored in the inf which
        // we will directly plop down into the registry entry created. Since
        // tags are not important for this boot, the fact that the service
        // controller has some tag and the registry entry may have a different
        // tag is not important.
        //
        //

        CloseServiceHandle( hSCService );

        //
        // Log this service name in our 'modified services' list.
        //
        AddServiceToModifiedServiceList(lpServiceName);

        SetReturnText( "SUCCESS" );
        Status = TRUE;

    }
    else {

        dw = GetLastError();

        if (dw == ERROR_SERVICE_EXISTS) {

            Status = SetupChangeServiceConfigWorker(
                         lpServiceName,
                         dwServiceType,
                         dwStartType,
                         dwErrorControl,
                         lpBinaryPathName,
                         lpLoadOrderGroup,
                         lpDependencies,
                         lpServiceStartName,
                         lpPassword,
                         lpDisplayName
                         );

        }
        else {

            KdPrint(("SETUPDLL: CreateService Last Error Code: %x", dw));
            //
            // process error returned
            //
            switch( dw ) {
            case ERROR_ACCESS_DENIED:
                SetErrorText( IDS_ERROR_PRIVILEGE );
                break;

            case ERROR_INVALID_HANDLE:
            case ERROR_INVALID_NAME:
            case ERROR_INVALID_SERVICE_ACCOUNT:
            case ERROR_INVALID_PARAMETER:
            case ERROR_CIRCULAR_DEPENDENCY:
            default:
                SetErrorText( IDS_ERROR_SCSCREATE );
                break;
            }

            Status = FALSE;
        }
    }

    CloseServiceHandle( hSC );
    return( Status );
}


BOOL
SetupChangeServiceStartWorker(
    LPSTR   lpServiceName,
    DWORD   dwStartType
    )

/*++

Routine Description:

    Routine to change the start value of a service.  This turns
    around and calls the setupdll stub to ChangeServiceConfig.

Arguments:

    lpServiceName      - Name of service

    dwStartType        - Service Start value, e.g. SERVICE_BOOT_START

Return value:

    Returns TRUE if successful. FALSE otherwise.

    if TRUE then ReturnTextBuffer has "SUCCESS" else it has the error text
    to be displayed by the caller.

--*/
{
    return( SetupChangeServiceConfigWorker(
                lpServiceName,
                SERVICE_NO_CHANGE,
                dwStartType,
                SERVICE_NO_CHANGE,
                "",
                "",
                NULL,
                "",
                "",
                ""
                ));
}




BOOL
SetupChangeServiceConfigWorker(
    LPSTR  lpServiceName,
    DWORD  dwServiceType,
    DWORD  dwStartType,
    DWORD  dwErrorControl,
    LPSTR  lpBinaryPathName,
    LPSTR  lpLoadOrderGroup,
    LPSTR  lpDependencies,
    LPSTR  lpServiceStartName,
    LPSTR  lpPassword,
    LPSTR  lpDisplayName
    )

/*++

Routine Description:

    Setupdll stub for ChangeServiceConfig.

Arguments:

    lpServiceName      - Name of service

    dwServiceType      - Service type, e.g. SERVICE_KERNEL_DRIVER

    dwStartType        - Service Start value, e.g. SERVICE_BOOT_START

    dwErrorControl     - Error control value, e.g. SERVICE_ERROR_NORMAL

    lpBinaryPathName   - Full Path of the binary image containing service

    lpLoadOrderGroup   - Group name for load ordering or ""

    lpDependencies     - Multisz string having dependencies.  Any dependency
                         component having + as the first character is a
                         group dependency.  The others are service
                         dependencies.

    lpServiceStartName - Service Start name ( account name in which this
                         service is run ).

    lpPassword         - Password used for starting the service.

    lpDisplayName      - Localizable name of Service or ""


Return value:

    Returns TRUE if successful. FALSE otherwise.

    if TRUE then ReturnTextBuffer has "SUCCESS" else it has the error text
    to be displayed by the caller.

--*/

{
    SC_LOCK   sclLock;
    SC_HANDLE hSC;
    SC_HANDLE hSCService;
    DWORD     dw;
    BOOL      Status = TRUE;

    //
    // Open a handle to the service controller manager
    //

    hSC = OpenSCManager(
              NULL,
              NULL,
              SC_MANAGER_ALL_ACCESS
              );

    if( hSC == NULL ) {
        Status = FALSE;
        dw = GetLastError();
        KdPrint(("SETUPDLL: OpenSCManager Last Error Code: %x", dw));
        switch( dw ) {
        case ERROR_ACCESS_DENIED:
            SetErrorText( IDS_ERROR_PRIVILEGE );
            break;
        case ERROR_DATABASE_DOES_NOT_EXIST:
        case ERROR_INVALID_PARAMETER:
        default:
            SetErrorText( IDS_ERROR_SCOPEN );
            break;
        }
        return( Status );
    }

    //
    // Try to lock the database, if possible.  if we are not able to lock
    // the database we will still modify the services entry.  this is because
    // we are just modifying a single service and chances are very low that
    // anybody else is manipulating the same entry at the same time.
    //

    sclLock = LockServiceDatabase( hSC );

    //
    // Open the service with SERVICE_CHANGE_CONFIG access
    //

    hSCService = OpenService(
                     hSC,
                     lpServiceName,
                     SERVICE_CHANGE_CONFIG
                     );

    if( hSCService != NULL ) {

        if( ChangeServiceConfig(
                hSCService,
                dwServiceType,
                dwStartType,
                dwErrorControl,
                lstrcmpi(lpBinaryPathName, "")   ? lpBinaryPathName   : NULL,
                lstrcmpi(lpLoadOrderGroup, "")   ? lpLoadOrderGroup   : NULL,
                NULL,
                lpDependencies,
                lstrcmpi(lpServiceStartName, "") ? lpServiceStartName : NULL,
                lstrcmpi(lpPassword, "")         ? lpPassword         : NULL,
                lstrcmpi(lpDisplayName, "")      ? lpDisplayName      : NULL
                ))
        {
            //
            // Log this service name in our 'modified services' list.
            //
            AddServiceToModifiedServiceList(lpServiceName);

            SetReturnText("SUCCESS");
        }
        else {
            dw = GetLastError();
            KdPrint(("SETUPDLL: ChangeServiceConfig Last Error Code: %x", dw));
            switch( dw ) {
            case ERROR_ACCESS_DENIED:
                SetErrorText( IDS_ERROR_PRIVILEGE );
                break;

            case ERROR_SERVICE_MARKED_FOR_DELETE:
                SetErrorText( IDS_ERROR_SERVDEL );
                break;

            case ERROR_INVALID_HANDLE:
            case ERROR_INVALID_SERVICE_ACCOUNT:
            case ERROR_INVALID_PARAMETER:
            case ERROR_CIRCULAR_DEPENDENCY:
            default:
                SetErrorText( IDS_ERROR_SCSCHANGE );
                break;
            }
            Status = FALSE;
        }

        CloseServiceHandle( hSCService );
    }
    else {
        dw = GetLastError();
        KdPrint(("SETUPDLL: OpenService Last Error Code: %x", dw));
        switch( dw ) {
        case ERROR_ACCESS_DENIED:
            SetErrorText( IDS_ERROR_PRIVILEGE );
            break;

        case ERROR_INVALID_HANDLE:
        case ERROR_INVALID_NAME:
        case ERROR_SERVICE_DOES_NOT_EXIST:
        default:
            SetErrorText( IDS_ERROR_SCSOPEN );
            break;
        }
        Status = FALSE;
    }


    //
    // Unlock the database if locked and then close the service controller
    // handle
    //


    if( sclLock != NULL ) {
        UnlockServiceDatabase( sclLock );
    }

    CloseServiceHandle( hSC );
    return( Status );

}

LPSTR
ProcessDependencyList(
    LPSTR lpDependenciesList
    )

/*++

Routine Description:

    This processes an LPSTR containing a list of dependencies {...}
    and converts it into a MULTI_SZ string.

Arguments:

    lpDependenciesList - List of dependencies. {blah, blah, ... }

Return value:

    Returns LPSTR containing a MULTI_SZ string which has the dependencies.
    NULL otherwise.  Caller should free the string after use.

--*/

{
    LPSTR lp = NULL;
    RGSZ  rgsz;
    PSZ   psz;
    SZ    sz;

    if ( !lstrcmpi( lpDependenciesList, "" ) ) {
        return( lp );
    }

    rgsz = RgszFromSzListValue( lpDependenciesList );
    if( rgsz ) {

        //
        // process GROUP_IDENTIFIER character
        //

        psz = rgsz;
        while( sz = *psz++ ) {
            if( *sz == '\\' ) {
                *sz = SC_GROUP_IDENTIFIER;
            }
        }

        //
        // Convert the rgsz into a multi sz
        //

        lp = RgszToMultiSz( rgsz );
        RgszFree( rgsz );
    }
    return ( lp );

}


DWORD
LegacyInfGetModifiedSvcList(
    IN  LPSTR SvcNameBuffer,
    IN  UINT  SvcNameBufferSize,
    OUT PUINT RequiredSize
    )
/*++

Routine Description:

    This routine is provided solely for use by the Device Installer APIs to be
    used immediately after installing a device via a legacy INF (i.e., using
    LegacyInfInterpret).  The Device Installer sets a variable, LEGACY_DODEVINSTALL,
    that causes the service modifications to be logged (the service names are
    written to a global multi-sz buffer).  If the legacy INF runs successfully,
    then the Device Installer calls this API to retrieve the list of services that
    were modified.  Upon successful completion of this call (i.e., the caller supplies
    us with a large enough buffer), we will free our list, and subsequent calls will
    return ERROR_NO_MORE_ITEMS.

Arguments:

    SvcNameBuffer - Supplies the address of the character buffer that will receive
        the list of service names.  If this parameter is NULL, then SvcNameBufferSize
        must be zero, and the call will fail with ERROR_INSUFFICIENT_BUFFER if there
        is a list to retrieve.

    SvcNameBufferSize - Supplies the size, in characters, of SvcNameBuffer.

    RequiredSize - Supplies the address of a variable that receives the size, in characters,
        required to store the service name list.

Return Value:

    If the function succeeds (i.e., there's a list to return, and the caller's buffer
    was big enough to hold it), the return value is NO_ERROR.

    If the function fails, the return value will be one of the following error codes:

        ERROR_NO_MORE_ITEMS : Either no services were modified during this INF run,
                              or the list has already been successfully retrieved via
                              this API.

        ERROR_INSUFFICIENT_BUFFER : The caller-supplied buffer was not large enough to
                                    hold the service name list.  In this case, 'RequiredSize'
                                    will contain the necessary buffer size upon return.

--*/
{
    //
    // If we don't have a service name list, then there's nothing to do.
    //
    if(!ServicesModified) {
        return ERROR_NO_MORE_ITEMS;
    }

    *RequiredSize = ServicesModifiedSize;

    if(ServicesModifiedSize > SvcNameBufferSize) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // OK, the caller's buffer is large enough to hold our list.  Store the list in their
    // buffer, and get rid of ours.
    //
    CopyMemory(SvcNameBuffer,
               ServicesModified,
               ServicesModifiedSize * sizeof(CHAR)
              );

    SFree(ServicesModified);
    ServicesModified = NULL;
    ServicesModifiedSize = 0;

    return NO_ERROR;
}


VOID
AddServiceToModifiedServiceList(
    IN LPSTR ServiceName
    )
/*++

Routine Description:

    This routine adds the specified service name to our global 'modified services' list,
    if it's not already in the list.

    This is only done if the global variable, !LEGACY_DODEVINSTALL, is set.

Arguments:

    ServiceName - Specifies the service name to be added to the list.

Return Value:

    None.

--*/
{
    LPSTR CurSvcName, TempPtr;
    DWORD ServiceNameLen, NewBufferSize;

    //
    // First, check to make sure that we're supposed to be logging service modifications.
    //
    if(!(TempPtr = SzFindSymbolValueInSymTab("!LEGACY_DODEVINSTALL")) ||
       lstrcmp(TempPtr, "YES")) {
        //
        // Then we weren't invoked by the Device Installer, so no logging should be done.
        //
        return;
    }

    //
    // Now, search through the existing list to see if this service name is already
    // present.
    //
    if(ServicesModified) {

        for(CurSvcName = ServicesModified;
            *CurSvcName;
            CurSvcName += lstrlen(CurSvcName) + 1) {

            if(!lstrcmpi(ServiceName, CurSvcName)) {
                //
                // The service is already in the list--nothing to do.
                //
                return;
            }
        }
    }

    //
    // The service wasn't already in the list.  Allocate/grow the buffer to accommodate
    // this new name.
    //
    ServiceNameLen = lstrlen(ServiceName);
    if(ServicesModified) {

        TempPtr = SRealloc(ServicesModified,
                           (NewBufferSize = ServicesModifiedSize + ServiceNameLen + 1) * sizeof(CHAR)
                          );

        if(TempPtr) {
            ServicesModified = TempPtr;
            lstrcpy(&(ServicesModified[ServicesModifiedSize-1]), ServiceName);
            ServicesModifiedSize = NewBufferSize;
            //
            // Now add extra terminating NULL at the end.
            //
            ServicesModified[ServicesModifiedSize-1] = '\0';
        }

    } else {
        if(ServicesModified = SAlloc((NewBufferSize = ServiceNameLen + 2) * sizeof(CHAR))) {

            ServicesModifiedSize = NewBufferSize;

            lstrcpy(ServicesModified, ServiceName);
            //
            // Now add extra terminating NULL at the end.
            //
            ServicesModified[ServiceNameLen+1] = '\0';
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\security.c ===
#include "precomp.h"
#pragma hdrstop
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    security.c

Abstract:

    Security related functions in the setupdll

    Detect Routines:

    1. GetUserAccounts.       Lists down all the user accounts in the system
    2. GetComputerName.       Finds the computer name.

    Install Routines Workers:

    1. CheckPrivilegeExistsWorker.
    2. EnablePrivilegeWorker.

    General Subroutines:

    1. AdjustPrivilege.
    2. RestorePrivilege.

Author:

    Sunil Pai (sunilp) April 1992

--*/


//
// Routines which are used to force deletion of a file by taking ownership
// of the file
//

BOOL
AssertTakeOwnership(
    HANDLE TokenHandle,
    PTOKEN_PRIVILEGES OldPrivs
    );

BOOL
GetTokenHandle(
    PHANDLE TokenHandle
    );



VOID
RestoreTakeOwnership(
    HANDLE TokenHandle,
    PTOKEN_PRIVILEGES OldPrivs
    );

BOOL
FForceDeleteFile(
    LPSTR szPath
    );



//======================
//  DETECT ROUTINES
//=======================

//
// Get current users account name
//

CB
GetMyUserName(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )
/*++

Routine Description:

    DetectRoutine for GetUserName. This finds out the username of
    the logged in account.

Arguments:

    Args   - C argument list to this detect routine (None exist)

    cArgs  - Number of arguments.

    ReturnBuffer - Buffer in which detected value is returned.

    cbReturnBuffer - Buffer Size.


Return value:

    Returns length of detected value.


--*/
{
    CHAR   UserName[MAX_PATH];
    CHAR   DomainName[MAX_PATH];
    DWORD  cbUserName = MAX_PATH;
    DWORD  cbDomainName = MAX_PATH;
    SID_NAME_USE peUse;
    BOOL   bStatus = FALSE;
    HANDLE hToken = NULL;

    TOKEN_USER *ptu = NULL;
    DWORD cbTokenBuffer = 0;

    CB     Length;

    #define DEFAULT_USERNAME ""

    Unused(Args);
    Unused(cArgs);
    Unused(cbReturnBuffer);


    if( !OpenProcessToken( GetCurrentProcess(), TOKEN_READ, &hToken ) ) {
        goto err;
    }

    //
    // Get space needed for process token information
    //

    if( !GetTokenInformation( hToken, TokenUser, (LPVOID)NULL, 0, &cbTokenBuffer) ) {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            goto err;
        }
    }

    //
    // Allocate space for token user information
    //

    if ( (ptu = (TOKEN_USER *)SAlloc(cbTokenBuffer)) == NULL ) {
        goto err;
    }

    //
    // Query token user information again
    //

    if( !GetTokenInformation( hToken, TokenUser, (LPVOID)ptu, cbTokenBuffer, &cbTokenBuffer) ) {
        goto err;
    }

    //
    // Query the user name and return it
    //

    if( LookupAccountSid( NULL, ptu->User.Sid, UserName, &cbUserName , DomainName, &cbDomainName, &peUse) ) {
        lstrcpy( ReturnBuffer, DomainName );
        lstrcat( ReturnBuffer, "\\" );
        lstrcat( ReturnBuffer, UserName );
        Length = lstrlen( ReturnBuffer ) + 1;
        bStatus = TRUE;
    }

err:

    if( !bStatus ) {
        lstrcpy( ReturnBuffer, DEFAULT_USERNAME );
        Length = lstrlen( DEFAULT_USERNAME ) + 1;
    }

    if( hToken != NULL ) {
        CloseHandle( hToken );
    }

    if( ptu ) {
        SFree( ptu );
    }

    return( Length );

}


//
//  Get User Accounts
//

CB
GetUserAccounts(
    IN  RGSZ    Args,
    IN  USHORT  cArgs,
    OUT SZ      ReturnBuffer,
    IN  CB      cbReturnBuffer
    )

/*++

Routine Description:

    DetectRoutine for UserAccounts.  This routine enumerates all the
    user accounts under HKEY_USERS and returns the <sid-string key, username>
    tuplet for every user found.  The detected value will have the
    following form:

    { {sid-string1, user-name1}, {sid-string2, user-name2} ... }

Arguments:

    Args   - C argument list to this detect routine (None exist)

    cArgs  - Number of arguments.

    ReturnBuffer - Buffer in which detected value is returned.

    cbReturnBuffer - Buffer Size.


Return value:

    Returns length of detected value.


--*/
{
    HKEY        hProfile, hSubKey;
    CHAR        SubKeyName[MAX_PATH];
    CHAR        UserName[MAX_PATH];
    CHAR        DomainName[MAX_PATH];
    CHAR        ProfilePath[MAX_PATH];
    CHAR        Class[MAX_PATH];
    DWORD       cbSubKeyName;
    DWORD       cbUserName;
    DWORD       cbDomainName;
    DWORD       cbProfilePath;
    DWORD       cbClass;
    FILETIME    FileTime;
    UINT        Index;
    LONG        Status;
    BOOL        bStatus;
    RGSZ        rgszUsers, rgszCurrent;
    SZ          sz;
    CB          Length;

    CHAR         UnknownUser[MAX_PATH];
    DWORD        UnknownUserNum;
    CHAR         UnknownUserChar[10];
    PSID         pSid;
    SID_NAME_USE peUse;

    Unused(Args);
    Unused(cArgs);
    Unused(cbReturnBuffer);

    #define     NO_ACCOUNTS "{}"


    //
    // Load the string to use as the unknown user string.  We will append
    // it with numbers
    //
    LoadString( MyDllModuleHandle, IDS_STRING_UNKNOWN_USER, UnknownUser, MAX_PATH );
    UnknownUserNum = 1;

    //
    // Enumerate keys under HKEY_USERS, for each user see if it is a
    // a .Default (reject this), get the sid value and convert the
    // sid to a user name.  Add the subkey (this is a sid-string) and
    // the username as an account.
    //

    //
    // Intialise users list to no users
    //

    rgszUsers = RgszAlloc(1);

    //
    // open the key to the profile tree
    //

    Status = RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 "Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",
                 0,
                 KEY_READ,
                 &hProfile
                 );

    if (Status == ERROR_SUCCESS) {

        //
        // Profile key exists, enumerate the profiles under this key
        //

        for ( Index = 0 ; ; Index++ ) {

            //
            // Get the current sub-key
            //

            cbSubKeyName  = MAX_PATH;
            cbClass       = MAX_PATH;
            cbUserName    = MAX_PATH;
            cbDomainName  = MAX_PATH;
            cbProfilePath = MAX_PATH;

            Status = RegEnumKeyEx(
                         hProfile,
                         Index,
                         SubKeyName,
                         &cbSubKeyName,
                         NULL,
                         Class,
                         &cbClass,
                         &FileTime
                         );

            if ( Status != ERROR_SUCCESS ) {
                break;
            }


            //
            // Open the subkey
            //

            Status = RegOpenKeyEx(
                         hProfile,
                         SubKeyName,
                         0,
                         KEY_READ,
                         &hSubKey
                         );

            if ( Status != ERROR_SUCCESS) {
                continue;
            }

            if( !lstrcmpi( SubKeyName, "THE_USER" ) ) {
                lstrcpy( UserName, "THE_USER" );
                goto skip_1;
            }

            //
            // Get the User name for this profile, by looking up the sid
            // value in the user key and then looking up the sid.
            //

            pSid = (PSID)GetValueEntry(
                             hSubKey,
                             "Sid"
                             );

            if (!pSid) {
                RegCloseKey( hSubKey );
                continue;
            }

            //
            // Convert the Sid into Username
            //

            bStatus = LookupAccountSid(
                          NULL,
                          pSid,
                          UserName,
                          &cbUserName,
                          DomainName,
                          &cbDomainName,
                          &peUse
                          );
            SFree( pSid );

            if( !bStatus ) {
                RegCloseKey( hSubKey );
                continue;
            }

            lstrcat( DomainName, "\\" );
            if(!lstrcmpi(UserName, "")) {
                lstrcat(DomainName, UnknownUser);
                _ultoa( UnknownUserNum,  UnknownUserChar, 10 );
                lstrcat(DomainName, UnknownUserChar);
                UnknownUserNum++;
            }
            else {
                lstrcat(DomainName, UserName);
            }

skip_1:

            //
            // Get the profilepath for this subkey, check to see if profilepath
            // exists
            //

            bStatus = HUserKeyToProfilePath(
                          hSubKey,
                          ProfilePath,
                          &cbProfilePath
                          );

            if( !bStatus ) {
                RegCloseKey( hSubKey );
                continue;
            }

            RegCloseKey( hSubKey );

            //
            // Form the list entry for this user
            //

            rgszCurrent    = RgszAlloc(4);
            rgszCurrent[0] = SzDup ( SubKeyName );
            rgszCurrent[1] = SzDup ( DomainName   );
            rgszCurrent[2] = SzDup ( ProfilePath );
            rgszCurrent[3] = NULL;

            //
            // Add this user to the list of users
            //

            sz = SzListValueFromRgsz( rgszCurrent );
            if ( sz ) {
                if( !RgszAdd ( &rgszUsers, sz ) ) {
                    SFree( sz );
                }
            }
            RgszFree ( rgszCurrent );

        }

        RegCloseKey( hProfile );
    }

    sz = SzListValueFromRgsz( rgszUsers );
    RgszFree( rgszUsers );

    if ( sz ) {
        lstrcpy( ReturnBuffer, sz );
        Length = lstrlen( sz ) + 1;
        SFree ( sz );
    }
    else {
        lstrcpy( ReturnBuffer, NO_ACCOUNTS );
        Length = lstrlen( NO_ACCOUNTS ) + 1;
    }

    return ( Length );
}




//========================
// INSTALL ROUTINE WORKERS
//========================

BOOL
CheckPrivilegeExistsWorker(
    IN LPSTR PrivilegeType
    )
/*++

Routine Description:

    Routine to determine whether we have a particular privilege

Arguments:

    PrivilegeType    - Name of the privilege to enable / disable

Return value:

    TRUE if CheckTakeOwnerPrivilege succeeds, FALSE otherwise.

    If TRUE:  ReturnTextBuffer has "YES" if privilege exists, "NO" otherwise.

    If FALSE: ReturnTextBuffer has error text.


--*/
{
    LONG              Privilege;
    TOKEN_PRIVILEGES  PrevState;
    ULONG             ReturnLength = sizeof( TOKEN_PRIVILEGES );

    if ( !lstrcmpi( PrivilegeType, "SeTakeOwnershipPrivilege" ) ) {
        Privilege = SE_TAKE_OWNERSHIP_PRIVILEGE;
    }
    else if ( !lstrcmpi( PrivilegeType, "SeSystemEnvironmentPrivilege" ) ) {
        Privilege = SE_SYSTEM_ENVIRONMENT_PRIVILEGE;
    }
    else {
        SetErrorText(IDS_ERROR_UNSUPPORTEDPRIV);
        return ( FALSE );
    }

    if (  AdjustPrivilege(
              Privilege,
              ENABLE_PRIVILEGE,
              &PrevState,
              &ReturnLength
              )
       ) {
        SetReturnText( "YES" );
        RestorePrivilege( &PrevState );
        return ( TRUE );
    }
    else {
        SetReturnText( "NO" );
        return ( TRUE );
    }
}


BOOL
EnablePrivilegeWorker(
    LPSTR PrivilegeType,
    LPSTR Action
    )
/*++

Routine Description:

    Install routine to enable / disable the SE_SYSTEM_ENVIRONMENT_PRIVILEGE

Arguments:

    PrivilegeType - Name of the privilege to enable / disable
    Action        - Whether to enable / disable

Return value:

    TRUE if Enable / Disable succeeds, FALSE otherwise.  ReturnTextBuffer
    gets initialised to error text if FALSE.


--*/
{

    ULONG                   Privilege;
    INT                     AdjustAction;


    if ( !lstrcmpi( PrivilegeType, "SeTakeOwnershipPrivilege" ) ) {
        Privilege = SE_TAKE_OWNERSHIP_PRIVILEGE;
    }
    else if ( !lstrcmpi( PrivilegeType, "SeSystemEnvironmentPrivilege" ) ) {
        Privilege = SE_SYSTEM_ENVIRONMENT_PRIVILEGE;
    }
    else {
        SetErrorText(IDS_ERROR_UNSUPPORTEDPRIV);
        return ( FALSE );
    }

    //
    // Check Arg[1] .. Whether to enable / disable
    //

    if (!lstrcmpi(Action, "ENABLE")) {
        AdjustAction = ENABLE_PRIVILEGE;
    }
    else if (!lstrcmpi(Action, "DISABLE")) {
        AdjustAction = DISABLE_PRIVILEGE;
    }
    else {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    if ( !AdjustPrivilege(
              Privilege,
              AdjustAction,
              NULL,
              NULL
              )
       ) {
        SetErrorText(IDS_ERROR_ADJUSTPRIVILEGE);
        return ( FALSE );
    }
    else {
        return ( TRUE );
    }
}


//======================================================================
//  General security subroutines
//======================================================================

BOOL
AdjustPrivilege(
    IN LONG PrivilegeType,
    IN INT  Action,
    IN PTOKEN_PRIVILEGES PrevState, OPTIONAL
    IN PULONG ReturnLength          OPTIONAL
    )
/*++

Routine Description:

    Routine to enable or disable a particular privilege

Arguments:

    PrivilegeType    - Name of the privilege to enable / disable

    Action           - ENABLE_PRIVILEGE | DISABLE_PRIVILEGE

    PrevState        - Optional pointer to TOKEN_PRIVILEGES structure
                       to receive the previous state of privilege.

    ReturnLength     - Optional pointer to a ULONG to receive the length
                       of the PrevState returned.

Return value:

    TRUE if succeeded, FALSE otherwise.

--*/
{
    NTSTATUS          NtStatus;
    HANDLE            Token;
    LUID              Privilege;
    TOKEN_PRIVILEGES  NewState;
    ULONG             BufferLength = 0;


    //
    // Get Privilege LUID
    //

    Privilege = RtlConvertLongToLuid(PrivilegeType);

    NewState.PrivilegeCount = 1;
    NewState.Privileges[0].Luid = Privilege;

    //
    // Look at action and determine the attributes
    //

    switch( Action ) {

    case ENABLE_PRIVILEGE:
        NewState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        break;

    case DISABLE_PRIVILEGE:
        NewState.Privileges[0].Attributes = 0;
        break;

    default:
        return ( FALSE );
    }

    //
    // Open our own token
    //

    NtStatus = NtOpenProcessToken(
                   NtCurrentProcess(),
                   TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                   &Token
                   );

    if (!NT_SUCCESS(NtStatus)) {
        return( FALSE );
    }

    //
    // See if return buffer is present and accordingly set the parameter
    // of buffer length
    //

    if ( PrevState && ReturnLength ) {
        BufferLength = *ReturnLength;
    }


    //
    // Set the state of the privilege
    //

    NtStatus = NtAdjustPrivilegesToken(
                   Token,                         // TokenHandle
                   FALSE,                         // DisableAllPrivileges
                   &NewState,                     // NewState
                   BufferLength,                  // BufferLength
                   PrevState,                     // PreviousState (OPTIONAL)
                   ReturnLength                   // ReturnLength (OPTIONAL)
                   );

    if ( NT_SUCCESS( NtStatus ) ) {

        NtClose( Token );
        return( TRUE );

    }
    else {

        NtClose( Token );
        return( FALSE );

    }
}


BOOL
RestorePrivilege(
    IN PTOKEN_PRIVILEGES PrevState
    )
/*++

Routine Description:

    To restore a privilege to its previous state

Arguments:

    PrevState    - Pointer to token privileges returned from an earlier
                   AdjustPrivileges call.

Return value:

    TRUE on success, FALSE otherwise

--*/
{
    NTSTATUS          NtStatus;
    HANDLE            Token;

    //
    // Parameter checking
    //

    if ( !PrevState ) {
        return ( FALSE );
    }

    //
    // Open our own token
    //

    NtStatus = NtOpenProcessToken(
                   NtCurrentProcess(),
                   TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                   &Token
                   );

    if (!NT_SUCCESS(NtStatus)) {
        return( FALSE );
    }


    //
    // Set the state of the privilege
    //

    NtStatus = NtAdjustPrivilegesToken(
                   Token,                         // TokenHandle
                   FALSE,                         // DisableAllPrivileges
                   PrevState,                     // NewState
                   0,                             // BufferLength
                   NULL,                          // PreviousState (OPTIONAL)
                   NULL                           // ReturnLength (OPTIONAL)
                   );

    if ( NT_SUCCESS( NtStatus ) ) {
        NtClose( Token );
        return( TRUE );
    }
    else {

        NtClose( Token );
        return( FALSE );
    }
}


BOOL
HUserKeyToProfilePath(
    IN  HKEY       hUserKey,
    OUT LPSTR      lpProfilePath,
    IN OUT LPDWORD lpcbProfilePath
    )
/*++

Routine Description:

    This finds out the ProfilePath corresponding to a user account key handle
    sees if the file exists and then returns the path to the profile.

Arguments:

    hUserKey        - Handle to a user account profile key

    lpProfilePath   - Pointer to a profile path buffer which will receive the
                      queried path.

    lpcbProfilePath - Pointer to the size of the profile path buffer.  Input
                      value is the size of the name buffer.  Output value is the
                      actual size of the username queried

Return value:

    Returns TRUE for success, FALSE for failure.  If TRUE lpProfilePath and
    lpcbProfilePath are initialized.

--*/
{
    LONG  Status;
    CHAR  szValue[ MAX_PATH ];
    DWORD dwSize = MAX_PATH;

    //
    // Get the profile path value
    //

    Status = RegQueryValueEx(
                 hUserKey,
                 "ProfileImagePath",
                 NULL,
                 NULL,
                 szValue,
                 &dwSize
                 );

    if( Status != ERROR_SUCCESS ) {
        return( FALSE );
    }

    *lpcbProfilePath = ExpandEnvironmentStrings(
                           (LPCSTR)szValue,
                           lpProfilePath,
                           *lpcbProfilePath
                           );

    //
    // Check if profile path exists
    //

    if ( FFileExist( lpProfilePath ) ) {

        return( TRUE );
    }
    else {

        return( FALSE );

    }

}


BOOL
FForceDeleteFile(
    LPSTR szPath
    )
{
    BOOL Result;
    SECURITY_DESCRIPTOR SecurityDescriptor;
    HANDLE TokenHandle;
    TOKEN_PRIVILEGES OldPrivs;
    PSID AliasAdminsSid = NULL;
    SID_IDENTIFIER_AUTHORITY    SepNtAuthority = SECURITY_NT_AUTHORITY;


    Result = AllocateAndInitializeSid(
                 &SepNtAuthority,
                 2,
                 SECURITY_BUILTIN_DOMAIN_RID,
                 DOMAIN_ALIAS_RID_ADMINS,
                 0,
                 0,
                 0,
                 0,
                 0,
                 0,
                 &AliasAdminsSid
                 );

    if ( !Result ) {
        return( FALSE );
    }

    Result = GetTokenHandle( &TokenHandle );

    if ( !Result ) {
        return( FALSE );
    }

    //
    // Create the security descritor with NULL DACL and Administrator as owner
    //

    InitializeSecurityDescriptor( &SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION );


    Result = SetSecurityDescriptorDacl (
                 &SecurityDescriptor,
                 TRUE,
                 NULL,
                 FALSE
                 );


    if ( !Result ) {
        CloseHandle( TokenHandle );
        return( FALSE );
    }

    Result = SetSecurityDescriptorOwner (
                 &SecurityDescriptor,
                 AliasAdminsSid,
                 FALSE
                 );

    if ( !Result ) {
        CloseHandle( TokenHandle );
        return FALSE;
    }


    //
    // Assert TakeOwnership privilege.
    //

    Result = AssertTakeOwnership( TokenHandle, &OldPrivs );

    if ( !Result ) {
        CloseHandle( TokenHandle );
        return FALSE;
    }

    //
    // Make Administrator the owner of the file.
    //

    Result = SetFileSecurity(
                 szPath,
                 OWNER_SECURITY_INFORMATION,
                 &SecurityDescriptor
                 );

    RestoreTakeOwnership( TokenHandle, &OldPrivs );

    if ( !Result ) {
        CloseHandle( TokenHandle );
        return( FALSE );
    }

    //
    // We are now the owner, put a benign DACL onto the file
    //

    Result = SetFileSecurity(
                 szPath,
                 DACL_SECURITY_INFORMATION,
                 &SecurityDescriptor
                 );

    if ( !Result ) {
        CloseHandle( TokenHandle );
        return( FALSE );
    }


    return( TRUE );
}





BOOL
GetTokenHandle(
    PHANDLE TokenHandle
    )
//
// This routine will open the current process and return
// a handle to its token.
//
// These handles will be closed for us when the process
// exits.
//
{

    HANDLE ProcessHandle;
    BOOL Result;

    ProcessHandle = OpenProcess(
                        PROCESS_QUERY_INFORMATION,
                        FALSE,
                        GetCurrentProcessId()
                        );

    if ( ProcessHandle == NULL ) {

        //
        // This should not happen
        //

        return( FALSE );
    }


    Result = OpenProcessToken (
                 ProcessHandle,
                 TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                 TokenHandle
                 );

    if ( !Result ) {

        //
        // This should not happen
        //

        return( FALSE );

    }

    return( TRUE );
}


BOOL
AssertTakeOwnership(
    HANDLE TokenHandle,
    PTOKEN_PRIVILEGES OldPrivs
    )
//
// This routine turns on SeTakeOwnershipPrivilege in the current
// token.  Once that has been accomplished, we can open the file
// for WRITE_OWNER even if we are denied that access by the ACL
// on the file.

{
    LUID TakeOwnershipValue;
    BOOL Result;
    TOKEN_PRIVILEGES TokenPrivileges;
    DWORD ReturnLength;


    //
    // First, find out the value of TakeOwnershipPrivilege
    //


    Result = LookupPrivilegeValue(
                 NULL,
                 "SeTakeOwnershipPrivilege",
                 &TakeOwnershipValue
                 );

    if ( !Result ) {

        //
        // This should not happen
        //

        return FALSE;
    }

    //
    // Set up the privilege set we will need
    //

    TokenPrivileges.PrivilegeCount = 1;
    TokenPrivileges.Privileges[0].Luid = TakeOwnershipValue;
    TokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;


    ReturnLength = sizeof( TOKEN_PRIVILEGES );

    (VOID) AdjustTokenPrivileges (
                TokenHandle,
                FALSE,
                &TokenPrivileges,
                sizeof( TOKEN_PRIVILEGES ),
                OldPrivs,
                &ReturnLength
                );

    if ( GetLastError() != NO_ERROR ) {

        return( FALSE );

    } else {

        return( TRUE );
    }

}

VOID
RestoreTakeOwnership(
    HANDLE TokenHandle,
    PTOKEN_PRIVILEGES OldPrivs
    )
{
    (VOID) AdjustTokenPrivileges (
                TokenHandle,
                FALSE,
                OldPrivs,
                sizeof( TOKEN_PRIVILEGES ),
                NULL,
                NULL
                );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\setupdll.c ===
#include "precomp.h"
#pragma hdrstop
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    setupdll.c

Abstract:

    This file continas the entrypoints for the Win32 Setup support DLL
    and common subroutines.

Author:

    Ted Miller (tedm) July 1991

--*/



#define RETURN_BUFFER_SIZE 1024
typedef DWORD  (APIENTRY *PFWNETPROC)();

CHAR ReturnTextBuffer[ RETURN_BUFFER_SIZE ];

BOOL
FForceDeleteFile(
    LPSTR szPath
    );

#ifdef CONTIG
// arg0 = drive (only first letter is signifiacnt)
// arg1 = file
BOOL
MakeFileContiguous(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    char     ActualDrive[4];
    char     ActualFile[13];

    *TextOut = ReturnTextBuffer;
    if(cArgs != 2) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    ActualDrive[0] = *Args[0];
    ActualDrive[1] = ':';
    ActualDrive[2] = '\\';
    ActualDrive[3] = '\0';

    memset(ActualFile,0,13);
    strncpy(ActualFile,Args[1],12);

    *ReturnTextBuffer = '\0';

    return(MakeContigWorker(ActualDrive,ActualFile));
}
#endif

#if 0
// arg0 = drive -- must be 'x:\'
// arg1 = filesystem ("FAT" or "HPFS")
// arg2 = file containing boot code
// arg3 = file for saving current boot sector
BOOL
LayBootCode(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    *TextOut = ReturnTextBuffer;
    if(cArgs != 4) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    *ReturnTextBuffer = '\0';

    return(LayBootCodeWorker(Args[0],Args[1],Args[2],Args[3]));
}
#endif


// arg0 = Variable name ( OSLOADPARTITION, OSLOADFILENAME, OSLOADOPTIONS)
// arg1 = Value to be set.

BOOL
SetNVRAMVar(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    *TextOut = ReturnTextBuffer;
    if(cArgs != 2) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    *ReturnTextBuffer = '\0';

    return(SetEnvironmentString(Args[0], Args[1]));
}


// arg0: fully qualified dos path

BOOL
DosPathToNtPath(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    CHAR NtPath[MAX_PATH];

    *TextOut = ReturnTextBuffer;
    if(cArgs != 1) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    if (!DosPathToNtPathWorker(*Args, NtPath)) {
        return (FALSE);
    }

    lstrcpy(ReturnTextBuffer, NtPath);

    return(TRUE);
}

// arg0: fully qualified dos path

BOOL
NtPathToDosPath(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    CHAR DosPath[MAX_PATH];

    *TextOut = ReturnTextBuffer;
    if(cArgs != 1) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    if (!NtPathToDosPathWorker(*Args, DosPath)) {
        return (FALSE);
    }

    lstrcpy(ReturnTextBuffer, DosPath);

    return(TRUE);
}

// arg0: fully qualified dos path

BOOL
DosPathToArcPath(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    CHAR ArcPath[MAX_PATH];

    *TextOut = ReturnTextBuffer;
    if(cArgs != 1) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    if (!DosPathToArcPathWorker(*Args, ArcPath)) {
        return (FALSE);
    }

    lstrcpy(ReturnTextBuffer, ArcPath);

    return(TRUE);
}

#if 0
// Change scsi(x) to scsi() because there is only ever one miniport
// driver loaded into ntldr.
// arg0: arc path to change.

BOOL
FixArcPathForBootIni(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    PCHAR p,q;

    *TextOut = ReturnTextBuffer;
    if(cArgs != 1) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    lstrcpy(ReturnTextBuffer,Args[0]);
    _strlwr(ReturnTextBuffer);

    if(p = strstr(ReturnTextBuffer,"scsi(")) {

        p += 5;         // p points to next char after scsi(

        if(q = strchr(p,')')) {

            memmove(p,q,lstrlen(q)+1);
        }
    }

    return(TRUE);
}
#endif


// arg0 = fully qualified arc path

BOOL
ArcPathToDosPath(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    CHAR DosName[MAX_PATH];

    *TextOut = ReturnTextBuffer;
    if(cArgs != 1) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    if (!ArcPathToDosPathWorker(*Args, DosName)) {
        return (FALSE);
    }

    lstrcpy(ReturnTextBuffer, DosName);

    return(TRUE);
}

//
// arg[0] Drive (X:)
//

BOOL
CheckDriveExternal(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    BOOL IsExternal;

    *TextOut = ReturnTextBuffer;
    if(cArgs != 1) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    if (!IsDriveExternalScsi(*Args, &IsExternal)) {
        return(FALSE);
    }

    lstrcpy(ReturnTextBuffer, IsExternal ? "YES" : "NO");

    return(TRUE);
}

// arg0 = filename
// arg2n+1 = original text string #n (n is 0-based)
// arg2n+2 = substitute text string #n (n is 0-based)

BOOL
ConfigFileSubst(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    *TextOut = ReturnTextBuffer;
    if((!(cArgs % 2)) || (cArgs == 1)) {
        SetErrorText(IDS_ERROR_BADARGS);         // if cArgs is even
        return(FALSE);
    }

    *ReturnTextBuffer = '\0';

    return(ConfigFileSubstWorker(Args[0],(cArgs-1)/2,&Args[1]));
}

// arg0 = filename
// arg2n+1 = original text string #n (n is 0-based)
// arg2n+2 = substitute text string #n (n is 0-based)
BOOL
BinaryFileSubst(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    *TextOut = ReturnTextBuffer;
    if((!(cArgs % 2)) || (cArgs == 1)) {
        SetErrorText(IDS_ERROR_BADARGS);         // if cArgs is even
        return(FALSE);
    }

    *ReturnTextBuffer = '\0';

    return(BinaryFileSubstWorker(Args[0],(cArgs-1)/2,&Args[1]));
}

// arg0 = filename
// argn = append text string #n (n >= 1)
BOOL
ConfigFileAppend(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    *TextOut = ReturnTextBuffer;
    if(cArgs == 1) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    *ReturnTextBuffer = '\0';

    return(ConfigFileAppendWorker(Args[0],cArgs-1,&Args[1]));
}


//
// arg0 = filename
//

BOOL
DelFile(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    OFSTRUCT          ReOpen;
    BOOL b;

    *TextOut = ReturnTextBuffer;
    if(cArgs != 1) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    *ReturnTextBuffer = '\0';

    //
    // If file doesn't exist then return true
    //

    if ( OpenFile(Args[0],&ReOpen,OF_EXIST) == -1 ) {
        SetReturnText("SUCCESS");
        return( TRUE );
    }

    //
    // Try to delete the file or force delete the file
    //
    if(b = SetFileAttributes(Args[0],FILE_ATTRIBUTE_NORMAL)) {
        b = DeleteFile(Args[0]);
    }
    if(!b) {
        if(FForceDeleteFile(Args[0])) {
            b = DeleteFile(Args[0]);
        }
    }

    SetReturnText(b ? "SUCCESS" : "FAILED");

    return( TRUE );
}

//
// arg0 = old filename
// arg1 = new filename
//

BOOL
RenFile(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{

    *TextOut = ReturnTextBuffer;
    if(cArgs != 2) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    *ReturnTextBuffer = '\0';

    return(MoveFile(Args[0],Args[1]));
}



//
// arg0 = source filename
// arg1 = destination filename
//

BOOL
CopySingleFile(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    BOOL bStatus;

    *TextOut = ReturnTextBuffer;
    if(cArgs != 2) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    *ReturnTextBuffer = '\0';

    bStatus = CopyFile( Args[0], Args[1], FALSE );
    if (!bStatus) {
        SetErrorText(IDS_ERROR_COPYFILE);
    }
    return (bStatus);

}


//
// arg0 = list
//

BOOL
SumListItems(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    LPSTR n,p;
    UINT  Sum,Number;

    *TextOut = ReturnTextBuffer;
    if(cArgs != 1) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }


    Sum = 0;

    p = Args[0];
    n = CharNext(p);

    while(n-p) {                // else *p was 0

        if(n-p == 1) {          // single byte char

            Number = 0;

            while((n-p == 1) && (*p >= '0') && (*p <= '9')) {

                Number = 10*Number + (UINT)(UCHAR)*p - (UINT)(UCHAR)'0';
                p = n;
                n = CharNext(p);
            }
            Sum += Number;
        }
        p = n;
        n = CharNext(p);
    }
    wsprintf(ReturnTextBuffer,"%d",Sum);
    return(TRUE);
}


// arg0 = YES for Reboot after Shutdown, NO for no Reboot.
BOOL
ShutdownSystem(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    BOOL Reboot, Status;
    LONG              Privilege = SE_SHUTDOWN_PRIVILEGE;
    TOKEN_PRIVILEGES  PrevState;
    ULONG             ReturnLength = sizeof( TOKEN_PRIVILEGES );


    *TextOut = ReturnTextBuffer;
    if(cArgs != 1) {
        SetErrorText(IDS_ERROR_BADARGS);         // if reboot indication not given
        return(FALSE);
    }

    *ReturnTextBuffer = '\0';

    if (!lstrcmpi(Args[0], "YES"))
       Reboot = TRUE;
    else if (!lstrcmpi(Args[0], "NO"))
       Reboot = FALSE;
    else
       return(FALSE);

    //
    // Enable the shutdown privilege
    //

    if ( !AdjustPrivilege(
              Privilege,
              ENABLE_PRIVILEGE,
              &PrevState,
              &ReturnLength
              )
       ) {

        SetErrorText( IDS_ERROR_PRIVILEGE );
        return( FALSE );
    }

    Status = ShutdownSystemWorker(Reboot);
    RestorePrivilege( &PrevState );
    if( !Status ) {
        SetErrorText( IDS_ERROR_SHUTDOWN );
    }
    return( Status );

}


// arg0 = string to check
BOOL
WhiteSpaceCheck(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    LPSTR p;
    BOOL  WhiteSpace;

    *TextOut = ReturnTextBuffer;
    if(cArgs != 1) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    for(WhiteSpace = FALSE, p = *Args; *p && !WhiteSpace; p++) {

        if(isspace((unsigned char)(*p))) {
            WhiteSpace = TRUE;
        }
    }

    lstrcpy(ReturnTextBuffer,WhiteSpace ? "YES" : "NO");


    return(TRUE);
}


// arg0 = string to check
BOOL
NetNameCheck(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    DWORD len = lstrlen(Args[0]);

    #define CTRL_CHARS_0   TEXT(    "\001\002\003\004\005\006\007")
    #define CTRL_CHARS_1   TEXT("\010\011\012\013\014\015\016\017")
    #define CTRL_CHARS_2   TEXT("\020\021\022\023\024\025\026\027")
    #define CTRL_CHARS_3   TEXT("\030\031\032\033\034\035\036\037")

    #define CTRL_CHARS_STR CTRL_CHARS_0 CTRL_CHARS_1 CTRL_CHARS_2 CTRL_CHARS_3
    #define ILLEGAL_NAME_CHARS_STR  TEXT("\"/\\[]:|<>+=;,?*") CTRL_CHARS_STR

    *TextOut = ReturnTextBuffer;
    if(cArgs != 1) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    //
    // Leading/trailing spaces are invalid.
    //

    lstrcpy(ReturnTextBuffer,
              (    (Args[0][0] != ' ')
                && (Args[0][len-1] != ' ')
                && (_mbscspn(Args[0],ILLEGAL_NAME_CHARS_STR) == _mbstrlen(Args[0]))
              )
            ? "YES"
            : "NO"
           );

    return(TRUE);
}



// arg0 = file to check for (may be a directory)

BOOL
CheckFileExistance(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    DWORD d;

    *TextOut = ReturnTextBuffer;
    if(cArgs != 1) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    d = GetFileAttributes(*Args);

    lstrcpy(ReturnTextBuffer,(d == (DWORD)(-1)) ? "NO" : "YES");

    return(TRUE);
}


// arg0 = config file to check.  This returns if it is a DOS config
//        or not.

BOOL
CheckConfigType(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    *TextOut = ReturnTextBuffer;
    if(cArgs != 1) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    lstrcpy(ReturnTextBuffer, CheckConfigTypeWorker( Args[0] ) ? "DOS" : "OS2");
    return ( TRUE );
}


//
// Create config.nt [and possibly autoexec.nt] for the Dos subsystem
//
// Args[0]:  Add on block for config.nt
// Args[1]:  Add on block for autoexec.nt


BOOL
VdmFixup(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    *TextOut = ReturnTextBuffer;
    if(cArgs != 2) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }
    *ReturnTextBuffer = '\0';

    return( VdmFixupWorker( Args[0], Args[1]) );
}


// arg0 = Remote name
// arg1 = Password
// arg2 = Local Name

BOOL
AddNetConnection(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    SZ         szPassword = NULL;

    *TextOut = ReturnTextBuffer;
    if(cArgs < 2) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    if(cArgs >= 3) {
        szPassword = Args[2];
    }

    return ( AddNetConnectionWorker( Args[0], szPassword, Args[1] ) );

}


//
// Arg[0]: Local Name
// Arg[1]: Force closure -- "TRUE" | "FALSE"
//

BOOL
DeleteNetConnection(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    *TextOut = ReturnTextBuffer;
    if(cArgs != 2) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }
    DeleteNetConnectionWorker( Args[0], Args[1] );
    return( TRUE );
}


//
// Args[0]: Printer Model       (eg QMS ..)
// Args[1]: Printer Environment (eg w32x86)
// Args[2]: Printer Driver      (eg pscript.dll)
// Args[3]: Printer Datafile    (eg QMS810.PPD)
// Args[4]: Printer Configfile  (eg PSCRPTUI.DLL)
//

BOOL
SetupAddPrinterDriver(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    SZ Server = NULL;

    *TextOut = ReturnTextBuffer;
    if(cArgs < 5) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }
    *ReturnTextBuffer = '\0';

    if( cArgs > 5 && (*(Args[5]) != '\0')) {
        Server = Args[5];
    }

    return(
        AddPrinterDriverWorker(
            Args[0],
            Args[1],
            Args[2],
            Args[3],
            Args[4],
            Server
            ) );
}




//
// Args[0]: Monitor Model       (eg QMS ..)
// Args[1]: Monitor Environment (eg w32x86)
// Args[2]: Monitor DLL     (eg pscript.dll)
//

BOOL
SetupAddPrinterMonitor(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    SZ Server = NULL;

    *TextOut = ReturnTextBuffer;
    if(cArgs < 3) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }
    *ReturnTextBuffer = '\0';

    if( cArgs > 3 && (*(Args[3]) != '\0')) {
        Server = Args[3];
    }

    return(
        AddPrinterMonitorWorker(
            Args[0],
            Args[1],
            Args[2],
            Server
            ) );
}

// Args[0]: Printer Name        (My Favorite Printer)
// Args[1]: Printer Port        (COM1..)
// Args[2]: Printer Driver      (e.g. HP LAserJet IIP)
// Args[3]: Printer Description (e.g. HP LasetJet IIP on COM1:)
// Args[4]: Printer Processor   (WINPRINT)
// Args[5]: Printer Attributes  (QUEUEDDEFAULT..)

BOOL
SetupAddPrinter(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    SZ Server = NULL;

    *TextOut = ReturnTextBuffer;
    if(cArgs < 6) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }
    *ReturnTextBuffer = '\0';

    if( cArgs > 6 && (*(Args[6]) != '\0')) {
        Server = Args[6];
    }

    return(
        AddPrinterWorker(
            Args[0],
            Args[1],
            Args[2],
            Args[3],
            Args[4],
            (DWORD)atoi(Args[5]),
            Server
            ) );
}


BOOL
AreCharsInString(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    *TextOut = ReturnTextBuffer;
    if(cArgs != 2) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    lstrcpy(ReturnTextBuffer,_mbspbrk(Args[0],Args[1]) ? "YES" : "NO");

    return(TRUE);
}

//
// Security related library functions
//

//
// 1. CheckPrivilegeExists <PrivilegeName>
//

BOOL
CheckPrivilegeExists(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    *TextOut = ReturnTextBuffer;
    if(cArgs != 1) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }
    *ReturnTextBuffer = '\0';

    return( CheckPrivilegeExistsWorker( Args[0] ) );
}

//
// 2. EnablePrivilege <Privilege> <ENABLE | DISABLE>
//

BOOL
EnablePrivilege(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    *TextOut = ReturnTextBuffer;
    if(cArgs != 2) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }
    *ReturnTextBuffer = '\0';

    return( EnablePrivilegeWorker( Args[0], Args[1] ) );
}


//
// 5. SetMyComputerName
//

BOOL
SetMyComputerName(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    *TextOut = ReturnTextBuffer;
    if(cArgs != 1) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }
    *ReturnTextBuffer = '\0';

    return( SetMyComputerNameWorker( Args[0] ) );
}


//
// DeleteAllConnections:  Remove all automatically created UNC uses.
//

BOOL
DeleteAllConnections(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    *TextOut = ReturnTextBuffer;
    *ReturnTextBuffer = '\0';

    DeleteAllConnectionsWorker();
    return TRUE ;
}



//
// Path related routines
//

BOOL
CheckPathFullPathSpec(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    BOOL  IsFullPath = FALSE;
    DWORD Length;

    *TextOut = ReturnTextBuffer;
    if(cArgs != 1) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    Length = lstrlen( Args[0] );
    if ( Length >= 2 && Args[0][1] == ':') {
        if( Length > 2 ) {
            if ( Args[0][2] == '\\' ) {
                IsFullPath = TRUE;
            }
        }
        else {
            IsFullPath = TRUE;
        }

    }

    lstrcpy(ReturnTextBuffer, IsFullPath ? "YES" : "NO");
    return(TRUE);
}

BOOL
AppendBackSlash(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    DWORD Length;

    *TextOut = ReturnTextBuffer;
    if(cArgs != 1) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    lstrcpy( ReturnTextBuffer, Args[0] );
    Length = lstrlen( Args[0] );

    if( Length == 0 || Args[0][Length - 1] != '\\' ) {
        lstrcat( ReturnTextBuffer, "\\" );
    }

    return( TRUE );
}

BOOL
ProcessForUNC(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    SZ    szPath;
    BOOL  IsUNC = FALSE;
    DWORD Attr;

    *TextOut = ReturnTextBuffer;
    if(cArgs != 1) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }
    szPath = Args[0];

    //
    // Check to see if UNC
    //

    if ( lstrlen( szPath ) > 4 &&
         szPath[0] == '\\'     &&
         szPath[1] == '\\'     &&
         szPath[2] != '\\'
       ) {
        IsUNC = TRUE;
    }

    if ( IsUNC ) {
        //
        // Check to see if UNC path exists.  if exists return Path
        // else return "UNC-FAILCONNECT"
        //
        if ((( Attr = GetFileAttributes(szPath) ) != 0xFFFFFFFF) &&
            (Attr & FILE_ATTRIBUTE_DIRECTORY )
           ) {
            lstrcpy ( ReturnTextBuffer, szPath );
        }
        else {
            lstrcpy ( ReturnTextBuffer, "UNC-FAILCONNECT" );
        }
    }
    else {
        lstrcpy ( ReturnTextBuffer, "NOT-UNC" );
    }
    return( TRUE );

}

//
// SetEnvVar <USER | SYSTEM> <ValueName> <ValueTitleIndex> <ValueType> <ValueData>
//

BOOL
SetEnvVar(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    *TextOut = ReturnTextBuffer;
    if(cArgs != 5) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    return( SetEnvVarWorker( Args[0], Args[1], Args[2], Args[3], Args[4] ) );

}


//
// ExpandSz <String>
//

BOOL
ExpandSz(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    *TextOut = ReturnTextBuffer;
    if(cArgs != 1) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    return( ExpandSzWorker( Args[0], ReturnTextBuffer, RETURN_BUFFER_SIZE ) );

}


BOOL
ShutdownRemoteSystem(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    INT nReturnCode;

    *TextOut = ReturnTextBuffer;
    if(cArgs != 5) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }


    nReturnCode = InitiateSystemShutdown(
                         Args[0],              // machinename
                         Args[1],              // shutdown message
                         (DWORD)atol(Args[2]),        // delay
                         !lstrcmpi(Args[3], "TRUE"),  // force apps close
                         !lstrcmpi(Args[4], "TRUE")   // reboot after shutdown
                         );

    return(TRUE);
}


//
// SERVICE CONTROLLER FUNCTIONS:
//
// - TestAdmin
// - SetupCreateService
// - SetupChangeServiceStart
// - SetupChangeServiceConfig
//

//
// TestAdmin: This tries to open the service controller with write access
//            and reports whether we have admin privileges in the services
//            area.
// (No Args)

BOOL
TestAdmin(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    *TextOut = ReturnTextBuffer;
    if(cArgs != 0) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    return( TestAdminWorker() );

}


//
// SetupCreateService: To create a service.  The parameters passed in are:
//
// arg0: lpServiceName
// arg1: lpDisplayName
// arg2: dwServiceType
// arg3: dwStartType
// arg4: dwErrorControl
// arg5: lpBinaryPathName
// arg6: lpLoadOrderGroup
// arg7: lpDependencies
// arg8: lpServiceStartName
// arg9: lpPassword
//

BOOL
SetupCreateService(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    LPSTR lpDependencies = NULL;
    BOOL  Status;

    *TextOut = ReturnTextBuffer;
    if(cArgs != 10) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    lpDependencies = ProcessDependencyList( Args[7] );
    Status = SetupCreateServiceWorker(
                 Args[0],
                 Args[1],
                 (DWORD)atol( Args[2] ),
                 (DWORD)atol( Args[3] ),
                 (DWORD)atol( Args[4] ),
                 Args[5],
                 Args[6],
                 lpDependencies,
                 Args[8],
                 Args[9]
                 );
    if( lpDependencies ) {
        SFree( lpDependencies );
    }
    return( Status );
}


//
// SetupChangeServiceStart: To just change the start value of the service
//
// arg0: lpServiceName
// arg1: dwStartType
//

BOOL
SetupChangeServiceStart(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    *TextOut = ReturnTextBuffer;
    if(cArgs != 2) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    return( SetupChangeServiceStartWorker(
                Args[0],
                (DWORD)atol( Args[1] )
                ) );

}


//
// SetupChangeServiceConfig: To change the parameters of an existing service.
// The parameters passed in are:
//
// arg0: lpServiceName,
// arg1: dwServiceType,
// arg2: dwStartType,
// arg3: dwErrorControl,
// arg4: lpBinaryPathName,
// arg5: lpLoadOrderGroup,
// arg6: lpDependencies,
// arg7: lpServiceStartName,
// arg8: lpPassword,
// arg9: lpDisplayName
//


BOOL
SetupChangeServiceConfig(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    LPSTR lpDependencies = NULL;
    BOOL  Status;

    *TextOut = ReturnTextBuffer;
    if(cArgs != 10) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    lpDependencies = ProcessDependencyList( Args[6] );
    Status = SetupChangeServiceConfigWorker(
                 Args[0],
                 (DWORD)atol(Args[1]),
                 (DWORD)atol(Args[2]),
                 (DWORD)atol(Args[3]),
                 Args[4],
                 Args[5],
                 lpDependencies,
                 Args[7],
                 Args[8],
                 Args[9]
                 );
    if( lpDependencies ) {
        SFree( lpDependencies );
    }
    return( Status );
}


BOOL
Delnode(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )

/*++

Routine Description:

    Perform a recusive deletion starting at a given directory.  All files
    and subdirectories are deleted.

Parameters:

    cArgs - supplies number of arguments. Must be 1, which is the directory
        to delnode.

    Args - supplies an argv-style array of parameters to this routine

    TextOut - receives address of buffer containing error text

Returns:

    FALSE if argc != 1.  TRUE otherwise.

--*/

{
    DWORD x;
    PCHAR Directory;


    *TextOut = ReturnTextBuffer;
    *ReturnTextBuffer = '\0';

    if(cArgs != 1) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    Directory = Args[0];

    //
    // If the given directory ends in \, remove the trailing \.
    //

    if(Directory[x=(lstrlen(Directory)-1)] == TEXT('\\')) {
        Directory[x] = 0;
    }

    DoDelnode(Directory);

    return(TRUE);
}


BOOL
SetCurrentLayout(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    *TextOut = ReturnTextBuffer;
    if(cArgs != 1) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    if( LoadKeyboardLayout(
                 Args[0],
                 KLF_ACTIVATE
                 ) != NULL
      ) {
        SetReturnText( "SUCCESS" );
    }
    else {
        SetReturnText( "FAILED" );
    }
    return( TRUE );
}



BOOL
SetCurrentLocale(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    *TextOut = ReturnTextBuffer;
    if(cArgs != 2) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    if( SetCurrentLocaleWorker( Args[0] , Args[1] ) ) {
        SetReturnText( "SUCCESS" );
    }
    return( TRUE );
}


//
// Error Text routine
//


VOID
SetErrorText(
    IN DWORD ResID
    )
{
    LoadString(MyDllModuleHandle,(WORD)ResID,ReturnTextBuffer,sizeof(ReturnTextBuffer)-1);
    ReturnTextBuffer[sizeof(ReturnTextBuffer)-1] = '\0';     // just in case
}


//
// Return Text Routine
//

VOID
SetReturnText(
    IN LPSTR Text
    )

{
    lstrcpy( ReturnTextBuffer, Text );
}



//
//  Return a list of indices for a sorted version of the given list.
//  See MISC.C for details.
//

BOOL
GenerateSortedIndexList (
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    BOOL bAscending, bCaseSens ;
    SZ szIndexList = NULL ;

    *TextOut = ReturnTextBuffer;
    if ( cArgs != 3 )
    {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    bAscending = lstrcmpi( Args[1], "TRUE" ) == 0 ;
    bCaseSens  = lstrcmpi( Args[2], "TRUE" ) == 0 ;

    szIndexList = GenerateSortedIntList( Args[0], bAscending, bCaseSens ) ;

    if ( szIndexList == NULL )
    {
        SetErrorText( IDS_ERROR_NO_MEMORY ) ;
        return FALSE ;
    }

    SetReturnText( szIndexList ) ;
    SFree( szIndexList ) ;

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\srcdescr.c ===
#include "precomp.h"
#pragma hdrstop



/*
**	Purpose:
**		Allocates a new SDLE record from memory.
**	Arguments:
**		none
**	Returns:
**		non-Null empty SDLE if successful; Null otherwise (OOM).
**
*********************************************************************/
PSDLE  APIENTRY PsdleAlloc()
{
	PSDLE psdle;

	if ((psdle = (PSDLE)SAlloc((CB)sizeof(SDLE))) != (PSDLE)NULL)
		{
		psdle->psdleNext = (PSDLE)NULL;
        psdle->did       = (DID)0;
        psdle->didGlobal = (DID)0;
		psdle->szLabel   = (SZ)NULL;
		psdle->szTagFile = (SZ)NULL;
		psdle->szNetPath = (SZ)NULL;
		}

	return(psdle);
}


/*
**	Purpose:
**		Frees a previously allocated SDLE record.
**	Arguments:
**		none
**	Returns:
**		fTrue if successful; fFalse otherwise.
**
*********************************************************************/
BOOL   APIENTRY FFreePsdle(PSDLE psdle)
{
	ChkArg(psdle != (PSDLE)NULL, 1, fFalse);

	if(psdle->szLabel) {
        SFree(psdle->szLabel);
    }

	if(psdle->szTagFile) {
	    SFree(psdle->szTagFile);
    }

    if(psdle->szNetPath) {
	    SFree(psdle->szNetPath);
    }

	SFree(psdle);

	return(fTrue);
}


/*
**	Purpose:
**		Finds the [Source Media Descriptions] section of the INF File, and
**		fills the Source Description List.
**	Arguments:
**		none
**	Notes:
**		Requires that the memory INF has been properly initialized.
**	Returns:
**		grcOkay if successful; grcOutOfMemory or grcINFSrcDescrSect otherwise.
**
*********************************************************************/
GRC APIENTRY GrcFillSrcDescrListFromInf()
{
    PPSDLE          ppsdle;
    GRC             grc = grcINFSrcDescrSect;
    RGSZ            rgsz = (RGSZ)NULL;
    SZ              szKey = (SZ)NULL;
    INT             Line;
    PINFPERMINFO    pPermInfo = pLocalInfPermInfo();

	PreCondInfOpen(grcNotOkay);

    EvalAssert(pPermInfo->psdleHead == (PSDLE)NULL ||
            FFreeSrcDescrList(pPermInfo));


    Assert(pPermInfo->psdleHead == (PSDLE)NULL &&
           pPermInfo->psdleCur == (PSDLE)NULL);

    ppsdle = &(pPermInfo->psdleHead);
    if((Line = FindFirstLineFromInfSection("Source Media Descriptions")) == -1)
		goto LSrcDescrErr;

	do  {
        UINT   cFields;
		USHORT iTag = 0, iNet = 0;
		DID    did;

        if (!FKeyInInfLine(Line) ||
                ((cFields = CFieldsInInfLine(Line)) != 1 &&
				 cFields != 4 &&
				 cFields != 7))
			goto LSrcDescrErr;

        if ((rgsz = RgszFromInfScriptLine(Line,cFields)) == (RGSZ)NULL ||
                (szKey = SzGetNthFieldFromInfLine(Line,0)) == (SZ)NULL)
			{
			grc = grcOutOfMemory;
			goto LSrcDescrErr;
			}

        if ((did = (DID)atoi(szKey)) < didMin ||
				did > didMost ||
                PsdleFromDid(did, pPermInfo) != (PSDLE)NULL)
			goto LSrcDescrErr;

		SFree(szKey);
		szKey = (SZ)NULL;

		if (cFields == 4 ||
				cFields == 7)
			{
			if (CrcStringCompare(rgsz[2], "=") != crcEqual)
				goto LSrcDescrErr;
			else if (CrcStringCompare(rgsz[1], "TAGFILE") == crcEqual)
				iTag = 3;
			else if (CrcStringCompare(rgsz[1], "NETPATH") == crcEqual)
				iNet = 3;
			else
				goto LSrcDescrErr;
			}

		if (cFields == 7)
			{
			if (CrcStringCompare(rgsz[5], "=") != crcEqual)
				goto LSrcDescrErr;
			else if (iTag == 0 &&
					CrcStringCompare(rgsz[4], "TAGFILE") == crcEqual)
				iTag = 6;
			else if (iNet == 0 &&
					CrcStringCompare(rgsz[4], "NETPATH") == crcEqual)
				iNet = 6;
			else
				goto LSrcDescrErr;

			Assert(iTag != 0 &&
					iNet != 0);
			}

		if ((*ppsdle = PsdleAlloc()) == (PSDLE)NULL ||
				((*ppsdle)->szLabel = SzDupl(rgsz[0])) == (SZ)NULL ||
				(iTag != 0 &&
				 ((*ppsdle)->szTagFile = SzDupl(rgsz[iTag])) == (SZ)NULL) ||
				(iNet != 0 &&
				 ((*ppsdle)->szNetPath = SzDupl(rgsz[iNet])) == (SZ)NULL))
			{
			grc = grcOutOfMemory;
			goto LSrcDescrErr;
			}

		SFree(rgsz);
		rgsz = (RGSZ)NULL;
        (*ppsdle)->did = did;

		ppsdle = &((*ppsdle)->psdleNext);
        Assert(pPermInfo->psdleHead != (PSDLE)NULL);
        pPermInfo->psdleCur = pPermInfo->psdleHead;
		Assert(*ppsdle == (PSDLE)NULL);
        } while ((Line = FindNextLineFromInf(Line)) != -1);

    pPermInfo->psdleCur     = pPermInfo->psdleHead;

	return(grcOkay);

LSrcDescrErr:
	if (szKey != (SZ)NULL)
		SFree(szKey);
	if (rgsz != (RGSZ)NULL)
		EvalAssert(FFreeRgsz(rgsz));
    EvalAssert(FFreeSrcDescrList(pPermInfo));

	return(grc);
}


/*
**	Purpose:
**		Frees each element in the Source Description List.
**	Arguments:
**		none
**	Returns:
**		fTrue if successful; fFalse otherwise.
**
*********************************************************************/
BOOL   APIENTRY FFreeSrcDescrList( PINFPERMINFO pPermInfo)
{
    while ((pPermInfo->psdleCur = pPermInfo->psdleHead) != (PSDLE)NULL)
		{
        pPermInfo->psdleHead = pPermInfo->psdleCur->psdleNext;
        EvalAssert(FFreePsdle(pPermInfo->psdleCur));
		}

	return(fTrue);
}


/*
**	Purpose:
**		Search for a corresponding Source Description List Element.
**	Arguments:
**		did: did to search for.
**	Notes:
**		Requires that the Source Description List was initialized with a
**		successful call to GrcFillSrcDescrListFromInf().
**	Returns:
**		non-Null SDLE if successful; Null otherwise (not in list).
**
*********************************************************************/
PSDLE  APIENTRY PsdleFromDid(DID did, PINFPERMINFO pPermInfo)
{
	ChkArg(did >= didMin &&
			did <= didMost, 1, (PSDLE)NULL);

    if (pPermInfo->psdleHead == (PSDLE)NULL)
		return((PSDLE)NULL);
    Assert(pPermInfo->psdleCur != (PSDLE)NULL);

    if (pPermInfo->psdleCur->did == did)
        return(pPermInfo->psdleCur);
	
    pPermInfo->psdleCur = pPermInfo->psdleHead;
    while (pPermInfo->psdleCur != (PSDLE)NULL && pPermInfo->psdleCur->did != did)
        pPermInfo->psdleCur = pPermInfo->psdleCur->psdleNext;
		
    return(pPermInfo->psdleCur);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\spfile.c ===
#include "precomp.h"
#pragma hdrstop
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spfile.c

Abstract:

    File operations for text setup.

Author:

    Ted Miller (tedm) 2-Aug-1993

Revision History:

--*/



#if 0
//
// Helper macro to make object attribute initialization a little cleaner.
//
#define INIT_OBJA(Obja,UnicodeString,UnicodeText)           \
                                                            \
    RtlInitUnicodeString((UnicodeString),(UnicodeText));    \
                                                            \
    InitializeObjectAttributes(                             \
        (Obja),                                             \
        (UnicodeString),                                    \
        OBJ_CASE_INSENSITIVE,                               \
        NULL,                                               \
        NULL                                                \
        )
#endif


NTSTATUS
SpGetFileSize(
    IN  HANDLE hFile,
    OUT PULONG Size
    )

/*++

Routine Description:

    Determine the size of a file.  Only the low 32 bits of the size
    are considered.

Arguments:

    hFile - supplies open handle to file whose size is desired.

    Size - receives size of file.

Return Value:

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_STANDARD_INFORMATION StandardInfo;

    Status = NtQueryInformationFile(
                hFile,
                &IoStatusBlock,
                &StandardInfo,
                sizeof(StandardInfo),
                FileStandardInformation
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("SETUP: SpGetFileSize: status %lx from NtQueryInformationFile\n",Status));
        return(Status);
    }

    *Size = StandardInfo.EndOfFile.LowPart;

    return(STATUS_SUCCESS);
}

NTSTATUS
SpMapEntireFile(
    IN  HANDLE   hFile,
    OUT PHANDLE  Section,
    OUT PVOID   *ViewBase,
    IN  BOOLEAN  WriteAccess
    )

/*++

Routine Description:

    Map an entire file for read or write access access.

Arguments:

    hFile - supplies handle of open file to be mapped.

    Section - receives handle for section object created to map file.

    ViewBase - receives address of the view of the file

    WriteAccess - if TRUE, map file for read and write access.
        If FALSE, map file for read access.

Return Value:

--*/

{
    NTSTATUS Status;
    LARGE_INTEGER SectionOffset;
    SIZE_T ViewSize = 0;

    SectionOffset.QuadPart = 0;

    Status = NtCreateSection(
                Section,
                  STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ
                | (WriteAccess ? SECTION_MAP_WRITE : 0),
                NULL,
                NULL,       // entire file
                WriteAccess ? PAGE_READWRITE : PAGE_READONLY,
                SEC_COMMIT,
                hFile
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("SETUP: Status %lx from NtCreateSection\n",Status));
        return(Status);
    }

    *ViewBase = NULL;
    Status = NtMapViewOfSection(
                *Section,
                NtCurrentProcess(),
                ViewBase,
                0,
                0,
                &SectionOffset,
                &ViewSize,
                ViewShare,
                0,
                WriteAccess ? PAGE_READWRITE : PAGE_READONLY
                );

    if(!NT_SUCCESS(Status)) {

        NTSTATUS s;

        KdPrint(("SETUP: SpMapEntireFile: Status %lx from NtMapViewOfSection\n",Status));

        s = NtClose(*Section);

        if(!NT_SUCCESS(s)) {
            KdPrint(("SETUP: SpMapEntireFile: Warning: status %lx from NtClose on section handle\n",s));
        }

        return(Status);
    }

    return(STATUS_SUCCESS);
}


#if 0
BOOLEAN
SpUnmapFile(
    IN HANDLE Section,
    IN PVOID  ViewBase
    )
{
    NTSTATUS Status;
    BOOLEAN  rc = TRUE;

    Status = NtUnmapViewOfSection(NtCurrentProcess(),ViewBase);
    if(!NT_SUCCESS(Status)) {
        KdPrint(("SETUP: Warning: status %lx from NtUnmapViewOfSection\n",Status));
        rc = FALSE;
    }

    Status = NtClose(Section);
    if(!NT_SUCCESS(Status)) {
        KdPrint(("SETUP: Warning: status %lx from NtClose on section handle\n",Status));
        rc = FALSE;
    }

    return(rc);
}
#endif


#if 0
NTSTATUS
SpOpenAndMapFile(
    IN  PWSTR    FileName,
    OUT PHANDLE  FileHandle,
    OUT PHANDLE  SectionHandle,
    OUT PVOID   *ViewBase,
    OUT PULONG   FileSize,
    IN  BOOLEAN  WriteAccess
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;

    //
    // Open the file.
    //
    INIT_OBJA(&Obja,&UnicodeString,FileName);
    Status = NtCreateFile(
                FileHandle,
                FILE_GENERIC_READ | (WriteAccess ? FILE_GENERIC_WRITE : 0),
                &Obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ,
                FILE_OPEN,
                0,
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("SETUP: SpOpenAndMapFile: Unable to open %ws (%lx)\n",FileName,Status));
        return(Status);
    }

    //
    // Get the size of the file.
    //
    Status = SpGetFileSize(*FileHandle,FileSize);
    if(!NT_SUCCESS(Status)) {
        KdPrint(("SETUP: SpOpenAndMapFile: unable to determine size of %ws (%lx)\n",FileName,Status));
        NtClose(*FileHandle);
        return(Status);
    }

    //
    // Map the file.
    //
    Status = SpMapEntireFile(*FileHandle,SectionHandle,ViewBase,WriteAccess);
    if(!NT_SUCCESS(Status)) {
        KdPrint(("SETUP: SpOpenAndMapFile: unable to map %ws (%lx)\n",FileName,Status));
        NtClose(*FileHandle);
        return(Status);
    }

    return(STATUS_SUCCESS);
}
#endif


DWORD
DnMapFile(
    IN  PSTR     FileName,
    OUT PDWORD   FileSize,
    OUT PHANDLE  FileHandle,
    OUT PHANDLE  MappingHandle,
    OUT PVOID   *BaseAddress
    )

/*++

Routine Description:

    Open and map a file for read access.

Arguments:

    FileName - supplies pathname to file to be mapped.

    FileSize - receives the size in bytes of the file.

    FileHandle - receives the win32 file handle for the open file.
        The file will be opened for generic read access.

    MappingHandle - receives the win32 handle for the file mapping
        object.  This object will be for read access.

    BaseAddress - receives the address where the file is mapped.

Return Value:

    NO_ERROR if the file was opened and mapped successfully.
        The caller must unmap the file with DnUnmapFile when
        access to the file is no longer desired.

    Win32 error code if the file was not successfully mapped.

--*/

{
    DWORD rc;

    //
    // Open the file -- fail if it does not exist.
    //
    *FileHandle = CreateFile(
                    FileName,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );

    if(*FileHandle == INVALID_HANDLE_VALUE) {

        rc = GetLastError();

    } else {

        //
        // Get the size of the file.
        //
        *FileSize = GetFileSize(*FileHandle,NULL);
        if(*FileSize != (DWORD)(-1)) {

            if(*FileSize == 0) {
                *MappingHandle = 0;
                return( NO_ERROR );
            }

            //
            // Create file mapping for the whole file.
            //
            *MappingHandle = CreateFileMapping(
                                *FileHandle,
                                NULL,
                                PAGE_READONLY,
                                0,
                                *FileSize,
                                NULL
                                );

            if(*MappingHandle) {

                //
                // Map the whole file.
                //
                *BaseAddress = MapViewOfFile(
                                    *MappingHandle,
                                    FILE_MAP_READ,
                                    0,
                                    0,
                                    *FileSize
                                    );

                if(*BaseAddress) {
                    return(NO_ERROR);
                }

                rc = GetLastError();
                CloseHandle(*MappingHandle);
            }
        }

        rc = GetLastError();
        CloseHandle(*FileHandle);
    }

    return(rc);
}



DWORD
DnUnmapFile(
    IN HANDLE MappingHandle,
    IN PVOID  BaseAddress
    )

/*++

Routine Description:

    Unmap a file.  Note that the file itself is left open.

Arguments:

    MappingHandle - supplies the win32 handle for the open file mapping
        object.

    BaseAddress - supplies the address where the file is mapped.

Return Value:

    NO_ERROR if the file was unmapped successfully.

    Win32 error code if the file was not successfully unmapped.

--*/

{
    if(!UnmapViewOfFile(BaseAddress)) {
        return(GetLastError());
    }

    if(!CloseHandle(MappingHandle)) {
        return(GetLastError());
    }

    return NO_ERROR;
}


VOID
ValidateAndChecksumFile(
    IN  PSTR     Filename,
    OUT PBOOLEAN IsNtImage,
    OUT PULONG   Checksum,
    OUT PBOOLEAN Valid
    )

/*++

Routine Description:

    Calculate a checksum value for a file using the standard
    nt image checksum method.  If the file is an nt image, validate
    the image using the partial checksum in the image header.  If the
    file is not an nt image, it is simply defined as valid.

    If we encounter an i/o error while checksumming, then the file
    is declared invalid.

Arguments:

    Filename - supplies full NT path of file to check.

    IsNtImage = Receives flag indicating whether the file is an
        NT image file.

    Checksum - receives 32-bit checksum value.

    Valid - receives flag indicating whether the file is a valid
        image (for nt images) and that we can read the image.

Return Value:

    None.

--*/

{
//    NTSTATUS Status;
    DWORD  Status;
    PVOID BaseAddress;
    ULONG FileSize;
    HANDLE hFile,hSection;
    PIMAGE_NT_HEADERS NtHeaders;
    ULONG HeaderSum;

    //
    // Assume not an image and failure.
    //
    *IsNtImage = FALSE;
    *Checksum = 0;
    *Valid = FALSE;

    //
    // Open and map the file for read access.
    //
//    Status = SpOpenAndMapFile(
//                Filename,
//                &hFile,
//                &hSection,
//                &BaseAddress,
//                &FileSize,
//                FALSE
//                );
//
//    if(!NT_SUCCESS(Status)) {
//        return;
//    }

    Status = DnMapFile( Filename,
                        &FileSize,
                        &hFile,
                        &hSection,
                        &BaseAddress );

    if( Status != ERROR_SUCCESS ) {
        return;
    }

    if( FileSize == 0 ) {
        *IsNtImage = FALSE;
        *Checksum = 0;
        *Valid = TRUE;
        CloseHandle( hFile );
        return;
    }


    try {
        NtHeaders = CheckSumMappedFile(BaseAddress,FileSize,&HeaderSum,Checksum);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        *Checksum = 0;
        NtHeaders = NULL;
    }

    //
    // If the file is not an image and we got this far (as opposed to encountering
    // an i/o error) then the checksum is declared valid.  If the file is an image,
    // then its checksum may or may not be valid.
    //

    if(NtHeaders) {
        *IsNtImage = TRUE;
        *Valid = HeaderSum ? (*Checksum == HeaderSum) : TRUE;
    } else {
        *Valid = TRUE;
    }

//    SpUnmapFile(hSection,BaseAddress);
    DnUnmapFile( hSection, BaseAddress );

//    NtClose(hFile);
    CloseHandle( hFile );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\legacy\dll\setupdll.h ===
// common (shared) routines

VOID SetErrorText( DWORD ResID );
VOID SetReturnText( LPSTR Text );
BOOL FFileExist(LPSTR);

BOOL
GenerateSortedIndexList (
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    );


// routines in nt_io.c

HANDLE OpenDisk(PSTR DriveName,BOOL WriteAccessDesired);
HANDLE OpenDiskNT(CHAR *NTStylePathName);
ULONG  OpenDiskStatus(PSTR NTDeviceName,PHANDLE Handle);
BOOL   CloseDisk(HANDLE Handle);
ULONG  GetSectorSize(HANDLE Handle);
ULONG  GetPartitionSize(CHAR *DriveName);
BOOL   ReadDiskSectors (HANDLE Handle,ULONG Sector,ULONG NumSectors,PVOID Buffer,ULONG SectorSize);
BOOL   WriteDiskSectors(HANDLE Handle,ULONG Sector,ULONG NumSectors,PVOID Buffer,ULONG SectorSize);
BOOL   ShutdownSystemWorker(IN BOOL Reboot);
//BOOL   MakePartitionWorker(DWORD Disk,DWORD Size);

// workers for DLL entry points

BOOL LayBootCodeWorker(IN LPSTR DOSDriveName,IN LPSTR FileSys,IN LPSTR BootCodeFile,IN LPSTR BootSectorSaveFile);
BOOL ConfigFileSubstWorker(IN LPSTR File,IN DWORD NumSubsts,IN LPSTR *Substs);
BOOL BinaryFileSubstWorker(IN LPSTR File,IN DWORD NumSubsts,IN LPSTR *Substs);
BOOL ConfigFileAppendWorker(IN LPSTR File,IN DWORD NumSubsts, IN LPSTR *Substs);
BOOL CheckConfigTypeWorker( IN LPSTR File );
BOOL VdmFixupWorker( LPSTR szAddOnConfig, LPSTR szAddOnBatch);




//=====================================================
// Registry.c declarations
//=====================================================

//
// 1. 