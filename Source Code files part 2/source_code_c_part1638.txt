+++++++++++
HRESULT
CAddress::Initialize(
                     ITTAPI * pTapi,
                     HLINEAPP hLineApp,
#ifdef USE_PHONEMSP
                     HPHONEAPP hPhoneApp,
#endif USE_PHONEMSP
                     DWORD dwAPIVersion,
                     DWORD dwDeviceID,
                     DWORD dwAddressID,
                     DWORD dwProviderID,
                     LPLINEDEVCAPS pDevCaps,
                     DWORD dwEventFilterMask
                    )
{
    LONG                lResult;
    HRESULT             hr;
    T3LINE              t3Line;
#ifdef USE_PHONEMSP
    BOOL                bPreferPhoneMSPForProvider =  FALSE;
#endif USE_PHONEMSP


    t3Line.hLine = NULL;
    t3Line.dwAddressLineStructHandle = 0;

    LOG((TL_TRACE, "Initialize[%p] enter", this ));
    LOG((TL_INFO, "   hLineApp ---------->%lx", hLineApp ));
#ifdef USE_PHONEMSP
    LOG((TL_INFO, "   hPhoneApp --------->%lx", hPhoneApp ));
#endif USE_PHONEMSP
    LOG((TL_INFO, "   dwAPIVersion ------>%lx", dwAPIVersion ));
    LOG((TL_INFO, "   dwDeviceID -------->%lx", dwDeviceID ));
    LOG((TL_INFO, "   dwAddressID ------->%lx", dwAddressID ));
    LOG((TL_INFO, "   pDevCaps ---------->%p", pDevCaps ));


    Lock();
            
    //
    // save relevant info
    //
    m_pTAPI                         = pTapi;
    m_dwDeviceID                    = dwDeviceID;
    m_dwAddressID                   = dwAddressID;
    m_dwMediaModesSupported         = pDevCaps->dwMediaModes;
    m_hLineApp                      = hLineApp;
#ifdef USE_PHONEMSP
    m_hPhoneApp                     = hPhoneApp;
#endif USE_PHONEMSP
    m_dwAPIVersion                  = dwAPIVersion;
    m_AddressState                  = AS_INSERVICE;
    m_pCallHubTrackingLine          = NULL;
    m_dwProviderID                  = dwProviderID;
    m_pPrivate                      = NULL;
    m_szAddressName                 = NULL;
    m_pAddressCaps                  = NULL;
    m_pDevCaps                      = NULL;

    
    //
    // Read the event filter mask from TAPIobject
    //
    SetEventFilterMask( dwEventFilterMask );
    
    AddRef();
    
    m_pTAPI->AddRef();
    
    //
    // default  address type
    //
    if (m_dwAPIVersion >= TAPI_VERSION3_0)
    {
        //
        // save msp and address types support
        //
        if ( (pDevCaps->dwDevCapFlags) & LINEDEVCAPFLAGS_MSP )
        {
            m_dwAddressFlags |= ADDRESSFLAG_MSP;
        
            LOG((TL_INFO, "Initialize - has an msp" ));
        }

        if ( (pDevCaps->dwDevCapFlags) & LINEDEVCAPFLAGS_PRIVATEOBJECTS )
        {
            m_dwAddressFlags |= ADDRESSFLAG_PRIVATEOBJECTS;

            LOG((TL_INFO, "Initialize - has private object" ));
        }

        if ( (pDevCaps->dwDevCapFlags) & LINEDEVCAPFLAGS_CALLHUB )
        {
            m_dwAddressFlags |= ADDRESSFLAG_CALLHUB;

            LOG((TL_INFO, "Initialize - supports callhubs" ));
        }

        if ( (pDevCaps->dwDevCapFlags) & LINEDEVCAPFLAGS_CALLHUBTRACKING )
        {
            m_dwAddressFlags |= ADDRESSFLAG_CALLHUBTRACKING;

            LOG((TL_INFO, "Initialize - supports callhub tracking" ));
        }

    }

    //
    // check for wave device if it doesn't
    // have it's own MSP
    //
    // the sp lets tapi know of wave support through the
    // device classes field, as well
    //
    // so, go through the array
    // and look for the appropriate string
    //
    if ( !(m_dwAddressFlags & ADDRESSFLAG_MSP) && (m_dwAPIVersion >= TAPI_VERSION2_0 ) )
    {
        if (0 != pDevCaps->dwDeviceClassesOffset)
        {
            PWSTR       pszDevices;


            //
            // look for full duplex
            // if not full duplex then
            //      look for wave out
            //      look for wave in
            //      if not wave then
            //          look for wave
            // 
            pszDevices = (PWSTR)( ( (PBYTE)pDevCaps ) + pDevCaps->dwDeviceClassesOffset );

            while (NULL != *pszDevices)
            {
                if (0 == lstrcmpiW(pszDevices, L"wave/in/out"))
                {
                    m_dwAddressFlags |= ADDRESSFLAG_WAVEFULLDUPLEX;

                    LOG((TL_INFO, "Initialize - supports full duplex wave"));

                    break;
                }

                pszDevices += (lstrlenW(pszDevices) + 1 );
            }

            if (!HasWaveDevice())
            {
                pszDevices = (PWSTR)( ( (PBYTE)pDevCaps ) + pDevCaps->dwDeviceClassesOffset );
                
                //
                // look for wave out
                //
                while (NULL != *pszDevices)
                {
                    if (0 == lstrcmpiW(pszDevices, L"wave/out"))
                    {
                        m_dwAddressFlags |= ADDRESSFLAG_WAVEOUTDEVICE;

                        LOG((TL_INFO, "Initialize - supports wave/out device" ));

                        break;
                    }

                    pszDevices += (lstrlenW(pszDevices) +1);

                }

                pszDevices = (PWSTR)( ( (PBYTE)pDevCaps ) + pDevCaps->dwDeviceClassesOffset );


                //
                // look for wave in
                //

                while (NULL != *pszDevices)
                {
                    if (0 == lstrcmpiW(pszDevices, L"wave/in"))
                    {
                        m_dwAddressFlags |= ADDRESSFLAG_WAVEINDEVICE;

                        LOG((TL_INFO, "Initialize - supports wave/in device" ));

                        break;
                    }

                    pszDevices += (lstrlenW(pszDevices) +1);

                }

                if (!HasWaveDevice())
                {
                    pszDevices = (PWSTR)( ( (PBYTE)pDevCaps ) + pDevCaps->dwDeviceClassesOffset );

                    //
                    // look for just wave
                    // some sps don't differentiate between wave out and wave in
                    //
                    while (NULL != *pszDevices)
                    {
                        if (0 == lstrcmpiW(pszDevices, L"wave"))
                        {
                            m_dwAddressFlags |= (ADDRESSFLAG_WAVEINDEVICE|ADDRESSFLAG_WAVEOUTDEVICE);

                            LOG((TL_INFO, "Initialize - supports wave device" ));

                            break;
                        }

                        pszDevices += (lstrlenW(pszDevices) + 1);

                    }
                }
            }
        }
    }

    IUnknown * pUnk;

    _InternalQueryInterface(IID_IUnknown, (void**)&pUnk);

#ifdef USE_PHONEMSP
    if ( HasWaveDevice() || ( NULL != GetHPhoneApp() ) )
#else
    if ( HasWaveDevice() )
#endif USE_PHONEMSP
    {
        t3Line.hLine = NULL;
        t3Line.pAddress = this;
        t3Line.dwAddressLineStructHandle = 0;
        
        hr = LineOpen(
                      GetHLineApp(),
                      GetDeviceID(),
                      GetAddressID(),
                      &t3Line,
                      GetAPIVersion(),
                      LINECALLPRIVILEGE_NONE,
                      LINEMEDIAMODE_UNKNOWN,
                      0,
                      NULL,
                      this,
                      GetTapi(),
                      FALSE         // no need to add to line hash table
                     );

        if (S_OK != hr)
        {
            LOG((TL_ERROR, "Initialize failed to open the line"));
            t3Line.hLine = NULL;
            t3Line.dwAddressLineStructHandle = 0;
        }
 
        //
        // Try to set the event filter mask to the TapiSrv level
        //

        hr = m_EventMasks.SetTapiSrvAddressEventMask( 
            t3Line.hLine
            );

        if( FAILED(hr) )
        {
            LOG((TL_ERROR, "SetTapiSrvAddressEventMask failed "));
        }

        m_hLine = t3Line.hLine;
    }
  
#ifdef USE_PHONEMSP     
    {
    HKEY    hKey;
    TCHAR   szProviderKeyName[256];
    DWORD   dwDataType;
    DWORD   dwDataSize = sizeof(DWORD);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     "Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\TAPI3",
                     0,
                     KEY_READ,
                     &hKey
                    ) == ERROR_SUCCESS)
    {
        // form reg name
        wsprintf(szProviderKeyName, ("PreferPhoneMSPForProvider%d"), m_dwProviderID);
        RegQueryValueEx(hKey,
                        szProviderKeyName,
                        0,
                        &dwDataType,
                        (LPBYTE) &bPreferPhoneMSPForProvider,
                        &dwDataSize
                       );
        RegCloseKey(hKey);
    }
    }
#endif USE_PHONEMSP
    
    if ( (m_dwAddressFlags & ADDRESSFLAG_MSP) )
    {
        //
        // CreateMSPObject
        //
        hr = CreateMSPObject(
                             m_dwDeviceID,
                             pUnk,
                             &m_pMSPAggAddress
                            );

        if (S_OK != hr)
        {
            LOG((TL_ERROR, "Initialize - CreateMSPObject return %lx", hr));

            m_dwAddressFlags = m_dwAddressFlags & ~(ADDRESSFLAG_MSP);
        }
    }
    else
    {
#ifdef USE_PHONEMSP
        if(bPreferPhoneMSPForProvider == TRUE)
        {
            // Create the Phone MSP as preference
            //
            if ( NULL != GetHPhoneApp() )
            {
                hr = CreatePhoneDeviceMSP(
                                          pUnk,
                                          t3Line.hLine,
                                          &m_pMSPAggAddress
                                         );
                if (!SUCCEEDED(hr))
                {
                    LOG((TL_ERROR, "Initialize - failed to create phone msp object - %lx", hr));
                }
                    
            }
            //
            // if it's a wave device, create wavemsp object
            //
            else if ( HasWaveDevice() ) 
            {
                
                hr = CreateWaveMSPObject(
                                         pUnk,
                                         &m_pMSPAggAddress
                                        );

                if (!SUCCEEDED(hr))
                {
                    LOG((TL_ERROR, "Initialize - failed to create wave msp object - %lx", hr));

                    m_dwAddressFlags = m_dwAddressFlags & ~(ADDRESSFLAG_WAVEINDEVICE | ADDRESSFLAG_WAVEOUTDEVICE | ADDRESSFLAG_WAVEFULLDUPLEX);
                }
            }
        }
        else
#endif USE_PHONEMSP
        {
            //
            // if it's a wave device, create wavemsp object as preference
            //
            if ( HasWaveDevice() ) 
            {
                
                hr = CreateWaveMSPObject(
                                         pUnk,
                                         &m_pMSPAggAddress
                                        );

                if (!SUCCEEDED(hr))
                {
                    LOG((TL_ERROR, "Initialize - failed to create wave msp object - %lx", hr));

                    m_dwAddressFlags = m_dwAddressFlags & ~(ADDRESSFLAG_WAVEINDEVICE | ADDRESSFLAG_WAVEOUTDEVICE | ADDRESSFLAG_WAVEFULLDUPLEX);
                }
            }
#ifdef USE_PHONEMSP
            // Create the Phone MSP
            //
            else if ( NULL != GetHPhoneApp() )
            {
                hr = CreatePhoneDeviceMSP(
                                          pUnk,
                                          t3Line.hLine,
                                          &m_pMSPAggAddress
                                         );
                if (!SUCCEEDED(hr))
                {
                    LOG((TL_ERROR, "Initialize - failed to create phone msp object - %lx", hr));
                }
                    
            }
#endif USE_PHONEMSP
        }

    }


    pUnk->Release();

    if (NULL != m_pMSPAggAddress)
    {
        m_hMSPEvent = CreateEvent(
                                  NULL,
                                  FALSE,
                                  FALSE,
                                  NULL
                                 );

        if ( NULL == m_hMSPEvent )
        {
            LOG((TL_ERROR, "Initialize - can't create MSP event"));

            m_dwAddressFlags = m_dwAddressFlags & ~(ADDRESSFLAG_AMREL);

            
            //
            // release msp object, so we are not tempted to do Shutdown on it
            // later without having (successfully) initialized it first
            //

            m_pMSPAggAddress->Release();
            m_pMSPAggAddress = NULL;
        }
        else
        {
            // Create a context handle to give the Callback & associate it with this object
            // in the global handle hash table

            m_MSPContext = GenerateHandleAndAddToHashTable((ULONG_PTR)this);
            
            LOG((TL_INFO, "Initialize - Map MSP handle %p to Address object %p", m_MSPContext, this ));

            BOOL fSuccess = RegisterWaitForSingleObject(
                & m_hWaitEvent,
                m_hMSPEvent,
                MSPEventCallback,
                (PVOID)m_MSPContext,
                INFINITE,
                WT_EXECUTEDEFAULT
                );

            if ( ( ! fSuccess ) || ( NULL == m_hWaitEvent ) )
            {
                LOG((TL_ERROR, "Initialize - RegisterWaitForSingleObject failed"));

                m_dwAddressFlags = m_dwAddressFlags & ~(ADDRESSFLAG_AMREL);

                m_pMSPAggAddress->Release();

                m_pMSPAggAddress = NULL;
            }
            else
            {
                ITMSPAddress * pMSPAddress = GetMSPAddress();
                
                hr = pMSPAddress->Initialize(
                                             (MSP_HANDLE)m_hMSPEvent
                                            );

                if ( SUCCEEDED(hr) && HasWaveDevice() )
                {
                    InitializeWaveDeviceIDs( t3Line.hLine );
                }
                
                pMSPAddress->Release();
                
                if (!SUCCEEDED(hr))
                {
                    LOG((TL_ERROR, "Initialize - failed to initialize msp object - %lx", hr));

                    UnregisterWait( m_hWaitEvent );

                    m_hWaitEvent = NULL;

                    m_dwAddressFlags = m_dwAddressFlags & ~(ADDRESSFLAG_AMREL);

                    m_pMSPAggAddress->Release();

                    m_pMSPAggAddress = NULL;
                }
            }
        }
    }

    if ( NULL != t3Line.hLine )
    {
        LineClose( &t3Line );
    }
    
    //
    // get the address caps structure
    //
    hr = UpdateAddressCaps();
    

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "Initialize - LineGetAddressCaps failed - return %lx", hr ));

        Unlock();

        LOG((TL_ERROR, hr, "Initialize - exit LineGetAddressCaps failed"));

        return hr;
    }

    //
    // save the address name
    //
    if (0 != m_pAddressCaps->dwAddressSize)
    {
        m_szAddress = (PWSTR) ClientAlloc (m_pAddressCaps->dwAddressSize + sizeof(WCHAR));

        if (NULL == m_szAddress)
        {
            LOG((TL_ERROR, "Initialize - alloc m_szAddress failed" ));

            Unlock();

            LOG((TL_ERROR, E_OUTOFMEMORY, "Initialize - exit alloc m_szAddress failed"));

            return E_OUTOFMEMORY;
        }
        
        memcpy(
               m_szAddress,
               ((LPBYTE)(m_pAddressCaps)) + m_pAddressCaps->dwAddressOffset,
               m_pAddressCaps->dwAddressSize
              );
        
        LOG((TL_INFO, "CAddress - Address is '%ls'", m_szAddress ));
    }

    hr = SaveAddressName( pDevCaps );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "Initialize - SaveAddressName failed %lx", hr));
        
        ClientFree(m_szAddress);

        /*This is to take care of AV*/
        m_szAddress = NULL;

        Unlock();

        LOG((TL_ERROR, hr, "Initialize - exit SaveAddressName failed"));

        return hr;
    }

    LOG((TL_INFO, "CAddress - m_szAddressName is '%ls'", m_szAddressName ));

    
    LOG((TL_TRACE, "Initialize - exit S_OK" ));

    Unlock();

    return S_OK;
    
    }

#ifdef USE_PHONEMSP
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CreatePhoneDeviceMSP
//      This address has a tapi phone devices, so create
//      the relevant terminals
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT
CAddress::CreatePhoneDeviceMSP(
                               IUnknown * pUnk,
                               HLINE hLine,
                               IUnknown ** ppMSPAggAddress
                              )
{
    HRESULT                         hr = S_OK;
    BOOL                            bSucceeded = FALSE;
    LPPHONECAPS                     pPhoneCaps;
    DWORD                           dwPhoneDevice;
    LPVARSTRING                     pVarString = NULL;
    CComAggObject<CPhoneMSP>      * pPhoneMSP;
    CPhoneMSP                     * pCPhoneMSP;
    ITMSPAddress                  * pMSPAddress;
    
    
    LOG((TL_TRACE, "CreatePhoneTerminal enter" ));

    //
    // get the related phone device id
    //
    hr = LineGetID(
                   hLine,
                   GetAddressID(),
                   NULL,
                   LINECALLSELECT_ADDRESS,
                   &pVarString,
                   L"tapi/phone"
                  );

    //
    // there is no phone device
    //
    if (S_OK != hr)
    {
        if ( NULL != pVarString )
        {
            ClientFree( pVarString );

            /*This is to take care of AV*/
            pVarString = NULL;
        }
        
        return hr;
    }

    
    //
    // get the phone device id at the endo
    // of the var string
    //
    if (pVarString->dwStringSize < sizeof(DWORD))
    {
        LOG((TL_ERROR, "CreatePhoneDeviceMSP - dwStringSize < 4" ));
        LOG((TL_ERROR, "CreatePhoneDeviceMSP exit - return LINEERR_OPERATIONFAILED" ));

        ClientFree( pVarString );

        /*This is to take care of AV*/
        pVarString = NULL;
        
        return mapTAPIErrorCode( LINEERR_OPERATIONFAILED );
    }

    //
    // get the phone device
    //
    dwPhoneDevice = (DWORD) ( * ( ( (PBYTE)pVarString ) + pVarString->dwStringOffset ) );

    ClientFree( pVarString );
    
    /*This is to take care of AV*/
    pVarString = NULL;

    //
    // create the msp object
    //
    pPhoneMSP = new CComAggObject<CPhoneMSP>(pUnk);

    /*NikhilB: This is to take care of an AV*/
    if ( NULL == pPhoneMSP )
    {
        LOG((TL_ERROR, "Could not allocate for phone MSP object" ));
        return E_OUTOFMEMORY;
    }


    //
    // save the aggregated interface in
    // the msppointer
    //
    pPhoneMSP->QueryInterface(
                              IID_IUnknown,
                              (void **)ppMSPAggAddress
                             );

    //
    // get to the real object
    //
    pMSPAddress = GetMSPAddress();
    
    pCPhoneMSP = dynamic_cast<CPhoneMSP *>(pMSPAddress);
    
    //
    // initialize it
    //
    hr = pCPhoneMSP->InitializeTerminals(
        GetHPhoneApp(),
        m_dwAPIVersion,
        dwPhoneDevice,
        this
        );

    pCPhoneMSP->Release();
    
    if ( !SUCCEEDED(hr) )
    {
    }

    LOG((TL_TRACE, "CreatePhoneDeviceMSP exit - return %lx", hr ));
    
    return hr;
}
#endif USE_PHONEMSP

    
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddCall
//      Keep track of calls
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CAddress::AddCall(
                  ITCallInfo * pCallInfo
                 )
{
    Lock();
    
    m_CallArray.Add( pCallInfo );

    Unlock();

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// RemoveCall
//
//      remove call from address's list
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CAddress::RemoveCall(
                     ITCallInfo * pCallInfo
                    )
{
    Lock();
    
    m_CallArray.Remove( pCallInfo );

    Unlock();

    return S_OK;
}



// ITMediaSupport methods
HRESULT
STDMETHODCALLTYPE
CAddress::get_MediaTypes(
               long * plMediaTypes
              )
{
    LOG((TL_TRACE, "get_MediaTypes enter" ));
    LOG((TL_TRACE, "   plMediaType ------->%p", plMediaTypes ));

    if (TAPIIsBadWritePtr( plMediaTypes, sizeof( long ) ) )
    {
        LOG((TL_ERROR, "get_MediaTypes - bad pointer"));

        return E_POINTER;
    }
    
    *plMediaTypes = (long)m_dwMediaModesSupported;
    if (*plMediaTypes & LINEMEDIAMODE_INTERACTIVEVOICE)
    {
        *plMediaTypes |= LINEMEDIAMODE_AUTOMATEDVOICE;
    }
        
    *plMediaTypes &= ALLMEDIAMODES;

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// QueryMediaType
//      find out of mediatype is supported
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
STDMETHODCALLTYPE
CAddress::QueryMediaType( 
    long lMediaType,
    VARIANT_BOOL * pbSupport
    )
{
    HRESULT         hr = S_OK;
    DWORD           dwMediaMode;

    LOG((TL_TRACE, "QueryMediaType enter"));
    LOG((TL_TRACE, "   lMediaType--------->%lx", lMediaType));
    LOG((TL_TRACE, "   pbSupport---------->%p", pbSupport));

    if ( TAPIIsBadWritePtr( pbSupport, sizeof(VARIANT_BOOL) ) )
    {
        LOG((TL_ERROR, "QueryMediaType - inval pointer"));

        return E_POINTER;
    }
    
    //
    // get the tapi mediamode that
    // the application is asking about
    //
    if (GetMediaMode(
                     lMediaType,
                     &dwMediaMode
                    ) )
    {
        *pbSupport = VARIANT_TRUE;
    }
    else
    {
        *pbSupport = VARIANT_FALSE;
    }

    LOG((TL_TRACE, "QueryMediaType exit - return success"));

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// AddCallNotification
//
// Adds a callback to notify on call events
//
// dwPrivs
//      IN tapi 2 style Privileges
//
// dwMediaModes
//      IN tapi 2 style mediamodes
//
// pNotification
//      IN the callback to notify
//
// pulRegiser
//      OUT the unique ID of the callback (so they can unregister)
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::AddCallNotification(
                              DWORD dwPrivs,
                              DWORD dwMediaModes,
                              long lInstance,
                              PVOID * ppRegister
                             )
{
    HRESULT                 hr;
    AddressLineStruct *     pAddressLine;

    //
    // create addressline
    //
    pAddressLine = (AddressLineStruct *)ClientAlloc( sizeof( AddressLineStruct ) );

    if (NULL == pAddressLine)
    {
        LOG((TL_ERROR, "AddCallNotification - pAddressLine is NULL"));

        return E_OUTOFMEMORY;
    }

    //
    // initialize
    //
    pAddressLine->dwPrivs               = dwPrivs;
    pAddressLine->t3Line.pAddress       = this;
    pAddressLine->t3Line.dwAddressLineStructHandle = 0;
    pAddressLine->InitializeRefcount(1);
    pAddressLine->lCallbackInstance     = lInstance;
    
    if (ALLMEDIATYPES == dwMediaModes)
    {
        pAddressLine->dwMediaModes      = GetMediaModes();
    }
    else
    {
        pAddressLine->dwMediaModes      = dwMediaModes;

        //
        // if we are listening on any audio mode
        //
        if (pAddressLine->dwMediaModes & AUDIOMEDIAMODES)
        {
            //
            // add in all the audio modes that we support
            //
            pAddressLine->dwMediaModes |= (GetMediaModes() & AUDIOMEDIAMODES);
        }
    }

    //
    // get a line
    //
    hr = LineOpen(
                  GetHLineApp(),
                  GetDeviceID(),
                  GetAddressID(),
                  &(pAddressLine->t3Line),
                  GetAPIVersion(),
                  pAddressLine->dwPrivs,
                  pAddressLine->dwMediaModes,
                  pAddressLine,
                  NULL,
                  (CAddress *)this,
                  GetTapi()
                 );


    if (!SUCCEEDED(hr))
    {
        LOG((TL_ERROR, "AddCallNotification - LineOpen failed %lx", hr));

        ClientFree( pAddressLine );
        
        return hr;
    }

    //
    // Try to set the event filter mask to the TapiSrv level
    //

    hr = m_EventMasks.SetTapiSrvAddressEventMask( 
        pAddressLine->t3Line.hLine
        );

    if( FAILED(hr) )
    {
        LOG((TL_ERROR, "AddCallNotification - SetTapiSrvAddressEventMask failed 0x%08x", hr));

        LineClose( &(pAddressLine->t3Line) );

        ClientFree( pAddressLine );
        
        return hr;
    }

    // Fix for bug 263866 & 250924
    //
    if ( m_dwAddressFlags & ADDRESSFLAG_MSP )
    {
        hr = LineCreateMSPInstance(
                                   pAddressLine->t3Line.hLine,
                                   GetAddressID()
                                  );

        if ( !SUCCEEDED(hr) )
        {
            LOG((TL_ERROR, "AddCallNotification - LineCreateMSPInstance failed %lx", hr));

            LineClose( &(pAddressLine->t3Line) );

            ClientFree( pAddressLine );

            return hr;
        }
    }


    // Tell TAPISRV what status messages we want
    // NOTE : if the lines SP doesn't support TSPI_lineSetStatusMessages
    // TAPISRV will fail this with LINEERR_OPERATIONUNAVAIL
    LineSetStatusMessages( 
                          &(pAddressLine->t3Line),
                          ALL_LINEDEVSTATE_MESSAGES,
                          ALL_LINEADDRESSSTATE_MESSAGES 
                          );


    //
    // ZoltanS fix: enable callhub notifications only if the app
    // hasn't already told us it doesn't want them
    //

    if ( m_fEnableCallHubTrackingOnLineOpen )
    {
        LINECALLHUBTRACKINGINFO         lchti;
        lchti.dwTotalSize = sizeof(lchti);
        lchti.dwCurrentTracking = LINECALLHUBTRACKING_ALLCALLS;

        hr = LineSetCallHubTracking(
                                    &(pAddressLine->t3Line),
                                    &lchti
                                   );

        if ( S_OK != hr )
        {
            LOG((TL_ERROR, "AddCallNotification - LineSetCallHubTracking failed %lx", hr ));

            LineClose( &(pAddressLine->t3Line) );

            ClientFree( pAddressLine );

            return hr;
        }
    }

    if (m_pCallHubTrackingLine)
    {
        MaybeCloseALine( &m_pCallHubTrackingLine );
        m_pCallHubTrackingLine = pAddressLine;
        pAddressLine->AddRef();
    }

    //
    // save the line in the address's list
    //
    hr = AddNotificationLine( pAddressLine );;

    if ( S_OK != hr )
    {
        LOG((TL_ERROR, "AddCallNotification - AddNotificationLine failed %lx", hr ));

        LineClose( &(pAddressLine->t3Line) );

        ClientFree( pAddressLine );

    }
    else
    {
        //
        // fill in pulRegister
        //
        
        *ppRegister = (PVOID) pAddressLine;
    }

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// RemoveCallNotification
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::RemoveCallNotification(
                                 PVOID pRegister
                                )
{
    AddressLineStruct *pLine = (AddressLineStruct *)pRegister;

    MaybeCloseALine( &pLine );

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// FindOrOpenALine
//
//  Attempts to find a line that's already open.  If so, keeps a
//  pointer to it.  If not opens the line.
//
//  dwMediaModes
//      IN tapi 2 style mediamodes
//
//  ppAddressLine
//      OUT addresslinestruct associated with this request
//
//  RETURNS
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT
CAddress::FindOrOpenALine(
                          DWORD dwMediaModes,
                            AddressLineStruct ** ppAddressLine
                         )
{
    HRESULT                 hr = S_OK;

    LOG((TL_TRACE, "FindOrOpenALine - enter" ));

    Lock();

    //
    // if there is already a line,
    // just return it
    //
    if ( m_AddressLinesPtrList.size() > 0 )
    {
        LOG((TL_INFO, "Found a line that is already open" ));

        *ppAddressLine = (AddressLineStruct *)*( m_AddressLinesPtrList.begin() );
        
        (*ppAddressLine)->AddRef();

        LOG((TL_TRACE, "FindOrOpenALine - exit"));

        Unlock();
        
        return S_OK;
    }
        

    //
    // we didn't have an address
    //
    LOG((TL_INFO, "Did not find an already open line"));


    //
    // create a new addressline
    //
    AddressLineStruct * pLine = (AddressLineStruct *)ClientAlloc( sizeof(AddressLineStruct) );

    if (NULL == pLine)
    {
        LOG((TL_ERROR, "FindOrOpenALine - alloc pLine failed" ));

        Unlock();
        
        return E_OUTOFMEMORY;
    }

    //
    // initialize
    //
    pLine->dwMediaModes = dwMediaModes;
    pLine->dwPrivs = LINECALLPRIVILEGE_NONE;
    pLine->t3Line.pAddress = this;
    pLine->t3Line.dwAddressLineStructHandle = 0;
    pLine->InitializeRefcount(1);
    pLine->lCallbackInstance = 0;

    
    LOG((TL_INFO, "FindOrOpenALine - Opening a line" ));

    //
    // open the line
    //
    hr = LineOpen(
                  GetHLineApp(),
                  GetDeviceID(),
                  GetAddressID(),
                  &(pLine->t3Line),
                  GetAPIVersion(),
                  LINECALLPRIVILEGE_NONE,
                  dwMediaModes,
                  pLine,
                  NULL,
                  this,
                  GetTapi()
                 );

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "FindOrOpenALine - LineOpen failed %lx", hr ));

        ClientFree( pLine );

        Unlock();
        
        return hr;
    }

    //
    // Try to set the event filter mask to the TapiSrv level
    //

    hr = m_EventMasks.SetTapiSrvAddressEventMask( 
        pLine->t3Line.hLine
        );

    if( FAILED(hr) )
    {
        LOG((TL_ERROR, "FindOrOpenALine - SetTapiSrvAddressEventMask failed 0x%08x", hr));

        LineClose( &(pLine->t3Line) );

        ClientFree( pLine );

        Unlock();
        
        return hr;
    }

    if ( m_dwAddressFlags & ADDRESSFLAG_MSP )
    {
        hr = LineCreateMSPInstance(
                                   pLine->t3Line.hLine,
                                   GetAddressID()
                                  );

        if ( !SUCCEEDED(hr) )
        {
            LOG((TL_ERROR, "FindOrOpenALine - LineCreateMSPInstance failed %lx", hr));

            LineClose( &(pLine->t3Line) );

            ClientFree( pLine );

            Unlock();
            
            return hr;
        }
    }

    // Tell TAPISRV what status messages we want
    // NOTE : if the lines SP doesn't support TSPI_lineSetStatusMessages
    // TAPISRV will fail this with LINEERR_OPERATIONUNAVAIL
    LineSetStatusMessages( 
                          &(pLine->t3Line),
                          ALL_LINEDEVSTATE_MESSAGES,
                          ALL_LINEADDRESSSTATE_MESSAGES 
                          );


    //
    // ZoltanS fix: enable callhub notifications only if the app
    // hasn't already told us it doesn't want them
    //

    if ( m_fEnableCallHubTrackingOnLineOpen )
    {
        LINECALLHUBTRACKINGINFO         lchti;
        lchti.dwTotalSize = sizeof(lchti);
        lchti.dwCurrentTracking = LINECALLHUBTRACKING_ALLCALLS;


        hr = LineSetCallHubTracking(
                                    &(pLine->t3Line),
                                    &lchti
                                   );

        if ( S_OK != hr )
        {
            LOG((TL_ERROR, "FindOrOpenALine - LineSetCallHubTracking failed %lx", hr ));

            LineClose( &(pLine->t3Line) );

            ClientFree( pLine );

            Unlock();
        
            return hr;
        }
    }
    
    //
    // Add this line to our list of open lines. This is independent of
    // the callhub tracking stuff above.
    //

    hr = AddNotificationLine( pLine );

    if ( S_OK != hr )
    {
        LOG((TL_ERROR, "FindOrOpenALine - AddNotificationLine failed %lx", hr ));

        LineClose( &(pLine->t3Line) );

        ClientFree( pLine );
    }
    else
    {
        *ppAddressLine  = pLine;
    }

    LOG((TL_TRACE, "FindOrOpenALine - exit"));

    Unlock();
    
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// MaybeCloseALine
//      After a call is done, close the line if it's not being
//      used for monitoring.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::MaybeCloseALine(
                          AddressLineStruct ** ppAddressLine
                         )
{
    HRESULT hr = S_OK;

    LOG((TL_TRACE, "MaybeCloseALine - enter"));


    Lock();

    if (NULL == *ppAddressLine || !IsValidAddressLine(*ppAddressLine))
    {
        Unlock();
        
        return S_OK;
    }

    
    //
    // decrement reference count on the the address line
    //

    DWORD dwAddressLineRefcount = (*ppAddressLine)->Release();
    
    //
    // if ref count is 0, close line
    //
    if ( 0 == dwAddressLineRefcount )
    {

        m_AddressLinesPtrList.remove( (PVOID)*ppAddressLine );


        //
        // clean handle table.
        //

        try
        {

            DWORD dwAddressLineHandle = (*ppAddressLine)->t3Line.dwAddressLineStructHandle;

            DeleteHandleTableEntry(dwAddressLineHandle);

        }
        catch(...)
        {

            LOG((TL_ERROR, 
                "MaybeCloseALine - exception accessing address line's handle" ));

            _ASSERTE(FALSE);
        }


        //
        // attempt to close the line
        //

        LOG((TL_INFO, "MaybeCloseALine - Calling LineClose" ));

        if ( m_dwAddressFlags & ADDRESSFLAG_MSP )
        {
            LineCloseMSPInstance( (*ppAddressLine)->t3Line.hLine );
        }

    
        //
        // release the lock and call lineclose
        //

        Unlock();


        //
        // now that the line was removed from our list of managed lines and all
        // the calls have been notified, we can close the line and free the
        // structure
        //
 
        hr = LineClose(
                       &((*ppAddressLine)->t3Line)
                      );

        ClientFree( *ppAddressLine );

    }
    else
    {
        
        Unlock();


        //
        // otherwise, decrement the dwRefCount count
        //
        LOG((TL_INFO, "MaybeCloseALine - Not calling line close - decrementing number of addresses using line" ));

    }

    *ppAddressLine = NULL;
    
    LOG((TL_TRACE, "MaybeCloseALine - exit"));

   
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// SetCallHubTracking
//
// called by the tapi object to start callhub tracking on this
// address
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::SetCallHubTracking(
                             BOOL bSet
                            )
{
    HRESULT                         hr = S_OK;
    LINECALLHUBTRACKINGINFO         lchti;

        

    Lock();

    //
    // Check if we have to make any change now.
    //

    if ( bSet == m_fEnableCallHubTrackingOnLineOpen )
    {
        //
        // already doing the right thing
        //
        Unlock();
        
        return S_OK;
    }

    //
    // ZoltanS: make sure we don't clobber this setting in other methods
    // (e.g., AddCallNotification or FindOrOpenALine) where the
    // default call notification behavior (true) would otherwise
    // be set.
    //

    m_fEnableCallHubTrackingOnLineOpen = bSet;


    
    //
    // need an hline to call setcallhubtracking
    //

    if ( m_pCallHubTrackingLine == NULL )
    {
        hr = FindOrOpenALine(
                             LINEMEDIAMODE_INTERACTIVEVOICE,
                             &m_pCallHubTrackingLine
                            );

        if ( !SUCCEEDED( hr ) )
        {
            LOG((TL_ERROR, "SCHT - FindOrOpen failed %lx", hr));
            Unlock();
            return hr;
        }
        
        //
        // ZoltanS fix:
        // FindOrOpenALine does callhubtracking for non-sp
        // tracking capable lines, but only if it is opening
        // the line (rather than just finding it in our list.
        // So we still need to do LineSetCallHubTracking below,
        // even for an SPCallHubTrackingAddress.
        //
    }

    //
    // tell the sp to track callhubs
    //
    ZeroMemory(
               &lchti,
               sizeof(lchti)
              );

    lchti.dwTotalSize = sizeof(lchti);
    lchti.dwCurrentTracking = bSet? LINECALLHUBTRACKING_ALLCALLS : 
                                    LINECALLHUBTRACKING_NONE;

    //
    // ZoltanS: Only pass this flag if it applies.
    // Note: LineSetCallHubTracking apparently ignores its first argument
    // if the tracking level is set to LINECALLHUBTRACKING_NONE; otherwise
    // we would also have to FindOrOpenALine if we are unsetting.
    //

    if ( bSet && IsSPCallHubTrackingAddress() )
    {
        lchti.dwCurrentTracking |= LINECALLHUBTRACKING_PROVIDERLEVEL;
    }

    hr = LineSetCallHubTracking(
                                &(m_pCallHubTrackingLine->t3Line),
                                &lchti
                               );

    if ( !SUCCEEDED( hr ) )
    {
        LOG((TL_ERROR, "SCHT - LSCHT failed %lx", hr));

        if ( bSet )
        {
            MaybeCloseALine( &m_pCallHubTrackingLine );

            m_pCallHubTrackingLine = NULL;
        }
        
        Unlock();
        return hr;
    }

    //
    //  Also properly set callhub tracking on lines that were
    //  opened for call notification
    //
    PtrList::iterator l;

    for (l = m_AddressLinesPtrList.begin(); l != m_AddressLinesPtrList.end(); l++)
    {
        AddressLineStruct * pLine;

        pLine = (AddressLineStruct *)(*l);
        if (pLine != m_pCallHubTrackingLine)
        {
            LineSetCallHubTracking(
                &(pLine->t3Line),
                &lchti
                );
        }
    }

    //
    // close it if unsetting
    //
    if ( !bSet )
    {
        MaybeCloseALine( &m_pCallHubTrackingLine );

        m_pCallHubTrackingLine = NULL;
    }

    Unlock();
    
    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// DoesThisAddressSupportCallHubs
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DWORD
CAddress::DoesThisAddressSupportCallHubs(
                                         CCall * pCall
                                        )
{
    HCALL                   hCall;
    LINECALLINFO          * pCallInfo;
    HRESULT                 hr;
    

    //
    // does the sp tell us it supports callhubs?
    //
    if ( IsSPCallHubAddress() )
    {
        return CALLHUBSUPPORT_FULL;
    }

    //
    // have we already determined that it doesn't?
    //
    if ( m_dwAddressFlags & ADDRESSFLAG_NOCALLHUB )
    {
        return CALLHUBSUPPORT_NONE;
    }

    //
    // otherwise - hack - see if the dwrelatedcallid
    // field is non-zero in this call.
    // if so, it does callhubs,
    //
    hCall = pCall->GetHCall();
    
    hr = LineGetCallInfo(
                         hCall,
                         &pCallInfo
                        );

    if ( SUCCEEDED( hr ) )
    {
        if ( 0 != pCallInfo->dwCallID )
        {
            Lock();

            m_dwAddressFlags |= ADDRESSFLAG_CALLHUB;

            Unlock();
            
            ClientFree( pCallInfo );
            
            return CALLHUBSUPPORT_FULL;
        }
        else
        {
            Lock();
            
            m_dwAddressFlags |= ADDRESSFLAG_NOCALLHUB;

            Unlock();

            ClientFree( pCallInfo );

            return CALLHUBSUPPORT_NONE;
        }
    }
                         
    return CALLHUBSUPPORT_UNKNOWN;
}




//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CreateForwardInfoObject
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::CreateForwardInfoObject(
                                  ITForwardInformation ** ppForwardInfo
                                 )
{
    CComObject< CForwardInfo > * p;
    HRESULT                     hr = S_OK;

    LOG((TL_TRACE, "CreatForwardInfoObject - enter"));

    
    if (TAPIIsBadWritePtr(ppForwardInfo , sizeof(ITForwardInformation *) ) )
    {
        LOG((TL_ERROR, "CreateForwardInfoObject - bad pointer"));

        return E_POINTER;
    }

    //
    // create object
    //
    CComObject< CForwardInfo >::CreateInstance( &p );

    if ( NULL == p )
    {
        LOG((TL_ERROR, "Create forward object failed"));
        return E_OUTOFMEMORY;
    }

    //
    // init
    //
    hr = p->Initialize();

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "Initialize forward object failed"));
        delete p;
        return hr;
    }

    //
    // return
    //
    hr = p->QueryInterface(
                           IID_ITForwardInformation,
                           (void**)ppForwardInfo
                          );
    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "CreateForwardobject failed - %lx", hr));
        delete p;
        return hr;
    }

    LOG((TL_TRACE, "CreateForwardObject - exit success"));
    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Forward - simple forwarding
//
// will unconditially forward to pDestAddress
//
// if pDestAddress is NULL, will cancel forwarding
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::Forward(
                  ITForwardInformation * pForwardInfo,
                  ITBasicCallControl * pCall
                 )
{
    HRESULT               hr;
    LINEFORWARDLIST     * pList;
    AddressLineStruct   * pLine;
    HCALL                 hCall = NULL;
    CForwardInfo        * pFI;
    CCall               * pCCall;
    LONG                  lCap;

    if ( IsBadReadPtr( pForwardInfo, sizeof( ITForwardInformation * ) ) )
    {
        LOG((TL_ERROR, "Forward - bad pForwardInfo"));
        
        return E_POINTER;
    }
    
    hr = get_AddressCapability( AC_ADDRESSCAPFLAGS, &lCap );

    if ( !SUCCEEDED(hr) )
    {
        return hr;
    }
    
    if ( lCap & LINEADDRCAPFLAGS_FWDCONSULT )
    {
        if ( IsBadReadPtr( pCall, sizeof(ITBasicCallControl *) ) )
        {
            LOG((TL_ERROR, "Forward - Need consultation call"));
            return E_INVALIDARG;
        }

        pCCall = dynamic_cast<CCall *>(pCall);

        if ( NULL == pCCall )
        {
            LOG((TL_ERROR, "Forward - invalid call"));
            return E_POINTER;
        }
    }

    pFI = dynamic_cast<CForwardInfo *>(pForwardInfo);

    if ( NULL == pFI )
    {
        return E_POINTER;
    }

    hr = pFI->CreateForwardList( &pList );

    if ( !SUCCEEDED(hr) )
    {
        return hr;
    }


    //
    // get a line
    //
    hr = FindOrOpenALine(
                         LINEMEDIAMODE_INTERACTIVEVOICE,
                         &pLine
                        );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "Forward - FindOrOpen failed - %lx", hr));

        ClientFree( pList );
        
        return hr;
    }

    //
    // call forward
    //
    //
    DWORD dwRings;

    pForwardInfo->get_NumRingsNoAnswer( (long *)&dwRings );


    hr = LineForward(
                     &(pLine->t3Line),
                     m_dwAddressID,
                     pList,
                     dwRings,
                     &hCall
                    );

    ClientFree( pList );
    
    if ( ((long)hr) < 0 )
    {
        LOG((TL_ERROR, "Forward failed sync - %lx", hr));

        MaybeCloseALine( &pLine );

        return hr;
    }

    hr = WaitForReply( hr );


    if ( lCap & LINEADDRCAPFLAGS_FWDCONSULT )
    {
        pCCall->Lock();

        pCCall->FinishSettingUpCall( hCall );

        pCCall->Unlock();
    }
    else
    {
        HRESULT     hr2;

        if( hCall != NULL )
        {
            hr2 = LineDrop(
                           hCall,
                           NULL,
                           0
                          );

            if ( ((long)hr2) > 0 )
            {
                hr2 = WaitForReply( hr2 );
            }

            LineDeallocateCall( hCall );
        }
    }
    
    MaybeCloseALine( &pLine );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "Forward failed async - %lx", hr));

        return hr;
    }

    LOG((TL_TRACE, "Forward - Exit"));

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITAddress
// Method    : get_CurrentForwardInfo
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::get_CurrentForwardInfo(
                                 ITForwardInformation ** ppForwardInfo
                                )
{
    HRESULT             hr = S_OK;
    AddressLineStruct * pLine = NULL;
    LINEADDRESSSTATUS * pAddressStatus = NULL;
    LINEFORWARD       * plineForward = NULL;
    DWORD               dwNumEntries = 0;
    DWORD               dwCount = 0;
    PWSTR               pszCallerAddress = NULL;    
    PWSTR               pszDestddress = NULL;    

    LOG((TL_TRACE, "get_CurrentForwardInfo - enter"));
    
    hr = CreateForwardInfoObject(ppForwardInfo);
    if ( SUCCEEDED(hr) )
    {
    
        hr = FindOrOpenALine(
                             LINEMEDIAMODE_INTERACTIVEVOICE,
                             &pLine
                            );
    
        if ( SUCCEEDED(hr) )
        {
            hr = LineGetAddressStatus(
                                      &(pLine->t3Line),
                                      m_dwAddressID,
                                      &pAddressStatus
                                     );
            if ( SUCCEEDED(hr) )
            {
                
                (*ppForwardInfo)->put_NumRingsNoAnswer(pAddressStatus->dwNumRingsNoAnswer);

                //
                // if there is forwarding
                //
                dwNumEntries = pAddressStatus->dwForwardNumEntries;
                
                plineForward = (LINEFORWARD *) (((LPBYTE)pAddressStatus) + pAddressStatus->dwForwardOffset);

                for (dwCount = 0; dwCount != dwNumEntries; dwCount++)
                {
                    if (plineForward->dwCallerAddressOffset > 0) // Caller address is not used for some forward modes
                    {
                        pszCallerAddress = (PWSTR) (((LPBYTE)pAddressStatus) + plineForward->dwCallerAddressOffset);
                    }

                    pszDestddress = (PWSTR) (((LPBYTE)pAddressStatus) + plineForward->dwDestAddressOffset);
                   
                    if ( m_dwAPIVersion >= TAPI_VERSION3_1 )
                    {
                        //
                        // We have negotiated TAPI3.1 or better, so we can get the address types.
                        //

                        ITForwardInformation2 * pForwardInfo2;

                        //
                        // Get the ITForwardInformation2 interface so we can call SetForwardType2
                        //

                        hr = (*ppForwardInfo)->QueryInterface(
                                                              IID_ITForwardInformation2,
                                                              (void **)&pForwardInfo2
                                                             );

                        if ( SUCCEEDED(hr) )
                        {
                            pForwardInfo2->SetForwardType2(plineForward->dwForwardMode,
                                                           pszDestddress,
                                                           plineForward->dwDestAddressType,
                                                           pszCallerAddress,
                                                           plineForward->dwCallerAddressType                                                           
                                                          ); 

                            pForwardInfo2->Release();
                        }
                        else
                        {
                            LOG((TL_ERROR, "get_CurrentForwardInfo - QueryInterface failed - %lx", hr));

                            //
                            // If for some reason the QI fails, break out of the loop
                            //

                            break;
                        }
                    }
                    else
                    {
                        (*ppForwardInfo)->SetForwardType(plineForward->dwForwardMode,                                                         
                                                         pszDestddress,
                                                         pszCallerAddress
                                                        ); 
                    }
                    
                    plineForward++;
                }
            
                
                ClientFree( pAddressStatus );
            }
            else
            {
                LOG((TL_ERROR, "get_CurrentForwardInfo - LineGetAddressStatus failed "));
            }
            
            MaybeCloseALine( &pLine );

        }
        else
        {
            LOG((TL_ERROR, "get_CurrentForwardInfo - FindOrOpen failed"));
        }                      
            
    }
    else
    {
        LOG((TL_ERROR, "get_CurrentForwardInfo - failed to create"));
    }


    LOG((TL_TRACE, hr, "get_CurrentForwardInfo - exit"));
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::get_DialableAddress(
                              BSTR * ppDialableAddress
                             )
{
    HRESULT             hr = S_OK;

    LOG((TL_TRACE, "get_DialableAddress - Enter"));

    if (TAPIIsBadWritePtr(ppDialableAddress , sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_DialableAddress - bad pointer"));

        return E_POINTER;
    }

    *ppDialableAddress = SysAllocString( m_szAddress );

    if ( ( NULL == *ppDialableAddress ) && ( NULL != m_szAddress ) )
    {
        LOG((TL_TRACE, "SysAllocString Failed" ));
        hr = E_OUTOFMEMORY;
    }
    
    LOG((TL_TRACE, "get_DialableAddress - Exit"));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::put_MessageWaiting(
                             VARIANT_BOOL  fMessageWaiting
                            )
{
    HRESULT             hr = S_OK;
    AddressLineStruct * pLine = NULL;

    
    LOG((TL_TRACE, "put_MessageWaiting - Enter"));

    hr = FindOrOpenALine(
                         LINEMEDIAMODE_INTERACTIVEVOICE,
                         &pLine
                        );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "put_MessageWaiting - findoropen failed %lx", hr));
        return hr;
    }
    
    hr = LineSetLineDevStatus(
                              &(pLine->t3Line),
                              LINEDEVSTATUSFLAGS_MSGWAIT,
                              fMessageWaiting?-1:0
                             );

    if ( ((LONG)hr) < 0 )
    {
        LOG((TL_TRACE, "put_MessageWaiting failed sync - %lx", hr));
        
        MaybeCloseALine( &pLine );

        return hr;
    }

    // Wait for the async reply & map it's tapi2 code T3
    hr = WaitForReply( hr );
    
    MaybeCloseALine( &pLine );
    
    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_TRACE, "put_MessageWaiting failed async - %lx", hr));

        return hr;
    }
    
    LOG((TL_TRACE, "put_MessageWaiting - Exit"));

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::get_MessageWaiting(
                             VARIANT_BOOL * pfMessageWaiting
                            )
{
    HRESULT               hr = S_OK;
    LINEDEVSTATUS       * pDevStatus;
    AddressLineStruct   * pLine;

    
    LOG((TL_TRACE, "get_MessageWaiting - Enter"));

    if (TAPIIsBadWritePtr(pfMessageWaiting , sizeof(VARIANT_BOOL) ) )
    {
        LOG((TL_ERROR, "get_MessageWaiting - bad pointer"));

        return E_POINTER;
    }

    hr = FindOrOpenALine(
                         LINEMEDIAMODE_INTERACTIVEVOICE,
                         &pLine
                        );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "FindOrOpenALine failed - %lx", hr ));

        return hr;
    }
    
    hr = LineGetLineDevStatus(
                              pLine->t3Line.hLine,
                              &pDevStatus
                             );

    MaybeCloseALine( &pLine );
    
    if ( !SUCCEEDED( hr ) )
    {
        LOG((TL_ERROR, "LineGetDevStatus failed - %lx", hr ));

        return hr;
    }

    if ( pDevStatus->dwDevStatusFlags & LINEDEVSTATUSFLAGS_MSGWAIT )
    {
        *pfMessageWaiting = VARIANT_TRUE;
    }
    else
    {
        *pfMessageWaiting = VARIANT_FALSE;
    }

    ClientFree( pDevStatus );
    
    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "Bad pointer in get_MessageWaiting"));
        return hr;
    }

    LOG((TL_TRACE, "get_MessageWaiting - Exit"));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::put_DoNotDisturb(
                           VARIANT_BOOL  fDoNotDisturb
                          )
{
    HRESULT             hr = S_OK;
    LINEFORWARDLIST     lfl;
    HCALL               hCall = NULL;
    AddressLineStruct * pLine;
    

    //
    // do not disturb is acheived through calling
    // lineforward with NULL for the dest address
    //
    
    LOG((TL_TRACE, "put_DoNotDisturb - Enter"));

    //
    // if we are setting dnd, create a lineforwardlist
    // structure
    //
    if ( fDoNotDisturb )
    {
        ZeroMemory(
                   &lfl,
                   sizeof( LINEFORWARDLIST )
                  );

        lfl.dwTotalSize = sizeof( LINEFORWARDLIST );
        lfl.dwNumEntries = 1;
        //
        // there is only one item, and the dest address
        // is NULL
        //
        lfl.ForwardList[0].dwForwardMode = LINEFORWARDMODE_UNCOND;
    }

    //
    // get a line to use
    //
    hr = FindOrOpenALine(
                         LINEMEDIAMODE_INTERACTIVEVOICE,
                         &pLine
                        );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "put_DoNotDisturb - FindOrOpen failed %lx", hr));

        return hr;
    }

    //
    // call line forward
    // if fDND is false, the LINEFORWARDLIST structure pointer
    // should be NULL.  This clears any fowarding on that
    // line.
    //

    hr = LineForward(
                     &(pLine->t3Line),
                     m_dwAddressID,
                     fDoNotDisturb?&lfl:NULL,
                     0,
                     &hCall
                    );

    if ( ((long)hr) < 0 )
    {
        LOG((TL_ERROR, "put_DND - linefoward failed sync - %lx", hr));
        MaybeCloseALine( &pLine );

        return hr;
    }

    // Wait for the async reply & map it's tapi2 code T3
    hr = WaitForReply( hr );

    if ( NULL != hCall )
    {
        T3CALL t3Call;
        HRESULT hr2;
        
        t3Call.hCall = hCall;
        
        hr2 = LineDrop(
                       t3Call.hCall,
                       NULL,
                       0
                      );

        if ( ((long)hr2) > 0 )
        {
            hr2 = WaitForReply( hr2 ) ;
        }

        hr2 = LineDeallocateCall(
                                 t3Call.hCall
                                );
    }
    
    //
    // we are no longer using the line
    //
    MaybeCloseALine( &pLine );
    
    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "put_DND - linefoware failed async - %lx", hr));
        return hr;
    }

    
    LOG((TL_TRACE, "put_DoNotDisturb - Exit"));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::get_DoNotDisturb(
                           VARIANT_BOOL * pfDoNotDisturb
                          )
{
    HRESULT             hr = S_OK;
    AddressLineStruct * pLine;
    LINEADDRESSSTATUS * pAddressStatus;
    LINEDEVSTATUS       * pDevStatus = NULL;
    
    //
    // donotdisturb is implemented through
    // line forward.
    // to get_DND, check the forward state
    //
    LOG((TL_TRACE, "get_DoNotDisturb - Enter"));

    if (TAPIIsBadWritePtr(pfDoNotDisturb , sizeof(VARIANT_BOOL) ) )
    {
        LOG((TL_ERROR, "pfDoNotDisturb - bad pointer"));

        return E_POINTER;
    }

    
    hr = FindOrOpenALine(
                         LINEMEDIAMODE_INTERACTIVEVOICE,
                         &pLine
                        );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "get_DND - FindOrOpen failed %lx", hr));
        return hr;
    }

    hr = LineGetLineDevStatus(
                              pLine->t3Line.hLine,
                              &pDevStatus
                             );

    if ( !SUCCEEDED(hr) )
    {
        MaybeCloseALine( &pLine );
        return hr;
    }

    if ( !(pDevStatus->dwLineFeatures & LINEFEATURE_FORWARD ) )
    {
        LOG((TL_INFO, "get_DND - not supported"));
        MaybeCloseALine( &pLine );

        if(pDevStatus != NULL)
        {
            ClientFree(pDevStatus);
        }

        return TAPI_E_NOTSUPPORTED;
    }

    // finished with pDevStatus
    if(pDevStatus != NULL)
    {
        ClientFree(pDevStatus);
    }
    
    //
    // get the addresss status
    //
    hr = LineGetAddressStatus(
                              &(pLine->t3Line),
                              m_dwAddressID,
                              &pAddressStatus
                             );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "get_DND - LineGetAddressStatus failed - %lx", hr));
        MaybeCloseALine( &pLine );
        return hr;
    }

    //
    // initialize to false
    //
    *pfDoNotDisturb = VARIANT_FALSE;

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "get_DND - bad pointer"));
        return E_OUTOFMEMORY;
    }

    //
    // if there is forwarding
    //
    if ( 0 != pAddressStatus->dwForwardNumEntries )
    {
        LINEFORWARD * pfl;

        pfl = (LINEFORWARD *) (((LPBYTE)pAddressStatus) + pAddressStatus->dwForwardOffset);

        //
        // and the dest address is NULL
        //
        if ( 0 == pfl->dwDestAddressOffset )
        {
            //
            // DND is set
            //
            *pfDoNotDisturb = VARIANT_TRUE;
        }
    }

    MaybeCloseALine( &pLine );
    
    ClientFree( pAddressStatus );
                              
    LOG((TL_TRACE, "get_DoNotDisturb - Exit"));

    return S_OK;
}

//
// itaddresscapabilities
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::get_AddressCapability(
         ADDRESS_CAPABILITY AddressCap,
         long * plCapability
         )
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "get_AddressCapability - Enter"));

    if ( TAPIIsBadWritePtr( plCapability, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_AddressCapability - bad pointer"));

        return E_POINTER;
    }

    Lock();
    
    hr = UpdateAddressCaps();

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "get_AddressCapability - could not get addresscaps"));

        Unlock();
        
        return E_UNEXPECTED;
    }

    switch (AddressCap)
    {
        case AC_LINEID:
            *plCapability = m_dwDeviceID;
            break;
            
        case AC_ADDRESSID:
            *plCapability = m_dwAddressID;
            break;
            
        case AC_ADDRESSTYPES:
        case AC_BEARERMODES:  
        case AC_MONITORDIGITSUPPORT:
        case AC_GENERATEDIGITSUPPORT:
        case AC_GENERATETONEMODES:
        case AC_GENERATETONEMAXNUMFREQ:
        case AC_MONITORTONEMAXNUMFREQ:
        case AC_MONITORTONEMAXNUMENTRIES:
        case AC_DEVCAPFLAGS:
        case AC_ANSWERMODES:
        case AC_LINEFEATURES:
        case AC_SETTABLEDEVSTATUS:
        case AC_PERMANENTDEVICEID:
        case AC_GATHERDIGITSMINTIMEOUT:
        case AC_GATHERDIGITSMAXTIMEOUT:
        case AC_GENERATEDIGITMINDURATION:
        case AC_GENERATEDIGITMAXDURATION:
        case AC_GENERATEDIGITDEFAULTDURATION:
        {
                                   
            hr = UpdateLineDevCaps();

            if ( !SUCCEEDED(hr) )
            {
                LOG((TL_ERROR, "get_AddressCap - could not get devcaps - %lx", hr));

                Unlock();

                return hr;
            }

            switch (AddressCap)
            {
                case AC_ADDRESSTYPES:
                    if ( m_dwAPIVersion >= TAPI_VERSION3_0 )
                    {
                        *plCapability = m_pDevCaps->dwAddressTypes;
                    }
                    else
                    {
                        *plCapability = LINEADDRESSTYPE_PHONENUMBER;
                    }
                    break;
                case AC_BEARERMODES:  
                    *plCapability = m_pDevCaps->dwBearerModes;
                    break;
                case AC_MONITORDIGITSUPPORT:
                    *plCapability = m_pDevCaps->dwMonitorDigitModes;
                    break;
                case AC_GENERATEDIGITSUPPORT:
                    *plCapability = m_pDevCaps->dwGenerateDigitModes;
                    break;
                case AC_GENERATETONEMODES:
                    *plCapability = m_pDevCaps->dwGenerateToneModes;
                    break;
                case AC_GENERATETONEMAXNUMFREQ:
                    *plCapability = m_pDevCaps->dwGenerateToneMaxNumFreq;
                    break;
                case AC_MONITORTONEMAXNUMFREQ:
                    *plCapability = m_pDevCaps->dwMonitorToneMaxNumFreq;
                    break;
                case AC_MONITORTONEMAXNUMENTRIES:
                    *plCapability = m_pDevCaps->dwMonitorToneMaxNumEntries;
                    break;
                case AC_DEVCAPFLAGS:
                    *plCapability = m_pDevCaps->dwDevCapFlags;
                    break;
                case AC_ANSWERMODES:
                    *plCapability = m_pDevCaps->dwAnswerMode;
                    break;
                case AC_LINEFEATURES:
                    *plCapability = m_pDevCaps->dwLineFeatures;
                    break;
                case AC_SETTABLEDEVSTATUS:
                    if ( m_dwAPIVersion >= TAPI_VERSION2_0 )
                    {
                        *plCapability = m_pDevCaps->dwSettableDevStatus;
                    }
                    else
                        hr = TAPI_E_NOTSUPPORTED;
                    
                    break;
                case AC_PERMANENTDEVICEID:
                    *plCapability = m_pDevCaps->dwPermanentLineID;
                    break;
                case AC_GATHERDIGITSMINTIMEOUT:
                    *plCapability = m_pDevCaps->dwGatherDigitsMinTimeout;
                    break;
                case AC_GATHERDIGITSMAXTIMEOUT:
                    *plCapability = m_pDevCaps->dwGatherDigitsMaxTimeout;
                    break;
                case AC_GENERATEDIGITMINDURATION:
                    *plCapability = m_pDevCaps->MinDialParams.dwDigitDuration;
                    break;
                case AC_GENERATEDIGITMAXDURATION:
                    *plCapability = m_pDevCaps->MaxDialParams.dwDigitDuration;
                    break;
                case AC_GENERATEDIGITDEFAULTDURATION:
                    *plCapability = m_pDevCaps->DefaultDialParams.dwDigitDuration;
                    break;
            }

            break;
        }                              


        case AC_MAXACTIVECALLS:
        case AC_MAXONHOLDCALLS:
        case AC_MAXONHOLDPENDINGCALLS:
        case AC_MAXNUMCONFERENCE:
        case AC_MAXNUMTRANSCONF:
        case AC_PARKSUPPORT:
        case AC_CALLERIDSUPPORT:
        case AC_CALLEDIDSUPPORT:
        case AC_CONNECTEDIDSUPPORT:
        case AC_REDIRECTIONIDSUPPORT:
        case AC_REDIRECTINGIDSUPPORT:
        case AC_ADDRESSCAPFLAGS:
        case AC_CALLFEATURES1:
        case AC_CALLFEATURES2:
        case AC_REMOVEFROMCONFCAPS:
        case AC_REMOVEFROMCONFSTATE:
        case AC_TRANSFERMODES:
        case AC_ADDRESSFEATURES:
        case AC_PREDICTIVEAUTOTRANSFERSTATES:
        case AC_MAXCALLDATASIZE:
        case AC_FORWARDMODES:
        case AC_MAXFORWARDENTRIES:
        case AC_MAXSPECIFICENTRIES:
        case AC_MINFWDNUMRINGS:
        case AC_MAXFWDNUMRINGS:
        case AC_MAXCALLCOMPLETIONS:
        case AC_CALLCOMPLETIONCONDITIONS:
        case AC_CALLCOMPLETIONMODES:
        {
            hr = UpdateAddressCaps();

            if ( !SUCCEEDED(hr) )
            {
                LOG((TL_ERROR, "get_AddressCaps - could not update caps - %lx", hr));

                Unlock();

                return hr;
            }

            switch (AddressCap)
            {
                case AC_MAXACTIVECALLS:
                    *plCapability = m_pAddressCaps->dwMaxNumActiveCalls;
                    break;
                case AC_MAXONHOLDCALLS:
                    *plCapability = m_pAddressCaps->dwMaxNumOnHoldCalls;
                    break;
                case AC_MAXONHOLDPENDINGCALLS:
                    *plCapability = m_pAddressCaps->dwMaxNumOnHoldPendingCalls;
                    break;
                case AC_MAXNUMCONFERENCE:
                    *plCapability = m_pAddressCaps->dwMaxNumConference;
                    break;
                case AC_MAXNUMTRANSCONF:
                    *plCapability = m_pAddressCaps->dwMaxNumTransConf;
                    break;
                case AC_PARKSUPPORT:
                    *plCapability = m_pAddressCaps->dwParkModes;
                    break;
                case AC_CALLERIDSUPPORT:
                    *plCapability = m_pAddressCaps->dwCallerIDFlags;
                    break;
                case AC_CALLEDIDSUPPORT:
                    *plCapability = m_pAddressCaps->dwCalledIDFlags;
                    break;
                case AC_CONNECTEDIDSUPPORT:
                    *plCapability = m_pAddressCaps->dwConnectedIDFlags;
                    break;
                case AC_REDIRECTIONIDSUPPORT:
                    *plCapability = m_pAddressCaps->dwRedirectionIDFlags;
                    break;
                case AC_REDIRECTINGIDSUPPORT:
                    *plCapability = m_pAddressCaps->dwRedirectingIDFlags;
                    break;
                case AC_ADDRESSCAPFLAGS:
                    *plCapability = m_pAddressCaps->dwAddrCapFlags;
                    break;
                case AC_CALLFEATURES1:
                    *plCapability = m_pAddressCaps->dwCallFeatures;
                    break;
                case AC_CALLFEATURES2:
                    if ( m_dwAPIVersion < TAPI_VERSION2_0 )
                    {
                        hr = TAPI_E_NOTSUPPORTED;
                    }
                    else
                    {
                        *plCapability = m_pAddressCaps->dwCallFeatures2;
                    }
                    
                    break;
                case AC_REMOVEFROMCONFCAPS:
                    *plCapability = m_pAddressCaps->dwRemoveFromConfCaps;
                    break;
                case AC_REMOVEFROMCONFSTATE:
                    *plCapability = m_pAddressCaps->dwRemoveFromConfState;
                    break;
                case AC_TRANSFERMODES:
                    *plCapability = m_pAddressCaps->dwTransferModes;
                    break;
                case AC_ADDRESSFEATURES:
                    *plCapability = m_pAddressCaps->dwAddressFeatures;
                    break;
                case AC_PREDICTIVEAUTOTRANSFERSTATES:
                    if ( m_dwAPIVersion < TAPI_VERSION2_0 )
                    {
                        hr = TAPI_E_NOTSUPPORTED;
                    }
                    else
                    {
                        *plCapability = m_pAddressCaps->dwPredictiveAutoTransferStates;
                    }
                    break;
                case AC_MAXCALLDATASIZE:

                    if ( m_dwAPIVersion < TAPI_VERSION2_0 )
                    {
                        hr = TAPI_E_NOTSUPPORTED;
                    }
                    else
                    {
                        *plCapability = m_pAddressCaps->dwMaxCallDataSize;
                    }
                    break;
                case AC_FORWARDMODES:
                    *plCapability = m_pAddressCaps->dwForwardModes;
                    break;
                case AC_MAXFORWARDENTRIES:
                    *plCapability = m_pAddressCaps->dwMaxForwardEntries;
                    break;
                case AC_MAXSPECIFICENTRIES:
                    *plCapability = m_pAddressCaps->dwMaxSpecificEntries;
                    break;
                case AC_MINFWDNUMRINGS:
                    *plCapability = m_pAddressCaps->dwMinFwdNumRings;
                    break;
                case AC_MAXFWDNUMRINGS:
                    *plCapability = m_pAddressCaps->dwMaxFwdNumRings;
                    break;
                case AC_MAXCALLCOMPLETIONS:
                    *plCapability = m_pAddressCaps->dwMaxCallCompletions;
                    break;
                case AC_CALLCOMPLETIONCONDITIONS:
                    *plCapability = m_pAddressCaps->dwCallCompletionConds;
                    break;
                case AC_CALLCOMPLETIONMODES:
                    *plCapability = m_pAddressCaps->dwCallCompletionModes;
                    break;
            }
            
            break;
        }
        default:
            LOG((TL_ERROR, "get_AddressCapability - bad addrcap"));

            Unlock();
            
            return E_INVALIDARG;
    }

    
    LOG((TL_TRACE, "get_AddressCapability - Exit - result - %lx", hr));

    Unlock();
    
    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::get_AddressCapabilityString(
         ADDRESS_CAPABILITY_STRING AddressCapString,
         BSTR * ppCapabilityString
         )
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "get_AddressCapabilityString - Enter"));

    if ( TAPIIsBadWritePtr( ppCapabilityString, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_AddressCapabilityString - bad pointer"));

        return E_POINTER;
    }

    *ppCapabilityString = NULL;
    
    Lock();

    //
    // note on:
    // ACS_ADDRESSDEVICESPECIFIC
    // ACS_LINEDEVICESPECIFIC:
    // ACS_PROVIDERSPECIFIC:
    // ACS_SWITCHSPECIFIC:
    //
    // These buffers in LINEDEVCAPS and LINEADDRESSCAPS may or may not be strings.  However
    // in TAPI 3, we define them as strings.
    //
    // The algorithm for moving them from the tapi 2 structure to the tapi 3 string is:
    //
    // if the size of the buffer is evenly divisible by sizeof(WCHAR)
    //      then it's definitely not a string (we only support WCHAR)
    //      so we will just copy the buffer straight into the returned string, and append a
    //      NULL at the end
    // else
    //      if the buffer already has a null at the end, don't copy it, because SysAllocStringByteLen
    //      always appends a NULL and double NULLs frighten VB.
    //
    // It can still be a "buffer" and not a string even if it is divisible by sizeof WCHAR, but for
    // this it does matter, since we are using SysAllocStringByteLen to copy the buffer no
    // matter what
    //
    switch (AddressCapString)
    {
        case ACS_ADDRESSDEVICESPECIFIC:
            hr = UpdateAddressCaps();

            if ( !SUCCEEDED(hr) )
            {
                Unlock();

                return hr;
            }

            if ( m_pAddressCaps->dwDevSpecificSize != 0 )
            {
                LPWSTR      pHold;
                DWORD       dwSize;

                dwSize = m_pAddressCaps->dwDevSpecificSize;

                //
                // is size divisible by sizeof(WCHAR)?
                //
                if (0 == (dwSize % sizeof(WCHAR)))
                {
                    //
                    // yes - get to the last character in the string
                    //
                    pHold = (LPWSTR)(((LPBYTE)(m_pAddressCaps)) + m_pAddressCaps->dwDevSpecificOffset),
                    (dwSize-sizeof(WCHAR))/sizeof(WCHAR);

                    //
                    // is the last character a NULL?
                    //
                    if (*pHold == NULL)
                    {
                        //
                        // yes, so don't copy it
                        //
                        dwSize-=sizeof(WCHAR);
                    }
                }

                //
                // Alloc and copy into return string.  SysAllocStringByteLen always
                // appends a NULL
                //
                *ppCapabilityString = SysAllocStringByteLen(
                    (LPSTR)(((LPBYTE)(m_pAddressCaps)) + m_pAddressCaps->dwDevSpecificOffset),
                    dwSize
                    );
                if ( NULL == *ppCapabilityString )
                {
                    LOG((TL_ERROR, "get_AddressCapabilityString - SysAllocString Failed"));
                    hr = E_OUTOFMEMORY;
                }
            }

            break;
                
        case ACS_PROTOCOL:
        case ACS_LINEDEVICESPECIFIC:
        case ACS_PROVIDERSPECIFIC:
        case ACS_SWITCHSPECIFIC:
        case ACS_PERMANENTDEVICEGUID:
        {
            hr = UpdateLineDevCaps();

            if ( !SUCCEEDED(hr) )
            {
                Unlock();

                return hr;
            }

            switch (AddressCapString)
            {
                case ACS_PROTOCOL:
                {
                    LPWSTR pwstr;
                    
                    if ( m_dwAPIVersion >= TAPI_VERSION3_0 )
                    {
                        IID iid;

                        iid = m_pDevCaps->ProtocolGuid;
                        StringFromIID(iid, &pwstr);
                    }
                    else
                    {
                        StringFromIID( TAPIPROTOCOL_PSTN, &pwstr );
                    }

                    *ppCapabilityString = SysAllocString( pwstr );

                    if ( NULL == *ppCapabilityString )
                    {
                        LOG((TL_ERROR, "get_AddressCapabilityString - SysAllocString Failed"));
                        hr = E_OUTOFMEMORY;
                    }
                    
                    CoTaskMemFree( pwstr );

                    break;
                }
                case ACS_LINEDEVICESPECIFIC:
                    if ( m_pDevCaps->dwDevSpecificSize != 0 )
                    {
                        LPWSTR      pHold;
                        DWORD       dwSize;

                        dwSize = m_pDevCaps->dwDevSpecificSize;

                        //
                        // is size divisible by sizeof(WCHAR)?
                        //
                        if (0 == (dwSize % sizeof(WCHAR)))
                        {
                            //
                            // yes - get to the last character in the string
                            //
                            pHold = (LPWSTR)(((LPBYTE)(m_pDevCaps)) + m_pDevCaps->dwDevSpecificOffset) +
                                    (dwSize-sizeof(WCHAR))/sizeof(WCHAR);

                            //
                            // is the last character a NULL?
                            //
                            if (*pHold == NULL)
                            {
                                //
                                // yes, so don't copy it
                                //
                                dwSize-=sizeof(WCHAR);
                            }
                        }

                        //
                        // Alloc and copy into return string.  SysAllocStringByteLen always
                        // appends a NULL
                        //
                        *ppCapabilityString = SysAllocStringByteLen(
                            (LPSTR)(((LPBYTE)(m_pDevCaps)) + m_pDevCaps->dwDevSpecificOffset),
                            dwSize
                            );
                        
                        if ( NULL == *ppCapabilityString )
                        {
                            LOG((TL_ERROR, "get_AddressCapabilityString - SysAllocString Failed"));
                            hr = E_OUTOFMEMORY;
                        }
                            
                    }

                    break;
                case ACS_PROVIDERSPECIFIC:
                    if ( m_pDevCaps->dwProviderInfoSize != 0 )
                    {
                        LPWSTR      pHold;
                        DWORD       dwSize;

                        dwSize = m_pDevCaps->dwProviderInfoSize;
                        
                        //
                        // is size divisible by sizeof(WCHAR)?
                        //
                        if (0 == (dwSize % sizeof(WCHAR)))
                        {
                            //
                            // yes - get to the last character in the string
                            //
                            pHold = (LPWSTR)(((LPBYTE)(m_pDevCaps)) + m_pDevCaps->dwProviderInfoOffset) +
                                    (dwSize-sizeof(WCHAR))/sizeof(WCHAR);

                            //
                            // is the last character a NULL?
                            //
                            if (*pHold == NULL)
                            {
                                //
                                // yes, so don't copy it
                                //
                                dwSize-=sizeof(WCHAR);
                            }
                        }

                        //
                        // Alloc and copy into return string.  SysAllocStringByteLen always
                        // appends a NULL
                        //
                        *ppCapabilityString = SysAllocStringByteLen(
                                (LPSTR)(((LPBYTE)(m_pDevCaps)) + m_pDevCaps->dwProviderInfoOffset),
                                dwSize
                                );

                        if ( NULL == *ppCapabilityString )
                        {
                            LOG((TL_ERROR, "get_AddressCapabilityString - SysAllocString Failed"));
                            hr = E_OUTOFMEMORY;
                        }
                            
                    }

                    break;
                case ACS_SWITCHSPECIFIC:
                    if ( m_pDevCaps->dwSwitchInfoSize != 0 )
                    {
                        LPWSTR      pHold;
                        DWORD       dwSize;

                        dwSize = m_pDevCaps->dwSwitchInfoSize;

                        //
                        // is size divisible by sizeof(WCHAR)?
                        //
                        if (0 == (dwSize % sizeof(WCHAR)))
                        {
                            //
                            // yes - get to the last character in the string
                            //
                            pHold = (LPWSTR)(((LPBYTE)(m_pDevCaps)) + m_pDevCaps->dwSwitchInfoOffset) +
                                    (dwSize-sizeof(WCHAR))/sizeof(WCHAR);

                            //
                            // is the last character a NULL?
                            //
                            if (*pHold == NULL)
                            {
                                //
                                // yes, so don't copy it
                                //
                                dwSize-=sizeof(WCHAR);
                            }
                        }

                        //
                        // Alloc and copy into return string.  SysAllocStringByteLen always
                        // appends a NULL
                        //
                        *ppCapabilityString = SysAllocStringByteLen(
                            (LPSTR)(((LPBYTE)(m_pDevCaps)) + m_pDevCaps->dwSwitchInfoOffset),
                            dwSize
                            );
                        
                        if ( NULL == *ppCapabilityString )
                        {
                            LOG((TL_ERROR, "get_AddressCapabilityString - SysAllocString Failed"));
                            hr = E_OUTOFMEMORY;
                        }
                            
                    }

                    break;
                case ACS_PERMANENTDEVICEGUID:
                {
                    LPWSTR pwstrGUIDText;
                    
                    if ( m_dwAPIVersion >= TAPI_VERSION2_2 )
                    {
                        IID iid;

                        iid = m_pDevCaps->PermanentLineGuid;
                        StringFromIID(iid, &pwstrGUIDText);
                        
                        *ppCapabilityString = SysAllocString( pwstrGUIDText );

                        if ( NULL == *ppCapabilityString )
                        {
                            LOG((TL_ERROR, "get_AddressCapabilityString - SysAllocString Failed"));
                            hr = E_OUTOFMEMORY;
                        }
                            
                        
                        CoTaskMemFree( pwstrGUIDText );
                    }
                    else
                    {
                        // return with NULL string & error code
                        hr = TAPI_E_NOTSUPPORTED;
                    }


                    break;
                }

                default:
                    break;
            }

            break;
        }

        default:
            LOG((TL_ERROR, "get_AddressCapabilityString - invalid cap"));

            Unlock();
            
            return E_INVALIDARG;
    }
    
    LOG((TL_TRACE, "get_AddressCapabilityString - Exit - result - %lx", hr));

    Unlock();
    
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CreateBstrCollection(
    IN  BSTR  *     pBstr,
    IN  DWORD       dwCount,
    OUT VARIANT *   pVariant
    )
{
    //
    // create the collection object
    //

    CComObject<CTapiBstrCollection> * pCollection;
    HRESULT hr = CComObject<CTapiBstrCollection>::CreateInstance( &pCollection );

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "CreateBstrCollection - "
            "can't create collection - exit 0x%lx", hr));

        return hr;
    }

    //
    // get the Collection's IDispatch interface
    //

    IDispatch * pDispatch;

    hr = pCollection->_InternalQueryInterface(__uuidof(IDispatch),
                                              (void **) &pDispatch );

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "CreateBstrCollection - "
            "QI for IDispatch on collection failed - exit 0x%lx", hr));

        delete pCollection;

        return hr;
    }

    //
    // Init the collection using an iterator -- pointers to the beginning and
    // the ending element plus one.
    //

    hr = pCollection->Initialize( dwCount,
                                  pBstr,
                                  pBstr + dwCount);

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "CreateBstrCollection - "
            "Initialize on collection failed - exit 0x%lx", hr));
        
        pDispatch->Release();

        return hr;
    }

    //
    // put the IDispatch interface pointer into the variant
    //

    LOG((TL_ERROR, "CreateBstrCollection - "
        "placing IDispatch value %p in variant", pDispatch));

    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDispatch;

    LOG((TL_TRACE, "CreateBstrCollection - exit S_OK"));
 
    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CreateBstrEnumerator(
    IN  BSTR *                  begin,
    IN  BSTR *                  end,
    OUT IEnumBstr **           ppIEnum
    )
{
typedef CSafeComEnum<IEnumBstr, &__uuidof(IEnumBstr), BSTR, _CopyBSTR> CEnumerator;

    HRESULT hr;

    CComObject<CEnumerator> *pEnum = NULL;

    hr = CComObject<CEnumerator>::CreateInstance(&pEnum);

    if (pEnum == NULL)
    {
        LOG((TL_ERROR, "CreateBstrEnumerator - "
            "Could not create enumerator object, 0x%lx", hr));
        return hr;
    }

    IEnumBstr * pIEnum;

    hr = pEnum->_InternalQueryInterface(
        __uuidof(IEnumBstr),
        (void**)&pIEnum
        );

    if (FAILED(hr))
    {
        LOG((TL_ERROR, "CreateBstrEnumerator - "
            "query enum interface failed, 0x%lx", hr));
        delete pEnum;
        return hr;
    }

    hr = pEnum->Init(begin, end, NULL, AtlFlagCopy);

    if (FAILED(hr))
    {
        LOG((TL_ERROR, "CreateBstrEnumerator - "
            "init enumerator object failed, 0x%lx", hr));
        pIEnum->Release();
        return hr;
    }

    *ppIEnum = pIEnum;

    LOG((TL_TRACE, "CreateBstrEnumerator - exit S_OK"));

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::get_CallTreatments(VARIANT * pVariant )
{
    HRESULT         hr = E_NOTIMPL;

    LOG((TL_TRACE, "get_CallTreatments - Enter"));
    LOG((TL_TRACE, "get_CallTreatments - Exit - result - %lx", hr));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::EnumerateCallTreatments(IEnumBstr ** ppEnumCallTreatment )
{
    HRESULT         hr = E_NOTIMPL;

    LOG((TL_TRACE, "EnumerateCallTreatments - Enter"));
    LOG((TL_TRACE, "EnumerateCallTreatments - Exit - result - %lx", hr));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::get_CompletionMessages(VARIANT * pVariant)
{
    HRESULT         hr = E_NOTIMPL;

    LOG((TL_TRACE, "get_CompletionMessages - Enter"));
    LOG((TL_TRACE, "get_CompletionMessages - Exit - result - %lx", hr));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::EnumerateCompletionMessages(IEnumBstr ** ppEnumCompletionMessage)
{
    HRESULT         hr = E_NOTIMPL;

    LOG((TL_TRACE, "EnumerateCompletionMessages - Enter"));
    LOG((TL_TRACE, "EnumerateCompletionMessages - Exit - result - %lx", hr));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::get_DeviceClasses(VARIANT * pVariant)
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "get_DeviceClasses - Enter"));

    //
    // Check arguments.
    //

    if ( TAPIIsBadWritePtr( pVariant, sizeof( VARIANT ) ) )
    {
        LOG((TL_ERROR, "get_DeviceClasses - bad pointer"));

        return E_POINTER;
    }

    Lock();

    hr = UpdateLineDevCaps();

    if ( SUCCEEDED(hr) )
    {
        if ( (m_dwAPIVersion >= TAPI_VERSION2_0) && (0 != m_pDevCaps->dwDeviceClassesOffset) )
        {
            PWSTR       pszDevices;
            DWORD       dwNumDeviceClasses;              
         
            //
            // first count the device classes
            //

            dwNumDeviceClasses = 0;

            pszDevices = (PWSTR)( ( (PBYTE)m_pDevCaps ) + m_pDevCaps->dwDeviceClassesOffset );

            while (NULL != *pszDevices)
            {
                dwNumDeviceClasses++;                

                pszDevices += (lstrlenW(pszDevices) + 1 );
            }

            //
            // allocate an array of BSTR pointers
            //

            BSTR *DeviceClasses = 
                (BSTR *)ClientAlloc(sizeof(BSTR *) * dwNumDeviceClasses);
    
            if (DeviceClasses == NULL)
            {
                LOG((TL_ERROR, "get_DeviceClasses - out of memory"));

                Unlock();

                return E_OUTOFMEMORY;
            }

            //
            // allocate all the BSTRs, copying the device class names
            //

            DWORD       dwCount = 0;

            pszDevices = (PWSTR)( ( (PBYTE)m_pDevCaps ) + m_pDevCaps->dwDeviceClassesOffset );

            for (DWORD i = 0; i < dwNumDeviceClasses; i++)
            {
                LOG((TL_INFO, "get_DeviceClasses - got '%ws'", pszDevices));

                DeviceClasses[i] = SysAllocString(pszDevices);     
                
                if (DeviceClasses[i] == NULL)
                {
                    LOG((TL_ERROR, "get_DeviceClasses - out of memory"));

                    hr = E_OUTOFMEMORY;

                    break;
                }

                dwCount++;

                pszDevices += (lstrlenW(pszDevices) + 1 );
            }

            if ( FAILED(hr) )
            {
                // release all the BSTRs and the array.
                for (i = 0; i < dwCount; i ++)
                {
                    SysFreeString(DeviceClasses[i]);
                }
                
                ClientFree(DeviceClasses);

                Unlock();

                return hr;
            }

            hr = CreateBstrCollection(DeviceClasses, dwCount, pVariant);

            // if the collection is not created, release all the BSTRs.
            if (FAILED(hr))
            {
                LOG((TL_ERROR, "get_DeviceClasses - unable to create collection"));

                for (i = 0; i < dwCount; i ++)
                {
                    SysFreeString(DeviceClasses[i]);
                }
            }

            // delete the pointer array.
            ClientFree(DeviceClasses);
        }
        else
        {
            LOG((TL_ERROR, "get_DeviceClasses - no device classes"));

            //
            // create an empty collection
            //

            hr = CreateBstrCollection(NULL, 0, pVariant);

            if (FAILED(hr))
            {
                LOG((TL_ERROR, "get_DeviceClasses - unable to create collection"));
            }
        }
    }

    Unlock();

    LOG((TL_TRACE, "get_DeviceClasses - Exit - result - %lx", hr));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::EnumerateDeviceClasses(IEnumBstr ** ppEnumDeviceClass)
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "EnumerateDeviceClasses - Enter"));

    //
    // Check arguments.
    //

    if ( TAPIIsBadWritePtr( ppEnumDeviceClass, sizeof( IEnumBstr * ) ) )
    {
        LOG((TL_ERROR, "EnumerateDeviceClasses - bad pointer"));

        return E_POINTER;
    }

    Lock();

    hr = UpdateLineDevCaps();

    if ( SUCCEEDED(hr) )
    {
        if ( (m_dwAPIVersion >= TAPI_VERSION2_0) && (0 != m_pDevCaps->dwDeviceClassesOffset) )
        {
            PWSTR       pszDevices;
            DWORD       dwNumDeviceClasses;              
         
            //
            // first count the device classes
            //

            dwNumDeviceClasses = 0;

            pszDevices = (PWSTR)( ( (PBYTE)m_pDevCaps ) + m_pDevCaps->dwDeviceClassesOffset );

            while (NULL != *pszDevices)
            {
                dwNumDeviceClasses++;                

                pszDevices += (lstrlenW(pszDevices) + 1 );
            }

            //
            // allocate an array of BSTR pointers
            //

            BSTR *DeviceClasses = 
                (BSTR *)ClientAlloc(sizeof(BSTR *) * dwNumDeviceClasses);
    
            if (DeviceClasses == NULL)
            {
                LOG((TL_ERROR, "EnumerateDeviceClasses - out of memory"));

                Unlock();

                return E_OUTOFMEMORY;
            }

            //
            // allocate all the BSTRs, copying the device class names
            //

            DWORD       dwCount = 0;

            pszDevices = (PWSTR)( ( (PBYTE)m_pDevCaps ) + m_pDevCaps->dwDeviceClassesOffset );

            for (DWORD i = 0; i < dwNumDeviceClasses; i++)
            {
                LOG((TL_INFO, "EnumerateDeviceClasses - got '%ws'", pszDevices));

                DeviceClasses[i] = SysAllocString(pszDevices);     
                
                if (DeviceClasses[i] == NULL)
                {
                    LOG((TL_ERROR, "EnumerateDeviceClasses - out of memory"));

                    hr = E_OUTOFMEMORY;

                    break;
                }

                dwCount++;

                pszDevices += (lstrlenW(pszDevices) + 1 );
            }

            if ( FAILED(hr) )
            {
                // release all the BSTRs and the array.
                for (i = 0; i < dwCount; i ++)
                {
                    SysFreeString(DeviceClasses[i]);
                }
                
                ClientFree(DeviceClasses);

                Unlock();

                return hr;
            }

            hr = CreateBstrEnumerator(DeviceClasses, DeviceClasses + dwCount, ppEnumDeviceClass);

            if (FAILED(hr))
            {
                LOG((TL_ERROR, "EnumerateDeviceClasses - unable to create enum"));
            }

            // release all the BSTRs as the enumerator made a copy of them            
            for (i = 0; i < dwCount; i ++)
            {
                SysFreeString(DeviceClasses[i]);
            }                          

            // delete the pointer array.
            ClientFree(DeviceClasses);
        }
        else
        {
            LOG((TL_ERROR, "EnumerateDeviceClasses - no device classes"));

            //
            // create an empty enumeration
            //

            hr = CreateBstrEnumerator(NULL, NULL, ppEnumDeviceClass);

            if (FAILED(hr))
            {
                LOG((TL_ERROR, "EnumerateDeviceClasses - unable to create enumeration"));
            }
        }
        
    }

    Unlock();

    LOG((TL_TRACE, "EnumerateDeviceClasses - Exit - result - %lx", hr));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void
HandleLineDevStateMessage(
                          CTAPI * pTapi,
                          PASYNCEVENTMSG pParams
                         )
{
    LOG((TL_TRACE, "HandleLineDevStateMessage - enter. tapi[%p]", pTapi));

    CAddress * pAddress;
    
    if ( LINEDEVSTATE_REINIT == pParams->Param1 )
    {
        LOG((TL_TRACE, "HandleLineDevStateMessage - LINEDEVSTATE_REINIT"));

        pTapi->AddRef();    
        
        //This is to remove the bug, 4 RE_INIT messages for two objects.
        pTapi->HandleReinit();


        pTapi->Release();


        LOG((TL_TRACE, "HandleLineDevStateMessage - exit"));
        
        return;
    }

    if ( LINEDEVSTATE_TRANSLATECHANGE == pParams->Param1 )
    {
        CTapiObjectEvent::FireEvent(
                                    pTapi,
                                    TE_TRANSLATECHANGE,
                                    NULL,
                                    0,
                                    NULL
                                   );
        return;
    }
    
    if ( !FindAddressObject(
                            (HLINE)(pParams->hDevice),
                            &pAddress
                           ) )
    {
        LOG((TL_WARN, "Can't process LINE_LINEDEVSTATE message"));
        LOG((TL_WARN, "  - cannot find hLine %lx", pParams->hDevice));

        return;
    }

    switch ( pParams->Param1 )
    {
        case LINEDEVSTATE_CONNECTED:
        case LINEDEVSTATE_INSERVICE:
        {
            pAddress->InService( pParams->Param1 );
            break;
        }

        case LINEDEVSTATE_OUTOFSERVICE:
        case LINEDEVSTATE_MAINTENANCE:
        case LINEDEVSTATE_REMOVED:
        case LINEDEVSTATE_DISCONNECTED:
        case LINEDEVSTATE_LOCK:
            pAddress->OutOfService( pParams->Param1 );
            break;

        case LINEDEVSTATE_MSGWAITON:
            
            CAddressEvent::FireEvent(
                                     pAddress,
                                     AE_MSGWAITON,
                                     NULL
                                    );
            break;
            
        case LINEDEVSTATE_MSGWAITOFF:
            
            CAddressEvent::FireEvent(
                                     pAddress,
                                     AE_MSGWAITOFF,
                                     NULL
                                    );
            break;

        // the line has been opened or
        // closed by another app
        case LINEDEVSTATE_OPEN:
        case LINEDEVSTATE_CLOSE:
            break;
            
        case LINEDEVSTATE_CAPSCHANGE:
            pAddress->CapsChange( FALSE );
            break;
            
        case LINEDEVSTATE_CONFIGCHANGE:
        {
            CAddressEvent::FireEvent(
                                     pAddress,
                                     AE_CONFIGCHANGE,
                                     NULL
                                    );
            break;
        }
            
        case LINEDEVSTATE_RINGING:
        {
            CAddressEvent::FireEvent(
                                     pAddress,
                                     AE_RINGING,
                                     NULL
                                    );
            break;
        }
            
        case LINEDEVSTATE_DEVSPECIFIC:

        case LINEDEVSTATE_OTHER:
        
        case LINEDEVSTATE_NUMCALLS:
        case LINEDEVSTATE_NUMCOMPLETIONS:
        case LINEDEVSTATE_TERMINALS:
        case LINEDEVSTATE_ROAMMODE:
        case LINEDEVSTATE_BATTERY:
        case LINEDEVSTATE_SIGNAL:
        case LINEDEVSTATE_COMPLCANCEL:
            LOG((TL_INFO, "LINE_LINEDEVSTATE message not handled - %lx", pParams->Param1));
            break;
            
        default:
            LOG((TL_WARN, "Unknown LINE_LINEDEVSTATE message - %lx", pParams->Param1));
            break;
    }

    //FindAddressObject addrefs the address objct
    pAddress->Release();
    
    LOG((TL_TRACE, "HandleLineDevStateMessage - exit."));

    return;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void
HandleAddressStateMessage(
                          PASYNCEVENTMSG pParams
                         )
{
    CAddress * pAddress;

    
    if ( !FindAddressObject(
                            (HLINE)(pParams->hDevice),
                            &pAddress
                           ) )
    {
        LOG((TL_WARN, "Can't process LINE_LINEDEVSTATE message"));
        LOG((TL_WARN, "  - cannot find hLine %lx", pParams->hDevice));

        return;
    }

    switch ( pParams->Param1 )
    {
        case LINEADDRESSSTATE_FORWARD:
        {
            CAddressEvent::FireEvent(
                                     pAddress,
                                     AE_FORWARD,
                                     NULL
                                    );
            break;
        }
        case LINEADDRESSSTATE_CAPSCHANGE:
        {
            pAddress->CapsChange( TRUE );
            break;
        }
        case LINEADDRESSSTATE_OTHER:
        case LINEADDRESSSTATE_DEVSPECIFIC:

        case LINEADDRESSSTATE_INUSEZERO:
        case LINEADDRESSSTATE_INUSEONE:
        case LINEADDRESSSTATE_INUSEMANY:
        case LINEADDRESSSTATE_NUMCALLS:
            
        case LINEADDRESSSTATE_TERMINALS:
            LOG((TL_WARN, "HandleAddressStateMessage - not handled %lx", pParams->Param1));
            break;
        default:
            LOG((TL_WARN, "HandleAddressStateMessage - Unknown %lx", pParams->Param1));
            break;
    }

    //FindAddressObject addrefs the address objct
    pAddress->Release();

    return;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void
CAddress::InService(
                    DWORD dwType
                   )
{
    BOOL        bEvent = FALSE;

    
    switch( dwType )
    {
        case LINEDEVSTATE_CONNECTED:
        case LINEDEVSTATE_INSERVICE:
        default:
            break;
    }
    
    Lock();

    if ( AS_INSERVICE != m_AddressState )
    {
        m_AddressState = AS_INSERVICE;
        bEvent = TRUE;
    }

    Unlock();

    if (bEvent)
    {
        CAddressEvent::FireEvent(
                                 this,
                                 AE_STATE,
                                 NULL
                                );
    }
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void
CAddress::OutOfService(
                       DWORD dwType
                      )
{
    BOOL        bEvent = FALSE;

    
    switch ( dwType )
    {
        case LINEDEVSTATE_OUTOFSERVICE:
        case LINEDEVSTATE_MAINTENANCE:
        case LINEDEVSTATE_REMOVED:
        case LINEDEVSTATE_DISCONNECTED:
        case LINEDEVSTATE_LOCK:
        default:
            break;
    }

    Lock();

    if ( AS_OUTOFSERVICE != m_AddressState )
    {
        m_AddressState = AS_OUTOFSERVICE;
        bEvent = TRUE;
    }
    
    Unlock();

    if ( bEvent )
    {
        CAddressEvent::FireEvent(
                                 this,
                                 AE_STATE,
                                 NULL
                                );
    }
}

void
CAddress::CapsChange( BOOL bAddress )
{
    Lock();

    if (bAddress)
    {
        m_dwAddressFlags |= ADDRESSFLAG_ADDRESSCAPSCHANGE;
    }
    else
    {
        m_dwAddressFlags |= ADDRESSFLAG_DEVCAPSCHANGE;
    }

    Unlock();

    CAddressEvent::FireEvent(
                             this,
                             AE_CAPSCHANGE,
                             NULL
                            );
}

//
// CAddressEvent
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddressEvent::FireEvent(
                         CAddress * pCAddress,
                         ADDRESS_EVENT Event,
                         ITTerminal * pTerminal
                        )
{
    HRESULT                           hr = S_OK;
    CComObject<CAddressEvent>  * p;
    IDispatch                       * pDisp;


    //
    // Check the event filter mask
    // just if is the AE_NEWTERMINAL or AE_REMOVETERMINAL
    // These two events are MSP events and are not filtered by 
    // TapiSrv
    //

    DWORD dwEventFilterMask = 0;
    dwEventFilterMask = pCAddress->GetSubEventsMask( TE_ADDRESS );
    if( !( dwEventFilterMask & GET_SUBEVENT_FLAG(Event)))
    {
        STATICLOG((TL_ERROR, "This event is filtered - %lx", Event));
        return S_OK;
    }

    //
    // create event
    //
    hr = CComObject<CAddressEvent>::CreateInstance( &p );

    if ( !SUCCEEDED(hr) )
    {
        STATICLOG((TL_ERROR, "Could not create AddressEvent object - %lx", hr));
        return hr;
    }


    //
    // initialize
    //
    p->m_Event = Event;
    p->m_pAddress = dynamic_cast<ITAddress *>(pCAddress);
    p->m_pAddress->AddRef();
    p->m_pTerminal = pTerminal;

    if ( NULL != pTerminal )
    {
        pTerminal->AddRef();
    }   

#if DBG
    p->m_pDebug = (PWSTR) ClientAlloc( 1 );
#endif

    //
    // get idisp interface
    //
    hr = p->QueryInterface(
                           IID_IDispatch,
                           (void **)&pDisp
                          );

    if ( !SUCCEEDED(hr) )
    {
        STATICLOG((TL_ERROR, "Could not get disp interface of AddressEvent object %lx", hr));
        
        delete p;
        
        return hr;
    }

    //
    // get callback
    //
    //
    // fire event
    //
    (pCAddress->GetTapi())->Event(
                                  TE_ADDRESS,
                                  pDisp
                                 );

    //
    // release stuff
    //
    pDisp->Release();
    
    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// finalrelease
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void
CAddressEvent::FinalRelease()
{
    LOG((TL_INFO, "CAddressEvent - FinalRelease"));
    
    m_pAddress->Release();

    if ( NULL != m_pTerminal )
    {
        m_pTerminal->Release();
    }    

#if DBG
    ClientFree( m_pDebug );
#endif
}




//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Address
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddressEvent::get_Address(
                           ITAddress ** ppAddress
                          )
{
    if (TAPIIsBadWritePtr(ppAddress , sizeof(ITAddress *) ) )
    {
        LOG((TL_ERROR, "get_Address - bad pointer"));

        return E_POINTER;
    }

    *ppAddress = m_pAddress;
    (*ppAddress)->AddRef();

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Terminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddressEvent::get_Terminal(
                            ITTerminal ** ppTerminal
                           )
{
    if ( TAPIIsBadWritePtr( ppTerminal , sizeof(ITTerminal *) ) )
    {
        LOG((TL_ERROR, "get_Terminal - bad pointer"));

        return E_POINTER;
    }

    if ((m_Event != AE_NEWTERMINAL) && (m_Event != AE_REMOVETERMINAL))
    {
        LOG((TL_ERROR, "get_Terminal - wrong event"));

        return TAPI_E_WRONGEVENT;
    }

    *ppTerminal = m_pTerminal;

    if ( NULL != m_pTerminal )
    {
        m_pTerminal->AddRef();
    }
       
    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Event
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddressEvent::get_Event(
                         ADDRESS_EVENT * pEvent
                        )
{
    if (TAPIIsBadWritePtr(pEvent , sizeof(ADDRESS_EVENT) ) )
    {
        LOG((TL_ERROR, "get_Event - bad pointer"));

        return E_POINTER;
    }

    *pEvent = m_Event;

    return S_OK;
}




///////////////////////////////////////////////////////////////////////////////
//
// CAddressDevSpecificEvent
//

// static
HRESULT CAddressDevSpecificEvent::FireEvent( CAddress * pCAddress,
                                             CCall    * pCall,
                                             long l1,
                                             long l2,
                                             long l3
                                            )
{
    STATICLOG((TL_INFO, "CAddressDevSpecificEvent::FireEvent - enter"));


    //
    // try to create the event
    //

    CComObject<CAddressDevSpecificEvent> *pEventObject = NULL;

    HRESULT hr = CComObject<CAddressDevSpecificEvent>::CreateInstance(&pEventObject);

    if ( FAILED(hr) )
    {
        STATICLOG((TL_ERROR, 
            "CAddressDevSpecificEvent::FireEvent - failed to create CAddressDevSpecificEvent. hr = %lx", 
            hr));

        return hr;
    }


    //
    // initialize the event with the data we received
    //


    //
    // get ITAddress from CAddress we received
    //

    hr = pCAddress->_InternalQueryInterface(IID_ITAddress, (void**)(&(pEventObject->m_pAddress)) );

    if (FAILED(hr))
    {
        STATICLOG((TL_ERROR, 
            "CAddressDevSpecificEvent::FireEvent - failed to create get ITAddress interface from address. hr = %lx", 
            hr));

        delete pEventObject;

        return hr;
    }


    //
    // get ITCallInfo interface from CCall we received
    //


    if (NULL != pCall)
    {

        hr = pCall->_InternalQueryInterface(IID_ITCallInfo, (void**)(&(pEventObject->m_pCall)) );

        if (FAILED(hr))
        {
            STATICLOG((TL_ERROR, 
                "CAddressDevSpecificEvent::FireEvent - failed to create get ITAddress interface from address. hr = %lx", 
                hr));

            //
            // no need to release event's data members, event's destructor will do 
            // this for us
            //

            delete pEventObject;

            return hr;
        }
    }


    //
    // keep the actual data
    //

    pEventObject->m_l1 = l1;
    pEventObject->m_l2 = l2;
    pEventObject->m_l3 = l3;


#if DBG
    pEventObject->m_pDebug = (PWSTR) ClientAlloc( 1 );
#endif


    //
    // get event's idispatch interface
    //

    IDispatch *pDispatch = NULL;

    hr = pEventObject->QueryInterface( IID_IDispatch,
                                       (void **)&pDispatch );

    if ( FAILED(hr) )
    {
        STATICLOG((TL_ERROR, 
            "CAddressDevSpecificEvent::FireEvent - Could not get disp interface of AddressEvent object %lx", 
            hr));

        
        //
        // no need to release event's data members, event's destructor will do 
        // this for us
        //


        //
        // delete the event object
        //

        delete pEventObject;
        
        return hr;
    }


    //
    // from this point on, we will be using events pDispatch
    //

    pEventObject = NULL;


    //
    // get callback
    //
    //
    // fire event to tapi
    //

    hr = (pCAddress->GetTapi())->Event(TE_ADDRESSDEVSPECIFIC, pDispatch);


    //
    // succeeded or not, we no longer need a reference to the event object
    //

    pDispatch->Release();
    pDispatch = NULL;
    
    STATICLOG((TL_INFO, "CAddressDevSpecificEvent::FireEvent - exit, hr = %lx", hr));

    return hr;
}

///////////////////////////////////////////////////////////////////////////////

CAddressDevSpecificEvent::CAddressDevSpecificEvent()
    :m_pAddress(NULL),
    m_pCall(NULL)
{
    LOG((TL_INFO, "CAddressDevSpecificEvent - enter"));

#if DBG
    m_pDebug = NULL;
#endif 


    LOG((TL_INFO, "CAddressDevSpecificEvent - exit"));
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// ~CAddressDevSpecificEvent
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CAddressDevSpecificEvent::~CAddressDevSpecificEvent()
{
    LOG((TL_INFO, "~CAddressDevSpecificEvent - enter"));

    
    if (NULL != m_pAddress)
    {
        m_pAddress->Release();
        m_pAddress = NULL;
    }


    if (NULL != m_pCall)
    {
        m_pCall->Release();
        m_pCall = NULL;
    }


#if DBG
    ClientFree( m_pDebug );
#endif

    LOG((TL_INFO, "~CAddressDevSpecificEvent - exit"));

}




//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Address
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddressDevSpecificEvent::get_Address(
                           ITAddress ** ppAddress
                          )
{
    LOG((TL_TRACE, "get_Address - enter"));


    //
    // good out pointer?
    //

    if (TAPIIsBadWritePtr(ppAddress , sizeof(ITAddress *) ) )
    {
        LOG((TL_ERROR, "get_Address - bad pointer at [%p]", ppAddress));

        return E_POINTER;
    }


    //
    // return addreff'd address
    //

    _ASSERTE(NULL != m_pAddress);

    *ppAddress = m_pAddress;
    (*ppAddress)->AddRef();


    LOG((TL_TRACE, "get_Address - enter. address[%p]", (*ppAddress) ));

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Address
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddressDevSpecificEvent::get_Call(
                           ITCallInfo ** ppCall
                          )
{
    LOG((TL_TRACE, "get_Call - enter"));


    //
    // good out pointer?
    //

    if (TAPIIsBadWritePtr(ppCall, sizeof(ITCallInfo*) ) )
    {
        LOG((TL_ERROR, "get_Call - bad pointer at [%p]", ppCall));

        return E_POINTER;
    }


    //
    // return addreff'd call
    //


    HRESULT hr = S_OK;

    if ( NULL != m_pCall )
    {

        //
        // this event is call specific
        //

        *ppCall = m_pCall;
        (*ppCall)->AddRef();

    }
    else 
    {

        //
        // this event was not call specific
        //

        LOG((TL_WARN, "get_Call - no call"));

        hr = TAPI_E_CALLUNAVAIL;
    }


    LOG(( TL_TRACE, "get_Call - enter. call [%p]. hr = %lx", (*ppCall), hr ));

    return hr;
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_lParam1
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CAddressDevSpecificEvent::get_lParam1( long *pl1 )
{
    LOG((TL_TRACE, "get_lParam1 - enter"));


    //
    // good out pointer?
    //

    if (TAPIIsBadWritePtr(pl1, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_lParam1 - bad pointer at %p", pl1));

        return E_POINTER;
    }


    //
    // log and return the value
    //

    *pl1 = m_l1;

    LOG((TL_TRACE, "get_lParam1 - exit. p1[%ld]", *pl1));


    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_lParam2
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CAddressDevSpecificEvent::get_lParam2( long *pl2 )
{
    LOG((TL_TRACE, "get_lParam2 - enter"));


    //
    // good out pointer?
    //

    if (TAPIIsBadWritePtr(pl2, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_lParam2 - bad pointer at %p", pl2));

        return E_POINTER;
    }


    //
    // log and return the value
    //

    *pl2 = m_l2;

    LOG((TL_TRACE, "get_lParam2 - exit. p2[%ld]", *pl2));


    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_lParam3
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CAddressDevSpecificEvent::get_lParam3( long *pl3 )
{
    LOG((TL_TRACE, "get_lParam3 - enter"));


    //
    // good out pointer?
    //

    if ( TAPIIsBadWritePtr(pl3, sizeof(long)) )
    {
        LOG((TL_ERROR, "get_lParam3 - bad pointer at %p", pl3));

        return E_POINTER;
    }


    //
    // log and return the value
    //

    *pl3 = m_l3;

    LOG((TL_TRACE, "get_lParam3 - exit. p3[%ld]", *pl3));


    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Initialize
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CForwardInfo::Initialize()
{
    HRESULT         hr = S_OK;

    ZeroMemory(
               m_ForwardStructs,
               sizeof( MYFORWARDSTRUCT ) * NUMFORWARDTYPES
              );

    m_lNumRings = 0;
    
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetForwardOffset
//
// maps a forward type to an offset for the array
// in the 
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DWORD
GetForwardOffset(
                 DWORD dwForwardType
                )
{
    switch (dwForwardType)
    {
        case LINEFORWARDMODE_UNCOND:
            return 0;
        case LINEFORWARDMODE_UNCONDINTERNAL:
            return 1;
        case LINEFORWARDMODE_UNCONDEXTERNAL:
            return 2;
        case LINEFORWARDMODE_UNCONDSPECIFIC:
            return 3;
        case LINEFORWARDMODE_BUSY:
            return 4;
        case LINEFORWARDMODE_BUSYINTERNAL:
            return 5;
        case LINEFORWARDMODE_BUSYEXTERNAL:
            return 6;
        case LINEFORWARDMODE_BUSYSPECIFIC:
            return 7;
        case LINEFORWARDMODE_NOANSW:
            return 8;
        case LINEFORWARDMODE_NOANSWINTERNAL:
            return 9;
        case LINEFORWARDMODE_NOANSWEXTERNAL:
            return 10;
        case LINEFORWARDMODE_NOANSWSPECIFIC:
            return 11;
        case LINEFORWARDMODE_BUSYNA:
            return 12;
        case LINEFORWARDMODE_BUSYNAINTERNAL:
            return 13;
        case LINEFORWARDMODE_BUSYNAEXTERNAL:
            return 14;
        case LINEFORWARDMODE_BUSYNASPECIFIC:
            return 15;
        case LINEFORWARDMODE_UNKNOWN:
            return 16;
        case LINEFORWARDMODE_UNAVAIL:
            return 17;
        default:
            return 0;
    }

    return 0;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// put_NumRingsNoAnswer
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CForwardInfo::put_NumRingsNoAnswer(
                                   long lNumRings
                                  )
{
    HRESULT         hr = S_OK;

    Lock();
    
    m_lNumRings = lNumRings;

    Unlock();
    
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_NumRingsNoAnswer
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CForwardInfo::get_NumRingsNoAnswer(
                                   long * plNumRings
                                  )
{
    if (TAPIIsBadWritePtr(plNumRings , sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_NumRingsNoAnswer - bad pointer"));

        return E_POINTER;
    }

    Lock();
    
    *plNumRings = m_lNumRings;

    Unlock();
    
    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// SetForwardType
//
// save the forward type.  overwrite and free is there is already
// a matching type
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CForwardInfo::SetForwardType( 
        long ForwardType, 
        BSTR pDestAddress,
        BSTR pCallerAddress
        )
{
    HRESULT         hr;

    LOG((TL_TRACE, "SetForwardType - enter"));

    hr = SetForwardType2(
                         ForwardType,
                         pDestAddress,
                         0,
                         pCallerAddress,
                         0
                        );
    
    LOG((TL_TRACE, "SetForwardType - exit - %lx", hr));
    
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// SetForwardType2
//
// save the forward type.  overwrite and free is there is already
// a matching type
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CForwardInfo::SetForwardType2( 
        long ForwardType, 
        BSTR pDestAddress,
        long DestAddressType,
        BSTR pCallerAddress,
        long CallerAddressType
        )
{
    HRESULT         hr = S_OK;
    DWORD           dwCount;

    LOG((TL_TRACE, "SetForwardType2 - enter"));

    //
    // check forwardtype
    //
    if ( !IsOnlyOneBitSetInDWORD( ForwardType ) )
    {
        LOG((TL_ERROR, "ForwardType has more than one bit set"));
        return E_INVALIDARG;
    }

    //
    // check destaddress
    //
    if ( pDestAddress == NULL )
    {
        LOG((TL_ERROR, "Forward destaddress cannot be NULL"));
        return E_INVALIDARG;
    }

    if ( IsBadStringPtrW( pDestAddress, -1 ) )
    {
        LOG((TL_ERROR, "Forward destaddress invalid"));
        return E_POINTER;
    }
    
    //
    // check calleraddress
    //
    if ( FORWARDMODENEEDSCALLER( ForwardType ) )
    {
        if ( NULL == pCallerAddress )
        {
            LOG((TL_ERROR, "Forward type needs calleraddress"));
            return E_INVALIDARG;
        }

        if ( IsBadStringPtrW( pCallerAddress, -1 ) )
        {
            LOG((TL_ERROR, "Forward calleraddress invalid"));
            return E_POINTER;
        }
    }

    Lock();
    
    //
    // find correct structure in array
    //
    MYFORWARDSTRUCT * pStruct = NULL;

    pStruct = &(m_ForwardStructs[GetForwardOffset(ForwardType)]);
    
    //
    // free alloced stuff
    //
    if ( NULL != pStruct->bstrDestination )
    {
        SysFreeString( pStruct->bstrDestination );
        pStruct->bstrDestination = NULL;
    }

    if ( NULL != pStruct->bstrCaller )
    {
        SysFreeString( pStruct->bstrCaller );
        pStruct->bstrCaller = NULL;
    }

    //
    // save stuff
    //
    pStruct->bstrDestination = SysAllocString( pDestAddress );
    if ( NULL == pStruct->bstrDestination )
    {
        Unlock();
        
        LOG((TL_ERROR, "Could not alloc dest in put_Forward"));
        return E_OUTOFMEMORY;
    }

    if ( NULL != pCallerAddress )
    {
        pStruct->bstrCaller = SysAllocString( pCallerAddress );
        if ( NULL == pStruct->bstrCaller )
        {
            LOG((TL_ERROR, "Could not calloc caller in put_Forward"));
            SysFreeString( pStruct->bstrDestination );
            Unlock();
            return E_OUTOFMEMORY;
        }
    }

    pStruct->dwDestAddressType = DestAddressType;
    pStruct->dwCallerAddressType = CallerAddressType;
    
    pStruct->dwForwardType = ForwardType;

    Unlock();
    
    LOG((TL_TRACE, "SetForwardType2 - exit - success"));
    
    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_ForwardTypeDestination
//
// will return null if nothing saved
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CForwardInfo::get_ForwardTypeDestination( 
        long ForwardType, 
        BSTR * ppDestAddress 
        )
{
    HRESULT         hr = S_OK;
    DWORD           dwCount;

    LOG((TL_TRACE, "get_ForwardTypeDest - enter"));

    //
    // check forwardtype
    //
    if ( !IsOnlyOneBitSetInDWORD( ForwardType ) )
    {
        LOG((TL_ERROR, "ForwardType has more than one bit set"));
        return E_INVALIDARG;
    }

    
    if ( TAPIIsBadWritePtr( ppDestAddress, sizeof( BSTR ) ) )
    {
        LOG((TL_ERROR, "Bad pointer in get_ForwardTypeDest"));
        return E_POINTER;
    }

    *ppDestAddress = NULL;

    Lock();

    dwCount = GetForwardOffset( ForwardType );
    
    if ( NULL != m_ForwardStructs[dwCount].bstrDestination )
    {
        *ppDestAddress = SysAllocString(
                                        m_ForwardStructs[dwCount].bstrDestination
                                       );

        if ( NULL == *ppDestAddress )
        {
            LOG((TL_ERROR, "OutOfMemory in get_ForwardTypeDest"));

            Unlock();

            return E_POINTER;
        }
    }

    Unlock();
    
    LOG((TL_TRACE, "get_ForwardTypeDest - exit"));
    
    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_ForwardTypeDestinationAddressType
//
// will return null if nothing saved
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CForwardInfo::get_ForwardTypeDestinationAddressType( 
        long ForwardType, 
        long * pDestAddressType 
        )
{
    HRESULT         hr = S_OK;
    DWORD           dwCount;

    LOG((TL_TRACE, "get_ForwardTypeDestinationAddressType - enter"));

    //
    // check forwardtype
    //
    if ( !IsOnlyOneBitSetInDWORD( ForwardType ) )
    {
        LOG((TL_ERROR, "ForwardType has more than one bit set"));
        return E_INVALIDARG;
    }

    
    if ( TAPIIsBadWritePtr( pDestAddressType, sizeof( long ) ) )
    {
        LOG((TL_ERROR, "Bad pointer in get_ForwardTypeDestinationAddressType"));
        return E_POINTER;
    }

    Lock();

    dwCount = GetForwardOffset( ForwardType );

    *pDestAddressType = m_ForwardStructs[dwCount].dwDestAddressType;
    
    Unlock();
    
    LOG((TL_TRACE, "get_ForwardTypeDestinationAddressType - exit"));
    
    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_ForwardTypeCaller
//
// gets the caller save for the specifies forward type
//
// will return NULL in ppCallerAddress if nothing saved
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CForwardInfo::get_ForwardTypeCaller( 
        long ForwardType, 
        BSTR * ppCallerAddress 
        )
{
    HRESULT         hr = S_OK;

    DWORD           dwCount;

    LOG((TL_TRACE, "get_ForwardTypeCaller - enter"));

    //
    // check forwardtype
    //
    if ( !IsOnlyOneBitSetInDWORD( ForwardType ) )
    {
        LOG((TL_ERROR, "ForwardType has more than one bit set"));
        return E_INVALIDARG;
    }

    
    if ( TAPIIsBadWritePtr( ppCallerAddress, sizeof( BSTR ) ) )
    {
        LOG((TL_ERROR, "Bad pointer in get_ForwardTypeCaller"));
        return E_POINTER;
    }

    *ppCallerAddress = NULL;

    Lock();

    dwCount = GetForwardOffset( ForwardType );
    
    if ( NULL != m_ForwardStructs[dwCount].bstrCaller )
    {
        *ppCallerAddress = SysAllocString(
                                          m_ForwardStructs[dwCount].bstrCaller
                                         );

        if ( NULL == *ppCallerAddress )
        {
            LOG((TL_ERROR, "OutOfMemory in get_ForwardTypeCaller"));

            Unlock();

            return E_POINTER;
        }
    }

    Unlock();
    
    LOG((TL_TRACE, "get_ForwardTypeDest - exit"));
    
    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_ForwardTypeCallerAddressType
//
// will return null if nothing saved
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CForwardInfo::get_ForwardTypeCallerAddressType( 
        long ForwardType, 
        long * pCallerAddressType 
        )
{
    HRESULT         hr = S_OK;
    DWORD           dwCount;

    LOG((TL_TRACE, "get_ForwardTypeCallerAddressType - enter"));

    //
    // check forwardtype
    //
    if ( !IsOnlyOneBitSetInDWORD( ForwardType ) )
    {
        LOG((TL_ERROR, "ForwardType has more than one bit set"));
        return E_INVALIDARG;
    }

    
    if ( TAPIIsBadWritePtr( pCallerAddressType, sizeof( long ) ) )
    {
        LOG((TL_ERROR, "Bad pointer in get_ForwardTypeCallerAddressType"));
        return E_POINTER;
    }

    Lock();

    dwCount = GetForwardOffset( ForwardType );

    *pCallerAddressType = m_ForwardStructs[dwCount].dwCallerAddressType;
    
    Unlock();
    
    LOG((TL_TRACE, "get_ForwardTypeCallerAddressType - exit"));
    
    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetForwardType
//
// get the destination and caller based on the type
//
// simply use the vb functions to do this.
//
// will return success even if no info - both addresses will
// be NULL in that case
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CForwardInfo::GetForwardType(
        long ForwardType,
        BSTR * ppDestinationAddress,
        BSTR * ppCallerAddress
        )
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "GetForwardType - enter"));
    
    hr = get_ForwardTypeDestination( ForwardType, ppDestinationAddress );

    if ( !SUCCEEDED(hr) )
    {
        return hr;
    }
    
    hr = get_ForwardTypeCaller( ForwardType, ppCallerAddress );

    if ( !SUCCEEDED(hr) )
    {
        SysFreeString( *ppDestinationAddress );
        return hr;
    }
    
    LOG((TL_TRACE, "GetForwardType - exit"));
    
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetForwardType2
//
// get the destination and caller based on the type
//
// simply use the vb functions to do this.
//
// will return success even if no info - both addresses will
// be NULL in that case
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CForwardInfo::GetForwardType2(
        long ForwardType,
        BSTR * ppDestinationAddress,
        long * pDestAddressType,
        BSTR * ppCallerAddress,
        long * pCallerAddressType
        )
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "GetForwardType2 - enter"));
    
    hr = get_ForwardTypeDestination( ForwardType, ppDestinationAddress );

    if ( !SUCCEEDED(hr) )
    {
        return hr;
    }

    hr = get_ForwardTypeDestinationAddressType( ForwardType, pDestAddressType );

    if ( !SUCCEEDED(hr) )
    {
        SysFreeString( *ppDestinationAddress );
        return hr;
    }
    
    hr = get_ForwardTypeCaller( ForwardType, ppCallerAddress );

    if ( !SUCCEEDED(hr) )
    {
        SysFreeString( *ppDestinationAddress );
        return hr;
    }

    hr = get_ForwardTypeCallerAddressType( ForwardType, pCallerAddressType );

    if ( !SUCCEEDED(hr) )
    {
        SysFreeString( *ppDestinationAddress );
        SysFreeString( *ppCallerAddress );
        return hr;
    }
    
    LOG((TL_TRACE, "GetForwardType2 - exit"));
    
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Clear
//
// clears & frees all info in the forward object
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CForwardInfo::Clear()
{
    HRESULT         hr = S_OK;
    DWORD           dwCount;

    LOG((TL_TRACE, "Clear - enter"));

    Lock();

    //
    // go through all the structs and free
    // related memory
    //
    for (dwCount = 0; dwCount < NUMFORWARDTYPES; dwCount++)
    {
        if ( NULL != m_ForwardStructs[dwCount].bstrDestination )
        {
            SysFreeString( m_ForwardStructs[dwCount].bstrDestination );
        }

        if ( NULL != m_ForwardStructs[dwCount].bstrCaller )
        {
            SysFreeString( m_ForwardStructs[dwCount].bstrCaller );
        }
    }

    //
    // zero out stuff
    //
    ZeroMemory(
               m_ForwardStructs,
               sizeof( MYFORWARDSTRUCT ) * NUMFORWARDTYPES
              );

    Unlock();
    
    LOG((TL_TRACE, "Clear - exit"));
    
    return S_OK;
}
    
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CreateForwardList
//
// Creates a LINEFORWARDLIST structure based on the info
// in the object
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CForwardInfo::CreateForwardList(
                                LINEFORWARDLIST ** ppList
                               )
{
    LINEFORWARDLIST       * pList;
    DWORD                   dwCount;
    DWORD                   dwSize = 0;
    DWORD                   dwOffset;
    DWORD                   dwNumEntries = 0;

    Lock();

    //
    // count the number of entries that are filled
    //
    for (dwCount = 0; dwCount < NUMFORWARDTYPES; dwCount++)
    {
        if ( 0 != m_ForwardStructs[dwCount].dwForwardType )
        {
            dwSize += ( (lstrlenW( m_ForwardStructs[dwCount].bstrDestination ) + 1) * sizeof(WCHAR*));
            dwSize += ( (lstrlenW( m_ForwardStructs[dwCount].bstrCaller ) + 1) * sizeof(WCHAR*));

            dwNumEntries++;
        }
    }

    if ( 0 == dwNumEntries )
    {
        Unlock();
        *ppList = NULL;
        return S_OK;
    }
    
    dwSize += sizeof (LINEFORWARDLIST) +
              sizeof (LINEFORWARD) * dwNumEntries +
              dwSize;


    //
    // alloc structure
    //
    pList = (LINEFORWARDLIST *)ClientAlloc( dwSize );

    if ( NULL == pList )
    {
        LOG((TL_ERROR, "CreateForwardList - OutOfMemory"));

        Unlock();
        
        return E_OUTOFMEMORY;
    }

    //
    // init
    //
    pList->dwTotalSize = dwSize;
    pList->dwNumEntries = dwNumEntries;

    //
    // offset should be past the fixed part of the structure
    //
    dwOffset = sizeof( LINEFORWARDLIST ) + sizeof( LINEFORWARD ) * dwNumEntries;

    dwNumEntries = 0;

    //
    // go through entries again
    //
    for (dwCount = 0; dwCount < NUMFORWARDTYPES; dwCount++)
    {
        if ( 0 != m_ForwardStructs[dwCount].dwForwardType )
        {
            DWORD           dwSize;
            LINEFORWARD   * pEntry = &(pList->ForwardList[dwNumEntries]);
            

            //
            // save the type
            //
            pEntry->dwForwardMode = m_ForwardStructs[dwCount].dwForwardType;

            //
            // save destination - should always be a destination if
            // there is a type
            //
            pEntry->dwDestAddressType = m_ForwardStructs[dwCount].dwDestAddressType; 

            pEntry->dwDestAddressSize = (lstrlenW(m_ForwardStructs[dwCount].bstrDestination) + 1)
                                        * sizeof( WCHAR );
            pEntry->dwDestAddressOffset = dwOffset;
            lstrcpyW(
                     (PWSTR)(((PBYTE)pList)+dwOffset),
                     m_ForwardStructs[dwCount].bstrDestination
                    );

            //
            // fixup offset
            //
            dwOffset += pEntry->dwDestAddressSize;

            //
            // if there is a caller, do the same
            //
            if ( NULL != m_ForwardStructs[dwCount].bstrCaller )
            {
                pEntry->dwCallerAddressType = m_ForwardStructs[dwCount].dwCallerAddressType; 

                pEntry->dwCallerAddressSize = (lstrlenW(m_ForwardStructs[dwCount].bstrCaller) + 1)
                                            * sizeof( WCHAR );
                pEntry->dwCallerAddressOffset = dwOffset;
                lstrcpyW(
                         (PWSTR)(((PBYTE)pList)+dwOffset),
                         m_ForwardStructs[dwCount].bstrCaller
                        );

                dwOffset += pEntry->dwCallerAddressSize;
            }

            dwNumEntries++;
        }
    }

    //
    // return it
    //
    *ppList = pList;

    Unlock();
    
    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// FinalRelease()
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void
CForwardInfo::FinalRelease()
{
    //
    // simply clear it
    //
    Clear();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITAddressTranslation
// Method    : TranslateAddress
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP
CAddress::TranslateAddress(
            BSTR pAddressToTranslate,
            long ulCard,
            long ulTranslateOptions,
            ITAddressTranslationInfo ** ppTranslated
            )
{
    HRESULT                 hr = S_OK;
    LPLINETRANSLATEOUTPUT   pTranslateOutput = NULL;
    PWSTR                   pszDialableString = NULL;
    PWSTR                   pszDisplayableString = NULL;
    CComObject< CAddressTranslationInfo > * pTranslationInfo = NULL;
    long                    lCap = 0;
    BOOL                    bUsePSTNAddressTranslation =  TRUE;
    HLINEAPP                hLineApp;
    DWORD                   dwDeviceID;
          
    
    LOG((TL_TRACE, "TranslateAddress - enter" ));

    if ( !TAPIIsBadWritePtr( ppTranslated, sizeof(ITAddressTranslationInfo *) ) )
    {
        // ppTranslated OK
        if ( !IsBadStringPtrW( pAddressToTranslate, -1 ) )
        {
            //  pAddressToTranslate OK
            
            // Check Addresscap bit
            hr = get_AddressCapability( AC_ADDRESSCAPFLAGS, &lCap );
            if ( SUCCEEDED(hr) )
            {
                if ( lCap & LINEADDRCAPFLAGS_NOPSTNADDRESSTRANSLATION  )
                {
                    bUsePSTNAddressTranslation =  FALSE;
                }
            }

            // create Translate Info object
            hr = CComObject< CAddressTranslationInfo >::CreateInstance( &pTranslationInfo );
            if ( SUCCEEDED(hr) )
            {
                // Translate or copy ?
                if (bUsePSTNAddressTranslation)
                {
                    LOG((TL_INFO, "TranslateAddress - Do address translation" ));

                    Lock();
                    hLineApp = m_hLineApp;
                    dwDeviceID = m_dwDeviceID;
                    Unlock();

                    hr= LineTranslateAddress(
                        hLineApp,
                        dwDeviceID,
                        TAPI_CURRENT_VERSION,
                        (LPCWSTR)pAddressToTranslate,
                        ulCard,
                        ulTranslateOptions,
                        &pTranslateOutput);
                    if(SUCCEEDED(hr) )
                    {
                        // Pull String info out of LPLINETRANSLATEOUTPUT structure
                        pszDialableString   = (PWSTR) ((BYTE*)(pTranslateOutput) + pTranslateOutput->dwDialableStringOffset);
                        pszDisplayableString = (PWSTR) ((BYTE*)(pTranslateOutput) + pTranslateOutput->dwDisplayableStringOffset);
                        
                        hr = pTranslationInfo->Initialize(pszDialableString, 
                                                          pszDisplayableString, 
                                                          pTranslateOutput->dwCurrentCountry,  
                                                          pTranslateOutput->dwDestCountry,     
                                                          pTranslateOutput->dwTranslateResults
                                                          );
                    }
                    else // LinetranslateAddress failed
                    {
                        LOG((TL_ERROR, "TranslateAddress - LineTranslateAddress failed" ));
                    }
                }
                else // copy input string unmodified
                {
                    LOG((TL_INFO, "TranslateAddress - No address translation" ));

                    hr = pTranslationInfo->Initialize(pAddressToTranslate, 
                                                      pAddressToTranslate, 
                                                      0,  
                                                      0,     
                                                      LINETRANSLATERESULT_NOTRANSLATION
                                                     );
                } // end if (bUsePSTNAddressTranslation)

                //
                // Did we translate & initialize output object  ?
                if ( SUCCEEDED(hr) )
                {
                    hr = pTranslationInfo->QueryInterface(IID_ITAddressTranslationInfo,(void**)ppTranslated);

                    if ( SUCCEEDED(hr) )
                    {
                        LOG((TL_TRACE, "TranslateAddress - success"));
                        hr = S_OK;
                    }
                    else
                    {
                        LOG((TL_ERROR, "TranslateAddress - Bad pointer" ));
                        delete pTranslationInfo;
                    }
                    
                }
                else  // object failed to initialize
                {
                    LOG((TL_ERROR, "TranslateAddress - Initialize TranslateInfo object failed" ));
                    delete pTranslationInfo;
                }
            }
            else  // Create instance failed 
            {
                LOG((TL_ERROR, "TranslateAddress - Create TranslateInfo object failed" ));
            }
        }
        else // pAddressToTranslate bad
        {
            LOG((TL_ERROR, "TranslateAddress -pAddressToTranslate invalid"));
            hr = E_POINTER;
        }
    }
    else // ppTranslated bad
    {
        LOG((TL_ERROR, "TranslateAddress - Bad ppTranslated Pointer" ));
        hr = E_POINTER;
    }

    
    if(pTranslateOutput != NULL)
    {
        ClientFree(pTranslateOutput);
    }

    LOG((TL_TRACE, hr, "TranslateAddress - exit" ));
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// TranslateDialog
//
// simply call LineTranslateDialog
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::TranslateDialog(
                          TAPIHWND hwndOwner,
                          BSTR pAddressIn
                         )
{
    HRESULT             hr = E_NOTIMPL;
    HLINEAPP            hLineApp;
    DWORD               dwDeviceID;
    DWORD               dwAPIVersion;
            
    LOG((TL_TRACE, "TranslateDialog - enter:%p", hwndOwner ));
    
    Lock();

    hLineApp = m_hLineApp;
    dwDeviceID = m_dwDeviceID;
    dwAPIVersion = m_dwAPIVersion;

    Unlock();
    
    hr = LineTranslateDialog(
                             dwDeviceID,
                             dwAPIVersion,
                             (HWND)hwndOwner,
                             pAddressIn
                            );

    LOG((TL_TRACE, "TranslateDialog - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITAddressTranslation
// Method    : EnumerateLocations
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAddress::EnumerateLocations (IEnumLocation ** ppEnumLocation )
{
    HRESULT                 hr = S_OK;
    LPLINETRANSLATECAPS     pTranslateCaps = NULL;
    DWORD                   dwNumLocations;    
    DWORD                   dwCount;
    LPLINELOCATIONENTRY     pEntry = NULL;
    
    PWSTR                   pszLocationName;            
    PWSTR                   pszCityCode;                
    PWSTR                   pszLocalAccessCode;         
    PWSTR                   pszLongDistanceAccessCode;  
    PWSTR                   pszTollPrefixList;          
    PWSTR                   pszCancelCallWaitingCode;   
    DWORD                   dwPermanentLocationID;   
    DWORD                   dwCountryCode;           
    DWORD                   dwPreferredCardID;       
    DWORD                   dwCountryID;             
    DWORD                   dwOptions;               
                                                     
    
    LOG((TL_TRACE, "EnumerateLocations - enter" ));

    
    if ( TAPIIsBadWritePtr( ppEnumLocation, sizeof(IEnumLocation *) ) )
    {
        LOG((TL_ERROR, "EnumerateLocations - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        //
        // create the enumerator
        //
        CComObject< CTapiEnum<IEnumLocation, ITLocationInfo, &IID_IEnumLocation> > * pEnum;
        hr = CComObject< CTapiEnum<IEnumLocation, ITLocationInfo, &IID_IEnumLocation> > ::CreateInstance( &pEnum );
    
        if (SUCCEEDED(hr) )
        {
            //
            // initialize it with our Locations list
            //
            pEnum->Initialize();

            hr = LineGetTranslateCaps(m_hLineApp, TAPI_CURRENT_VERSION, &pTranslateCaps);
            if(SUCCEEDED(hr) )
            {
                dwNumLocations = pTranslateCaps->dwNumLocations ;    
        
                // Find positionn of 1st LINELOCATIONENTRY structure in the LINETRANSLATECAPS structure
                pEntry = (LPLINELOCATIONENTRY) ((BYTE*)(pTranslateCaps) + pTranslateCaps->dwLocationListOffset );
            
                for (dwCount = 0; dwCount < dwNumLocations; dwCount++)
                {
                    // Pull Location Info out of LINELOCATIONENTRY structure
                    pszLocationName           = (PWSTR) ((BYTE*)(pTranslateCaps) + pEntry->dwLocationNameOffset);
                    pszCityCode               = (PWSTR) ((BYTE*)(pTranslateCaps) + pEntry->dwCityCodeOffset);
                    pszLocalAccessCode        = (PWSTR) ((BYTE*)(pTranslateCaps) + pEntry->dwLocalAccessCodeOffset);
                    pszLongDistanceAccessCode = (PWSTR) ((BYTE*)(pTranslateCaps) + pEntry->dwLongDistanceAccessCodeOffset);
                    pszTollPrefixList         = (PWSTR) ((BYTE*)(pTranslateCaps) + pEntry->dwTollPrefixListOffset);
                    pszCancelCallWaitingCode  = (PWSTR) ((BYTE*)(pTranslateCaps) + pEntry->dwCancelCallWaitingOffset);
                    dwPermanentLocationID     = pEntry->dwPermanentLocationID;
                    dwCountryCode             = pEntry->dwCountryCode;
                    dwPreferredCardID         = pEntry->dwPreferredCardID;
                    dwCountryID               = pEntry->dwCountryID;
                    dwOptions                 = pEntry->dwOptions;

                    // create our new LocationInfo Object                
                    CComObject<CLocationInfo> * pLocationInfo;
                    CComObject<CLocationInfo>::CreateInstance( &pLocationInfo );
                    if (SUCCEEDED(hr) )
                    {
                        // initialize the new LocationInfo Object
                        hr = pLocationInfo->Initialize(
                                                       pszLocationName, 
                                                       pszCityCode, 
                                                       pszLocalAccessCode, 
                                                       pszLongDistanceAccessCode, 
                                                       pszTollPrefixList, 
                                                       pszCancelCallWaitingCode , 
                                                       dwPermanentLocationID,
                                                       dwCountryCode,
                                                       dwPreferredCardID,
                                                       dwCountryID,
                                                       dwOptions
                                                      );
                        if (SUCCEEDED(hr) )
                        {
                            // Add it to the enumerator
                            hr = pEnum->Add(pLocationInfo);
                            if (SUCCEEDED(hr))
                            {
                                LOG((TL_INFO, "EnumerateLocations - Added LocationInfo object to enum"));
                            }
                            else
                            {
                                LOG((TL_INFO, "EnumerateLocations - Add LocationInfo object failed"));
                                delete pLocationInfo;
                            }
                        }
                        else
                        {
                            LOG((TL_ERROR, "EnumerateLocations - Init LocationInfo object failed"));
                            delete pLocationInfo;
                        }
                    
                    }
                    else  // CComObject::CreateInstance failed
                    {
                        LOG((TL_ERROR, "EnumerateLocations - Create LocationInfo object failed"));
                    }

                    // Try next location in list
                    pEntry++;
                
                } //for(dwCount.....)
    
                
                //
                // return the Enumerator
                //
                *ppEnumLocation = pEnum;

            }
            else // LineGetTranslateCaps failed
            {
                LOG((TL_ERROR, "EnumerateLocations - LineGetTranslateCaps failed" ));
                pEnum->Release();
            }

        }
        else  // CComObject::CreateInstance failed
        {
            LOG((TL_ERROR, "EnumerateLocations - could not create enum" ));
        }


        // finished with TAPI memory block so release
        if ( pTranslateCaps != NULL )
                ClientFree( pTranslateCaps );
    }
    
    LOG((TL_TRACE, hr, "EnumerateLocations - exit" ));
    return hr;
}

STDMETHODIMP
CAddress::get_Locations( 
            VARIANT * pVariant
            )
{
    IEnumLocation         * pEnumLocation;
    HRESULT                 hr;
    CComObject< CTapiCollection< ITLocationInfo > >         * p;
    LocationArray           TempLocationArray;
    ITLocationInfo        * pLocation;
    
    
    if ( TAPIIsBadWritePtr( pVariant, sizeof( VARIANT ) ) )
    {
        LOG((TL_ERROR, "get_locations - bad pointer"));

        return E_POINTER;
    }
    
    //
    // create collection object
    //
    CComObject< CTapiCollection< ITLocationInfo > >::CreateInstance( &p );

    if (NULL == p)
    {
        LOG((TL_ERROR, "get_Locations - could not create collection" ));
        
        return E_OUTOFMEMORY;
    }


    hr = EnumerateLocations ( &pEnumLocation );

    if ( !SUCCEEDED(hr) )
    {
        delete p;
        LOG((TL_ERROR, "get_locations - enumerate locations failed"));

        return hr;
    }

    while (TRUE)
    {
        hr = pEnumLocation->Next(1, &pLocation, NULL);

        if ( S_OK != hr )
        {
            break;
        }

        TempLocationArray.Add( pLocation );

        pLocation->Release();
    }

    pEnumLocation->Release();
    
    p->Initialize( TempLocationArray );

    TempLocationArray.Shutdown();
    
    IDispatch * pDisp;
    
    //
    // get the IDispatch interface
    //
    hr = p->_InternalQueryInterface( IID_IDispatch, (void **) &pDisp );

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "get_Locations - could not get IDispatch interface" ));
        
        delete p;
        return hr;
    }

    //
    // put it in the variant
    //
    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDisp;

    LOG((TL_TRACE, "get_Locations exit - return success"));
    
    return S_OK;
    
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITAddressTranslation
// Method    : EnumerateCallingCards
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAddress::EnumerateCallingCards (IEnumCallingCard ** ppCallingCards )
{
    HRESULT                 hr = S_OK;
    LPLINETRANSLATECAPS     pTranslateCaps = NULL;
    DWORD                   dwNumCards;    
    DWORD                   dwCount;
    LPLINECARDENTRY         pEntry = NULL;
    
    PWSTR                   pszCardName;
    PWSTR                   pszSameAreaDialingRule;
    PWSTR                   pszLongDistanceDialingRule;
    PWSTR                   pszInternationalDialingRule;
    DWORD                   dwPermanentCardID;
    DWORD                   dwNumberOfDigits;
    DWORD                   dwOptions;

    
    LOG((TL_TRACE, "EnumerateCallingCards - enter" ));

    
    if ( TAPIIsBadWritePtr( ppCallingCards, sizeof(IEnumCallingCard *) ) )
    {
        LOG((TL_ERROR, "EnumerateCallingCards - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        //
        // create the enumerator
        //
        CComObject< CTapiEnum<IEnumCallingCard, ITCallingCard, &IID_IEnumCallingCard> > * pEnum;
        hr = CComObject< CTapiEnum<IEnumCallingCard, ITCallingCard, &IID_IEnumCallingCard> > ::CreateInstance( &pEnum );
    
        if ( SUCCEEDED(hr) )
        {
            //
            // initialize it with our Locations list
            //
            pEnum->Initialize();

            hr = LineGetTranslateCaps(m_hLineApp, TAPI_CURRENT_VERSION, &pTranslateCaps);
            if( SUCCEEDED(hr) )
            {
                dwNumCards = pTranslateCaps->dwNumCards ;    
        
                // Find positionn of 1st LINECARDENTRY  structure in the LINETRANSLATECAPS structure
                pEntry = (LPLINECARDENTRY) ((BYTE*)(pTranslateCaps) + pTranslateCaps->dwCardListOffset );
            
                for (dwCount = 0; dwCount < dwNumCards; dwCount++)
                {
                    // Pull Location Info out of LINECARDENTRY  structure
                    pszCardName                 = (PWSTR) ((BYTE*)(pTranslateCaps) + pEntry->dwCardNameOffset);
                    pszSameAreaDialingRule      = (PWSTR) ((BYTE*)(pTranslateCaps) + pEntry->dwSameAreaRuleOffset);
                    pszLongDistanceDialingRule  = (PWSTR) ((BYTE*)(pTranslateCaps) + pEntry->dwLongDistanceRuleOffset);
                    pszInternationalDialingRule = (PWSTR) ((BYTE*)(pTranslateCaps) + pEntry->dwInternationalRuleOffset);
                    dwPermanentCardID           = pEntry->dwPermanentCardID;
                    dwNumberOfDigits            = pEntry->dwCardNumberDigits;
                    dwOptions                   = pEntry->dwOptions;

                    // create our new CallingCard Object                
                    CComObject<CCallingCard> * pCallingCard;
                    CComObject<CCallingCard>::CreateInstance( &pCallingCard );
                    if (SUCCEEDED(hr) )
                    {
                        // initialize the new CallingCard Object
                        hr = pCallingCard->Initialize(
                                                       pszCardName,
                                                       pszSameAreaDialingRule,
                                                       pszLongDistanceDialingRule,
                                                       pszInternationalDialingRule,
                                                       dwPermanentCardID,
                                                       dwNumberOfDigits,
                                                       dwOptions
                                                      );
                        if (SUCCEEDED(hr) )
                        {
                            // Add it to the enumerator
                            hr = pEnum->Add(pCallingCard);
                            if (SUCCEEDED(hr))
                            {
                                LOG((TL_INFO, "EnumerateCallingCards - Added CallingCard object to enum"));
                            }
                            else
                            {
                                LOG((TL_INFO, "EnumertateCallingCards - Add CallingCard object failed"));
                                delete pCallingCard;
                            }
                        }
                        else
                        {
                            LOG((TL_ERROR, "EnumerateCallingCards - Init CallingCard object failed"));
                            delete pCallingCard;
                        }
                    
                    }
                    else  // CComObject::CreateInstance failed
                    {
                        LOG((TL_ERROR, "EnumerateCallingCards - Create CallingCard object failed"));
                    }

                    // Try next card in list
                    pEntry++;
                
                } //for(dwCount.....)
    
                
                //
                // return the Enumerator
                //
                *ppCallingCards = pEnum;
            }
            else // LineGetTranslateCaps failed
            {
                LOG((TL_ERROR, "EnumerateCallingCards - LineGetTranslateCaps failed" ));
                pEnum->Release();
            }

        }
        else  // CComObject::CreateInstance failed
        {
            LOG((TL_ERROR, "EnumerateCallingCards - could not create enum" ));
        }


        // finished with TAPI memory block so release
        if ( pTranslateCaps != NULL )
                ClientFree( pTranslateCaps );
    }
    LOG((TL_TRACE, hr, "EnumerateCallingCards - exit" ));
    return hr;
}

STDMETHODIMP
CAddress::get_CallingCards( 
            VARIANT * pVariant
            )
{
    IEnumCallingCard      * pEnumCallingCards;
    HRESULT                 hr;
    CComObject< CTapiCollection< ITCallingCard > >         * p;
    CallingCardArray        TempCallingCardArray;
    ITCallingCard         * pCallingCard;

    
    if ( TAPIIsBadWritePtr( pVariant, sizeof( VARIANT ) ) )
    {
        LOG((TL_ERROR, "get_CallingCard - bad pointer"));

        return E_POINTER;
    }
    
    //
    // create collection object
    //
    CComObject< CTapiCollection< ITCallingCard > >::CreateInstance( &p );

    if (NULL == p)
    {
        LOG((TL_ERROR, "get_CallingCards - could not create collection" ));
        
        return E_OUTOFMEMORY;
    }


    hr = EnumerateCallingCards ( &pEnumCallingCards );

    if ( !SUCCEEDED(hr) )
    {
        delete p;
        LOG((TL_ERROR, "get_CallingCards - enumerate callingcards failed"));

        return hr;
    }

    while (TRUE)
    {
        hr = pEnumCallingCards->Next(1, &pCallingCard, NULL);

        if ( S_OK != hr )
        {
            break;
        }

        TempCallingCardArray.Add( pCallingCard );

        pCallingCard->Release();
    }

    pEnumCallingCards->Release();
    
    p->Initialize( TempCallingCardArray );

    TempCallingCardArray.Shutdown();
    
    IDispatch * pDisp;
    
    //
    // get the IDispatch interface
    //
    hr = p->_InternalQueryInterface( IID_IDispatch, (void **) &pDisp );

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "get_CallingCards - could not get IDispatch interface" ));
        
        delete p;
        return hr;
    }

    //
    // put it in the variant
    //
    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDisp;

    LOG((TL_TRACE, "get_CallingCards exit - return success"));
    
    return S_OK;
    
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Method    : GetPhoneArrayFromTapiAndPrune
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::GetPhoneArrayFromTapiAndPrune( 
                                        PhoneArray *pPhoneArray,
                                        BOOL bPreferredOnly
                                       )
{
    HRESULT         hr;
    CTAPI         * pCTapi;
    ITPhone       * pPhone;
    CPhone        * pCPhone;

    LOG((TL_TRACE, "GetPhoneArrayFromTapiAndPrune enter"));

    if ( IsBadReadPtr( pPhoneArray, sizeof( PhoneArray ) ) )
    {
        LOG((TL_ERROR, "GetPhoneArrayFromTapiAndPrune - bad pointer"));

        return E_POINTER;
    }
               
    pCTapi = GetTapi();
    
    if( NULL == pCTapi )
    {
        LOG((TL_ERROR, "dynamic cast operation failed"));
        hr = E_POINTER;
    }
    else
    {   
        hr = pCTapi->GetPhoneArray( pPhoneArray );

        if ( SUCCEEDED(hr) )
        {
            //
            // Go through the phones
            //
            for(int iCount = 0; iCount < pPhoneArray->GetSize(); iCount++)
            {
                pPhone = (*pPhoneArray)[iCount];

                pCPhone = dynamic_cast<CPhone *>(pPhone);

                if ( NULL == pCPhone )
                {
                    //
                    // We have a bad pointer in our phone array.
                    // Lets skip it and move on.
                    //

                    _ASSERTE(FALSE);
                    continue;   
                }

                //
                // Is the phone on this address?
                //
                if ( bPreferredOnly ? pCPhone->IsPhoneOnPreferredAddress(this) : pCPhone->IsPhoneOnAddress(this) )
                {
                    LOG((TL_INFO, "GetPhoneArrayFromTapiAndPrune - found matching phone - %p", pPhone));
                }
                else
                {
                    // No, remove it from the array
                    pPhoneArray->RemoveAt(iCount);
                    iCount--;
                }
            }         
        }
    }

    LOG((TL_TRACE, "GetPhoneArrayFromTapiAndPrune - exit - return %lx", hr ));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITAddress2
// Method    : get_Phones
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::get_Phones(
                     VARIANT * pPhones
                     )
{
    HRESULT         hr;
    IDispatch     * pDisp;
    PhoneArray      PhoneArray;

    LOG((TL_TRACE, "get_Phones enter"));

    if ( TAPIIsBadWritePtr( pPhones, sizeof( VARIANT ) ) )
    {
        LOG((TL_ERROR, "get_Phones - bad pointer"));

        return E_POINTER;
    }

    hr = GetPhoneArrayFromTapiAndPrune( &PhoneArray, FALSE );
       
    if ( SUCCEEDED(hr) )
    {
        CComObject< CTapiCollection< ITPhone > > * p;
        CComObject< CTapiCollection< ITPhone > >::CreateInstance( &p );
    
        if (NULL == p)
        {
            LOG((TL_ERROR, "get_Phones - could not create collection" ));

            PhoneArray.Shutdown();
            return E_OUTOFMEMORY;
        }

        // get the IDispatch interface
        hr = p->_InternalQueryInterface( IID_IDispatch, (void **) &pDisp );

        if (S_OK != hr)
        {
            LOG((TL_ERROR, "get_Phones - could not get IDispatch interface" ));
        
            delete p;
            return hr;
        }

        Lock();
    
        // initialize
        hr = p->Initialize( PhoneArray );

        Unlock();

        PhoneArray.Shutdown();

        if (S_OK != hr)
        {
            LOG((TL_ERROR, "get_Phones - could not initialize collection" ));
        
            pDisp->Release();
            return hr;
        }

        // put it in the variant

        VariantInit(pPhones);
        pPhones->vt = VT_DISPATCH;
        pPhones->pdispVal = pDisp;
    }

    LOG((TL_TRACE, "get_Phones - exit - return %lx", hr ));
    
    return hr;
}
   
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITAddress2
// Method    : EnumeratePhones
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::EnumeratePhones(
                          IEnumPhone ** ppEnumPhone
                          )
{
    HRESULT     hr;
    PhoneArray  PhoneArray;

    LOG((TL_TRACE, "EnumeratePhones - enter"));
    LOG((TL_TRACE, "   ppEnumPhone----->%p", ppEnumPhone ));

    if ( TAPIIsBadWritePtr( ppEnumPhone, sizeof( IEnumPhone * ) ) )
    {
        LOG((TL_ERROR, "EnumeratePhones - bad pointer"));

        return E_POINTER;
    }

    hr = GetPhoneArrayFromTapiAndPrune( &PhoneArray, FALSE );
       
    if ( SUCCEEDED(hr) )
    {
        //
        // create the enumerator
        //
        CComObject< CTapiEnum< IEnumPhone, ITPhone, &IID_IEnumPhone > > * p;
        hr = CComObject< CTapiEnum< IEnumPhone, ITPhone, &IID_IEnumPhone > >
             ::CreateInstance( &p );

        if (S_OK != hr)
        {
            LOG((TL_ERROR, "EnumeratePhones - could not create enum" ));
        
            PhoneArray.Shutdown();
            return hr;
        }


        Lock();
    
        // initialize it with our phone list
        p->Initialize( PhoneArray );

        Unlock();

        PhoneArray.Shutdown();

        //
        // return it
        //
        *ppEnumPhone = p;
    }

    LOG((TL_TRACE, "EnumeratePhones - exit - return %lx", hr ));
    
    return hr;
} 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITAddress2
// Method    : get_PreferredPhones
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::get_PreferredPhones(
                              VARIANT * pPhones
                             )
{
    HRESULT         hr;
    IDispatch     * pDisp;
    PhoneArray      PhoneArray;

    LOG((TL_TRACE, "get_PreferredPhones enter"));

    if ( TAPIIsBadWritePtr( pPhones, sizeof( VARIANT ) ) )
    {
        LOG((TL_ERROR, "get_PreferredPhones - bad pointer"));

        return E_POINTER;
    }

    hr = GetPhoneArrayFromTapiAndPrune( &PhoneArray, TRUE );
       
    if ( SUCCEEDED(hr) )
    {
        CComObject< CTapiCollection< ITPhone > > * p;
        CComObject< CTapiCollection< ITPhone > >::CreateInstance( &p );
    
        if (NULL == p)
        {
            LOG((TL_ERROR, "get_PreferredPhones - could not create collection" ));

            PhoneArray.Shutdown();
            return E_OUTOFMEMORY;
        }

        // get the IDispatch interface
        hr = p->_InternalQueryInterface( IID_IDispatch, (void **) &pDisp );

        if (S_OK != hr)
        {
            LOG((TL_ERROR, "get_PreferredPhones - could not get IDispatch interface" ));
        
            delete p;
            return hr;
        }

        Lock();
    
        // initialize
        hr = p->Initialize( PhoneArray );

        Unlock();

        PhoneArray.Shutdown();

        if (S_OK != hr)
        {
            LOG((TL_ERROR, "get_PreferredPhones - could not initialize collection" ));
        
            pDisp->Release();
            return hr;
        }

        // put it in the variant

        VariantInit(pPhones);
        pPhones->vt = VT_DISPATCH;
        pPhones->pdispVal = pDisp;
    }

    LOG((TL_TRACE, "get_PreferredPhones - exit - return %lx", hr ));
    
    return hr;
}
   
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITAddress2
// Method    : EnumeratePreferredPhones
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::EnumeratePreferredPhones(
                                   IEnumPhone ** ppEnumPhone
                                  )
{
    HRESULT     hr;
    PhoneArray  PhoneArray;

    LOG((TL_TRACE, "EnumeratePreferredPhones - enter"));
    LOG((TL_TRACE, "   ppEnumPhone----->%p", ppEnumPhone ));

    if ( TAPIIsBadWritePtr( ppEnumPhone, sizeof( IEnumPhone * ) ) )
    {
        LOG((TL_ERROR, "EnumeratePreferredPhones - bad pointer"));

        return E_POINTER;
    }

    hr = GetPhoneArrayFromTapiAndPrune( &PhoneArray, TRUE );
       
    if ( SUCCEEDED(hr) )
    {
        //
        // create the enumerator
        //
        CComObject< CTapiEnum< IEnumPhone, ITPhone, &IID_IEnumPhone > > * p;
        hr = CComObject< CTapiEnum< IEnumPhone, ITPhone, &IID_IEnumPhone > >
             ::CreateInstance( &p );

        if (S_OK != hr)
        {
            LOG((TL_ERROR, "EnumeratePreferredPhones - could not create enum" ));
        
            PhoneArray.Shutdown();
            return hr;
        }


        Lock();
    
        // initialize it with our phone list
        p->Initialize( PhoneArray );

        Unlock();

        PhoneArray.Shutdown();

        //
        // return it
        //
        *ppEnumPhone = p;
    }

    LOG((TL_TRACE, "EnumeratePreferredPhones - exit - return %lx", hr ));
    
    return hr;
} 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITAddress2
// Method    : GetPhoneFromTerminal
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CAddress::GetPhoneFromTerminal(
                             ITTerminal * pTerminal,
                             ITPhone ** ppPhone
                            )
{
    HRESULT     hr = E_FAIL;
    PhoneArray  PhoneArray;
    ITStaticAudioTerminal * pStaticAudioTerminal;
    LONG lMediaType;
    TERMINAL_DIRECTION nDir;

    LOG((TL_TRACE, "GetPhoneFromTerminal - enter"));

    if ( TAPIIsBadWritePtr( ppPhone, sizeof( ITPhone * ) ) ||
         IsBadReadPtr( pTerminal, sizeof( ITTerminal ) ) )
    {
        LOG((TL_ERROR, "GetPhoneFromTerminal - bad pointer"));

        return E_POINTER;
    }

    *ppPhone = NULL;

    if ( SUCCEEDED(pTerminal->get_MediaType(&lMediaType)) &&
         SUCCEEDED(pTerminal->get_Direction(&nDir))  &&
         (lMediaType == TAPIMEDIATYPE_AUDIO) )
    {
        hr = pTerminal->QueryInterface(IID_ITStaticAudioTerminal, (void **) &pStaticAudioTerminal);

        if ( SUCCEEDED(hr) )
        {
            LONG lWaveId;
    
            hr = pStaticAudioTerminal->get_WaveId(&lWaveId);
   
            if ( SUCCEEDED(hr) )
            {
                LOG((TL_INFO, "GetPhoneFromTerminal - got terminal wave id %d", lWaveId));
               
                hr = GetPhoneArrayFromTapiAndPrune( &PhoneArray, FALSE );

                if ( SUCCEEDED(hr) )
                {
                    ITPhone               * pPhone;
                    CPhone                * pCPhone;
                    int                     iPhoneCount;

                    hr = TAPI_E_NODEVICE;

                    for(iPhoneCount = 0; iPhoneCount < PhoneArray.GetSize(); iPhoneCount++)
                    {
                        pPhone = PhoneArray[iPhoneCount];

                        pCPhone = dynamic_cast<CPhone *>(pPhone);

                        if ( NULL == pCPhone )
                        {
                            //
                            // We have a bad pointer in our phone array.
                            // Lets skip it and move on.
                            //

                            _ASSERTE(FALSE);
                            continue;
                        }

                        if (pCPhone->IsPhoneUsingWaveID( lWaveId, nDir ))
                        {
                            *ppPhone = pPhone;

                            pPhone->AddRef();

                            hr = S_OK;
                            break;
                        }
                    }

                    PhoneArray.Shutdown();
                }
            }

            pStaticAudioTerminal->Release();
        }
    }
  
    LOG((TL_TRACE, "GetPhoneFromTerminal - exit - return %lx", hr ));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITAddress2
// Method    : put_EventFilter
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::put_EventFilter(
    TAPI_EVENT      TapiEvent,
    long            lSubEvent,
    VARIANT_BOOL    bEnable
    )
{
    LOG((TL_TRACE, "put_EventFilter - enter"));

    //
    // Validates the pair TapiEvent - lSubEvent
    // Accept also all subevents
    //
    if( !m_EventMasks.IsSubEventValid( TapiEvent, lSubEvent, TRUE, FALSE) )
    {
        LOG((TL_ERROR, "put_EventFilter - "
            "This event can't be set: %x, return E_INVALIDARG", TapiEvent ));
        return E_INVALIDARG;
    }

    // Enter critical section
    Lock();

    // Set the subevent flag
    HRESULT hr = E_FAIL;
    hr = SetSubEventFlag( 
        TapiEvent, 
        (DWORD)lSubEvent, 
        (bEnable == VARIANT_TRUE)
        );
    
    // Leave critical section
    Unlock();

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITAddress2
// Method    : get_EventFilter
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::get_EventFilter(
        TAPI_EVENT      TapiEvent,
        long            lSubEvent,
        VARIANT_BOOL*   pEnable
        )
{
    LOG((TL_TRACE, "get_EventFilter - enter"));

    //
    // Validates output argument
    //
    if( IsBadReadPtr(pEnable, sizeof(VARIANT_BOOL)) )
    {
        LOG((TL_ERROR, "get_EventFilter - "
            "invalid VARIANT_BOOL pointer, return E_POINTER" ));
        return E_POINTER;
    }

    //
    // Validates the pair TapiEvent - lSubEvent
    // Don't accept all subevents
    //
    if( !m_EventMasks.IsSubEventValid( TapiEvent, lSubEvent, FALSE, FALSE) )
    {
        LOG((TL_ERROR, "get_EventFilter - "
            "This event can't be set: %x, return E_INVALIDARG", TapiEvent ));
        return E_INVALIDARG;
    }

    // Enter critical section
    Lock();

    //
    // Get the subevent mask for that (event, subevent) pair
    //

    BOOL bEnable = FALSE;
    HRESULT hr = GetSubEventFlag(
        TapiEvent,
        (DWORD)lSubEvent,
        &bEnable);

    if( FAILED(hr) )
    {
        LOG((TL_ERROR, "get_EventFilter - "
            "GetSubEventFlag failed, return 0x%08x", hr ));

        // Leave critical section
        Unlock();

        return hr;
    }

    //
    // Set the output argument
    //

    *pEnable = bEnable ? VARIANT_TRUE : VARIANT_FALSE;

    // Leave critical section
    Unlock();

    LOG((TL_TRACE, "get_EventFilter - exit S_OK"));
    return S_OK;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITAddress2
// Method    : DeviceSpecific
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT CAddress::DeviceSpecific(
	     IN ITCallInfo *pCall,
	     IN BYTE *pbDataArray,
	     IN DWORD dwSize
        )
{

    LOG((TL_TRACE, "DeviceSpecific - enter"));


    //
    // check if arguments are any good
    //

    if ( NULL == pbDataArray )
    {
        LOG((TL_ERROR, "DeviceSpecific - pbDataArray is NULL. E_INVALIDARG"));

        return E_INVALIDARG;
    }

    if ( 0 == dwSize )
    {
        LOG((TL_ERROR, "DeviceSpecific - dwSize is 0. E_INVALIDARG"));

        return E_INVALIDARG;
    }

    //
    // check if the buffer is valid
    //

    if ( IsBadReadPtr(pbDataArray, dwSize) )
    {
        LOG((TL_ERROR,
            "DeviceSpecific - bad array passed in [%p] of size %ld",
            pbDataArray, dwSize));

        return E_POINTER;
    }


    //
    // see if the call is obviously bad, and try to get call object pointer if 
    // it is good
    //

    CCall *pCallObject = NULL;

    if (  (NULL != pCall)  )
    {

        //
        // does it point to readable memory at all?
        //
        if ( IsBadReadPtr(pCall, sizeof(ITCallInfo)) )
        {
            LOG((TL_ERROR, "DeviceSpecific - unreadable call pointer [%p]", pCall));

            return E_POINTER;
        }


        //
        // see if call is pointing to a real call object
        //

        try
        {

            pCallObject = dynamic_cast<CCall*>(pCall);
        }
        catch (...)
        {

            //
            // call pointer is really really bad
            //

            LOG((TL_ERROR,
                "DeviceSpecific - exception casting call pointer to a call object, bad call [%p]", 
                pCall));
        }


        //
        // if we could not get the call object pointer, this is not a good call
        //

        if (NULL == pCallObject)
        {

            LOG((TL_ERROR, 
                "DeviceSpecific - could not get call object from call pointer -- bad call pointer argument [%p]", 
                pCall));

            return E_POINTER;

        }


    } // received call pointer that is NULL?
    


    //
    // by this point we know pCall is either NULL or we have a call pointer 
    // that seems (but not guaranteed) to be good
    //


    //
    // prepare all the data for the call to lineDevSpecific
    //
    

    //
    // get hcall from the call
    //

    HCALL hCall = NULL;

    if (NULL != pCallObject)
    {
        hCall = pCallObject->GetHCall();


        //
        // if we there is no call handle, return an error -- the app did not 
        // called Connect on the call
        //

        if (NULL == hCall)
        {
            LOG((TL_ERROR, 
                "DeviceSpecific - no call handle. hr = TAPI_E_INVALCALLSTATE",
                pCall));

            return TAPI_E_INVALCALLSTATE;
        }
    }


    //
    // starting to access data members. lock.
    //

    Lock();


    //
    // get a line to use to communicate devspecific information
    //

    AddressLineStruct *pAddressLine = NULL;

    HRESULT hr = FindOrOpenALine(m_dwMediaModesSupported, &pAddressLine);

    if (FAILED(hr))
    {

        Unlock();

        LOG((TL_TRACE, "DeviceSpecific - FindOrOpenALine failed. hr = %lx", hr));

        return hr;
    }


    DWORD dwAddressID = m_dwAddressID;

    Unlock();


    //
    // make the tapisrv call
    //

    hr = lineDevSpecific( pAddressLine->t3Line.hLine,
                          dwAddressID,
                          hCall,
                          pbDataArray,
                          dwSize
                        );


    //
    // no longer need the line. if registered for address notifications, the 
    // line will remain opened. otherwise, if no one has the line open, it will
    // close -- we are not processing incoming events anyway.
    //

    MaybeCloseALine(&pAddressLine);


    LOG((TL_TRACE, "DeviceSpecific - exit. hr = %lx", hr));

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITAddress2
// Method    : DeviceSpecificVariant
//
// this is the scriptable version of DeviceSpecific
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT CAddress::DeviceSpecificVariant(
	     IN ITCallInfo *pCall,
	     IN VARIANT varDevSpecificByteArray
        )
{
    LOG((TL_TRACE, "DeviceSpecificVariant - enter"));


    //
    // extract buffer from the variant
    //

    DWORD dwByteArraySize = 0;
    BYTE *pBuffer = NULL;

    HRESULT hr = E_FAIL;
    
    hr = MakeBufferFromVariant(varDevSpecificByteArray, &dwByteArraySize, &pBuffer);

    if (FAILED(hr))
    {
        LOG((TL_TRACE, "DeviceSpecificVariant - MakeBufferFromVariant failed. hr = %lx", hr));

        return hr;
    }


    //
    // call the non-scriptable version and pass it the nonscriptable implementation
    //
    
    hr = DeviceSpecific(pCall, pBuffer, dwByteArraySize);


    //
    // success or failure, free the buffer allocated by MakeBufferFromVariant
    //

    ClientFree(pBuffer);
    pBuffer = NULL;


    //
    // log rc and exit
    //

    LOG((TL_TRACE, "DeviceSpecificVariant - exit. hr = %lx", hr));

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITAddress2
// Method    : NegotiateExtVersion
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT CAddress::NegotiateExtVersion (
	     IN long lLowVersion,
	     IN long lHighVersion,
	     OUT long *plExtVersion
        )
{
    
    LOG((TL_TRACE, "NegotiateExtVersion - enter"));

    
    //
    // make sure the out parameter is writable
    //

    if (IsBadWritePtr(plExtVersion, sizeof(long)) )
    {
        LOG((TL_ERROR, "NegotiateExtVersion - output arg [%p] not writeable", plExtVersion));

        return E_POINTER;
    }


    Lock();


    //
    // make a call to tapisrv
    //

    DWORD dwNegotiatedVersion = 0;

    LONG lResult = lineNegotiateExtVersion( m_hLineApp, 
                                            m_dwDeviceID, 
                                            m_dwAPIVersion, 
                                            lLowVersion, 
                                            lHighVersion, 
                                            &dwNegotiatedVersion );

    Unlock();


    HRESULT hr = mapTAPIErrorCode(lResult);


    //
    // return the value on success
    //

    if ( SUCCEEDED(hr) )
    {
        LOG((TL_TRACE, "NegotiateExtVersion - negotiated version %ld", dwNegotiatedVersion));

        *plExtVersion = dwNegotiatedVersion;
    }


    LOG((TL_TRACE, "NegotiateExtVersion - exit. hr = %lx", hr));

    return hr;
}


//
//  ----------------------- CAddressTranslationInfo -----------------------------
//


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddressTranslationInfo
// Method    : Initialize
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddressTranslationInfo::Initialize(
                       PWSTR pszDialableString,                  
                       PWSTR pszDisplayableString,               
                       DWORD dwCurrentCountry, 
                       DWORD dwDestCountry,    
                       DWORD dwTranslateResults
                      )
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "Initialize - enter" ));
    Lock();

    m_dwCurrentCountryCode      = dwCurrentCountry;
    m_dwDestinationCountryCode  = dwDestCountry;
    m_dwTranslationResults      = dwTranslateResults;
    m_szDialableString          = NULL;
    m_szDialableString          = NULL;

    // copy the Dialable String 
    if (pszDialableString!= NULL)
    {
        m_szDialableString = (PWSTR) ClientAlloc((lstrlenW(pszDialableString) + 1) * sizeof (WCHAR));
        if (m_szDialableString != NULL)
        {
            lstrcpyW(m_szDialableString, pszDialableString);

            // Now copy the Displayable String 
            if (pszDisplayableString!= NULL)
            {
                m_szDisplayableString = (PWSTR) ClientAlloc((lstrlenW(pszDisplayableString) + 1) * sizeof (WCHAR));
                if (m_szDisplayableString != NULL)
                {
                    lstrcpyW(m_szDisplayableString, pszDisplayableString);
                }
                else
                {
                    LOG((TL_ERROR, "Initialize - Alloc m_szDisplayableString failed" ));
                    ClientFree( pszDialableString );
                    pszDialableString = NULL;
                    hr = E_OUTOFMEMORY;
                }
            }
    
        }
        else
        {
            LOG((TL_ERROR, "Initialize - Alloc m_szDialableString failed" ));
            hr = E_OUTOFMEMORY;
        }
    }


    Unlock();
    LOG((TL_TRACE, hr, "Initialize - exit" ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddressTranslationInfo
// Method    : FinalRelease
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CAddressTranslationInfo::FinalRelease()
{
    LOG((TL_TRACE, "FinalRelease - enter" ));
    

    if (m_szDialableString != NULL)
    {
        ClientFree( m_szDialableString);
    }

    if (m_szDisplayableString != NULL)
    {
        ClientFree( m_szDisplayableString);
    }

    LOG((TL_TRACE, "FinalRelease - exit" ));
    }


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddressTranslationInfo
// Interface : ITAddressTranslationInfo
// Method    : get_CurrentCountryCode
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddressTranslationInfo::get_CurrentCountryCode(long * CountryCode  )
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_CurrentCountryCode - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( CountryCode  , sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_CurrentCountryCode - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *CountryCode  = m_dwCurrentCountryCode;
    }
    
    Unlock();
    LOG((TL_TRACE, hr, "get_CurrentCountryCode - exit" ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddressTranslationInfo
// Interface : ITAddressTranslationInfo
// Method    : get_DestinationCountryCode
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddressTranslationInfo::get_DestinationCountryCode(long * CountryCode  )
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_DestinationCountryCode - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( CountryCode  , sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_DestinationCountryCode - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *CountryCode  = m_dwDestinationCountryCode;
    }
    Unlock();
    LOG((TL_TRACE, hr, "get_DestinationCountryCode - exit" ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddressTranslationInfo
// Interface : ITAddressTranslationInfo
// Method    : get_TranslationResult
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddressTranslationInfo::get_TranslationResults(long * Results  )
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_TranslationResults - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( Results  , sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_TranslationResults - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *Results  = m_dwTranslationResults;
    }
    Unlock();
    LOG((TL_TRACE, hr, "get_TranslationResults - exit" ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddressTranslationInfo
// Interface : ITAddressTranslationInfo
// Method    : get_DialableString
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddressTranslationInfo::get_DialableString(BSTR * ppDialableString)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_DialableString - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ppDialableString, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_DialableString - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ppDialableString = SysAllocString( m_szDialableString );

        if ( ( NULL == *ppDialableString ) && ( NULL != m_szDialableString ) )
        {
            LOG((TL_TRACE, "SysAllocString Failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    Unlock();
    
    

    LOG((TL_TRACE, hr, "get_DialableString - exit" ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddressTranslationInfo
// Interface : ITAddressTranslationInfo
// Method    : get_DisplayableString
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddressTranslationInfo::get_DisplayableString(BSTR * ppDisplayableString)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_DisplayableString - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ppDisplayableString, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_DisplayableString - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ppDisplayableString = SysAllocString( m_szDisplayableString );
        
        if ( ( NULL == *ppDisplayableString ) && ( NULL != m_szDisplayableString ) )
        {
            LOG((TL_TRACE, "SysAllocString Failed" ));
            hr = E_OUTOFMEMORY;
        }

    }
    Unlock();
    LOG((TL_TRACE, hr, "get_DisplayableString - exit" ));

    return hr;
}




//
//  ----------------------- CCallingCard -----------------------------
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCallingCard
// Method    : Initialize
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CCallingCard::Initialize(
                       PWSTR pszCardName,
                       PWSTR pszSameAreaDialingRule,
                       PWSTR pszLongDistanceDialingRule,
                       PWSTR pszInternationalDialingRule,
                       DWORD dwPermanentCardID,
                       DWORD dwNumberOfDigits,
                       DWORD dwOptions
                      )
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "Initialize - enter" ));
    Lock();

    m_dwPermanentCardID             = dwPermanentCardID;
    m_dwNumberOfDigits              = dwNumberOfDigits;
    m_dwOptions                     = dwOptions;
    m_szCardName                    = NULL;
    m_szSameAreaDialingRule         = NULL;
    m_szLongDistanceDialingRule     = NULL;
    m_szInternationalDialingRule    = NULL;


    // copy the Card Name
    if (pszCardName != NULL)
    {
        m_szCardName = (PWSTR) ClientAlloc((lstrlenW(pszCardName) + 1) * sizeof (WCHAR));
        if (m_szCardName != NULL)
        {
            lstrcpyW(m_szCardName, pszCardName);
        }
        else
        {
            LOG((TL_ERROR, "Initialize - Alloc m_szCardName failed" ));
            hr = E_OUTOFMEMORY;
        }
    }

    // copy the Same Area Dialing Rule
    if (pszSameAreaDialingRule != NULL)
    {
        m_szSameAreaDialingRule = (PWSTR) ClientAlloc((lstrlenW(pszSameAreaDialingRule) + 1) * sizeof (WCHAR));
        if (m_szSameAreaDialingRule != NULL)
        {
            lstrcpyW(m_szSameAreaDialingRule, pszSameAreaDialingRule);
        }
        else
        {
            LOG((TL_ERROR, "Initialize - Alloc m_szSameAreaDialingRule failed" ));
            hr = E_OUTOFMEMORY;
        }
    }

    // copy the Long Distance Dialing Rule
    if (pszLongDistanceDialingRule != NULL)
    {
        m_szLongDistanceDialingRule = (PWSTR) ClientAlloc((lstrlenW(pszLongDistanceDialingRule) + 1) * sizeof (WCHAR));
        if (m_szLongDistanceDialingRule != NULL)
        {
            lstrcpyW(m_szLongDistanceDialingRule, pszLongDistanceDialingRule);
        }
        else
        {
            LOG((TL_ERROR, "Initialize - Alloc m_szLongDistanceDialingRule failed" ));
            hr = E_OUTOFMEMORY;
        }
    }

    //copy the International Dialing Rule
    if (pszInternationalDialingRule != NULL)
    {
        m_szInternationalDialingRule = (PWSTR) ClientAlloc((lstrlenW(pszInternationalDialingRule) + 1) * sizeof (WCHAR));
        if (m_szInternationalDialingRule != NULL)
        {
            lstrcpyW(m_szInternationalDialingRule, pszInternationalDialingRule);
        }
        else
        {
            LOG((TL_ERROR, "Initialize - Alloc m_szInternationalDialingRule failed" ));
            hr = E_OUTOFMEMORY;
        }
    }

    Unlock();
    LOG((TL_TRACE, hr, "Initialize - exit" ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCallingCard
// Method    : FinalRelease
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CCallingCard::FinalRelease()
{
    LOG((TL_TRACE, "FinalRelease - enter" ));
    
    if (m_szCardName != NULL)
    {
        ClientFree(m_szCardName);
    }

    if (m_szSameAreaDialingRule != NULL)
    {
        ClientFree(m_szSameAreaDialingRule);
    }
    
    if (m_szLongDistanceDialingRule != NULL)
    {
        ClientFree(m_szLongDistanceDialingRule);
    }
    
    if (m_szInternationalDialingRule != NULL)
    {
        ClientFree(m_szInternationalDialingRule);
    }

    LOG((TL_TRACE, "FinalRelease - exit" ));
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCallingCard
// Interface : ITCallingCard
// Method    : get_PermanentCardID
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCallingCard::get_PermanentCardID(long * ulCardID)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_PermanentCardID - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ulCardID, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_PermanentCardID - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ulCardID= m_dwPermanentCardID;
    }
    Unlock();
    LOG((TL_TRACE, hr, "get_PermanentCardID - exit" ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCallingCard
// Interface : ITCallingCard
// Method    : get_NumberOfDigits
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCallingCard::get_NumberOfDigits(long * ulDigits)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_NumberOfDigits - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ulDigits, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_NumberOfDigits - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ulDigits= m_dwNumberOfDigits;
    }
    Unlock();
    LOG((TL_TRACE, hr, "get_NumberOfDigits - exit" ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCallingCard
// Interface : ITCallingCard
// Method    : get_Options
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCallingCard::get_Options(long * ulOptions)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_Options - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ulOptions, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_Options - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ulOptions= m_dwOptions;
    }
    Unlock();
    LOG((TL_TRACE, hr, "get_Options - exit" ));

    return hr;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCallingCard
// Interface : ITCallingCard
// Method    : get_CardName
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCallingCard::get_CardName(BSTR * ppCardName)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_CardName - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ppCardName, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_CardName - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ppCardName = SysAllocString( m_szCardName );

        if ( ( NULL == *ppCardName ) && ( NULL != m_szCardName ) )
        {
            LOG((TL_TRACE, "SysAllocString Failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    Unlock();
        
    
    LOG((TL_TRACE, hr, "get_CardName - exit" ));

    return hr;
}


    
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCallingCard
// Interface : ITCallingCard
// Method    : get_SameAreaDialingRule
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCallingCard::get_SameAreaDialingRule(BSTR * ppRule)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_SameAreaDialingRule - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ppRule, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_SameAreaDialingRule - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ppRule = SysAllocString( m_szSameAreaDialingRule );

        if ( ( NULL == *ppRule ) && ( NULL != m_szSameAreaDialingRule ) )
        {
            LOG((TL_TRACE, "SysAllocString Failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    Unlock();

    LOG((TL_TRACE, hr, "get_SameAreaDialingRule - exit" ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCallingCard
// Interface : ITCallingCard
// Method    : get_LongDistanceDialingRule
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCallingCard::get_LongDistanceDialingRule(BSTR * ppRule)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_LongDistanceDialingRule - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ppRule, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_LongDistanceDialingRule - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ppRule = SysAllocString( m_szLongDistanceDialingRule );

        if ( ( NULL == *ppRule ) && ( NULL != m_szLongDistanceDialingRule ) )
        {
            LOG((TL_TRACE, "SysAllocString Failed" ));
            hr = E_OUTOFMEMORY;
        }

    }
    Unlock();

    LOG((TL_TRACE, hr, "get_LongDistanceDialingRule - exit" ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCallingCard
// Interface : ITCallingCard
// Method    : get_InternationalDialingRule
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCallingCard::get_InternationalDialingRule(BSTR * ppRule)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_InternationalDialingRule - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ppRule, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_InternationalDialingRule - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ppRule = SysAllocString( m_szInternationalDialingRule );

        if ( ( NULL == *ppRule ) && ( NULL != m_szInternationalDialingRule ) )
        {
            LOG((TL_TRACE, "SysAllocString Failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    Unlock();

    LOG((TL_TRACE, hr, "get_InternationalDialingRule - exit" ));

    return hr;
}





//
//  ----------------------- CLocationInfo -----------------------------
//


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CLocationInfo
// Method    : Initialize
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CLocationInfo::Initialize(
                       PWSTR pszLocationName, 
                       PWSTR pszCityCode, 
                       PWSTR pszLocalAccessCode, 
                       PWSTR pszLongDistanceAccessCode, 
                       PWSTR pszTollPrefixList, 
                       PWSTR pszCancelCallWaitingCode , 
                       DWORD dwPermanentLocationID,
                       DWORD dwCountryCode,
                       DWORD dwPreferredCardID,
                       DWORD dwCountryID,
                       DWORD dwOptions
                      )
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "Initialize - enter" ));
    Lock();

    m_dwPermanentLocationID     = dwPermanentLocationID;
    m_dwCountryCode             = dwCountryCode;
    m_dwPreferredCardID         = dwPreferredCardID;
    m_dwCountryID               = dwCountryID;
    m_dwOptions                 = dwOptions;
    m_szLocationName            = NULL;
    m_szCityCode                = NULL;
    m_szLocalAccessCode         = NULL;
    m_szLongDistanceAccessCode  = NULL;
    m_szTollPrefixList          = NULL;
    m_szCancelCallWaitingCode   = NULL;

    // copy the Location Name
    if (pszLocationName!= NULL)
    {
        m_szLocationName = (PWSTR) ClientAlloc((lstrlenW(pszLocationName) + 1) * sizeof (WCHAR));
        if (m_szLocationName != NULL)
        {
            lstrcpyW(m_szLocationName, pszLocationName);
        }
        else
        {
            LOG((TL_ERROR, "Initialize - Alloc m_szDialableString failed" ));
            hr = E_OUTOFMEMORY;
        }
    }


    // copy the City Code
    if (pszCityCode != NULL)
    {
        m_szCityCode  = (PWSTR) ClientAlloc((lstrlenW(pszCityCode) + 1) * sizeof (WCHAR));
        if (m_szCityCode  != NULL)
        {
            lstrcpyW(m_szCityCode , pszCityCode);
        }
        else
        {
            LOG((TL_ERROR, "Initialize - Alloc m_szCityCode  failed" ));
            hr = E_OUTOFMEMORY;
        }
    }

    // copy the Local Access Code
    if (pszLocalAccessCode != NULL)
    {
        m_szLocalAccessCode = (PWSTR) ClientAlloc((lstrlenW(pszLocalAccessCode) + 1) * sizeof (WCHAR));
        if (m_szLocalAccessCode != NULL)
        {
            lstrcpyW(m_szLocalAccessCode, pszLocalAccessCode);
        }
        else
        {
            LOG((TL_ERROR, "Initialize - Alloc m_szLocalAccessCode failed" ));
            hr = E_OUTOFMEMORY;
        }
    }

    // copy the Long Distance Access Code
    if (pszLongDistanceAccessCode != NULL)
    {
        m_szLongDistanceAccessCode = (PWSTR) ClientAlloc((lstrlenW(pszLongDistanceAccessCode) + 1) * sizeof (WCHAR));
        if (m_szLongDistanceAccessCode != NULL)
        {
            lstrcpyW(m_szLongDistanceAccessCode, pszLongDistanceAccessCode);
        }
        else
        {
            LOG((TL_ERROR, "Initialize - Alloc m_szLongDistanceAccessCode failed" ));
            hr = E_OUTOFMEMORY;
        }
    }

    // copy the Toll Prefix List
    if (pszTollPrefixList != NULL)
    {
        m_szTollPrefixList = (PWSTR) ClientAlloc((lstrlenW(pszTollPrefixList) + 1) * sizeof (WCHAR));
        if (m_szTollPrefixList != NULL)
        {
            lstrcpyW(m_szTollPrefixList, pszTollPrefixList);
        }
        else
        {
            LOG((TL_ERROR, "Initialize - Alloc m_szTollPrefixList failed" ));
            hr = E_OUTOFMEMORY;
        }
    }

    // copy the Cancel Call Waiting Code
    if (pszCancelCallWaitingCode != NULL)
    {
        m_szCancelCallWaitingCode = (PWSTR) ClientAlloc((lstrlenW(pszCancelCallWaitingCode) + 1) * sizeof (WCHAR));
        if (m_szCancelCallWaitingCode != NULL)
        {
            lstrcpyW(m_szCancelCallWaitingCode, pszCancelCallWaitingCode);
        }
        else
        {
            LOG((TL_ERROR, "Initialize - Alloc m_szCancelCallWaitingCode failed" ));
            hr = E_OUTOFMEMORY;
        }
    }


    Unlock();
    LOG((TL_TRACE, hr, "Initialize - exit" ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CLocationInfo
// Method    : FinalRelease
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CLocationInfo::FinalRelease()
{
    LOG((TL_TRACE, "FinalRelease - enter" ));
    

    if (m_szLocationName != NULL)
    {
        ClientFree( m_szLocationName);
    }

    if (m_szCityCode != NULL)
    {
        ClientFree( m_szCityCode);
    }
    
    if (m_szLocalAccessCode != NULL)
    {
        ClientFree( m_szLocalAccessCode);
    }
    
    if (m_szLongDistanceAccessCode != NULL)
    {
        ClientFree( m_szLongDistanceAccessCode);
    }
    
    if (m_szTollPrefixList != NULL)
    {
        ClientFree( m_szTollPrefixList);
    }
    
    if (m_szCancelCallWaitingCode != NULL)
    {
        ClientFree( m_szCancelCallWaitingCode);
    }

    LOG((TL_TRACE, "FinalRelease - exit" ));
}





//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CLocationInfo
// Interface : ITLocationInfo
// Method    : get_PermanentLocationID
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CLocationInfo::get_PermanentLocationID(long * ulLocationID )
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_PermanentLocationID - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ulLocationID , sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_PermanentLocationID - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ulLocationID = m_dwPermanentLocationID;
    }
    Unlock();
    LOG((TL_TRACE, hr, "get_PermanentLocationID - exit" ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CLocationInfo
// Interface : ITLocationInfo
// Method    : get_CountryCode
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CLocationInfo::get_CountryCode(long * ulCountryCode)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_CountryCode - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ulCountryCode, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_CountryCode - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ulCountryCode= m_dwCountryCode;
    }
    Unlock();
    LOG((TL_TRACE, hr, "get_CountryCode - exit" ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CLocationInfo
// Interface : ITLocationInfo
// Method    : get_CountryID
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CLocationInfo::get_CountryID(long * ulCountryID)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_CountryID - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ulCountryID, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_CountryID - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ulCountryID= m_dwCountryID;
    }
    Unlock();
    LOG((TL_TRACE, hr, "get_CountryID - exit" ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CLocationInfo
// Interface : ITLocationInfo
// Method    : get_Options
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CLocationInfo::get_Options(long * Options)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_Options - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( Options, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_Options - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *Options= m_dwOptions;
    }
    Unlock();
    LOG((TL_TRACE, hr, "get_Options - exit" ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CLocationInfo
// Interface : ITLocationInfo
// Method    : get_PreferredCardID
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CLocationInfo::get_PreferredCardID(long * ulCardID)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_PreferredCardID - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ulCardID, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_PreferredCardID - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ulCardID= m_dwPreferredCardID;
    }
    Unlock();
    LOG((TL_TRACE, hr, "get_PreferredCardID - exit" ));

    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CLocationInfo
// Interface : ITLocationInfo
// Method    : get_LocationName
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CLocationInfo::get_LocationName(BSTR * ppLocationName)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_LocationName - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ppLocationName, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_LocationName - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ppLocationName = SysAllocString( m_szLocationName );

        if ( ( NULL == *ppLocationName ) && ( NULL != m_szLocationName ) )
        {
            LOG((TL_TRACE, "SysAllocString Failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    Unlock();
    
    
    
    LOG((TL_TRACE, hr, "gget_LocationName - exit" ));

    return hr;
}
    
    
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CLocationInfo
// Interface : ITLocationInfo
// Method    : get_CityCode
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CLocationInfo::get_CityCode(BSTR * ppCode)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_CityCode - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ppCode, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_CityCode - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ppCode = SysAllocString( m_szCityCode );

        if ( ( NULL == *ppCode ) && ( NULL != m_szCityCode ) )
        {
            LOG((TL_TRACE, "SysAllocString Failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    Unlock();
    
    LOG((TL_TRACE, hr, "get_CityCode - exit" ));

    return hr;
}
    

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CLocationInfo
// Interface : ITLocationInfo
// Method    : get_LocalAccessCode
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CLocationInfo::get_LocalAccessCode(BSTR * ppCode)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_LocalAccessCode - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ppCode, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_LocalAccessCode - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ppCode = SysAllocString( m_szLocalAccessCode );

        if ( ( NULL == *ppCode ) && ( NULL != m_szLocalAccessCode ) )
        {
            LOG((TL_TRACE, "SysAllocString Failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    Unlock();
   

    LOG((TL_TRACE, hr, "get_LocalAccessCode - exit" ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CLocationInfo
// Interface : ITLocationInfo
// Method    : get_LongDistanceAccessCode
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CLocationInfo::get_LongDistanceAccessCode(BSTR * ppCode )
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_LongDistanceAccessCode - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ppCode , sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_LongDistanceAccessCode - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ppCode = SysAllocString( m_szLongDistanceAccessCode);

        if ( ( NULL == *ppCode ) && ( NULL != m_szLongDistanceAccessCode ) )
        {
            LOG((TL_TRACE, "SysAllocString Failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    Unlock();

    LOG((TL_TRACE, hr, "get_LongDistanceAccessCode - exit" ));

    return hr;
}
    

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CLocationInfo
// Interface : ITLocationInfo
// Method    : get_TollPrefixList
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CLocationInfo::get_TollPrefixList(BSTR * ppTollList)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_TollPrefixList - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ppTollList, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_TollPrefixList - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ppTollList = SysAllocString( m_szTollPrefixList );

        if ( ( NULL == *ppTollList ) && ( NULL != m_szTollPrefixList ) )
        {
            LOG((TL_TRACE, "SysAllocString Failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    Unlock();

    LOG((TL_TRACE, hr, "get_TollPrefixList - exit" ));

    return hr;
}
    

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CLocationInfo
// Interface : ITLocationInfo
// Method    : get_CancelCallWaitingCode
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CLocationInfo::get_CancelCallWaitingCode(BSTR * ppCode)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_CancelCallWaitingCode - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ppCode, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_CancelCallWaitingCode - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ppCode = SysAllocString( m_szCancelCallWaitingCode );

        if ( ( NULL == *ppCode ) && ( NULL != m_szCancelCallWaitingCode ) )
        {
            LOG((TL_TRACE, "SysAllocString Failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    Unlock();
    
    LOG((TL_TRACE, hr, "get_CancelCallWaitingCode - exit" ));

    return hr;
}

BOOL
CAddress::GetMediaMode( long lMediaType, DWORD * pdwMediaMode )
{
    DWORD dwRet = (DWORD)lMediaType;
    DWORD dwHold;

    if (dwRet & AUDIOMEDIAMODES)
    {
        dwHold = m_dwMediaModesSupported & AUDIOMEDIAMODES;

        if ( dwHold == AUDIOMEDIAMODES )
        {
            dwHold = LINEMEDIAMODE_AUTOMATEDVOICE;
        }
        
        dwRet &= ~AUDIOMEDIAMODES;
        dwRet |= dwHold;
    }

    *pdwMediaMode = dwRet;

    if ( (dwRet == 0) ||
         ((dwRet & m_dwMediaModesSupported) != dwRet) ) 
    {
        return FALSE;
    }

    return TRUE;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_LineID
//
// returns the tapi 2 device ID for this line
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::get_LineID(
                     long * plLineID
                    )
{
    LOG((TL_TRACE, "get_LineID - enter"));
    
    if ( TAPIIsBadWritePtr( plLineID, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_LineID - bad pointer"));

        return E_POINTER;
    }

    Lock();

    *plLineID = m_dwDeviceID;

    Unlock();

    LOG((TL_TRACE, "get_LineID - exit"));

    return S_OK;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_AddressID
//
// returns the tapi 2 address ID of this address
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::get_AddressID(
                        long * plAddressID
                       )
{
    LOG((TL_TRACE, "get_AddressID - enter"));
    
    if ( TAPIIsBadWritePtr( plAddressID, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_AddressID - bad pointer"));

        return E_POINTER;
    }

    Lock();

    *plAddressID = m_dwAddressID;

    Unlock();

    LOG((TL_TRACE, "get_AddressID - exit"));

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CAddress::UpdateAddressCaps
//
// must be called in lock
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::UpdateAddressCaps()
{
    HRESULT             hr = S_OK;

    if ( NULL == m_pAddressCaps )
    {
        LPLINEADDRESSCAPS       pTemp;
        CTAPI                 * pCTapi;
        
        pCTapi = GetTapi();
        
        if( NULL == pCTapi )
        {
            LOG((TL_ERROR, "dynamic cast operation failed"));
            hr = E_POINTER;
        }
        else
        {
            hr = pCTapi->GetBuffer( BUFFERTYPE_ADDRCAP,
                                    (UINT_PTR)this,
                                    (LPVOID*)&m_pAddressCaps
                                  );
        }

        if ( !SUCCEEDED(hr) )
        {
            return hr;
        }

        pTemp = m_pAddressCaps;
        
        hr = LineGetAddressCaps(
                                m_hLineApp,
                                m_dwDeviceID,
                                m_dwAddressID,
                                m_dwAPIVersion,
                                &m_pAddressCaps
                               );

        if ( !SUCCEEDED(hr) )
        {
            return hr;
        }

        if ( m_pAddressCaps != pTemp )
        {
            pCTapi->SetBuffer( BUFFERTYPE_ADDRCAP, (UINT_PTR)this, (LPVOID)m_pAddressCaps );
        }
    }

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CAddress::UpdateLineDevCaps
//
// must be called in lock
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::UpdateLineDevCaps()
{
    HRESULT             hr = S_OK;

    if ( NULL == m_pDevCaps )
    {
        LPLINEDEVCAPS           pTemp;
        CTAPI                 * pCTapi;

        pCTapi = GetTapi();
        
        if( NULL == pCTapi )
        {
            LOG((TL_ERROR, "dynamic cast operation failed"));
            hr = E_POINTER;
        }
        else
        {
            hr = pCTapi->GetBuffer( BUFFERTYPE_LINEDEVCAP,
                                    (UINT_PTR)this,
                                    (LPVOID*)&m_pDevCaps
                                  );
        }
        if ( !SUCCEEDED(hr) )
        {
            return hr;
        }

        pTemp = m_pDevCaps;
        
        hr = LineGetDevCaps(
                            m_hLineApp,
                            m_dwDeviceID,
                            m_dwAPIVersion,
                            &m_pDevCaps
                           );

        if ( !SUCCEEDED(hr) )
        {
            return hr;
        }

        if ( m_pDevCaps != pTemp )
        {
            pCTapi->SetBuffer( BUFFERTYPE_LINEDEVCAP, (UINT_PTR)this, (LPVOID)m_pDevCaps );
        }
    }

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// SetAddrCapBuffer
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void
CAddress::SetAddrCapBuffer( LPVOID pBuf )
{
    Lock();

    m_pAddressCaps = (LPLINEADDRESSCAPS)pBuf;

    Unlock();
}
    
void
CAddress::SetLineDevCapBuffer( LPVOID pBuf )
{
    Lock();

    m_pDevCaps = (LPLINEDEVCAPS)pBuf;
    
    Unlock();
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::CreateMSPCall(
                        MSP_HANDLE hCall,
                        DWORD dwReserved,
                        long lMediaType,
                        IUnknown * pOuterUnk,
                        IUnknown ** ppStreamControl
                       )
{
    HRESULT         hr = E_FAIL;
    
    if ( NULL != m_pMSPAggAddress )
    {
        ITMSPAddress * pMSPAddress = GetMSPAddress();
        
        __try
        {

            hr = pMSPAddress->CreateMSPCall(
                                         hCall,
                                         dwReserved,
                                         lMediaType,
                                         pOuterUnk,
                                         ppStreamControl
                                        );

        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {

            //
            // catch any exceptions thrown by the msp, to protect ouirselves from
            // misbehaving msps
            //

            LOG((TL_ERROR, 
                "CreateMSPCall - MSPAddress::CreateMSPCall threw an exception"));

            hr = E_OUTOFMEMORY;
        }

        
        pMSPAddress->Release();

    }

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::ShutdownMSPCall( IUnknown * pStreamControl )
{
    HRESULT     hr = S_FALSE;
    
    if ( NULL != m_pMSPAggAddress )
    {
        ITMSPAddress * pMSPAddress = GetMSPAddress();
        
        hr = pMSPAddress->ShutdownMSPCall( pStreamControl );

        pMSPAddress->Release();
    }

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::ReceiveTSPData(
                         IUnknown * pMSPCall,
                         LPBYTE pBuffer,
                         DWORD dwSize
                        )
{
    HRESULT         hr = E_FAIL;
    
    Lock();
    
    if ( NULL != m_pMSPAggAddress )
    {
        ITMSPAddress * pMSPAddress = GetMSPAddress();
        
        hr = pMSPAddress->ReceiveTSPData(
                                           pMSPCall,
                                           pBuffer,
                                           dwSize
                                          );

        pMSPAddress->Release();
    }

    Unlock();

    return hr;
}
    

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// LINE_SENDMSPMESSAGE handler
//
// give the opaque blob to the msp
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT HandleSendMSPDataMessage( PASYNCEVENTMSG pParams )
{
    CAddress      * pAddress;
    BOOL            bSuccess;
    HRESULT         hr = S_OK;
    IUnknown      * pMSPCall = NULL;;


    LOG((TL_TRACE, "HandleSendMSPDataMessage - enter"));
    

    //
    // find the correct line
    //
    bSuccess = FindAddressObject(
                                 (HLINE)(pParams->hDevice),
                                 &pAddress
                                );

    if (bSuccess)
    {
        CCall     * pCall = NULL;

        if ( NULL != (HCALL)(pParams->Param1) )
        {
            bSuccess = FindCallObject(
                                      (HCALL)(pParams->Param1),
                                      &pCall
                                     );

            if ( !bSuccess )
            {
                LOG((TL_ERROR, "HandleSendMSPDataMessage - couldn't find call %X",pParams->Param1));
        
                //FindAddressObject addrefs the address objct
                pAddress->Release();
    
                return E_FAIL;
            }

            pMSPCall = pCall->GetMSPCall();
        }
        
        //
        // the blob is at the end of the fixed
        // structure
        //


        //
        // get the size of the blob
        //

        DWORD dwSize = pParams->Param2;


        BYTE *pBuffer = NULL;
        
        //
        // if the buffer's not empty, get a pointer to it
        //

        if (0 < dwSize)
        {

            pBuffer = (LPBYTE)(pParams + 1);
        }
        

        //
        // call the msp
        //
        pAddress->ReceiveTSPData(
                                 pMSPCall,
                                 pBuffer,
                                 dwSize
                                );

        if ( pCall )
        {
            pCall->Release();
            
            if ( pMSPCall )
            {
                pMSPCall->Release();
            }
        }
        
        hr = S_OK;

        //FindAddressObject addrefs the address objct
        pAddress->Release();
    
    }
    else
    {
        LOG((TL_ERROR, "HandleSendMSPDataMessage - failed to find address Object %lx",
               pParams->hDevice));
        
        hr = E_FAIL;
    }

    
    LOG((TL_TRACE, "HandleSendMSPDataMessage - exit. hr = %lx", hr));

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// HandleSendTSPData
//
// sends an opaque buffer from the msp to the tsp
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CAddress::HandleSendTSPData( MSP_EVENT_INFO * pEvent )
{
    LOG((TL_INFO, "HandleSendTSPData - enter pEvent %p", pEvent));


    //
    // see if the event is bad
    //

    if (IsBadReadPtr(pEvent, sizeof(MSP_EVENT_INFO) ) )
    {
        LOG((TL_ERROR, "HandleSendTSPData - bad event structure"));

        return E_POINTER;
    }


    HRESULT               hr = S_OK;
    HCALL                 hCall = NULL;
    CCall               * pCall = NULL;
	AddressLineStruct	* pAddressLine = NULL;


    //
    // if we were given msp call handle, find the corresponding call
    //

    if ( NULL != pEvent->hCall)
    {
    
        gpHandleHashTable->Lock();

        hr = gpHandleHashTable->Find( (ULONG_PTR)pEvent->hCall, (ULONG_PTR *)&pCall);

        if ( SUCCEEDED(hr) )
        {

            //
            // found the call, addreff the call and and release the table 
            //

            LOG((TL_INFO, "HandleSendTSPData - Matched handle %X to Call object %p",
                pEvent->hCall, pCall ));

            pCall->AddRef();
    
            gpHandleHashTable->Unlock();


            //
            // get the handle for this call
            //

            hCall = pCall->GetHCall();


            //
            // get call's address line, if any
            //

            pAddressLine = pCall->GetAddRefMyAddressLine();

            LOG((TL_INFO, "HandleSendTSPData - address line[%p] hCall[%lx]",
                pAddressLine, hCall ));

        }
        else
        {

            //
            // there is no corresponding call in the hash table. the call no 
            // longer exists, or msp passed a bugus handle
            //

            gpHandleHashTable->Unlock();

            LOG((TL_ERROR, 
                "HandleSendTSPData - Couldn't match handle %X to Call object. hr = %lx", 
                pEvent->hCall, hr));

            return hr;
        }

    }
   

    //
    // by this point we either had msp call handle that is null or successfully
    // found a matching call object and asked it for its address line
    //
    
	if (NULL == pAddressLine)
	{

        //
        // if we don't have address line, send a message to the first address line on
        // this address (?)
        //

        if ( m_AddressLinesPtrList.size() > 0 )
		{
			PtrList::iterator       iter;

			iter = m_AddressLinesPtrList.begin();

			//
			// send to the tsp
			//
			hr = LineReceiveMSPData(
							   ((AddressLineStruct *)(*iter))->t3Line.hLine,
							   hCall,
							   pEvent->MSP_TSP_DATA.pBuffer,
							   pEvent->MSP_TSP_DATA.dwBufferSize
							  );
		}
		else
		{
            LOG((TL_ERROR, 
                "HandleSendTSPData - no address lines on the address. E_UNEXPECTED"));

            hr = E_UNEXPECTED;
		}
    }
    else
    {

        //
        // if we have an address line, send a message to the corresponding line
        //

        hr = LineReceiveMSPData(
					   pAddressLine->t3Line.hLine,
					   hCall,
					   pEvent->MSP_TSP_DATA.pBuffer,
					   pEvent->MSP_TSP_DATA.dwBufferSize
					  );


        //
        // no longer need our address line, release it. the line will be closed
        // if needed
        //

        pCall->ReleaseAddressLine(pAddressLine);
        pAddressLine = NULL;

    }


    //
    // if we have a call, release it
    //
    
    if (NULL != pCall)
    {
        pCall->Release();
        pCall = NULL;
    }
                           

    LOG((TL_INFO, "HandleSendTSPData - finish hr = %lx", hr));

    return hr;
}


//
// handle dev specific message
//

void HandleLineDevSpecificMessage(  PASYNCEVENTMSG pParams )
{

    LOG((TL_INFO, "HandleLineDevSpecificMessage - enter"));


    //
    // note:
    //
    // unfortunately, the message that we receive does not give us any 
    // indication as to whether hDevice contains a call handle or am address
    // handle.
    //
    // to determine the kind of handle, we have to search both tables. if we 
    // find the corresponding address object, this is a line handle, if we find
    // a corresponding call, this is a call handle. this brute-force search is 
    // fairly expensive. 
    //
    // one possible optimization would be to track the number of calls and 
    // addresses and search the smaller table first. however, this would 
    // require tracking overhead (even in the cases where the optimization is 
    // not needed), and for this to work well, we would also need to estimate
    // the likelyhood of each type of message. which makes this kind of 
    // optimization even more expensive.
    //
    // so we will simply check both tables to determine whether we have a call
    // or an address.
    // 


    CCall *pCall = NULL;
   
    CAddress *pAddress = NULL;


    //
    // find the corresponding address
    //

    if ( !FindAddressObject( (HLINE)(pParams->hDevice), &pAddress ) )
    {

        LOG((TL_WARN, 
            "HandleLineDevSpecificMessage - FindAddressObject failed to find matching address. searching for call"));


        pAddress = NULL;


        //
        // no address, try to find matching call
        //

        if ( !FindCallObject( (HCALL)(pParams->hDevice), &pCall) )
        {
            LOG((TL_ERROR, 
                "HandleLineDevSpecificMessage - FindAddressObject failed to find matching call. "));
      
            return;
        }

    }


    //
    // if we got a call, get the corresponding address object
    //

    if (NULL != pCall)
    {
        ITAddress *pITAddress = NULL;

        HRESULT hr = pCall->get_Address(&pITAddress);

        if (FAILED(hr))
        {
            LOG((TL_ERROR,
                "HandleLineDevSpecificMessage - call does not have an address. hr = %lx", hr));

            pCall->Release();
            pCall = NULL;

            return;
        }

        try
        {

            pAddress = dynamic_cast<CAddress*>(pITAddress);
        }
        catch(...)
        {
            LOG((TL_ERROR,
                "HandleLineDevSpecificMessage - exception using address. address pointer bad"));
        }

        //
        // if the address is bad, return
        //

        if (NULL == pAddress)
        {
       
            LOG((TL_ERROR,
                "HandleLineDevSpecificMessage - no address"));

            pCall->Release();
            pCall = NULL;


            //
            // yes, queryinterface returned us an addreffed pITAddress... but
            // since it does not seem valid anyway, do not bother releasing.
            //

            _ASSERTE(FALSE);

            return;
        }
    
    } // call is not null


    //
    // by this time we must have an address and maybe a call. we actually 
    // ensured this in the logic above. this assert is to make this condition 
    // explicit.
    //

    _ASSERTE( NULL != pAddress );


    //
    // fire event
    //

    CAddressDevSpecificEvent::FireEvent(
                             pAddress,
                             pCall,
                             pParams->Param1,
                             pParams->Param2,
                             pParams->Param3
                            );


    //
    //  undo FindXObject's addreffs
    //

    if (NULL != pAddress)
    {
        pAddress->Release();
        pAddress = NULL;
    }


    if (NULL != pCall)
    {
        pCall->Release();
        pCall = NULL;
    }


    LOG((TL_INFO, "HandleLineDevSpecificMessage - exit. "));
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// HandleMSPAddressEvent
//
// fires an addressevent to the application based on
// an event from the MSP
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CAddress::HandleMSPAddressEvent( MSP_EVENT_INFO * pEvent )
{
    switch ( pEvent->MSP_ADDRESS_EVENT_INFO.Type )
    {
        case ADDRESS_TERMINAL_AVAILABLE:

            CAddressEvent::FireEvent(
                                     this,
                                     AE_NEWTERMINAL,
                                     pEvent->MSP_ADDRESS_EVENT_INFO.pTerminal
                                    );
            break;
            
        case ADDRESS_TERMINAL_UNAVAILABLE:

            CAddressEvent::FireEvent(
                                     this,
                                     AE_REMOVETERMINAL,
                                     pEvent->MSP_ADDRESS_EVENT_INFO.pTerminal
                                    );
            break;
            
        default:
            LOG((TL_ERROR, "HandleMSPAddressEvent - bad event"));
            break;
    }

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// HandleMSPCallEvent
//
// fires a callmediaevent to the application based on an
// event from the msp
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CAddress::HandleMSPCallEvent( MSP_EVENT_INFO * pEvent )
{
    CCall                   * pCall;
    ITCallInfo              * pCallInfo;
    CALL_MEDIA_EVENT          Event;
    CALL_MEDIA_EVENT_CAUSE    Cause;
    ITTerminal              * pTerminal = NULL;
    ITStream                * pStream = NULL;
    HRESULT                   hrEvent = 0;
    HRESULT                   hr = S_OK;


    gpHandleHashTable->Lock();
    hr = gpHandleHashTable->Find( (ULONG_PTR)pEvent->hCall, (ULONG_PTR *)&pCall);

    if ( SUCCEEDED(hr) )
    {
        LOG((TL_INFO, "HandleMSPCallEvent - Matched handle %X to Call object %p", pEvent->hCall, pCall ));

        pCall->AddRef();
        gpHandleHashTable->Unlock();
        
        hr = pCall->QueryInterface(
                                   IID_ITCallInfo,
                                   (void**) &pCallInfo
                                  );
    }
    else // ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "HandleMSPCallEvent - Couldn't match handle %X to Call object ", pEvent->hCall));
        gpHandleHashTable->Unlock();

        return hr;
    }
    

    //
    // set up the info for the event
    // pStream applies to all of the currently-defined events
    //

    pStream   = pEvent->MSP_CALL_EVENT_INFO.pStream;

    //
    // cause is the same, although the MSPI and API use different enumerated types.
    // Note: this will have to expand to a switch if the order of enums ever gets
    // out of sync!
    //

    Cause = (CALL_MEDIA_EVENT_CAUSE) pEvent->MSP_CALL_EVENT_INFO.Cause;

    //
    // Rest depend on the type...
    //

    switch ( pEvent->MSP_CALL_EVENT_INFO.Type )
    {
    
        case CALL_NEW_STREAM:
            Event     = CME_NEW_STREAM;
            break;
            
        case CALL_STREAM_FAIL:
            Event     = CME_STREAM_FAIL;
            hrEvent   = pEvent->MSP_CALL_EVENT_INFO.hrError;
            break;
            
        case CALL_TERMINAL_FAIL:
            Event     = CME_TERMINAL_FAIL;
            pTerminal = pEvent->MSP_CALL_EVENT_INFO.pTerminal;
            hrEvent   = pEvent->MSP_CALL_EVENT_INFO.hrError;
            break;
            
        case CALL_STREAM_NOT_USED:
            Event     = CME_STREAM_NOT_USED;
            break;
            
        case CALL_STREAM_ACTIVE:
            Event     = CME_STREAM_ACTIVE;
            break;
            
        case CALL_STREAM_INACTIVE:
            Event     = CME_STREAM_INACTIVE;
            break;
            
        default:
            LOG((TL_ERROR, "HandleMSPCallEvent - bad event"));

            return E_INVALIDARG;
    }

    //
    // fire the event
    //
    CCallMediaEvent::FireEvent(
                               pCallInfo,
                               Event,
                               Cause,
                               dynamic_cast<CTAPI *>(m_pTAPI),
                               pTerminal,
                               pStream,
                               hrEvent
                              );

    //
    // addref'd above
    //
    pCallInfo->Release();
    pCall->Release();
    
    return S_OK;
}

HRESULT
CAddress::HandleMSPTTSTerminalEvent( MSP_EVENT_INFO * pEvent )
{
    if (NULL == pEvent)
    {
        LOG((TL_ERROR, "HandleMSPTTSTerminalEvent - pEvent  is NULL"));
        return E_POINTER;
    }



    ITAddress *pAddress = dynamic_cast<ITAddress *>(this);

    if (pAddress == NULL)
    {
        LOG((TL_ERROR, "HandleMSPTTSTerminalEvent - can't cast the address %p to ITAddress", this));
        return E_UNEXPECTED;
    }


    CCall      * pCall =  NULL;
    ITCallInfo * pCallInfo =  NULL;

    gpHandleHashTable->Lock();


    HRESULT hr = E_FAIL;

    hr = gpHandleHashTable->Find( (ULONG_PTR)pEvent->hCall, (ULONG_PTR *)&pCall);

    if ( SUCCEEDED(hr) )
    {
        LOG((TL_INFO, "HandleMSPTTSTerminalEvent - Matched handle %X to Call object %p", pEvent->hCall, pCall ));

        pCall->AddRef();
        gpHandleHashTable->Unlock();
        
        hr = pCall->QueryInterface(
                                   IID_ITCallInfo,
                                   (void**) &pCallInfo
                                  );
    }
    else // ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "HandleMSPTTSTerminalEvent - Couldn't match handle %X to Call object ", pEvent->hCall));
        gpHandleHashTable->Unlock();

        return hr;
    }


    //
    // get tapi object and fire the event
    //

    hr = CTTSTerminalEvent::FireEvent(GetTapi(),
                                      pCallInfo,
                                      pEvent->MSP_TTS_TERMINAL_EVENT_INFO.pTTSTerminal,
                                      pEvent->MSP_TTS_TERMINAL_EVENT_INFO.hrErrorCode);

    if (FAILED(hr))
    {

        LOG((TL_ERROR, "HandleMSPTTSTerminalEvent - CFileTerminalEvent::FireEvent failed. hr = %lx", hr));
    }

 
    //
    // we addref'd these above, so release now
    //

    pCallInfo->Release();
    pCall->Release();
    
    return hr;
}

HRESULT
CAddress::HandleMSPASRTerminalEvent( MSP_EVENT_INFO * pEvent )
{
    if (NULL == pEvent)
    {
        LOG((TL_ERROR, "HandleMSPASRTerminalEvent - pEvent  is NULL"));
        return E_POINTER;
    }



    ITAddress *pAddress = dynamic_cast<ITAddress *>(this);

    if (pAddress == NULL)
    {
        LOG((TL_ERROR, "HandleMSPASRTerminalEvent - can't cast the address %p to ITAddress", this));
        return E_UNEXPECTED;
    }


    CCall      * pCall =  NULL;
    ITCallInfo * pCallInfo =  NULL;

    gpHandleHashTable->Lock();


    HRESULT hr = E_FAIL;

    hr = gpHandleHashTable->Find( (ULONG_PTR)pEvent->hCall, (ULONG_PTR *)&pCall);

    if ( SUCCEEDED(hr) )
    {
        LOG((TL_INFO, "HandleMSPASRTerminalEvent - Matched handle %X to Call object %p", pEvent->hCall, pCall ));

        pCall->AddRef();
        gpHandleHashTable->Unlock();
        
        hr = pCall->QueryInterface(
                                   IID_ITCallInfo,
                                   (void**) &pCallInfo
                                  );
    }
    else // ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "HandleMSPASRTerminalEvent - Couldn't match handle %X to Call object ", pEvent->hCall));
        gpHandleHashTable->Unlock();

        return hr;
    }


    //
    // get tapi object and fire the event
    //

    hr = CASRTerminalEvent::FireEvent(GetTapi(),
                                       pCallInfo,
                                       pEvent->MSP_ASR_TERMINAL_EVENT_INFO.pASRTerminal,
                                       pEvent->MSP_ASR_TERMINAL_EVENT_INFO.hrErrorCode);

    if (FAILED(hr))
    {

        LOG((TL_ERROR, "HandleMSPASRTerminalEvent - CFileTerminalEvent::FireEvent failed. hr = %lx", hr));
    }

 
    //
    // we addref'd these above, so release now
    //

    pCallInfo->Release();
    pCall->Release();
    
    return hr;
}

HRESULT
CAddress::HandleMSPToneTerminalEvent( MSP_EVENT_INFO * pEvent )
{
    if (NULL == pEvent)
    {
        LOG((TL_ERROR, "HandleMSPToneTerminalEvent - pEvent  is NULL"));
        return E_POINTER;
    }



    ITAddress *pAddress = dynamic_cast<ITAddress *>(this);

    if (pAddress == NULL)
    {
        LOG((TL_ERROR, "HandleMSPToneTerminalEvent - can't cast the address %p to ITAddress", this));
        return E_UNEXPECTED;
    }


    CCall      * pCall =  NULL;
    ITCallInfo * pCallInfo =  NULL;

    gpHandleHashTable->Lock();


    HRESULT hr = E_FAIL;

    hr = gpHandleHashTable->Find( (ULONG_PTR)pEvent->hCall, (ULONG_PTR *)&pCall);

    if ( SUCCEEDED(hr) )
    {
        LOG((TL_INFO, "HandleMSPToneTerminalEvent - Matched handle %X to Call object %p", pEvent->hCall, pCall ));

        pCall->AddRef();
        gpHandleHashTable->Unlock();
        
        hr = pCall->QueryInterface(
                                   IID_ITCallInfo,
                                   (void**) &pCallInfo
                                  );
    }
    else // ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "HandleMSPToneTerminalEvent - Couldn't match handle %X to Call object ", pEvent->hCall));
        gpHandleHashTable->Unlock();

        return hr;
    }


    //
    // get tapi object and fire the event
    //

    hr = CToneTerminalEvent::FireEvent(GetTapi(),
                                       pCallInfo,
                                       pEvent->MSP_TONE_TERMINAL_EVENT_INFO.pToneTerminal,
                                       pEvent->MSP_TONE_TERMINAL_EVENT_INFO.hrErrorCode);

    if (FAILED(hr))
    {

        LOG((TL_ERROR, "HandleMSPToneTerminalEvent - CFileTerminalEvent::FireEvent failed. hr = %lx", hr));
    }

 
    //
    // we addref'd these above, so release now
    //

    pCallInfo->Release();
    pCall->Release();
    
    return hr;
}


HRESULT
CAddress::HandleMSPFileTerminalEvent( MSP_EVENT_INFO * pEvent )
{

    if (NULL == pEvent)
    {
        LOG((TL_ERROR, "HandleMSPFileTerminalEvent - pEvent  is NULL"));
        return E_POINTER;
    }



    ITAddress *pAddress = dynamic_cast<ITAddress *>(this);

    if (pAddress == NULL)
    {
        LOG((TL_ERROR, "HandleMSPFileTerminalEvent - can't cast the address %p to ITAddress", this));
        return E_UNEXPECTED;
    }


    CCall      * pCall =  NULL;
    ITCallInfo * pCallInfo =  NULL;

    gpHandleHashTable->Lock();


    HRESULT hr = E_FAIL;

    hr = gpHandleHashTable->Find( (ULONG_PTR)pEvent->hCall, (ULONG_PTR *)&pCall);

    if ( SUCCEEDED(hr) )
    {
        LOG((TL_INFO, "HandleMSPFileTerminalEvent - Matched handle %X to Call object %p", pEvent->hCall, pCall ));

        pCall->AddRef();
        gpHandleHashTable->Unlock();
        
        hr = pCall->QueryInterface(
                                   IID_ITCallInfo,
                                   (void**) &pCallInfo
                                  );
    }
    else // ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "HandleMSPFileTerminalEvent - Couldn't match handle %X to Call object ", pEvent->hCall));
        gpHandleHashTable->Unlock();

        return hr;
    }


    //
    // get tapi object and fire the event
    //

    hr = CFileTerminalEvent::FireEvent(this,
                                       GetTapi(),
                                       pCallInfo,
                                       pEvent->MSP_FILE_TERMINAL_EVENT_INFO.TerminalMediaState,
                                       pEvent->MSP_FILE_TERMINAL_EVENT_INFO.ftecEventCause,
                                       pEvent->MSP_FILE_TERMINAL_EVENT_INFO.pParentFileTerminal,
                                       pEvent->MSP_FILE_TERMINAL_EVENT_INFO.pFileTrack,
                                       pEvent->MSP_FILE_TERMINAL_EVENT_INFO.hrErrorCode);

    if (FAILED(hr))
    {

        LOG((TL_ERROR, "HandleMSPFileTerminalEvent - CFileTerminalEvent::FireEvent failed. hr = %lx", hr));
    }

 
    //
    // we addref'd these above, so release now
    //

    pCallInfo->Release();
    pCall->Release();
    
    return hr;
}

HRESULT
CAddress::HandleMSPPrivateEvent( MSP_EVENT_INFO * pEvent )
{
    ITAddress *pAddress = dynamic_cast<ITAddress *>(this);

    if (pAddress == NULL)
    {
        LOG((TL_ERROR, "HandleMSPPrivateEvent - can't cast the address %p to ITAddress", this));
        return E_UNEXPECTED;
    }

    CCall               * pCall =  NULL;
    ITCallInfo          * pCallInfo =  NULL;
    HRESULT               hr;

    gpHandleHashTable->Lock();
    hr = gpHandleHashTable->Find( (ULONG_PTR)pEvent->hCall, (ULONG_PTR *)&pCall);

    if ( SUCCEEDED(hr) )
    {
        LOG((TL_INFO, "HandleMSPPrivateEvent - Matched handle %X to Call object %p", pEvent->hCall, pCall ));

        pCall->AddRef();
        gpHandleHashTable->Unlock();
        
        hr = pCall->QueryInterface(
                                   IID_ITCallInfo,
                                   (void**) &pCallInfo
                                  );
    }
    else // ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "HandleMSPPrivateEvent - Couldn't match handle %X to Call object ", pEvent->hCall));
        gpHandleHashTable->Unlock();

        return hr;
    }
    


    CPrivateEvent::FireEvent(
                             GetTapi(),
                             pCallInfo,
                             pAddress,
                             NULL,
                             pEvent->MSP_PRIVATE_EVENT_INFO.pEvent,
                             pEvent->MSP_PRIVATE_EVENT_INFO.lEventCode
                            );


  
    //
    // addref'd above
    //
    pCallInfo->Release();
    pCall->Release();
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseEvent
//
// releases any reference counts in the event from
// the msp.
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CAddress::ReleaseEvent( MSP_EVENT_INFO * pEvent )
{

    LOG((TL_TRACE, "ReleaseEvent -  enter"));

    switch ( pEvent->Event )
    {
        case ME_ADDRESS_EVENT:

            if (NULL != pEvent->MSP_ADDRESS_EVENT_INFO.pTerminal)
            {
                (pEvent->MSP_ADDRESS_EVENT_INFO.pTerminal)->Release();
            }
            
            break;
            
        case ME_CALL_EVENT:

            if (NULL != pEvent->MSP_CALL_EVENT_INFO.pTerminal)
            {
                (pEvent->MSP_CALL_EVENT_INFO.pTerminal)->Release();
            }
            
            if (NULL != pEvent->MSP_CALL_EVENT_INFO.pStream)
            {
                (pEvent->MSP_CALL_EVENT_INFO.pStream)->Release();
            }
            
            break;
            
        case ME_TSP_DATA:

            break;

        case ME_PRIVATE_EVENT:
            
            if ( NULL != pEvent->MSP_PRIVATE_EVENT_INFO.pEvent )
            {
                (pEvent->MSP_PRIVATE_EVENT_INFO.pEvent)->Release();
            }

            break;

        case ME_FILE_TERMINAL_EVENT:

            if( NULL != pEvent->MSP_FILE_TERMINAL_EVENT_INFO.pParentFileTerminal)
            {
                (pEvent->MSP_FILE_TERMINAL_EVENT_INFO.pParentFileTerminal)->Release();
                pEvent->MSP_FILE_TERMINAL_EVENT_INFO.pParentFileTerminal = NULL;
            }

            if( NULL != pEvent->MSP_FILE_TERMINAL_EVENT_INFO.pFileTrack )
            {
                (pEvent->MSP_FILE_TERMINAL_EVENT_INFO.pFileTrack)->Release();
                pEvent->MSP_FILE_TERMINAL_EVENT_INFO.pFileTrack = NULL;
            }

            break;

        case ME_ASR_TERMINAL_EVENT:

            if( NULL != pEvent->MSP_ASR_TERMINAL_EVENT_INFO.pASRTerminal)
            {
                (pEvent->MSP_ASR_TERMINAL_EVENT_INFO.pASRTerminal)->Release();
            }

            break;

        case ME_TTS_TERMINAL_EVENT:

            if( NULL != pEvent->MSP_TTS_TERMINAL_EVENT_INFO.pTTSTerminal)
            {
                (pEvent->MSP_TTS_TERMINAL_EVENT_INFO.pTTSTerminal)->Release();
            }

            break;

        case ME_TONE_TERMINAL_EVENT:

            if( NULL != pEvent->MSP_TONE_TERMINAL_EVENT_INFO.pToneTerminal)
            {
                (pEvent->MSP_TONE_TERMINAL_EVENT_INFO.pToneTerminal)->Release();
            }

            break;

        default:

            break;
    }


    LOG((TL_TRACE, "ReleaseEvent -  finished"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
// HRESULT
// CAddress::MSPEvent()
//
// gets an event buffer from the MSP
// and calls the relevant event handler
//
// this is _only_ called from the asynceventsthread. this is
// necessary for synchronization of events.
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CAddress::MSPEvent()
{
    DWORD                   dwSize;
    MSP_EVENT_INFO        * pEvent = NULL;
    HRESULT                 hr;

    //
    // Allocate an MSP event buffer -- best guess as to an appropriate
    // size. We need to free it before returning.
    //

    dwSize = sizeof (MSP_EVENT_INFO) + 500;

    pEvent = (MSP_EVENT_INFO *)ClientAlloc( dwSize );

    if ( NULL == pEvent )
    {
        LOG((TL_ERROR, "Alloc failed in MSP event"));

        return E_OUTOFMEMORY;
    }

    pEvent->dwSize = dwSize;

    //
    // Get pointer to msp address object. We need to release it before returning.
    // This must be done while the address object is locked.
    //

    Lock();

    ITMSPAddress * pMSPAddress = GetMSPAddress();

    Unlock();
    
    while (TRUE)
    {
        //
        // Get an event from the event queue. Abort and clean up if
        // allocation fails.
        //

        do
        {
            hr = pMSPAddress->GetEvent(
                                       &dwSize,
                                       (LPBYTE)pEvent
                                      );

            if ( hr == TAPI_E_NOTENOUGHMEMORY)
            {
                ClientFree( pEvent );
                
                pEvent = (MSP_EVENT_INFO *)ClientAlloc( dwSize );

                if ( NULL == pEvent )
                {
                    LOG((TL_ERROR, "Alloc failed in MSP event"));

                    pMSPAddress->Release();

                    return E_OUTOFMEMORY;
                }

                pEvent->dwSize = dwSize;
            }

        } while ( hr == TAPI_E_NOTENOUGHMEMORY );

        //
        // If there is nothing left in the MSP event queue, then stop the
        // outer while loop.
        //

        if ( !SUCCEEDED(hr) )
        {
            break;
        }


        //
        // Call the relevant handler, and do not hold the address lock during
        // the call. 
        //

        switch ( pEvent->Event )
        {
            case ME_ADDRESS_EVENT:

                HandleMSPAddressEvent( pEvent );

                break;

            case ME_CALL_EVENT:

                HandleMSPCallEvent( pEvent );

                break;

            case ME_TSP_DATA:

                HandleSendTSPData( pEvent );

                break;

            case ME_PRIVATE_EVENT:

                HandleMSPPrivateEvent( pEvent );

                break;

            case ME_FILE_TERMINAL_EVENT:

                HandleMSPFileTerminalEvent( pEvent );

                break;

            case ME_ASR_TERMINAL_EVENT:

                HandleMSPASRTerminalEvent( pEvent );

                break;

            case ME_TTS_TERMINAL_EVENT:
                
                HandleMSPTTSTerminalEvent( pEvent );

                break;

            case ME_TONE_TERMINAL_EVENT:

                HandleMSPToneTerminalEvent( pEvent );

               break;

            default:

                break;
        }

        //
        // release any refcounts in the
        // event
        //

        ReleaseEvent( pEvent );
    }

    //
    // We get here when there is nothing more to retrieve from the
    // MSP event queue.
    //

    pMSPAddress->Release();

    ClientFree( pEvent );

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
ITMSPAddress * CAddress::GetMSPAddress()
{
    ITMSPAddress * pMSPAddress = NULL;
    
    if ( NULL != m_pMSPAggAddress )
    {
        m_pMSPAggAddress->QueryInterface(IID_ITMSPAddress, (void**)&pMSPAddress);
    }

    return pMSPAddress;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CAddress::GetID(
                BSTR pDeviceClass,
                DWORD * pdwSize,
                BYTE ** ppDeviceID
               )
{
    HRESULT             hr;
    PtrList::iterator   iter;
    LPVARSTRING         pVarString = NULL;
    
    if ( IsBadStringPtrW( pDeviceClass, -1 ) )
    {
        LOG((TL_ERROR, "GetID - bad string"));

        return E_POINTER;
    }

    if ( TAPIIsBadWritePtr( pdwSize, sizeof(DWORD)))
    {
        LOG((TL_ERROR, "GetID - bad size"));

        return E_POINTER;
    }

    if ( TAPIIsBadWritePtr( ppDeviceID, sizeof(BYTE *) ) )
    {
        LOG((TL_ERROR, "GetID - bad pointer"));

        return E_POINTER;
    }

    Lock();
    
    if ( m_AddressLinesPtrList.size() > 0 )
    {
        iter = m_AddressLinesPtrList.begin();
    }
    else
    {
        Unlock();

        return E_FAIL;
    }
    
    hr = LineGetID(
                   ((AddressLineStruct *)*iter)->t3Line.hLine,
                   m_dwAddressID,
                   NULL,
                   LINECALLSELECT_ADDRESS,
                   &pVarString,
                   pDeviceClass
                  );

    Unlock();

    if ( SUCCEEDED(hr) )
    {
        *ppDeviceID = (BYTE *)CoTaskMemAlloc( pVarString->dwUsedSize );

        if ( *ppDeviceID != NULL )
        {
            CopyMemory(
                       *ppDeviceID,
                       ((LPBYTE)pVarString)+pVarString->dwStringOffset,
                       pVarString->dwStringSize
                      );

            *pdwSize = pVarString->dwStringSize;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    if ( NULL != pVarString )
    {
        ClientFree( pVarString );
    }

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITLegacyAddressMediaControl
// Method    : GetDevConfig
//
// Get Device Config
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::GetDevConfig(
                       BSTR     pDeviceClass,
                       DWORD  * pdwSize,
                       BYTE  ** ppDeviceConfig
                      )
{
    HRESULT             hr;
    LPVARSTRING         pVarString = NULL;
    
    LOG((TL_TRACE, "GetDevConfig -  enter"));

    if ( IsBadStringPtrW( pDeviceClass, -1 ) )
    {
        LOG((TL_ERROR, "GetDevConfig - bad DeviceClass string"));

        return E_POINTER;
    }

    if ( TAPIIsBadWritePtr( pdwSize, sizeof(DWORD)))
    {
        LOG((TL_ERROR, "GetDevConfig - bad size"));

        return E_POINTER;
    }

    if ( TAPIIsBadWritePtr( ppDeviceConfig, sizeof(BYTE*) ) )
    {
        LOG((TL_ERROR, "GetDevConfig - bad buffer pointer"));

        return E_POINTER;
    }

    Lock();
    
    hr = LineGetDevConfig(m_dwDeviceID,
                          &pVarString,
                          pDeviceClass
                         );
        
    Unlock();

    if ( SUCCEEDED(hr) )
    {
        *ppDeviceConfig = (BYTE *)CoTaskMemAlloc( pVarString->dwUsedSize );
        
        if(*ppDeviceConfig != NULL)
        {
    
            CopyMemory(
                       *ppDeviceConfig,
                       ((LPBYTE)pVarString)+pVarString->dwStringOffset,
                       pVarString->dwStringSize
                      );
    
            *pdwSize = pVarString->dwStringSize;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    if ( NULL != pVarString )
    {
        ClientFree( pVarString );
    }

    LOG((TL_TRACE, hr, "GetDevConfig -  exit" ));
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITLegacyAddressMediaControl
// Method    : SetDevConfig
//
// Set Device Config
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::SetDevConfig(
                       BSTR     pDeviceClass,
                       DWORD    dwSize,
                       BYTE   * pDeviceConfig
                      )
{
    HRESULT     hr = S_OK;

    LOG((TL_TRACE, "SetDevConfig - enter"));

    if ( IsBadStringPtrW( pDeviceClass, -1) )
    {
        LOG((TL_ERROR, "SetDevConfig - bad string pointer"));

        return E_POINTER;
    }

    if (dwSize == 0)
    {
        LOG((TL_ERROR, "SetDevConfig - dwSize = 0"));
        return E_INVALIDARG;
    }
    
    if (IsBadReadPtr( pDeviceConfig, dwSize) )
    {
        LOG((TL_ERROR, "SetDevConfig - bad pointer"));

        return E_POINTER;
    }

    
    Lock();

    hr = lineSetDevConfigW(m_dwDeviceID,
                           pDeviceConfig,
                           dwSize,
                           pDeviceClass
                          );

    Unlock();
    
    LOG((TL_TRACE, hr, "SetDevConfig - exit"));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITLegacyAddressMediaControl2
// Method    : ConfigDialog
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::ConfigDialog(
                       HWND   hwndOwner,
                       BSTR   pDeviceClass
                      )
{
    HRESULT     hr = S_OK;

    LOG((TL_TRACE, "ConfigDialog - enter"));
    
    if ( (pDeviceClass != NULL) && IsBadStringPtrW( pDeviceClass, -1) )
    {
        LOG((TL_ERROR, "ConfigDialog - bad string pointer"));

        return E_POINTER;
    }

    Lock();

    hr = LineConfigDialogW(
                          m_dwDeviceID,
                          hwndOwner,
                          pDeviceClass
                         );

    Unlock();
    
    LOG((TL_TRACE, hr, "ConfigDialog - exit"));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITLegacyAddressMediaControl2
// Method    : ConfigDialogEdit
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::ConfigDialogEdit(
                           HWND    hwndOwner,
                           BSTR    pDeviceClass,
                           DWORD   dwSizeIn,
                           BYTE  * pDeviceConfigIn,
                           DWORD * pdwSizeOut,
                           BYTE ** ppDeviceConfigOut
                          )
{
    HRESULT     hr = S_OK;
    LPVARSTRING pVarString = NULL;

    LOG((TL_TRACE, "ConfigDialogEdit - enter"));

    if ( (pDeviceClass != NULL) && IsBadStringPtrW( pDeviceClass, -1) )
    {
        LOG((TL_ERROR, "ConfigDialogEdit - bad string pointer"));

        return E_POINTER;
    } 
    
    if (dwSizeIn == 0)
    {
        LOG((TL_ERROR, "ConfigDialogEdit - dwSize = 0"));

        return E_INVALIDARG;
    }
    
    if (IsBadReadPtr( pDeviceConfigIn, dwSizeIn) )
    {
        LOG((TL_ERROR, "ConfigDialogEdit - bad pointer"));

        return E_POINTER;
    }

    if ( TAPIIsBadWritePtr( pdwSizeOut, sizeof(DWORD)))
    {
        LOG((TL_ERROR, "ConfigDialogEdit - bad size"));

        return E_POINTER;
    }

    if ( TAPIIsBadWritePtr( ppDeviceConfigOut, sizeof(BYTE*) ) )
    {
        LOG((TL_ERROR, "ConfigDialogEdit - bad buffer pointer"));

        return E_POINTER;
    }

    Lock();

    hr = LineConfigDialogEditW(
                           m_dwDeviceID,
                           hwndOwner,                           
                           pDeviceClass,
                           pDeviceConfigIn,
                           dwSizeIn,
                           &pVarString
                          );

    Unlock();

    if ( SUCCEEDED(hr) )
    {
        *ppDeviceConfigOut = (BYTE *)CoTaskMemAlloc( pVarString->dwUsedSize );
        
        if(*ppDeviceConfigOut != NULL)
        {
    
            CopyMemory(
                       *ppDeviceConfigOut,
                       ((LPBYTE)pVarString)+pVarString->dwStringOffset,
                       pVarString->dwStringSize
                      );
    
            *pdwSizeOut = pVarString->dwStringSize;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    if ( NULL != pVarString )
    {
        ClientFree( pVarString );
    }
    
    LOG((TL_TRACE, hr, "ConfigDialogEdit - exit"));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT HandleLineCloseMessage( PASYNCEVENTMSG pParams )
{
    CAddress                * pAddress;
    AddressLineStruct       * pAddressLine;
    CTAPI                   * pTapi;
    ITAddress               * pITAddress;

    LOG((TL_TRACE, "HandleLineCloseMessage - enter"));

    if ( !FindAddressObject(
                            (HLINE)(pParams->hDevice),
                            &pAddress
                           ) )
    {
        LOG((TL_TRACE, "HandleLineCloseMessage - FindAddressObject failed. exiting... "));
    
        return S_OK;
    }

    pTapi = pAddress->GetTapi();
    
    pAddress->QueryInterface(
                             IID_ITAddress,
                             (void **)&pITAddress
                            );



    //
    // get the lock so that the address line does not go away meanwhile
    //

    pAddress->Lock();


    //
    // covert the 32bit address line handle (contained in pParams->OpenContext)
    // into a pointer value
    //

    pAddressLine = (AddressLineStruct *)GetHandleTableEntry(pParams->OpenContext);


    //
    // is this a good line anyway?
    //

    BOOL bValidLine = pAddress->IsValidAddressLine(pAddressLine);


    long lCallBackInstance = 0;


    //
    // if seems to be a good line, attempt to get callback instance from it.
    //

    if (bValidLine)
    {

        try
        {

            lCallBackInstance = pAddressLine->lCallbackInstance;
        }
        catch(...)
        {
            LOG((TL_ERROR, 
                "HandleLineCloseMessage - exception getting callback instance from line struc"));

            _ASSERTE(FALSE);

            bValidLine = FALSE;
        }

    }

    
    pAddress->Unlock();


    //
    // if good and known line, attempt to fire an event
    //

    if ( bValidLine && pTapi->FindRegistration( (PVOID)pAddressLine ) )
    {
        LOG((TL_TRACE, "HandleLineCloseMessage - found registration, firing event"));

        CTapiObjectEvent::FireEvent(
                                    pTapi,
                                    TE_ADDRESSCLOSE,
                                    pITAddress,
                                    lCallBackInstance,
                                    NULL
                                   );

    }
    else
    {
        LOG((TL_TRACE, 
            "HandleLineCloseMessage AddressLine %p not found. calling maybeclosealine", 
            pAddressLine ));

        pAddress->MaybeCloseALine(&pAddressLine);
    }
                        
    pITAddress->Release();
    
    //FindAddressObject addrefs the address objct
    pAddress->Release();
    
    LOG((TL_TRACE, "HandleLineCloseMessage - exit"));

    return S_OK;
    
}

/////////////////////////////////////////////////////////////////////////////
// IDispatch implementation
//
typedef IDispatchImpl<ITAddress2Vtbl<CAddress>, &IID_ITAddress2, &LIBID_TAPI3Lib> AddressType;
typedef IDispatchImpl<ITAddressCapabilitiesVtbl<CAddress>, &IID_ITAddressCapabilities, &LIBID_TAPI3Lib> AddressCapabilitiesType;
typedef IDispatchImpl<ITMediaSupportVtbl<CAddress>, &IID_ITMediaSupport, &LIBID_TAPI3Lib> MediaSupportType;
typedef IDispatchImpl<ITAddressTranslationVtbl<CAddress>, &IID_ITAddressTranslation, &LIBID_TAPI3Lib> AddressTranslationType;
typedef IDispatchImpl<ITLegacyAddressMediaControl2Vtbl<CAddress>, &IID_ITLegacyAddressMediaControl2, &LIBID_TAPI3Lib> LegacyAddressMediaControlType;



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CAddress::GetIDsOfNames
//
// Overide if IDispatch method
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP CAddress::GetIDsOfNames(REFIID riid, 
                                     LPOLESTR* rgszNames, 
                                     UINT cNames, 
                                     LCID lcid, 
                                     DISPID* rgdispid
                                    ) 
{ 
   HRESULT hr = DISP_E_UNKNOWNNAME;


    // See if the requsted method belongs to the default interface
    hr = AddressType::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((TL_INFO, "GetIDsOfNames - found %S on ITAddress", *rgszNames));
        rgdispid[0] |= IDISPADDRESS;
        return hr;
    }

    // If not, then try the Address Capabilities interface
    hr = AddressCapabilitiesType::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((TL_INFO, "GetIDsOfNames - found %S on ITAddressCapabilities", *rgszNames));
        rgdispid[0] |= IDISPADDRESSCAPABILITIES;
        return hr;
    }

    // If not, then try the Media Support interface
    hr = MediaSupportType::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((TL_INFO, "GetIDsOfNames - found %S on ITMediaSupport", *rgszNames));
        rgdispid[0] |= IDISPMEDIASUPPORT;
        return hr;
    }

    // If not, then try the Address Translation interface
    hr = AddressTranslationType::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((TL_INFO, "GetIDsOfNames - found %S on ITAddressTranslation", *rgszNames));
        rgdispid[0] |= IDISPADDRESSTRANSLATION;
        return hr;
    }

    // If not, then try the Legacy Address Media Control interface
    hr = LegacyAddressMediaControlType::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((TL_INFO, "GetIDsOfNames - found %S on ITLegacyAddressMediaControl", *rgszNames));
        rgdispid[0] |= IDISPLEGACYADDRESSMEDIACONTROL;
        return hr;
    }

    // If not, then try the aggregated MSP Address object
    if (m_pMSPAggAddress != NULL)
    {
        IDispatch *pIDispatchMSPAggAddress;
        
        m_pMSPAggAddress->QueryInterface(IID_IDispatch, (void**)&pIDispatchMSPAggAddress);
        
        hr = pIDispatchMSPAggAddress->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
        if (SUCCEEDED(hr))  
        {  
            pIDispatchMSPAggAddress->Release();
            LOG((TL_INFO, "GetIDsOfNames - found %S on our aggregated MSP Address", *rgszNames));
            rgdispid[0] |= IDISPAGGREGATEDMSPADDRESSOBJ;
            return hr;
        }
        pIDispatchMSPAggAddress->Release();
    }
    
    LOG((TL_INFO, "GetIDsOfNames - Didn't find %S on our iterfaces", *rgszNames));
    return hr; 
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CAddress::Invoke
//
// Overide if IDispatch method
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP CAddress::Invoke(DISPID dispidMember, 
                              REFIID riid, 
                              LCID lcid, 
                              WORD wFlags, 
                              DISPPARAMS* pdispparams, 
                              VARIANT* pvarResult, 
                              EXCEPINFO* pexcepinfo, 
                              UINT* puArgErr
                             )
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    DWORD   dwInterface = (dispidMember & INTERFACEMASK);


    LOG((TL_TRACE, "Invoke - dispidMember %X", dispidMember));

    // Call invoke for the required interface
    switch (dwInterface)
    {
    case IDISPADDRESS:
    {
        hr = AddressType::Invoke(dispidMember, 
                                   riid, 
                                   lcid, 
                                   wFlags, 
                                   pdispparams,
                                   pvarResult, 
                                   pexcepinfo, 
                                   puArgErr
                                  );
        break;
    }
    case IDISPADDRESSCAPABILITIES:
    {
        hr = AddressCapabilitiesType::Invoke(dispidMember, 
                                               riid, 
                                               lcid, 
                                               wFlags, 
                                               pdispparams,
                                               pvarResult, 
                                               pexcepinfo, 
                                               puArgErr
                                              );
        break;
    }
    case IDISPMEDIASUPPORT:
    {
        hr = MediaSupportType::Invoke(dispidMember, 
                                         riid, 
                                         lcid, 
                                         wFlags, 
                                         pdispparams,
                                         pvarResult, 
                                         pexcepinfo, 
                                         puArgErr
                                        );
        break;
    }
    case IDISPADDRESSTRANSLATION:
    {
        hr = AddressTranslationType::Invoke(dispidMember, 
                                              riid, 
                                              lcid, 
                                              wFlags, 
                                              pdispparams,
                                              pvarResult, 
                                              pexcepinfo, 
                                              puArgErr
                                             );
        break;
    }
    case IDISPLEGACYADDRESSMEDIACONTROL:
    {
        hr = LegacyAddressMediaControlType::Invoke(dispidMember, 
                                                     riid, 
                                                     lcid, 
                                                     wFlags, 
                                                     pdispparams,
                                                     pvarResult, 
                                                     pexcepinfo, 
                                                     puArgErr
                                                    );

        break;
    }
    case IDISPAGGREGATEDMSPADDRESSOBJ:
    {
        IDispatch *pIDispatchMSPAggAddress = NULL;
    
        if (m_pMSPAggAddress != NULL)
        {
            m_pMSPAggAddress->QueryInterface(IID_IDispatch, (void**)&pIDispatchMSPAggAddress);
    
            hr = pIDispatchMSPAggAddress->Invoke(dispidMember, 
                                            riid, 
                                            lcid, 
                                            wFlags, 
                                            pdispparams,
                                            pvarResult, 
                                            pexcepinfo, 
                                            puArgErr
                                           );
            
            pIDispatchMSPAggAddress->Release();
        }

        break;
    }

    } // end switch (dwInterface)

    
    LOG((TL_TRACE, hr, "Invoke - exit" ));
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CAddress::IsValidAddressLine
//
// returns TRUE if the address line passed in is in the address line list
//
// This method is not thread safe -- all calls must be protected, unless 
// bAddRef argument is TRUE
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

BOOL CAddress::IsValidAddressLine(AddressLineStruct *pAddressLine, BOOL bAddref)
{

    if (IsBadReadPtr(pAddressLine, sizeof(AddressLineStruct) ) )
    {
        LOG((TL_WARN,
            "IsValidAddressLine - unreadeable memory at [%p]",
            pAddressLine));

        return FALSE;
    }


    if (bAddref)
    {
        Lock();
    }

    PtrList::iterator it = m_AddressLinesPtrList.begin();

    PtrList::iterator end = m_AddressLinesPtrList.end();

    // iterate through address line list until we find the line
    for ( ; it != end; it++ )
    {
        if (pAddressLine == (AddressLineStruct *)(*it))
        {

            if (bAddref)
            {

                //
                // addref the line and release the lock
                //

                try
                {

                    pAddressLine->AddRef();

                }
                catch(...)
                {

                    //
                    // this is a bug. debug.
                    //

                    LOG((TL_INFO, "IsValidAddressLine -- exception while addreffing the line"));
                    
                    _ASSERTE(FALSE);

                    Unlock();

                    return FALSE;

                }

                
                Unlock();
            }

            LOG((TL_INFO, "IsValidAddressLine returning TRUE"));

            return TRUE;
        }
    }


    if (bAddref)
    {
        Unlock();
    }

    LOG((TL_INFO, "IsValidAddressLine returning FALSE"));

    return FALSE;
}



/////////////////////////////////////////////////////////////
//
// implementing method from CObjectSafeImpl
// 
// check the aggregated objects to see if they support the interface requested.
// if they do, return the non-delegating IUnknown of the object that supports 
// the interface. 
//


HRESULT CAddress::QIOnAggregates(REFIID riid, IUnknown **ppNonDelegatingUnknown)
{

    //
    // argument check
    // 

    if ( TAPIIsBadWritePtr(ppNonDelegatingUnknown, sizeof(IUnknown*)) )
    {
     
        return E_POINTER;
    }

    //
    // if we fail, at least return consistent values
    //
    
    *ppNonDelegatingUnknown = NULL;


    //
    // see if m_pMSPAggAddress or private support the interface riid
    //

    HRESULT hr = E_FAIL;


    Lock();

    if (m_pMSPAggAddress)
    {
        
        // 
        // does m_pMSPAggAddress expose this interface?
        // 

        IUnknown *pUnk = NULL;

        hr = m_pMSPAggAddress->QueryInterface(riid, (void**)&pUnk);
        
        if (SUCCEEDED(hr))
        {

            pUnk->Release();
            pUnk = NULL;


            //
            // return the mspcall's non-delegating unknown
            //

           *ppNonDelegatingUnknown = m_pMSPAggAddress;
           (*ppNonDelegatingUnknown)->AddRef();
        }
    }
    
    if ( FAILED(hr) && m_pPrivate )
    {
        
        //
        // bad luck with m_pMSPAggAddress? still have a chance with private
        //
        IUnknown *pUnk = NULL;
        
        hr = m_pPrivate->QueryInterface(riid, (void**)&pUnk);

        if (SUCCEEDED(hr))
        {

            pUnk->Release();
            pUnk = NULL;


            *ppNonDelegatingUnknown = m_pPrivate;
            (*ppNonDelegatingUnknown)->AddRef();
        }
    }

    Unlock();

    return hr;
}

// 
// Event filtering methods
//

/*++
SetEventFilterMask

  Is called by TAPI object to set the event filter mask to each address
  The caller method is CTAPI::SetEventFilterToAddresses()
  dwEventFilterMask is the TAPI event filter mask
--*/
HRESULT CAddress::SetEventFilterMask( 
    DWORD dwEventFilterMask
    )
{
    LOG((TL_TRACE, "SetEventFilterMask - enter. dwEventFilterMask[%lx]", dwEventFilterMask ));

    //
    // Set the event mask for all TAPI events
    //

    // TE_ADDRESS
    SetSubEventFlag( 
        TE_ADDRESS, 
        CEventMasks::EM_ALLSUBEVENTS, 
        (dwEventFilterMask & TE_ADDRESS) ? TRUE : FALSE);

    // TE_CALLHUB
    SetSubEventFlag( 
        TE_CALLHUB, 
        CEventMasks::EM_ALLSUBEVENTS, 
        (dwEventFilterMask & TE_CALLHUB) ? TRUE : FALSE);

    // TE_CALLINFOCHANGE
    SetSubEventFlag( 
        TE_CALLINFOCHANGE, 
        CEventMasks::EM_ALLSUBEVENTS, 
        (dwEventFilterMask & TE_CALLINFOCHANGE) ? TRUE : FALSE);

    // TE_CALLMEDIA
    SetSubEventFlag( 
        TE_CALLMEDIA, 
        CEventMasks::EM_ALLSUBEVENTS, 
        (dwEventFilterMask & TE_CALLMEDIA) ? TRUE : FALSE);

    // TE_CALLNOTIFICATION
    SetSubEventFlag( 
        TE_CALLNOTIFICATION, 
        CEventMasks::EM_ALLSUBEVENTS, 
        (dwEventFilterMask & TE_CALLNOTIFICATION) ? TRUE : FALSE);

    // TE_CALLSTATE
    SetSubEventFlag( 
        TE_CALLSTATE, 
        CEventMasks::EM_ALLSUBEVENTS, 
        (dwEventFilterMask & TE_CALLSTATE) ? TRUE : FALSE);

    // TE_FILETERMINAL
    SetSubEventFlag( 
        TE_FILETERMINAL, 
        CEventMasks::EM_ALLSUBEVENTS, 
        (dwEventFilterMask & TE_FILETERMINAL) ? TRUE : FALSE);

    // TE_PRIVATE
    SetSubEventFlag( 
        TE_PRIVATE, 
        CEventMasks::EM_ALLSUBEVENTS, 
        (dwEventFilterMask & TE_PRIVATE) ? TRUE : FALSE);

    // TE_QOSEVENT
    SetSubEventFlag( 
        TE_QOSEVENT, 
        CEventMasks::EM_ALLSUBEVENTS, 
        (dwEventFilterMask & TE_QOSEVENT) ? TRUE : FALSE);

    // TE_ADDRESSDEVSPECIFIC
    SetSubEventFlag( 
        TE_ADDRESSDEVSPECIFIC, 
        CEventMasks::EM_ALLSUBEVENTS, 
        (dwEventFilterMask & TE_ADDRESSDEVSPECIFIC) ? TRUE : FALSE);

    // TE_PHONEDEVSPECIFIC
    SetSubEventFlag( 
        TE_PHONEDEVSPECIFIC, 
        CEventMasks::EM_ALLSUBEVENTS, 
        (dwEventFilterMask & TE_PHONEDEVSPECIFIC) ? TRUE : FALSE);

    LOG((TL_TRACE, "SetEventFilterMask exit S_OK"));
    return S_OK;
}

/*++
SetSubEventFlag

Sets in m_EventFilterMasks array the bitflag for an subevent
Is called by CAddress::SetEventFilterMask
--*/
HRESULT CAddress::SetSubEventFlag(
    TAPI_EVENT  TapiEvent,
    DWORD       dwSubEvent,
    BOOL        bEnable
    )
{
    LOG((TL_TRACE, 
        "SetSubEventFlag - enter. event [%lx] subevent[%lx] enable?[%d]", 
        TapiEvent, dwSubEvent, bEnable ));

    HRESULT hr = S_OK;

    //
    // Set the mask for the event
    //

    hr = m_EventMasks.SetSubEventFlag( 
        TapiEvent, 
        dwSubEvent, 
        bEnable);

    if( SUCCEEDED(hr) )
    {
        hr = SetSubEventFlagToCalls( 
            TapiEvent,
            dwSubEvent,
            bEnable
            );
    }

    LOG((TL_TRACE, "SetSubEventFlag exit 0x%08x", hr));
    return hr;
}

/*++
GetSubEventFlag

It is calle by get_EventFilter() method
--*/
HRESULT CAddress::GetSubEventFlag(
    TAPI_EVENT  TapiEvent,
    DWORD       dwSubEvent,
    BOOL*       pEnable
    )
{
    LOG((TL_TRACE, "GetSubEventFlag enter" ));

    HRESULT hr = E_FAIL;

    //
    // Get the subevent falg
    //
    hr = m_EventMasks.GetSubEventFlag(
        TapiEvent,
        dwSubEvent,
        pEnable
        );

    LOG((TL_TRACE, "GetSubEventFlag exit 0x%08x", hr));
    return hr;
}

/*++
SetSubEventFlagToCalls

Sets the flags to all calls
Is called by SetSubEventFlag() method
--*/
HRESULT CAddress::SetSubEventFlagToCalls(
    TAPI_EVENT  TapiEvent,
    DWORD       dwSubEvent,
    BOOL        bEnable
    )
{
    LOG((TL_TRACE, "SetSubEventFlagToCalls enter" ));
    HRESULT hr = S_OK;

    //
    // Apply the sub event filter mask to all the calls on this address
    //
    for (int nCall = 0; nCall < m_CallArray.GetSize() ; nCall++ )
    {
        CCall * pCall = NULL;
        pCall = dynamic_cast<CCall *>(m_CallArray[nCall]);

        if ( NULL != pCall )
        {
            hr = pCall->SetSubEventFlag(
                TapiEvent, 
                dwSubEvent, 
                bEnable
                );

            if( FAILED(hr) )
            {
                break;
            }
        }
    }

    LOG((TL_TRACE, "SetSubEventFlagToCalls exit 0x%08x", hr));
    return hr;
}

/*++
GetSubEventsMask

  Is called by SetSubEventFlag to get the sub events mask for
  a specific TAPI_EVENT

  Assumed is called into a Lock statement
--*/
DWORD CAddress::GetSubEventsMask(
    IN  TAPI_EVENT TapiEvent
    )
{
    LOG((TL_TRACE, "GetSubEventsMask - enter"));

    DWORD dwSubEventFlag = m_EventMasks.GetSubEventMask( TapiEvent );

    LOG((TL_TRACE, "GetSubEventsMask - exit %ld", dwSubEventFlag));
    return dwSubEventFlag;
}

/*++
GetEventMasks

  It is called by CCall::Initialize()
--*/
HRESULT CAddress::GetEventMasks(
    OUT CEventMasks* pEventMasks
    )
{
    LOG((TL_TRACE, "GetEventMasks - enter"));

    m_EventMasks.CopyEventMasks( pEventMasks );

    LOG((TL_TRACE, "GetEventMasks - exit S_OK"));
    return S_OK;
}


////////////////////////////////////////////
//
//  RegisterNotificationCookie
//
//  adds the specified cookie to the list of cookies on this address
//

HRESULT CAddress::RegisterNotificationCookie(long lCookie)
{
    HRESULT hr = S_OK;

    LOG((TL_INFO, 
           "RegisterNotificationCookie - adding cookie %lx to m_NotificationCookies list", 
           lCookie ));

    Lock();

    try
    {
        m_NotificationCookies.push_back(lCookie);
    }
    catch(...)
    {
        LOG((TL_ERROR, 
            "RegisterNotificationCookie - failed to add a cookie to m_NotificationCookies list - alloc failure" ));

        hr = E_OUTOFMEMORY;
    }

    Unlock();

    return hr;
}


////////////////////////////////////////////
//
//  RemoveNotificationCookie
//
//  removes the specified cookie from this address's cookies
//

HRESULT CAddress::RemoveNotificationCookie(long lCookie)
{
    HRESULT hr = S_OK;

    LOG((TL_INFO, 
           "RemoveNotificationCookie - removing cookie %lx from m_NotificationCookies list", 
           lCookie ));

    Lock();

    m_NotificationCookies.remove(lCookie);

    Unlock();

    return hr;
}


////////////////////////////////////////////
//
//  UnregisterAllCookies
//
//  removes all cookies from this address's cookie list
//
//  for each valid cookie, call RemoveCallNotification
//

void CAddress::UnregisterAllCookies()
{
    LOG((TL_TRACE, "UnregisterAllCookies entering. this[%p]", this));

    Lock();

    LongList::iterator it = m_NotificationCookies.begin();

    LongList::iterator end = m_NotificationCookies.end();

    //
    // if there are any cookies, remove the corresponding registeritems 
    // from the handlehashtable
    //
    // also, unregister call notification for these cookies, to make sure
    // everything is cleaned up (and in particular that lineCloseMSPInstance
    // gets called if needed so the tsp gets notified that the msp is going
    // away
    // 

    for ( ; it != end; it++ )
    {
        long lCookie = (long)(*it);

        LOG((TL_INFO, "UnregisterAllCookies removing handle %lx", lCookie));

        
        //
        // get register item, so we can unregister call notifications with it.
        //

        REGISTERITEM *pRegisterItem = (REGISTERITEM*) GetHandleTableEntry(lCookie);


        //
        // remove the entry from the handle table
        //

        RemoveHandleFromHashTable(lCookie);


        //
        // if we did not get a good registeritem that corresponds to this cookie,
        // go on to the next cookie
        //

        if ( (NULL == pRegisterItem) || 
             IsBadReadPtr(pRegisterItem, sizeof(REGISTERITEM)) )
        {
            LOG((TL_INFO, 
                "UnregisterAllCookies - no corresponfing registeritem for cookie 0x%lx",
                lCookie));

            continue;
        }


        //
        // if the register item is not RA_ADDRESS, ignore it and go on to 
        // the next cookie.
        //

        if (RA_ADDRESS != pRegisterItem->dwType)
        {
            LOG((TL_INFO, 
                "UnregisterAllCookies - cookie 0x%lx is of type 0x%lx, not RA_ADDRESS",
                lCookie,
                pRegisterItem->dwType));

            continue;
        }


        //
        // remove call notification for this cookie, since the app did not 
        // do this. best effort -- ignore the error code.
        //

        LOG((TL_INFO,
            "UnregisterAllCookies - removing call notification for cookie 0x%lx",
            lCookie));

        RemoveCallNotification(pRegisterItem->pRegister);

    }
    

    //
    // clear cookie list
    //

    m_NotificationCookies.clear();


    Unlock();

    LOG((TL_TRACE, "UnregisterAllCookies exiting"));
}

///////////////////////////////////////////////////////////////////////////////
//
// CAddress::AddressOnTapiShutdown 
//
// this function is called by the owner tapi object when it is going away. 
//
// we then propagate tapi shutdown notification to each call, so the calls 
// can do their clean up
//

void CAddress::AddressOnTapiShutdown()
{

    LOG((TL_TRACE, "AddressOnTapiShutdown - enter"));


    //
    // protect access to m_CallArray
    //

    Lock();


    //
    // tell each call to clean up
    //

    int nCalls = m_CallArray.GetSize();

    for (int i = 0; i < nCalls; i++)
    {

        ITCallInfo *pCallInfo = m_CallArray[i];

        try 
        {

            //
            // get a pointer to the call object
            //

            CCall *pCallObject = dynamic_cast<CCall *>(pCallInfo);

            if (NULL == pCallObject)
            {


                //
                // the pointer is not pointing to a call object. this is odd 
                // and is worth debugging
                //
                
                LOG((TL_ERROR,
                    "AddressOnTapiShutdown - invalid call pointer[%p] in the call array",
                    pCallInfo));

                _ASSERTE(FALSE);

            }
            else
            {

                //
                // tell the call that it's time to go
                //

                pCallObject->CallOnTapiShutdown();
            }

        }
        catch(...)
        {

            //
            // not only is the pointer not pointing to a call object, but it is
            // also pointing to memory that is not readable. how did this happen?
            //

            LOG((TL_ERROR,
                "AddressOnTapiShutdown - unreadable call pointer[%p] in the call array",
                pCallInfo));

            _ASSERTE(FALSE);

        }

    }


    //
    // set the flag so no new calls are created following this
    //
    
    m_bTapiSignaledShutdown = TRUE;


    //
    // unregister the msp wait event in the thread pool. we don't want to get 
    // any callbacks after tapi has shut down
    //

    if ( NULL != m_hWaitEvent )
    {

        LOG((TL_TRACE, "AddressOnTapiShutdown - unregistering the MSPEventCallback callback"));

        UnregisterWaitEx( m_hWaitEvent, INVALID_HANDLE_VALUE);
        m_hWaitEvent = NULL;
    }

    

    Unlock();


    LOG((TL_TRACE, "AddressOnTapiShutdown - finish"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\agenthand.cpp ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    agenthand.cpp

Abstract:

    Implementation of the CAll centre interface for TAPI 3.0.
    AgentHandler class

Author:

    noela - 03/16/98

Notes:

    optional-notes

Revision History:

--*/


#define UNICODE
#include "stdafx.h"
#include "lmcons.h"

extern CHashTable *    gpAgentHandlerHashTable ;





/////////////////////////////////////////////////////////////////////////////
// ITAgentHandler


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentHandler
// Method    : Initialize
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentHandler::Initialize(PWSTR pszProxyName, GUID proxyGUID, CTAPI *tapiObj)
{
    HRESULT  hr = S_OK;


    LOG((TL_TRACE, "Initialize - enter" ));

    m_GUID          = proxyGUID;
    m_tapiObj       = tapiObj;
    m_pAddressLine  = NULL;

    // copy the Name
    if (pszProxyName != NULL)
    {
        m_szName = (PWSTR) ClientAlloc((lstrlenW(pszProxyName) + 1) * sizeof (WCHAR));
        if (m_szName != NULL)
        {
            lstrcpyW(m_szName,pszProxyName);
        }
    else
        {
            LOG((TL_ERROR, "Initialize - Alloc m_szName failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        LOG((TL_ERROR, "Initialize - name is NULL" ));
        m_szName = NULL;
    }

    // Initialize our hash tables
    //
    m_AgentSessionHashtable.Initialize(1);
    m_QueueHashtable.Initialize(1);


    LOG((TL_TRACE, hr, "Initialize - exit" ));
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentHandler
// Method    : AddAddress
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CAgentHandler::AddAddress(CAddress *pAddress)
{

    LOG((TL_TRACE, "AddAddress - enter"));

    
    //
    // good address?
    //

    if (IsBadReadPtr(pAddress, sizeof(CAddress) ))
    {
        LOG((TL_ERROR, "AddAddress - bad address pointer"));
        return;
    }


    //
    // get ITAddress out of the CAddress pointer
    //

    ITAddress *pITAddress = dynamic_cast<ITAddress *>(pAddress);

    if (NULL == pITAddress)
    {
        LOG((TL_ERROR, "AddAddress - pITAddress is NULL"));
        return;
    }


    //
    // log address' name
    //

#if DBG

    {
        BSTR bstrName = NULL;

        HRESULT hr = pITAddress->get_AddressName(&bstrName);

        if (SUCCEEDED(hr))
        {
            LOG((TL_TRACE, "AddAddress - using address %ls ",bstrName));
            SysFreeString( bstrName );
        }
    }

#endif


    //
    // first see if this ITAddress is in the array of my addresses
    //

    int nIndex = m_AddressArray.Find( pITAddress );

    if (nIndex >= 0)
    {
        
        LOG((TL_TRACE, 
            "AddAddress - address already in the array. doing nothing"));

        return;
    }


    //
    // add address to the array of managed addresses
    //

    BOOL bAddSuccess = m_AddressArray.Add( pITAddress );


    //
    // log a message if the object failed to be added to the array
    //

    if ( !bAddSuccess )
    {

        LOG((TL_ERROR,
            "AddAddress - failed to add address to the array"));

        return;

    }

    LOG((TL_TRACE, "AddAddress - exit"));
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentHandler
// Method    : getHLine
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HLINE CAgentHandler::getHLine()
{
    CAddress  * pAddress;
    HLINE       hLine = 0;
    HRESULT     hr = S_OK;

    LOG((TL_TRACE, "getHLine - enter"));

    if (m_pAddressLine != NULL)
    {
        hLine = m_pAddressLine->t3Line.hLine;
    }
    else
    {
        // If we don't have a line, find one
        pAddress = dynamic_cast<CAddress *>(m_AddressArray[0]);

        if ( NULL != pAddress )
        {

#if DBG
            {
                BSTR        bstrName;

                ((ITAddress *)(pAddress))->get_AddressName(&bstrName);
                LOG((TL_INFO, "getHLine - using address %ls ",bstrName));
                SysFreeString( bstrName );
            }
#endif
        
            hr = pAddress->FindOrOpenALine (LINEMEDIAMODE_INTERACTIVEVOICE, &m_pAddressLine);
            
            if (SUCCEEDED(hr) )
            {
                hLine = m_pAddressLine->t3Line.hLine;

                // We've got a line open to the proxy, so lets add it to the AH hash table
                gpAgentHandlerHashTable->Lock();
                gpAgentHandlerHashTable->Insert( (ULONG_PTR)hLine, (ULONG_PTR)this );
                gpAgentHandlerHashTable->Unlock();
            }
        }

    }

    LOG((TL_TRACE,hr, "getHLine(%8x) - exit", hLine));
    return hLine;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentHandler
// Method    : FinalRelease
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CAgentHandler::FinalRelease()
{
    CAddress    * pAddress;

    LOG((TL_TRACE, "FinalRelease AgentHandler - %S", m_szName ));

    if ( m_szName != NULL )
    {
         ClientFree(m_szName);
    }

    // If we  have a line open close it
    if (m_pAddressLine != NULL)
    {
        // We've got a line open to the proxy, so lets remove it from the AH hash table
        gpAgentHandlerHashTable->Lock();
        gpAgentHandlerHashTable->Remove( (ULONG_PTR)(m_pAddressLine->t3Line.hLine) );
        gpAgentHandlerHashTable->Unlock();

        // And then close it
        pAddress = dynamic_cast<CAddress *>(m_AddressArray[0]);

        if ( NULL != pAddress )
        {
            pAddress->MaybeCloseALine (&m_pAddressLine);
        }
    }

    m_AddressArray.Shutdown();
    m_GroupArray.Shutdown();
    m_AgentArray.Shutdown();

    // Shutdown our hash tables
    //
    m_AgentSessionHashtable.Shutdown();
    m_QueueHashtable.Shutdown();


    LOG((TL_TRACE, "FinalRelease AgentHandler - exit" ));
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentHandler
// Method    : FindSessionObject
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL CAgentHandler::FindSessionObject(
                            HAGENTSESSION  hAgentSession,
                            CAgentSession  ** ppAgentSession
                            )
{
    BOOL    bResult = FALSE;


    m_AgentSessionHashtable.Lock();

    if ( SUCCEEDED(m_AgentSessionHashtable.Find( (ULONG_PTR)hAgentSession, (ULONG_PTR *)ppAgentSession )) )
    {
        bResult = TRUE;
    }
    else
    {
        bResult = FALSE;
    }

    m_AgentSessionHashtable.Unlock();

    return bResult;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentHandler
// Method    : FindSessionObject
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL CAgentHandler::FindQueueObject(
                            DWORD  dwQueueID,
                            CQueue  ** ppQueue
                            )
{
    BOOL    bResult = FALSE;


    m_QueueHashtable.Lock();

   
    if ( SUCCEEDED(m_QueueHashtable.Find( (ULONG_PTR)dwQueueID, (ULONG_PTR *)ppQueue )) )
    {
        bResult = TRUE;
    }
    else
    {
        bResult = FALSE;
    }

    m_QueueHashtable.Unlock();

    return bResult;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentHandler
// Method    : FindAgentObject
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL CAgentHandler::FindAgentObject(
                            HAGENT hAgent,
                            CAgent ** ppAgent
                            )
{
    HRESULT             hr = FALSE;
    CAgent              *pAgent;
    int                 iCount;
    
    LOG((TL_TRACE, "FindAgent %d", hAgent));

    for ( iCount = 0; iCount < m_AgentArray.GetSize(); iCount++ )
    {
        pAgent = dynamic_cast<CComObject<CAgent>*>(m_AgentArray[iCount]);
        if (pAgent !=NULL)
        {
            if (hAgent == pAgent->getHandle() )
            {
                // Found it
                *ppAgent = pAgent;
                hr = TRUE;
                break;
            }
        }
    }

    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CACDGroup
// Method    : UpdateAgentHandlerList
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CAgentHandler::UpdateGroupArray()
{
    HRESULT                 hr = S_OK;
    DWORD                   dwNumberOfEntries;
    LPLINEAGENTGROUPLIST    pGroupList = NULL;
    LPLINEAGENTGROUPENTRY   pGroupEntry = NULL;
    PWSTR                   pszGroupName;
    DWORD                   dwCount;
    GUID                  * pGroupID;
    BOOL                    foundIt;
    CACDGroup             * thisGroup = NULL;
    int                     iCount;
    

    LOG((TL_TRACE, "UpdateGroupArray - enter"));


    // Call lineGetGroupList to get list of Groups
    hr = LineGetGroupList( getHLine(), &pGroupList );
    if( SUCCEEDED(hr) )
    {
        dwNumberOfEntries = pGroupList->dwNumEntries;
        LOG((TL_INFO, "UpdateGroupArray - Number of entries: %d", dwNumberOfEntries));
        if ( dwNumberOfEntries !=0 )
        {
            // Run through the new list from the Proxy &see if any new groups have appeared
            // By Comparing IDs from the new list with those in TAPIs list
            
            
            // Find position of 1st LINEAGENTGROUPEENTRY structure in the LINEAGENTGROUPLIST
            pGroupEntry = (LPLINEAGENTGROUPENTRY) ((BYTE*)(pGroupList) + pGroupList->dwListOffset);
            
            // Run though the received list
            for (dwCount = 0; dwCount < dwNumberOfEntries; dwCount++)
            {
                pszGroupName= (PWSTR)( (PBYTE)pGroupList + pGroupEntry->dwNameOffset);
                pGroupID = (GUID*)&pGroupEntry->GroupID;
    
                #if DBG
                {
                    WCHAR guidName[100];
    
                    StringFromGUID2(*pGroupID, (LPOLESTR)&guidName, 100);
                    LOG((TL_INFO, "UpdateGroupArray - Group Name : %S", pszGroupName));
                    LOG((TL_INFO, "UpdateGroupArray - Group GUID : %S", guidName));
                }
                #endif
    
                // Run through the array of Groups & see if we already have this one in the list
                // by comparing IDs
                foundIt = FALSE;
                Lock();
                
                for (iCount = 0; iCount < m_GroupArray.GetSize(); iCount++)
                {
                    thisGroup = dynamic_cast<CComObject<CACDGroup>*>(m_GroupArray[iCount]);
                    if (thisGroup != NULL)
                    {
                        if ( IsEqualGUID(*pGroupID, thisGroup->getID() ) )
                        {
                            foundIt = TRUE;
                            break;
                        }
                    }
                }
                Unlock();
                
                if (foundIt == FALSE)
                {
                    // Didn't match so lets add this Group
                    LOG((TL_INFO, "UpdateGroupArray - create new Group"));
    
                    CComObject<CACDGroup> * pGroup;
                    hr = CComObject<CACDGroup>::CreateInstance( &pGroup );
                    if( SUCCEEDED(hr) )
                    {
                        ITACDGroup * pITGroup;
                        hr = pGroup->QueryInterface(IID_ITACDGroup, (void **)&pITGroup);
                        if ( SUCCEEDED(hr) )
                        {
                            // initialize the Group
                            hr = pGroup->Initialize(pszGroupName, *pGroupID, this);
                            if( SUCCEEDED(hr) )
                            {

                                LOG((TL_TRACE, "UpdateGroupArray - Initialize Group succeededed" ));
    
                                //
                                // add to Array of Groups
                                //
                                Lock();
                                m_GroupArray.Add(pITGroup);
                                Unlock();
                                pITGroup->Release();
    
                                LOG((TL_INFO, "UpdateGroupArray - Added Group to Array"));
    
                            }
                            else
                            {
                                LOG((TL_ERROR, "UpdateGroupArray - Initialize Group failed" ));
                                delete pGroup;
                            }
                        }
                        else
                        {
                            LOG((TL_ERROR, "UpdateGroupArray - QueryInterface failed" ));
                            delete pGroup;
                        }
                    }
                    else
                    {
                        LOG((TL_ERROR, "UpdateGroupArray - Create Group failed" ));
                    }
                }
                else // foundIt == TRUE
                {
                    LOG((TL_INFO, "UpdateGroupArray - Group Object exists for this entry" ));
                    // Just in case is was previously inactive
                    thisGroup->SetActive();
    
                }
    
                // next entry in list
                pGroupEntry ++;
            } //for(dwCount = 0......)
    
    
    
    
            // Run through the list of Groups & see if any groups have been removed by the Proxy
            // By comparing IDs of those in TAPIs list with the new list from the Proxy
            for (iCount = 0; iCount < m_GroupArray.GetSize(); iCount++)
            {
                thisGroup = dynamic_cast<CComObject<CACDGroup>*>( m_GroupArray[iCount] );
                if (thisGroup != NULL)
                {
                    foundIt = FALSE;
                    // Find position of 1st LINEAGENTGROUPEENTRY structure in the LINEAGENTGROUPLIST
                    pGroupEntry = (LPLINEAGENTGROUPENTRY) ((BYTE*)(pGroupList) + pGroupList->dwListOffset);
                    // Run though the list
                    for (dwCount = 0; dwCount < dwNumberOfEntries; dwCount++)
                    {
                        pGroupID = (GUID*)&pGroupEntry->GroupID;
                        if ( IsEqualGUID(*pGroupID, thisGroup->getID() ) )
                        {
                            foundIt = TRUE;
                            break;
                        }
                    pGroupEntry ++;     // next
                    } // for (dwCount = 0......) 
    
    
                    if (foundIt == FALSE)
                    {
                        // Didn't match so it's no longer a valid group , according to the Proxy
                        LOG((TL_INFO, "UpdateGroupArray - Group has gone from the proxy"));
                        thisGroup->SetInactive();
                    }
                }
            } 
        }
        else
        {
            LOG((TL_ERROR, "UpdateGroupArray - lineGetGroupList failed - empty list"));
            hr = E_FAIL; 
        }

    }
    else  // lineGetGroupList  failed
    {
        LOG((TL_ERROR, "UpdateGroupArray - lineGetGroupList failed"));
    }




    // finished with memory block so release
    if ( pGroupList != NULL )
        ClientFree( pGroupList );


    LOG((TL_TRACE, hr, "UpdateGroupArray - exit"));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentHandler
// Interface : ITAgentHandler
// Method    : get_Name
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentHandler::get_Name(BSTR * Name)
{
    HRESULT hr = S_OK;

    LOG((TL_TRACE, "Name - enter" ));
    Lock();
    if(!TAPIIsBadWritePtr( Name, sizeof(BSTR) ) )
    {
        *Name = SysAllocString(m_szName);

        if (*Name == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        LOG((TL_ERROR, "Name - bad Name pointer" ));
        hr = E_POINTER;
    }

    Unlock();
    LOG((TL_TRACE, hr, "Name - exit" ));
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentHandler
// Interface : ITAgentHandler
// Method    : CreateAgent
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentHandler::CreateAgent(ITAgent **ppAgent)
{
    HRESULT     hr = S_OK;
    CAgent    * pAgent;

    LOG((TL_TRACE, "CreateAgent - enter"));
    if(!TAPIIsBadWritePtr( ppAgent, sizeof(ITAgent *) ) )
    {
        hr  = InternalCreateAgent(NULL, NULL, &pAgent);
        if ( SUCCEEDED(hr) )
        {
            //
            // put result in out pointer - also
            pAgent->QueryInterface(IID_ITAgent, (void **)ppAgent );
        }
        else
        {
            LOG((TL_ERROR, "CreateAgent - InternalCreateAgent failed" ));
        }
    }
    else
    {
        LOG((TL_ERROR, "CreateAgent - Bad ppAgent Pointer"));
        hr = E_POINTER;
    }
	LOG((TL_TRACE, hr, "CreateAgent - exit"));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentHandler
// Interface : ITAgentHandler
// Method    : CreateAgentWithID
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentHandler::CreateAgentWithID(BSTR pID, BSTR pPIN, ITAgent **ppAgent)
{
    HRESULT     hr = S_OK;
    CAgent    * pAgent;

    LOG((TL_TRACE, "CreateAgentWithID - enter"));

    if(!TAPIIsBadWritePtr( ppAgent, sizeof(ITAgent *) ) )
    {
        if (!IsBadStringPtrW( pID, -1 ))
        {
            // ID Pointer OK, is it empty ?
            if( *pID != NULL)
            {    
                if (!IsBadStringPtrW( pPIN, -1 ))
                {
                    // All OK so far, so try  to create
                    hr  = InternalCreateAgent(pID, pPIN, &pAgent);
                    if ( SUCCEEDED(hr) )
                    {
                        // put result in out pointer - also
                        pAgent->QueryInterface(IID_ITAgent, (void **)ppAgent );
                    }
                    else // InternalCreateAgent failed
                    {
                        LOG((TL_ERROR, "CreateAgentWithID - InternalCreateAgent failed" ));
                    }
                }
                else  // bad PIN pointer
                {
                    LOG((TL_ERROR, "CreateAgentWithID - Bad PIN pointer" ));
                    hr = E_POINTER;
                }
            }
            else // NULL ID
            {
                LOG((TL_ERROR, "CreateAgentWithID - ID is Empty String" ));
                hr = E_INVALIDARG;
            }
        }
        else // bad ID pointer
        {
            LOG((TL_ERROR, "CreateAgentWithID - Bad ID pointer" ));
            hr = E_POINTER;
        }
    }
    else
    {
        LOG((TL_ERROR, "CreateAgentWithID - Bad ppAgent Pointer"));
        hr = E_POINTER;
    }

	LOG((TL_TRACE, hr, "CreateAgentWithID - exit"));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentHandler
// Method    : InternalCreateAgent
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CAgentHandler::InternalCreateAgent(BSTR pID, BSTR pPIN, CAgent ** ppAgent)
{
    HRESULT     hr = S_OK;
    HAGENT      hAgent;
    DWORD       dwUserNameSize = (UNLEN + 1);
    PWSTR       pszName = NULL;

    LOG((TL_TRACE, "InternalCreateAgent - enter"));

    hr = LineCreateAgent(getHLine(), pID, pPIN, &hAgent);
    if ( SUCCEEDED(hr) )
    {
        hr = WaitForReply( hr );
        if ( SUCCEEDED(hr) )
        {
            // Successs, so create agent
            LOG((TL_INFO, "InternalCreateAgent - create new Agent Handler" ));

            CComObject<CAgent> * pAgent;
            hr = CComObject<CAgent>::CreateInstance( &pAgent);
            if( SUCCEEDED(hr) )
            {
                // initialize the AgentHandler
                pszName =  (PWSTR)ClientAlloc((dwUserNameSize + 1) * sizeof(WCHAR) );
                if (pszName != NULL)
                {
                    if ( GetUserNameW( pszName, &dwUserNameSize) )
                    {
                        ITAgent *pITAgent;
                        hr = pAgent->QueryInterface(IID_ITAgent, (void **)&pITAgent);

                        if( SUCCEEDED(hr ))
                        {
                            hr = pAgent->Initialize(hAgent, pszName, pID, pPIN, this );
                            if( SUCCEEDED(hr) )
                            {
                                //
                                // add to list
                                //
                                Lock();
                                m_AgentArray.Add(pITAgent);
                                Unlock();
                                
                                pITAgent->Release();
                                LOG((TL_INFO, "InternalCreateAgent - Added Agent to array"));
        
                                // Return new Agent object
                                *ppAgent = pAgent;
                            }
                            else
                            {
                                LOG((TL_ERROR, "InternalCreateAgent - Initialize Agent failed" ));
                                delete pAgent;
                            }
                        }
                        else
                        {
                            LOG((TL_ERROR, "InternalCreateAgent - QueryInterface failed" ));
                            delete pAgent;
                        }

                    }
                    else  // GetUserName fail
                    {
                        LOG((TL_ERROR, "InternalCreateAgent - GetUserNameW failed" ));
                        hr = TAPI_E_CALLCENTER_INVALAGENTID;
                    }
                }
                else // pszName == NULL
                {
                    LOG((TL_ERROR, "InternalCreateAgent - ClientAlloc pszName failed" ));
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                LOG((TL_ERROR, "InternalCreateAgent - Create Agent failed" ));
            }
        }
        else // LineCreateAgent failed async
        {
            LOG((TL_ERROR, "InternalCreateAgent - LineCreateAgent failed async" ));
        }
    }
    else // LineCreateAgent failed
    {
        LOG((TL_ERROR, "InternalCreateAgent - LineCreateAgent failed" ));
    }


    if(pszName != NULL)
        ClientFree(pszName);


	LOG((TL_TRACE, hr, "InternalCreateAgent - exit"));
    return hr;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentHandler
// Interface : ITAgentHandler
// Method    : EnumerateACDGroups
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentHandler::EnumerateACDGroups(IEnumACDGroup ** ppEnumACDGroup)
{
    HRESULT     hr = S_OK;

    LOG((TL_TRACE, "EnumerateACDGroups - enter"));

    if(!TAPIIsBadWritePtr( ppEnumACDGroup, sizeof(IEnumACDGroup *) ) )
    {
        UpdateGroupArray();
    
        //
        // create the enumerator
        //
        CComObject< CTapiEnum<IEnumACDGroup, ITACDGroup, &IID_IEnumACDGroup> > * pEnum;
        hr = CComObject< CTapiEnum<IEnumACDGroup, ITACDGroup, &IID_IEnumACDGroup> > ::CreateInstance( &pEnum );
    
        if (SUCCEEDED(hr) )
        {
            // initialize it with our group list
            Lock();
            hr = pEnum->Initialize( m_GroupArray );
            Unlock();
            if ( SUCCEEDED(hr) )
            {
                // return it
                *ppEnumACDGroup = pEnum;
            }
            else //  failed to  initialize
            {
                LOG((TL_ERROR, "EnumerateACDGroup - could not initialize enum" ));
                pEnum->Release();
            }
        }
        else  // failed to create enum
        {
            LOG((TL_ERROR, "EnumerateACDGroups - could not create enum" ));
        }
    }
    else
    {
        LOG((TL_ERROR, "EnumerateACDGroups - bad ppEnumACDGroup ponter" ));
        hr = E_POINTER;
    }

    LOG((TL_TRACE, hr, "EnumerateACDGroups - exit"));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentHandler
// Interface : ITAgentHandler
// Method    : get_ACDGroups
//
// Return a collection of calls usable for this Agent Handler
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentHandler::get_ACDGroups(VARIANT  * pVariant)
{
    HRESULT         hr = S_OK;
    IDispatch     * pDisp = NULL;


    LOG((TL_TRACE, "get_ACDGroups - enter"));

    if (!TAPIIsBadWritePtr( pVariant, sizeof(VARIANT) ) )
    {
        UpdateGroupArray();
        
        //
        // create the collection
        //
        CComObject< CTapiCollection< ITACDGroup > > * p;
        hr = CComObject< CTapiCollection< ITACDGroup > >::CreateInstance( &p );
        
        if (SUCCEEDED(hr) )
        {
            // initialize it with our address list
            Lock();
            hr = p->Initialize( m_GroupArray );
            Unlock();
        
            if ( SUCCEEDED(hr) )
            {
                // get the IDispatch interface
                hr = p->_InternalQueryInterface( IID_IDispatch, (void **) &pDisp );
            
                if ( SUCCEEDED(hr) )
                {
                    // put it in the variant
                    VariantInit(pVariant);
                    pVariant->vt = VT_DISPATCH;
                    pVariant->pdispVal = pDisp;
                }
                else
                {
                    LOG((TL_ERROR, "get_ACDGroups - could not get IDispatch interface" ));
                    delete p;
                }
            }
            else
            {
                LOG((TL_ERROR, "get_ACDGroups - could not initialize collection" ));
                 delete p;
            }
        }
        else
        {
            LOG((TL_ERROR, "get_ACDGroups - could not create collection" ));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_ACDGroups - bad pVariant pointer" ));
        hr = E_POINTER;
    }


    LOG((TL_TRACE, hr, "get_ACDGroups - exit"));
    return hr;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentHandler
// Interface : ITAgentHandler
// Method    : EnumerateUsableAddresses
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentHandler::EnumerateUsableAddresses(IEnumAddress ** ppEnumAddress)
{
    HRESULT     hr = S_OK;

    LOG((TL_TRACE, "EnumerateUsableAddresses - enter"));


    if(!TAPIIsBadWritePtr( ppEnumAddress, sizeof(IEnumAddress *) ) )
    {
        //
        // create the enumerator
        //
        CComObject< CTapiEnum<IEnumAddress, ITAddress, &IID_IEnumAddress> > * pEnum;
        hr = CComObject< CTapiEnum<IEnumAddress, ITAddress, &IID_IEnumAddress> > ::CreateInstance( &pEnum );
    
        if ( SUCCEEDED(hr) )
        {
            //
            // initialize it with our address array
            //
            Lock();
            
            hr = pEnum->Initialize( m_AddressArray );
            
            Unlock();
            
            if ( SUCCEEDED(hr) )
            {
                // return it
                *ppEnumAddress = pEnum;
            }
            else // failed to initialize
            {
                LOG((TL_ERROR, "EnumerateUsableAddresses - could not initialize enum" ));
                pEnum->Release();
            }
        }
        else  // failed to create enum
        {
            LOG((TL_ERROR, "EnumerateUsableAddresses - could not create enum" ));
        }
    }
    else
    {
        LOG((TL_ERROR, "EnumerateUsableAddresses - bad ppEnumAddress pointer" ));
        hr = E_POINTER;
    }


    LOG((TL_TRACE, hr, "EnumerateUsableAddresses - exit"));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentHandler
// Interface : ITAgentHandler
// Method    : get_UsableAddresses
//
// Return a collection of calls usable for this Agent Handler
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentHandler::get_UsableAddresses(VARIANT  * pVariant)
{
    HRESULT         hr = S_OK;
    IDispatch     * pDisp = NULL;


    LOG((TL_TRACE, "get_UsableAddresses - enter"));

    if (!TAPIIsBadWritePtr( pVariant, sizeof(VARIANT) ) )
    {
        //
        // create the collection
        //
        CComObject< CTapiCollection< ITAddress > > * p;
        hr = CComObject< CTapiCollection< ITAddress > >::CreateInstance( &p );
        
        if (SUCCEEDED(hr) )
        {
            // initialize it with our address Array
            Lock();
            
            hr = p->Initialize( m_AddressArray );
            
            Unlock();
        
            if ( SUCCEEDED(hr) )
            {
                // get the IDispatch interface
                hr = p->_InternalQueryInterface( IID_IDispatch, (void **) &pDisp );
            
                if ( SUCCEEDED(hr) )
                {
                    // put it in the variant
                    VariantInit(pVariant);
                    pVariant->vt = VT_DISPATCH;
                    pVariant->pdispVal = pDisp;
                }
                else
                {
                    LOG((TL_ERROR, "get_UsableAddresses - could not get IDispatch interface" ));
                    delete p;
                }
            }
            else
            {
                LOG((TL_ERROR, "get_UsableAddresses - could not initialize collection" ));
                 delete p;
            }
        }
        else
        {
            LOG((TL_ERROR, "get_UsableAddresses - could not create collection" ));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_UsableAddresses - bad pVariant pointer" ));
        hr = E_POINTER;
    }


    LOG((TL_TRACE, hr, "get_UsableAddresses - exit"));
    return hr;
}





/////////////////////////////////////////////////////////////////////////////
// CAgentEvent



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentEvent
// Method    : FireEvent
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CAgentHandlerEvent::FireEvent(CAgentHandler* pAgentHandler, AGENTHANDLER_EVENT Event)
{
    HRESULT                    hr = S_OK;
    CComObject<CAgentHandlerEvent>  * pEvent;
    IDispatch                * pIDispatch;

    if ( IsBadReadPtr(pAgentHandler, sizeof(CAgentHandler)) )
    {
        STATICLOG((TL_ERROR, "FireEvent - pAgentHandler is an invalid pointer"));
        return E_POINTER;
    }

    //
    // create event
    //
    hr = CComObject<CAgentHandlerEvent>::CreateInstance( &pEvent );

    if ( SUCCEEDED(hr) )
    {
        //
        // initialize
        //
        pEvent->m_AgentHandlerEvent = Event;
        pEvent->m_pAgentHandler= dynamic_cast<ITAgentHandler *>(pAgentHandler);
        pEvent->m_pAgentHandler->AddRef();
    
        //
        // get idisp interface
        //
        hr = pEvent->QueryInterface( IID_IDispatch, (void **)&pIDispatch );

        if ( SUCCEEDED(hr) )
        {
            //
            // get callback & fire event

            //
            CTAPI *pTapi = pAgentHandler->GetTapi();
            pTapi->Event( TE_AGENTHANDLER, pIDispatch );
        
            // release stuff
            //
            pIDispatch->Release();
            
        }
        else
        {
            STATICLOG((TL_ERROR, "FireEvent - Could not get disp interface of AgentHandlerEvent object"));
            delete pEvent;
        }
    }
    else
    {
        STATICLOG((TL_ERROR, "FireEvent - Could not create AgentHandlerEvent object"));
    }

   
    STATICLOG((TL_TRACE, hr, "FireEvent - exit"));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentHandlerEvent
// Method    : FinalRelease
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CAgentHandlerEvent::FinalRelease()
{
    m_pAgentHandler->Release();

}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentEvent
// Interface : ITAgentEvent
// Method    : Agent
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentHandlerEvent::get_AgentHandler(ITAgentHandler ** ppAgentHandler)
{
    HRESULT hr = S_OK;


    LOG((TL_TRACE, "(Event)AgentHandler - enter" ));
    if(!TAPIIsBadWritePtr( ppAgentHandler, sizeof(ITAgentHandler *) ) )
        {
        *ppAgentHandler = m_pAgentHandler;
        m_pAgentHandler->AddRef();
        }
    else
        {
        LOG((TL_ERROR, "(Event)AgentHandler - bad ppAgentHandler Pointer"));
        hr = E_POINTER;
        }

        
    LOG((TL_TRACE, hr, "(Event)AgentHandler - exit"));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentEvent
// Interface : ITAgentEvent
// Method    : Event
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentHandlerEvent::get_Event(AGENTHANDLER_EVENT * pEvent)
{
    HRESULT hr = S_OK;
    LOG((TL_TRACE, "Event - enter" ));
    if(!TAPIIsBadWritePtr( pEvent, sizeof(AGENTHANDLER_EVENT) ) )
        {
        *pEvent = m_AgentHandlerEvent;
        }
    else
        {
        LOG((TL_ERROR, "Event - bad pEvent Pointer"));
        hr = E_POINTER;
        }
  
    
    LOG((TL_TRACE, hr, "Event - exit"));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\callcent.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    Callcent.h

Abstract:

    
Author:

    noela  12-04-97

Notes:

Revision History:

--*/

#ifndef __callcentre_h__
#define __callcentre_h__
/*
// Proxy message  - LINEPROXYREQUEST_ENUMAGENTS : struct - GetAgentList

LONG
WINAPI
lineGetAgentList(     
    HLINE               hLine,
    LPAGENTLIST         lpAgentList
    );

HRESULT
LineGetAgentList(     
    HLINE               hLine,
    LPAGENTLIST         *ppAgentList
    );



// Proxy message  - LINEPROXYREQUEST_FINDAGENT : struct - FindAgent

LONG
WINAPI
lineGetAgent(     
    HLINE               hLine,
    LPAGENTENTRY        lpAgent
    );



// Proxy message  - LINEPROXYREQUEST_AGENTINFO : struct - GetAgentInfo

LONG
WINAPI
lineGetAgentInfo(     
    HLINE               hLine,
    LPAGENTINFO         lpAgentInfo
    );


    
// Proxy message  - LINEPROXYREQUEST_AGENTGETPERIOD : struct - GetSetAgentMeasurementPeriod

LONG
WINAPI
LineGetAgentMeasurementPeriod(     
    HLINE               hLine,
    DWORD               dwAgentHandle,
    LPDWORD             lpdwMeasurementPeriod
    );



// Proxy message  - LINEPROXYREQUEST_AGENTSETPERIOD : struct - GetSetAgentMeasurementPeriod

LONG
WINAPI
LineSetAgentMeasurementPeriod(     
    HLINE               hLine,
    DWORD               dwAgentHandle,
    DWORD               dwMeasurementPeriod
    );



// Proxy mesage LINEPROXYREQUEST_AGENTCREATESESSION :struct - CreateSession

LONG
WINAPI
LineCreateAgentSession(     
    HLINE               hLine,
    LPDWORD             lpdwAgentSessionHandle,
    AGENTENTRY          Agent,
    DWORD               dwAddressID,
    DWORD               dwGroupAddressID
    );


                                            

// Proxy message LINEPROXYREQUEST_AGENTENUMSESSIONS : struct -  GetAgentSessionList

LONG
WINAPI
lineGetAgentSessionList(     
    HLINE               hLine,
    DWORD               dwAgentHandle, 
    LPAGENTSESSIONLIST  lpAgentSessionList
    );


HRESULT LineGetAgentSessionList(
    HLINE hLine, 
    DWORD dwAgentHandle, 
    LPAGENTSESSIONLIST  *ppAgentSessionList 
    );



// Proxy message LINEPROXYREQUEST_AGENTSESSIONSETSTATE : struct - SetAgentSessionState

LONG
WINAPI
lineSetAgentSessionState(   
    HLINE               hLine,
    DWORD               dwAgentSessionHandle,
    DWORD               dwAgentState,
    DWORD               dwNextAgentState     
    );

    
    
// Proxy message LINEPROXYREQUEST_AGENTSESSIONINFO : struct - GetAgentSessionInfo

LONG
WINAPI
lineGetAgentSessionInfo(     
    HLINE               hLine,
    LPAGENTSESSIONINFO  lpAgentSessionInfo
    );
    


// Proxy message  - LINEPROXYREQUEST_QUEUEGETPERIOD : struct - GetSetQueueMeasurementPeriod

LONG
WINAPI
LineGetQueueMeasurementPeriod(     
    HLINEAPP            hLine,
    DWORD               dwQueueAddressID,
    LPDWORD             lpdwMeasurementPeriod
    );



// Proxy message  - LINEPROXYREQUEST_QUEUESETPERIOD : struct - GetSetQueueMeasurementPeriod

LONG
WINAPI
LineSetQueueMeasurementPeriod(     
    HLINEAPP            hLine,
    DWORD               dwQueueAddressID, 
    DWORD               dwMeasurementPeriod
    );



// Proxy message  - LINEPROXYREQUEST_QUEUEINFO : struct - GetQueueInfo

LONG
WINAPI
LineGetQueueInfo(     
    HLINEAPP            hLine,
    DWORD               dwQueueAddressID,
    LPQUEUEINFO         *lpQueueInfo
    );



// Proxy message  - LINEPROXYREQUEST_ACDENUMAGENTS : struct - GetACDGroupAgentList

LONG
WINAPI
LineGetGroupAgentList(     
    HLINE               hLine,
    DWORD               dwACDGroupAddressID,
    LPAGENTLIST         lpAgentList
    );



// Proxy message  - LINEPROXYREQUEST_ACDENUMAGENTSESSIONS : struct - GetACDGroupAgentSessionList

LONG
WINAPI
lineGetGroupAgentSessionList(     
    HLINE               hLine,
    DWORD               dwACDGroupAddressID, 
    LPAGENTSESSIONLIST  lpAgentSessionList
    );

HRESULT LineGetGroupAgentSessionList(
    HLINE hLine, 
    DWORD dwACDGroupAddressID, 
    LPAGENTSESSIONLIST  *ppAgentSessionList 
    );

*/

              
STDMETHODIMP FindAgent(DWORD dwAgentHandle, ITAgent ** ppAgent );
STDMETHODIMP FindGroup(DWORD dwAddressID, ITACDGroup ** ppGroup );
STDMETHODIMP FindQueue(DWORD dwAddressID, ITQueue ** ppQueue );
HRESULT UpdateGlobalAgentSessionList(LPLINEAGENTSESSIONLIST pAgentSessionList);

              
              

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\call.cpp ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    call.cpp

Abstract:

    Implements helper functions for call object

Author:

    mquinton - 4/17/97

Notes:

    optional-notes

Revision History:

--*/

#include "stdafx.h"
#include "tapievt.h"


extern ULONG_PTR GenerateHandleAndAddToHashTable( ULONG_PTR Element);
extern void RemoveHandleFromHashTable(ULONG_PTR Handle);

extern CHashTable             * gpCallHubHashTable;
extern CHashTable             * gpCallHashTable;
extern CHashTable             * gpHandleHashTable;
extern HANDLE                   ghAsyncRetryQueueEvent;


DWORD gdwWaitForConnectSleepTime = 100;
DWORD gdwWaitForConnectWaitIntervals = 600;

char *callStateName(CALL_STATE callState);

HRESULT
ProcessNewCallPrivilege(
                        DWORD dwPrivilege,
                        CALL_PRIVILEGE * pCP
                       );

HRESULT
ProcessNewCallState(
                    DWORD dwCallState,
                    DWORD dwDetail,
                    CALL_STATE CurrentCallState,
                    CALL_STATE * pCallState,
                    CALL_STATE_EVENT_CAUSE * pCallStateCause
                   );

/////////////////////////////////////////////////////////////////////////////
// CCall

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// Initialize the call object
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCall::Initialize(
                  CAddress * pAddress,
                  PWSTR pszDestAddress,
                  long lAddressType,
                  long lMediaType,
                  CALL_PRIVILEGE cp,
                  BOOL bNeedToNotify,
                  BOOL bExpose,
                  HCALL hCall,
                  CEventMasks* pEventMasks
                 )
{
    HRESULT         hr = S_OK;
    IUnknown      * pUnk = NULL;
    
    LOG((TL_TRACE,"Initialize - enter" ));
    LOG((TL_TRACE,"    pAddress ---------> %p", pAddress ));
    LOG((TL_TRACE,"    pszDestAddress ---> %p", pszDestAddress ));
    LOG((TL_TRACE,"    DestAddress is ---> %ls", pszDestAddress ));
    LOG((TL_TRACE,"    CallPrivilege ----> %d", cp ));
    LOG((TL_TRACE,"    bNeedToNotify ----> %d", bNeedToNotify ));
    LOG((TL_TRACE,"    hCall ------------> %lx", hCall ));


    //
    // good address object?
    //

    if (IsBadReadPtr(pAddress, sizeof(CAddress)))
    {
        LOG((TL_ERROR, "Initialize - - bad address pointer"));

        return E_INVALIDARG;
    }


    //
    // copy the destination address
    //
    if (NULL != pszDestAddress)
    {
        m_szDestAddress = (PWSTR) ClientAlloc(
                                              (lstrlenW(pszDestAddress) + 1) * sizeof (WCHAR)
                                             );
        if (NULL == m_szDestAddress)
        {
            LOG((TL_ERROR, E_OUTOFMEMORY,"Initialize - exit" ));

            return E_OUTOFMEMORY;
        }

        lstrcpyW(
                 m_szDestAddress,
                 pszDestAddress
                );
    }

    m_pCallParams = (LINECALLPARAMS *)ClientAlloc( sizeof(LINECALLPARAMS) + 1000 );

    if ( NULL == m_pCallParams )
    {
        ClientFree( m_szDestAddress );

        m_szDestAddress = NULL;

        LOG((TL_ERROR, E_OUTOFMEMORY,"Initialize - exit" ));

        return E_OUTOFMEMORY;
    }


    m_pCallParams->dwTotalSize = sizeof(LINECALLPARAMS) + 1000;
    m_dwCallParamsUsedSize = sizeof(LINECALLPARAMS);
    
    //
    // set original state
    //
    m_t3Call.hCall = hCall;
    m_t3Call.pCall = this;
    m_hAdditionalCall = NULL;
    m_CallPrivilege = cp;
    m_pAddress = pAddress;
    m_pAddress->AddRef();
    if( m_pAddress->GetAPIVersion() >= TAPI_VERSION3_0 )
    {
        m_pCallParams->dwAddressType = lAddressType;
    }
    m_dwMediaMode = lMediaType;

    //
    // Read the subevent mask from the 
    // address parent object
    //
    pEventMasks->CopyEventMasks( &m_EventMasks);


    if (bNeedToNotify)
    {
        m_dwCallFlags |= CALLFLAG_NEEDTONOTIFY;
    }

    if (!bExpose)
    {
        m_dwCallFlags |= CALLFLAG_DONTEXPOSE;
    }

    //
    // keep 1 reference for the global hash table
    //
    if ( bNeedToNotify )
    {
        m_dwRef = 3;
    }
    else
    {
        m_dwRef = 2;
    }


    //
    // if we are the owner of the call, and the address has msp, attempt to
    // create msp call
    //

    if ( (CP_OWNER == m_CallPrivilege) && m_pAddress->HasMSP() )
    {
        hr = CreateMSPCall( lMediaType );
        if ( FAILED (hr) )
        {
            // If we fail to create an MSP call we can still use the call 
            // for non media call control
            LOG((TL_ERROR, hr, "Initialize - CreateMSPCall failed"));
        }
    }
    

    //
    // put in global hash table
    //
    if ( NULL != m_t3Call.hCall )
    {
        AddCallToHashTable();
    }
    
    LOG((TL_TRACE,S_OK,"Initialize - exit" ));

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// ExternalFinalRelease
//      Clean up call object
//
// we have this special finalrelease because we keep our own reference
// to the call.  right before the ref count goes to 1 inside of release,
// we call this.  It is possible that the call's ref count could go up
// again because of a message from tapisrv.  So, we lock the hashtable,
// then verify the refcount again.  If we did process a message from
// tapisrv for the call,the refcount will be increased, and we won't
// do this finalrelease.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL
CCall::ExternalFinalRelease()
{
    HRESULT hr = S_OK;
    CCallHub * pCallHub = NULL;

    
    LOG((TL_TRACE, "ExternalFinalRelease - enter" ));

    Lock();

    //
    // NikhilB: Call object has a reference to Callhub object so its safe to
    // lock the callhub object before locking the call. This is to avoid a
    // deadlock that happens dur to locking the call and the callhub in reverse 
    // orders in different functions.
    //
        
    if( m_pCallHub != NULL )
    {
        m_pCallHub->AddRef();
        
        pCallHub = m_pCallHub;
        
        Unlock();
        
        // lock the callhub object before locking the call
        pCallHub->Lock();
        Lock();
        
        pCallHub->Release();
    }

    //
    // Check extra t3call used in conference legs
    //
    if (NULL != m_hAdditionalCall)
    {
        LOG((TL_INFO,"ExternalFinalRelease: Deallocating Addditional call"));
        
        LineDeallocateCall( m_hAdditionalCall );
        
        m_hAdditionalCall = NULL;
    }


    if (NULL != m_t3Call.hCall)
    {
        //
        // dealloc call
        //
        LOG((TL_INFO,"Deallocating call"));
        
        hr = LineDeallocateCall( m_t3Call.hCall );
        if (FAILED(hr))
        {
            LOG((TL_ERROR, hr, "ExternalFinalRelease - LineDeallocateCall failed" ));
        }

        m_t3Call.hCall = NULL;
    }

    //
    // clean up & release the callhub
    //
    if (NULL != pCallHub)
    {


        pCallHub->RemoveCall( this );



        Unlock();


        //
        // checkforidle will lock the callhub and then every call that belongs
        // to it. make this call outside call's lock to prevent deadlocks with 
        // other threads that can possibly lock a call (which belongs to this 
        // callhub) while trying to lock this callhub
        //
        
        pCallHub->CheckForIdle();


        Lock();


        pCallHub->Unlock();
        pCallHub = NULL;

        //release the refcount that call object has to the callhub.
        if(m_pCallHub != NULL)
        {
            m_pCallHub->Release();
            m_pCallHub = NULL;
        }
    }

    //
    // close the associated line
    //
    if ( ! ( m_dwCallFlags & CALLFLAG_NOTMYLINE ) )
    {
        m_pAddress->MaybeCloseALine( &m_pAddressLine );
    }

    //
    // remove the call from the address's list
    //
    m_pAddress->RemoveCall( (ITCallInfo *) this );

    //
    // free the dest address string
    //
    ClientFree(m_szDestAddress);
    m_szDestAddress = NULL;

    if ( NULL != m_pCallInfo )
    {
        ClientFree( m_pCallInfo );
        m_pCallInfo = NULL;
        m_dwCallFlags |= CALLFLAG_CALLINFODIRTY;
    }

    //
    // tell the msp the call is going away
    //
    if ( NULL != m_pMSPCall )
    {
        m_pAddress->ShutdownMSPCall( m_pMSPCall );

        m_pMSPCall->Release();
    }



    //
    // release the address
    //
    m_pAddress->Release();

    //
    // release the private object
    //
    if (NULL != m_pPrivate)
    {
        m_pPrivate->Release();
    }

    //
    //NikhilB:If this was a consultation call and is being dropped before 
    //calling Finish on it then we should release the reference it holds to
    //the primary call object through m_pRelatedCall
    //
    if( NULL != m_pRelatedCall )
    {
        m_pRelatedCall->Release();

        m_pRelatedCall = NULL;
        m_dwCallFlags &= ~CALLFLAG_CONSULTCALL;
    }


    //
    // free any call params
    //
    if ( NULL != m_pCallParams )
    {
        ClientFree( m_pCallParams );
        m_pCallParams = NULL;
    }  
    
    //
    // clean up the gather digits queue
    //
    m_GatherDigitsQueue.Shutdown();

    Unlock();

    
    LOG((TL_TRACE, "ExternalFinalRelease - exit" ));

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////

void CCall::CallOnTapiShutdown()
{
    LOG((TL_TRACE, "CallOnTapiShutdown - enter" ));


    //
    // we need to remove the call from the handle hash table to avoid duplicate
    // entries with the calls that are created later with the same call handle
    // (in case _this_  call object is still referenced by the app and is 
    // still around
    //

    gpCallHashTable->Lock();
    
    gpCallHashTable->Remove( (ULONG_PTR)(m_t3Call.hCall) );

    gpCallHashTable->Unlock();


    LOG((TL_TRACE, "CallOnTapiShutdown - exit" ));
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// MyBasicCallControlQI
//      don't give out the basiccallcontrol interface
//      if the application does not own the call
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
WINAPI
MyBasicCallControlQI(void* pv, REFIID riid, LPVOID* ppv, DWORD_PTR dw)
{
    LOG((TL_TRACE,"MyBasicCallControlQI - enter"));

    CALL_PRIVILEGE cp;

    ((CCall *)pv)->get_Privilege( &cp );

    if (CP_OWNER != cp)
    {
        LOG((TL_WARN,"The application is not the owner of this call"));
        LOG((TL_WARN,"so it cannot access the BCC interface"));
        return E_NOINTERFACE;
    }

    //
    // S_FALSE tells atl to continue querying for the interface
    //
    LOG((TL_INFO,"The application owns this call, so it can access the BCC interface"));

    LOG((TL_TRACE, "MyBasicCallControlQI - exit"));

    return S_FALSE;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// TryToFindACallHub
//
// for an incoming call, tries to find an existing callhub.
// the order of events (LINE_APPNEWCALL and LINE_APPNEWCALLHUB) is
// not guaranteed.
//
// must be called in a Lock()
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCall::TryToFindACallHub()
{
    HRESULT                   hr;
    HCALLHUB                  hCallHub;
    CCallHub                * pCallHub;

    //
    // do we already have a callhub?
    //
    if ( ( NULL == m_pCallHub ) && (NULL != m_t3Call.hCall ) )
    {
        //
        // no.  Ask tapisrv for the hCallHub
        //
        hr = LineGetCallHub(
                            m_t3Call.hCall,
                            &hCallHub
                           );

        //
        // if it fails, there is no hCallHub,
        // so try to create a fake one
        //
        if (!SUCCEEDED(hr))
        {
            hr = CheckAndCreateFakeCallHub();
            
            return hr;
        }

        //
        // if there is, find the correponding CallHub object
        //
        if (FindCallHubObject(
                              hCallHub,
                              &pCallHub
                             ))
        {
            //
            // save it in the call
            //
            SetCallHub( pCallHub );

            //
            // tell it about this call
            // ZoltanS note: the following calls CCall::SetCallHub as well,
            // but this no longer results in an extra reference to the callhub
            // as we now check for that in CCall::SetCallHub.
            //
            pCallHub->AddCall( this );

            //
            // FindCallHubObject addrefs
            //
            pCallHub->Release();
        }

    }

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  SetRelatedCall
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CCall::SetRelatedCall(CCall * pCall, DWORD callFlags) 
{
    Lock();

    //
    // keep a reference to the related call
    //
    pCall->AddRef();

    //
    // save it
    //
    m_pRelatedCall = pCall;

    //
    // save the relavant call flags
    //
    m_dwCallFlags |= callFlags;

    Unlock();
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  ResetRelatedCall
//
// clear out the relate call stuff
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CCall::ResetRelatedCall()
{
    Lock();
    
    //
    // release ref
    //
    if( m_pRelatedCall != NULL )
    {
        m_pRelatedCall->Release();
        m_pRelatedCall = NULL;
    }
     
    m_dwCallFlags &= ~(CALLFLAG_CONSULTCALL | CALLFLAG_CONFCONSULT | CALLFLAG_TRANSFCONSULT );

    Unlock();
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CreateMSPCall
//
// tell the msp to create a call based on the give mediatype
// 
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CCall::CreateMSPCall(
                     long lMediaType
                    )
{
    HRESULT              hr;
    IUnknown           * pUnk;
    
    LOG((TL_TRACE,"CreateMSPCall - enter"));

    Lock();

    hr = _InternalQueryInterface( IID_IUnknown, (void**) &pUnk );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "CreateMSPCall - cant get IUnk - %lx", hr));

        Unlock();

        return hr;
    }
    
    // Create a context handle to give the MSPCall object & associate it with 
    //this object in the global handle hash table
    m_MSPCallHandle = (MSP_HANDLE) GenerateHandleAndAddToHashTable((ULONG_PTR)this);
 
    
    //
    // create a MSPCall - the address actually calls
    // into the msp for us.
    //
    hr = m_pAddress->CreateMSPCall(
        m_MSPCallHandle,
        0,
        lMediaType,
        pUnk,
        &m_pMSPCall
        );

    pUnk->Release();
    
    Unlock();
    
    if (!SUCCEEDED(hr))
    {
        LOG((TL_ERROR, "CreateMSPCall failed, %x", hr ));
    }

    LOG((TL_TRACE,"CreateMSPCall - exit - returning %lx", hr));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// DialConsultCall
//
// bSync - same as connect - should we wait to return until
// the call is connected or disconnected?
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CCall::DialConsultCall(BOOL bSync)
{
    HRESULT         hr = S_OK;
    HANDLE          hEvent;
    
    LOG((TL_TRACE, "DialConsultCall - enter" ));
    LOG((TL_TRACE, "     bSync ---> %d", bSync ));

    Lock();
    
    // make sure they have selected media terminals
    //
    hr = m_pAddress->FindOrOpenALine(
                                     m_dwMediaMode,
                                     &m_pAddressLine
                                    );

    if (S_OK != hr)
    {
        Unlock();
        
        LOG((
               TL_ERROR,
               "DialConsultCall - FindOrOpenALine failed - %lx",
               hr
              ));
        
        return hr;
    }

    //
    // dial the call
    //
    hr = LineDial(
                  m_t3Call.hCall,
                  m_szDestAddress,
                  m_dwCountryCode
                 );
    
    if ( SUCCEEDED(hr) )
    {
        if (bSync)
        {
            hEvent = CreateConnectedEvent();
        }

        Unlock();

        //
        // wait for an async reply
        //
        hr = WaitForReply( hr );

        Lock();
    }

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "DialConsultCall - LineDial failed - %lx", hr ));

        ClearConnectedEvent();
        
        m_CallState = CS_DISCONNECTED;
        
        m_pAddress->MaybeCloseALine( &m_pAddressLine );

        Unlock();
        
        return hr;
    }

    Unlock();

    if (bSync)
    {
        return SyncWait( hEvent );
    }

    LOG((TL_TRACE, "DialConsultCall - exit - return SUCCESS"));

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// OnDisconnect
//
// called when the call transitions into the disconnected state
//
// called in lock
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CCall::OnDisconnect()
{
    CCallHub * pCallHub = NULL;
    
    LOG((TL_ERROR, "OnDisconnect - enter"));

    Lock();

    //
    // set the connected event if necessary
    //
    if ( NULL != m_hConnectedEvent )
    {
        SetEvent( m_hConnectedEvent );
    }

    //
    // special case for wavemsp
    //
    if ( OnWaveMSPCall() )
    {
        StopWaveMSPStream();
    }
#ifdef USE_PHONEMSP
    else if ( OnPhoneMSPCall() )
    {
        StopPhoneMSPStream();
    }
#endif USE_PHONEMSP
    
    //
    // check to see if the callhub
    // is idle
    //
    pCallHub = m_pCallHub;
    
    if ( NULL != pCallHub )
    {

        pCallHub->AddRef();

        Unlock();


        //
        //  unlock the call before calling checkfor idle to prevent deadlocks
        //

        pCallHub->CheckForIdle();

        pCallHub->Release();
    }
    else
    {


       Unlock();
    }

    LOG((TL_ERROR, "OnDisconnect - finish"));

    return S_OK;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CCall::StartWaveMSPStream
//
// need to give it the waveID info and
// tell it to start streaming
//
// the format of the blob given to the wave msp is:
//
// First DWORD =  Command                Second DWORD  Third DWORD
// -------------  -------                ------------  -----------
// 0              Set wave IDs           WaveIn ID     WaveOut ID
// 1              Start streaming        <ignored>     <ignored>
// 2              Stop streaming         <ignored>     <ignored>
// 3 <per-address, not per-call>
// 4 <per-address, not per-call>
// 5              Suspend streaming      <ignored>     <ignored>
// 6              Resume streaming       <ignored>     <ignored>
// 7              Wave IDs unavailable   <ignored>     <ignored>
//
//
// called in lock()
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCall::StartWaveMSPStream()
{
    //
    // Get the stream control interface.
    //

    DWORD             adwInfo[3];
    ITStreamControl * pStreamControl;
    
    pStreamControl = GetStreamControl();
    
    if ( NULL == pStreamControl )
    {
        return E_FAIL;
    }

    //
    // Get the per-call waveids, and report the results to the wavemsp.
    //

    HRESULT         hr;

    hr = CreateWaveInfo(
                        NULL,
                        0,
                        m_t3Call.hCall,
                        LINECALLSELECT_CALL,
                        m_pAddress->HasFullDuplexWaveDevice(),
                        adwInfo
                       );

    if ( SUCCEEDED(hr) )
    {
        // 0 = set waveids
        adwInfo[0] = 0; 
        // waveids filled in above
    }
    else
    {
        // 7: per-call waveids unavailable
        adwInfo[0] = 7;
        adwInfo[1] = 0;
        adwInfo[2] = 0;
    }

    m_pAddress->ReceiveTSPData(
                               pStreamControl,
                               (LPBYTE)adwInfo,
                               sizeof(adwInfo)
                              );

    //
    // now tell it to start streaming
    //

    adwInfo[0] = 1;
    adwInfo[1] = 0;
    adwInfo[2] = 0;

    m_pAddress->ReceiveTSPData(
                               pStreamControl,
                               (LPBYTE)adwInfo,
                               sizeof(adwInfo)
                              );

    pStreamControl->Release();

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CCall::StopWaveMSPStream
//
// called in lock
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCall::StopWaveMSPStream()
{
    DWORD           adwInfo[3];
    ITStreamControl * pStreamControl;

    adwInfo[0] = 2;

    pStreamControl = GetStreamControl();

    if ( NULL == pStreamControl )
    {
        return E_FAIL;
    }
    
    m_pAddress->ReceiveTSPData(
                               pStreamControl,
                               (LPBYTE)adwInfo,
                               sizeof(adwInfo)
                              );

    pStreamControl->Release();
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CCall::SuspendWaveMSPStream
//
// called in lock
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCall::SuspendWaveMSPStream()
{
    DWORD           adwInfo[3];
    ITStreamControl * pStreamControl;

    adwInfo[0] = 5;

    pStreamControl = GetStreamControl();

    if ( NULL == pStreamControl )
    {
        return E_FAIL;
    }
    
    m_pAddress->ReceiveTSPData(
                               pStreamControl,
                               (LPBYTE)adwInfo,
                               sizeof(adwInfo)
                              );

    pStreamControl->Release();
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CCall::ResumeWaveMSPStream
//
// called in lock
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCall::ResumeWaveMSPStream()
{
    DWORD           adwInfo[3];
    ITStreamControl * pStreamControl;

    adwInfo[0] = 6;

    pStreamControl = GetStreamControl();

    if ( NULL == pStreamControl )
    {
        return E_FAIL;
    }
    
    m_pAddress->ReceiveTSPData(
                               pStreamControl,
                               (LPBYTE)adwInfo,
                               sizeof(adwInfo)
                              );

    pStreamControl->Release();
    
    return S_OK;
}

#ifdef USE_PHONEMSP
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CCall::StartPhoneMSPStream
//
// called in lock
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCall::StartPhoneMSPStream()
{
    ITStreamControl                 * pStreamControl;
    DWORD                             dwControl = 0;

    
    pStreamControl = GetStreamControl();

    if ( NULL == pStreamControl )
    {
        return E_FAIL;
    }

    
    m_pAddress->ReceiveTSPData(
                               pStreamControl,
                               (LPBYTE)&dwControl,
                               sizeof(DWORD)
                              );

    pStreamControl->Release();
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CCall::StopPhoneMSPStream
//
// called in lock
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCall::StopPhoneMSPStream()
{
    ITStreamControl                 * pStreamControl;
    DWORD                             dwControl = 1;

    
    pStreamControl = GetStreamControl();

    if ( NULL == pStreamControl )
    {
        return E_FAIL;
    }

    
    m_pAddress->ReceiveTSPData(
                               pStreamControl,
                               (LPBYTE)&dwControl,
                               sizeof(DWORD)
                              );

    pStreamControl->Release();
    
    return S_OK;
}
#endif USE_PHONEMSP

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// OnConnect
//
// called when the call transitions to the connected state
//
// called in lock
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CCall::OnConnect()
{
    HRESULT         hr = S_OK;

    //
    // set connected event if it exists
    //
    if ( NULL != m_hConnectedEvent )
    {
        SetEvent( m_hConnectedEvent );
    }

    //
    // special cases
    //
    if (OnWaveMSPCall())
    {
        StartWaveMSPStream();
    }
#ifdef USE_PHONEMSP
    else if ( OnPhoneMSPCall() )
    {
        StartPhoneMSPStream();
    }
#endif USE_PHONEMSP

    return S_OK;
        
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCall
// Method    : CreateConference
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CCall::CreateConference(
    CCall        * pConsultationCall,
    VARIANT_BOOL   bSync
    )
{
    HRESULT             hr = S_OK;
    HCALL               hConfCall;
    HCALL               hConsultCall;
    DWORD               dwCallFeatures;
    CALL_STATE          consultationCallState = CS_IDLE;
    
    LOG((TL_TRACE,  "CreateConference - enter"));

    Lock();

    //
    // we must have a hub
    //

    if (m_pCallHub == NULL)
    {
        
        //
        // if this is happening, we have a bug. debug.
        //

        LOG((TL_ERROR,  "CreateConference - no call hub. returning E_UNEXPECTED"));
        
        _ASSERTE(FALSE);

        Unlock();

        return E_UNEXPECTED;
    }

    //
    // Get Call Status to determine what features we can use
    //
    LPLINECALLSTATUS    pCallStatus = NULL;

    hr = LineGetCallStatus(  m_t3Call.hCall, &pCallStatus  );
    
    if (!SUCCEEDED(hr))
    {
        LOG((TL_ERROR, "CreateConference - LineGetCallStatus failed %lx", hr));

        Unlock();
        
        return hr;
    }

    dwCallFeatures = pCallStatus->dwCallFeatures;

    ClientFree( pCallStatus );
    
#if CHECKCALLSTATUS
    
    //
    // Do we support the required call features ?
    //
    if ( !( (dwCallFeatures & LINECALLFEATURE_SETUPCONF) &&
            (dwCallFeatures & LINECALLFEATURE_ADDTOCONF) ) )
    {
        LOG((TL_ERROR, "CreateConference - LineGetCallStatus reports Conference not supported"));

        Unlock();

        return E_FAIL;
    }

#endif

    //
    // we support it, so try the Conference
    // Setup & dial the consultation Call
    //
    LOG((TL_INFO, "CreateConference - Trying to setupConference" ));

    pConsultationCall->Lock();
    
    pConsultationCall->FinishCallParams();

    hr = LineSetupConference(
                             m_t3Call.hCall,
                             &(m_pAddressLine->t3Line),
                             &hConfCall,
                             &hConsultCall,
                             3,
                             m_pCallParams
                            );

    Unlock();

    pConsultationCall->Unlock();

    if ( SUCCEEDED(hr) )
    {
        //
        // wait for async reply
        //
        hr = WaitForReply( hr );

    }

    if ( FAILED(hr) )
    {
        LOG((TL_INFO, "CreateConference - LineSetupConference failed - %lx", hr));

        return hr;
    }
    
    LOG((TL_INFO, "CreateConference - LineSetupConference completed OK"));

    //Check if the call is in connected state.
    pConsultationCall->Lock();
    
    pConsultationCall->get_CallState(&consultationCallState);

    if ( (consultationCallState == CS_CONNECTED) || (consultationCallState == CS_HOLD) )
    {
        //
        // the existing call is in a connected stae so we just need to deallocate 
        // hConsultcall and do a finish() to call down to LineAddToConference()
        //
        if ( NULL != hConsultCall  )
        {
	        HRESULT hr2;

	        hr2 = LineDrop( hConsultCall, NULL, 0 );

	        if ( ((long)hr2) > 0 )
	        {
		        hr2 = WaitForReply( hr2 ) ;
	        }

	        hr = LineDeallocateCall( hConsultCall );
	        hConsultCall = NULL;
        }
        
        if ( FAILED(hr) )
        {
            LOG((TL_INFO, "CreateConference - lineDeallocateCall failed - %lx", hr));
        }
        else
        {
            pConsultationCall->SetRelatedCall(
                                              this,
                                              CALLFLAG_CONFCONSULT|CALLFLAG_CONSULTCALL
                                             );

            hr = S_OK;
        }
        
        pConsultationCall->Unlock();

        Lock();
        //
        // Store the confcontroller in the callhub object
        //
        if (m_pCallHub != NULL)
        {
            m_pCallHub->CreateConferenceControllerCall(
                hConfCall,
                m_pAddress
                );
        }
        else
        {
            //
            // we made sure we had the hub when we entered the function
            //
            
            LOG((TL_INFO, "CreateConference - No CallHub"));
            _ASSERTE(FALSE);
        }

        Unlock();

    }
    else
    {
        pConsultationCall->FinishSettingUpCall( hConsultCall );

        pConsultationCall->Unlock();
        
        Lock();
        //
        // Store the confcontroller in the callhub object
        //
        if (m_pCallHub != NULL)
        {
            m_pCallHub->CreateConferenceControllerCall(
                hConfCall,
                m_pAddress
                );
        }
        else
        {
            LOG((TL_ERROR, "CreateConference - No CallHub"));
            _ASSERTE(FALSE);
        }

        Unlock();

        //
        // now do the consulation call
        //
        hr = pConsultationCall->DialAsConsultationCall( this, dwCallFeatures, TRUE, bSync );
    
    }
    
    LOG((TL_TRACE, hr, "CreateConference - exit"));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCall
// Method    : AddToConference
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CCall::AddToConference(
    CCall        * pConsultationCall,
    VARIANT_BOOL   bSync
    )
{
    HRESULT             hr = S_OK;
    CCall             * pConfContCall = NULL;
    HCALL               hConfContCall = NULL;
    HCALL               hConsultCall = NULL;
    CALL_STATE          consultationCallState = CS_IDLE;
    DWORD               dwCallFeatures;
    
    LOG((TL_TRACE,  "AddToConference - enter"));

    Lock();

    //
    // we must have a hub
    //

    if (m_pCallHub == NULL)
    {
        
        //
        // if this is happening, we have a bug. debug.
        //

        LOG((TL_ERROR,  
            "AddToConference - no call hub. returning E_UNEXPECTED"));
        
        _ASSERTE(FALSE);

        Unlock();

        return E_UNEXPECTED;
    }

    {
        //
        // NikhilB: Call object has a reference to Callhub object so its safe to
        // lock the callhub object before locking the call. This is to avoid a
        // deadlock that happens dur to locking the call and the callhub in reverse 
        // orders in different functions.
        //

        m_pCallHub->AddRef();
        AddRef();

        Unlock();
    
        // lock the callhub object before locking the call
        m_pCallHub->Lock();
        Lock();
    
        Release();
        m_pCallHub->Release();
    }

    //
    // we must have conference controller
    //

    pConfContCall = m_pCallHub->GetConferenceControllerCall();
    m_pCallHub->Unlock();
    
    if (NULL == pConfContCall)
    {

        //
        // if we get here, we have a bug. debug.
        //

        LOG((TL_ERROR, 
            "AddToConference - the callhub does not have a conference controller. E_UNEXPECTED"));

        _ASSERTE(FALSE);

        Unlock();
                
        return E_UNEXPECTED;
    }


    //
    // ask conference call controller for a conference call handle
    //

    hConfContCall = pConfContCall->GetHCall();

    if (NULL == hConfContCall)
    {
        LOG((TL_ERROR, 
            "AddToConference - conf controller does not have a valid conf call handle. E_UNEXPECTED"));

        _ASSERTE(FALSE);

        Unlock();

        return E_UNEXPECTED;
    }

    //
    // Get Call Status to determine what features we can use
    //
    LPLINECALLSTATUS    pCallStatus = NULL;  

    hr = LineGetCallStatus(  m_t3Call.hCall, &pCallStatus  );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "AddToConference - LineGetCallStatus failed %lx", hr));

        Unlock();
        
        return hr;
    }
    
    dwCallFeatures = pCallStatus->dwCallFeatures;

    ClientFree( pCallStatus );
    
#if CHECKCALLSTATUS
    
    //
    // Do we support the required call features ?
    //
    if ( !( ( dwCallFeatures & LINECALLFEATURE_PREPAREADDCONF ) &&
            ( dwCallFeatures & LINECALLFEATURE_ADDTOCONF ) ) )
    {
        LOG((TL_ERROR, "AddToConference - LineGetCallStatus reports Conference not supported"));

        Unlock();
        
        return E_FAIL;
    }
        
#endif

    //
    // we support it, so try the Conference
    //
    pConsultationCall->get_CallState(&consultationCallState);

    if ( (consultationCallState == CS_CONNECTED) || (consultationCallState == CS_HOLD) )
    {
        //
        // the existing call is in a connected stae so we just need to to do a finish()
        // to call down to LineAddToConference()
        //
        pConsultationCall->SetRelatedCall(
                                          this,
                                          CALLFLAG_CONFCONSULT|CALLFLAG_CONSULTCALL
                                         );

        Unlock();
        return S_OK;
    }

    //
    // We need to Setup & dial the consultation Call
    //
    //Lock();

    pConsultationCall->Lock();

    pConsultationCall->FinishCallParams();


    hr = LinePrepareAddToConference(
                                    hConfContCall, 
                                    &hConsultCall,
                                    m_pCallParams 
                                   );

    pConsultationCall->Unlock();

    Unlock();

    if ( SUCCEEDED(hr) )
    {
        //
        // wait for async reply
        //
        hr = WaitForReply( hr );

        if ( SUCCEEDED(hr) )
        {
            LONG            lCap;

            LOG((TL_INFO, "AddToConference - LinePrepareAddToConference completed OK"));
            //
            // Update handles in consult call object & insert it in the hash table
            // note - we can miss messages if something comes in between the time time
            // we get the reply, and the time we insert the call
            //
            pConsultationCall->Lock();

            pConsultationCall->FinishSettingUpCall( hConsultCall );

            pConsultationCall->Unlock();

            //
            // now do the consulation call
            //
            hr = pConsultationCall->DialAsConsultationCall( this, dwCallFeatures, TRUE, bSync );
        }
        else // AddToConference async reply failed
        {
            LOG((TL_ERROR, "AddToConference - LinePrepareAddToConference failed async" ));
        }
    }
    else  // AddToConference failed
    {
        LOG((TL_ERROR, "AddToConference - LinePrepareAddToConference failed" ));
    }

           
    LOG((TL_TRACE, hr, "AddToConference - exit"));
    
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCall
// Method    : WaitForCallState
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CCall::WaitForCallState( CALL_STATE requiredCS )
{
    DWORD       gdwWaitIntervals = 0;
    HRESULT     hr = E_FAIL;

    LOG((TL_TRACE,  "WaitForCallState - enter"));
        
    while (
           ( requiredCS != m_CallState ) &&
           ( CS_DISCONNECTED != m_CallState ) &&
           ( gdwWaitIntervals < gdwWaitForConnectWaitIntervals )
          )
    {
        LOG((TL_INFO,  "WaitForCallState - Waiting for state %d", requiredCS));
        LOG((TL_INFO,  "     state is currently %d for call %p", m_CallState, this));
        Sleep( gdwWaitForConnectSleepTime );
        gdwWaitIntervals++;
    }

    if (m_CallState == requiredCS)
    {
        LOG((TL_INFO,  "WaitForCallState - Reached required state"));
        hr = S_OK;
    }
    else
    {
        LOG((TL_INFO,  "WaitForCallState - Did not reach required state"));
    }

    LOG((TL_TRACE, hr, "WaitForCallState - exit"));
    return(hr);
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCall
// Method    : OneStepTransfer
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CCall::OneStepTransfer(
    CCall        * pConsultationCall,
    VARIANT_BOOL   bSync
    )

{
    HRESULT             hr = S_OK;
    LPLINECALLPARAMS    pCallParams;
    DWORD               dwDestAddrSize;
    HCALL               hCall;
    HANDLE              hEvent;

    
    
    LOG((TL_TRACE, "OneStepTransfer - enter"));

    //
    // Setup call params structure for a one step transfer Consultation call
    //
    pConsultationCall->Lock();

    dwDestAddrSize = (lstrlenW(pConsultationCall->m_szDestAddress) * sizeof(WCHAR)) + sizeof(WCHAR);

    Lock();

    hr = ResizeCallParams(dwDestAddrSize);

    if( !SUCCEEDED(hr) )
    {
        pConsultationCall->Unlock();

        Unlock();

        LOG((TL_ERROR, "OneStepTransfer - resizecallparams failed %lx", hr));
        
        return hr;
    }
    
    //
    // Copy the string & set the size, offset etc
    //
    lstrcpyW((PWSTR)(((PBYTE)m_pCallParams) + m_dwCallParamsUsedSize),
             pConsultationCall->m_szDestAddress);

    if ( m_pAddress->GetAPIVersion() >= TAPI_VERSION2_0 )
    {
        m_pCallParams->dwTargetAddressSize = dwDestAddrSize;
        m_pCallParams->dwTargetAddressOffset = m_dwCallParamsUsedSize;
    }

    m_dwCallParamsUsedSize += dwDestAddrSize;

    //
    // Set the one step bit flag
    //
    m_pCallParams->dwCallParamFlags |= LINECALLPARAMFLAGS_ONESTEPTRANSFER ;


    FinishCallParams();

    //
    // Do the transfer
    //
    hr = LineSetupTransfer(
                           m_t3Call.hCall,
                           &hCall,
                           m_pCallParams
                          );

    Unlock();
    
    if ( SUCCEEDED(hr) )
    {
        hEvent = pConsultationCall->CreateConnectedEvent();

        pConsultationCall->Unlock();

        //
        // wait for async reply
        //
        hr = WaitForReply( hr );

        pConsultationCall->Lock();
    }

    if ( FAILED(hr) )
    {
        ClearConnectedEvent();

        pConsultationCall->Unlock();

        return hr;
    }
    
    LOG((TL_INFO, "OneStepTransfer - LineSetupTransfer completed OK"));

    pConsultationCall->FinishSettingUpCall( hCall );

    pConsultationCall->SetRelatedCall(
                                      this,
                                      CALLFLAG_TRANSFCONSULT|CALLFLAG_CONSULTCALL
                                     );

    pConsultationCall->Unlock();
    
    if(bSync)
    {
        //
        // Wait for connect on on our consultation call
        //
        hr = pConsultationCall->SyncWait( hEvent );

        if( S_OK == hr )
        {
            LOG((TL_INFO, "OneStepTransfer -  Consultation call connected" ));
        }
        else
        {
            LOG((TL_ERROR, "OneStepTransfer - Consultation call failed to connect" ));
            
            hr = TAPI_E_OPERATIONFAILED;
        }
    }

    LOG((TL_TRACE, hr, "OneStepTransfer - exit"));
    
    return hr; 
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// UpdateStateAndPrivilege
//
// update the call state and privilege of this call
// this method is used when a call shows up in Unpark or Pickup
// and needs to have the correct state and priv
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CCall::UpdateStateAndPrivilege()
{
    HRESULT             hr = S_OK;
    LINECALLSTATUS    * pCallStatus;
    HCALL               hCall;
    

    Lock();

    hCall = m_t3Call.hCall;

    hr = LineGetCallStatus(
                           hCall,
                           &pCallStatus
                          );

    if ( SUCCEEDED(hr) )
    {
        CALL_STATE                      cs;
        CALL_STATE_EVENT_CAUSE          csc;
        CALL_PRIVILEGE                  cp;
        
        hr = ProcessNewCallState(
                                 pCallStatus->dwCallState,
                                 0,
                                 m_CallState,
                                 &cs,
                                 &csc
                                );

        SetCallState( cs );

        hr = ProcessNewCallPrivilege(
                                     pCallStatus->dwCallPrivilege,
                                     &cp
                                    );

        m_CallPrivilege = cp;

        ClientFree(pCallStatus);
    }

    Unlock();
    
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// ProcessNewCallState
//      given a call state message (dwCallState, dwDetail, dwPriv)
//      create a new tapi 3.0 callstate
//
//      return S_OK if a new call state was created
//      return S_FALSE if the message can be ignored (duplicate
//      return E_? if bad error
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CCall::ProcessNewCallState(
                    DWORD dwCallState,
                    DWORD dwDetail,
                    CALL_STATE CurrentCallState,
                    CALL_STATE * pCallState,
                    CALL_STATE_EVENT_CAUSE * pCallStateCause
                   )
{
    HRESULT     hr = S_OK;
    CALL_STATE  NewCallState = CurrentCallState;

    LOG((TL_INFO, "ProcessNewCallState"));
    LOG((TL_INFO, "       dwCallState----->%lx", dwCallState));
    LOG((TL_INFO, "       dwDetail-------->%lx", dwDetail));
    LOG((TL_INFO, "       pCallState------>%p", pCallState));
    LOG((TL_INFO, "       pCallStateCause->%p", pCallStateCause));

    *pCallStateCause = CEC_NONE;

    
    switch (dwCallState)
    {
        case LINECALLSTATE_BUSY:
            dwDetail = LINEDISCONNECTMODE_BUSY;
            // fall through
        case LINECALLSTATE_DISCONNECTED:
        case LINECALLSTATE_IDLE:
        {
            
            NewCallState = CS_DISCONNECTED;

            switch (dwDetail)
            {
                case LINEDISCONNECTMODE_REJECT:
                    *pCallStateCause = CEC_DISCONNECT_REJECTED;
                    break;
                case LINEDISCONNECTMODE_BUSY:
                    *pCallStateCause = CEC_DISCONNECT_BUSY;
                    break;
                case LINEDISCONNECTMODE_NOANSWER:
                    *pCallStateCause = CEC_DISCONNECT_NOANSWER;
                    break;
                case LINEDISCONNECTMODE_BLOCKED:
                    *pCallStateCause = CEC_DISCONNECT_BLOCKED;
                    break;
                case LINEDISCONNECTMODE_CONGESTION:
                case LINEDISCONNECTMODE_INCOMPATIBLE:
                case LINEDISCONNECTMODE_NODIALTONE:
                case LINEDISCONNECTMODE_UNAVAIL:
                case LINEDISCONNECTMODE_NUMBERCHANGED:
                case LINEDISCONNECTMODE_OUTOFORDER:
                case LINEDISCONNECTMODE_TEMPFAILURE:
                case LINEDISCONNECTMODE_QOSUNAVAIL:                
                case LINEDISCONNECTMODE_DONOTDISTURB:
                case LINEDISCONNECTMODE_CANCELLED:
                    *pCallStateCause = CEC_DISCONNECT_FAILED;
                    break;
                case LINEDISCONNECTMODE_UNREACHABLE:
                case LINEDISCONNECTMODE_BADADDRESS:
                    *pCallStateCause = CEC_DISCONNECT_BADADDRESS;
                    break;
                case LINEDISCONNECTMODE_PICKUP:
                case LINEDISCONNECTMODE_FORWARDED:
                case LINEDISCONNECTMODE_NORMAL:
                case LINEDISCONNECTMODE_UNKNOWN:
                default:
                    *pCallStateCause = CEC_DISCONNECT_NORMAL;
                    break;
            }

            break;

        }

        case LINECALLSTATE_OFFERING:
        {    
			switch (CurrentCallState)
			{
			case CS_IDLE:

				if ( ! ( CALLFLAG_ACCEPTTOALERT & m_dwCallFlags ) )
				{
					NewCallState = CS_OFFERING;
				}
				else
				{
					LOG((TL_INFO, "ProcessNewCallState - ignoring LINECALLSTATE_OFFERING message as this is ISDN & needs a lineAccept"));
					hr = S_FALSE;
				}
	            break;
			default:
                LOG((TL_ERROR, "ProcessNewCallState - trying to go to OFFERING from bad state"));
                hr = S_FALSE;
                break;
			}
			break;

        }

        case LINECALLSTATE_ACCEPTED:
        {    
			switch (CurrentCallState)
			{
			case CS_IDLE:

				if ( CALLFLAG_ACCEPTTOALERT & m_dwCallFlags )
				{
					NewCallState = CS_OFFERING;
				}
				else
				{
	                LOG((TL_INFO, "ProcessNewCallState - ignoring LINECALLSTATE_ACCEPTED message "));
					hr = S_FALSE;
				}
	            break;
			default:
                LOG((TL_ERROR, "ProcessNewCallState - trying to go to OFFERING from bad state"));
                hr = S_FALSE;
                break;
			}
			break;
        }

        case LINECALLSTATE_PROCEEDING:
        case LINECALLSTATE_RINGBACK:
        case LINECALLSTATE_DIALING:
        case LINECALLSTATE_DIALTONE:
        {
            switch(CurrentCallState)
            {
                case CS_IDLE:
                    NewCallState = CS_INPROGRESS;
                    break;
                case CS_INPROGRESS:
                    break;
                default:
                    LOG((TL_ERROR, "ProcessNewCallState - trying to go to INPROGRESS from bad state"));
                    hr = S_FALSE;
                    break;
            }
            break;
        }

        case LINECALLSTATE_CONFERENCED:
        case LINECALLSTATE_CONNECTED:
        {
            if ( CurrentCallState == CS_DISCONNECTED )
            {
                LOG((TL_ERROR, "ProcessNewCallState - invalid state going to CONNECTED"));
                hr = S_FALSE;
            }
            else
            {
                NewCallState = CS_CONNECTED;
            }
            break;
        }

        case LINECALLSTATE_ONHOLDPENDCONF:
        case LINECALLSTATE_ONHOLD:
        case LINECALLSTATE_ONHOLDPENDTRANSFER:
        {
            switch(CurrentCallState)
            {
                case CS_HOLD:
                    break;
                default:
                    NewCallState = CS_HOLD;
                    break;
            }
            break;
        }
        
        case LINECALLSTATE_SPECIALINFO:
        {
            LOG((TL_INFO, "ProcessNewCallState - ignoring message"));
            hr = S_FALSE;
            break;
        }

        case LINECALLSTATE_UNKNOWN:
        {
            LOG((TL_INFO, "ProcessNewCallState - LINECALLSTATE_UNKNOWN, so ignoring message"));
            //return a failure as we don't want to processs this further
            hr = E_FAIL;
            break;
        }


        default:
            break;
    
    } // End switch(dwCallState)



    if (NewCallState == CurrentCallState)
    {
#if DBG
        LOG((TL_INFO, "ProcessNewCallState - No State Change - still in %s", 
            callStateName(NewCallState) ));
#endif
        hr = S_FALSE;
    }
    else // Valid change so update & return S_OK
    {
#if DBG
        LOG((TL_INFO, "ProcessNewCallState - State Transition %s -> %s", 
            callStateName(CurrentCallState), 
            callStateName(NewCallState) ));
#endif
        *pCallState = NewCallState; 
        hr = S_OK;
    }


    LOG((TL_TRACE, "ProcessNewCallState - exit"));
    LOG((TL_INFO, "       *pCallState------->%lx", *pCallState));
    LOG((TL_INFO, "       *pCallStateCause-->%lx", *pCallStateCause));

    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetOtherParty()
//
// Used to find the other party in a call ie,
//                         ___
//                        /   \      
// [A1]--hCall1--(this)--| CH1 |--(OtherCall)--hCall3--[A2]
//                        \___/ 
//
//  AddRefs returned call
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CCall* CCall::GetOtherParty()
{
    LINECALLLIST  * pCallHubList = NULL;
    HCALL         * phCalls;
    HRESULT         hr;
    CCall         * pCall = NULL; 
    
    //
    // get the list of hcalls
    // related to this call
    //
    hr = LineGetHubRelatedCalls(
                                0,
                                m_t3Call.hCall,
                                &pCallHubList
                               );

    if ( SUCCEEDED(hr) )
    {
        if (pCallHubList->dwCallsNumEntries >= 3)
        {
            //
            // get to the list of calls
            //
            phCalls = (HCALL *)(((LPBYTE)pCallHubList) + pCallHubList->dwCallsOffset);

            //
            // the first call is the callhub, we want the third
            //
            FindCallObject(phCalls[2], &pCall);
        }
    }


        
    if (pCallHubList)
    {
        ClientFree( pCallHubList );
    }

    return pCall;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// FindConferenceControllerCall()
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CCall * CCall::FindConferenceControllerCall()
{
    LINECALLLIST  * pCallList;
    HCALL         * phCalls;
    CCall         * pCall = NULL;
    HRESULT         hr;


    hr = LineGetConfRelatedCalls(
                                m_t3Call.hCall,
                                &pCallList
                               );

    if ( SUCCEEDED(hr) )
    {
        //
        // get to the list of calls
        //
        phCalls = (HCALL *)(((LPBYTE)pCallList) + pCallList->dwCallsOffset);

        //
        // The first call is the conf controller
        // get its tapi3 call object
        //
        if (FindCallObject(phCalls[0], &pCall))
        {
            LOG((TL_INFO, "FindConferenceControllerCall - controller is %p "
                     ,pCall));
        }
        else
        {
            pCall = NULL;
            LOG((TL_INFO, "FindConferenceControllerCall - call handle %lx "
                     "does not currently exist", phCalls[0]));
        }

        if(pCallList)
        {
            ClientFree( pCallList );
        }
    }
    else
    {
        LOG((TL_ERROR, "FindExistingCalls - LineGetConfRelatedCalls failed "));
    }

    return pCall;
    
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// AddCallToHashTable()
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CCall::AddCallToHashTable()
{
    //
    // put in global hash table
    //
    CTAPI *pTapi = m_pAddress->GetTapi();

    if ( NULL != m_t3Call.hCall )
    {
        gpCallHashTable->Lock();
        
        gpCallHashTable->Insert( (ULONG_PTR)(m_t3Call.hCall), (ULONG_PTR)this, pTapi );

        gpCallHashTable->Unlock();
    }

    //
    // Signal the asyncEventThread to wake up & process the retry queue
    // since events may have come in for this call before it
    // was in the hash table
    //
    SetEvent(ghAsyncRetryQueueEvent);

}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// OnConference()
//
// called in lock()
//
// called when call goes into conferenced state.
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CCall::OnConference()
{
    HRESULT         hr = S_FALSE;
    CCall         * pCall = NULL;
    CCall         * pConfControllerCall = NULL;
    CCall         * pCallOtherParty = NULL;
    CCallHub      * pConferenceCallHub = NULL;  

    pConfControllerCall = FindConferenceControllerCall();
    
    if (pConfControllerCall != NULL)
    {    
        pConferenceCallHub = pConfControllerCall->GetCallHub();

        //
        // try & find this call in the callhub
        //
        if (pConferenceCallHub != NULL)
        {
            pCall = pConferenceCallHub->FindCallByHandle(m_t3Call.hCall);
            
            if (pCall == NULL)
            {
                // Not in the same hub so this is the consultation call being added in
                // see if there's a call object for the other party
                //
                //        (ConfControllerCall)___
                //                               \_________________
                //                               /                 \      
                // [A1]--hCall1--(RelatedCall)--| ConferenceCallHub |--
                //   |                           \_________________/ 
                //   |
                //   |                    ___
                //   |                   /   \      
                //    --hCall2--(this)--| CH1 |--(CallOtherParty)--hCall3--[A3]
                //                       \___/ 
                //

                LOG((TL_INFO, "OnConference - This is the consult call being conferenced " ));
/*                
                if ( NULL != (pCallOtherParty = GetOtherParty()) )
                {
                    //
                    // Yes there is, so we're going to take this call out of the hash table
                    // & give the other call our hCall Handle;
                    //
                    LOG((TL_INFO, "OnConference - We have the other party , so give him our hCall %x", m_t3Call.hCall));

                    RemoveCallFromHashTable();

                    // release the callhub
                    //
                    if (NULL != m_pCallHub)
                    {
                        m_pCallHub->RemoveCall( this );
                
                    //    m_pCallHub->Release();
                    }

                    pCallOtherParty->Lock();
                    
                    pCallOtherParty->m_hAdditionalCall = m_t3Call.hCall;

                    pCallOtherParty->Unlock();
                    
                    m_t3Call.hCall =  NULL;

                    hr = S_OK;
                }
*/
                
            }
            else
            {
                LOG((TL_INFO, "OnConference - This is the initial call being conferenced " ));
                pCall->Release();  // FindCallByHandle addRefs
            }

            
        }
        else
        {
            LOG((TL_INFO, "OnConference -  Couldn't find conference CallHub " ));
        }

        pConfControllerCall->Release(); // FindConferenceControllerCall addrefs
    }
    else
    {
        LOG((TL_ERROR, "OnConference - Couldn't find conference controller " ));
    }

    return hr;

}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// ProcessNewCallPrivilege
//
// converts a tapi2 callpriv to a tapi3 call priv.
//
// returns S_OK if there was a priv
// returns S_FALSE if priv was 0 (indicating there was no change)
// returns E_UNEXPECTED if the priv wasn't recognized
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
ProcessNewCallPrivilege(
                        DWORD dwPrivilege,
                        CALL_PRIVILEGE * pCP
                       )
{
    if ( 0 == dwPrivilege )
    {
        return S_FALSE;
    }

    if ( LINECALLPRIVILEGE_OWNER == dwPrivilege )
    {
        *pCP = CP_OWNER;
        return S_OK;
    }
    
    if ( LINECALLPRIVILEGE_MONITOR == dwPrivilege )
    {
        *pCP = CP_MONITOR;
        S_OK;
    }

    return E_UNEXPECTED;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CallStateEvent
//      process call state events, and queue an event to the app
//      if necessary
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CCall::CallStateEvent(
                      PASYNCEVENTMSG pParams
                     )
{
    HRESULT                         hr = S_OK;
    HRESULT                         hrCallStateEvent;
    HRESULT                         hrCallPrivilege;
    BOOL                            bNeedToNotify;
    CONNECTDATA                     cd;
    AddressLineStruct             * pLine;
    

    CALL_STATE                      CallState;
    CALL_STATE_EVENT_CAUSE          CallStateCause;
    CALL_PRIVILEGE                  newCP;


    LOG((TL_INFO, "CallStateEvent - enter hCall %lx", m_t3Call.hCall));

    //
    // pParams->OpenContext is the 32-bit handle for AddressLineStruct
    //

    LOG((TL_INFO, "CallStateEvent: pParams->OpenContext %p", pParams->OpenContext ));
    

    //
    // recover the ptr value of AddressLineStruct from the 32-bit handle
    //

    pLine = GetAddRefAddressLine(pParams->OpenContext);

    if ( NULL == pLine )
    {
        //
        // pLine is NULL, the line must have already been closed before we got this event.
        //

        LOG((TL_WARN, "CallStateEvent - pLine is NULL"));

        return S_OK;
    }

    LOG((TL_INFO, "CallStateEvent: pLine %p", pLine));

    Lock();

    if ( NULL == m_pAddressLine )
    {
        m_pAddressLine = pLine;
        m_dwCallFlags |= CALLFLAG_NOTMYLINE;
    }


    //
    // keep callback instance for this line
    //

    long lCallbackInstance = pLine->lCallbackInstance;



    //
    // no longer need address line itself
    //


    // (this needs to be done outside call lock)

    Unlock();



    ReleaseAddressLine(pLine);
    pLine = NULL;



    Lock();


    
    if (pParams->Param1 == LINECALLSTATE_OFFERING)
    {
        OnOffering();
    }
    else if (pParams->Param1 == LINECALLSTATE_CONFERENCED)
    {
        if( OnConference() == S_OK)
        {
            pParams->Param1 = LINECALLSTATE_IDLE;
            pParams->Param2 = LINEDISCONNECTMODE_UNKNOWN;
        }

    }
    else if (pParams->Param1 == LINECALLSTATE_ONHOLDPENDCONF)
    {
        //
        // This is a cnf controller call  so hide it
        //
        LOG((TL_INFO, "CallStateEvent  - This is a conference controller call, so hide it"));
        
        m_dwCallFlags |= CALLFLAG_DONTEXPOSE;
        m_dwCallFlags &= ~CALLFLAG_NEEDTONOTIFY;
    }

    bNeedToNotify = m_dwCallFlags & CALLFLAG_NEEDTONOTIFY;



    //
    // verify and get the new state
    //
    hrCallStateEvent = ProcessNewCallState(
                                           pParams->Param1,
                                           pParams->Param2,
                                           m_CallState,
                                           &CallState,
                                           &CallStateCause
                                          );


    hrCallPrivilege = ProcessNewCallPrivilege(
                                              pParams->Param3,
                                              &newCP
                                             );

    if ( S_OK == hrCallPrivilege )
    {
        if ( m_CallPrivilege != newCP )
        {
            if ( !bNeedToNotify )
            {
                //
                // callpriv changed.  send a new call notification event
                //

                m_CallPrivilege = newCP;

                CAddress *pAddress = m_pAddress;
                pAddress->AddRef();

                Unlock();
                

                
                CCallInfoChangeEvent::FireEvent(
                                                this,
                                                CIC_PRIVILEGE,
                                                pAddress->GetTapi(),
                                                lCallbackInstance
                                                );

                Lock();

                pAddress->Release();
                pAddress = NULL;

            }
        }
    }
    
    if ( FAILED(hrCallStateEvent) ||
         FAILED(hrCallPrivilege) )
    {
        //
        // bad failure
        // We get here if we had LINECALLSTATE_UNKNOWN
        //
        Unlock();
        
        return S_OK;

    }

    //
    // if it's s_ok, then the callstate
    // changed, so do relevant stuff
    //
    else if (S_OK == hrCallStateEvent)
    {
        LOG((TL_ERROR, "CCall::Changing call state :%p", this ));

        //
        // save the callstate
        //
        SetCallState( CallState );

        //
        // do relevant processing on call
        //
        if (CS_CONNECTED == m_CallState)
        {
            OnConnect();
        }
        else if (CS_DISCONNECTED == m_CallState)
        {
            LOG((TL_ERROR, "CCall::Changing call state to disconnect:%p", this ));


            Unlock();


            //
            // do not hold call's lock while calling disconnect , to prevent deadlocks with callhub
            //

            OnDisconnect();

            Lock();
        }

    }
    else
    {
        //
        // if we are here, ProcessNewCallState returned
        // S_FALSE, indicating we are already in the
        // correct callstate
        // if we don't need to notify the app of the call
        // then we can return right here
        //
        if ( !bNeedToNotify )
        {
            LOG((TL_TRACE, "CallStateEvent - ProcessNewCallState returned %lx - ignoring message", hr ));
            Unlock();
            return S_OK;
        }

    }


    //
    // if this is a new call
    // find out the mediamode
    // and tell the app about the
    // new call
    //
    if ( bNeedToNotify )
    {
        LPLINECALLINFO pCallInfo = NULL;

        TryToFindACallHub();

        hr = LineGetCallInfo(
                             m_t3Call.hCall,
                             &pCallInfo
                            );

        if (S_OK != hr)
        {
            if (NULL != pCallInfo)
            {
                ClientFree( pCallInfo );
            }

            LOG((TL_ERROR, "CallStateEvent - LineGetCallInfo returned %lx", hr ));
            LOG((TL_ERROR, "CallStateEvent - can't set new mediamode"));
            //
            // since we could not get media mode, keep media mode that we 
            // received on initalization
            //            
        }
        else
        {
            SetMediaMode( pCallInfo->dwMediaMode );

            {
                // get rid of unknown bit
                SetMediaMode( m_dwMediaMode & ~LINEMEDIAMODE_UNKNOWN );

            }

            LOG((TL_INFO, "CallStateEvent - new call media modes is %lx", m_dwMediaMode ));

            ClientFree(pCallInfo);
        }

        LOG((TL_INFO, "Notifying app of call" ));

        //
        // now, create and fire the callnotification event
        //

        CAddress *pAddress = m_pAddress;
        pAddress->AddRef();

        CALL_NOTIFICATION_EVENT Priveledge = (m_CallPrivilege == CP_OWNER) ? CNE_OWNER : CNE_MONITOR;

        Unlock();

        hr = CCallNotificationEvent::FireEvent(
                                               (ITCallInfo *)this,
                                               Priveledge,
                                               pAddress->GetTapi(),
                                               lCallbackInstance
                                              );

        Lock();

        pAddress->Release();
        pAddress = NULL;


        if (!SUCCEEDED(hr))
        {
            LOG((TL_ERROR, "CallNotificationEvent failed %lx", hr));
        }

        //
        // if it was needtonotify, we had an extra ref
        // count, so get rid of it now
        //
        Release();
        
        //
        // just notify of existence once
        //
        m_dwCallFlags = m_dwCallFlags & ~CALLFLAG_NEEDTONOTIFY;
    }

    if ( S_OK == hrCallStateEvent )
    {
        //
        // create the call state event object
        //
        LOG((TL_INFO, "Firing CallStateEvent"));


        CAddress *pAddress = m_pAddress;
        pAddress->AddRef();

        Unlock();

        hr = CCallStateEvent::FireEvent(
                                        (ITCallInfo *)this,
                                        CallState,
                                        CallStateCause,
                                        pAddress->GetTapi(),
                                        lCallbackInstance
                                       );
    
        if (!SUCCEEDED(hr))
        {
            LOG((TL_ERROR, "CallStateEvent - fire event failed %lx", hr));
        }
        
        //
        // Go through the phones and call our event hooks
        //

        ITPhone               * pPhone;
        CPhone                * pCPhone;
        int                     iPhoneCount;
        PhoneArray              PhoneArray;

        //
        // Get a copy of the phone array from tapi. This copy will contain
        // references to all the phone objects.
        //

        pAddress->GetTapi()->GetPhoneArray( &PhoneArray );

        pAddress->Release();
        pAddress = NULL;


        //
        // stay unlocked while we are messing with the phone objects, otherwise
        // we risk deadlock if a phone object would try to access call methods.
        //

        for(iPhoneCount = 0; iPhoneCount < PhoneArray.GetSize(); iPhoneCount++)
        {
            pPhone = PhoneArray[iPhoneCount];

            pCPhone = dynamic_cast<CPhone *>(pPhone);

            pCPhone->Automation_CallState( (ITCallInfo *)this, CallState, CallStateCause );
        }

        //
        // Release all the phone objects.
        //

        PhoneArray.Shutdown();

        Lock();
    }

    LOG((TL_TRACE, "CallStateEvent - exit - return SUCCESS" ));

    Unlock();
    
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////

AddressLineStruct *CCall::GetAddRefMyAddressLine()
{

    LOG((TL_INFO, "GetAddRefMyAddressLine - enter."));


    Lock();


    //
    // have address line?
    //

    if ( NULL == m_pAddressLine )
    {
        LOG((TL_WARN, "GetAddRefMyAddressLine - no address line"));

        Unlock();
        
        return NULL;
    }


    //
    // get address
    //

    if (NULL == m_pAddress)
    {
        LOG((TL_ERROR, "GetAddRefMyAddressLine - no address"));

        Unlock();

        return NULL;
    }



    //
    // get the address line
    //

    AddressLineStruct *pLine = m_pAddressLine;


    //
    // keep a reference to the address for after we unlock the call
    //

    CAddress *pAddress = m_pAddress;
    pAddress->AddRef();


    //
    // unlock
    //

    Unlock();


    //
    // lock the address (so address line does not go away before we addref it)
    //

    pAddress->Lock();


    //
    // does our address manage this line? if so, get a refcount on that line.
    //

    if (!pAddress->IsValidAddressLine(pLine, TRUE))
    {
        LOG((TL_ERROR, "GetAddRefMyAddressLine - not one of the address' lines"));

        
        //
        // assume this line is plain bad. in which case there is no need to 
        // undo the addref (we cannot do it anyway, since we don't have the
        // address which the line belongs to so we cannot maybeclosealine it.)
        //


        //
        // unlock and release the address
        //

        pAddress->Unlock();
        pAddress->Release();
        
        return NULL;
    }



    //
    // unlock the address
    //

    pAddress->Unlock();


    //
    // no need to keep the reference to the address anymore
    //

    pAddress->Release();


    //
    // all done. return pLine.
    //

    LOG((TL_INFO, "GetAddRefMyAddressLine - finish. pLine = %p", pLine));

    return pLine;
}




//////////////////////////////////////////////////////////////////////////////
//
// CCall::GetAddRefAddressLine()
//
// this function returns a pointer to an addreff'ed address line on success 
// or NULL on failure
//
// this function should be called OUTSIDE call lock to prevent deadlocks
//

AddressLineStruct *CCall::GetAddRefAddressLine(DWORD dwAddressLineHandle)
{

    LOG((TL_INFO, "GetAddRefAddressLine - enter. dwAddressLineHandle[0x%lx]", 
        dwAddressLineHandle));


    Lock();


    //
    // get address
    //

    if (NULL == m_pAddress)
    {
        LOG((TL_ERROR, "GetAddRefAddressLine - no address"));

        Unlock();

        return NULL;
    }


    //
    // keep a reference to the address for after we unlock the call
    //

    CAddress *pAddress = m_pAddress;
    pAddress->AddRef();


    //
    // unlock
    //

    Unlock();


    //
    // lock the address (so address line does not go away before we addref it)
    //

    pAddress->Lock();


    //
    // get address line
    //

    AddressLineStruct *pLine = 
        (AddressLineStruct *)GetHandleTableEntry(dwAddressLineHandle);


    //
    // handle table entry exists?
    //

    if (NULL == pLine)
    {
        LOG((TL_ERROR, "GetAddRefAddressLine - no address line"));


        //
        // unlock and release the address
        //

        pAddress->Unlock();
        pAddress->Release();
        
        return NULL;
    }


    //
    // does our address manage this line?
    //

    if (!pAddress->IsValidAddressLine(pLine, TRUE))
    {
        LOG((TL_ERROR, "GetAddRefAddressLine - not one of the address' lines"));


        //
        // so there is no confusion in the future, remove this so-called "line"
        // from handle table
        //

        DeleteHandleTableEntry(dwAddressLineHandle);


        //
        // unlock and release the address
        //

        pAddress->Unlock();
        pAddress->Release();
        
        return NULL;
    }


    //
    // unlock the address
    //

    pAddress->Unlock();


    //
    // no need to keep the reference to the address anymore
    //

    pAddress->Release();


    //
    // all done. return pLine.
    //

    LOG((TL_INFO, "GetAddRefAddressLine - finish. pLine = %p", pLine));

    return pLine;
}


//////////////////////////////////////////////////////////////////////////////
//
// CCall::ReleaseAddressLine()
//
// this function takes a pointer to an line and attempts to free it if needed
//
// this function should be called OUTSIDE call lock to prevent deadlocks
//

HRESULT CCall::ReleaseAddressLine(AddressLineStruct *pLine)
{

    LOG((TL_INFO, "ReleaseAddressLine - enter. pLine[%p]", pLine));


    //
    // lock
    //

    Lock();


    //
    // get address
    //

    if (NULL == m_pAddress)
    {
        LOG((TL_ERROR, "ReleaseAddressLine - no address"));

        Unlock();

        return E_FAIL;
    }


    //
    // keep a reference to the address for after we unlock the call
    //

    CAddress *pAddress = m_pAddress;
    pAddress->AddRef();


    //
    // unlock
    //

    Unlock();


    //
    // close address line
    //

    AddressLineStruct *pAddressLine = pLine;

    HRESULT hr = pAddress->MaybeCloseALine(&pAddressLine);

    if (FAILED(hr))
    {

        LOG((TL_ERROR, "ReleaseAddressLine - MaybeCloseALine failed. hr = %lx", hr));

    }


    //
    // no need to keep the reference to the address anymore
    //

    pAddress->Release();


    //
    // all done.
    //

    LOG((TL_INFO, "ReleaseAddressLine - finish. hr = %lx", hr));

    return hr;
}



///////////////////////////////////////////////////////////////////////////////
//
// CCall::GetCallBackInstance
//
// return lCallbackInstance from the address line referred to by the handle
//

HRESULT 
CCall::GetCallBackInstance(IN DWORD dwAddressLineHandle, 
                           OUT long *plCallbackInstance)
{

    LOG((TL_INFO, "GetCallBackInstance - enter. dwAddressLineHandle = 0x%lx",
        dwAddressLineHandle));


    //
    // got a good pointer?
    //

    if (IsBadWritePtr(plCallbackInstance, sizeof(long) ) )
    {
        LOG((TL_ERROR, "GetCallBackInstance - bad pointer[%p]",
            plCallbackInstance));

        _ASSERTE(FALSE);

        return E_POINTER;
    }


    //
    // get an address line from the handle
    //

    AddressLineStruct *pLine = GetAddRefAddressLine(dwAddressLineHandle);

    if ( NULL == pLine )
    {
        //
        // pLine is NULL, the line must have already been closed before we got this event.
        //

        LOG((TL_WARN, "HandleMonitorToneMessage - pLine is NULL"));

        return E_FAIL;
    }


    LOG((TL_INFO, "HandleMonitorToneMessage: pLine %p", pLine));

    
    //
    // try to get callbackinstance from pline
    //

    long lCBInstance = 0;

    try
    {

        lCBInstance = pLine->lCallbackInstance;
    }
    catch(...)
    {

        LOG((TL_ERROR, 
            "HandleMonitorToneMessage - exception while accessing pLine[%p]",
            pLine));


        //
        // pline memory got released somehow. this should not happen so debug to see why
        //

        _ASSERTE(FALSE);
    }


    //
    // release address line
    //

    HRESULT hr = ReleaseAddressLine(pLine);

    if (FAILED(hr))
    {
        LOG((TL_ERROR, 
            "HandleMonitorToneMessage - ReleaseAddressLine failed. hr = %lx",
            hr));
    }


    *plCallbackInstance = lCBInstance;


    LOG((TL_INFO, "ReleaseAddressLine - finish. lCallbackInstance[0x%lx]", *plCallbackInstance));

    return S_OK;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// MediaModeEvent
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CCall::MediaModeEvent(
                      PASYNCEVENTMSG pParams
                     )
{
    LOG((TL_INFO, "MediaModeEvent - enter. pParams->OpenContext %lx", pParams->OpenContext ));
    

    //
    // pParams->OpenContext is the 32-bit handle for AddressLineStruct
    //


    //
    // get the callback instance thatcorresponds to this address line structure
    //

    long lCallBackInstance = 0;
    
    HRESULT hr = GetCallBackInstance(pParams->OpenContext, &lCallBackInstance);

    if ( FAILED(hr) )
    {
        //
        // failed to get callback instance
        //

        LOG((TL_WARN, "MediaModeEvent - GetCallBackInstance failed. hr = %lx", hr));

        return S_OK;
    }



    Lock(); // using m_pAddress below -- therefore need to lock?
    
    
    //
    // fire the event
    //

    CCallInfoChangeEvent::FireEvent(
                                    this,
                                    CIC_MEDIATYPE,
                                    m_pAddress->GetTapi(),
                                    lCallBackInstance
                                   );

    Unlock();

    
    LOG((TL_INFO, "MediaModeEvent - exit. hr = %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CheckAndCreateFakeCallHub
//
// we need to create a fake callhub object if the address doesn't support
// call hubs.
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CCall::CheckAndCreateFakeCallHub()
{
    Lock();
    
    if (NULL == m_pCallHub)
    {
        DWORD       dwRet;
        HRESULT     hr;
            
        //
        // if it doesn't support callhubs, then
        // create one
        //
        // if it does, then we should get notified from
        // tapisrv, and the callhub will be filled in during
        // the LINE_APPNEWCALLHUB handling
        //
        dwRet = m_pAddress->DoesThisAddressSupportCallHubs( this );

        if ( CALLHUBSUPPORT_NONE == dwRet )
        {
            hr = CCallHub::CreateFakeCallHub(
                m_pAddress->GetTapi(),
                this,
                &m_pCallHub
                );

            if (!SUCCEEDED(hr))
            {
                LOG((TL_ERROR, "CheckAndCreateFakeCallHub - "
                                   "could not creat callhub %lx", hr));

                Unlock();
                
                return hr;
            }
        }
        else
        {
            Unlock();

            return E_PENDING;
        }
        
    }

    LOG((TL_ERROR, "CCall::m_pCallHub -created:%p:%p", this, m_pCallHub ));

    Unlock();

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// SetCallHub
//
// sets the callhub member
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void
CCall::SetCallHub(
                  CCallHub * pCallHub
                 )
{
    CCallHub* temp_pCallHub;

    Lock();

    LOG((TL_ERROR, "CCall::SetCallhub:%p:%p", this, pCallHub ));

    // only process if they've changed 3/3/1999 - bug 300914
    if (pCallHub != m_pCallHub)
    {
        //NikhilB: These cahnges are to solve a hang and an AV.

        temp_pCallHub = m_pCallHub;   //store the old value
        m_pCallHub = pCallHub;        //assign the new value
        LOG((TL_ERROR, "CCall::m_pCallHub -set:%p:%p", this, m_pCallHub ));
        
        if (temp_pCallHub != NULL)    //release the old reference
        {
            LOG((TL_INFO, "SetCallHub - call %p changing hub from %p to %p"
                    , this, temp_pCallHub, pCallHub));

            //NikhilB:remove this Call from previous CallHub's m_CallArray otherwise
            //this call will be present in two call hubs.
            temp_pCallHub->RemoveCall( this );

            temp_pCallHub->Release(); // ZoltanS fix 11-12-98
        }
        
        //addref to the new reference
        if ( NULL != pCallHub )
        {
            pCallHub->AddRef();
        }
        
    }

    Unlock();

}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// LINE_CALLSTATE handler
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT HandleCallStateMessage( PASYNCEVENTMSG pParams )
{
    CCall     * pCall;
    BOOL        bSuccess;
    HRESULT     hr = E_FAIL;

    bSuccess = FindCallObject(
                              (HCALL)(pParams->hDevice),
                              &pCall
                             );

    if (bSuccess)
    {
        // fire the event
        pCall->CallStateEvent(
                              pParams
                             );

        // find call object addrefs the
        // call, so release it
        pCall->Release();
        hr = S_OK;
    }
    else
    {
        LOG((TL_INFO, "HandleCallStateMessage - failed to find Call Object %lx", pParams->hDevice));
        hr = E_FAIL;
    }

    return hr;
}

HRESULT
HandleCallIDChange(
                   PASYNCEVENTMSG pParams,
                   CCall * pCall
                  )
{
    LINECALLLIST  * pCallHubList;
    HCALL *         phCalls;
    HCALLHUB        hNewCallHub = 0;
    HCALLHUB        hCurrentCallHub = 0;
    CCallHub      * pCallHub = NULL;
    HRESULT         hr;
    
    //
    // find the current callhub handle
    //
    pCallHub = pCall->GetCallHub();

    if(pCallHub != NULL)
    {
        hCurrentCallHub = pCallHub->GetCallHub();
    }


    //
    // Now get the callhub handle from TAPI (based on hCall)
    //
    hr = LineGetHubRelatedCalls(
                                0,
                                (HCALL)(pParams->hDevice),
                                &pCallHubList
                               );
    if ( SUCCEEDED(hr) )
    {
        // get to the list of calls
        phCalls = (HCALL *)(((LPBYTE)pCallHubList) + pCallHubList->dwCallsOffset);

        // the first handle is  the callhub
        hNewCallHub = (HCALLHUB)(phCalls[0]);

        // have they changed ?
        if (hNewCallHub != hCurrentCallHub  )
        {
            //
            // Yes so we've moved hubs
            //
            LOG((TL_INFO, "HandleCallInfoMessage - LINECALLINFOSTATE_CALLID callhub change"));
            LOG((TL_INFO, "HandleCallInfoMessage - Call %p > old Hub handle:%lx > new handle:%lx",
                    pCall, hCurrentCallHub, hNewCallHub ));


            // remove call from current hub.
            if(pCallHub != NULL)
            {
                pCallHub->RemoveCall(pCall);
                pCallHub->CheckForIdle();
            }

            // Add it to new hub.
            if(FindCallHubObject(hNewCallHub, &pCallHub) )
            {
                pCallHub->AddCall(pCall); 

                // FindCallHubObject AddRefs, so release
                pCallHub->Release();
            }

        }
        else
        {
            LOG((TL_ERROR, "HandleCallInfoMessage - LINECALLINFOSTATE_CALLID callhub not changed"));
        }

        ClientFree( pCallHubList );
    }
    else
    {
        LOG((TL_ERROR, "HandleCallInfoMessage - LINECALLINFOSTATE_CALLID LineGetHubRelatedCalls "
                "failed %lx", hr));
    }

    pCall->CallInfoChangeEvent( CIC_CALLID );

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// LINE_CALLINFO handler
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT HandleCallInfoMessage( PASYNCEVENTMSG pParams )
{
    BOOL        bSuccess;
    HRESULT     hr = S_OK;
    CALLINFOCHANGE_CAUSE        cic;
    CCall *     pCall;
    DWORD       dw;
    
    bSuccess = FindCallObject(
                              (HCALL)(pParams->hDevice),
                              &pCall
                             );

    if ( !bSuccess )
    {
        LOG((TL_INFO, "HandleCallInfoMessage - failed to find Call Object %lx", pParams->hDevice));
        return E_FAIL;
    }

    pCall->SetCallInfoDirty();
    
    dw = pParams->Param1;
    
    if (dw & LINECALLINFOSTATE_MEDIAMODE)
    {
        pCall->MediaModeEvent(pParams);
    }
    
    if (dw & LINECALLINFOSTATE_CALLID)
    {
        HandleCallIDChange( pParams, pCall );
    }

    if (dw & LINECALLINFOSTATE_OTHER)
        pCall->CallInfoChangeEvent( CIC_OTHER );
    if (dw & LINECALLINFOSTATE_DEVSPECIFIC)
        pCall->CallInfoChangeEvent( CIC_DEVSPECIFIC );
    if (dw & LINECALLINFOSTATE_BEARERMODE)
        pCall->CallInfoChangeEvent( CIC_BEARERMODE );
    if (dw & LINECALLINFOSTATE_RATE)
        pCall->CallInfoChangeEvent( CIC_RATE );
    if (dw & LINECALLINFOSTATE_APPSPECIFIC)
        pCall->CallInfoChangeEvent( CIC_APPSPECIFIC );
    if (dw & LINECALLINFOSTATE_RELATEDCALLID)
        pCall->CallInfoChangeEvent( CIC_RELATEDCALLID );
    if (dw & LINECALLINFOSTATE_ORIGIN)
        pCall->CallInfoChangeEvent( CIC_ORIGIN );
    if (dw & LINECALLINFOSTATE_REASON)
        pCall->CallInfoChangeEvent( CIC_REASON );
    if (dw & LINECALLINFOSTATE_COMPLETIONID)
        pCall->CallInfoChangeEvent( CIC_COMPLETIONID );
    if (dw & LINECALLINFOSTATE_NUMOWNERINCR)
        pCall->CallInfoChangeEvent( CIC_NUMOWNERINCR );
    if (dw & LINECALLINFOSTATE_NUMOWNERDECR)
        pCall->CallInfoChangeEvent( CIC_NUMOWNERDECR );
    if (dw & LINECALLINFOSTATE_NUMMONITORS)
        pCall->CallInfoChangeEvent( CIC_NUMMONITORS );
    if (dw & LINECALLINFOSTATE_TRUNK)
        pCall->CallInfoChangeEvent( CIC_TRUNK );
    if (dw & LINECALLINFOSTATE_CALLERID)
        pCall->CallInfoChangeEvent( CIC_CALLERID );
    if (dw & LINECALLINFOSTATE_CALLEDID)
        pCall->CallInfoChangeEvent( CIC_CALLEDID );
    if (dw & LINECALLINFOSTATE_CONNECTEDID)
        pCall->CallInfoChangeEvent( CIC_CONNECTEDID );
    if (dw & LINECALLINFOSTATE_REDIRECTIONID)
        pCall->CallInfoChangeEvent( CIC_REDIRECTIONID );
    if (dw & LINECALLINFOSTATE_REDIRECTINGID)
        pCall->CallInfoChangeEvent( CIC_REDIRECTINGID );
    if (dw & LINECALLINFOSTATE_USERUSERINFO)
        pCall->CallInfoChangeEvent( CIC_USERUSERINFO );
    if (dw & LINECALLINFOSTATE_HIGHLEVELCOMP)
        pCall->CallInfoChangeEvent( CIC_HIGHLEVELCOMP );
    if (dw & LINECALLINFOSTATE_LOWLEVELCOMP)
        pCall->CallInfoChangeEvent( CIC_LOWLEVELCOMP );
    if (dw & LINECALLINFOSTATE_CHARGINGINFO)
        pCall->CallInfoChangeEvent( CIC_CHARGINGINFO );
    if (dw & LINECALLINFOSTATE_TREATMENT)
        pCall->CallInfoChangeEvent( CIC_TREATMENT );
    if (dw & LINECALLINFOSTATE_CALLDATA)
        pCall->CallInfoChangeEvent( CIC_CALLDATA );

    if (dw & LINECALLINFOSTATE_QOS)
    {
        LOG((TL_WARN, "Unhandled LINECALLINFOSTATE_QOS message"));
    }
    if (dw & LINECALLINFOSTATE_MONITORMODES)
    {
        LOG((TL_WARN, "Unhandled LINECALLINFOSTATE_MONITORMODES message"));
    }
    if (dw & LINECALLINFOSTATE_DIALPARAMS)
    {
        LOG((TL_WARN, "Unhandled LINECALLINFOSTATE_DIALPARAMS message"));
    }
    if (dw & LINECALLINFOSTATE_TERMINAL)
    {
        LOG((TL_WARN, "Unhandled LINECALLINFOSTATE_TERMINAL message"));
    }
    if (dw & LINECALLINFOSTATE_DISPLAY)
    {
        LOG((TL_WARN, "Unhandled LINECALLINFOSTATE_DISPLAY message"));
    }

    
    // find call object addrefs the call
    // so release it.
    pCall->Release();

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// LINE_MONITORDIGIT handler
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT HandleMonitorDigitsMessage( PASYNCEVENTMSG pParams )
{
    
    LOG((TL_INFO, "HandleMonitorDigitsMessage - enter"));


    BOOL            bSuccess;
    CCall         * pCall = NULL;
    HRESULT         hr = S_OK;


    //
    // get the call object
    //
    bSuccess = FindCallObject(
                              (HCALL)(pParams->hDevice),
                              &pCall
                             );

    if (bSuccess)
    {
        AddressLineStruct               * pLine;
        CAddress                        * pAddress;

        pAddress = pCall->GetCAddress();


        //
        // pParams->OpenContext is the 32-bit handle for AddressLineStruct
        //

        LOG((TL_INFO, "HandleMonitorDigitsMessage: pParams->OpenContext %lx", pParams->OpenContext ));
        

        //
        // recover the callback instance value corresponding to this AddressLineStruct
        //

        long lCallbackInstance = 0;

        hr = pCall->GetCallBackInstance(pParams->OpenContext, &lCallbackInstance);

        if ( FAILED(hr) )
        {
            //
            // failed to get callback instance 
            //

            LOG((TL_WARN, "HandleMonitorDigitsMessage - GetCallBackInstance failed. hr = %lx", hr));

            pCall->Release();

            return S_OK;
        }

        
        LOG((TL_INFO, "HandleMonitorDigitsMessage - callbackinstance[%lx]", lCallbackInstance));

        
        //
        // fire the event
        //

        CDigitDetectionEvent::FireEvent(
                                        pCall,
                                        (long)(pParams->Param1),
                                        (TAPI_DIGITMODE)(pParams->Param2),
                                        (long)(pParams->Param3),
                                        pAddress->GetTapi(),
                                        lCallbackInstance
                                       );
        //
        // release the call
        //
        pCall->Release();
        
        hr = S_OK;
    }
    else
    {
        LOG((TL_INFO, "HandleMonitorDigitsMessage - failed to find Call Object %lx", pParams->hDevice));
        hr = E_FAIL;
    }

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// LINE_MONITORTONE handler
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT HandleMonitorToneMessage( PASYNCEVENTMSG pParams )
{
    BOOL            bSuccess;
    CCall         * pCall;
    HRESULT         hr = S_OK;

    //
    // get the call object
    //
    bSuccess = FindCallObject(
                              (HCALL)(pParams->hDevice),
                              &pCall
                             );

    if (bSuccess)
    {
        AddressLineStruct               * pLine;
        CAddress                        * pAddress;

        pAddress = pCall->GetCAddress();


        //
        // pParams->OpenContext is the 32-bit handle for AddressLineStruct
        //

        LOG((TL_INFO, "HandleMonitorToneMessage: pParams->OpenContext %lx", pParams->OpenContext ));
        

        //
        // recover the callback instance corresponding to this AddressLineStruct
        //

        long lCallbackInstance = 0;

        hr = pCall->GetCallBackInstance(pParams->OpenContext, &lCallbackInstance);

        if ( FAILED(hr) )
        {

            LOG((TL_WARN, "HandleMonitorToneMessage - GetCallBackInstance failed. hr = %lx", hr));

            pCall->Release();

            return S_OK;
        }
   

        LOG((TL_INFO, "HandleMonitorToneMessage -  lCallbackInstance 0x%lx", lCallbackInstance));

        
        //
        // fire the event
        //

        CToneDetectionEvent::FireEvent(
                                        pCall,
                                        (long)(pParams->Param1),
                                        (long)(pParams->Param3),                                      
                                        lCallbackInstance,
                                        pAddress->GetTapi()
                                       );


        //
        // release the call
        //
        pCall->Release();
        
        hr = S_OK;
    }
    else
    {
        LOG((TL_INFO, "HandleMonitorDigitsMessage - failed to find Call Object %lx", pParams->hDevice));
        hr = E_FAIL;
    }

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// LINE_MONITORMEDIA handler
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void HandleMonitorMediaMessage( PASYNCEVENTMSG pParams )
{
    BOOL            bSuccess;
    CCall         * pCall;

    //
    // get the call object
    //

    bSuccess = FindCallObject(
                              (HCALL)(pParams->hDevice),
                              &pCall
                             );

    if (bSuccess)
    {
        //
        // Retrieve relevant info about the event:
        //
        // (long) (pParams->Param1) is the media type
        // (DWORD?) (pParams->Param3) is the tick count (which we ignore)
        //
        
        long lMediaType = (long) (pParams->Param1);
        
        HRESULT hr;

        //
        // This event means the TSP signaled a new media type that it
        // detected. Try to set this on the call. The setting will
        // trigger another event (LINE_CALLINFO) to inform the app
        // that the media type actually changed, and that we will
        // propagate to the app.
        //

        hr = pCall->SetMediaType( lMediaType );

        if ( FAILED(hr) )
        {
            LOG((TL_INFO, "HandleMonitorMediaMessage - "
                "failed SetMediaType 0x%08x", hr));
        }
        
        //
        // release the call because FindCallObject AddRefed it
        //

        pCall->Release();

    }
    else
    {
        LOG((TL_INFO, "HandleMonitorMediaMessage - "
            "failed to find Call Object %lx", pParams->hDevice));
    }

    return;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// HandleLineGenerateMessage
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT HandleLineGenerateMessage( PASYNCEVENTMSG pParams )
{
    BOOL            bSuccess;
    CCall         * pCall;
    HRESULT         hr = S_OK;

    //
    // get the call object
    //
    bSuccess = FindCallObject(
                              (HCALL)(pParams->hDevice),
                              &pCall
                             );

    if (bSuccess)
    {
        
        //
        // get call's address
        //

        CAddress *pAddress = pCall->GetCAddress();


        //
        // pParams->OpenContext is the 32-bit handle for AddressLineStruct
        //

        LOG((TL_INFO, "HandleLineGenerateMessage: pParams->OpenContext %lx", pParams->OpenContext ));
        

        //
        // get the callback instance corresponding to this AddressLineStruct handle
        //

        long lCallbackInstance = 0;

        hr = pCall->GetCallBackInstance(pParams->OpenContext, &lCallbackInstance);

        if ( FAILED(hr) )
        {
            //
            // it is possible the line had been closed before we got this event.
            //

            LOG((TL_WARN, "HandleLineGenerateMessage - GetCallBackInstance failed. hr = %lx", hr));

            pCall->Release();

            return S_OK;
        }
    
        LOG((TL_INFO, "HandleLineGenerateMessage - lCallbackInstance %lx", lCallbackInstance ));

        //
        // fire the event
        //
        CDigitGenerationEvent::FireEvent(
                                        pCall,
                                        (long)(pParams->Param1),
                                        (long)(pParams->Param3),
                                        lCallbackInstance,
                                        pAddress->GetTapi()
                                       );



        //
        // special case for wavemsp
        // LineGenerateDigits or LineGenerateTones has completed, so we are
        // now ready to resume...
        // resume the stream so the wave devices are reopened after the
        // tapi function has completed
        //
        // param1 is LINEGENERATETERM_DONE or LINEGENERATETERM_CANCEL
        //           (either way we need to resume the stream)
        //

        if ( pCall->OnWaveMSPCall() )
        {
            pCall->ResumeWaveMSPStream();
        }



        //
        // release the call
        //
        pCall->Release();
        
        hr = S_OK;
    }
    else
    {
        LOG((TL_INFO, "HandleLineGenerateMessage - failed to find Call Object %lx", pParams->hDevice));
        hr = E_FAIL;
    }

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// LINE_GATHERDIGIT handler
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT HandleGatherDigitsMessage( PASYNCEVENTMSG pParams )
{
    BOOL            bSuccess;
    CCall         * pCall;
    HRESULT         hr = S_OK;

    //
    // get the call object
    //
    bSuccess = FindCallObject(
                              (HCALL)(pParams->hDevice),
                              &pCall
                             );

    if (bSuccess)
    {
        pCall->GatherDigitsEvent( pParams );

        //
        // release the call
        //
        pCall->Release();
        
        hr = S_OK;
    }
    else
    {
        LOG((TL_INFO, "HandleGatherDigitsMessage - failed to find Call Object %lx", pParams->hDevice));
        hr = E_FAIL;
    }

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GatherDigitsEvent
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT CCall::GatherDigitsEvent( PASYNCEVENTMSG pParams )
{

    LOG((TL_INFO, "GatherDigitsEvent - enter. pParams->OpenContext[%lx]", 
        pParams->OpenContext ));


    //
    // pParams->OpenContext is the 32-bit handle for AddressLineStruct
    //


    //
    // recover the callback instance associated with thisAddressLineStruct
    //

    long lCallbackInstance = 0;
        
    HRESULT hr = GetCallBackInstance(pParams->OpenContext, &lCallbackInstance);

    if ( FAILED(hr) )
    {

        LOG((TL_WARN, "GatherDigitsEvent - failed to get callback instance"));

        return S_OK;
    }

    LOG((TL_INFO, "GatherDigitsEvent - lCallbackInstance %lx", lCallbackInstance));

    Lock();

    //
    // Check to make sure the queue isn't empty
    //

    if ( m_GatherDigitsQueue.GetSize() == 0 )
    {
        LOG((TL_ERROR, "GatherDigitsEvent - GatherDigitsQueue is empty"));

        Unlock();

        return E_FAIL;
    }

    LPWSTR pDigits;
    BSTR bstrDigits;
    
    //
    // Get the digit string from the queue
    //

    pDigits = m_GatherDigitsQueue[0];
    m_GatherDigitsQueue.RemoveAt(0);

    if ( IsBadStringPtrW(pDigits, -1) )
    { 
        LOG((TL_ERROR, "GatherDigitsEvent - bad digits string"));
        
        Unlock();

        return S_OK;
    }
                  
    bstrDigits = SysAllocString(pDigits);

    ClientFree(pDigits);
    pDigits = NULL;
    
    //
    // fire the event
    //

    CDigitsGatheredEvent::FireEvent(
                                    this,
                                    bstrDigits,
                                    (TAPI_GATHERTERM)(pParams->Param1),
                                    (long)(pParams->Param3),                                        
                                    lCallbackInstance,
                                    m_pAddress->GetTapi()
                                   );

    Unlock();

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// RefreshCallInfo
//
// Assume called in lock
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CCall::RefreshCallInfo()
{
    LINECALLINFO            * pCallInfo;
    HRESULT                   hr = S_OK;


    //
    // do we need to update?
    //
    if ( CS_IDLE == m_CallState )
    {
        LOG((TL_ERROR, "Can't get callinfo while in idle state"));
        
        return TAPI_E_INVALCALLSTATE;
    }
    
    if ( CALLFLAG_CALLINFODIRTY & m_dwCallFlags )
    {
        hr = LineGetCallInfo(
                             m_t3Call.hCall,
                             &pCallInfo
                            );

        if ( !SUCCEEDED(hr) )
        {
            LOG((TL_ERROR, "RefreshCallInfo - linegetcallinfo failed - %lx", hr));

            if ( NULL != m_pCallInfo )
            {
                //
                // use cached struct
                //
                // don't clear bit
                //
                return S_FALSE;
            }
            else
            {
                return hr;
            }
        }

        //
        // clear bit
        //
        m_dwCallFlags &= ~CALLFLAG_CALLINFODIRTY;

        //
        // free
        //
        if ( NULL != m_pCallInfo )
        {
            ClientFree( m_pCallInfo );
        }

        //
        // save
        //
        m_pCallInfo = pCallInfo;
    }

    if( NULL == m_pCallInfo )
    {
        return E_POINTER;
    }

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CCall::FinishCallParams()
//
// called in lock
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void
CCall::FinishCallParams()
{
    if(m_pCallParams != NULL)
    {
        
        Lock();
    
        m_pCallParams->dwAddressMode = LINEADDRESSMODE_ADDRESSID;
        m_pCallParams->dwAddressID = m_pAddress->GetAddressID();
    
        if (m_dwMediaMode & AUDIOMEDIAMODES)
        {
            m_dwMediaMode &= ~AUDIOMEDIAMODES;

            m_dwMediaMode |= (AUDIOMEDIAMODES & m_pAddress->GetMediaModes());
        }

        
        //
        // if we're < tapi3, multiple media modes can't be handled
        //
        if ( m_pAddress->GetAPIVersion() < TAPI_VERSION3_0 )
        {
            if ( (m_dwMediaMode & AUDIOMEDIAMODES) == AUDIOMEDIAMODES )
            {
                m_dwMediaMode &= ~LINEMEDIAMODE_INTERACTIVEVOICE;
            }
        }

        m_pCallParams->dwMediaMode = m_dwMediaMode;
    
        Unlock();
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// ResizeCallParams
//
// assumed called in lock
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CCall::ResizeCallParams( DWORD dwSize )
{
    LOG((TL_TRACE, "ResizeCallParams - enter"));

    DWORD                   dwNewSize;
    LINECALLPARAMS        * pCallParams;


    if ( NULL == m_pCallParams )
    {
        LOG((TL_WARN, 
            "ResizeCallParams - finish. no call params. invalid state for this function call"));

        return TAPI_E_INVALCALLSTATE;
    }


    dwSize += m_dwCallParamsUsedSize;

    if ( dwSize <= m_pCallParams->dwTotalSize )
    {
        LOG((TL_TRACE, "ResizeCallParams - finish. sufficient size"));

        return S_OK;
    }
    
    dwNewSize = m_pCallParams->dwTotalSize;
        
    while ( dwNewSize < dwSize )
    {
        dwNewSize *= 2;
    }

    pCallParams = (LINECALLPARAMS *) ClientAlloc (dwNewSize);

    if ( NULL == pCallParams )
    {
        LOG((TL_ERROR, "ResizeCallParams - alloc failed"));
        return E_OUTOFMEMORY;
    }

    CopyMemory(
               pCallParams,
               m_pCallParams,
               m_dwCallParamsUsedSize
              );

    ClientFree( m_pCallParams );

    m_pCallParams = pCallParams;

    m_pCallParams->dwTotalSize = dwNewSize;

    LOG((TL_TRACE, "ResizeCallParams - finish."));

    return S_OK;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// SendUserUserInfo
//
// Not called in lock
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCall::SendUserUserInfo(
                        HCALL hCall,
                        long lSize,
                        BYTE * pBuffer
                       )
{
    HRESULT         hr = S_OK;

    if ( IsBadReadPtr( pBuffer, lSize ) )
    {
        LOG((TL_ERROR, "SendUserUserInfo - invalid buffer"));
        hr = E_POINTER;
    }
    else
    {
        hr = LineSendUserUserInfo(
                                  hCall,
                                  (LPCSTR)pBuffer,
                                  lSize
                                 );

        if (((LONG)hr) < 0)
        {
            LOG((TL_ERROR, "LineSendUserUserInfo failed - %lx", hr));
            return hr;
        }

        hr = WaitForReply( hr );
    }
    
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// SaveUserUserInfo
//
// called in Lock()
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCall::SaveUserUserInfo(
                        long lSize,
                        BYTE * pBuffer
                       )
{
    HRESULT         hr;

    
    if ( IsBadReadPtr( pBuffer, lSize ) )
    {
        LOG((TL_ERROR, "SaveUserUserInfo - invalid buffer"));
        return E_POINTER;
    }

    hr = ResizeCallParams( lSize );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "SaveUserUserInfo - can't resize call params - %lx", hr));

        return hr;
    }

    CopyMemory(
               ((PBYTE)m_pCallParams) + m_dwCallParamsUsedSize,
               pBuffer,
               lSize
              );

    m_pCallParams->dwUserUserInfoSize = lSize;
    m_pCallParams->dwUserUserInfoOffset = m_dwCallParamsUsedSize;
    m_dwCallParamsUsedSize += lSize;

    return S_OK;
    
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// MakeBufferFromVariant
//
// this function copies the data from a VARIANT with a safearray
// of bytes to a byte buffer.  the caller must clientfee the
// buffer allocated.
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
MakeBufferFromVariant(
                      VARIANT var,
                      DWORD * pdwSize,
                      BYTE ** ppBuffer
                     )
{
    long        lDims;
    long        lUpper;
    long        lLower;
    BYTE      * pArray;
    HRESULT     hr = S_OK;
    DWORD       dwSize;
    
    
    if ( ( ! (var.vt & VT_ARRAY) ) ||
         ( ! (var.vt & VT_UI1) ) )
    {
        LOG((TL_ERROR, "MakeBufferFromVariant - Variant not array or not byte"));
        return E_INVALIDARG;
    }

    lDims = SafeArrayGetDim( var.parray );

    if ( 1 != lDims )
    {
        LOG((TL_ERROR, "MakeBufferFromVariant - Variant dims != 1 - %d", lDims));
        return E_INVALIDARG;
    }

    if ( !(SUCCEEDED(SafeArrayGetLBound(var.parray, 1, &lLower)) ) ||
         !(SUCCEEDED(SafeArrayGetUBound(var.parray, 1, &lUpper)) ) )
    {
        LOG((TL_ERROR, "MakeBufferFromVariant - get bound failed"));
        return E_INVALIDARG;
    }

    if ( lLower >= lUpper )
    {
        LOG((TL_ERROR, "MakeBufferFromVariant - bounds invalid"));
        return E_INVALIDARG;
    }
               
    dwSize = lUpper - lLower + 1;

    *ppBuffer = (BYTE *)ClientAlloc( dwSize );

    if ( NULL == *ppBuffer )
    {
        LOG((TL_ERROR, "MakeBufferFromVariant - Alloc failed"));
        return E_OUTOFMEMORY;
    }

    SafeArrayAccessData( var.parray, (void**)&pArray );

    CopyMemory(
               *ppBuffer,
               pArray,
               dwSize
              );

    SafeArrayUnaccessData( var.parray );

    *pdwSize = dwSize;
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// FillVariantFromBuffer
//
// create a safearray of bytes, copy the buffer into the safearray,
// and save the safearray in the variant
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
FillVariantFromBuffer(
                      DWORD dw,
                      BYTE * pBuffer,
                      VARIANT * pVar
                      )
{
    SAFEARRAY         * psa;
    SAFEARRAYBOUND      sabound[1];
    BYTE              * pArray;
    
    
    sabound[0].lLbound = 0;
    sabound[0].cElements = dw;

    psa = SafeArrayCreate(VT_UI1, 1, sabound);

    if ( NULL == psa )
    {
        LOG((TL_ERROR, "FillVariantFromBuffer - failed to allocate safearray"));

        return E_OUTOFMEMORY;
    }

    if ( 0 != dw )
    {
        SafeArrayAccessData( psa, (void **) &pArray );

        CopyMemory(
                   pArray,
                   pBuffer,
                   dw
                  );

        SafeArrayUnaccessData( psa );
    }

    pVar->vt = VT_ARRAY | VT_UI1;
    pVar->parray = psa;

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// HandleLineQOSInfoMessage
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT HandleLineQOSInfoMessage(
                         PASYNCEVENTMSG pParams
                        )
{
    CCall     * pCall;
    BOOL        bSuccess;
    HRESULT     hr = S_OK;

    bSuccess = FindCallObject(
                              (HCALL)(pParams->hDevice),
                              &pCall
                             );

    if (bSuccess)
    {
        ITCallHub * pCallHub;
        CCallHub * pCCallHub;
        
        hr = pCall->get_CallHub( &pCallHub );

        if (SUCCEEDED(hr))
        {
            pCCallHub = dynamic_cast<CCallHub *>(pCallHub);

            CQOSEvent::FireEvent(
                                 pCall,
                                 (QOS_EVENT)pParams->Param1,
                                 (long)pParams->Param2,
                                 pCCallHub->GetTapi() // no addref
                                );

            hr = S_OK;
        }

        //
        // release the call
        //
        pCall->Release();
    }
    else
    {
        LOG((TL_INFO, "HandleLineQOSInfoMessage - failed to find Call Object %lx", pParams->hDevice));
        hr = E_FAIL;
    }

    return hr;
}
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
AddressLineStruct *
CCall::GetPAddressLine()
{
    AddressLineStruct * pAddressLine;

    Lock();

    pAddressLine = m_pAddressLine;

    Unlock();

    return pAddressLine;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HCALL
CCall::GetHCall()
{
    HCALL hCall;

    Lock();

    hCall = m_t3Call.hCall;

    Unlock();

    return hCall;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL
CCall::DontExpose()
{
    BOOL bReturn;

    Lock();

    bReturn = (m_dwCallFlags & CALLFLAG_DONTEXPOSE)?TRUE:FALSE;

    Unlock();

    return bReturn;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
CCallHub *
CCall::GetCallHub()
{
    CCallHub * pCallHub;

    Lock();

    pCallHub = m_pCallHub;

    Unlock();

    return pCallHub;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// called in lock
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CCall::ResetCallParams()
{
    LOG((TL_TRACE, "ResetCallParams - enter."));

    ClientFree( m_pCallParams );

    m_pCallParams = NULL;
    
    m_dwCallParamsUsedSize = 0;

    LOG((TL_TRACE, "ResetCallParams - finish."));
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// called in lock
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CCall::FinishSettingUpCall( HCALL hCall )
{
    LOG((TL_TRACE, "FinishSettingUpCall - enter"));

    if(m_t3Call.hCall != NULL)
    {
        LOG((TL_ERROR, "FinishSettingUpCall - m_t3Call.hCall != NULL"));
        #ifdef DBG
            DebugBreak();
        #endif
    }

    m_t3Call.hCall = hCall;
    
    //
    // Set filter events for this call
    //
    m_EventMasks.SetTapiSrvCallEventMask( m_t3Call.hCall );
    
    //
    // note - we can miss messages if something comes in between the time time
    // we get the reply, and the time we insert the call
    //
    AddCallToHashTable();    
    
    CheckAndCreateFakeCallHub();

    ResetCallParams();

    LOG((TL_TRACE, "FinishSettingUpCall - finish"));

}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// not called in Lock()
//
// returns S_OK if gets to connected
// S_FALSE otherwise
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCall::SyncWait( HANDLE hEvent )
{
    HRESULT             hr = S_OK;
    
    //
    // wait for connected event
    //
    extern DWORD gdwTapi3SyncWaitTimeOut;

    WaitForSingleObject(
                        hEvent,
                        gdwTapi3SyncWaitTimeOut
                       );

    Lock();

    //
    // get rid of event
    //
    ClearConnectedEvent();
    
    //
    // it it is connected
    // return S_OK
    //
    if (m_CallState == CS_CONNECTED)
    {
        LOG((TL_INFO, "Connect - reached connected state"));

        Unlock();

        LOG((TL_TRACE, "Connect - exit bSync - return SUCCESS"));
        
        hr = S_OK;
    }

    //
    // if it is disconnect or times out
    // return S_FALSE;
    //
    else
    {
        LOG((TL_ERROR, "Connect - did not reach connected state"));

        //
        // if it isn't disconnected (it timed out), make it disconnect
        //
        if (m_CallState != CS_DISCONNECTED)
        {
            if ( m_t3Call.hCall != NULL )
            {
                LONG lResult;

                lResult = LineDrop(
                           m_t3Call.hCall,
                           NULL,
                           0
                          );

                if ( lResult < 0 )
                {
                    LOG((TL_ERROR, "Connect - LineDrop failed %lx", lResult ));

                    m_CallState = CS_DISCONNECTED;
                }
            }
        }
        
        Unlock();

        LOG((TL_TRACE, "Connect - exit bSync - return S_FALSE"));
        
        hr = S_FALSE;
    }

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// this must be created inside the same
// Lock() as the call to tapisrv
// otherwise, the connected message
// may appear before the event
// exists
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HANDLE
CCall::CreateConnectedEvent()
{
    m_hConnectedEvent = CreateEvent(
                                    NULL,
                                    FALSE,
                                    FALSE,
                                    NULL
                                   );

    return m_hConnectedEvent;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ClearConnectedEvent
// called in Lock()
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CCall::ClearConnectedEvent()
{
    if ( NULL != m_hConnectedEvent )
    {
        CloseHandle( m_hConnectedEvent );

        m_hConnectedEvent = NULL;
    }
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// DialAsConsultationCall
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCall::DialAsConsultationCall(
                              CCall * pRelatedCall,
                              DWORD   dwCallFeatures,
                              BOOL    bConference,
                              BOOL    bSync
                             )
{
    //
    // do we support Linedial or makeCall for creating our consultation call ?
    //
    LONG            lCap;
    BOOL            bCap;
    DWORD           dwConsultFlags;
    HRESULT         hr = S_OK;


    m_pAddress->get_AddressCapability( AC_ADDRESSCAPFLAGS, &lCap );

    if (bConference)
    {
        bCap = lCap & LINEADDRCAPFLAGS_CONFERENCEMAKE;
        dwConsultFlags = CALLFLAG_CONFCONSULT|CALLFLAG_CONSULTCALL;
    }
    else
    {
        bCap = lCap & LINEADDRCAPFLAGS_TRANSFERMAKE;
        dwConsultFlags = CALLFLAG_TRANSFCONSULT|CALLFLAG_CONSULTCALL;
    }

    if ( !(dwCallFeatures & LINECALLFEATURE_DIAL) &&
         (bCap)  )
    {
        //
        // We need to do a makecall to create a consultation call  
        // lose the consulation call handle created by lineSetupConference
        //
        hr = Disconnect(DC_NORMAL);

        //
        // Make the new call
        //
        hr = Connect((BOOL)bSync);
        
        if(SUCCEEDED(hr) )
        {
            SetRelatedCall(
                           pRelatedCall,
                           dwConsultFlags
                          );
        }
        else
        {
            LOG((TL_INFO, "DialAsConsultationCall - Consultation makeCall failed"));
        }
    }
    else // We can linedial our consultaion call
    {
        //
        // Wait for dialtone or equivalent
        //
        hr = WaitForCallState(CS_INPROGRESS);
        
        if(SUCCEEDED(hr) )
        {
            hr = DialConsultCall(bSync);
            
            if(SUCCEEDED(hr) )
            {
                SetRelatedCall(
                               pRelatedCall,
                               dwConsultFlags
                              );
            }
            else  // LineDial failed
            {
                LOG((TL_ERROR, "DialAsConsultationCall - DialConsultCall failed" ));
            }
        }
        else
        {
            LOG((TL_ERROR, "DialAsConsultationCall - Failed to get to CS_INPROGRESS (dialtone) on consult call"));
        }

    } // Endif - Linedial or make call for consultation ?

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// SetCallInfoDirty
//
// not called in lock
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CCall::SetCallInfoDirty()
{
    Lock();

    m_dwCallFlags |= CALLFLAG_CALLINFODIRTY;

    Unlock();
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// SetMediaMode
//
// called in lock
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CCall::SetMediaMode( DWORD dwMediaMode )
{
    m_dwMediaMode = dwMediaMode;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// SetCallState
//
// called in lock
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CCall::SetCallState( CALL_STATE cs )
{
    m_CallState = cs;
    
    if ( CS_OFFERING == cs )
    {
        m_dwCallFlags |= CALLFLAG_INCOMING;
    }
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnWaveMSPCall
//
// called in lock
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL
CCall::OnWaveMSPCall()
{
    Lock();

    BOOL bWaveMSPCall = ( ( NULL != m_pMSPCall ) && m_pAddress->HasWaveDevice() );

    Unlock();

    return bWaveMSPCall;
}

#ifdef USE_PHONEMSP
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnPhoneMSPCall
//
// called in lock
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL
CCall::OnPhoneMSPCall()
{
    return ( ( NULL != m_pMSPCall ) && m_pAddress->HasPhoneDevice() );
}
#endif USE_PHONEMSP

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
CAddress *
CCall::GetCAddress()
{
    return m_pAddress;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetStreamControl
//
// called in lock
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
ITStreamControl *
CCall::GetStreamControl()
{
    HRESULT             hr;
    ITStreamControl * pStreamControl;

    // +++ FIXBUG 90668 +++
    if( NULL == m_pMSPCall )
    {
        return NULL;
    }

    hr = m_pMSPCall->QueryInterface(
                                    IID_ITStreamControl,
                                    (void**)&pStreamControl
                                   );

    if ( !SUCCEEDED(hr) )
    {
        return NULL;
    }

    return pStreamControl;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetMSPCall()
//
// not called in lock
//
//
// returns the IUnknown of the msp call (the object we are
// aggregating)
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
IUnknown *
CCall::GetMSPCall()
{
    IUnknown * pUnk;

    Lock();

    pUnk = m_pMSPCall;

    Unlock();
    
    if ( NULL != pUnk )
    {
        pUnk->AddRef();
    }

    return pUnk;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CCall::DetectDigits
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCall::DetectDigits(TAPI_DIGITMODE DigitMode)
{
    HRESULT             hr;
    HCALL               hCall;
    
    LOG((TL_TRACE, "DetectDigits - enter"));

    Lock();

    hCall = m_t3Call.hCall;

    Unlock();
    
    if ( NULL == hCall )
    {
        LOG((TL_TRACE, "DetectDigits - need a call first"));

        return TAPI_E_INVALCALLSTATE;
    }
    
    hr = LineMonitorDigits(
                           hCall,
                           DigitMode
                          );
    
    LOG((TL_TRACE, "DetectDigits - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CCall::GenerateDigits
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCall::GenerateDigits(
    BSTR pDigits,
    TAPI_DIGITMODE DigitMode
    )
{
    HRESULT             hr;

    LOG((TL_TRACE, "GenerateDigits - enter"));

    hr = GenerateDigits2(pDigits, DigitMode, 0);

    LOG((TL_TRACE, "GenerateDigits - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CCall::GenerateDigits2
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCall::GenerateDigits2(
    BSTR pDigits,
    TAPI_DIGITMODE DigitMode,
    long lDuration
    )
{
    HRESULT             hr;
    HCALL               hCall;

    LOG((TL_TRACE, "GenerateDigits2 - enter"));

    // It is alright for pDigits to be NULL
    if ( ( pDigits != NULL ) && IsBadStringPtrW( pDigits, -1 ) )
    {
        LOG((TL_TRACE, "GenerateDigits2 - bad string"));

        return E_POINTER;
    }

    Lock();

    hCall = m_t3Call.hCall;

    Unlock();

    if ( NULL == hCall )
    {
        LOG((TL_TRACE, "GenerateDigits2 - need call first"));

        return TAPI_E_INVALCALLSTATE;
    }

    //
    // special case for wavemsp
    // suspend the stream so the wave devices are closed before the
    // tapi function starts. SuspendWaveMSPStream is a synchronous
    // call.
    //
    // But if pDigits is NULL, then we do not suspend the stream, as
    // this call is only intended to cancel an already-pending
    // LineGenerateDigits. Only one event will be fired in this case,
    // and the specifics of the event will indicate whether the digit
    // generation was completed or aborted -- the LGD(NULL) itself
    // never results in a separate event being fired.
    //

    if ( OnWaveMSPCall() && ( pDigits != NULL ) )
    {
        SuspendWaveMSPStream();
    }

    hr = LineGenerateDigits(
                            hCall,
                            DigitMode,
                            pDigits,
                            lDuration
                           );

    //
    // For a wavemsp call, we will tell the wavemsp to resume the stream when
    // we receive the digit completion event from tapisrv. However, if the
    // LineGenerateDigits failed synchronously, then we will never receive
    // such an event, so we must resume the stream now.
    //
    // Also see above -- we didn't suspend the stream if the digit string
    // is NULL.
    //
    
    if ( OnWaveMSPCall() && ( pDigits != NULL ) && FAILED(hr) )
    {
        ResumeWaveMSPStream();
    }

    LOG((TL_TRACE, "GenerateDigits2 - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CCall::GatherDigits
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCall::GatherDigits(
    TAPI_DIGITMODE DigitMode,
    long lNumDigits,
    BSTR pTerminationDigits,
    long lFirstDigitTimeout,
    long lInterDigitTimeout
    )
{
    HRESULT             hr;
    HCALL               hCall;
    LPWSTR              pDigitBuffer;
    BOOL                fResult;

    LOG((TL_TRACE, "GatherDigits - enter"));

    // It is alright for pTerminationDigits to be NULL
    if ( ( pTerminationDigits != NULL ) && IsBadStringPtrW( pTerminationDigits, -1 ) )
    {
        LOG((TL_TRACE, "GatherDigits - bad string"));

        return E_POINTER;
    }    

    Lock();

    hCall = m_t3Call.hCall;

    Unlock();
    
    if ( NULL == hCall )
    {
        LOG((TL_TRACE, "GatherDigits - need a call first"));

        return TAPI_E_INVALCALLSTATE;
    }
    
    if (lNumDigits)
    {
        //
        // Allocate the digit string
        //

        pDigitBuffer = (LPWSTR)ClientAlloc( (lNumDigits + 1)*sizeof(WCHAR) );

        if (NULL == pDigitBuffer)
        {
            LOG((TL_TRACE, "GatherDigits - out of memory"));

            return E_OUTOFMEMORY;
        }

        ZeroMemory(pDigitBuffer, (lNumDigits + 1)*sizeof(WCHAR) );

        Lock();

        //
        // Add digit string to the queue
        //

        fResult = m_GatherDigitsQueue.Add(pDigitBuffer);



        if (FALSE == fResult)
        {
            LOG((TL_TRACE, "GatherDigits - unable to add to queue"));

            ClientFree( pDigitBuffer );

            return E_OUTOFMEMORY;
        }

        hr = LineGatherDigits(
                              hCall,
                              DigitMode,
                              pDigitBuffer,
                              lNumDigits,
                              pTerminationDigits,
                              lFirstDigitTimeout,
                              lInterDigitTimeout
                             );

        if ( FAILED(hr) )
        {
            fResult = m_GatherDigitsQueue.Remove(pDigitBuffer);

            if (TRUE == fResult)
            {
                ClientFree( pDigitBuffer );
            }
            else
            {
                LOG((TL_TRACE, "GatherDigits - unable to remove from queue"));

                // This shouldn't happen
                _ASSERTE(FALSE);
            }
        }

        Unlock();
    }
    else
    {
        //
        // lNumDigits == 0 means cancel the gather digits
        //

        hr = LineGatherDigits(
                              hCall,
                              DigitMode,
                              NULL,
                              0,
                              pTerminationDigits,
                              lFirstDigitTimeout,
                              lInterDigitTimeout
                             );
    }

    LOG((TL_TRACE, "GatherDigits - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CCall::DetectTones
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCall::DetectTones(
    TAPI_DETECTTONE * pToneList,
    long lNumTones
    )
{
    HRESULT             hr;
    HCALL               hCall;

    LOG((TL_TRACE, "DetectTones - enter"));

    //
    // pToneList == NULL is ok, it means cancel tone detection
    //

    if ( (pToneList != NULL) && IsBadReadPtr( pToneList, lNumTones * sizeof(TAPI_DETECTTONE) ))
    {
        LOG((TL_TRACE, "DetectTones - invalid pointer"));

        return E_POINTER;
    }

    Lock();

    hCall = m_t3Call.hCall;

    Unlock();
    
    if ( NULL == hCall )
    {
        LOG((TL_TRACE, "DetectTones - need a call first"));

        return TAPI_E_INVALCALLSTATE;
    }

    hr = LineMonitorTones(
                           hCall,
                           (LPLINEMONITORTONE)pToneList,
                           lNumTones
                          );

    LOG((TL_TRACE, "DetectTones - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CCall::DetectTonesByCollection
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCall::DetectTonesByCollection(
    ITCollection2 * pDetectToneCollection
    )
{
    HRESULT             hr;    
    TAPI_DETECTTONE   * pToneList = NULL;
    long                lNumTones = 0;
    long                lCount;

    LOG((TL_TRACE, "DetectTonesByCollection - enter"));

    //
    // pDetectToneCollection == NULL is ok, it means cancel tone detection
    //

    if ( (pDetectToneCollection != NULL) && IsBadReadPtr( pDetectToneCollection, sizeof(ITCollection2) ) )
    {
        LOG((TL_ERROR, "DetectTonesByCollection - bad pointer"));

        return E_POINTER;
    }

    if ( pDetectToneCollection != NULL )
    {
        //
        // Find out how many items are in the collection and allocate an appropriately
        // sized data structure
        //

        hr = pDetectToneCollection->get_Count(&lCount);

        if ( FAILED(hr) )
        {
            LOG((TL_ERROR, "DetectTonesByCollection - get_Count failed - return %lx", hr));

            return hr;
        }

        pToneList = (TAPI_DETECTTONE *)ClientAlloc( lCount * sizeof(TAPI_DETECTTONE) );

        if ( NULL == pToneList )
        {
            LOG((TL_ERROR, "DetectTonesByCollection - out of memory"));

            return E_OUTOFMEMORY;
        }

        //
        // Go through collection
        //

        for ( int i = 1; i <= lCount; i++ )
        {
            ITDetectTone * pDetectTone;
            IDispatch    * pDisp;
            VARIANT        var;        

            hr = pDetectToneCollection->get_Item(i, &var);

            if ( FAILED(hr) )
            {
                LOG((TL_WARN, "DetectTonesByCollection - get_Item failed - %lx", hr));

                continue;
            }

            //
            // get the IDispatch pointer out of the variant
            //

            try
            {
                if ( var.vt != VT_DISPATCH )
                {
                    LOG((TL_WARN, "DetectTonesByCollection - expected VT_DISPATCH"));

                    continue;
                }

                pDisp = V_DISPATCH(&var);
            }
            catch(...)
            {
                LOG((TL_WARN, "DetectTonesByCollection - bad variant"));

                continue;
            }

            if ( IsBadReadPtr( pDisp, sizeof(IDispatch) ) )
            {
                LOG((TL_WARN, "DetectTonesByCollection - bad pointer"));

                continue;
            }

            //
            // Query for the ITDetectTone interface
            //

            hr = pDisp->QueryInterface( IID_ITDetectTone, (void **) &pDetectTone );

            if ( FAILED(hr) )
            {
                LOG((TL_WARN, "DetectTonesByCollection - QI failed - %lx", hr));

                continue;
            }
      
            //
            // Fill in the data structure with information from ITDetectTone
            //

            pDetectTone->get_AppSpecific((long *)&pToneList[lNumTones].dwAppSpecific);
            pDetectTone->get_Duration((long *)&pToneList[lNumTones].dwDuration);
            pDetectTone->get_Frequency(1, (long *)&pToneList[lNumTones].dwFrequency1);
            pDetectTone->get_Frequency(2, (long *)&pToneList[lNumTones].dwFrequency2);
            pDetectTone->get_Frequency(3, (long *)&pToneList[lNumTones].dwFrequency3);

            LOG((TL_INFO, "DetectTonesByCollection - **** Tone %d ****", lNumTones));
            LOG((TL_INFO, "DetectTonesByCollection - AppSpecific %d", pToneList[lNumTones].dwAppSpecific));
            LOG((TL_INFO, "DetectTonesByCollection - Duration %d", pToneList[lNumTones].dwDuration));
            LOG((TL_INFO, "DetectTonesByCollection - Frequency1 %d", pToneList[lNumTones].dwFrequency1));
            LOG((TL_INFO, "DetectTonesByCollection - Frequency2 %d", pToneList[lNumTones].dwFrequency2));
            LOG((TL_INFO, "DetectTonesByCollection - Frequency3 %d", pToneList[lNumTones].dwFrequency3));

            lNumTones++;

            pDetectTone->Release();
        }
    }

    hr = DetectTones( pToneList, lNumTones );

    LOG((TL_TRACE, "DetectTonesByCollection - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CCall::GenerateTone
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCall::GenerateTone(
    TAPI_TONEMODE ToneMode,
    long lDuration
    )
{
    HRESULT             hr;
    HCALL               hCall;

    LOG((TL_TRACE, "GenerateTone - enter"));

    Lock();

    hCall = m_t3Call.hCall;

    Unlock();

    if ( NULL == hCall )
    {
        LOG((TL_TRACE, "GenerateTone - need call first"));

        return TAPI_E_INVALCALLSTATE;
    }

    if ( ToneMode == (TAPI_TONEMODE)LINETONEMODE_CUSTOM ) // no custom tones
    {
        return E_INVALIDARG;
    }

    //
    // special case for wavemsp
    // suspend the stream so the wave devices are closed before the
    // tapi function starts. SuspendWaveMSPStream is a synchronous
    // call.
    //
    // But if ToneMode is 0, then we do not suspend the stream, as
    // this call is only intended to cancel an already-pending
    // LineGenerateTone. Only one event will be fired in this case,
    // and the specifics of the event will indicate whether the tone
    // generation was completed or aborted -- the LGT(0) itself
    // never results in a separate event being fired.
    //

    if ( OnWaveMSPCall() && ( ToneMode != (TAPI_TONEMODE)0 ) )
    {
        SuspendWaveMSPStream();
    }

    hr = LineGenerateTone(
                            hCall,
                            ToneMode,
                            lDuration,
                            0,
                            NULL
                           );

    //
    // For a wavemsp call, we will tell the wavemsp to resume the stream when
    // we receive the digit completion event from tapisrv. However, if the
    // LineGenerateTone failed synchronously, then we will never receive
    // such an event, so we must resume the stream now.
    //
    // Also see above -- we didn't suspend the stream if the ToneMode
    // is 0.
    //
    
    if ( OnWaveMSPCall() && ( ToneMode != (TAPI_TONEMODE)0 ) && FAILED(hr) )
    {
        ResumeWaveMSPStream();
    }

    LOG((TL_TRACE, "GenerateTone - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CCall::GenerateCustomTones
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCall::GenerateCustomTones(
    TAPI_CUSTOMTONE * pToneList,
    long lNumTones,
    long lDuration
    )
{
    HRESULT             hr;
    HCALL               hCall;

    LOG((TL_TRACE, "GenerateCustomTones - enter"));

    if ( IsBadReadPtr( pToneList, lNumTones * sizeof(TAPI_CUSTOMTONE) ) )
    {
        LOG((TL_TRACE, "GenerateCustomTones - invalid pointer"));

        return E_POINTER;
    }

    Lock();

    hCall = m_t3Call.hCall;

    Unlock();

    if ( NULL == hCall )
    {
        LOG((TL_TRACE, "GenerateCustomTones - need call first"));

        return TAPI_E_INVALCALLSTATE;
    }

    //
    // special case for wavemsp
    // suspend the stream so the wave devices are closed before the
    // tapi function starts. SuspendWaveMSPStream is a synchronous
    // call.
    //

    if ( OnWaveMSPCall() )
    {
        SuspendWaveMSPStream();
    }

    hr = LineGenerateTone(
                            hCall,
                            LINETONEMODE_CUSTOM,
                            lDuration,
                            lNumTones,
                            (LPLINEGENERATETONE)pToneList
                           );

    //
    // For a wavemsp call, we will tell the wavemsp to resume the stream when
    // we receive the digit completion event from tapisrv. However, if the
    // LineGenerateTone failed synchronously, then we will never receive
    // such an event, so we must resume the stream now.
    //
    
    if ( OnWaveMSPCall() && FAILED(hr) )
    {
        ResumeWaveMSPStream();
    }

    LOG((TL_TRACE, "GenerateCustomTones - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CCall::GenerateCustomTonesByCollection
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCall::GenerateCustomTonesByCollection(
    ITCollection2 * pCustomToneCollection,
    long lDuration
    )
{
    HRESULT             hr;
    TAPI_CUSTOMTONE   * pToneList = NULL;
    long                lNumTones = 0;
    long                lCount;

    LOG((TL_TRACE, "GenerateCustomTonesByCollection - enter"));

    if ( IsBadReadPtr( pCustomToneCollection, sizeof(ITCollection2) ) )
    {
        LOG((TL_ERROR, "GenerateCustomTonesByCollection - bad pointer"));

        return E_POINTER;
    }

    //
    // Find out how many items are in the collection and allocate an appropriately
    // sized data structure
    //

    hr = pCustomToneCollection->get_Count(&lCount);

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "GenerateCustomTonesByCollection - get_Count failed - return %lx", hr));

        return hr;
    }

    pToneList = (TAPI_CUSTOMTONE *)ClientAlloc( lCount * sizeof(TAPI_CUSTOMTONE) );

    if ( NULL == pToneList )
    {
        LOG((TL_ERROR, "GenerateCustomTonesByCollection - out of memory"));

        return E_OUTOFMEMORY;
    }

    //
    // Go through collection
    //

    for ( int i = 1; i <= lCount; i++ )
    {
        ITCustomTone * pCustomTone;
        IDispatch    * pDisp;
        VARIANT        var;
        
        hr = pCustomToneCollection->get_Item(i, &var);

        if ( FAILED(hr) )
        {
            LOG((TL_WARN, "GenerateCustomTonesByCollection - get_Item failed - %lx", hr));

            continue;
        }

        //
        // get the IDispatch pointer out of the variant
        //

        try
        {
            if ( var.vt != VT_DISPATCH )
            {
                LOG((TL_WARN, "GenerateCustomTonesByCollection - expected VT_DISPATCH"));

                continue;
            }

            pDisp = V_DISPATCH(&var);
        }
        catch(...)
        {
            LOG((TL_WARN, "GenerateCustomTonesByCollection - bad variant"));

            continue;
        }

        if ( IsBadReadPtr( pDisp, sizeof(IDispatch) ) )
        {
            LOG((TL_WARN, "GenerateCustomTonesByCollection - bad pointer"));

            continue;
        }

        //
        // Query for the ITDetectTone interface
        //

        hr = pDisp->QueryInterface( IID_ITCustomTone, (void **) &pCustomTone );

        if ( FAILED(hr) )
        {
            LOG((TL_WARN, "GenerateCustomTonesByCollection - QI failed - %lx", hr));

            continue;
        }

        //
        // Fill in the data structure with information from ITDetectTone
        //

        pCustomTone->get_CadenceOff((long *)&pToneList[lNumTones].dwCadenceOff);
        pCustomTone->get_CadenceOn((long *)&pToneList[lNumTones].dwCadenceOn);
        pCustomTone->get_Frequency((long *)&pToneList[lNumTones].dwFrequency);
        pCustomTone->get_Volume((long *)&pToneList[lNumTones].dwVolume);

        LOG((TL_INFO, "GenerateCustomTonesByCollection - **** Tone %d ****", lNumTones));
        LOG((TL_INFO, "GenerateCustomTonesByCollection - CadenceOff %d", pToneList[lNumTones].dwCadenceOff));
        LOG((TL_INFO, "GenerateCustomTonesByCollection - CadenceOn %d", pToneList[lNumTones].dwCadenceOn));
        LOG((TL_INFO, "GenerateCustomTonesByCollection - Frequency %d", pToneList[lNumTones].dwFrequency));
        LOG((TL_INFO, "GenerateCustomTonesByCollection - Volume %d", pToneList[lNumTones].dwVolume));

        lNumTones++;

        pCustomTone->Release();
    }

    hr = GenerateCustomTones( pToneList, lNumTones, lDuration );

    LOG((TL_TRACE, "GenerateCustomTonesByCollection - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CCall::CreateDetectToneObject
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCall::CreateDetectToneObject(
                              ITDetectTone ** ppDetectTone
                             )
{
    HRESULT         hr;

    LOG((TL_TRACE, "CreateDetectToneObject enter"));

    if ( TAPIIsBadWritePtr( ppDetectTone, sizeof( ITDetectTone * ) ) )
    {
        LOG((TL_ERROR, "CreateDetectToneObject - bad pointer"));

        return E_POINTER;
    }

    // Initialize the return value in case we fail
    *ppDetectTone = NULL;

    CComObject< CDetectTone > * p;
    hr = CComObject< CDetectTone >::CreateInstance( &p );

    if ( S_OK != hr )
    {
        LOG((TL_ERROR, "CreateDetectToneObject - could not create CDetectTone" ));

        return E_OUTOFMEMORY;
    }

    // get the ITDetectTone interface
    hr = p->QueryInterface( IID_ITDetectTone, (void **) ppDetectTone );

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "CreateDetectToneObject - could not get IDispatch interface" ));
    
        delete p;
        return hr;
    }

    LOG((TL_TRACE, "CreateDetectToneObject - exit - return %lx", hr ));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CCall::CreateCustomToneObject
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCall::CreateCustomToneObject(
                              ITCustomTone ** ppCustomTone
                             )
{
    HRESULT         hr;

    LOG((TL_TRACE, "CreateCustomToneObject enter"));

    if ( TAPIIsBadWritePtr( ppCustomTone, sizeof( ITCustomTone * ) ) )
    {
        LOG((TL_ERROR, "CreateCustomToneObject - bad pointer"));

        return E_POINTER;
    }

    // Initialize the return value in case we fail
    *ppCustomTone = NULL;

    CComObject< CCustomTone > * p;
    hr = CComObject< CCustomTone >::CreateInstance( &p );

    if ( S_OK != hr )
    {
        LOG((TL_ERROR, "CreateCustomToneObject - could not create CCustomTone" ));

        return E_OUTOFMEMORY;
    }

    // get the ITCustomTone interface
    hr = p->QueryInterface( IID_ITCustomTone, (void **) ppCustomTone );

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "CreateCustomToneObject - could not get ITCustomTone interface" ));
    
        delete p;
        return hr;
    }

    LOG((TL_TRACE, "CreateCustomToneObject - exit - return %lx", hr ));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CCall::GetID
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCall::GetID(
             BSTR pDeviceClass,
             DWORD * pdwSize,
             BYTE ** ppDeviceID
            )
{
    HRESULT             hr = S_OK;
    LPVARSTRING         pVarString = NULL;
    
    LOG((TL_TRACE, "GetID - enter"));

    if ( IsBadStringPtrW( pDeviceClass, -1 ) )
    {
        LOG((TL_ERROR, "GetID - bad string"));

        return E_POINTER;
    }

    if ( TAPIIsBadWritePtr( pdwSize, sizeof(DWORD)))
    {
        LOG((TL_ERROR, "GetID - bad size"));

        return E_POINTER;
    }

    if ( TAPIIsBadWritePtr( ppDeviceID, sizeof(BYTE *) ) )
    {
        LOG((TL_ERROR, "GetID - bad pointer"));

        return E_POINTER;
    }

    if( m_t3Call.hCall == NULL )
    {
        if( m_CallState == CS_IDLE )
        {
            LOG((TL_ERROR, "GetID - idle call, invalid call state"));

            return TAPI_E_INVALCALLSTATE;
        }
        else
        {
            LOG((TL_ERROR, "GetID - weird call state!!!"));

            return E_UNEXPECTED;
        }
    }

    hr = LineGetID(
                   NULL,
                   0,
                   m_t3Call.hCall,
                   LINECALLSELECT_CALL,
                   &pVarString,
                   pDeviceClass
                  );

    if ( SUCCEEDED(hr) )
    {
        *ppDeviceID = (BYTE *)CoTaskMemAlloc( pVarString->dwUsedSize );

        if (NULL != *ppDeviceID)
        {
            CopyMemory(
                       *ppDeviceID,
                       ((LPBYTE)pVarString)+pVarString->dwStringOffset,
                       pVarString->dwStringSize
                      );

            *pdwSize = pVarString->dwStringSize;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        // Check LineGetID to see if it can succeed w/o setting pVarString
        ClientFree (pVarString);
    }
    
    LOG((TL_TRACE, "GetID - exit - return %lx", hr));
    
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CCall::GetIDAsVariant
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP CCall::GetIDAsVariant( IN BSTR bstrDeviceClass,
                                    OUT VARIANT *pVarDeviceID )
{
    LOG((TL_TRACE, "GetIDAsVariant - enter"));


    //
    // did we get a good string?
    //

    if ( IsBadStringPtrW( bstrDeviceClass, -1 ) )
    {
        LOG((TL_ERROR, "GetIDAsVariant - bad string"));

        return E_POINTER;
    }


    //
    // did we get a good variant?
    //

    if ( IsBadWritePtr( pVarDeviceID, sizeof(VARIANT) ) )
    {
        LOG((TL_ERROR, "GetIDAsVariant - bad variant pointer"));

        return E_POINTER;
    }


    //
    // initialize the variant
    //

    VariantInit(pVarDeviceID);


    //
    // get the buffer containing ID
    //


    DWORD dwDeviceIDBufferSize = 0;
    
    BYTE *pDeviceIDBuffer = NULL;

    HRESULT hr = GetID(bstrDeviceClass,
                       &dwDeviceIDBufferSize, 
                       &pDeviceIDBuffer);

    if (FAILED(hr))
    {
        LOG((TL_ERROR, "GetIDAsVariant - failed to get device id. hr = %lx", hr));

        return hr;
    }


    //
    // place device id buffer into the variant
    //

    hr = FillVariantFromBuffer(dwDeviceIDBufferSize,
                               pDeviceIDBuffer, 
                               pVarDeviceID);


    //
    // succeeded, or failed, we no longer need the buffer
    //

    CoTaskMemFree(pDeviceIDBuffer);
    pDeviceIDBuffer = NULL;



    if (FAILED(hr))
    {
        LOG((TL_ERROR, "GetIDAsVariant - failed to put device id into a variant. hr = %lx"));

        return hr;
    }


    //
    // done. returning the variant that is array of bytes that contains device id.
    //

    LOG((TL_TRACE, "GetIDAsVariant - exit"));

    return S_OK;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CCall::SetMediaType
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCall::SetMediaType(long lMediaType)
{
    LOG((TL_TRACE, "SetMediaType - enter"));

    HRESULT   hr;

    Lock();

    HCALL     hCall = m_t3Call.hCall;

    Unlock();

    if ( hCall == NULL )
    {
        LOG((TL_ERROR, "SetMediaType - invalid hCall"));
        
        return E_FAIL;
    }

    hr = LineSetMediaMode( hCall, lMediaType );

    LOG((TL_TRACE, "SetMediaType - exit - return %lx", hr));
    
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CCall::MonitorMedia
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCall::MonitorMedia(long lMediaType)
{
    LOG((TL_TRACE, "MonitorMedia - enter"));

    HRESULT   hr;

    Lock();

    HCALL     hCall = m_t3Call.hCall;

    Unlock();

    if ( hCall == NULL )
    {
        LOG((TL_ERROR, "MonitorMedia - invalid hCall"));
        
        return E_FAIL;
    }

    hr = lineMonitorMedia( hCall, lMediaType );

    LOG((TL_TRACE, "MonitorMedia - exit - return %lx", hr));
    
    return hr;
}



/////////////////////////////////////////////////////////////////////////////
// IDispatch implementation
//
typedef IDispatchImpl<ITCallInfo2Vtbl<CCall>, &IID_ITCallInfo2, &LIBID_TAPI3Lib> CallInfoType;
typedef IDispatchImpl<ITBasicCallControl2Vtbl<CCall>, &IID_ITBasicCallControl2, &LIBID_TAPI3Lib> BasicCallControlType;
typedef IDispatchImpl<ITLegacyCallMediaControl2Vtbl<CCall>, &IID_ITLegacyCallMediaControl2, &LIBID_TAPI3Lib> LegacyCallMediaControlType;


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CCall::GetIDsOfNames
//
// Overide if IDispatch method
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP CCall::GetIDsOfNames(REFIID riid, 
                                  LPOLESTR* rgszNames, 
                                  UINT cNames, 
                                  LCID lcid, 
                                  DISPID* rgdispid
                                 ) 
{ 
   HRESULT hr = DISP_E_UNKNOWNNAME;


    // See if the requsted method belongs to the default interface
    hr = CallInfoType::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((TL_INFO, "GetIDsOfNames - found %S on ITCallInfo", *rgszNames));
        rgdispid[0] |= IDISPCALLINFO;
        return hr;
    }

    // If not, then try the Basic Call control interface
    hr = BasicCallControlType::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((TL_INFO, "GetIDsOfNames - found %S on ITBasicCallControl", *rgszNames));
        rgdispid[0] |= IDISPBASICCALLCONTROL;
        return hr;
    }


    // If not, then try the Legacy CAll Media Control interface
    hr = LegacyCallMediaControlType::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((TL_INFO, "GetIDsOfNames - found %S on ITLegacyCallMediaControl", *rgszNames));
        rgdispid[0] |= IDISPLEGACYCALLMEDIACONTROL;
        return hr;
    }

    // If not, then try the aggregated MSP Call object
    if (m_pMSPCall != NULL)
    {
        IDispatch *pIDispatchMSPAggCall;
        
        m_pMSPCall->QueryInterface(IID_IDispatch, (void**)&pIDispatchMSPAggCall);
        
        hr = pIDispatchMSPAggCall->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
        if (SUCCEEDED(hr))  
        {  
            pIDispatchMSPAggCall->Release();
            LOG((TL_INFO, "GetIDsOfNames - found %S on our aggregated MSP Call", *rgszNames));
            rgdispid[0] |= IDISPAGGREGATEDMSPCALLOBJ;
            return hr;
        }
        pIDispatchMSPAggCall->Release();
    }

    LOG((TL_INFO, "GetIDsOfNames - Didn't find %S on our iterfaces", *rgszNames));
    return hr; 
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CCall::Invoke
//
// Overide if IDispatch method
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP CCall::Invoke(DISPID dispidMember, 
                              REFIID riid, 
                              LCID lcid, 
                              WORD wFlags, 
                              DISPPARAMS* pdispparams, 
                              VARIANT* pvarResult, 
                              EXCEPINFO* pexcepinfo, 
                              UINT* puArgErr
                             )
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    DWORD   dwInterface = (dispidMember & INTERFACEMASK);
   
    
    LOG((TL_TRACE, "Invoke - dispidMember %X", dispidMember));

    // Call invoke for the required interface
    switch (dwInterface)
    {
    case IDISPCALLINFO:
    {
        hr = CallInfoType::Invoke(dispidMember, 
                                    riid, 
                                    lcid, 
                                    wFlags, 
                                    pdispparams,
                                    pvarResult, 
                                    pexcepinfo, 
                                    puArgErr
                                   );
        break;
    }
    case IDISPBASICCALLCONTROL:
    {
        hr = BasicCallControlType::Invoke(dispidMember, 
                                            riid, 
                                            lcid, 
                                            wFlags, 
                                            pdispparams,
                                            pvarResult, 
                                            pexcepinfo, 
                                            puArgErr
                                           );
        break;
    }
    case IDISPLEGACYCALLMEDIACONTROL:
    {
        hr = LegacyCallMediaControlType::Invoke(dispidMember, 
                                                  riid, 
                                                  lcid, 
                                                  wFlags, 
                                                  pdispparams,
                                                  pvarResult, 
                                                  pexcepinfo, 
                                                  puArgErr
                                                 );
        break;
    }
    case IDISPAGGREGATEDMSPCALLOBJ:
    {
        IDispatch *pIDispatchMSPAggCall =  NULL;
        
        if (m_pMSPCall != NULL)
        {
            m_pMSPCall->QueryInterface(IID_IDispatch, (void**)&pIDispatchMSPAggCall);
    
            hr = pIDispatchMSPAggCall->Invoke(dispidMember, 
                                                 riid, 
                                                 lcid, 
                                                 wFlags, 
                                                 pdispparams,
                                                 pvarResult, 
                                                 pexcepinfo, 
                                                 puArgErr
                                                );

            pIDispatchMSPAggCall->Release();
        }

        break;
    }

    } // end switch (dwInterface)

    
    LOG((TL_TRACE, hr, "Invoke - exit" ));
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// HandleAcceptToAlert
//
// Handler for PRIVATE_ISDN__ACCEPTTOALERT message
// This is processed on the callback thread to do a lineAccept on an offering 
// ISDN call that requires Accept before it will ring.  Bug 335566
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void HandleAcceptToAlert( PASYNCEVENTMSG pParams )
{
    HRESULT     hr;
    HCALL       hCall = (HCALL) pParams->hDevice;


    hr = LineAccept( hCall, NULL, 0 );
    if ( SUCCEEDED(hr) )
    {
        hr = WaitForReply(hr);
        if ( FAILED(hr) )
        {
            LOG((TL_INFO, hr, "HandleAcceptToAlert - lineAccept failed async"));
        }
    }
    else
    {
        LOG((TL_INFO, hr, "HandleAcceptToAlert - lineAccept failed sync"));
    }
    
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// OnOffering()
//
// If it's an offering call & the TSP requires a lineAccept to start ringing 
// (typically an ISDN feature) then we queue a message to the callback thread 
// to do the lineAccept.  We can't do it here because this is processed on 
// the async thread & as lineAccept is an async fucion we would deadlock 
// while waiting for the async reply.  Bug 335566
//  
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CCall::OnOffering()
{
    LOG((TL_TRACE, "OnOffering - enter" ));

    HRESULT         hr = S_FALSE;
    LONG            lCap;
    ASYNCEVENTMSG   Msg;

    if (m_pAddress != NULL)
    {
        hr = m_pAddress->get_AddressCapability( AC_ADDRESSCAPFLAGS, &lCap );
        if ( SUCCEEDED(hr) )
        {
            if ( (lCap & LINEADDRCAPFLAGS_ACCEPTTOALERT) && (CP_OWNER == m_CallPrivilege) )
            {
                
                LOG((TL_TRACE, "OnOffering - queueing PRIVATE_ISDN__ACCEPTTOALERT message."));


                // Build an msg to queue to the callback thread 
                Msg.Msg = PRIVATE_ISDN__ACCEPTTOALERT;
                Msg.TotalSize = sizeof (ASYNCEVENTMSG);
                Msg.hDevice = (ULONG_PTR) m_t3Call.hCall;
                Msg.Param1 = 0;
                Msg.Param2 = 0;
                Msg.Param3 = 0;

                QueueCallbackEvent( &Msg );

                // Set the Call flag
                m_dwCallFlags |= CALLFLAG_ACCEPTTOALERT;

            }

        }
    }

    LOG((TL_TRACE, "OnOffering - exit. hr = %lx", hr ));

    return hr;
}




//
//  CObjectSafeImpl. since we have aggregates, implement this method
//
//  return non delegating iunkown of the first aggregated object 
//  that supports the interface
//

HRESULT CCall::QIOnAggregates(REFIID riid, IUnknown **ppNonDelegatingUnknown)
{

    //
    // argument check
    // 

    if ( TAPIIsBadWritePtr(ppNonDelegatingUnknown, sizeof(IUnknown*)) )
    {
     
        return E_POINTER;
    }

    //
    // if we fail, at least return consistent values
    //
    
    *ppNonDelegatingUnknown = NULL;


    //
    // see if mspcall or private support the interface riid
    //

    HRESULT hr = E_FAIL;

    Lock();

    if (m_pMSPCall)
    {
        
        // 
        // does mspcall expose this interface?
        // 

        IUnknown *pUnk = NULL;

        hr = m_pMSPCall->QueryInterface(riid, (void**)&pUnk);
        
        if (SUCCEEDED(hr))
        {

            pUnk->Release();
            pUnk = NULL;

            //
            // return the mspcall's non-delegating unknown
            //

           *ppNonDelegatingUnknown = m_pMSPCall;
           (*ppNonDelegatingUnknown)->AddRef();
        }
    }
    
    if ( FAILED(hr) && m_pPrivate )
    {
        
        //
        // bad luck with mspcall? still have a chance with private
        //

        IUnknown *pUnk = NULL;
        
        hr = m_pPrivate->QueryInterface(riid, (void**)&pUnk);

        if (SUCCEEDED(hr))
        {
            pUnk->Release();
            pUnk = NULL;

           *ppNonDelegatingUnknown = m_pPrivate;
           (*ppNonDelegatingUnknown)->AddRef();
        }
    }

    Unlock();

    return hr;
}

// ITBasicCallControl2

/*++
RequestTerminal

ITBasicCallControl2::CreateTerminal() method

If bstrTerminalClassGUID is CLSID_NULL then
we'll try to create the default dynamic terminals
--*/
STDMETHODIMP CCall::RequestTerminal(
    IN  BSTR bstrTerminalClassGUID,
    IN  long lMediaType,
    IN  TERMINAL_DIRECTION  Direction,
    OUT ITTerminal** ppTerminal
    )
{
    LOG((TL_TRACE, "RequestTerminal - enter" ));

    //
    // Validates arguments
    //

    if( IsBadStringPtrW( bstrTerminalClassGUID, (UINT)-1) )
    {
        LOG((TL_ERROR, "RequestTerminal - exit "
            " bstrTerminalClassGUID invalid, returns E_INVALIDARG"));
        return E_INVALIDARG;
    }

    if( TAPIIsBadWritePtr( ppTerminal, sizeof(ITTerminal*)) )
    {
        LOG((TL_ERROR, "RequestTerminal - exit "
            " ppTerminal invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Determines if is a static terminal or a dynamic one
    // For static terminal bstrTerminalClassGUID should have one
    // of the following values
    // CLSID_NULL {00000000-0000-0000-0000-000000000000}
    // CLSID_MicrophoneTerminal     
    // CLSID_SpeakersTerminal 
    // CLSID_VideoInputTerminal 
    //

    HRESULT hr = E_FAIL;

    if( IsStaticGUID( bstrTerminalClassGUID ))
    {
        // Create a static terminal
        LOG((TL_INFO, "RequestTerminal -> StaticTerminal" ));

        hr = CreateStaticTerminal(
            bstrTerminalClassGUID,
            Direction,
            lMediaType,
            ppTerminal);
    }
    else
    {
        // Create a dynamic terminal
        LOG((TL_INFO, "RequestTerminal -> DynamicTerminal" ));
        hr = CreateDynamicTerminal(
            bstrTerminalClassGUID,
            Direction,
            lMediaType,
            ppTerminal);
    }

    //
    // Return value
    //

    LOG((TL_TRACE, "RequestTerminal - exit 0x%08x", hr));
    return hr;
}

STDMETHODIMP CCall::SelectTerminalOnCall(
    IN  ITTerminal *pTerminal
    )
{
    LOG((TL_TRACE, "SelectTerminalOnCall - enter" ));

    //
    // Validates argument
    //

    if( IsBadReadPtr( pTerminal, sizeof(ITTerminal)) )
    {
        LOG((TL_ERROR, "SelectTerminalOnCall - exit "
            " pTerminal invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Just a HRESULT
    //

    HRESULT hr = E_FAIL;

    //
    // Is a single or multi track terminal
    //

    ITMultiTrackTerminal* pMultiTrack = NULL;
    hr = pTerminal->QueryInterface(
        IID_ITMultiTrackTerminal,
        (void**)&pMultiTrack);

    if( FAILED(hr) )
    {
        //
        // SingleTrack terminal
        //

        LOG((TL_TRACE, "SelectTerminalOnCall - SingleTrack terminal" ));

        long lMediaType = 0;
        TERMINAL_DIRECTION Direction =TD_NONE;

        hr = SelectSingleTerminalOnCall(
            pTerminal,
            &lMediaType,
            &Direction);

        LOG((TL_TRACE, "SelectTerminalOnCall - " 
            "SelectSingleTerminalOnCall exit with 0x%08x", hr));
    }
    else
    {
        //
        // Multitrack terminal
        //


        hr = SelectMultiTerminalOnCall(
            pMultiTrack);

        LOG((TL_TRACE, "SelectTerminalOnCall - " 
            "SelectMultiTerminalOnCall failed"));
     }

    //
    // Clean-up
    //

    if( pMultiTrack )
    {
        pMultiTrack->Release();
    }

    LOG((TL_TRACE, "SelectTerminalOnCall - exit 0x%08x", hr ));
    return hr;
}

STDMETHODIMP CCall::UnselectTerminalOnCall(
    IN  ITTerminal *pTerminal
    )
{
    LOG((TL_TRACE, "UnselectTerminalOnCall - enter" ));

    //
    // Validates argument
    //

    if( IsBadReadPtr( pTerminal, sizeof(ITTerminal)) )
    {
        LOG((TL_ERROR, "UnselectTerminalOnCall - exit "
            " pTerminal invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Just a HRESULT
    //

    HRESULT hr = E_FAIL;

    //
    // Is a single or multi track terminal
    //

    ITMultiTrackTerminal* pMultiTrack = NULL;
    hr = pTerminal->QueryInterface(
        IID_ITMultiTrackTerminal,
        (void**)&pMultiTrack);

    if( FAILED(hr) )
    {
        //
        // SingleTrack terminal
        //

        LOG((TL_INFO, "UnselectTerminalOnCall - SingleTrack terminal" ));

        hr = UnSelectSingleTerminalFromCall(
            pTerminal);

        LOG((TL_INFO, "UnselectTerminalOnCall - " 
            "UnSelectSingleTerminalFromCall exit 0x%08x", hr));
    }
    else
    {
        //
        // Multitrack terminal
        //

        LOG((TL_INFO, "UnselectTerminalOnCall - MultiTrack terminal" ));

        hr = UnSelectMultiTerminalFromCall(
            pMultiTrack);

        LOG((TL_INFO, "UnselectTerminalOnCall - " 
            "UnSelectMultiTerminalOnCall exit 0x%08x", hr));
     }

    //
    // Clean-up
    //

    if( pMultiTrack )
    {
        pMultiTrack->Release();
    }
    
    LOG((TL_TRACE, "UnselectTerminalOnCall - exit 0x%08x", hr));
    return hr;
}


/*++
SelectSingleTerminalOnCall

Select pTerminal on a right stream
pMediaType - if *pMediatype is 0 the we have just to return the media type
pDirection - if pDirection is TD_NONE we have just to return the direction
--*/
HRESULT CCall::SelectSingleTerminalOnCall(
    IN  ITTerminal* pTerminal,
    OUT long*       pMediaType,
    OUT TERMINAL_DIRECTION* pDirection)
{
    LOG((TL_TRACE, "SelectSingleTerminalOnCall - Enter" ));

    //
    // Validate terminal pointer
    //

    if( IsBadReadPtr( pTerminal, sizeof(ITTerminal)))
    {
        LOG((TL_ERROR, "SelectSingleTerminalOnCall - exit "
            "pTerminal invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Is terminal in use?
    //

    HRESULT hr = E_FAIL;
    TERMINAL_STATE state = TS_INUSE;
    pTerminal->get_State( &state );

    if( TS_INUSE == state )
    {
        LOG((TL_ERROR, "SelectSingleTerminalOnCall - exit "
            "terminal IN USE, returns E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    //
    // Get ITStreamControl interface
    //

    ITStreamControl* pStreamControl = NULL;
    pStreamControl = GetStreamControl();

    if( NULL == pStreamControl )
    {
        LOG((TL_ERROR, "SelectSingleTerminalOnCall - exit "
            " GetStreamControl failed, returns E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    //
    // Get streams
    //

    IEnumStream * pEnumStreams = NULL;
    
    hr = pStreamControl->EnumerateStreams(&pEnumStreams);

    //
    // Clean up
    //

    pStreamControl->Release();

    if( FAILED(hr) )
    {
        LOG((TL_ERROR, "SelectSingleTerminalOnCall - exit "
            " EnumerateStreams failed, returns 0x%08x", hr));
        return hr;
    }

    //
    // Find the right stream
    //

    ITStream * pStream = NULL;
    hr = E_FAIL;

    while ( S_OK == pEnumStreams->Next(1, &pStream, NULL) )
    {
        //
        // Find out the media type and direction of this stream,
        // and compare with pTerminal.
        //

        hr = IsRightStream(
            pStream, 
            pTerminal, 
            pMediaType,
            pDirection
            );

        if( SUCCEEDED(hr) )
        {
            hr = pStream->SelectTerminal( pTerminal );


            if( FAILED(hr) )
            {
                LOG((TL_TRACE, "SelectSingleTerminalOnCall - "
                    "pStream->SelectTerminal failed. 0x%08x",hr));

                // Clean-up
                pStream->Release();
                break;
            }
            else
            {
                // Clean-up
                pStream->Release();
                break;
            }
        }

        //
        // Clean-up
        //

        pStream->Release();
    }

    //
    // Clean-up
    //

    pEnumStreams->Release();

    LOG((TL_TRACE, "SelectSingleTerminalOnCall - exit 0x%08x", hr));
    return hr;
}

/*++
SelectMultiTerminalOnCall

It's a complict algorithm to describe it here
See specs
--*/
HRESULT CCall::SelectMultiTerminalOnCall(
    IN  ITMultiTrackTerminal* pMultiTerminal)
{
    LOG((TL_TRACE, "SelectMultiTerminalOnCall - enter" ));

    //
    // Get tracks
    //

    HRESULT hr = E_FAIL;
    IEnumTerminal*  pEnumTerminals = NULL;
    hr = pMultiTerminal->EnumerateTrackTerminals(&pEnumTerminals);

    if( FAILED(hr) )
    {
        LOG((TL_ERROR, "SelectMultiTerminalOnCall - exit "
            "EnumerateTrackTerminals failed, returns 0x%08x", hr));
        return hr;
    }

    ITTerminal* pTerm = NULL;
    hr = pMultiTerminal->QueryInterface(
        IID_ITTerminal,
        (void**)&pTerm);
    if( FAILED(hr) )
    {
        //Clean-up
        pEnumTerminals->Release();

        LOG((TL_ERROR, "SelectMultiTerminalOnCall - exit "
            "QI for Terminal failed, returns 0x%08x", hr));
        return hr;
    }

    long nTermMediaTypes = 0;
    hr = pTerm->get_MediaType( &nTermMediaTypes );
    if( FAILED(hr) )
    {
        //Clean-up
        pEnumTerminals->Release();
        pTerm->Release();

        LOG((TL_ERROR, "SelectMultiTerminalOnCall - exit "
            "get_MediaType failed, returns 0x%08x", hr));
        return hr;
    }

    pTerm->Release();

    //
    // Inner struct
    //

    typedef struct tagSTREAMINFO
    {
        TERMINAL_DIRECTION  Direction;
        long    lMediaType;
        BOOL    bSelected;
    } STREAMINFO;

    //
    // Find tracks unused and select them
    // on the right stream

    ITTerminal * pTerminal = NULL;
    STREAMINFO StreamsInfo[4] = {
        {TD_RENDER, TAPIMEDIATYPE_AUDIO, FALSE},
        {TD_RENDER, TAPIMEDIATYPE_VIDEO, FALSE},
        {TD_CAPTURE, TAPIMEDIATYPE_AUDIO, FALSE},
        {TD_CAPTURE, TAPIMEDIATYPE_VIDEO, FALSE}
    };

    //
    // +++ FIXBUG 92559 +++
    //

    BOOL bSelectAtLeastOne = FALSE;
    LOG((TL_INFO, "SelectMultiTerminalOnCall - FIRST LOOP ENTER"));
    while ( S_OK == pEnumTerminals->Next(1, &pTerminal, NULL) )
    {
        //
        // Select track on the right stream
        //

        long lMediaType = 0;
        TERMINAL_DIRECTION Direction = TD_NONE;
        HRESULT hr = E_FAIL;

        LOG((TL_INFO, "SelectMultiTerminalOnCall - FIRST LOOP IN"));
        hr = SelectSingleTerminalOnCall(
            pTerminal,
            &lMediaType,
            &Direction);

        if( SUCCEEDED(hr) )
        {
            LOG((TL_TRACE, "SelectMultiTerminalOnCall - "
            "select terminal on stream (%ld, %ld)", lMediaType, Direction));

            int nIndex = GetStreamIndex(
                lMediaType,
                Direction);

            if( nIndex != STREAM_NONE )
            {
                StreamsInfo[nIndex].bSelected = TRUE;
            }

            bSelectAtLeastOne = TRUE;
        }

        // Clean-up
        pTerminal->Release();
    }
    LOG((TL_INFO, "SelectMultiTerminalOnCall - FIRST LOOP EXIT"));

    //
    // Clean-up
    //
    pEnumTerminals->Release();

    BOOL bCreateAtLeastOne = FALSE;    

    //
    // Let's create a terminal for unselected streams
    //

    LOG((TL_INFO, "SelectMultiTerminalOnCall - SECOND LOOP ENTER"));
    for(int nStream = STREAM_RENDERAUDIO; nStream < STREAM_NONE; nStream++)
    {
        LOG((TL_INFO, "SelectMultiTerminalOnCall - SECOND LOOP IN"));

        if( StreamsInfo[ nStream ].bSelected)
        {
            continue;
        }

        if( (StreamsInfo[ nStream ].lMediaType & nTermMediaTypes)==0 )
        {
            continue;
        }

        //
        // Unselected stream
        //

        LOG((TL_INFO, "SelectMultiTerminalOnCall - SECOND LOOP REALYIN"));

        HRESULT hr = E_FAIL;
        ITTerminal* pTerminal = NULL;
        hr = pMultiTerminal->CreateTrackTerminal(
            StreamsInfo[ nStream ].lMediaType,
            StreamsInfo[ nStream ].Direction,
            &pTerminal);

        if( FAILED(hr) )
        {
            LOG((TL_ERROR, "SelectMultiTerminalOnCall - "
            "create terminal on stream (%ld, %ld) failed", 
            StreamsInfo[ nStream ].lMediaType, 
            StreamsInfo[ nStream ].Direction));
        }
        else
        {
            long lMediaType = StreamsInfo[ nStream ].lMediaType;
            TERMINAL_DIRECTION Direction = StreamsInfo[ nStream ].Direction;
            hr = SelectSingleTerminalOnCall(
                pTerminal,
                &lMediaType,
                &Direction);

            if( FAILED(hr) )
            {
                LOG((TL_INFO,  "SelectMultiTerminalOnCall - "
                "select terminal on stream (%ld, %ld) failed", 
                StreamsInfo[ nStream ].lMediaType, 
                StreamsInfo[ nStream ].Direction));

                pMultiTerminal->RemoveTrackTerminal( pTerminal );
            }
            else
            {
                LOG((TL_ERROR, "SelectMultiTerminalOnCall - SelectSingleTerminal SUCCEEDED"));
                bCreateAtLeastOne = TRUE;
            }
            
            // Clean-up
            pTerminal->Release();
        }
    }
    LOG((TL_INFO, "SelectMultiTerminalOnCall - SECOND LOOP EXIT"));

    if( bSelectAtLeastOne )
    {
       LOG((TL_INFO, "SelectMultiTerminalOnCall - "
           "Select at least one existing track terminal"));
       hr = S_OK;
    }
    else
    {
       if( bCreateAtLeastOne )
       {
           LOG((TL_ERROR, "SelectMultiTerminalOnCall - "
               "Create and select at least one track terminal"));
           hr = S_OK;
       }
       else
       {
           LOG((TL_ERROR, "SelectMultiTerminalOnCall - "
               "Create and/or select no track terminal"));
           hr = E_FAIL;
       }
    }

    LOG((TL_TRACE, "SelectMultiTerminalOnCall - exit 0X%08X", hr ));
    return hr;
}

HRESULT CCall::IsRightStream(
    IN  ITStream*   pStream,
    IN  ITTerminal* pTerminal,
    OUT long*       pMediaType/*= NULL*/,
    OUT TERMINAL_DIRECTION* pDirection/*=NULL*/)
{
    LOG((TL_TRACE, "IsRightStream - enter" ));

    if( NULL == pStream )
    {
        LOG((TL_ERROR, "IsRightStream - exit "
            "pStream failed, returns E_POINTER"));
        return E_POINTER;
    }

    HRESULT            hr = E_FAIL;
    long               lMediaStream, lMediaTerminal;
    TERMINAL_DIRECTION DirStream, DirTerminal;

    //
    // Determine the media type and direction of this stream.
    //
    
    hr = pStream->get_MediaType( &lMediaStream );
    if ( FAILED(hr) ) 
    {
        LOG((TL_ERROR, "IsRightStream - exit "
            "IStream::get_MediaType failed, returns 0x%08x", hr));
        return hr;
    }

    hr = pStream->get_Direction( &DirStream );
    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "IsRightStream - exit "
            "IStream::get_Direction failed, returns 0x%08x", hr));
        return hr;
    }

    //
    // Determine the media type and direction of this terminal.
    //

    hr = pTerminal->get_MediaType( &lMediaTerminal );
    if ( FAILED(hr) ) 
    {
        LOG((TL_ERROR, "IsRightStream - exit "
            "ITTerminal::get_MediaType failed, returns 0x%08x", hr));
        return hr;
    }

    hr = pTerminal->get_Direction( &DirTerminal );
    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "IsRightStream - exit "
            "ITTerminal::get_Direction failed, returns 0x%08x", hr));
        return hr;
    }

    //
    // Compare the media types supported
    //

    if ( (0 == (lMediaTerminal & lMediaStream)) /*||
         (*pMediaType != 0 && *pMediaType != lMediaStream)*/ )
    {
        LOG((TL_ERROR, "IsRightStream - exit "
            "media types unmatched, returns E_FAIL (S=0x%08x,T=0x%08x)",
            lMediaStream, lMediaTerminal));
        return E_FAIL;
    }

    //
    // Compare directions
    //

    if( ( DirTerminal != DirStream) /*||
        ( *pDirection != TD_NONE && *pDirection != DirStream)*/)
    {
        LOG((TL_ERROR, "IsRightStream - exit "
            "directions unmatched, returns E_FAIL (S=0x%08x,T=0x%08x)",
            DirStream,DirTerminal));
        return E_FAIL;
    }

    //
    // The wants to know the media type & direction?
    //
    *pMediaType = lMediaStream;
    *pDirection = DirStream;

    LOG((TL_TRACE, "IsRightStream - exit, matched (M=0x%08x, D=0x%08x)",
        *pMediaType, *pDirection));
    return S_OK;
}

/*++
GetStreamIndex
--*/
int CCall::GetStreamIndex(
    IN  long    lMediaType,
    IN  TERMINAL_DIRECTION Direction)
{
    int nIndex = STREAM_NONE;
    LOG((TL_TRACE, "GetStreamIndex - enter (%ld, %ld)", lMediaType, Direction));

    if(Direction == TD_RENDER )
    {
        if( lMediaType == TAPIMEDIATYPE_AUDIO )
        {
            nIndex = STREAM_RENDERAUDIO;
        }
        else
        {
            nIndex = STREAM_RENDERVIDEO;
        }
    }
    else
    {
        if( lMediaType == TAPIMEDIATYPE_AUDIO )
        {
            nIndex = STREAM_CAPTUREAUDIO;
        }
        else
        {
            nIndex = STREAM_CAPTUREVIDEO;
        }
    }

    LOG((TL_TRACE, "GetStreamIndex - exit %d", nIndex));
    return nIndex;
}

/*++
UnSelectSingleTerminalFromCall
--*/
HRESULT CCall::UnSelectSingleTerminalFromCall(
    IN  ITTerminal* pTerminal)
{
    LOG((TL_TRACE, "UnSelectSingleTerminalFromCall - enter" ));

    //
    // Get ITStreamControl interface
    //

    ITStreamControl* pStreamControl = NULL;
    pStreamControl = GetStreamControl();

    if( NULL == pStreamControl )
    {
        LOG((TL_ERROR, "UnSelectSingleTerminalFromCall - exit "
            " GetStreamControl failed, returns E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    //
    // Get streams
    //

    IEnumStream * pEnumStreams = NULL;
    HRESULT hr = E_FAIL;
    
    hr = pStreamControl->EnumerateStreams(&pEnumStreams);

    //
    // Clean up
    //

    pStreamControl->Release();

    if( FAILED(hr) )
    {
        LOG((TL_ERROR, "UnSelectSingleTerminalFromCall - exit "
            "EnumerateStreams failed, returns 0x%08x", hr));
        return hr;
    }

    //
    // Find the right stream
    //

    ITStream * pStream = NULL;
    hr = TAPI_E_INVALIDTERMINAL;

    while ( S_OK == pEnumStreams->Next(1, &pStream, NULL) )
    {
        //
        // Unselect terminal
        //

        hr = pStream->UnselectTerminal(
            pTerminal);

        //
        // Clean-up
        //

        pStream->Release();

        LOG((TL_INFO, "UnSelectSingleTerminalFromCall - " 
            "pStream->UnselectTerminal returns 0x%08x", hr));

        if( hr == S_OK)
            break;
    }

    //
    // Clean-up
    //

    pEnumStreams->Release();

    LOG((TL_TRACE, "UnSelectSingleTerminalFromCall - exit 0x%08x", hr));
    return hr;
}

/*++
UnSelectMultiTerminalFromCall
--*/
HRESULT CCall::UnSelectMultiTerminalFromCall(
    IN  ITMultiTrackTerminal* pMultiTerminal)
{
    LOG((TL_TRACE, "UnSelectMultiTerminalFromCall - enter" ));

    //
    // Get tracks
    //

    HRESULT hr = E_FAIL;
    IEnumTerminal*  pEnumTerminals = NULL;
    hr = pMultiTerminal->EnumerateTrackTerminals(&pEnumTerminals);

    if( FAILED(hr) )
    {
        LOG((TL_ERROR, "UnSelectMultiTerminalFromCall - exit "
            "EnumerateTrackTerminals failed, returns 0x%08x", hr));
        return hr;
    }

    //
    // Find tracks and unselect them
    // 

    ITTerminal * pTerminal = NULL;
    HRESULT hrUnselect = S_OK;  // The return HR
    BOOL bOnStream = FALSE;     // If we have a track on stream

    while ( S_OK == pEnumTerminals->Next(1, &pTerminal, NULL) )
    {
        LOG((TL_INFO, "UnSelectMultiTerminalFromCall - NextTerminalBegin "));

        //
        // Try to find out if the terminal
        // was selected on a stream
        //

        BOOL bSelected = FALSE;
        HRESULT hr = IsTerminalSelected(
            pTerminal,
            &bSelected
            );

        if( FAILED(hr) )
        {
            hrUnselect = hr;
            pTerminal->Release();

            LOG((TL_INFO, "UnSelectMultiTerminalFromCall - "
                "IsTerminalSelected failed all method will failed hrUnselect=0x%08x", 
                hrUnselect));

            continue;
        }

        //
        // The terminal wasn't selected?
        //

        if( !bSelected )
        {
            //
            // The terminal wasn't selected
            // goto the next terminal
            //

            LOG((TL_INFO, "UnSelectMultiTerminalFromCall - "
                "the terminal wasn't selected on a stream, "
                "goto the next terminal hrUnselect=0x%08x",
                hrUnselect));

            pTerminal->Release();
            continue;
        }

        //
        // We have an terminal on stream
        //

        bOnStream = TRUE;

        //
        // The terminal was selected on stream
        // try to unselect terminal
        //

        hr = UnSelectSingleTerminalFromCall(
                pTerminal
                );

        //
        // Unselection failed?
        //

        if( FAILED(hr) )
        {
            //
            // Event this unselection failed
            // try to unselect the other terminals
            // so go to the next terminal
            //

            hrUnselect = hr;

            LOG((TL_INFO, "UnSelectMultiTerminalFromCall - "
                "the terminal wasn't unselected from the stream, "
                "goto the next terminal hrUnselect=0x%08x",
                hrUnselect));

            pTerminal->Release();
            continue;
        }

        //
        // Unselection succeded
        // Leave the hrUnselected as it was before
        // we start the loop with hrUnselect=S_OK
        // if a previous terminal failed
        // we already have setted on FAIL the hrUnselect
        // Goto the next terminal
        //

        pTerminal->Release();        

        LOG((TL_INFO, "UnSelectMultiTerminalFromCall - NextTerminalEnd hrUnselect=0x%08x", hrUnselect));
    }

    //
    // Clean-up
    //
    pEnumTerminals->Release();

    //
    // If we don't have track on streams
    // this is realy bad
    //
    if( !bOnStream )
    {
        hrUnselect = E_FAIL;
    }

    hr = hrUnselect;

    LOG((TL_TRACE, "UnSelectMultiTerminalFromCall - exit 0x%08x", hr));
    return hr;
}

/*++
IsStaticGUID

Is caleled by RequestTerminal
Determines if the GUID represents a static terminal
or a dynamic one
--*/
BOOL CCall::IsStaticGUID(
    BSTR    bstrTerminalGUID)
{
    LOG((TL_TRACE, "IsStaticGUID - enter" ));

    BOOL bStatic = FALSE;

    //
    // Get the CLSID from bstrTerminalGUID
    //

    CLSID clsidTerminal;
    HRESULT hr = E_FAIL;
    hr = CLSIDFromString( bstrTerminalGUID, &clsidTerminal );

    if( FAILED(hr) )
    {
        LOG((TL_ERROR, "IsStaticGUID - exit "
            "CLSIDFromString failed, returns FALSE"));
        return FALSE;
    }

    //
    // Is clsidTerminal a 'static terminal' CLSID?
    //

    if( (clsidTerminal == CLSID_NULL) ||
        (clsidTerminal == CLSID_MicrophoneTerminal) ||
        (clsidTerminal == CLSID_SpeakersTerminal) ||
        (clsidTerminal == CLSID_VideoInputTerminal))
    {
        bStatic = TRUE;
    }

    LOG((TL_TRACE, "IsStaticGUID - exit (%d)", bStatic));
    return bStatic;
}

/*++
CreateStaticTerminal

  Called by RequestTerminal
--*/
HRESULT CCall::CreateStaticTerminal(
    IN  BSTR bstrTerminalClassGUID,
    IN  TERMINAL_DIRECTION  Direction,
    IN  long lMediaType,
    OUT ITTerminal** ppTerminal
    )
{
    LOG((TL_TRACE, "CreateStaticTerminal - enter"));

    //
    // Helper method, the argument should be valid
    //

    _ASSERTE( bstrTerminalClassGUID );
    _ASSERTE( *pTerminal );

    //
    // Get ITTerminalSupport interface
    //

    HRESULT hr = E_FAIL;
    ITTerminalSupport* pSupport = NULL;

    hr = m_pAddress->QueryInterface(
        IID_ITTerminalSupport,
        (void**)&pSupport);

    if( FAILED(hr) )
    {
        LOG((TL_ERROR, "CreateStaticTerminal - exit"
            "QueryInterface for ITTerminalSupport failed, returns 0x%08x", hr));
        return hr;
    }

    //
    // Get terminal CLSID from BSTR
    //

    CLSID clsidTerminal = CLSID_NULL;
    hr = CLSIDFromString( bstrTerminalClassGUID, &clsidTerminal );

    if( FAILED(hr) )
    {
        // Cleanup
        pSupport->Release();

        LOG((TL_ERROR, "CreateStaticTerminal - exit"
            "CLSIDFromString failed, returns 0x%08x", hr));
        return hr;
    }

    //
    // Is CLSID matching with lMediaType and Direction?
    //

    if( clsidTerminal != CLSID_NULL )
    {
        if( clsidTerminal == CLSID_MicrophoneTerminal &&
            ((lMediaType != TAPIMEDIATYPE_AUDIO) || (Direction != TD_CAPTURE)))
        {
            // Cleanup
            pSupport->Release();

            LOG((TL_ERROR, "CreateStaticTerminal - exit"
                "CLSID_MicrophoneTerminal unmatched, returns E_UNEXPECTED"));
            return E_UNEXPECTED;
        }

        if( clsidTerminal == CLSID_SpeakersTerminal &&
            ((lMediaType != TAPIMEDIATYPE_AUDIO) || (Direction != TD_RENDER)))
        {
            // Cleanup
            pSupport->Release();

            LOG((TL_ERROR, "CreateStaticTerminal - exit"
                "CLSID_SpeakersTerminal unmatched, returns E_UNEXPECTED"));
            return E_UNEXPECTED;
        }

        if( clsidTerminal == CLSID_VideoInputTerminal &&
            ((lMediaType != TAPIMEDIATYPE_VIDEO) || (Direction != TD_CAPTURE)))
        {
            // Cleanup
            pSupport->Release();

            LOG((TL_ERROR, "CreateStaticTerminal - exit"
                "CLSID_VideoInputTerminal unmatched, returns E_UNEXPECTED"));
            return E_UNEXPECTED;
        }
    }
    else
    {
        // Shouldn't be the Dynamic terminal media type and direction
        if((lMediaType == TAPIMEDIATYPE_VIDEO) && (Direction == TD_RENDER))
        {
            // Cleanup
            pSupport->Release();

            LOG((TL_ERROR, "CreateStaticTerminal - exit"
                "try to create a dynamic terminal, returns E_UNEXPECTED"));
            return E_UNEXPECTED;
        }
    }

    //
    // Cool, let's create the terminal
    //

    LOG((TL_INFO, "CreateStaticTerminal -> "
        "ITterminalSupport::GetDefaultStaticTerminal"));

    hr = pSupport->GetDefaultStaticTerminal(
        lMediaType,
        Direction,
        ppTerminal);

    //
    // Clean-up ITTerminalSupport interface
    //

    pSupport->Release();

    LOG((TL_TRACE, "CreateStaticTerminal - exit 0x%08x", hr));
    return hr;
}

/*++
CreateDynamicTerminal

  Called by RequestTerminal
--*/
HRESULT CCall::CreateDynamicTerminal(
    IN  BSTR bstrTerminalClassGUID,
    IN  TERMINAL_DIRECTION  Direction,
    IN  long lMediaType,
    OUT ITTerminal** ppTerminal
    )
{
    LOG((TL_TRACE, "CreateDynamicTerminal - enter"));

    //
    // Helper method, the argument should be valid
    //

    _ASSERTE( bstrTerminalClassGUID );
    _ASSERTE( *pTerminal );

    //
    // Get ITTerminalSupport interface
    //

    HRESULT hr = E_FAIL;
    ITTerminalSupport* pSupport = NULL;

    hr = m_pAddress->QueryInterface(
        IID_ITTerminalSupport,
        (void**)&pSupport);

    if( FAILED(hr) )
    {
        LOG((TL_ERROR, "CreateDynamicTerminal - exit"
            "QueryInterface for ITTerminalSupport failed, returns 0x%08x", hr));
        return hr;
    }

    //
    // Create dynamic terminal 
    //

    LOG((TL_INFO, "CreateDynamicTerminal -> "
        "ITTerminalSupport::CreateTerminal"));

    hr = pSupport->CreateTerminal(
        bstrTerminalClassGUID,
        lMediaType,
        Direction,
        ppTerminal);

    //
    // Clean-up ITTerminalSupport interface
    //

    pSupport->Release();
    
    LOG((TL_TRACE, "CreateDynamicTerminal - exit 0x%08x", hr));
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCall
// Interface : ITCallInfo2
// Method    : put_FilterEvent
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CCall::put_EventFilter(
    TAPI_EVENT      TapiEvent,
    long            lSubEvent,
    VARIANT_BOOL    bEnable
    )
{
    LOG((TL_TRACE, "put_EventFilter - enter"));

    // Enter critical section
    Lock();

    //
    // Validates the pair TapiEvent - lSubEvent
    // Accept 'allsubevents'
    //
    if( !m_EventMasks.IsSubEventValid( TapiEvent, lSubEvent, TRUE, TRUE) )
    {
        LOG((TL_ERROR, "put_EventFilter - "
            "This event can't be set: %x, return E_INVALIDARG", TapiEvent ));

        // Leave critical section
        Unlock();

        return E_INVALIDARG;
    }

    // Let's set the flag
    HRESULT hr = E_FAIL;
    hr = SetSubEventFlag( 
        TapiEvent, 
        lSubEvent, 
        (bEnable  == VARIANT_TRUE)
        );

    // Leave critical section
    Unlock();

    LOG((TL_TRACE, "put_EventFilter - exit 0x%08x", hr));
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCall
// Interface : ITCallInfo2
// Method    : get_FilterEvent
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CCall::get_EventFilter(
    TAPI_EVENT      TapiEvent,
    long            lSubEvent,
    VARIANT_BOOL*   pEnable
    )
{
    LOG((TL_TRACE, "get_EventFilter - enter"));

    //
    // Validates output argument
    //
    if( IsBadReadPtr(pEnable, sizeof(VARIANT_BOOL)) )
    {
        LOG((TL_ERROR, "get_EventFilter - "
            "invalid VARIANT_BOOL pointer , return E_POINTER" ));
        return E_POINTER;
    }

    // Enter critical section
    Lock();

    //
    // Validates the pair TapiEvent - lSubEvent
    // Don't accept 'allsubevents'
    //

    if( !m_EventMasks.IsSubEventValid( TapiEvent, lSubEvent, FALSE, TRUE) )
    {
        LOG((TL_ERROR, "get_EventFilter - "
            "This event can't be set: %x, return E_INVALIDARG", TapiEvent ));

        // Leave critical section
        Unlock();

        return E_INVALIDARG;
    }

    //
    // Get the subevent mask for that (event, subevent) pair
    //

    BOOL bEnable = FALSE;
    HRESULT hr = GetSubEventFlag(
        TapiEvent,
        (DWORD)lSubEvent,
        &bEnable);

    if( FAILED(hr) )
    {
        LOG((TL_ERROR, "get_EventFilter - "
            "GetSubEventFlag failed, return 0x%08x", hr ));

        // Leave critical section
        Unlock();

        return hr;
    }

    //
    // Set the output argument
    //

    *pEnable = bEnable ? VARIANT_TRUE : VARIANT_FALSE;

    // Leave critical section
    Unlock();

    LOG((TL_TRACE, "get_EventFilter - exit S_OK"));
    return S_OK;
}


//
// SetSubEventFlag
// It is calle by CAddress::SetSubEventFlagToCalls()
// Sets the subevent flag
//

HRESULT CCall::SetSubEventFlag(
    IN  TAPI_EVENT  TapiEvent,
    IN  DWORD       dwSubEvent,
    IN  BOOL        bEnable
    )
{
    LOG((TL_TRACE, "SetSubEventFlag - enter"));

    //
    // Set the flag for that (event,subevent) pair
    //
    HRESULT hr = E_FAIL;
    hr = m_EventMasks.SetSubEventFlag(
        TapiEvent,
        dwSubEvent,
        bEnable);

    LOG((TL_TRACE, "SetSubEventFlag - exit 0x%08x", hr));
    return hr;
}

/*++
GetSubEventFlag

  It is called by get_EventFilter() method
--*/
HRESULT CCall::GetSubEventFlag(
    TAPI_EVENT  TapiEvent,
    DWORD       dwSubEvent,
    BOOL*       pEnable
    )
{
    LOG((TL_TRACE, "GetSubEventFlag enter" ));

    HRESULT hr = E_FAIL;

    //
    // Get the subevent falg
    //
    hr = m_EventMasks.GetSubEventFlag(
        TapiEvent,
        dwSubEvent,
        pEnable
        );

    LOG((TL_TRACE, "GetSubEventFlag exit 0x%08x", hr));
    return hr;
}

/*++
GetSubEventsMask
--*/
DWORD CCall::GetSubEventsMask(
    IN  TAPI_EVENT TapiEvent
    )
{
    LOG((TL_TRACE, "GetSubEventsMask - enter"));

    DWORD dwSubEventFlag = m_EventMasks.GetSubEventMask(
        TapiEvent
        );

    LOG((TL_TRACE, "GetSubEventsMask - exit %ld", dwSubEventFlag));
    return dwSubEventFlag;
}


HRESULT CCall::IsTerminalSelected(
    IN ITTerminal* pTerminal,
    OUT BOOL* pSelected
    )
{
    LOG((TL_TRACE, "IsTerminalSelected - enter"));

    // Initialize
    *pSelected = FALSE;
    HRESULT hr = E_FAIL;
    long nMTTerminal = TAPIMEDIATYPE_AUDIO;
    TERMINAL_DIRECTION DirTerminal = TD_CAPTURE;

    // Get media type
    hr = pTerminal->get_MediaType(&nMTTerminal);
    if( FAILED(hr) )
    {
        LOG((TL_ERROR, "IsTerminalSelected - get_MediaType failed. Exit 0x%08x, %d", hr, *pSelected));
        return hr;
    }

    // Get direction
    hr = pTerminal->get_Direction(&DirTerminal);
    if( FAILED(hr) )
    {
        LOG((TL_ERROR, "IsTerminalSelected - get_Direction failed. Exit %0x%08x, %d", hr, *pSelected));
        return hr;
    }

    LOG((TL_INFO, "IsTerminalSelected - MT=%d, Dir=%d", 
        nMTTerminal, DirTerminal));

    // Get stream control
    ITStreamControl* pStreamControl = NULL;
    pStreamControl = GetStreamControl();

    if( NULL == pStreamControl )
    {
        LOG((TL_ERROR, "IsTerminalSelected - exit "
            " GetStreamControl failed, returns E_UNEXPECTED, %d", *pSelected));
        return E_UNEXPECTED;
    }

    //Enumerate streams
    IEnumStream* pStreams = NULL;
    hr = pStreamControl->EnumerateStreams(&pStreams);
    pStreamControl->Release();
    if( FAILED(hr) )
    {
        LOG((TL_ERROR, "IsTerminalSelected - exit "
            " EnumerateStreams failed, returns 0x%08x, %d",hr, *pSelected));
        return hr;
    }

    // Parse the enumeration
    ITStream* pStream = NULL;
    ULONG ulFetched = 0;
    while( S_OK == pStreams->Next(1, &pStream, &ulFetched))
    {
        // Get media type for the stream
        long nMTStream = TAPIMEDIATYPE_AUDIO;
        hr = pStream->get_MediaType(&nMTStream);
        if( FAILED(hr))
        {
            LOG((TL_ERROR, "IsTerminalSelected - exit "
                " get_MediaType failed, returns 0x%08x, %d",hr, *pSelected));
            return hr;
        }

        // Get direction for stream
        TERMINAL_DIRECTION DirStream = TD_CAPTURE;
        hr = pStream->get_Direction(&DirStream);
        if( FAILED(hr))
        {
            LOG((TL_ERROR, "IsTerminalSelected - exit "
                " get_MediaType failed, returns 0x%08x, %d",hr, *pSelected));

            pStream->Release();
            pStreams->Release();
            return hr;
        }

        // The stream is matching with the terminal?
        if( (nMTTerminal!=nMTStream) || (DirTerminal!=DirStream) )
        {
            pStream->Release();
            continue; //Go to the next stream
        }

        // We are on the right stream
        // enumerate the terminals
        IEnumTerminal* pTerminals = NULL;
        hr = pStream->EnumerateTerminals( &pTerminals);
        if( FAILED(hr))
        {
            LOG((TL_ERROR, "IsTerminalSelected - exit "
                " EnumerateTerminals failed, returns 0x%08x, %d",hr, *pSelected));

            pStream->Release();
            pStreams->Release();
            return hr;
        }

        // Clean-up
        pStream->Release();

        // Parse the terminals
        ITTerminal* pTerminalStream = NULL;
        ULONG ulTerminal = 0;
        while(S_OK==pTerminals->Next(1, &pTerminalStream, &ulTerminal))
        {
            if( pTerminal == pTerminalStream)
            {
                *pSelected = TRUE;
                pTerminalStream->Release();
                break;
            }

            pTerminalStream->Release();
        }

        // Clean-up
        pTerminals->Release();
        break;
    }

    // Clean-up streams
    pStreams->Release();

    LOG((TL_TRACE, "IsTerminalSelected - exit S_OK Selected=%d", *pSelected));
    return S_OK;
}



/*++
Method:
    GetConfControlCall

Parameters:
    None.

Return Value:
    Conference controller call object associated with this call.

Remarks:
    None.

--*/

CCall* 
CCall::GetConfControlCall(void)
{
    CCall* pConfContCall = NULL;

    Lock();
    
    //
    // NikhilB: Call object has a reference to Callhub object so its safe to
    // lock the callhub object before locking the call. This is to avoid a
    // deadlock that happens dur to locking the call and the callhub in reverse 
    // orders in different functions.
    //
    
    if( m_pCallHub != NULL )
    {
        m_pCallHub->AddRef();
        AddRef();

        Unlock();
        
        // lock the callhub object before locking the call
        m_pCallHub->Lock();
        Lock();
        
        Release();
        m_pCallHub->Release();

        pConfContCall = m_pCallHub ->GetConferenceControllerCall();
        
        m_pCallHub->Unlock();
    }

    Unlock();

    return pConfContCall;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CDetectTone
// Interface : ITDetectTone
// Method    : put_AppSpecific
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CDetectTone::put_AppSpecific( long lAppSpecific )
{
    LOG((TL_TRACE, "put_AppSpecific - enter"));

    Lock();

    m_lAppSpecific = lAppSpecific;

    Unlock();

    LOG((TL_TRACE, "put_AppSpecific - exit - S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CDetectTone
// Interface : ITDetectTone
// Method    : get_AppSpecific
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CDetectTone::get_AppSpecific( long * plAppSpecific )
{
    LOG((TL_TRACE, "get_AppSpecific - enter"));

    if ( TAPIIsBadWritePtr( plAppSpecific, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_AppSpecific - bad pointer"));

        return E_POINTER;
    }

    Lock();

    *plAppSpecific = m_lAppSpecific;

    Unlock();

    LOG((TL_TRACE, "get_AppSpecific - exit - S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CDetectTone
// Interface : ITDetectTone
// Method    : put_Duration
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CDetectTone::put_Duration( long lDuration )
{
    LOG((TL_TRACE, "put_Duration - enter"));

    Lock();

    m_lDuration = lDuration;

    Unlock();

    LOG((TL_TRACE, "put_Duration - exit - S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CDetectTone
// Interface : ITDetectTone
// Method    : get_Duration
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CDetectTone::get_Duration( long * plDuration )
{
    LOG((TL_TRACE, "get_Duration - enter"));

    if ( TAPIIsBadWritePtr( plDuration, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_Duration - bad pointer"));

        return E_POINTER;
    }

    Lock();

    *plDuration = m_lDuration;

    Unlock();

    LOG((TL_TRACE, "get_Duration - exit - S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CDetectTone
// Interface : ITDetectTone
// Method    : put_Frequency
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CDetectTone::put_Frequency( 
                                   long Index,
                                   long lFrequency
                                  )
{
    LOG((TL_TRACE, "put_Frequency - enter"));

    if ( (Index < 1) || (Index > 3))
    {
        LOG((TL_ERROR, "put_Frequency - invalid index"));

        return E_INVALIDARG;
    }

    Lock();

    m_lFrequency[Index - 1] = lFrequency;

    Unlock();

    LOG((TL_TRACE, "put_Frequency - exit - S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CDetectTone
// Interface : ITDetectTone
// Method    : get_Frequency
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CDetectTone::get_Frequency( 
                                   long Index,
                                   long * plFrequency
                                  )
{
    LOG((TL_TRACE, "get_Frequency - enter"));

    if ( TAPIIsBadWritePtr( plFrequency, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_Frequency - bad pointer"));

        return E_POINTER;
    }

    if ( (Index < 1) || (Index > 3))
    {
        LOG((TL_ERROR, "get_Frequency - invalid index"));

        return E_INVALIDARG;
    }

    Lock();

    *plFrequency = m_lFrequency[Index - 1];

    Unlock();

    LOG((TL_TRACE, "get_Frequency - exit - S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCustomTone
// Interface : ITCustomTone
// Method    : put_Frequency
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CCustomTone::put_Frequency( long lFrequency )
{
    LOG((TL_TRACE, "put_Frequency - enter"));

    Lock();

    m_lFrequency = lFrequency;

    Unlock();

    LOG((TL_TRACE, "put_Frequency - exit - S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCustomTone
// Interface : ITCustomTone
// Method    : get_Frequency
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CCustomTone::get_Frequency( long * plFrequency )
{
    LOG((TL_TRACE, "get_Frequency - enter"));

    if ( TAPIIsBadWritePtr( plFrequency, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_Frequency - bad pointer"));

        return E_POINTER;
    }

    Lock();

    *plFrequency = m_lFrequency;

    Unlock();

    LOG((TL_TRACE, "get_Frequency - exit - S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCustomTone
// Interface : ITCustomTone
// Method    : put_CadenceOn
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CCustomTone::put_CadenceOn( long lCadenceOn )
{
    LOG((TL_TRACE, "put_CadenceOn - enter"));

    Lock();

    m_lCadenceOn = lCadenceOn;

    Unlock();

    LOG((TL_TRACE, "put_CadenceOn - exit - S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCustomTone
// Interface : ITCustomTone
// Method    : get_CadenceOn
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CCustomTone::get_CadenceOn( long * plCadenceOn )
{
    LOG((TL_TRACE, "get_CadenceOn - enter"));

    if ( TAPIIsBadWritePtr( plCadenceOn, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_CadenceOn - bad pointer"));

        return E_POINTER;
    }

    Lock();

    *plCadenceOn = m_lCadenceOn;

    Unlock();

    LOG((TL_TRACE, "get_CadenceOn - exit - S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCustomTone
// Interface : ITCustomTone
// Method    : put_CadenceOff
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CCustomTone::put_CadenceOff( long lCadenceOff )
{
    LOG((TL_TRACE, "put_CadenceOff - enter"));

    Lock();

    m_lCadenceOff = lCadenceOff;

    Unlock();

    LOG((TL_TRACE, "put_CadenceOff - exit - S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCustomTone
// Interface : ITCustomTone
// Method    : get_CadenceOff
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CCustomTone::get_CadenceOff( long * plCadenceOff )
{
    LOG((TL_TRACE, "get_CadenceOff - enter"));

    if ( TAPIIsBadWritePtr( plCadenceOff, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_CadenceOff - bad pointer"));

        return E_POINTER;
    }

    Lock();

    *plCadenceOff = m_lCadenceOff;

    Unlock();

    LOG((TL_TRACE, "get_CadenceOff - exit - S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCustomTone
// Interface : ITCustomTone
// Method    : put_Volume
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CCustomTone::put_Volume( long lVolume )
{
    LOG((TL_TRACE, "put_Volume - enter"));

    Lock();

    m_lVolume = lVolume;

    Unlock();

    LOG((TL_TRACE, "put_Volume - exit - S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCustomTone
// Interface : ITCustomTone
// Method    : get_CadenceOff
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CCustomTone::get_Volume( long * plVolume )
{
    LOG((TL_TRACE, "get_Volume - enter"));

    if ( TAPIIsBadWritePtr( plVolume, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_Volume - bad pointer"));

        return E_POINTER;
    }

    Lock();

    *plVolume = m_lVolume;

    Unlock();

    LOG((TL_TRACE, "get_Volume - exit - S_OK"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\callcent.cpp ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    callcent.cpp

Abstract:

    Implementation of the CAll centre interface for TAPI 3.0.
    CTAPI class

Author:

    noela - 11/04/97

Notes:

    optional-notes

Revision History:

--*/


#define UNICODE
#include "stdafx.h"
#include "lmcons.h"

extern CHashTable *    gpAgentHandlerHashTable ;


//
// Tapi 3 requires all of the following proxy requests to be supported (on a line) by an acd proxy before it will 
// create an Agent Handler object for that proxy
//
#define NUMBER_OF_REQUIRED_ACD_PROXYREQUESTS  13
DWORD RequiredACDProxyRequests[NUMBER_OF_REQUIRED_ACD_PROXYREQUESTS] = {
                                      LINEPROXYREQUEST_GETAGENTCAPS,
                                      LINEPROXYREQUEST_CREATEAGENT, 
                                      LINEPROXYREQUEST_SETAGENTMEASUREMENTPERIOD, 
                                      LINEPROXYREQUEST_GETAGENTINFO, 
                                      LINEPROXYREQUEST_CREATEAGENTSESSION, 
                                      LINEPROXYREQUEST_GETAGENTSESSIONLIST, 
                                      LINEPROXYREQUEST_SETAGENTSESSIONSTATE, 
                                      LINEPROXYREQUEST_GETAGENTSESSIONINFO, 
                                      LINEPROXYREQUEST_GETQUEUELIST, 
                                      LINEPROXYREQUEST_SETQUEUEMEASUREMENTPERIOD, 
                                      LINEPROXYREQUEST_GETQUEUEINFO, 
                                      LINEPROXYREQUEST_GETGROUPLIST, 
                                      LINEPROXYREQUEST_SETAGENTSTATEEX};




HRESULT
WaitForReply(
             DWORD
            );



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// handleAgentStatusMessage
//
//      Handles LINE_AGENTSTATUS messages
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void HandleAgentStatusMessage(PASYNCEVENTMSG pParams)
{
    CAgentHandler       * pAgentHandler;
    CAgent              * pAgent;
    HAGENT                hAgent;
    BOOL                  bSuccess;
    AGENT_EVENT           agentEvent;

    bSuccess = FindAgentHandlerObject(
                                (HLINE)(pParams->hDevice),
                                &pAgentHandler
                               );

    if (bSuccess)
    {
        hAgent = (HAGENT)(pParams->Param1);

        bSuccess = pAgentHandler->FindAgentObject(
                                        hAgent,
                                        &pAgent
                                        );

        if (bSuccess)
        {
            if (pParams->Param2 & LINEAGENTSTATUSEX_UPDATEINFO)
            {
                LOG((TL_INFO, "handleAgentStatusMessage - LINEAGENTSTATUSEX_UPDATEINFO"));
                pAgent->SetRequiresUpdate();

            }

            if (pParams->Param2 & LINEAGENTSTATUSEX_STATE)
            {
                LOG((TL_INFO, "handleAgentStatusMessage - LINEAGENTSTATUSEX_STATE"));

                if (pParams->Param3 & LINEAGENTSTATEEX_NOTREADY)
                {
                   agentEvent = AE_NOT_READY;
                   pAgent->SetState(AS_NOT_READY);
                } 
                else if (pParams->Param3 & LINEAGENTSTATEEX_READY)
                {
                   agentEvent = AE_READY;
                   pAgent->SetState(AS_READY);
                }
                else if (pParams->Param3 & LINEAGENTSTATEEX_BUSYACD)
                {
                    agentEvent = AE_BUSY_ACD;
                    pAgent->SetState(AS_BUSY_ACD);
                }
                else if (pParams->Param3 & LINEAGENTSTATEEX_BUSYINCOMING)
                {
                    agentEvent = AE_BUSY_INCOMING;
                    pAgent->SetState(AS_BUSY_INCOMING);
                }
                else if (pParams->Param3 & LINEAGENTSTATEEX_BUSYOUTGOING)
                {
                    agentEvent = AE_BUSY_OUTGOING;
                    pAgent->SetState(AS_BUSY_OUTGOING);
                }
                else if (pParams->Param3 & LINEAGENTSTATEEX_UNKNOWN)
                {
                    agentEvent = AE_UNKNOWN;
                    pAgent->SetState(AS_UNKNOWN);
                }
                else
                {
                    LOG((TL_ERROR, "handleAgentStatusMessage - invalid state %d - setting to AS_UNKNOWN", pParams->Param3));
                    agentEvent = AE_UNKNOWN;
                    pAgent->SetState(AS_UNKNOWN);
                }


	            CAgentEvent::FireEvent(pAgent, agentEvent);

            }
        }
        else
        {
            LOG((TL_ERROR, "handleAgentStatusMessage - can't find agent%d", hAgent));
        }

        // find AH object addrefs the AH, so release it
        pAgentHandler->Release();

    }
    else
    {
        LOG((TL_ERROR, "handleAgentStatusMessage - can't find Agent Handler"));
    }



}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// handleAgentStatusMessage
//
//      Handles LINE_AGENTSESSIONSTATUS messages
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void HandleAgentSessionStatusMessage(PASYNCEVENTMSG pParams)
{
    CAgentHandler       * pAgentHandler;
    CAgentSession       * pAgentSession;
    CAgent              * pAgent = NULL;
    ITAgent             * pITAgent = NULL;
    HAGENTSESSION         hAgentSession;
    BOOL                  bSuccess;
    AGENT_SESSION_EVENT   sessionEvent;

    bSuccess = FindAgentHandlerObject(
                                (HLINE)(pParams->hDevice),
                                &pAgentHandler
                               );

    if (bSuccess)
    {
        hAgentSession = (HAGENTSESSION)(pParams->Param1);

        bSuccess = pAgentHandler->FindSessionObject(
                                        hAgentSession,
                                        &pAgentSession
                                        );
        if (bSuccess)
        {
            if (pParams->Param2 & LINEAGENTSESSIONSTATUS_UPDATEINFO)
            {
                LOG((TL_INFO, "handleAgentSessionStatusMessage - LINEAGENTSESSIONSTATUS_UPDATEINFO"));
                pAgentSession->SetRequiresUpdate();
            }

            if (pParams->Param2 & LINEAGENTSESSIONSTATUS_STATE)
            {

                LOG((TL_INFO, "handleAgentSessionStatusMessage - LINEAGENTSESSIONSTATUS_STATE"));
                if (pParams->Param3 & LINEAGENTSESSIONSTATE_NOTREADY)
                {
                   sessionEvent = ASE_NOT_READY;
                   pAgentSession->SetState(ASST_NOT_READY);
                }
                else if (pParams->Param3 & LINEAGENTSESSIONSTATE_READY)
                {
                   sessionEvent = ASE_READY;
                   pAgentSession->SetState(ASST_READY);
                }
                else if (pParams->Param3 & LINEAGENTSESSIONSTATE_BUSYONCALL)
                {
                    sessionEvent = ASE_BUSY;
                    pAgentSession->SetState(ASST_BUSY_ON_CALL);
                }
                else if (pParams->Param3 & LINEAGENTSESSIONSTATE_BUSYWRAPUP)
                {
                    sessionEvent = ASE_WRAPUP;
                    pAgentSession->SetState(ASST_BUSY_WRAPUP);
                }
                else if (pParams->Param3 & LINEAGENTSESSIONSTATE_ENDED)
                {
                    sessionEvent = ASE_END;
                    pAgentSession->SetState(ASST_SESSION_ENDED);
                }
                else
                {
                    LOG((TL_ERROR, "handleAgentSessionStatusMessage - invalid state %d - setting to ASST_NOT_READY", pParams->Param3));
                    sessionEvent = ASE_NOT_READY;
                    pAgentSession->SetState(ASST_NOT_READY);
                }

                CAgentSessionEvent::FireEvent(pAgentSession, sessionEvent);

            }
        }
        else
        {
            LOG((TL_ERROR, "handleAgentSessionStatusMessage - can't find session %d", hAgentSession));
        }

        // find AH object addrefs the AH, so release it
        pAgentHandler->Release();

    }
    else
    {
        LOG((TL_ERROR, "handleAgentSessionStatusMessage - can't find Agent Handler"));
    }


}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// handleAgentStatusMessage
//
//      Handles LINE_QUEUESTATUS messages
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void HandleQueueStatusMessage(PASYNCEVENTMSG pParams)
{
    CAgentHandler       * pAgentHandler;
    CQueue              * pQueue;
    DWORD                 dwQueueID;
    BOOL                  bSuccess;

    bSuccess = FindAgentHandlerObject(
                                (HLINE)(pParams->hDevice),
                                &pAgentHandler
                               );

    if (bSuccess)
    {
        dwQueueID = (DWORD)(pParams->Param1);

        bSuccess = pAgentHandler->FindQueueObject(
                                        dwQueueID,
                                        &pQueue
                                        );
        if (bSuccess)
        {
            if (pParams->Param2 & LINEQUEUESTATUS_UPDATEINFO)
            {
                LOG((TL_INFO, "handleQueueStatusMessage - LINEQUEUESTATUS_UPDATEINFO"));
                pQueue->SetRequiresUpdate();
            }

        }
        else
        {
            LOG((TL_ERROR, "handleQueueStatusMessage - can't find Queue %d", dwQueueID));
        }

        // find AH object addrefs the AH, so release it
        pAgentHandler->Release();

    }
    else
    {
        LOG((TL_ERROR, "handleQueueStatusMessage - can't find Agent Handler"));
    }

}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// handleGroupStatusMessage
//
//      Handles LINE_GROUPSTATUS messages
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void handleGroupStatusMessage(PASYNCEVENTMSG pParams)
{
    if (pParams->Param2 & LINEGROUPSTATUS_NEWGROUP)
    {
        LOG((TL_INFO, "handleGroupStatusMessage - LINEGROUPSTATUS_NEWGROUP"));
    }
    else if (pParams->Param2 & LINEGROUPSTATUS_GROUPREMOVED)
    {
        LOG((TL_INFO, "handleGroupStatusMessage - LINEGROUPSTATUS_GROUPREMOVED"));
    }
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// handleProxyStatusMessage
//
//      Handles LINE_PROXYSTATUS messages
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void handleProxyStatusMessage( CTAPI * pTapi, PASYNCEVENTMSG pParams)
{
    HRESULT hr;

    LOG((TL_INFO, "handleProxyStatusMessage - message %02X %02X %02X", pParams->Param1, pParams->Param2, pParams->Param3));
    
    if (pParams->Param1 & LINEPROXYSTATUS_OPEN)
    {
        LOG((TL_INFO, "handleProxyStatusMessage - LINEPROXYSTATUS_OPEN %02X", pParams->Param2));
    }
    else if (pParams->Param1 & LINEPROXYSTATUS_CLOSE)
    {

        LOG((TL_INFO, "handleProxyStatusMessage - LINEPROXYSTATUS_CLOSE %02X", pParams->Param2));
    }
    else
    {
        LOG((TL_INFO, "handleProxyStatusMessage - Unknown message"));
        return;
    }

    hr = pTapi->UpdateAgentHandlerArray();
    
    if (SUCCEEDED(hr))
    {
        LOG((TL_INFO, "handleProxyStatusMessage - UpdateAgentHandlerArray successfully"));
    }
    else
    {
        LOG((TL_ERROR, "handleProxyStatusMessage - UpdateAgentHandlerArray unsuccessfully"));
    }
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// MyBasicCallControlQI
//      don't give out the basiccallcontrol interface
//      if the application does not own the call
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
WINAPI
MyCallCenterQI(void* pvClassObject, REFIID riid, LPVOID* ppv, DWORD_PTR dw)
{
    HRESULT hr = S_FALSE;
    LOG((TL_TRACE, "MyCallCenterQI - enter"));


    ((CTAPI *)pvClassObject)->UpdateAgentHandlerArray();


    //
    // S_FALSE tells atl to continue querying for the interface
    //

    LOG((TL_TRACE, hr, "MyCallCenterQI - exit"));
    return hr;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Method    : CheckForRequiredProxyRequests
//
//  Must find a match for every type (S_OK) or returns E_FAIL 
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CheckForRequiredProxyRequests( HLINEAPP hLineApp, DWORD dwDeviceID)
{
    HRESULT                 hr = S_OK;
    LPLINEPROXYREQUESTLIST  pLineProxyRequestList;
    DWORD                   i, j;
    LPDWORD                 pProxyListEntry;
    BOOL                    bFoundAMatch;


    
    LOG((TL_TRACE, "CheckForRequiredProxyRequests - enter"));


    hr = LineGetProxyStatus(hLineApp, dwDeviceID, TAPI_CURRENT_VERSION, &pLineProxyRequestList );

    if( SUCCEEDED(hr) )
    {
        // check for all required types
        for(i=0; i!= NUMBER_OF_REQUIRED_ACD_PROXYREQUESTS; i++)
        {
            
            bFoundAMatch = FALSE;
            pProxyListEntry = (LPDWORD) (  (LPBYTE)pLineProxyRequestList + pLineProxyRequestList->dwListOffset );

            for(j=0; j!= pLineProxyRequestList->dwNumEntries; j++)
            {
                if ( RequiredACDProxyRequests[i] == *pProxyListEntry++)
                {
                    bFoundAMatch = TRUE;
                    break;
                }
                
            }
            
            if(bFoundAMatch == FALSE)
            {
                LOG((TL_ERROR, "CheckForRequiredProxyRequests - no proxy of type %02X", RequiredACDProxyRequests[i]));
                hr = E_FAIL;    
            }

        }

    }
    else // LineGetProxyStatus failed
    {
        LOG((TL_ERROR, "CheckForRequiredProxyRequests - LineGetProxyStatus failed"));
        hr = E_FAIL;
    }

    // finished with memory block so release
    if ( pLineProxyRequestList != NULL )
    {
        ClientFree( pLineProxyRequestList );
    }


    LOG((TL_TRACE, hr, "CheckForRequiredProxyRequests - exit"));
    return hr ;
}
        


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CTAPI
// Method    : UpdateAgentHandlerArray
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CTAPI::UpdateAgentHandlerArray()
{
    HRESULT             hr = S_OK;
    LPLINEAGENTCAPS     pAgentCaps = NULL;
    GUID                proxyGUID;
    PWSTR               proxyName = NULL;
    BOOL                foundIt;
    CAgentHandler     * thisAgentHandler = NULL;
    CAddress          * pCAddress = NULL;
    int                 iCount, iCount2;
    AgentHandlerArray   activeAgentHandlerArray;

    LOG((TL_TRACE, "UpdateAgentHandlerArray - enter"));

    Lock();
    
    if (!( m_dwFlags & TAPIFLAG_INITIALIZED ) )
    {
        LOG((TL_ERROR, "UpdateAgentHandlerArray - tapi object must be initialized first" ));

        Unlock();
        
        return E_INVALIDARG;
    }

    Unlock();


    //
    // go through all the addresses
    //
    for ( iCount = 0; iCount < m_AddressArray.GetSize(); iCount++ )
    {
        pCAddress = dynamic_cast<CAddress *>(m_AddressArray[iCount]);

        if ( (pCAddress != NULL) && (pCAddress->GetAPIVersion() >= TAPI_VERSION2_2) )
        {
            hr = CheckForRequiredProxyRequests(
                                               pCAddress->GetHLineApp(),
                                               pCAddress->GetDeviceID() 
                                              );
        }
        else
        {
            hr = E_FAIL;
        }

        if( SUCCEEDED(hr) )
        {
            // Call LineGetAgentCaps to get proxy name & GUID
            hr = LineGetAgentCaps(
                             pCAddress->GetHLineApp(),
                             pCAddress->GetDeviceID(),
                             pCAddress->GetAddressID(),
                             TAPI_CURRENT_VERSION,
                             &pAgentCaps
                             );
            LOG((TL_TRACE, hr, "UpdateAgentHandlerArray - LineGetAgentCaps")); 
            if( SUCCEEDED(hr) )
            {
                // Get the proxy apps name string & GUID
                proxyName = (PWSTR)( (PBYTE)pAgentCaps + pAgentCaps->dwAgentHandlerInfoOffset);
                proxyGUID = pAgentCaps->ProxyGUID;
#if DBG
                {
                    WCHAR guidName[100];

                    StringFromGUID2(proxyGUID, (LPOLESTR)&guidName, 100);
                    LOG((TL_INFO, "UpdateAgentHandlerArray - Proxy Name : %S", proxyName));
                    LOG((TL_INFO, "UpdateAgentHandlerArray - Proxy GUID   %S", guidName));
                }
#endif

                // Run through the list of AgentHandlers & see if we already have this one in the list
                // by comparing GUIDs
                foundIt = FALSE;
                
                Lock();

                for (iCount2 = 0; iCount2 < m_AgentHandlerArray.GetSize(); iCount2++ )
                {
                    thisAgentHandler = dynamic_cast<CComObject<CAgentHandler>*>(m_AgentHandlerArray[iCount2]);
                    
                    if (thisAgentHandler != NULL)
                    {
                        if ( IsEqualGUID(proxyGUID , thisAgentHandler->getHandle() ) )
                        {
                            foundIt = TRUE;
                            activeAgentHandlerArray.Add(m_AgentHandlerArray[iCount2]);
                            break;
                        }
                    }
                }
                Unlock();

                if (foundIt == FALSE)
                {
                    // Didn't match so lets add this AgentHandler
                    LOG((TL_INFO, "UpdateAgentHandlerArray - create new Agent Handler" ));
                                                                                                           
                    CComObject<CAgentHandler> * pAgentHandler;
                    hr = CComObject<CAgentHandler>::CreateInstance( &pAgentHandler );
                    if( SUCCEEDED(hr) )
                    {
                        Lock();
                        // initialize the AgentHandler
                        hr = pAgentHandler->Initialize(proxyName, proxyGUID, this);
                        if( SUCCEEDED(hr) )
                        {
                            ITAgentHandler * pITAgentHandler;

                            pITAgentHandler = dynamic_cast<ITAgentHandler *>(pAgentHandler);

                            if ( NULL != pITAgentHandler )
                            {
                                // add to list of Agent handlers
                                m_AgentHandlerArray.Add(pITAgentHandler);
                                //pAgentHandler->AddRef();
                                activeAgentHandlerArray.Add(pITAgentHandler);
                            }

                            LOG((TL_INFO, "UpdateAgentHandlerArray - Added AgentHandler to list"));

                            //  Now add this address to the Agent Handlers list
                            pAgentHandler->AddAddress(pCAddress);

                        }
                        else
                        {
                            LOG((TL_ERROR, "UpdateAgentHandlerArray - Initialize AgentHandler failed" ));
                            delete pAgentHandler;
                        }
                        Unlock();
                    }
                    else
                    {
                        LOG((TL_ERROR, "UpdateAgentHandlerArray - Create AgentHandler failed" ));
                    }
                }
                else // foundIt == TRUE
                {
                    LOG((TL_INFO, "UpdateAgentHandlerArray - Agent Handler exists for this proxy" ));
                    //  So just add this address to the Agent Handlers list
                    thisAgentHandler->AddAddress(pCAddress);
                }
            }
            else  // LineGetAgentCaps  failed
            {
                LOG((TL_ERROR, "UpdateAgentHandlerArray - LineGetAgentCaps failed"));
            }

            // finished with memory block so release
            if ( pAgentCaps != NULL )
                ClientFree( pAgentCaps );
        }
        else
        {
            LOG((TL_INFO, hr, "UpdateAgentHandlerArray - CheckForRequiredProxyRequests failed"));
        }
    } // end - for ( ; iterAddr..... )

    Lock();
    for (iCount=m_AgentHandlerArray.GetSize()-1; iCount>=0; iCount--) 
    {
        if (-1 == activeAgentHandlerArray.Find(m_AgentHandlerArray[iCount])) //no longer active
        {
            HRESULT     hr1;
            BSTR        pszAgentHandlerName;
            thisAgentHandler = dynamic_cast<CComObject<CAgentHandler>*>(m_AgentHandlerArray[iCount]);
            hr1 = thisAgentHandler->get_Name(&pszAgentHandlerName);
            m_AgentHandlerArray.RemoveAt(iCount);
            if ( SUCCEEDED(hr1) )
            {
                LOG((TL_TRACE, "UpdateAgentHandlerArray - Removing one AgentHandler %s from AgentHandlerTable",
                    pszAgentHandlerName));
                if ( NULL != pszAgentHandlerName)
                    SysFreeString(pszAgentHandlerName);
            }
            else
            {
                LOG((TL_TRACE, "UpdateAgentHandlerArray - Removing one AgentHandler from AgentHandlerTable"));
            }
        }
    }
    Unlock();

    activeAgentHandlerArray.Shutdown();

    hr = S_OK;
    LOG((TL_TRACE, hr, "UpdateAgentHandlerArray - exit"));
    return hr;
}



/////////////////////////////////////////////////////////////////////////////
// ITTAPICallCenter



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CTAPI
// Interface : ITTAPICallCenter
// Method    : EnumerateAgentHandlers
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CTAPI::EnumerateAgentHandlers(IEnumAgentHandler ** ppEnumAgentHandler)
{
    HRESULT     hr = S_OK;

    LOG((TL_TRACE, "EnumerateAgentHandlers - enter"));

    Lock();
    
    if (!( m_dwFlags & TAPIFLAG_INITIALIZED ) )
    {
        LOG((TL_ERROR, "EnumerateAgentHandlers - tapi object must be initialized first" ));

        Unlock();
        
        return E_INVALIDARG;
    }

    Unlock();

    if(!TAPIIsBadWritePtr( ppEnumAgentHandler, sizeof(IEnumAgentHandler *) ) )
    {
        UpdateAgentHandlerArray();

        //
        // create the enumerator
        //
        CComObject< CTapiEnum<IEnumAgentHandler,
                    ITAgentHandler,
                    &IID_IEnumAgentHandler> > * pEnum;
        
        hr = CComObject< CTapiEnum<IEnumAgentHandler,
                         ITAgentHandler,
                         &IID_IEnumAgentHandler> > ::CreateInstance( &pEnum );
        
        if ( SUCCEEDED(hr) )
        {
            //
            // initialize it with our queue list
            //
            Lock();
            
            hr = pEnum->Initialize( m_AgentHandlerArray );
            
            Unlock();
            
            if ( SUCCEEDED(hr) )
            {
                // return it
                *ppEnumAgentHandler = pEnum;
            }
            else
            {
                LOG((TL_ERROR, "EnumerateAgentHandlers - could not initialize enum" ));
                pEnum->Release();
            }
        }
        else
        {
            LOG((TL_ERROR, "EnumerateAgentHandlers - could not create enum" ));
        }
    }
    else
    {
        LOG((TL_ERROR, "EnumerateAgentHandlers - bad ppEnumAgentHandler pointer" ));
        hr = E_POINTER;
    }

    LOG((TL_TRACE, hr, "EnumerateAgentHandlers - exit"));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CTAPI
// Interface : ITTAPICallCenter
// Method    : get_AgentHandlers
//
// Return a collection of AgentHandlers
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CTAPI::get_AgentHandlers(VARIANT  * pVariant)
{
    HRESULT         hr = S_OK;
    IDispatch     * pDisp = NULL;


    LOG((TL_TRACE, "get_AgentHandlers - enter"));

    Lock();
    
    if (!( m_dwFlags & TAPIFLAG_INITIALIZED ) )
    {
        LOG((TL_ERROR, "get_AgentHandlers - tapi object must be initialized first" ));

        Unlock();
        
        return E_INVALIDARG;
    }

    Unlock();

    if (!TAPIIsBadWritePtr( pVariant, sizeof(VARIANT) ) )
    {
        UpdateAgentHandlerArray();
        
        //
        // create the collection
        //
        CComObject< CTapiCollection< ITAgentHandler > > * p;
        hr = CComObject< CTapiCollection< ITAgentHandler > >::CreateInstance( &p );
        
        if (SUCCEEDED(hr) )
        {
            // initialize it with our address list
            Lock();
            
            hr = p->Initialize( m_AgentHandlerArray );
            
            Unlock();
        
            if ( SUCCEEDED(hr) )
            {
                // get the IDispatch interface
                hr = p->_InternalQueryInterface( IID_IDispatch, (void **) &pDisp );
            
                if ( SUCCEEDED(hr) )
                {
                    // put it in the variant
                    VariantInit(pVariant);
                    pVariant->vt = VT_DISPATCH;
                    pVariant->pdispVal = pDisp;
                }
                else
                {
                    LOG((TL_ERROR, "get_AgentHandlers - could not get IDispatch interface" ));
                    delete p;
                }
            }
            else
            {
                LOG((TL_ERROR, "get_AgentHandlers - could not initialize collection" ));
                delete p;
            }
        }
        else
        {
            LOG((TL_ERROR, "get_AgentHandlers - could not create collection" ));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_AgentHandlers - bad pVariant pointer" ));
        hr = E_POINTER;
    }


    LOG((TL_TRACE, hr, "get_AgentHandlers - exit"));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\callevnt.cpp ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    callevnt.cpp

Abstract:

    Implementation of the Call events for TAPI 3.0.

Author:

    mquinton - 9/4/98

Notes:


Revision History:

--*/

#include "stdafx.h"


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CCallStateEvent -
//          implementation of the ITCallStateEvent interface
//          This object is given to applications for call state events
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CCallStateEvent::FireEvent
//      static function to create and fire a new CCallStateEvent
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CCallStateEvent::FireEvent(
                           ITCallInfo * pCall,
                           CALL_STATE  state,
                           CALL_STATE_EVENT_CAUSE cause,
                           CTAPI * pTapi,
                           long lCallbackInstance
                          )
{
    CComObject< CCallStateEvent > * p;
    IDispatch                     * pDisp;
    HRESULT                         hr;
    CCall                         * pCCall;

    
    STATICLOG((TL_TRACE, "Create - enter" ));
    STATICLOG((TL_INFO, "     CallState -------------> %d", state ));
    STATICLOG((TL_INFO, "     CallStateEventCause ---> %d", cause ));

    pCCall = dynamic_cast<CComObject<CCall>*>(pCall);
    
    if (NULL == pCCall)
    {
        STATICLOG((TL_ERROR, "FireEvent - bad call pointer" ));
        return E_FAIL;
    }

    if( pCCall->DontExpose())
    {
        STATICLOG((TL_INFO, "FireEvent - Don't expose this call %p", pCCall));
        return S_OK;
    }

    //
    // Check the event filter mask
    // This event is not filtered by TapiSrv because is
    // related with TE_CALLSTATE.
    //

    DWORD dwEventFilterMask = 0;
    dwEventFilterMask = pCCall->GetSubEventsMask( TE_CALLSTATE );
    STATICLOG((TL_INFO, "     CallStateEventMask ---> %ld", dwEventFilterMask ));

    if( !( dwEventFilterMask & GET_SUBEVENT_FLAG(state)))
    {
        STATICLOG((TL_WARN, "FireEvent - filtering out this event [%lx]", cause));
        return S_OK;
    }

    //
    // create the event object
    //
    CComObject< CCallStateEvent >::CreateInstance( &p );

    if (NULL == p)
    {
        STATICLOG((TL_ERROR, "FireEvent - could not createinstance" ));
        return E_OUTOFMEMORY;
    }

    //
    // save info
    //
    p->m_pCall = pCall;
    pCall->AddRef();
    p->m_CallState = state;
    p->m_CallStateEventCause = cause;
    p->m_lCallbackInstance = lCallbackInstance;
#if DBG
    p->m_pDebug = (PWSTR) ClientAlloc( 1 );
#endif

    //
    // get the dispatch interface
    //
    hr = p->_InternalQueryInterface( IID_IDispatch, (void **)&pDisp );

    if (!SUCCEEDED(hr))
    {
        delete p;
        STATICLOG((TL_ERROR, "CallStateEvent - could not get IDispatch %lx", hr));

        return hr;
    }

    //
    // fire the event
    //
    pTapi->Event(
                 TE_CALLSTATE,
                 pDisp
                );

    //
    // release our reference
    //
    pDisp->Release();
    
    STATICLOG((TL_TRACE, "FireEvent - exit - returing SUCCESS" ));

    
    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  FinalRelease
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void
CCallStateEvent::FinalRelease()
{
    m_pCall->Release();

#if DBG
    ClientFree( m_pDebug );
#endif
}


// ITCallStateEvent methods

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Call
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CCallStateEvent::get_Call(
                          ITCallInfo ** ppCallInfo
                         )
{
    HRESULT hr = S_OK;

    LOG((TL_TRACE, "get_Call - enter" ));
    LOG((TL_TRACE, "     ppCallInfo ---> %p", ppCallInfo ));

    if (TAPIIsBadWritePtr( ppCallInfo, sizeof( ITCallInfo * ) ) )
    {
        LOG((TL_ERROR, "get_Call - bad pointer"));

        return E_POINTER;
    }

    *ppCallInfo = m_pCall;

    m_pCall->AddRef();

    LOG((TL_TRACE, "get_Call - exit - returing %lx", hr ));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_State
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CCallStateEvent::get_State(
                           CALL_STATE * pCallState
                          )
{
    HRESULT hr = S_OK;

    LOG((TL_TRACE, "get_State - enter" ));
    LOG((TL_TRACE, "     pCallState ---> %p", pCallState ));

    if (TAPIIsBadWritePtr( pCallState, sizeof(CALL_STATE) ) )
    {
        LOG((TL_ERROR, "get_State - bad pointer"));

        return E_POINTER;
    }
    
    *pCallState = m_CallState;

    LOG((TL_TRACE, "get_State - exit - returing %lx", hr ));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Cause
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CCallStateEvent::get_Cause(
                           CALL_STATE_EVENT_CAUSE * pCEC
                          )
{
    HRESULT hr = S_OK;

    LOG((TL_TRACE, "get_Cause - enter" ));
    LOG((TL_TRACE, "     pCEC ---> %p", pCEC ));

    if (TAPIIsBadWritePtr( pCEC, sizeof( CALL_STATE_EVENT_CAUSE ) ) )
    {
        LOG((TL_ERROR, "get_Cause - bad pointer"));

        return E_POINTER;
    }

    *pCEC = m_CallStateEventCause;

    LOG((TL_TRACE, "get_Cause - exit - returning %lx", hr ));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_callbackinstance
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CCallStateEvent::get_CallbackInstance(
                                      long * plCallbackInstance
                                     )
{
    HRESULT             hr = S_OK;

    if (TAPIIsBadWritePtr( plCallbackInstance, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_CallbackInstance - bad pointer"));

        return E_POINTER;
    }
                
    *plCallbackInstance = m_lCallbackInstance;

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CCallNotificationEvent
//          Implements the ITCallNotificationEvent interface
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// FireEvent
//
//      Creates and fires a ITCallNotificationEvent object
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT
CCallNotificationEvent::FireEvent(
                                  ITCallInfo * pCall,
                                  CALL_NOTIFICATION_EVENT CallNotificationEvent,
                                  CTAPI * pTapi,
                                  long lCallbackInstance
                                 )
{
    CComObject< CCallNotificationEvent > * p;
    IDispatch                     * pDisp;
    HRESULT                         hr;
    CCall                         * pCCall;

    
    STATICLOG((TL_TRACE, "FireEvent - enter" ));
    STATICLOG((TL_INFO, "     CallNotification -------------> %d", CallNotificationEvent ));

    pCCall = dynamic_cast<CComObject<CCall>*>(pCall);
    if (NULL == pCCall)
    {
        STATICLOG((TL_ERROR, "FireEvent - bad call pointer" ));
        return E_FAIL;
    }

    if( pCCall->DontExpose())
    {
        STATICLOG((TL_INFO, "FireEvent - Don't expose this  call %p", pCCall));
        return S_OK;
    }

    //
    // Check the event filter mask
    // This event is not filtered by TapiSrv because is
    // related with TE_CALLSTATE.
    //

    DWORD dwEventFilterMask = 0;
    dwEventFilterMask = pCCall->GetSubEventsMask( TE_CALLNOTIFICATION );
    if( !( dwEventFilterMask & GET_SUBEVENT_FLAG(CallNotificationEvent)))
    {
        STATICLOG((TL_WARN, "FireEvent - filtering out this event [%lx]", CallNotificationEvent));
        return S_OK;
    }


    //
    // create the event object
    //
    CComObject< CCallNotificationEvent >::CreateInstance( &p );

    if (NULL == p)
    {
        STATICLOG((TL_ERROR, "FireEvent - could not createinstance" ));
        return E_OUTOFMEMORY;
    }

    //
    // save info
    //
    p->m_pCall = pCall;
    pCall->AddRef();
    p->m_CallNotificationEvent = CallNotificationEvent;
    p->m_lCallbackInstance = lCallbackInstance;
#if DBG
    p->m_pDebug = (PWSTR) ClientAlloc( 1 );
#endif

    //
    // get the dispatch interface
    //
    hr = p->_InternalQueryInterface( IID_IDispatch, (void **)&pDisp );

    if (!SUCCEEDED(hr))
    {
        delete p;
        STATICLOG((TL_ERROR, "CallNotificationEvent - could not get IDispatch %lx", hr));

        return hr;
    }

    //
    // fire the event
    //
    pTapi->Event(
                 TE_CALLNOTIFICATION,
                 pDisp
                );


    //
    // release our reference
    //
    pDisp->Release();
    
    STATICLOG((TL_TRACE, "FireEvent - exit - returing SUCCESS" ));

    
    return S_OK;
    
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// finalrelease
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void
CCallNotificationEvent::FinalRelease()
{
    LOG((TL_INFO, "CallNotificationEvent - FinalRelease"));
    m_pCall->Release();

#if DBG
    ClientFree( m_pDebug );
#endif
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_call
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CCallNotificationEvent::get_Call(
                                 ITCallInfo ** ppCall
                                )
{
    HRESULT             hr = S_OK;

    if (TAPIIsBadWritePtr( ppCall, sizeof( ITCallInfo *) ) )
    {
        LOG((TL_ERROR, "get_Call - bad pointer"));

        return E_POINTER;
    }
    
    *ppCall = m_pCall;
    (*ppCall)->AddRef();

    return hr;
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Event
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CCallNotificationEvent::get_Event(
                                  CALL_NOTIFICATION_EVENT * pCallNotificationEvent
                                 )
{
    HRESULT             hr = S_OK;

    if (TAPIIsBadWritePtr(pCallNotificationEvent, sizeof(CALL_NOTIFICATION_EVENT) ) )
    {
        LOG((TL_ERROR, "get_Event - bad pointer"));

        return E_POINTER;
    }
    
    *pCallNotificationEvent = m_CallNotificationEvent;

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_callbackinstance
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CCallNotificationEvent::get_CallbackInstance(
                                             long * plCallbackInstance
                                            )
{
    HRESULT             hr = S_OK;

    if (TAPIIsBadWritePtr( plCallbackInstance, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_CallbackInstance bad pointer"));

        return E_POINTER;
    }
    
    *plCallbackInstance = m_lCallbackInstance;

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CQOSEvent::FireEvent
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CQOSEvent::FireEvent(
                     ITCallInfo * pCall,
                     QOS_EVENT QosEvent,
                     long lMediaMode,
                     CTAPI * pTapi
                    )
{
    CComObject<CQOSEvent> * p;
    HRESULT                 hr = S_OK;
    IDispatch *             pDisp;
    CCall                 * pCCall;

    //
    // We don't need to filter the event because it's already done
    // by TapiSrv
    //

    pCCall = dynamic_cast<CComObject<CCall>*>(pCall);

    if (NULL == pCCall)
    {
        STATICLOG((TL_ERROR, "FireEvent - bad call pointer" ));
        return E_FAIL;
    }

    if( pCCall->DontExpose())
    {
        STATICLOG((TL_INFO, "FireEvent - Don't expose this  call %p", pCCall));
        return S_OK;
    }

    CComObject< CQOSEvent >::CreateInstance( &p );

    if (NULL == p)
    {
        STATICLOG((TL_ERROR, "FireEvent - could not createinstance" ));
        return E_OUTOFMEMORY;
    }

    //
    // save info
    //
    p->m_pCall = pCall;
    pCall->AddRef();

    p->m_QosEvent = QosEvent;
    p->m_lMediaMode = lMediaMode;

    //
    // get the dispatch interface
    //
    hr = p->_InternalQueryInterface( IID_IDispatch, (void **)&pDisp );

    if (!SUCCEEDED(hr))
    {
        delete p;
        STATICLOG((TL_ERROR, "CallStateEvent - could not get IDispatch %lx", hr));

        return hr;
    }

    //
    // fire the event
    //
    pTapi->Event(
                 TE_QOSEVENT,
                 pDisp
                );

    //
    // release our reference
    //
    pDisp->Release();
    
    STATICLOG((TL_TRACE, "FireEvent - exit - returing SUCCESS" ));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CQOSEvent::get_Call
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CQOSEvent::get_Call(
                    ITCallInfo ** ppCall
                   )
{
    if ( TAPIIsBadWritePtr( ppCall, sizeof (ITCallInfo *) ) )
    {
        LOG((TL_ERROR, "get_Call - bad pointer"));

        return E_POINTER;
    }
    
    *ppCall = m_pCall;

    m_pCall->AddRef();
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CQOSEvent::get_Event
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CQOSEvent::get_Event(
                     QOS_EVENT * pQosEvent
                     )
{
    if ( TAPIIsBadWritePtr( pQosEvent, sizeof( QOS_EVENT ) ) )
    {
        LOG((TL_ERROR, "get_Event - bad pointer"));

        return E_POINTER;
    }
    
    *pQosEvent = m_QosEvent;

    return S_OK;
            
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CQOSEvent::get_MediaType
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CQOSEvent::get_MediaType(
                         long * plMediaMode
                        )
{
    if ( TAPIIsBadWritePtr( plMediaMode, sizeof( long ) ) )
    {
        LOG((TL_ERROR, "get_MediaMode - bad pointer"));

        return E_POINTER;
    }
    
    *plMediaMode = m_lMediaMode;

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CQOSEvent::FinalRelease
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CQOSEvent::FinalRelease()
{
    m_pCall->Release();
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CCall::CallInfoChangeEvent
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCall::CallInfoChangeEvent( CALLINFOCHANGE_CAUSE cic )
{
    if ( DontExpose() )
    {
        return S_OK;
    }
    
    if (NULL != m_pAddress)
    {
        return CCallInfoChangeEvent::FireEvent(
                                               this,
                                               cic,
                                               m_pAddress->GetTapi(),
                                               (m_pAddressLine)?(m_pAddressLine->lCallbackInstance):0
                                              );
    }
    else
    {
        return E_FAIL;
    }
}
    
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CCallInfoChangeEvent::FireEvent
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCallInfoChangeEvent::FireEvent(
                                ITCallInfo * pCall,
                                CALLINFOCHANGE_CAUSE Cause,
                                CTAPI * pTapi,
                                long lCallbackInstance
                               )
{
    HRESULT                                 hr = S_OK;
    CComObject<CCallInfoChangeEvent>      * p;
    IDispatch                             * pDisp;
    CCall                                 * pCCall;

    
    pCCall = dynamic_cast<CComObject<CCall>*>(pCall);
    
    if (NULL == pCCall)
    {
        STATICLOG((TL_ERROR, "FireEvent - bad call pointer" ));
        return E_FAIL;
    }

    if( pCCall->DontExpose())
    {
        STATICLOG((TL_INFO, "FireEvent - Don't expose this call %p", pCCall));
        return S_OK;
    }

    //
    // Check the event filter mask
    // This event is not filtered by TapiSrv because is
    // related with TE_CALLSTATE.
    //

    DWORD dwEventFilterMask = 0;
    dwEventFilterMask = pCCall->GetSubEventsMask( TE_CALLINFOCHANGE );
    STATICLOG((TL_INFO, "     CallInfochangeEventMask ---> %ld", dwEventFilterMask ));

    if( !( dwEventFilterMask & GET_SUBEVENT_FLAG(Cause)))
    {
        STATICLOG((TL_WARN, "FireEvent - filtering out this event [%lx]", Cause));
        return S_OK;
    }

    //
    // create event
    //
    hr = CComObject<CCallInfoChangeEvent>::CreateInstance( &p );

    if ( !SUCCEEDED(hr) )
    {
        STATICLOG((TL_ERROR, "Could not create CallInfoStateChange object - %lx", hr));
        return hr;
    }

    //
    // initialize
    //
    p->m_Cause = Cause;
    p->m_pCall = pCall;
    p->m_pCall->AddRef();
    p->m_lCallbackInstance = lCallbackInstance;
    
#if DBG
    p->m_pDebug = (PWSTR) ClientAlloc( 1 );
#endif

    //
    // get idisp interface
    //
    hr = p->QueryInterface(
                           IID_IDispatch,
                           (void **)&pDisp
                          );

    if ( !SUCCEEDED(hr) )
    {
        STATICLOG((TL_ERROR, "Could not get disp interface of CallInfoStateChange object %lx", hr));
        
        delete p;
        
        return hr;
    }

    //
    // fire event
    //
    pTapi->Event(
                 TE_CALLINFOCHANGE,
                 pDisp
                );

    //
    // release stuff
    //
    pDisp->Release();
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CCallInfoChangeEvent::FinalRelease
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CCallInfoChangeEvent::FinalRelease()
{
    m_pCall->Release();

#if DBG
   ClientFree( m_pDebug );
#endif
   
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CCallInfoChangeEvent::get_Call
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCallInfoChangeEvent::get_Call( ITCallInfo ** ppCallInfo)
{
    if ( TAPIIsBadWritePtr( ppCallInfo, sizeof (ITCallInfo *) ) )
    {
        return E_POINTER;
    }

    m_pCall->QueryInterface(
                            IID_ITCallInfo,
                            (void **) ppCallInfo
                           );

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CCallInfoChangeEvent::get_Cause
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCallInfoChangeEvent::get_Cause( CALLINFOCHANGE_CAUSE * pCallInfoChangeCause )
{
    if ( TAPIIsBadWritePtr( pCallInfoChangeCause, sizeof (CALLINFOCHANGE_CAUSE) ) )
    {
        return E_POINTER;
    }

    *pCallInfoChangeCause = m_Cause;

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CCallInfoChangeEvent::get_CallbackInstance
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCallInfoChangeEvent::get_CallbackInstance( long * plCallbackInstance )
{
    if ( TAPIIsBadWritePtr( plCallbackInstance, sizeof(long) ) ) 
    {
        return E_POINTER;
    }

    *plCallbackInstance = m_lCallbackInstance;

    return S_OK;
}



HRESULT
CCallMediaEvent::FireEvent(
                           ITCallInfo * pCall,
                           CALL_MEDIA_EVENT Event,
                           CALL_MEDIA_EVENT_CAUSE Cause,
                           CTAPI * pTapi,
                           ITTerminal * pTerminal,
                           ITStream * pStream,
                           HRESULT hrEvent
                          )
{
    CComObject< CCallMediaEvent > * p;
    IDispatch                     * pDisp;
    HRESULT                         hr;
    CCall                         * pCCall;

    
    STATICLOG((TL_TRACE, "FireEvent - enter" ));

    pCCall = dynamic_cast<CComObject<CCall>*>(pCall);
    
    if (NULL == pCCall)
    {
        STATICLOG((TL_ERROR, "FireEvent - bad call pointer" ));
        return E_FAIL;
    }

    if( pCCall->DontExpose())
    {
        STATICLOG((TL_INFO, "FireEvent - Don't expose this call %p", pCCall));
        return S_OK;
    }

    //
    // Check the event filter mask
    // These is a MSP event and it is not filter
    // by TapiSrv
    //

    DWORD dwEventFilterMask = 0;
    dwEventFilterMask = pCCall->GetSubEventsMask( TE_CALLMEDIA );
    if( !( dwEventFilterMask & GET_SUBEVENT_FLAG(Event)))
    {
        STATICLOG((TL_ERROR, "FireEvent exit - "
            "This event is filtered - %lx", Event));
        return S_OK;
    }

    //
    // create the event object
    //
    CComObject< CCallMediaEvent >::CreateInstance( &p );

    if (NULL == p)
    {
        STATICLOG((TL_ERROR, "FireEvent - could not createinstance" ));
        return E_OUTOFMEMORY;
    }

    //
    // save info
    //
    p->m_pCall = pCall;
    p->m_Event = Event;
    p->m_Cause = Cause;
    p->m_hr = hrEvent;
    p->m_pTerminal = pTerminal;
    p->m_pStream = pStream;

    if ( NULL != pCall )
    {
        pCall->AddRef();
    }

    if ( NULL != pTerminal )
    {
        pTerminal->AddRef();
    }

    if ( NULL != pStream )
    {
        pStream->AddRef();
    }
    
#if DBG
    p->m_pDebug = (PWSTR) ClientAlloc( 1 );
#endif

    //
    // get the dispatch interface
    //
    hr = p->_InternalQueryInterface( IID_IDispatch, (void **)&pDisp );

    if (!SUCCEEDED(hr))
    {
        STATICLOG((TL_ERROR, "CallMediaEvent - could not get IDispatch %lx", hr));

        return hr;
    }

    //
    // fire the event
    //
    pTapi->Event(
                 TE_CALLMEDIA,
                 pDisp
                );


    //
    // release our reference
    //
    pDisp->Release();
    
    STATICLOG((TL_TRACE, "FireEvent - exit - returing SUCCESS" ));

    
    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Call
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCallMediaEvent::get_Call(ITCallInfo ** ppCallInfo)
{
    if ( TAPIIsBadWritePtr( ppCallInfo, sizeof( ITCallInfo *) ) )
    {
        LOG((TL_ERROR, "get_Call - bad pointer"));

        return E_POINTER;
    }

    *ppCallInfo = m_pCall;

    if ( NULL != m_pCall )
    {
        m_pCall->AddRef();
    }
    
    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Event
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCallMediaEvent::get_Event(CALL_MEDIA_EVENT * pCallMediaEvent)
{
    if ( TAPIIsBadWritePtr( pCallMediaEvent, sizeof( CALL_MEDIA_EVENT ) ) )
    {
        LOG((TL_ERROR, "get_Event - bad pointer"));

        return E_POINTER;
    }

    *pCallMediaEvent = m_Event;
    
    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Cause
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCallMediaEvent::get_Cause(CALL_MEDIA_EVENT_CAUSE * pCause)
{
    if ( TAPIIsBadWritePtr( pCause, sizeof( CALL_MEDIA_EVENT_CAUSE ) ) )
    {
        LOG((TL_ERROR, "get_Cause - bad pointer"));

        return E_POINTER;
    }

    *pCause = m_Cause;
    
    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Error
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCallMediaEvent::get_Error(HRESULT * phrError)
{
    if ( TAPIIsBadWritePtr( phrError, sizeof( HRESULT ) ) )
    {
        LOG((TL_ERROR, "get_Error - bad pointer"));

        return E_POINTER;
    }

    *phrError = m_hr;
    
    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Terminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCallMediaEvent::get_Terminal(ITTerminal ** ppTerminal)
{
    HRESULT             hr = S_OK;

    if ( TAPIIsBadWritePtr( ppTerminal, sizeof( ITTerminal *) ) )
    {
        LOG((TL_ERROR, "get_Terminal - bad pointer"));

        return E_POINTER;
    }

    *ppTerminal = m_pTerminal;

    if ( NULL != m_pTerminal )
    {
        m_pTerminal->AddRef();
    }
    
    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Stream
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCallMediaEvent::get_Stream(ITStream ** ppStream)
{
    if ( TAPIIsBadWritePtr( ppStream, sizeof( ITStream *) ) )
    {
        LOG((TL_ERROR, "get_Stream - bad pointer"));

        return E_POINTER;
    }

    *ppStream = m_pStream;

    if ( NULL != m_pStream )
    {
        m_pStream->AddRef();
    }
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//  FinalRelease
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CCallMediaEvent::FinalRelease()
{
    if ( NULL != m_pCall )
    {
        m_pCall->Release();
    }

    if ( NULL != m_pTerminal )
    {
        m_pTerminal->Release();
    }

    if ( NULL != m_pStream )
    {
        m_pStream->Release();
    }

#if DBG
    ClientFree( m_pDebug );
#endif
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CDigitDetectionEvent::FireEvent
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CDigitDetectionEvent::FireEvent(
                                ITCallInfo * pCall,
                                unsigned char ucDigit,
                                TAPI_DIGITMODE DigitMode,
                                long lTickCount,
                                CTAPI * pTapi,
                                long lCallbackInstance
                               )
{
    CComObject< CDigitDetectionEvent > * p;
    IDispatch                          * pDisp;
    HRESULT                              hr;
    CCall                              * pCCall;

    pCCall = dynamic_cast<CComObject<CCall>*>(pCall);
    
    if (NULL == pCCall)
    {
        STATICLOG((TL_ERROR, "FireEvent - bad call pointer" ));
        return E_FAIL;
    }

    if( pCCall->DontExpose())
    {
        STATICLOG((TL_INFO, "FireEvent - Don't expose this call %p", pCCall));
        return S_OK;
    }

    //
    // create the event object
    //
    CComObject< CDigitDetectionEvent >::CreateInstance( &p );

    if (NULL == p)
    {
        STATICLOG((TL_ERROR, "FireEvent - could not createinstance" ));
        return E_OUTOFMEMORY;
    }

    //
    // save info
    //
    p->m_pCall = pCall;
    pCall->AddRef();
    p->m_Digit = ucDigit;
    p->m_DigitMode = DigitMode;
    p->m_lTickCount = lTickCount;
    p->m_lCallbackInstance = lCallbackInstance;
#if DBG
    p->m_pDebug = (PWSTR) ClientAlloc( 1 );
#endif

    //
    // get the dispatch interface
    //
    hr = p->_InternalQueryInterface( IID_IDispatch, (void **)&pDisp );

    if (!SUCCEEDED(hr))
    {
        STATICLOG((TL_ERROR, "DigitDetectionEvent - could not get IDispatch %lx", hr));

        delete p;

        pCall->Release();
        
        return hr;
    }

    //
    // fire the event
    //
    pTapi->Event(
                 TE_DIGITEVENT,
                 pDisp
                );


    //
    // release our reference
    //
    pDisp->Release();
    
    STATICLOG((TL_TRACE, "FireEvent - exit - returing SUCCESS" ));

    return S_OK;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CDigitDetectionEvent::FinalRelease
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CDigitDetectionEvent::FinalRelease()
{
    if ( NULL != m_pCall )
    {
        m_pCall->Release();
    }

#if DBG
    ClientFree( m_pDebug );
#endif
    
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CDigitDetectionEvent::get_Call
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CDigitDetectionEvent::get_Call( ITCallInfo ** ppCallInfo )
{
    LOG((TL_TRACE, "get_Call - enter"));

    if ( TAPIIsBadWritePtr( ppCallInfo, sizeof( ITCallInfo * ) ) )
    {
        LOG((TL_ERROR, "get_Call - bad pointer"));

        return E_POINTER;
    }

    *ppCallInfo = m_pCall;

    m_pCall->AddRef();
    
    LOG((TL_TRACE, "get_Call - exit - return SUCCESS"));

    return S_OK;
}

   
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CDigitDetectionEvent::get_Digit
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CDigitDetectionEvent::get_Digit( unsigned char * pucDigit )
{
    LOG((TL_TRACE, "get_Digit - enter"));

    if ( TAPIIsBadWritePtr( pucDigit, sizeof( unsigned char ) ) )
    {
        LOG((TL_ERROR, "get_Digit - bad pointer"));

        return E_POINTER;
    }

    *pucDigit = m_Digit;
    
    LOG((TL_TRACE, "get_Digit - exit - return SUCCESS"));
    
    return S_OK;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CDigitDetectionEvent::get_DigitMode
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CDigitDetectionEvent::get_DigitMode( TAPI_DIGITMODE * pDigitMode )
{
    HRESULT             hr = S_OK;

    LOG((TL_TRACE, "get_DigitMode - enter"));

    if ( TAPIIsBadWritePtr( pDigitMode, sizeof( TAPI_DIGITMODE ) ) )
    {
        LOG((TL_ERROR, "get_DigitMode - bad pointer"));

        return E_POINTER;
    }

    *pDigitMode = m_DigitMode;
                
    LOG((TL_TRACE, "get_DigitMode - exit - return %lx", hr));
    
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CDigitDetectionEvent::get_TickCount
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CDigitDetectionEvent::get_TickCount( long * plTickCount )
{
    HRESULT             hr = S_OK;

    LOG((TL_TRACE, "get_TickCount - enter"));
    
    if ( TAPIIsBadWritePtr( plTickCount, sizeof( long ) ) )
    {
        LOG((TL_ERROR, "get_DigitMode - bad pointer"));

        return E_POINTER;
    }

    *plTickCount = m_lTickCount;
                
    LOG((TL_TRACE, "get_TickCount - exit - return %lx", hr));
    
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CDigitDetectionEvent::get_CallbackInstance
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CDigitDetectionEvent::get_CallbackInstance( long * plCallbackInstance )
{
    HRESULT             hr = S_OK;

    LOG((TL_TRACE, "get_CallbackInstance - enter"));

    if ( TAPIIsBadWritePtr( plCallbackInstance, sizeof( long ) ) )
    {
        LOG((TL_ERROR, "get_DigitMode - bad pointer"));

        return E_POINTER;
    }

    *plCallbackInstance = m_lCallbackInstance;
    
    LOG((TL_TRACE, "get_CallbackInstance - exit - return %lx", hr));
    
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CDigitGenerationEvent::FireEvent
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CDigitGenerationEvent::FireEvent(
                                 ITCallInfo * pCall,
                                 long lGenerationTermination,
                                 long lTickCount,
                                 long lCallbackInstance,
                                 CTAPI * pTapi
                                )
{
    CComObject< CDigitGenerationEvent > * p;
    IDispatch                           * pDisp;
    HRESULT                               hr;
    CCall                               * pCCall;

    pCCall = dynamic_cast<CComObject<CCall>*>(pCall);
    
    if (NULL == pCCall)
    {
        STATICLOG((TL_ERROR, "FireEvent - bad call pointer" ));
        return E_FAIL;
    }

    if( pCCall->DontExpose())
    {
        STATICLOG((TL_INFO, "FireEvent - Don't expose this call %p", pCCall));
        return S_OK;
    }

    //
    // create the event object
    //
    CComObject< CDigitGenerationEvent >::CreateInstance( &p );

    if (NULL == p)
    {
        STATICLOG((TL_ERROR, "FireEvent - could not createinstance" ));
        return E_OUTOFMEMORY;
    }

    //
    // get the dispatch interface
    //
    hr = p->_InternalQueryInterface( IID_IDispatch, (void **)&pDisp );

    if (!SUCCEEDED(hr))
    {
        STATICLOG((TL_ERROR, "FireEvent - could not get IDispatch %lx", hr));

        delete p;
        
        return hr;
    }

    //
    // save info
    //
    p->m_pCall = pCall;
    pCall->AddRef();
    p->m_lGenerationTermination = lGenerationTermination;
    p->m_lTickCount = lTickCount;
    p->m_lCallbackInstance = lCallbackInstance;
#if DBG
    p->m_pDebug = (PWSTR) ClientAlloc( 1 );
#endif

    //
    // fire the event
    //
    pTapi->Event(
                 TE_GENERATEEVENT,
                 pDisp
                );

    //
    // release our reference
    //
    pDisp->Release();
    
    STATICLOG((TL_TRACE, "FireEvent - exit - returing SUCCESS" ));

    return S_OK;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CDigitGenerationEvent::FinalRelease
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CDigitGenerationEvent::FinalRelease()
{
    if ( NULL != m_pCall )
    {
        m_pCall->Release();
    }

#if DBG
    ClientFree( m_pDebug );
#endif
    
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CDigitGenerationEvent::get_Call
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CDigitGenerationEvent::get_Call( ITCallInfo ** ppCallInfo )
{
    LOG((TL_TRACE, "get_Call - enter"));

    if ( TAPIIsBadWritePtr( ppCallInfo, sizeof( ITCallInfo * ) ) )
    {
        LOG((TL_ERROR, "get_Call - bad pointer"));

        return E_POINTER;
    }

    *ppCallInfo = m_pCall;

    m_pCall->AddRef();
    
    LOG((TL_TRACE, "get_Call - exit - return SUCCESS"));

    return S_OK;
}

   
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CDigitGenerationEvent::get_GenerationTermination
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CDigitGenerationEvent::get_GenerationTermination( long * plGenerationTermination )
{
    HRESULT             hr = S_OK;

    LOG((TL_TRACE, "get_GenerationTermination - enter"));
    
    if ( TAPIIsBadWritePtr( plGenerationTermination, sizeof( long ) ) )
    {
        LOG((TL_ERROR, "get_DigitMode - bad pointer"));

        return E_POINTER;
    }

    *plGenerationTermination = m_lGenerationTermination;
                
    LOG((TL_TRACE, "get_GenerationTermination - exit - return %lx", hr));
    
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CDigitGenerationEvent::get_TickCount
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CDigitGenerationEvent::get_TickCount( long * plTickCount )
{
    HRESULT             hr = S_OK;

    LOG((TL_TRACE, "get_TickCount - enter"));
    
    if ( TAPIIsBadWritePtr( plTickCount, sizeof( long ) ) )
    {
        LOG((TL_ERROR, "get_DigitMode - bad pointer"));

        return E_POINTER;
    }

    *plTickCount = m_lTickCount;
                
    LOG((TL_TRACE, "get_TickCount - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CDigitGenerationEvent::get_CallbackInstance
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CDigitGenerationEvent::get_CallbackInstance( long * plCallbackInstance )
{
    HRESULT             hr = S_OK;

    LOG((TL_TRACE, "get_CallbackInstance - enter"));

    if ( TAPIIsBadWritePtr( plCallbackInstance, sizeof( long ) ) )
    {
        LOG((TL_ERROR, "get_DigitMode - bad pointer"));

        return E_POINTER;
    }

    *plCallbackInstance = m_lCallbackInstance;
    
    LOG((TL_TRACE, "get_CallbackInstance - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CDigitsGatheredEvent::FireEvent
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CDigitsGatheredEvent::FireEvent(
                                 ITCallInfo * pCall,
                                 BSTR pDigits,
                                 TAPI_GATHERTERM GatherTermination,
                                 long lTickCount,
                                 long lCallbackInstance,
                                 CTAPI * pTapi
                                )
{
    CComObject< CDigitsGatheredEvent > * p;
    IDispatch                           * pDisp;
    HRESULT                               hr;
    CCall                               * pCCall;

    pCCall = dynamic_cast<CComObject<CCall>*>(pCall);
    
    if (NULL == pCCall)
    {
        STATICLOG((TL_ERROR, "FireEvent - bad call pointer" ));
        return E_FAIL;
    }

    if( pCCall->DontExpose())
    {
        STATICLOG((TL_INFO, "FireEvent - Don't expose this call %p", pCCall));
        return S_OK;
    }

    //
    // create the event object
    //
    CComObject< CDigitsGatheredEvent >::CreateInstance( &p );

    if (NULL == p)
    {
        STATICLOG((TL_ERROR, "FireEvent - could not createinstance" ));
        return E_OUTOFMEMORY;
    }

    //
    // get the dispatch interface
    //
    hr = p->_InternalQueryInterface( IID_IDispatch, (void **)&pDisp );

    if (!SUCCEEDED(hr))
    {
        STATICLOG((TL_ERROR, "CDigitsGatheredEvent - could not get IDispatch %lx", hr));

        delete p;      
        return hr;
    }

    //
    // save info
    //
    p->m_pCall = pCall;
    pCall->AddRef();
    p->m_pDigits = pDigits;
    p->m_GatherTermination = GatherTermination;
    p->m_lTickCount = lTickCount;
    p->m_lCallbackInstance = lCallbackInstance;
#if DBG
    p->m_pDebug = (PWSTR) ClientAlloc( 1 );
#endif

    //
    // fire the event
    //
    pTapi->Event(
                 TE_GATHERDIGITS,
                 pDisp
                );


    //
    // release our reference
    //
    pDisp->Release();
    
    STATICLOG((TL_TRACE, "FireEvent - exit - returing SUCCESS" ));

    return S_OK;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CDigitsGatheredEvent::FinalRelease
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CDigitsGatheredEvent::FinalRelease()
{
    if ( NULL != m_pCall )
    {
        m_pCall->Release();
    }

#if DBG
    ClientFree( m_pDebug );
#endif
    
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CDigitsGatheredEvent::get_Call
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CDigitsGatheredEvent::get_Call( ITCallInfo ** ppCallInfo )
{
    LOG((TL_TRACE, "get_Call - enter"));

    if ( TAPIIsBadWritePtr( ppCallInfo, sizeof( ITCallInfo * ) ) )
    {
        LOG((TL_ERROR, "get_Call - bad pointer"));

        return E_POINTER;
    }

    *ppCallInfo = m_pCall;

    m_pCall->AddRef();
    
    LOG((TL_TRACE, "get_Call - exit - return SUCCESS"));

    return S_OK;
}

   
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CDigitsGatheredEvent::get_Digits
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CDigitsGatheredEvent::get_Digits( BSTR * ppDigits )
{
    LOG((TL_TRACE, "get_Digits - enter"));
    
    if ( TAPIIsBadWritePtr( ppDigits, sizeof( BSTR ) ) )
    {
        LOG((TL_ERROR, "get_Digits - bad pointer"));

        return E_POINTER;
    }

    *ppDigits = m_pDigits;
                
    LOG((TL_TRACE, "get_Digits - exit - return SUCCESS"));
    
    return S_OK;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CDigitsGatheredEvent::get_GatherTermination
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CDigitsGatheredEvent::get_GatherTermination( TAPI_GATHERTERM *pGatherTermination )
{
    LOG((TL_TRACE, "get_GatherTermination - enter"));
    
    if ( TAPIIsBadWritePtr( pGatherTermination, sizeof( TAPI_GATHERTERM ) ) )
    {
        LOG((TL_ERROR, "get_GatherTermination - bad pointer"));

        return E_POINTER;
    }

    *pGatherTermination = m_GatherTermination;
                
    LOG((TL_TRACE, "get_GatherTermination - exit - return SUCCESS"));
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CDigitsGatheredEvent::get_TickCount
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CDigitsGatheredEvent::get_TickCount( long * plTickCount )
{
    LOG((TL_TRACE, "get_TickCount - enter"));
    
    if ( TAPIIsBadWritePtr( plTickCount, sizeof( long ) ) )
    {
        LOG((TL_ERROR, "get_TickCount - bad pointer"));

        return E_POINTER;
    }

    *plTickCount = m_lTickCount;
                
    LOG((TL_TRACE, "get_TickCount - exit - return SUCCESS"));
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CDigitsGatheredEvent::get_CallbackInstance
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CDigitsGatheredEvent::get_CallbackInstance( long * plCallbackInstance )
{
    LOG((TL_TRACE, "get_CallbackInstance - enter"));

    if ( TAPIIsBadWritePtr( plCallbackInstance, sizeof( long ) ) )
    {
        LOG((TL_ERROR, "get_CallbackInstance - bad pointer"));

        return E_POINTER;
    }

    *plCallbackInstance = m_lCallbackInstance;
    
    LOG((TL_TRACE, "get_CallbackInstance - exit - return SUCCESS"));
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CToneDetectionEvent::FireEvent
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CToneDetectionEvent::FireEvent(
                                 ITCallInfo * pCall,
                                 long lAppSpecific,
                                 long lTickCount,
                                 long lCallbackInstance,
                                 CTAPI * pTapi
                                )
{
    CComObject< CToneDetectionEvent > * p;
    IDispatch                           * pDisp;
    HRESULT                               hr;
    CCall                               * pCCall;

    pCCall = dynamic_cast<CComObject<CCall>*>(pCall);
    
    if (NULL == pCCall)
    {
        STATICLOG((TL_ERROR, "FireEvent - bad call pointer" ));
        return E_FAIL;
    }

    if( pCCall->DontExpose())
    {
        STATICLOG((TL_INFO, "FireEvent - Don't expose this call %p", pCCall));
        return S_OK;
    }

    //
    // create the event object
    //
    CComObject< CToneDetectionEvent >::CreateInstance( &p );

    if (NULL == p)
    {
        STATICLOG((TL_ERROR, "FireEvent - could not createinstance" ));
        return E_OUTOFMEMORY;
    }

    //
    // get the dispatch interface
    //
    hr = p->_InternalQueryInterface( IID_IDispatch, (void **)&pDisp );

    if (!SUCCEEDED(hr))
    {
        STATICLOG((TL_ERROR, "CToneDetectionEvent - could not get IDispatch %lx", hr));

        delete p;      
        return hr;
    }

    //
    // save info
    //
    p->m_pCall = pCall;
    pCall->AddRef();
    p->m_lAppSpecific = lAppSpecific;
    p->m_lTickCount = lTickCount;
    p->m_lCallbackInstance = lCallbackInstance;
#if DBG
    p->m_pDebug = (PWSTR) ClientAlloc( 1 );
#endif

    //
    // fire the event
    //
    pTapi->Event(
                 TE_TONEEVENT,
                 pDisp
                );


    //
    // release our reference
    //
    pDisp->Release();
    
    STATICLOG((TL_TRACE, "FireEvent - exit - returing SUCCESS" ));

    return S_OK;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CToneDetectionEvent::FinalRelease
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CToneDetectionEvent::FinalRelease()
{
    if ( NULL != m_pCall )
    {
        m_pCall->Release();
    }

#if DBG
    ClientFree( m_pDebug );
#endif
    
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CToneDetectionEvent::get_Call
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CToneDetectionEvent::get_Call( ITCallInfo ** ppCallInfo )
{
    LOG((TL_TRACE, "get_Call - enter"));

    if ( TAPIIsBadWritePtr( ppCallInfo, sizeof( ITCallInfo * ) ) )
    {
        LOG((TL_ERROR, "get_Call - bad pointer"));

        return E_POINTER;
    }

    *ppCallInfo = m_pCall;

    m_pCall->AddRef();
    
    LOG((TL_TRACE, "get_Call - exit - return SUCCESS"));

    return S_OK;
}

   
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CToneDetectionEvent::get_AppSpecific
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CToneDetectionEvent::get_AppSpecific( long * plAppSpecific )
{
    LOG((TL_TRACE, "get_AppSpecific - enter"));
    
    if ( TAPIIsBadWritePtr( plAppSpecific, sizeof( long ) ) )
    {
        LOG((TL_ERROR, "get_AppSpecific - bad pointer"));

        return E_POINTER;
    }

    *plAppSpecific = m_lAppSpecific;
                
    LOG((TL_TRACE, "get_AppSpecific - exit - return SUCCESS"));
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CToneDetectionEvent::get_TickCount
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CToneDetectionEvent::get_TickCount( long * plTickCount )
{
    LOG((TL_TRACE, "get_TickCount - enter"));
    
    if ( TAPIIsBadWritePtr( plTickCount, sizeof( long ) ) )
    {
        LOG((TL_ERROR, "get_TickCount - bad pointer"));

        return E_POINTER;
    }

    *plTickCount = m_lTickCount;
                
    LOG((TL_TRACE, "get_TickCount - exit - return SUCCESS"));
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CToneDetectionEvent::get_CallbackInstance
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CToneDetectionEvent::get_CallbackInstance( long * plCallbackInstance )
{
    LOG((TL_TRACE, "get_CallbackInstance - enter"));

    if ( TAPIIsBadWritePtr( plCallbackInstance, sizeof( long ) ) )
    {
        LOG((TL_ERROR, "get_CallbackInstance - bad pointer"));

        return E_POINTER;
    }

    *plCallbackInstance = m_lCallbackInstance;
    
    LOG((TL_TRACE, "get_CallbackInstance - exit - return SUCCESS"));
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\callhub.cpp ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    callhub.cpp

Abstract:

    Implements all the methods on callhub interfaces.

Author:

    mquinton - 11-21-97

Notes:


Revision History:

--*/

#include "stdafx.h"

extern CHashTable * gpCallHubHashTable;
extern CHashTable * gpCallHashTable;

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// callhub.cpp
//
// this module implements the callhub object
//
// the callhub object is the "third party" view of a call.
//
// callhubs can be created in four different ways:
//
//  1 - the service provider supports them.  they indicate this through
//      the linedevcapsflag_callhub bit in LINEDEVCAPS.  this means
//      that the sp used the dwCallID field to associate calls.
//      tapisrv will synthesize the callhubs based on this information
//
//  2 - almost the same as 1, except that the sp does not set the
//      the linedevcapsflag_callhub bit (because it is a tapi2.x
//      sp).  tapisrv and tapi3 have to guess whether or not the sp
//      supports callhubs.  it does this simply by seeing if the
//      dwcallid field is non-zero.  however, this creates a problem
//      before a call is made, since we can't get to the dwcallid
//      field.  in this case, i set a flag in the address object
//      ADDRESSFLAG_CALLHUB or _NOCALLHUB to flag whether this is
//      supported.  however, for the very first call, we won't know
//      until the call is actually made.
//
//  3 - participant based callhub (also called part based). the sp
//      supports participants, as indicated by the linedevcapsflag_participantinfo
//      tapi3 breaks out all the participants into their own participant
//      objects
//
//  4 - fake call hub.  if the sp doesn't support anything, we create
//      a callhub, and fake the other end.
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL
FindCallObject(
               HCALL hCall,
               CCall ** ppCall
              );


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCallHub::Initialize(
                     CTAPI * pTapi,
                     HCALLHUB hCallHub,
                     DWORD dwFlags
                    )
{
    HRESULT             hr;

    LOG((TL_TRACE,"Initialize - enter" ));


    Lock();
    
    m_pTAPI     = pTapi;
    m_hCallHub  = hCallHub;
    m_State     = CHS_ACTIVE;
    m_dwFlags  |= dwFlags;
    
#if DBG
    m_pDebug = (PWSTR) ClientAlloc( 1 );
#endif

    m_dwRef = 2;
    
    //
    // save in tapi's list
    //
    pTapi->AddCallHub( this );
    pTapi->AddRef();

    if ( NULL != hCallHub )
    {
        //
        // add it to the global hash table
        // hash table is only for callhubs with
        // hcallhub handles, because we only need
        // the hash table when tapi sends a message
        // with the tapi handle in it
        //
        gpCallHubHashTable->Lock();

        hr = gpCallHubHashTable->Insert( (ULONG_PTR)hCallHub, (ULONG_PTR)this, pTapi );

        gpCallHubHashTable->Unlock();

        //
        // see if there are any existing
        // calls for this callhub
        //
        FindExistingTapisrvCallhubCalls();
    }


    //
    // tell the app
    //
    CCallHubEvent::FireEvent(
                             CHE_CALLHUBNEW,
                             this,
                             NULL,
                             pTapi
                            );

    Unlock();

    LOG((TL_TRACE, S_OK,"Initialize - exit" ));

    return S_OK;
    
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// Clear - clears the callhub.  there is no native tapi way
// to do this, so just iterate through all the calls and
// try to drop them
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCallHub::Clear()
{
    HRESULT                             hr = S_OK;
    ITBasicCallControl *                pCall;
    BOOL                                bFailure = FALSE;
    int                                 iCount;
    CCall                             * pConferenceControllerCall;
    CTArray <ITBasicCallControl *>      aLocalCalls;
    

    Lock();
   
    LOG((TL_TRACE, "Clear - enter "));

    //If there's a conference controller call -  drop it
    if(m_pConferenceControllerCall != NULL)
    {
        LOG((TL_INFO, "Clear - disconnect conf controller call"));
        pConferenceControllerCall = m_pConferenceControllerCall;
        m_pConferenceControllerCall = NULL;
        Unlock();
        pConferenceControllerCall->Disconnect(DC_NORMAL);
        pConferenceControllerCall->Release();
        Lock();
    }


    //
    // go through all the calls
    //
    for (iCount = 0; iCount < m_CallArray.GetSize(); iCount++ )
    {
        //
        // try to get to the basic call control interface
        //
        hr = (m_CallArray[iCount])->QueryInterface(
            IID_ITBasicCallControl,
            (void **)&pCall
            );

        if (SUCCEEDED(hr))
        {
            //
            // Add it to our private list. We have to avoid doing
            // disconnect and release on a call while holding the
            // callhub lock. There is a timing window in between disconnect
            // and release where the disconnect call state event can lock
            // the call. Then it locks the callhub, which makes a deadlock.
            //

            aLocalCalls.Add(pCall);

        }
        else
        {
            bFailure = TRUE;
        }
    }

    Unlock();

    //
    // Now that we've unlocked the callhub (see above), go through our
    // private list of calls and drop and release each one.
    //

    for ( iCount = 0; iCount < aLocalCalls.GetSize(); iCount++ )
    {
        pCall = aLocalCalls[iCount];

        //
        // if we can, try to disconnect.
        //
        pCall->Disconnect(DC_NORMAL);

        pCall->Release();
    }

    //
    // clean up the list.
    //

    aLocalCalls.Shutdown();

    LOG((TL_TRACE, "Clear - exit  "));

    return (bFailure?S_FALSE:S_OK);
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// just enumerate the calls
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCallHub::EnumerateCalls(
                         IEnumCall ** ppEnumCall
                        )
{
    HRESULT     hr = S_OK;
    
    LOG((TL_TRACE, "EnumerateCalls enter" ));
    LOG((TL_TRACE, "   ppEnumCalls----->%p", ppEnumCall ));

    if ( TAPIIsBadWritePtr( ppEnumCall, sizeof (IEnumCall *) ) )
    {
        LOG((TL_ERROR, "EnumCalls - bad pointer"));

        return E_POINTER;
    }
    
    //
    // create the enumerator
    //
    CComObject< CTapiEnum< IEnumCall, ITCallInfo, &IID_IEnumCall > > * p;
    hr = CComObject< CTapiEnum< IEnumCall, ITCallInfo, &IID_IEnumCall > >
         ::CreateInstance( &p );

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "EnumerateCalls - could not create enum" ));
        
        return hr;
    }


    Lock();

    //
    // initialize it with our call
    //
    p->Initialize( m_CallArray );

    
    Unlock();


    //
    // return it
    //
    *ppEnumCall = p;

    LOG((TL_TRACE, "EnumerateCalls exit - return S_OK" ));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// collection of calls
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCallHub::get_Calls(
                    VARIANT * pVariant
                   )
{
    HRESULT         hr;
    IDispatch *     pDisp;

    LOG((TL_TRACE, "get_Calls enter"));
    LOG((TL_TRACE, "   pVariant ------->%p", pVariant));

    if ( TAPIIsBadWritePtr( pVariant, sizeof(VARIANT) ) )
    {
        LOG((TL_ERROR, "get_Calls - invalid pointer" ));
        
        return E_POINTER;
    }

    CComObject< CTapiCollection< ITCallInfo > > * p;
    CComObject< CTapiCollection< ITCallInfo > >::CreateInstance( &p );
    
    if (NULL == p)
    {
        LOG((TL_ERROR, "get_Calls - could not create collection" ));
        
        return E_OUTOFMEMORY;
    }

    Lock();

    //
    // initialize
    //
    hr = p->Initialize( m_CallArray );

    Unlock();

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "get_Calls - could not initialize collection" ));
        
        delete p;
        return hr;
    }

    //
    // get the IDispatch interface
    //
    hr = p->_InternalQueryInterface( IID_IDispatch, (void **) &pDisp );

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "get_Calls - could not get IDispatch interface" ));
        
        delete p;
        return hr;
    }

    //
    // put it in the variant
    //
    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDisp;
    
    LOG((TL_TRACE, "get_Calls exit - return S_OK"));
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// get the current number of calls
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCallHub::get_NumCalls(
                       long * plCalls
                      )
{
    HRESULT         hr = S_OK;

    if ( TAPIIsBadWritePtr( plCalls, sizeof(LONG) ) )
    {
        LOG((TL_ERROR, "get_NumCalls - bad pointer"));

        return E_POINTER;
    }
    
    Lock();

    *plCalls = m_CallArray.GetSize();
    
    Unlock();

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// get the current state
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCallHub::get_State(
                    CALLHUB_STATE * pState
                   )
{
    HRESULT         hr = S_OK;

    if ( TAPIIsBadWritePtr( pState, sizeof (CALLHUB_STATE) ) )
    {
        LOG((TL_ERROR, "get_State - invalid pointer"));

        return E_POINTER;
    }
    
    Lock();

    *pState = m_State;

    Unlock();

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// release the object
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL
CCallHub::ExternalFinalRelease()
{
    HRESULT                             hr;
    int                                 iCount;
    

    LOG((TL_TRACE, "CCallHub - FinalRelease - enter - this %p - hCallHub - %lx", this, m_hCallHub));

    Lock();


    
#if DBG
    /*NikhilB: To avoid a hang*/
	if( m_pDebug != NULL )
	{
		ClientFree( m_pDebug );
		m_pDebug = NULL;
	}
#endif
    
    m_pTAPI->RemoveCallHub( this );
    m_pTAPI->Release();

    for (iCount = 0; iCount < m_CallArray.GetSize(); iCount++ )
    {
        CCall * pCCall;

        pCCall = dynamic_cast<CCall *>(m_CallArray[iCount]);

        if ( NULL != pCCall )
        {
            pCCall->SetCallHub(NULL);
        }
    }

    m_CallArray.Shutdown();

    if ( NULL != m_pPrivate )
    {
        m_pPrivate->Release();
    }

    Unlock();
    
    LOG((TL_TRACE, "CCallHub - FinalRelease - exit"));

    return TRUE;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// FindExistingTapisrvCallhubCalls
//
//  internal function
//
//  this is called when creating a 'tapisrv' callhub.  this function
//  will call lineGetHubRelatedCalls, and add any already existing calls
//  to this callhub
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCallHub::FindExistingTapisrvCallhubCalls()
{
    LINECALLLIST *  pCallHubList;
    HCALL *         phCalls;
    DWORD           dwCount;
    HRESULT         hr;
    
    //
    // get the list of hcalls
    // related to this call
    //
    hr = LineGetHubRelatedCalls(
                                m_hCallHub,
                                0,
                                &pCallHubList
                               );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "FindExistingCalls - LineGetHubRelatedCalls "
                           "failed %lx", hr));

        return hr;
    }

    //
    // get to the list of calls
    //
    phCalls = (HCALL *)(((LPBYTE)pCallHubList) + pCallHubList->dwCallsOffset);

    //
    // the first call is actually the callhub
    // that makes sense...
    //
    if (m_hCallHub != (HCALLHUB)(phCalls[0]))
    {
        LOG((TL_ERROR, "FindExistingCalls - callhub doesn't match"));

        _ASSERTE(0);

        ClientFree( pCallHubList );

        return E_FAIL;
    }
    
    //
    // go through the call handles and try to find the
    // objects
    //
    // phCalls[0] is the callhub, so skip it
    //
    for (dwCount = 1; dwCount < pCallHubList->dwCallsNumEntries; dwCount++)
    {
        CCall             * pCall;
        ITCallInfo        * pCallInfo;
        
        //
        // get the tapi3 call object
        //
        if (!FindCallObject(
                            phCalls[dwCount],
                            &pCall
                           ))
        {
            LOG((TL_INFO, "FindExistingCalls - call handle %lx "
                     "does not current exist", phCalls[dwCount]));

            continue;
        }

        //
        // tell the call
        //
        pCall->SetCallHub( this );

        if ( NULL == m_pAddress )
        {
            m_pAddress = pCall->GetCAddress();
        }
        
        //
        // get the callinfo interface
        //
        hr = pCall->QueryInterface(
                                   IID_ITCallInfo,
                                   (void **)&pCallInfo
                                  );

        //
        // findcallobject addrefs
        //
        pCall->Release();
        
        if ( !SUCCEEDED(hr) )
        {
            LOG((TL_ERROR, "FindExistingCalls - can't get callinfo interface"));

            _ASSERTE(0);

            continue;
        }

        //
        // save the call
        //
        m_CallArray.Add(pCallInfo);

        //
        // don't save a reference
        //
        pCallInfo->Release();

    }
        
    ClientFree( pCallHubList );

    return S_OK;
}


HRESULT
CCallHub::FindCallsDisconnected(
    BOOL * fAllCallsDisconnected
    )
{
    LINECALLLIST *  pCallHubList;
    HCALL *         phCalls;
    DWORD           dwCount;
    HRESULT         hr;
    CALL_STATE      callState = CS_IDLE;
    
    *fAllCallsDisconnected = TRUE;
    
    Lock();

    //
    // get the list of hcalls
    // related to this call
    //
    hr = LineGetHubRelatedCalls(
                                m_hCallHub,
                                0,
                                &pCallHubList
                               );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "FindExistingCalls - LineGetHubRelatedCalls "
                           "failed %lx", hr));

        Unlock();
        return hr;
    }

    //
    // get to the list of calls
    //
    phCalls = (HCALL *)(((LPBYTE)pCallHubList) + pCallHubList->dwCallsOffset);

    //
    // the first call is actually the callhub
    // that makes sense...
    //
    if (m_hCallHub != (HCALLHUB)(phCalls[0]))
    {
        LOG((TL_ERROR, "FindExistingCalls - callhub doesn't match"));

        _ASSERTE(0);

        ClientFree( pCallHubList );
        
        Unlock();
        return E_FAIL;
    }
    
    //
    // go through the call handles and try to find the
    // objects
    //
    // phCalls[0] is the callhub, so skip it
    //
    for (dwCount = 1; dwCount < pCallHubList->dwCallsNumEntries; dwCount++)
    {
        CCall             * pCall;
        
        //
        // get the tapi3 call object
        //
        if (!FindCallObject(
                            phCalls[dwCount],
                            &pCall
                           ))
        {
            LOG((TL_INFO, "FindExistingCalls - call handle %lx "
                     "does not current exist", phCalls[dwCount]));

            continue;
        }

        pCall->get_CallState(&callState);

        //
        // findcallobject addrefs
        //
        pCall->Release();

        if( callState != CS_DISCONNECTED )
        {
            *fAllCallsDisconnected = FALSE;
            break;
        }
    }
        
    ClientFree( pCallHubList );
    
    Unlock();
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CreateTapisrvCallHub
//
// Creates a callhub that is handled by tapisrv.
//
//          pTAPI - owning tapi object
//
//          hCallHub - tapi's handle for the call hub.
//
//          ppCallHub - returned call hub with ref count of 1
//                  
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCallHub::CreateTapisrvCallHub(
                               CTAPI * pTAPI,
                               HCALLHUB hCallHub,
                               CCallHub ** ppCallHub
                              )
{
    HRESULT hr;
    // CTAPIComObjectWithExtraRef<CCallHub>      * p;
     CComObject<CCallHub>   * p;

    STATICLOG((TL_TRACE, "CreateTapisrvCallHub - enter"));
    STATICLOG((TL_INFO, "  hCallHub ---> %lx", hCallHub));

    //
    // create the object
    //
    //p = new CTAPIComObjectWithExtraRef<CCallHub>;
    hr = CComObject<CCallHub>::CreateInstance( &p );

    if (NULL == p)
    {
        STATICLOG((TL_INFO, "CreateTapisrvCallHub - createinstance failed"));
        return E_OUTOFMEMORY;
    }

    //
    // initialize it
    //
    p->Initialize(
                  pTAPI,
                  hCallHub,
                  CALLHUBTYPE_CALLHUB
                 );
    //
    // return object
    // NOTE:initialize addrefs for us!
    //
    *ppCallHub = p;
    
    STATICLOG((TL_TRACE, "CreateTapisrvCallHub - exit"));
    
    return S_OK;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//  CreateOrFakeCallHub
//
//   creates a fake callhub
//
//   pTAPI - owning TAPI object
//   pCall - call
//   ppCallHub - return new callhub object - ref count of 1
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCallHub::CreateFakeCallHub(
                            CTAPI * pTAPI,
                            CCall * pCall,
                            CCallHub ** ppCallHub
                           )
{
    HRESULT hr;
         CComObject<CCallHub>   * p;
    
    STATICLOG((TL_TRACE, "CreateFakeCallHub - enter"));

    //
    // create the object
    //
    //p = new CTAPIComObjectWithExtraRef<CCallHub>;

    try
    {
        //
        // inside try in case critical section fails to be allocated
        //

        hr = CComObject<CCallHub>::CreateInstance( &p );

    }
    catch(...)
    {
    
        STATICLOG((TL_ERROR, "CreateFakeCallHub - failed to create a callhub -- exception"));

        p = NULL;
    }


    if (NULL == p)
    {
        STATICLOG((TL_INFO, "CreateFakeCallHub - createinstance failed"));
        return E_OUTOFMEMORY;
    }

    if ( (NULL == pTAPI) || (NULL == pCall) )
    {
        STATICLOG((TL_ERROR, "CreateFakeCallHub - invalid param"));

        _ASSERTE(0);
        
        delete p;

        return E_UNEXPECTED;
    }
    
    //
    // initialized
    //
    p->Initialize(
                  pTAPI,
                  NULL,
                  CALLHUBTYPE_NONE
                 );

    //
    // ZoltanS fix 11-12-98
    // Add the call to the fake callhub.
    // This in turn calls CCall::SetCallHub, which sets and addrefs the call's
    // member callhub pointer. When we return from here we will set the
    // callhub pointer again, and the reference that's released on
    // ExternalFinalRelease is in effect the initial reference from Initialize.
    // So we need to release here in order to avoid keeping an extra reference
    // to the callhub.
    //

    p->AddCall(pCall);
    ((CCallHub *) p)->Release();
    
    //
    // return object
    // NOTE: Initialize addrefs for us!
    //
    *ppCallHub = p;
    
    STATICLOG((TL_TRACE, "CreateFakeCallHub - exit"));
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// Remove Call
//
// remove a call object from the callhub's list
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CCallHub::RemoveCall(
                     CCall * pCall
                    )
{
    HRESULT               hr = S_OK;
    ITCallInfo          * pCallInfo;
    
    hr = pCall->QueryInterface(
                               IID_ITCallInfo,
                               (void**)&pCallInfo
                              );

    if ( !SUCCEEDED(hr) )
    {
        return;
    }

    Lock();

    m_CallArray.Remove( pCallInfo );
    
    Unlock();

    pCallInfo->Release();
}
    
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CheckForIdle()
//
// internal function
//
// checks the state of the calls in the hub to see if it is idle
//
// so, we go through all the objects that are call objects, and
// see if they are disconnected.  if they all are, then the
// hub is idle
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CCallHub::CheckForIdle()
{
    HRESULT                             hr;
    int                                 iCount;

    LOG((TL_ERROR, "CCallHub::CheckForIdle -Entered :%p", this ));

    Lock();

    //
    // go through the call list
    //
    for (iCount = 0; iCount < m_CallArray.GetSize() ; iCount++ )
    {
        CALL_STATE    cs;
        
        //
        // get the callstate
        //
        (m_CallArray[iCount])->get_CallState( &cs );

        //
        // if anything is not disconnected, then
        // it's not idle
        //
        if ( CS_DISCONNECTED != cs )
        {
            Unlock();

            return;
        }
    }

    Unlock();

    //
    // if we haven't returned yet, the callhub is
    // idle
    //
    SetState(CHS_IDLE);

    LOG((TL_ERROR, "CCallHub::CheckForIdle -Exited :%p", this ));
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//  CCallHub::SetState
//
//  sets the state of the object.  fires an event if necessary
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CCallHub::SetState(
                   CALLHUB_STATE chs
                  )
{
    BOOL            bEvent = FALSE;

    LOG((TL_ERROR, "CCallHub::SetState -Entered :%p", this ));
    Lock();

    if ( m_State != chs )
    {
        bEvent = TRUE;
        
        m_State = chs;
    }

    Unlock();

    if ( bEvent )
    {
        CALLHUB_EVENT   che;
        
        if ( CHS_IDLE == chs )
        {
            che = CHE_CALLHUBIDLE;
        }
        else
        {
            che = CHE_CALLHUBNEW;
        }

        CCallHubEvent::FireEvent(
                                 che,
                                 this,
                                 NULL,
                                 m_pTAPI
                                );

        LOG((TL_ERROR, "CCallHub::SetState -Exited :%p", this ));
        }
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//  CCallHubEvent::FireEvent
//
// create and fire a callhub event
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCallHubEvent::FireEvent(
                         CALLHUB_EVENT Event,
                         ITCallHub * pCallHub,
                         ITCallInfo * pCall,
                         CTAPI * pTapi
                        )
{
    CComObject<CCallHubEvent> * p;
    IDispatch                 * pDisp;
    HRESULT                     hr = S_OK;

    //
    // Check the event filter mask
    // This event is not filtered by TapiSrv because is
    // related with TE_CALLSTATE.
    //

    CCall* pCCall = (CCall*)pCall;
    if( pCCall )
    {
        DWORD dwEventFilterMask = 0;
        dwEventFilterMask = pCCall->GetSubEventsMask( TE_CALLHUB );
        if( !( dwEventFilterMask & GET_SUBEVENT_FLAG(Event)))
        {
            STATICLOG((TL_WARN, "FireEvent - filtering out this event [%lx]", Event));
            return S_OK;
        }
    }
    else
    {
        // Try with pTapi
        if( pTapi == NULL )
        {
            STATICLOG((TL_WARN, "FireEvent - filtering out this event [%lx]", Event));
            return S_OK;
        }

        long nEventMask = 0;
        pTapi->get_EventFilter( &nEventMask );
        if( (nEventMask & TE_CALLHUB) == 0)
        {
            STATICLOG((TL_WARN, "FireEvent - filtering out this event [%lx]", Event));
            return S_OK;
        }
    }

    //
    // create object
    //
    CComObject<CCallHubEvent>::CreateInstance( &p );

    if ( NULL == p )
    {
        STATICLOG((TL_ERROR, "CallHubEvent - could not create object"));

        return E_OUTOFMEMORY;
    }

    //
    // initialize
    //
    p->m_Event = Event;
    p->m_pCallHub = pCallHub;
    p->m_pCall = pCall;

#if DBG
    p->m_pDebug = (PWSTR) ClientAlloc( 1 );
#endif
    
    //
    // addref objects if valid
    //
    if ( NULL != pCallHub )
    {
        pCallHub->AddRef();
    }

    if ( NULL != pCall )
    {
        pCall->AddRef();
    }

    //
    // get the dispatch interface
    //
    hr = p->_InternalQueryInterface(
                                    IID_IDispatch,
                                    (void **)&pDisp
                                   );

    if (!SUCCEEDED(hr))
    {
        STATICLOG((TL_ERROR, "CallHubEvent - could not get dispatch interface"));
        
        delete p;

        return hr;
    }

    //
    // fire the event
    //
    pTapi->Event( TE_CALLHUB, pDisp );


    //
    // release our reference
    //
    pDisp->Release();

    return S_OK;
}
    
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// get_Event
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCallHubEvent::get_Event(
                         CALLHUB_EVENT * pEvent
                        )
{
    HRESULT         hr = S_OK;

    if ( TAPIIsBadWritePtr( pEvent, sizeof (CALLHUB_EVENT) ) )
    {
        LOG((TL_ERROR, "get_Event - bad pointer"));

        return E_POINTER;
    }
    
    *pEvent = m_Event;

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// get_CallHub
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCallHubEvent::get_CallHub(
                           ITCallHub ** ppCallHub
                          )
{
    HRESULT         hr = S_OK;

    if ( TAPIIsBadWritePtr( ppCallHub, sizeof (ITCallHub *) ) )
    {
        LOG((TL_ERROR, "get_CallHub - bad pointer"));

        return E_POINTER;
    }
    
    hr = m_pCallHub->QueryInterface(
                                    IID_ITCallHub,
                                    (void **)ppCallHub
                                   );
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// get_Call
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCallHubEvent::get_Call(
                        ITCallInfo ** ppCall
                       )
{
    HRESULT         hr = S_OK;

    if ( TAPIIsBadWritePtr( ppCall, sizeof(ITCallInfo *) ) )
    {
        LOG((TL_ERROR, "get_Call - bad pointer"));

        return E_POINTER;
    }
    
    *ppCall = NULL;

    //
    // the call can be NULL
    //
    if ( NULL == m_pCall )
    {
        return S_FALSE;
    }
    
    hr = m_pCall->QueryInterface(
                                 IID_ITCallInfo,
                                 (void **)ppCall
                                );

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CCallHubEvent::FinalRelease()
{
    m_pCallHub->Release();

    if ( NULL != m_pCall )
    {
        m_pCall->Release();
    }

#if DBG
    ClientFree( m_pDebug );
#endif
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// HandleCallHubClose
//
// handle LINE_CALLHUBCLOSE message - find the callhub object
// and clear the callhub handle from it
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
HandleCallHubClose( PASYNCEVENTMSG pParams )
{
    CCallHub * pCallHub;

    LOG((TL_INFO, "HandleCallHubClose %lx", pParams->Param1));
    
    if ( FindCallHubObject(
                           (HCALLHUB)pParams->Param1,
                           &pCallHub
                          ) )
    {
        pCallHub->ClearCallHub();

        pCallHub->Release();
    }

}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ClearCallHub
//
// clears the callhub handle in the object and removes the object
// from the callhub hash table
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CCallHub::ClearCallHub()
{
    HRESULT             hr;
    
    Lock();

    gpCallHubHashTable->Lock();

    hr = gpCallHubHashTable->Remove( (UINT_PTR) m_hCallHub );

    m_hCallHub = NULL;

    gpCallHubHashTable->Unlock();

    Unlock();
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// FindCallByHandle
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
CCall * CCallHub::FindCallByHandle(HCALL hCall)
{
    ITBasicCallControl * pCall;
    CCall              * pCCall;
    HRESULT              hr;
    int                  iCount;
    
    Lock();

    //
    // go through the call list
    //
    for ( iCount = 0; iCount < m_CallArray.GetSize(); iCount++ )
    {

        //
        // try to get to the basic call control interface
        //
        hr = (m_CallArray[iCount])->QueryInterface(
              IID_ITBasicCallControl,
              (void **)&pCall
             );

        if (SUCCEEDED(hr))
        {
            pCCall = dynamic_cast<CCall *>((ITBasicCallControl *)(pCall));
            
            if ( NULL != pCCall )
            {
                //
                // does this match?
                //
                if ( pCCall->GetHCall() == hCall )
                {
                    Unlock();
                    return pCCall;
                }
                else
                {
                 pCCall->Release();   
                }
            }
        }
    }
    
    Unlock();

    //
    // didn't find it
    //
    return NULL;

}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CreateConferenceControllerCall
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CCallHub::CreateConferenceControllerCall(HCALL hCall, CAddress * pAddress )
{
    HRESULT                 hr = S_OK;
    CCall                 * pConferenceControllerCall;
    

    LOG((TL_TRACE, "CreateConferenceController - enter"));
    
    //
    // create & initialize
    //
    hr = pAddress->InternalCreateCall(
                                      NULL,
                                      0,
                                      0,
                                      CP_OWNER,
                                      FALSE,
                                      hCall,
                                      FALSE,
                                      &pConferenceControllerCall
                                     );

    if ( SUCCEEDED(hr) )
    {
        pConferenceControllerCall->SetCallHub( this );
        
        //
        // save the call
        //
        Lock();
        
        m_pConferenceControllerCall = pConferenceControllerCall;
        
        Unlock();
    }
    else
    {
        LOG((TL_ERROR, "CreateConferenceController - could not create call instance"));
    }
    
    LOG((TL_TRACE, hr, "CreateConferenceController - exit"));
    
    return hr;
}




//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// AddCall
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CCallHub::AddCall(CCall * pCall)
{
    ITCallInfo        * pCallInfo;
    HRESULT             hr = S_OK;

    
    Lock();
    //
    // tell the call
    //
    pCall->SetCallHub( this );

    if ( NULL == m_pAddress )
    {
        m_pAddress = pCall->GetCAddress();
    }
    
    //
    // get the CallInfo interface
    //
    hr = pCall->QueryInterface(
                               IID_ITCallInfo,
                               (void **)&pCallInfo
                              );
    if ( !SUCCEEDED(hr) )
    {
        _ASSERTE(0);
    }

    //
    // save the Call
    //
    m_CallArray.Add( pCallInfo );

    //
    // don't save a reference
    //
    pCallInfo->Release();

    Unlock();

    CCallHubEvent::FireEvent(
                             CHE_CALLJOIN,
                             this,
                             pCallInfo,
                             m_pTAPI
                            );

}
    
CCall *
CCallHub::GetConferenceControllerCall()
{
    CCall * pCall;
    
    Lock();

    pCall = m_pConferenceControllerCall;

    Unlock();
    
    return pCall;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\call.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    Call.h

Abstract:

    Declaration of the CAgentSession & CCall class
    
Author:

    mquinton  06-12-97

Notes:

Revision History:

--*/

#ifndef __CALL_H_
#define __CALL_H_

#include "resource.h"       // main symbols
#include "address.h"

#ifdef USE_PHONEMSP
#include "terminal.h"
#endif USE_PHONEMSP

#include "callhub.h"
#include "callevnt.h"


extern CHashTable             * gpCallHashTable;
extern CHashTable             * gpHandleHashTable;
extern void RemoveHandleFromHashTable(ULONG_PTR Handle);


//
// helper function for converting array of bytes to a byte array. the caller 
// must ClientFree *ppBuffer when done.
//

HRESULT
MakeBufferFromVariant(
                      IN VARIANT var,
                      OUT DWORD * pdwSize,
                      OUT BYTE ** ppBuffer
                     );

typedef enum
{
    STREAM_RENDERAUDIO = 0,
    STREAM_RENDERVIDEO,
    STREAM_CAPTUREAUDIO,
    STREAM_CAPTUREVIDEO,
    STREAM_NONE
} CALL_STREAMS;


HRESULT
WINAPI
MyBasicCallControlQI(void* pv, REFIID riid, LPVOID* ppv, DWORD_PTR dw);

// the app needs to be notified of this call
#define CALLFLAG_NEEDTONOTIFY   0x00000001

// the call is an incoming call
#define CALLFLAG_INCOMING       0x00000002

// A Consultation Call
#define CALLFLAG_CONSULTCALL    0x00000008

// A Consultation Call used in a transfer
#define CALLFLAG_TRANSFCONSULT  0x00000010

// A Consultation Call used in a conference
#define CALLFLAG_CONFCONSULT    0x00000020

// received line_callinfo message
#define CALLFLAG_CALLINFODIRTY  0x00000040

// Don't send the app any notifications about this call 
#define CALLFLAG_DONTEXPOSE     0x00000100

// don't close m_addresslinestruct
#define CALLFLAG_NOTMYLINE      0x00000200

// Need to do a line accept before transitioning to CS_OFFERING
#define CALLFLAG_ACCEPTTOALERT  0x00000400

#define ISHOULDUSECALLPARAMS() ( ( NULL != m_pCallParams ) && ( CS_IDLE == m_CallState ) )


/////////////////////////////////////////////////////////////////
// Intermediate classes  used for DISPID encoding
template <class T>
class  ITCallInfoVtbl : public ITCallInfo
{
};

template <class T>
class  ITCallInfo2Vtbl : public ITCallInfo2
{
};


template <class T>
class  ITBasicCallControlVtbl : public ITBasicCallControl
{
};

                                                                           
template <class T>
class  ITLegacyCallMediaControl2Vtbl : public ITLegacyCallMediaControl2
{
};
                                                                           

template <class T>
class  ITBasicCallControl2Vtbl : public ITBasicCallControl2
{
};


class CAddress;
class CCallHub;
class CCallStateEvent;
class CCallNotificationEvent;

/////////////////////////////////////////////////////////////////////////////
// CCall
/////////////////////////////////////////////////////////////////////////////
class CCall :
    public CTAPIComObjectRoot<CCall>,
    public IDispatchImpl<ITCallInfo2Vtbl<CCall>, &IID_ITCallInfo2, &LIBID_TAPI3Lib>,
    public IDispatchImpl<ITBasicCallControl2Vtbl<CCall>, &IID_ITBasicCallControl2, &LIBID_TAPI3Lib>,
    public IDispatchImpl<ITLegacyCallMediaControl2Vtbl<CCall>, &IID_ITLegacyCallMediaControl2, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
    
public:

    CCall() : m_pMSPCall(NULL),
              m_CallState(CS_IDLE),
              m_pAddressLine(NULL),
              m_dwCallFlags(CALLFLAG_CALLINFODIRTY),
              m_dwMediaMode(0),
              m_pPrivate(NULL),
              m_pCallHub(NULL),
              m_pCallInfo(NULL),
              m_pCallParams(NULL),
              m_hConnectedEvent(NULL),
              m_szDestAddress(NULL),
              m_dwCountryCode(0),
              m_bReleased(FALSE),
              m_dwMinRate(0),
              m_dwMaxRate(0),
              m_pRelatedCall(NULL)

    {
        LOG((TL_TRACE, "CCall[%p] - enter", this));
        LOG((TL_TRACE, "CCall - exit"));
    }

    ~CCall()
    {
        LOG((TL_TRACE, "~CCall[%p] - enter", this));
        LOG((TL_TRACE, "~CCall - exit"));
    }

DECLARE_DEBUG_ADDREF_RELEASE(CCall)
DECLARE_QI()
DECLARE_MARSHALQI(CCall)
DECLARE_TRACELOG_CLASS(CCall)

BEGIN_COM_MAP(CCall)
    COM_INTERFACE_ENTRY2(IDispatch, ITCallInfo2)
    COM_INTERFACE_ENTRY(ITCallInfo)
    COM_INTERFACE_ENTRY(ITCallInfo2)
    COM_INTERFACE_ENTRY_FUNC(IID_ITBasicCallControl, 0, MyBasicCallControlQI)
    COM_INTERFACE_ENTRY(ITBasicCallControl)
    COM_INTERFACE_ENTRY_FUNC(IID_ITBasicCallControl2, 0, MyBasicCallControlQI)
    COM_INTERFACE_ENTRY(ITBasicCallControl2)
    COM_INTERFACE_ENTRY(ITLegacyCallMediaControl)    
    COM_INTERFACE_ENTRY(ITLegacyCallMediaControl2)     
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
    COM_INTERFACE_ENTRY_AGGREGATE_BLIND(m_pMSPCall)
    COM_INTERFACE_ENTRY_AGGREGATE_BLIND(m_pPrivate)
END_COM_MAP()

    //
    // check the aggregated objects to see if they support the interface requested.
    // if they do, return the non-delegating IUnknown of the first object that 
    // supports the interface.
    //
    // it needs to be released by the caller.
    //

    HRESULT QIOnAggregates(REFIID riid, IUnknown **ppNonDelegatingUnknown);

    void FinalRelease(){}
    BOOL ExternalFinalRelease();

    //
    // public access functions to call object
    // these are used by the address and callhub objects
    // mostly to access stuff in the call
    //
    HRESULT Initialize(
                       CAddress * pAddress,
                       BSTR lpszDestAddress,
                       long lAddressType,
                       long lMediaType,
                       CALL_PRIVILEGE cp,
                       BOOL bNeedToNotify,
                       BOOL bExpose,
                       HCALL hCall,
                       CEventMasks* pEventMasks
                      );
    HRESULT CallStateEvent( PASYNCEVENTMSG pParams );
    HRESULT MediaModeEvent( PASYNCEVENTMSG pParam );
    HRESULT GatherDigitsEvent( PASYNCEVENTMSG pParams );
    HRESULT CallInfoChangeEvent( CALLINFOCHANGE_CAUSE cic );
    HRESULT CreateMSPCall( long lMediaType );
    HCALL GetHCall();
	AddressLineStruct * GetPAddressLine();
    BOOL DontExpose();
    CCall * GetOtherParty();
    void FinishSettingUpCall( HCALL hCall );
    void SetCallHub( CCallHub * pCallHub );
    void SetCallInfoDirty();
    CAddress * GetCAddress();
    ITStreamControl * GetStreamControl();
    IUnknown * GetMSPCall();
    CCallHub * GetCallHub();

    //
    // this function is called by the address object when it is notified of 
    // tapi object's shutdown. in this function, the call object gets a chance 
    // to clean up.
    //

    void CallOnTapiShutdown();

protected:
//    IUnknown                      * m_pFTM;
    
private:
    // owning address object
    CAddress                      * m_pAddress;
    // dest address
    PWSTR                           m_szDestAddress;
    // current call state
    CALL_STATE                      m_CallState;
    // current call priv
    CALL_PRIVILEGE                  m_CallPrivilege;
    // current mediamode
    DWORD                           m_dwMediaMode;
    // the MSP call
    IUnknown                      * m_pMSPCall;
    // Context handle passed to MSP Call
    MSP_HANDLE                      m_MSPCallHandle;
    // call flags ( see defines above )
    DWORD                           m_dwCallFlags;
    // this call's t3call
    T3CALL                          m_t3Call;
    // used in consult calls to ID the original call (needed to complete transf etc)    
    HCALL                           m_hAdditionalCall;
    // related call
    CCall                         * m_pRelatedCall;
    // address line being used
    AddressLineStruct             * m_pAddressLine;
    // private object
    IUnknown                      * m_pPrivate;
    // related call hub
    CCallHub                      * m_pCallHub;
    // cached callinfo structure
    LINECALLINFO                  * m_pCallInfo;
    // cached callparams structure
    LINECALLPARAMS                * m_pCallParams;
    // used size of m_pcallparams
    DWORD                           m_dwCallParamsUsedSize;
    // if call is sync, need an event to signal
    HANDLE                          m_hConnectedEvent;
    // country code - the app can set this, but it's not part of callparams
    DWORD                           m_dwCountryCode;
    // protect against releasing twice
    BOOL                            m_bReleased;
    // Can't get these from TAPISRV so remember what gets set
    DWORD                           m_dwMinRate;
    DWORD                           m_dwMaxRate;
    // queue for GatherDigits buffers
    CTArray<LPWSTR>                 m_GatherDigitsQueue;

    //
    // private functions inside the call object.
    //
    void SetMediaMode( DWORD dwMediaMode );
    void SetCallState( CALL_STATE cs );
    void ResetCallParams();
    void FinishCallParams();
    void ClearConnectedEvent();
    void SetRelatedCall(CCall* pCall, DWORD callFlags); 
    void ResetRelatedCall();
    void AddCallToHashTable();
    void RemoveCallFromHashTable();


    //
    // get an addreffed address line that corresponds to this address line 
    // handle
    //

    AddressLineStruct *GetAddRefAddressLine(DWORD dwAddressLineHandle);
    

public:

    //
    // get addreff'ed address line that belongs to this call.
    //

    AddressLineStruct *GetAddRefMyAddressLine();


    //
    // release address line received from GetAddRefAddressLine or GetAddRefMyAddressLine
    //

    HRESULT ReleaseAddressLine(AddressLineStruct *pLine);


public:
    //
    // get the callback instance associated with the address line represented
    // by dwAddressLineHandle handle
    //

    HRESULT GetCallBackInstance(IN DWORD dwAddressLineHandle,
                                OUT long *plCallbackInstance);


public:
    BOOL OnWaveMSPCall(); // called in event handler
private:
#ifdef USE_PHONEMSP
    BOOL OnPhoneMSPCall();
#endif USE_PHONEMSP
    CCall * FindConferenceControllerCall();
    HANDLE CreateConnectedEvent();
    
    HRESULT TryToFindACallHub();
    HRESULT DialConsultCall(BOOL bSync);
    HRESULT WaitForCallState( CALL_STATE requiredCS );
    HRESULT CheckAndCreateFakeCallHub();
    HRESULT UpdateStateAndPrivilege();
    HRESULT OnConnect();
    HRESULT OnDisconnect();
    HRESULT OnConference();
    HRESULT OnOffering();
    HRESULT ProcessNewCallState(
                DWORD dwCallState,
                DWORD dwDetail,
                CALL_STATE CurrentCallState,
                CALL_STATE * pCallState,
                CALL_STATE_EVENT_CAUSE * pCallStateCause
                );

    HRESULT RefreshCallInfo();
    HRESULT ResizeCallParams( DWORD );
    HRESULT SendUserUserInfo(HCALL hCall, long lSize, BYTE * pBuffer);
    HRESULT SaveUserUserInfo(long lSize,BYTE * pBuffer);
    HRESULT SyncWait( HANDLE hEvent );
    HRESULT StartWaveMSPStream();
    HRESULT StopWaveMSPStream();
    HRESULT SuspendWaveMSPStream();
public:
    HRESULT ResumeWaveMSPStream(); // called in event handler
private:
#ifdef USE_PHONEMSP
    HRESULT StartPhoneMSPStream();
    HRESULT StopPhoneMSPStream();
#endif USE_PHONEMSP
    HRESULT DialAsConsultationCall(
                                   CCall * pRelatedCall,
                                   DWORD   dwCallFeatures,
                                   BOOL    bConference,
                                   BOOL    bSync
                                  );
    HRESULT OneStepTransfer(
                            CCall *pConsultationCall,
                            VARIANT_BOOL bSync
                            );


public:
#ifdef NEWCALLINFO
    STDMETHOD(get_Address)(ITAddress ** ppAddress);
    STDMETHOD(get_CallState)(CALL_STATE * pCallState);
    STDMETHOD(get_Privilege)(CALL_PRIVILEGE * pPrivilege);
    STDMETHOD(get_CallHub)(ITCallHub ** ppCallHub);
    STDMETHOD(get_CallInfoLong)(
                                CALLINFO_LONG CallInfoLong,
                                long * plCallInfoLongVal
                               );
    STDMETHOD(put_CallInfoLong)(
                                CALLINFO_LONG CallInfoLong,
                                long lCallInfoLongVal
                               );
    STDMETHOD(get_CallInfoString)(
                                  CALLINFO_STRING CallInfoString,
                                  BSTR * ppCallInfoString
                                 );
    STDMETHOD(put_CallInfoString)(
                                  CALLINFO_STRING CallInfoString,
                                  BSTR pCallInfoString
                                 );
    STDMETHOD(get_CallInfoBuffer)(
                                  CALLINFO_BUFFER CallInfoBuffer,
                                  VARIANT * ppCallInfoBuffer
                                 );
    STDMETHOD(put_CallInfoBuffer)(
                                  CALLINFO_BUFFER CallInfoBuffer,
                                  VARIANT pCallInfoBuffer
                                 );
    STDMETHOD(GetCallInfoBuffer)(
            CALLINFO_BUFFER CallInfoBuffer,
            DWORD * pdwSize,
            BYTE ** ppCallInfoBuffer
            );
    STDMETHOD(SetCallInfoBuffer)(
            CALLINFO_BUFFER CallInfoBuffer,
            DWORD dwSize,
            BYTE * pCallInfoBuffer
            );
    STDMETHOD(ReleaseUserUserInfo)();

    HRESULT get_MediaTypesAvailable(long * plMediaTypes);
    HRESULT get_CallerIDAddressType(long * plAddressType );
    HRESULT get_CalledIDAddressType(long * plAddressType );
    HRESULT get_ConnectedIDAddressType(long * plAddressType );
    HRESULT get_RedirectionIDAddressType(long * plAddressType );
    HRESULT get_RedirectingIDAddressType(long * plAddressType );    
    HRESULT get_BearerMode(long * plBearerMode);
    HRESULT put_BearerMode(long lBearerMode);
    HRESULT get_Origin(long * plOrigin );
    HRESULT get_Reason(long * plReason );
    HRESULT get_CallerIDName(BSTR * ppCallerIDName );
    HRESULT get_CallerIDNumber(BSTR * ppCallerIDNumber );
    HRESULT get_CalledIDName(BSTR * ppCalledIDName );
    HRESULT get_CalledIDNumber(BSTR * ppCalledIDNumber );
    HRESULT get_ConnectedIDName(BSTR * ppConnectedIDName );
    HRESULT get_ConnectedIDNumber(BSTR * ppConnectedIDNumber );
    HRESULT get_RedirectionIDName(BSTR * ppRedirectionIDName );
    HRESULT get_RedirectionIDNumber(BSTR * ppRedirectionIDNumber );
    HRESULT get_RedirectingIDName(BSTR * ppRedirectingIDName );
    HRESULT get_RedirectingIDNumber(BSTR * ppRedirectingIDNumber );
    HRESULT get_CalledPartyFriendlyName(BSTR * ppCalledPartyFriendlyName );
    HRESULT put_CalledPartyFriendlyName(BSTR pCalledPartyFriendlyName );
    HRESULT get_Comment(BSTR * ppComment );
    HRESULT put_Comment(BSTR pComment );
    HRESULT GetUserUserInfo(DWORD * pdwSize, BYTE ** ppBuffer );
    HRESULT SetUserUserInfo(long lSize, BYTE * pBuffer );
    HRESULT get_UserUserInfo(VARIANT * pUUI);
    HRESULT put_UserUserInfo(VARIANT UUI);
    HRESULT get_AppSpecific(long * plAppSpecific );
    HRESULT put_AppSpecific(long lAppSpecific );
    HRESULT GetDevSpecificBuffer(DWORD * pdwSize, BYTE ** ppDevSpecificBuffer);
    HRESULT SetDevSpecificBuffer(long lSize, BYTE * pDevSpecificBuffer);
    HRESULT get_DevSpecificBuffer(VARIANT * pBuffer);
    HRESULT put_DevSpecificBuffer(VARIANT Buffer);
    HRESULT SetCallParamsFlags(long lFlags);
    HRESULT GetCallParamsFlags(long * plFlags);
    HRESULT put_DisplayableAddress(BSTR pDisplayableAddress);
    HRESULT get_DisplayableAddress(BSTR * ppDisplayableAddress);
    HRESULT GetCallDataBuffer(DWORD * pdwSize, BYTE ** ppBuffer);
    HRESULT SetCallDataBuffer(long lSize, BYTE * pBuffer);
    HRESULT put_CallDataBuffer(VARIANT Buffer);
    HRESULT get_CallDataBuffer(VARIANT * pBuffer);
    HRESULT put_CallingPartyID(BSTR pCallingPartyID);
    HRESULT get_CallingPartyID(BSTR * ppCallingPartyID);
    HRESULT put_CallTreatment(long lTreatment);
    HRESULT get_CallTreatment(long * plTreatment);
    HRESULT put_MinRate(long lMinRate);
    HRESULT get_MinRate(long * plMinRate);
    HRESULT put_MaxRate(long lMaxRate);
    HRESULT get_MaxRate(long * plMaxRate);
    HRESULT put_CountryCode(long lCountryCode);
    HRESULT get_CountryCode(long * plCountryCode);
    HRESULT get_CallId(long * plCallId );
    HRESULT get_RelatedCallId(long * plCallId );
    HRESULT get_CompletionId(long * plCompletionId );
    HRESULT get_NumberOfOwners(long * plNumberOfOwners );
    HRESULT get_NumberOfMonitors(long * plNumberOfMonitors );
    HRESULT get_Trunk(long * plTrunk );
    HRESULT GetChargingInfoBuffer(DWORD * pdwSize, BYTE ** ppBuffer);
    HRESULT get_ChargingInfoBuffer(VARIANT * pBuffer );
    HRESULT SetHighLevelCompatibilityBuffer(long lSize, BYTE * pBuffer);
    HRESULT GetHighLevelCompatibilityBuffer(DWORD * pdwSize, BYTE ** ppBuffer);
    HRESULT put_HighLevelCompatibilityBuffer(VARIANT Buffer );
    HRESULT get_HighLevelCompatibilityBuffer(VARIANT * pBuffer );
    HRESULT SetLowLevelCompatibilityBuffer(long lSize, BYTE * pBuffer);
    HRESULT GetLowLevelCompatibilityBuffer(DWORD * pdwSize, BYTE ** ppBuffer);
    HRESULT put_LowLevelCompatibilityBuffer(VARIANT Buffer );
    HRESULT get_LowLevelCompatibilityBuffer(VARIANT * pBuffer );
    HRESULT get_Rate(long * plRate );
    HRESULT put_GenerateDigitDuration( long lGenerateDigitDuration );
    HRESULT get_GenerateDigitDuration( long * plGenerateDigitDuration );
    HRESULT get_MonitorDigitModes( long * plMonitorDigitModes );
    HRESULT get_MonitorMediaModes( long * plMonitorMediaModes );
    
#else
    
    // ITCallInfo methods
    STDMETHOD(get_Address)(ITAddress ** ppAddress);
    STDMETHOD(get_CallState)(CALL_STATE * pCallState);
    STDMETHOD(get_Privilege)(CALL_PRIVILEGE * pPrivilege);
    STDMETHOD(get_MediaTypesAvailable)(long * plMediaTypes);
    STDMETHOD(get_CallHub)(ITCallHub ** ppCallHub);
    STDMETHOD(get_AddressType)(long * plAddressType );
    STDMETHOD(put_AddressType)(long lAddressType );
    STDMETHOD(get_BearerMode)(long * plBearerMode);
    STDMETHOD(put_BearerMode)(long lBearerMode);
    STDMETHOD(get_Origin)(long * plOrigin );
    STDMETHOD(get_Reason)(long * plReason );
    STDMETHOD(get_CallerIDName)(BSTR * ppCallerIDName );
    STDMETHOD(get_CallerIDNumber)(BSTR * ppCallerIDNumber );
    STDMETHOD(get_CalledIDName)(BSTR * ppCalledIDName );
    STDMETHOD(get_CalledIDNumber)(BSTR * ppCalledIDNumber );
    STDMETHOD(get_ConnectedIDName)(BSTR * ppConnectedIDName );
    STDMETHOD(get_ConnectedIDNumber)(BSTR * ppConnectedIDNumber );
    STDMETHOD(get_RedirectionIDName)(BSTR * ppRedirectionIDName );
    STDMETHOD(get_RedirectionIDNumber)(BSTR * ppRedirectionIDNumber );
    STDMETHOD(get_RedirectingIDName)(BSTR * ppRedirectingIDName );
    STDMETHOD(get_RedirectingIDNumber)(BSTR * ppRedirectingIDNumber );
    STDMETHOD(get_CalledPartyFriendlyName)(BSTR * ppCalledPartyFriendlyName );
    STDMETHOD(put_CalledPartyFriendlyName)(BSTR pCalledPartyFriendlyName );
    STDMETHOD(get_Comment)(BSTR * ppComment );
    STDMETHOD(put_Comment)(BSTR pComment );
    STDMETHOD(GetUserUserInfoSize)(long * plSize );
    STDMETHOD(GetUserUserInfo)(long lSize, BYTE * pBuffer );
    STDMETHOD(SetUserUserInfo)(long lSize, BYTE * pBuffer );
    STDMETHOD(get_UserUserInfo)(VARIANT * pUUI);
    STDMETHOD(put_UserUserInfo)(VARIANT UUI);
    STDMETHOD(ReleaseUserUserInfo)();
    STDMETHOD(get_AppSpecific)(long * plAppSpecific );
    STDMETHOD(put_AppSpecific)(long lAppSpecific );
    STDMETHOD(GetDevSpecificBufferSize)(long * plDevSpecificSize );
    STDMETHOD(GetDevSpecificBuffer)(long lSize, BYTE * pDevSpecificBuffer);
    STDMETHOD(SetDevSpecificBuffer)(long lSize, BYTE * pDevSpecificBuffer);
    STDMETHOD(get_DevSpecificBuffer)(VARIANT * pBuffer);
    STDMETHOD(put_DevSpecificBuffer)(VARIANT Buffer);
    STDMETHOD(SetCallParamsFlags)(long lFlags);
    STDMETHOD(put_DisplayableAddress)(BSTR pDisplayableAddress);
    STDMETHOD(get_DisplayableAddress)(BSTR * ppDisplayableAddress);
    STDMETHOD(GetCallDataBufferSize)(long * plSize);
    STDMETHOD(GetCallDataBuffer)(long lSize, BYTE * pBuffer);
    STDMETHOD(SetCallDataBuffer)(long lSize, BYTE * pBuffer);
    STDMETHOD(put_CallDataBuffer)(VARIANT Buffer);
    STDMETHOD(get_CallDataBuffer)(VARIANT * pBuffer);
    STDMETHOD(put_CallingPartyID)(BSTR pCallingPartyID);
    STDMETHOD(get_CallingPartyID)(BSTR * ppCallingPartyID);
    STDMETHOD(put_CallTreatment)(long lTreatment);
    STDMETHOD(get_CallTreatment)(long * plTreatment);
    STDMETHOD(put_MinRate)(long lMinRate);
    STDMETHOD(get_MinRate)(long * plMinRate);
    STDMETHOD(put_MaxRate)(long lMaxRate);
    STDMETHOD(get_MaxRate)(long * plMaxRate);
    STDMETHOD(put_CountryCode)(long lCountryCode);

    STDMETHOD (get_CallId)(long * plCallId );
    STDMETHOD (get_RelatedCallId)(long * plCallId );
    STDMETHOD (get_CompletionId)(long * plCompletionId );
    STDMETHOD (get_NumberOfOwners)(long * plNumberOfOwners );
    STDMETHOD (get_NumberOfMonitors)(long * plNumberOfMonitors );
    STDMETHOD (get_Trunk)(long * plTrunk );
    
    STDMETHOD (GetChargingInfoBufferSize)(long * plSize );
    STDMETHOD (GetChargingInfoBuffer)(long lSize, BYTE * pBuffer);
    STDMETHOD (get_ChargingInfoBuffer)(VARIANT * pBuffer );

    STDMETHOD (GetHighLevelCompatibilityBufferSize)(long * plSize );
    STDMETHOD (SetHighLevelCompatibilityBuffer)(long lSize, BYTE * pBuffer);
    STDMETHOD (GetHighLevelCompatibilityBuffer)(long lSize, BYTE * pBuffer);
    STDMETHOD (put_HighLevelCompatibilityBuffer)(VARIANT Buffer );
    STDMETHOD (get_HighLevelCompatibilityBuffer)(VARIANT * pBuffer );

    STDMETHOD (GetLowLevelCompatibilityBufferSize)(long * plSize );
    
    STDMETHOD (SetLowLevelCompatibilityBuffer)(long lSize, BYTE * pBuffer);
    STDMETHOD (GetLowLevelCompatibilityBuffer)(long lSize, BYTE * pBuffer);
    STDMETHOD (put_LowLevelCompatibilityBuffer)(VARIANT Buffer );
    STDMETHOD (get_LowLevelCompatibilityBuffer)(VARIANT * pBuffer );
    STDMETHOD (get_Rate)(long * plRate );
#endif

    // ITCallInfo2
    STDMETHOD(get_EventFilter)(
        TAPI_EVENT      TapiEvent,
        long            lSubEvent,
        VARIANT_BOOL*   pEnable
        );

    STDMETHOD(put_EventFilter)(
        TAPI_EVENT      TapiEvent,
        long            lSubEvent,
        VARIANT_BOOL    bEnable
        );
    
    // ITBasicCallControl methods
    STDMETHOD(Connect)(VARIANT_BOOL bSync);
    STDMETHOD(Answer)(void);
    STDMETHOD(Disconnect)(DISCONNECT_CODE code);
    STDMETHOD(Hold)(VARIANT_BOOL bHold);
    STDMETHOD(HandoffDirect)(BSTR pApplicationName);
    STDMETHOD(HandoffIndirect)(long lMediaType);
    STDMETHOD(Conference)(
        ITBasicCallControl * pCall,
        VARIANT_BOOL bSync
        );
    STDMETHOD(CreateConference)(
        CCall  * pConsultationCall,
        VARIANT_BOOL bSync
        );
    STDMETHOD(AddToConference)(
        CCall  * pConsultationCall,
        VARIANT_BOOL bSync
        );
    STDMETHOD(BlindTransfer)(BSTR pDestAddress);
    STDMETHOD(Transfer)(
        ITBasicCallControl * pCall,
        VARIANT_BOOL bSync
        );
    STDMETHOD(SwapHold)(ITBasicCallControl * pCall);
    STDMETHOD(ParkDirect)(BSTR pParkAddress);
    STDMETHOD(ParkIndirect)(BSTR * ppNonDirAddress);
    STDMETHOD(Unpark)();
    STDMETHOD(SetQOS)(
        long lMediaType,
        QOS_SERVICE_LEVEL ServiceLevel
        );
    STDMETHOD(Pickup)( BSTR pGroupID );
    STDMETHOD(Dial)( BSTR pDestAddress );
    STDMETHOD(Finish)(FINISH_MODE   finishMode);
    STDMETHOD(RemoveFromConference)(void);

    // ITBasicCallControl2
    STDMETHOD(RequestTerminal)(
        IN  BSTR bstrTerminalClassGUID,
        IN  long lMediaType,
        IN  TERMINAL_DIRECTION  Direction,
        OUT ITTerminal** ppTerminal
        );

    STDMETHOD(SelectTerminalOnCall)(
        IN  ITTerminal *pTerminal
        );

    STDMETHOD(UnselectTerminalOnCall)(
        IN  ITTerminal *pTerminal
        );

    // ITLegacyCallMediaControl
    STDMETHOD(DetectDigits)(TAPI_DIGITMODE DigitMode);
    STDMETHOD(GenerateDigits)(
            BSTR pDigits,
            TAPI_DIGITMODE DigitMode
            );
    STDMETHOD(GetID)(
                     BSTR pDeviceClass,
                     DWORD * pdwSize,
                     BYTE ** ppDeviceID
                    );
    STDMETHOD(SetMediaType)(long lMediaType);
    STDMETHOD(MonitorMedia)(long lMediaType);

    // ITLegacyCallMediaControl2
    STDMETHOD(GenerateDigits2)(
                               BSTR pDigits,
                               TAPI_DIGITMODE DigitMode,
                               long lDuration
                              );

    STDMETHOD(GatherDigits)(
                            TAPI_DIGITMODE DigitMode,
                            long lNumDigits,
                            BSTR pTerminationDigits,
                            long lFirstDigitTimeout,
                            long lInterDigitTimeout
                           );

    STDMETHOD(DetectTones)(
                          TAPI_DETECTTONE * pToneList,
                          long lNumTones
                         );

    STDMETHOD(DetectTonesByCollection)(
                                       ITCollection2 * pDetectToneCollection
                                      );

    STDMETHOD(GenerateTone)(
                            TAPI_TONEMODE ToneMode,
                            long lDuration
                           );

    STDMETHOD(GenerateCustomTones)(
                                  TAPI_CUSTOMTONE * pToneList,
                                  long lNumTones,
                                  long lDuration
                                 );

    STDMETHOD(GenerateCustomTonesByCollection)(
                                               ITCollection2 * pCustomToneCollection,
                                               long lDuration
                                              );

    STDMETHOD(CreateDetectToneObject)(
                                      ITDetectTone ** ppDetectTone
                                     );

    STDMETHOD(CreateCustomToneObject)(
                                      ITCustomTone ** ppCustomTone
                                     );

    STDMETHOD(GetIDAsVariant)(IN BSTR bstrDeviceClass,
                              OUT VARIANT *pVarDeviceID);

    
    // IDispatch  Methods
    STDMETHOD(GetIDsOfNames)(REFIID riid, 
                             LPOLESTR* rgszNames,
                             UINT cNames, 
                             LCID lcid, 
                             DISPID* rgdispid
                            );
    STDMETHOD(Invoke)(DISPID dispidMember, 
                      REFIID riid, 
                      LCID lcid,
                      WORD wFlags, 
                      DISPPARAMS* pdispparams, 
                      VARIANT* pvarResult,
                      EXCEPINFO* pexcepinfo, 
                      UINT* puArgErr
                      );


    STDMETHOD_(ULONG, InternalAddRef)()
    {
        DWORD dwR;

        dwR = InterlockedIncrement(&m_dwRef);;

    #if DBG
        LogDebugAddRef(m_dwRef);
    #endif

        return dwR;
    }

    
    STDMETHOD_(ULONG, InternalRelease)()
    {

        Lock();

        LOG((TL_INFO, "InternalRelease - enter m_dwRef = %ld", m_dwRef));


        gpCallHashTable->Lock();
        gpHandleHashTable->Lock();
        
        DWORD dwR = InterlockedDecrement(&m_dwRef);

        // if ref count is 1 (means we entered function with 2) then we final release
        if (1 == dwR)
        {
            // make sure we only call ExternalFinalRelease  & delete once
            if(m_bReleased == FALSE)
            {
                m_bReleased = TRUE;

                LOG((TL_TRACE, "InternalRelease - final" ));

                // remove from the hash table, so any more messages
                // from tapisrv are ignored
                //
                gpCallHashTable->Remove( (ULONG_PTR)(m_t3Call.hCall) );
                gpCallHashTable->Unlock();

                // remove from the handle hash table, so any more messages
                // from msp are ignored
                //
                RemoveHandleFromHashTable((ULONG_PTR)m_MSPCallHandle);
                gpHandleHashTable->Unlock();


                ExternalFinalRelease();
                dwR = m_dwRef = 0;

                Unlock();

            }
            else
            {
                gpCallHashTable->Unlock();
                gpHandleHashTable->Unlock();
                Unlock();
                LOG((TL_INFO, "InternalRelease - m_bReleased is TRUE. dwR[%ld]", dwR));
            }
            
                
        }
        else
        {
            gpCallHashTable->Unlock();
            gpHandleHashTable->Unlock();
            Unlock();
        }

     

        #if DBG  
            LogDebugRelease( dwR );
        #endif


        LOG((TL_INFO, "InternalRelease - exit. refcount %ld", dwR));

        return dwR;
    }

protected:
    HRESULT SelectSingleTerminalOnCall(
        IN  ITTerminal* pTerminal,
        OUT long*       pMediaType,
        OUT TERMINAL_DIRECTION* pDirection);

    HRESULT SelectMultiTerminalOnCall(
        IN  ITMultiTrackTerminal* pTerminal);

    HRESULT IsRightStream(
        IN  ITStream*   pStream,
        IN  ITTerminal* pTerminal,
        OUT long*       pMediaType = NULL,
        OUT TERMINAL_DIRECTION* pDirection = NULL);

    int GetStreamIndex(
        IN  long    lMediaType,
        IN  TERMINAL_DIRECTION Direction);

    HRESULT UnSelectSingleTerminalFromCall(
        IN  ITTerminal* pTerminal);

    HRESULT UnSelectMultiTerminalFromCall(
        IN  ITMultiTrackTerminal* pTerminal);

    //
    // Helper methods for CreateTerminal
    //
    BOOL    IsStaticGUID(
        BSTR    bstrTerminalGUID);

    HRESULT CreateStaticTerminal(
        IN  BSTR bstrTerminalClassGUID,
        IN  TERMINAL_DIRECTION  Direction,
        IN  long lMediaType,
        OUT ITTerminal** ppTerminal
        );

    HRESULT CreateDynamicTerminal(
        IN  BSTR bstrTerminalClassGUID,
        IN  TERMINAL_DIRECTION  Direction,
        IN  long lMediaType,
        OUT ITTerminal** ppTerminal
        );
public:
    //
    // Sets the subevent flag
    //
    HRESULT SetSubEventFlag(
        IN  TAPI_EVENT  TapiEvent,
        IN  DWORD       dwSubEvent,
        IN  BOOL        bEnable
        );

    HRESULT GetSubEventFlag(
        TAPI_EVENT  TapiEvent,
        DWORD       dwSubEvent,
        BOOL*       pEnable
        );

    // Get subevents mask
    DWORD GetSubEventsMask(
        IN  TAPI_EVENT TapiEvent
        );

    //Get the conference controller call object if one exists.
    CCall* GetConfControlCall();
    
private:
    //
    // Helper methods for event filtering
    //

    CEventMasks     m_EventMasks;

    HRESULT IsTerminalSelected(
        IN ITTerminal* pTerminal,
        OUT BOOL*   pSelected
        );

};


/////////////////////////////////////////////////////////////////////////////
// CDetectTone
/////////////////////////////////////////////////////////////////////////////
class CDetectTone : 
    public CTAPIComObjectRoot<CDetectTone>,
    public IDispatchImpl<ITDetectTone, &IID_ITDetectTone, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
public:

    CDetectTone()
    {
        m_lAppSpecific  = 0;
        m_lDuration     = 0;
        m_lFrequency[0] = 0;
        m_lFrequency[1] = 0;
        m_lFrequency[2] = 0;
    }

DECLARE_MARSHALQI(CDetectTone)
DECLARE_QI()
DECLARE_TRACELOG_CLASS(CDetectTone)

BEGIN_COM_MAP(CDetectTone)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITDetectTone)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

protected:

    long                      m_lAppSpecific;
    long                      m_lDuration;
    long                      m_lFrequency[3];

public:
    
    STDMETHOD(put_AppSpecific)( long lAppSpecific );
    STDMETHOD(get_AppSpecific)( long * plAppSpecific );
    STDMETHOD(put_Duration)( long lDuration );
    STDMETHOD(get_Duration)( long * plDuration );
    STDMETHOD(put_Frequency)(
                             long Index,
                             long lFrequency
                            );
    STDMETHOD(get_Frequency)(
                             long Index,
                             long * plFrequency
                            );
};

/////////////////////////////////////////////////////////////////////////////
// CCustomTone
/////////////////////////////////////////////////////////////////////////////
class CCustomTone : 
    public CTAPIComObjectRoot<CCustomTone>,
    public IDispatchImpl<ITCustomTone, &IID_ITCustomTone, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
public:

    CCustomTone()
    {
        m_lFrequency  = 0;
        m_lCadenceOn  = 0;
        m_lCadenceOff = 0;
        m_lVolume     = 0;
    }

DECLARE_MARSHALQI(CCustomTone)
DECLARE_QI()
DECLARE_TRACELOG_CLASS(CCustomTone)

BEGIN_COM_MAP(CCustomTone)
	COM_INTERFACE_ENTRY2(IDispatch, ITCustomTone)
    COM_INTERFACE_ENTRY(ITCustomTone)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

protected:

    long                      m_lFrequency;
    long                      m_lCadenceOn;
    long                      m_lCadenceOff;
    long                      m_lVolume;
    

public:
    
    STDMETHOD(put_Frequency)( long lFrequency );
    STDMETHOD(get_Frequency)( long * plFrequency );
    STDMETHOD(put_CadenceOn)( long lCadenceOn );
    STDMETHOD(get_CadenceOn)( long * plCadenceOn );
    STDMETHOD(put_CadenceOff)( long lCadenceOff );
    STDMETHOD(get_CadenceOff)( long * plCadenceOff );
    STDMETHOD(put_Volume)( long lVolume );
    STDMETHOD(get_Volume)( long * plVolume );
};


#endif //__CALL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\callevnt.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    callevnt.h

Abstract:

    
Author:

    mquinton  09-04-98

Notes:

Revision History:

--*/

#ifndef __CALLEVNT_H_
#define __CALLEVNT_H_

class CCallStateEvent :
    public CTAPIComObjectRoot<CCallStateEvent, CComMultiThreadModelNoCS>,
    public CComDualImpl<ITCallStateEvent, &IID_ITCallStateEvent, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
public:

    CCallStateEvent(){}

    void
    FinalRelease();

    static HRESULT FireEvent(
                             ITCallInfo * pCall,
                             CALL_STATE state,
                             CALL_STATE_EVENT_CAUSE cause,
                             CTAPI * pTapi,
                             long lCallbackInstance
                            );

DECLARE_MARSHALQI(CCallStateEvent)
DECLARE_QI()
DECLARE_TRACELOG_CLASS(CCallStateEvent)

BEGIN_COM_MAP(CCallStateEvent)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITCallStateEvent)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

protected:

    ITCallInfo * m_pCall;
    CALL_STATE m_CallState;
    CALL_STATE_EVENT_CAUSE m_CallStateEventCause;
    long m_lCallbackInstance;

#if DBG
    PWSTR               m_pDebug;
#endif
    
    
public:

    STDMETHOD(get_Call)(ITCallInfo ** ppCallInfo);
    STDMETHOD(get_State)(CALL_STATE * pCallState);
    STDMETHOD(get_Cause)(CALL_STATE_EVENT_CAUSE * pCEC);
    STDMETHOD(get_CallbackInstance)(long * plCallbackInstance);
};


class CCallNotificationEvent : 
    public CTAPIComObjectRoot<CCallNotificationEvent, CComMultiThreadModelNoCS>,
    public CComDualImpl<ITCallNotificationEvent, &IID_ITCallNotificationEvent, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
public:

    CCallNotificationEvent(){}

    void
    FinalRelease();

    static HRESULT FireEvent(
                             ITCallInfo * pCall,
                             CALL_NOTIFICATION_EVENT CallNotificationEvent,
                             CTAPI * pTapi,
                             long lCallbackInstance
                            );

DECLARE_MARSHALQI(CCallNotificationEvent)
DECLARE_QI()
DECLARE_TRACELOG_CLASS(CCallNotificationEvent)

BEGIN_COM_MAP(CCallNotificationEvent)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITCallNotificationEvent)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

protected:

    ITCallInfo *        m_pCall;
    CALL_NOTIFICATION_EVENT m_CallNotificationEvent;
    long                m_lCallbackInstance;
    
#if DBG
    PWSTR               m_pDebug;
#endif
    
public:
    
    STDMETHOD(get_Call)(ITCallInfo ** ppCall);
    STDMETHOD(get_Event)(CALL_NOTIFICATION_EVENT * pCallNotificationEvent);
    STDMETHOD(get_CallbackInstance)(long * plCallbackInstance);
};


class CCallMediaEvent : 
    public CTAPIComObjectRoot<CCallMediaEvent, CComMultiThreadModelNoCS>,
    public CComDualImpl<ITCallMediaEvent, &IID_ITCallMediaEvent, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
public:

    CCallMediaEvent(){}

    void
    FinalRelease();

    static HRESULT FireEvent(
                             ITCallInfo * pCall,
                             CALL_MEDIA_EVENT Event,
                             CALL_MEDIA_EVENT_CAUSE Cause,
                             CTAPI * pTapi,
                             ITTerminal * pTerminal,
                             ITStream * pStream,
                             HRESULT hr
                            );

    
DECLARE_MARSHALQI(CCallMediaEvent)
DECLARE_QI()
DECLARE_TRACELOG_CLASS(CCallMediaEvent)

BEGIN_COM_MAP(CCallMediaEvent)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITCallMediaEvent)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()


protected:

    ITCallInfo *            m_pCall;
    CALL_MEDIA_EVENT        m_Event;
    CALL_MEDIA_EVENT_CAUSE  m_Cause;
    HRESULT                 m_hr;
    ITTerminal *            m_pTerminal;
    ITStream *              m_pStream;
    
#if DBG
    PWSTR               m_pDebug;
#endif
    
public:
    
    STDMETHOD(get_Call)(ITCallInfo ** ppCallInfo);
    STDMETHOD(get_Event)(CALL_MEDIA_EVENT * pCallMediaEvent);
    STDMETHOD(get_Cause)(CALL_MEDIA_EVENT_CAUSE * pCause);
    STDMETHOD(get_Error)(HRESULT * phrError);
    STDMETHOD(get_Terminal)(ITTerminal ** ppTerminal);
    STDMETHOD(get_Stream)(ITStream ** ppStream);

};


class CCallInfoChangeEvent : 
    public CTAPIComObjectRoot<CCallInfoChangeEvent, CComMultiThreadModelNoCS>,
    public CComDualImpl<ITCallInfoChangeEvent, &IID_ITCallInfoChangeEvent, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
public:

    CCallInfoChangeEvent(){}

    void
    FinalRelease();

    static HRESULT FireEvent(
                             ITCallInfo * pCall,
                             CALLINFOCHANGE_CAUSE Cause,
                             CTAPI * pTapi,
                             long lCallbackInstance
                            );

    
DECLARE_MARSHALQI(CCallInfoChangeEvent)
DECLARE_QI()
DECLARE_TRACELOG_CLASS(CCallInfoChangeEvent)

BEGIN_COM_MAP(CCallInfoChangeEvent)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITCallInfoChangeEvent)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

protected:

    ITCallInfo *            m_pCall;
    CALLINFOCHANGE_CAUSE    m_Cause;
    long                    m_lCallbackInstance;
    
#if DBG
    PWSTR                   m_pDebug;
#endif
    
public:
    
    STDMETHOD(get_Call)( ITCallInfo ** ppCallInfo);
    STDMETHOD(get_Cause)( CALLINFOCHANGE_CAUSE * pCallMediaCause );
    STDMETHOD(get_CallbackInstance)( long * plCallbackInstance );
};


class CQOSEvent : 
    public CTAPIComObjectRoot<CQOSEvent, CComMultiThreadModelNoCS>,
    public CComDualImpl<ITQOSEvent, &IID_ITQOSEvent, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
protected:

    ITCallInfo * m_pCall;
    long m_lMediaMode;
    QOS_EVENT m_QosEvent;
    
public:

    CQOSEvent(){}

    void
    FinalRelease();

    static HRESULT FireEvent(
                             ITCallInfo * pCall,
                             QOS_EVENT QosEvent,
                             long lMediaMode,
                             CTAPI * pTapi
                            );

DECLARE_MARSHALQI(CQOSEvent)
DECLARE_QI()
DECLARE_TRACELOG_CLASS(CQOSEvent)

BEGIN_COM_MAP(CQOSEvent)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITQOSEvent)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

    STDMETHOD(get_Call)(ITCallInfo ** ppCall );
    STDMETHOD(get_Event)(QOS_EVENT * pQosEvent );
    STDMETHOD(get_MediaType)(long * plMediaType );
};


class CDigitDetectionEvent : 
    public CTAPIComObjectRoot<CDigitDetectionEvent, CComMultiThreadModelNoCS>,
    public CComDualImpl<ITDigitDetectionEvent, &IID_ITDigitDetectionEvent, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
public:

    CDigitDetectionEvent(){}

    void
    FinalRelease();

    static HRESULT FireEvent(
                             ITCallInfo * pCall,
                             unsigned char ucDigit,
                             TAPI_DIGITMODE DigitMode,
                             long lTickCount,
                             CTAPI * pTapi,
                             long lCallbackInstance
                            );

DECLARE_MARSHALQI(CDigitDetectionEvent)
DECLARE_QI()
DECLARE_TRACELOG_CLASS(CDigitDetectionEvent)

BEGIN_COM_MAP(CDigitDetectionEvent)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITDigitDetectionEvent)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

protected:

    ITCallInfo *        m_pCall;
    unsigned char       m_Digit;
    TAPI_DIGITMODE      m_DigitMode;
    long                m_lTickCount;
    long                m_lCallbackInstance;
    
#if DBG
    PWSTR               m_pDebug;
#endif
    
public:
    
    STDMETHOD(get_Call)( ITCallInfo ** ppCallInfo );
    STDMETHOD(get_Digit)( unsigned char * pucDigit );
    STDMETHOD(get_DigitMode)( TAPI_DIGITMODE * pDigitMode );
    STDMETHOD(get_TickCount)( long * plTickCount );
    STDMETHOD(get_CallbackInstance)( long * plCallbackInstance );
};


class CDigitGenerationEvent : 
    public CTAPIComObjectRoot<CDigitGenerationEvent, CComMultiThreadModelNoCS>,
    public CComDualImpl<ITDigitGenerationEvent, &IID_ITDigitGenerationEvent, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
public:

    CDigitGenerationEvent(){}

    void
    FinalRelease();

    static HRESULT FireEvent(
                             ITCallInfo * pCall,
                             long lGenerationTermination,
                             long lTickCount,
                             long lCallbackInstance,
                             CTAPI * pTapi
                            );

DECLARE_MARSHALQI(CDigitGenerationEvent)
DECLARE_QI()
DECLARE_TRACELOG_CLASS(CDigitGenerationEvent)

BEGIN_COM_MAP(CDigitGenerationEvent)
	COM_INTERFACE_ENTRY2(IDispatch, ITDigitGenerationEvent)
    COM_INTERFACE_ENTRY(ITDigitGenerationEvent)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

protected:

    ITCallInfo              * m_pCall;
    long                      m_lGenerationTermination;
    long                      m_lTickCount;
    long                      m_lCallbackInstance;

#if DBG
    PWSTR               m_pDebug;
#endif
    

public:
    
    STDMETHOD(get_Call)( ITCallInfo ** ppCallInfo );
    STDMETHOD(get_GenerationTermination)( long * plGenerationTermination );
    STDMETHOD(get_TickCount)( long * plTickCount );
    STDMETHOD(get_CallbackInstance)( long * plCallbackInstance );
};

class CDigitsGatheredEvent : 
    public CTAPIComObjectRoot<CDigitsGatheredEvent, CComMultiThreadModelNoCS>,
    public CComDualImpl<ITDigitsGatheredEvent, &IID_ITDigitsGatheredEvent, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
public:

    CDigitsGatheredEvent(){}

    void
    FinalRelease();

    static HRESULT FireEvent(
                             ITCallInfo * pCall,
                             BSTR pDigits,
                             TAPI_GATHERTERM GatherTermination,
                             long lTickCount,
                             long lCallbackInstance,
                             CTAPI * pTapi
                            );

DECLARE_MARSHALQI(CDigitsGatheredEvent)
DECLARE_QI()
DECLARE_TRACELOG_CLASS(CDigitGatheredEvent)

BEGIN_COM_MAP(CDigitsGatheredEvent)
	COM_INTERFACE_ENTRY2(IDispatch, ITDigitsGatheredEvent)
    COM_INTERFACE_ENTRY(ITDigitsGatheredEvent)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

protected:

    ITCallInfo              * m_pCall;
    BSTR                      m_pDigits;
    TAPI_GATHERTERM           m_GatherTermination;
    long                      m_lTickCount;
    long                      m_lCallbackInstance;

#if DBG
    PWSTR               m_pDebug;
#endif
    

public:
    
    STDMETHOD(get_Call)( ITCallInfo ** ppCallInfo );
    STDMETHOD(get_Digits)( BSTR * ppDigits );
    STDMETHOD(get_GatherTermination)( TAPI_GATHERTERM * pGenerationTermination );
    STDMETHOD(get_TickCount)( long * plTickCount );
    STDMETHOD(get_CallbackInstance)( long * plCallbackInstance );
};

class CToneDetectionEvent : 
    public CTAPIComObjectRoot<CToneDetectionEvent, CComMultiThreadModelNoCS>,
    public CComDualImpl<ITToneDetectionEvent, &IID_ITToneDetectionEvent, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
public:

    CToneDetectionEvent(){}

    void
    FinalRelease();

    static HRESULT FireEvent(
                             ITCallInfo * pCall,
                             long lAppSpecific,
                             long lTickCount,
                             long lCallbackInstance,
                             CTAPI * pTapi
                            );

DECLARE_MARSHALQI(CToneDetectionEvent)
DECLARE_QI()
DECLARE_TRACELOG_CLASS(CToneDetectionEvent)

BEGIN_COM_MAP(CToneDetectionEvent)
	COM_INTERFACE_ENTRY2(IDispatch, ITToneDetectionEvent)
    COM_INTERFACE_ENTRY(ITToneDetectionEvent)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

protected:

    ITCallInfo              * m_pCall;
    long                      m_lAppSpecific;
    long                      m_lTickCount;
    long                      m_lCallbackInstance;

#if DBG
    PWSTR               m_pDebug;
#endif
    

public:
    
    STDMETHOD(get_Call)( ITCallInfo ** ppCallInfo );
    STDMETHOD(get_AppSpecific)( long * plAppSpecific );
    STDMETHOD(get_TickCount)( long * plTickCount );
    STDMETHOD(get_CallbackInstance)( long * plCallbackInstance );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\callhub.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    CallHub.h

Abstract:

    Declaration of the CCallHub Class
    
Author:

    mquinton  11-21-97

Notes:

Revision History:

--*/

#ifndef __CALLHUB_H_
#define __CALLHUB_H_

#include "resource.h"       // main symbols
#include "tapiobj.h"

extern CHashTable             * gpCallHubHashTable;

// loword of flags is type
//
// careful because even though it's a bitfield
// only one of these should be selected
//
#define CALLHUBTYPE_CALLHUB             0x00000002
#define CALLHUBTYPE_NONE                0x00000004

/////////////////////////////////////////////////////////////////////////////
// CCallHub
class CCallHub : 
	public CTAPIComObjectRoot<CCallHub>,
    public CComDualImpl<ITCallHub, &IID_ITCallHub, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
public:

    CCallHub(): m_hCallHub(NULL),
                m_pTAPI(NULL),
                m_pRootCall(NULL),
                m_pConferenceControllerCall(NULL),
                m_dwFlags(0),
                m_pPrivate(NULL),
                m_pAddress(NULL),                
     			m_bReleased(FALSE)
     {}

DECLARE_DEBUG_ADDREF_RELEASE(CCallHub)
DECLARE_QI()
DECLARE_MARSHALQI(CCallHub)
DECLARE_TRACELOG_CLASS(CCallHub)

BEGIN_COM_MAP(CCallHub)
	COM_INTERFACE_ENTRY2(IDispatch, ITCallHub)
    COM_INTERFACE_ENTRY(ITCallHub)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_AGGREGATE_BLIND(m_pPrivate)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

    BOOL ExternalFinalRelease();

protected:

    HCALLHUB                m_hCallHub;
    CallInfoArrayNR         m_CallArray;
    CTAPI                 * m_pTAPI;
    CALLHUB_STATE           m_State;
    CCall                 * m_pRootCall;
    CCall                 * m_pConferenceControllerCall;
    DWORD                   m_dwFlags;
    IUnknown              * m_pPrivate;
    CAddress              * m_pAddress;
    
#if DBG
    PWSTR                   m_pDebug;
#endif
    BOOL					m_bReleased;

  

public:

    HRESULT Initialize(
                       CTAPI * pTapi,
                       HCALLHUB hCallHub,
                       DWORD dwFlags
                      );
    CCall * GetRootCall(){ return m_pRootCall; }
    void RemoveCall(CCall * pCall);
    void AddCall(CCall * pCall);
    HRESULT FindExistingTapisrvCallhubCalls();
    HRESULT FindCallsDisconnected( BOOL * fAllCallsDisconnected );

    static HRESULT CreateTapisrvCallHub(
                                        CTAPI * pTAPI,
                                        HCALLHUB hCallHub,
                                        CCallHub ** ppCallHub
                                       );
    static HRESULT CreateFakeCallHub(
                                     CTAPI * pTAPI,
                                     CCall * pCall,
                                     CCallHub ** ppCallHub
                                    );
    HRESULT Initialize(CTAPI * pTAPI, HCALLHUB hCallHub, CCall * pCall);
    CCall * FindCallByHandle(HCALL hCall);

    void SetState( CALLHUB_STATE chs );
    void CheckForIdle();
    CTAPI * GetTapi(){ return m_pTAPI;}
    HCALLHUB GetCallHub(){ return m_hCallHub;}
    void ClearCallHub();
    HRESULT CreateConferenceControllerCall(HCALL hCall, CAddress * pAddress );
    CCall * GetConferenceControllerCall();
    
    // itcallhub
    STDMETHOD(Clear)();
    STDMETHOD(EnumerateCalls)(IEnumCall ** ppEnumCall);
    STDMETHOD(get_Calls)(VARIANT * pCalls);
    STDMETHOD(get_NumCalls)(long * plCalls);
    STDMETHOD(get_State)(CALLHUB_STATE * pState);


    

    
    STDMETHOD_(ULONG, InternalAddRef)()
    {
        DWORD dwR;

        dwR = InterlockedIncrement(&m_dwRef);;

        #if DBG
            LogDebugAddRef(m_dwRef);
        #endif

        return dwR;
    }

    
    STDMETHOD_(ULONG, InternalRelease)()
    {
        DWORD	dwR;


        LOG((TL_INFO, "InternalRelease - m_dwRef %d",m_dwRef ));
        Lock();
        gpCallHubHashTable->Lock();
        
        dwR = InterlockedDecrement(&m_dwRef);

        // if ref count is 1 (means we entered function with 2) then we final release
        if (1 == dwR)
        {
            // make sure we only call ExternalFinalRelease  & delete once
            if(m_bReleased == FALSE) 
            {
                m_bReleased = TRUE;

                LOG((TL_TRACE, "InternalRelease - final" ));

                // remove from the hash table, so any more messages
                // from tapisrv are ignored
                if ( NULL != m_hCallHub )
                {
                    gpCallHubHashTable->Remove( (ULONG_PTR)m_hCallHub );
                }
                gpCallHubHashTable->Unlock();

                ExternalFinalRelease();
                dwR = m_dwRef = 0;
                
                Unlock();
                LOG((TL_INFO, "InternalRelease - final OK dwR %d",dwR ));
                LOG((TL_TRACE, "InternalRelease - final OK dwR %d",dwR ));

            }
            else
            {
                gpCallHubHashTable->Unlock();
                Unlock();
                LOG((TL_INFO, "InternalRelease - final failed dwR %d",dwR ));
            }
            
                
        }
        else
        {
            gpCallHubHashTable->Unlock();
            Unlock();
            LOG((TL_INFO, "InternalRelease - not final dwR %d",dwR ));
        }

     

        #if DBG  
            LogDebugRelease( dwR );
        #endif

        return dwR;
    }

};



class CCallHubEvent : 
	public CTAPIComObjectRoot<CCallHubEvent, CComMultiThreadModelNoCS>, // no need for a cs
    public CComDualImpl<ITCallHubEvent, &IID_ITCallHubEvent, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
public:

    CCallHubEvent(){}

DECLARE_MARSHALQI(CCallHubEvent)
DECLARE_TRACELOG_CLASS(CCallHubEvent)

BEGIN_COM_MAP(CCallHubEvent)
	COM_INTERFACE_ENTRY2(IDispatch, ITCallHubEvent)
    COM_INTERFACE_ENTRY(ITCallHubEvent)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppvObject) = 0;
	virtual ULONG STDMETHODCALLTYPE AddRef() = 0;
	virtual ULONG STDMETHODCALLTYPE Release() = 0;

    static HRESULT FireEvent(
                             CALLHUB_EVENT Event,
                             ITCallHub * pCallHub,
                             ITCallInfo * pCallInfo,
                             CTAPI * pTapi
                            );
    void FinalRelease();
    
protected:

    CALLHUB_EVENT       m_Event;
    ITCallHub         * m_pCallHub;
    ITCallInfo        * m_pCall;

#if DBG
    PWSTR               m_pDebug;
#endif
    

public:

    
STDMETHOD(get_Event)(CALLHUB_EVENT * pEvent);
STDMETHOD(get_CallHub)(ITCallHub ** ppCallHub);
STDMETHOD(get_Call)(ITCallInfo ** ppCall);

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\debug.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    
Author:

    mquinton  04-28-98

Notes:

Revision History:

--*/

#ifndef __TAPIDEBUGH___
#define __TAPIDEBUGH___
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\connect.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    connect.h

Abstract:

    Declaration of the CTAPIConnectionPoint class
    
Author:

    mquinton  06-12-97

Notes:

Revision History:

--*/

#ifndef __CONNECT_H_
#define __CONNECT_H_

class CTAPIConnectionPoint :
   public CTAPIComObjectRoot<CTAPIConnectionPoint>,
   public IConnectionPoint
{
public:

    CTAPIConnectionPoint() : m_iid(CLSID_NULL),
                             m_pCPC(NULL),
                             m_pConnectData(NULL),                             
                             m_bInitialized(FALSE),
                             m_hUnadviseEvent(NULL),
                             m_fMarkedForDelete(FALSE)

    {}
    
    
BEGIN_COM_MAP(CTAPIConnectionPoint)
    COM_INTERFACE_ENTRY(IConnectionPoint)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

DECLARE_MARSHALQI(CTAPIConnectionPoint)
DECLARE_QI()
DECLARE_TRACELOG_CLASS(CTAPIConnectionPoint)    

protected:

    IConnectionPointContainer     * m_pCPC;
    CONNECTDATA                   * m_pConnectData;
    IID                             m_iid;
    BOOL                            m_bInitialized;
    HANDLE                          m_hUnadviseEvent;

    //
    // the following member variables are synchronized with
    // the gcsGlobalInterfaceTable critical section
    //
    DWORD                           m_dwCallbackCookie;
    DWORD							m_cThreadsInGet;
    BOOL							m_fMarkedForDelete;
    
public:
    
    HRESULT Initialize(
                       IConnectionPointContainer * pCPC,
                       IID iid
                      );

    ULONG_PTR GrabEventCallback();

    HRESULT STDMETHODCALLTYPE GetConnectionInterface(
        IID * pIID
        );
    
    HRESULT STDMETHODCALLTYPE GetConnectionPointContainer(
        IConnectionPointContainer ** ppCPC
        );
    
    HRESULT STDMETHODCALLTYPE Advise(
                                     IUnknown * pUnk,
                                     DWORD * pdwCookie
                                    );
    
    HRESULT STDMETHODCALLTYPE Unadvise(
                                       DWORD dwCookie
                                      );
    
    HRESULT STDMETHODCALLTYPE EnumConnections(
                                              IEnumConnections ** ppEnum
                                             );
    
    void FinalRelease();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\card.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    card.h

Abstract:

   
Author:

    noela  01-20-98

Notes:

Revision History:

--*/

//***************************************************************************
typedef struct {

        DWORD dwID;

#define MAXLEN_CARDNAME            96
        WCHAR NameW[MAXLEN_CARDNAME];


#define MAXLEN_PIN                 96
        WCHAR PinW[MAXLEN_PIN];


//Card3=3,"AT&T via 1-800-321-0288","","G","18003210288$TFG$TH","18003210288$T01EFG$TH",1

#define MAXLEN_RULE                128
        WCHAR LocalRuleW[MAXLEN_RULE];
        WCHAR LDRuleW[MAXLEN_RULE];
        WCHAR InternationalRuleW[MAXLEN_RULE];

        DWORD dwFlags;
             #define CARD_BUILTIN  1
             #define CARD_HIDE     2

               } CARD, *PCARD;


extern PCARD gCardList;
//extern UINT gnNumCards;
//UINT gnCurrentCardID = 0;

extern DWORD *gpnStuff;
extern PCARD gpCardList;
extern PCARD gpCurrentCard;


//***************************************************************************
//***************************************************************************
BOOL  UtilGetEditNumStr( HWND  hWnd,
                                 UINT  uControl,
                                 UINT  nExtendNum );

//***************************************************************************
//***************************************************************************
//enum DWORD {
enum  {
        UTIL_BIG_EXTENDED,
        UTIL_NUMBER
     };


//***************************************************************************
//***************************************************************************
//***************************************************************************
LONG PASCAL ReadCardsEasy(
                           PCARD  *pCardSpace,
                           LPUINT *pnStuff );

LONG PASCAL GetCardIndexFromID( UINT nID,
                                PCARD pCallersList,
                                UINT nCallersNumCards );

void PASCAL WriteCards( PCARD pCardList, UINT nNumCards,
                 DWORD dwChangedFlags);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\dispmap.cpp ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    Connect.cpp
    
Abstract:

    Handles all outgoing interfaces

Author:

    mquinton - 5/7/97

Notes:

    optional-notes

Revision History:

--*/

#include "stdafx.h"
#include "windows.h"
#include "wownt32.h"
#include "stdarg.h"
#include "stdio.h"
#include "shellapi.h"


STDMETHODIMP
CDispatchMapper::QueryDispatchInterface(
                                        BSTR pIID,
                                        IDispatch * pDispIn,
                                        IDispatch ** ppDispOut
                                       )
{
    IID         iid;
    HRESULT     hr;
    void *      pVoid;


    if ( IsBadReadPtr( pDispIn, sizeof( IDispatch ) ) )
    {
        LOG((TL_ERROR, "QDI bad pDispIn"));

        return E_INVALIDARG;
    }

    if ( TAPIIsBadWritePtr( ppDispOut, sizeof( IDispatch * ) ) )
    {
        LOG((TL_ERROR, "QDI bad ppDispOut"));

        return E_POINTER;
    }


    *ppDispOut = NULL;
    

    hr = IIDFromString(
                       pIID,
                       &iid
                      );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "QDI bad bstr"));

        return E_INVALIDARG;
    }

    hr = pDispIn->QueryInterface(
                                 iid,
                                 &pVoid
                                );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "QDI invalid IID"));

        return E_INVALIDARG;
    }


    //
    // see if the object we are going to QI is safe for scripting
    //

    CComPtr<IObjectSafety> pObjectSafety;

    hr = pDispIn->QueryInterface(IID_IObjectSafety, (void**)&pObjectSafety);
    
    //
    // the object _must_ support IObjectSafety interface. 
    //
    // Note: if this requirement is too strict and we need to remove it in the future,
    // we need to pass in class id for the object, and query ie category manager if 
    // the object is marked safe for scripting in the registry
    //

    if ( FAILED(hr) )
    {

        ((IUnknown*)pVoid)->Release();

        return hr;
    }

    //
    // do what ie does -- call setinterfacesafetyoptions with safe for 
    // scripting options
    // 

    DWORD dwXSetMask = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
    DWORD dwXOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;

    hr = pObjectSafety->SetInterfaceSafetyOptions(iid,
                       dwXSetMask,
                       dwXOptions);

    if (FAILED(hr))
    {
     
        ((IUnknown*)pVoid)->Release();
        
        return hr;
    }
    
    //
    //  If we got here, the object is safe for scripting. Proceeed.
    //


    *ppDispOut = (IDispatch *) pVoid;

    return S_OK;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\callint.cpp ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    callint.cpp

Abstract:

    Implements all the methods on call interfaces.

Author:

    mquinton - 9/4/98

Notes:


Revision History:

--*/

#include "stdafx.h"

HRESULT mapTAPIErrorCode(long lErrorCode);

HRESULT
MakeBufferFromVariant(
                      VARIANT var,
                      DWORD * pdwSize,
                      BYTE ** ppBuffer
                     );

HRESULT
FillVariantFromBuffer(
                      DWORD dw,
                      BYTE * pBuffer,
                      VARIANT * pVar
                      );


///////////////////////////////////////////////////////////////////////////////
//
// BSTRFromUnalingedData
//
// this is a helper function that takes unalinged data and returns a BSTR 
// allocated around it
//

BSTR BSTRFromUnalingedData(  IN BYTE *pbUnalignedData,
                             IN DWORD dwDataSize)
{
    LOG((TL_TRACE, "BSTRFromUnalingedData - enter"));


    BSTR bstrResult = NULL;


#ifdef _WIN64



    //
    // allocate aligned memory big enough to fit our string data
    //

    DWORD dwOleCharArraySize = ( (dwDataSize) / ( sizeof(OLECHAR) / sizeof(BYTE) ) ) + 1;

    
    LOG((TL_TRACE,
        "BSTRFromUnalingedData - allocating aligned memory of size[%ld]", dwOleCharArraySize));

    OLECHAR *pbAlignedData = new OLECHAR[dwOleCharArraySize];

    if (NULL == pbAlignedData)
    {
        LOG((TL_ERROR, "BSTRFromUnalingedData - failed to allocate aligned memory"));

        return NULL;
    }


    _ASSERTE( (dwOleCharArraySize/sizeof(OLECHAR) ) >= dwDataSize );


    //
    // copy data to the aligned memory
    //

    CopyMemory( (BYTE*)(pbAlignedData ),
                (BYTE*)pbUnalignedData,
                dwDataSize );


    //
    // allocate bstr from the aligned data
    //

    bstrResult = SysAllocString(pbAlignedData);


    //
    // no longer need the allocated buffer
    //

    delete pbAlignedData;
    pbAlignedData = NULL;

#else

    bstrResult = SysAllocString((PWSTR)pbUnalignedData);

#endif



    LOG((TL_TRACE, "BSTRFromUnalingedData - exit. bstrResult[%p]", bstrResult));

    return bstrResult;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Finish
//
//  this method is used to finish a two step call operation
//  (conference or transfer)
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
STDMETHODCALLTYPE
CCall::Finish(
    FINISH_MODE   finishMode
    )
{
    HRESULT         hr = S_OK;
    CCall         * pConferenceControllerCall = NULL;
    HCALL           hConfContCall;
    HCALL           hRelatedCall;
    CCallHub      * pRelatedCallHub = NULL;
    ITAddress     * pAddress;
    CAddress      * pCAddress;

    LOG((TL_TRACE, "Finish - enter"));

    //
    // are we a tranfer?
    //
    if (m_dwCallFlags & CALLFLAG_TRANSFCONSULT)
    {
        
        if( ( FM_ASCONFERENCE != finishMode ) && ( FM_ASTRANSFER != finishMode ) )
        {
            hr = E_INVALIDARG;
            
            LOG((TL_ERROR, "Wrong value passed for finish mode" ));
        }
        else
        {
        
            T3CALL t3ConfCall;

            //
            // get the related calls hCall
            //
            hRelatedCall = m_pRelatedCall->GetHCall();

            //
            // Finish a Transfer
            //
            Lock();

            hr = LineCompleteTransfer(
                                      hRelatedCall,
                                      m_t3Call.hCall,
                                      ( FM_ASCONFERENCE == finishMode )?&t3ConfCall:NULL,
                                      ( FM_ASCONFERENCE == finishMode )?
                                      LINETRANSFERMODE_CONFERENCE:LINETRANSFERMODE_TRANSFER
                                     );

            Unlock();
        
            if ( SUCCEEDED(hr) )
            {
                // wait for async reply
                hr = WaitForReply( hr );
            
                if ( SUCCEEDED(hr) )
                {
                    Lock();
                    // Reset Transfer - Consultation Flag
                    m_dwCallFlags &= ~CALLFLAG_TRANSFCONSULT; 
                    Unlock();
                }
                else
                {
                    LOG((TL_ERROR, "Finish - LineCompleteTransfer failed async" ));
                }
            }
            else  // LineCompleteTransfer failed
            {
                LOG((TL_ERROR, "Finish - LineCompleteTransferr failed" ));
            }


            if( FM_ASCONFERENCE == finishMode )
            {
                //
                // Store the confcontroller in the callhub object
                //

                Lock();

                pRelatedCallHub = m_pRelatedCall->GetCallHub();

                m_pRelatedCall->get_Address( &pAddress );
            
                pCAddress = dynamic_cast<CAddress *>(pAddress);
            
                if(pRelatedCallHub != NULL)
                {
                    pRelatedCallHub->CreateConferenceControllerCall(
                        t3ConfCall.hCall,
                        pCAddress
                        );
                }
                else
                {
                    LOG((TL_INFO, "CreateConference - No CallHub"));
                }

                Unlock();
            }

            // Finished with relatedCall
            ResetRelatedCall();
        }
    }
    //
    // are we a conference?
    //
    else if (m_dwCallFlags & CALLFLAG_CONFCONSULT)
    {

        if( FM_ASCONFERENCE != finishMode )
        {
            hr = E_INVALIDARG;
            
            LOG((TL_ERROR, "A conference can't be finished as a transfer" ));
        }
        else
        {
            // Finish a Conference

            //
            // get the related calls callhub
            //
            pRelatedCallHub = m_pRelatedCall->GetCallHub();
        
            if (pRelatedCallHub != NULL)
            {
                //
                // Get the conference controller handle from the callhub
                //
                pConferenceControllerCall = pRelatedCallHub->GetConferenceControllerCall();
            
                if (pConferenceControllerCall != NULL)
                {
                    hConfContCall = pConferenceControllerCall->GetHCall();

                    //
                    // Finished with relatedCall
                    //
                    ResetRelatedCall();

                    Lock();
        
                    hr = LineAddToConference(
                                             hConfContCall,
                                             m_t3Call.hCall
                                            );

                    Unlock();
        
                    if ( SUCCEEDED(hr) )
                    {
                        // wait for async reply
                        hr = WaitForReply( hr );

                        if ( SUCCEEDED(hr) )
                        {
                            //
                            // Reset Conference - Consultation Flag
                            //
                            Lock();
                
                            m_dwCallFlags &= ~CALLFLAG_CONFCONSULT;

                            Unlock();
                        }
                        else
                        {
                            LOG((TL_ERROR, "Finish - LineAddToConference failed async" ));
                        }
                    }
                    else  // LineAddToConference failed
                    {
                        LOG((TL_ERROR, "Finish - LineAddToConference failed" ));
                    }
                }
                else  // GetConferenceControllerCall failed
                {
                    LOG((TL_ERROR, "Finish - GetConferenceControllerCall failed" ));
                }
            }    
            else  // GetCallHub failed
            {
                LOG((TL_ERROR, "Finish - GetCallHub failed" ));
            }
        }        
    }
    else   // Not flagged as transfer OR conference !!!!
    {
        LOG((TL_ERROR, "Finish - Not flagged as transfer OR conference"));
        hr = TAPI_E_INVALCALLSTATE;
    }


    LOG((TL_TRACE,hr, "Finish - exit"));
    return hr;
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  RemoveFromConference
//
//  this method is called to remove this call from a conference
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
STDMETHODCALLTYPE
CCall::RemoveFromConference(void)
{
    HRESULT     hr = S_OK;

    LOG((TL_TRACE, "RemoveFromConference - enter"));

    Lock();


    hr = LineRemoveFromConference( m_t3Call.hCall );

    Unlock();
    
    if ( SUCCEEDED(hr) )
    {
        // wait for async reply
        hr = WaitForReply( hr );

        if ( SUCCEEDED(hr) )
        {
            // OK
        }
        else
        {
            LOG((TL_ERROR, "RemoveFromConference - LineRemoveFromConference failed async" ));
        }
    }
    else  // LineAddToConference failed
    {
        LOG((TL_ERROR, "RemoveFromConference - LineRemoveFromConference failed" ));
    }


    LOG((TL_TRACE, hr, "RemoveFromConference - exit"));
    return hr;
}


// ITCallInfo methods
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Address
//
// retrieves the address object
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
STDMETHODCALLTYPE
CCall::get_Address(
    ITAddress ** ppAddress
    )
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "get_Address - enter"));
    LOG((TL_TRACE, "     ppAddress ---> %p", ppAddress ));

    if ( TAPIIsBadWritePtr( ppAddress, sizeof( ITAddress * ) ) )
    {
        LOG((TL_ERROR, "get_Address - invalid pointer"));

        return E_POINTER;
    }

    //
    // gets correct interface
    // and addrefs
    //
    hr = m_pAddress->QueryInterface(
                                    IID_ITAddress,
                                    (void **)ppAddress
                                   );
    
    LOG((TL_TRACE, "get_Address - exit - return %lx", hr ));

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_CallState
//
// retrieves the current callstate
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
STDMETHODCALLTYPE
CCall::get_CallState(
    CALL_STATE * pCallState
    )
{
    LOG((TL_TRACE, "get_CallState - enter"));
    LOG((TL_TRACE, "     pCallState ---> %p", pCallState ));

    if ( TAPIIsBadWritePtr( pCallState, sizeof( CALL_STATE ) ) )
    {
        LOG((TL_ERROR, "get_CallState - invalid pointer"));

        return E_POINTER;
    }
    
    Lock();
    
    *pCallState = m_CallState;

    Unlock();

    LOG((TL_TRACE, "get_CallState - exit - return success" ));

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Privilege
//
// get the privilege
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
STDMETHODCALLTYPE
CCall::get_Privilege(
    CALL_PRIVILEGE * pPrivilege
    )
{
    LOG((TL_TRACE, "get_Privilege - enter"));
    LOG((TL_TRACE, "     pPrivilege ---> %p", pPrivilege ));

    if ( TAPIIsBadWritePtr( pPrivilege, sizeof( CALL_PRIVILEGE ) ) )
    {
        LOG((TL_ERROR, "get_Privilege - bad pointer"));

        return E_POINTER;
    }

    Lock();
    
    *pPrivilege = m_CallPrivilege;

    Unlock();

    LOG((TL_TRACE, "get_Privilege - exit - return SUCCESS" ));

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_MediaTypesAvailable
//
// gets the media types on the call.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::get_MediaTypesAvailable(
                               long * plMediaTypesAvail
                              )
{
    LOG((TL_TRACE, "get_MediaTypesAvailable enter"));
    LOG((TL_TRACE, "   plMediaTypesAvail ------->%p", plMediaTypesAvail ));

    //
    // check pointer
    //
    if ( TAPIIsBadWritePtr( plMediaTypesAvail, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_MediaTypesAvailable - bad pointer"));

        return E_POINTER;
    }
    
    Lock();

    DWORD           dwHold = 0;

    //
    // ask address for types
    //
    if (ISHOULDUSECALLPARAMS())
    {
        dwHold = m_pAddress->GetMediaModes();
    }
    //
    // or types currently on call
    //
    else
    {
        if ( SUCCEEDED(RefreshCallInfo()) )
        {
            dwHold = m_pCallInfo->dwMediaMode;
        }
        else
        {
            dwHold = m_pAddress->GetMediaModes();
        }
    }

    //
    // fix up tapi2 media modes
    //
    if (dwHold & AUDIOMEDIAMODES)
    {
        dwHold |= LINEMEDIAMODE_AUTOMATEDVOICE;
    }

    dwHold &= ALLMEDIAMODES;

    *plMediaTypesAvail = dwHold;

    Unlock();

    return S_OK;
}

// ITBasicCallControl methods
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Connect
//
// connect the call - call linemakecall
//
// bsync tells tapi if it should wait for the call to get to connected
// or not before returning.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
STDMETHODCALLTYPE
CCall::Connect(
    VARIANT_BOOL bSync
    )
{
    HRESULT         hr = S_OK;
    HANDLE          hEvent;
    HCALL           hCall;
    
    LOG((TL_TRACE, "Connect - enter" ));
    LOG((TL_TRACE, "     bSync ---> %d", bSync ));

    Lock();
    
    if (m_CallState != CS_IDLE)
    {
        Unlock();
        
        LOG((TL_ERROR,"Connect - call is not in IDLE state - cannot call connect"));
        
        return TAPI_E_INVALCALLSTATE;
    }

    //
    // get an hline to use
    //
    hr = m_pAddress->FindOrOpenALine(
                                     m_dwMediaMode,
                                     &m_pAddressLine
                                    );

    if (S_OK != hr)
    {
        Unlock();
        
        LOG((TL_ERROR,
               "Connect - FindOrOpenALine failed - %lx",
               hr
              ));
        
        return hr;
    }

    //
    // set up the callparams structure
    //
    FinishCallParams();


    //
    // make the call
    //
    hr = LineMakeCall(
                      &(m_pAddressLine->t3Line),
                      &hCall,
                      m_szDestAddress,
                      m_dwCountryCode,
                      m_pCallParams
                     );

    if (((LONG)hr) > 0)
    {
        if (bSync)
        {
            //
            // this must be created inside the same
            // Lock() as the call to tapisrv
            // otherwise, the connected message
            // may appear before the event
            // exists
            //
            hEvent = CreateConnectedEvent();
        }

        //
        // wait for an async reply
        //
        Unlock();
        
        hr = WaitForReply( hr );

        Lock();
    }


    if ( S_OK != hr )
    {
        HRESULT hr2;

        LOG((TL_ERROR, "Connect - LineMakeCall failed - %lx", hr ));

        ClearConnectedEvent();
        
        // post an event in the callback thread for LINE_CALLSTATE

        hr2 = CCallStateEvent::FireEvent(
                                (ITCallInfo *)this,
                                CS_DISCONNECTED,
                                CEC_DISCONNECT_BADADDRESS,  /*there should be something called CEC_DISCONNECT_BADADDRESSTYPE*/
                                m_pAddress->GetTapi(),
                                NULL
                               );
    
        if (!SUCCEEDED(hr2))
        {
            LOG((TL_ERROR, "CallStateEvent - fire event failed %lx", hr));
        }
        
        m_CallState = CS_DISCONNECTED;
        
        m_pAddress->MaybeCloseALine( &m_pAddressLine );

        //
        // Go through the phones and call our event hooks
        //

        ITPhone               * pPhone;
        CPhone                * pCPhone;
        int                     iPhoneCount;
        PhoneArray              PhoneArray;

        //
        // Get a copy of the phone array from tapi. This copy will contain
        // references to all the phone objects.
        //

        m_pAddress->GetTapi()->GetPhoneArray( &PhoneArray );

        //
        // Unlock before we mess with the phone objects, otherwise we risk deadlock
        // if a phone object would try to access call methods.
        //

        Unlock();

        for(iPhoneCount = 0; iPhoneCount < PhoneArray.GetSize(); iPhoneCount++)
        {
            pPhone = PhoneArray[iPhoneCount];

            pCPhone = dynamic_cast<CPhone *>(pPhone);

            pCPhone->Automation_CallState( (ITCallInfo *)this, CS_DISCONNECTED, CEC_DISCONNECT_BADADDRESS );
        }

        //
        // Release all the phone objects.
        //

        PhoneArray.Shutdown();
    }
    else    //hr is S_OK
    {
        FinishSettingUpCall( hCall );

        Unlock();
    
        if (bSync)
        {
            return SyncWait( hEvent );
        }

        LOG((TL_TRACE, "Connect - exit - return SUCCESS"));
    }

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Answer
//
//  Answer an offering call.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
STDMETHODCALLTYPE
CCall::Answer(
    void
    )
{
    HRESULT         hr;

    LOG((TL_TRACE, "Answer - enter" ));

    Lock();
    
    //
    // make sure we are in the correct call state
    //
    if (CS_OFFERING != m_CallState)
    {
        LOG((TL_ERROR, "Answer - call not in offering state" ));

        Unlock();
        
        return TAPI_E_INVALCALLSTATE;
    }

    //
    // answer
    //
    hr = LineAnswer(
                    m_t3Call.hCall
                   );

    Unlock();
    
    if ( ((LONG)hr) < 0 )
    {
        LOG((TL_ERROR, "Answer - LineAnswer failed %lx", hr ));

        return hr;
    }

    //
    // wait for reply
    //
    hr = WaitForReply( hr );

    LOG((TL_TRACE, "Answer - exit - return %lx", hr ));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Disconnect
//
// called to disconnect the call
// the disconnected_code is ignored
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
STDMETHODCALLTYPE
CCall::Disconnect(
    DISCONNECT_CODE code
    )
{
    HRESULT         hr = S_OK;
    LONG            lResult;
    HCALL           hCall, hAdditionalCall;
    
    LOG((TL_TRACE, "Disconnect - enter" ));
    LOG((TL_TRACE, "     DisconnectCode ---> %d", code ));

    Lock();
    
    if (m_CallState == CS_IDLE)
    {
        Unlock();
        LOG((TL_ERROR, "Disconnect - invalid state"));
        return S_FALSE;
    }

    if (NULL == m_t3Call.hCall)
    {
        Unlock();
        LOG((TL_ERROR, "Disconnect - invalid hCall"));
        return S_FALSE;
    }

    hCall = m_t3Call.hCall;
    hAdditionalCall = m_hAdditionalCall;

    //
    // special case for wavemsp
    // tell it to stop streaming
    //
    if ( OnWaveMSPCall() )
    {
        StopWaveMSPStream();
    }
    
    Unlock();

    //
    // Check extra t3call used in conference legs
    //
    if (NULL != hAdditionalCall)
    {
        lResult = LineDrop(
                           hAdditionalCall,
                           NULL,
                           0
                          );

        if ( lResult < 0 )
        {
            LOG((TL_ERROR, "Disconnect - AdditionalCall - LineDrop failed %lx", lResult ));
        }
        else
        {
            hr = WaitForReply( (DWORD) lResult );
            
            if (S_OK != hr)
            {
                LOG((TL_ERROR, "Disconnect - AdditionalCall - WaitForReply failed %lx", hr ));
            }
        }
    }   
    
    lResult = LineDrop(
                       hCall,
                       NULL,
                       0
                      );

    if ( lResult < 0 )
    {
        LOG((TL_ERROR, "Disconnect - LineDrop failed %lx", lResult ));
        return mapTAPIErrorCode( lResult );
    }

    hr = WaitForReply( (DWORD) lResult );

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "Disconnect - WaitForReply failed %lx", hr ));
        return hr;
    }


    LOG((TL_TRACE, "Disconnect - exit - return %lx", hr ));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCall
// Interface : ITBasicCallControl
// Method    : Hold
//
// If bHold == TRUE,  the call should be put on hold.  
// If bHold == FALSE, the call should unheld
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
STDMETHODCALLTYPE
CCall::Hold(
    VARIANT_BOOL bHold
    )
{
    HRESULT         hr = S_OK;
    HCALL           hCall;

    
    LOG((TL_TRACE,  "Hold - enter"));
    LOG((TL_TRACE,  "     bHold ---> %d", bHold));

    Lock();

    hCall = m_t3Call.hCall;

    Unlock();

    if ( NULL == hCall )
    {
        return TAPI_E_INVALCALLSTATE;
    }
    
    if (bHold)
    {
        hr = LineHold(hCall);
        
        if ( SUCCEEDED(hr) )
        {
            //
            // wait for async reply
            //
            hr = WaitForReply( hr );
            
            if ( FAILED(hr) )
            {
                LOG((TL_ERROR, "Hold - lineHold failed async" ));
            }
        }
        else  // lineHold failed
        {
            LOG((TL_ERROR, "Hold - lineHold failed" ));
        }
    }
    else // want to unhold, so we should be held
    {
        hr = LineUnhold(hCall);
        
        if ( SUCCEEDED(hr) )
        {
            //
            // wait for async reply
            //
            hr = WaitForReply( hr );

            if ( FAILED(hr) )
            {
                LOG((TL_ERROR, "Hold - lineUnhold failed async" ));
            }
        }
        else  // lineUnhold failed
        {
            LOG((TL_ERROR, "Hold - lineUnhold failed" ));
        }
    }

    LOG((TL_TRACE, hr, "Hold - exit"));
    
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCall
// Interface : ITBasicCallControl
// Method    : Handoff
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
STDMETHODCALLTYPE
CCall::HandoffDirect(
    BSTR pApplicationName
    )
{
    HRESULT         hr = S_OK;
    HCALL           hCall;

    LOG((TL_TRACE,  "HandoffDirect - enter"));
    LOG((TL_TRACE,  "     pApplicationName ---> %p", pApplicationName));

    if ( IsBadStringPtrW( pApplicationName, -1 ) )
    {
        LOG((TL_ERROR, "HandoffDirect - AppName pointer invalid"));

        return E_POINTER;
    }

    Lock();


    hCall = m_t3Call.hCall;


    Unlock();
    
    hr = LineHandoff(hCall, pApplicationName, 0);
        
    if (FAILED(hr))
    {
        LOG((TL_ERROR, "HandoffDirect - LineHandoff failed"));
    }

    LOG((TL_TRACE, hr, "HandoffDirect - exit"));
    
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCall
// Interface : ITBasicCallControl
// Method    : Handoff
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
STDMETHODCALLTYPE
CCall::HandoffIndirect(
    long lMediaType
    )
{
    HRESULT         hr = S_OK;
    DWORD           dwMediaMode = 0;
    HCALL           hCall;

    
    LOG((TL_TRACE,  "HandoffIndirect - enter"));
    LOG((TL_TRACE,  "     lMediaType ---> %d", lMediaType));

    if (!(m_pAddress->GetMediaMode(
                                   lMediaType,
                                   &dwMediaMode
                                  ) ) )
    {
        LOG((TL_ERROR, "HandoffIndirect - invalid mediatype"));

        return E_INVALIDARG;
    }

    Lock();




    hCall = m_t3Call.hCall;

    Unlock();
    
    hr = LineHandoff(hCall, NULL, dwMediaMode);
        
    if (FAILED(hr))
    {
        LOG((TL_ERROR, "HandoffIndirect - LineHandoff failed"));
    }

    LOG((TL_TRACE, hr, "HandoffIndirect - exit"));
    
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCall
// Interface : ITBasicCallControl
// Method    : Conference
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
STDMETHODCALLTYPE
CCall::Conference(
    ITBasicCallControl * pCall,
    VARIANT_BOOL bSync
    )
{
    HRESULT         hr = S_OK;
    CCall         * pConferenceControllerCall = NULL;
    CCall         * pConsultationCall = NULL;


    LOG((TL_TRACE,  "Conference - enter"));
    LOG((TL_TRACE,  "     pCall ---> %p", pCall));
    LOG((TL_TRACE,  "     bSync ---> %hd",bSync));

    if ( IsBadReadPtr( pCall, sizeof (ITBasicCallControl) ) )
    {
        LOG((TL_ERROR, "Conference - bad call pointer"));

        return E_POINTER;
    }

    //
    // Get CCall pointer to our consultation call object
    //
    pConsultationCall = dynamic_cast<CComObject<CCall>*>(pCall);
    
    if (pConsultationCall != NULL)
    {

        Lock();
        
        if (pConsultationCall->GetHCall() == GetHCall())
        {
            Unlock();
            hr = E_INVALIDARG;
            LOG((TL_INFO, "Conference - invalid Call pointer (same call & consult call)"));
            
        }
        else if (m_pCallHub != NULL)
        {
            //
            // Get the conference controller handle from the callhub
            //
            pConferenceControllerCall = m_pCallHub->GetConferenceControllerCall();

            Unlock();
            
            //
            // Do we have an existing Conference ??
            //
            if (pConferenceControllerCall == NULL)
            {
                //
                // No existing conference, so create one
                //
                hr = CreateConference(pConsultationCall, bSync );
            }
            else
            {
                //
                // Add to an existing conference
                //
                hr = AddToConference(pConsultationCall, bSync );
    
            }
        }
        else
        {
            Unlock();
            hr = E_UNEXPECTED;
            LOG((TL_INFO, "Conference - No Call Hub" ));
        }

    }
    else
    {
        hr = E_INVALIDARG;
        LOG((TL_INFO, "Conference - invalid Call pointer"));
        LOG((TL_ERROR, hr, "Conference - exit"));
    }

    return hr; 
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCall
// Interface : ITBasicCallControl
// Method    : Transfer
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
STDMETHODCALLTYPE
CCall::Transfer(
    ITBasicCallControl * pCall,
    VARIANT_BOOL bSync
    )
{
    HRESULT             hr = S_OK;
    LPLINECALLSTATUS    pCallStatus = NULL;  
    CCall             * pConsultationCall = NULL;
    DWORD               dwCallFeatures;
    DWORD               dwCallFeatures2;
    CALL_STATE          consultationCallState = CS_IDLE;

    LOG((TL_TRACE,  "Transfer - enter"));
    LOG((TL_TRACE,  "     pCall ---> %p", pCall));
    LOG((TL_TRACE,  "     bSync ---> %hd",bSync));

    try
    {
        //
        // Get CCall pointer to our consultation call object
        //
        pConsultationCall = dynamic_cast<CComObject<CCall>*>(pCall);
        
        if (pConsultationCall != NULL)
        {
        }
        else
        {
            hr = E_INVALIDARG;
            LOG((TL_INFO, "Transfer - invalid Call pointer"));
            LOG((TL_ERROR, hr, "Transfer - exit"));
            return(hr);
        }
    }
    catch(...)
    {
        
        hr = E_INVALIDARG;
        LOG((TL_INFO, "Transfer - invalid Call pointer"));
        LOG((TL_ERROR, hr, "Transfer - exit"));
        return(hr);
    }
    
    if (pConsultationCall->GetHCall() == GetHCall())
    {
        hr = E_INVALIDARG;
        LOG((TL_INFO, "Transfer - invalid Call pointer (same call & consult call)"));
        LOG((TL_ERROR, hr, "Transfer - exit"));
        return(hr);
    }



    // Pointer seems Ok, so carry on

    Lock();
    
    //
    // Get Call Status to determine what features we can use
    //
    
    hr = LineGetCallStatus(  m_t3Call.hCall, &pCallStatus  );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "Transfer - LineGetCallStatus failed - %lx", hr));

        Unlock();

        return hr;
    }

    dwCallFeatures = pCallStatus->dwCallFeatures;
    if ( m_pAddress->GetAPIVersion() >= TAPI_VERSION2_0 )
    {
        dwCallFeatures2 = pCallStatus->dwCallFeatures2;
    }
    
    ClientFree( pCallStatus );

#if CHECKCALLSTATUS

    if ( (dwCallFeatures & LINECALLFEATURE_SETUPTRANSFER) &&
         (dwCallFeatures & LINECALLFEATURE_COMPLETETRANSF) )
    {
#endif
        //
        // we support it, so try the transfer
        // Can we do a one step transfer ???
        //
        if ( dwCallFeatures2 & LINECALLFEATURE2_ONESTEPTRANSFER )
        {
            Unlock();
            
            hr = OneStepTransfer(pConsultationCall, bSync);

            return hr;

        }
        
        HCALL           hConsultationCall;

        //
        // Setup & dial the consultation Call
        //
        LOG((TL_INFO, "Transfer - Trying Two Step Transfer" ));

        hr = LineSetupTransfer(
                               m_t3Call.hCall,
                               &hConsultationCall,
                               NULL
                              );

        Unlock();
        
        if ( SUCCEEDED(hr) )
        {
            //
            // wait for async reply
            //
            hr = WaitForReply( hr );

            if ( SUCCEEDED(hr) )
            {
                //
                // we support it, so try the Conference
                //
                pConsultationCall->get_CallState (&consultationCallState);

                if ( (consultationCallState == CS_CONNECTED) || (consultationCallState == CS_HOLD) )
                {
                    //
                    // the existing call is in a connected stae so we just need to to do a finish()
                    // to call down to LineAddToConference()
                    //
                    pConsultationCall->SetRelatedCall(
                                                      this,
                                                      CALLFLAG_TRANSFCONSULT|CALLFLAG_CONSULTCALL
                                                     );

                    return S_OK;
                }

                LONG            lCap;

                LOG((TL_INFO, "Transfer - LineSetupTransfer completed OK"));

                pConsultationCall->Lock();

                pConsultationCall->FinishSettingUpCall( hConsultationCall );

                pConsultationCall->Unlock();

                hr = pConsultationCall->DialAsConsultationCall( this, dwCallFeatures, FALSE, bSync );
            }
            else // LineSetupTransfer async reply failed
            {
                LOG((TL_ERROR, "Transfer - LineSetupTransfer failed async" ));
            }
        }
        else  // LineSetupTransfer failed
        {
            LOG((TL_ERROR, "Transfer - LineSetupTransfer failed" ));
        }

#if CHECKCALLSTATUS

    }
    else // don't support transfer features
    {
        LOG((TL_ERROR, "Transfer - LineGetCallStatus reports Transfer not supported"));
        hr = E_FAIL;
    }
#endif
    
    LOG((TL_TRACE, hr, "Transfer - exit"));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCall
// Interface : ITBasicCallControl
// Method    : BlindTransfer
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
STDMETHODCALLTYPE
CCall::BlindTransfer(
    BSTR pDestAddress
    )
{
    HRESULT             hr = S_OK;
    DWORD               dwCallFeatures;

    
    LOG((TL_TRACE,  "BlindTransfer - enter"));
    LOG((TL_TRACE,  "     pDestAddress ---> %p", pDestAddress));

    if ( IsBadStringPtrW( pDestAddress, -1 ) )
    {
        LOG((TL_ERROR, "BlindTransfer - bad pDestAddress"));

        return E_POINTER;
    }

    Lock();

    
#if CHECKCALLSTATUS

    LPLINECALLSTATUS    pCallStatus = NULL;

    hr = LineGetCallStatus(
                           m_t3Call.hCall,
                           &pCallStatus
                           );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "BlindTransfer - LineGetCallStatus failed - %lx", hr));

        Unlock();
        
        return hr;
    }

    dwCallFeatures = pCallStatus->dwCallFeatures;

    ClientFree( pCallStatus );

    if (!(dwCallFeatures & LINECALLFEATURE_BLINDTRANSFER ))
    {
        LOG((TL_ERROR, "BlindTransfer - not supported" ));

        Unlock();
        
        return E_FAIL;
    }
#endif

    // If the calls in the offering state we can't blindtransfer, so redirect.
    if (m_CallState == CS_OFFERING)
    {
        hr = lineRedirectW(
                          m_t3Call.hCall,
                          pDestAddress,
                          m_dwCountryCode
                         );
    }
    else
    {
    //
    // we support it, so try the transfer
    //
        hr = LineBlindTransfer(
                               m_t3Call.hCall,
                               pDestAddress,
                               m_dwCountryCode
                              );
    }
    Unlock();
    
    if ( SUCCEEDED(hr) )
    {
        //
        // wait for async reply
        //
        hr = WaitForReply( hr );

        if ( FAILED(hr) )
        {
            LOG((TL_ERROR, "BlindTransfer - lineBlindTransfer failed async" ));
        }
    }
    else  // LineBlindTransfer failed
    {
        LOG((TL_ERROR, "BlindTransfer - lineBlindTransfer failed" ));
    }

    LOG((TL_TRACE, hr, "BlindTransfer - exit"));
    
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCall
// Interface : ITBasicCallControl
// Method    : Park
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
STDMETHODCALLTYPE
CCall::ParkDirect(
        BSTR pParkAddress
        )
{
    HRESULT             hr = S_OK;
    HCALL               hCall;
    
    LOG((TL_TRACE,  "ParkDirect - enter"));

    if ( IsBadStringPtrW( pParkAddress, -1 ) )
    {
        LOG((TL_ERROR, "ParkDirect - bad pParkAddress"));

        return E_POINTER;
    }
    
    Lock();

    hCall = m_t3Call.hCall;

    Unlock();

#if CHECKCALLSTATUS
    
    LPLINECALLSTATUS    pCallStatus = NULL;

    hr = LineGetCallStatus(  hCall, &pCallStatus  );
    
    if (!SUCCEEDED(hr))
    {
        LOG((TL_ERROR, "ParkDirect - LineGetCallStatus failed - %lx", hr));

        return hr;
    }
    
    if (!(pCallStatus->dwCallFeatures & LINECALLFEATURE_PARK ))
    {
        LOG((TL_ERROR, "ParkDirect - this call doesn't support park"));

        ClientFree( pCallStatus );
        
        return E_FAIL;
    }

    ClientFree( pCallStatus );
    
#endif
    
    
    hr = LinePark(
                  hCall,
                  LINEPARKMODE_DIRECTED,
                  pParkAddress,
                  NULL
                  );
    
    if ( SUCCEEDED(hr) )
    {
        //
        // wait for async reply
        //
        hr = WaitForReply( hr );
    }
    
    LOG((TL_TRACE, hr, "Park - exit"));
    
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCall
// Interface : ITBasicCallControl
// Method    : Park
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
STDMETHODCALLTYPE
CCall::ParkIndirect(
        BSTR * ppNonDirAddress
        )
{
    HRESULT             hr = S_OK;
    LPVARSTRING         pCallParkedAtThisAddress = NULL;  
    PWSTR               pszParkedHere;
    HCALL               hCall;
    
    
    LOG((TL_TRACE,  "ParkIndirect - enter"));

    if ( TAPIIsBadWritePtr( ppNonDirAddress, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "Park - Bad return Pointer" ));

        return E_POINTER;
    }

    Lock();

    hCall = m_t3Call.hCall;

    Unlock();

#if CHECKCALLSTATUS
    
    LPLINECALLSTATUS    pCallStatus = NULL;  

    hr = LineGetCallStatus(  hCall, &pCallStatus  );
    
    if (!SUCCEEDED(hr))
    {
        LOG((TL_ERROR, "ParkDirect - LineGetCallStatus failed %lx",hr));

        return hr;
    }

    if ( !(pCallStatus->dwCallFeatures & LINECALLFEATURE_PARK ))
    {
        LOG((TL_ERROR, "ParkIndirect - call doesn't support park"));

        ClientFree( pCallStatus );
        
        return E_FAIL;
    }

    ClientFree( pCallStatus );

#endif
    
    //
    // we support it, so try to park
    //
    hr = LinePark(
                  hCall,
                  LINEPARKMODE_NONDIRECTED,
                  NULL,
                  &pCallParkedAtThisAddress
                 );
    
    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "LineParkIndirect - failed sync - %lx", hr));

        return hr;
    }

    //
    // wait for async reply
    //
    hr = WaitForReply( hr );
        
    if ( SUCCEEDED(hr) && (NULL != pCallParkedAtThisAddress) )
    {

        //
        // Get the string from the VARSTRING structure
        //

        pszParkedHere = (PWSTR) ((BYTE*)(pCallParkedAtThisAddress) +
                                 pCallParkedAtThisAddress->dwStringOffset);

        *ppNonDirAddress = BSTRFromUnalingedData( (BYTE*)pszParkedHere,
                                       pCallParkedAtThisAddress->dwStringSize);

        if ( NULL == *ppNonDirAddress )
        {
            LOG((TL_ERROR, "ParkIndirect - BSTRFromUnalingedData Failed" ));
            hr = E_OUTOFMEMORY;
        }
        
        ClientFree( pCallParkedAtThisAddress );
        
    }              
    else  // LinePark failed async
    {
        LOG((TL_ERROR, "ParkIndirect - LinePark failed async" ));
    }
    
    LOG((TL_TRACE, hr, "ParkIndirect - exit"));
    
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCall
// Interface : ITBasicCallControl
// Method    : SwapHold
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
STDMETHODCALLTYPE
CCall::SwapHold(ITBasicCallControl * pCall)
{
    HRESULT             hr = S_OK;
    CCall               *pHeldCall;
    HCALL               hHeldCall;
    HCALL               hCall;
    CCall               *pConfContCall;
    ITCallHub           *pCallHub;


    LOG((TL_TRACE, "SwapHold - enter"));

    try
    {
        //
        // Get CCall pointer to our other call object
        //
        pHeldCall = dynamic_cast<CComObject<CCall>*>(pCall);
        if (pHeldCall != NULL)
        {
            //
            // Get held call objects T3CALL
            //
            hHeldCall = pHeldCall->GetHCall();

            //
            //If the call has a conference controller associated with it then
            //the conference controller is swapheld instead of the call itself.
            //
            pConfContCall = pHeldCall->GetConfControlCall();

            if (pConfContCall != NULL)
            {
                hHeldCall = pConfContCall->GetHCall();
            }
        }
        else
        {
            hr = E_INVALIDARG;
            LOG((TL_INFO, "SwapHold - invalid Call pointer"));
            LOG((TL_ERROR, hr, "Transfer - exit"));
            return(hr);
        }
    }
    catch(...)
    {
        hr = E_INVALIDARG;
        LOG((TL_INFO, "SwapHold - invalid Call pointer"));
        LOG((TL_ERROR, hr, "Transfer - exit"));
        return(hr);
    }

    //
    //Get the swap call handle.
    //Look for the conference controller call first.
    //

    pConfContCall = GetConfControlCall();

    if (pConfContCall != NULL)
    {
        hCall = pConfContCall->GetHCall();
    }
    else
    {
        hCall = GetHCall();
    }


    //
    // Pointer seems Ok, so carry on
    //
#if CHECKCALLSTATUS
    
    LPLINECALLSTATUS    pCallStatus = NULL;
    
    hr = LineGetCallStatus( hCall, &pCallStatus );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "SwapHold - LineGetCallStatus failed"));
    }
    
    if (pCallStatus->dwCallFeatures & LINECALLFEATURE_SWAPHOLD )
    {
#endif

        //
        // we support it, so try to swap hold
        //
        hr = LineSwapHold(hCall, hHeldCall);
        
        if ( SUCCEEDED(hr) )
        {
            //
            // wait for async reply
            //
            hr = WaitForReply( hr );
            
            if ( FAILED(hr) )
            {
                LOG((TL_ERROR, "SwapHold - LineSwapHold failed async" ));
            }
        }
        else  // LineSwapHold failed
        {
            LOG((TL_ERROR, "SwapHold - LineSwapHold failed" ));
        }
        
#if CHECKCALLSTATUS
        
    }
    else // don't support LineSwapHold
    {
        LOG((TL_ERROR, "SwapHold - LineGetCallStatus reports LineSwapHold not supported"));
        hr = E_FAIL;
    }

    ClientFree( pCallStatus );

#endif
    
    LOG((TL_TRACE, hr, "SwapHold - exit"));
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCall
// Interface : ITBasicCallControl
// Method    : Unpark
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCall::Unpark()
{
    HRESULT             hr = E_FAIL;
    HCALL               hCall;

    LOG((TL_TRACE, "Unpark - enter"));
    
    Lock();
    
    if (m_CallState != CS_IDLE)
    {
        Unlock();
        
        LOG((TL_ERROR,"Unpark - call is not in IDLE state - cannot call Unpark"));
        
        return TAPI_E_INVALCALLSTATE;
    }

    //
    // Do we have a line open ?
    //
    if ( NULL == m_pAddressLine )
    {
        hr = m_pAddress->FindOrOpenALine(
                                         m_dwMediaMode,
                                         &m_pAddressLine
                                        );

        if ( FAILED(hr) )
        {
            Unlock();
            LOG((TL_ERROR, "Unpark - couldn't open a line"));
            LOG((TL_TRACE, hr, "Unpark - exit"));
            return hr;       
        }
    }    
    

    hr =  LineUnpark(
                     m_pAddressLine->t3Line.hLine,
                     m_pAddress->GetAddressID(),
                     &hCall,
                     m_szDestAddress
                    );

    Unlock();

    //
    // Check sync return
    //
    if ( SUCCEEDED(hr) )
    {
        // Wait for the async reply & map it's tapi2 code T3
        hr = WaitForReply( hr );

        if ( SUCCEEDED(hr) )
        {
            FinishSettingUpCall( hCall );
        }
        else // async reply failed
        {
            LOG((TL_ERROR, "Unpark - LineUnpark failed async"));
    
            Lock();
            
            m_pAddress->MaybeCloseALine( &m_pAddressLine );
            
            Unlock();
        }
        
    }
    else  // LineUnpark failed
    {
        LOG((TL_ERROR, "Unpark - LineUnpark failed sync" ));

        Lock();
        
        m_pAddress->MaybeCloseALine( &m_pAddressLine );
        
        Unlock();
    }

    LOG((TL_TRACE, hr, "Unpark - exit"));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_CallHub
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCall::get_CallHub(
                   ITCallHub ** ppCallHub
                  )
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "get_CallHub - enter"));
    
    if ( TAPIIsBadWritePtr( ppCallHub, sizeof(ITCallHub *) ) )
    {
        LOG((TL_ERROR, "get_CallHub - bad pointer"));

        return E_POINTER;
    }
    
    *ppCallHub = NULL;

    //
    // do we have a callhub yet?
    //

    Lock();
    
    if (NULL == m_pCallHub)
    {
        hr = CheckAndCreateFakeCallHub();
    }

    if ( SUCCEEDED(hr) )
    {
        hr = m_pCallHub->QueryInterface(
                                        IID_ITCallHub,
                                        (void**)ppCallHub
                                       );
    }
    
    Unlock();

    LOG((TL_TRACE, "get_CallHub - exit - return %lx", hr));
    
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Pickup
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCall::Pickup(
              BSTR pGroupID
             )
{
    HRESULT             hr = E_FAIL;
    HCALL               hCall;
    
    
    LOG((TL_TRACE, "Pickup - enter"));
    
    //
    // Pickup should accept NULL value in pGroupID argument                                          
    //
    if ( (pGroupID != NULL) && IsBadStringPtrW( pGroupID, -1 ) )
    {
        LOG((TL_TRACE, "Pickup - bad pGroupID"));

        return E_POINTER;
    }

    Lock();

    //
    // If we already have a call handle, don't pickup this call as it will
    // overwrite that handle
    //
    if ( NULL != m_t3Call.hCall )
    {
        Unlock();

        LOG((TL_ERROR, "Pickup - we already have a call handle"));
        LOG((TL_TRACE, hr, "Pickup - exit"));
        
        return TAPI_E_INVALCALLSTATE;        
    }

    //
    // Do we have a line open ?
    //
    if ( NULL == m_pAddressLine )
    {
        hr = m_pAddress->FindOrOpenALine(
                                         m_dwMediaMode,
                                         &m_pAddressLine
                                        );

        if ( FAILED(hr) )
        {
            Unlock();
            
            LOG((TL_ERROR, "Pickup - couldn't open a line"));
            LOG((TL_TRACE, hr, "Pickup - exit"));
            
            return hr;            
        }
    }    



    hr = LinePickup(
                    m_pAddressLine->t3Line.hLine,
                    m_pAddress->GetAddressID(),
                    &hCall,
                    m_szDestAddress,
                    pGroupID
                   );

    Unlock();
    
    //
    // Check sync return
    //
    if ( SUCCEEDED(hr) )
    {
        //
        // wait for async reply
        //
        hr = WaitForReply( hr );

        if ( SUCCEEDED(hr) )
        {
            FinishSettingUpCall( hCall );
            
            //UpdateStateAndPrivilege();
            
        }
        else // async reply failed
        {
            LOG((TL_ERROR, "Pickup - LinePickup failed async"));
    
            Lock();
            
            m_pAddress->MaybeCloseALine( &m_pAddressLine );
            
            Unlock();
        }
        
    }
    else  // LinePickup failed
    {
        LOG((TL_ERROR, "Pickup - LinePickup failed sync" ));

        Lock();
        
        m_pAddress->MaybeCloseALine( &m_pAddressLine );
        
        Unlock();
    }


    LOG((TL_TRACE, hr, "Pickup - exit"));
    
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Dial
//
// simply call LineDial
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCall::Dial( BSTR pDestAddress )
{
    HRESULT     hr;

    LOG((TL_TRACE, "Dial - enter"));
    LOG((TL_TRACE, "Dial - pDestAddress %ls", pDestAddress));

    if ( IsBadStringPtrW( pDestAddress, -1 ) )
    {
        LOG((TL_ERROR, "Dial - bad pDestAddress"));

        return E_POINTER;
    }
    
    Lock();


    hr = LineDial(
                  m_t3Call.hCall,
                  pDestAddress,
                  m_dwCountryCode
                 );


    Unlock();

    if ( SUCCEEDED(hr) )
    {
        hr = WaitForReply( hr );
    }
    else
    {
        LOG((TL_ERROR, "Dial - fail sync - %lx", hr));
    }
    
    LOG((TL_TRACE, "Dial - exit - return %lx", hr));
    
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_AddressType
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifndef NEWCALLINFO
STDMETHODIMP
CCall::get_AddressType(
                       long * plAddressType
                       )
{
    HRESULT         hr = S_OK;
    DWORD           dwAPI;
    

    LOG((TL_TRACE, "get_AddressType - enter"));

    if ( TAPIIsBadWritePtr( plAddressType, sizeof (long) ) )
    {
        LOG((TL_ERROR, "get_AddressType - bad pointer"));
        return E_POINTER;
    }
    
    dwAPI = m_pAddress->GetAPIVersion();
    
    if ( TAPI_VERSION3_0 > dwAPI )
    {
        *plAddressType = LINEADDRESSTYPE_PHONENUMBER;

        LOG((TL_INFO, "get_AddressType - addresstype %lx", *plAddressType));
        LOG((TL_TRACE, "get_AddressType - exit"));
        
        return S_OK;
    }    

    Lock();

    if (ISHOULDUSECALLPARAMS())
    {
        *plAddressType = m_pCallParams->dwAddressType;

        hr = S_OK;
    }
    else
    {
        hr = RefreshCallInfo();

        if ( SUCCEEDED(hr) )
        {
            *plAddressType = m_pCallInfo->dwAddressType;

            LOG((TL_INFO, "get_AddressType - addresstype %lx", m_pCallInfo->dwAddressType));
        }
    }
    
    Unlock();

    LOG((TL_TRACE, "get_AddressType - exit"));
    
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// put_AddressType
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCall::put_AddressType(long lType)
{
    HRESULT             hr = S_OK;
    
    LOG((TL_TRACE, "put_AddressType - enter"));
    
    Lock();

    if ( ISHOULDUSECALLPARAMS() )
    {
        if( m_pAddress->GetAPIVersion() < TAPI_VERSION3_0 )
        {
            if ( LINEADDRESSTYPE_PHONENUMBER != lType )
            {
                LOG((TL_ERROR, "put_AddressType - tsp < ver 3.0 only support phonenumber"));

                hr = E_INVALIDARG;
            }
        }
        else
        {
            //
            // address types get validate in tapisrv
            // when callparams is used
            //
            m_pCallParams->dwAddressType = lType;
        }
        
    }
    else
    {
        LOG((TL_ERROR, "put_AddressType - cannot save in this callstate"));
        
        hr = TAPI_E_INVALCALLSTATE;
    }
   
    Unlock();
    
    LOG((TL_TRACE, "put_AddressType - exit"));
    
    return hr;
}
#endif

#ifdef NEWCALLINFO
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCall::get_CallerIDAddressType(long * plAddressType )
{
    HRESULT         hr = S_OK;
    DWORD           dwAPI;
    
    LOG((TL_TRACE, "get_CallerIDAddressType - enter"));
    
    if ( TAPIIsBadWritePtr( plAddressType, sizeof (long) ) )
    {
        LOG((TL_ERROR, "get_CallerIDAddressType - bad pointer"));
        return E_POINTER;
    }
    
    dwAPI = m_pAddress->GetAPIVersion();
    
    Lock();

    if (ISHOULDUSECALLPARAMS())
    {
        LOG((TL_INFO, "get_CallerIDAddressType - invalid call state"));
        
        hr = TAPI_E_INVALCALLSTATE;
    }
    else
    {
        hr = RefreshCallInfo();

        if ( SUCCEEDED(hr) )
        {
            if ( m_pCallInfo->dwCallerIDFlags & LINECALLPARTYID_ADDRESS )
            {
                if ( TAPI_VERSION3_0 > dwAPI )
                {
                    *plAddressType = LINEADDRESSTYPE_PHONENUMBER;

                    LOG((TL_INFO, "get_CallerIDAddressType - addresstype %lx", *plAddressType));
                    LOG((TL_TRACE, "get_CallerIDAddressType - exit"));
                }    
                else
                {
                    *plAddressType = m_pCallInfo->dwCallerIDAddressType;

                    LOG((TL_INFO, "get_CallerIDAddressType - addresstype %lx", m_pCallInfo->dwCallerIDAddressType));
                }
                
                hr = S_OK;
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }
    
    Unlock();
    LOG((TL_TRACE, "get_CallerIDAddressType - exit"));

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCall::get_CalledIDAddressType(long * plAddressType )
{
    HRESULT         hr = S_OK;
    DWORD           dwAPI;
    
    LOG((TL_TRACE, "get_CalledIDAddressType - enter"));
    
    if ( TAPIIsBadWritePtr( plAddressType, sizeof (long) ) )
    {
        LOG((TL_ERROR, "get_CalledIDAddressType - bad pointer"));
        return E_POINTER;
    }
    
    dwAPI = m_pAddress->GetAPIVersion();
    
    Lock();

    if (ISHOULDUSECALLPARAMS())
    {
        LOG((TL_INFO, "get_CalledIDAddressType - invalid call state"));
        
        hr = TAPI_E_INVALCALLSTATE;
    }
    else
    {
        hr = RefreshCallInfo();

        if ( SUCCEEDED(hr) )
        {
            if ( m_pCallInfo->dwCalledIDFlags & LINECALLPARTYID_ADDRESS )
            {
                if ( TAPI_VERSION3_0 > dwAPI )
                {
                    *plAddressType = LINEADDRESSTYPE_PHONENUMBER;

                    LOG((TL_INFO, "get_CalledIDAddressType - addresstype %lx", *plAddressType));
                    LOG((TL_TRACE, "get_CalledIDAddressType - exit"));
                }    
                else
                {
                    *plAddressType = m_pCallInfo->dwCalledIDAddressType;

                    LOG((TL_INFO, "get_CalledIDAddressType - addresstype %lx", m_pCallInfo->dwCalledIDAddressType));
                }

                hr = S_OK;
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }
    
    Unlock();
    LOG((TL_TRACE, "get_CalledIDAddressType - exit"));

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCall::get_ConnectedIDAddressType(long * plAddressType )
{
    HRESULT         hr = S_OK;
    DWORD           dwAPI;
    
    LOG((TL_TRACE, "get_ConnectedIDAddressType - enter"));
    
    if ( TAPIIsBadWritePtr( plAddressType, sizeof (long) ) )
    {
        LOG((TL_ERROR, "get_ConnectedIDAddressType - bad pointer"));
        return E_POINTER;
    }
    
    dwAPI = m_pAddress->GetAPIVersion();
    
    Lock();

    if (ISHOULDUSECALLPARAMS())
    {
        LOG((TL_INFO, "get_ConnectedIDAddressType - invalid call state"));
        
        hr = TAPI_E_INVALCALLSTATE;
    }
    else
    {
        hr = RefreshCallInfo();

        if ( SUCCEEDED(hr) )
        {
            if ( m_pCallInfo->dwConnectedIDFlags & LINECALLPARTYID_ADDRESS )
            {
                if ( TAPI_VERSION3_0 > dwAPI )
                {
                    *plAddressType = LINEADDRESSTYPE_PHONENUMBER;

                    LOG((TL_INFO, "get_ConnectedIDAddressType - addresstype %lx", *plAddressType));
                    LOG((TL_TRACE, "get_ConnectedIDAddressType - exit"));
                }
                else
                {
                    *plAddressType = m_pCallInfo->dwConnectedIDAddressType;

                    LOG((TL_INFO, "get_ConnectedIDAddressType - addresstype %lx", m_pCallInfo->dwConnectedIDAddressType));
                }

                hr = S_OK;
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }
    
    Unlock();
    LOG((TL_TRACE, "get_ConnectedIDAddressType - exit"));

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCall::get_RedirectionIDAddressType(long * plAddressType )
{
    HRESULT         hr = S_OK;
    DWORD           dwAPI;
    
    LOG((TL_TRACE, "get_RedirectionIDAddressType - enter"));
    
    if ( TAPIIsBadWritePtr( plAddressType, sizeof (long) ) )
    {
        LOG((TL_ERROR, "get_RedirectionIDAddressType - bad pointer"));
        return E_POINTER;
    }
    
    dwAPI = m_pAddress->GetAPIVersion();
    
    Lock();

    if (ISHOULDUSECALLPARAMS())
    {
        LOG((TL_INFO, "get_RedirectionIDAddressType - invalid call state"));
        
        hr = TAPI_E_INVALCALLSTATE;
    }
    else
    {
        hr = RefreshCallInfo();

        if ( SUCCEEDED(hr) )
        {
            if ( m_pCallInfo->dwRedirectionIDFlags & LINECALLPARTYID_ADDRESS )
            {
                if ( TAPI_VERSION3_0 > dwAPI )
                {
                    *plAddressType = LINEADDRESSTYPE_PHONENUMBER;

                    LOG((TL_INFO, "get_RedirectionIDAddressType - addresstype %lx", *plAddressType));
                    LOG((TL_TRACE, "get_RedirectionIDAddressType - exit"));
                }    
                else
                {
                    *plAddressType = m_pCallInfo->dwRedirectionIDAddressType;
                    LOG((TL_INFO, "get_RedirectionIDAddressType - addresstype %lx", m_pCallInfo->dwRedirectionIDAddressType));
                }

                hr = S_OK;
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }
    
    Unlock();
    LOG((TL_TRACE, "get_RedirectionIDAddressType - exit"));

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCall::get_RedirectingIDAddressType(long * plAddressType )
{
    HRESULT         hr = S_OK;
    DWORD           dwAPI;
    
    LOG((TL_TRACE, "get_RedirectingIDAddressType - enter"));
    
    if ( TAPIIsBadWritePtr( plAddressType, sizeof (long) ) )
    {
        LOG((TL_ERROR, "get_RedirectingIDAddressType - bad pointer"));
        return E_POINTER;
    }
    
    dwAPI = m_pAddress->GetAPIVersion();
    
    Lock();

    if (ISHOULDUSECALLPARAMS())
    {
        LOG((TL_INFO, "get_RedirectingIDAddressType - invalid call state"));
        
        hr = TAPI_E_INVALCALLSTATE;
    }
    else
    {
        hr = RefreshCallInfo();

        if ( SUCCEEDED(hr) )
        {
            if ( m_pCallInfo->dwRedirectingIDFlags & LINECALLPARTYID_ADDRESS )
            {
                if ( TAPI_VERSION3_0 > dwAPI )
                {
                    *plAddressType = LINEADDRESSTYPE_PHONENUMBER;

                    LOG((TL_INFO, "get_RedirectingIDAddressType - addresstype %lx", *plAddressType));
                    LOG((TL_TRACE, "get_RedirectingIDAddressType - exit"));
                }    
                else
                {
                    *plAddressType = m_pCallInfo->dwRedirectingIDAddressType;

                    LOG((TL_INFO, "get_RedirectingIDAddressType - addresstype %lx", m_pCallInfo->dwRedirectingIDAddressType));
                }

                hr = S_OK;
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }
    
    Unlock();
    LOG((TL_TRACE, "get_RedirectingIDAddressType - exit"));

    return hr;
}

#endif

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// get_BearerMode
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::get_BearerMode(long * plBearerMode)
{
    LOG((TL_TRACE, "get_BearerMode - enter"));
    
    if ( TAPIIsBadWritePtr( plBearerMode, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_BearerMode - bad pointer"));
        return E_POINTER;
    }

    Lock();

    HRESULT             hr = S_OK;
    
    if ( ISHOULDUSECALLPARAMS() )
    {
        *plBearerMode = m_pCallParams->dwBearerMode;
    }
    else
    {
        hr = RefreshCallInfo();

        if ( SUCCEEDED(hr) )
        {
            *plBearerMode = m_pCallInfo->dwBearerMode;
        }
        else
        {
            LOG((TL_TRACE, "get_BearerMode - not available"));
        }
    }

    Unlock();

    LOG((TL_TRACE, "get_BearerMode - exit"));
    
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// put_BearerMode
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::put_BearerMode(long lBearerMode)
{
    HRESULT         hr = S_OK;
    HCALL           hCall;
    long            lMinRate = 0;
    long            lMaxRate = 0;

    LOG((TL_TRACE, "put_BearerMode - enter"));
    
    Lock();
    
    if ( ISHOULDUSECALLPARAMS() )
    {
        //
        // type is checked in tapisrv
        //
        m_pCallParams->dwBearerMode = lBearerMode;
        Unlock();

    }
    else  // call in progress ( not idle)
    {
        hCall = m_t3Call.hCall;
        Unlock();
    
        get_MinRate(&lMinRate);
        get_MaxRate(&lMaxRate);


        hr = LineSetCallParams(hCall,
                               lBearerMode,
                               lMinRate,
                               lMaxRate,
                               NULL
                              );
        if ( SUCCEEDED(hr) )
        {
            hr = WaitForReply( hr );

            if ( FAILED(hr) )
            {
                LOG((TL_ERROR, "put_BearerMode - failed async"));
            }
        }
        else
        {
            LOG((TL_ERROR, "put_BearerMode - failed sync"));
        }
            
    }


    LOG((TL_TRACE, hr,  "put_BearerMode - exit"));
    
    return hr;
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Origin
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::get_Origin(long * plOrigin )
{
    HRESULT         hr = S_OK;

    
    LOG((TL_TRACE, "get_Origin - enter"));

    if (TAPIIsBadWritePtr(plOrigin, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_Origin - bad pointer"));

        return E_POINTER;
    }

    Lock();
    
    hr = RefreshCallInfo();

    if (!SUCCEEDED(hr))
    {
        LOG((TL_ERROR, "get_Origin - RefreshCallInfo failed - %lx", hr));
    }
    else
    {
        *plOrigin = m_pCallInfo->dwOrigin;
    }

    Unlock();
    
    LOG((TL_TRACE, "get_Origin - exit"));
    
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Reason
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::get_Reason(long * plReason )
{
    HRESULT         hr = S_OK;
    
    LOG((TL_TRACE, "get_Reason - enter"));

    if ( TAPIIsBadWritePtr( plReason , sizeof( plReason ) ) )
    {
        LOG((TL_ERROR, "get_Reason - bad pointer"));

        return E_POINTER;
    }

    Lock();
    
    hr = RefreshCallInfo();

    if ( SUCCEEDED(hr) )
    {
        *plReason = m_pCallInfo->dwReason;
    }
    else
    {
        LOG((TL_ERROR, "get_Reason - linegetcallinfo failed - %lx", hr));
    }

    LOG((TL_TRACE, "get_Reason - exit"));

    Unlock();
    
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_CallerIDName
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::get_CallerIDName(BSTR * ppCallerIDName )
{
    HRESULT         hr = S_OK;
    
    LOG((TL_TRACE, "get_CallerIDName - enter"));

    //
    // validate pointer
    //
    if ( TAPIIsBadWritePtr( ppCallerIDName, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_CallerIDName - bad pointer"));
        return E_POINTER;
    }

    *ppCallerIDName = NULL;
    
    Lock();

    hr = RefreshCallInfo();

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "get_CallerIDName - could not get callinfo"));

        Unlock();
        
        return hr;
    }

    //
    // if info is available
    //
    if ( m_pCallInfo->dwCallerIDFlags & LINECALLPARTYID_NAME )
    {

        //
        // return it
        //

        *ppCallerIDName = BSTRFromUnalingedData(
            (((PBYTE)m_pCallInfo) + m_pCallInfo->dwCallerIDNameOffset),
            m_pCallInfo->dwCallerIDNameSize);

        if ( NULL == *ppCallerIDName )
        {
            LOG((TL_ERROR, "get_CallerIDName - out of memory"));

            Unlock();
            
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        LOG((TL_INFO, "get_CallerIDName - no info avail"));

        Unlock();
        
        return E_FAIL;
    }
    
    Unlock();

    
    LOG((TL_TRACE, "get_CallerIDName - exit"));
    
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_CallerIDNumber
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::get_CallerIDNumber(BSTR * ppCallerIDNumber )
{
    HRESULT         hr = S_OK;
    
    LOG((TL_TRACE, "get_CallerIDNumber - enter"));

    //
    // validate pointer
    //
    if ( TAPIIsBadWritePtr( ppCallerIDNumber, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_CallerIDNumber - bad pointer"));
        return E_POINTER;
    }

    *ppCallerIDNumber = NULL;
    
    Lock();

    hr = RefreshCallInfo();

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "get_CallerIDNumber - could not get callinfo"));

        Unlock();
        
        return hr;
    }

    //
    // if info is available
    //
    if ( m_pCallInfo->dwCallerIDFlags & LINECALLPARTYID_ADDRESS )
    {

        //
        // return it
        //

        *ppCallerIDNumber = BSTRFromUnalingedData(
            (((PBYTE)m_pCallInfo) + m_pCallInfo->dwCallerIDOffset),
            m_pCallInfo->dwCallerIDSize);

        if ( NULL == *ppCallerIDNumber )
        {
            LOG((TL_ERROR, "get_CallerIDNumber - out of memory"));

            Unlock();
            
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        LOG((TL_INFO, "get_CallerIDNumber - no info avail"));

        Unlock();
        
        return E_FAIL;
    }
    
    Unlock();

    
    LOG((TL_TRACE, "get_CallerIDNumber - exit"));
    
    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_CalledIDName
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::get_CalledIDName(BSTR * ppCalledIDName )
{
    HRESULT         hr = S_OK;
    
    LOG((TL_TRACE, "get_CalledIDName - enter"));

    //
    // validate pointer
    //
    if ( TAPIIsBadWritePtr( ppCalledIDName, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_CalledIDName - bad pointer"));

        return E_POINTER;
    }

    *ppCalledIDName = NULL;
    
    Lock();

    hr = RefreshCallInfo();

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "get_CalledIDName - could not get callinfo"));
        
        Unlock();
        
        return hr;
    }

    //
    // if info is available
    //
    if ( m_pCallInfo->dwCalledIDFlags & LINECALLPARTYID_NAME )
    {

        //
        // return it
        //

        *ppCalledIDName = BSTRFromUnalingedData(
            (((PBYTE)m_pCallInfo) + m_pCallInfo->dwCalledIDNameOffset),
            m_pCallInfo->dwCalledIDNameSize );

        if ( NULL == *ppCalledIDName )
        {
            LOG((TL_ERROR, "get_CalledIDName - out of memory"));

            Unlock();
            
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        LOG((TL_INFO, "get_CalledIDName - no info avail"));

        Unlock();
        
        return E_FAIL;
    }
    
    Unlock();

    
    LOG((TL_TRACE, "get_CalledIDName - exit"));
    
    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_CalledIDNumber
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::get_CalledIDNumber(BSTR * ppCalledIDNumber )
{
    HRESULT         hr = S_OK;
    
    LOG((TL_TRACE, "get_CalledIDNumber - enter"));

    //
    // validate pointer
    //
    if ( TAPIIsBadWritePtr( ppCalledIDNumber, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_CalledIDNumber - bad pointer"));
        return E_POINTER;
    }

    *ppCalledIDNumber = NULL;
    
    Lock();

    hr = RefreshCallInfo();

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "get_CalledIDNumber - could not get callinfo"));

        Unlock();
        
        return hr;
    }

    //
    // if info is available
    //
    if ( m_pCallInfo->dwCalledIDFlags & LINECALLPARTYID_ADDRESS )
    {

        //
        // return it
        //
        *ppCalledIDNumber = BSTRFromUnalingedData(
            (((PBYTE)m_pCallInfo) + m_pCallInfo->dwCalledIDOffset),
            m_pCallInfo->dwCalledIDSize);

        if ( NULL == *ppCalledIDNumber )
        {
            LOG((TL_ERROR, "get_CalledIDNumber - out of memory"));

            Unlock();
            
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        LOG((TL_INFO, "get_CalledIDNumber - no info avail"));

        Unlock();
        
        return E_FAIL;
    }
    
    Unlock();

    
    LOG((TL_TRACE, "get_CalledIDNumber - exit"));
    
    return hr;
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_ConnectedIDName
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::get_ConnectedIDName(BSTR * ppConnectedIDName )
{
    HRESULT         hr = S_OK;
    
    LOG((TL_TRACE, "get_ConnectedIDName - enter"));

    //
    // validate pointer
    //
    if ( TAPIIsBadWritePtr( ppConnectedIDName, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_ConnectedIDName - bad pointer"));
        return E_POINTER;
    }

    *ppConnectedIDName = NULL;
    
    Lock();

    hr = RefreshCallInfo();

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "get_ConnectedIDName - could not get callinfo"));

        Unlock();
        
        return hr;
    }

    //
    // if info is available
    //
    if ( m_pCallInfo->dwConnectedIDFlags & LINECALLPARTYID_NAME )
    {

        //
        // return it
        //

        *ppConnectedIDName = BSTRFromUnalingedData(
            (((PBYTE)m_pCallInfo) + m_pCallInfo->dwConnectedIDNameOffset),
            m_pCallInfo->dwConnectedIDNameSize );

        if ( NULL == *ppConnectedIDName )
        {
            LOG((TL_ERROR, "get_ConnectedIDName - out of memory"));

            Unlock();
            
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        LOG((TL_INFO, "get_ConnectedIDName - no info avail"));

        Unlock();
        
        return E_FAIL;
    }
    
    Unlock();

    
    LOG((TL_TRACE, "get_ConnectedIDName - exit"));
    
    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_ConnectedIDNumber
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::get_ConnectedIDNumber(BSTR * ppConnectedIDNumber )
{
    HRESULT         hr = S_OK;
    
    LOG((TL_TRACE, "get_ConnectedIDNumber - enter"));

    //
    // validate pointer
    //
    if ( TAPIIsBadWritePtr( ppConnectedIDNumber, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_ConnectedIDNumber - bad pointer"));
        return E_POINTER;
    }

    *ppConnectedIDNumber = NULL;
    
    Lock();

    hr = RefreshCallInfo();

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "get_ConnectedIDNumber - could not get callinfo"));

        Unlock();
        
        return hr;
    }

    //
    // if info is available
    //
    if ( m_pCallInfo->dwConnectedIDFlags & LINECALLPARTYID_ADDRESS )
    {

        //
        // return it
        //

        *ppConnectedIDNumber = BSTRFromUnalingedData(
            (((PBYTE)m_pCallInfo) + m_pCallInfo->dwConnectedIDOffset),
            m_pCallInfo->dwConnectedIDSize );

        if ( NULL == *ppConnectedIDNumber )
        {
            LOG((TL_ERROR, "get_ConnectedIDNumber - out of memory"));

            Unlock();
            
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        LOG((TL_INFO, "get_ConnectedIDNumber - no info avail"));

        Unlock();
        
        return E_FAIL;
    }
    
    Unlock();

    
    LOG((TL_TRACE, "get_ConnectedIDNumber - exit"));
    
    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_RedirectionIDName
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::get_RedirectionIDName(BSTR * ppRedirectionIDName )
{
    HRESULT         hr = S_OK;
    
    LOG((TL_TRACE, "get_RedirectionIDName - enter"));

    //
    // validate pointer
    //
    if ( TAPIIsBadWritePtr( ppRedirectionIDName, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_RedirectionIDName - bad pointer"));
        return E_POINTER;
    }

    *ppRedirectionIDName = NULL;
    
    Lock();

    hr = RefreshCallInfo();

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "get_RedirectionIDName - could not get callinfo"));

        Unlock();
        
        return hr;
    }

    //
    // if info is available
    //
    if ( m_pCallInfo->dwRedirectionIDFlags & LINECALLPARTYID_NAME )
    {

        //
        // return it
        //
        *ppRedirectionIDName = BSTRFromUnalingedData(
            (((PBYTE)m_pCallInfo) + m_pCallInfo->dwRedirectionIDNameOffset),
            m_pCallInfo->dwRedirectionIDNameSize);

        if ( NULL == *ppRedirectionIDName )
        {
            LOG((TL_ERROR, "get_RedirectionIDName - out of memory"));

            Unlock();
            
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        LOG((TL_INFO, "get_RedirectionIDName - no info avail"));

        Unlock();
        
        return E_FAIL;
    }
    
    Unlock();

    
    LOG((TL_TRACE, "get_RedirectionIDName - exit"));
    
    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_RedirectionIDNumber
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::get_RedirectionIDNumber(BSTR * ppRedirectionIDNumber )
{
    HRESULT         hr = S_OK;
    
    LOG((TL_TRACE, "get_RedirectionIDNumber - enter"));

    //
    // validate pointer
    //
    if ( TAPIIsBadWritePtr( ppRedirectionIDNumber, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_RedirectionIDNumber - bad pointer"));
        return E_POINTER;
    }

    *ppRedirectionIDNumber = NULL;
    
    Lock();

    hr = RefreshCallInfo();

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "get_RedirectionIDNumber - could not get callinfo"));

        Unlock();
        
        return hr;
    }

    //
    // if info is available
    //
    if ( m_pCallInfo->dwRedirectionIDFlags & LINECALLPARTYID_ADDRESS )
    {

        //
        // return it
        //
        *ppRedirectionIDNumber = BSTRFromUnalingedData(
            (((PBYTE)m_pCallInfo) + m_pCallInfo->dwRedirectionIDOffset),
            m_pCallInfo->dwRedirectionIDSize);

        if ( NULL == *ppRedirectionIDNumber )
        {
            LOG((TL_ERROR, "get_RedirectionIDNumber - out of memory"));

            Unlock();
            
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        LOG((TL_INFO, "get_RedirectionIDNumber - no info avail"));

        Unlock();
        
        return E_FAIL;
    }
    
    Unlock();

    
    LOG((TL_TRACE, "get_RedirectionIDNumber - exit"));
    
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_RedirectingIDName
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::get_RedirectingIDName(BSTR * ppRedirectingIDName )
{
    HRESULT         hr = S_OK;
    
    LOG((TL_TRACE, "get_RedirectingIDName - enter"));

    //
    // validate pointer
    //
    if ( TAPIIsBadWritePtr( ppRedirectingIDName, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_RedirectingIDName - bad pointer"));
        return E_POINTER;
    }

    *ppRedirectingIDName = NULL;
    
    
    Lock();

    hr = RefreshCallInfo();

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "get_RedirectingIDName - could not get callinfo"));

        Unlock();
        
        return hr;
    }

    //
    // if info is available
    //
    if ( m_pCallInfo->dwRedirectingIDFlags & LINECALLPARTYID_NAME )
    {

        //
        // return it
        //
        *ppRedirectingIDName = BSTRFromUnalingedData(
            (((PBYTE)m_pCallInfo) + m_pCallInfo->dwRedirectingIDNameOffset),
            m_pCallInfo->dwRedirectingIDNameSize);

        if ( NULL == *ppRedirectingIDName )
        {
            LOG((TL_ERROR, "get_RedirectingIDName - out of memory"));

            Unlock();
            
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        LOG((TL_INFO, "get_RedirectingIDName - no info avail"));

        Unlock();
        
        return E_FAIL;
    }
    
    Unlock();

    
    LOG((TL_TRACE, "get_RedirectingIDName - exit"));
    
    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_RedirectingIDNumber
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::get_RedirectingIDNumber(BSTR * ppRedirectingIDNumber )
{
    HRESULT         hr = S_OK;
    
    LOG((TL_TRACE, "get_RedirectingIDNumber - enter"));

    //
    // validate pointer
    //
    if ( TAPIIsBadWritePtr( ppRedirectingIDNumber, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_RedirectingIDNumber - bad pointer"));
        return E_POINTER;
    }

    *ppRedirectingIDNumber = NULL;
    
    Lock();

    hr = RefreshCallInfo();

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "get_RedirectingIDNumber - could not get callinfo"));

        Unlock();
        
        return hr;
    }

    //
    // if info is available
    //
    if ( m_pCallInfo->dwRedirectingIDFlags & LINECALLPARTYID_ADDRESS )
    {

        //
        // return it
        //

        *ppRedirectingIDNumber = BSTRFromUnalingedData(
            (((PBYTE)m_pCallInfo) + m_pCallInfo->dwRedirectingIDOffset),
            m_pCallInfo->dwRedirectingIDSize );

        if ( NULL == *ppRedirectingIDNumber )
        {
            LOG((TL_ERROR, "get_RedirectingIDNumber - out of memory"));

            Unlock();
            
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        LOG((TL_INFO, "get_RedirectingIDNumber - no info avail"));

        Unlock();
        
        return E_FAIL;
    }
    
    Unlock();

    
    LOG((TL_TRACE, "get_RedirectingIDNumber - exit"));
    
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_CalledPartyFriendlyName
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::get_CalledPartyFriendlyName(BSTR * ppCalledPartyFriendlyName )
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "get_CalledPartyFriendlyName - enter"));

    if ( TAPIIsBadWritePtr( ppCalledPartyFriendlyName, sizeof (BSTR) ) )
    {
        LOG((TL_ERROR, "get_CalledPartyFriendlyName - badpointer"));
        return E_POINTER;
    }

    *ppCalledPartyFriendlyName = NULL;
    
    Lock();

    if ( ISHOULDUSECALLPARAMS() )
    {
        if ( 0 != m_pCallParams->dwCalledPartyOffset )
        {

            *ppCalledPartyFriendlyName = BSTRFromUnalingedData(
                (((PBYTE)m_pCallParams) +  m_pCallParams->dwCalledPartyOffset),
                m_pCallParams->dwCalledPartySize );

            if ( NULL == *ppCalledPartyFriendlyName )
            {
                Unlock();
                
                LOG((TL_ERROR, "get_CalledPartyFriendlyName - out of memory 1"));

                return E_OUTOFMEMORY;
            }

            Unlock();
            
            return S_OK;
        }
        else
        {
            LOG((TL_ERROR, "get_CalledPartyFriendlyName - not available"));
            
            Unlock();

            return S_FALSE;
        }
    }
    
    hr = RefreshCallInfo();

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "get_CalledPartyFriendlyName - can't get callinfo - %lx", hr));

        Unlock();
        
        return hr;
    }

    if ( ( 0 != m_pCallInfo->dwCalledPartyOffset ) &&
         ( 0 != m_pCallInfo->dwCalledPartySize ) )
    {

        //
        // allocated bstr from the data
        //

        *ppCalledPartyFriendlyName = BSTRFromUnalingedData( 
            (((PBYTE)m_pCallInfo) + m_pCallInfo->dwCalledPartyOffset),
            m_pCallInfo->dwCalledPartySize);

        if ( NULL == *ppCalledPartyFriendlyName )
        {
            LOG((TL_ERROR, "get_CalledPartyFriendlyName - out of memory"));

            Unlock();
                    
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        LOG((TL_ERROR, "get_CalledPartyFriendlyName2 - not available"));

        Unlock();
        
        return S_FALSE;
    }

    Unlock();
    
    LOG((TL_TRACE, "get_CalledPartyFriendlyName - exit"));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// put_CalledPartyFriendlyName
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::put_CalledPartyFriendlyName(
                                   BSTR pCalledPartyFriendlyName
                                  )
{
    HRESULT             hr;
    DWORD               dw;
    
    if ( IsBadStringPtrW( pCalledPartyFriendlyName, -1 ) )
    {
        LOG((TL_ERROR, "put_CalledPartyFriendlyName - bad pointer"));

        return E_POINTER;
    }

    dw = ( lstrlenW( pCalledPartyFriendlyName ) + 1 ) * sizeof (WCHAR) ;

    Lock();
    
    if ( !ISHOULDUSECALLPARAMS() )
    {
        LOG((TL_ERROR, "put_CalledPartyFriendlyName - can only be called before connect"));

        Unlock();
        
        return TAPI_E_INVALCALLSTATE;
    }
    
    hr = ResizeCallParams( dw );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "put_CalledPartyFriendlyName - can't resize cp - %lx", hr));

        Unlock();

        return hr;
    }


    //
    // copy string (as bytes to avoid alignment faults under 64 bit)
    //

    CopyMemory( (BYTE*) m_pCallParams + m_dwCallParamsUsedSize,
                pCalledPartyFriendlyName,
                dw );

    m_pCallParams->dwCalledPartySize = dw;
    m_pCallParams->dwCalledPartyOffset = m_dwCallParamsUsedSize;
    m_dwCallParamsUsedSize += dw;

    Unlock();
    
    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Comment
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::get_Comment( BSTR * ppComment )
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "get_Comment - enter"));

    if ( TAPIIsBadWritePtr( ppComment, sizeof (BSTR) ) )
    {
        LOG((TL_ERROR, "get_Comment - badpointer"));
        return E_POINTER;
    }


    *ppComment = NULL;
    
    Lock();

    if ( ISHOULDUSECALLPARAMS() )
    {
        if ( 0 != m_pCallParams->dwCommentOffset )
        {
            *ppComment = BSTRFromUnalingedData(
                (((LPBYTE)m_pCallParams) +  m_pCallParams->dwCommentOffset),
                m_pCallParams->dwCommentSize );

            if ( NULL == *ppComment )
            {
                Unlock();
                
                LOG((TL_ERROR, "get_Comment - out of memory 1"));

                return E_OUTOFMEMORY;
            }

            Unlock();
            
            return S_OK;
        }
        else
        {
            LOG((TL_ERROR, "get_Comment1 - not available"));
            
            Unlock();

            return S_FALSE;
        }
    }
    
    hr = RefreshCallInfo();

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "get_Comment - can't get callinfo - %lx", hr));

        Unlock();
        
        return hr;
    }

    if ( ( 0 != m_pCallInfo->dwCommentSize ) &&
         ( 0 != m_pCallInfo->dwCommentOffset ) )
    {
        *ppComment = BSTRFromUnalingedData(
            (((PBYTE)m_pCallInfo) + m_pCallInfo->dwCommentOffset),
            m_pCallInfo->dwCommentSize );

        if ( NULL == *ppComment )
        {
            LOG((TL_ERROR, "get_Comment - out of memory"));

            Unlock();
            
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        LOG((TL_ERROR, "get_Comment - not available"));

        Unlock();
        
        return S_FALSE;
    }

    Unlock();
    
    LOG((TL_TRACE, "get_Comment - exit"));

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// put_Comment
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::put_Comment( BSTR pComment )
{
    HRESULT             hr;
    DWORD               dw;

    
    if ( IsBadStringPtrW( pComment, -1 ) )
    {
        LOG((TL_ERROR, "put_Comment - bad pointer"));

        return E_POINTER;
    }

    dw = ( lstrlenW( pComment ) + 1 ) * sizeof (WCHAR) ;

    Lock();
    
    if ( !ISHOULDUSECALLPARAMS() )
    {
        LOG((TL_ERROR, "put_Comment - can only be called before connect"));

        Unlock();
        
        return TAPI_E_INVALCALLSTATE;
    }
    
    hr = ResizeCallParams( dw );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "put_Comment - can't resize cp - %lx", hr));

        Unlock();

        return hr;
    }


    //
    // do a byte-wise copy to avoid alignment faults under 64 bit platform
    //

    CopyMemory( (BYTE*) m_pCallParams + m_dwCallParamsUsedSize,
                pComment,
                dw );

    m_pCallParams->dwCommentSize = dw;
    m_pCallParams->dwCommentOffset = m_dwCallParamsUsedSize;
    m_dwCallParamsUsedSize += dw;

    Unlock();
    
    return S_OK;
    
}

#ifndef NEWCALLINFO
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetUserUserInfoSize
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCall::GetUserUserInfoSize(long * plSize )
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "get_UserUserInfoSize - enter"));

    if ( TAPIIsBadWritePtr( plSize, sizeof( long ) ) )
    {
        LOG((TL_ERROR, "get_UserUserInfoSize - bad pointer"));
        return E_POINTER;
    }
         
    Lock();

    if ( ISHOULDUSECALLPARAMS() )
    {
        *plSize = m_pCallParams->dwUserUserInfoSize;
        
        Unlock();

        return S_OK;
    }
    
    hr = RefreshCallInfo();

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "get_UserUserInfoSize - can't get callinfo - %lx", hr));

        Unlock();
        
        return hr;
    }

    *plSize = m_pCallInfo->dwUserUserInfoSize;

    Unlock();

    LOG((TL_TRACE, "get_UserUserInfoSize - exit"));
    
    return hr;
}

#endif

#ifndef NEWCALLINFO   
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetUserUserInfo
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCall::GetUserUserInfo(
                       long lSize,
                       BYTE * pBuffer
                      )
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "GetUserUserInfo - enter"));

    if (lSize == 0)
    {
        LOG((TL_ERROR, "GetUserUserInfo - lSize = 0"));
        return S_FALSE;
    }

    if (TAPIIsBadWritePtr( pBuffer, lSize ) )
    {
        LOG((TL_ERROR, "GetUserUserInfo - bad pointer"));
        return E_POINTER;
    }

    Lock();

    if ( ISHOULDUSECALLPARAMS() )
    {
        if ( 0 == m_pCallParams->dwUserUserInfoSize )
        {
            *pBuffer = NULL;
        }
        else
        {
            if ( lSize < m_pCallParams->dwUserUserInfoSize )
            {
                LOG((TL_ERROR, "GetUserUserInfo - lSize not big enough"));
                
                Unlock();
                
                return E_INVALIDARG;
            }

            CopyMemory(
                       pBuffer,
                       ((PBYTE)m_pCallParams) + m_pCallParams->dwUserUserInfoOffset,
                       m_pCallParams->dwUserUserInfoSize
                      );

        }

        Unlock();

        return hr;
    }
    
    hr = RefreshCallInfo();

    if (!SUCCEEDED(hr))
    {
        LOG((TL_ERROR, "GetUserUserInfo - can't get callinfo - %lx", hr));

        Unlock();
        
        return hr;
    }

    if ( lSize < m_pCallInfo->dwUserUserInfoSize )
    {
        Unlock();
        
        LOG((TL_ERROR, "GetUserUserInfo - buffer not big enough"));

        return E_INVALIDARG;
    }
    
    CopyMemory(
               pBuffer,
               ( (PBYTE)m_pCallInfo ) + m_pCallInfo->dwUserUserInfoOffset,
               m_pCallInfo->dwUserUserInfoSize
              );

    Unlock();

    LOG((TL_TRACE, "GetUserUserInfo - exit"));
    
    return S_OK;
}

#endif

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetUserUserInfo
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifdef NEWCALLINFO
HRESULT
CCall::GetUserUserInfo(
                       DWORD * pdwSize,
                       BYTE ** ppBuffer
                      )
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "GetUserUserInfo - enter"));

    if (TAPIIsBadWritePtr(pdwSize, sizeof(DWORD)))
    {
        LOG((TL_ERROR, "GetUserUserInfo - bad size pointer"));
        return E_POINTER;
    }

    if (TAPIIsBadWritePtr(ppBuffer,sizeof(BYTE*) ) )
    {
        LOG((TL_ERROR, "GetUserUserInfo - bad buffer pointer"));
        return E_POINTER;
    }

    *ppBuffer = NULL;
    *pdwSize = 0;
    
    Lock();

    if ( ISHOULDUSECALLPARAMS() )
    {
        if ( m_pCallParams->dwUserUserInfoSize != 0 )
        {
            BYTE * pTemp;

            pTemp = (BYTE *)CoTaskMemAlloc( m_pCallParams->dwUserUserInfoSize );

            if ( NULL == pTemp )
            {
                LOG((TL_ERROR, "GetUserUserInfo - out of memory"));
                hr = E_OUTOFMEMORY;
            }
            else
            {

                CopyMemory(
                           pTemp,
                           ((PBYTE)m_pCallParams) + m_pCallParams->dwUserUserInfoOffset,
                           m_pCallParams->dwUserUserInfoSize
                          );

                *ppBuffer = pTemp;
                *pdwSize = m_pCallParams->dwUserUserInfoSize;
            }
        }

        Unlock();

        return S_OK;
    }
    
    hr = RefreshCallInfo();

    if (!SUCCEEDED(hr))
    {
        LOG((TL_ERROR, "GetUserUserInfo - can't get callinfo - %lx", hr));

        Unlock();
        
        return hr;
    }

    hr = S_OK;
    
    if ( m_pCallInfo->dwUserUserInfoSize != 0 )
    {
        BYTE * pTemp;

        pTemp = (BYTE *)CoTaskMemAlloc( m_pCallInfo->dwUserUserInfoSize );

        if ( NULL == pTemp )
        {
            LOG((TL_ERROR, "GetUserUserInfo - out of memory"));
            hr = E_OUTOFMEMORY;
        }
        else
        {
            CopyMemory(
                       pTemp,
                       ( (PBYTE)m_pCallInfo ) + m_pCallInfo->dwUserUserInfoOffset,
                       m_pCallInfo->dwUserUserInfoSize
                      );

            *ppBuffer = pTemp;
            *pdwSize = m_pCallInfo->dwUserUserInfoSize;
        }
    }

    Unlock();

    LOG((TL_TRACE, "GetUserUserInfo - exit"));
    
    return hr;
}

#endif

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// SetUserUserInfo
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::SetUserUserInfo(
                       long lSize,
                       BYTE * pBuffer
                      )
{
    HRESULT         hr;
    HCALL           hCall;
    CALL_STATE      cs;
    
    LOG((TL_TRACE, "SetUserUserInfo - enter"));
    
    Lock();

    cs = m_CallState;
    hCall = m_t3Call.hCall;

    if ( CS_IDLE != cs )
    {
        Unlock();
                
        hr =  SendUserUserInfo( hCall, lSize, pBuffer );
    }
    else
    {
        hr =  SaveUserUserInfo( lSize, pBuffer );

        Unlock();
    }

    LOG((TL_TRACE, "SetUserUserInfo - exit - return %lx", hr));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// put_UserUserInfo
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::put_UserUserInfo( VARIANT UUI )
{
    HRESULT         hr;
    DWORD           dwSize;
    PBYTE           pBuffer;

    LOG((TL_TRACE, "put_UserUserInfo - enter"));
    
    hr = MakeBufferFromVariant(
                               UUI,
                               &dwSize,
                               &pBuffer
                              );

    if (!SUCCEEDED(hr))
    {
        LOG((TL_ERROR, "put_UUI - MakeBuffer failed - %lx", hr));
        return hr;
    }
    
    hr = SetUserUserInfo( dwSize, pBuffer );

    ClientFree( pBuffer );

    LOG((TL_TRACE, "put_UserUserInfo - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// get_UserUserInfo
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
#ifdef NEWCALLINFO
HRESULT
CCall::get_UserUserInfo( VARIANT * pUUI )
{
    HRESULT         hr;
    DWORD           dw = 0;
    BYTE          * pBuffer = NULL;
    
    LOG((TL_TRACE, "get_UserUserInfo - enter"));

    if ( TAPIIsBadWritePtr( pUUI, sizeof( VARIANT ) ) )
    {
        LOG((TL_ERROR, "get_UserUserInfo - bad pointer"));

        return E_POINTER;
    }

    pUUI->vt = VT_EMPTY;
    
    hr = GetUserUserInfo( &dw, &pBuffer );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "get_UUI - GetUUI failed %lx", hr));

        ClientFree( pBuffer );
            
        return hr;
    }

    hr = FillVariantFromBuffer( dw, pBuffer, pUUI );

    if ( 0 != dw )
    {
        CoTaskMemFree( pBuffer );
    }

    LOG((TL_TRACE, "get_UserUserInfo - exit - return %lx", hr));
    
    return hr;
}
#else
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// get_UserUserInfo
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCall::get_UserUserInfo( VARIANT * pUUI )
{
    HRESULT         hr;
    DWORD           dw;
    BYTE          * pBuffer;
    
    LOG((TL_TRACE, "get_UserUserInfo - enter"));

    if ( TAPIIsBadWritePtr( pUUI, sizeof( VARIANT ) ) )
    {
        LOG((TL_ERROR, "get_UserUserInfo - bad pointer"));

        return E_POINTER;
    }


    pUUI->vt = VT_EMPTY;
    
    hr = GetUserUserInfoSize( (long *)&dw );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_TRACE, "get_UserUserInfo - GetUUISize failed %lx", hr));

        return hr;
    }
    
    if ( 0 != dw )
    {
        pBuffer = (PBYTE)ClientAlloc( dw );

        if ( NULL == pBuffer )
        {
            LOG((TL_ERROR, "get_useruserinfo - alloc failed"));
            return E_OUTOFMEMORY;
        }
        
        hr = GetUserUserInfo( dw, pBuffer );

        if ( !SUCCEEDED(hr) )
        {
            LOG((TL_ERROR, "get_UUI - GetUUI failed %lx", hr));

            ClientFree( pBuffer );
            
            return hr;
        }
    }

    hr = FillVariantFromBuffer( dw, pBuffer, pUUI );

    if ( 0 != dw )
    {
        ClientFree( pBuffer );
    }

    LOG((TL_TRACE, "get_UserUserInfo - exit - return %lx", hr));
    
    return hr;
}
#endif

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseUserUserInfo
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCall::ReleaseUserUserInfo()
{
    HRESULT         hr;
    HCALL           hCall;

    
    LOG((TL_TRACE, "ReleaseUserUserInfo - enter"));


    Lock();

    hCall = m_t3Call.hCall;

    Unlock();
    
    hr = LineReleaseUserUserInfo(
                                 hCall
                                );

    if (((LONG)hr) < 0)
    {
        LOG((TL_ERROR, "LineReleaseUserUserInfo failed - %lx", hr));
        return hr;
    }

    hr = WaitForReply( hr );

    LOG((TL_TRACE, "ReleaseUserUserInfo - exit"));
    
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_AppSpecific
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::get_AppSpecific(long * plAppSpecific )
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "get_AppSpecific - enter"));

    if ( TAPIIsBadWritePtr( plAppSpecific, sizeof( long ) ) )
    {
        LOG((TL_ERROR, "get_AppSpecific - bad pointer"));
        return E_POINTER;
    }

    Lock();

    hr = RefreshCallInfo();

    if ( !SUCCEEDED(hr) )
    {
        Unlock();
        
        LOG((TL_ERROR, "get_AppSpecific - can't get callinf - %lx", hr));
        
        return hr;
    }

    *plAppSpecific = m_pCallInfo->dwAppSpecific;

    Unlock();

    LOG((TL_TRACE, "get_AppSpecific - exit"));
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// put_AppSpecific
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::put_AppSpecific( long lAppSpecific )
{
    HRESULT         hr = S_OK;
    HCALL           hCall;

    
    LOG((TL_TRACE, "put_AppSpecific - enter"));
    
    Lock();


    //
    // this can only be done if we own the call.
    //

    if (CP_OWNER != m_CallPrivilege)
    {

        Unlock();

        LOG((TL_ERROR, 
            "put_AppSpecific - not call's owner. returning TAPI_E_NOTOWNER"));

        return TAPI_E_NOTOWNER;
    }


    hCall = m_t3Call.hCall;


    Unlock();
    
    
    //
    // we also need to have a call handle before we can linesetappspecific
    //

    if ( hCall != NULL )
    {
        hr = LineSetAppSpecific(
                                hCall,
                                lAppSpecific
                               );
    }
    else
    {
        LOG((TL_ERROR, 
            "put_AppSpecific - Can't set app specific until call is made"));

        hr = TAPI_E_INVALCALLSTATE;
    }

    LOG((TL_TRACE, "put_AppSpecific - exit. hr = %lx", hr));
    
    return hr;
}

#ifdef NEWCALLINFO
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetDevSpecificBuffer
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CCall::GetDevSpecificBuffer(
           DWORD * pdwSize,
           BYTE ** ppDevSpecificBuffer
           )
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "GetDevSpecificBuffer - enter"));

    if (TAPIIsBadWritePtr( pdwSize, sizeof(DWORD) ) )
    {
        LOG((TL_ERROR, "GetDevSpecificBuffer - bad dword pointer"));
        return E_POINTER;
    }

    if ( TAPIIsBadWritePtr ( ppDevSpecificBuffer, sizeof(BYTE*) ) )
    {
        LOG((TL_ERROR, "GetDevSpecificBuffer - bad pointer"));
        return E_POINTER;
    }

    *pdwSize = 0;
    *ppDevSpecificBuffer = NULL;
    
    Lock();

    if ( ISHOULDUSECALLPARAMS() )
    {
        if ( 0 != m_pCallParams->dwDevSpecificSize )
        {
            BYTE * pTemp;

            pTemp = (BYTE *)CoTaskMemAlloc( m_pCallParams->dwDevSpecificSize );

            if ( NULL == pTemp )
            {
                LOG((TL_ERROR, "GetDevSpecificBuffer - out of memory"));
                hr = E_OUTOFMEMORY;
            }
            else
            {
                CopyMemory(
                           pTemp,
                           ((PBYTE)m_pCallParams) + m_pCallParams->dwDevSpecificOffset,
                           m_pCallParams->dwDevSpecificSize
                          );

                *ppDevSpecificBuffer = pTemp;
                *pdwSize = m_pCallParams->dwDevSpecificSize;
            }
        }

        Unlock();

        return hr;
    }
    
    hr = RefreshCallInfo();

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "GetDevSpecificBuffer - can't get callinf - %lx", hr));

        Unlock();

        return hr;
    }

    hr = S_OK;
    
    if ( 0 != m_pCallInfo->dwDevSpecificSize )
    {
        BYTE * pTemp;

        pTemp = (BYTE *)CoTaskMemAlloc( m_pCallInfo->dwDevSpecificSize );

        if ( NULL == pTemp )
        {
            LOG((TL_ERROR, "GetDevSpecificBuffer - out of memory"));
            hr = E_OUTOFMEMORY;
        }
        else
        {
            CopyMemory(
                       pTemp,
                       ( (PBYTE) m_pCallInfo ) + m_pCallInfo->dwDevSpecificOffset,
                       m_pCallInfo->dwDevSpecificSize
                      );

            *ppDevSpecificBuffer = pTemp;
            *pdwSize = m_pCallInfo->dwDevSpecificSize;
        }
    }

    Unlock();
    
    LOG((TL_TRACE, "get_DevSpecificBuffer - exit"));
    
    return hr;
}

#endif


#ifndef NEWCALLINFO
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetDevSpecificBuffer
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCall::GetDevSpecificBuffer(
           long lSize,
           BYTE * pDevSpecificBuffer
           )
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "GetDevSpecificBuffer - enter"));

    if (lSize == 0)
    {
        LOG((TL_ERROR, "GetDevSpecificBuffer - lSize = 0"));
        return S_FALSE;
    }

    if ( TAPIIsBadWritePtr ( pDevSpecificBuffer, lSize ) )
    {
        LOG((TL_ERROR, "GetDevSpecificBuffer - bad pointer"));
        return E_POINTER;
    }
    
    Lock();

    if ( ISHOULDUSECALLPARAMS() )
    {
        if ( 0 != m_pCallParams->dwDevSpecificSize )
        {
            if ( lSize < m_pCallParams->dwDevSpecificSize )
            {
                LOG((TL_ERROR, "GetDevSpecificBuffer - too small"));
                hr = E_INVALIDARG;
            }
            else
            {
                CopyMemory(
                           pDevSpecificBuffer,
                           ((PBYTE)m_pCallParams) + m_pCallParams->dwDevSpecificOffset,
                           m_pCallParams->dwDevSpecificSize
                          );
            }
        }
        else
        {
            *pDevSpecificBuffer = 0;
        }

        Unlock();

        return hr;
    }
    
    hr = RefreshCallInfo();

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "GetDevSpecificBuffer - can't get callinf - %lx", hr));

        Unlock();

        return hr;
    }

    if ( m_pCallInfo->dwDevSpecificSize > lSize )
    {
        LOG((TL_ERROR, "get_DevSpecificBuffer - size not big enough "));

        Unlock();
        
        return E_INVALIDARG;
    }

    CopyMemory(
               pDevSpecificBuffer,
               ( (PBYTE) m_pCallInfo ) + m_pCallInfo->dwDevSpecificOffset,
               m_pCallInfo->dwDevSpecificSize
              );

    Unlock();
    
    LOG((TL_TRACE, "get_DevSpecificBuffer - exit"));
    
    return S_OK;
}

#endif

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// SetDevSpecificBuffer
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::SetDevSpecificBuffer(
                            long lSize,
                            BYTE * pBuffer
                           )
{
    HRESULT             hr = S_OK;

    LOG((TL_TRACE, "SetDevSpecificBuffer - enter"));

    
    if (IsBadReadPtr( pBuffer, lSize) )
    {
        LOG((TL_ERROR, "SetDevSpecificBuffer - bad pointer"));

        return E_POINTER;
    }

    
    Lock();
    
    if ( !ISHOULDUSECALLPARAMS() )
    {
        LOG((TL_ERROR, "SetDevSpecificBuffer - only when call is idle"));

        Unlock();

        return TAPI_E_INVALCALLSTATE;
    }
    
    hr = ResizeCallParams( lSize );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "SetDevSpecificBuffer - can't resize callparams - %lx", hr));

        Unlock();

        return hr;
    }

    CopyMemory(
               ((LPBYTE)m_pCallParams) + m_dwCallParamsUsedSize,
               pBuffer,
               lSize
              );

    m_pCallParams->dwDevSpecificOffset = m_dwCallParamsUsedSize;
    m_pCallParams->dwDevSpecificSize = lSize;
    m_dwCallParamsUsedSize += lSize;

    Unlock();
    
    LOG((TL_TRACE, "SetDevSpecificBuffer - exit"));
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// get_DevSpecificBuffer
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
#ifdef NEWCALLINFO
HRESULT
CCall::get_DevSpecificBuffer( VARIANT * pBuffer )
{
    HRESULT             hr = S_OK;
    BYTE              * p;
    DWORD               dwSize = 0;

    LOG((TL_TRACE, "get_DevSpecificBuffer - enter"));

    if ( TAPIIsBadWritePtr( pBuffer, sizeof( VARIANT ) ) )
    {
        LOG((TL_ERROR, "get_DevSpecificBuffer - bad pointer"));

        return E_POINTER;
    }


    pBuffer->vt = VT_EMPTY;
    
    hr = GetDevSpecificBuffer(
                              &dwSize,
                              &p
                             );

    if (!SUCCEEDED(hr))
    {
        LOG((TL_ERROR, "get_DevSpecificBuffer - GetDevSpecificBuffer failed - %lx", hr));

        return hr;
    }

    hr = FillVariantFromBuffer(
                               dwSize,
                               p,
                               pBuffer
                              );

    if ( 0 != dwSize )
    {
        CoTaskMemFree( p );
    }
    
    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "get_DevSpecificBuffer - fillvariant failed -%lx", hr));

        return hr;
    }

    LOG((TL_TRACE, "get_DevSpecificBuffer - exit"));
    
    return S_OK;
}

#else
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// get_DevSpecificBuffer
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCall::get_DevSpecificBuffer( VARIANT * pBuffer )
{
    HRESULT             hr = S_OK;
    BYTE              * p;
    DWORD               dwSize;

    LOG((TL_TRACE, "get_DevSpecificBuffer - enter"));

    if ( TAPIIsBadWritePtr( pBuffer, sizeof( VARIANT ) ) )
    {
        LOG((TL_ERROR, "get_DevSpecificBuffer - bad pointer"));

        return E_POINTER;
    }


    pBuffer->vt = VT_EMPTY;
    
    hr = GetDevSpecificBufferSize( (long*)&dwSize );

    if (!SUCCEEDED(hr))
    {
        LOG((TL_ERROR, "get_DevSpecificBuffer - getsize failed"));

        return hr;
    }

    if ( 0 != dwSize )
    {
        p = (PBYTE) ClientAlloc( dwSize );

        if ( NULL == p )
        {
            LOG((TL_ERROR, "get_DevSpecificBuffer - alloc failed"));

            return E_OUTOFMEMORY;
        }

        hr = GetDevSpecificBuffer(
                                  dwSize,
                                  p
                                 );

        if (!SUCCEEDED(hr))
        {
            LOG((TL_ERROR, "get_DevSpecificBuffer - GetDevSpecificBuffer failed - %lx", hr));

            ClientFree( p );

            return hr;
        }
    }

    hr = FillVariantFromBuffer(
                               dwSize,
                               p,
                               pBuffer
                              );

    if ( 0 != dwSize )
    {
        ClientFree( p );
    }
    
    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "get_DevSpecificBuffer - fillvariant failed -%lx", hr));

        return hr;
    }

    LOG((TL_TRACE, "get_DevSpecificBuffer - exit"));
    
    return S_OK;
}

#endif
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// put_DevSpecificBuffer
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::put_DevSpecificBuffer( VARIANT Buffer )
{
    HRESULT             hr = S_OK;
    DWORD               dwSize;
    BYTE              * pBuffer;

    
    LOG((TL_TRACE, "put_DevSpecificBuffer - enter"));

    hr = MakeBufferFromVariant(
                               Buffer,
                               &dwSize,
                               &pBuffer
                              );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "put_DevSpecificBuffer - can't make buffer - %lx", hr));

        return hr;
    }

    hr = SetDevSpecificBuffer(
                              dwSize,
                              pBuffer
                             );

    ClientFree( pBuffer );
    
    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "put_DevSpecificBuffer - Set failed - %lx", hr));

        return hr;
    }
    
    LOG((TL_TRACE, "put_DevSpecificBuffer - exit"));
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// SetCallParamsFlags
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::SetCallParamsFlags( long lFlags )
{
    HRESULT             hr = S_OK;
    
    LOG((TL_TRACE, "SetCallParamsFlags - enter"));

    Lock();
    
    if (ISHOULDUSECALLPARAMS())
    {
        //
        // validation in tapisrv
        //
        m_pCallParams->dwCallParamFlags = lFlags;
    }
    else
    {
        LOG((TL_ERROR, "Can't set callparams flags"));

        hr = TAPI_E_INVALCALLSTATE;
    }

    LOG((TL_TRACE, "SetCallParamsFlags - exit"));

    Unlock();
    
    return hr;
}

#ifdef NEWCALLINFO
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetCallParamsFlags
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCall::GetCallParamsFlags( long * plFlags )
{
    HRESULT             hr = S_OK;
    
    LOG((TL_TRACE, "GetCallParamsFlags - enter"));

    if ( TAPIIsBadWritePtr( plFlags, sizeof (long) ) )
    {
        LOG((TL_ERROR, "GetCallParamsFlags - bad pointer"));
        return E_POINTER;
    }

    Lock();
    
    if (ISHOULDUSECALLPARAMS())
    {
        *plFlags = m_pCallParams->dwCallParamFlags;
    }
    else
    {
        hr = RefreshCallInfo();

        if ( !SUCCEEDED(hr) )
        {
            LOG((TL_ERROR, "GetCallParamsFlags - can't get callinfo - %lx", hr));

            Unlock();
        
            return hr;
        }

        *plFlags = m_pCallInfo->dwCallParamFlags;    
    }

    LOG((TL_TRACE, "GetCallParamsFlags - exit"));

    Unlock();
    
    return hr;
}
#endif

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// put_DisplayableAddress
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::put_DisplayableAddress( BSTR pDisplayableAddress )
{
    HRESULT         hr = S_OK;
    DWORD           dwSize;

    
    LOG((TL_TRACE, "put_DisplayableAddress - enter"));
    
    if (IsBadStringPtrW( pDisplayableAddress, -1 ))
    {
        LOG((TL_ERROR, "put_DisplayableAddress - invalid pointer"));

        return E_POINTER;
    }
        
    Lock();
    
    if (!ISHOULDUSECALLPARAMS())
    {
        LOG((TL_ERROR, "Displayable address can only be set before call is made"));

        Unlock();

        return TAPI_E_INVALCALLSTATE;
    }

    dwSize = (lstrlenW( pDisplayableAddress ) + 1) * sizeof(WCHAR);

    hr = ResizeCallParams( dwSize );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "put_DisplayableAddress - resize failed - %lx", hr));

        Unlock();

        return hr;
    }

    //
    // do a byte-wise memory copy (byte-wise to avoid alignment faults under 64
    // bit)
    //

    CopyMemory( (BYTE*) m_pCallParams + m_dwCallParamsUsedSize,
                pDisplayableAddress,
                dwSize );

    m_pCallParams->dwDisplayableAddressSize = dwSize;
    m_pCallParams->dwDisplayableAddressOffset = m_dwCallParamsUsedSize;
    m_dwCallParamsUsedSize += dwSize;

    Unlock();

    LOG((TL_TRACE, "put_DisplayableAddress - exit"));
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// get_DisplayableAddress
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::get_DisplayableAddress( BSTR * ppDisplayableAddress )
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "get_DisplayableAddress - enter"));

    if ( TAPIIsBadWritePtr( ppDisplayableAddress, sizeof (BSTR) ) )
    {
        LOG((TL_ERROR, "get_DisplayableAddress - badpointer"));
        return E_POINTER;
    }

    *ppDisplayableAddress = NULL;
    
    Lock();

    if ( ISHOULDUSECALLPARAMS() )
    {
        if ( 0 != m_pCallParams->dwDisplayableAddressOffset )
        {
            *ppDisplayableAddress = BSTRFromUnalingedData(
                (((LPBYTE)m_pCallParams) +  m_pCallParams->dwDisplayableAddressOffset),
                m_pCallParams->dwDisplayableAddressSize 
                );

            if ( NULL == *ppDisplayableAddress )
            {
                LOG((TL_ERROR, "get_DisplayableAddress - out of memory 1"));

                hr = E_OUTOFMEMORY;

            }

            hr = S_OK;
        }
        else
        {
            *ppDisplayableAddress = NULL;

            hr = S_FALSE;
        }

        Unlock();
        
        return S_OK;
    }
    
    hr = RefreshCallInfo();

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "get_DisplayableAddress - can't get callinfo - %lx", hr));

        Unlock();
        
        return hr;
    }

    if ( ( 0 != m_pCallInfo->dwDisplayableAddressSize ) &&
         ( 0 != m_pCallInfo->dwDisplayableAddressOffset ) )
    {
        *ppDisplayableAddress = BSTRFromUnalingedData( 
            (((PBYTE)m_pCallInfo) + m_pCallInfo->dwDisplayableAddressOffset),
            m_pCallInfo->dwDisplayableAddressSize
            );

        if ( NULL == *ppDisplayableAddress )
        {
            LOG((TL_ERROR, "get_DisplayableAddress - out of memory"));

            Unlock();
            
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        LOG((TL_ERROR, "get_DisplayableAddress - not available"));

        Unlock();
        
        return S_FALSE;
    }

    Unlock();
    
    LOG((TL_TRACE, "get_DisplayableAddress - exit"));

    return hr;
}

#ifdef NEWCALLINFO
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetCallDataBuffer
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCall::GetCallDataBuffer(
                         DWORD * pdwSize,
                         BYTE ** ppBuffer
                        )
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "GetCallDataBuffer - enter"));

    if (TAPIIsBadWritePtr(pdwSize, sizeof(DWORD)))
    {
        LOG((TL_ERROR, "GetCallDataBuffer - bad size pointer"));
        return E_POINTER;
    }

    if (TAPIIsBadWritePtr(ppBuffer,sizeof(BYTE*) ) )
    {
        LOG((TL_ERROR, "GetCallDataBuffer - bad buffer pointer"));
        return E_POINTER;
    }

    *ppBuffer = NULL;
    *pdwSize = 0;

    
    Lock();

    DWORD dwVersionNumber = m_pAddress->GetAPIVersion();

    if ( dwVersionNumber < TAPI_VERSION2_0 )
    {

        LOG((TL_ERROR, 
            "GetCallDataBuffer - version # [0x%lx] less than TAPI_VERSION2_0",
            dwVersionNumber));

        Unlock();
        
        return TAPI_E_NOTSUPPORTED;
    }

    if ( ISHOULDUSECALLPARAMS() )
    {
        if ( m_pCallParams->dwCallDataSize != 0 )
        {
            BYTE * pTemp;

            pTemp = (BYTE *)CoTaskMemAlloc( m_pCallParams->dwCallDataSize );

            if ( NULL == pTemp )
            {
                LOG((TL_ERROR, "GetCallDataBuffer - out of memory"));
                hr = E_OUTOFMEMORY;
            }
            else
            {

                CopyMemory(
                           pTemp,
                           ((PBYTE)m_pCallParams) + m_pCallParams->dwCallDataOffset,
                           m_pCallParams->dwCallDataSize
                          );

                *ppBuffer = pTemp;
                *pdwSize = m_pCallParams->dwCallDataSize;
            }
        }

        Unlock();

        return hr;
    }
    
    hr = RefreshCallInfo();

    if (!SUCCEEDED(hr))
    {
        LOG((TL_ERROR, "GetCallDataBuffer - can't get callinfo - %lx", hr));

        Unlock();
        
        return hr;
    }

    hr = S_OK;
    
    if ( m_pCallInfo->dwCallDataSize != 0 )
    {
        BYTE * pTemp;

        pTemp = (BYTE *)CoTaskMemAlloc( m_pCallInfo->dwCallDataSize );

        if ( NULL == pTemp )
        {
            LOG((TL_ERROR, "GetCallDataBuffer - out of memory"));
            hr = E_OUTOFMEMORY;
        }
        else
        {
            CopyMemory(
                       pTemp,
                       ( (PBYTE)m_pCallInfo ) + m_pCallInfo->dwCallDataOffset,
                       m_pCallInfo->dwCallDataSize
                      );

            *ppBuffer = pTemp;
            *pdwSize = m_pCallInfo->dwCallDataSize;
        }
    }

    Unlock();

    LOG((TL_TRACE, "GetCallDataBuffer - exit"));
    
    return hr;
}
#endif

#ifndef NEWCALLINFO
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetCallDataBuffer
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCall::GetCallDataBuffer( long lSize, BYTE * pBuffer )
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "GetCallDataBuffer - enter"));

    if (lSize == 0)
    {
        LOG((TL_ERROR, "GetCallDataBuffer - lSize = 0"));
        return S_FALSE;
    }

    if ( TAPIIsBadWritePtr ( pBuffer, lSize ) )
    {
        LOG((TL_ERROR, "GetCallDataBuffer - bad pointer"));
        return E_POINTER;
    }
    
    Lock();

    if ( m_pAddress->GetAPIVersion() < TAPI_VERSION2_0 )
    {
        Unlock();
        return TAPI_E_NOTSUPPORTED;
    }

    if ( ISHOULDUSECALLPARAMS() )
    {
        if ( 0 != m_pCallParams->dwCallDataSize )
        {
            if ( lSize < m_pCallParams->dwCallDataSize )
            {
                LOG((TL_ERROR, "GetCallDataBuffer - too small"));
                hr = E_INVALIDARG;
            }
            else
            {
                CopyMemory(
                           pBuffer,
                           ((PBYTE)m_pCallParams) + m_pCallParams->dwCallDataOffset,
                           m_pCallParams->dwCallDataSize
                          );
            }
        }
        else
        {
            *pBuffer = 0;
        }

        Unlock();

        return hr;
    }
    
    hr = RefreshCallInfo();

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "GetCallDataBuffer - can't get callinf - %lx", hr));

        Unlock();

        return hr;
    }

    if ( m_pCallInfo->dwCallDataSize > lSize )
    {
        LOG((TL_ERROR, "GetCallDataBuffer - size not big enough "));

        Unlock();
        
        return E_INVALIDARG;
    }

    CopyMemory(
               pBuffer,
               ( (PBYTE) m_pCallInfo ) + m_pCallInfo->dwCallDataOffset,
               m_pCallInfo->dwCallDataSize
              );

    Unlock();
    
    LOG((TL_TRACE, "GetCallDataBuffer - exit"));
    
    return S_OK;
}

#endif

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// SetCallDataBuffer
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::SetCallDataBuffer( long lSize, BYTE * pBuffer )
{
    HRESULT             hr = S_OK;
    HCALL               hCall;

    LOG((TL_TRACE, "SetCallDataBuffer - enter"));

    if (IsBadReadPtr( pBuffer, lSize) )
    {
        LOG((TL_ERROR, "SetCallDataBuffer - bad pointer"));

        return E_POINTER;
    }

    
    Lock();
    
    if ( m_pAddress->GetAPIVersion() < TAPI_VERSION2_0 )
    {
        Unlock();

        LOG((TL_ERROR, "SetCallDataBuffer - unsupported api version"));

        return TAPI_E_NOTSUPPORTED;
    }


    if ( !ISHOULDUSECALLPARAMS() ) // call in progess (not idle)
    {
        hCall = m_t3Call.hCall;
        Unlock();

        hr = LineSetCallData(hCall,
                             pBuffer,
                             lSize
                            );

        if ( SUCCEEDED(hr) )
        {
            hr = WaitForReply( hr );

            if ( FAILED(hr) )
            {
                LOG((TL_ERROR, "SetCallDataBuffer - failed async"));
            }
        }
        else
        {
            LOG((TL_ERROR, "SetCallDataBuffer - failed sync"));
        }

        LOG((TL_TRACE, "SetCallDataBuffer - exit"));
    
        return hr;
    }
    
    hr = ResizeCallParams( lSize );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "SetCallDataBuffer - can't resize callparams - %lx", hr));

        Unlock();

        return hr;
    }

    CopyMemory(
               ((LPBYTE)m_pCallParams) + m_dwCallParamsUsedSize,
               pBuffer,
               lSize
              );

    m_pCallParams->dwCallDataOffset = m_dwCallParamsUsedSize;
    m_pCallParams->dwCallDataSize = lSize;
    m_dwCallParamsUsedSize += lSize;

    Unlock();
    
    LOG((TL_TRACE, "SetCallDataBuffer - exit"));
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// get_CallDataBuffer
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
#ifdef NEWCALLINFO
HRESULT
CCall::get_CallDataBuffer( VARIANT * pBuffer )
{
    HRESULT             hr = S_OK;
    BYTE              * p;
    DWORD               dwSize = 0;

    LOG((TL_TRACE, "get_CallDataBuffer - enter"));

    if ( TAPIIsBadWritePtr( pBuffer, sizeof( VARIANT ) ) )
    {
        LOG((TL_ERROR, "get_CallDataBuffer - bad pointer"));

        return E_POINTER;
    }


    pBuffer->vt = VT_EMPTY;
    
    hr = GetCallDataBuffer(
                           &dwSize,
                           &p
                          );

    if (!SUCCEEDED(hr))
    {
        LOG((TL_ERROR, "get_CallDataBuffer - failed - %lx", hr));

        return hr;
    }

    hr = FillVariantFromBuffer(
                               dwSize,
                               p,
                               pBuffer
                              );

    if ( 0 != dwSize )
    {
        CoTaskMemFree( p );
    }
    
    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "get_CallDataBuffer - fillvariant failed -%lx", hr));

        return hr;
    }

    LOG((TL_TRACE, "get_CallDataBuffer - exit"));
    
    return S_OK;
}
#else
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// get_CallDataBuffer
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCall::get_CallDataBuffer( VARIANT * pBuffer )
{
    HRESULT             hr = S_OK;
    BYTE              * p;
    DWORD               dwSize;

    LOG((TL_TRACE, "get_CallDataBuffer - enter"));

    if ( TAPIIsBadWritePtr( pBuffer, sizeof( VARIANT ) ) )
    {
        LOG((TL_ERROR, "get_CallDataBuffer - bad pointer"));

        return E_POINTER;
    }


    pBuffer->vt = VT_EMPTY;
    
    hr = GetCallDataBufferSize( (long*)&dwSize );

    if (!SUCCEEDED(hr))
    {
        LOG((TL_ERROR, "get_CallDataBuffer - getsize failed"));

        return hr;
    }

    if ( 0 != dwSize )
    {
        p = (PBYTE) ClientAlloc( dwSize );

        if ( NULL == p )
        {
            LOG((TL_ERROR, "get_CallDataBuffer - alloc failed"));

            return E_OUTOFMEMORY;
        }

        hr = GetCallDataBuffer(
                               dwSize,
                               p
                              );

        if (!SUCCEEDED(hr))
        {
            LOG((TL_ERROR, "get_CallDataBuffer - failed - %lx", hr));

            ClientFree( p );

            return hr;
        }
    }

    hr = FillVariantFromBuffer(
                               dwSize,
                               p,
                               pBuffer
                              );

    if ( 0 != dwSize )
    {
        ClientFree( p );
    }
    
    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "get_CallDataBuffer - fillvariant failed -%lx", hr));

        return hr;
    }

    LOG((TL_TRACE, "get_CallDataBuffer - exit"));
    
    return S_OK;
}


#endif
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// put_CallDataBuffer
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::put_CallDataBuffer( VARIANT Buffer )
{
    HRESULT             hr = S_OK;
    DWORD               dwSize;
    BYTE              * pBuffer;

    LOG((TL_TRACE, "put_CallDataBuffer - enter"));

    hr = MakeBufferFromVariant(
                               Buffer,
                               &dwSize,
                               &pBuffer
                              );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "put_CallDataBuffer - can't make buffer - %lx", hr));

        return hr;
    }

    hr = SetCallDataBuffer(
                           dwSize,
                           pBuffer
                          );

    ClientFree( pBuffer );
    
    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "put_CallDataBuffer - Set failed - %lx", hr));

        return hr;
    }
    
    LOG((TL_TRACE, "put_CallDataBuffer - exit"));
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// get_CallingPartyID
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::get_CallingPartyID( BSTR * ppCallingPartyID )
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "get_CallingPartyID - enter"));

    if ( TAPIIsBadWritePtr( ppCallingPartyID, sizeof (BSTR) ) )
    {
        LOG((TL_ERROR, "get_CallingPartyID - badpointer"));
        return E_POINTER;
    }

    *ppCallingPartyID = NULL;
    
    Lock();

    if ( !ISHOULDUSECALLPARAMS() )
    {
        LOG((TL_ERROR, "get_CallingPartyID - call must be idle"));

        Unlock();
        
        return TAPI_E_INVALCALLSTATE;
    }
    
    if ( ( m_pAddress->GetAPIVersion() >= TAPI_VERSION2_0 ) && ( 0 != m_pCallParams->dwCallingPartyIDOffset ) )
    {

        *ppCallingPartyID = BSTRFromUnalingedData(
            (((LPBYTE)m_pCallParams) +  m_pCallParams->dwCallingPartyIDOffset),
            m_pCallParams->dwCallingPartyIDSize );

        if ( NULL == *ppCallingPartyID )
        {
            LOG((TL_ERROR, "get_CallingPartyID - out of memory 1"));

            hr = E_OUTOFMEMORY;

        }
        else
        {
            hr = S_OK;
        }
    }
    else
    {
        *ppCallingPartyID = NULL;

        hr = S_OK;
    }

    Unlock();
        
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// put_CallingPartyID
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::put_CallingPartyID( BSTR pCallingPartyID )
{
    HRESULT         hr = S_OK;
    DWORD           dwSize;

    
    LOG((TL_TRACE, "put_CallingPartyID - enter"));
    
    if (IsBadStringPtrW( pCallingPartyID, -1 ))
    {
        LOG((TL_ERROR, "put_CallingPartyID - invalid pointer"));

        return E_POINTER;
    }
        
    Lock();
    
    if ( m_pAddress->GetAPIVersion() < TAPI_VERSION2_0 )
    {
        Unlock();
        return TAPI_E_NOTSUPPORTED;
    }

    if (!ISHOULDUSECALLPARAMS())
    {
        LOG((TL_ERROR, "callingpartyid can only be set before call is made"));

        Unlock();

        return TAPI_E_INVALCALLSTATE;
    }

    dwSize = (lstrlenW( pCallingPartyID ) + 1) * sizeof(WCHAR);

    hr = ResizeCallParams( dwSize );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "put_CallingPartyID - resize failed - %lx", hr));

        Unlock();

        return hr;
    }


    //
    // do a byte-wise memory copy (byte-wise to avoid alignment faults under 64
    // bit)
    //

    CopyMemory( (BYTE*) m_pCallParams + m_dwCallParamsUsedSize,
                pCallingPartyID,
                dwSize);

    m_pCallParams->dwCallingPartyIDSize = dwSize;
    m_pCallParams->dwCallingPartyIDOffset = m_dwCallParamsUsedSize;
    m_dwCallParamsUsedSize += dwSize;

    Unlock();

    LOG((TL_TRACE, "put_CallingPartyID - exit"));
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// get_CallTreatment
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::get_CallTreatment( long * plTreatment )
{
    HRESULT         hr;
    
    if ( TAPIIsBadWritePtr( plTreatment, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_CallTreatement - invalid pointer"));
        return E_POINTER;
    }
         
    Lock();

    if ( m_pAddress->GetAPIVersion() < TAPI_VERSION2_0 )
    {
        Unlock();
        return TAPI_E_NOTSUPPORTED;
    }

    if ( CS_IDLE == m_CallState )
    {
        LOG((TL_ERROR, "get_CallTreatment - must be on call"));

        Unlock();
        
        return TAPI_E_INVALCALLSTATE;
    }

    hr = RefreshCallInfo();

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "get_CallTreatment - can't get callinfo - %lx", hr));

        Unlock();

        return hr;
    }
    
    *plTreatment = m_pCallInfo->dwCallTreatment;

    Unlock();
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// put_CallTreatment
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::put_CallTreatment( long lTreatment )
{
    HRESULT         hr = S_OK;
    HCALL           hCall;

    
    LOG((TL_TRACE, "put_CallTreatment - enter"));

    Lock();
    
    if ( CS_IDLE == m_CallState )
    {
        LOG((TL_ERROR, "put_CallTreatment - must make call first"));

        Unlock();
        
        return TAPI_E_INVALCALLSTATE;
    }

    hCall = m_t3Call.hCall;
    
    Unlock();

    
    hr = LineSetCallTreatment(
                              hCall,
                              lTreatment
                             );

    if (((LONG)hr) < 0)
    {
        LOG((TL_ERROR, "put_CallTreatment failed - %lx", hr));
        return hr;
    }

    hr = WaitForReply( hr );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "put_CallTreatment - failed - %lx", hr));
    }


    LOG((TL_TRACE, "put_CallTreatment - exit"));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// put_MinRate
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::put_MinRate(long lMinRate)
{
    HRESULT         hr;


    LOG((TL_TRACE, "put_MinRate - enter"));
    
    if (!(ISHOULDUSECALLPARAMS()))
    {
        LOG((TL_ERROR, "put_MinRate - invalid call state"));

        return TAPI_E_INVALCALLSTATE;
    }

    m_pCallParams->dwMinRate = lMinRate;
    m_dwMinRate = lMinRate;

    LOG((TL_TRACE, "put_MinRate - exit"));
    
    return S_OK;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// get_MinRate
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::get_MinRate(long * plMinRate)
{
    HRESULT         hr;


    LOG((TL_TRACE, "get_MinRate - enter"));

    if (TAPIIsBadWritePtr( plMinRate, sizeof( long ) ) )
    {
        LOG((TL_ERROR, "get_MinRate - bad pointer"));

        return E_POINTER;
    }
    
    *plMinRate = m_dwMinRate;

    LOG((TL_TRACE, "get_MinRate - exit"));
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// put_MaxRate
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::put_MaxRate(long lMaxRate)
{
    HRESULT         hr;


    LOG((TL_TRACE, "put_MaxRate - enter"));
    
    if (!(ISHOULDUSECALLPARAMS()))
    {
        LOG((TL_ERROR, "put_MaxRate - invalid call state"));

        return TAPI_E_INVALCALLSTATE;
    }

    m_pCallParams->dwMaxRate = lMaxRate;
    m_dwMaxRate = lMaxRate;

    LOG((TL_TRACE, "put_MaxRate - exit"));
    
    return S_OK;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// get_MaxRate
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::get_MaxRate(long * plMaxRate)
{
    HRESULT         hr;


    if (TAPIIsBadWritePtr( plMaxRate, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_MaxRate - bad pointer"));

        return E_POINTER;
    }
    
    LOG((TL_TRACE, "get_MaxRate - enter"));
    
  
    *plMaxRate = m_dwMaxRate;

    LOG((TL_TRACE, "get_MaxRate - exit"));
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// put_CountryCode
//
// simply save country code to be used if necessary in lineMakeCall
// and other places
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::put_CountryCode(long lCountryCode)
{
    LOG((TL_TRACE, "put_CountryCode - enter"));

    //
    // simply save - will be validated if/when used
    //
    Lock();
    
    m_dwCountryCode = (DWORD)lCountryCode;

    Unlock();

    LOG((TL_TRACE, "put_CountryCode - exit - success"));
    
    return S_OK;
}

#ifdef NEWCALLINFO
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// get_CountryCode
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCall::get_CountryCode(long * plCountryCode)
{
    HRESULT         hr;


    if (TAPIIsBadWritePtr( plCountryCode, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_CountryCode - bad pointer"));

        return E_POINTER;
    }
    
    LOG((TL_TRACE, "get_CountryCode - enter"));
    
  
    *plCountryCode = m_dwCountryCode;

    LOG((TL_TRACE, "get_CountryCode - exit"));
    
    return S_OK;
}
#endif

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// SetQOS
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCall::SetQOS(
              long lMediaType,
              QOS_SERVICE_LEVEL ServiceLevel
             )
{
    HRESULT         hr = S_OK;
    DWORD           dwMediaMode;

    if (!(m_pAddress->GetMediaMode(
                                   lMediaType,
                                   &dwMediaMode
                                  ) ) )
    {
        LOG((TL_ERROR, "SetQOS - invalid pMediaType"));
        return E_INVALIDARG;
    }
    
    Lock();

    if (ISHOULDUSECALLPARAMS())
    {
        LINECALLQOSINFO * plci;

        if ( m_pAddress->GetAPIVersion() < TAPI_VERSION2_0 )
        {
            Unlock();
            return TAPI_E_NOTSUPPORTED;
        }
    
        if ( 0 != m_pCallParams->dwReceivingFlowspecSize )
        {
            DWORD           dwCount;
            DWORD           dwSize;
            LINECALLQOSINFO * plciOld;
            

            plciOld = (LINECALLQOSINFO*)(((LPBYTE)m_pCallParams) +
                      m_pCallParams->dwReceivingFlowspecOffset);

            dwSize = plciOld->dwTotalSize + sizeof(LINEQOSSERVICELEVEL);
            
            ResizeCallParams( dwSize );

            plci = (LINECALLQOSINFO*)(((LPBYTE)m_pCallParams) +
                                      m_dwCallParamsUsedSize);

            CopyMemory(
                       plci,
                       plciOld,
                       plciOld->dwTotalSize
                      );

            dwCount = plci->SetQOSServiceLevel.dwNumServiceLevelEntries;

            plci->SetQOSServiceLevel.LineQOSServiceLevel[dwCount].
                    dwMediaMode = dwMediaMode;
            plci->SetQOSServiceLevel.LineQOSServiceLevel[dwCount].
                    dwQOSServiceLevel = ServiceLevel;

            plci->SetQOSServiceLevel.dwNumServiceLevelEntries++;

            m_dwCallParamsUsedSize += dwSize;

            Unlock();

            return S_OK;
        }
        else
        {
            ResizeCallParams( sizeof(LINECALLQOSINFO) );

            plci = (LINECALLQOSINFO*)(((LPBYTE)m_pCallParams) +
                                      m_dwCallParamsUsedSize);

            m_pCallParams->dwReceivingFlowspecSize = sizeof( LINECALLQOSINFO );
            m_pCallParams->dwReceivingFlowspecOffset = m_dwCallParamsUsedSize;

            plci->dwKey = LINEQOSSTRUCT_KEY;
            plci->dwTotalSize = sizeof(LINECALLQOSINFO);
            plci->dwQOSRequestType = LINEQOSREQUESTTYPE_SERVICELEVEL;
            plci->SetQOSServiceLevel.dwNumServiceLevelEntries = 1;
            plci->SetQOSServiceLevel.LineQOSServiceLevel[0].
                    dwMediaMode = dwMediaMode;
            plci->SetQOSServiceLevel.LineQOSServiceLevel[0].
                    dwQOSServiceLevel = ServiceLevel;

            m_dwCallParamsUsedSize += sizeof(LINECALLQOSINFO);

            Unlock();
        
            return S_OK;
        }
    }
    else
    {
        HCALL           hCall;

        hCall = m_t3Call.hCall;
        
        Unlock();
        
        hr = LineSetCallQualityOfService(
                                         hCall,
                                         ServiceLevel,
                                         dwMediaMode
                                        );

        return hr;
    }
                                
    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_CallId
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::get_CallId(long * plCallId )
{
    HRESULT         hr = S_OK;

    
    LOG((TL_TRACE, "get_CallId - enter"));

    if (TAPIIsBadWritePtr(plCallId, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_CallId - bad pointer"));

        return E_POINTER;
    }

    Lock();
    
    hr = RefreshCallInfo();

    if (!SUCCEEDED(hr))
    {
        LOG((TL_ERROR, "get_CallId - RefreshCallInfo failed - %lx", hr));
    }
    else
    {
        *plCallId = m_pCallInfo->dwCallID;
    }

    Unlock();
    
    LOG((TL_TRACE, "get_CallId - exit"));
    
    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_RelatedCallId
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::get_RelatedCallId(long * plCallId )
{
    HRESULT         hr = S_OK;

    
    LOG((TL_TRACE, "get_RelatedCallId - enter"));

    if (TAPIIsBadWritePtr(plCallId, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_RelatedCallId - bad pointer"));

        return E_POINTER;
    }

    Lock();
    
    hr = RefreshCallInfo();

    if (!SUCCEEDED(hr))
    {
        LOG((TL_ERROR, "get_RelatedCallId - RefreshCallInfo failed - %lx", hr));
    }
    else
    {
        *plCallId = m_pCallInfo->dwRelatedCallID;
    }

    Unlock();
    
    LOG((TL_TRACE, "get_RelatedCallId - exit"));
    
    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_CompletionId
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::get_CompletionId(long * plCompletionId )
{
    HRESULT         hr = S_OK;

    
    LOG((TL_TRACE, "get_CompletionId - enter"));

    if (TAPIIsBadWritePtr(plCompletionId, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_CompletionId - bad pointer"));

        return E_POINTER;
    }

    Lock();
    
    hr = RefreshCallInfo();

    if (!SUCCEEDED(hr))
    {
        LOG((TL_ERROR, "get_CompletionId - RefreshCallInfo failed - %lx", hr));
    }
    else
    {
        *plCompletionId = m_pCallInfo->dwCompletionID;
    }

    Unlock();
    
    LOG((TL_TRACE, "get_CompletionId - exit"));
    
    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_NumberOfOwners
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::get_NumberOfOwners(long * plNumberOfOwners )
{
    HRESULT         hr = S_OK;

    
    LOG((TL_TRACE, "get_NumberOfOwners - enter"));

    if (TAPIIsBadWritePtr(plNumberOfOwners, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_NumberOfOwners - bad pointer"));

        return E_POINTER;
    }

    Lock();
    
    hr = RefreshCallInfo();

    if (!SUCCEEDED(hr))
    {
        LOG((TL_ERROR, "get_NumberOfOwners - RefreshCallInfo failed - %lx", hr));
    }
    else
    {
        *plNumberOfOwners = m_pCallInfo->dwNumOwners;
    }

    Unlock();
    
    LOG((TL_TRACE, "get_NumberOfOwners - exit"));
    
    return hr;
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_NumberOfMonitors
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::get_NumberOfMonitors(long * plNumberOfMonitors )
{
    HRESULT         hr = S_OK;

    
    LOG((TL_TRACE, "get_NumberOfMonitors - enter"));

    if (TAPIIsBadWritePtr(plNumberOfMonitors, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_NumberOfMonitors - bad pointer"));

        return E_POINTER;
    }

    Lock();
    
    hr = RefreshCallInfo();

    if (!SUCCEEDED(hr))
    {
        LOG((TL_ERROR, "get_NumberOfMonitors - RefreshCallInfo failed - %lx", hr));
    }
    else
    {
        *plNumberOfMonitors = m_pCallInfo->dwNumMonitors;
    }

    Unlock();
    
    LOG((TL_TRACE, "get_NumberOfMonitors - exit"));
    
    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_NumberOfMonitors
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::get_Trunk(long * plTrunk )
{
    HRESULT         hr = S_OK;

    
    LOG((TL_TRACE, "get_Trunk - enter"));

    if (TAPIIsBadWritePtr(plTrunk, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_Trunk - bad pointer"));

        return E_POINTER;
    }

    Lock();
    
    hr = RefreshCallInfo();

    if (!SUCCEEDED(hr))
    {
        LOG((TL_ERROR, "get_Trunk - RefreshCallInfo failed - %lx", hr));
    }
    else
    {
        *plTrunk = m_pCallInfo->dwTrunk;
    }

    Unlock();
    
    LOG((TL_TRACE, "get_Trunk - exit"));
    
    return hr;
}
    


#ifdef NEWCALLINFO
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetHighLevelCompatibilityBuffer
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCall::GetHighLevelCompatibilityBuffer(
                         DWORD * pdwSize,
                         BYTE ** ppBuffer
                        )
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "GetHighLevelCompatibilityBuffer - enter"));

    if (TAPIIsBadWritePtr(pdwSize, sizeof(DWORD)))
    {
        LOG((TL_ERROR, "GetHighLevelCompatibilityBuffer - bad size pointer"));
        return E_POINTER;
    }

    if (TAPIIsBadWritePtr(ppBuffer,sizeof(BYTE*) ) )
    {
        LOG((TL_ERROR, "GetHighLevelCompatibilityBuffer - bad buffer pointer"));
        return E_POINTER;
    }

    *ppBuffer = NULL;
    *pdwSize = 0;
    
    Lock();

    if ( ISHOULDUSECALLPARAMS() )
    {
        if ( m_pCallParams->dwHighLevelCompSize != 0 )
        {
            BYTE * pTemp;

            pTemp = (BYTE *)CoTaskMemAlloc( m_pCallParams->dwHighLevelCompSize );

            if ( NULL == pTemp )
            {
                LOG((TL_ERROR, "GetHighLevelCompatibilityBuffer - out of memory"));
                hr = E_OUTOFMEMORY;
            }
            else
            {

                CopyMemory(
                           pTemp,
                           ((PBYTE)m_pCallParams) + m_pCallParams->dwHighLevelCompOffset,
                           m_pCallParams->dwHighLevelCompSize
                          );

                *ppBuffer = pTemp;
                *pdwSize = m_pCallParams->dwHighLevelCompSize;
            }
        }

        Unlock();

        return hr;
    }
    
    hr = RefreshCallInfo();

    if (!SUCCEEDED(hr))
    {
        LOG((TL_ERROR, "GetHighLevelCompatibilityBuffer - can't get callinfo - %lx", hr));

        Unlock();
        
        return hr;
    }

    hr = S_OK;
    
    if ( m_pCallInfo->dwHighLevelCompSize != 0 )
    {
        BYTE * pTemp;

        pTemp = (BYTE *)CoTaskMemAlloc( m_pCallInfo->dwHighLevelCompSize );

        if ( NULL == pTemp )
        {
            LOG((TL_ERROR, "GetHighLevelCompatibilityBuffer - out of memory"));
            hr = E_OUTOFMEMORY;
        }
        else
        {
            CopyMemory(
                       pTemp,
                       ( (PBYTE)m_pCallInfo ) + m_pCallInfo->dwHighLevelCompOffset,
                       m_pCallInfo->dwHighLevelCompSize
                      );

            *ppBuffer = pTemp;
            *pdwSize = m_pCallInfo->dwHighLevelCompSize;
        }
    }

    Unlock();

    LOG((TL_TRACE, "GetHighLevelCompatibilityBuffer - exit"));
    
    return hr;
}

#endif

#ifndef NEWCALLINFO
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetHighLevelCompatibilityBuffer
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCall::GetHighLevelCompatibilityBuffer(
           long lSize,
           BYTE * pBuffer
           )
{
    HRESULT     hr = S_OK;

    LOG((TL_TRACE, "GetHighLevelCompatibilityBuffer - enter"));

    if (lSize == 0)
    {
        LOG((TL_ERROR, "GetHighLevelCompatibilityBuffer - lSize = 0"));
        return S_FALSE;
    }

    if ( TAPIIsBadWritePtr ( pBuffer, lSize ) )
    {
        LOG((TL_ERROR, "GetHighLevelCompatibilityBuffer - bad pointer"));
        return E_POINTER;
    }
    
    Lock();

    if ( ISHOULDUSECALLPARAMS() )
    {
        if ( 0 != m_pCallParams->dwHighLevelCompSize )
        {
            if ( lSize < m_pCallParams->dwHighLevelCompSize )
            {
                LOG((TL_ERROR, "GetHighLevelCompatibilityBuffer - too small"));
                hr = E_INVALIDARG;
            }
            else
            {
                CopyMemory(pBuffer,
                           ((PBYTE)m_pCallParams) + m_pCallParams->dwHighLevelCompOffset,
                           m_pCallParams->dwHighLevelCompSize
                          );
            }
        }
        else
        {
            *pBuffer = 0;
        }

    }
    else
    {
        hr = RefreshCallInfo();
    
        if ( SUCCEEDED(hr) )
        {
            if ( m_pCallInfo->dwHighLevelCompSize > lSize )
            {
                LOG((TL_ERROR, "GetHighLevelCompatibilityBuffer - size not big enough "));
                return E_INVALIDARG;
            }
            else
            {
            
                CopyMemory(pBuffer,
                           ( (PBYTE) m_pCallInfo ) + m_pCallInfo->dwHighLevelCompOffset,
                           m_pCallInfo->dwHighLevelCompSize
                          );
            }
        }    
        else
        {
            LOG((TL_ERROR, "GetHighLevelCompatibilityBuffer - can't get callinfo - %lx", hr));
        }
    
    }

    Unlock();
    
    LOG((TL_TRACE, hr, "GetHighLevelCompatibilityBuffer - exit"));
    
    return hr;
}
#endif


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// SetHighLevelCompatibilityBuffer
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::SetHighLevelCompatibilityBuffer(
                            long lSize,
                            BYTE * pBuffer
                           )
{
    HRESULT             hr = S_OK;

    LOG((TL_TRACE, "SetHighLevelCompatibilityBuffer - enter"));

    
    if (IsBadReadPtr( pBuffer, lSize) )
    {
        LOG((TL_ERROR, "SetHighLevelCompatibilityBuffer - bad pointer"));

        return E_POINTER;
    }

    
    Lock();
    
    if ( !ISHOULDUSECALLPARAMS() )
    {
        LOG((TL_ERROR, "SetHighLevelCompatibilityBuffer - only when call is idle"));
        hr = TAPI_E_INVALCALLSTATE;
    }
    else
    {
        hr = ResizeCallParams( lSize );
    
        if ( SUCCEEDED(hr) )
        {
            CopyMemory(
                       ((LPBYTE)m_pCallParams) + m_dwCallParamsUsedSize,
                       pBuffer,
                       lSize
                      );
        
            m_pCallParams->dwHighLevelCompOffset = m_dwCallParamsUsedSize;
            m_pCallParams->dwHighLevelCompSize = lSize;
            m_dwCallParamsUsedSize += lSize;
        }
        else
        {
            LOG((TL_ERROR, "SetHighLevelCompatibilityBuffer - can't resize callparams - %lx", hr));
        }
    }

    Unlock();
    
    LOG((TL_TRACE, hr, "SetHighLevelCompatibilityBuffer - exit"));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// get_HighLevelCompatibilityBuffer
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
#ifdef NEWCALLINFO
HRESULT
CCall::get_HighLevelCompatibilityBuffer( VARIANT * pBuffer )
{
    HRESULT             hr = S_OK;
    BYTE              * p = NULL;
    DWORD               dwSize = 0;

    LOG((TL_TRACE, "get_HighLevelCompatibilityBuffer - enter"));

    if ( TAPIIsBadWritePtr( pBuffer, sizeof( VARIANT ) ) )
    {
        LOG((TL_ERROR, "get_HighLevelCompatibilityBuffer - bad pointer"));

        return E_POINTER;
    }


    pBuffer->vt = VT_EMPTY;
    
    hr = GetHighLevelCompatibilityBuffer(&dwSize, &p);

    if (SUCCEEDED(hr))
    {
        hr = FillVariantFromBuffer(
                                   dwSize,
                                   p,
                                   pBuffer
                                  );
        if ( !SUCCEEDED(hr) )
        {
            LOG((TL_ERROR, "get_HighLevelCompatibilityBuffer - fillvariant failed -%lx", hr));
        }
    }

    if ( p != NULL )
    {
        CoTaskMemFree( p );
    }

    LOG((TL_TRACE, hr, "get_HighLevelCompatibilityBuffer - exit"));
    
    return hr;
}

#else
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// get_HighLevelCompatibilityBuffer
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCall::get_HighLevelCompatibilityBuffer( VARIANT * pBuffer )
{
    HRESULT             hr = S_OK;
    BYTE              * p;
    DWORD               dwSize = 0;

    LOG((TL_TRACE, "get_HighLevelCompatibilityBuffer - enter"));

    if ( TAPIIsBadWritePtr( pBuffer, sizeof( VARIANT ) ) )
    {
        LOG((TL_ERROR, "get_HighLevelCompatibilityBuffer - bad pointer"));

        return E_POINTER;
    }


    pBuffer->vt = VT_EMPTY;
    
    hr = GetHighLevelCompatibilityBufferSize( (long*)&dwSize );

    if (SUCCEEDED(hr))
    {
        if ( 0 != dwSize )
        {
            p = (PBYTE) ClientAlloc( dwSize );
            if ( p != NULL )
            {
                hr = GetHighLevelCompatibilityBuffer(dwSize, p);

                if (SUCCEEDED(hr))
                {
                    hr = FillVariantFromBuffer(
                                               dwSize,
                                               p,
                                               pBuffer
                                              );
                    if ( !SUCCEEDED(hr) )
                    {
                        LOG((TL_ERROR, "get_HighLevelCompatibilityBuffer - fillvariant failed -%lx", hr));
                    }
                }
                else
                {
                    LOG((TL_ERROR, "get_HighLevelCompatibilityBuffer - GetHighLevelCompatibilityBuffer failed"));
                }
            }
            else
            {
                LOG((TL_ERROR, "get_HighLevelCompatibilityBuffer - alloc failed"));
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            LOG((TL_INFO, "get_HighLevelCompatibilityBuffer - dwSize = 0"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_HighLevelCompatibilityBuffer - getsize failed"));
    }


    if ( p != NULL )
    {
        ClientFree( p );
    }

    LOG((TL_TRACE, hr, "get_HighLevelCompatibilityBuffer - exit"));
    
    return hr;
}

#endif
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// put_HighLevelCompatibilityBuffer
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::put_HighLevelCompatibilityBuffer( VARIANT Buffer )
{
    HRESULT             hr = S_OK;
    DWORD               dwSize;
    BYTE              * pBuffer;

    
    LOG((TL_TRACE, "put_HighLevelCompatibilityBuffer - enter"));

    hr = MakeBufferFromVariant(
                               Buffer,
                               &dwSize,
                               &pBuffer
                              );

    if ( SUCCEEDED(hr) )
    {
        hr = SetHighLevelCompatibilityBuffer(
                                             dwSize,
                                             pBuffer
                                            );
    
        ClientFree( pBuffer );
        
        if ( !SUCCEEDED(hr) )
        {
            LOG((TL_ERROR, "put_HighLevelCompatibilityBuffer - Set failed - %lx", hr));
    
            return hr;
        }
    }
    else
    {
        LOG((TL_ERROR, "put_HighLevelCompatibilityBuffer - can't make buffer - %lx", hr));
    }

    
    LOG((TL_TRACE, "put_HighLevelCompatibilityBuffer - exit"));
    
    return S_OK;
}


#ifdef NEWCALLINFO
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetLowLevelCompatibilityBuffer
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCall::GetLowLevelCompatibilityBuffer(
                         DWORD * pdwSize,
                         BYTE ** ppBuffer
                        )
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "GetLowLevelCompatibilityBuffer - enter"));

    if (TAPIIsBadWritePtr(pdwSize, sizeof(DWORD)))
    {
        LOG((TL_ERROR, "GetLowLevelCompatibilityBuffer - bad size pointer"));
        return E_POINTER;
    }

    if (TAPIIsBadWritePtr(ppBuffer,sizeof(BYTE*) ) )
    {
        LOG((TL_ERROR, "GetLowLevelCompatibilityBuffer - bad buffer pointer"));
        return E_POINTER;
    }

    *ppBuffer = NULL;
    *pdwSize = 0;
    
    Lock();

    if ( ISHOULDUSECALLPARAMS() )
    {
        if ( m_pCallParams->dwLowLevelCompSize != 0 )
        {
            BYTE * pTemp;

            pTemp = (BYTE *)CoTaskMemAlloc( m_pCallParams->dwLowLevelCompSize );

            if ( NULL == pTemp )
            {
                LOG((TL_ERROR, "GetLowLevelCompatibilityBuffer - out of memory"));
                hr = E_OUTOFMEMORY;
            }
            else
            {

                CopyMemory(
                           pTemp,
                           ((PBYTE)m_pCallParams) + m_pCallParams->dwLowLevelCompOffset,
                           m_pCallParams->dwLowLevelCompSize
                          );

                *ppBuffer = pTemp;
                *pdwSize = m_pCallParams->dwLowLevelCompSize;
            }
        }

        Unlock();

        return hr;
    }
    
    hr = RefreshCallInfo();

    if (!SUCCEEDED(hr))
    {
        LOG((TL_ERROR, "GetLowLevelCompatibilityBuffer - can't get callinfo - %lx", hr));

        Unlock();
        
        return hr;
    }

    hr = S_OK;
    
    if ( m_pCallInfo->dwLowLevelCompSize != 0 )
    {
        BYTE * pTemp;

        pTemp = (BYTE *)CoTaskMemAlloc( m_pCallInfo->dwLowLevelCompSize );

        if ( NULL == pTemp )
        {
            LOG((TL_ERROR, "GetLowLevelCompatibilityBuffer - out of memory"));
            hr = E_OUTOFMEMORY;
        }
        else
        {
            CopyMemory(
                       pTemp,
                       ( (PBYTE)m_pCallInfo ) + m_pCallInfo->dwLowLevelCompOffset,
                       m_pCallInfo->dwLowLevelCompSize
                      );

            *ppBuffer = pTemp;
            *pdwSize = m_pCallInfo->dwLowLevelCompSize;
        }
    }

    Unlock();

    LOG((TL_TRACE, "GetLowLevelCompatibilityBuffer - exit"));
    
    return hr;
}
#endif

#ifndef NEWCALLINFO
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetLowLevelCompatibilityBuffer
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCall::GetLowLevelCompatibilityBuffer(
           long lSize,
           BYTE * pBuffer
           )
{
    HRESULT     hr = S_OK;

    LOG((TL_TRACE, "GetLowLevelCompatibilityBuffer - enter"));

    if (lSize == 0)
    {
        LOG((TL_ERROR, "GetLowLevelCompatibilityBuffer - lSize = 0"));
        return S_FALSE;
    }

    if ( TAPIIsBadWritePtr ( pBuffer, lSize ) )
    {
        LOG((TL_ERROR, "GetLowLevelCompatibilityBuffer - bad pointer"));
        return E_POINTER;
    }
    
    Lock();

    if ( ISHOULDUSECALLPARAMS() )
    {
        if ( 0 != m_pCallParams->dwLowLevelCompSize )
        {
            if ( lSize < m_pCallParams->dwLowLevelCompSize )
            {
                LOG((TL_ERROR, "GetLowLevelCompatibilityBuffer - too small"));
                hr = E_INVALIDARG;
            }
            else
            {
                CopyMemory(pBuffer,
                           ((PBYTE)m_pCallParams) + m_pCallParams->dwLowLevelCompOffset,
                           m_pCallParams->dwLowLevelCompSize
                          );
            }
        }
        else
        {
            *pBuffer = 0;
        }

    }
    else
    {
        hr = RefreshCallInfo();
    
        if ( SUCCEEDED(hr) )
        {
            if ( m_pCallInfo->dwLowLevelCompSize > lSize )
            {
                LOG((TL_ERROR, "GetLowLevelCompatibilityBuffer - size not big enough "));
                return E_INVALIDARG;
            }
            else
            {
            
                CopyMemory(pBuffer,
                           ( (PBYTE) m_pCallInfo ) + m_pCallInfo->dwLowLevelCompOffset,
                           m_pCallInfo->dwLowLevelCompSize
                          );
            }
        }    
        else
        {
            LOG((TL_ERROR, "GetLowLevelCompatibilityBuffer - can't get callinfo - %lx", hr));
        }
    
    }

    Unlock();
    
    LOG((TL_TRACE, hr, "GetLowLevelCompatibilityBuffer - exit"));
    
    return hr;
}
#endif

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// SetLowLevelCompatibilityBuffer
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::SetLowLevelCompatibilityBuffer(
                            long lSize,
                            BYTE * pBuffer
                           )
{
    HRESULT             hr = S_OK;

    LOG((TL_TRACE, "SetLowLevelCompatibilityBuffer - enter"));

    
    if (IsBadReadPtr( pBuffer, lSize) )
    {
        LOG((TL_ERROR, "SetLowLevelCompatibilityBuffer - bad pointer"));

        return E_POINTER;
    }

    
    Lock();
    
    if ( !ISHOULDUSECALLPARAMS() )
    {
        LOG((TL_ERROR, "SetLowLevelCompatibilityBuffer - only when call is idle"));
        hr = TAPI_E_INVALCALLSTATE;
    }
    else
    {
        hr = ResizeCallParams( lSize );
    
        if ( SUCCEEDED(hr) )
        {
            CopyMemory(
                       ((LPBYTE)m_pCallParams) + m_dwCallParamsUsedSize,
                       pBuffer,
                       lSize
                      );
        
            m_pCallParams->dwLowLevelCompOffset = m_dwCallParamsUsedSize;
            m_pCallParams->dwLowLevelCompSize = lSize;
            m_dwCallParamsUsedSize += lSize;
        }
        else
        {
            LOG((TL_ERROR, "SetLowLevelCompatibilityBuffer - can't resize callparams - %lx", hr));
        }
    }

    Unlock();
    
    LOG((TL_TRACE, hr, "SetLowLevelCompatibilityBuffer - exit"));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// get_LowLevelCompatibilityBuffer
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
#ifdef NEWCALLINFO
HRESULT
CCall::get_LowLevelCompatibilityBuffer( VARIANT * pBuffer )
{
    HRESULT             hr = S_OK;
    BYTE              * p = NULL;
    DWORD               dwSize = 0;

    LOG((TL_TRACE, "get_LowLevelCompatibilityBuffer - enter"));

    if ( TAPIIsBadWritePtr( pBuffer, sizeof( VARIANT ) ) )
    {
        LOG((TL_ERROR, "get_LowLevelCompatibilityBuffer - bad pointer"));

        return E_POINTER;
    }


    pBuffer->vt = VT_EMPTY;
    
    hr = GetLowLevelCompatibilityBuffer(&dwSize, &p);

    if (SUCCEEDED(hr))
    {
        hr = FillVariantFromBuffer(
                                   dwSize,
                                   p,
                                   pBuffer
                                  );
        if ( !SUCCEEDED(hr) )
        {
            LOG((TL_ERROR, "get_LowLevelCompatibilityBuffer - fillvariant failed -%lx", hr));
        }
    }


    if ( p != NULL )
    {
        CoTaskMemFree( p );
    }

    LOG((TL_TRACE, hr, "get_LowLevelCompatibilityBuffer - exit"));
    
    return hr;
}

#else
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// get_LowLevelCompatibilityBuffer
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCall::get_LowLevelCompatibilityBuffer( VARIANT * pBuffer )
{
    HRESULT             hr = S_OK;
    BYTE              * p;
    DWORD               dwSize = 0;

    LOG((TL_TRACE, "get_LowLevelCompatibilityBuffer - enter"));

    if ( TAPIIsBadWritePtr( pBuffer, sizeof( VARIANT ) ) )
    {
        LOG((TL_ERROR, "get_LowLevelCompatibilityBuffer - bad pointer"));

        return E_POINTER;
    }


    pBuffer->vt = VT_EMPTY;
    
    hr = GetLowLevelCompatibilityBufferSize( (long*)&dwSize );

    if (SUCCEEDED(hr))
    {
        if ( 0 != dwSize )
        {
            p = (PBYTE) ClientAlloc( dwSize );
            if ( p != NULL )
            {
                hr = GetLowLevelCompatibilityBuffer(dwSize, p);

                if (SUCCEEDED(hr))
                {
                    hr = FillVariantFromBuffer(
                                               dwSize,
                                               p,
                                               pBuffer
                                              );
                    if ( !SUCCEEDED(hr) )
                    {
                        LOG((TL_ERROR, "get_LowLevelCompatibilityBuffer - fillvariant failed -%lx", hr));
                    }
                }
                else
                {
                    LOG((TL_ERROR, "get_LowLevelCompatibilityBuffer - Get failed"));
                }
            }
            else
            {
                LOG((TL_ERROR, "get_LowLevelCompatibilityBuffer - alloc failed"));
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            LOG((TL_INFO, "get_LowLevelCompatibilityBuffer - dwSize = 0"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_LowLevelCompatibilityBuffer - getsize failed"));
    }


    if ( p != NULL )
    {
        ClientFree( p );
    }

    LOG((TL_TRACE, hr, "get_LowLevelCompatibilityBuffer - exit"));
    
    return hr;
}


#endif
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// put_LowLevelCompatibilityBuffer
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::put_LowLevelCompatibilityBuffer( VARIANT Buffer )
{
    HRESULT             hr = S_OK;
    DWORD               dwSize;
    BYTE              * pBuffer;

    
    LOG((TL_TRACE, "put_LowLevelCompatibilityBuffer - enter"));

    hr = MakeBufferFromVariant(
                               Buffer,
                               &dwSize,
                               &pBuffer
                              );

    if ( SUCCEEDED(hr) )
    {
        hr = SetLowLevelCompatibilityBuffer(
                                            dwSize,
                                            pBuffer
                                           );
    
        ClientFree( pBuffer );
        
        if ( !SUCCEEDED(hr) )
        {
            LOG((TL_ERROR, "put_LowLevelCompatibilityBuffer - Set failed - %lx", hr));
    
            return hr;
        }
    }
    else
    {
        LOG((TL_ERROR, "put_LowLevelCompatibilityBuffer - can't make buffer - %lx", hr));
    }

    
    LOG((TL_TRACE, "put_LowLevelCompatibilityBuffer - exit"));
    
    return S_OK;
}




#ifdef NEWCALLINFO
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetChargingInfoBuffer
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCall::GetChargingInfoBuffer(
                             DWORD * pdwSize,
                             BYTE ** ppBuffer
                            )
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "GetChargingInfoBuffer - enter"));

    if (TAPIIsBadWritePtr(pdwSize, sizeof(DWORD)))
    {
        LOG((TL_ERROR, "GetChargingInfoBuffer - bad size pointer"));
        return E_POINTER;
    }

    if (TAPIIsBadWritePtr(ppBuffer,sizeof(BYTE*) ) )
    {
        LOG((TL_ERROR, "GetChargingInfoBuffer - bad buffer pointer"));
        return E_POINTER;
    }

    *ppBuffer = NULL;
    *pdwSize = 0;
    
    Lock();

    hr = RefreshCallInfo();

    if (!SUCCEEDED(hr))
    {
        LOG((TL_ERROR, "GetChargingInfoBuffer - can't get callinfo - %lx", hr));

        Unlock();
        
        return hr;
    }

    hr = S_OK;
    
    if ( m_pCallInfo->dwChargingInfoSize != 0 )
    {
        BYTE * pTemp;

        pTemp = (BYTE *)CoTaskMemAlloc( m_pCallInfo->dwChargingInfoSize );

        if ( NULL == pTemp )
        {
            LOG((TL_ERROR, "GetChargingInfoBuffer - out of memory"));
            hr = E_OUTOFMEMORY;
        }
        else
        {
            CopyMemory(
                       pTemp,
                       ( (PBYTE)m_pCallInfo ) + m_pCallInfo->dwChargingInfoOffset,
                       m_pCallInfo->dwChargingInfoSize
                      );

            *ppBuffer = pTemp;
            *pdwSize = m_pCallInfo->dwChargingInfoSize;
        }
    }

    Unlock();

    LOG((TL_TRACE, "GetChargingInfoBuffer - exit"));
    
    return hr;
}
#endif


#ifndef NEWCALLINFO
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetChargingInfoBuffer
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCall::GetChargingInfoBuffer(
           long lSize,
           BYTE * pBuffer
           )
{
    HRESULT     hr = S_OK;

    LOG((TL_TRACE, "GetChargingInfoBuffer - enter"));

    if (lSize == 0)
    {
        LOG((TL_ERROR, "GetChargingInfoBuffer - lSize = 0"));
        return S_FALSE;
    }

    if ( TAPIIsBadWritePtr ( pBuffer, lSize ) )
    {
        LOG((TL_ERROR, "GetChargingInfoBuffer - bad pointer"));
        return E_POINTER;
    }
    
    Lock();

    hr = RefreshCallInfo();

    if ( SUCCEEDED(hr) )
    {
        if ( m_pCallInfo->dwChargingInfoSize > lSize )
        {
            LOG((TL_ERROR, "GetChargingInfoBuffer - size not big enough "));
            return E_INVALIDARG;
        }
        else
        {
        
            CopyMemory(pBuffer,
                       ( (PBYTE) m_pCallInfo ) + m_pCallInfo->dwChargingInfoOffset,
                       m_pCallInfo->dwChargingInfoSize
                      );
        }
    }    
    else
    {
        LOG((TL_ERROR, "GetChargingInfoBuffer - can't get callinfo - %lx", hr));
    }


    Unlock();
    
    LOG((TL_TRACE, hr, "GetChargingInfoBuffer - exit"));
    
    return hr;
}
#endif

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// get_ChargingInfoBuffer
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
#ifdef NEWCALLINFO
HRESULT
CCall::get_ChargingInfoBuffer( VARIANT * pBuffer )
{
    HRESULT             hr = S_OK;
    BYTE              * p = NULL;
    DWORD               dwSize = 0;

    LOG((TL_TRACE, "get_ChargingInfoBuffer - enter"));

    if ( TAPIIsBadWritePtr( pBuffer, sizeof( VARIANT ) ) )
    {
        LOG((TL_ERROR, "get_ChargingInfoBuffer - bad pointer"));

        return E_POINTER;
    }


    pBuffer->vt = VT_EMPTY;
    
    hr = GetChargingInfoBuffer(&dwSize, &p);

    if (SUCCEEDED(hr))
    {
        hr = FillVariantFromBuffer(
                                   dwSize,
                                   p,
                                   pBuffer
                                  );
        if ( !SUCCEEDED(hr) )
        {
            LOG((TL_ERROR, "get_ChargingInfoBuffer - fillvariant failed -%lx", hr));
        }
    }

    if ( p != NULL )
    {
        CoTaskMemFree( p );
    }

    LOG((TL_TRACE, hr, "get_ChargingInfoBuffer - exit"));
    
    return hr;
}


#else
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// get_ChargingInfoBuffer
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCall::get_ChargingInfoBuffer( VARIANT * pBuffer )
{
    HRESULT             hr = S_OK;
    BYTE              * p;
    DWORD               dwSize = 0;

    LOG((TL_TRACE, "get_ChargingInfoBuffer - enter"));

    if ( TAPIIsBadWritePtr( pBuffer, sizeof( VARIANT ) ) )
    {
        LOG((TL_ERROR, "get_ChargingInfoBuffer - bad pointer"));

        return E_POINTER;
    }


    pBuffer->vt = VT_EMPTY;
    
    hr = GetChargingInfoBufferSize( (long*)&dwSize );

    if (SUCCEEDED(hr))
    {
        if ( 0 != dwSize )
        {
            p = (PBYTE) ClientAlloc( dwSize );
            if ( p != NULL )
            {
                hr = GetChargingInfoBuffer(dwSize, p);

                if (SUCCEEDED(hr))
                {
                    hr = FillVariantFromBuffer(
                                               dwSize,
                                               p,
                                               pBuffer
                                              );
                    if ( !SUCCEEDED(hr) )
                    {
                        LOG((TL_ERROR, "get_ChargingInfoBuffer - fillvariant failed -%lx", hr));
                    }
                }
                else
                {
                    LOG((TL_ERROR, "get_ChargingInfoBuffer - GetDevSpecificBuffer"));
                }
            }
            else
            {
                LOG((TL_ERROR, "get_ChargingInfoBuffer - alloc failed"));
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            LOG((TL_INFO, "get_ChargingInfoBuffer - dwSize = 0"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_ChargingInfoBuffer - getsize failed"));
    }


    if ( p != NULL )
    {
        ClientFree( p );
    }

    LOG((TL_TRACE, hr, "get_ChargingInfoBuffer - exit"));
    
    return hr;
}


#endif

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Rate
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifdef NEWCALLINFO
HRESULT
#else
STDMETHODIMP
#endif
CCall::get_Rate(long * plRate )
{
    HRESULT         hr = S_OK;

    
    LOG((TL_TRACE, "get_Rate - enter"));

    if (TAPIIsBadWritePtr(plRate, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_Rate - bad pointer"));

        return E_POINTER;
    }

    Lock();
    
    hr = RefreshCallInfo();

    if (!SUCCEEDED(hr))
    {
        LOG((TL_ERROR, "get_Rate - RefreshCallInfo failed - %lx", hr));
    }
    else
    {
        *plRate = m_pCallInfo->dwRate;
    }

    Unlock();
    
    LOG((TL_TRACE, hr, "get_Rate - exit"));
    
    return hr;
}
#ifdef NEWCALLINFO
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCall::get_CallInfoLong(
                        CALLINFO_LONG CallInfoLongType,
                        long * plCallInfoLongVal
                       )
{
    HRESULT         hr = E_FAIL;
    
    LOG((TL_TRACE, "get_CallInfoLong - enter"));

    switch( CallInfoLongType )
    {
        case CIL_MEDIATYPESAVAILABLE:
            hr = get_MediaTypesAvailable( plCallInfoLongVal );
            break;
        case CIL_BEARERMODE:
            hr = get_BearerMode( plCallInfoLongVal );
            break;
        case CIL_CALLERIDADDRESSTYPE:
            hr = get_CallerIDAddressType( plCallInfoLongVal );
            break;
        case CIL_CALLEDIDADDRESSTYPE:
            hr = get_CalledIDAddressType( plCallInfoLongVal );
            break;
        case CIL_CONNECTEDIDADDRESSTYPE:
            hr = get_ConnectedIDAddressType( plCallInfoLongVal );
            break;
        case CIL_REDIRECTIONIDADDRESSTYPE:
             hr = get_RedirectionIDAddressType( plCallInfoLongVal );
            break;
        case CIL_REDIRECTINGIDADDRESSTYPE:
            hr = get_RedirectingIDAddressType( plCallInfoLongVal );
            break;
        case CIL_ORIGIN:
            hr = get_Origin( plCallInfoLongVal );
            break;
        case CIL_REASON:
            hr = get_Reason( plCallInfoLongVal );
            break;
        case CIL_APPSPECIFIC:
            hr = get_AppSpecific( plCallInfoLongVal );
            break;
        case CIL_CALLTREATMENT:
            hr = get_CallTreatment( plCallInfoLongVal );
            break;
        case CIL_MINRATE:
            hr = get_MinRate( plCallInfoLongVal );
            break;
        case CIL_MAXRATE:
            hr = get_MaxRate( plCallInfoLongVal );
            break;
        case CIL_CALLID:
            hr = get_CallId( plCallInfoLongVal );
            break;
        case CIL_RELATEDCALLID:
            hr = get_RelatedCallId( plCallInfoLongVal );
            break;
        case CIL_COMPLETIONID:
            hr = get_CompletionId( plCallInfoLongVal );
            break;
        case CIL_NUMBEROFOWNERS:
            hr = get_NumberOfOwners( plCallInfoLongVal );
            break;
        case CIL_NUMBEROFMONITORS:
            hr = get_NumberOfMonitors( plCallInfoLongVal );
            break;
        case CIL_TRUNK:
            hr = get_Trunk( plCallInfoLongVal );
            break;
        case CIL_RATE:
            hr = get_Rate( plCallInfoLongVal );
            break;
        case CIL_COUNTRYCODE:
            hr = get_CountryCode( plCallInfoLongVal );
            break;
        case CIL_CALLPARAMSFLAGS:
            hr = GetCallParamsFlags( plCallInfoLongVal );
            break;
        case CIL_GENERATEDIGITDURATION:
            hr = get_GenerateDigitDuration( plCallInfoLongVal );
            break;
        case CIL_MONITORDIGITMODES:
            hr = get_MonitorDigitModes( plCallInfoLongVal );
            break;
        case CIL_MONITORMEDIAMODES:
            hr = get_MonitorMediaModes( plCallInfoLongVal );
            break;
        default:
            hr = E_INVALIDARG;
            break;
    }
    
    LOG((TL_TRACE, "get_CallInfoLong - exit - return %lx", hr));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCall::put_CallInfoLong(
                        CALLINFO_LONG CallInfoLongType,
                        long lCallInfoLongVal
                       )
{
    HRESULT         hr = E_FAIL;
    
    LOG((TL_TRACE, "put_CallInfoLong - enter"));
    
    switch( CallInfoLongType )
    {
        case CIL_MEDIATYPESAVAILABLE:
            LOG((TL_ERROR, "Cannot set MEDIATYPESAVAILABLE"));
            hr = TAPI_E_NOTSUPPORTED;
            break;
        case CIL_BEARERMODE:
            hr = put_BearerMode( lCallInfoLongVal );
            break;
        case CIL_CALLERIDADDRESSTYPE:
            LOG((TL_ERROR, "Cannot set CALLERIDIADDRESSTYPE"));
            hr = TAPI_E_NOTSUPPORTED;
            break;
        case CIL_CALLEDIDADDRESSTYPE:
            LOG((TL_ERROR, "Cannot set CALLEDIDIADDRESSTYPE"));
            hr = TAPI_E_NOTSUPPORTED;
            break;
        case CIL_CONNECTEDIDADDRESSTYPE:
            LOG((TL_ERROR, "Cannot set CONNECTEDIDIADDRESSTYPE"));
            hr = TAPI_E_NOTSUPPORTED;
            break;
        case CIL_REDIRECTIONIDADDRESSTYPE:
            LOG((TL_ERROR, "Cannot set REDIRECTIONIDIADDRESSTYPE"));
            hr = TAPI_E_NOTSUPPORTED;
            break;
        case CIL_REDIRECTINGIDADDRESSTYPE:
            LOG((TL_ERROR, "Cannot set REDIRECTINGIDIADDRESSTYPE"));
            hr = TAPI_E_NOTSUPPORTED;
            break;
        case CIL_ORIGIN:
            LOG((TL_ERROR, "Cannot set ORIGIN"));
            hr = TAPI_E_NOTSUPPORTED;
            break;
        case CIL_REASON:
            LOG((TL_ERROR, "Cannot set REASON"));
            hr = TAPI_E_NOTSUPPORTED;
            break;
        case CIL_APPSPECIFIC:
            hr = put_AppSpecific( lCallInfoLongVal );
            break;
        case CIL_CALLTREATMENT:
            hr = put_CallTreatment( lCallInfoLongVal );
            break;
        case CIL_MINRATE:
            hr = put_MinRate( lCallInfoLongVal );
            break;
        case CIL_MAXRATE:
            hr = put_MaxRate( lCallInfoLongVal );
            break;
        case CIL_CALLID:
            LOG((TL_ERROR, "Cannot set CALLID"));
            hr = TAPI_E_NOTSUPPORTED;
            break;
        case CIL_RELATEDCALLID:
            LOG((TL_ERROR, "Cannot set RELATEDCALLID"));
            hr = TAPI_E_NOTSUPPORTED;
            break;
        case CIL_COMPLETIONID:
            LOG((TL_ERROR, "Cannot set COMPLETIONID"));
            hr = TAPI_E_NOTSUPPORTED;
            break;
        case CIL_NUMBEROFOWNERS:
            LOG((TL_ERROR, "Cannot set NUMBEROFOWNERS"));
            hr = TAPI_E_NOTSUPPORTED;
            break;
        case CIL_NUMBEROFMONITORS:
            LOG((TL_ERROR, "Cannot set NUMBEROFMONITORS"));
            hr = TAPI_E_NOTSUPPORTED;
            break;
        case CIL_TRUNK:
            LOG((TL_ERROR, "Cannot set TRUNK"));
            hr = TAPI_E_NOTSUPPORTED;
            break;
        case CIL_RATE:
            LOG((TL_ERROR, "Cannot set RATE"));
            hr = TAPI_E_NOTSUPPORTED;
            break;
        case CIL_COUNTRYCODE:
            hr = put_CountryCode( lCallInfoLongVal );
            break;
        case CIL_CALLPARAMSFLAGS:
            hr = SetCallParamsFlags( lCallInfoLongVal );
            break;
        case CIL_GENERATEDIGITDURATION:
            hr = put_GenerateDigitDuration( lCallInfoLongVal );
            break;
        case CIL_MONITORDIGITMODES:
            LOG((TL_ERROR, "Cannot set MONITORDIGITMODES"));
            hr = TAPI_E_NOTSUPPORTED;
            break;
        case CIL_MONITORMEDIAMODES:
            LOG((TL_ERROR, "Cannot set MONITORMEDIAMODES"));
            hr = TAPI_E_NOTSUPPORTED;
            break;
        default:
            hr = E_INVALIDARG;
            break;
    }

    LOG((TL_TRACE, "put_CallInfoLong - exit - return %lx", hr));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCall::get_CallInfoString(
                          CALLINFO_STRING CallInfoStringType,
                          BSTR * ppCallInfoString
                         )
{
    HRESULT         hr = E_FAIL;
    
    LOG((TL_TRACE, "get_CallInfoString - enter"));

    switch(CallInfoStringType)
    {
        case CIS_CALLERIDNAME:
            hr = get_CallerIDName(ppCallInfoString);
            break;
        case CIS_CALLERIDNUMBER:
            hr = get_CallerIDNumber(ppCallInfoString);
            break;
        case CIS_CALLEDIDNAME:
            hr = get_CalledIDName(ppCallInfoString);
            break;
        case CIS_CALLEDIDNUMBER:
            hr = get_CalledIDNumber(ppCallInfoString);
            break;
        case CIS_CONNECTEDIDNAME:
            hr = get_ConnectedIDName(ppCallInfoString);
            break;
        case CIS_CONNECTEDIDNUMBER:
            hr = get_ConnectedIDNumber(ppCallInfoString);
            break;
        case CIS_REDIRECTIONIDNAME:
            hr = get_RedirectionIDName(ppCallInfoString);
            break;
        case CIS_REDIRECTIONIDNUMBER:
            hr = get_RedirectionIDNumber(ppCallInfoString);
            break;
        case CIS_REDIRECTINGIDNAME:
            hr = get_RedirectingIDName(ppCallInfoString);
            break;
        case CIS_REDIRECTINGIDNUMBER:
            hr = get_RedirectingIDNumber(ppCallInfoString);
            break;
        case CIS_CALLEDPARTYFRIENDLYNAME:
            hr = get_CalledPartyFriendlyName(ppCallInfoString);
            break;
        case CIS_COMMENT:
            hr = get_Comment(ppCallInfoString);
            break;
        case CIS_DISPLAYABLEADDRESS:
            hr = get_DisplayableAddress(ppCallInfoString);
            break;
        case CIS_CALLINGPARTYID:
            hr = get_CallingPartyID(ppCallInfoString);
            break;
        default:
            LOG((TL_ERROR, "get_CallInfoString - invalid type"));
            hr = E_INVALIDARG;
            break;
    }

    
    LOG((TL_TRACE, "get_CallInfoString - exit - return %lx", hr));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCall::put_CallInfoString(
                          CALLINFO_STRING CallInfoStringType,
                          BSTR pCallInfoString
                         )
{
    HRESULT         hr = E_FAIL;
    
    LOG((TL_TRACE, "put_CallInfoString - enter"));

    switch( CallInfoStringType )
    {
        case CIS_CALLERIDNAME:
        case CIS_CALLERIDNUMBER:
        case CIS_CALLEDIDNAME:
        case CIS_CALLEDIDNUMBER:
        case CIS_CONNECTEDIDNAME:
        case CIS_CONNECTEDIDNUMBER:
        case CIS_REDIRECTIONIDNAME:
        case CIS_REDIRECTIONIDNUMBER:
        case CIS_REDIRECTINGIDNAME:
        case CIS_REDIRECTINGIDNUMBER:
            LOG((TL_TRACE,"put_CallInfoString - unsupported CALLINFO_STRING constant - %lx", CallInfoStringType));
            hr = TAPI_E_NOTSUPPORTED;
            break;
        case CIS_CALLEDPARTYFRIENDLYNAME:
            hr = put_CalledPartyFriendlyName(pCallInfoString);
            break;
        case CIS_COMMENT:
            hr = put_Comment(pCallInfoString);
            break;
        case CIS_DISPLAYABLEADDRESS:
            hr = put_DisplayableAddress(pCallInfoString);
            break;
        case CIS_CALLINGPARTYID:
            hr = put_CallingPartyID(pCallInfoString);
            break;
        default:
            LOG((TL_ERROR, "put_CallInfoString - invalid type"));
            hr = E_INVALIDARG;
            break;
    }
    
    LOG((TL_TRACE, "put_CallInfoString - exit - return %lx", hr));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCall::get_CallInfoBuffer(
                          CALLINFO_BUFFER CallInfoBufferType,
                          VARIANT * ppCallInfoBuffer
                         )
{
    HRESULT         hr = E_FAIL;
    
    LOG((TL_TRACE, "get_CallInfoBuffer - enter"));

    switch( CallInfoBufferType )
    {
        case CIB_USERUSERINFO:
            hr = get_UserUserInfo( ppCallInfoBuffer );
            break;
        case CIB_DEVSPECIFICBUFFER:
            hr = get_DevSpecificBuffer( ppCallInfoBuffer );
            break;
        case CIB_CALLDATABUFFER:
            hr = get_CallDataBuffer( ppCallInfoBuffer );
            break;
        case CIB_CHARGINGINFOBUFFER:
            hr = get_ChargingInfoBuffer( ppCallInfoBuffer );
            break;
        case CIB_HIGHLEVELCOMPATIBILITYBUFFER:
            hr = get_HighLevelCompatibilityBuffer( ppCallInfoBuffer );
            break;
        case CIB_LOWLEVELCOMPATIBILITYBUFFER:
            hr = get_LowLevelCompatibilityBuffer( ppCallInfoBuffer );
            break;
        default:
            LOG((TL_ERROR, "get_CallInfoBuffer - invalid type"));
            hr = E_INVALIDARG;
    }
    
    LOG((TL_TRACE, "get_CallInfoBuffer - exit"));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCall::put_CallInfoBuffer(
                          CALLINFO_BUFFER CallInfoBufferType,
                          VARIANT pCallInfoBuffer
                         )
{
    HRESULT         hr = E_FAIL;
    
    LOG((TL_TRACE, "put_CallInfoBuffer - enter"));

    switch( CallInfoBufferType )
    {
        case CIB_USERUSERINFO:
            hr = put_UserUserInfo( pCallInfoBuffer );
            break;
        case CIB_DEVSPECIFICBUFFER:
            hr = put_DevSpecificBuffer( pCallInfoBuffer );
            break;
        case CIB_CALLDATABUFFER:
            hr = put_CallDataBuffer( pCallInfoBuffer );
            break;
        case CIB_CHARGINGINFOBUFFER:
            LOG((TL_ERROR, "put_CallInfoBuffer - CHARGINGINFOBUFFER not supported"));
            hr = TAPI_E_NOTSUPPORTED;
            break;
        case CIB_HIGHLEVELCOMPATIBILITYBUFFER:
            hr = put_HighLevelCompatibilityBuffer( pCallInfoBuffer );
            break;
        case CIB_LOWLEVELCOMPATIBILITYBUFFER:
            hr = put_LowLevelCompatibilityBuffer( pCallInfoBuffer );
            break;
        default:
            LOG((TL_ERROR, "put_CallInfoBuffer - invalid type"));
            hr = E_INVALIDARG;
    }
    
    LOG((TL_TRACE, "put_CallInfoBuffer - exit"));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCall::GetCallInfoBuffer(
                         CALLINFO_BUFFER CallInfoBufferType,
                         DWORD * pdwSize,
                         BYTE ** ppCallInfoBuffer
                        )
{
    HRESULT         hr = E_FAIL;
    
    LOG((TL_TRACE, "GetCallInfoBuffer - enter"));
    
    switch( CallInfoBufferType )
    {
        case CIB_USERUSERINFO:
            hr = GetUserUserInfo( pdwSize, ppCallInfoBuffer );
            break;
        case CIB_DEVSPECIFICBUFFER:
            hr = GetDevSpecificBuffer( pdwSize, ppCallInfoBuffer );
            break;
        case CIB_CALLDATABUFFER:
            hr = GetCallDataBuffer( pdwSize, ppCallInfoBuffer );
            break;
        case CIB_CHARGINGINFOBUFFER:
            hr = GetChargingInfoBuffer( pdwSize, ppCallInfoBuffer );
            break;
        case CIB_HIGHLEVELCOMPATIBILITYBUFFER:
            hr = GetHighLevelCompatibilityBuffer( pdwSize, ppCallInfoBuffer );
            break;
        case CIB_LOWLEVELCOMPATIBILITYBUFFER:
            hr = GetLowLevelCompatibilityBuffer( pdwSize, ppCallInfoBuffer );
            break;
        default:
            LOG((TL_ERROR, "GetCallInfoBuffer - invalid type"));
            hr = E_INVALIDARG;
    }
    LOG((TL_TRACE, "GetCallInfoBuffer - exit"));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCall::SetCallInfoBuffer(
                         CALLINFO_BUFFER CallInfoBufferType,
                         DWORD dwSize,
                         BYTE * pCallInfoBuffer
                        )
{
    HRESULT         hr = E_FAIL;
    
    LOG((TL_TRACE, "SetCallInfoBuffer - enter"));

    switch( CallInfoBufferType )
    {
        case CIB_USERUSERINFO:
            hr = SetUserUserInfo( dwSize, pCallInfoBuffer );
            break;
        case CIB_DEVSPECIFICBUFFER:
            hr = SetDevSpecificBuffer( dwSize, pCallInfoBuffer );
            break;
        case CIB_CALLDATABUFFER:
            hr = SetCallDataBuffer( dwSize, pCallInfoBuffer );
            break;
        case CIB_CHARGINGINFOBUFFER:
            LOG((TL_ERROR, "SetCallInfoBuffer - CHARGINGINFOBUFFER not supported"));
            hr = TAPI_E_NOTSUPPORTED;
            break;
        case CIB_HIGHLEVELCOMPATIBILITYBUFFER:
            hr = SetHighLevelCompatibilityBuffer( dwSize, pCallInfoBuffer );
            break;
        case CIB_LOWLEVELCOMPATIBILITYBUFFER:
            hr = SetLowLevelCompatibilityBuffer( dwSize, pCallInfoBuffer );
            break;
        default:
            LOG((TL_ERROR, "SetCallInfoBuffer - invalid type"));
            hr = E_INVALIDARG;
    }

    LOG((TL_TRACE, "SetCallInfoBuffer - exit"));

    return hr;
}
#endif

#ifndef NEWCALLINFO
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetDevSpecificSize
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCall::GetDevSpecificBufferSize(long * plDevSpecificSize )
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "get_DevSpecificSize - enter"));

    if ( TAPIIsBadWritePtr( plDevSpecificSize, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_DevSpecificSize - bad pointer"));
        return E_POINTER;
    }

    Lock();

    if ( ISHOULDUSECALLPARAMS() )
    {
        *plDevSpecificSize = m_pCallParams->dwDevSpecificSize;

        Unlock();

        return S_OK;
    }
    
    hr = RefreshCallInfo();

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "get_DevSpecificSize - can't get callinfo - %lx", hr));

        Unlock();
        
        return hr;
    }

    *plDevSpecificSize = m_pCallInfo->dwDevSpecificSize;

    Unlock();

    LOG((TL_TRACE, "get_DevSpecificSize - exit"));
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetCallDataBufferSize
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CCall::GetCallDataBufferSize( long * plSize )
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "get_CallDataSize - enter"));

    if ( TAPIIsBadWritePtr( plSize, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_CallDataSize - bad pointer"));
        return E_POINTER;
    }

    Lock();

    if ( m_pAddress->GetAPIVersion() < TAPI_VERSION2_0 )
    {
        Unlock();
        return TAPI_E_NOTSUPPORTED;
    }

    if ( ISHOULDUSECALLPARAMS() )
    {
        *plSize = m_pCallParams->dwCallDataSize;

        Unlock();

        return S_OK;
    }
    
    hr = RefreshCallInfo();

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "get_CallDataSize - can't get callinfo - %lx", hr));

        Unlock();
        
        return hr;
    }

    *plSize = m_pCallInfo->dwCallDataSize;

    Unlock();

    LOG((TL_TRACE, "get_CallDataSize - exit"));
    
    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetHighLevelCompatibilityBufferSize
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCall::GetHighLevelCompatibilityBufferSize(long * plSize )
{
    HRESULT     hr = S_OK;

    LOG((TL_TRACE, "GetHighLevelCompatibilityBufferSize - enter"));

    if ( TAPIIsBadWritePtr( plSize, sizeof(long) ) )
    {
        LOG((TL_ERROR, "GetHighLevelCompatibilityBufferSize - bad pointer"));
        return E_POINTER;
    }

    Lock();

    if ( ISHOULDUSECALLPARAMS() )
    {
        *plSize = m_pCallParams->dwHighLevelCompSize;

        hr = S_OK;

    }
    else
    {
        hr = RefreshCallInfo();
    
        if ( SUCCEEDED(hr) )
        {
            *plSize = m_pCallInfo->dwHighLevelCompSize;
        }
        else
        {
            *plSize = 0;
            LOG((TL_ERROR, "GetHighLevelCompatibilityBufferSize - can't get callinfo - %lx", hr));
        }
    }

    Unlock();

    LOG((TL_TRACE, hr, "GetHighLevelCompatibilityBufferSize - exit"));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetLowLevelCompatibilityBufferSize
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCall::GetLowLevelCompatibilityBufferSize(long * plSize )
{
    HRESULT     hr = S_OK;

    LOG((TL_TRACE, "GetLowLevelCompatibilityBufferSize - enter"));

    if ( TAPIIsBadWritePtr( plSize, sizeof(long) ) )
    {
        LOG((TL_ERROR, "GetLowLevelCompatibilityBufferSize - bad pointer"));
        return E_POINTER;
    }

    Lock();

    if ( ISHOULDUSECALLPARAMS() )
    {
        *plSize = m_pCallParams->dwLowLevelCompSize;

        hr = S_OK;

    }
    else
    {
        hr = RefreshCallInfo();
    
        if ( SUCCEEDED(hr) )
        {
            *plSize = m_pCallInfo->dwLowLevelCompSize;
        }
        else
        {
            *plSize = 0;
            LOG((TL_ERROR, "GetLowLevelCompatibilityBufferSize - can't get callinfo - %lx", hr));
        }
    }

    Unlock();

    LOG((TL_TRACE, hr, "GetLowLevelCompatibilityBufferSize - exit"));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetChargingInfoBufferSize
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCall::GetChargingInfoBufferSize(long * plSize )
{
    HRESULT     hr = S_OK;

    LOG((TL_TRACE, "GetChargingInfoBufferSize - enter"));

    if ( TAPIIsBadWritePtr( plSize, sizeof(long) ) )
    {
        LOG((TL_ERROR, "GetChargingInfoBufferSize - bad pointer"));
        return E_POINTER;
    }

    Lock();

    hr = RefreshCallInfo();

    if ( SUCCEEDED(hr) )
    {
        *plSize = m_pCallInfo->dwChargingInfoSize;
    }
    else
    {
        *plSize = 0;
        LOG((TL_ERROR, "GetChargingInfoBufferSize - can't get callinfo - %lx", hr));
    }

    Unlock();

    LOG((TL_TRACE, hr, "GetChargingInfoBufferSize - exit"));

    return hr;
}
#endif

#ifdef NEWCALLINFO
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// put_GenerateDigitDuration
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCall::put_GenerateDigitDuration( long lGenerateDigitDuration )
{
    HRESULT             hr = S_OK;
    
    LOG((TL_TRACE, "put_GenerateDigitDuration - enter"));

    Lock();
    
    if (ISHOULDUSECALLPARAMS())
    {
        //
        // validation in tapisrv
        //
        m_pCallParams->DialParams.dwDigitDuration = lGenerateDigitDuration;
    }
    else
    {
        LOG((TL_ERROR, "Can't set generate digit duration"));

        hr = TAPI_E_INVALCALLSTATE;
    }

    LOG((TL_TRACE, "put_GenerateDigitDuration - exit"));

    Unlock();
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// get_GenerateDigitDuration
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCall::get_GenerateDigitDuration( long * plGenerateDigitDuration )
{
    HRESULT             hr = S_OK;
    
    LOG((TL_TRACE, "get_GenerateDigitDuration - enter"));

    if ( TAPIIsBadWritePtr( plGenerateDigitDuration, sizeof (long) ) )
    {
        LOG((TL_ERROR, "get_GenerateDigitDuration - bad pointer"));
        return E_POINTER;
    }

    Lock();
    
    if (ISHOULDUSECALLPARAMS())
    {
        *plGenerateDigitDuration = m_pCallParams->DialParams.dwDigitDuration;
    }
    else
    {
        hr = RefreshCallInfo();

        if ( !SUCCEEDED(hr) )
        {
            LOG((TL_ERROR, "get_GenerateDigitDuration - can't get callinfo - %lx", hr));

            Unlock();
        
            return hr;
        }

        *plGenerateDigitDuration = m_pCallInfo->DialParams.dwDigitDuration;    
    }

    LOG((TL_TRACE, "get_GenerateDigitDuration - exit"));

    Unlock();
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// get_MonitorDigitModes
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCall::get_MonitorDigitModes( long * plMonitorDigitModes )
{
    HRESULT             hr = S_OK;
    
    LOG((TL_TRACE, "get_MonitorDigitModes - enter"));

    if ( TAPIIsBadWritePtr( plMonitorDigitModes, sizeof (long) ) )
    {
        LOG((TL_ERROR, "get_MonitorDigitModes - bad pointer"));
        return E_POINTER;
    }

    Lock();
    
    if (ISHOULDUSECALLPARAMS())
    {
        LOG((TL_ERROR, "get_MonitorDigitModes - invalid call state"));

        return TAPI_E_INVALCALLSTATE;
    }
    else
    {
        hr = RefreshCallInfo();

        if ( !SUCCEEDED(hr) )
        {
            LOG((TL_ERROR, "get_MonitorDigitModes - can't get callinfo - %lx", hr));

            Unlock();
        
            return hr;
        }

        *plMonitorDigitModes = m_pCallInfo->dwMonitorDigitModes;    
    }

    LOG((TL_TRACE, "get_MonitorDigitModes - exit"));

    Unlock();
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// get_MonitorMediaModes
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CCall::get_MonitorMediaModes( long * plMonitorMediaModes )
{
    HRESULT             hr = S_OK;
    
    LOG((TL_TRACE, "get_MonitorMediaModes - enter"));

    if ( TAPIIsBadWritePtr( plMonitorMediaModes, sizeof (long) ) )
    {
        LOG((TL_ERROR, "get_MonitorMediaModes - bad pointer"));
        return E_POINTER;
    }

    Lock();
    
    if (ISHOULDUSECALLPARAMS())
    {
        LOG((TL_ERROR, "get_MonitorMediaModes - invalid call state"));

        return TAPI_E_INVALCALLSTATE;
    }
    else
    {
        hr = RefreshCallInfo();

        if ( !SUCCEEDED(hr) )
        {
            LOG((TL_ERROR, "get_MonitorMediaModes - can't get callinfo - %lx", hr));

            Unlock();
        
            return hr;
        }

        *plMonitorMediaModes = m_pCallInfo->dwMonitorMediaModes;    
    }

    LOG((TL_TRACE, "get_MonitorMediaModes - exit"));

    Unlock();
    
    return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\common.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    common.h

Abstract:

Author:

    mquinton  06-12-97

Notes:

Revision History:

--*/

#ifndef __common_h__
#define __common_h__

#undef new
#include <list>
#if defined(_DEBUG)
#define new new(_NORMAL_BLOCK, __FILE__, __LINE__)
#endif

using namespace std;

#include "utils.h"
#include "tapi3err.h"



class CAddress;
class CCall;
class CMediaServiceProvider;
class CTAPI;
class CAgentHandler;
class CCallHub;
class CTerminal;
class CPhone;

typedef struct _T3CALL
{
    HCALL hCall;

    CCall * pCall;
    
} T3CALL, *PT3CALL;

typedef struct _T3LINE
{
    HLINE hLine;

    CAddress * pAddress;
    
    DWORD dwAddressLineStructHandle;

} T3LINE, *PT3LINE;

typedef struct _T3PHONE
{
    HPHONE hPhone;

    CPhone * pPhone;

#ifdef USEPHONE_MSP
    ITPhoneMSPCallPrivate * pMSPCall;
#endif USEPHONE_MSP

} T3PHONE, *PT3PHONE;

typedef struct _tagPrivateObjectStruct
{
    DWORD                    dwProviderID;
    DWORD                    dwDeviceID;
    CTAPI                  * pTapi;
    IUnknown               * pPrivateTapi;
    
} PrivateObjectStruct;



typedef list<DWORD>                         AddressTypeList;
typedef list<LPOLESTR>                      MediaTypePtrList;
typedef list<BSTR>                          TerminalClassPtrList;
typedef list<BSTR>                          BstrPtrList;
typedef list<CONNECTDATA>                   ConnectDataList;
typedef list<PVOID>                         PtrList;
typedef list<long>                          LongList;

typedef CTObjectArray<ITAddress *>                 AddressArray;
typedef CTObjectArray<ITTerminal *>                TerminalArray;
typedef CTObjectArray<ITTerminalPrivate *>         TerminalPrivateArray;
typedef CTArray<ITCallInfo *>                      CallInfoArrayNR;
typedef CTObjectArray<ITCallingCard *>             CallingCardArray;
typedef CTObjectArray<ITLocationInfo *>            LocationArray;
typedef CTObjectArray<ITQueue *>                   QueueArray;
typedef CTObjectArray<ITAgentSession *>            AgentSessionArray;
typedef CTArray<ITCallHub *>                       CallHubArrayNR;
typedef CTArray<IUnknown *>                        UnknownArrayNR;
typedef CTObjectArray<IUnknown *>                  UnknownArray;
//typedef CTArray<ITAgentHandler *>                  AgentHandlerArrayNR;
typedef CTObjectArray<ITAgentHandler *>            AgentHandlerArray;
typedef CTArray<CTAPI *>                           TAPIObjectArrayNR;
typedef CTObjectArray<CTAPI *>                     TAPIObjectArray;
typedef CTObjectArray<ITACDGroup *>                GroupArray;
typedef CTObjectArray<ITAgent *>                   AgentArray;
typedef CTArray<CONNECTDATA>                       ConnectDataArray;
typedef CTArray<PrivateObjectStruct *>             PrivateObjectStructArray;
typedef CTObjectArray<CAddress *>                  CAddressArray;
typedef CTObjectArray<ITStream *>                  StreamArray;
typedef CTObjectArray<ITPhone *>                   PhoneArray;


struct AddressLineStruct
{
    DECLARE_TRACELOG_CLASS(AddressLineStruct)

    AddressLineStruct()
    {
        dwMediaModes = 0;
        dwPrivs = 0;
        dwRefCount = 0;
        lCallbackInstance = 0;
    }

    T3LINE                          t3Line;
    DWORD                           dwMediaModes;
    DWORD                           dwPrivs;

private:
    
    //
    // this data member should only be accessed through public access functions
    //

    DWORD                           dwRefCount;

public:
    
    long                            lCallbackInstance;

public:

    DWORD AddRef()
    {
        LONG l = InterlockedIncrement( (LONG*)(&dwRefCount) );

        LOG((TL_INFO, "AddRef - dwRefCount[%ld]", l));

        _ASSERTE(l > 0);

        return l;
    }


    DWORD Release()
    {
        LONG l = InterlockedDecrement( (LONG*)(&dwRefCount) );

        LOG((TL_INFO, "Release - dwRefCount[%ld]", l));

        _ASSERTE(l >= 0);

        return l;
    }


    //
    // note: the caller is responsible for ensuring thread safety of this call
    //

    void InitializeRefcount(DWORD dwInitialRC)
    {

        dwRefCount = dwInitialRC;
    }

   
};

typedef list<AddressLineStruct *> AddressLinePtrList;

typedef struct _tagRegisterItem
{
    DWORD dwType;
    PVOID pInterface;
    PVOID pRegister;
    
} REGISTERITEM;

typedef enum TAPICALLBACKEVENTTYPE
{
    CALLBACKTYPE_TAPI_EVENT_OBJECT,
    CALLBACKTYPE_RAW_ASYNC_MESSAGE
    
} TAPICALLBACKEVENTTYPE;

typedef struct _tagTAPICALLBACKEVENT
{
    TAPICALLBACKEVENTTYPE   type;
    CTAPI                   *pTapi;
    union
    {
        ASYNCEVENTMSG  asyncMessage;
        struct
        {
            TAPI_EVENT   te;
            IDispatch  * pEvent;
            
        }tapiEvent;
        
    }data;
} TAPICALLBACKEVENT, *PTAPICALLBACKEVENT;

typedef struct _T3INIT_DATA
{
    DWORD               dwKey;

    DWORD               dwInitOptions;

    DWORD               hXxxApp;

    BOOL                bPendingAsyncEventMsg;

    CTAPI *             pTAPI;

} T3INIT_DATA, *PT3INIT_DATA;

#define TAPIERR_INVALRPCCONTEXT     0xF101
   
#define RA_ADDRESS          0
#define RA_CALLHUB          1

#define AUDIOMEDIAMODES (LINEMEDIAMODE_INTERACTIVEVOICE | LINEMEDIAMODE_AUTOMATEDVOICE)

#define ALLMEDIAMODES   (LINEMEDIAMODE_AUTOMATEDVOICE | LINEMEDIAMODE_VIDEO | \
                        LINEMEDIAMODE_G3FAX | LINEMEDIAMODE_DATAMODEM )

#define PRIVATE_UNADVISE                0xFFFF0000
#define PRIVATE_CALLHUB                 0xFFFE0000
#define PRIVATE_PHONESETHOOKSWITCH      0xFFFD0000
#define PRIVATE_MSPEVENT                0xFFFC0000
#define PRIVATE_ISDN__ACCEPTTOALERT     0xFFFB0000

#define ALLMEDIATYPES 0xFFFFFFFF

#define GET_SUBEVENT_FLAG( a )          ( 1 << ( a ) )

EXTERN_C const CLSID CLSID_AddressRoot;
EXTERN_C const GUID CLSID_CallRoot;
EXTERN_C const GUID IID_Audio;
EXTERN_C const GUID IID_InteractiveVoice;
EXTERN_C const GUID IID_AutomatedVoice;
EXTERN_C const GUID IID_Video;
EXTERN_C const GUID IID_Data;
EXTERN_C const GUID IID_DataModem;
EXTERN_C const GUID IID_G3Fax;

HRESULT
LineGetAddressCaps(
                   HLINEAPP hLineApp,
                   DWORD dwDeviceID,
                   DWORD dwAddressID,
                   DWORD dwAPIVersion,
                   LPLINEADDRESSCAPS * ppAddressCaps
                  );
HRESULT
LineGetDevCaps(
               HLINEAPP hLineApp,
               DWORD dwDeviceID,
               DWORD dwAPIVersion,
               LPLINEDEVCAPS * ppLineDevCaps
              );

HRESULT
LineGetDevCapsWithAlloc(
                        HLINEAPP hLineApp,
                        DWORD dwDeviceID,
                        DWORD dwAPIVersion,
                        LPLINEDEVCAPS * ppLineDevCaps
                       );

HRESULT
LineGetID(
          HLINE   hLine,
          DWORD   dwID,
          HCALL   hCall,
          DWORD   dwSelect,
          LPVARSTRING * ppDeviceID,
          LPCWSTR lpszDeviceClass
         );

HRESULT
LineGetDevConfig(
                 DWORD           dwDeviceID,
                 LPVARSTRING   * ppDeviceConfig,
                 LPCWSTR         lpszDeviceClass
                ); 

HRESULT
LineGetCallStatus(  
          HCALL hCall,
          LPLINECALLSTATUS  * ppCallStatus  
          );

HRESULT
LineGetProviderList(
                    LPLINEPROVIDERLIST * ppProviderList
                   );


HRESULT
LineNegotiateAPIVersion(
                        HLINEAPP     hLineApp,
                        DWORD        dwDeviceID,
                        LPDWORD      lpdwAPIVersion
                       );
HRESULT
LineOpen(
         HLINEAPP                hLineApp,
         DWORD                   dwDeviceID,
         DWORD                   dwAddressID,
         T3LINE *                pt3Line,
         DWORD                   dwAPIVersion,
         DWORD                   dwPrivileges,
         DWORD                   dwMediaModes,
         AddressLineStruct *     pAddressLine,
         LPLINECALLPARAMS const  lpCallParams,
         CAddress *              pAddress,
         CTAPI *                 pTapiObj,
         BOOL                    bAddToHashTable = TRUE
        );

HRESULT
LineClose(
          T3LINE * pt3Line
         );
HRESULT
LineMakeCall(
    T3LINE * pt3Line,
    HCALL * phCall,
    LPCWSTR lpszDestAddress,
    DWORD   dwCountryCode,
    LPLINECALLPARAMS const lpCallParams
    );

LONG
LineDrop(
    HCALL   hCall,
    LPCSTR  lpsUserUserInfo,
    DWORD   dwSize
    );

HRESULT
LineDeallocateCall(
    HCALL hCall
    );

HRESULT
LineDial(
    HCALL hCall,
    LPCWSTR lpszDestAddress,
    DWORD   dwCountryCode
    );

HRESULT
LineAddToConference(
    HCALL hConfCall,
    HCALL hConsultCall
    );

HRESULT
LinePrepareAddToConference(
    HCALL hConfCall,
    HCALL *phConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

HRESULT
LineSetupConference(
    HCALL    hCall,
    T3LINE * pt3Line,
    HCALL  * phConfCall,
    HCALL  * phConsultCall,
    DWORD   dwNumParties,
    LPLINECALLPARAMS    const lpCallParams
    );

HRESULT
LineRemoveFromConference(
    HCALL hCall
    );

HRESULT
LineGetConfRelatedCalls(
    HCALL           hCall,
    LINECALLLIST ** ppCallList
    );  
HRESULT
LineBlindTransfer(
    HCALL hCall,
    LPCWSTR lpszDestAddress,
    DWORD   dwCountryCode
    );

HRESULT
LineSetupTransfer(
    HCALL    hCall,
    HCALL   *phConsultCall,
    LPLINECALLPARAMS  const lpCallParams
    );

HRESULT
LineCompleteTransfer(
    HCALL hCall,
    HCALL hConsultCall,
    T3CALL * pt3ConfCall,
    DWORD   dwTransferMode
    );

HRESULT
LineConfigDialogW(
    DWORD   dwDeviceID,
    HWND    hwndOwner,
    LPCWSTR lpszDeviceClass
    );

HRESULT
LineConfigDialogEditW(
    DWORD           dwDeviceID,
    HWND            hwndOwner,
    LPCWSTR         lpszDeviceClass,
    LPVOID const    lpDeviceConfigIn,
    DWORD           dwSize,
    LPVARSTRING   * ppDeviceConfigOut
    );

HRESULT
LineHold(
    HCALL hCall
    );

HRESULT
LineUnhold(
    HCALL hCall
    );

HRESULT
LineHandoff(
    HCALL   hCall,
    LPCWSTR lpszFileName,
    DWORD   dwMediaMode
    );

HRESULT
LineSetStatusMessages(
    T3LINE * pt3Line,
    DWORD dwLineStates,
    DWORD dwAddressStates
    );

HRESULT
LineGetTranslateCaps(
    HLINEAPP            hLineApp,
    DWORD               dwAPIVersion,
    LPLINETRANSLATECAPS *ppTranslateCaps
    );

HRESULT 
LineTranslateAddress(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    DWORD                   dwAPIVersion,
    LPCWSTR                 lpszAddressIn,
    DWORD                   dwCard,
    DWORD                   dwTranslateOptions,
    LPLINETRANSLATEOUTPUT   *ppTranslateOutput
    );

HRESULT
LinePark(
    HCALL         hCall,
    DWORD         dwParkMode,
    LPCWSTR       lpszDirAddress,
    LPVARSTRING * ppNonDirAddress
    );

HRESULT
LineUnpark(
    HLINE     hLine,
    DWORD     dwAddressID,
    HCALL     *phCall,
    LPCWSTR   lpszDestAddress
    );

HRESULT
LineSwapHold(
    HCALL hActiveCall,
    HCALL hHeldCall
    );


HRESULT
LineSendUserUserInfo(
    HCALL   hCall,
    LPCSTR  lpsUserUserInfo,
    DWORD   dwSize
    );
HRESULT
LineReleaseUserUserInfo(
    HCALL hCall
    );
HRESULT
LineRegisterRequestRecipient(
    HLINEAPP    hLineApp,
    DWORD       dwRegistrationInstance,
    DWORD       dwRequestMode,
#ifdef NEWREQUEST
    DWORD       dwAddressTypes,
#endif
    DWORD       bEnable
    );
HRESULT
LineSetAppSpecific(
    HCALL   hCall,
    DWORD   dwAppSpecific
    );
HRESULT
LineGetCallIDs(
    HCALL               hCall,
    LPDWORD             lpdwAddressID,
    LPDWORD             lpdwCallID,
    LPDWORD             lpdwRelatedCallID
    );
HRESULT
LineGetCallInfo(
    HCALL hCall,
    LPLINECALLINFO *  ppCallInfo
    );

HRESULT
LineSetCallData(
    HCALL   hCall,
    LPVOID  lpCallData,
    DWORD   dwSize
    );

HRESULT
WINAPI
LineSetCallHubTracking(
                       T3LINE * pt3Line,
                       LINECALLHUBTRACKINGINFO * plchti
                      );

HRESULT
CreateMSPObject(
    DWORD dwDeviceID,
    IUnknown * pUnk,
    IUnknown ** ppMSPAggAddress
    );

HRESULT
LineAnswer(
           HCALL hCall
          );

HRESULT
LineSetCallTreatment(
    HCALL   hCall,
    DWORD   dwTreatment
    );

HRESULT
LineSetMediaMode(
                 HCALL   hCall,
                 DWORD   dwMediaModes
                );

HRESULT
LineMonitorDigits(
    HCALL    hCall,
    DWORD    dwDigitModes
    );

HRESULT
LineMonitorTones(
    HCALL   hCall,
    LPLINEMONITORTONE   const lpToneList,
    DWORD   dwNumEntries
    );

HRESULT
LineGatherDigits(
    HCALL   hCall,
    DWORD   dwDigitModes,
    LPWSTR  lpsDigits,
    DWORD   dwNumDigits,
    LPCWSTR lpszTerminationDigits,
    DWORD   dwFirstDigitTimeout,
    DWORD   dwInterDigitTimeout
    );

HRESULT
LineGenerateDigits(
    HCALL   hCall,
    DWORD   dwDigitMode,
    LPCWSTR lpszDigits,
    DWORD   dwDuration
    );

HRESULT
LineGenerateTone(
    HCALL   hCall,
    DWORD   dwToneMode,
    DWORD   dwDuration,
    DWORD   dwNumTones,
    LPLINEGENERATETONE const lpTones
    );

HRESULT
LineReceiveMSPData(
                   HLINE hLine,
                   HCALL hCall,
                   PBYTE pBuffer,
                   DWORD dwSize
                  );

HRESULT
LineGetCallHubTracking(
                       DWORD dwDeviceID,
                       LINECALLHUBTRACKINGINFO ** ppTrackingInfo
                      );

HRESULT
LineGetHubRelatedCalls(
                       HCALLHUB        hCallHub,
                       HCALL           hCall,
                       LINECALLLIST ** ppCallHubList
                      );

HRESULT
LineGetCallHub(
               HCALL hCall,
               HCALLHUB * pCallHub
              );

HRESULT
LinePickup(
           HLINE    hLine,
           DWORD    dwAddressID,
           HCALL    *phCall,
           LPCWSTR  lpszDestAddress,
           LPCWSTR  lpszGroupID
          );

HRESULT
LineGetLineDevStatus(
                     HLINE hLine,
                     LPLINEDEVSTATUS * ppDevStatus
                    );

HRESULT
LineGetProxyStatus(
                   HLINEAPP                 hLineApp,
                   DWORD                    dwDeviceID,
                   DWORD                    dwAppAPIVersion,
                   LPLINEPROXYREQUESTLIST * ppLineProxyReqestList
                  );


HRESULT
LineSetLineDevStatus(
    T3LINE *pLine,
    DWORD   dwStatusToChange,
    DWORD   fStatus
    );

HRESULT
LineGetAddressStatus(
    T3LINE * pt3Line,
    DWORD   dwAddressID,
    LPLINEADDRESSSTATUS * ppAddressStatus
    );
HRESULT
LineForward(
    T3LINE * pt3Line,
    DWORD   dwAddressID,
    LPLINEFORWARDLIST   const lpForwardList,
    DWORD   dwNumRingsNoAnswer,
    LPHCALL lphConsultCall
    );

HRESULT
LineSetCallQualityOfService(
    HCALL             hCall,
    QOS_SERVICE_LEVEL ServiceLevel,
    DWORD             dwMediaType
    );

HRESULT 
LineAccept(
    HCALL   hCall,
    LPCSTR  lpsUserUserInfo,
    DWORD   dwSize
    );

HRESULT
PhoneNegotiateAPIVersion(
                        HPHONEAPP    hPhoneApp,
                        DWORD        dwDeviceID,
                        LPDWORD      lpdwAPIVersion
                       );

HRESULT
PhoneOpen(
          HPHONEAPP   hPhoneApp,
          DWORD       dwDeviceID,
          T3PHONE *   pt3Phone,
          DWORD       dwAPIVersion,
          DWORD       dwPrivilege
         );


HRESULT
PhoneClose(
    HPHONE  hPhone,
    BOOL bCleanHashTableOnFailure = TRUE
    );

HRESULT
PhoneGetStatusWithAlloc(
                HPHONE hPhone,
                LPPHONESTATUS *ppPhoneStatus
              );

HRESULT
PhoneGetDevCapsWithAlloc(
                HPHONEAPP   hPhoneApp,
                DWORD       dwDeviceID,
                DWORD       dwAPIVersion,
                LPPHONECAPS * ppPhoneCaps
               );

HRESULT
PhoneGetDevCaps(
                HPHONEAPP   hPhoneApp,
                DWORD       dwDeviceID,
                DWORD       dwAPIVersion,
                LPPHONECAPS * ppPhoneCaps
               );

HRESULT
PhoneGetDisplay(
          HPHONE      hPhone,
          LPVARSTRING * ppDisplay
          );

HRESULT
PhoneSetStatusMessages(
    T3PHONE * pt3Phone,
    DWORD dwPhoneStates,
    DWORD dwButtonModes,
    DWORD dwButtonStates
    );

HRESULT
PhoneGetButtonInfo(
    HPHONE  hPhone,
    DWORD   dwButtonLampID,
    LPPHONEBUTTONINFO * ppButtonInfo
    );

HRESULT
PhoneSetButtonInfo(
    HPHONE  hPhone,
    DWORD   dwButtonLampID,
    LPPHONEBUTTONINFO const pButtonInfo
    );

HRESULT
PhoneGetLamp(
    HPHONE hPhone,
    DWORD dwButtonLampID,
    LPDWORD lpdwLampMode
    );

HRESULT
PhoneSetLamp(
    HPHONE hPhone,
    DWORD  dwButtonLampID,
    DWORD  dwLampMode
    );


HRESULT
PhoneGetHookSwitch(
    HPHONE hPhone,
    LPDWORD lpdwHookSwitchDevs
    );

HRESULT
PhoneGetRing(
    HPHONE hPhone,
    LPDWORD lpdwRingMode,
    LPDWORD lpdwVolume
    );

HRESULT
PhoneSetRing(
    HPHONE hPhone,
    DWORD  dwRingMode,
    DWORD  dwVolume
    );

HRESULT
PhoneGetID(
          HLINE   hPhone,
          LPVARSTRING * ppDeviceID,
          LPCWSTR lpszDeviceClass
         );

HRESULT
PhoneSetDisplay(
    HPHONE  hPhone,
    DWORD   dwRow,
    DWORD   dwColumn,
    LPCSTR  lpsDisplay,
    DWORD   dwSize
    );

HRESULT
PhoneGetGain(
    HPHONE hPhone,
    DWORD dwHookSwitchDev,
    LPDWORD lpdwGain
    );

HRESULT
PhoneSetGain(
    HPHONE hPhone,
    DWORD dwHookSwitchDev,
    DWORD dwGain
    );

HRESULT
PhoneGetVolume(
    HPHONE hPhone,
    DWORD dwHookSwitchDev,
    LPDWORD lpdwVolume
    );

HRESULT
PhoneSetVolume(
    HPHONE hPhone,
    DWORD dwHookSwitchDev,
    DWORD dwVolume
    );

HRESULT
PhoneSetHookSwitch(
    HPHONE hPhone,
    DWORD  dwHookSwitchDevs,
    DWORD  dwHookSwitchMode
    );

HRESULT
ProviderPrivateFactoryIdentify(
                               DWORD dwDeviceID,
                               GUID * pguid
                              );

HRESULT
ProviderPrivateChannelData(
                           DWORD dwDeviceID,
                           DWORD dwAddressID,
                           HCALL hCall,
                           HCALLHUB hCallHub,
                           DWORD dwType,
                           BYTE * pBuffer,
                           DWORD dwSize
                          );
BOOL
GetMediaMode(
             BSTR bstr,
             BOOL bActiveMovie,
             DWORD * pdwMediaMode
            );

BOOL
GetMediaTypes(
              DWORD dwMediaMode,
              MediaTypePtrList * plist
             );

HRESULT
VerifyAndGetArrayBounds(
                        VARIANT Array,
                        SAFEARRAY ** ppsa,
                        long * pllBound,
                        long * pluBound
                       );

HRESULT
ConvertMediaTypesToMediaModes(
                              VARIANT pMediaTypes,
                              DWORD * pdwMediaModes
                             );

BOOL
IsAudioInTerminal( ITTerminal * pTerminal);

BOOL
FindCallObject(
               HCALL hCall,
               CCall ** ppCall
              );

BOOL
FindAddressObject(
                  HLINE hLine,
                  CAddress ** ppAddress
                 );

BOOL
FindAgentHandlerObject(
                  HLINE hLine,
                  CAgentHandler ** ppAgentHandler
                 );

BOOL
FindPhoneObject(
                  HPHONE hPhone,
                  CPhone ** ppPhone
                 );

BOOL
FindCallHubObject(
                  HCALLHUB hCallHub,
                  CCallHub ** ppCallHub
                 );

HRESULT
LineGetAgentCaps(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAppAPIVersion,
    LPLINEAGENTCAPS     *ppAgentCaps
    );

HRESULT
LineCreateAgent(     
    HLINE               hLine,
    PWSTR               pszAgentID,        
    PWSTR               pszAgentPIN,       
    LPHAGENT            lphAgent        // Return value
    );

LONG
WINAPI
lineSetAgentMeasurementPeriod(     
    HLINE               hLine,
    HAGENT              hAgent,
    DWORD               dwMeasurementPeriod
    );

LONG
WINAPI
lineGetAgentInfo(     
    HLINE               hLine,
    HAGENT              hAgent,
    LPLINEAGENTINFO     lpAgentInfo         // Returned structure
    );

HRESULT
LineCreateAgentSession(     
    HLINE               hLine,
    HAGENT              hAgent,
    PWSTR               pszAgentPIN,       
    DWORD               dwWorkingAddressID,
    LPGUID              lpGroupID,
    LPHAGENTSESSION     lphAgentSession         // Return value 
    );

LONG
WINAPI
lineGetAgentSessionInfo(     
    HLINE                   hLine,
    HAGENTSESSION           hAgentSession,
    LPLINEAGENTSESSIONINFO  lpAgentSessionInfo      // Returned structure
    );

LONG
WINAPI
lineSetAgentSessionState(   
    HLINE               hLine,
    HAGENTSESSION       hAgentSession,
    DWORD               dwAgentState,
    DWORD               dwNextAgentState     
    );

LONG
WINAPI
lineSetQueueMeasurementPeriod(     
    HLINE               hLine,
    DWORD               dwQueueID, 
    DWORD               dwMeasurementPeriod
    );

LONG
WINAPI
lineGetQueueInfo(     
    HLINE               hLine,
    DWORD               dwQueueID, 
    LPLINEQUEUEINFO     lpQueueInfo         // Returned structure
    );

HRESULT
LineGetGroupList(     
    HLINE                   hLine,
    LPLINEAGENTGROUPLIST  * pGroupList     // Returned structure
    );

HRESULT
lineGetQueueList(     
    HLINE                   hLine,
    LPGUID                  lpGroupID,
    LPLINEQUEUELIST       * ppQueueList     // Returned structure
    );

LONG
WINAPI
lineGetAgentSessionList(
    HLINE                   hLine,
    HAGENT                  hAgent,
    LPLINEAGENTSESSIONLIST  lpSessionList     // Returned structure
    );

HRESULT TapiMakeCall(
                     BSTR pDestAddress,
                     BSTR pAppName,
                     BSTR pCalledParty,
                     BSTR pComment
                    );

HRESULT
LineTranslateDialog(
                    DWORD dwDeviceID,
                    DWORD dwAPIVersion,
                    HWND hwndOwner,
                    BSTR pAddressIn
                   );

HRESULT
LineGetRequest(
    HLINEAPP    hLineApp,
    DWORD       dwRequestMode,
    LPLINEREQMAKECALLW * ppReqMakeCall
    );

HRESULT
LineSetAppPriority(
    LPCWSTR lpszAppName,
    DWORD   dwMediaMode,
    DWORD   dwRequestMode,
    DWORD   dwPriority
    );

HRESULT
LineCreateMSPInstance(
    HLINE hLine,
    DWORD dwAddressID
    );

HRESULT
LineCloseMSPInstance(
    HLINE hLine
    );

HRESULT
LineSetCallParams(
    HCALL   hCall,
    DWORD   dwBearerMode,
    DWORD   dwMinRate,
    DWORD   dwMaxRate,
    LPLINEDIALPARAMS const lpDialParams
    );


HRESULT
WaitForReply(DWORD);

HRESULT
WaitForPhoneReply(DWORD dwID);

void
QueueCallbackEvent(PASYNCEVENTMSG pParams);

PWSTR
MyLoadString( UINT uID );

HRESULT
CreateWaveInfo(
               HLINE hLine,
               DWORD dwAddressID,
               HCALL hCall,
               DWORD dwCallSelect,
               BOOL bFullDuplex,
               LPDWORD pdwIDs
              );


//
// a helper function implemented in call.cpp that puts the passeed buffer into 
// a variant array
//

HRESULT FillVariantFromBuffer(
                      IN DWORD dwBufferSize,
                      IN BYTE * pBuffer,
                      OUT VARIANT * pVar
                      );


#define MAX_DWORD 0xffffffff


#if DBG

    DWORD DWORD_CAST(ULONG_PTR v);

#else

    #define DWORD_CAST(x) ((DWORD)(x))

#endif
    

//
// handle table manipulation routines
//

DWORD CreateHandleTableEntry(ULONG_PTR nEntry);
void DeleteHandleTableEntry(DWORD dwHandle);
ULONG_PTR GetHandleTableEntry(DWORD dwHandle);


#define DECLARE_QI() \
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppvObject) = 0; \
	virtual ULONG STDMETHODCALLTYPE AddRef() = 0; \
	virtual ULONG STDMETHODCALLTYPE Release() = 0; \


#endif


//
// IsBadWritePtr is not thread safe. so use IsBadReadPtr instread
//

#define TAPIIsBadWritePtr(x, y)  IsBadWritePtr((x), (y))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\connect.cpp ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    Connect.cpp
    
Abstract:

    Handles all outgoing interfaces

Author:

    mquinton - 5/7/97

Notes:

    optional-notes

Revision History:

--*/

#include "stdafx.h"
#include "uuids.h"

extern IGlobalInterfaceTable * gpGIT;
extern CRITICAL_SECTION        gcsGlobalInterfaceTable;


extern ULONG_PTR GenerateHandleAndAddToHashTable( ULONG_PTR Element);
extern void RemoveHandleFromHashTable(ULONG_PTR dwHandle);
extern CHashTable * gpHandleHashTable;


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CTAPIConnectionPoint - implementation of IConnectionPoint
// for TAPI object (ITTAPIEventNotification outgoing interface).
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


HRESULT
CTAPIConnectionPoint::Initialize(
                                 IConnectionPointContainer * pCPC,
                                 IID iid
                                )
{
    LOG((TL_TRACE, "Initialize enter"));

    #if DBG
    {
        WCHAR guidName[100];

        StringFromGUID2(iid, (LPOLESTR)&guidName, 100);
        LOG((TL_INFO, "Initialize - IID : %S", guidName));
    }
    #endif

    //
    // Create the unadvise event
    //

    m_hUnadviseEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    
    if (m_hUnadviseEvent == NULL)
    {
        LOG((TL_TRACE, "Initialize - out of memory"));

        return E_OUTOFMEMORY;
    }

    //
    // Addref the connection point container
    //

    pCPC->AddRef();

    //
    // Addref ourselves
    //

    this->AddRef(); 

    //
    // Save stuff
    //

    m_pCPC = pCPC;
    
    m_iid = iid;
    
    m_pConnectData = NULL;
        
    EnterCriticalSection( &gcsGlobalInterfaceTable );

    m_cThreadsInGet = 0;
    m_fMarkedForDelete = FALSE;

    LeaveCriticalSection( &gcsGlobalInterfaceTable );

    m_bInitialized = TRUE;

    LOG((TL_TRACE, "Initialize exit"));
    return S_OK;
}


// IConnectionPoint methods
HRESULT
STDMETHODCALLTYPE
CTAPIConnectionPoint::GetConnectionInterface(
                                             IID * pIID
                                            )
{
    if ( TAPIIsBadWritePtr( pIID, sizeof (IID) ) )
    {
        LOG((TL_ERROR, "GetConnectionInterface - bad pointer"));

        return E_POINTER;
    }

    Lock();
    
    *pIID = m_iid;

    Unlock();
    
    return S_OK;
}

HRESULT
STDMETHODCALLTYPE
CTAPIConnectionPoint::GetConnectionPointContainer(
    IConnectionPointContainer ** ppCPC
    )
{
    if ( TAPIIsBadWritePtr( ppCPC, sizeof( IConnectionPointContainer *) ) )
    {
        LOG((TL_ERROR, "GetCPC - bad pointer"));

        return E_POINTER;
    }

    Lock();

    *ppCPC = m_pCPC;
    (*ppCPC)->AddRef();

    Unlock();

    return S_OK;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Advise
//
//      the application calls this function when it wants to register an
//      outgoing interface
//
//      this interface is used to register the ITTAPIEventNotification
//      interface which is used to get all TAPI call control events
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT
STDMETHODCALLTYPE
CTAPIConnectionPoint::Advise(
                             IUnknown * pUnk,
                             DWORD * pdwCookie
                            )
{
    HRESULT                   hr = S_OK;
    CONNECTDATA             * pCD;
    IID                       iid;

    LOG((TL_TRACE, "Advise[%p] called", this));

    if ( TAPIIsBadWritePtr( pdwCookie, sizeof (DWORD) ) )
    {
        LOG((TL_ERROR, "Advise - bad pointer"));

        return E_POINTER;
    }

    if ( IsBadReadPtr( pUnk, sizeof(IUnknown *) ) )
    {
        LOG((TL_ERROR, "Advise - bad IUnknown"));

        return E_POINTER;
    }
    
    Lock();

    if ( m_bInitialized == FALSE )
    {
        LOG((TL_ERROR, "Advise - not initialized"));

        Unlock();

        return TAPI_E_NOT_INITIALIZED;
    }

    //
    // We only allow one callback per connection point
    //

    if ( NULL != m_pConnectData )
    {
        LOG((TL_ERROR, "Advise - advise already called"));

        Unlock();
        
        return CONNECT_E_ADVISELIMIT;
    }

    //
    // Create a new connectdata struct
    //

    m_pConnectData = (CONNECTDATA *) ClientAlloc( sizeof CONNECTDATA );
    
    if (NULL == m_pConnectData)
    {
        LOG((TL_ERROR, "Advise failed - pCD == NULL"));

        Unlock();
        
        return E_OUTOFMEMORY;
    }
    
    //
    // Keep a reference to the callback
    //

    try
    {
        pUnk->AddRef();
    }
    catch(...)
    {
        LOG((TL_ERROR, "Advise - IUnknown bad"));

        ClientFree( m_pConnectData );

        m_pConnectData = NULL;

        Unlock();
        
        return E_POINTER;
    }

    //
    // Save the interface
    //

    m_pConnectData->pUnk = pUnk;
    
    ITTAPIEventNotification *pEventNotification;
    hr = pUnk->QueryInterface(IID_ITTAPIEventNotification,
                              (void**)(&pEventNotification)
                             );
    if (SUCCEEDED(hr) )
    {
        iid  = IID_ITTAPIEventNotification; 
        pEventNotification->Release();
    }
    else
    {
        iid  = DIID_ITTAPIDispatchEventNotification;    
    }

    m_iid = iid;
    
    m_pConnectData->dwCookie = CreateHandleTableEntry((ULONG_PTR)m_pConnectData);
 
    //
    // Return the cookie
    //

    *pdwCookie = m_pConnectData->dwCookie;

    //set it to FALSE if not already set.
    m_fMarkedForDelete = FALSE;

    Unlock();

    LOG((TL_TRACE, "Advise generated cookie [%lx]", *pdwCookie));


    //
    // Put the callback in the globalinterfacetable
    // so it can be accessed across threads
    //

    EnterCriticalSection( &gcsGlobalInterfaceTable );  

    if ( NULL != gpGIT )
    {
        hr = gpGIT->RegisterInterfaceInGlobal(
                                              pUnk,
                                              iid,
                                              &m_dwCallbackCookie
                                             );
    }
    else
    {
        hr = E_FAIL;
    }
    
    LeaveCriticalSection( &gcsGlobalInterfaceTable );
    
    if ( FAILED(hr) )
    {
        Lock();

        LOG((TL_ERROR, "Advise - RegisterInterfaceInGlobal failed - %lx", hr));

        DeleteHandleTableEntry(m_pConnectData->dwCookie);
        
        *pdwCookie = 0;

        ClientFree( m_pConnectData );

        m_pConnectData = NULL;

        m_fMarkedForDelete = TRUE;

        pUnk->Release();

        Unlock();
    }

    LOG((TL_TRACE, "Advise - exit"));
    
    return hr;           
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Unadvise
//
// Used to unregister an interface
//
// dwCookie - Cookie used to identify the interface registration, returned in
//            advise
//
// returns
//      S_OK
//      CONNECT_E_NOCONNECTION
//          dwCookie is not a valid connection
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT
STDMETHODCALLTYPE
CTAPIConnectionPoint::Unadvise(
                               DWORD dwCookie
                              )
{
    HRESULT     hr =  S_OK;
    
    LOG((TL_TRACE, "Unadvise[%p] - enter. Cookie: [%lx]", this, dwCookie));
    
    Lock();

    //
    // Check connection point
    //

    if ( NULL != m_pConnectData )
    {
        //
        // Check cookie
        //

        if (m_pConnectData->dwCookie == dwCookie)
        {
            LOG((TL_INFO, "Unadvise - immediate "));
            
            //
            // Remove entry for this cookie from the handle table 
            //

            DeleteHandleTableEntry(m_pConnectData->dwCookie);
            
            //
            // Free the connect data
            //

            m_pConnectData->dwCookie = 0;

            m_pConnectData->pUnk->Release();

            ClientFree( m_pConnectData );

            m_pConnectData = NULL;
           
            Unlock();

            EnterCriticalSection( &gcsGlobalInterfaceTable ); 

            //
            // Mark for delete
            //

            m_fMarkedForDelete = TRUE;

            if ( NULL != gpGIT )
            {
                //
                // If there are threads in get we must wait for them to complete so
                // we can call revoke
                //

                while ( m_cThreadsInGet != 0 )
                {
                    LOG((TL_INFO, "Unadvise - %ld threads in get", m_cThreadsInGet));

                    LeaveCriticalSection( &gcsGlobalInterfaceTable );                 

                    DWORD dwSignalled;
                  
                    CoWaitForMultipleHandles (
                              0,
                              INFINITE,
                              1,
                              &m_hUnadviseEvent,
                              &dwSignalled
                             );

                    EnterCriticalSection( &gcsGlobalInterfaceTable ); 
                }
                    
                //
                // We have guaranteed that no threads are in get. Do the revoke.
                //
                
                hr = gpGIT->RevokeInterfaceFromGlobal( m_dwCallbackCookie );

                if ( FAILED(hr) )
                {
                    LOG((TL_ERROR, "Unadvise - RevokeInterfaceFromGlobal failed - hr = %lx", hr));
                }

                m_dwCallbackCookie = 0;
            }
            else
            {
                LOG((TL_ERROR, "Unadvise - no global interface table"));
            }

            LeaveCriticalSection( &gcsGlobalInterfaceTable );
        }
        else
        {
            Unlock();
            LOG((TL_ERROR, "Unadvise - cp does not match "));
            hr = CONNECT_E_NOCONNECTION;
        }
    }
    else
    {
        Unlock();
        LOG((TL_ERROR, "Unadvise - cp not registered "));
        hr = CONNECT_E_NOCONNECTION;
    }
        
    LOG((TL_TRACE, hr, "Unadvise - exit"));
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// EnumConnections
//
// Used to enumerate connections already made on this connection point
//
// ppEnum
//      return enumerator in here
//
// returns
//      S_OK
//      E_POINTER
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT
STDMETHODCALLTYPE
CTAPIConnectionPoint::EnumConnections(
                                      IEnumConnections ** ppEnum
                                     )
{
    HRESULT         hr = S_OK;

    if ( TAPIIsBadWritePtr( ppEnum, sizeof( IEnumConnections *) ) )
    {
        LOG((TL_ERROR, "EnumConnections - bad pointer"));
        return E_POINTER;
    }
    
    //
    // Create enumerate object
    //
    CComObject< CTapiTypeEnum <IEnumConnections,
                                CONNECTDATA,
                                _Copy<CONNECTDATA>,
                                &IID_IEnumConnections> > * p;

    hr = CComObject< CTapiTypeEnum <IEnumConnections,
                                    CONNECTDATA,
                                    _Copy<CONNECTDATA>,
                                    &IID_IEnumConnections> >::CreateInstance( &p );

    if (S_OK != hr)
    {
        return hr;
    }

    //
    // Initialize it
    //

    ConnectDataArray     newarray;

    Lock();
    
    if ( NULL != m_pConnectData )
    {
        newarray.Add(*m_pConnectData);
    }

    Unlock();
    
    hr = p->Initialize( newarray );   

    newarray.Shutdown();

    if (S_OK != hr)
    {
        return hr;
    }

    *ppEnum = p;
    
    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// FinalRelease
//      release all CONNECTDATA structs
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void
CTAPIConnectionPoint::FinalRelease()
{
    LOG((TL_TRACE, "FinalRelease - enter"));

    if (NULL != m_pConnectData)
    {
        //
        // The app didn't call unadvise. Let's do it now.
        //

        LOG((TL_INFO, "FinalRelease - calling unadvise"));

        Unadvise(m_pConnectData->dwCookie) ;        
    }

    //
    // Release the connection point container
    //

    if (m_pCPC)
    {
        m_pCPC->Release();
        m_pCPC = NULL;
    }

    //
    // Close the unadvise event
    //

    if (m_hUnadviseEvent)
    {
        CloseHandle(m_hUnadviseEvent);
        m_hUnadviseEvent = NULL;
    }

    LOG((TL_TRACE, "FinalRelease - exit"));
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// the object calls this to get a marshaled event
// pointer in the correct thread
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
ULONG_PTR
CTAPIConnectionPoint::GrabEventCallback()
{
    IUnknown      * pReturn = NULL;
    HRESULT         hr = E_FAIL;
    DWORD           dwCallbackCookie;
    IID             iid;

    Lock();   
    
    //
    // If we're already released, don't try to send any events.
    //

    if ( NULL != m_pConnectData )
    {
        //
        // Copy member data
        //

        iid = m_iid;

        Unlock();
             
        EnterCriticalSection( &gcsGlobalInterfaceTable );                

        if (m_fMarkedForDelete == FALSE)
        {            
            //
            // Add to the count of threads in get.
            //

            m_cThreadsInGet++;

            //
            // Copy member data
            //

            dwCallbackCookie = m_dwCallbackCookie;

            if (gpGIT != NULL)
            {
                gpGIT->AddRef();

                //
                // Don't hold a critical section while getting
                //

                LeaveCriticalSection( &gcsGlobalInterfaceTable );
                
                hr = gpGIT->GetInterfaceFromGlobal(
                                                   dwCallbackCookie,
                                                   iid,
                                                   (void **)&pReturn
                                                  );
                if ( SUCCEEDED(hr) )
                {
                    LOG((TL_INFO, "GrabEventCallback - GetInterfaceFromGlobal suceeded [%p]", pReturn));
                }
                else
                {
                    LOG((TL_ERROR, "GrabEventCallback - GetInterfaceFromGlobal failed - hr = %lx", hr));
                    pReturn =  NULL;
                }

                EnterCriticalSection( &gcsGlobalInterfaceTable );
                gpGIT->Release();
            }

            //
            // Done. Decrement the count of threads in get.
            //

            m_cThreadsInGet--;
        }
        else
        {
            LOG((TL_INFO, "GrabEventCallback - already marked for delete"));
        }

        LeaveCriticalSection( &gcsGlobalInterfaceTable );

        if ( m_fMarkedForDelete == TRUE )
        {
            //
            // Someone called unadvise while we were using the cookie.
            // Signal so they can do the revoke now.
            //

            if ( m_hUnadviseEvent )
            {
                SetEvent(m_hUnadviseEvent);
            }
            else
            {
                LOG((TL_ERROR, "GrabEventCallback - no event"));

                _ASSERTE(FALSE);
            }

            //
            // If we got a callback, no need to return it because
            // unadvise has been called.
            //

            if ( pReturn != NULL )
            {
                pReturn->Release();
                pReturn = NULL;
            }
        } 
        
    }
    else
    {
        LOG((TL_ERROR, "GrabEventCallback - already released"));

        Unlock();
    }
    
    LOG((TL_TRACE, hr, "GrabEventCallback - exit"));

    return (ULONG_PTR)pReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\client.cpp ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects
Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    client.c

Abstract:

    This module contains the tapi.dll implementation (client-side tapi)

Author:

    Dan Knudson (DanKn)    01-Apr-1995

Revision History:


Notes:

    1. Make all funcArg structs STATIC, & just do whatever mov's necessary
       for the params (saves mov's for flags, pfnPostProcess, funcName, &
       argTypes)

--*/


#include "stdafx.h"

#include "windows.h"
#include "wownt32.h"
#include "stdarg.h"
#include "stdio.h"

#include "private.h"
#include "tapsrv.h"
#include "loc_comn.h"
#include "prsht.h"
#include "shellapi.h"
#include "tapiperf.h"
#include "tlnklist.h"
#include "tapievt.h"
#include <mmsystem.h>
#include <mmddk.h>

extern "C" {
#include "tapihndl.h"
}

#ifdef _WIN64
#define TALIGN_MASK                 0xfffffff8
#define TALIGN_COUNT                7
#else
#define TALIGN_MASK                 0xfffffffc
#define TALIGN_COUNT                3
#endif
#define ALIGN(a)                    (((a)+TALIGN_COUNT)&TALIGN_MASK)


#define TAPILoadLibraryW        LoadLibraryW

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_TAPI, CTAPI)
    OBJECT_ENTRY(CLSID_DispatchMapper, CDispatchMapper)
    OBJECT_ENTRY(CLSID_RequestMakeCall, CRequest)
END_OBJECT_MAP()

typedef LONG (PASCAL *PQCSPROC)(HANDLE, DWORD, DWORD, LPOVERLAPPED);
typedef LONG (PASCAL *TUIGDDPROC)(HTAPIDIALOGINSTANCE, LPVOID, DWORD);
typedef LONG (PASCAL *TUIGDPROC)(TUISPIDLLCALLBACK, HTAPIDIALOGINSTANCE, LPVOID, DWORD, HANDLE);
typedef LONG (PASCAL *TUIPROVPROC)(TUISPIDLLCALLBACK, HWND, DWORD);
static PQCSPROC  gpPostQueuedCompletionStatus = NULL;
typedef LONG (PASCAL *TUILINECONFIGPROC)(TUISPIDLLCALLBACK, DWORD, HWND, LPCSTR);
typedef LONG (PASCAL *TUILINECONFIGEDITPROC)(TUISPIDLLCALLBACK, DWORD, HWND, LPCSTR, LPVOID, DWORD, LPVARSTRING);
typedef LONG (PASCAL *TUIPHONECONFIGPROC)(TUISPIDLLCALLBACK, DWORD, HWND, LPCSTR);
typedef BOOL (PASCAL *ShellExecutePROC)(LPSHELLEXECUTEINFOW);


HRESULT mapTAPIErrorCode(long lErrorCode);
char *eventName(TAPI_EVENT event);

//
// messge handlers
//
void HandleLineDevStateMessage( CTAPI * pTapi, PASYNCEVENTMSG pParams );
void HandleAddressStateMessage( PASYNCEVENTMSG pParams );
void HandlePrivateChannelDataMessage( PASYNCEVENTMSG pParams );
void HandleAgentStatusMessage(PASYNCEVENTMSG pParams);
void HandleAgentSessionStatusMessage(PASYNCEVENTMSG pParams);
void HandleQueueStatusMessage(PASYNCEVENTMSG pParams);
void handleGroupStatusMessage(PASYNCEVENTMSG pParams);
void handleProxyStatusMessage( CTAPI * pTapi, PASYNCEVENTMSG pParams);
void HandleLineDevSpecificMessage(  PASYNCEVENTMSG pParams );
void HandlePhoneDevSpecificMessage(  PASYNCEVENTMSG pParams );
void HandleDevSpecificFeatureMessage(  PASYNCEVENTMSG pParams );
void HandleMonitorMediaMessage(  PASYNCEVENTMSG pParams );
void HandlePrivateUnadviseMessage( PASYNCEVENTMSG pParams );
void HandlePrivateCallhubMessage( PASYNCEVENTMSG pParams );
HRESULT HandleCallStateMessage( PASYNCEVENTMSG pParams );
HRESULT HandleCallInfoMessage( PASYNCEVENTMSG pParams );
HRESULT HandleMonitorDigitsMessage( PASYNCEVENTMSG pParams );
HRESULT HandleMonitorToneMessage(  PASYNCEVENTMSG pParams );
HRESULT HandleGatherDigitsMessage( PASYNCEVENTMSG pParams );
HRESULT HandleSendMSPDataMessage( PASYNCEVENTMSG pParams );
HRESULT HandleLineQOSInfoMessage( PASYNCEVENTMSG pParams );
void HandleLineCreate( PASYNCEVENTMSG pParams );
void HandleLineRemove( PASYNCEVENTMSG pParams );
void HandleLineRequest( CTAPI * pTapi, PASYNCEVENTMSG pParams );
void HandleCallHubClose( PASYNCEVENTMSG pParams );
void HandlePrivateMSPEvent( PASYNCEVENTMSG pParams );
void HandleAcceptToAlert( PASYNCEVENTMSG pParams );
HRESULT HandleLineGenerateMessage( PASYNCEVENTMSG pParams );
HRESULT HandleLineCloseMessage( PASYNCEVENTMSG pParams );
void HandlePhoneCreate( PASYNCEVENTMSG pParams );
void HandlePhoneRemove( PASYNCEVENTMSG pParams );
HRESULT HandlePhoneButtonMessage( PASYNCEVENTMSG pParams );
HRESULT HandlePhoneStateMessage( PASYNCEVENTMSG pParams );
HRESULT HandlePhoneCloseMessage( PASYNCEVENTMSG pParams );
LONG WINAPI AllocClientResources( DWORD dwErrorClass );

CAsyncReplyList *    gpLineAsyncReplyList;
CAsyncReplyList *    gpPhoneAsyncReplyList;



// The global retry queue
CRetryQueue     *gpRetryQueue;



//
//
//


#define ASNYC_MSG_BUF_SIZE 1024

typedef struct _ASYNC_EVENTS_THREAD_PARAMS
{
    BOOL    bExitThread;

    DWORD   dwBufSize;

    HANDLE  hTapi32;

    HANDLE  hWow32;

    HANDLE  hThreadStartupEvent;

    LPBYTE  pBuf;

} ASYNC_EVENTS_THREAD_PARAMS, *PASYNC_EVENTS_THREAD_PARAMS;

//
// N.B. This structure MUST be a multiple of 8 bytes in size.
//

#if DBG

typedef struct _MYMEMINFO
{
    struct _MYMEMINFO * pNext;
    struct _MYMEMINFO * pPrev;
    DWORD               dwSize;
    DWORD               dwLine;
    PSTR                pszFile;
    DWORD               dwAlign;

//    LPTSTR              pName;
} MYMEMINFO, *PMYMEMINFO;

PMYMEMINFO            gpMemFirst = NULL, gpMemLast = NULL;
CRITICAL_SECTION      csMemoryList;
BOOL                  gbBreakOnLeak = FALSE;

void
DumpMemoryList();
#endif

//
// Global vars
//

BOOL    gbExitThread         = FALSE;
HANDLE  ghCallbackThread     = NULL;
HANDLE  ghAsyncEventsThread  = NULL;
DWORD   gdwTlsIndex;
DWORD   gdwNumLineDevices    = 0;
DWORD   gdwNumPhoneDevices   = 0;
HANDLE  ghAsyncEventsEvent   = NULL;
HANDLE  ghAsyncRetryQueueEvent = NULL;
HANDLE  ghCallbackThreadEvent= NULL;
HANDLE  ghTapiInitShutdownSerializeMutex;


//
// handle table handle
//

extern HANDLE ghHandleTable;


#if DBG
DWORD gdwDebugLevel = 0;
#endif

typedef LONG (PASCAL *TAPIREQUESTMAKECALLPROC)(LPWSTR, LPWSTR, LPWSTR, LPWSTR);
typedef LONG (PASCAL *LINETRANSLATEDIALOGPROC)(HLINEAPP, DWORD, DWORD, HWND, LPWSTR);
typedef LONG (PASCAL *LINEINITIALIZEPROC)(LPHLINEAPP, HINSTANCE, LINECALLBACK, LPWSTR, LPDWORD, LPDWORD,LPLINEINITIALIZEEXPARAMS);
typedef LONG (PASCAL *LINESHUTDOWNPROC)(HLINEAPP);


HINSTANCE ghTapi32           = NULL;
HLINEAPP ghLineApp           = NULL;
LINEINITIALIZEPROC gpInitialize = NULL;
LINESHUTDOWNPROC   gpShutdown = NULL;


CHashTable *    gpCallHashTable = NULL;
CHashTable *    gpLineHashTable = NULL;
CHashTable *    gpCallHubHashTable = NULL;
CHashTable *    gpPrivateObjectHashTable = NULL;
CHashTable *    gpAgentHandlerHashTable = NULL;
CHashTable *    gpPhoneHashTable = NULL;
CHashTable *    gpHandleHashTable = NULL;
PtrList         gCallbackEventPtrList;

HINSTANCE  ghInst;

PASYNC_EVENTS_THREAD_PARAMS gpAsyncEventsThreadParams = NULL;

const CHAR   gszTapi32MaxNumRequestRetries[] = "Tapi32MaxNumRequestRetries";
const CHAR   gszTapi32RequestRetryTimeout[] =  "Tapi32RequestRetryTimeout";
const CHAR   gszTapi2AsynchronousCallTimeout[] =  "AsynchronousCallTimeout";
const CHAR   gszTapi3RetryProcessingSleep[] = "Tapi3RetryProcessingSleep";
const CHAR   gszTapi3SyncWaitTimeOut[] = "Tapi3SyncWaitTimeOut"; // "Tapi3BlockingCallSleep";



DWORD   gdwMaxNumRequestRetries;
DWORD   gdwRequestRetryTimeout;
DWORD   gdwTapi2AsynchronousCallTimeout;

static const DWORD DEFAULT_TAPI2_ASYNCRONOUS_CALL_TIMEOUT = 120000;
static const DWORD DEFAULT_TAPI3_RETRY_PROCESSING_SLEEP = 0;
static const DWORD DEFAULT_TAPI3_BLOCKING_CALL_SLEEP = 60000;

DWORD   gdwTapi3RetryProcessingSleep = DEFAULT_TAPI3_RETRY_PROCESSING_SLEEP;
DWORD   gdwTapi3SyncWaitTimeOut = DEFAULT_TAPI3_BLOCKING_CALL_SLEEP;


const char    szTapi32WndClass[]    = "Tapi32WndClass";

const CHAR  gszTUISPI_providerConfig[]        = "TUISPI_providerConfig";
const CHAR  gszTUISPI_providerGenericDialog[] = "TUISPI_providerGenericDialog";
const CHAR  gszTUISPI_providerGenericDialogData[] = "TUISPI_providerGenericDialogData";
const CHAR  gszTUISPI_providerInstall[]       = "TUISPI_providerInstall";
const CHAR  gszTUISPI_providerRemove[]        = "TUISPI_providerRemove";
const CHAR  gszTUISPI_lineConfigDialog[]      = "TUISPI_lineConfigDialog";
const CHAR  gszTUISPI_lineConfigDialogEdit[]  = "TUISPI_lineConfigDialogEdit";
const CHAR  gszTUISPI_phoneConfigDialog[]     = "TUISPI_phoneConfigDialog";

const CHAR gszTelephonyKey[] = "Software\\Microsoft\\Windows\\CurrentVersion\\Telephony";
const CHAR gszNumEntries[]         = "NumEntries";
const CHAR    gszLocations[]    = "Locations";

const WCHAR gszTAPI3[] = L"TAPI3";

BOOL    gbTranslateSimple = FALSE;
BOOL    gbTranslateSilent = FALSE;

HINSTANCE   ghWow32Dll = NULL;

PUITHREADDATA   gpUIThreadInstances = NULL;

CRITICAL_SECTION        gcsTapisrvCommunication;
CRITICAL_SECTION        gcsCallbackQueue;
CRITICAL_SECTION        gcsTapi32;
CRITICAL_SECTION        gcsGlobalInterfaceTable;

/*This is the CRITICAL_SECTION to protect m_sTapiObjectArray*/
CRITICAL_SECTION        gcsTapiObjectArray;

//This is the CRITICAL_SECTION to serialize access to functions
//AllocClientResources and FreeClientResources
CRITICAL_SECTION        gcsClientResources;

PCONTEXT_HANDLE_TYPE    gphCx = (PCONTEXT_HANDLE_TYPE) NULL;

LIST_ENTRY              gTlsListHead;
CRITICAL_SECTION        gTlsCriticalSection;

BOOL   gbCriticalSectionsInitialized = FALSE;


#if DBG
const char *aszMsgs[] =
{
    "LINE_ADDRESSSTATE",
    "LINE_CALLINFO",
    "LINE_CALLSTATE",
    "LINE_CLOSE",
    "LINE_DEVSPECIFIC",
    "LINE_DEVSPECIFICFEATURE",
    "LINE_GATHERDIGITS",
    "LINE_GENERATE",
    "LINE_LINEDEVSTATE",
    "LINE_MONITORDIGITS",
    "LINE_MONITORMEDIA",
    "LINE_MONITORTONE",
    "LINE_REPLY",
    "LINE_REQUEST",
    "PHONE_BUTTON",
    "PHONE_CLOSE",
    "PHONE_DEVSPECIFIC",
    "PHONE_REPLY",
    "PHONE_STATE",
    "LINE_CREATE",
    "PHONE_CREATE",
    "LINE_AGENTSPECIFIC",
    "LINE_AGENTSTATUS",
    "LINE_APPNEWCALL",
    "LINE_PROXYREQUEST",
    "LINE_REMOVE",
    "PHONE_REMOVE"
};
#endif

LONG gaNoMemErrors[3] =
{
    TAPIERR_REQUESTFAILED,
    LINEERR_NOMEM,
    PHONEERR_NOMEM
};

LONG gaInvalHwndErrors[3] =
{
    TAPIERR_INVALWINDOWHANDLE,
    LINEERR_INVALPARAM,
    PHONEERR_INVALPARAM
};

LONG gaInvalPtrErrors[3] =
{
    TAPIERR_INVALPOINTER,
    LINEERR_INVALPOINTER,
    PHONEERR_INVALPOINTER
};

LONG gaOpFailedErrors[3] =
{
    TAPIERR_REQUESTFAILED,
    LINEERR_OPERATIONFAILED,
    PHONEERR_OPERATIONFAILED
};

LONG gaStructTooSmallErrors[3] =
{
    TAPIERR_REQUESTFAILED,
    LINEERR_STRUCTURETOOSMALL,
    PHONEERR_STRUCTURETOOSMALL
};

LONG gaServiceNotRunningErrors[3] =
{
    TAPIERR_REQUESTFAILED,
    LINEERR_SERVICE_NOT_RUNNING,
    PHONEERR_SERVICE_NOT_RUNNING
};

#define AllInitExOptions2_0                           \
        (LINEINITIALIZEEXOPTION_USEHIDDENWINDOW     | \
        LINEINITIALIZEEXOPTION_USEEVENT             | \
        LINEINITIALIZEEXOPTION_USECOMPLETIONPORT)


//
// Function prototypes
//

void
PASCAL
lineMakeCallPostProcess(
    PASYNCEVENTMSG  pMsg
    );

#ifdef __cplusplus
extern "C" {
#endif
BOOL
WINAPI
_CRT_INIT(
    HINSTANCE   hDLL,
    DWORD   dwReason,
    LPVOID  lpReserved
    );
#ifdef __cplusplus
}
#endif

void
FreeInitData(
    PT3INIT_DATA  pInitData
    );

LONG
WINAPI
FreeClientResources(
    void
    );

LONG
CALLBACK
TUISPIDLLCallback(
    ULONG_PTR dwObjectID,
    DWORD   dwObjectType,
    LPVOID  lpParams,
    DWORD   dwSize
    );

BOOL
CALLBACK
TranslateDlgProc(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
    );

void
UIThread(
    LPVOID  pParams
    );

char *
PASCAL
MapResultCodeToText(
    LONG    lResult,
    char   *pszResult
    );

void
PASCAL
lineDevSpecificPostProcess(
    PASYNCEVENTMSG pMsg
    );

BOOL
WaveStringIdToDeviceId(
    LPWSTR  pwszStringID,
    LPCWSTR  pwszDeviceType,
    LPDWORD pdwDeviceId
    );

HRESULT
ProcessMessage(
               PT3INIT_DATA,
               PASYNCEVENTMSG
              );


//
// The code...
//

#if DBG

////////////////////////////////////////////////////////////////////////////
//
// DWORD_CAST 
// 
// casts the argument from type ULONG_PTR to DWORD. provides verification 
// to make sure no data is lost during the cast. these casts are currently 
// unavoidable due to the way some of our tapisrv communication logic is 
// implemented.
//
// note that casts produce lvalues as long as the size of result does not 
// exceed the size of the value that is being cast (this is ms-specific 
// compiler extension that can be disabled by /Za). To be consistent with this 
// compiler cast behavior, this function returns result by reference. 
//

DWORD DWORD_CAST(ULONG_PTR v)
{

    DWORD dwReturnValue = (DWORD)v;


    if (v > dwReturnValue)
    {
        LOG((TL_ERROR,
            "DWORD_CAST: information will be lost during cast from %p to %lx", 
            v, dwReturnValue));

        DebugBreak();
    }

    return dwReturnValue;
}

#endif


///////////////////////////////////////////////////////////////////////////////
//
// DWORD CreateHandleTableEntry(ULONG_PTR nEntry)
//
// indended to be used to map ULONG_PTR-sized values to 32-bit handles.
//
// CreateHandleTableEntry creates an entry in the handle table and returns a 
// 32-bit handle corresponding to it. the handle can later be used to retrieve
// the original ULONG_PTR-sized value by calling GetHandleTableEntry or to
// remove the entry in handle table by calling DeleteHandleTableEntry
// 
// returns 0 if handle table entry creation failed.
// 

DWORD CreateHandleTableEntry(ULONG_PTR nEntry)
{
    
     LOG((TL_INFO,
         "CreateHandleTableEntry - enter. nEntry %p", 
         nEntry));


    if (0 == ghHandleTable)
    {
         LOG((TL_ERROR,
             "CreateHandleTableEntry - handle table does not exist."));


         //
         // debug to see why this happened
         //

         _ASSERTE(FALSE);

         return 0;
    }


    //
    // get a 32-bit handle from the (up to) 64-bit pAddressLine. this 
    // is needed to avoid marshaling/passing 64-bit values to tapisrv 
    // (to preserve backward compatibility with older clients and servers)
    //

    DWORD dwHandle = NewObject(ghHandleTable, (LPVOID)nEntry, NULL);

    LOG((TL_INFO, "CreateHandleTableEntry - completed. returning [0x%lx]", dwHandle));

    return dwHandle;

}



//////////////////////////////////////////////////////////////////////////////
//
// void DeleteHandleTableEntry(DWORD dwHandle)
// 
// DeleteHandleTableEntry function removes the specified entry from the 
// handle table.
//

void DeleteHandleTableEntry(DWORD dwHandle)
{
    
     LOG((TL_INFO,
         "DeleteHandleTableEntry - enter. dwHandle 0x%lx", dwHandle ));


    if (0 == ghHandleTable)
    {
         LOG((TL_ERROR,
             "DeleteHandleTableEntry - handle table does not exist."));

         return;
    }


    //
    // handle 0 is a non-handle. deleting handle 0 is analogous to deleting NULL
    //

    if (0 == dwHandle)
    {
	    LOG((TL_INFO, 
		    "DeleteHandleTableEntry - the handle is 0. Returning."));

	    return;
	    
    }

    //
    // if there are no other outstanding references to the handle (and there 
    // should not be any), this will remove the entry from the handle table.
    //

    DereferenceObject(ghHandleTable, dwHandle, 1);

    LOG((TL_TRACE, "DeleteHandleTableEntry - finished."));

    return;
   
}


//////////////////////////////////////////////////////////////////////////////
//
// ULONG_PTR GetHandleTableEntry(DWORD dwHandle)
// 
// this function uses the supplied 32-bit value to get the corresponding 
// ULONG_PTR entry from the handle table. This is used under 64-bit to 
// recover the original 64-bit value from the handle
//

ULONG_PTR GetHandleTableEntry(DWORD dwHandle)
{
    
     LOG((TL_TRACE, 
         "GetHandleTableEntry - enter. dwHandle 0x%lx", 
         dwHandle));

    
    if (0 == ghHandleTable)
    {
         LOG((TL_ERROR,
             "GetHandleTableEntry - handle table does not exist."));

         return NULL;
    }


    //
    // get the pointer-sized value from the table
    //

    ULONG_PTR nValue = (ULONG_PTR)ReferenceObject(ghHandleTable, dwHandle, 0);


    //
    // we don't really need to keep a reference to it.
    // so don't -- this will simplify client logic
    //

    DereferenceObject(ghHandleTable, dwHandle, 1);


    LOG((TL_TRACE, 
             "GetHandleTableEntry - succeeded. returning 0x%p", 
             nValue));


    return nValue;
}


//***************************************************************************
//***************************************************************************
//***************************************************************************
PWSTR
PASCAL
NotSoWideStringToWideString(
    LPCSTR  lpStr,
    DWORD   dwLength
    )
{
   DWORD dwSize;
   PWSTR pwStr;


   if (IsBadStringPtrA (lpStr, dwLength))
   {
      return NULL;
   }

   dwSize = MultiByteToWideChar(
       GetACP(),
       MB_PRECOMPOSED,
       lpStr,
       dwLength,
       NULL,
       0
       );

   pwStr = (PWSTR)ClientAlloc( dwSize * sizeof(WCHAR) );

   if (NULL != pwStr)
   {
       MultiByteToWideChar(
           GetACP(),
           MB_PRECOMPOSED,
           lpStr,
           dwLength,
           pwStr,
           dwSize
           );
   }

   return pwStr;
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
//
//NOTE: This function requires that lpBase is a pointer to the start of
//      a TAPI struct that has dwTotalSize as the first DWORD
//
void
PASCAL
WideStringToNotSoWideString(
    LPBYTE  lpBase,
    LPDWORD lpdwXxxSize
    )
{
    DWORD  dwSize;
    DWORD  dwNewSize;
    DWORD  dwOffset;
    DWORD  dwTotalSize;
    DWORD  dwUsedSize;
    PWSTR  pString;
    PSTR   lpszStringA;


    if ((dwSize = *lpdwXxxSize) != 0)
    {
        dwTotalSize = *((LPDWORD) lpBase);

        dwUsedSize = *(((LPDWORD) lpBase)+2);

        dwOffset = *(lpdwXxxSize + 1);

        pString = (PWSTR)(lpBase + dwOffset);


        if (IsBadStringPtrW (pString, dwSize))
        {
           LOG((TL_ERROR, "The service provider returned an invalid field in the structure 0x%p : 0x%p",
                          lpBase, lpdwXxxSize));

           *lpdwXxxSize     = 0;
           *(lpdwXxxSize+1) = 0;

           return;
        }


        //
        // Did we get enough chars?
        //

        if (dwUsedSize > dwOffset )
        {
            dwNewSize = WideCharToMultiByte(
                GetACP(),
                0,
                pString,
                ( dwUsedSize >= (dwOffset+dwSize)) ?
                    (dwSize/sizeof(WCHAR)) :
                    (dwUsedSize - dwOffset) / sizeof(WCHAR),
                NULL,
                0,
                NULL,
                NULL
                );

            lpszStringA = (PSTR)ClientAlloc( dwNewSize );

            if ( NULL == lpszStringA )
            {
               LOG((TL_ERROR, "Memory alloc failed - alloc(0x%08lx)",
                                             dwSize));
               LOG((TL_ERROR, "The service provider returned an invalid field size in the structure 0x08lx : 0x08lx",
                              dwSize));

               *lpdwXxxSize     = 0;
               *(lpdwXxxSize+1) = 0;

               return;
            }

//            lpszStringA[dwNewSize]     = '\0';

            WideCharToMultiByte(
                GetACP(),
                0,
                pString,
//                dwSize,
                ( dwUsedSize >= (dwOffset+dwSize)) ?
                    (dwSize/sizeof(WCHAR)) :
                    (dwUsedSize - dwOffset) / sizeof(WCHAR),
                lpszStringA,
                dwNewSize,
                NULL,
                NULL
                );

            //
            // Copy the new ANSI string back to where the Unicode string was
//            // and write out NULL terminator if possible.
            //

            CopyMemory ( (LPBYTE) pString,
                         lpszStringA,
                         dwNewSize  // + (
                                    //  ((dwNewSize + dwOffset) < dwUsedSize ) ?
                                    //  1 :
                                    //  0
                                    // )
                       );

            ClientFree (lpszStringA);


            //
            // Update the number of bytes
            //

            *lpdwXxxSize = dwNewSize;
        }
    }
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// ReadRegistryValues
//
// During initialization, reads various values from the registry
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL
ReadRegistryValues()
{
    HKEY  hKey;


#if DBG
    gdwDebugLevel = 0;
#endif
    gdwMaxNumRequestRetries = 40;
    gdwRequestRetryTimeout = 250; // milliseconds
    gdwTapi2AsynchronousCallTimeout = DEFAULT_TAPI2_ASYNCRONOUS_CALL_TIMEOUT;
   
    //
    // open the telephony key
    //
    if (RegOpenKeyEx(
                     HKEY_LOCAL_MACHINE,
                     gszTelephonyKey,
                     0,
                     KEY_READ,
                     &hKey

                    ) == ERROR_SUCCESS)
    {

        DWORD dwDataSize, dwDataType;

        //
        // get the rpc max num of retries
        //
        dwDataSize = sizeof(DWORD);
        RegQueryValueEx(
                        hKey,
                        gszTapi32MaxNumRequestRetries,
                        0,
                        &dwDataType,
                        (LPBYTE) &gdwMaxNumRequestRetries,
                        &dwDataSize
                       );

        //
        // get the retry timeout
        //
        dwDataSize = sizeof(DWORD);
        RegQueryValueEx(
                        hKey,
                        gszTapi32RequestRetryTimeout,
                        0,
                        &dwDataType,
                        (LPBYTE) &gdwRequestRetryTimeout,
                        &dwDataSize
                       );

        //
        // get the timeout for asynchronous calls to tapi2
        //
        dwDataSize = sizeof(DWORD);
        LONG rc = RegQueryValueEx(
                                  hKey,
                                  gszTapi2AsynchronousCallTimeout,
                                  0,
                                  &dwDataType,
                                  (LPBYTE) &gdwTapi2AsynchronousCallTimeout,
                                  &dwDataSize
                                 );
        
        if (rc != ERROR_SUCCESS)
        {
            gdwTapi2AsynchronousCallTimeout = DEFAULT_TAPI2_ASYNCRONOUS_CALL_TIMEOUT;
        }

        LOG((TL_INFO, "AsynchronousCallTimeout initialized to %d",
                gdwTapi2AsynchronousCallTimeout));


        //
        // get sleep time for retry processing
        //
        
        dwDataSize = sizeof(DWORD);

        rc = RegQueryValueEx(
                              hKey,
                              gszTapi3RetryProcessingSleep,
                              0,
                              &dwDataType,
                              (LPBYTE) &gdwTapi3RetryProcessingSleep,
                              &dwDataSize
                             );

        if (rc != ERROR_SUCCESS)
        {
            gdwTapi3RetryProcessingSleep = DEFAULT_TAPI3_RETRY_PROCESSING_SLEEP;
        }

        
        LOG((TL_INFO, "gdwTapi3RetryProcessingSleep initialized to %ld",
                gdwTapi3RetryProcessingSleep));


        //
        // get sleep time for blocking call timeout
        //
        
        dwDataSize = sizeof(DWORD);

        rc = RegQueryValueEx(
                              hKey,
                              gszTapi3SyncWaitTimeOut,
                              0,
                              &dwDataType,
                              (LPBYTE) &gdwTapi3SyncWaitTimeOut,
                              &dwDataSize
                             );

        if (rc != ERROR_SUCCESS)
        {
            gdwTapi3SyncWaitTimeOut = DEFAULT_TAPI3_BLOCKING_CALL_SLEEP;
        }

        
        LOG((TL_INFO, "gdwTapi3SyncWaitTimeOut initialized to %ld",
                gdwTapi3SyncWaitTimeOut));

        RegCloseKey (hKey);
    }

    return TRUE;
}


//***************************************************************************
//***************************************************************************
//***************************************************************************
extern "C"
BOOL
WINAPI
DllMain(
    HANDLE  hDLL,
    DWORD   dwReason,
    LPVOID  lpReserved
    )
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            gbCriticalSectionsInitialized = FALSE;
#if DBG
            _CrtSetDbgFlag(_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG));

#endif
            ghInst = (HINSTANCE)hDLL;

            //
            // ATL initialization
            //
#ifdef _MERGE_PROXYSTUB
            if (!PrxDllMain(ghInst, dwReason, lpReserved))
            {
                return FALSE;
            }
#endif
            _Module.Init(ObjectMap, ghInst);

            //
            // Init CRT
            //
            if (!_CRT_INIT (ghInst, dwReason, lpReserved))
            {
                LOG((TL_ERROR,
                             "DLL_PROCESS_ATTACH, _CRT_INIT() failed"
                           ));

                return FALSE;
            }


            // Register for trace output.
            TRACELOGREGISTER(_T("tapi3"));

            LOG((TL_INFO, "DLL_PROCESS_ATTACH"));


            //
            // initialize stuff from the registry
            //

            ReadRegistryValues();


            //
            // Alloc a Tls index
            //
            if ((gdwTlsIndex = TlsAlloc()) == 0xffffffff)
            {
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH, TlsAlloc() failed"));

                return FALSE;
            }

            //
            // Initialize Tls to NULL for this thread
            //
            TlsSetValue (gdwTlsIndex, NULL);


            //
            // Create mutex
            //
            ghTapiInitShutdownSerializeMutex = CreateMutex(NULL, FALSE, NULL);

            //
            // init critical sections
            //

            try
            {
                InitializeCriticalSection (&gcsTapisrvCommunication);
            }
            catch(...)
            {
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH, InitializeCriticalSection failed"));
                return FALSE;
            }

            try
            {
                InitializeCriticalSection (&gTlsCriticalSection);
            }
            catch(...)
            {
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH, InitializeCriticalSection failed"));

                DeleteCriticalSection (&gcsTapisrvCommunication);
                return FALSE;
            }

            try
            {
                InitializeCriticalSection (&gcsCallbackQueue);
            }
            catch(...)
            {
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH, InitializeCriticalSection failed"));

                DeleteCriticalSection (&gcsTapisrvCommunication);
                DeleteCriticalSection (&gTlsCriticalSection);
                return FALSE;
            }

            
            try
            {
                InitializeCriticalSection (&gcsTapi32);
            }
            catch(...)
            {
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH, InitializeCriticalSection failed"));

                DeleteCriticalSection (&gcsTapisrvCommunication);
                DeleteCriticalSection (&gTlsCriticalSection);
                DeleteCriticalSection (&gcsCallbackQueue);
                return FALSE;
            }

            
            try
            {
                InitializeCriticalSection (&gcsGlobalInterfaceTable);
            }
            catch(...)
            {
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH, InitializeCriticalSection failed"));

                DeleteCriticalSection (&gcsTapisrvCommunication);
                DeleteCriticalSection (&gTlsCriticalSection);
                DeleteCriticalSection (&gcsCallbackQueue);
                DeleteCriticalSection (&gcsTapi32);
                return FALSE;
            }

            
            try
            {
                InitializeCriticalSection (&gcsClientResources);
            }
            catch(...)
            {
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH, InitializeCriticalSection failed"));

                DeleteCriticalSection (&gcsTapisrvCommunication);
                DeleteCriticalSection (&gTlsCriticalSection);
                DeleteCriticalSection (&gcsCallbackQueue);
                DeleteCriticalSection (&gcsTapi32);
                DeleteCriticalSection (&gcsGlobalInterfaceTable);
                return FALSE;
            }

            
            try
            {
                InitializeCriticalSection (&gcsTapiObjectArray);
            }
            catch(...)
            {
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH, InitializeCriticalSection failed"));

                DeleteCriticalSection (&gcsTapisrvCommunication);
                DeleteCriticalSection (&gTlsCriticalSection);
                DeleteCriticalSection (&gcsCallbackQueue);
                DeleteCriticalSection (&gcsTapi32);
                DeleteCriticalSection (&gcsGlobalInterfaceTable);
                DeleteCriticalSection (&gcsClientResources);
                return FALSE;
            }

            

#if DBG
            try
            {
                InitializeCriticalSection( &csMemoryList);
            }
            catch(...)
            {
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH, InitializeCriticalSection failed"));

                DeleteCriticalSection (&gcsTapisrvCommunication);
                DeleteCriticalSection (&gTlsCriticalSection);
                DeleteCriticalSection (&gcsCallbackQueue);
                DeleteCriticalSection (&gcsTapi32);
                DeleteCriticalSection (&gcsGlobalInterfaceTable);
                DeleteCriticalSection (&gcsClientResources);
                DeleteCriticalSection (&gcsTapiObjectArray);
                return FALSE;
            }            
#endif

            gbCriticalSectionsInitialized = TRUE;

            InitializeListHead (&gTlsListHead);

            HRESULT     hr;

            //
            // gpCallHashTable
            //

            try
            {
                gpCallHashTable = new CHashTable;
            }
            catch(...)
            {
                // Initialize critical section in the constructor most likely threw this exception
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH, gpCallHashTable constructor threw an exception"));
                return FALSE;
            } 

            if ( NULL == gpCallHashTable )
            {
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH, gpCallHashTable alloc failed"));
                return FALSE;
            }

            hr = gpCallHashTable->Initialize( 1 );

            if ( !SUCCEEDED(hr) )
            {
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH, gpCallHashTable init failed"));
                return FALSE;
            }

            //
            // gpLineHashTable
            //

            try
            {
                gpLineHashTable = new CHashTable;
            }
            catch(...)
            {
                // Initialize critical section in the constructor most likely threw this exception
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH, gpLineHashTable constructor threw an exception"));
                return FALSE;
            } 

            if ( NULL == gpLineHashTable )
            {
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH, gpLineHashTable alloc failed"));
                return FALSE;
            }

            hr = gpLineHashTable->Initialize( 1 );

            if ( !SUCCEEDED(hr) )
            {
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH, gpLineHashTable init failed"));
                return FALSE;
            }

            //
            // gpCallHubHashTable
            //

            try
            {
                gpCallHubHashTable = new CHashTable;
            }
            catch(...)
            {
                // Initialize critical section in the constructor most likely threw this exception
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH, gpCallHubHashTable constructor threw an exception"));
                return FALSE;
            } 

            if ( NULL == gpCallHubHashTable )
            {
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH, gpCallHubHashTable alloc failed"));
                return FALSE;
            }

            hr = gpCallHubHashTable->Initialize( 1 );

            if ( !SUCCEEDED(hr) )
            {
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH, gpCallHubHashTable init failed"));
                return FALSE;
            }

            //
            // gpAgentHandlerHashTable
            //

            try
            {
                gpAgentHandlerHashTable = new CHashTable;
            }
            catch(...)
            {
                // Initialize critical section in the constructor most likely threw this exception
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH, gpAgentHandlerHashTable constructor threw an exception"));
                return FALSE;
            } 

            if ( NULL == gpAgentHandlerHashTable )
            {
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH, gpAgentHandlerHashTable alloc failed"));
                return FALSE;
            }

            hr = gpAgentHandlerHashTable->Initialize( 1 );

            if ( !SUCCEEDED(hr) )
            {
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH, gpAgentHandlerHashTable init failed"));
                return FALSE;
            }

            //
            // gpPhoneHashTable
            //

            try
            {
                gpPhoneHashTable = new CHashTable;
            }
            catch(...)
            {
                // Initialize critical section in the constructor most likely threw this exception
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH, gpPhoneHashTable constructor threw an exception"));
                return FALSE;
            } 

            if ( NULL == gpPhoneHashTable )
            {
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH, gpPhoneHashTable alloc failed"));
                return FALSE;
            }

            hr = gpPhoneHashTable->Initialize( 1 );

            if ( !SUCCEEDED(hr) )
            {
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH, gpPhoneHashTable init failed"));
                return FALSE;
            }

            //
            // gpHandleHashTable
            // 

            try
            {
                gpHandleHashTable = new CHashTable;
            }
            catch(...)
            {
                // Initialize critical section in the constructor most likely threw this exception
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH, gpHandleHashTable constructor threw an exception"));
                return FALSE;
            } 

            if ( NULL == gpHandleHashTable )
            {
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH, gpHandleHashTable alloc failed"));
                return FALSE;
            }

            hr = gpHandleHashTable->Initialize( 1 );

            if ( !SUCCEEDED(hr) )
            {
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH, gpHandleHashTable init failed"));
                return FALSE;
            }

            //
            // gpLineAsyncReplyList
            // 

            try
            {
                gpLineAsyncReplyList = new CAsyncReplyList;
            }
            catch(...)
            {
                // Initialize critical section in the constructor most likely threw this exception
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH, gpLineAsyncReplyList constructor threw an exception"));
                return FALSE;
            } 

            if ( NULL == gpLineAsyncReplyList )
            {
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH - gpLineAsyncReplyList alloc failed"));
                return FALSE;
            }

            //
            // gpPhoneAsyncReplyList
            // 

            try
            {
                gpPhoneAsyncReplyList = new CAsyncReplyList;
            }
            catch(...)
            {
                // Initialize critical section in the constructor most likely threw this exception
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH, gpPhoneAsyncReplyList constructor threw an exception"));
                return FALSE;
            } 

            if ( NULL == gpPhoneAsyncReplyList )
            {
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH - gpPhoneAsyncReplyList alloc failed"));
                return FALSE;
            }

            //
            // gpRetryQueue
            // 

            try
            {
                gpRetryQueue = new CRetryQueue;
            }
            catch(...)
            {
                // Initialize critical section in the constructor most likely threw this exception
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH, gpRetryQueue constructor threw an exception"));
                return FALSE;
            } 

            if ( NULL == gpRetryQueue )
            {
                LOG((TL_ERROR, "DLL_PROCESS_ATTACH - gpRetryQueue alloc failed"));
                return FALSE;
            }

            break;            
        }
        case DLL_PROCESS_DETACH:
        {
            PCLIENT_THREAD_INFO pTls;

            LOG((TL_INFO, "DLL_PROCESS_DETACH"));

            if (gpCallHashTable != NULL)
            {
                gpCallHashTable->Shutdown();
                delete gpCallHashTable;
            }

            if (gpLineHashTable != NULL)
            {
                gpLineHashTable->Shutdown();
                delete gpLineHashTable;
            }

            if (gpCallHubHashTable != NULL)
            {
                gpCallHubHashTable->Shutdown();
                delete gpCallHubHashTable;
            }

            if (gpAgentHandlerHashTable != NULL)
            {
                gpAgentHandlerHashTable->Shutdown();
                delete gpAgentHandlerHashTable;
            }

            if (gpPhoneHashTable != NULL)
            {
                gpPhoneHashTable->Shutdown();
                delete gpPhoneHashTable;
            }

            if (gpHandleHashTable != NULL)
            {
                gpHandleHashTable->Shutdown();
                delete gpHandleHashTable;
            }

            CTAPI::m_sTAPIObjectArray.Shutdown();
        
            delete gpLineAsyncReplyList;
            delete gpPhoneAsyncReplyList;
            delete gpRetryQueue;

            //
            // Clean up any Tls (no need to enter crit sec since process detaching)
            //

            while (!IsListEmpty (&gTlsListHead))
            {
                LIST_ENTRY *pEntry = RemoveHeadList (&gTlsListHead);

                pTls = CONTAINING_RECORD (pEntry, CLIENT_THREAD_INFO, TlsList);

                ClientFree (pTls->pBuf);
                ClientFree (pTls);
            }


            //
            // ATL shutdown
            //
            _Module.Term();

            TlsFree( gdwTlsIndex );

            if (!_CRT_INIT (ghInst, dwReason, lpReserved))
            {
                LOG((TL_ERROR, "_CRT_INIT() failed"));
            }


            //
            // delete all our critical sections
            //

            if (gbCriticalSectionsInitialized)
            {
                DeleteCriticalSection (&gcsTapisrvCommunication);
                DeleteCriticalSection (&gTlsCriticalSection);
                DeleteCriticalSection (&gcsCallbackQueue);
                DeleteCriticalSection (&gcsTapi32);
                DeleteCriticalSection (&gcsGlobalInterfaceTable);
                DeleteCriticalSection (&gcsClientResources);
                DeleteCriticalSection (&gcsTapiObjectArray);
            }

#if DBG
            DumpMemoryList();
            _CrtDumpMemoryLeaks();

            if (gbCriticalSectionsInitialized)
            {
                DeleteCriticalSection( &csMemoryList );
            }
#endif

            //
            // Close our mutex
            //
            CloseHandle( ghTapiInitShutdownSerializeMutex );


            //
            // do not deregister if the process is terminating -- working around 
            // bugs in rtutils that could cause a "deadlock" if DeregisterTracing
            // is called from DllMain on process termination.
            // also we want to delay unregistering until the end so that debugger
            // output gets logged up to this point, if it is configured.
            //

            if (NULL == lpReserved)
            {

                TRACELOGDEREGISTER();
            }


            break;
        }
        case DLL_THREAD_ATTACH:

            //
            // First must init CRT
            //
            if (!_CRT_INIT (ghInst, dwReason, lpReserved))
            {
                LOG((TL_ERROR, "_CRT_INIT() failed"));

                return FALSE;
            }

            //
            // Initialize Tls to NULL for this thread
            //

            TlsSetValue (gdwTlsIndex, NULL);

            break;

        case DLL_THREAD_DETACH:
        {
            PCLIENT_THREAD_INFO pTls;

            //
            // Clean up any Tls
            //
            if ((pTls = (PCLIENT_THREAD_INFO) TlsGetValue (gdwTlsIndex)))
            {
                EnterCriticalSection (&gTlsCriticalSection);

                RemoveEntryList (&pTls->TlsList);

                LeaveCriticalSection (&gTlsCriticalSection);

                if (pTls->pBuf)
                {
                    ClientFree (pTls->pBuf);
                }

                ClientFree (pTls);
            }

            //
            // Finally, alert CRT
            //
            if (!_CRT_INIT (ghInst, dwReason, lpReserved))
            {
                LOG((TL_ERROR, "_CRT_INIT() failed"));
            }

            break;
        }

    } // switch

    return TRUE;
}

////////////////////////////////////////////////////////////////////
// QueueCallbackEvent
//
// Queues a raw async message that will be processed in the
// CallbackThread.
////////////////////////////////////////////////////////////////////
void
QueueCallbackEvent(
                   PASYNCEVENTMSG pParams
                  )
{
    PTAPICALLBACKEVENT  pNew;
    DWORD               dwSize; // = sizeof (ASYNCEVENTMSG);


    LOG((TL_TRACE, "QueueCallbackEvent - enter"));
    LOG((TL_INFO, " hDevice ----> %lx", pParams->hDevice));
    LOG((TL_INFO, " Msg   ----> %lx", pParams->Msg));
    LOG((TL_INFO, " Param1 ---> %lx", pParams->Param1));
    LOG((TL_INFO, " Param2 ---> %lx", pParams->Param2));
    LOG((TL_INFO, " Param3 ---> %lx", pParams->Param3));

    dwSize = pParams->TotalSize;

    pNew = (PTAPICALLBACKEVENT)ClientAlloc( sizeof(TAPICALLBACKEVENT) + (dwSize-sizeof(ASYNCEVENTMSG) ) );

    if ( pNew != NULL)
    {
        pNew->type = CALLBACKTYPE_RAW_ASYNC_MESSAGE;
        pNew->pTapi = NULL;
        CopyMemory(
                   &pNew->data.asyncMessage,
                   pParams,
                   dwSize
                  );

        // add to list
        EnterCriticalSection( &gcsCallbackQueue );

        try
        {
            gCallbackEventPtrList.push_back( (PVOID)pNew );
        }
        catch(...)
        {
            LOG((TL_ERROR, "QueueCallbackEvent - out of memory - losing message"));
            ClientFree( pNew );
        }


        LeaveCriticalSection( &gcsCallbackQueue );

        SetEvent( ghCallbackThreadEvent );

        LOG((TL_INFO, "QueueCallbackEvent - New pParams is ----> %p", pNew ));
    }
    else
    {
        LOG((TL_ERROR, "QueueCallbackEvent - out of memory - losing message"));
        return;
    }

}


////////////////////////////////////////////////////////////////////
// QueueCallbackEvent
//
// Queues a raw async message that will be processed in the
// CallbackThread.
////////////////////////////////////////////////////////////////////
void
QueueCallbackEvent(
                   CTAPI           *pTapi,
                   PASYNCEVENTMSG pParams
                  )
{
    PTAPICALLBACKEVENT  pNew;
    DWORD               dwSize; // = sizeof (ASYNCEVENTMSG);


    LOG((TL_TRACE, "QueueCallbackEvent - enter"));
    LOG((TL_INFO, " hDevice ----> %lx", pParams->hDevice));
    LOG((TL_INFO, " Msg   ----> %lx", pParams->Msg));
    LOG((TL_INFO, " Param1 ---> %lx", pParams->Param1));
    LOG((TL_INFO, " Param2 ---> %lx", pParams->Param2));
    LOG((TL_INFO, " Param3 ---> %lx", pParams->Param3));

    dwSize = pParams->TotalSize;

    pNew = (PTAPICALLBACKEVENT)ClientAlloc( sizeof(TAPICALLBACKEVENT) + (dwSize-sizeof(ASYNCEVENTMSG) ) );

    if ( pNew != NULL)
    {
        pNew->type = CALLBACKTYPE_RAW_ASYNC_MESSAGE;
        pNew->pTapi = pTapi;
        CopyMemory(
                   &pNew->data.asyncMessage,
                   pParams,
                   dwSize
                  );

        // add to list
        EnterCriticalSection( &gcsCallbackQueue );

        try
        {
            gCallbackEventPtrList.push_back( (PVOID)pNew );
        }
        catch(...)
        {
            LOG((TL_ERROR, "QueueCallbackEvent - out of memory - losing message"));
            ClientFree( pNew );
        }


        LeaveCriticalSection( &gcsCallbackQueue );

        SetEvent( ghCallbackThreadEvent );

        LOG((TL_INFO, "QueueCallbackEvent - New pParams is ----> %p", pNew ));
    }
    else
    {
        LOG((TL_ERROR, "QueueCallbackEvent - out of memory - losing message"));
        return;
    }

}

////////////////////////////////////////////////////////////////////
// QueueCallbackEvent
//
// Queues a TAPI event message object that will be processed in the
// CallbackThread.
////////////////////////////////////////////////////////////////////
BOOL
QueueCallbackEvent(
                   CTAPI      * pTapi,
                   TAPI_EVENT   te,
                   IDispatch  * pEvent
                  )
{
    BOOL                bResult = TRUE;
    PTAPICALLBACKEVENT  pNew;


    LOG((TL_TRACE, "QueueCallbackEvent - enter"));
#if DBG
    LOG((TL_INFO, "QueueCallbackEvent - TAPI Event -> %lx %s", te, eventName(te) ));
#endif

    pNew = (PTAPICALLBACKEVENT)ClientAlloc( sizeof(TAPICALLBACKEVENT) );

    if ( pNew != NULL)
    {
        pNew->type = CALLBACKTYPE_TAPI_EVENT_OBJECT;
        pNew->pTapi = pTapi;
        pNew->data.tapiEvent.te = te;
        pNew->data.tapiEvent.pEvent = pEvent;

        // add to list
        EnterCriticalSection( &gcsCallbackQueue );

        try
        {
            gCallbackEventPtrList.push_back( (PVOID)pNew );
        }
        catch(...)
        {
            bResult = FALSE;
            LOG((TL_ERROR, "QueueCallbackEvent - out of memory - losing message"));
            ClientFree( pNew );
        }

        LeaveCriticalSection( &gcsCallbackQueue );

        if( bResult )
        {
            SetEvent( ghCallbackThreadEvent );
        }

        LOG((TL_INFO, "QueueCallbackEvent - New pParams is ----> %p", pNew ));
    }
    else
    {
        LOG((TL_ERROR, "QueueCallbackEvent - out of memory - losing message"));
        bResult = FALSE;
    }

    return bResult;

}




////////////////////////////////////////////////////////////////////
// DequeueCallbackEvent
//
// Pulls an event from the queue for the CallbackThread
////////////////////////////////////////////////////////////////////
BOOL
DequeueCallbackEvent(
                     PTAPICALLBACKEVENT * ppCallBackEvent
                    )
{
    BOOL    bResult = TRUE;


    LOG((TL_TRACE, "DequeueCallbackEvent - enter"));

    EnterCriticalSection( &gcsCallbackQueue );

    if (gCallbackEventPtrList.size() > 0)
    {
        *ppCallBackEvent = (PTAPICALLBACKEVENT) gCallbackEventPtrList.front();
        try
        {
            gCallbackEventPtrList.pop_front();
        }
        catch(...)
        {
            LOG((TL_ERROR, "DequeueCallbackEvent - failed to pop from gCallbackEventPtrList"));
            bResult = FALSE;
        }
        
        if( bResult )
        {
            if(IsBadReadPtr(*ppCallBackEvent, sizeof( TAPICALLBACKEVENT )) )
            {
                bResult = FALSE;
                LOG((TL_ERROR, "DequeueCallbackEvent - IsBadReadPtr *ppCallBackEvent"));
            }
        }
        
    }
    else
    {
        // return false if there are no more messages
        LOG((TL_ERROR, "DequeueCallbackEvent - no more messages"));
        bResult = FALSE;
    }

    LeaveCriticalSection( &gcsCallbackQueue );

#if DBG
    if (bResult)
    {
        LOG((TL_INFO, "DequeueCallbackEvent - returning %p", *ppCallBackEvent));
    }
    else
    {
        LOG((TL_INFO, "DequeueCallbackEvent - no event"));
    }
#endif

    return bResult;
}


BOOL WaitWithMessageLoop(HANDLE hEvent)
{
    DWORD dwRet;
    MSG msg;

    while(1)
    {
        dwRet = MsgWaitForMultipleObjects(
                                          1,    // One event to wait for
                                          &hEvent,        // The array of events
                                          FALSE,          // Wait for 1 event
                                          INFINITE,       // Timeout value
                                          QS_ALLINPUT
                                         );   // Any message wakes up

        // There is a window message available. Dispatch it.
        while(PeekMessage(&msg,NULL,0,0xFFFFFFFF,PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        if (dwRet == WAIT_OBJECT_0)
        {
            return TRUE;
        }
    }
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CallbackThread
//
// Thread proc used to call application's callback routines.
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CallbackThread(
               LPVOID pv
              )
{
    HINSTANCE       hLib;

    LOG((TL_TRACE, "CallbackThread: enter"));

    //
    // make sure we're CoInitialized
    //
    if ( !(SUCCEEDED( CoInitializeEx(NULL, COINIT_MULTITHREADED) ) ) )
    {
        LOG((TL_ERROR, "CallbackThread: CoInitialize failed"));
    }

    hLib = LoadLibrary("tapi3.dll");

    while (TRUE)
    {
        //
        // put the break here, so when the
        // flag is set, we still flush the callbackevent
        // queue in the while(TRUE) loop below
        //
        if (gbExitThread)
        {
            LOG((TL_TRACE, "CallbackThread: gbExitThread"));
            break;
        }

        LOG((TL_INFO, "CallbackThread: Wait for event"));
        DWORD dwSignalled;
        CoWaitForMultipleHandles (COWAIT_ALERTABLE,
                                INFINITE,
                                1,
                                &ghCallbackThreadEvent,
                                &dwSignalled);
/*
        WaitForSingleObject(
                            ghCallbackThreadEvent,
                            INFINITE
                           );
*/
        while (TRUE)
        {
            PTAPICALLBACKEVENT  pCallBackEvent;
            HRESULT             hr = S_OK;

            //
            // get the event
            //
            if (!DequeueCallbackEvent(&pCallBackEvent ) )
            {
                LOG((TL_ERROR, "CallbackThread: The DequeueCallbackEvent returned a wrong value"));
                break;
            }

            if(pCallBackEvent->type == CALLBACKTYPE_RAW_ASYNC_MESSAGE)
            {
                PASYNCEVENTMSG      pParams;

                LOG((TL_INFO, "CallbackThread: event type is CALLBACKTYPE_RAW_ASYNC_MESSAGE"));
                pParams = &pCallBackEvent->data.asyncMessage;

                //
                // call the handler
                //
                switch( pParams->Msg )
                {
#ifdef USE_PHONEMSP
                    case PRIVATE_PHONESETHOOKSWITCH:
                    {
                        CPhoneMSPCall::HandlePrivateHookSwitch( pParams );
                        break;
                    }
#endif USE_PHONEMSP

                    case LINE_CREATE:
                    {
                        HandleLineCreate( pParams );
                        break;
                    }

                    case LINE_REMOVE:
                    {
                        HandleLineRemove( pParams );
                        break;
                    }

                    case PHONE_STATE:
                    {
                        HandlePhoneStateMessage( pParams );
                        break;
                    }

                    case PHONE_CREATE:
                    {
                        HandlePhoneCreate( pParams );
                        break;
                    }

                    case PHONE_REMOVE:
                    {
                        HandlePhoneRemove( pParams );
                        break;
                    }

                    case PRIVATE_ISDN__ACCEPTTOALERT:
                    {
                        HandleAcceptToAlert( pParams );
                        break;
                    }

                    case LINE_PROXYSTATUS:
                    {
                        handleProxyStatusMessage(pCallBackEvent->pTapi, pParams);
                        break;
                    }
                    
                    default:
                        LOG((TL_WARN, "CallbackThread: asyncevent type not handled %x", pParams->Msg ));
                        break;
                }
            }
            else
            {

                //
                // fire the event
                //

                CTAPI * pTapi = pCallBackEvent->pTapi;

                LOG((TL_INFO, "CallbackThread: event type is CALLBACKTYPE_TAPI_EVENT_OBJECT"));
#if DBG
                LOG((TL_INFO, "CallbackThread: firing event event -> %lx %s tapi[%p]",
                    pCallBackEvent->data.tapiEvent.te,
                    eventName(pCallBackEvent->data.tapiEvent.te),
                    pTapi));
#endif
                pTapi->EventFire(
                             pCallBackEvent->data.tapiEvent.te,
                             pCallBackEvent->data.tapiEvent.pEvent
                            );

                pTapi->Release();

            }


            //
            // free the message
            //
            ClientFree( pCallBackEvent );

        }

    }

    CoUninitialize();

    if (hLib != NULL)
    {
        FreeLibraryAndExitThread ((HINSTANCE)hLib, 0);
    }
    else
    {
        ExitThread(0);
    }

    LOG((TL_TRACE, "CallbackThread: exit"));

}

void
PASCAL
lineCompleteCallPostProcess(
    PASYNCEVENTMSG  pMsg
    );


void
PASCAL
lineGatherDigitsWPostProcess(
    PASYNCEVENTMSG  pMsg
    );


void
PASCAL
lineSetupConferencePostProcess(
    PASYNCEVENTMSG pMsg
    );


void
PASCAL
phoneDevSpecificPostProcess(
    PASYNCEVENTMSG pMsg
    );


///////////////////////////////////////////////////////////////////////////////
//
// array of functions. function index is passed to tapisrv when we make an 
// asynchronous tapisrv call. in LINE_REPLY, we get this index back, and call 
// the appropriate function. we need to do this because we cannot pass function
// address to tapisrv
//

POSTPROCESSPROC gPostProcessingFunctions[] = 
{
    NULL,
    lineDevSpecificPostProcess, 
    lineCompleteCallPostProcess,
    lineMakeCallPostProcess, 
    lineGatherDigitsWPostProcess, 
    lineSetupConferencePostProcess,
    phoneDevSpecificPostProcess
};


/////////////////////////////////////
//
//  GetFunctionIndex
// 
//  find the array index of the function. 
//
//  returns 0 if the function was not found in the array
//

DWORD GetFunctionIndex(POSTPROCESSPROC Function)
{

    const int nArraySize = 
        sizeof(gPostProcessingFunctions)/sizeof(POSTPROCESSPROC);


    for (int i = 0; i < nArraySize; i++)
    {

        if (Function == gPostProcessingFunctions[i])
        {

            break;
        }
    }



    //
    // the function that is passed in had better be in the array. if not -- this should be caught in testing!
    //

    _ASSERTE( (0 != i) && (i < nArraySize) );

    if (i == nArraySize)
    {

        LOG((TL_ERROR,
            "GetFunctionIndex: function %p is not found in the array of functions!",
            Function));

        i = 0;
    }


    LOG((TL_INFO, 
        "GetFunctionIndex: function %p mapped to index %d.", Function, i));

    return i;

}


//**************************************************************************
//**************************************************************************
//**************************************************************************
void
AsyncEventsThread(
    PASYNC_EVENTS_THREAD_PARAMS pAsyncEventsThreadParams
    )
{
    BOOL           *pbExitThread = &pAsyncEventsThreadParams->bExitThread,
                    bRetry;

    HANDLE          hStartupEvent = pAsyncEventsThreadParams->hThreadStartupEvent;
    
    DWORD           dwBufSize    = pAsyncEventsThreadParams->dwBufSize;
    LPBYTE          pBuf         = pAsyncEventsThreadParams->pBuf;
    PTAPI32_MSG     pMsg         = (PTAPI32_MSG) pBuf;

    HANDLE ahWaitForTheseEvents[]={
        ghAsyncRetryQueueEvent,
        ghAsyncEventsEvent
        };


    LOG((TL_TRACE, "AsyncEventsThread: enter"));

    if ( !(SUCCEEDED( CoInitializeEx(NULL, COINIT_MULTITHREADED) ) ) )
    {
        LOG((TL_ERROR, "AsyncEventsThread: CoInitialize failed "));
    }


    //
    // mark retryqueue as open for new entries
    //

    gpRetryQueue->OpenForNewEntries();


    //
    // it is now ok for events to be posted to the retry queue
    //

    BOOL bSetStartuptEvent = SetEvent(hStartupEvent);

    if (!bSetStartuptEvent)
    {
        LOG((TL_ERROR, 
            "AsyncEventsThread - failed to signal hStartupEvent event. LastError = 0x%lx",
            GetLastError()));

        return;
    }

    //
    // we will never need this event again. the creator of the thread will 
    // release it
    //

    hStartupEvent = NULL;


    //
    // Just loop reading async events/completions from server &
    // handling them
    //
    while (1)
    {
        DWORD           dwUsedSize, dwNeededSize;
        PASYNCEVENTMSG  pAsyncEventMsg;


        //
        // Check to see if xxxShutdown or FreeClientResources
        // is signaling us to exit (we need to check both before
        // & after the wait to dela with a event setting/resetting
        // race condition between FreeClientResources & Tapisrv)
        //

        if (*pbExitThread)
        {

            LOG((TL_INFO, "AsyncEventsThread: exit requested"));

            break;
        }


        //
        // Block until tapisrv signals us that it has some event data for us
        //

        {
            DWORD dwSignalled;


            CoWaitForMultipleHandles (COWAIT_ALERTABLE,
                                    INFINITE,
                                    sizeof(ahWaitForTheseEvents)/sizeof(HANDLE),
                                    ahWaitForTheseEvents,
                                    &dwSignalled);


/*
            dwSignalled = WaitForMultipleObjects(
                                                 sizeof(ahWaitForTheseEvents)/sizeof(HANDLE),
                                                 ahWaitForTheseEvents,
                                                 FALSE,
                                                 INFINITE
                                                );
*/
            //
            // map for dwSignalled:
            //
            // 0 == ghAsyncRetryQueueEvent,
            // 1 == ghAsyncEventsEvent,
            //
            dwSignalled = dwSignalled - WAIT_OBJECT_0;

            if( 0 == dwSignalled )
            {
                //
                // Now lets process the Re-try Queue
                //
                LOG((TL_INFO, "AsyncEventsThread: Retry Queue signalled"));

                gpRetryQueue->ProcessQueue();

                //
                // Don't want to process RPC so...
                //
                continue;
            }
        }

        //
        // Check to see if xxxShutdown or FreeClientResources
        // is signaling us to exit
        //

        if (*pbExitThread)
        {
            LOG((TL_INFO, "AsyncEventsThread: exit requested."));

            break;
        }

        //
        // Retrieve the data from tapisrv
        //

AsyncEventsThread_clientRequest:

        do
        {
            pMsg->u.Req_Func     = xGetAsyncEvents;
            pMsg->Params[0]      = dwBufSize - sizeof (TAPI32_MSG);

            dwUsedSize = sizeof (TAPI32_MSG);

            RpcTryExcept
            {
                ClientRequest (gphCx, (unsigned char *) pMsg, dwBufSize, (LONG *)&dwUsedSize);
                bRetry = FALSE;
            }
            RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
            {
                bRetry = !(*pbExitThread);
                LOG((
					TL_WARN,
                    "AsyncEventsThread: rpc exception %d handled",
                    RpcExceptionCode()
                    ));
                Sleep (10);
            }
            RpcEndExcept

        } while (bRetry);

#if DBG
        if (
              ( dwUsedSize > dwBufSize )
            ||
              ( pMsg->Params[2] > dwBufSize )
           )
        {
            LOG((TL_ERROR,  "OVERFLOW!!!"));

            LOG((TL_ERROR,  "Watch this..."));
            ClientFree( ClientAlloc( 0x10000 ) );
        }
#endif

        if ((dwUsedSize = pMsg->Params[2]) == 0 &&
            (dwNeededSize = pMsg->Params[1]) != 0)
        {


            //
            // There's a msg waiting for us that is bigger than our buffer,
            // so alloc a larger buffer & try again
            //


            dwNeededSize += sizeof (TAPI32_MSG) + 128;


            LOG((
                TL_INFO,
                "AsyncEventsThread: allocating larger event buf (size=x%x)",
                dwNeededSize
                ));


            
            //
            // deallocate buffer that we currently have
            //

            ClientFree(pBuf);
            pBuf = NULL;
            
            dwBufSize = 0;


            //
            // allocate a bigger memory chunk. try until successful or exit is requested.
            //

            while (!(*pbExitThread))
            {

                //
                // attempt to allocate a bigger memory chunk
                //
                
                pBuf = (LPBYTE)ClientAlloc (dwNeededSize);

                if ((NULL == pBuf))
                {

                    //
                    // no memory. log a message and yeld, giving other apps/
                    // threads a chance to free up some memory
                    //

                    LOG((TL_ERROR,
                        "AsyncEventsThread: failed to allocate memory for a larger event buffer"
                        ));


                    Sleep(10);

                }
                else
                {
                    
                    //
                    // we got our memory. break out of allocation attempt cycle
                    //

                    break;
                }
            }

            
            //
            // did we have any luck allocating memory?
            //

            if (NULL == pBuf)
            {

                //
                // we tried hard but did not get the memory. we did our best. 
                // now break out of message processing loop.
                //
                
                LOG((TL_ERROR,
                    "AsyncEventsThread: failed to allocate memory."
                    ));

                break;
                
            }


            //
            // reallocated memory to get a larger buffer. try to get the message again.
            //

            dwBufSize = dwNeededSize;
            pMsg = (PTAPI32_MSG) pBuf;

            goto AsyncEventsThread_clientRequest;
        }


        //
        // Handle the events
        //

        pAsyncEventMsg = (PASYNCEVENTMSG) (pBuf + sizeof (TAPI32_MSG));

        while (dwUsedSize)
        {
            
            //
            // pAsyncEventMsg->InitContext the 32-bit handle. recover the 
            // pointer value for pInitData from the handle.
            //

            PT3INIT_DATA    pInitData = (PT3INIT_DATA) GetHandleTableEntry(pAsyncEventMsg->InitContext);
            DWORD           dwNumInits;


            LOG((
                TL_INFO,
               "AsyncEventsThread: msg=%ld, hDevice=x%x, OpenContext =x%lx, p1=x%lx, p2=x%lx, p3=x%lx, pInitData=%p",
                pAsyncEventMsg->Msg,
                pAsyncEventMsg->hDevice,
                pAsyncEventMsg->OpenContext,
                pAsyncEventMsg->Param1,
                pAsyncEventMsg->Param2,
                pAsyncEventMsg->Param3,
                pInitData
                ));

            //
            // Special case for UI msgs (not fwd'd to client)
            //

            switch (pAsyncEventMsg->Msg)
            {
            case LINE_CREATEDIALOGINSTANCE:
            {
                LOG((TL_INFO, "AsyncEventsThread: LINE_CREATEDIALOGINSTANCE"));

                DWORD           dwThreadID,
                                dwDataOffset      = pAsyncEventMsg->Param1,
                                dwDataSize        = pAsyncEventMsg->Param2,
                                dwUIDllNameOffset = pAsyncEventMsg->Param3;
                PUITHREADDATA   pUIThreadData;


                if (!(pUIThreadData = (PUITHREADDATA)ClientAlloc (sizeof (UITHREADDATA))))
                {
                    goto LINE_CREATEDIALOGINSTANCE_error;
                }

                if ((pUIThreadData->dwSize = dwDataSize) != 0)
                {
                    if (!(pUIThreadData->pParams = ClientAlloc (dwDataSize)))
                    {
                        goto LINE_CREATEDIALOGINSTANCE_error;
                    }

                    CopyMemory(
                        pUIThreadData->pParams,
                        ((LPBYTE)pAsyncEventMsg) + dwDataOffset,
                        dwDataSize
                        );
                }

                if (!(pUIThreadData->hUIDll = TAPILoadLibraryW(
                        (PWSTR)(((LPBYTE) pAsyncEventMsg) +
                                  dwUIDllNameOffset)
                        )))
                {
                    LOG((
                        TL_ERROR,
                        "LoadLibraryW(%ls) failed, err=%d",
                        ((LPBYTE) pAsyncEventMsg) + dwUIDllNameOffset,
                        GetLastError()
                        ));

                    goto LINE_CREATEDIALOGINSTANCE_error;
                }

                if (!(pUIThreadData->pfnTUISPI_providerGenericDialog =
                        (TUISPIPROC) GetProcAddress(
                            pUIThreadData->hUIDll,
                            (LPCSTR) gszTUISPI_providerGenericDialog
                            )))
                {
                    LOG((
                        TL_INFO,
                        "GetProcAddr(TUISPI_providerGenericDialog) failed"
                        ));

                    goto LINE_CREATEDIALOGINSTANCE_error;
                }

                pUIThreadData->pfnTUISPI_providerGenericDialogData =
                    (TUISPIPROC) GetProcAddress(
                        pUIThreadData->hUIDll,
                        (LPCSTR) gszTUISPI_providerGenericDialogData
                        );

                if (!(pUIThreadData->hEvent = CreateEvent(
                        (LPSECURITY_ATTRIBUTES) NULL,
                        TRUE,   // manual reset
                        FALSE,  // non-signaled
                        NULL    // unnamed
                        )))
                {
                    goto LINE_CREATEDIALOGINSTANCE_error;
                }

                pUIThreadData->htDlgInst = (HTAPIDIALOGINSTANCE)
                    pAsyncEventMsg->hDevice;


                //
                // Safely add this instance to the global list
                // (check if dwNumInits == 0, & if so fail)
                //
                EnterCriticalSection( &gcsTapiObjectArray );

                dwNumInits = CTAPI::m_sTAPIObjectArray.GetSize();
    
                LeaveCriticalSection ( &gcsTapiObjectArray );

                EnterCriticalSection (&gcsTapisrvCommunication);

                if (dwNumInits != 0)
                {
                    if ((pUIThreadData->pNext = gpUIThreadInstances))
                    {
                        pUIThreadData->pNext->pPrev = pUIThreadData;
                    }

                    gpUIThreadInstances  = pUIThreadData;
                    LeaveCriticalSection (&gcsTapisrvCommunication);
                }
                else
                {
                    LeaveCriticalSection (&gcsTapisrvCommunication);
                    goto LINE_CREATEDIALOGINSTANCE_error;
                }

                if ((pUIThreadData->hThread = CreateThread(
                        (LPSECURITY_ATTRIBUTES) NULL,
                        0,
                        (LPTHREAD_START_ROUTINE) UIThread,
                        (LPVOID) pUIThreadData,
                        0,
                        &dwThreadID
                        )))
                {
                    goto AsyncEventsThread_decrUsedSize;
                }


                //
                // If here an error occured, so safely remove the ui
                // thread data struct from the global list
                //

                EnterCriticalSection (&gcsTapisrvCommunication);

                if (pUIThreadData->pNext)
                {
                    pUIThreadData->pNext->pPrev = pUIThreadData->pPrev;
                }

                if (pUIThreadData->pPrev)
                {
                    pUIThreadData->pPrev->pNext = pUIThreadData->pNext;
                }
                else
                {
                    gpUIThreadInstances = pUIThreadData->pNext;
                }

                LeaveCriticalSection (&gcsTapisrvCommunication);


LINE_CREATEDIALOGINSTANCE_error:

                if (pUIThreadData)
                {
                    if (pUIThreadData->pParams)
                    {
                        ClientFree (pUIThreadData->pParams);
                    }

                    if (pUIThreadData->hUIDll)
                    {
                        FreeLibrary (pUIThreadData->hUIDll);
                    }

                    if (pUIThreadData->hEvent)
                    {
                        CloseHandle (pUIThreadData->hEvent);
                    }

                    ClientFree (pUIThreadData);
                }

                {
                    FUNC_ARGS funcArgs =
                    {
                        MAKELONG (LINE_FUNC | SYNC | 1, xFreeDialogInstance),

                        {
                            pAsyncEventMsg->hDevice
                        },

                        {
                            Dword
                        }
                    };


                    DOFUNC (&funcArgs, "FreeDialogInstance");
                }

                goto AsyncEventsThread_decrUsedSize;
            }
            case LINE_SENDDIALOGINSTANCEDATA:
            {
                LOG((TL_INFO, "AsyncEventsThread: LINE_SENDDIALOGINSTANCEDATA"));

                PUITHREADDATA       pUIThreadData = gpUIThreadInstances;
                HTAPIDIALOGINSTANCE htDlgInst = (HTAPIDIALOGINSTANCE)
                                        pAsyncEventMsg->hDevice;


                EnterCriticalSection (&gcsTapisrvCommunication);

                while (pUIThreadData)
                {
                    if (pUIThreadData->htDlgInst == htDlgInst)
                    {
                        WaitForSingleObject (pUIThreadData->hEvent, INFINITE);

                        ((TUIGDDPROC)(*pUIThreadData->pfnTUISPI_providerGenericDialogData))(
                            htDlgInst,
                            ((LPBYTE) pAsyncEventMsg) +
                                pAsyncEventMsg->Param1,   // data offset
                            pAsyncEventMsg->Param2        // data size
                            );

                        break;
                    }

                    pUIThreadData = pUIThreadData->pNext;
                }

                LeaveCriticalSection (&gcsTapisrvCommunication);

                goto AsyncEventsThread_decrUsedSize;
            }
            }


            //
            // Enter the critical section so we've exclusive access
            // to the init data, & verify it
            //

            EnterCriticalSection (&gcsTapisrvCommunication);


            //
            // see if pInitData is null
            //

            if (NULL == pInitData)
            {
                LOG((TL_WARN, "AsyncEventsThread: pInitInst is NULL. discarding msg"));
                goto AsyncEventsThread_leaveCritSec;

            }


            //
            // properly aligned?
            //

            if ((ULONG_PTR) pInitData & 0x7)
            {
                LOG((TL_ERROR, 
                    "AsyncEventsThread: misaligned pInitInst[%p]. discarding msg", pInitData));

                goto AsyncEventsThread_leaveCritSec;
            }

            
            //
            // points to unreadeable memory?
            //

            if ( IsBadReadPtr(pInitData, sizeof(T3INIT_DATA)) )
            {
                LOG((TL_ERROR, 
                    "AsyncEventsThread: pInitData[%p] points to unreadable memory. discarding msg", pInitData));

                goto AsyncEventsThread_leaveCritSec;
            }


            //
            // appears to have valid data? 
            //
            // just in case the pointer became invalid since we checked, do 
            // this in try/catch
            //

            __try
            {

                if (pInitData->dwKey != INITDATA_KEY )
                {
                    LOG((TL_ERROR, 
                        "AsyncEventsThread: Bad pInitInst[%p], key[%ld] discarding msg",
                        pInitData, pInitData->dwKey));

                    goto AsyncEventsThread_leaveCritSec;
                }

            }
            __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                    EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
            {
                LOG((TL_ERROR, "AsyncEventsThread: exception. bad pInitData[%p]", pInitData ));

                goto AsyncEventsThread_leaveCritSec;
            }


            //
            // Special case for PROXYREQUEST
            //

            if (pAsyncEventMsg->Msg == LINE_PROXYREQUEST)
            {
                LOG((TL_INFO, "AsyncEventsThread: LINE_PROXYREQUEST"));

                PPROXYREQUESTHEADER     pProxyRequestHeader;
                LPLINEPROXYREQUEST      pProxyRequest = (LPLINEPROXYREQUEST)
                                            (pAsyncEventMsg + 1),
                                        pProxyRequestApp;


                switch (pProxyRequest->dwRequestType)
                {
                case LINEPROXYREQUEST_SETAGENTGROUP:
                case LINEPROXYREQUEST_SETAGENTSTATE:
                case LINEPROXYREQUEST_SETAGENTACTIVITY:
                case LINEPROXYREQUEST_AGENTSPECIFIC:
                case LINEPROXYREQUEST_CREATEAGENT:
                case LINEPROXYREQUEST_CREATEAGENTSESSION:
                case LINEPROXYREQUEST_SETAGENTMEASUREMENTPERIOD:
                case LINEPROXYREQUEST_SETAGENTSESSIONSTATE:
                case LINEPROXYREQUEST_SETQUEUEMEASUREMENTPERIOD:
                case LINEPROXYREQUEST_SETAGENTSTATEEX:


                    //
                    // For these msgs the proxy request as received from
                    // the tapisrv already contains the exact bits we want
                    // to pass on to the app, so we just alloc a buffer of
                    // the same size (plus a little extra for the key at
                    // the head of the buffer) and copy the data to it
                    //

                    if (!(pProxyRequestHeader = (PPROXYREQUESTHEADER)ClientAlloc(
                            sizeof (PROXYREQUESTHEADER) + pProxyRequest->dwSize
                            )))
                    {
                     
                        //
                        // if we could not allocate memory, log a message and break out.
                        //

                        LOG((TL_ERROR, 
                            "AsyncEventsThread: failed to allocate memory for proxy request"));

                        goto AsyncEventsThread_leaveCritSec;
                    }

                    pProxyRequestApp = (LPLINEPROXYREQUEST)
                        (pProxyRequestHeader + 1);

                    CopyMemory(
                        pProxyRequestApp,
                        pProxyRequest,
                        pProxyRequest->dwSize
                        );

                    break;

                case LINEPROXYREQUEST_GETAGENTCAPS:
                case LINEPROXYREQUEST_GETAGENTSTATUS:
                case LINEPROXYREQUEST_GETAGENTACTIVITYLIST:
                case LINEPROXYREQUEST_GETAGENTGROUPLIST:
                case LINEPROXYREQUEST_GETQUEUEINFO:
                case LINEPROXYREQUEST_GETGROUPLIST:
                case LINEPROXYREQUEST_GETQUEUELIST:

                case LINEPROXYREQUEST_GETAGENTINFO:
                case LINEPROXYREQUEST_GETAGENTSESSIONINFO:
                case LINEPROXYREQUEST_GETAGENTSESSIONLIST:

                    //
                    // For these msgs tapisrv only embedded the dwTotalSize
                    // field of the corresponding structure (to save having
                    // to send us a bunch of unused bits), so we want to
                    // increase the pProxyRequest->dwSize by the dwTotalSize
                    // - sizeof (DWORD), alloc a buffer (including a little
                    // extra space for the key at the head of the buffer),
                    // and rebuild the request
                    //

                    if ( pProxyRequest->dwRequestType ==
                         LINEPROXYREQUEST_GETGROUPLIST )
                    {
                        pProxyRequest->dwSize +=
                              pProxyRequest->GetGroupList.GroupList.dwTotalSize;
                    }
                    else if ( pProxyRequest->dwRequestType ==
                         LINEPROXYREQUEST_GETQUEUELIST )
                    {
                        pProxyRequest->dwSize +=
                              pProxyRequest->GetQueueList.QueueList.dwTotalSize;
                    }
                    else
                    {
                        //
                        // all of the rest of the structures have the
                        // same format
                        //
                        pProxyRequest->dwSize +=
                              pProxyRequest->GetAgentCaps.AgentCaps.dwTotalSize;
                    }

                    if (!(pProxyRequestHeader = (PROXYREQUESTHEADER *)ClientAlloc(
                            sizeof (PROXYREQUESTHEADER) + pProxyRequest->dwSize
                            )))
                    {
                     
                        //
                        // if we could not allocate memory, log a message and break out.
                        //

                        LOG((TL_ERROR, 
                            "AsyncEventsThread: failed to allocate memory for proxy request."));

                        goto AsyncEventsThread_leaveCritSec;

                    }

                    pProxyRequestApp = (LPLINEPROXYREQUEST)
                        (pProxyRequestHeader + 1);


                    //
                    // The following will copy the non-union fields in the
                    // proxy message, as well as the first two DWORD in the
                    // union (which currently are the dwAddressID and the
                    // dwTotalSize field of the corresponding structure)
                    //

                    if ( pProxyRequest->dwRequestType ==
                         LINEPROXYREQUEST_GETGROUPLIST )
                    {
                        CopyMemory(
                                   pProxyRequestApp,
                                   pProxyRequest,
                                   8 * sizeof (DWORD)
                                  );
                    }
                    else if ( pProxyRequest->dwRequestType ==
                         LINEPROXYREQUEST_GETQUEUELIST )
                    {
                        CopyMemory(
                                   pProxyRequestApp,
                                   pProxyRequest,
                                   8 * sizeof (DWORD) + sizeof(GUID)
                                  );
                    }
                    else
                    {
                        CopyMemory(
                                   pProxyRequestApp,
                                   pProxyRequest,
                                   9 * sizeof (DWORD)
                                  );
                    }


                    //
                    // Relocate the machine & user names to the end of the
                    // structure
                    //

                    pProxyRequestApp->dwClientMachineNameOffset =
                        pProxyRequest->dwSize -
                            pProxyRequest->dwClientMachineNameSize;

                    wcscpy(
                        (WCHAR *)(((LPBYTE) pProxyRequestApp) +
                            pProxyRequestApp->dwClientMachineNameOffset),
                        (WCHAR *)(((LPBYTE) pProxyRequest) +
                            pProxyRequest->dwClientMachineNameOffset)
                        );

                    pProxyRequestApp->dwClientUserNameOffset =
                        pProxyRequestApp->dwClientMachineNameOffset -
                            pProxyRequest->dwClientUserNameSize;

                    wcscpy(
                        (WCHAR *)(((LPBYTE) pProxyRequestApp) +
                            pProxyRequestApp->dwClientUserNameOffset),
                        (WCHAR *)(((LPBYTE) pProxyRequest) +
                            pProxyRequest->dwClientUserNameOffset)
                        );

                    break;
                }

                pProxyRequestHeader->dwKey      = TPROXYREQUESTHEADER_KEY;
                pProxyRequestHeader->dwInstance = pAsyncEventMsg->Param1;

                pAsyncEventMsg->Param1 = (ULONG_PTR) pProxyRequestApp;
            }


            //
            // Call the post processing proc if there is one
            //

            if (pAsyncEventMsg->fnPostProcessProcHandle)
            {
                LOG((TL_INFO, 
                    "AsyncEventsThread: calling postprocessing function,"
                    "function index (pAsyncEventMsg->fnPostProcessProcHandle) = "
                    "[%d]", pAsyncEventMsg->fnPostProcessProcHandle));
             
                (*(gPostProcessingFunctions[
                    pAsyncEventMsg->fnPostProcessProcHandle]))(pAsyncEventMsg);

            }


            LOG((TL_INFO, "AsyncEventsThread: calling ProcessMessage()"));

            if FAILED(ProcessMessage(
                           pInitData,
                           pAsyncEventMsg
                          ) )
            {
                LOG((TL_INFO, "AsyncEventsThread: ProcessMessage()"
                                          " did not succeed. requeueing..."));

                BOOL bQueueSuccess = gpRetryQueue->QueueEvent(pAsyncEventMsg);

                if (!bQueueSuccess)
                {

                    //
                    // QueueEvent failed to allocate resources needed to queue 
                    // the message. other than log a message, there is nothing 
                    // much we can do.
                    //

                    LOG((TL_ERROR, "AsyncEventsThread: ProcessMessage() - "
                                  "failed to requeue item"));
                }
            }


AsyncEventsThread_leaveCritSec:

//            LOG((TL_INFO, "AsyncEventsThread: releasing critical section (0x%08lx)", gcsTapisrvCommunication));
            LeaveCriticalSection (&gcsTapisrvCommunication);

AsyncEventsThread_decrUsedSize:

            dwUsedSize -= pAsyncEventMsg->TotalSize;

            pAsyncEventMsg = (PASYNCEVENTMSG)
                ((LPBYTE) pAsyncEventMsg + pAsyncEventMsg->TotalSize);
#if DBG
            if ( (LONG)dwUsedSize < 0 )
            {
                LOG((TL_ERROR, "dwUsedSize went negative!!!"));
            }
#endif
        } // END while (dwUsedSize)

//        LOG((TL_INFO, "AsyncEventsThread: Done processing TAPISRV message block"));

        // We've now processed all the messages in the last RPC block from TAPISRV
        // Now lets process the Re-try Queue

        gpRetryQueue->ProcessQueue();

    } // end of message reading/processing loop


    
    //
    // the thread is about to exit, we don't want to leave anything behind in
    // the retry queue, so close the queue for new entries and process all the 
    // entries that are already in there
    //


    //
    // mark the queue as closed for new entries
    //

    gpRetryQueue->CloseForNewEntries();


    //
    // process elements still remaining in the queue
    //

    gpRetryQueue->ProcessQueue();




    {
        //
        // Free our resources, and then exit
        //

        HANDLE  hTapi32 = pAsyncEventsThreadParams->hTapi32;


        if (pAsyncEventsThreadParams->hWow32)
        {
            FreeLibrary ((HINSTANCE)(pAsyncEventsThreadParams->hWow32));
        }

        ClientFree (pBuf);
        ClientFree (pAsyncEventsThreadParams);

        CoUninitialize();

        LOG((TL_TRACE, "AsyncEventsThread: exit"));

        FreeLibraryAndExitThread ((HINSTANCE)hTapi32, 0);
    }

}


BOOL
PASCAL
IsBadDwordPtr(
    LPDWORD p
    )
{

    DWORD dwError;


    __try
    {
        *p = *p + 1;
    }
    __except ((((dwError = GetExceptionCode()) == EXCEPTION_ACCESS_VIOLATION) ||
             dwError == EXCEPTION_DATATYPE_MISALIGNMENT) ?
            EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
    {
        return TRUE;
    }


    *p = *p - 1;
    return FALSE;
}


BOOL
WINAPI
GrowBuf(
    LPBYTE *ppBuf,
    LPDWORD pdwBufSize,
    DWORD   dwCurrValidBytes,
    DWORD   dwBytesToAdd
    )
{
    DWORD   dwCurrBufSize, dwNewBufSize;
    LPBYTE  pNewBuf;


    //
    // Try to get a new buffer big enough to hold everything
    //

    for(
        dwNewBufSize = 2 * (dwCurrBufSize = *pdwBufSize);
        dwNewBufSize < (dwCurrBufSize + dwBytesToAdd);
        dwNewBufSize *= 2
        );

    if (!(pNewBuf = (LPBYTE)ClientAlloc (dwNewBufSize)))
    {
        return FALSE;
    }

    //
    // Copy the "valid" bytes in the old buf to the new buf,
    // then free the old buf
    //

    CopyMemory (pNewBuf, *ppBuf, dwCurrValidBytes);

    ClientFree (*ppBuf);


    //
    // Reset the pointers to the new buf & buf size
    //

    *ppBuf = pNewBuf;
    *pdwBufSize = dwNewBufSize;

    return TRUE;
}


PCLIENT_THREAD_INFO
WINAPI
GetTls(
    void
    )
{
    PCLIENT_THREAD_INFO pClientThreadInfo;


    if (!(pClientThreadInfo = (PCLIENT_THREAD_INFO)TlsGetValue (gdwTlsIndex)))
    {
        pClientThreadInfo = (PCLIENT_THREAD_INFO)
            ClientAlloc (sizeof(CLIENT_THREAD_INFO));

        if (!pClientThreadInfo)
        {
            return NULL;
        }

        pClientThreadInfo->pBuf = (unsigned char *)ClientAlloc (INITIAL_CLIENT_THREAD_BUF_SIZE);

        if (!pClientThreadInfo->pBuf)
        {
            ClientFree (pClientThreadInfo);

            return NULL;
        }

        pClientThreadInfo->dwBufSize = INITIAL_CLIENT_THREAD_BUF_SIZE;

        TlsSetValue (gdwTlsIndex, (LPVOID) pClientThreadInfo);

        EnterCriticalSection (&gTlsCriticalSection);

        InsertHeadList (&gTlsListHead, &pClientThreadInfo->TlsList);

        LeaveCriticalSection (&gTlsCriticalSection);
    }

    return pClientThreadInfo;
}

#if DBG

LONG
WINAPI
DoFunc(
    PFUNC_ARGS  pFuncArgs,
    char       *pszFuncName
    )

#else

LONG
WINAPI
DoFunc(
    PFUNC_ARGS  pFuncArgs
    )

#endif
{
    DWORD   dwFuncClassErrorIndex = (pFuncArgs->Flags & 0x00000030) >> 4;
    LONG    lResult;
    BOOL    bCopyOnSuccess = FALSE;
    DWORD   i, j, dwUsedSize, dwNeededSize;
    ULONG_PTR   Value;

    PCLIENT_THREAD_INFO pTls;

#if DBG
    LOG((TL_INFO, "About to call %s", pszFuncName));
#endif


    //
    // Get the tls
    //

    if (!(pTls = GetTls()))
    {
        lResult = gaNoMemErrors[dwFuncClassErrorIndex];
        goto DoFunc_return;
    }

    //
    // The first arg of all async msg blocks is a remote request id; set
    // this to zero to indicate that we are a local client (not remotesp)
    //

    if (pFuncArgs->Flags & ASYNC)
    {
        ((PTAPI32_MSG) pTls->pBuf)->Params[0] = 0;
    }


    //
    // Validate all the func args
    //

    dwNeededSize = dwUsedSize = ALIGN (sizeof (TAPI32_MSG));

    for(
        i = 0, j = (pFuncArgs->Flags & ASYNC ? 1 : 0);
        i < (pFuncArgs->Flags & NUM_ARGS_MASK);
        i++, j++
        )
    {

        //
        // extract the ptr-sized value from the arguments
        //

        Value = pFuncArgs->Args[i];
            
        ((PTAPI32_MSG) pTls->pBuf)->Params[j] = pFuncArgs->Args[i];

        switch (pFuncArgs->ArgTypes[i])
        {

        case Dword:


            //
            // make sure the data is 32bit at most
            //
            
            
            ((PTAPI32_MSG) pTls->pBuf)->Params[j] = DWORD_CAST(pFuncArgs->Args[i]);


            continue;

        case lpDword:

            

            if (IsBadDwordPtr ((LPDWORD) Value))
            {
                LOG((TL_ERROR, "Bad lpdword in dofunc"));
                lResult = gaInvalPtrErrors[dwFuncClassErrorIndex];
                goto DoFunc_return;
            }


            //
            // we don't need to send the actual pointer. but send the value we point to.
            //

            ((PTAPI32_MSG) pTls->pBuf)->Params[j] = *((DWORD*)Value);

            bCopyOnSuccess = TRUE;

            continue;


        case hXxxApp_NULLOK:
        case hXxxApp:
        {
            //
            // Verify that the hXxxApp is a pointer to a valid InitData
            // struct, then retrieve the real hXxxApp from that struct.
            // If the hXxxApp is bad, pass the server 0xffffffff so that
            // it can figure out whether to return an UNINITIALIZED error
            // or a INVALAPPHANDLE error.
            //

            DWORD   dwError;


            if (
                  (0 == pFuncArgs->Args[i])
                &&
                  (hXxxApp_NULLOK == pFuncArgs->ArgTypes[i])
               )
            {
                //
                // Looks good to me...
                //

                continue;
            }

            __try
            {

                //
                // Value contains the 32-bit handle to be passed to tapisrv
                //
                // recover the pointer corresponding to the 32-bit handle in Value
                //

                PT3INIT_DATA pInitData = (PT3INIT_DATA) GetHandleTableEntry(Value);

                if (pInitData->dwKey != INITDATA_KEY)
                {
                    LOG((TL_ERROR, "DoFunc: Bad hxxxapp [%p] in dofunc", pInitData));
                    ((PTAPI32_MSG) pTls->pBuf)->Params[j] = 0xffffffff;
                }
                else
                {
                    ((PTAPI32_MSG) pTls->pBuf)->Params[j] = pInitData->hXxxApp;
                }
            }
            __except ((((dwError = GetExceptionCode())
                        == EXCEPTION_ACCESS_VIOLATION) ||
                     dwError == EXCEPTION_DATATYPE_MISALIGNMENT) ?
                    EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
            {
                 LOG((TL_ERROR, "DoFunc: Bad hxxxapp2 in dofunc (0x%08lx)", dwError));
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = 0xffffffff;
            }

            continue;
        }
        case Hwnd:

            if (!IsWindow ((HWND) Value))
            {
                LOG((TL_ERROR, "DoFunc: Bad hWnd in dofunc"));
                lResult = gaInvalHwndErrors[dwFuncClassErrorIndex];
                goto DoFunc_return;
            }

            continue;


//        case lpsz:
        case lpszW:

            //
            // Check if Value is a valid string ptr and if so
            // copy the contents of the string to the extra data
            // buffer passed to the server
            //

            __try
            {
                DWORD   n = (lstrlenW((WCHAR *) Value) + 1) * sizeof(WCHAR),
                        nAligned = ALIGN (n);


                if ((nAligned + dwUsedSize) > pTls->dwBufSize)
                {
                    if (!GrowBuf(
                            &pTls->pBuf,
                            &pTls->dwBufSize,
                            dwUsedSize,
                            nAligned
                            ))
                    {
                        lResult = gaNoMemErrors[dwFuncClassErrorIndex];
                        goto DoFunc_return;
                    }
                }

                CopyMemory (pTls->pBuf + dwUsedSize, (LPBYTE) Value, n);


                //
                // Pass the server the offset of the string in the var data
                // portion of the buffer
                //

                ((PTAPI32_MSG) pTls->pBuf)->Params[j] =
                    dwUsedSize - sizeof (TAPI32_MSG);


                //
                // Increment the total number of data bytes
                //

                dwUsedSize   += nAligned;
                dwNeededSize += nAligned;
            }
            __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                    EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
            {
                lResult = gaInvalPtrErrors[dwFuncClassErrorIndex];
                goto DoFunc_return;
            }

            continue;

        case lpGet_Struct:
        case lpGet_SizeToFollow:
        {
            BOOL  bSizeToFollow = (pFuncArgs->ArgTypes[i]==lpGet_SizeToFollow);
            DWORD dwSize;


            if (bSizeToFollow)
            {
#if DBG
                //
                // Check to make sure the following arg is of type Size
                //

                if ((i == ((pFuncArgs->Flags & NUM_ARGS_MASK) - 1)) ||
                    (pFuncArgs->ArgTypes[i + 1] != Size))
                {
                    LOG((
                        TL_ERROR,
                        "DoFunc: error, lpGet_SizeToFollow !followed by Size"
                        ));

                    lResult = gaOpFailedErrors[dwFuncClassErrorIndex];
                    goto DoFunc_return;
                }
#endif
                dwSize = pFuncArgs->Args[i + 1];
            }
            else
            {
                DWORD   dwError;

                __try
                {
                    dwSize = *((LPDWORD) Value);
                }
                __except ((((dwError = GetExceptionCode())
                            == EXCEPTION_ACCESS_VIOLATION) ||
                         dwError == EXCEPTION_DATATYPE_MISALIGNMENT) ?
                        EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
                {
                    LOG((TL_ERROR, "Bad get struct/size in dofunc"));
                    lResult = gaInvalPtrErrors[dwFuncClassErrorIndex];
                    goto DoFunc_return;
                }

            }

            if (TAPIIsBadWritePtr ((LPVOID) Value, dwSize))
            {
                LOG((TL_ERROR, "Bad get size/struct2 in dofunc"));
                lResult = gaInvalPtrErrors[dwFuncClassErrorIndex];
                goto DoFunc_return;
            }


            if (bSizeToFollow)
            {
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = TAPI_NO_DATA;
                ((PTAPI32_MSG) pTls->pBuf)->Params[++j] = pFuncArgs->Args[++i];
            }
            else
            {
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = dwSize;
            }


            //
            // Now set the bCopyOnSuccess flag to indicate that we've data
            // to copy back on successful completion, and add to the
            // dwNeededSize field
            //

            bCopyOnSuccess = TRUE;

            dwNeededSize += ALIGN (dwSize);

            continue;
        }
        case lpSet_Struct:
        case lpSet_SizeToFollow:
        {
            BOOL  bSizeToFollow = (pFuncArgs->ArgTypes[i]==lpSet_SizeToFollow);
            DWORD dwSize, dwError, dwSizeAligned;

#if DBG
            //
            // Check to make sure the following arg is of type Size
            //

            if (bSizeToFollow &&
                ((i == ((pFuncArgs->Flags & NUM_ARGS_MASK) - 1)) ||
                (pFuncArgs->ArgTypes[i + 1] != Size)))
            {
                LOG((
                    TL_ERROR,
                    "DoFunc: error, lpSet_SizeToFollow !followed by Size"
                    ));

                lResult = gaOpFailedErrors[dwFuncClassErrorIndex];
                goto DoFunc_return;
            }
#endif
            __try
            {
                //
                // First determine the data size & if the ptr is bad
                //

                dwSize = (bSizeToFollow ? pFuncArgs->Args[i + 1] :
                     *((LPDWORD) Value));

                if (IsBadReadPtr ((LPVOID) Value, dwSize))
                {
                    LOG((TL_ERROR, "Bad set size/struct in dofunc"));
                    lResult = gaInvalPtrErrors[dwFuncClassErrorIndex];
                    goto DoFunc_return;
                }

                dwSizeAligned = ALIGN (dwSize);


                //
                // Special case if the size isn't even big enough to pass
                // over a complete DWORD for the dwTotalSize field
                //

                if (!bSizeToFollow && (dwSize < sizeof (DWORD)))
                {
                      static DWORD dwZeroTotalSize = 0;


                      dwSize = dwSizeAligned = sizeof (DWORD);
                      Value = (ULONG_PTR) &dwZeroTotalSize;

//                    LOG((TL_1, "Bad set size/struct2 in dofunc"));
//                    lResult = gaStructTooSmallErrors[dwFuncClassErrorIndex];
//                    goto DoFunc_return;
                }


                //
                // Grow the buffer if necessary, & do the copy
                //

                if ((dwSizeAligned + dwUsedSize) > pTls->dwBufSize)
                {
                    if (!GrowBuf(
                            &pTls->pBuf,
                            &pTls->dwBufSize,
                            dwUsedSize,
                            dwSizeAligned
                            ))
                    {
                        LOG((TL_ERROR, "Nomem set size/struct in dofunc"));
                        lResult = gaNoMemErrors[dwFuncClassErrorIndex];
                        goto DoFunc_return;
                    }
                }

                CopyMemory (pTls->pBuf + dwUsedSize, (LPBYTE) Value, dwSize);
            }
            __except ((((dwError = GetExceptionCode())
                        == EXCEPTION_ACCESS_VIOLATION) ||
                     dwError == EXCEPTION_DATATYPE_MISALIGNMENT) ?
                    EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
            {
                LOG((TL_ERROR, "Bad pointer in get size/struct in dofunc"));
                lResult = gaInvalPtrErrors[dwFuncClassErrorIndex];
                goto DoFunc_return;
            }


            //
            // Pass the server the offset of the data in the var data
            // portion of the buffer
            //

            if (dwSize)
            {
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] =
                    dwUsedSize - sizeof (TAPI32_MSG);
            }
            else
            {
                ((PTAPI32_MSG) pTls->pBuf)->Params[j] = TAPI_NO_DATA;
            }


            //
            // Increment the dwXxxSize vars appropriately
            //

            dwUsedSize   += dwSizeAligned;
            dwNeededSize += dwSizeAligned;


            //
            // Since we already know the next arg (Size) just handle
            // it here so we don't have to run thru the loop again
            //

            if (bSizeToFollow)
            {
                ((PTAPI32_MSG) pTls->pBuf)->Params[++j] = pFuncArgs->Args[++i];
            }

            continue;
        }
#if DBG
        case Size:

            LOG((TL_ERROR, "DoFunc: error, hit case Size"));

            continue;

        default:

            LOG((TL_ERROR, "DoFunc: error, unknown arg type"));

            continue;
#endif
        } // switch

    } // for


    //
    // Now make the request
    //

    if (dwNeededSize > pTls->dwBufSize)
    {
        if (!GrowBuf(
                &pTls->pBuf,
                &pTls->dwBufSize,
                dwUsedSize,
                dwNeededSize - pTls->dwBufSize
                ))
        {
            lResult = gaNoMemErrors[dwFuncClassErrorIndex];
            goto DoFunc_return;
        }
    }

    ((PTAPI32_MSG) pTls->pBuf)->u.Req_Func = (DWORD)HIWORD(pFuncArgs->Flags);

    {
        DWORD   dwRetryCount = 0;
        BOOL    bReinitResource;

        do
        {
            bReinitResource = FALSE;
            RpcTryExcept
            {
                ClientRequest (gphCx, pTls->pBuf, dwNeededSize, (LONG *)&dwUsedSize);
                lResult = ((PTAPI32_MSG) pTls->pBuf)->u.Ack_ReturnValue;
                  if (lResult == TAPIERR_INVALRPCCONTEXT)
                {
                    if (dwRetryCount ++ >= gdwMaxNumRequestRetries)
                    {
                        bReinitResource = FALSE;
                        lResult = gaOpFailedErrors[dwFuncClassErrorIndex];
                        dwRetryCount = 0;
                    }
                    else
                    {
                        bReinitResource = TRUE;
                    }
                }
                else
                {
                    bReinitResource = FALSE;
                    dwRetryCount = 0;
                }
                
            }
            RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
            {
                unsigned long rpcException = RpcExceptionCode();

                if (rpcException == RPC_S_SERVER_TOO_BUSY)
                {
                    if (dwRetryCount++ < gdwMaxNumRequestRetries)
                    {
                        Sleep (gdwRequestRetryTimeout);
                    }
                    else
                    {
                        dwRetryCount = 0;
                        lResult = gaOpFailedErrors[dwFuncClassErrorIndex];
                    }
                }
                else if ((rpcException == RPC_S_SERVER_UNAVAILABLE) ||
                         (rpcException == RPC_S_CALL_FAILED_DNE))
                {
                    if (dwRetryCount ++ >= gdwMaxNumRequestRetries)
                    {
                        bReinitResource = FALSE;
                        lResult = gaOpFailedErrors[dwFuncClassErrorIndex];
                        dwRetryCount = 0;
                    }
                    else
                    {
                        bReinitResource = TRUE;
                    }
                }
                else
                {
                    LOG((TL_ERROR, "DoFunc: rpcException # %d", rpcException));
                    lResult = gaOpFailedErrors[dwFuncClassErrorIndex];
                    dwRetryCount = 0;
                }
            }
            RpcEndExcept
            
            if (bReinitResource)
            {
                FreeClientResources();
                AllocClientResources(dwFuncClassErrorIndex);
            }

        } while (dwRetryCount != 0);
    }

// note: 99.99% of the time this result dump will == the one at end of the
// func (only when ptrs have gone bad will the result differ), no reason
// to dump 2x unless doing internal dbgging
//
    LOG((TL_INFO, "DoFunc: back from srv- return code=0x%08lx", lResult));


    //
    // If request completed successfully and the bCopyOnSuccess flag
    // is set then we need to copy data back to client buffer(s)
    //

    if ((lResult == TAPI_SUCCESS) && bCopyOnSuccess)
    {
        for (i = 0, j = 0; i < (pFuncArgs->Flags & NUM_ARGS_MASK); i++, j++)
        {
            PTAPI32_MSG pMsg = (PTAPI32_MSG) pTls->pBuf;

            DWORD dwServerData = pMsg->Params[j];
 
            switch (pFuncArgs->ArgTypes[i])
            {
            case Dword:
            case Hwnd:
//            case lpsz:
            case lpszW:
            case lpSet_Struct:

                continue;

            case lpDword:

                __try
                {
                    //
                    // Fill in the pointer with the return value
                    //

                    *((LPDWORD) pFuncArgs->Args[i]) = dwServerData;

                }
                __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                        EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
                {
                    //
                    // this should really never happen -- the memory was 
                    // checked before the call to tapisrv ws made
                    //

                    _ASSERTE(FALSE);

                    lResult = gaInvalPtrErrors[dwFuncClassErrorIndex];
                    goto DoFunc_return;
                }

                continue;


            case lpGet_SizeToFollow:

                __try
                {
                    //
                    // Fill in the pointer with the return value
                    //
                    
                    CopyMemory(
                        (LPBYTE) pFuncArgs->Args[i],
                        pTls->pBuf + dwServerData + sizeof(TAPI32_MSG),
                        pMsg->Params[j+1]
                        );
                }
                __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                        EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
                {


                    LOG((TL_ERROR, "DoFunc: lpGet_SizeToFollow MemCopy failed"));


                    //
                    // we made sure the memory was writeable before the call to tapisrv
                    // if we catch an exception here, that means that tapisrv did not 
                    // return us proper information. in which case we cannot make any 
                    // assumtions about its state, so we are not responsible 
                    // for cleaning it up.
                    //

                    lResult = gaInvalPtrErrors[dwFuncClassErrorIndex];
                    goto DoFunc_return;
                }


                //
                // Increment i (and j, since Size passed as arg in msg)
                // to skip following Size arg in pFuncArgs->Args
                //

                i++;
                j++;

                continue;

            case lpSet_SizeToFollow:

                //
                // Increment i (and j, since Size passed as arg in msg)
                // to skip following Size arg in pFuncArgs->Args
                //

                i++;
                j++;

                continue;

            case lpGet_Struct:

                __try
                {
                    //
                    // Params[j] contains the offset in the var data
                    // portion of pTls->pBuf of some TAPI struct.
                    // Get the dwUsedSize value from this struct &
                    // copy that many bytes from pTls->pBuf to client buf
                    //

                    if (dwServerData != TAPI_NO_DATA)
                    {

                        LPDWORD pStruct;


                        pStruct = (LPDWORD) (pTls->pBuf + sizeof(TAPI32_MSG) +
                            dwServerData);


                        CopyMemory(
                            (LPBYTE) pFuncArgs->Args[i],
                            (LPBYTE) pStruct,
                            *(pStruct + 2)      // ptr to dwUsedSize field
                            );

                    }
                }
                __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                        EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
                {
                    LOG((TL_WARN, "DoFunc: lpGet_Struct MemCopy failed"));


                    //
                    // we made sure the memory of the size of the struct was 
                    // writeable before the call to tapisrv if we catch an 
                    // exception here, that most likely means that tapisrv 
                    // did not return us proper information. in which case 
                    // we cannot make any assumtions about its state, or 
                    // make an effort clean up tapisrv's state.
                    //

                    lResult = gaInvalPtrErrors[dwFuncClassErrorIndex];
                    goto DoFunc_return;
                }

                continue;

            default:

                continue;
            }
        }
    }
//    else if ((pFuncArgs->Flags & ASYNC) && (lResult < TAPI_SUCCESS))
//    {
//    }

DoFunc_return:

#if DBG
    {
        char szResult[32];


        LOG((
            TL_INFO,
            "%s: result = %s",
            pszFuncName,
            MapResultCodeToText (lResult, szResult)
            ));
    }
#endif

    return lResult;
}

HRESULT
CreateMSPObject(
    DWORD dwDeviceID,
    IUnknown * pUnk,
    IUnknown ** ppMSPAggAddress
    )
{
    HRESULT         hr;
    CLSID           clsid;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lMSPIdentify),

        {
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) &clsid,
            (ULONG_PTR) sizeof(clsid)
        },

        {
            Dword,
            lpGet_SizeToFollow,
            Size
        }
    };

    if ((hr = DOFUNC (&funcArgs, "lineMSPIdentify")) == 0)
    {
        hr = CoCreateInstance(
                              clsid,
                              pUnk,
                              CLSCTX_ALL,
                              IID_IUnknown,
                              (void **) ppMSPAggAddress
                             );

        if (!SUCCEEDED(hr))
        {
            LOG((
                   TL_ERROR,
                   "CoCreate failed for MSP on dwDeviceID %ld - error %lx",
                   dwDeviceID,
                   hr
                  ));
        }
    }
    else
    {
        LOG((TL_ERROR, "GetMSPClsid failed on dwDeviceID %l", dwDeviceID));
    }

    return hr;
}

HRESULT
LineReceiveMSPData(
                   HLINE hLine,
                   HCALL hCall,
                   PBYTE pBuffer,
                   DWORD dwSize
                  )
{
    HRESULT         hr = S_OK;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lReceiveMSPData),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) hCall,
            (ULONG_PTR) pBuffer,
            (ULONG_PTR) dwSize
        },

        {
            Dword,
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };

    hr = mapTAPIErrorCode( DOFUNC (&funcArgs, "LineReceiveMSPData") );

    return hr;
}


LONG
LoadUIDll(
    HWND        hwndOwner,
    DWORD       dwWidgetID,
    DWORD       dwWidgetType,
    HANDLE     *phDll,
    const CHAR       *pszTUISPI_xxx,
    TUISPIPROC *ppfnTUISPI_xxx
    )
{
    LONG    lResult;
    HANDLE  hDll = NULL;
    WCHAR   szUIDllName[MAX_PATH];
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, xGetUIDllName),

        {
            (ULONG_PTR) dwWidgetID,
            (ULONG_PTR) dwWidgetType,
            (ULONG_PTR) szUIDllName,
            (ULONG_PTR) MAX_PATH
        },

        {
            Dword,
            Dword,
            lpGet_SizeToFollow,
            Size
        }
    };


    if (hwndOwner && !IsWindow (hwndOwner))
    {
       lResult = (dwWidgetType == TUISPIDLL_OBJECT_PHONEID ?
           PHONEERR_INVALPARAM : LINEERR_INVALPARAM);

       goto LoadUIDll_return;
    }

    if ((lResult = DOFUNC (&funcArgs, "GetUIDllName")) == 0)
    {
        if (hDll = TAPILoadLibraryW(szUIDllName))
        {
            if ((*ppfnTUISPI_xxx = (TUISPIPROC) GetProcAddress(
                (HINSTANCE)hDll,
                pszTUISPI_xxx
                )))
            {
                *phDll = hDll;
                lResult = 0;
            }
            else
            {
                LOG((
                        TL_ERROR,
                        "LoadUIDll: GetProcAddress(%ls,%s) failed, err=%d",
                        szUIDllName,
                        pszTUISPI_xxx,
                        GetLastError()
                       ));

                FreeLibrary ((HINSTANCE)hDll);
                lResult = (dwWidgetType == TUISPIDLL_OBJECT_PHONEID ?
                                PHONEERR_OPERATIONUNAVAIL : LINEERR_OPERATIONUNAVAIL);
            }
        }
        else
        {
            LOG((
                    TL_ERROR,
                    "LoadLibraryW(%ls) failed, err=%d",
                    szUIDllName,
                    GetLastError()
                   ));

            lResult = (dwWidgetType == TUISPIDLL_OBJECT_PHONEID ?
                                PHONEERR_OPERATIONFAILED : LINEERR_OPERATIONFAILED);
        }

    }

LoadUIDll_return:

    return lResult;
}


LONG
PASCAL
lineXxxProvider(
    const CHAR   *pszTUISPI_providerXxx,
    LPCSTR  lpszProviderFilename,
    HWND    hwndOwner,
    DWORD   dwPermProviderID,
    LPDWORD lpdwPermProviderID
    )
{
    BOOL                bAddProvider = (pszTUISPI_providerXxx ==
                            gszTUISPI_providerInstall);
    WCHAR               szUIDllName[MAX_PATH];
    LONG                lResult;
    HINSTANCE           hDll;
    TUISPIPROC          pfnTUISPI_providerXxx;
    HTAPIDIALOGINSTANCE htDlgInst;


#ifndef _WIN64
    if (
          (GetVersion() & 0x80000000)
        &&
          ( 0xffff0000 == ( (DWORD)hwndOwner & 0xffff0000) )
       )
    {
       //
       // Yeah.  It don't play no ffff.
       //
       hwndOwner = (HWND) ( (DWORD)hwndOwner & 0x0000ffff );
    }

#endif

    if (bAddProvider && IsBadDwordPtr (lpdwPermProviderID))
    {
        LOG((TL_ERROR, "Bad lpdwPermProviderID pointer"));
        return LINEERR_INVALPOINTER;
    }
    else if (hwndOwner && !IsWindow (hwndOwner))
    {
        LOG((TL_ERROR, "hwndOwner is not a window"));
        return LINEERR_INVALPARAM;
    }

    {
        FUNC_ARGS funcArgs =
        {
            MAKELONG (LINE_FUNC | SYNC | 7, xGetUIDllName),

            {
                (ULONG_PTR) (bAddProvider ? (ULONG_PTR) &dwPermProviderID :
                            dwPermProviderID),
                (ULONG_PTR) TUISPIDLL_OBJECT_PROVIDERID,
                (ULONG_PTR) szUIDllName,
                (ULONG_PTR) MAX_PATH,
                (ULONG_PTR) (bAddProvider ? (ULONG_PTR) lpszProviderFilename :
                            TAPI_NO_DATA),
                (ULONG_PTR) (pszTUISPI_providerXxx==gszTUISPI_providerRemove ?1:0),
                (ULONG_PTR) &htDlgInst
            },

            {
                (bAddProvider ? lpDword : Dword),
                Dword,
                lpGet_SizeToFollow,
                Size,
                (bAddProvider ? lpszW : Dword),
                Dword,
                lpDword
            }
        };


        if ((lResult = DOFUNC (&funcArgs,"lineXxxProvider/GetUIDllName")) != 0)
        {
            if (lResult == TAPI16BITSUCCESS)
            {
                // 16 bit sp success
                // set result correctly, and return here
                lResult = 0;
            }
            return lResult;
        }
    }

    if ((hDll = TAPILoadLibraryW(szUIDllName)))
    {
        if ((pfnTUISPI_providerXxx = (TUISPIPROC) GetProcAddress(
                hDll,
                pszTUISPI_providerXxx
                )))
        {
            LOG((TL_INFO, "Calling %ls...", pszTUISPI_providerXxx));

            lResult = ((TUIPROVPROC)(*pfnTUISPI_providerXxx))(
                TUISPIDLLCallback,
                hwndOwner,
                dwPermProviderID
                );
#if DBG
            {
                char szResult[32];


                LOG((
                    TL_INFO,
                    "%ls: result = %s",
                    pszTUISPI_providerXxx,
                    MapResultCodeToText (lResult, szResult)
                    ));
            }
#endif
        }
        else
        {
            LOG((
                TL_ERROR,
                "lineXxxProvider: GetProcAddr(%ls,%ls) failed, err=%d",
                szUIDllName,
                pszTUISPI_providerXxx,
                GetLastError()
                ));

            lResult = LINEERR_OPERATIONUNAVAIL;
        }

        FreeLibrary (hDll);
    }
    else
    {
        LOG((
            TL_ERROR,
            "lineXxxProvider: LoadLibraryW('%ls') failed, err=%d",
            szUIDllName,
            GetLastError()
            ));

        lResult = LINEERR_OPERATIONFAILED;
    }

    {
        LONG    lResult2;
        FUNC_ARGS funcArgs =
        {
            MAKELONG (LINE_FUNC | SYNC | 2, xFreeDialogInstance),

            {
                (ULONG_PTR) htDlgInst,
                (ULONG_PTR) lResult
            },

            {
                Dword,
                Dword
            }
        };


        //
        // If TUISPI_providerXxx failed then we want to pass that error back
        // to the app, else if it succeeded & FreeDlgInst failed then pass
        // that error back to the app
        //

        if ((lResult2 = DOFUNC(
                &funcArgs,
                "lineXxxProvider/FreeDialogInstance"

                )) == 0)
        {
            if (bAddProvider)
            {
                *lpdwPermProviderID = dwPermProviderID;
            }
        }
        else if (lResult == 0)
        {
            lResult = lResult2;
        }
    }

    return lResult;
}


LONG
PASCAL
ValidateXxxInitializeParams(
    DWORD                       dwAPIVersion,
    BOOL                        bLine,
    LPLINEINITIALIZEEXPARAMS    pXxxInitExParams,
    LINECALLBACK                pfnCallback
    )
{
    DWORD dwError;


    __try
    {
        DWORD   dwTotalSize = pXxxInitExParams->dwTotalSize;


        if (dwTotalSize < sizeof (LINEINITIALIZEEXPARAMS))
        {
            return (bLine ? LINEERR_STRUCTURETOOSMALL :
                PHONEERR_STRUCTURETOOSMALL);
        }

        if (TAPIIsBadWritePtr (pXxxInitExParams, dwTotalSize))
        {
            return (bLine ? LINEERR_INVALPOINTER : PHONEERR_INVALPOINTER);
        }


        //
        // When checking the dwOptions field be careful about compatibility
        // with future vers, so we only look at the currently valid bits
        //

        switch ((pXxxInitExParams->dwOptions & 0xf))
        {
        case 0:
        case LINEINITIALIZEEXOPTION_USEHIDDENWINDOW:

            if (IsBadCodePtr ((FARPROC) pfnCallback))
            {
                return (bLine ? LINEERR_INVALPOINTER : PHONEERR_INVALPOINTER);
            }
            break;


        case LINEINITIALIZEEXOPTION_USECOMPLETIONPORT:
            if ( !gpPostQueuedCompletionStatus )
            {
                HINSTANCE hInst;

                hInst = GetModuleHandle( "Kernel32.dll" );

#ifdef MEMPHIS


                {
                FARPROC pfn;
                BOOL fResult;
                DWORD dw;
                OVERLAPPED o;


                pfn = GetProcAddress(
                                      hInst,
                                      "GetCompletionPortStatus"
                                    );

                if ( NULL == pfn )
                {
                    LOG((TL_ERROR, "It would seem CompletionPorts are not supported on this platform(1)"));
                    return (bLine ? LINEERR_INVALFEATURE : PHONEERR_OPERATIONFAILED);
                }

                fResult = pfn( -1, &dw, &dw, &o, 0 );
                }

                if ( ERROR_NOT_SUPPORTED != GetLastError() )
#endif
                {
                    gpPostQueuedCompletionStatus = (PQCSPROC)GetProcAddress(
                                                            hInst,
                                                            "PostQueuedCompletionStatus"
                                                            );

                    if ( NULL == gpPostQueuedCompletionStatus )
                    {
                        LOG((TL_ERROR, "It would seem CompletionPorts are not supported on this platform"));
                        return (bLine ? LINEERR_INVALFEATURE : PHONEERR_OPERATIONFAILED);
                    }
                }

            }
            break;


        case LINEINITIALIZEEXOPTION_USEEVENT:
            break;

        default:

            if (
                  (TAPI_VERSION2_0 == dwAPIVersion)
                ||
                  (TAPI_VERSION2_1 == dwAPIVersion)
               )
            {
                //
                // This 2.x app is nuts.
                //
                return (bLine ? LINEERR_INVALPARAM : PHONEERR_INVALPARAM);
            }
            else
            {
                //
                // This >2.0 app is asking for something we can't do.
                //
                return (bLine ? LINEERR_INCOMPATIBLEAPIVERSION :
                                PHONEERR_INCOMPATIBLEAPIVERSION);
            }

        }

        pXxxInitExParams->dwNeededSize =
        pXxxInitExParams->dwUsedSize = sizeof (LINEINITIALIZEEXPARAMS);
    }
    __except ((((dwError = GetExceptionCode()) == EXCEPTION_ACCESS_VIOLATION) ||
               dwError == EXCEPTION_DATATYPE_MISALIGNMENT) ?
            EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
    {
        return (bLine ? LINEERR_INVALPOINTER : PHONEERR_INVALPOINTER);
    }

    return 0;
}

LONG
GetTheModuleFileName( WCHAR ** ppName )
{

    DWORD   dwSize = MAX_PATH, dwLength;
    WCHAR * pszModuleNamePathW;

alloc_module_name_buf:

    if (!(pszModuleNamePathW = (WCHAR *)ClientAlloc (dwSize*sizeof(WCHAR))))
    {
        return LINEERR_NOMEM;
    }

    if (GetVersion() & 0x80000000)
    {
        PSTR pTemp;

        //
        // We're on Win9x - do ANSI
        //

        pTemp = (PSTR) ClientAlloc( dwSize );

        if ( NULL == pTemp )
        {
            LOG((
                        TL_ERROR,
                        "Mem alloc failed (for mod name) size:0x%08lx",
                        dwSize
                       ));

            return LINEERR_NOMEM;
        }


        if ((dwLength = GetModuleFileName(
                                          NULL,
                                          pTemp,
                                          dwSize
                                         )) == 0)
        {
            LOG((
                        TL_ERROR,
                        "GetModuleFileNameA failed, err=%d",
                        GetLastError()
                       ));

            ClientFree( pTemp );

            return LINEERR_INVALPARAM;
        }
        else if (dwLength >= dwSize)
        {
            ClientFree (pTemp);
            ClientFree (pszModuleNamePathW);
            dwSize *= 2;
            goto alloc_module_name_buf;
        }

        MultiByteToWideChar(
                            GetACP(),
                            MB_PRECOMPOSED,
                            pTemp,
                            dwLength,
                            pszModuleNamePathW,
                            dwSize
                           );

        ClientFree( pTemp );
    }
    else
    {
        //
        // We're on WinNT - do Unicode
        //
        if ((dwLength = GetModuleFileNameW(
                                           NULL,
                                           pszModuleNamePathW,
                                           dwSize

                                          )) == 0)
        {
            LOG((
                        TL_ERROR,
                        "GetModuleFileNameW failed, err=%d",
                        GetLastError()
                       ));

            return LINEERR_INVALPARAM;
        }
        else if (dwLength >= dwSize)
        {
            ClientFree (pszModuleNamePathW);
            dwSize *= 2;
            goto alloc_module_name_buf;
        }

    }

    *ppName = pszModuleNamePathW;

    return 0;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CreateThreadsAndStuff
//
// This function is called from inside CTAPI::Initialize and CTAPI::Shutdown
// only and hence access to it is serialized. Calling this function from some
// other functionality would need making an alternate arrangement to serialize 
// access to this function
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

LONG
CreateThreadsAndStuff()
{
    DWORD   dwThreadID;

    
    LOG((TL_TRACE, "CreateThreadsAndStuff: enter"));    
    
    //
    // Alloc resources for a new async events thread, then
    // create the thread
    //

    gpAsyncEventsThreadParams = (PASYNC_EVENTS_THREAD_PARAMS) ClientAlloc(
        sizeof (ASYNC_EVENTS_THREAD_PARAMS));

    if (NULL == gpAsyncEventsThreadParams)
    {
        LOG((TL_ERROR, "CreateThreadsAndStuff: failed to allocate gpAsyncEventsThreadParams"));    

        return LINEERR_OPERATIONFAILED;
    }


    //
    // we don't want the thread to exit as soon as it starts
    //

    gpAsyncEventsThreadParams->bExitThread = FALSE;


    //
    // Create the initial buffer the thread will use for
    // retreiving async events
    //

    gpAsyncEventsThreadParams->dwBufSize =
                                          ASNYC_MSG_BUF_SIZE;

    gpAsyncEventsThreadParams->pBuf = (LPBYTE) ClientAlloc(
        gpAsyncEventsThreadParams->dwBufSize);

    if (NULL == gpAsyncEventsThreadParams->pBuf)
    {
        LOG((TL_ERROR, "CreateThreadsAndStuff: failed to allocate gpAsyncEventsThreadParams->pBuf"));    

        ClientFree( gpAsyncEventsThreadParams );

        gpAsyncEventsThreadParams = NULL;

        return LINEERR_OPERATIONFAILED;
    }

    ghAsyncRetryQueueEvent = CreateEvent(
                                          NULL,
                                          FALSE,
                                          FALSE,
                                          NULL
                                         );

    if (NULL == ghAsyncRetryQueueEvent)
    {
        LOG((TL_ERROR, 
            "CreateThreadsAndStuff - failed to create ghAsyncRetryQueueEvent event"));

        ClientFree(gpAsyncEventsThreadParams->pBuf);

        ClientFree( gpAsyncEventsThreadParams );

        gpAsyncEventsThreadParams = NULL;

        return LINEERR_OPERATIONFAILED;
    }


    //
    // create startup event -- the thread will signal it when it is up and 
    // ready to do stuff
    //

    gpAsyncEventsThreadParams->hThreadStartupEvent = 
                    CreateEvent(NULL, FALSE, FALSE, NULL);

    if (NULL == gpAsyncEventsThreadParams->hThreadStartupEvent)
    {

        LOG((TL_ERROR, 
            "CreateThreadsAndStuff - failed to create hThreadStartupEvent event. LastError= 0x%lx",
            GetLastError()));


        CloseHandle(ghAsyncRetryQueueEvent);
        ghAsyncRetryQueueEvent = NULL;

        ClientFree(gpAsyncEventsThreadParams->pBuf);
        ClientFree( gpAsyncEventsThreadParams );
        gpAsyncEventsThreadParams = NULL;

        return LINEERR_OPERATIONFAILED;
    }


    //
    // Now that we've allocated all the resources try to exec
    // the thread
    //

    ghAsyncEventsThread = CreateThread(
                                       NULL,
                                       0,
                                       (LPTHREAD_START_ROUTINE) AsyncEventsThread,
                                       (LPVOID) gpAsyncEventsThreadParams,
                                       0,
                                       &dwThreadID
                                      );

    if (NULL == ghAsyncEventsThread)
    {
        LOG((TL_ERROR, "CreateThreadsAndStuff: failed to allocate AsyncEventsThread"));    

        CloseHandle(ghAsyncRetryQueueEvent);
        ghAsyncRetryQueueEvent = NULL;

        CloseHandle(gpAsyncEventsThreadParams->hThreadStartupEvent);
        ClientFree(gpAsyncEventsThreadParams->pBuf);
        ClientFree(gpAsyncEventsThreadParams);

        gpAsyncEventsThreadParams = NULL;

        return LINEERR_OPERATIONFAILED;
    }


    //
    // wait for the thread to have completed initialization or for the thread 
    // to exit. if the thread exited, it had an error, so return an error.
    //
    // this is needed so msp's do not initialize and start posting events 
    // before asynceventsthread opens up RetryQueue to accept these events.
    //
    // it would be more efficient to wait for these events immediately before
    // creating address objects, but the code would be much more complex and
    // the performance gain would be for tapi initialization only, so we won't
    // bother.
    // 

    HANDLE ahAsyncThreadEvents[] =
    {
        gpAsyncEventsThreadParams->hThreadStartupEvent,
        ghAsyncEventsThread
    };

       
    DWORD dwWaitResult = WaitForMultipleObjectsEx(
        sizeof(ahAsyncThreadEvents)/sizeof(HANDLE),
        ahAsyncThreadEvents,
        FALSE,
        INFINITE,
        FALSE);


    //
    // succeeded or failed, this event is no longer needed
    //

    CloseHandle(gpAsyncEventsThreadParams->hThreadStartupEvent);
    gpAsyncEventsThreadParams->hThreadStartupEvent = NULL;

    
    //
    // did we unblock because the thread exited?
    //

    if (dwWaitResult == WAIT_OBJECT_0 + 1)
    {
        //
        // thread exited
        //

        LOG((TL_ERROR, "CreateThreadsAndStuff: AsyncEventsThread exited"));


        CloseHandle(ghAsyncRetryQueueEvent);
        ghAsyncRetryQueueEvent = NULL;

        CloseHandle(ghAsyncEventsThread);

        ClientFree(gpAsyncEventsThreadParams->pBuf);
        ClientFree(gpAsyncEventsThreadParams);

        gpAsyncEventsThreadParams = NULL;

        return LINEERR_OPERATIONFAILED;
    }


    //
    // did we unblock for any reason other than thread exited or success?
    //

    if (dwWaitResult != WAIT_OBJECT_0)
    {

        LOG((TL_ERROR, "CreateThreadsAndStuff: failed waiting tor AsyncEventsThread initialization"));

        //
        // we had an error waiting for the thread to signal its successful
        // startup. 
        //
        
        //
        // if the thread is still up, tell it to stop.
        //

        gpAsyncEventsThreadParams->bExitThread = TRUE;


        //
        // we could wait for the thread to exit... but we got here because wait
        // failed, so there is little benefit in retrying. so take our chances 
        // and clean up.
        //

        CloseHandle(ghAsyncRetryQueueEvent);
        ghAsyncRetryQueueEvent = NULL;
        
        CloseHandle(ghAsyncEventsThread);
        ghAsyncEventsThread = NULL;
 
        ClientFree(gpAsyncEventsThreadParams->pBuf);
        ClientFree(gpAsyncEventsThreadParams);

        gpAsyncEventsThreadParams = NULL;

        return LINEERR_OPERATIONFAILED;
    }


    //
    // if we got here, async events thread initialized and is running
    //


    ghCallbackThreadEvent = CreateEvent(
                                        NULL,
                                        FALSE,
                                        FALSE,
                                        NULL
                                       );


    gbExitThread = FALSE;

    ghCallbackThread = CreateThread(
                                    NULL,
                                    0,
                                    (LPTHREAD_START_ROUTINE) CallbackThread,
                                    (LPVOID) NULL,
                                    0,
                                    &dwThreadID
                                   );

    if (NULL == ghCallbackThread)
    {
        // don't free these buffers.  The other thread
        // is already running at this point, the these
        // buffers will be cleaned up during normal
        // shutdown
        //ClientFree(gpAsyncEventsThreadParams->pBuf);
        //ClientFree(gpAsyncEventsThreadParams);
        
        LOG((TL_ERROR, "CreateThreadsAndStuff: failed to create CallbackThread"));

        return LINEERR_OPERATIONFAILED;
    }


    LOG((TL_TRACE, "CreateThreadsAndStuff: exit"));    

    return 0;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// NewInitialize
//
// This function is called from inside CTAPI::Initialize and CTAPI::Shutdown
// only and hence access to it is serialized. Calling this function from some
// other functionality would need making an alternate arrangement to serialize 
// access to this function
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT
CTAPI::NewInitialize()
{
    
    LOG((TL_INFO, "NewInitialize - enter"));

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 7, lInitialize),

        {
            (ULONG_PTR) &m_hLineApp,
            // tapisrv ignores this argument, so pass 0 and save on HINSTANCE<->32bit conversion
            0,
            0,
            (ULONG_PTR) gszTAPI3,
            (ULONG_PTR) &m_dwLineDevs,
            0,          // pszModuleName
            TAPI_CURRENT_VERSION
        },

        {
            lpDword,
            Dword,
            Dword,
            lpszW,
            lpDword,
            lpszW,
            Dword
        }
    };

    WCHAR             * pszModuleNamePathW = NULL;
    LONG                lResult = (LONG)S_OK;
    int                 tapiObjectArraySize=0;

    lResult = GetTheModuleFileName( &pszModuleNamePathW );
    
    if ( 0!= lResult )
    {
        goto xxxInitialize_return;
    }

    funcArgs.Args[5] = (ULONG_PTR) wcsrchr (pszModuleNamePathW, '\\') +
                       sizeof(WCHAR);

    _ASSERTE(m_pLineInitData == NULL);

    m_pLineInitData = (PT3INIT_DATA) ClientAlloc (sizeof(T3INIT_DATA));

    if (NULL == m_pLineInitData)
    {
        LOG((TL_ERROR, "NewInitialize: failed to allocate m_pLineInitData"));
        lResult = LINEERR_NOMEM;
        goto xxxInitialize_return;
    }


    m_pLineInitData->dwInitOptions         = LINEINITIALIZEEXOPTION_USEHIDDENWINDOW |
                                             LINEINITIALIZEEXOPTION_CALLHUBTRACKING;
    m_pLineInitData->bPendingAsyncEventMsg = FALSE;
    m_pLineInitData->dwKey                 = INITDATA_KEY;
    m_pLineInitData->pTAPI                 = this;

    //
    // We want to pass TAPISRV pInitData so that later when it does async
    // completion/event notification it can pass pInitData along too so
    // we know which init instance to talk to
    //

    //
    // convert the pointer into a 32-bit handle, so we don't need to pass a
    // 64-bit value between tapi3.dll and tapisrv
    //

    _ASSERTE(m_dwLineInitDataHandle == 0);

    m_dwLineInitDataHandle = CreateHandleTableEntry((ULONG_PTR)m_pLineInitData);

    LOG((TL_INFO, "NewInitialize: handle for m_pLineInitData = [0x%lx]", m_dwLineInitDataHandle));

    if (0 == m_dwLineInitDataHandle)
    {
        LOG((TL_ERROR, "NewInitialize: failed to create handle"));


        ClientFree(m_pLineInitData);
        m_pLineInitData = NULL;

        lResult = LINEERR_NOMEM;
        goto xxxInitialize_return;
    }
        
    
    funcArgs.Args[2] = m_dwLineInitDataHandle;

    //
    // call lineInitialize
    //

    lResult = DOFUNC (&funcArgs, "lineInitialize");

    if (lResult == 0)
    {

        LOG((TL_INFO, "NewInitialize: lineInitialize succeeded. m_hLineApp %p", m_hLineApp));
    }
    else
    {
        LOG((TL_ERROR, "NewInitialize: lineInitialize failed. "));


        //
        // undo the deed
        //

        ClientFree(m_pLineInitData);
        m_pLineInitData = NULL;

        DeleteHandleTableEntry(m_dwLineInitDataHandle);
        m_dwLineInitDataHandle = NULL;

        goto xxxInitialize_return;
    }


    //
    // Save the hLineApp returned by TAPISRV in our InitData struct,
    // and give the app back a pointer to the InitData struct instead
    //

    m_pLineInitData->hXxxApp = m_hLineApp;


    //
    // now setup for phoneinitialize
    //
    funcArgs.Args[0] = (ULONG_PTR)&m_hPhoneApp;
    funcArgs.Args[4] = (ULONG_PTR)&m_dwPhoneDevs;
    funcArgs.Flags = MAKELONG (PHONE_FUNC | SYNC | 7, pInitialize);

    
    _ASSERTE(m_pPhoneInitData == NULL);

    m_pPhoneInitData = (PT3INIT_DATA) ClientAlloc (sizeof(T3INIT_DATA));

    if ( NULL == m_pPhoneInitData )
    {
        LOG((TL_ERROR, "NewInitialize: failed to allocate m_pPhoneInitData"));

        lResult = LINEERR_NOMEM;
        goto xxxInitialize_return;
    }


    m_pPhoneInitData->dwInitOptions         = LINEINITIALIZEEXOPTION_USEHIDDENWINDOW;
    m_pPhoneInitData->bPendingAsyncEventMsg = FALSE;
    m_pPhoneInitData->dwKey                 = INITDATA_KEY;
    m_pPhoneInitData ->pTAPI                = this;

    //
    // We want to pass TAPISRV pInitData so that later when it does async
    // completion/event notification it can pass pInitData along too so
    // we know which init instance to talk to
    //

    //
    // convert the pointer into a 32-bit handle, so we don't need to pass a
    // 64-bit value between tapi3.dll and tapisrv
    //

    _ASSERTE(m_dwPhoneInitDataHandle == 0);

    m_dwPhoneInitDataHandle = CreateHandleTableEntry((ULONG_PTR)m_pPhoneInitData );

    LOG((TL_INFO, "NewInitialize: handle for m_pPhoneInitData = [0x%lx]", m_dwPhoneInitDataHandle));

    if (0 == m_dwPhoneInitDataHandle)
    {
        LOG((TL_ERROR, "NewInitialize: failed to create handle"));


        //
        // free the phone-related resources that we have already allocated
        //

        ClientFree(m_pPhoneInitData);
        m_pPhoneInitData = NULL;

        lResult = LINEERR_NOMEM;
        goto xxxInitialize_return;
    }


    funcArgs.Args[2] = m_dwPhoneInitDataHandle;

    lResult = DOFUNC (&funcArgs, "phoneInitialize");

    if (lResult == 0)
    {

        LOG((TL_INFO, "NewInitialize: phoneInitialize succeeded. m_hPhoneApp %p", m_hPhoneApp));
    }
    else
    {
        LOG((TL_ERROR, "NewInitialize: phoneInitialize failed. "));


        //
        // deallocate whatever resources we have allocated for the phone
        //


        ClientFree(m_pPhoneInitData);
        m_pPhoneInitData = NULL;

        DeleteHandleTableEntry(m_dwPhoneInitDataHandle);
        m_dwPhoneInitDataHandle = 0;

        goto xxxInitialize_return;
    }


    m_pPhoneInitData ->hXxxApp = m_hPhoneApp;

    //
    // If total number of init instances is 0 we need to start a
    // new async events thread
    //

    EnterCriticalSection( &gcsTapiObjectArray );

    tapiObjectArraySize = m_sTAPIObjectArray.GetSize();
    
    LeaveCriticalSection ( &gcsTapiObjectArray );

    if ( 0 == tapiObjectArraySize )
    {
        lResult = CreateThreadsAndStuff();

        if ( 0 != lResult )
        {
            goto xxxInitialize_return;
        }
    }

xxxInitialize_return:
    
    if (pszModuleNamePathW)
    {
        ClientFree (pszModuleNamePathW);
    }



    if ( 0 != lResult )
    {

        //
        // cleanup all line- and phone-related resources.
        //

        NewShutdown();
    }


#if DBG
    {
        char szResult[32];

        LOG((
            TL_INFO,
            "Initialize exit, result=%s",
            MapResultCodeToText (lResult, szResult)
            ));
    }

#else


    //
    // we may want to know what happened even with non-debug build
    // 

    LOG((TL_INFO, "NewInitialize - exit, result=0x%lx", lResult));

#endif
    

    return mapTAPIErrorCode( lResult );
}



//
// --------------------------------- lineXxx ----------------------------------
//

HRESULT 
LineAccept(
    HCALL   hCall,
    LPCSTR  lpsUserUserInfo,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lAccept),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpsUserUserInfo,
            dwSize
        },

        {
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };


    if (!lpsUserUserInfo)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[1]  = Dword;
        funcArgs.Args[1]      = TAPI_NO_DATA;
        funcArgs.ArgTypes[2]  = Dword;
    }

    return mapTAPIErrorCode( (DOFUNC (&funcArgs, "lineAccept")) );
}


HRESULT
LineAddToConference(
    HCALL hConfCall,
    HCALL hConsultCall
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 2, lAddToConference),

        {
            (ULONG_PTR) hConfCall,
            (ULONG_PTR) hConsultCall
        },

        {
            Dword,
            Dword
        }
    };


    return mapTAPIErrorCode( (DOFUNC (&funcArgs, "LineAddToConference")) );
}


LONG
WINAPI
lineAgentSpecific(
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwAgentExtensionIDIndex,
    LPVOID              lpParams,
    DWORD               dwSize
    )
{

    DWORD hpParams = CreateHandleTableEntry((ULONG_PTR) lpParams);
        
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 7, lAgentSpecific),

        {
            GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) dwAgentExtensionIDIndex,
            hpParams,
            (ULONG_PTR) lpParams,
            (ULONG_PTR) dwSize
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };

    LONG lResult = DOFUNC (&funcArgs, "lineAgentSpecific");


    //
    // in case of failure or synchronous call, delete the entry from the table
    // otherwise, the callback will do that
    //

    if (lResult <= 0)
    {
        DeleteHandleTableEntry(hpParams);
    }


    return lResult;
}


HRESULT
LineAnswer(
    HCALL hCall
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lAnswer),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) 0,
            0
        },

        {
            Dword,
            Dword,
            Dword
        }
    };


    return mapTAPIErrorCode( DOFUNC (&funcArgs, "lineAnswer") );
}


HRESULT
LineBlindTransfer(
    HCALL hCall,
    LPCWSTR lpszDestAddress,
    DWORD   dwCountryCode
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lBlindTransfer),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpszDestAddress,
            dwCountryCode
        },

        {
            Dword,
            lpszW,
            Dword
        }
    };


    if ( IsBadStringPtrW( lpszDestAddress, (UINT)-1 ) )
    {
        LOG((TL_ERROR, "LineBlindTransfer: bad lpszDestAddress: 0x%p", lpszDestAddress));
        return mapTAPIErrorCode(LINEERR_INVALPOINTER);
    }

    return mapTAPIErrorCode( DOFUNC (&funcArgs, "lineBlindTransfer") );
}


HRESULT
LineClose(
          T3LINE * pt3Line
         )
{
    LONG        lResult;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 1, lClose),

        {
            (ULONG_PTR) pt3Line->hLine
        },

        {
            Dword
        }
    };


    gpLineHashTable->Lock();

    lResult = DOFUNC (&funcArgs, "lineClose");

    LOG((TL_INFO, "lineClose: line - %lx  lResult %lx", pt3Line->hLine, lResult));

    gpLineHashTable->Remove( (ULONG_PTR)(pt3Line->hLine) );

    gpLineHashTable->Unlock();


    //
    // remove the corresponding entry from the callback instance handle table
    //


    if (0 != pt3Line->dwAddressLineStructHandle)
    {

        LOG((TL_INFO, "lineClose: removing address line handle [%lx] from the handle table",
                                   pt3Line->dwAddressLineStructHandle));

        DeleteHandleTableEntry(pt3Line->dwAddressLineStructHandle);
        pt3Line->dwAddressLineStructHandle = 0;

    }

    return mapTAPIErrorCode( lResult );
}


void
PASCAL
lineCompleteCallPostProcess(
    PASYNCEVENTMSG  pMsg
    )
{
    LOG((TL_TRACE, "lineCompleteCallPostProcess: enter"));
    LOG((
        TL_INFO,
        "\t\tdwP1=x%lx, dwP2=x%lx, dwP3=x%lx, dwP4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param2 == 0)
    {
        DWORD   dwCompletionID   = pMsg->Param3;
        
        LPDWORD lpdwCompletionID = (LPDWORD)GetHandleTableEntry(pMsg->Param4);
        DeleteHandleTableEntry(pMsg->Param4);

        __try
        {
            {
                *lpdwCompletionID = dwCompletionID;
            }
        }
        __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {
        
            LOG((TL_WARN, "lineCompleteCallPostProcess: failed "
                    "to write to [%p]: LINEERR_INVALPOINTER", 
                    lpdwCompletionID));
            
            pMsg->Param2 = LINEERR_INVALPOINTER;
        }
    }
}



LONG
WINAPI
lineCompleteCall(
    HCALL   hCall,
    LPDWORD lpdwCompletionID,
    DWORD   dwCompletionMode,
    DWORD   dwMessageID
    )
{

    DWORD hpdwCompletionID = CreateHandleTableEntry((ULONG_PTR)lpdwCompletionID);


    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lCompleteCall),

        {
            GetFunctionIndex(lineCompleteCallPostProcess),
            (ULONG_PTR) hCall,
            hpdwCompletionID,
            dwCompletionMode,
            dwMessageID
        },

        {
            Dword,
            Dword,
            lpDword,
            Dword,
            Dword
        }
    };


    LONG lResult = (DOFUNC (&funcArgs, "lineCompleteCall"));


    //
    // in case of failure or synchronous call, delete the entry from the table
    // otherwise, the callback will do that
    //

    if (lResult <= 0)
    {
        DeleteHandleTableEntry(hpdwCompletionID);
    }


    return lResult;
}

HRESULT
LineCompleteTransfer(
    HCALL hCall,
    HCALL hConsultCall,
    T3CALL * pt3ConfCall,
    DWORD   dwTransferMode
    )
{

    DWORD hpCallHandle = CreateHandleTableEntry((ULONG_PTR) &(pt3ConfCall->hCall));


    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lCompleteTransfer),

        {
            GetFunctionIndex(lineMakeCallPostProcess),
            hCall,
            hConsultCall,
            hpCallHandle,
            dwTransferMode,
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
        }
    };


    if (dwTransferMode == LINETRANSFERMODE_TRANSFER)
    {

        funcArgs.Args[0] = 0;
        

        //
        // hpCallHandle should be ignored
        //

        funcArgs.Args[3] = 0;
        
        DeleteHandleTableEntry(hpCallHandle);
        hpCallHandle = 0;
    }

    
    HRESULT hr = mapTAPIErrorCode( DOFUNC (&funcArgs, "lineCompleteTransfer") );


    if (FAILED(hr))
    {
        DeleteHandleTableEntry(hpCallHandle);
        hpCallHandle = 0;

    }

    return hr ;
}


HRESULT
LineConfigDialogW(
    DWORD   dwDeviceID,
    HWND    hwndOwner,
    LPCWSTR lpszDeviceClass
    )
{
    LONG        lResult;
    HANDLE      hDll;
    TUISPIPROC  pfnTUISPI_lineConfigDialog;


    if (lpszDeviceClass && IsBadStringPtrW (lpszDeviceClass, 256))
    {
        return E_POINTER;
    }

    if ((lResult = LoadUIDll(
            hwndOwner,
            dwDeviceID,
            TUISPIDLL_OBJECT_LINEID,
            &hDll,
            gszTUISPI_lineConfigDialog,
            &pfnTUISPI_lineConfigDialog

            )) == 0)
    {
        LOG((TL_INFO, "Calling TUISPI_lineConfigDialog..."));

        lResult = ((TUILINECONFIGPROC)(*pfnTUISPI_lineConfigDialog))(
            TUISPIDLLCallback,
            dwDeviceID,
            (HWND)hwndOwner,
            (LPCSTR)lpszDeviceClass
            );

#if DBG
        {
            char szResult[32];


            LOG((TL_INFO,
                "TUISPI_lineConfigDialog: result = %s",
                MapResultCodeToText (lResult, szResult)
                ));
        }
#endif

        FreeLibrary ((HINSTANCE)hDll);
    }

    return mapTAPIErrorCode(lResult);
}


HRESULT
LineConfigDialogEditW(
    DWORD           dwDeviceID,
    HWND            hwndOwner,
    LPCWSTR         lpszDeviceClass,
    LPVOID const    lpDeviceConfigIn,
    DWORD           dwSizeIn,
    LPVARSTRING *   ppDeviceConfigOut
    )
{
    LONG        lResult;
    HANDLE      hDll;
    TUISPIPROC  pfnTUISPI_lineConfigDialogEdit;

    if (lpszDeviceClass && IsBadStringPtrW (lpszDeviceClass, (UINT) -1))
    {
        return E_POINTER;
    }

    if (IsBadReadPtr (lpDeviceConfigIn, dwSizeIn))
    {
        return E_POINTER;
    }

    DWORD       dwSize = sizeof (VARSTRING) + 500;

    *ppDeviceConfigOut = (LPVARSTRING) ClientAlloc( dwSize );

    if (NULL == *ppDeviceConfigOut)
    {
        LOG((TL_ERROR, "LineConfigDialogEditW exit - return E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    (*ppDeviceConfigOut)->dwTotalSize = dwSize;

    if ((lResult = LoadUIDll(
            hwndOwner,
            dwDeviceID,
            TUISPIDLL_OBJECT_LINEID,
            &hDll,
            gszTUISPI_lineConfigDialogEdit,
            &pfnTUISPI_lineConfigDialogEdit

            )) == 0)
    {
        while (TRUE)
        {
            LOG((TL_INFO, "Calling TUISPI_lineConfigDialogEdit..."));

            lResult = ((TUILINECONFIGEDITPROC)(*pfnTUISPI_lineConfigDialogEdit))(
                TUISPIDLLCallback,
                dwDeviceID,
                (HWND)hwndOwner,
                (char *)lpszDeviceClass,
                lpDeviceConfigIn,
                dwSizeIn,
                *ppDeviceConfigOut
                );

#if DBG
            {
                char szResult[32];


                LOG((TL_INFO,
                    "TUISPI_lineConfigDialogEdit: result = %s",
                    MapResultCodeToText (lResult, szResult)
                    ));
            }
#endif

            if ((lResult == 0) && ((*ppDeviceConfigOut)->dwNeededSize > (*ppDeviceConfigOut)->dwTotalSize))
            {
                dwSize = (*ppDeviceConfigOut)->dwNeededSize;

                ClientFree(*ppDeviceConfigOut);

                *ppDeviceConfigOut = (LPVARSTRING)ClientAlloc(dwSize);

                if (NULL == *ppDeviceConfigOut)
                {
                    LOG((TL_ERROR, "LineConfigDialogEditW exit - return E_OUTOFMEMORY"));
                    return E_OUTOFMEMORY;
                }

                (*ppDeviceConfigOut)->dwTotalSize = dwSize;
            }
            else
            {
                break;
            }
        }

        FreeLibrary ((HINSTANCE)hDll);
    }

    return mapTAPIErrorCode(lResult);
}


LONG
WINAPI
lineConfigProvider(
    HWND    hwndOwner,
    DWORD   dwPermanentProviderID
    )
{
    return (lineXxxProvider(
        gszTUISPI_providerConfig,   // func name
        NULL,                       // lpszProviderFilename
        hwndOwner,                  // hwndOwner
        dwPermanentProviderID,      // dwPermProviderID
        NULL                        // lpdwPermProviderID
        ));
}


HRESULT
LineDeallocateCall(
    HCALL hCall
    )
{
    HRESULT         hr;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 1, lDeallocateCall),

        {
            (ULONG_PTR) hCall
        },

        {
            Dword
        }
    };

    LOG((TL_INFO, "lineDeallocateCall - hCall = 0x%08lx", hCall));

    hr = mapTAPIErrorCode( DOFUNC (&funcArgs, "lineDeallocateCall") );

    return hr;
}


void
PASCAL
lineDevSpecificPostProcess(
    PASYNCEVENTMSG pMsg
    )
{
    LOG((TL_TRACE, "lineDevSpecificPostProcess: enter"));
    LOG((TL_INFO,
        "\t\tdwP1=x%lx, dwP2=x%lx, dwP3=x%lx, dwP4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param2 == 0)
    {
        DWORD   dwSize  = pMsg->Param4;

        LPBYTE  pParams = (LPBYTE) GetHandleTableEntry(pMsg->Param3);


        //
        // no longer need the handle table entry for this handle
        //

        DeleteHandleTableEntry(pMsg->Param3);

        __try
        {
            {
                CopyMemory (pParams, (LPBYTE) (pMsg + 1), dwSize);
            }
        }
        __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {
            pMsg->Param2 = LINEERR_INVALPOINTER;
            
            LOG((TL_INFO,
                "lineDevSpecificPostProcess: failed to copy memory to "
                "[%p] from [%p]:  LINEERR_INVALPOINTER", 
                pParams, (LPBYTE) (pMsg + 1)));

        }
    }

    
    LOG((TL_TRACE, "lineDevSpecificPostProcess: exit"));
}


HRESULT
WINAPI
lineDevSpecific(
    HLINE   hLine,
    DWORD   dwAddressID,
    HCALL   hCall,
    LPVOID  lpParams,
    DWORD   dwSize
    )
{

    //
    // convert the pointer to a handle. the table entry will be removed in 
    // the callback
    //
    
    DWORD hpParams = CreateHandleTableEntry((ULONG_PTR)lpParams);


    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 7, lDevSpecific),

        {
            GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            dwAddressID,
            (ULONG_PTR) hCall,
            hpParams, // pass the handle to actual pointer (for post processing)
            (ULONG_PTR) lpParams, // pass data
            dwSize
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };

    
    LONG lResult = DOFUNC (&funcArgs, "lineDevSpecific");


    //
    // if failed, or synchronous call, remove the handle table entry. otherwise
    // the callback will do this.
    //

    HRESULT hr = E_FAIL;

    if (lResult <= 0)
    {
        DeleteHandleTableEntry(hpParams);
        hpParams = 0;

        hr = mapTAPIErrorCode(lResult);
    }
    else
    {

        //
        // block to see if the operation succeeds
        //

        hr = WaitForReply(lResult);

    }

    return hr;
}


LONG
WINAPI
lineDevSpecificFeature(
    HLINE   hLine,
    DWORD   dwFeature,
    LPVOID  lpParams,
    DWORD   dwSize
    )
{
    
    DWORD hpParams = CreateHandleTableEntry((ULONG_PTR)lpParams);
    
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 6, lDevSpecificFeature),

        {
            GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            dwFeature,
            hpParams, // pass the actual pointer (for post processing)
            (ULONG_PTR) lpParams, // pass data
            dwSize
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };


    LONG lResult = DOFUNC (&funcArgs, "lineDevSpecificFeature");


    //
    // if failed, or synchronous call, remove the handle table entry. 
    // otherwise the callback will do this.
    //

    if (lResult <= 0)
    {
        DeleteHandleTableEntry(hpParams);
    }

    return lResult;
}


HRESULT
LineDial(
    HCALL hCall,
    LPCWSTR lpszDestAddress,
    DWORD   dwCountryCode
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lDial),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpszDestAddress,
            dwCountryCode
        },

        {
            Dword,
            lpszW,
            Dword
        }
    };


    if ( IsBadStringPtrW(lpszDestAddress, (UINT)-1) )
    {
        LOG((TL_ERROR, "Bad lpszDestAddress in lineDial"));
        return mapTAPIErrorCode( LINEERR_INVALPOINTER );
    }

    return mapTAPIErrorCode( DOFUNC (&funcArgs, "lineDial") );

}


LONG
LineDrop(
    HCALL   hCall,
    LPCSTR  lpsUserUserInfo,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lDrop),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpsUserUserInfo,
            dwSize
        },

        {
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };


    if (!lpsUserUserInfo)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[1] = Dword;
        funcArgs.Args[1]     = TAPI_NO_DATA;
        funcArgs.ArgTypes[2] = Dword;
    }

    return (DOFUNC (&funcArgs, "lineDrop"));
}


HRESULT
LineForward(
    T3LINE * pt3Line,
    DWORD   dwAddressID,
    LPLINEFORWARDLIST   const lpForwardList,
    DWORD   dwNumRingsNoAnswer,
    LPHCALL lphConsultCall
    )
{

    DWORD hpCallHandle = CreateHandleTableEntry((ULONG_PTR)lphConsultCall);

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 9, lForward),

        {
            GetFunctionIndex(lineMakeCallPostProcess),
            (ULONG_PTR) pt3Line->hLine,
            FALSE,
            dwAddressID,
            (ULONG_PTR) lpForwardList,
            dwNumRingsNoAnswer,
            hpCallHandle,
            TAPI_NO_DATA,
            (ULONG_PTR) 0xffffffff      // dwAsciiCallParamsCodePage
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpSet_Struct,
            Dword,
            Dword,
            Dword,
            Dword
        }
    };


    if (!lpForwardList)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[4] = Dword;
        funcArgs.Args[4]     = TAPI_NO_DATA;
    }

    HRESULT hr = mapTAPIErrorCode( DOFUNC (&funcArgs, "lineForwardW") );

    if (FAILED(hr))
    {
        DeleteHandleTableEntry(hpCallHandle);
    }

    return hr;
}


void
PASCAL
lineGatherDigitsWPostProcess(
    PASYNCEVENTMSG  pMsg
    )
{
    LOG((TL_TRACE, "lineGatherDigitsWPostProcess: enter"));
    LOG((TL_INFO,
        "\t\tdwP1=x%lx, dwP2=x%lx, dwP3=x%lx, dwP4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param1 & (LINEGATHERTERM_BUFFERFULL | LINEGATHERTERM_CANCEL |
            LINEGATHERTERM_TERMDIGIT | LINEGATHERTERM_INTERTIMEOUT))
    {      
        LPSTR   lpsDigits = (LPSTR) GetHandleTableEntry(pMsg->Param2);

        //
        // no longer need the handle table entry
        //

        DeleteHandleTableEntry(pMsg->Param2);

        DWORD   dwNumDigits = pMsg->Param4;
        LPWSTR  pBuffer = (LPWSTR) (((ULONG_PTR *)(pMsg + 1)) + 2);

        __try
        {
            {
                CopyMemory (lpsDigits, pBuffer, dwNumDigits * sizeof(WCHAR));
            }
        }
        __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {
            //
            // Don't do anything if we GPF
            //

            LOG((TL_WARN, 
                "lineGatherDigitsWPostProcess: "
                "failed to write %lx digits to memory [%p]",
                dwNumDigits, lpsDigits));

        }
    }

    pMsg->Param2 = pMsg->Param3 = 0;
}


HRESULT
LineGatherDigits(
    HCALL   hCall,
    DWORD   dwDigitModes,
    LPWSTR  lpsDigits,
    DWORD   dwNumDigits,
    LPCWSTR lpszTerminationDigits,
    DWORD   dwFirstDigitTimeout,
    DWORD   dwInterDigitTimeout
    )
{

    //
    // Note: we do the ptr check here rather than in DOFUNC because we're
    //       not passing any digits data within the context of this func
    //

    if (lpsDigits && TAPIIsBadWritePtr (lpsDigits, dwNumDigits * sizeof (WCHAR)))
    {
        return LINEERR_INVALPOINTER;
    }


    //
    // this entry will be cleared in the callback (lineGatherDigitsWPostProcess)
    //

    DWORD hpOutputBuffer = CreateHandleTableEntry((ULONG_PTR)lpsDigits);




    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 9, lGatherDigits),
        {
            GetFunctionIndex(lineGatherDigitsWPostProcess),
            (ULONG_PTR) hCall,
			(ULONG_PTR) 0,				// this is the dwendtoendid for remotesp
            dwDigitModes,
            hpOutputBuffer,
            dwNumDigits,
            (ULONG_PTR) lpszTerminationDigits,
            dwFirstDigitTimeout,
            dwInterDigitTimeout
        },

        {

            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            lpszW,
            Dword,
            Dword
        }
    };


    if (lpszTerminationDigits == (LPCWSTR) NULL)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //
        funcArgs.ArgTypes[6] = Dword;
        funcArgs.Args[6]     = TAPI_NO_DATA;
    }
    else
    {
        if ( IsBadStringPtrW(lpszTerminationDigits, (UINT)-1) )
        {

            DeleteHandleTableEntry(hpOutputBuffer);
            hpOutputBuffer = 0;

            LOG((TL_ERROR, "Bad lpszDestAddress in lineGatherDigitsW"));
            return( LINEERR_INVALPOINTER );
        }
    }

    LONG lResult = DOFUNC (&funcArgs, "lineGatherDigits");

    if (lResult < 0)
    {
        DeleteHandleTableEntry(hpOutputBuffer);
        hpOutputBuffer = 0;
    }


    return mapTAPIErrorCode(lResult);
}

HRESULT
LineGenerateDigits(
    HCALL   hCall,
    DWORD   dwDigitMode,
    LPCWSTR lpszDigits,
    DWORD   dwDuration
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 5, lGenerateDigits),

        {
            (ULONG_PTR) hCall,
            dwDigitMode,
            (ULONG_PTR) lpszDigits,
            dwDuration,
            0           // dwEndToEndID, remotesp only
        },

        {
            Dword,
            Dword,
            lpszW,
            Dword,
            Dword
        }
    };


    if (!lpszDigits)
    {
        funcArgs.Args[2]     = TAPI_NO_DATA;
        funcArgs.ArgTypes[2] = Dword;
    }

    return mapTAPIErrorCode( DOFUNC (&funcArgs, "lineGenerateDigits") );
}

HRESULT
LineGenerateTone(
    HCALL   hCall,
    DWORD   dwToneMode,
    DWORD   dwDuration,
    DWORD   dwNumTones,
    LPLINEGENERATETONE const lpTones
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 7, lGenerateTone),

        {
            (ULONG_PTR) hCall,
            dwToneMode,
            dwDuration,
            dwNumTones,
            TAPI_NO_DATA,   // (DWORD) lpTones,
            0,              // dwNumTones * sizeof(LINEGENERATETONE)
            0               // dwEndToEndID, remotesp only
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,      // lpSet_SizeToFollow,
            Dword,      // Size
            Dword
        }
    };


    if (dwToneMode == LINETONEMODE_CUSTOM)
    {
        //
        // Set lpTones (& following Size arg) since in this case
        // they are valid args
        //

        funcArgs.ArgTypes[4] = lpSet_SizeToFollow;
        funcArgs.Args[4]     = (ULONG_PTR) lpTones;
        funcArgs.ArgTypes[5] = Size;
        funcArgs.Args[5]     = dwNumTones * sizeof(LINEGENERATETONE);
    }

    return mapTAPIErrorCode(DOFUNC (&funcArgs, "lineGenerateTone"));
}


HRESULT
LineGetCallHubTracking(
                       DWORD dwDeviceID,
                       LINECALLHUBTRACKINGINFO ** ppTrackingInfo
                      )
{
    return E_NOTIMPL;
}

HRESULT
LineGetHubRelatedCalls(
                       HCALLHUB        hCallHub,
                       HCALL           hCall,
                       LINECALLLIST ** ppCallHubList
                      )
{
    DWORD           dwSize = sizeof(LINECALLLIST) + sizeof(DWORD) * 20;
    HRESULT         hr;


    *ppCallHubList = (LINECALLLIST *)ClientAlloc( dwSize );

    if (NULL == *ppCallHubList)
    {
        return E_OUTOFMEMORY;
    }

    (*ppCallHubList)->dwTotalSize = dwSize;


    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lGetHubRelatedCalls),

        {
            (ULONG_PTR) hCallHub,
            (ULONG_PTR) hCall,
            (ULONG_PTR) *ppCallHubList
        },

        {
            Dword,
            Dword,
            lpGet_Struct
        }
    };


    while (TRUE)
    {
        hr = mapTAPIErrorCode( DOFUNC (&funcArgs, "lineGetHubRelatedCalls") );

        if (!SUCCEEDED(hr))
        {
            ClientFree( *ppCallHubList );
            *ppCallHubList = NULL;

            return hr;
        }

        if ((*ppCallHubList)->dwNeededSize > (*ppCallHubList)->dwTotalSize)
        {
            dwSize = (*ppCallHubList)->dwNeededSize;

            ClientFree( *ppCallHubList );

            *ppCallHubList = (LINECALLLIST *)ClientAlloc( dwSize );

            if (NULL == *ppCallHubList)
            {
                return E_OUTOFMEMORY;
            }

            (*ppCallHubList)->dwTotalSize = dwSize;

            funcArgs.Args[2] = (ULONG_PTR) *ppCallHubList;
        }
        else
        {
            break;
        }
    }

    return hr;
}

HRESULT
LineGetCallHub(
               HCALL hCall,
               HCALLHUB * pCallHub
              )
{
    DWORD           dwSize = sizeof(LINECALLLIST) + sizeof(DWORD);
    HRESULT         hr;
    LINECALLLIST *  pCallList;


    pCallList = (LINECALLLIST *)ClientAlloc( dwSize );

    if (NULL == pCallList)
    {
        return E_OUTOFMEMORY;
    }

    pCallList->dwTotalSize = dwSize;


    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lGetHubRelatedCalls),

        {
            (ULONG_PTR) 0,
            (ULONG_PTR) hCall,
            (ULONG_PTR) pCallList
        },

        {
            Dword,
            Dword,
            lpGet_Struct
        }
    };


    hr = mapTAPIErrorCode( DOFUNC (&funcArgs, "lineGetHubRelatedCalls") );

    if (SUCCEEDED(hr))
    {
        *pCallHub = *(LPHCALLHUB)(((LPBYTE)pCallList) + pCallList->dwCallsOffset);
    }

    ClientFree( pCallList );

    return hr;

}


HRESULT
LineGetAddressCaps(
                   HLINEAPP hLineApp,
                   DWORD dwDeviceID,
                   DWORD dwAddressID,
                   DWORD dwAPIVersion,
                   LPLINEADDRESSCAPS * ppAddressCaps
                  )
{
    LONG        lResult;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 6, lGetAddressCaps),

        {
            (ULONG_PTR) hLineApp,
            dwDeviceID,
            dwAddressID,
            dwAPIVersion,
            0,
            (ULONG_PTR) *ppAddressCaps
        },

        {
            hXxxApp,
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct
        }
    };


    while (TRUE)
    {
        lResult = DOFUNC (&funcArgs, "lineGetAddressCaps");

        if ((0 == lResult) && ((*ppAddressCaps)->dwNeededSize > (*ppAddressCaps)->dwTotalSize))
        {
            DWORD       dwSize;

            dwSize = (*ppAddressCaps)->dwNeededSize;

            ClientFree(*ppAddressCaps);

            *ppAddressCaps = (LPLINEADDRESSCAPS) ClientAlloc( dwSize );

            if (NULL == (*ppAddressCaps))
            {
                return E_OUTOFMEMORY;
            }

            (*ppAddressCaps)->dwTotalSize = dwSize;

            funcArgs.Args[5] = (ULONG_PTR) *ppAddressCaps;
        }
        else
        {
            break;
        }
    }

    return mapTAPIErrorCode( lResult );
}


LONG
WINAPI
lineGetAddressIDW(
    HLINE   hLine,
    LPDWORD lpdwAddressID,
    DWORD   dwAddressMode,
    LPCWSTR lpsAddress,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 5, lGetAddressID),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) lpdwAddressID,
            dwAddressMode,
            (ULONG_PTR) lpsAddress,
            dwSize
        },

        {
            Dword,
            lpDword,
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };


    return (DOFUNC (&funcArgs, "lineGetAddressID"));
}



HRESULT
LineGetAddressStatus(
    T3LINE * pt3Line,
    DWORD   dwAddressID,
    LPLINEADDRESSSTATUS * ppAddressStatus
    )
{
    HRESULT             hr;
    DWORD               dwSize;

    dwSize = sizeof( LINEADDRESSSTATUS ) + 500;

    *ppAddressStatus = (LINEADDRESSSTATUS *)ClientAlloc( dwSize );

    if ( NULL == *ppAddressStatus )
    {
        LOG((TL_ERROR, "Alloc failed in LineGetAddressStatus"));

        return E_OUTOFMEMORY;
    }

    (*ppAddressStatus)->dwTotalSize = dwSize;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lGetAddressStatus),

        {
            (ULONG_PTR) pt3Line->hLine,
            dwAddressID,
            (ULONG_PTR) *ppAddressStatus
        },

        {
            Dword,
            Dword,
            lpGet_Struct
        }
    };

    while (TRUE)
    {
        hr = mapTAPIErrorCode( DOFUNC (&funcArgs, "lineGetAddressStatus") );

        if ( 0 != hr )
        {
            ClientFree( *ppAddressStatus );
            *ppAddressStatus = NULL;
            return hr;
        }

        if ((0 == hr) && ((*ppAddressStatus)->dwNeededSize > (*ppAddressStatus)->dwTotalSize))
        {
            dwSize = (*ppAddressStatus)->dwNeededSize;

            ClientFree( *ppAddressStatus );

            *ppAddressStatus = (LPLINEADDRESSSTATUS) ClientAlloc( dwSize );

            if (NULL == *ppAddressStatus)
            {
                LOG((TL_ERROR, "Alloc failed 2 in LineGetAddressStatus"));

                return E_OUTOFMEMORY;
            }

            (*ppAddressStatus)->dwTotalSize = dwSize;

            funcArgs.Args[2] = (ULONG_PTR)*ppAddressStatus;

        }
        else
        {
            break;
        }
    }

    return hr;
}


LONG
WINAPI
lineGetAgentActivityListW(
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTACTIVITYLIST lpAgentActivityList
    )
{

    DWORD hpAgentActivityList = CreateHandleTableEntry((ULONG_PTR)lpAgentActivityList);
    

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lGetAgentActivityList),

        {
            GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) hpAgentActivityList,    // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpAgentActivityList     // pass data
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct,
        }
    };

    
    LONG lResult = DOFUNC (&funcArgs, "lineGetAgentActivityListW");


    //
    // if failed, or synchronous call, remove the handle table entry. 
    // otherwise the callback will do this.
    //

    if (lResult <= 0)
    {

        DeleteHandleTableEntry(hpAgentActivityList);
    }

    return lResult;
}


HRESULT
LineGetAgentCaps(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAppAPIVersion,
    LPLINEAGENTCAPS     *ppAgentCaps
    )
{
    HRESULT     hr = S_OK;
    long        lResult;
    DWORD       dwSize = sizeof(LINEAGENTCAPS) + 500;


    *ppAgentCaps = (LPLINEAGENTCAPS) ClientAlloc( dwSize );

    if (NULL == *ppAgentCaps)
    {
        return E_OUTOFMEMORY;
    }

    (*ppAgentCaps)->dwTotalSize = dwSize;


    DWORD hpAgentCaps = CreateHandleTableEntry((ULONG_PTR)*ppAgentCaps);

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 7, lGetAgentCaps),

        {
            GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLineApp,
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) dwAppAPIVersion,
            hpAgentCaps,    // pass the actual ptr (for ppproc)
            (ULONG_PTR) *ppAgentCaps     // pass data
        },

        {
            Dword,
            hXxxApp,
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct,
        }
    };


    while (TRUE)
    {
        lResult = DOFUNC (&funcArgs, "LineGetAgentCaps");

        if (lResult > 0)    // async reply
        {
            hr = WaitForReply( lResult );

            if ((hr == S_OK) )
            {
                if (((*ppAgentCaps)->dwNeededSize > (*ppAgentCaps)->dwTotalSize))
                {
                    // didnt Work , adjust buffer size & try again

                    DeleteHandleTableEntry(hpAgentCaps);
                    hpAgentCaps = 0;


                    LOG((TL_INFO, "LineGetAgentCaps failed - buffer to small"));
                    dwSize = (*ppAgentCaps)->dwNeededSize;
                    ClientFree( *ppAgentCaps );
                    *ppAgentCaps = NULL;

                    *ppAgentCaps = (LPLINEAGENTCAPS) ClientAlloc( dwSize );
                    if (*ppAgentCaps == NULL)
                    {
                        LOG((TL_ERROR, "LineGetAgentCaps - repeat ClientAlloc failed"));
                        hr = E_OUTOFMEMORY;
                        break;
                    }
                    else
                    {
                        (*ppAgentCaps)->dwTotalSize = dwSize;

                        hpAgentCaps = CreateHandleTableEntry((ULONG_PTR)*ppAgentCaps);
                        funcArgs.Args[5] = hpAgentCaps;

                        funcArgs.Args[6] = (ULONG_PTR)*ppAgentCaps;
                    }
                } // buffer too small
                else
                {
                    // WaitForReply succeeded and the buffer was big enough. 
                    // break out of the loop
                    break;
                }

            } // waitforreply succeeded
            else 
            {
                // waitforreply failed. not likely to receive a callback. 
                // clear handle table entries. 

                LOG((TL_ERROR, "LineGetAgentCaps - WaitForReply failed"));
                
                DeleteHandleTableEntry(hpAgentCaps);
                hpAgentCaps = 0;

            }
        }
        else  // failed sync
        {
            LOG((TL_ERROR, "LineGetAgentCaps - failed sync"));

            DeleteHandleTableEntry(hpAgentCaps);
            hpAgentCaps = 0;

            
            hr = mapTAPIErrorCode( lResult );
            break;
        }
    } // end while(TRUE)

    return hr;

}



LONG
WINAPI
lineGetAgentGroupListW(
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTGROUPLIST    lpAgentGroupList
    )
{
    
    DWORD hpAgentGroupList = CreateHandleTableEntry((ULONG_PTR)lpAgentGroupList);

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lGetAgentGroupList),

        {
            GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            hpAgentGroupList,       // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpAgentGroupList        // pass data
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct,
        }
    };


    LONG lResult  = DOFUNC (&funcArgs, "lineGetAgentGroupListW");

    
    //
    // if failed, or synchronous call, remove the handle table entry. 
    // otherwise the callback will do this.
    //

    if (lResult <= 0)
    {
        DeleteHandleTableEntry(hpAgentGroupList);
    }

    return lResult;
}


LONG
WINAPI
lineGetAgentStatusW(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEAGENTSTATUS   lpAgentStatus
    )
{

    DWORD hpAgentStatus = CreateHandleTableEntry((ULONG_PTR)lpAgentStatus);


    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lGetAgentStatus),

        {
            GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            hpAgentStatus,                      // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpAgentStatus           // pass data
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct,
        }
    };


    LONG lResult = DOFUNC(&funcArgs, "lineGetAgentStatusW");

    if (lResult <= 0)
    {
        DeleteHandleTableEntry(hpAgentStatus);
    }


    return lResult;
}



LONG
WINAPI
lineGetAppPriorityW(
    LPCWSTR lpszAppName,
    DWORD   dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD   dwRequestMode,
    LPVARSTRING lpExtensionName,
    LPDWORD lpdwPriority
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 7, lGetAppPriority),

        {
            (ULONG_PTR) lpszAppName,
            dwMediaMode,
            0,
            0,
            dwRequestMode,
            0,
            (ULONG_PTR) lpdwPriority
        },

        {
            lpszW,      // app name
            Dword,      // media mode
            Dword,      // ext id (offset)
            Dword,      // ext id (size)
            Dword,      // request mode
            Dword,      // ext name total size
            lpDword     // lp pri
        }
    };


    if (dwMediaMode & 0xff000000)
    {
        if ((LPVOID) lpExtensionName == (LPVOID) lpdwPriority)
        {
            return LINEERR_INVALPOINTER;
        }


        //
        // We have to do some arg list munging here (adding an extra arg)
        //

        //
        // Set lpExtensionID, the following Size arg,
        // lpExtensionName, and the following MinSize
        // Type's and Value appropriately since they're
        // valid args in this case
        //

        funcArgs.ArgTypes[2] = lpSet_SizeToFollow;
        funcArgs.Args[2]     = (ULONG_PTR) lpExtensionID;
        funcArgs.ArgTypes[3] = Size;
        funcArgs.Args[3]     = sizeof (LINEEXTENSIONID);
        funcArgs.ArgTypes[5] = lpGet_Struct;
        funcArgs.Args[5]     = (ULONG_PTR) lpExtensionName;
    }

    if ( IsBadStringPtrW(lpszAppName, (UINT)-1) )
    {
        LOG((TL_ERROR, "Bad lpszDestAddress in lineGetAppPriorityW"));
        return( LINEERR_INVALPOINTER );
    }

    return (DOFUNC (&funcArgs, "lineGetAppPriority"));
}

HRESULT
LineGetCallIDs(
    HCALL               hCall,
    LPDWORD             lpdwAddressID,
    LPDWORD             lpdwCallID,
    LPDWORD             lpdwRelatedCallID
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lGetCallIDs),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpdwAddressID,
            (ULONG_PTR) lpdwCallID,
            (ULONG_PTR) lpdwRelatedCallID
        },

        {
            Dword,
            lpDword,
            lpDword,
            lpDword
        }
    };


    return mapTAPIErrorCode(DOFUNC (&funcArgs, "lineGetCallIDs"));
}

HRESULT
LineGetCallInfo(
    HCALL hCall,
    LPLINECALLINFO *  ppCallInfo
    )
{

    if ( NULL == hCall )
    {
        LOG((TL_WARN, "LineGetCallInfo: NULL hCall"));

        *ppCallInfo = NULL;

        return TAPI_E_INVALCALLSTATE;
    }

    *ppCallInfo = (LPLINECALLINFO) ClientAlloc( sizeof(LINECALLINFO) + 500 );

    if (NULL == *ppCallInfo)
    {
        return E_OUTOFMEMORY;
    }

    (*ppCallInfo)->dwTotalSize = sizeof(LINECALLINFO) + 500;


    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lGetCallInfo),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) *ppCallInfo
        },

        {
            Dword,
            lpGet_Struct
        }
    };


    HRESULT hr = E_FAIL;

    while (TRUE)
    {
        hr = mapTAPIErrorCode(DOFUNC (&funcArgs, "lineGetCallInfo"));

        //
        // if we fail, free alloc
        //
        if ( FAILED(hr) )
        {
            ClientFree( *ppCallInfo );
            *ppCallInfo = NULL;

            return hr;
        }

        //
        // do we need to realloc?
        //
        if ((*ppCallInfo)->dwNeededSize > (*ppCallInfo)->dwTotalSize)
        {
            DWORD       dwSize = (*ppCallInfo)->dwNeededSize;

            ClientFree( *ppCallInfo );

            *ppCallInfo = (LPLINECALLINFO) ClientAlloc( dwSize );

            if (NULL == *ppCallInfo)
            {
                // return LINEERR_NOMEM;
                return E_OUTOFMEMORY;
            }

            (*ppCallInfo)->dwTotalSize = dwSize;

            funcArgs.Args[1] = (ULONG_PTR)*ppCallInfo;

        }
        else
        {
            break;
        }
    }

    return hr;
}


HRESULT
LineGetCallStatus(
          HCALL hCall,
          LPLINECALLSTATUS  * ppCallStatus
          )

{

    *ppCallStatus = (LPLINECALLSTATUS) ClientAlloc( sizeof(LINECALLSTATUS) + 500 );

    if (NULL == *ppCallStatus)
    {
        return E_OUTOFMEMORY;
    }

    (*ppCallStatus)->dwTotalSize = sizeof(LINECALLSTATUS) + 500;



    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lGetCallStatus),

        {
        (ULONG_PTR) hCall,
        (ULONG_PTR) *ppCallStatus
        },

        {
            Dword,
            lpGet_Struct
        }
    };


    HRESULT hr = E_FAIL;

    while (TRUE)
    {
        hr = mapTAPIErrorCode(DOFUNC (&funcArgs, "lineGetCallStatus"));

        //
        // if we fail, free alloc
        //
        if ( FAILED(hr) )
        {
            ClientFree( *ppCallStatus );
            *ppCallStatus = NULL;

            return hr;
        }

        //
        // do we need to realloc?
        //
        if ((*ppCallStatus)->dwNeededSize > (*ppCallStatus)->dwTotalSize)
        {
            DWORD       dwSize = (*ppCallStatus)->dwNeededSize;

            ClientFree( *ppCallStatus );

            *ppCallStatus = (LPLINECALLSTATUS) ClientAlloc( dwSize );

            if (NULL == *ppCallStatus)
            {
                return mapTAPIErrorCode( LINEERR_NOMEM );
            }

            (*ppCallStatus)->dwTotalSize = dwSize;

            funcArgs.Args[1] = (ULONG_PTR)*ppCallStatus;

        }
        else
        {
            break;
        }
    }

    return hr;

}


HRESULT
LineGetConfRelatedCalls(
    HCALL           hCall,
    LINECALLLIST ** ppCallList
    )
{
    DWORD           dwSize = sizeof(LINECALLLIST) + sizeof(DWORD) * 20;
    LONG            lResult;
    HRESULT         hr;


    *ppCallList = (LINECALLLIST *)ClientAlloc( dwSize );

    if (NULL == *ppCallList)
    {
        return E_OUTOFMEMORY;
    }

    (*ppCallList)->dwTotalSize = dwSize;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC| 2, lGetConfRelatedCalls),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) *ppCallList
        },

        {
            Dword,
            lpGet_Struct
        }
    };


    while (TRUE)
    {
        lResult = DOFUNC (&funcArgs, "lineGetConfRelatedCalls") ;


        if ( (0 == lResult) && ((*ppCallList)->dwNeededSize > (*ppCallList)->dwTotalSize) )
        {
            dwSize = (*ppCallList)->dwNeededSize;

            ClientFree( *ppCallList );

            *ppCallList = (LINECALLLIST *)ClientAlloc( dwSize );

            if (NULL == *ppCallList)
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            (*ppCallList)->dwTotalSize = dwSize;

            funcArgs.Args[1] = (ULONG_PTR) *ppCallList;
        }
        else
        {
            hr = mapTAPIErrorCode( lResult );
            break;
        }
    }

    return hr;

}



LONG
WINAPI
lineGetCountryW(
    DWORD   dwCountryID,
    DWORD   dwAPIVersion,
    LPLINECOUNTRYLIST   lpLineCountryList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lGetCountry),

        {
            dwCountryID,
            dwAPIVersion,
            0,
            (ULONG_PTR) lpLineCountryList
        },

        {
            Dword,
            Dword,
            Dword,
            lpGet_Struct
        }
    };


    if (
          ( TAPI_CURRENT_VERSION != dwAPIVersion )
        &&
          ( 0x00020000 != dwAPIVersion )
        &&
          ( 0x00010004 != dwAPIVersion )
        &&
          ( 0x00010003 != dwAPIVersion )
       )
    {
       LOG((TL_ERROR, "lineGetCountryW - bad API version 0x%08lx", dwAPIVersion));
       return LINEERR_INCOMPATIBLEAPIVERSION;
    }

    return (DOFUNC (&funcArgs, "lineGetCountry"));
}

HRESULT
LineGetDevCapsWithAlloc(
               HLINEAPP hLineApp,
               DWORD dwDeviceID,
               DWORD dwAPIVersion,
               LPLINEDEVCAPS * ppLineDevCaps
              )
{
    LONG        lResult;

    *ppLineDevCaps = (LPLINEDEVCAPS) ClientAlloc( sizeof(LINEDEVCAPS) + 500 );

    if (NULL == *ppLineDevCaps)
    {
        return E_OUTOFMEMORY;
    }

    (*ppLineDevCaps)->dwTotalSize = sizeof(LINEDEVCAPS) + 500;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 5, lGetDevCaps),

        {
            (ULONG_PTR) hLineApp,
            dwDeviceID,
            dwAPIVersion,
            0,
            (ULONG_PTR) *ppLineDevCaps
        },

        {
            hXxxApp,
            Dword,
            Dword,
            Dword,
            lpGet_Struct
        }
    };


    while (TRUE)
    {
        lResult = DOFUNC (&funcArgs, "lineGetDevCaps");

        if ((0 == lResult) && ((*ppLineDevCaps)->dwNeededSize > (*ppLineDevCaps)->dwTotalSize))
        {
            DWORD       dwSize = (*ppLineDevCaps)->dwNeededSize;

            ClientFree( *ppLineDevCaps );

            *ppLineDevCaps = (LPLINEDEVCAPS) ClientAlloc( dwSize );

            if (NULL == *ppLineDevCaps)
            {
                // return LINEERR_NOMEM;
                return E_OUTOFMEMORY;
            }

            (*ppLineDevCaps)->dwTotalSize = dwSize;

            funcArgs.Args[4] = (ULONG_PTR)*ppLineDevCaps;

        }
        else
        {
            break;
        }
    }

    return mapTAPIErrorCode( lResult );
}


HRESULT
LineGetDevCaps(
               HLINEAPP hLineApp,
               DWORD dwDeviceID,
               DWORD dwAPIVersion,
               LPLINEDEVCAPS * ppLineDevCaps
              )
{
    LONG        lResult;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 5, lGetDevCaps),

        {
            (ULONG_PTR) hLineApp,
            dwDeviceID,
            dwAPIVersion,
            0,
            (ULONG_PTR) *ppLineDevCaps
        },

        {
            hXxxApp,
            Dword,
            Dword,
            Dword,
            lpGet_Struct
        }
    };


    while (TRUE)
    {
        lResult = DOFUNC (&funcArgs, "lineGetDevCaps");

        if ((0 == lResult) && ((*ppLineDevCaps)->dwNeededSize > (*ppLineDevCaps)->dwTotalSize))
        {
            DWORD       dwSize = (*ppLineDevCaps)->dwNeededSize;

            ClientFree( *ppLineDevCaps );

            *ppLineDevCaps = (LPLINEDEVCAPS) ClientAlloc( dwSize );

            if (NULL == *ppLineDevCaps)
            {
                // return LINEERR_NOMEM;
                return E_OUTOFMEMORY;
            }

            (*ppLineDevCaps)->dwTotalSize = dwSize;

            funcArgs.Args[4] = (ULONG_PTR)*ppLineDevCaps;

        }
        else
        {
            break;
        }
    }

    return mapTAPIErrorCode( lResult );
}


HRESULT
LineGetDevConfig(
    DWORD           dwDeviceID,
    LPVARSTRING   * ppDeviceConfig,
    LPCWSTR         lpszDeviceClass
    )
{
    LONG            lResult;
    DWORD           dwSize = sizeof (VARSTRING) + 500;

    *ppDeviceConfig = (LPVARSTRING) ClientAlloc( dwSize );

    if (NULL == *ppDeviceConfig)
    {
        return E_OUTOFMEMORY;
    }

    (*ppDeviceConfig)->dwTotalSize = dwSize;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lGetDevConfig),

        {
            dwDeviceID,
            (ULONG_PTR) *ppDeviceConfig,
            (ULONG_PTR) lpszDeviceClass
        },

        {
            Dword,
            lpGet_Struct,
            lpszW
        }
    };

    while ( TRUE )
    {
        lResult = DOFUNC (&funcArgs, "lineGetDevConfig");

        if ((lResult == 0) && ((*ppDeviceConfig)->dwNeededSize > (*ppDeviceConfig)->dwTotalSize))
        {
            dwSize = (*ppDeviceConfig)->dwNeededSize;

            ClientFree(*ppDeviceConfig);

            *ppDeviceConfig = (LPVARSTRING)ClientAlloc(dwSize);

            if (NULL == *ppDeviceConfig)
            {
                LOG((TL_ERROR, "LineGetDevConfig exit - return E_OUTOFMEMORY"));
                return E_OUTOFMEMORY;
            }

            (*ppDeviceConfig)->dwTotalSize = dwSize;

            funcArgs.Args[1] = (ULONG_PTR)*ppDeviceConfig;
        }
        else
        {
            break;
        }
    }

    LOG((TL_TRACE, "LineGetDevConfig exit - return %lx", lResult));

    return mapTAPIErrorCode( lResult );
}



LONG
WINAPI
lineGetIconW(
    DWORD   dwDeviceID,
    LPCWSTR lpszDeviceClass,
    LPHICON lphIcon
    )
{
    HICON   hIcon;
    LONG    lResult;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lGetIcon),

        {
            dwDeviceID,
            (ULONG_PTR) lpszDeviceClass,
            (ULONG_PTR) &hIcon
        },

        {
            Dword,
            lpszW,
            lpDword
        }
    };


    if (IsBadDwordPtr ((LPDWORD) lphIcon))
    {
        LOG((TL_ERROR, "lphIcon is an invalid pointer!"));
        return LINEERR_INVALPOINTER;
    }

    if (lpszDeviceClass == (LPCWSTR) NULL)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[1] = Dword;
        funcArgs.Args[1]     = TAPI_NO_DATA;
    }

    if ((lResult = DOFUNC (&funcArgs, "lineGetIcon")) == 0)
    {
        *lphIcon = hIcon;
    }

    return lResult;
}



HRESULT
LineGetID(
          HLINE   hLine,
          DWORD   dwID,
          HCALL   hCall,
          DWORD   dwSelect,
          LPVARSTRING * ppDeviceID,
          LPCWSTR lpszDeviceClass
         )
{
    LONG        lResult;
    DWORD       dwNumDevices;
    DWORD       dwDeviceId1, dwDeviceId2;
    BOOL        bWaveDevice = FALSE;

    *ppDeviceID = (LPVARSTRING) ClientAlloc( sizeof (VARSTRING) + 500 );

    if (NULL == *ppDeviceID)
    {
        return E_OUTOFMEMORY;
    }

    (*ppDeviceID)->dwTotalSize = sizeof (VARSTRING) + 500;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 6, lGetID),

        {
            (ULONG_PTR) hLine,
            dwID,
            (ULONG_PTR) hCall,
            dwSelect,
            (ULONG_PTR) *ppDeviceID,
            (ULONG_PTR) lpszDeviceClass
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct,
            lpszW
        }
    };

    
    LOG((TL_TRACE, "LineGetID - enter"));
    LOG((TL_INFO, "   hLine --------->%lx", hLine));
    LOG((TL_INFO, "   hCall ----------->%lx", hCall));
    LOG((TL_INFO, "   dwSelect -------->%lx", dwSelect));
    LOG((TL_INFO, "   ppDeviceID ------>%p", ppDeviceID));
    LOG((TL_INFO, "   lpszDeviceClass ->%p", lpszDeviceClass));

    //
    // If the request is for a wave device, call LGetIDEx.
    // This will return a device string ID which is guaranteed to be unique across 
    // all processes. 
    // Then we will convert the string ID to the correct device ID in the client process context.
    //

    if (!_wcsicmp(lpszDeviceClass, L"wave/in")  ||
        !_wcsicmp(lpszDeviceClass, L"wave/out") ||
        !_wcsicmp(lpszDeviceClass, L"midi/in")  ||
        !_wcsicmp(lpszDeviceClass, L"midi/out") ||
        !_wcsicmp(lpszDeviceClass, L"wave/in/out")
       )
    {
        bWaveDevice = TRUE;
        dwNumDevices = _wcsicmp(lpszDeviceClass, L"wave/in/out") ? 1 : 2;
        funcArgs.Flags = MAKELONG (LINE_FUNC | SYNC | 6, lGetIDEx);
    }

    while ( TRUE )
    {
        lResult = DOFUNC (&funcArgs, bWaveDevice ? "lineGetIDEx" : "lineGetID");

        if ((lResult == 0) && ((*ppDeviceID)->dwNeededSize > (*ppDeviceID)->dwTotalSize))
        {
            DWORD       dwSize = (*ppDeviceID)->dwNeededSize;

            ClientFree(*ppDeviceID);

            *ppDeviceID = (LPVARSTRING)ClientAlloc(dwSize);

            if (NULL == *ppDeviceID)
            {
                LOG((TL_ERROR, "LineGetID exit - return LINEERR_NOMEM"));
                // return LINEERR_NOMEM;
                return E_OUTOFMEMORY;
            }

            (*ppDeviceID)->dwTotalSize = dwSize;

            funcArgs.Args[4] = (ULONG_PTR)*ppDeviceID;
        }
        else
        {
            if (lResult != 0)
            {
                ClientFree (*ppDeviceID);
                *ppDeviceID = NULL;
            }
            break;
        }
    }

    if (bWaveDevice && lResult == 0)
    {
        //
        // We got the string ID(s), now we need to convert them to numeric device ID(s)
        //

        BOOL    bConversionOk;

        if ( dwNumDevices == 1 )
        {
            bConversionOk = WaveStringIdToDeviceId (
                    (LPWSTR)((LPBYTE)(*ppDeviceID) + (*ppDeviceID)->dwStringOffset),
                    lpszDeviceClass,
                    &dwDeviceId1);
        }
        else
        {

            _ASSERTE(dwNumDevices == 2);

            // 
            // for "wave/in/out", we get back two devices from tapisrv -> convert both
            //
            LPWSTR  szString1 = (LPWSTR)((LPBYTE)(*ppDeviceID) + (*ppDeviceID)->dwStringOffset);

            // first convert the wave/in device 
            bConversionOk = WaveStringIdToDeviceId (
                    szString1,
                    L"wave/in",
                    &dwDeviceId1);

            // next convert the wave/out device
            bConversionOk = bConversionOk && WaveStringIdToDeviceId (
                    szString1 + wcslen(szString1),
                    L"wave/out",
                    &dwDeviceId2);
        }

        if (!bConversionOk)
        {
            LOG((TL_ERROR, "LineGetID - WaveStringIdToDeviceId failed"));
            ClientFree(*ppDeviceID);
            *ppDeviceID = NULL;
            lResult = LINEERR_OPERATIONFAILED;
        }
        else
        {
            //
            // conversion succeeded, now fill the VARSTRING to be returned to the caller
            //
            (*ppDeviceID)->dwNeededSize = (*ppDeviceID)->dwUsedSize = 
                sizeof(VARSTRING) + sizeof(DWORD) * dwNumDevices;
            (*ppDeviceID)->dwStringFormat = STRINGFORMAT_BINARY;
            (*ppDeviceID)->dwStringSize = sizeof(DWORD) * dwNumDevices;
            (*ppDeviceID)->dwStringOffset = sizeof(VARSTRING);
            *(DWORD *)((*ppDeviceID) + 1) = dwDeviceId1;
            if (dwNumDevices == 2) 
                *((DWORD *)((*ppDeviceID) + 1) + 1) = dwDeviceId2;
        }
    }


    LOG((TL_TRACE, "LineGetID exit - return %lx", lResult));

    return mapTAPIErrorCode( lResult );
}

HRESULT
LineGetLineDevStatus(
                     HLINE hLine,
                     LPLINEDEVSTATUS * ppDevStatus
                    )
{
    HRESULT             hr;
    DWORD               dwSize = sizeof(LINEDEVSTATUS) + 500;

    *ppDevStatus = ( LPLINEDEVSTATUS ) ClientAlloc( dwSize );

    if ( NULL == *ppDevStatus )
    {
        LOG((TL_ERROR, "LineGetLineDevStatus - alloc failed"));

        return E_OUTOFMEMORY;
    }

    (*ppDevStatus)->dwTotalSize = dwSize;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lGetLineDevStatus),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) *ppDevStatus
        },

        {
            Dword,
            lpGet_Struct
        }
    };

    while (TRUE)
    {

        hr = mapTAPIErrorCode( DOFUNC (&funcArgs, "lineGetLineDevStatus") );

        if ( 0 != hr )
        {
            ClientFree( *ppDevStatus );
            *ppDevStatus = NULL;
            return hr;
        }

        if ((0 == hr) && ((*ppDevStatus)->dwNeededSize > (*ppDevStatus)->dwTotalSize))
        {
            dwSize = (*ppDevStatus)->dwNeededSize;

            ClientFree( *ppDevStatus );

            *ppDevStatus = (LPLINEDEVSTATUS) ClientAlloc( dwSize );

            if (NULL == *ppDevStatus)
            {
                return E_OUTOFMEMORY;
            }

            (*ppDevStatus)->dwTotalSize = dwSize;

            funcArgs.Args[1] = (ULONG_PTR)*ppDevStatus;

        }
        else
        {
            break;
        }
    }

    return hr;
}



HRESULT
LineGetProxyStatus(
                     HLINEAPP                 hLineApp,
                     DWORD                    dwDeviceID,
                     DWORD                    dwAppAPIVersion,
                     LPLINEPROXYREQUESTLIST * ppLineProxyReqestList
                    )
{
    HRESULT             hr;
    DWORD               dwSize = sizeof(LINEPROXYREQUESTLIST) + 100;

    *ppLineProxyReqestList = ( LPLINEPROXYREQUESTLIST ) ClientAlloc( dwSize );

    if ( NULL == *ppLineProxyReqestList )
    {
        LOG((TL_ERROR, "LineGetProxyStatus - alloc failed"));

        return E_OUTOFMEMORY;
    }

    (*ppLineProxyReqestList)->dwTotalSize = dwSize;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lGetProxyStatus),

        {
            (ULONG_PTR)hLineApp,
            dwDeviceID,
            dwAppAPIVersion,
            (ULONG_PTR) *ppLineProxyReqestList
        },

        {
            hXxxApp,
            Dword,
            Dword,
            lpGet_Struct
        }
    };

    while (TRUE)
    {

        hr = mapTAPIErrorCode( DOFUNC (&funcArgs, "lineGetProxyStatus") );

        if ( FAILED(hr) )
        {
            ClientFree( *ppLineProxyReqestList );
            *ppLineProxyReqestList = NULL;
            return hr;
        }

        //
        // succeeded, but need a bigger buffer?
        //

        if ( (*ppLineProxyReqestList)->dwNeededSize > (*ppLineProxyReqestList)->dwTotalSize )
        {
            dwSize = (*ppLineProxyReqestList)->dwNeededSize;

            ClientFree( *ppLineProxyReqestList );

            *ppLineProxyReqestList = (LPLINEPROXYREQUESTLIST) ClientAlloc( dwSize );

            if (NULL == *ppLineProxyReqestList)
            {
                return E_OUTOFMEMORY;
            }

            (*ppLineProxyReqestList)->dwTotalSize = dwSize;

            funcArgs.Args[3] = (ULONG_PTR)*ppLineProxyReqestList;

        }
        else
        {

            //
            // plain success
            //

            break;
        }
    }

    return hr;
}




LONG
WINAPI
lineGetNewCalls(
    HLINE   hLine,
    DWORD   dwAddressID,
    DWORD   dwSelect,
    LPLINECALLLIST  lpCallList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lGetNewCalls),

        {
            (ULONG_PTR) hLine,
            dwAddressID,
            dwSelect,
            (ULONG_PTR) lpCallList
        },

        {
            Dword,
            Dword,
            Dword,
            lpGet_Struct
        }
    };


    return (DOFUNC (&funcArgs, "lineGetNewCalls"));
}


LONG
WINAPI
lineGetNumRings(
    HLINE   hLine,
    DWORD   dwAddressID,
    LPDWORD lpdwNumRings
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lGetNumRings),

        {
            (ULONG_PTR) hLine,
            dwAddressID,
            (ULONG_PTR) lpdwNumRings
        },

        {
            Dword,
            Dword,
            lpDword
        }
    };


    return (DOFUNC (&funcArgs, "lineGetNumRings"));
}

HRESULT
LineGetProviderList(
                    LPLINEPROVIDERLIST * ppProviderList
                   )
{
    LONG        lResult;

    *ppProviderList = (LPLINEPROVIDERLIST) ClientAlloc( sizeof (LINEPROVIDERLIST) +
                                                        5*sizeof(LINEPROVIDERENTRY));

    if (NULL == *ppProviderList)
    {
        return E_OUTOFMEMORY;
    }

    (*ppProviderList)->dwTotalSize = sizeof(LINEPROVIDERLIST) + 5*sizeof(LINEPROVIDERENTRY);

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lGetProviderList),

        {
            TAPI_CURRENT_VERSION,
            (ULONG_PTR) *ppProviderList
        },

        {
            Dword,
            lpGet_Struct
        }
    };

    while (TRUE)
    {
        lResult = DOFUNC (&funcArgs, "lineGetProviderList");

        if ((0 == lResult) && ((*ppProviderList)->dwNeededSize > (*ppProviderList)->dwTotalSize))
        {
            DWORD       dwSize;

            dwSize = (*ppProviderList)->dwNeededSize;

            ClientFree(*ppProviderList);

            *ppProviderList = (LPLINEPROVIDERLIST) ClientAlloc( dwSize );

            if (NULL == (*ppProviderList))
            {
                return E_OUTOFMEMORY;
            }

            (*ppProviderList)->dwTotalSize = dwSize;

            funcArgs.Args[1] = (ULONG_PTR) *ppProviderList;
        }
        else if ( 0 != lResult )
        {
            ClientFree( *ppProviderList );
            *ppProviderList = NULL;
            break;
        }
        else
        {
            break;
        }
    }

    return mapTAPIErrorCode( lResult );
}

HRESULT
LineGetRequest(
    HLINEAPP    hLineApp,
    DWORD       dwRequestMode,
    LPLINEREQMAKECALLW * ppReqMakeCall
    )
{
    *ppReqMakeCall = (LPLINEREQMAKECALLW)ClientAlloc( sizeof(LINEREQMAKECALLW) );

    if ( NULL == *ppReqMakeCall )
    {
        return E_OUTOFMEMORY;
    }

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lGetRequest),

        {
            (ULONG_PTR) hLineApp,
            dwRequestMode,
            (ULONG_PTR) *ppReqMakeCall,
            0
        },

        {
            hXxxApp,
            Dword,
            lpGet_SizeToFollow,
            Size
        }
    };


    if (dwRequestMode == LINEREQUESTMODE_MAKECALL)
    {
        //
        // Set the size param appropriately
        //

        funcArgs.Args[3] = sizeof(LINEREQMAKECALLW);
    }
    else if (dwRequestMode == LINEREQUESTMODE_MEDIACALL)
    {
        //
        // Set the size param appropriately
        //

        funcArgs.Args[3] = sizeof(LINEREQMEDIACALLW);
    }

    return mapTAPIErrorCode(DOFUNC (&funcArgs, "lineGetRequest"));
}

LONG
WINAPI
lineGetStatusMessages(
    HLINE hLine,
    LPDWORD lpdwLineStates,
    LPDWORD lpdwAddressStates
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lGetStatusMessages),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) lpdwLineStates,
            (ULONG_PTR) lpdwAddressStates
        },

        {
            Dword,
            lpDword,
            lpDword
        }
    };


    if (lpdwLineStates == lpdwAddressStates)
    {
        return LINEERR_INVALPOINTER;
    }

    return (DOFUNC (&funcArgs, "lineGetStatusMessages"));
}



HRESULT
LineHandoff(
    HCALL   hCall,
    LPCWSTR lpszFileName,
    DWORD   dwMediaMode
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lHandoff),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpszFileName,
            dwMediaMode
        },

        {
            Dword,
            lpszW,
            Dword
        }
    };


    if (lpszFileName == (LPCWSTR) NULL)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[1] = Dword;
        funcArgs.Args[1]     = TAPI_NO_DATA;
    }

    return mapTAPIErrorCode( DOFUNC (&funcArgs, "lineHandoff") );
}


HRESULT
LineHold(
    HCALL hCall
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 1, lHold),

        {
            (ULONG_PTR) hCall
        },

        {
            Dword
        }
    };


    return mapTAPIErrorCode( DOFUNC (&funcArgs, "lineHold"));
}


PWSTR
PASCAL
MultiToWide(
    LPCSTR  lpStr
    )
{
    DWORD dwSize;
    PWSTR szTempPtr;


    dwSize = MultiByteToWideChar(
        GetACP(),
        MB_PRECOMPOSED,
        lpStr,
        -1,
        NULL,
        0
        );

    if ((szTempPtr = (PWSTR) ClientAlloc ((dwSize + 1) * sizeof (WCHAR))))
    {
        MultiByteToWideChar(
            GetACP(),
            MB_PRECOMPOSED,
            lpStr,
            -1,
            szTempPtr,
            dwSize + 1
            );
    }

    return szTempPtr;
}



void
PASCAL
lineMakeCallPostProcess(
    PASYNCEVENTMSG  pMsg
    )
{
    LOG((TL_TRACE, "lineMakeCallPostProcess: enter"));
    LOG((TL_INFO,
        "\t\tdwP1=x%lx, dwP2=x%lx, dwP3=x%lx, dwP4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param2 == 0)
    {
        HCALL   hCall   = (HCALL) pMsg->Param3;

        LPHCALL lphCall = (LPHCALL)GetHandleTableEntry(pMsg->Param4);
        
        
        DeleteHandleTableEntry(pMsg->Param4);

        __try
        {
            {
                *lphCall = NULL;

                *lphCall = hCall;
            }
        }
        __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {

            LOG((TL_WARN,
                "lineMakeCallPostProcess: failed to write handle %lx to memory"
                " location %p. returning LINEERR_INVALPOINTER", 
                hCall, lphCall));
    
            pMsg->Param2 = LINEERR_INVALPOINTER;

            
            //
            // tapisrv has allocated a call handle for us. deallocate it.
            //

            LineDeallocateCall(hCall);

        }
    }
}


HRESULT
LineMakeCall(
    T3LINE * pt3Line,
    HCALL * phCall,
    LPCWSTR lpszDestAddress,
    DWORD   dwCountryCode,
    LPLINECALLPARAMS const lpCallParams
    )
{

    DWORD hpCallHandle = CreateHandleTableEntry((ULONG_PTR)phCall);


    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 7, lMakeCall),

        {
            GetFunctionIndex(lineMakeCallPostProcess),
            (ULONG_PTR) pt3Line->hLine,
            hpCallHandle,
            (ULONG_PTR) lpszDestAddress,
            (ULONG_PTR) dwCountryCode,
            (ULONG_PTR) lpCallParams,
            (ULONG_PTR) 0xffffffff      // dwAsciiCallParamsCodePage
        },

        {
            Dword,
            Dword,
            Dword,
            lpszW,
            Dword,
            lpSet_Struct,
            Dword
        }
    };


    if (!lpszDestAddress)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[3] = Dword;
        funcArgs.Args[3]     = TAPI_NO_DATA;
    }

    if (!lpCallParams)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[5] = Dword;
        funcArgs.Args[5]     = TAPI_NO_DATA;
    }


    HRESULT hr = mapTAPIErrorCode( DOFUNC (&funcArgs, "lineMakeCall") );

    if (FAILED(hr))
    {
        DeleteHandleTableEntry(hpCallHandle);
    }

    return hr;
}


HRESULT
LineMonitorDigits(
    HCALL    hCall,
    DWORD    dwDigitModes
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lMonitorDigits),

        {
            (ULONG_PTR) hCall,
            dwDigitModes
        },

        {
            Dword,
            Dword
        }
    };


    return mapTAPIErrorCode( DOFUNC (&funcArgs, "lineMonitorDigits") );
}


LONG
WINAPI
lineMonitorMedia(
    HCALL   hCall,
    DWORD   dwMediaModes
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lMonitorMedia),

        {
            (ULONG_PTR) hCall,
            dwMediaModes
        },

        {
            Dword,
            Dword
        }
    };


    return mapTAPIErrorCode( DOFUNC (&funcArgs, "lineMonitorMedia") );
}


HRESULT
LineMonitorTones(
    HCALL   hCall,
    LPLINEMONITORTONE   const lpToneList,
    DWORD   dwNumEntries
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lMonitorTones),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpToneList,
            dwNumEntries * sizeof(LINEMONITORTONE),
            0     // dwToneListID, remotesp only
        },

        {
            Dword,
            lpSet_SizeToFollow,
            Size,
            Dword
        }
    };


    if (!lpToneList)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[1] = Dword;
        funcArgs.Args[1]     = TAPI_NO_DATA;
        funcArgs.ArgTypes[2] = Dword;
    }

    return mapTAPIErrorCode(DOFUNC (&funcArgs, "lineMonitorTones"));
}


HRESULT
LineNegotiateAPIVersion(
                        HLINEAPP     hLineApp,
                        DWORD        dwDeviceID,
                        LPDWORD      lpdwAPIVersion
                       )
{
    LINEEXTENSIONID     LED;

    LOG((TL_INFO, "LineNegotiateAPIVersion: hLineApp %p", hLineApp));

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 7, lNegotiateAPIVersion),

        {
            (ULONG_PTR) hLineApp,
            dwDeviceID,
            TAPI_VERSION1_0,
            TAPI_VERSION_CURRENT,
            (ULONG_PTR) lpdwAPIVersion,
            (ULONG_PTR) &LED,
            (ULONG_PTR) sizeof(LINEEXTENSIONID)
        },

        {
            hXxxApp,
            Dword,
            Dword,
            Dword,
            lpDword,
            lpGet_SizeToFollow,
            Size
        }
    };

    return mapTAPIErrorCode( DOFUNC (&funcArgs, "lineNegotiateAPIVersion") );
}


LONG
WINAPI
lineNegotiateExtVersion(
    HLINEAPP    hLineApp,
    DWORD       dwDeviceID,
    DWORD       dwAPIVersion,
    DWORD       dwExtLowVersion,
    DWORD       dwExtHighVersion,
    LPDWORD     lpdwExtVersion
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 6, lNegotiateExtVersion),

        {
            (ULONG_PTR) hLineApp,
            dwDeviceID,
            dwAPIVersion,
            dwExtLowVersion,
            dwExtHighVersion,
            (ULONG_PTR) lpdwExtVersion
        },

        {
            hXxxApp,
            Dword,
            Dword,
            Dword,
            Dword,
            lpDword
        }
    };


    return (DOFUNC (&funcArgs, "lineNegotiateExtVersion"));
}


HRESULT
LineOpen(
         HLINEAPP                hLineApp,
         DWORD                   dwDeviceID,
         DWORD                   dwAddressID,
         T3LINE *                pt3Line,
         DWORD                   dwAPIVersion,
         DWORD                   dwPrivileges,
         DWORD                   dwMediaModes,
         AddressLineStruct *     pAddressLine,
         LPLINECALLPARAMS const  lpCallParams,
         CAddress *              pAddress,
         CTAPI *                 pTapiObj,
         BOOL                    bAddToHashTable
        )
{
    LONG lResult;
    LINECALLPARAMS lcp;
    LINECALLPARAMS * plcp;

    if (IsBadReadPtr(pt3Line, sizeof(T3LINE))) 
    {
        LOG((TL_ERROR, "LineOpen: pt3Line %p -- invalid ptr ", pt3Line));

        //
        // if we are getting an invalid ptr, we need to see why
        //

        _ASSERTE(FALSE);

        return E_POINTER;
    }

    if (NULL == lpCallParams)
    {
        memset(
               &lcp,
               0,
               sizeof(lcp)
              );

        lcp.dwTotalSize = sizeof(lcp);
        lcp.dwAddressMode = LINEADDRESSMODE_ADDRESSID;
        lcp.dwAddressID = dwAddressID;

        plcp = &lcp;
    }
    else
    {
        plcp = lpCallParams;
    }

    dwPrivileges|= LINEOPENOPTION_SINGLEADDRESS;

    
    //
    // if we were passed a pAddressLine pointer, create a corresponding
    // DWORD-sized handle, and keep it around in the T3LINE structure.
    // we need this so we can remove the handle table entry on LineClose.
    // 

    _ASSERTE(0 == pt3Line->dwAddressLineStructHandle);
    
    if (NULL != pAddressLine)
    {

        pt3Line->dwAddressLineStructHandle = CreateHandleTableEntry((UINT_PTR)pAddressLine);
    }
 

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 11, lOpen),

        {
            (ULONG_PTR) hLineApp,
            dwDeviceID,
            (ULONG_PTR) &(pt3Line->hLine),
            dwAPIVersion,
            0,
            pt3Line->dwAddressLineStructHandle,
            dwPrivileges, //| LINEOPENOPTION_SINGLEADDRESS),
            dwMediaModes,
            (ULONG_PTR) plcp,
            (ULONG_PTR) 0xffffffff,     // dwAsciiCallParamsCodePage
            0                       // LINEOPEN_PARAMS.hRemoteLine
        },

        {
            hXxxApp,
            Dword,
            lpDword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            lpSet_Struct,
            Dword,
            Dword
        }
    };


    if (!(dwPrivileges & (LINEOPENOPTION_PROXY|LINEOPENOPTION_SINGLEADDRESS)))
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[8] = Dword;
        funcArgs.Args[8]     = TAPI_NO_DATA;
    }


    gpLineHashTable->Lock();

    lResult = (DOFUNC (&funcArgs, "lineOpen"));

#if DBG
    LOG((TL_INFO, "Returning from lineOpenW, *lphLine = 0x%08lx", pt3Line->hLine));

    LOG((TL_INFO, "Returning from lineOpenW, retcode = 0x%08lx", lResult));
#endif


    if ( 0 == lResult && bAddToHashTable)
    {
        gpLineHashTable->Insert( (ULONG_PTR)(pt3Line->hLine), (ULONG_PTR)pAddress, pTapiObj );
    }

    gpLineHashTable->Unlock();


    //
    // if an address line handle was created, but the call failed, remove the
    // entry from the handle table
    //

    if ( (0 != lResult) && (0 != pt3Line->dwAddressLineStructHandle))
    {

        DeleteHandleTableEntry(pt3Line->dwAddressLineStructHandle);
        pt3Line->dwAddressLineStructHandle = 0;

    }


    return mapTAPIErrorCode( lResult );
}


HRESULT
LinePark(
    HCALL         hCall,
    DWORD         dwParkMode,
    LPCWSTR       lpszDirAddress,
    LPVARSTRING * ppNonDirAddress
    )
{

    HRESULT hr = S_OK;
    long    lResult;
    DWORD   dwSize = sizeof (VARSTRING) + 500;


    LOG((TL_TRACE, "LinePark - enter"));


    if ( NULL != ppNonDirAddress )
    {
        *ppNonDirAddress = (LPVARSTRING) ClientAlloc(dwSize);

        if (NULL == *ppNonDirAddress)
        {
            return E_OUTOFMEMORY;
        }

        (*ppNonDirAddress)->dwTotalSize = dwSize;
    }

    FUNC_ARGS funcArgs =
    {
            MAKELONG (LINE_FUNC | ASYNC | 6, lPark),

            {
            (ULONG_PTR) 0,               // post process proc
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwParkMode,
            (ULONG_PTR) TAPI_NO_DATA, //lpszDirAddress,
            (ULONG_PTR) 0, // pass ptr as Dword for post processing
            (ULONG_PTR) TAPI_NO_DATA, //lpNonDirAddress  // pass ptr as lpGet_Xx for IsValPtr chk
            },

            {
            Dword,
            Dword,
            Dword,
            Dword, // lpszW,
            Dword,
            Dword, // lpGet_Struct
            }
    };


    
    DWORD hpNonDirAddress = 0;


    if (dwParkMode == LINEPARKMODE_DIRECTED)
    {
            funcArgs.ArgTypes[3] = lpszW;
            funcArgs.Args[3]     = (ULONG_PTR) lpszDirAddress;
    }
    else if (dwParkMode == LINEPARKMODE_NONDIRECTED)
    {
        if ( NULL == ppNonDirAddress )
        {
            return E_POINTER;
        }

        //
        // Set post process proc
        //

        funcArgs.Args[0] = GetFunctionIndex(lineDevSpecificPostProcess),


        hpNonDirAddress = CreateHandleTableEntry((ULONG_PTR)*ppNonDirAddress);

        funcArgs.ArgTypes[4] = Dword;
        funcArgs.Args[4]     = hpNonDirAddress;
        funcArgs.ArgTypes[5] = lpGet_Struct;
        funcArgs.Args[5]     = (ULONG_PTR) *ppNonDirAddress;
    }


    while (TRUE)
    {
        lResult = DOFUNC (&funcArgs, "LinePark");


        if (lResult == LINEERR_STRUCTURETOOSMALL)
        {
            // didnt Work , adjust buffer size & try again
            LOG((TL_INFO, "LinePark failed - buffer too small"));


            dwSize = (*ppNonDirAddress)->dwNeededSize;

            
            //
            // no longer need the handle
            //

            DeleteHandleTableEntry(hpNonDirAddress);
            hpNonDirAddress = 0;

            ClientFree( *ppNonDirAddress );


            *ppNonDirAddress = (LPVARSTRING) ClientAlloc( dwSize );
            
            if (*ppNonDirAddress == NULL)
            {
                LOG((TL_ERROR, "LinePark - repeat ClientAlloc failed"));
                hr =  E_OUTOFMEMORY;
                break;
            }
            else
            {

                //
                // get a handle corresponding to the new *ppNonDirAddress and 
                // use it to pass to DoFunc
                //

                hpNonDirAddress = CreateHandleTableEntry((ULONG_PTR)*ppNonDirAddress);

                if (0 == hpNonDirAddress)
                {
                    LOG((TL_ERROR, "LinePark - repeat CreateHandleTableEntry failed"));
                    hr =  E_OUTOFMEMORY;

                    ClientFree(*ppNonDirAddress);
                    *ppNonDirAddress = NULL;

                    break;
                }

                funcArgs.Args[4] = hpNonDirAddress;

                (*ppNonDirAddress)->dwTotalSize = dwSize;
            }
        }
        else if (lResult < 0)
        {
            if ( NULL != ppNonDirAddress )
            {
                ClientFree( *ppNonDirAddress );
            }

            hr = mapTAPIErrorCode( lResult );

            break;
        }
        else
        {

            hr = lResult;

            break;
        }

    } // end while(TRUE)


    //
    // if we failed, remove the handle table entry because it will not be cleared by the callback
    //

    if (FAILED(hr) && (0 != hpNonDirAddress))
    {
        DeleteHandleTableEntry(hpNonDirAddress);
        hpNonDirAddress = 0;
    }

    LOG((TL_TRACE, hr, "LinePark - exit"));
    return hr;
}


HRESULT
LinePickup(
           HLINE    hLine,
           DWORD    dwAddressID,
           HCALL    *phCall,
           LPCWSTR  lpszDestAddress,
           LPCWSTR  lpszGroupID
          )
{

    DWORD hpCallHandle = CreateHandleTableEntry((ULONG_PTR)phCall);

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 6, lPickup),

        {
            GetFunctionIndex(lineMakeCallPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            hpCallHandle,
            (ULONG_PTR) lpszDestAddress,
            (ULONG_PTR) lpszGroupID
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpszW,
            lpszW
        }
    };


    if (!lpszDestAddress)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[4] = Dword;
        funcArgs.Args[4]     = TAPI_NO_DATA;
    }

    if (!lpszGroupID)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[5] = Dword;
        funcArgs.Args[5]     = TAPI_NO_DATA;
    }
    

    HRESULT hr = mapTAPIErrorCode( DOFUNC (&funcArgs, "linePickup") );
    
    if (FAILED(hr))
    {
        DeleteHandleTableEntry(hpCallHandle);
        hpCallHandle = 0;
    }

    return hr;
}


HRESULT
LinePrepareAddToConference(
    HCALL hConfCall,
    HCALL * phConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{

    DWORD hpConsultCallHandle = CreateHandleTableEntry((ULONG_PTR)phConsultCall);

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lPrepareAddToConference),

        {
            GetFunctionIndex(lineMakeCallPostProcess),
            (ULONG_PTR) hConfCall,
            hpConsultCallHandle,
            (ULONG_PTR) lpCallParams,
            (ULONG_PTR) 0xffffffff      // dwAsciiCallParamsCodePage
        },

        {
            Dword,
            Dword,
            Dword,
            lpSet_Struct,
            Dword
        }
    };


    if (!lpCallParams)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[3] = Dword;
        funcArgs.Args[3]     = TAPI_NO_DATA;
    }


    HRESULT hr = mapTAPIErrorCode( DOFUNC (&funcArgs, "LinePrepareAddToConference") );


    if (FAILED(hr))
    {
        DeleteHandleTableEntry(hpConsultCallHandle);
    }
    
    return hr;
}

LONG
WINAPI
lineProxyMessage(
    HLINE               hLine,
    HCALL               hCall,
    DWORD               dwMsg,
    DWORD               Param1,
    DWORD               Param2,
    DWORD               Param3
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 6, lProxyMessage),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) hCall,
            dwMsg,
            Param1,
            Param2,
            Param3
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
        }
    };


    return (DOFUNC (&funcArgs, "lineProxyMessage"));
}


LONG
WINAPI
lineProxyResponse(
    HLINE               hLine,
    LPLINEPROXYREQUEST  lpProxyRequest,
    DWORD               dwResult
    )
{
    LONG    lResult = 0;
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lProxyResponse),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) 0,
            (ULONG_PTR) lpProxyRequest,
            (ULONG_PTR) dwResult
        },

        {
            Dword,
            Dword,
            lpSet_Struct,
            Dword
        }
    };
    PPROXYREQUESTHEADER pProxyRequestHeader;


    //
    // The following is not the most thorough checking, but it's close
    // enough that a client app won't get a totally unexpected value
    // back
    //

    if (dwResult != 0  &&
        (dwResult < LINEERR_ALLOCATED  ||
            dwResult > LINEERR_DIALVOICEDETECT))
    {
        return LINEERR_INVALPARAM;
    }


    //
    // Backtrack a little bit to get the pointer to what ought to be
    // the proxy header, and then make sure we're dealing with a valid
    // proxy request
    //

    pProxyRequestHeader = (PPROXYREQUESTHEADER)
        (((LPBYTE) lpProxyRequest) - sizeof (PROXYREQUESTHEADER));

    __try
    {
        //
        // Make sure we've a valid pProxyRequestHeader, then invalidate
        // the key so subsequent attempts to call lineProxyResponse with
        // the same lpProxyRequest fail
        //

//        if ((DWORD) pProxyRequestHeader & 0x7 ||
        if(pProxyRequestHeader->dwKey != TPROXYREQUESTHEADER_KEY)
        {
            lResult = LINEERR_INVALPOINTER;
        }

        pProxyRequestHeader->dwKey = 0xefefefef;

        funcArgs.Args[1] = pProxyRequestHeader->dwInstance;


        //
        // See if this is one of the requests that don't require
        // any data to get passed back & reset the appropriate
        // params if so
        //

        switch (lpProxyRequest->dwRequestType)
        {
        case LINEPROXYREQUEST_SETAGENTGROUP:
        case LINEPROXYREQUEST_SETAGENTSTATE:
        case LINEPROXYREQUEST_SETAGENTACTIVITY:
        case LINEPROXYREQUEST_SETAGENTMEASUREMENTPERIOD:
        case LINEPROXYREQUEST_SETAGENTSESSIONSTATE:
        case LINEPROXYREQUEST_SETQUEUEMEASUREMENTPERIOD:
        case LINEPROXYREQUEST_SETAGENTSTATEEX:

            funcArgs.Args[2]     = TAPI_NO_DATA;
            funcArgs.ArgTypes[2] = Dword;

            break;
        }
    }
    __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
            EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
    {
        lResult = LINEERR_INVALPOINTER;
    }


    if (lResult == 0)
    {
        lResult = DOFUNC (&funcArgs, "lineProxyResponse");


        //
        // If we've gotten this far we want to free the buffer
        // unconditionally
        //

        ClientFree (pProxyRequestHeader);
    }

    return lResult;
}


LONG
WINAPI
lineRedirectW(
    HCALL   hCall,
    LPCWSTR lpszDestAddress,
    DWORD   dwCountryCode
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lRedirect),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpszDestAddress,
            dwCountryCode
        },

        {
            Dword,
            lpszW,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineRedirect"));
}


HRESULT
LineRegisterRequestRecipient(
    HLINEAPP    hLineApp,
    DWORD       dwRegistrationInstance,
    DWORD       dwRequestMode,
#ifdef NEWREQUEST
    DWORD       dwAddressTypes,
#endif
    DWORD       bEnable
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lRegisterRequestRecipient),

        {
            (ULONG_PTR) hLineApp,
            dwRegistrationInstance,
            dwRequestMode,
            bEnable
        },

        {
            hXxxApp,
            Dword,
            Dword,
            Dword
        }
    };


    return mapTAPIErrorCode(DOFUNC (&funcArgs, "lineRegisterRequestRecipient"));
}


HRESULT
LineReleaseUserUserInfo(
    HCALL hCall
    )
{
    if ( !hCall )
    {
        return TAPI_E_INVALCALLSTATE;
    }

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 1, lReleaseUserUserInfo),

        {
            (ULONG_PTR) hCall
        },

        {
            Dword,
        }
    };


    return mapTAPIErrorCode( DOFUNC (&funcArgs, "lineReleaseUserUserInfo") );
}


HRESULT
LineRemoveFromConference(
    HCALL hCall
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 1, lRemoveFromConference),

        {
            (ULONG_PTR) hCall
        },

        {
            Dword
        }
    };


    return mapTAPIErrorCode( DOFUNC (&funcArgs, "LineRemoveFromConference") );
}


LONG
WINAPI
lineRemoveProvider(
    DWORD   dwPermanentProviderID,
    HWND    hwndOwner
    )
{
    return (lineXxxProvider(
        gszTUISPI_providerRemove,   // func name
        NULL,                       // lpszProviderFilename
        hwndOwner,                  // hwndOwner
        dwPermanentProviderID,      // dwPermProviderID
        NULL                        // lpdwPermProviderID
        ));
}


LONG
WINAPI
lineSecureCall(
    HCALL hCall
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 1, lSecureCall),

        {
            (ULONG_PTR) hCall
        },

        {
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSecureCall"));
}


HRESULT
LineSendUserUserInfo(
    HCALL   hCall,
    LPCSTR  lpsUserUserInfo,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lSendUserUserInfo),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpsUserUserInfo,
            dwSize
        },

        {
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };


    if (!lpsUserUserInfo)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[1] = Dword;
        funcArgs.Args[1]     = TAPI_NO_DATA;
        funcArgs.ArgTypes[2] = Dword;
    }

    return mapTAPIErrorCode( DOFUNC (&funcArgs, "lineSendUserUserInfo") );
}


LONG
WINAPI
lineSetAgentActivity(
    HLINE   hLine,
    DWORD   dwAddressID,
    DWORD   dwActivityID
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lSetAgentActivity),

        {
            (ULONG_PTR) hLine,
            dwAddressID,
            dwActivityID
        },

        {
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetAgentActivity"));
}


LONG
WINAPI
lineSetAgentGroup(
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTGROUPLIST    lpAgentGroupList
    )
{
    static LINEAGENTGROUPLIST EmptyGroupList =
    {
        sizeof (LINEAGENTGROUPLIST),    // dwTotalSize
        sizeof (LINEAGENTGROUPLIST),    // dwNeededSize
        sizeof (LINEAGENTGROUPLIST),    // dwUsedSize
        0,                              // dwNumEntries
        0,                              // dwListSize
        0                               // dwListOffset
    };
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lSetAgentGroup),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) lpAgentGroupList
        },

        {
            Dword,
            Dword,
            lpSet_Struct
        }
    };


    if (!lpAgentGroupList)
    {
        funcArgs.Args[2] = (ULONG_PTR) &EmptyGroupList;
    }

    return (DOFUNC (&funcArgs, "lineSetAgentGroup"));
}


LONG
WINAPI
lineSetAgentState(
    HLINE   hLine,
    DWORD   dwAddressID,
    DWORD   dwAgentState,
    DWORD   dwNextAgentState
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 4, lSetAgentState),

        {
            (ULONG_PTR) hLine,
            dwAddressID,
            dwAgentState,
            dwNextAgentState
        },

        {
            Dword,
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetAgentState"));
}


LONG
WINAPI
lineSetAgentStateEx(
    HLINE               hLine,
    HAGENT              hAgent,
    DWORD               dwAgentState,
    DWORD               dwNextAgentState
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 4, lSetAgentStateEx),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) hAgent,
            dwAgentState,
            dwNextAgentState
        },

        {
            Dword,
            Dword,
            Dword,
            Dword
        }
    };


    return mapTAPIErrorCode(DOFUNC (&funcArgs, "lineSetAgentStateEx"));
}



HRESULT
LineSetAppPriority(
    LPCWSTR lpszAppName,
    DWORD   dwMediaMode,
    DWORD   dwRequestMode,
    DWORD   dwPriority
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 7, lSetAppPriority),

        {
            (ULONG_PTR) lpszAppName,
            dwMediaMode,
            (ULONG_PTR) TAPI_NO_DATA,    // (ULONG_PTR) lpExtensionID,
            0,                  // (ULONG_PTR) sizeof(LINEEXTENSIONID),
            dwRequestMode,
            (ULONG_PTR) TAPI_NO_DATA,    // (ULONG_PTR) lpszExtensionName,
            dwPriority
        },

        {
            lpszW,
            Dword,
            Dword,  // lpSet_SizeToFollow,
            Dword,  // Size,
            Dword,
            Dword,  // lpsz,
            Dword
        }
    };

    return mapTAPIErrorCode(DOFUNC (&funcArgs, "lineSetAppPriority"));
}

HRESULT
LineSetAppSpecific(
    HCALL   hCall,
    DWORD   dwAppSpecific
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lSetAppSpecific),

        {
            (ULONG_PTR) hCall,
            dwAppSpecific
        },

        {
            Dword,
            Dword
        }
    };


    return mapTAPIErrorCode(DOFUNC (&funcArgs, "lineSetAppSpecific"));
}


HRESULT
LineSetCallData(
    HCALL   hCall,
    LPVOID  lpCallData,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lSetCallData),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpCallData,
            dwSize
        },

        {
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };


    if (dwSize == 0)
    {
        funcArgs.Args[1]     = TAPI_NO_DATA;
        funcArgs.ArgTypes[1] =
        funcArgs.ArgTypes[2] = Dword;
    }

    return mapTAPIErrorCode(DOFUNC (&funcArgs, "lineSetCallData"));
}

HRESULT
WINAPI
LineSetCallHubTracking(
                       T3LINE * pt3Line,
                       LINECALLHUBTRACKINGINFO * plchti
                      )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lSetCallHubTracking),

        {
            (ULONG_PTR) (pt3Line->hLine),
            (ULONG_PTR) plchti
        },

        {
            Dword,
            lpSet_Struct
        }
    };


    return mapTAPIErrorCode( DOFUNC (&funcArgs, "lineSetCallHubTracking") );
}

HRESULT
LineSetCallParams(
    HCALL   hCall,
    DWORD   dwBearerMode,
    DWORD   dwMinRate,
    DWORD   dwMaxRate,
    LPLINEDIALPARAMS const lpDialParams
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 6, lSetCallParams),

        {
            (ULONG_PTR) hCall,
            dwBearerMode,
            dwMinRate,
            dwMaxRate,
            (ULONG_PTR) lpDialParams,
            sizeof(LINEDIALPARAMS)
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };


    if (!lpDialParams)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[4] = Dword;
        funcArgs.Args[4]     = TAPI_NO_DATA;
        funcArgs.ArgTypes[5] = Dword;
    }

    return mapTAPIErrorCode( DOFUNC (&funcArgs, "lineSetCallParams") );
}


LONG
WINAPI
lineSetCallPrivilege(
    HCALL   hCall,
    DWORD   dwCallPrivilege
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lSetCallPrivilege),

        {
            (ULONG_PTR) hCall,
            dwCallPrivilege
        },

        {
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetCallPrivilege"));
}


HRESULT
LineSetCallQualityOfService(
    HCALL             hCall,
    QOS_SERVICE_LEVEL ServiceLevel,
    DWORD             dwMediaType
    )
{
    LINECALLQOSINFO   * plqi;
    DWORD               dwSize;
    HRESULT             hr;


    dwSize = sizeof(LINECALLQOSINFO);

    plqi = (LINECALLQOSINFO *)ClientAlloc( dwSize );

    if ( NULL == plqi )
    {
        return E_OUTOFMEMORY;
    }


    plqi->dwKey = LINEQOSSTRUCT_KEY;
    plqi->dwTotalSize = dwSize;

    if ( 0 != ServiceLevel )
    {
        plqi->dwQOSRequestType = LINEQOSREQUESTTYPE_SERVICELEVEL;
        plqi->SetQOSServiceLevel.dwNumServiceLevelEntries = 1;
        plqi->SetQOSServiceLevel.LineQOSServiceLevel[0].dwMediaMode = dwMediaType;
        plqi->SetQOSServiceLevel.LineQOSServiceLevel[0].dwQOSServiceLevel = ServiceLevel;
    }

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lSetCallQualityOfService),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) TAPI_NO_DATA,
            (ULONG_PTR) 0,
            (ULONG_PTR) plqi,
            (ULONG_PTR) dwSize
        },

        {
            Dword,
            Dword,
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };


    hr = mapTAPIErrorCode( DOFUNC (&funcArgs, "lineSetCallQualityOfService") );

    ClientFree( plqi );

    return hr;
}


HRESULT
LineSetCallTreatment(
    HCALL   hCall,
    DWORD   dwTreatment
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 2, lSetCallTreatment),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwTreatment
        },

        {
            Dword,
            Dword
        }
    };


    return mapTAPIErrorCode( DOFUNC (&funcArgs, "lineSetCallTreatment") );
}


LONG
WINAPI
lineSetDevConfigW(
    DWORD   dwDeviceID,
    LPVOID  const lpDeviceConfig,
    DWORD   dwSize,
    LPCWSTR lpszDeviceClass
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lSetDevConfig),

        {
            dwDeviceID,
            (ULONG_PTR) lpDeviceConfig,
            dwSize,
            (ULONG_PTR) lpszDeviceClass
        },

        {
            Dword,
            lpSet_SizeToFollow,
            Size,
            lpszW
        }
    };


    return (DOFUNC (&funcArgs, "lineSetDevConfig"));
}


HRESULT
LineSetLineDevStatus(
    T3LINE *pt3Line,
    DWORD   dwStatusToChange,
    DWORD   fStatus
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lSetLineDevStatus),

        {
            (ULONG_PTR) pt3Line->hLine,
            dwStatusToChange,
            fStatus
        },

        {
            Dword,
            Dword,
            Dword
        }
    };


    return mapTAPIErrorCode( DOFUNC (&funcArgs, "lineSetLineDevStatus") );
}


LONG
WINAPI
lineSetMediaControl(
    HLINE   hLine,
    DWORD   dwAddressID,
    HCALL   hCall,
    DWORD   dwSelect,
    LPLINEMEDIACONTROLDIGIT const lpDigitList,
    DWORD   dwDigitNumEntries,
    LPLINEMEDIACONTROLMEDIA const lpMediaList,
    DWORD   dwMediaNumEntries,
    LPLINEMEDIACONTROLTONE  const lpToneList,
    DWORD   dwToneNumEntries,
    LPLINEMEDIACONTROLCALLSTATE const lpCallStateList,
    DWORD   dwCallStateNumEntries
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 12, lSetMediaControl),

        {
            (ULONG_PTR) hLine,
            dwAddressID,
            (ULONG_PTR) hCall,
            dwSelect,
            TAPI_NO_DATA,
            dwDigitNumEntries * sizeof(LINEMEDIACONTROLDIGIT),
            TAPI_NO_DATA,
            dwMediaNumEntries * sizeof(LINEMEDIACONTROLMEDIA),
            TAPI_NO_DATA,
            dwToneNumEntries * sizeof(LINEMEDIACONTROLTONE),
            TAPI_NO_DATA,
            dwCallStateNumEntries * sizeof(LINEMEDIACONTROLCALLSTATE)
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword
        }
    };


    //
    // If lpXxxList is non-NULL reset Arg & ArgType, and check
    // to see that dwXxxNumEntries is not unacceptably large
    //

    if (lpDigitList)
    {
            if (dwDigitNumEntries >
                    (0x1000000 / sizeof (LINEMEDIACONTROLDIGIT)))
            {
            return LINEERR_INVALPOINTER;
            }

            funcArgs.ArgTypes[4] = lpSet_SizeToFollow;
            funcArgs.Args[4]     = (ULONG_PTR) lpDigitList;
            funcArgs.ArgTypes[5] = Size;
    }

    if (lpMediaList)
    {
            if (dwMediaNumEntries >
                    (0x1000000 / sizeof (LINEMEDIACONTROLMEDIA)))
            {
            return LINEERR_INVALPOINTER;
            }

            funcArgs.ArgTypes[6] = lpSet_SizeToFollow;
            funcArgs.Args[6]     = (ULONG_PTR) lpMediaList;
            funcArgs.ArgTypes[7] = Size;
    }

    if (lpToneList)
    {
            if (dwToneNumEntries >
                    (0x1000000 / sizeof (LINEMEDIACONTROLTONE)))
            {
            return LINEERR_INVALPOINTER;
            }

            funcArgs.ArgTypes[8] = lpSet_SizeToFollow;
            funcArgs.Args[8]     = (ULONG_PTR) lpToneList;
            funcArgs.ArgTypes[9] = Size;
    }

    if (lpCallStateList)
    {
            if (dwCallStateNumEntries >
                    (0x1000000 / sizeof (LINEMEDIACONTROLCALLSTATE)))
            {
            return LINEERR_INVALPOINTER;
            }

            funcArgs.ArgTypes[10] = lpSet_SizeToFollow;
            funcArgs.Args[10]     = (ULONG_PTR) lpCallStateList;
            funcArgs.ArgTypes[11] = Size;
    }

    return (DOFUNC (&funcArgs, "lineSetMediaControl"));
}


HRESULT
LineSetMediaMode(
                 HCALL   hCall,
                 DWORD   dwMediaModes
                )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lSetMediaMode),

        {
            (ULONG_PTR) hCall,
            dwMediaModes
        },

        {
            Dword,
            Dword
        }
    };


    return mapTAPIErrorCode( DOFUNC (&funcArgs, "lineSetMediaMode") );
}


LONG
WINAPI
lineSetNumRings(
    HLINE   hLine,
    DWORD   dwAddressID,
    DWORD   dwNumRings
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lSetNumRings),

        {
            (ULONG_PTR) hLine,
            dwAddressID,
            dwNumRings
        },

        {
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetNumRings"));
}



HRESULT
LineSetStatusMessages(
    T3LINE * pt3Line,
    DWORD dwLineStates,
    DWORD dwAddressStates
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lSetStatusMessages),

        {
            (ULONG_PTR) pt3Line->hLine,
            dwLineStates,
            dwAddressStates
        },

        {
            Dword,
            Dword,
            Dword
        }
    };


    return mapTAPIErrorCode( DOFUNC (&funcArgs, "lineSetStatusMessages") );
}


LONG
WINAPI
lineSetTerminal(
    HLINE   hLine,
    DWORD   dwAddressID,
    HCALL   hCall,
    DWORD   dwSelect,
    DWORD   dwTerminalModes,
    DWORD   dwTerminalID,
    DWORD   bEnable
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 7, lSetTerminal),

        {
            (ULONG_PTR) hLine,
            dwAddressID,
            (ULONG_PTR) hCall,
            dwSelect,
            dwTerminalModes,
            dwTerminalID,
            bEnable
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetTerminal"));
}


void
PASCAL
lineSetupConferencePostProcess(
    PASYNCEVENTMSG pMsg
    )
{
    LOG((TL_TRACE, "lineSetupConfPostProcess: enter"));
    LOG((TL_INFO,
        "\t\tdwP1=x%lx, dwP2=x%lx, dwP3=x%lx, dwP4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param2 == 0)
    {
        HCALL   hConfCall      = (HCALL) pMsg->Param3,
                hConsultCall   = (HCALL) (*(&pMsg->Param4 + 1));

        LPHCALL lphConfCall    = 
            (LPHCALL) GetHandleTableEntry(pMsg->Param4);

        LPHCALL lphConsultCall = 
            (LPHCALL) GetHandleTableEntry(*(&pMsg->Param4 + 2));

        LOG((TL_INFO, 
            "lineSetupConfPostProcess: hConfCall [%lx] hConsultCall [%lx] lphConfCall [%p] lphConsultCall [%p]",
            hConfCall, hConsultCall, lphConfCall, lphConsultCall));

        __try
        {
            {
                *lphConfCall = NULL;
                *lphConsultCall = NULL;


                *lphConfCall = hConfCall;
                *lphConsultCall = hConsultCall;
            }
        }
        __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {
            pMsg->Param2 = LINEERR_INVALPOINTER;

            LOG((TL_WARN, 
               "lineSetupConfPostProcess: failed to set memory at %p or at %p",
               lphConfCall, lphConsultCall));

            //
            // tapisrv has allocated call handles for us. deallocate them.
            //

            LineDeallocateCall(hConfCall);
            LineDeallocateCall(hConsultCall);
        }
    }
}


HRESULT
LineSetupConference(
    HCALL    hCall,
    T3LINE * pt3Line,
    HCALL  * phConfCall,
    HCALL  * phConsultCall,
    DWORD   dwNumParties,
    LPLINECALLPARAMS    const lpCallParams
    )
{

    if ( phConfCall ==  phConsultCall )
    {
        return E_POINTER;
    }


    DWORD hpConfCallHandle = CreateHandleTableEntry((ULONG_PTR) phConfCall);

    DWORD hpConsultCallHandle = CreateHandleTableEntry((ULONG_PTR) phConsultCall);


    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 8, lSetupConference),

        {
            GetFunctionIndex(lineSetupConferencePostProcess),
            (ULONG_PTR) hCall,
            (ULONG_PTR) pt3Line->hLine,
            hpConfCallHandle,
            hpConsultCallHandle,
            (ULONG_PTR) dwNumParties,
            (ULONG_PTR) lpCallParams,
            (ULONG_PTR) 0xffffffff      // dwAsciiCallParamsCodePage
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            lpSet_Struct,
            Dword
        }
    };



    if (!lpCallParams)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[6] = Dword;
        funcArgs.Args[6]     = TAPI_NO_DATA;
    }


    HRESULT hr = mapTAPIErrorCode( DOFUNC (&funcArgs, "LineSetupConference") );

    if (FAILED(hr))
    {
        DeleteHandleTableEntry(hpConfCallHandle);
        DeleteHandleTableEntry(hpConsultCallHandle);
    }

    return hr;
}

HRESULT
LineSetupTransfer(
    HCALL hCall,
    HCALL *phConsultCall,
    LPLINECALLPARAMS  const lpCallParams
    )
{

    DWORD hpConsultCallHandle = CreateHandleTableEntry((ULONG_PTR)phConsultCall);

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lSetupTransfer),

        {
            GetFunctionIndex(lineMakeCallPostProcess),
            (ULONG_PTR) hCall,
            hpConsultCallHandle,
            (ULONG_PTR) lpCallParams,
            0xffffffff      // dwAsciiCallParamsCodePage
        },

        {
            Dword,
            Dword,
            Dword,
            lpSet_Struct,
            Dword
        }
    };


    if (!lpCallParams)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[3] = Dword;
        funcArgs.Args[3]     = TAPI_NO_DATA;
    }


    HRESULT hr = mapTAPIErrorCode( DOFUNC (&funcArgs, "lineSetupTransferW") );

    if (FAILED(hr))
    {
        DeleteHandleTableEntry(hpConsultCallHandle);
        hpConsultCallHandle = 0;
    }

    return hr;
}


HRESULT
LineSwapHold(
    HCALL hActiveCall,
    HCALL hHeldCall
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 2, lSwapHold),

        {
            (ULONG_PTR) hActiveCall,
            (ULONG_PTR) hHeldCall
        },

        {
            Dword,
            Dword
        }
    };

    return mapTAPIErrorCode( DOFUNC (&funcArgs, "lineSwapHold") );
}


LONG
WINAPI
lineUncompleteCall(
    HLINE   hLine,
    DWORD   dwCompletionID
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 2, lUncompleteCall),

        {
            (ULONG_PTR) hLine,
            dwCompletionID
        },

        {
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineUncompleteCall"));
}


HRESULT
LineUnhold(
    HCALL hCall
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 1, lUnhold),

        {
            (ULONG_PTR) hCall
        },

        {
            Dword
        }
    };


    return mapTAPIErrorCode( DOFUNC (&funcArgs, "lineUnhold") );
}


HRESULT
LineUnpark(
    HLINE     hLine,
    DWORD     dwAddressID,
    HCALL     *phCall,
    LPCWSTR   lpszDestAddress
    )
{

    DWORD hpCallHandle = CreateHandleTableEntry((ULONG_PTR)phCall);


    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lUnpark),

        {
            GetFunctionIndex(lineMakeCallPostProcess),
            (ULONG_PTR) hLine,
            dwAddressID,
            hpCallHandle,
            (ULONG_PTR) lpszDestAddress
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpszW
        }
    };



    HRESULT hr = mapTAPIErrorCode( DOFUNC (&funcArgs, "LineUnpark") );

    if (FAILED(hr))
    {
        DeleteHandleTableEntry(hpCallHandle);
    }
    
    return hr;
}


//
// ------------------------------- phoneXxx -----------------------------------
//


///////////////////////////////////////////////////////////////////////////////
//
// PhoneClose
//
//
// Closes the phone specified by hPhone, the mode of hash table clean up is
// described by bCleanHashTableOnFailure
//
// Arguments:
//
//  HPHONE hPhone  -- handle of the phone to close
//
//  BOOL bCleanHashTableOnFailure -- boolean that specifies how phone 
// hash table should be cleaned:
//
//      FALSE -- remove hash table entry only if the call succeeds. The caller 
//      function will then have the opportunity to perform transaction-like 
//      error handling -- it could recover the state from before the function 
//      was called, so it could return an error which would mean that the state
//      remained unchanged
//
//      TRUE -- clean table even if tapisrv call fails. The caller will not be 
//      able to recover the original state in case of failure. this is ok for
//      the functions that do not provide full error handling for PhoneClose
// 

HRESULT
PhoneClose(
    HPHONE hPhone,
    BOOL bCleanHashTableOnFailure   // = TRUE
    )
{
    LOG((TL_INFO, "PhoneClose - enter. hPhone[%p] CleanOnError[%d]", 
        hPhone, bCleanHashTableOnFailure));

    LONG            lResult;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 1, pClose),

        {
            (ULONG_PTR) hPhone
        },

        {
            Dword
        }
    };

    gpPhoneHashTable->Lock();

    lResult = (DOFUNC (&funcArgs, "phoneClose"));


    //
    // clean hash table entry if needed
    //

    if ( (0 == lResult) || bCleanHashTableOnFailure )
    {
        LOG((TL_INFO, "PhoneClose - removing phone's hash table entry"));

        gpPhoneHashTable->Remove( (ULONG_PTR)(hPhone) );
    }

    gpPhoneHashTable->Unlock();


    //
    // get hr error code
    //

    HRESULT hr = mapTAPIErrorCode( lResult );
        
    LOG((TL_INFO, "PhoneClose - exit. hr = %lx", hr));

    return hr;
}


LONG
WINAPI
phoneConfigDialogW(
    DWORD   dwDeviceID,
    HWND    hwndOwner,
    LPCWSTR lpszDeviceClass
    )
{
    LONG        lResult;
    HANDLE      hDll;
    TUISPIPROC  pfnTUISPI_phoneConfigDialog;


    if (lpszDeviceClass && IsBadStringPtrW (lpszDeviceClass, (UINT) -1))
    {
        return PHONEERR_INVALPOINTER;
    }

    if ((lResult = LoadUIDll(
            hwndOwner,
            dwDeviceID,
            TUISPIDLL_OBJECT_PHONEID,
            &hDll,
            gszTUISPI_phoneConfigDialog,
            &pfnTUISPI_phoneConfigDialog

            )) == 0)
    {
        LOG((TL_INFO, "Calling TUISPI_phoneConfigDialog..."));

        lResult = ((TUIPHONECONFIGPROC)(*pfnTUISPI_phoneConfigDialog))(
            TUISPIDLLCallback,
            dwDeviceID,
            (HWND)hwndOwner,
            (char *)lpszDeviceClass
            );

#if DBG
        {
            char szResult[32];


            LOG((TL_INFO,
                "TUISPI_phoneConfigDialog: result = %s",
                MapResultCodeToText (lResult, szResult)
                ));
        }
#endif
        FreeLibrary ((HINSTANCE)hDll);
    }

    return lResult;
}

void
PASCAL
phoneDevSpecificPostProcess(
    PASYNCEVENTMSG pMsg
    )
{
    LOG((TL_TRACE, "phoneDevSpecificPostProcess: enter"));
    LOG((TL_INFO,
        "\t\tdwP1=x%lx, dwP2=x%lx, dwP3=x%lx, dwP4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param2 == 0)
    {
        DWORD   dwSize  = pMsg->Param4;
        
        LPBYTE  pParams = 
            (LPBYTE) GetHandleTableEntry(pMsg->Param3);

        __try
        {
            {
                CopyMemory (pParams, (LPBYTE) (pMsg + 1), dwSize);
            }
        }
        __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {
            
            pMsg->Param2 = PHONEERR_INVALPOINTER;
            
            LOG((TL_WARN, 
                "phoneDevSpecificPostProcess: failed to copy %ld(10) bytes, %p -> %p."
                "PHONEERR_INVALPOINTER",
                dwSize, (LPBYTE) (pMsg + 1), pParams));

        }
    }
}


HRESULT
WINAPI
phoneDevSpecific(
    HPHONE  hPhone,
    LPVOID  lpParams,
    DWORD   dwSize
    )
{
    DWORD hpParams = CreateHandleTableEntry((ULONG_PTR)lpParams);

    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 5, pDevSpecific),

        {
            GetFunctionIndex(phoneDevSpecificPostProcess),
            (ULONG_PTR) hPhone,
            hpParams, // passed as Dword for post processing
            (ULONG_PTR) lpParams, // passed as LpSet_Xxx for IsValidPtr chk
            dwSize
        },

        {
            Dword,
            Dword,
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };


    LONG lResult = DOFUNC (&funcArgs, "phoneDevSpecific");


    //
    // remove the handle table entry if failed. otherwise the LINE_REPLY will
    // do this.
    //

    HRESULT hr = E_FAIL;

    if (lResult <= 0)
    {
        DeleteHandleTableEntry(hpParams);
        hpParams = 0;

        hr = mapTAPIErrorCode(lResult);
    }
    else
    {

        //
        // block to see if the operation succeeds
        //

        hr = WaitForPhoneReply(lResult);

    }


    return hr;
}

HRESULT
PhoneSetStatusMessages(
    T3PHONE * pt3Phone,
    DWORD dwPhoneStates,
    DWORD dwButtonModes,
    DWORD dwButtonStates
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 4, pSetStatusMessages),

        {
            (ULONG_PTR) pt3Phone->hPhone,
            dwPhoneStates,
            dwButtonModes,
            dwButtonStates
        },

        {
            Dword,
            Dword,
            Dword,
            Dword
        }
    };


    return mapTAPIErrorCode( DOFUNC (&funcArgs, "phoneSetStatusMessages") );
}

HRESULT
PhoneGetButtonInfo(
    HPHONE  hPhone,
    DWORD   dwButtonLampID,
    LPPHONEBUTTONINFO * ppButtonInfo
    )
{
    LONG        lResult;

    *ppButtonInfo = (LPPHONEBUTTONINFO) ClientAlloc( sizeof(PHONEBUTTONINFO) + 500 );

    if (NULL == *ppButtonInfo)
    {
        return E_OUTOFMEMORY;
    }

    (*ppButtonInfo)->dwTotalSize = sizeof(PHONEBUTTONINFO) + 500;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 3, pGetButtonInfo),

        {
            (ULONG_PTR) hPhone,
            dwButtonLampID,
            (ULONG_PTR) *ppButtonInfo
        },

        {
            Dword,
            Dword,
            lpGet_Struct
        }
    };

    while (TRUE)
    {
        lResult = DOFUNC (&funcArgs, "phoneGetButtonInfo");

        if ((0 == lResult) && ((*ppButtonInfo)->dwNeededSize > (*ppButtonInfo)->dwTotalSize))
        {
            DWORD       dwSize = (*ppButtonInfo)->dwNeededSize;

            ClientFree( *ppButtonInfo );

            *ppButtonInfo = (LPPHONEBUTTONINFO) ClientAlloc( dwSize );

            if (NULL == *ppButtonInfo)
            {
                return E_OUTOFMEMORY;
            }

            (*ppButtonInfo)->dwTotalSize = dwSize;

            funcArgs.Args[2] = (ULONG_PTR)*ppButtonInfo;

        }
        else
        {
            break;
        }
    }

    return mapTAPIErrorCode(lResult);
}


LONG
WINAPI
phoneGetData(
    HPHONE  hPhone,
    DWORD   dwDataID,
    LPVOID  lpData,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 4, pGetData),

        {
            (ULONG_PTR) hPhone,
            dwDataID,
            (ULONG_PTR) lpData,
            dwSize
        },

        {
            Dword,
            Dword,
            lpGet_SizeToFollow,
            Size
        }
    };


    return (DOFUNC (&funcArgs, "phoneGetData"));
}


HRESULT
PhoneGetDevCapsWithAlloc(
                HPHONEAPP   hPhoneApp,
                DWORD       dwDeviceID,
                DWORD       dwAPIVersion,
                LPPHONECAPS * ppPhoneCaps
               )
{
    LONG        lResult;

    *ppPhoneCaps = (LPPHONECAPS) ClientAlloc( sizeof(PHONECAPS) + 500 );

    if (NULL == *ppPhoneCaps)
    {
        return E_OUTOFMEMORY;
    }

    (*ppPhoneCaps)->dwTotalSize = sizeof(PHONECAPS) + 500;


    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 5, pGetDevCaps),

        {
            (ULONG_PTR) hPhoneApp,
            dwDeviceID,
            dwAPIVersion,
            0,
            (ULONG_PTR) *ppPhoneCaps
        },

        {
            hXxxApp,
            Dword,
            Dword,
            Dword,
            lpGet_Struct
        }
    };

    while (TRUE)
    {
        lResult = DOFUNC (&funcArgs, "phoneGetDevCaps");

        if ((0 == lResult) && ((*ppPhoneCaps)->dwNeededSize > (*ppPhoneCaps)->dwTotalSize))
        {
            DWORD       dwSize = (*ppPhoneCaps)->dwNeededSize;

            ClientFree( *ppPhoneCaps );

            *ppPhoneCaps = (LPPHONECAPS) ClientAlloc( dwSize );

            if (NULL == *ppPhoneCaps)
            {
                return E_OUTOFMEMORY;
            }

            (*ppPhoneCaps)->dwTotalSize = dwSize;

            funcArgs.Args[4] = (ULONG_PTR)*ppPhoneCaps;

        }
        else
        {
            break;
        }
    }

    return mapTAPIErrorCode(lResult);
}

HRESULT
PhoneGetDevCaps(
                HPHONEAPP   hPhoneApp,
                DWORD       dwDeviceID,
                DWORD       dwAPIVersion,
                LPPHONECAPS * ppPhoneCaps
               )
{
    LONG lResult;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 5, pGetDevCaps),

        {
            (ULONG_PTR) hPhoneApp,
            dwDeviceID,
            dwAPIVersion,
            0,
            (ULONG_PTR) *ppPhoneCaps
        },

        {
            hXxxApp,
            Dword,
            Dword,
            Dword,
            lpGet_Struct
        }
    };

    while (TRUE)
    {
        lResult = DOFUNC (&funcArgs, "phoneGetDevCaps");

        if ((0 == lResult) && ((*ppPhoneCaps)->dwNeededSize > (*ppPhoneCaps)->dwTotalSize))
        {
            DWORD       dwSize = (*ppPhoneCaps)->dwNeededSize;

            ClientFree( *ppPhoneCaps );

            *ppPhoneCaps = (LPPHONECAPS) ClientAlloc( dwSize );

            if (NULL == *ppPhoneCaps)
            {
                return E_OUTOFMEMORY;
            }

            (*ppPhoneCaps)->dwTotalSize = dwSize;

            funcArgs.Args[4] = (ULONG_PTR)*ppPhoneCaps;

        }
        else
        {
            break;
        }
    }

    return mapTAPIErrorCode(lResult);
}

HRESULT
PhoneGetDisplay(
          HPHONE      hPhone,
          LPVARSTRING * ppDisplay
          )
{
    LONG            lResult;

    *ppDisplay = (LPVARSTRING) ClientAlloc( sizeof (VARSTRING) + 500 );

    if (NULL == *ppDisplay)
    {
        return E_OUTOFMEMORY;
    }

    (*ppDisplay)->dwTotalSize = sizeof (VARSTRING) + 500;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 2, pGetDisplay),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) *ppDisplay
        },

        {
            Dword,
            lpGet_Struct
        }
    };

    LOG((TL_TRACE, "PhoneGetDisplay - enter"));
    LOG((TL_INFO, "   hPhone ---------->%lx", hPhone));
    LOG((TL_INFO, "   ppDisplay ------->%p", ppDisplay));

    while ( TRUE )
    {
        lResult = DOFUNC (&funcArgs, "phoneGetDisplay");

        if ((lResult == 0) && ((*ppDisplay)->dwNeededSize > (*ppDisplay)->dwTotalSize))
        {
            DWORD       dwSize = (*ppDisplay)->dwNeededSize;

            ClientFree(*ppDisplay);

            *ppDisplay = (LPVARSTRING)ClientAlloc(dwSize);

            if (NULL == *ppDisplay)
            {
                LOG((TL_ERROR, "PhoneGetDisplay exit - return E_OUTOFMEMORY"));
                return E_OUTOFMEMORY;
            }

            (*ppDisplay)->dwTotalSize = dwSize;

            funcArgs.Args[4] = (ULONG_PTR)*ppDisplay;
        }
        else
        {
            break;
        }
    }

    LOG((TL_TRACE, "PhoneGetDisplay exit"));

    return mapTAPIErrorCode( lResult );
}


HRESULT
PhoneGetGain(
    HPHONE hPhone,
    DWORD dwHookSwitchDev,
    LPDWORD lpdwGain
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 3, pGetGain),

        {
            (ULONG_PTR) hPhone,
            dwHookSwitchDev,
            (ULONG_PTR) lpdwGain
        },

        {
            Dword,
            Dword,
            lpDword
        }
    };


    return mapTAPIErrorCode(DOFUNC (&funcArgs, "phoneGetGain"));
}


HRESULT
PhoneGetHookSwitch(
    HPHONE hPhone,
    LPDWORD lpdwHookSwitchDevs
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 2, pGetHookSwitch),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) lpdwHookSwitchDevs
        },

        {
            Dword,
            lpDword
        }
    };


    return mapTAPIErrorCode(DOFUNC (&funcArgs, "phoneGetHookSwitch"));
}


LONG
WINAPI
phoneGetIconW(
    DWORD   dwDeviceID,
    LPCWSTR lpszDeviceClass,
    LPHICON lphIcon
    )
{
    HICON   hIcon;
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 3, pGetIcon),

        {
            dwDeviceID,
            (ULONG_PTR) lpszDeviceClass,
            (ULONG_PTR) &hIcon
        },

        {
            Dword,
            lpszW,
            lpDword
        }
    };
    LONG    lResult;


    if (IsBadDwordPtr ((LPDWORD) lphIcon))
    {
        return PHONEERR_INVALPOINTER;
    }

    if (lpszDeviceClass == (LPCWSTR) NULL)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[1] = Dword;
        funcArgs.Args[1]     = TAPI_NO_DATA;
    }

    if ((lResult = DOFUNC (&funcArgs, "phoneGetIcon")) == 0)
    {
        *lphIcon = hIcon;
    }
    return lResult;
}


HRESULT
PhoneGetID(
          HPHONE      hPhone,
          LPVARSTRING * ppDeviceID,
          LPCWSTR     lpszDeviceClass
          )
{
    LONG        lResult;
    DWORD       dwNumDevices;
    DWORD       dwDeviceId1, dwDeviceId2;
    BOOL        bWaveDevice = FALSE;

    *ppDeviceID = (LPVARSTRING) ClientAlloc( sizeof (VARSTRING) + 500 );

    if (NULL == *ppDeviceID)
    {
        return E_OUTOFMEMORY;
    }

    (*ppDeviceID)->dwTotalSize = sizeof (VARSTRING) + 500;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 3, pGetID),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) *ppDeviceID,
            (ULONG_PTR) lpszDeviceClass
        },

        {
            Dword,
            lpGet_Struct,
            lpszW
        }
    };


    LOG((TL_TRACE, "PhoneGetID - enter"));
    LOG((TL_INFO, "   hPhone ---------->%lx", hPhone));
    LOG((TL_INFO, "   ppDeviceID ------>%p", ppDeviceID));
    LOG((TL_INFO, "   lpszDeviceClass ->%p", lpszDeviceClass));

    //
    // If the request is for a wave device, call PGetIDEx.
    // This will return a device string ID which is guaranteed to be unique across 
    // all processes. 
    // Then we will convert the string ID to the correct device ID in the client process context.
    //

    if (!_wcsicmp(lpszDeviceClass, L"wave/in")  ||
        !_wcsicmp(lpszDeviceClass, L"wave/out") ||
        !_wcsicmp(lpszDeviceClass, L"midi/in")  ||
        !_wcsicmp(lpszDeviceClass, L"midi/out") ||
        !_wcsicmp(lpszDeviceClass, L"wave/in/out")
       )
    {
        bWaveDevice = TRUE;
        dwNumDevices = _wcsicmp(lpszDeviceClass, L"wave/in/out") ? 1 : 2;
        funcArgs.Flags = MAKELONG (PHONE_FUNC | SYNC | 3, pGetIDEx);
    }
    
    while ( TRUE )
    {
        lResult = DOFUNC (&funcArgs, bWaveDevice ? "phoneGetIDEx" : "phoneGetID");

        if ((lResult == 0) && ((*ppDeviceID)->dwNeededSize > (*ppDeviceID)->dwTotalSize))
        {
            DWORD       dwSize = (*ppDeviceID)->dwNeededSize;

            ClientFree(*ppDeviceID);

            *ppDeviceID = (LPVARSTRING)ClientAlloc(dwSize);

            if (NULL == *ppDeviceID)
            {
                LOG((TL_ERROR, "PhoneGetID exit - return LINEERR_NOMEM"));
                return E_OUTOFMEMORY;
            }

            (*ppDeviceID)->dwTotalSize = dwSize;

            funcArgs.Args[1] = (ULONG_PTR)*ppDeviceID;
        }
        else
        {
            break;
        }
    }

    if (bWaveDevice && lResult == 0)
    {
        //
        // We got the string ID(s), now we need to convert them to numeric device ID(s)
        //
        BOOL    bConversionOk;

        if ( dwNumDevices == 1 )
        {
            bConversionOk = WaveStringIdToDeviceId (
                    (LPWSTR)((LPBYTE)(*ppDeviceID) + (*ppDeviceID)->dwStringOffset),
                    lpszDeviceClass,
                    &dwDeviceId1);
        }
        else
        {
            _ASSERTE(dwNumDevices == 2);

            // 
            // for "wave/in/out", we get back two devices from tapisrv -> convert both
            //
            LPWSTR  szString1 = (LPWSTR)((LPBYTE)(*ppDeviceID) + (*ppDeviceID)->dwStringOffset);

            // first convert the wave/in device 
            bConversionOk = WaveStringIdToDeviceId (
                    szString1,
                    L"wave/in",
                    &dwDeviceId1);

            // next convert the wave/out device
            bConversionOk = bConversionOk && WaveStringIdToDeviceId (
                    szString1 + wcslen(szString1),
                    L"wave/out",
                    &dwDeviceId2);
        }

        if (!bConversionOk)
        {
            LOG((TL_ERROR, "PhoneGetID - WaveStringIdToDeviceId failed"));
            ClientFree(*ppDeviceID);
            *ppDeviceID = NULL;
            lResult = LINEERR_OPERATIONFAILED;
        }
        else
        {
            //
            // conversion succeeded, now fill the VARSTRING to be returned to the caller
            //
            (*ppDeviceID)->dwNeededSize = (*ppDeviceID)->dwUsedSize = 
                sizeof(VARSTRING) + sizeof(DWORD) * dwNumDevices;
            (*ppDeviceID)->dwStringFormat = STRINGFORMAT_BINARY;
            (*ppDeviceID)->dwStringSize = sizeof(DWORD) * dwNumDevices;
            (*ppDeviceID)->dwStringOffset = sizeof(VARSTRING);
            *(DWORD *)((*ppDeviceID) + 1) = dwDeviceId1;
            if (dwNumDevices == 2) 
                *((DWORD *)((*ppDeviceID) + 1) + 1) = dwDeviceId2;
        }
    }
    
    LOG((TL_TRACE, "PhoneGetID exit - return %lx", lResult));

    return mapTAPIErrorCode( lResult );
}


HRESULT
PhoneGetLamp(
    HPHONE hPhone,
    DWORD dwButtonLampID,
    LPDWORD lpdwLampMode
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 3, pGetLamp),

        {
            (ULONG_PTR) hPhone,
            dwButtonLampID,
            (ULONG_PTR) lpdwLampMode
        },

        {
            Dword,
            Dword,
            lpDword
        }
    };


    return mapTAPIErrorCode(DOFUNC (&funcArgs, "phoneGetLamp"));
}

HRESULT
PhoneGetRing(
    HPHONE hPhone,
    LPDWORD lpdwRingMode,
    LPDWORD lpdwVolume
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 3, pGetRing),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) lpdwRingMode,
            (ULONG_PTR) lpdwVolume
        },

        {
            Dword,
            lpDword,
            lpDword
        }
    };


    if (lpdwRingMode == lpdwVolume)
    {
        return E_POINTER;
    }

    return mapTAPIErrorCode(DOFUNC (&funcArgs, "phoneGetRing"));
}


HRESULT
PhoneGetStatusWithAlloc(
    HPHONE hPhone,
    LPPHONESTATUS *ppPhoneStatus
    )
{
    LONG        lResult;

    *ppPhoneStatus = (LPPHONESTATUS) ClientAlloc( sizeof(PHONESTATUS) + 500 );

    if (NULL == *ppPhoneStatus)
    {
        return E_OUTOFMEMORY;
    }

    (*ppPhoneStatus)->dwTotalSize = sizeof(PHONESTATUS) + 500;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 2, pGetStatus),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) *ppPhoneStatus
        },

        {
            Dword,
            lpGet_Struct
        }
    };

    while (TRUE)
    {
        lResult = DOFUNC (&funcArgs, "phoneGetStatus");

        if ((0 == lResult) && ((*ppPhoneStatus)->dwNeededSize > (*ppPhoneStatus)->dwTotalSize))
        {
            DWORD       dwSize = (*ppPhoneStatus)->dwNeededSize;

            ClientFree( *ppPhoneStatus );

            *ppPhoneStatus = (LPPHONESTATUS) ClientAlloc( dwSize );

            if (NULL == *ppPhoneStatus)
            {
                return E_OUTOFMEMORY;
            }

            (*ppPhoneStatus)->dwTotalSize = dwSize;

            funcArgs.Args[4] = (ULONG_PTR)*ppPhoneStatus;

        }
        else
        {
            break;
        }
    }

    return mapTAPIErrorCode(lResult);
}


LONG
WINAPI
phoneGetStatusMessages(
    HPHONE hPhone,
    LPDWORD lpdwPhoneStates,
    LPDWORD lpdwButtonModes,
    LPDWORD lpdwButtonStates
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 4, pGetStatusMessages),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) lpdwPhoneStates,
            (ULONG_PTR) lpdwButtonModes,
            (ULONG_PTR) lpdwButtonStates
        },

        {
            Dword,
            lpDword,
            lpDword,
            lpDword
        }
    };


    if (lpdwPhoneStates == lpdwButtonModes  ||
        lpdwPhoneStates == lpdwButtonStates  ||
        lpdwButtonModes == lpdwButtonStates)
    {
        return PHONEERR_INVALPOINTER;
    }

    return (DOFUNC (&funcArgs, "phoneGetStatusMessages"));
}


HRESULT
PhoneGetVolume(
    HPHONE hPhone,
    DWORD dwHookSwitchDev,
    LPDWORD lpdwVolume
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 3, pGetVolume),

        {
            (ULONG_PTR) hPhone,
            dwHookSwitchDev,
            (ULONG_PTR) lpdwVolume
        },

        {
            Dword,
            Dword,
            lpDword
        }
    };


    return mapTAPIErrorCode(DOFUNC (&funcArgs, "phoneGetVolume"));
}


HRESULT
PhoneNegotiateAPIVersion(
                        HPHONEAPP     hPhoneApp,
                        DWORD        dwDeviceID,
                        LPDWORD      lpdwAPIVersion
                       )
{
    PHONEEXTENSIONID     PED;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 7, pNegotiateAPIVersion),

        {
            (ULONG_PTR) hPhoneApp,
            dwDeviceID,
            TAPI_VERSION1_0,
            TAPI_VERSION_CURRENT,
            (ULONG_PTR) lpdwAPIVersion,
            (ULONG_PTR) &PED,
            (ULONG_PTR) sizeof(PHONEEXTENSIONID)
        },

        {
            hXxxApp,
            Dword,
            Dword,
            Dword,
            lpDword,
            lpGet_SizeToFollow,
            Size
        }
    };


    return mapTAPIErrorCode( DOFUNC (&funcArgs, "phoneNegotiateAPIVersion") );
}


LONG
WINAPI
phoneNegotiateExtVersion(
    HPHONEAPP   hPhoneApp,
    DWORD       dwDeviceID,
    DWORD       dwAPIVersion,
    DWORD       dwExtLowVersion,
    DWORD       dwExtHighVersion,
    LPDWORD     lpdwExtVersion
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 6, pNegotiateExtVersion),

        {
            (ULONG_PTR) hPhoneApp,
            dwDeviceID,
            dwAPIVersion,
            dwExtLowVersion,
            dwExtHighVersion,
            (ULONG_PTR) lpdwExtVersion
        },

        {
            hXxxApp,
            Dword,
            Dword,
            Dword,
            Dword,
            lpDword
        }
    };


    return (DOFUNC (&funcArgs, "phoneNegotiateExtVersion"));
}


HRESULT
PhoneOpen(
          HPHONEAPP   hPhoneApp,
          DWORD       dwDeviceID,
          T3PHONE *   pt3Phone,
          DWORD       dwAPIVersion,
          DWORD       dwPrivilege
         )
{
    HRESULT     hr;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 8, pOpen),

        {
            (ULONG_PTR) hPhoneApp,
            dwDeviceID,
            (ULONG_PTR) &(pt3Phone->hPhone),
            dwAPIVersion,
            0,
            0,
            dwPrivilege,
            0,                  // PHONEOPEN_PARAMS.hRemotePhone
        },

        {
            hXxxApp,
            Dword,
            lpDword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword
        }
    };

    gpPhoneHashTable->Lock();

    hr = ( DOFUNC (&funcArgs, "phoneOpen") );

    if ( 0 == hr )
    {
#ifdef USE_PHONEMSP
        gpPhoneHashTable->Insert( (ULONG_PTR)(pt3Phone->hPhone), (ULONG_PTR)(pt3Phone->pMSPCall) );
#else
        gpPhoneHashTable->Insert( (ULONG_PTR)(pt3Phone->hPhone), (ULONG_PTR)(pt3Phone->pPhone) );
#endif USE_PHONEMSP
    }

    gpPhoneHashTable->Unlock();

    return mapTAPIErrorCode( hr );
}


HRESULT
PhoneSetButtonInfo(
    HPHONE hPhone,
    DWORD dwButtonLampID,
    LPPHONEBUTTONINFO const pButtonInfo
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 3, pSetButtonInfo),

        {
            (ULONG_PTR) hPhone,
            dwButtonLampID,
            (ULONG_PTR) pButtonInfo
        },

        {
            Dword,
            Dword,
            lpSet_Struct
        }
    };

    LONG lResult = DOFUNC (&funcArgs, "phoneSetButtonInfo");
        
    if (lResult > 0)    // async reply
    {
        return WaitForPhoneReply( lResult );
    }
    else
    {
        return mapTAPIErrorCode( lResult );
    }
}


LONG
WINAPI
phoneSetData(
    HPHONE  hPhone,
    DWORD   dwDataID,
    LPVOID  const lpData,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 4, pSetData),

        {
            (ULONG_PTR) hPhone,
            dwDataID,
            (ULONG_PTR) lpData,
            dwSize
        },

        {
            Dword,
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };


    return (DOFUNC (&funcArgs, "phoneSetData"));
}


HRESULT
PhoneSetDisplay(
    HPHONE  hPhone,
    DWORD   dwRow,
    DWORD   dwColumn,
    LPCSTR  lpsDisplay,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 5, pSetDisplay),

        {
            (ULONG_PTR) hPhone,
            dwRow,
            dwColumn,
            (ULONG_PTR) lpsDisplay,
            dwSize
        },

        {
            Dword,
            Dword,
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };

    LONG lResult = DOFUNC (&funcArgs, "phoneSetDisplay");
        
    if (lResult > 0)    // async reply
    {
        return WaitForPhoneReply( lResult );
    }
    else
    {
        return mapTAPIErrorCode( lResult );
    }
}


HRESULT
PhoneSetGain(
    HPHONE  hPhone,
    DWORD   dwHookSwitchDev,
    DWORD   dwGain
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 3, pSetGain),

        {
            (ULONG_PTR) hPhone,
            dwHookSwitchDev,
            dwGain
        },

        {
            Dword,
            Dword,
            Dword
        }
    };

    LONG lResult = DOFUNC (&funcArgs, "phoneSetGain");
        
    if (lResult > 0)    // async reply
    {
        return WaitForPhoneReply( lResult );
    }
    else
    {
        return mapTAPIErrorCode( lResult );
    }
}


HRESULT
PhoneSetHookSwitch(
    HPHONE hPhone,
    DWORD  dwHookSwitchDevs,
    DWORD  dwHookSwitchMode
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 3, pSetHookSwitch),

        {
            (ULONG_PTR) hPhone,
            dwHookSwitchDevs,
            dwHookSwitchMode
        },

        {
            Dword,
            Dword,
            Dword
        }
    };


    if (!(dwHookSwitchDevs & AllHookSwitchDevs) ||
        (dwHookSwitchDevs & (~AllHookSwitchDevs)))
    {
        return mapTAPIErrorCode( PHONEERR_INVALHOOKSWITCHDEV );
    }

    if (!IsOnlyOneBitSetInDWORD (dwHookSwitchMode) ||
        (dwHookSwitchMode & ~AllHookSwitchModes))
    {
        return mapTAPIErrorCode( PHONEERR_INVALHOOKSWITCHMODE );
    }

    LONG lResult = DOFUNC (&funcArgs, "phoneSetHookSwitch");
        
    if (lResult > 0)    // async reply
    {
        return WaitForPhoneReply( lResult );
    }
    else
    {
        return mapTAPIErrorCode( lResult );
    }
}


HRESULT
PhoneSetLamp(
    HPHONE hPhone,
    DWORD  dwButtonLampID,
    DWORD  dwLampMode
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 3, pSetLamp),

        {
            (ULONG_PTR) hPhone,
            dwButtonLampID,
            dwLampMode
        },

        {
            Dword,
            Dword,
            Dword
        }
    };

    LONG lResult = DOFUNC (&funcArgs, "phoneSetRing");
        
    if (lResult > 0)    // async reply
    {
        return WaitForPhoneReply( lResult );
    }
    else
    {
        return mapTAPIErrorCode( lResult );
    }
}


HRESULT
PhoneSetRing(
    HPHONE hPhone,
    DWORD  dwRingMode,
    DWORD  dwVolume
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 3, pSetRing),

        {
            (ULONG_PTR) hPhone,
            dwRingMode,
            dwVolume
        },

        {
            Dword,
            Dword,
            Dword
        }
    };

    LONG lResult = DOFUNC (&funcArgs, "phoneSetRing");
        
    if (lResult > 0)    // async reply
    {
        return WaitForPhoneReply( lResult );
    }
    else
    {
        return mapTAPIErrorCode( lResult );
    }
}


LONG
WINAPI
phoneSetStatusMessages(
    HPHONE hPhone,
    DWORD  dwPhoneStates,
    DWORD  dwButtonModes,
    DWORD  dwButtonStates
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 4, pSetStatusMessages),

        {
            (ULONG_PTR) hPhone,
            dwPhoneStates,
            dwButtonModes,
            dwButtonStates
        },

        {
            Dword,
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "phoneSetStatusMessages"));
}


HRESULT
PhoneSetVolume(
    HPHONE hPhone,
    DWORD  dwHookSwitchDev,
    DWORD  dwVolume
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 3, pSetVolume),

        {
            (ULONG_PTR) hPhone,
            dwHookSwitchDev,
            dwVolume
        },

        {
            Dword,
            Dword,
            Dword
        }
    };

    LONG lResult = DOFUNC (&funcArgs, "phoneSetVolume");
        
    if (lResult > 0)    // async reply
    {
        return WaitForPhoneReply( lResult );
    }
    else
    {
        return mapTAPIErrorCode( lResult );
    }
}


HRESULT
ProviderPrivateFactoryIdentify(
                               DWORD dwDeviceID,
                               GUID * pguid
                              )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, xPrivateFactoryIdentify),

        {
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) pguid,
            (ULONG_PTR) sizeof(GUID)
        },

        {
            Dword,
            lpGet_SizeToFollow,
            Size
        }
    };

    return mapTAPIErrorCode( DOFUNC (&funcArgs, "ProviderPrivateFactoryIdentify") );
}

HRESULT
ProviderPrivateChannelData(
                           DWORD dwDeviceID,
                           DWORD dwAddressID,
                           HCALL hCall,
                           HCALLHUB hCallHub,
                           DWORD dwType,
                           BYTE * pBuffer,
                           DWORD dwSize
                          )
{
    HRESULT             hr;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 7, lDevSpecificEx),

        {
            dwDeviceID,
            dwAddressID,
            (ULONG_PTR)hCall,
            (ULONG_PTR)hCallHub,
            dwType,
            (ULONG_PTR)pBuffer,
            dwSize
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };

    return mapTAPIErrorCode( DOFUNC (&funcArgs, "ProviderPrivateChannelData") );
}

//
// ----------------------- Private support routines ---------------------------
//

void
FreeInitData(
    PT3INIT_DATA  pInitData
    )
{

    EnterCriticalSection (&gcsTapisrvCommunication);

    if (pInitData && ( pInitData->dwKey != 0xefefefef ) )
    {
        pInitData->dwKey = 0xefefefef;
        
        LeaveCriticalSection (&gcsTapisrvCommunication);

        ClientFree (pInitData);
    }
    else
    {
        LeaveCriticalSection (&gcsTapisrvCommunication);
    }

}


//////////////////////////////////////////////////////////////////
// Wait for a reply for async stuff
//
//////////////////////////////////////////////////////////////////
HRESULT
WaitForReply(
             DWORD dwID
            )
{
    HRESULT         hr = S_OK;
    CAsyncRequestReply *pReply;

    // Create a new request entry on the list
    pReply = gpLineAsyncReplyList->addRequest( dwID );

    if( NULL == pReply )
    {
        LOG((TL_INFO, "gpLineAsyncReplyList->addRequest failed"));
        hr = E_OUTOFMEMORY;
    }
    else
    {
        // Now we wait to be signalled
        hr = pReply->wait();

        if (-1 == hr)
        {
            gpLineAsyncReplyList->remove (pReply);
        }
        // Cleanup
        delete pReply;
        
        // if we we didn't wait long enough for the asycnronous call to succeed.
        if (-1 == hr)
            return TAPI_E_TIMEOUT;
    }

    return mapTAPIErrorCode( hr );
}


HRESULT
WaitForPhoneReply(
                  DWORD dwID
                 )
{
    HRESULT         hr = S_OK;
    CAsyncRequestReply *pReply;

    // Create a new request entry on the list
    pReply = gpPhoneAsyncReplyList->addRequest( dwID );
    
    if( NULL == pReply )
    {
        LOG((TL_INFO, "gpPhoneAsyncReplyList->addRequest failed"));
        hr = E_OUTOFMEMORY;
    }
    else
    {
        // Now we wait to be signalled
        hr = pReply->wait();

        if (-1 == hr)
        {
            gpPhoneAsyncReplyList->remove (pReply);
        }
        // Cleanup
        delete pReply;

        // if we we didn't wait long enough for the asycnronous call to succeed.
        if (-1 == hr)
            return TAPI_E_TIMEOUT;

    }

    return mapTAPIErrorCode( hr );
}


/////////////////////////////////////////////////////////////////////
// FindCallObject
//
// Finds the call object associated with an HCALL
//
// Returns TRUE if the call object is found, FALSE if not.
//////////////////////////////////////////////////////////////////////
BOOL
FindCallObject(
               HCALL hCall,
               CCall ** ppCall
              )
{
    HRESULT     hr;

    gpCallHashTable->Lock();

    hr = gpCallHashTable->Find( (ULONG_PTR)hCall, (ULONG_PTR *)ppCall );

    if (SUCCEEDED(hr))
    {
        (*ppCall)->AddRef();

        gpCallHashTable->Unlock();

        return TRUE;
    }

    gpCallHashTable->Unlock();


    return FALSE;
}

/////////////////////////////////////////////////////////////////////
// FindAddressObject
//
// Finds the address object associated with an HLINE
//
// Returns TRUE if the line object is found, FALSE if not.
//////////////////////////////////////////////////////////////////////
BOOL
FindAddressObject(
                  HLINE hLine,
                  CAddress ** ppAddress
                 )
{
    HRESULT     hr;

    gpLineHashTable->Lock();

    hr = gpLineHashTable->Find( (ULONG_PTR)hLine, (ULONG_PTR *)ppAddress );

    if ( SUCCEEDED(hr) )
    {
        (*ppAddress)->AddRef();
        gpLineHashTable->Unlock();

        return TRUE;
    }

    gpLineHashTable->Unlock();

    return FALSE;
}


BOOL
FindAddressObjectWithDeviceID(
                              HLINE hLine,
                              DWORD dwAddressID,
                              CAddress ** ppAddress
                             )
{
    HRESULT         hr;

    gpLineHashTable->Lock();

    hr = gpLineHashTable->Find( (ULONG_PTR)hLine, (ULONG_PTR *)ppAddress );

    if ( SUCCEEDED(hr) )
    {
        if ((*ppAddress)->GetAddressID() == dwAddressID)
        {
            (*ppAddress)->AddRef();

            gpLineHashTable->Unlock();

            return TRUE;
        }
    }

    gpLineHashTable->Unlock();

    return FALSE;
}

/////////////////////////////////////////////////////////////////////
// FindPhoneObject
//
// Finds the phone object associated with an HPHONE
//
// Returns TRUE if the phone object is found, FALSE if not.
//////////////////////////////////////////////////////////////////////
BOOL
FindPhoneObject(
                  HPHONE hPhone,
                  CPhone ** ppPhone
                 )
{
    HRESULT     hr;

    gpPhoneHashTable->Lock();

    hr = gpPhoneHashTable->Find( (ULONG_PTR)hPhone, (ULONG_PTR *)ppPhone );

    if ( SUCCEEDED(hr) )
    {
        (*ppPhone)->AddRef();
        gpPhoneHashTable->Unlock();

        return TRUE;
    }

    gpPhoneHashTable->Unlock();

    return FALSE;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// FindAgentHandlerObject
//
// Finds the Agent Handler object associated with an HLINE
//
// Returns TRUE if the line object is found, FALSE if not.
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL
FindAgentHandlerObject(
                  HLINE hLine,
                  CAgentHandler ** ppAgentHandler
                 )
{
    HRESULT     hr = FALSE;


    gpAgentHandlerHashTable->Lock();

    hr = gpAgentHandlerHashTable->Find( (ULONG_PTR)hLine, (ULONG_PTR *)ppAgentHandler );

    if ( SUCCEEDED(hr) )
    {
        (*ppAgentHandler)->AddRef();
        hr = TRUE;
    }
    else
    {
        hr = FALSE;
    }

    gpAgentHandlerHashTable->Unlock();

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// FindCallHubObject
//
// Finds the CallHub object based on the hCallHub
//
// Returns TRUE if the line object is found, FALSE if not.
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL
FindCallHubObject(
                  HCALLHUB hCallHub,
                  CCallHub ** ppCallHub
                 )
{
    HRESULT     hr = FALSE;

    gpCallHubHashTable->Lock();

    hr = gpCallHubHashTable->Find( (ULONG_PTR)hCallHub, (ULONG_PTR *)ppCallHub );

    if ( SUCCEEDED(hr) )
    {
        try
        {
            (*ppCallHub)->AddRef();
            hr = TRUE;
        }
        catch(...)
        {
            hr = FALSE;
        }
    }        
    else
    {
        hr = FALSE;
    }

    gpCallHubHashTable->Unlock();

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CheckTapisrvCallhub
//
// Checks that at least one hCall that TAPISRV supports for a CallHub exists
// as a Call Objects.
// This is to ensure that we have one call obect to reference the hub, otherwise
// it can be released prematurely
//
// Returns S_OK if one exists, E_FAIL if all are missing
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CheckTapisrvCallhub(HCALLHUB hCallHub)
{
    LINECALLLIST  * pCallHubList;
    HCALL         * phCalls;
    DWORD           dwCount;
    CCall         * pCall = NULL;
    HRESULT         hr = E_FAIL;

    LOG((TL_INFO, "CheckTapisrvCallhub - hCallHub: %lx",hCallHub));

    //
    // get the list of hcalls
    // related to this callhub
    //
    hr = LineGetHubRelatedCalls(
                                hCallHub,
                                0,
                                &pCallHubList
                               );

    if ( SUCCEEDED(hr) )
    {
        // Assume the worst..
        hr = E_FAIL;

        //
        // get to the list of calls
        //
        phCalls = (HCALL *)(((LPBYTE)pCallHubList) + pCallHubList->dwCallsOffset);

        //
        // the first call is actually the callhub
        // check it against the handle we gave...
        //
        if (hCallHub == (HCALLHUB)(phCalls[0]))
        {
            //
            // go through the call handles and try to find call objects
            //
            for (dwCount = 1; dwCount < pCallHubList->dwCallsNumEntries; dwCount++)
            {
                //
                // get the tapi3 call object
                //
                if ( FindCallObject(phCalls[dwCount], &pCall) )
                {
                    // Found it - findcallobject addrefs, so release
                    pCall->Release();
                    LOG((TL_INFO, "CheckTapisrvCallhub - found hCall %lx", phCalls[dwCount]));
                    hr = S_OK;
                    break;
                }
            }
        }
        else
        {
            LOG((TL_INFO, "CheckTapisrvCallhub - returned callhub doesn't match"));
            _ASSERTE(0);
            hr = E_FAIL;
        }

        ClientFree( pCallHubList );  // Clean up

    }
    else
    {
        LOG((TL_INFO, "CheckTapisrvCallhub - LineGetHubRelatedCallsfailed"));
    }

    LOG((TL_TRACE, hr, "CheckTapisrvCallhub - exit"));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ProcessEvent
//   This processes messages from tapisrv
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
ProcessMessage(
               PT3INIT_DATA pInitData,
               PASYNCEVENTMSG pParams
              )
{
    HRESULT hResult = S_OK;

    LOG((TL_INFO, "In ProcessMessage - MsgType:%x", pParams->Msg));

    switch( pParams->Msg )
    {

        case LINE_CALLSTATE:
        {
            hResult = HandleCallStateMessage( pParams );
            break;
        }
        case LINE_CALLINFO:
        {
            hResult = HandleCallInfoMessage( pParams );
            break;
        }
        case LINE_MONITORDIGITS:
        {
            hResult = HandleMonitorDigitsMessage( pParams );
            break;
        }
        case LINE_SENDMSPDATA:
        {
            hResult = HandleSendMSPDataMessage( pParams );
            break;
        }
        case LINE_DEVSPECIFICEX:
        {
            //HandlePrivateEventMessage( pParams );
            break;
        }
        case LINE_LINEDEVSTATE:
        {
            CTAPI *pTapi = NULL;

            if (!IsBadReadPtr(pInitData, sizeof(pInitData)))
            {
                pTapi = pInitData->pTAPI;
            }

            HandleLineDevStateMessage( pTapi, pParams );

            break;
        }
        case LINE_ADDRESSSTATE:
        {
            HandleAddressStateMessage( pParams );
            break;
        }
        case LINE_DEVSPECIFIC:
        {
            HandleLineDevSpecificMessage( pParams );
            break;
        }
        case LINE_DEVSPECIFICFEATURE:
        {
            //HandleDevSpecificFeatureMessage( pParams );
            break;
        }
        case LINE_GATHERDIGITS:
        {
            hResult = HandleGatherDigitsMessage( pParams );
            break;
        }
        case LINE_GENERATE:
        {
            hResult = HandleLineGenerateMessage( pParams );
            break;
        }
        case LINE_MONITORMEDIA:
        {
            HandleMonitorMediaMessage( pParams );
            break;
        }
        case LINE_MONITORTONE:
        {
            HandleMonitorToneMessage( pParams );
            break;
        }
        case LINE_CLOSE:
        {
            HandleLineCloseMessage( pParams );
            break;
        }
        case LINE_AGENTSTATUS:
        {
            break;
        }
        case LINE_AGENTSTATUSEX:
        {
            HandleAgentStatusMessage(pParams);
            break;
        }

        case LINE_AGENTSESSIONSTATUS:
        {
            HandleAgentSessionStatusMessage(pParams);
            break;
        }

        case LINE_QUEUESTATUS:
        {
            HandleQueueStatusMessage(pParams);
            break;
        }

        case LINE_QOSINFO:
        {
            hResult = HandleLineQOSInfoMessage( pParams );
            break;
        }
        case LINE_APPNEWCALLHUB:
        {
            HRESULT         hr;
            CCallHub      * pCallHub;
            BOOL            fAllCallsDisconnected;

            hResult = CheckTapisrvCallhub((HCALLHUB)pParams->Param1);
            if (SUCCEEDED(hResult))
            {
                CTAPI *pTapi = NULL;


                //
                // pInitData seems good?
                //

                if (!IsBadReadPtr(pInitData, sizeof(pInitData)))
                {

                    //
                    // check the tapi object, and get an addref'ed copy if it is
                    // valid
                    //

                    if ( CTAPI::IsValidTapiObject(pInitData->pTAPI) )
                    {

                        //
                        // got a good, addref'ed object. keep it.
                        //

                        pTapi = pInitData->pTAPI;
                    }

                }


                hr = CCallHub::CreateTapisrvCallHub(
                    pTapi,
                    (HCALLHUB)pParams->Param1,
                    &pCallHub
                    );

                if (!SUCCEEDED(hr))
                {
                    LOG((TL_ERROR, "CreateTapisrvCallHub failed in LINE_APPNEWCALLHUB"));
                }
                else
                {
                    //Send CHE_CALLHUBIDLE message if all the calls in the callhub are disconnected.
                    hr = pCallHub -> FindCallsDisconnected( &fAllCallsDisconnected );
                    if( hr == S_OK )
                    {
                        if( fAllCallsDisconnected == TRUE )
                        {
                            //
                            // tell the app
                            //
                            pCallHub -> SetState(CHS_IDLE);
                        }
                    }

                    pCallHub->Release();
                }


                //
                // if we we got a good tapi object, we must release it now.
                //

                if (NULL != pTapi)
                {
                    pTapi->Release();
                    pTapi = NULL;
                }
            }

            break;
        }

       case LINE_GROUPSTATUS:
       {
            handleGroupStatusMessage(pParams);
            break;
       }

       case LINE_PROXYSTATUS:
       {
            CTAPI *pTapi = NULL;

            if (!IsBadReadPtr(pInitData, sizeof(pInitData)))
            {
                pTapi = pInitData->pTAPI;
            }

            QueueCallbackEvent( pTapi, pParams );
            break;
       }



        case LINE_REPLY:
        {
            CAsyncRequestReply *pReply;

            LOG((TL_INFO, "LINE_REPLY"));

            // Add (or complete existing) response entry on the list
            pReply = gpLineAsyncReplyList->addReply( pParams->Param1, (HRESULT) pParams->Param2 );
            
            if(pReply==NULL)
            {
                LOG((TL_INFO, "gpLineAsyncReplyList->addReply failed"));
                hResult = E_OUTOFMEMORY;
            }
            else
            {
                // Signal it to say we're done.
                pReply->signal();
            }
            break;
        }

        case PHONE_REPLY:
        {
            CAsyncRequestReply *pReply;

            LOG((TL_INFO, "PHONE_REPLY"));

            // Add (or complete existing) response entry on the list
            pReply = gpPhoneAsyncReplyList->addReply( pParams->Param1, (HRESULT) pParams->Param2 );
            
            // Signal it to say we're done.
            if(pReply == NULL )
            {
                LOG((TL_INFO, "gpPhoneAsyncReplyList->addReply failed"));
                hResult = E_OUTOFMEMORY;
            }
            else
            {
                pReply->signal();
            }

            break;
        }

        case LINE_APPNEWCALL:
        {
            // LINE_APPNEWCALL is the first notification we get of
            // a new call object.  Create the call here, but
            // don't notify the app until we get the first
            // message about it.

            CAddress * pAddress;
            CCall * pCall = NULL;

            if (FindAddressObjectWithDeviceID(
                                              (HLINE) pParams->hDevice,
                                              pParams->Param1,
                                              &pAddress
                                             ))
            {
                HRESULT         hr;
                LINECALLINFO *  pCallInfo = NULL;

                hr = LineGetCallInfo(
                                     pParams->Param2,
                                     &pCallInfo
                                    );

                if ( SUCCEEDED(hr) )
                {
                    BOOL callExposeAndNotify = TRUE;

                    if ( pCallInfo->dwMediaMode & LINEMEDIAMODE_INTERACTIVEVOICE )
                    {
                        pCallInfo->dwMediaMode |= LINEMEDIAMODE_AUTOMATEDVOICE;
                        pCallInfo->dwMediaMode &= ~((DWORD)LINEMEDIAMODE_INTERACTIVEVOICE);
                    }

                    pCallInfo->dwMediaMode &= ~((DWORD)LINEMEDIAMODE_UNKNOWN);
                    
                    //Check if the new call is a conference controller call.
                    BOOL fConfContCall = *(&pParams->Param4 + 3);

                    //Don't expose if a conference controller call
                    LOG(( TL_ERROR, "conference controller call:%d.", *(&pParams->Param4 + 3) ));
                    if( fConfContCall == TRUE )
                    {
                        LOG(( TL_ERROR, "conference controller call." ));
                        callExposeAndNotify = FALSE;
                    }
                    
                    pAddress->InternalCreateCall(
                        NULL,
                        0,
                        pCallInfo->dwMediaMode,
                        (pParams->Param3 == LINECALLPRIVILEGE_OWNER) ? CP_OWNER : CP_MONITOR,
                        callExposeAndNotify,
                        (HCALL)pParams->Param2,
                        callExposeAndNotify,
                        &pCall
                        );
                }

                if ( NULL != pCallInfo )
                {
                    ClientFree( pCallInfo );
                }

                //
                // don't keep a ref
                if(pCall != NULL)
                {
                    pCall->Release();
                }
                //
                //FindAddressObject addrefs the address objct
                pAddress->Release();
    
            }
            else
            {
                LOG((TL_ERROR, "Ignoring call with wrong address id"));

                FUNC_ARGS funcArgs =
                {
                    MAKELONG (LINE_FUNC | SYNC | 1, lDeallocateCall),

                    {
                        pParams->Param2
                    },

                    {
                            Dword
                    }
                };

                LOG((TL_INFO, "lineDeallocateCall - hCall = 0x%08lx", pParams->Param2));

                DOFUNC (&funcArgs, "lineDeallocateCall");

            }

            break;
        }
        case LINE_CREATE:
        {
            
            QueueCallbackEvent( pParams );

            break;
        }
        case LINE_REMOVE:
        {

            QueueCallbackEvent( pParams );

            break;
        }

        case LINE_REQUEST:
        {
            CTAPI *pTapi = NULL;

            if (!IsBadReadPtr(pInitData, sizeof(pInitData)))
            {
                pTapi = pInitData->pTAPI;
            }

            HandleLineRequest( pTapi, pParams );

            break;
        }

        case LINE_CALLHUBCLOSE:
        {
            gpRetryQueue->RemoveNewCallHub(pParams->Param1);
            HandleCallHubClose( pParams );
            break;
        }

        case PRIVATE_MSPEVENT:
        {
            HandlePrivateMSPEvent( pParams );
            break;
        }

        case PHONE_BUTTON:
        {
            HandlePhoneButtonMessage( pParams );
            break;
        }

        case PHONE_CLOSE:
        {
            HandlePhoneCloseMessage( pParams );
            break;
        }

        case PHONE_DEVSPECIFIC:
        {
            HandlePhoneDevSpecificMessage( pParams );
            break;
        }

        case PHONE_STATE:
        {            
            QueueCallbackEvent( pParams );
            break;
        }

        case PHONE_CREATE:
        {
            QueueCallbackEvent( pParams );

            break;
        }

        case PHONE_REMOVE:
        {
            QueueCallbackEvent( pParams );

            break;
        }

        case LINE_AGENTSPECIFIC:
        case LINE_PROXYREQUEST:

        default:
            break;
    }

    return hResult;
}


void __RPC_FAR * __RPC_API midl_user_allocate(size_t len)
{
    LOG((TL_TRACE, "midl_user_allocate: enter, size=x%x", len));

    return (ClientAlloc (len));
}


void __RPC_API midl_user_free(void __RPC_FAR * ptr)
{
    LOG((TL_TRACE, "midl_user_free: enter, p=x%p", ptr));

    ClientFree (ptr);
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// AllocClientResources
//
// This function is called from inside CTAPI::Initialize and CTAPI::Shutdown
// only and hence access to it is serialized. Calling this function from some
// other functionality would need making an alternate arrangement to serialize 
// access to this function
//
// Starts tapisrv if it is not started and calls ClientAttach
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LONG
WINAPI
AllocClientResources(
    DWORD dwErrorClass
    )
{
    LOG((TL_INFO, "AllocClientResources - enter"));

    DWORD           dwExceptionCount = 0;
    DWORD           dwError = 0;
    LONG            lResult = gaOpFailedErrors[dwErrorClass];
    

    //
    // service handles
    //

    SC_HANDLE       hSCMgr   = NULL;
    SC_HANDLE       hTapiSrv = NULL;


    EnterCriticalSection ( &gcsClientResources );

    //
    // If we're in safeboot mode, tapisrv won't start;
    // fail initialization.
    //
    if (0 != GetSystemMetrics (SM_CLEANBOOT))
    {
        lResult = gaOpFailedErrors[dwErrorClass];

        goto AllocClientResources_return;
    }

    //
    // Start the TAPISRV.EXE service
    //
    if (!(GetVersion() & 0x80000000)) // Win NT
    {
        if ((hSCMgr = OpenSCManager(
                NULL,               // local machine
                NULL,               // ServicesActive database
                SC_MANAGER_CONNECT  // desired access
                )) == NULL)
        {
            dwError = GetLastError();
            LOG((TL_ERROR, "OpenSCManager failed, err=%d", dwError));

            if ( ERROR_ACCESS_DENIED == dwError ||
                 ERROR_NOACCESS == dwError
               )
            {
                // if OpenSCManager fails with ACCESS_DENIED,
                // we still need to try to attach to TAPISRV
                goto AllocClientResources_attachToServer;
            }
            else
            {
                goto AllocClientResources_return;
            }
        }

        if ((hTapiSrv = OpenService(
                hSCMgr,                 // SC mgr handle
                (LPCTSTR) "TAPISRV",    // name of service to open
                //SERVICE_START |         // desired access
                SERVICE_QUERY_STATUS
                )) == NULL)
        {
            dwError = GetLastError();
            LOG((TL_ERROR, "OpenService failed, err=%d", dwError));

            if ( ERROR_ACCESS_DENIED == dwError ||
                 ERROR_NOACCESS == dwError
               )
            {
                // if OpenService fails with ACCESS_DENIED,
                // we still need to try to attach to TAPISRV
                goto AllocClientResources_attachToServer;
            }
            else
            {            
                goto AllocClientResources_cleanup1;
            }
        }

AllocClientResources_queryServiceStatus:

        {
            #define MAX_NUM_SECONDS_TO_WAIT_FOR_TAPISRV 180

            DWORD   dwNumSecondsSleptStartPending = 0,
                    dwNumSecondsSleptStopPending = 0;

            while (1)
            {
                SERVICE_STATUS  status;


                QueryServiceStatus (hTapiSrv, &status);

                switch (status.dwCurrentState)
                {
                case SERVICE_RUNNING:

                    LOG((TL_INFO, "Tapisrv running"));
                    goto AllocClientResources_attachToServer;

                case SERVICE_START_PENDING:

                    Sleep (1000);

                    if (++dwNumSecondsSleptStartPending >
                            MAX_NUM_SECONDS_TO_WAIT_FOR_TAPISRV)
                    {
                        LOG((TL_ERROR,
                            "ERROR: Tapisrv stuck SERVICE_START_PENDING"
                            ));

                        goto AllocClientResources_cleanup2;
                    }

                    break;

                case SERVICE_STOP_PENDING:

                    Sleep (1000);

                    if (++dwNumSecondsSleptStopPending >
                            MAX_NUM_SECONDS_TO_WAIT_FOR_TAPISRV)
                    {
                        LOG((TL_ERROR,
                            "ERROR: Tapisrv stuck SERVICE_STOP_PENDING"
                            ));

                        goto AllocClientResources_cleanup2;
                    }

                    break;

                case SERVICE_STOPPED:

                    LOG((TL_ERROR, "Starting tapisrv (NT)..."));


                    //
                    // close service handle that we already have
                    //

                    if (NULL != hTapiSrv)
                    {
                        CloseServiceHandle(hTapiSrv);

                        hTapiSrv = NULL;
                    }

                    
                    /*Change: This is done in order to avoid opening service with
                      SERVICE_START previleges unless it needs to be started*/
                    if ((hTapiSrv = OpenService(
                                        hSCMgr,                 // SC mgr handle
                                        (LPCTSTR) "TAPISRV",    // name of service to open
                                        SERVICE_START |         // desired access
                                        SERVICE_QUERY_STATUS
                                        )) == NULL)
                    {
                        LOG((TL_ERROR, "OpenService failed, err=%d", GetLastError()));

                        goto AllocClientResources_cleanup2;
                    }

                    if (!StartService(
                            hTapiSrv,   // service handle
                            0,          // num args
                            NULL        // args
                            ))
                    {
                        DWORD dwLastError = GetLastError();


                        if (dwLastError != ERROR_SERVICE_ALREADY_RUNNING)
                        {
                            LOG((TL_ERROR,
                                "StartService(TapiSrv) failed, err=%d",
                                dwLastError
                                ));

                            goto AllocClientResources_cleanup2;
                        }
                    }

                    break;

                default:

                    LOG((TL_ERROR,
                        "error, service status=%d",
                        status.dwCurrentState
                        ));

                    goto AllocClientResources_cleanup2;
                }
            }
        }
    }
    else // Win95
    {
        HANDLE  hMutex, hEvent;


        //
        // First grab the global mutex that serializes the following
        // across all instances of tapi32.dll
        //

        if (!(hMutex = CreateMutex (NULL, FALSE, "StartTapiSrv")))
        {
            LOG((TL_ERROR,
                "CreateMutex ('StartTapiSrv') failed, err=%d",
                GetLastError()
                ));
        }

        WaitForSingleObject (hMutex, INFINITE);


        //
        // Try to open the event that tells us tapisrv has inited
        //

        if (!(hEvent = OpenEvent (EVENT_ALL_ACCESS, TRUE, "TapiSrvInited")))
        {
            //
            // OpenEvent failed, so tapisrv hasn't been started yet.  Start
            // tapisrv, and then get the event handle.
            //

            STARTUPINFO startupInfo;
            PROCESS_INFORMATION processInfo;


            LOG((TL_ERROR,
                "OpenEvent ('TapiSrvInited') failed, err=%d",
                GetLastError()
                ));

            ZeroMemory(&startupInfo, sizeof (STARTUPINFO));

            startupInfo.cb = sizeof (STARTUPINFO);

            LOG((TL_INFO, "Starting tapisrv (Win95)..."));

            if (!CreateProcess(
                    NULL,                   // image name
                    "tapisrv.exe",          // cmd line
                    NULL,                   // process security attrs
                    NULL,                   // thread security attrs
                    FALSE,                  // inherit handles
                    NORMAL_PRIORITY_CLASS,  // create opts
                    NULL,                   // environment
                    NULL,                   // curr dir
                    &startupInfo,
                    &processInfo
                    ))
            {
                LOG((TL_ERROR,
                    "CreateProcess('tapisrv.exe') failed, err=%d",
                    GetLastError()
                    ));
            }
            else
            {
                CloseHandle (processInfo.hProcess);
                CloseHandle (processInfo.hThread);
            }

            if (!(hEvent = CreateEvent (NULL, TRUE, FALSE, "TapiSrvInited")))
            {
                LOG((TL_ERROR,
                    "CreateEvent ('TapiSrvInited') failed, err=%d",
                    GetLastError()
                    ));
            }

        }


        //
        // Now wait on the event (it's will be signaled when tapisrv has
        // completed it's initialization).  Then clean up.
        //

        WaitForSingleObject (hEvent, INFINITE);
        CloseHandle (hEvent);

        ReleaseMutex (hMutex);
        CloseHandle (hMutex);
    }


    //
    // Init the RPC connection
    //

AllocClientResources_attachToServer:

    {
        #define CNLEN              25   // computer name length
        #define UNCLEN        CNLEN+2   // \\computername
        #define PATHLEN           260   // Path
        #define MAXPROTSEQ         20   // protocol sequence "ncacn_np"

        BOOL            bException = FALSE;
        RPC_STATUS      status;
        unsigned char   pszNetworkAddress[UNCLEN+1];
        unsigned char *pszUuid          = NULL;
        unsigned char *pszOptions       = NULL;
        unsigned char *pszStringBinding = NULL;
        DWORD          dwProcessID = GetCurrentProcessId();


        //
        // UNLEN (as documented for GetUserName()) is defined in LMCONS.H
        // to be 256 characters. LMCONS.H cannot be easily included, so we are
        // redefining the value here.
        //

        const DWORD MAXIMUM_USER_NAME_LENGTH = 256;


        //
        // allocate memory for user name
        //

        DWORD dwUserNameSize = MAXIMUM_USER_NAME_LENGTH + 1;

        WCHAR *pszUserName = (WCHAR *) ClientAlloc (dwUserNameSize * sizeof(WCHAR) );
        
        if (NULL == pszUserName)
        {
            LOG((TL_ERROR,
                "AllocClientResources: failed to allocate 0x%lx characters for pszUserName",
                dwUserNameSize));

            goto AllocClientResources_cleanup2;
        }


        //
        // try to get user name. we are passing in a buffer for the 
        // longest possible user name so if the call fails, do not 
        // retry with a bigger buffer
        //

        BOOL bResult = GetUserNameW(pszUserName, &dwUserNameSize);

        if ( ! bResult )
        {
            LOG((TL_ERROR,
                "AllocClientResources: GetUserName failed. LastError = 0x%lx", GetLastError()));

            ClientFree(pszUserName);
            pszUserName = NULL;

            goto AllocClientResources_cleanup2;
        }

        LOG((TL_INFO, "AllocClientResources: UserName [%S]", pszUserName));

        
        //
        // allocate memory for computer name
        //

        DWORD dwComputerNameSize = MAX_COMPUTERNAME_LENGTH + 1 ;

        WCHAR *pszComputerName = (WCHAR *) ClientAlloc (dwComputerNameSize * sizeof(WCHAR) );

        if (NULL == pszComputerName)
        {

            LOG((TL_ERROR,
                "AllocClientResources: failed to allocate 0x%lx characters for pszUserName",
                dwComputerNameSize
                ));


            ClientFree(pszUserName);
            pszUserName = NULL;


            goto AllocClientResources_cleanup2;
        }

        
        //
        // try to get computer name. we are passing in a buffer for the 
        // longest possible computer name so if the call fails, do not 
        // retry with a bigger buffer
        //

        bResult = GetComputerNameW(pszComputerName,
                                    &dwComputerNameSize);


        if ( ! bResult )
        {

            LOG((TL_ERROR,
                "AllocClientResources: GetComputerName failed. LastError = 0x%lx", GetLastError()));


            ClientFree(pszUserName);
            pszUserName = NULL;

            ClientFree(pszComputerName);
            pszComputerName = NULL;


            goto AllocClientResources_cleanup2;

        }
        
        LOG((TL_INFO, "AllocClientResources: ComputerName [%S]", pszComputerName));


        pszNetworkAddress[0] = '\0';

        status = RpcStringBindingCompose(
            pszUuid,
            (unsigned char *)"ncalrpc",
            pszNetworkAddress,
            (unsigned char *)"tapsrvlpc",
            pszOptions,
            &pszStringBinding
            );

        if (status)
        {
            LOG((TL_ERROR,
                "RpcStringBindingCompose failed: err=%d, szNetAddr='%s'",
                status,
                pszNetworkAddress
                ));
        }

        status = RpcBindingFromStringBinding(
            pszStringBinding,
            &hTapSrv
            );

        if (status)
        {
            LOG((TL_ERROR,
                "RpcBindingFromStringBinding failed, err=%d, szBinding='%s'",
                status,
                pszStringBinding
                ));
        }

       
        RpcTryExcept
        {
            LOG((TL_INFO, "AllocCliRes: calling ClientAttach..."));

            lResult = ClientAttach(
                (PCONTEXT_HANDLE_TYPE *) &gphCx,
                dwProcessID,
                (long *) &ghAsyncEventsEvent,
                pszUserName,
                pszComputerName
                );

            LOG((TL_INFO, "AllocCliRes: ClientAttach returned x%x. ghAsyncEventsEvent[%p]", 
                lResult, ghAsyncEventsEvent));
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
        {
            LOG((TL_ERROR,
                "AllocCliRes: ClientAttach caused except=%d",
                RpcExceptionCode()
                ));
            bException = TRUE;
        }
        RpcEndExcept

        ClientFree (pszUserName);
        ClientFree (pszComputerName);

        RpcBindingFree (&hTapSrv);

//            LOG((TL_
//                3,
//                "AllocCliRes: gphCx=x%x, PID=x%x, hAEEvent=x%x",
//                gphCx,
//                dwProcessID,
//                ghAsyncEventsEvent
//                ));

        RpcStringFree(&pszStringBinding);

        if (bException)
        {
            //
            // If here chances are that we started the service and it's
            // not ready to receive rpc requests. So we'll give it a
            // little time to get rolling and then try again.
            //

            if (dwExceptionCount < gdwMaxNumRequestRetries)
            {
                Sleep ((++dwExceptionCount > 1 ? gdwRequestRetryTimeout : 0));

                if (hTapiSrv) // Win NT && successful OpenService()
                {
                    goto AllocClientResources_queryServiceStatus;
                }
                else
                {
                    goto AllocClientResources_attachToServer;
                }
            }
            else
            {
                LOG((TL_ERROR,
                    "AllocCliRes: ClientAttach failed, result=x%x",
                    gaServiceNotRunningErrors[dwErrorClass]
                    ));

                lResult = gaServiceNotRunningErrors[dwErrorClass];
            }
        }
    }

AllocClientResources_cleanup2:

    if (NULL != hTapiSrv) 
    {
        CloseServiceHandle (hTapiSrv);

        hTapiSrv = NULL;

    }

AllocClientResources_cleanup1:

    if (NULL != hSCMgr) 
    {
        CloseServiceHandle (hSCMgr);
        
        hSCMgr = NULL;
    }

AllocClientResources_return:
    
    //release the mutex
    LeaveCriticalSection ( &gcsClientResources );

    LOG((TL_TRACE, "AllocClientResources: exit, returning x%x", lResult));

    return lResult;

}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// NewShutdown
//
// This function is called from inside CTAPI::Initialize and CTAPI::Shutdown
// only and hence access to it is serialized. Calling this function from some
// other functionality would need making an alternate arrangement to serialize 
// access to this function
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CTAPI::NewShutdown()
{
    LOG((TL_TRACE, "NewShutdown - enter"));


    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 1, lShutdown),

        {
            (ULONG_PTR)m_dwLineInitDataHandle
        },
        {
            hXxxApp
        }
    };


    //
    // deallocate line resources
    //

    if (0 != m_dwLineInitDataHandle)
    {
        DOFUNC(
               &funcArgs,
               "lineShutdown"
              );

        FreeInitData (m_pLineInitData);
        m_pLineInitData = NULL;

        DeleteHandleTableEntry(m_dwLineInitDataHandle);
        m_dwLineInitDataHandle = 0;
    }



    //
    // deallocate phone resources
    //

    if (0 != m_dwPhoneInitDataHandle)
    {

        funcArgs.Args[0] = (ULONG_PTR)m_dwPhoneInitDataHandle;

        funcArgs.Flags = MAKELONG (PHONE_FUNC | SYNC | 1, pShutdown),

        DOFUNC(
               &funcArgs,
               "phoneShutdown"
              );


        FreeInitData (m_pPhoneInitData);
        m_pPhoneInitData = NULL;

        DeleteHandleTableEntry(m_dwPhoneInitDataHandle);
        m_dwPhoneInitDataHandle = 0;

    }


    LOG((TL_TRACE, "NewShutdown - finish"));

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CreateThreadsAndStuff
//
// This function is called from inside CTAPI::Initialize and CTAPI::Shutdown
// only and hence access to it is serialized. Calling this function from some
// other functionality would need making an alternate arrangement to serialize 
// access to this function
//
// This is called when the last TAPI object has been freed
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void
CTAPI::FinalTapiCleanup()
{
    DWORD dwSignalled;


    STATICLOG((TL_TRACE, "FinalTapiCleanup - enter"));

    //
    // tell our threads that we are shutting down
    //
    if (gpAsyncEventsThreadParams)
    {
        gpAsyncEventsThreadParams->bExitThread = TRUE;
    }   
    SetEvent( ghAsyncEventsEvent );
    gbExitThread = TRUE;
    SetEvent( ghCallbackThreadEvent );

    //
    // and wait for them to exit
    //
    STATICLOG((TL_INFO, "FinalTapiCleanup - ghAsyncEventsThread"));
    //WaitForSingleObject( ghAsyncEventsThread, INFINITE );
    CoWaitForMultipleHandles (COWAIT_ALERTABLE,
                        INFINITE,
                        1,
                        &ghAsyncEventsThread,
                        &dwSignalled);


    STATICLOG((TL_INFO, "FinalTapiCleanup - ghCallbackThread"));
    //WaitForSingleObject( ghCallbackThread, INFINITE );
    CoWaitForMultipleHandles (COWAIT_ALERTABLE,
                        INFINITE,
                        1,
                        &ghCallbackThread,
                        &dwSignalled);

    //
    // close their handles
    //
    CloseHandle( ghAsyncEventsThread );
    CloseHandle( ghCallbackThread );

    gpAsyncEventsThreadParams = NULL;

    //
    // Safely close any existing generic dialog instances
    //
    EnterCriticalSection (&gcsTapisrvCommunication);

    if (gpUIThreadInstances)
    {
        PUITHREADDATA   pUIThreadData, pNextUIThreadData;

        pUIThreadData = gpUIThreadInstances;

        while (pUIThreadData)
        {
            //
            // Grab a ptr to the next UIThreadData while it's still
            // safe, wait until the ui dll has indicated that it
            // is will to receive generic dlg data, then pass it
            // NULL/0 to tell it to shutdown the dlg inst
            //

            pNextUIThreadData = pUIThreadData->pNext;

            // WaitForSingleObject (pUIThreadData->hEvent, INFINITE);
            CoWaitForMultipleHandles (COWAIT_ALERTABLE,
                                      INFINITE,
                                      1,
                                      &pUIThreadData->hEvent,
                                      &dwSignalled
                                     );

            STATICLOG((TL_INFO,
                    "NewShutdown: calling TUISPI_providerGenericDialogData..."
                   ));

            ((TUIGDDPROC)(*pUIThreadData->pfnTUISPI_providerGenericDialogData))(
                pUIThreadData->htDlgInst,
                NULL,
                0
                );

           STATICLOG((TL_INFO,
                    "NewShutdown: TUISPI_providerGenericDialogData returned"
                   ));

            pUIThreadData = pNextUIThreadData;
        }
    }

    LeaveCriticalSection (&gcsTapisrvCommunication);

    FreeClientResources();

    STATICLOG((TL_TRACE, "FinalTapiCleanup - exit"));

}

#if DBG
LPVOID
WINAPI
ClientAllocReal(
    DWORD   dwSize,
    DWORD   dwLine,
    PSTR    pszFile
    )
#else
LPVOID
WINAPI
ClientAllocReal(
    DWORD   dwSize
    )
#endif
{
    //
    // Alloc 16 extra bytes so we can make sure the pointer we pass back
    // is 64-bit aligned & have space to store the original pointer
    //
#if DBG

    PMYMEMINFO       pHold;
    PDWORD_PTR       pAligned;
    PBYTE            p;

    p = (PBYTE)LocalAlloc(LPTR, dwSize + sizeof(MYMEMINFO) + 16);

    if (p == NULL)
    {
        return NULL;
    }

    // note note note - this only works because mymeminfo is
    // a 16 bit multiple in size.  if it wasn't, this
    // align stuff would cause problems.
    pAligned = (PDWORD_PTR) (p + 8 - (((DWORD_PTR) p) & (DWORD_PTR)0x7));
    *pAligned = (DWORD_PTR) p;
    pHold = (PMYMEMINFO)((DWORD_PTR)pAligned + 8);
    
    pHold->dwSize = dwSize;
    pHold->dwLine = dwLine;
    pHold->pszFile = pszFile;
    pHold->pPrev = NULL;
    pHold->pNext = NULL;

    EnterCriticalSection(&csMemoryList);

    if (gpMemLast != NULL)
    {
        gpMemLast->pNext = pHold;
        pHold->pPrev = gpMemLast;
        gpMemLast = pHold;
    }
    else
    {
        gpMemFirst = gpMemLast = pHold;
    }

    LeaveCriticalSection(&csMemoryList);

    return (LPVOID)(pHold + 1);

#else

    LPBYTE  p;
    PDWORD_PTR pAligned;


    if ((p = (LPBYTE) LocalAlloc (LPTR, dwSize + 16)))
    {
        pAligned = (PDWORD_PTR) (p + 8 - (((DWORD_PTR) p) & (DWORD_PTR)0x7));
        *pAligned = (DWORD_PTR) p;
        pAligned = (PDWORD_PTR)((DWORD_PTR)pAligned + 8);
    }
    else
    {
        LOG((TL_ERROR,
            "ClientAlloc: LocalAlloc (x%lx) failed, err=x%lx",
            dwSize,
            GetLastError())
            );

        pAligned = NULL;
    }

    return ((LPVOID) pAligned);
#endif
}


void
WINAPI
ClientFree(
    LPVOID  p
    )
{
#if DBG
    PMYMEMINFO       pHold;

    if (p == NULL)
    {
        return;
    }

    pHold = (PMYMEMINFO)(((LPBYTE)p) - sizeof(MYMEMINFO));

    EnterCriticalSection(&csMemoryList);

    if (pHold->pPrev)
    {
        pHold->pPrev->pNext = pHold->pNext;
    }
    else
    {
        gpMemFirst = pHold->pNext;
    }

    if (pHold->pNext)
    {
        pHold->pNext->pPrev = pHold->pPrev;
    }
    else
    {
        gpMemLast = pHold->pPrev;
    }

    LeaveCriticalSection(&csMemoryList);

    {
        LPVOID  pOrig = (LPVOID) *((PDWORD_PTR)((DWORD_PTR)pHold - 8));


        LocalFree (pOrig);
    }
    
    //LocalFree(pHold);
    return;
#else
    if (p != NULL)
    {
        LPVOID  pOrig = (LPVOID) *((PDWORD_PTR)((DWORD_PTR)p - 8));
        LocalFree (pOrig);
    }
    else
    {
        LOG((TL_INFO,"----- ClientFree: ptr = NULL!"));
    }
#endif

}

SIZE_T
WINAPI
ClientSize(
    LPVOID  p
    )
{
    if (p != NULL)
    {
#if DBG
        p = (LPVOID)(((LPBYTE)p) - sizeof(MYMEMINFO));
#endif
        p = (LPVOID)*((PDWORD_PTR)((DWORD_PTR)p - 8));
        return (LocalSize (p) - 16);
    }

    LOG((TL_INFO,"----- ClientSize: ptr = NULL!"));
    return 0;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// FreeClientResources
//
// This function is called from inside CTAPI::Initialize and CTAPI::Shutdown
// only and hence access to it is serialized. Calling this function from some
// other functionality would need making an alternate arrangement to serialize 
// access to this function
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

LONG
WINAPI
FreeClientResources(
    void
    )
{

    LOG((TL_INFO, "FreeClientResources - enter"));

    //grab the critical section
    EnterCriticalSection ( &gcsClientResources );

    //
    // If ghTapi32 is non-NULL it means the AsyncEventsThread is
    // still running (an ill-behaved app is trying to unload us
    // without calling shutdown) so go thru the motions of getting
    // the thread to terminate (like we do in xxxShutdown)
    //
    // Otherwise close our handle to the shared event
    //

    if (gpAsyncEventsThreadParams)
    {
        gpAsyncEventsThreadParams->bExitThread = TRUE;
        SetEvent (ghAsyncEventsEvent);
        gpAsyncEventsThreadParams = NULL;

        gbExitThread = TRUE;
        SetEvent (ghCallbackThreadEvent);
    }
    else if (gphCx)
    {

        if (NULL != ghAsyncEventsEvent)
        {
            CloseHandle (ghAsyncEventsEvent);
            ghAsyncEventsEvent = NULL;
        }

        if (NULL != ghCallbackThreadEvent)
        {
            CloseHandle (ghCallbackThreadEvent);
            ghCallbackThreadEvent = NULL;
        }

        if (NULL != ghAsyncRetryQueueEvent)
        {
            CloseHandle (ghAsyncRetryQueueEvent);
            ghAsyncRetryQueueEvent = NULL;
        }
    }

    gpLineAsyncReplyList->FreeList();
    gpPhoneAsyncReplyList->FreeList();

    //
    // If we've made an rpc connection with tapisrv then cleanly detach
    //

    if (gphCx)
    {
        RpcTryExcept
        {
            ClientDetach (&gphCx);
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
            // do something?
        }
        RpcEndExcept

        gphCx = NULL;
    }


    //
    // Free up any other resources we were using
    //

    if (ghWow32Dll)
    {
        FreeLibrary (ghWow32Dll);
        ghWow32Dll = NULL;
    }

    //release the mutex
    LeaveCriticalSection ( &gcsClientResources );

    LOG((TL_INFO, "FreeClientResources - exit"));

    return 0;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// eventName
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
char *eventName(TAPI_EVENT event)
    {
    switch(event)
        {
        case TE_TAPIOBJECT:
            return "TE_TAPIOBJECT";
        case TE_ADDRESS:
            return "TE_ADDRESS";
        case TE_CALLNOTIFICATION:
            return "TE_CALLNOTIFICATION";
        case TE_CALLSTATE:
            return "TE_CALLSTATE";
        case TE_CALLMEDIA:
            return "TE_CALLMEDIA";
        case TE_CALLHUB:
            return "TE_CALLHUB";
        case TE_CALLINFOCHANGE:
            return "TE_CALLINFOCHANGE";
        case TE_PRIVATE:
            return "TE_PRIVATE";
        case TE_REQUEST:
            return "TE_REQUEST";
        case TE_AGENT:
            return "TE_AGENT";
        case TE_AGENTSESSION:
            return "TE_AGENTSESSION";
        case TE_QOSEVENT:
            return "TE_QOSEVENT";
        case TE_AGENTHANDLER:
            return "TE_AGENTHANDLER";
        case TE_ACDGROUP:
            return "TE_ACDGROUP";
        case TE_QUEUE:
            return "TE_QUEUE";
        case TE_DIGITEVENT:
            return "TE_DIGITEVENT";
        case TE_GENERATEEVENT:
            return "TE_GENERATEEVENT";
        case TE_PHONEEVENT:
            return "TE_PHONEEVENT";
        case TE_PHONEDEVSPECIFIC:
            return "TE_PHONEDEVSPECIFIC";
        case TE_ADDRESSDEVSPECIFIC:
            return "TE_ADDRESSDEVSPECIFIC";
        default:
            return "???";
 
        }
    }

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// callStateName
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
char *callStateName(CALL_STATE callState)
    {
    switch(callState)
        {
        case CS_IDLE:
            return "CS_IDLE";
        case CS_INPROGRESS:
            return "CS_INPROGRESS";
        case CS_CONNECTED:
            return "CS_CONNECTED";
        case CS_DISCONNECTED:
            return "CS_DISCONNECTED";
        case CS_OFFERING:
            return "CS_OFFERING";
        case CS_HOLD:
            return "CS_HOLD";
        case CS_QUEUED:
            return "CS_QUEUED";
        default:
            return "???";
        }
    }


#ifdef TRACELOG
void TAPIFormatMessage(HRESULT hr, LPVOID lpMsgBuf)
{
    // Get the error message relating to our HRESULT
    FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_FROM_HMODULE |
        FORMAT_MESSAGE_FROM_SYSTEM |
        FORMAT_MESSAGE_IGNORE_INSERTS,
        (LPCVOID)GetModuleHandle("TAPI3.DLL"),
        hr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) lpMsgBuf,
        0,
        NULL
        );
}
#endif


LONG
CALLBACK
TUISPIDLLCallback(
    DWORD_PTR dwObjectID,
    DWORD   dwObjectType,
    LPVOID  lpParams,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 6, xUIDLLCallback),

        {
            (ULONG_PTR) dwObjectID,
            (ULONG_PTR) dwObjectType,
            (ULONG_PTR) lpParams,
            (ULONG_PTR) dwSize,
            (ULONG_PTR) lpParams,
            (ULONG_PTR) dwSize
        },

        {
            Dword,
            Dword,
            lpSet_SizeToFollow,
            Size,
            lpGet_SizeToFollow,
            Size
        }
    };


    return (DOFUNC (&funcArgs, "UIDLLCallback"));
}


void
UIThread(
    LPVOID  pParams
    )
{
    DWORD           dwThreadID =  GetCurrentThreadId();
    HANDLE          hTapi32;
    PUITHREADDATA   pUIThreadData = (PUITHREADDATA) pParams;


    LOG((TL_TRACE, "UIThread: enter (tid=%d)", dwThreadID));


    //
    // Call LoadLibrary to increment the reference count in case this
    // thread is still running when this dll gets unloaded
    //

    hTapi32 = LoadLibrary ("tapi32.dll");

    LOG((TL_INFO, "UIThread: calling TUISPI_providerGenericDialog..."));

    ((TUIGDPROC)(*pUIThreadData->pfnTUISPI_providerGenericDialog))(
        TUISPIDLLCallback,
        pUIThreadData->htDlgInst,
        pUIThreadData->pParams,
        pUIThreadData->dwSize,
        pUIThreadData->hEvent
        );

    LOG((TL_INFO,
        "UIThread: TUISPI_providerGenericDialog returned (tid=%d)",
        dwThreadID
        ));


    //
    // Remove the ui thread data struct from the global list
    //

    EnterCriticalSection (&gcsTapisrvCommunication);

    if (pUIThreadData->pNext)
    {
        pUIThreadData->pNext->pPrev = pUIThreadData->pPrev;
    }

    if (pUIThreadData->pPrev)
    {
        pUIThreadData->pPrev->pNext = pUIThreadData->pNext;
    }
    else
    {
        gpUIThreadInstances = pUIThreadData->pNext;
    }

    LeaveCriticalSection (&gcsTapisrvCommunication);


    //
    // Free the library & buffers, then alert tapisrv
    //

    FreeLibrary (pUIThreadData->hUIDll);

    CloseHandle (pUIThreadData->hThread);

    CloseHandle (pUIThreadData->hEvent);

    if (pUIThreadData->pParams)
    {
        ClientFree (pUIThreadData->pParams);
    }

    {
        FUNC_ARGS funcArgs =
        {
            MAKELONG (LINE_FUNC | SYNC | 1, xFreeDialogInstance),

            {
                (ULONG_PTR) pUIThreadData->htDlgInst
            },

            {
                Dword
            }
        };


        DOFUNC (&funcArgs, "FreeDialogInstance");
    }

    ClientFree (pUIThreadData);

    LOG((TL_TRACE, "UIThread: exit (tid=%d)", dwThreadID));

    if (hTapi32 != NULL)
    {
        FreeLibraryAndExitThread ((HINSTANCE)hTapi32, 0);
    }
    else
    {
        ExitThread (0);
    }
}


LONG
//WINAPI
CALLBACK
LAddrParamsInited(
    LPDWORD lpdwInited
    )
{
    HKEY  hKey;
    HKEY  hKey2;
    DWORD dwDataSize;
    DWORD dwDataType;


    //
    // This is called by the modem setup wizard to determine
    // whether they should put up TAPI's Wizard page.
    //

    if (ERROR_SUCCESS !=
        RegOpenKeyEx(
                      HKEY_LOCAL_MACHINE,
                      gszTelephonyKey,
                      0,
                      KEY_READ,
                      &hKey2
                    ))
    {
        LOG((TL_ERROR, "LAddrParamsInited - failed to open registry key" ));
        return 0;
    }

    if (ERROR_SUCCESS !=
        RegOpenKeyEx(
                      hKey2,
                      gszLocations,
                      0,
                      KEY_READ,
                      &hKey
                    ))
    {
        RegCloseKey (hKey2);
        LOG((TL_ERROR, "LAddrParamsInited - failed to open registry key" ));
        return 0;
    }

    dwDataSize = sizeof(DWORD);
    *lpdwInited=0;

    RegQueryValueEx(
                     hKey,
                     gszNumEntries,
                     0,
                     &dwDataType,
                     (LPBYTE)lpdwInited,
                     &dwDataSize
                   );

    RegCloseKey( hKey );
    RegCloseKey( hKey2);

    //
    // Return a "proper" code
    //
    if ( *lpdwInited > 1 )
    {
       *lpdwInited = 1;
    }

    return 0;
}


LONG
WINAPI
lineTranslateDialogA(
    HLINEAPP    hLineApp,
    DWORD       dwDeviceID,
    DWORD       dwAPIVersion,
    HWND        hwndOwner,
    LPCSTR      lpszAddressIn
    );


/////////////////////////////////////////////////////////////////////
// internalPerformance
//   tapiperf.dll calls this function to get performance data
//   this just calls into tapisrv
/////////////////////////////////////////////////////////////////////
LONG
WINAPI
internalPerformance(PPERFBLOCK pPerfBlock)
{
        FUNC_ARGS funcArgs =
        {
            MAKELONG (LINE_FUNC | SYNC | 2, tPerformance),

            {
                (ULONG_PTR)pPerfBlock,
                sizeof(PERFBLOCK)
            },

            {
                lpGet_SizeToFollow,
                Size
            }
        };


        return (DOFUNC (&funcArgs, "PerfDataCall"));
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
#if DBG

char *aszLineErrors[] =
{
    NULL,
    "ALLOCATED",
    "BADDEVICEID",
    "BEARERMODEUNAVAIL",
    "inval err value (0x80000004)",      // 0x80000004 isn't valid err code
    "CALLUNAVAIL",
    "COMPLETIONOVERRUN",
    "CONFERENCEFULL",
    "DIALBILLING",
    "DIALDIALTONE",
    "DIALPROMPT",
    "DIALQUIET",
    "INCOMPATIBLEAPIVERSION",
    "INCOMPATIBLEEXTVERSION",
    "INIFILECORRUPT",
    "INUSE",
    "INVALADDRESS",                     // 0x80000010
    "INVALADDRESSID",
    "INVALADDRESSMODE",
    "INVALADDRESSSTATE",
    "INVALAPPHANDLE",
    "INVALAPPNAME",
    "INVALBEARERMODE",
    "INVALCALLCOMPLMODE",
    "INVALCALLHANDLE",
    "INVALCALLPARAMS",
    "INVALCALLPRIVILEGE",
    "INVALCALLSELECT",
    "INVALCALLSTATE",
    "INVALCALLSTATELIST",
    "INVALCARD",
    "INVALCOMPLETIONID",
    "INVALCONFCALLHANDLE",              // 0x80000020
    "INVALCONSULTCALLHANDLE",
    "INVALCOUNTRYCODE",
    "INVALDEVICECLASS",
    "INVALDEVICEHANDLE",
    "INVALDIALPARAMS",
    "INVALDIGITLIST",
    "INVALDIGITMODE",
    "INVALDIGITS",
    "INVALEXTVERSION",
    "INVALGROUPID",
    "INVALLINEHANDLE",
    "INVALLINESTATE",
    "INVALLOCATION",
    "INVALMEDIALIST",
    "INVALMEDIAMODE",
    "INVALMESSAGEID",                   // 0x80000030
    "inval err value (0x80000031)",      // 0x80000031 isn't valid err code
    "INVALPARAM",
    "INVALPARKID",
    "INVALPARKMODE",
    "INVALPOINTER",
    "INVALPRIVSELECT",
    "INVALRATE",
    "INVALREQUESTMODE",
    "INVALTERMINALID",
    "INVALTERMINALMODE",
    "INVALTIMEOUT",
    "INVALTONE",
    "INVALTONELIST",
    "INVALTONEMODE",
    "INVALTRANSFERMODE",
    "LINEMAPPERFAILED",                 // 0x80000040
    "NOCONFERENCE",
    "NODEVICE",
    "NODRIVER",
    "NOMEM",
    "NOREQUEST",
    "NOTOWNER",
    "NOTREGISTERED",
    "OPERATIONFAILED",
    "OPERATIONUNAVAIL",
    "RATEUNAVAIL",
    "RESOURCEUNAVAIL",
    "REQUESTOVERRUN",
    "STRUCTURETOOSMALL",
    "TARGETNOTFOUND",
    "TARGETSELF",
    "UNINITIALIZED",                    // 0x80000050
    "USERUSERINFOTOOBIG",
    "REINIT",
    "ADDRESSBLOCKED",
    "BILLINGREJECTED",
    "INVALFEATURE",
    "NOMULTIPLEINSTANCE",
    "INVALAGENTID",
    "INVALAGENTGROUP",
    "INVALPASSWORD",
    "INVALAGENTSTATE",
    "INVALAGENTACTIVITY",
    "DIALVOICEDETECT"
};

char *aszPhoneErrors[] =
{
    "SUCCESS",
    "ALLOCATED",
    "BADDEVICEID",
    "INCOMPATIBLEAPIVERSION",
    "INCOMPATIBLEEXTVERSION",
    "INIFILECORRUPT",
    "INUSE",
    "INVALAPPHANDLE",
    "INVALAPPNAME",
    "INVALBUTTONLAMPID",
    "INVALBUTTONMODE",
    "INVALBUTTONSTATE",
    "INVALDATAID",
    "INVALDEVICECLASS",
    "INVALEXTVERSION",
    "INVALHOOKSWITCHDEV",
    "INVALHOOKSWITCHMODE",              // 0x90000010
    "INVALLAMPMODE",
    "INVALPARAM",
    "INVALPHONEHANDLE",
    "INVALPHONESTATE",
    "INVALPOINTER",
    "INVALPRIVILEGE",
    "INVALRINGMODE",
    "NODEVICE",
    "NODRIVER",
    "NOMEM",
    "NOTOWNER",
    "OPERATIONFAILED",
    "OPERATIONUNAVAIL",
    "inval err value (0x9000001e)",      // 0x9000001e isn't valid err code
    "RESOURCEUNAVAIL",
    "REQUESTOVERRUN",                   // 0x90000020
    "STRUCTURETOOSMALL",
    "UNINITIALIZED",
    "REINIT"
};

char *aszTapiErrors[] =
{
    "SUCCESS",
    "DROPPED",
    "NOREQUESTRECIPIENT",
    "REQUESTQUEUEFULL",
    "INVALDESTADDRESS",
    "INVALWINDOWHANDLE",
    "INVALDEVICECLASS",
    "INVALDEVICEID",
    "DEVICECLASSUNAVAIL",
    "DEVICEIDUNAVAIL",
    "DEVICEINUSE",
    "DESTBUSY",
    "DESTNOANSWER",
    "DESTUNAVAIL",
    "UNKNOWNWINHANDLE",
    "UNKNOWNREQUESTID",
    "REQUESTFAILED",
    "REQUESTCANCELLED",
    "INVALPOINTER"
};


char *
PASCAL
MapResultCodeToText(
    LONG    lResult,
    char   *pszResult
    )
{
    if (lResult == 0)
    {
        wsprintf (pszResult, "SUCCESS");
    }
    else if (lResult > 0)
    {
        wsprintf (pszResult, "x%x (completing async)", lResult);
    }
    else if (((DWORD) lResult) <= LINEERR_DIALVOICEDETECT)
    {
        lResult &= 0x0fffffff;

        wsprintf (pszResult, "LINEERR_%s", aszLineErrors[lResult]);
    }
    else if (((DWORD) lResult) <= PHONEERR_REINIT)
    {
        if (((DWORD) lResult) >= PHONEERR_ALLOCATED)
        {
            lResult &= 0x0fffffff;

            wsprintf (pszResult, "PHONEERR_%s", aszPhoneErrors[lResult]);
        }
        else
        {
            goto MapResultCodeToText_badErrorCode;
        }
    }
    else if (((DWORD) lResult) <= ((DWORD) TAPIERR_DROPPED) &&
             ((DWORD) lResult) >= ((DWORD) TAPIERR_INVALPOINTER))
    {
        lResult = ~lResult + 1;

        wsprintf (pszResult, "TAPIERR_%s", aszTapiErrors[lResult]);
    }
    else
    {

MapResultCodeToText_badErrorCode:

        wsprintf (pszResult, "inval error value (x%x)");
    }

    return pszResult;
}

#endif

#if DBG
void
DumpMemoryList()
{


    PMYMEMINFO       pHold;

    if (gpMemFirst == NULL)
    {
        LOG((TL_ERROR, "All memory deallocated"));

        return;
    }

    pHold = gpMemFirst;

    while (pHold)
    {
       LOG((TL_ERROR, "DumpMemoryList: %p not freed - LINE %d FILE %s!", pHold+1, pHold->dwLine, pHold->pszFile));

       pHold = pHold->pNext;
    }

    LOG((TL_ERROR, "MEMORY LEAKS ALMOST ALWAYS INDICATE A REFERENCE COUNT PROBLEM"));
    LOG((TL_ERROR, "...except for the leaks in client.cpp"));

    if (gbBreakOnLeak)
    {
        DebugBreak();
    }

}
#endif





HRESULT
LineCreateAgent(
    HLINE               hLine,
    PWSTR               pszAgentID,
    PWSTR               pszAgentPIN,
    LPHAGENT            lphAgent        // Return value
    )
{
    
    DWORD hpAgentHandle = CreateHandleTableEntry((ULONG_PTR)lphAgent);

    //
    // the agent handle is filled when callback is called. until then, clear its value
    //

    *lphAgent = 0;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lCreateAgent),

        {
            GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) pszAgentID,
            (ULONG_PTR) pszAgentPIN,
            hpAgentHandle,
        },

        {
            Dword,
            Dword,
            lpszW,
            lpszW,
            Dword
        }
    };

    if ( NULL == pszAgentID )
    {
        funcArgs.Args[2] = TAPI_NO_DATA;
        funcArgs.ArgTypes[2] = Dword;
    }

    if ( NULL == pszAgentPIN )
    {
        funcArgs.Args[3] = TAPI_NO_DATA;
        funcArgs.ArgTypes[3] = Dword;
    }


    HRESULT hr = mapTAPIErrorCode(DOFUNC (&funcArgs, "lineCreateAgent"));


    //
    // if failed, delete the handle table entry now. otherwise it will be deleted by the callback
    //
    
    if (FAILED(hr))
    {
        DeleteHandleTableEntry(hpAgentHandle);
    }

    return hr;
}



LONG
WINAPI
lineSetAgentMeasurementPeriod(
    HLINE               hLine,
    HAGENT              hAgent,
    DWORD               dwMeasurementPeriod
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lSetAgentMeasurementPeriod),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) hAgent,
            (ULONG_PTR) dwMeasurementPeriod
        },

        {
            Dword,
            Dword,
            Dword
        }
    };


    return mapTAPIErrorCode(DOFUNC (&funcArgs, "lineSetAgentMeasurementPeriod"));
}



LONG
WINAPI
lineGetAgentInfo(
    HLINE               hLine,
    HAGENT              hAgent,
    LPLINEAGENTINFO     lpAgentInfo         // Returned structure
    )
{
    DWORD hpAgentInfo = CreateHandleTableEntry((ULONG_PTR)lpAgentInfo);

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lGetAgentInfo),

        {
            GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) hAgent,
            hpAgentInfo, // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpAgentInfo         // pass data
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct
        }
    };


    HRESULT hr = mapTAPIErrorCode(DOFUNC (&funcArgs, "lineGetAgentInfo"));

    if (FAILED(hr))
    {
        DeleteHandleTableEntry(hpAgentInfo);
    }


    return hr;
}



HRESULT
LineCreateAgentSession(
    HLINE               hLine,
    HAGENT              hAgent,
    PWSTR               pszAgentPIN,
    DWORD               dwWorkingAddressID,
    LPGUID              lpGroupID,
    HAGENTSESSION      *phAgentSession         // Return value
    )
{

    
    DWORD hpAgentSession = CreateHandleTableEntry((ULONG_PTR)phAgentSession);


    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 8, lCreateAgentSession),

        {
            GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) hAgent,
            (ULONG_PTR) pszAgentPIN,
            (ULONG_PTR) dwWorkingAddressID,
            (ULONG_PTR) lpGroupID,              //  GroupID GUID
            (ULONG_PTR) sizeof(GUID),           //  GroupID GUID (size)
            hpAgentSession
        },

        {
            Dword,
            Dword,
            Dword,
            lpszW,
            Dword,
            lpSet_SizeToFollow,             //  GroupID GUID
            Size,                           //  GroupID GUID
            Dword
        }
    };

    if ( NULL == pszAgentPIN )
    {
        funcArgs.Args[3] = TAPI_NO_DATA;
        funcArgs.ArgTypes[3] = Dword;
    }


    HRESULT hr = mapTAPIErrorCode(DOFUNC (&funcArgs, "lineCreateAgentSession"));


    //
    // if we failed, remove handle table entry now. otherwise it will be 
    // removed by the callback
    //
    
    if (FAILED(hr))
    {
        DeleteHandleTableEntry(hpAgentSession);
    }

    return hr;
}




LONG
WINAPI
lineGetAgentSessionInfo(
    HLINE                   hLine,
    HAGENTSESSION           hAgentSession,
    LPLINEAGENTSESSIONINFO  lpAgentSessionInfo      // Returned structure
    )
{
    
    DWORD hpAgentSessionInfo = CreateHandleTableEntry((ULONG_PTR)lpAgentSessionInfo);

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lGetAgentSessionInfo),

        {
            GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) hAgentSession,
            hpAgentSessionInfo, // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpAgentSessionInfo         // pass data
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct
        }
    };

    
    HRESULT hr = mapTAPIErrorCode(DOFUNC (&funcArgs, "lineGetAgentSessionInfo"));


    //
    // if failed, clear handle table now. otherwise the callback will do this.
    //

    if (FAILED(hr))
    {
     
        DeleteHandleTableEntry(hpAgentSessionInfo);
    }


    return hr;
}


LONG
WINAPI
lineSetAgentSessionState(
    HLINE               hLine,
    HAGENTSESSION       hAgentSession,
    DWORD               dwAgentState,
    DWORD               dwNextAgentState
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 4, lSetAgentSessionState),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) hAgentSession,
            dwAgentState,
            dwNextAgentState
        },

        {
            Dword,
            Dword,
            Dword,
            Dword
        }
    };


    return mapTAPIErrorCode(DOFUNC (&funcArgs, "lineSetAgentSessionState"));
}



LONG
WINAPI
lineSetQueueMeasurementPeriod(
    HLINE               hLine,
    DWORD               dwQueueID,
    DWORD               dwMeasurementPeriod
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lSetQueueMeasurementPeriod),

        {
            (ULONG_PTR) hLine,
            dwQueueID,
            dwMeasurementPeriod
        },

        {
            Dword,
            Dword,
            Dword
        }
    };


    return mapTAPIErrorCode(DOFUNC (&funcArgs, "lineSetQueueMeasurementPeriod"));
}




LONG
WINAPI
lineGetQueueInfo(
    HLINE               hLine,
    DWORD               dwQueueID,
    LPLINEQUEUEINFO     lpQueueInfo         // Returned structure
    )
{

    DWORD hpQueueInfo = CreateHandleTableEntry((ULONG_PTR)lpQueueInfo);

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lGetQueueInfo),

        {
            GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            dwQueueID,
            hpQueueInfo, // pass the actual ptr (for ppproc)
            (ULONG_PTR) lpQueueInfo         // pass data
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct
        }
    };


    HRESULT hr = mapTAPIErrorCode(DOFUNC (&funcArgs, "lineGetQueueInfo"));


    //
    // if we failed, cleanup now. otherwise the callback will.
    //

    if (FAILED(hr))
    {

        DeleteHandleTableEntry(hpQueueInfo);
    }


    return hr;
}



// Proxy message  - LINEPROXYREQUEST_GETGROUPLIST : struct - GetGroupList

HRESULT
LineGetGroupList(
    HLINE                   hLine,
    LPLINEAGENTGROUPLIST  * ppGroupList     // Returned structure
    )
{
    HRESULT     hr = S_OK;
    long        lResult;
    DWORD       dwSize = sizeof(LINEAGENTGROUPLIST) + 500;


    *ppGroupList = (LPLINEAGENTGROUPLIST) ClientAlloc( dwSize );

    if (NULL == *ppGroupList)
    {
        return E_OUTOFMEMORY;
    }

    (*ppGroupList)->dwTotalSize = dwSize;

    
    DWORD hpGroupList = CreateHandleTableEntry( (ULONG_PTR)*ppGroupList );


    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 4, lGetGroupList),

        {
            GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            hpGroupList, // pass the actual ptr (for ppproc)
            (ULONG_PTR) *ppGroupList        // pass data
        },

        {
            Dword,
            Dword,
            Dword,
            lpGet_Struct,
        }
    };


    while (TRUE)
    {
        lResult = DOFUNC (&funcArgs, "lineGetGroupList");
        if (lResult > 0)    // async reply
        {
            hr = WaitForReply( lResult );

            if ((hr == S_OK))
            {
                if (((*ppGroupList)->dwNeededSize > (*ppGroupList)->dwTotalSize))
                {
                    // didnt Work , adjust buffer size & try again
                    LOG((TL_INFO, "lineGetGroupList failed - buffer too small"));
                    dwSize = (*ppGroupList)->dwNeededSize;

                    DeleteHandleTableEntry(hpGroupList);
                    hpGroupList = 0;

                    ClientFree( *ppGroupList );
                    *ppGroupList = NULL;

                    *ppGroupList = (LPLINEAGENTGROUPLIST) ClientAlloc( dwSize );
                    if (*ppGroupList == NULL)
                    {
                        LOG((TL_ERROR, "lineGetGroupList - repeat ClientAlloc failed"));
                        hr = E_OUTOFMEMORY;
                        break;
                    }
                    else
                    {
                        (*ppGroupList)->dwTotalSize = dwSize;

                        _ASSERTE(0 == hpGroupList);

                        hpGroupList = CreateHandleTableEntry((ULONG_PTR)*ppGroupList);

                        if (0 == hpGroupList)
                        {

                            LOG((TL_ERROR, "lineGetGroupList - failed to create a handle"));
        
                            ClientFree( *ppGroupList );
                            hr = E_OUTOFMEMORY;

                            break;
                        }

                        funcArgs.Args[2] = hpGroupList;
                        funcArgs.Args[3] = (ULONG_PTR)*ppGroupList;
                    }
                }
                else
                {
                    //
                    // WaitForReply succeeded and the buffer was big enough
                    //

                    break;
                }

            } // WaitforReply succeeded
            else
            {
                //
                // WaitForReply failed
                //

                LOG((TL_ERROR, "lineGetGroupList - WaitForReply failed"));

                break;
            }
        }
        else  // failed sync
        {
            LOG((TL_ERROR, "lineGetGroupList - failed sync"));
            hr = mapTAPIErrorCode(lResult);

            break;
        }
    } // end while(TRUE)

    
    DeleteHandleTableEntry(hpGroupList);
    hpGroupList = 0;


    LOG((TL_ERROR, "lineGetGroupList - completed hr %lx", hr));

    return hr;
}




HRESULT
lineGetQueueList(
    HLINE                   hLine,
    LPGUID                  lpGroupID,
    LPLINEQUEUELIST       * ppQueueList     // Returned structure
    )
{
    LOG((TL_TRACE, "lineGetQueueList - enter"));

    HRESULT     hr = S_OK;
    long        lResult;
    DWORD       dwSize = sizeof(LINEQUEUELIST) + 500;


    *ppQueueList = (LPLINEQUEUELIST) ClientAlloc( dwSize );

    if (NULL == *ppQueueList)
    {
        return E_OUTOFMEMORY;
    }

    (*ppQueueList)->dwTotalSize = dwSize;

    
    DWORD hpQueueRequest = CreateHandleTableEntry((ULONG_PTR)*ppQueueList);
    

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 6, lGetQueueList),

        {
            GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) lpGroupID,          // GroupID GUID
            (ULONG_PTR) sizeof(GUID),       // GroupID GUID (size)
            hpQueueRequest, // pass the actual ptr (for ppproc)
            (ULONG_PTR) *ppQueueList        // pass data
        },

        {
            Dword,
            Dword,
            lpSet_SizeToFollow,         //  GroupID GUID
            Size,                       //  GroupID GUID (size)
            Dword,
            lpGet_Struct
        }
    };


    while (TRUE)
    {
        lResult = DOFUNC (&funcArgs, "lineGetQueueList");
        if (lResult > 0)
        {
            hr = WaitForReply( lResult );

            if ((hr == S_OK) )
            {
                if ((*ppQueueList)->dwNeededSize > (*ppQueueList)->dwTotalSize)
                {
                    // didnt Work , adjust buffer size & try again
                    LOG((TL_INFO, "lineGetQueueList failed - buffer to small"));
                    dwSize = (*ppQueueList)->dwNeededSize;
                
                    DeleteHandleTableEntry(hpQueueRequest);
                    hpQueueRequest = 0;

                    ClientFree( *ppQueueList );
                    *ppQueueList = NULL;

                    *ppQueueList = (LPLINEQUEUELIST) ClientAlloc( dwSize );
                    if (*ppQueueList == NULL)
                    {
                        LOG((TL_ERROR, "lineGetQueueList - repeat ClientAlloc failed"));
                        hr = E_OUTOFMEMORY;
                        break;
                    }
                    else
                    {
                        hpQueueRequest = CreateHandleTableEntry((ULONG_PTR)*ppQueueList);

                        (*ppQueueList)->dwTotalSize = dwSize;
                        funcArgs.Args[4] = hpQueueRequest;
                        funcArgs.Args[5] = (ULONG_PTR)*ppQueueList;
                    }
                } // buffer too small
                else
                {
                    //
                    // everything is fine and dandy. nothing else left to do.
                    //

                    break;

                }
            }
            else
            {

                //
                // error case. we have hr, break out. we should really not be 
                // here, since we checked lResult > 0 above
                //

                break;
            }
        }
        else  // failed sync
        {
            LOG((TL_ERROR, "lineGetQueueList - failed sync"));
            hr = mapTAPIErrorCode(lResult);

            break;
        }
    } // end while(TRUE)


    DeleteHandleTableEntry(hpQueueRequest);
    hpQueueRequest = 0;

    LOG((TL_TRACE, "lineGetQueueList - finished hr = %lx", hr));

    return hr;
}



LONG
WINAPI
lineGetAgentSessionList(
    HLINE                     hLine,
    HAGENT                    hAgent,
    LPLINEAGENTSESSIONLIST  * ppSessionList     // Returned structure
    )
{
    HRESULT     hr = S_OK;
    long        lResult;
    DWORD       dwSize = sizeof(LINEAGENTSESSIONLIST) + 500;


    *ppSessionList = (LPLINEAGENTSESSIONLIST) ClientAlloc( dwSize );

    if (NULL == *ppSessionList)
    {
        return E_OUTOFMEMORY;
    }

    (*ppSessionList)->dwTotalSize = dwSize;

    DWORD hpSessionList = CreateHandleTableEntry((ULONG_PTR)*ppSessionList);

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lGetAgentSessionList),

        {
            GetFunctionIndex(lineDevSpecificPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) hAgent,
            hpSessionList, // pass the actual ptr (for ppproc)
            (ULONG_PTR) *ppSessionList        // pass data
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpGet_Struct
        }
    };


    while (TRUE)
    {
        lResult = DOFUNC (&funcArgs, "lineGetAgentSessionList");
        if (lResult > 0)
        {
            hr = WaitForReply( lResult );

            if ((hr == S_OK) && ((*ppSessionList)->dwNeededSize > (*ppSessionList)->dwTotalSize))
            {
                // didnt Work , adjust buffer size & try again
                LOG((TL_INFO, "lineGetAgentSessionList failed - buffer to small"));
                dwSize = (*ppSessionList)->dwNeededSize;
                
                DeleteHandleTableEntry(hpSessionList);
                hpSessionList = 0;

                ClientFree( *ppSessionList );
                *ppSessionList = NULL;

                *ppSessionList = (LPLINEAGENTSESSIONLIST) ClientAlloc( dwSize );
                if (*ppSessionList == NULL)
                {
                    LOG((TL_ERROR, "lineGetAgentSessionList - repeat ClientAlloc failed"));
                    hr = E_OUTOFMEMORY;
                    break;
                }
                else
                {
                    
                    hpSessionList = CreateHandleTableEntry((ULONG_PTR)*ppSessionList);

                    (*ppSessionList)->dwTotalSize = dwSize;
                    funcArgs.Args[3] = hpSessionList;
                    funcArgs.Args[4] = (ULONG_PTR)*ppSessionList;
                }
            }
            else
            {

                //
                // either hr is not ok or hr is ok and the buffer was sufficient.
                // in both cases, nothing much we need to do here, so break out
                //

                break;
            }
        }
        else  // failed sync
        {

            LOG((TL_ERROR, "lineGetAgentSessionListt - failed sync"));
            hr = mapTAPIErrorCode(lResult);

            break;
        }
    } // end while(TRUE)


    DeleteHandleTableEntry(hpSessionList);
    hpSessionList = 0;

    LOG((TL_TRACE, "lineGetAgentSessionListt - finish. hr = %lx", hr));

    return hr;
}

HRESULT
LineCreateMSPInstance(
                      HLINE hLine,
                      DWORD dwAddressID
                     )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lCreateMSPInstance),

        {
            (ULONG_PTR) hLine,
            dwAddressID
        },

        {
            Dword,
            Dword
        }
    };


    return mapTAPIErrorCode( DOFUNC (&funcArgs, "lineCreateMSPInstance") );

}

HRESULT
LineCloseMSPInstance(
                     HLINE hLine
                    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 1, lCloseMSPInstance),

        {
            (ULONG_PTR) hLine
        },

        {
            Dword
        }
    };


    return mapTAPIErrorCode( DOFUNC (&funcArgs, "lineCloseMSPInstance") );
}


/**/
HRESULT mapTAPIErrorCode(long lErrorCode)
{
    HRESULT hr;

    // Check if it's async
    if (lErrorCode > 0)
    {
        hr = lErrorCode;
    }
    else
    {
        switch(lErrorCode)
        {
            //
            // Sucess codes - ie 0
            //
            case TAPI_SUCCESS:
            // case LINEERR_SUCCESS:             // The operation completed successfully.
            // case PHONEERR_SUCCESS:            // The operation completed successfully
            // case TAPIERR_CONNECTED:           // The request was accepted
                hr = S_OK;
                break;

            //
            // Serious errors - Somethings very wrong in TAPI3 !
            //
            // Bad handles !!
            case LINEERR_INVALAPPHANDLE:         // Invalid TAPI line application handle
            case LINEERR_INVALCALLHANDLE:        // Invalid call handle
            case LINEERR_INVALCONFCALLHANDLE:    // Invalid conference call handle
            case LINEERR_INVALCONSULTCALLHANDLE: // Invalid consultation call handle
            case LINEERR_INVALDEVICEHANDLE:      // Invalid device handle
            case LINEERR_INVALLINEHANDLE:        // Invalid line handle
            case LINEERR_BADDEVICEID:            // Invalid line device ID
            case LINEERR_INCOMPATIBLEAPIVERSION: // Incompatible API version
            case LINEERR_INVALADDRESSID:         // Invalid address ID
            case LINEERR_INVALADDRESSMODE:       // Invalid address mode
            case LINEERR_INVALAPPNAME:           // Invalid application name
            case LINEERR_INVALCALLSELECT:        // Invalid call select parameter
            case LINEERR_INVALEXTVERSION:        // Invalid extension version
            case LINEERR_INVALTERMINALID:        // Invalid terminal ID
            case LINEERR_INVALTERMINALMODE:      // Invalid terminal mode
            case LINEERR_LINEMAPPERFAILED:       // No device matches the specified requirements
            case LINEERR_UNINITIALIZED:          // The telephony service has not been initialized
            case LINEERR_NOMULTIPLEINSTANCE:     // You cannot have two instances of the same service provider
            case PHONEERR_INVALAPPHANDLE:        // Invalid TAPI phone application handle
            case PHONEERR_INVALPHONEHANDLE:      // Invalid phone handle
            case PHONEERR_BADDEVICEID:           // Invalid phone device ID
            case PHONEERR_INCOMPATIBLEAPIVERSION:// Incompatible API version
            case PHONEERR_INVALEXTVERSION:       // Invalid extension version
            case PHONEERR_INVALAPPNAME:          // Invalid application name
            case PHONEERR_UNINITIALIZED:         // The telephony service has not been initialized
            case TAPIERR_INVALDEVICEID:          // Invalid device ID
            case TAPIERR_UNKNOWNWINHANDLE:       // Unknown window handle
            case TAPIERR_UNKNOWNREQUESTID:       // Unknown request ID
            case TAPIERR_INVALWINDOWHANDLE:      // Invalid window handle
            // Memory/ Allocation errors
            case LINEERR_STRUCTURETOOSMALL:      // The application failed to allocate sufficient memory for the
                                                 // minimum structure size
            case PHONEERR_STRUCTURETOOSMALL:     // The application failed to allocate sufficient memory for the
                                                 // minimum structure size
                //_ASSERTE( 0 );
                hr = E_UNEXPECTED;
                break;

            case PHONEERR_INIFILECORRUPT:        // The TAPI configuration information is unusable          
            case LINEERR_INIFILECORRUPT:         // The TAPI configuration information is unusable
                hr = TAPI_E_REGISTRY_SETTING_CORRUPT;
                break;

            // Bad Pointers
            case LINEERR_INVALPOINTER:           // Invalid pointer
            case PHONEERR_INVALPOINTER:          // Invalid pointer
            case TAPIERR_INVALPOINTER:           // Invalid pointer
                hr = E_POINTER;
                break;
            //
            // Unexpected Errors
            //
            case LINEERR_OPERATIONFAILED:        // The operation failed for unspecified reasons
            case PHONEERR_OPERATIONFAILED:       // The operation failed for unspecified reasons

            case LINEERR_INCOMPATIBLEEXTVERSION: // Incompatible extension version
            case PHONEERR_INCOMPATIBLEEXTVERSION:// Incompatible extension version

                hr = TAPI_E_OPERATIONFAILED;
                break;

            case LINEERR_ALLOCATED:              // The line device is already in use
            case PHONEERR_ALLOCATED:             // The phone device is already in use
                hr = TAPI_E_ALLOCATED;
                break;

            case LINEERR_BEARERMODEUNAVAIL:      // The requested bearer mode is unavailable
            case LINEERR_INVALBEARERMODE:        // Invalid bearer mode
                hr = TAPI_E_INVALMODE;
                break;

            case LINEERR_CALLUNAVAIL:            // No call appearance available
                hr = TAPI_E_CALLUNAVAIL;
                break;

            case LINEERR_COMPLETIONOVERRUN:      // Too many call completions outstanding
                hr = TAPI_E_COMPLETIONOVERRUN;
                break;

            case LINEERR_CONFERENCEFULL:         // The conference is full
                hr = TAPI_E_CONFERENCEFULL;
                break;

            case LINEERR_DIALBILLING:            // The '$' dial modifier is not supported
            case LINEERR_DIALDIALTONE:           // The 'W' dial modifier is not supported
            case LINEERR_DIALPROMPT:             // The '?' dial modifier is not supported
            case LINEERR_DIALQUIET:              // The '@' dial modifier is not supported
            case LINEERR_DIALVOICEDETECT:        // The ':' dial modifier is not supported
                hr = TAPI_E_DIALMODIFIERNOTSUPPORTED;
                break;

            case LINEERR_RESOURCEUNAVAIL:        // A resource needed to fulfill the request is not available
            case PHONEERR_RESOURCEUNAVAIL:       // A resource needed to fulfill the request is not available
                hr = TAPI_E_RESOURCEUNAVAIL;
                break;

            case LINEERR_INUSE:                  // The line device is already in use
            case PHONEERR_INUSE:                 // The phone device is already in use
            case TAPIERR_DEVICEINUSE:            // The device is already in use
                hr = TAPI_E_INUSE;
                break;

            case LINEERR_INVALADDRESS:           // The phone number is invalid or not properly formatted
            case TAPIERR_INVALDESTADDRESS:       // The phone number is invalid or improperly formatted
                hr = TAPI_E_INVALADDRESS;
                break;

            case LINEERR_INVALADDRESSSTATE:      // Operation not permitted in current address state
            case LINEERR_INVALLINESTATE:         // Operation not permitted in current line state
            case PHONEERR_INVALPHONESTATE:       // Operation not permitted in current phone state
                hr = TAPI_E_INVALADDRESSSTATE;
                break;

            case LINEERR_INVALADDRESSTYPE:       // The specified address type is not supported by this address.
                hr = TAPI_E_INVALADDRESSTYPE;
                break;

            case LINEERR_INVALCALLCOMPLMODE:     // Invalid call completion mode
                hr = TAPI_E_INVALMODE;
                break;

            case LINEERR_INVALCALLPARAMS:        // Invalid LINECALLPARAMS structure
                hr = TAPI_E_INVALCALLPARAMS;
                break;

            case LINEERR_INVALCALLPRIVILEGE:     // Invalid call privilege
            case LINEERR_INVALPRIVSELECT:        // Invalid call privilege selection
                hr = TAPI_E_INVALCALLPRIVILEGE;
                break;

            case LINEERR_INVALCALLSTATE:         // Operation not permitted in current call state
                hr = TAPI_E_INVALCALLSTATE;
                break;

            case LINEERR_INVALCALLSTATELIST:     // Invalid call state list
                hr = TAPI_E_INVALLIST;
                break;

            case LINEERR_INVALCARD:              // Invalid calling card ID
                hr = TAPI_E_INVALCARD;
                break;

            case LINEERR_INVALCOMPLETIONID:      // Invalid call completion ID
                hr = TAPI_E_INVALCOMPLETIONID;
                break;

            case LINEERR_INVALCOUNTRYCODE:       // Invalid country code
                hr = TAPI_E_INVALCOUNTRYCODE;
                break;

            case LINEERR_INVALDEVICECLASS:       // Invalid device class identifier
            case PHONEERR_INVALDEVICECLASS:      // Invalid device class identifier
            case TAPIERR_INVALDEVICECLASS:
            case TAPIERR_DEVICECLASSUNAVAIL:     // The device class is unavailable
            case TAPIERR_DEVICEIDUNAVAIL:        // The specified device is unavailable
                hr = TAPI_E_INVALDEVICECLASS;
                break;

            case LINEERR_INVALDIALPARAMS:        // Invalid dialing parameters
                hr = TAPI_E_INVALDIALPARAMS;
                break;

            case LINEERR_INVALDIGITLIST:         // Invalid digit list
                hr = TAPI_E_INVALLIST;
                break;

            case LINEERR_INVALDIGITMODE:         // Invalid digit mode
                hr = TAPI_E_INVALMODE;
                break;

            case LINEERR_INVALDIGITS:            // Invalid digits
                hr = TAPI_E_INVALDIGITS;
                break;

            case LINEERR_INVALGROUPID:           // Invalid group pickup ID
                hr = TAPI_E_INVALGROUPID;
                break;

            case LINEERR_INVALLOCATION:          // Invalid location ID
                hr = TAPI_E_INVALLOCATION;
                break;

            case LINEERR_INVALMEDIALIST:         // Invalid media list
                hr = TAPI_E_INVALLIST;
                break;

            case LINEERR_INVALMEDIAMODE:         // Invalid media mode
                hr = TAPI_E_INVALIDMEDIATYPE;
                break;

            case LINEERR_INVALMESSAGEID:         // Invalid message ID
                hr = TAPI_E_INVALMESSAGEID;
                break;

            case LINEERR_INVALPARAM:             // Invalid parameter
                hr = E_INVALIDARG;
                break;

            case LINEERR_INVALPARKID:            // Invalid park ID
                hr = TAPI_E_INVALPARKID;
                break;

            case LINEERR_INVALPARKMODE:          // Invalid park mode
            case PHONEERR_INVALPARAM:            // Invalid parameter
                hr = TAPI_E_INVALMODE;
                break;

            case LINEERR_INVALRATE:              // Invalid rate
            case LINEERR_RATEUNAVAIL:            // The requested data rate is not available
                hr = TAPI_E_INVALRATE;
                break;

            case LINEERR_INVALREQUESTMODE:       // Invalid request mode
                hr = TAPI_E_INVALMODE;
                break;

            case LINEERR_INVALTIMEOUT:           // Invalid timeout value
                hr = TAPI_E_INVALTIMEOUT;
                break;

            case LINEERR_INVALTONE:              // Invalid tone
                hr = TAPI_E_INVALTONE;
                break;

            case LINEERR_INVALTONELIST:          // Invalid tone list
                hr = TAPI_E_INVALLIST;
                break;

            case LINEERR_INVALTONEMODE:          // Invalid tone mode
            case LINEERR_INVALTRANSFERMODE:      // Invalid transfer mode
            case PHONEERR_INVALBUTTONMODE:       // Invalid button mode
            case PHONEERR_INVALHOOKSWITCHMODE:   // Invalid hookswitch mode
            case PHONEERR_INVALLAMPMODE:         // Invalid lamp mode
            case PHONEERR_INVALRINGMODE:         // Invalid ring mode
                hr = TAPI_E_INVALMODE;
                break;


            case LINEERR_NOCONFERENCE:           // The call is not part of a conference
                hr = TAPI_E_NOCONFERENCE;
                break;

            case LINEERR_NODEVICE:               // The device was removed, or the device class is not recognized
            case PHONEERR_NODEVICE:              // The device was removed, or the device class is not recognized
                hr = TAPI_E_NODEVICE;
                break;

            case LINEERR_NODRIVER:               // The service provider was removed
            case PHONEERR_NODRIVER:              // The service provider was removed
                hr = TAPI_E_NODRIVER;
                break;

            case LINEERR_NOMEM:                  // Insufficient memory available to complete the operation
            case PHONEERR_NOMEM:                 // Insufficient memory available to complete the operation
                hr = E_OUTOFMEMORY;
                break;

            case LINEERR_NOREQUEST:              // No Assisted Telephony requests are pending
                hr = TAPI_E_NOREQUEST;
                break;

            case LINEERR_NOTOWNER:               // The application is does not have OWNER privilege on the call
            case PHONEERR_NOTOWNER:              // The application is does not have OWNER privilege on the phone
                hr = TAPI_E_NOTOWNER;
                break;

            case LINEERR_NOTREGISTERED:          // The application is not registered to handle requests
                hr = TAPI_E_NOTREGISTERED;
                break;

            case LINEERR_OPERATIONUNAVAIL:       // The operation is not supported by the underlying service provider
            case PHONEERR_OPERATIONUNAVAIL:      // The operation is not supported by the underlying service provider
                hr = TAPI_E_NOTSUPPORTED;
                break;


            case LINEERR_REQUESTOVERRUN:         // The request queue is already full
            case PHONEERR_REQUESTOVERRUN:        // The request queue is already full
                hr= TAPI_E_REQUESTOVERRUN;
                break;

            case LINEERR_SERVICE_NOT_RUNNING:    // The Telephony service could not be contacted
            case PHONEERR_SERVICE_NOT_RUNNING:   // The Telephony service could not be contacted
                hr = TAPI_E_SERVICE_NOT_RUNNING;
                break;

            case LINEERR_TARGETNOTFOUND:         // The call handoff failed because the specified target was not found
                hr = TAPI_E_TARGETNOTFOUND;
                break;

            case LINEERR_TARGETSELF:             // No higher priority target exists for the call handoff
                hr = TAPI_E_TARGETSELF;
                break;

            case LINEERR_USERUSERINFOTOOBIG:     // The amount of user-user info exceeds the maximum permitted
                hr = TAPI_E_USERUSERINFOTOOBIG;
                break;

            case LINEERR_REINIT:                 // The operation cannot be completed until all TAPI applications
                                                 // call lineShutdown
            case PHONEERR_REINIT:                // The operation cannot be completed until all TAPI applications
				hr = TAPI_E_REINIT;
                break;

            case LINEERR_ADDRESSBLOCKED:         // You are not permitted to call this number
                hr = TAPI_E_ADDRESSBLOCKED;
                break;

            case LINEERR_BILLINGREJECTED:        // The calling card number or other billing information was rejected
                hr = TAPI_E_BILLINGREJECTED;
                break;

            case LINEERR_INVALFEATURE:           // Invalid device-specific feature
                hr = TAPI_E_INVALFEATURE;
                break;

            case LINEERR_INVALAGENTID:           // Invalid agent ID
                hr = TAPI_E_CALLCENTER_INVALAGENTID;
                break;

            case LINEERR_INVALAGENTGROUP:        // Invalid agent group
                hr = TAPI_E_CALLCENTER_INVALAGENTGROUP;
                break;

            case LINEERR_INVALPASSWORD:          // Invalid agent password
                hr = TAPI_E_CALLCENTER_INVALPASSWORD;
                break;

            case LINEERR_INVALAGENTSTATE:        // Invalid agent state
                hr = TAPI_E_CALLCENTER_INVALAGENTSTATE;
                break;

            case LINEERR_INVALAGENTACTIVITY:     // Invalid agent activity
                hr = TAPI_E_CALLCENTER_INVALAGENTACTIVITY;
                break;

            case PHONEERR_INVALPRIVILEGE:        // Invalid privilege
                hr = TAPI_E_INVALPRIVILEGE;
                break;

            case PHONEERR_INVALBUTTONLAMPID:     // Invalid button or lamp ID
                hr = TAPI_E_INVALBUTTONLAMPID;
                break;

            case PHONEERR_INVALBUTTONSTATE:      // Invalid button state
                hr = TAPI_E_INVALBUTTONSTATE;
                break;

            case PHONEERR_INVALDATAID:           // Invalid data segment ID
                hr = TAPI_E_INVALDATAID;
                break;

            case PHONEERR_INVALHOOKSWITCHDEV:    // Invalid hookswitch device ID
                hr = TAPI_E_INVALHOOKSWITCHDEV;
                break;


            case TAPIERR_DROPPED:                // The call was disconnected
                hr = TAPI_E_DROPPED;
                break;

            case TAPIERR_NOREQUESTRECIPIENT:     // No program is available to handle the request
                hr = TAPI_E_NOREQUESTRECIPIENT;
                break;

            case TAPIERR_REQUESTQUEUEFULL:       // The queue of call requests is full
                hr = TAPI_E_REQUESTQUEUEFULL;
                break;

            case TAPIERR_DESTBUSY:               // The called number is busy
                hr = TAPI_E_DESTBUSY;
                break;

            case TAPIERR_DESTNOANSWER:           // The called party does not answer
                hr = TAPI_E_DESTNOANSWER;
                break;

            case TAPIERR_DESTUNAVAIL:            // The called number could not be reached
                hr = TAPI_E_DESTUNAVAIL;
                break;

            case TAPIERR_REQUESTFAILED:          // The request failed for unspecified reasons
                hr = TAPI_E_REQUESTFAILED;
                break;

            case TAPIERR_REQUESTCANCELLED:       // The request was cancelled
                hr = TAPI_E_REQUESTCANCELLED;
                break;

            default:
                hr = E_FAIL;
                break;

        } // End switch(lErrorCode)
    }
    return hr;
}




HRESULT UnloadTapi32( BOOL bShutdown )
{
    EnterCriticalSection( &gcsTapi32 );

    if ( bShutdown )
    {
        if ( NULL == gpShutdown )
        {
            gpShutdown = (LINESHUTDOWNPROC)GetProcAddress(
                ghTapi32,
                "lineShutdown"
                );

            if ( NULL == gpShutdown )
            {
                LeaveCriticalSection( &gcsTapi32 );

                return E_FAIL;
            }

            (gpShutdown)(ghLineApp);
        }
    }

    ghLineApp = NULL;
    gpShutdown = NULL;
    gpInitialize = NULL;

    if ( NULL != ghTapi32 )
    {
        FreeLibrary( ghTapi32 );
    }

    LeaveCriticalSection( &gcsTapi32 );

    return S_OK;
}


HRESULT LoadTapi32( BOOL bInitialize )
{
    HRESULT                 hr;
    DWORD                   dwNumDevs;
    DWORD                   dwAPIVersion = TAPI_CURRENT_VERSION;

    EnterCriticalSection( &gcsTapi32 );

        ghTapi32 = LoadLibrary("tapi32.dll");

        //
        // ll failed
        //
        if ( NULL == ghTapi32 )
        {
            LeaveCriticalSection( &gcsTapi32 );

            return E_FAIL;
        }

    if ( bInitialize )
    {
        if ( NULL == gpInitialize )
        {
            gpInitialize = (LINEINITIALIZEPROC)GetProcAddress(
                ghTapi32,
                "lineInitializeExW"
                );

            if ( NULL == gpInitialize )
            {
                LOG((TL_ERROR, "LoadTapi32 - getprocaddres failed 1"));

                LeaveCriticalSection( &gcsTapi32 );

                UnloadTapi32( FALSE );

                return E_FAIL;
            }
        }

        LINEINITIALIZEEXPARAMS      lei;

        ZeroMemory( &lei, sizeof(lei) );

        lei.dwTotalSize = sizeof(lei);
        lei.dwOptions = LINEINITIALIZEEXOPTION_USEEVENT;

        hr = (gpInitialize)(
                            &ghLineApp,
                            NULL,
                            NULL,
                            L"tapi3helper",
                            &dwNumDevs,
                            &dwAPIVersion,
                            &lei
                           );

        if ( !SUCCEEDED(hr) )
        {
            ghLineApp = NULL;

            LOG((TL_ERROR, "LoadTapi32 - lineinit failed"));

            LeaveCriticalSection( &gcsTapi32 );

            UnloadTapi32( FALSE );

            return mapTAPIErrorCode( hr );
        }
    }

    LeaveCriticalSection( &gcsTapi32 );

    return S_OK;
}

HRESULT TapiMakeCall(
                     BSTR pDestAddress,
                     BSTR pAppName,
                     BSTR pCalledParty,
                     BSTR pComment
                    )
{
    HRESULT                 hr;
    TAPIREQUESTMAKECALLPROC pTapiMakeCall;

    hr = LoadTapi32( FALSE );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "Could not load TAPI32.DLL"));
        return hr;
    }

    pTapiMakeCall = (TAPIREQUESTMAKECALLPROC)GetProcAddress( ghTapi32, "tapiRequestMakeCallW" );

    if ( NULL == pTapiMakeCall )
    {
        LOG((TL_ERROR, "Could not get the address of tapimakecall"));

        UnloadTapi32( FALSE );

        return E_FAIL;
    }

    hr = pTapiMakeCall(
                       pDestAddress,
                       pAppName,
                       pCalledParty,
                       pComment
                      );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "tapimakecall failed - %lx", hr));
    }

    UnloadTapi32( FALSE );

    return hr;
}


HRESULT
LineTranslateDialog(
                    DWORD dwDeviceID,
                    DWORD dwAPIVersion,
                    HWND hwndOwner,
                    BSTR pAddressIn
                   )
{
    HRESULT                     hr;
    LINEINITIALIZEPROC          pInitialize;
    LINETRANSLATEDIALOGPROC     pTranslateDialog;

    hr = LoadTapi32( TRUE );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "LineTranslateDialog - load tapi32 failed"));

        return hr;
    }

    pTranslateDialog = (LINETRANSLATEDIALOGPROC)GetProcAddress(
        ghTapi32,
        "lineTranslateDialogW"
        );

    if ( NULL == pTranslateDialog )
    {
        LOG((TL_ERROR, "LineTranslateDialog - getprocaddress failed 2"));

        UnloadTapi32( TRUE );

        return E_FAIL;
    }

    hr = (pTranslateDialog)(
                            ghLineApp,
                            dwDeviceID,
                            dwAPIVersion,
                            hwndOwner,
                            pAddressIn
                           );

    hr = mapTAPIErrorCode( hr );
    
    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "LineTranslateDialog failed - %lx", hr));
    }

    UnloadTapi32( TRUE );

    return hr;
}
typedef LONG (PASCAL *LINETRANSLATEADDRESSPROC)(HLINEAPP,
                                                DWORD,
                                                DWORD,
                                                LPCWSTR,
                                                DWORD,
                                                DWORD,
                                                LPLINETRANSLATEOUTPUT);

typedef LONG (PASCAL *LINEGETTRANSLATECAPSPROC)(HLINEAPP,
                                                DWORD,
                                                LPLINETRANSLATECAPS);


HRESULT
LineTranslateAddress(
                     HLINEAPP                hLineApp,
                     DWORD                   dwDeviceID,
                     DWORD                   dwAPIVersion,
                     LPCWSTR                 lpszAddressIn,
                     DWORD                   dwCard,
                     DWORD                   dwTranslateOptions,
                     LPLINETRANSLATEOUTPUT   *ppTranslateOutput
                    )
{
    LONG                        lResult = 0;
    HRESULT                     hr = S_OK;
    DWORD                       dwSize = sizeof(LINETRANSLATECAPS ) + 2000;
    LINETRANSLATEADDRESSPROC    pTranslateProc;


    LOG((TL_TRACE, "lineTranslateAddress - enter"));


    hr = LoadTapi32( FALSE );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "lineTranslateAddress - load tapi32 failed"));

        return hr;
    }

    pTranslateProc = (LINETRANSLATEADDRESSPROC)GetProcAddress(
        ghTapi32,
        "lineTranslateAddressW"
        );

    if ( NULL == pTranslateProc )
    {
        LOG((TL_ERROR, "lineTranslateAddress - getprocaddress failed 2"));

        UnloadTapi32( FALSE );

        return E_FAIL;
    }

    *ppTranslateOutput = (LPLINETRANSLATEOUTPUT) ClientAlloc( dwSize );
    if (*ppTranslateOutput == NULL)
    {
        LOG((TL_ERROR, "lineTranslateAddress - ClientAlloc failed"));
        hr =  E_OUTOFMEMORY;
    }
    else
    {

        (*ppTranslateOutput)->dwTotalSize = dwSize;

        while (TRUE)
        {
            lResult =  (pTranslateProc)(0,
                                        dwDeviceID,
                                        dwAPIVersion,
                                        lpszAddressIn,
                                        dwCard,
                                        dwTranslateOptions,
                                        *ppTranslateOutput
                                        );

            if ((lResult == 0) && ((*ppTranslateOutput)->dwNeededSize > (*ppTranslateOutput)->dwTotalSize))
            {
                // didnt Work , adjust buffer size & try again
                LOG((TL_INFO, "LineGetTranslateCaps failed - buffer to small"));
                dwSize = (*ppTranslateOutput)->dwNeededSize;

                ClientFree( *ppTranslateOutput );

                *ppTranslateOutput = (LPLINETRANSLATEOUTPUT) ClientAlloc( dwSize );
                if (*ppTranslateOutput == NULL)
                {
                    LOG((TL_ERROR, "lineTranslateAddress - repeat ClientAlloc failed"));
                    hr =  E_OUTOFMEMORY;
                    break;
                }
                else
                {
                    (*ppTranslateOutput)->dwTotalSize = dwSize;
                }
            }
            else
            {
                hr = mapTAPIErrorCode( lResult );
                break;
            }
        } // end while(TRUE)


    }

    UnloadTapi32( FALSE );


    LOG((TL_TRACE, hr, "lineTranslateAddress - exit"));
    return hr;
}



HRESULT
LineGetTranslateCaps(
                     HLINEAPP            hLineApp,
                     DWORD               dwAPIVersion,
                     LPLINETRANSLATECAPS *ppTranslateCaps
                    )
{
    LONG                        lResult = 0;
    HRESULT                     hr = S_OK;
    DWORD                       dwSize = sizeof(LINETRANSLATECAPS ) + 2000;
    LINEGETTRANSLATECAPSPROC    pTranslateProc;


    LOG((TL_TRACE, "LineGetTranslateCaps - enter"));

    hr = LoadTapi32( FALSE );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "LineGetTranslateCapsg - load tapi32 failed"));

        return hr;
    }

    pTranslateProc = (LINEGETTRANSLATECAPSPROC)GetProcAddress(
                      ghTapi32,
                      "lineGetTranslateCapsW"
                      );

    if ( NULL == pTranslateProc )
    {
        LOG((TL_ERROR, "LineGetTranslateCaps - getprocaddress failed 2"));

        UnloadTapi32( FALSE );

        return E_FAIL;
    }


    *ppTranslateCaps = (LPLINETRANSLATECAPS) ClientAlloc( dwSize );
    if (*ppTranslateCaps == NULL)
    {
        LOG((TL_ERROR, "LineGetTranslateCaps - ClientAlloc failed"));
        hr =  E_OUTOFMEMORY;
    }
    else
    {

        (*ppTranslateCaps)->dwTotalSize = dwSize;

        while (TRUE)
        {
            lResult = (pTranslateProc)(0,
                                       dwAPIVersion,
                                       *ppTranslateCaps
                                      );

            if ((lResult == 0) && ((*ppTranslateCaps)->dwNeededSize > (*ppTranslateCaps)->dwTotalSize))
            {
                // didnt Work , adjust buffer size & try again
                LOG((TL_INFO, "LineGetTranslateCaps failed - buffer to small"));
                dwSize = (*ppTranslateCaps)->dwNeededSize;

                ClientFree( *ppTranslateCaps );

                *ppTranslateCaps = (LPLINETRANSLATECAPS) ClientAlloc( dwSize );
                if (*ppTranslateCaps == NULL)
                {
                    LOG((TL_ERROR, "LineGetTranslateCaps - repeat ClientAlloc failed"));
                    hr =  E_OUTOFMEMORY;
                    break;
                }
                else
                {
                    (*ppTranslateCaps)->dwTotalSize = dwSize;
                }
            }
            else
            {
                hr = mapTAPIErrorCode( lResult );
                break;
            }
        } // end while(TRUE)

    }

    UnloadTapi32( FALSE );


    LOG((TL_TRACE, hr, "LineGetTranslateCaps - exit"));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function  :  GenerateHandleAndAddToHashTable
//              Creates a unique ULONG_PTR handle  & maps this to the passed in
//              object via a hash table
//              Returns handle
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
ULONG_PTR GenerateHandleAndAddToHashTable( ULONG_PTR Element)
{
    static ULONG_PTR gNextHandle = 0;
    ULONG_PTR uptrHandle = 0;


    gpHandleHashTable->Lock();

    gNextHandle = ++gNextHandle % 0x10;

    uptrHandle = (Element << 4) + gNextHandle;

    gpHandleHashTable->Insert( uptrHandle, Element );

    gpHandleHashTable->Unlock();

    return  uptrHandle;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function  :  RemoveHandleFromHashTable
//              Removes hash table entry, based on passed in handle
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void RemoveHandleFromHashTable(ULONG_PTR dwHandle)
{
    gpHandleHashTable->Lock();

    gpHandleHashTable->Remove( (ULONG_PTR)(dwHandle) );

    gpHandleHashTable->Unlock();
}


/////////////////////////////////////////////////////////////////////
//
//  Internal event filtering functions
//
/////////////////////////////////////////////////////////////////////

#define LOWDWORD(ul64) ((DWORD)(ul64 & 0xffffffff))
#define HIDWORD(ul64) ((DWORD)((ul64 & 0xffffffff00000000) >> 32))

LONG 
WINAPI 
tapiSetEventFilterMasks (
    DWORD           dwObjType,
    LONG_PTR        lObjectID,
    ULONG64         ulEventMasks
)
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (TAPI_FUNC | SYNC | 6, tSetEventMasksOrSubMasks),

        {
            (ULONG_PTR) dwObjType,              //  type of object handle
            (ULONG_PTR) lObjectID,              //  object handle
            (ULONG_PTR) FALSE,                  //  fSubMask
            (ULONG_PTR) 0,                      //  dwSubMasks
            (ULONG_PTR) LOWDWORD(ulEventMasks), //  ulEventMasks low
            (ULONG_PTR) HIDWORD(ulEventMasks),  //  ulEventMasks hi
        },

        {
            Dword,
            (dwObjType == TAPIOBJ_HLINEAPP || dwObjType == TAPIOBJ_HPHONEAPP)?\
                hXxxApp : Dword,
            Dword,
            Dword,
            Dword,
            Dword,
        }
    };


    return (DOFUNC (&funcArgs, "tapiSetEventFilter"));
}

LONG 
WINAPI 
tapiSetEventFilterSubMasks (
    DWORD           dwObjType,
    LONG_PTR        lObjectID,
    ULONG64         ulEventMasks,
    DWORD           dwEventSubMasks
)
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (TAPI_FUNC | SYNC | 6, tSetEventMasksOrSubMasks),

        {
            (ULONG_PTR) dwObjType,              //  type of object handle
            (ULONG_PTR) lObjectID,              //  object handle
            (ULONG_PTR) TRUE,                   //  fSubMask
            (ULONG_PTR) dwEventSubMasks,        //  dwSubMasks
            (ULONG_PTR) LOWDWORD(ulEventMasks), //  ulEventMasks low
            (ULONG_PTR) HIDWORD(ulEventMasks),  //  ulEventMasks hi
        },

        {
            Dword,
            (dwObjType == TAPIOBJ_HLINEAPP || dwObjType == TAPIOBJ_HPHONEAPP)?\
                hXxxApp : Dword,
            Dword,
            Dword,
            Dword,
            Dword,
        }
    };


    return (DOFUNC (&funcArgs, "tapiSetEventFilter"));
}

LONG
WINAPI
tapiGetEventFilterMasks (
    DWORD           dwObjType,
    LONG_PTR        lObjectID,
    ULONG64 *       pulEventMasks
)
{
    DWORD   dwEventSubMasks;
    DWORD   dwHiMasks;
    DWORD   dwLowMasks;
    LONG    lResult;
    
    FUNC_ARGS funcArgs =
    {
        MAKELONG (TAPI_FUNC | SYNC | 8, tGetEventMasksOrSubMasks),

        {
            (ULONG_PTR) dwObjType,          //  object type
            (ULONG_PTR) lObjectID,          //  object handles
            (ULONG_PTR) FALSE,              //  fSubMask
            (ULONG_PTR) &dwEventSubMasks,   //  &dwEventSubMasks
            (ULONG_PTR) 0,                  //  ulEventMasksIn low
            (ULONG_PTR) 0,                  //  ulEventMasksIn hi
            (ULONG_PTR) &dwLowMasks,        //  ulEventMasksOut low
            (ULONG_PTR) &dwHiMasks,         //  ulEventMasksOut hi
        },

        {
            Dword,
            (dwObjType == TAPIOBJ_HLINEAPP || dwObjType == TAPIOBJ_HPHONEAPP)?\
                hXxxApp : Dword,
            Dword,
            lpDword,
            Dword,
            Dword,
            lpDword,
            lpDword,
        }
    };

    lResult = DOFUNC (&funcArgs, "tapiGetEventFilter");
    if (lResult == 0)
    {
        *pulEventMasks = dwHiMasks;
        (*pulEventMasks) <<= 32;
        *pulEventMasks += dwLowMasks;
    }

    return lResult;
}

LONG
WINAPI
tapiGetEventFilterSubMasks (
    DWORD           dwObjType,
    LONG_PTR        lObjectID,
    ULONG64         ulEventMasks,
    DWORD    *      pdwEventSubMasks
)
{
    DWORD       dwHiMasks;
    DWORD       dwLowMasks;
    
    FUNC_ARGS funcArgs =
    {
        MAKELONG (TAPI_FUNC | SYNC | 8, tGetEventMasksOrSubMasks),

        {
            (ULONG_PTR) dwObjType,              //  object type
            (ULONG_PTR) lObjectID,              //  object handle
            (ULONG_PTR) TRUE,                   //  fSubMask
            (ULONG_PTR) pdwEventSubMasks,       //  &dwEventSubMasks
            (ULONG_PTR) LOWDWORD(ulEventMasks), //  ulEventMasksIn low
            (ULONG_PTR) HIDWORD(ulEventMasks),  //  ulEventMasksIn hi
            (ULONG_PTR) &dwLowMasks,            //  ulEventMasksOut low
            (ULONG_PTR) &dwHiMasks,             //  ulEventMasksOut hi
        },

        {
            Dword,
            (dwObjType == TAPIOBJ_HLINEAPP || dwObjType == TAPIOBJ_HPHONEAPP)?\
                hXxxApp : Dword,
            Dword,
            lpDword,
            Dword,
            Dword,
            lpDword,
            lpDword,
        }
    };

    return (DOFUNC (&funcArgs, "tapiGetEventFilter"));
}

LONG
WINAPI
tapiGetPermissibleMasks (
    ULONG64 *            pulPermMasks
)
{
    LONG        lResult;
    DWORD       dwLowMasks;
    DWORD       dwHiMasks;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (TAPI_FUNC | SYNC | 2, tGetPermissibleMasks),

        {
            (ULONG_PTR) &dwLowMasks,    //  ulPermMasks low
            (ULONG_PTR) &dwHiMasks,     //  ulPermMasks hi
        },
        {
            lpDword,
            lpDword,
        }
    };

    lResult = DOFUNC (&funcArgs, "tapiGetPermissibleMasks");
    if (lResult == 0)
    {
        *pulPermMasks = dwHiMasks;
        (*pulPermMasks) <<= 32;
        *pulPermMasks += dwLowMasks;
    }

    return lResult;
}

LONG
WINAPI
tapiSetPermissibleMasks (
    ULONG64              ulPermMasks
)
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (TAPI_FUNC | SYNC | 2, tSetPermissibleMasks),

        {
            (ULONG_PTR)LOWDWORD(ulPermMasks),   //  ulPermMasks low
            (ULONG_PTR)HIDWORD(ulPermMasks),    //  ulPermMasks hi
        },
        {
            Dword,
            Dword,
        }
    };

    return (DOFUNC (&funcArgs, "tapiGetPermissibleMasks"));
}

BOOL
WaveStringIdToDeviceId(
    LPWSTR  pwszStringID,
    LPCWSTR  pwszDeviceType,
    LPDWORD pdwDeviceId
    )
{
    // 
    // This function converts a wave device string ID to a numeric device ID 
    // The numeric device ID can be used in wave functions (waveOutOpen, etc)
    //

    if (!pwszDeviceType || !pwszStringID)
        return FALSE;

    LOG((TL_TRACE, "WaveStringIdToDeviceId (%S, %S) - enter", pwszStringID, pwszDeviceType));

    // get the device id, based on string id and device class
    if ( !_wcsicmp(pwszDeviceType, L"wave/in") ||
         !_wcsicmp(pwszDeviceType, L"wave/in/out")
       )
    {
        return (MMSYSERR_NOERROR == waveInMessage(
                                    NULL,
                                    DRV_QUERYIDFROMSTRINGID,
                                    (DWORD_PTR)pwszStringID,
                                    (DWORD_PTR)pdwDeviceId));

    } else if (!_wcsicmp(pwszDeviceType, L"wave/out"))
    {
        return (MMSYSERR_NOERROR == waveOutMessage(
                                    NULL,
                                    DRV_QUERYIDFROMSTRINGID,
                                    (DWORD_PTR)pwszStringID,
                                    (DWORD_PTR)pdwDeviceId));
    } else if (!_wcsicmp(pwszDeviceType, L"midi/in"))
    {
        return (MMSYSERR_NOERROR == midiInMessage(
                                    NULL,
                                    DRV_QUERYIDFROMSTRINGID,
                                    (DWORD_PTR)pwszStringID,
                                    (DWORD_PTR)pdwDeviceId));
    }  else if (!_wcsicmp(pwszDeviceType, L"midi/out"))
    {
        return (MMSYSERR_NOERROR == midiOutMessage(
                                    NULL,
                                    DRV_QUERYIDFROMSTRINGID,
                                    (DWORD_PTR)pwszStringID,
                                    (DWORD_PTR)pdwDeviceId));
    }

    LOG((TL_TRACE, "WaveStringIdToDeviceId (%S, %S) - failed", pwszStringID, pwszDeviceType));

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\makefile.inc ===
$(O)\tapi3errlocal.mc: $(PROJECT_ROOT)\published\inc\tapi3err.mc
    -copy /v $? $@
    
$(O)\tapsrvrpc.c: ..\..\idl\$(O)\tapsrv_c.c
    -copy /v $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\dispmap.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    dispmap.cpp

Abstract:

    Implements all the methods on DispatchMapper interfaces
    
Author:

    mquinton  03-31-98

Notes:

Revision History:

--*/

#ifndef __DISPMAP_H__
#define __DISPMAP_H__

#include "resource.h"
//#include "objsafe.h"
#include "atlctl.h"

/////////////////////////////////////////////////////////////////////////////
// CDispatchMapper
class CDispatchMapper : 
    public CTAPIComObjectRoot<CDispatchMapper>,
	public CComCoClass<CDispatchMapper, &CLSID_DispatchMapper>,
	public CComDualImpl<ITDispatchMapper, &IID_ITDispatchMapper, &LIBID_TAPI3Lib>,
    public IObjectSafetyImpl<CDispatchMapper>
{
public:                                    
	CDispatchMapper() 
	{
    }

DECLARE_REGISTRY_RESOURCEID(IDR_DISPATCHMAPPER)
DECLARE_QI()
DECLARE_MARSHALQI(CDispatchMapper)
DECLARE_TRACELOG_CLASS(CDispatchMapper)

BEGIN_COM_MAP(CDispatchMapper)
	COM_INTERFACE_ENTRY2(IDispatch, ITDispatchMapper)
	COM_INTERFACE_ENTRY(ITDispatchMapper)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
END_COM_MAP()

    STDMETHOD(QueryDispatchInterface)(
                                      BSTR pIID,
                                      IDispatch * pDispIn,
                                      IDispatch ** ppDispIn
                                     );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\hash.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    hash.h

Abstract:

    Declaration of the CHashTable class
    
Author:

    mquinton  04-28-98

Notes:

Revision History:

--*/

#ifndef __HASH_H__
#define __HASH_H__

typedef struct _TABLEENTRY
{
    ULONG_PTR    HashKey;
    ULONG_PTR    Element;
    CTAPI      * pTapiObj;
    
} TABLEENTRY;
    
typedef struct _TABLEHEADER
{
    DWORD           dwUsedElements;
    TABLEENTRY    * pEntries;
    
} TABLEHEADER;

class CHashTable
{
private:
    CRITICAL_SECTION    m_cs;
    DWORD               m_dwTables;
    DWORD               m_dwEntriesPerTable;
    TABLEHEADER       * m_pTables;
    
public:
    
    CHashTable()
    {
        InitializeCriticalSection( &m_cs );
    }
    ~CHashTable()
    {
        DeleteCriticalSection( &m_cs );
    }

DECLARE_TRACELOG_CLASS(CHashTable)

    void Lock()
    {
        //LOG((TL_INFO,"Hash Table locking......"));        
        EnterCriticalSection( &m_cs );
        //LOG((TL_INFO,"Hash Table locked"));        
    }
    void Unlock()
    {
        //LOG((TL_INFO,"Hash Table Unlocking......"));        
        LeaveCriticalSection( &m_cs );
        //LOG((TL_INFO,"Hash Table Unlocked"));        
    }
            
    HRESULT Initialize( DWORD dwEntries )
    {
        DWORD       dwCount;
        BYTE      * pStart;

        m_dwTables = 31;
        m_dwEntriesPerTable = dwEntries;

        m_pTables = (TABLEHEADER *)ClientAlloc( sizeof(TABLEHEADER) * m_dwTables );

        if ( NULL == m_pTables )
        {
            return E_OUTOFMEMORY;
        }

        pStart = (BYTE *)ClientAlloc( sizeof(TABLEENTRY) * m_dwTables * m_dwEntriesPerTable );

        if ( NULL == pStart )
        {
            ClientFree( m_pTables );

            return E_OUTOFMEMORY;
        }

        for ( dwCount = 0; dwCount < m_dwTables; dwCount++ )
        {
            m_pTables[dwCount].pEntries = (TABLEENTRY *)&( pStart[dwCount *
                m_dwEntriesPerTable * sizeof (TABLEENTRY)] );
            m_pTables[dwCount].dwUsedElements = 0;
        }
        
        return S_OK;

    }


    HRESULT Insert( ULONG_PTR HashKey, ULONG_PTR Element , CTAPI *pTapiObj = 0)
    {
        DWORD           dwHashIndex;
        DWORD           dwCount = 0;
        TABLEHEADER   * pTableHeader;

        if ( HashKey == 0 )
            return S_OK;
        
        dwHashIndex = Hash( HashKey );

        pTableHeader = &(m_pTables[dwHashIndex]);

        if (pTableHeader->dwUsedElements == m_dwEntriesPerTable)
        {
            HRESULT         hr;
            
            hr = Resize();

            if ( !SUCCEEDED(hr) )
            {
                return hr;
            }
        }

        while ( 0 != pTableHeader->pEntries[dwCount].HashKey )
        {
            dwCount ++;
        }
        if (dwCount >= m_dwEntriesPerTable)
        {
            LOG((TL_ERROR,"Hash Table insert: dwCount >= m_dwEntriesPerTable"));        
        }
        
        pTableHeader->pEntries[dwCount].HashKey  = HashKey;
        pTableHeader->pEntries[dwCount].Element  = Element;
        pTableHeader->pEntries[dwCount].pTapiObj = pTapiObj;
        pTableHeader->dwUsedElements++;

        LOG((TL_INFO,"Hash Table insert: key %p - obj %p - tapi %p", HashKey, Element, pTapiObj));

#ifdef DBG
        CheckForDups( pTableHeader );
#endif


        return S_OK;
    }



#ifdef DBG

    HRESULT CheckForDups( TABLEHEADER * pTableHeader )
    {
        DWORD           dwCount;
        DWORD           dwInner;
        
        for ( dwCount = 0; dwCount < m_dwEntriesPerTable; dwCount++ )
        {
            if (pTableHeader->pEntries[dwCount].HashKey == 0)
                continue;
            
            for ( dwInner = dwCount+1; dwInner < m_dwEntriesPerTable; dwInner++ )
            {
                if ( pTableHeader->pEntries[dwCount].HashKey ==
                     pTableHeader->pEntries[dwInner].HashKey )
                {
                    LOG((TL_ERROR, "HashTable - dup entry"));
                    LOG((TL_ERROR, " dwCount = %lx, dwInner = %lx", dwCount,dwInner));
                    LOG((TL_ERROR, " dwHash = %p", pTableHeader->pEntries[dwCount].HashKey));
                    LOG(( TL_ERROR, "HashTable - dup entry"));
                    LOG(( TL_ERROR, " dwCount = %lx, dwInner = %lx", dwCount,dwInner));
                    LOG(( TL_ERROR, " HashKey = %p", pTableHeader->pEntries[dwCount].HashKey));
                    
                    DebugBreak();
                }
            }
        }

        return 0;
    }

#endif // DBG
    
    HRESULT Remove( ULONG_PTR HashKey )
    {
        DWORD           dwHashIndex;
        DWORD           dwCount;
        TABLEHEADER   * pTableHeader;

        LOG((TL_INFO,"Hash Table Remove: key %p ", HashKey));        

        if ( HashKey == 0 )
            return S_OK;
        
        dwHashIndex = Hash( HashKey );

        pTableHeader = &(m_pTables[dwHashIndex]);
        
        for ( dwCount = 0; dwCount < m_dwEntriesPerTable; dwCount++ )
        {
            if ( HashKey == pTableHeader->pEntries[dwCount].HashKey )
            {
                LOG((TL_INFO,"Hash Table Remove: key %p - obj %p",HashKey,pTableHeader->pEntries[dwCount].Element));        
                LOG(( TL_TRACE, "Hash Table Remove: key %p - obj %p",HashKey,pTableHeader->pEntries[dwCount].Element));

                break;
            }
        }

        if ( dwCount == m_dwEntriesPerTable )
        {
            return E_FAIL;
        }

        pTableHeader->pEntries[dwCount].HashKey = 0;
        pTableHeader->pEntries[dwCount].pTapiObj = 0;
        pTableHeader->dwUsedElements--;

        return S_OK;
    }

    HRESULT Find( ULONG_PTR HashKey, ULONG_PTR * pElement )
    {
        DWORD           dwHashIndex;
        TABLEHEADER   * pTableHeader;
        DWORD           dwCount;

        if ( HashKey == 0 )
        {
            LOG((TL_INFO,"Find - Hash Table returning E_FAIL on Find(NULL)"));        
            return E_FAIL;
            // return S_OK;
        }

        dwHashIndex = Hash( HashKey );

        pTableHeader = &(m_pTables[dwHashIndex]);

        for (dwCount = 0; dwCount < m_dwEntriesPerTable; dwCount++ )
        {
            if ( HashKey == pTableHeader->pEntries[dwCount].HashKey )
            {
                break;
            }
        }

        if ( dwCount == m_dwEntriesPerTable )
        {
            return E_FAIL;
        }

        *pElement = pTableHeader->pEntries[dwCount].Element;
        
        LOG((TL_INFO,"Find - Hash Table found: key %p - obj %p",HashKey,*pElement));        

        return S_OK;
    }

    DWORD Hash( ULONG_PTR HashKey )
    {
        return (DWORD)((HashKey >> 4) % m_dwTables);
    }

    HRESULT Resize()
    {
        BYTE * pNewTable;
        BYTE * pOldTable;
        DWORD  dwCount;
        DWORD  dwNumEntries;

        dwNumEntries = 2 * m_dwEntriesPerTable;

        pNewTable = (BYTE *)ClientAlloc( sizeof(TABLEENTRY) * m_dwTables * dwNumEntries );

        if ( NULL == pNewTable )
        {
            return E_OUTOFMEMORY;
        }

        pOldTable = (BYTE *)(m_pTables[0].pEntries);

        for ( dwCount = 0; dwCount < m_dwTables; dwCount ++ )
        {
            CopyMemory(
                       pNewTable,
                       m_pTables[dwCount].pEntries,
                       sizeof(TABLEENTRY) * m_dwEntriesPerTable
                      );

            m_pTables[dwCount].pEntries = (TABLEENTRY*)pNewTable;

            pNewTable += sizeof(TABLEENTRY) * dwNumEntries;
        }

        ClientFree( pOldTable );

        m_dwEntriesPerTable = dwNumEntries;

        return S_OK;
    }
    
    void Shutdown()     
    {
        ClientFree( m_pTables[0].pEntries );
        ClientFree( m_pTables );
    }

    HRESULT Flush( CTAPI * pTapiObj )
    {
        DWORD           dwOuterCount;
        DWORD           dwInnerCount;
        TABLEHEADER   * pTableHeader;

        Lock();
        
        for ( dwOuterCount = 0; dwOuterCount < m_dwTables; dwOuterCount++ )
        {
            pTableHeader = &(m_pTables[dwOuterCount]);
        
            for ( dwInnerCount = 0; dwInnerCount < m_dwEntriesPerTable; dwInnerCount++ )
            {
                if ( pTapiObj == pTableHeader->pEntries[dwInnerCount].pTapiObj )
                {
                    LOG((TL_INFO,"Hash Table Flush: key %p - obj %p - tapi %p",pTableHeader->pEntries[dwInnerCount].HashKey,pTableHeader->pEntries[dwInnerCount].Element, pTapiObj));        
                    LOG(( TL_ERROR, "Hash Table Flush: key %p - obj %p - tapi %p",pTableHeader->pEntries[dwInnerCount].HashKey,pTableHeader->pEntries[dwInnerCount].Element, pTapiObj));

                    pTableHeader->pEntries[dwInnerCount].HashKey = 0;
                    pTableHeader->pEntries[dwInnerCount].pTapiObj = 0;
                    pTableHeader->dwUsedElements--;
                }
            } // end for dwInnerCount
        } // end for dwOuterCount

        Unlock();
        
        return S_OK;
    }


    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\mediaobj.cpp ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

Abstract:


Author:

    mquinton - 4/17/97

Notes:

    optional-notes

Revision History:

--*/

#include "stdafx.h"
#include "uuids.h"


BOOL
IsAudioInTerminal( ITTerminal * pTerminal)
{
    long                    lMediaType;
    TERMINAL_DIRECTION      td;


    pTerminal->get_MediaType(
                             &lMediaType
                            );

    pTerminal->get_Direction( &td );

    //
    // it it's audio in, use
    // the compound terminal
    //
    if ( ( LINEMEDIAMODE_AUTOMATEDVOICE == (DWORD)lMediaType ) &&
         ( TD_RENDER == td ) )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\objectsafeimpl.cpp ===
#include "stdafx.h"

#include "ObjectSafeImpl.h"


/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ObjectSafeImpl.cpp

Abstract:

  Definitions of static data members

--*/



//
// thread safety
//

CComAutoCriticalSection CObjectSafeImpl::s_CritSection;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\enum.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    enum.h

Abstract:

    Template classes for enumerations in TAPI3
    
Author:

    mquinton  06-12-97

Notes:

Revision History:

--*/

#ifndef __ENUM_H_
#define __ENUM_H_

#include "resource.h"       // main symbols

#include <mspenum.h>  // for CSafeComEnum

//////////////////////////////////////////////////////////////////////
// CTapiEnum
//          Template class for enumerations in TAPI3.
//////////////////////////////////////////////////////////////////////
template <class Base, class T, const IID* piid> class CTapiEnum :
    public Base,
    public CTAPIComObjectRoot<Base>
{
public:

    typedef CTapiEnum<Base, T, piid> _CTapiEnumBase;

    DECLARE_MARSHALQI(CTapiEnum)
	DECLARE_TRACELOG_CLASS(CTapiEnum)

    BEGIN_COM_MAP(_CTapiEnumBase)
            COM_INTERFACE_ENTRY_IID(*piid, _CTapiEnumBase)
            COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
            COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
    END_COM_MAP()

protected:

    CTObjectArray<T*>    m_Array;
    int                  m_iCurrentLocation;
    
public:

    // initialize the enumerator with a list<T*>
    HRESULT Initialize(
                       CTObjectArray<T*> array
                      )
    {
        int         iSize, iCount;

        iSize = array.GetSize();

        for( iCount = 0; iCount < iSize; iCount++ )
        {
            m_Array.Add(array[iCount]);
        }

        m_iCurrentLocation = 0;
        
        this->AddRef();

        return S_OK;
    }

    // overloaded
    HRESULT Initialize(
                       CTArray<T*> array
                      )
    {
        int         iSize, iCount;

        iSize = array.GetSize();

        for( iCount = 0; iCount < iSize; iCount++ )
        {
            m_Array.Add(array[iCount]);
        }

        m_iCurrentLocation = 0;
        
        this->AddRef();

        return S_OK;
    }

    // Overloaded function, used with Add to build enum list manually
    HRESULT Initialize( )
    {
        m_iCurrentLocation = 0;
        
        this->AddRef();
        
        return S_OK;
    }    

    // Add - used with non-parameterized initialize() to build enum list manually
    HRESULT Add( T* t)
    {
        m_Array.Add( t );

        return S_OK;
    }
    
    
    // FinalRelease - release the objects that were addreffed in
    // initialize
    void FinalRelease()
    {
        m_Array.Shutdown();
    }


    // standard Next method
    HRESULT STDMETHODCALLTYPE Next( 
                                    ULONG celt,
                                    T ** ppElements,
                                    ULONG* pceltFetched
                                  )
    {
        DWORD       dwCount = 0;
        HRESULT     hr = S_OK;

        if ((NULL == ppElements) || (NULL == pceltFetched && celt > 1))
        {
            return E_POINTER;
        }

        // special case
        if (celt == 0)
        {
            return E_INVALIDARG;
        }

        if (TAPIIsBadWritePtr( ppElements, celt * sizeof(T*)) )
        {
            return E_POINTER;
        }

        if ( ( NULL != pceltFetched) &&
             TAPIIsBadWritePtr( pceltFetched, sizeof (ULONG) ) )
        {
            return E_POINTER;
        }
        
        // iterator over elements
        while ((m_iCurrentLocation != m_Array.GetSize()) && (dwCount < celt))
        {
            ppElements[dwCount] = m_Array[m_iCurrentLocation];
            
            ppElements[dwCount]->AddRef();
            
            m_iCurrentLocation++;
            
            dwCount++;
        }

        if (NULL != pceltFetched)
        {
            *pceltFetched = dwCount;
        }

        // indicate that we've reached the end
        // of the enumeration.
        if (dwCount < celt)
        {
            return S_FALSE;
        }

        return S_OK;
    }

    // standard Reset method
    HRESULT STDMETHODCALLTYPE Reset( void )
    {
        m_iCurrentLocation = 0;
        
        return S_OK;
    }


    // standard Skip method
    HRESULT STDMETHODCALLTYPE Skip( 
                                   ULONG celt
                                  )
    {
        long        lCount = 0;
        
        while ( (lCount < celt) && (m_iCurrentLocation < m_Array.GetSize() ) )
        {
            m_iCurrentLocation++;
            lCount++;
        }

        return S_OK;
    }

    // standard Clone method
    HRESULT STDMETHODCALLTYPE Clone( 
                                    Base  ** ppEnum
                                   )
    {
        HRESULT                        hr = S_OK;
        CComObject< _CTapiEnumBase > * pNewEnum;

        if (TAPIIsBadWritePtr( ppEnum, sizeof (Base *) ) )
        {
            return E_POINTER;
        }

        CComObject< _CTapiEnumBase >::CreateInstance(&pNewEnum);
        if (pNewEnum == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pNewEnum->Initialize(m_Array);

            pNewEnum->m_iCurrentLocation = m_iCurrentLocation;

            *ppEnum = pNewEnum;
        }
        
        return hr;
    }

};

////////////////////////////////////////////////////////////////////////
// CTapiCollection
//      Collection template for TAPI3.0 collections
////////////////////////////////////////////////////////////////////////
template <class T> class CTapiCollection :
    public CComDualImpl<ITCollection2, &IID_ITCollection2, &LIBID_TAPI3Lib>,
    public CTAPIComObjectRoot<T>,
    public CObjectSafeImpl
{
public:
    typedef CTapiCollection<T> _CTapiCollectionBase;

DECLARE_MARSHALQI(CTapiCollection)
DECLARE_TRACELOG_CLASS(CTapiCollection)

BEGIN_COM_MAP(_CTapiCollectionBase)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITCollection)
    COM_INTERFACE_ENTRY(ITCollection2)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

private:

    int                 m_nSize;
    CComVariant *       m_Var;
    
public:

    CTapiCollection() : m_nSize(0),
                        m_Var(NULL)
                        {}


    // initialize
    HRESULT STDMETHODCALLTYPE Initialize(
                                         CTObjectArray<T *> array
                                        )
    {
        int                     i;
        HRESULT                 hr;

        LOG((TL_TRACE, "Initialize - enter"));

        // create variant array
        m_nSize = array.GetSize();

        m_Var = new CComVariant[m_nSize];

        if (m_Var == NULL)
        {
            LOG((TL_ERROR, "Initialize - out of memory"));
            return E_OUTOFMEMORY;
        }

        for (i = 0; i < array.GetSize(); i++)
        {
            // get IDispatch pointer
            IDispatch * pDisp = NULL;

            hr = array[i]->QueryInterface(IID_IDispatch, (void**)&pDisp);

            if (S_OK != hr)
            {
                return hr;
            }

            // create a variant and add it to the collection
            CComVariant& var = m_Var[i];

            VariantInit(&var);
            
            var.vt = VT_DISPATCH;
            var.pdispVal = pDisp;
        }

        LOG((TL_TRACE, "Initialize - exit"));
        
        return S_OK;
    }

    // initialize
    HRESULT STDMETHODCALLTYPE Initialize(
                                         CTArray<T *> array
                                        )
    {
        int                     i;
        HRESULT                 hr;

        LOG((TL_TRACE, "Initialize - enter"));

        // create variant array
        m_nSize = array.GetSize();

        m_Var = new CComVariant[m_nSize];

        if (m_Var == NULL)
        {
            LOG((TL_ERROR, "Initialize - out of memory"));
            return E_OUTOFMEMORY;
        }

        for (i = 0; i < array.GetSize(); i++)
        {
            // get IDispatch pointer
            IDispatch * pDisp = NULL;

            hr = array[i]->QueryInterface(IID_IDispatch, (void**)&pDisp);

            if (S_OK != hr)
            {
                return hr;
            }

            // create a variant and add it to the collection
            CComVariant& var = m_Var[i];

            VariantInit(&var);
            
            var.vt = VT_DISPATCH;
            var.pdispVal = pDisp;
        }

        LOG((TL_TRACE, "Initialize - exit"));
        
        return S_OK;
    }

    void FinalRelease()
    {
        //
        // We "new"ed an array of objects -- delete the array and call
        // each object's destructor. Each destructor calls VariantClear,
        // which calls Release on each pointer.
        //

        if(m_Var != NULL)
        {
            delete [] m_Var;
        }
    }
    
    STDMETHOD(get_Count)(
                         long* retval
                        )
    {
        LOG((TL_TRACE, "get_Count - enter"));

        if ( TAPIIsBadWritePtr( retval, sizeof(long) ) )
        {
            return E_POINTER;
        }
        
        *retval = m_nSize;

        LOG((TL_TRACE, "get_Count - exit"));

        return S_OK;
    }

    STDMETHOD(get_Item)(
                        long Index, 
                        VARIANT* retval
                       )
    {
        LOG((TL_TRACE, "get_Item - enter"));

        if ( TAPIIsBadWritePtr (retval, sizeof(VARIANT) ) )
        {
            return E_POINTER;
        }
        
        VariantInit(retval);

        retval->vt = VT_UNKNOWN;
        retval->punkVal = NULL;

        // use 1-based index, VB like
        if ((Index < 1) || (Index > m_nSize))
        {
            return E_INVALIDARG;
        }

        VariantCopy(retval, &m_Var[Index-1]);

        LOG((TL_TRACE, "get_Item - exit"));
        
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE get__NewEnum(
                                           IUnknown** retval
                                          )
    
    {
        HRESULT         hr;

        LOG((TL_TRACE, "new__Enum - enter"));
        
        if ( TAPIIsBadWritePtr( retval, sizeof( IUnknown * ) ) )
        {
            return E_POINTER;
        }

        *retval = NULL;

        typedef CComObject<CSafeComEnum<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _Copy<VARIANT> > > enumvar;

        enumvar* p; // = new enumvar;
        enumvar::CreateInstance( &p );

        _ASSERTE(p);
        
        if (p == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {

            hr = p->Init(&m_Var[0], &m_Var[m_nSize], NULL, AtlFlagCopy);

            if (SUCCEEDED(hr))
            {
                hr = p->QueryInterface(IID_IEnumVARIANT, (void**)retval);
            }

            if (FAILED(hr))
            {
                delete p;
            }
        }

        LOG((TL_TRACE, "new__Enum - exit"));
        
        return hr;

    }

    STDMETHOD(Add)(
                   long Index, 
                   VARIANT* pVariant
                  )
    {
        LOG((TL_TRACE, "Add - enter"));

        if ( IsBadReadPtr (pVariant, sizeof(VARIANT) ) )
        {
            return E_POINTER;
        }

         // use 1-based index, VB like
        if ( (Index < 1) || (Index > (m_nSize + 1)) )
        {
            return E_INVALIDARG;
        }

        CComVariant *       newVar = NULL;

        newVar = new CComVariant[m_nSize + 1];

        if ( NULL == newVar )
        {
            LOG((TL_ERROR, "Add - out of memory"));
            return E_OUTOFMEMORY;
        }

        HRESULT hr;
        int i;

        // fill in the new array
        for ( i = 0; i < (m_nSize + 1); i++ )
        {
            VariantInit(&newVar[i]);

            if ( i < (Index - 1) )
            {
                // shouldn't reach this case unless there was an old array
                _ASSERTE(m_Var != NULL);

                hr = VariantCopy(&newVar[i], &m_Var[i]);
            }
            else if ( i == (Index - 1) )
            {
                // copy the new element
                hr = VariantCopy(&newVar[i], pVariant);
            }
            else
            {
                // shouldn't reach this case unless there was an old array
                _ASSERTE(m_Var != NULL);

                hr = VariantCopy(&newVar[i], &m_Var[i-1]);
            }

            if ( FAILED(hr) ) 
            {
                LOG((TL_ERROR, "Add - VariantCopy failed - %lx", hr));

                delete [] newVar;

                return hr;
            }
        }

        if ( m_Var != NULL)
        {
            // Delete the old array
            delete [] m_Var;            
        }

        m_Var = newVar;
        m_nSize++;

        LOG((TL_TRACE, "Add - exit"));
        
        return S_OK;
    }

    STDMETHOD(Remove)(
                      long Index
                     )
    {
        LOG((TL_TRACE, "Remove - enter"));

         // use 1-based index, VB like
        if ( (Index < 1) || (Index > m_nSize) )
        {
            return E_INVALIDARG;
        }

        CComVariant *       newVar = NULL;

        // if there is only one element in the array we don't need to do
        // any copying
        if (m_nSize > 1)
        {
            newVar = new CComVariant[m_nSize - 1];

            if ( NULL == newVar )
            {
                LOG((TL_ERROR, "Remove - out of memory"));
                return E_OUTOFMEMORY;
            }

            HRESULT hr;
            int i;
       
            // fill in the new array
            for ( i = 0; i < (m_nSize - 1); i++ )
            {
                VariantInit(&newVar[i]);

                if ( i < (Index - 1) )
                {
                    // shouldn't reach this case unless there was an old array
                    _ASSERTE(m_Var != NULL);

                    hr = VariantCopy(&newVar[i], &m_Var[i]);
                }
                else
                {
                    // shouldn't reach this case unless there was an old array
                    _ASSERTE(m_Var != NULL);

                    hr = VariantCopy(&newVar[i], &m_Var[i+1]);
                }

                if ( FAILED(hr) ) 
                {
                    LOG((TL_ERROR, "Remove - VariantCopy failed - %lx", hr));

                    delete [] newVar;

                    return hr;
                }
            }
        }

        if ( m_Var != NULL)
        {
            // Delete the old array
            delete [] m_Var;            
        }

        m_Var = newVar;
        m_nSize--;

        LOG((TL_TRACE, "Remove - exit"));
        
        return S_OK;
    }

};

////////////////////////////////////////////////////////////////////////
// CTapiBstrCollection
//    Collection of BSTRs.
////////////////////////////////////////////////////////////////////////
class CTapiBstrCollection :
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public IDispatchImpl<ITCollection, &IID_ITCollection, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
public:
DECLARE_TRACELOG_CLASS(CTapiBstrCollection)
BEGIN_COM_MAP(CTapiBstrCollection)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITCollection)
    COM_INTERFACE_ENTRY(IObjectSafety)
END_COM_MAP()

private:

    DWORD               m_dwSize;
    CComVariant *       m_Var;
    
public:

    CTapiBstrCollection(void) : m_dwSize(0), m_Var(NULL) { }

    // initialize
    HRESULT STDMETHODCALLTYPE Initialize(
                                         DWORD dwSize,
                                         BSTR * pBegin,
                                         BSTR * pEnd                                         
                                        )
    {
        BSTR *  i;
        DWORD   dw = 0;

        LOG((TL_TRACE, "Initialize - enter"));

        // create variant array
        m_dwSize = dwSize;

        m_Var = new CComVariant[m_dwSize];

        if (m_Var == NULL)
        {
            // debug output
            return E_OUTOFMEMORY;
        }

        for (i = pBegin; i != pEnd; i++)
        {
            // create a variant and add it to the collection
            CComVariant& var = m_Var[dw];

            var.vt = VT_BSTR;
            var.bstrVal = *i;

            dw++;
        }

        LOG((TL_TRACE, "Initialize - exit"));
        
        return S_OK;
    }
    
    STDMETHOD(get_Count)(
                         long* retval
                        )
    {
        HRESULT         hr = S_OK;

        LOG((TL_TRACE, "get_Count - enter"));        

        try
        {
            *retval = m_dwSize;
        }
        catch(...)
        {
            hr = E_INVALIDARG;
        }

        LOG((TL_TRACE, "get_Count - exit"));
        
        return hr;
    }

    STDMETHOD(get_Item)(
                        long Index, 
                        VARIANT* retval
                       )
    {
        HRESULT         hr = S_OK;

        LOG((TL_TRACE, "get_Item - enter"));
        
        if (retval == NULL)
        {
            return E_POINTER;
        }

        try
        {
            VariantInit(retval);
        }
        catch(...)
        {
            hr = E_INVALIDARG;
        }

        if (hr != S_OK)
        {
            return hr;
        }

        retval->vt = VT_BSTR;
        retval->bstrVal = NULL;

        // use 1-based index, VB like
        // no problem with signed/unsigned, since
        // if Index < 0 then first clause is true, making it
        // irrelevant if the second clause is correct or not.

        if ((Index < 1) || ( (DWORD) Index > m_dwSize))
        {
            return E_INVALIDARG;
        }

        //
        // This copies the string, not just the pointer.
        //

        VariantCopy(retval, &m_Var[Index-1]);

        LOG((TL_TRACE, "get_Item - exit"));

        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE get__NewEnum(
                                           IUnknown** retval
                                          )
    
    {
        HRESULT         hr;

        LOG((TL_TRACE, "get__NumEnum - enter"));
        
        if (retval == NULL)
        {
            return E_POINTER;
        }

        *retval = NULL;

        typedef CComObject<CSafeComEnum<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _Copy<VARIANT> > > enumvar;

        enumvar* p = new enumvar;

        if ( p == NULL)
        {
            // debug output
            return E_OUTOFMEMORY;
        }

        hr = p->Init(&m_Var[0], &m_Var[m_dwSize], NULL, AtlFlagCopy);

        if (SUCCEEDED(hr))
        {
            hr = p->QueryInterface(IID_IEnumVARIANT, (void**)retval);
        }

        if (FAILED(hr))
        {
            delete p;
        }

        LOG((TL_TRACE, "get__NewEnum - exit"));
        
        return hr;

    }

    void FinalRelease()
    {
        LOG((TL_TRACE, "FinalRelease() - enter"));

        //
        // We "new"ed an array of objects. Delete each object in the array. The
        // destructor for each object calls VariantClear to release the pointer
        // in that object, based on the variant's tag.
        //

        delete [] m_Var;

        LOG((TL_TRACE, "FinalRelease() - exit"));
    }

};

////////////////////////////////////////////////////////////////////////
// CTapiTypeEnum template - enumerate types & structures
////////////////////////////////////////////////////////////////////////
template <class Base, class T, class Copy, const IID* piid> class CTapiTypeEnum :
    public Base,
    public CTAPIComObjectRoot<Base>
{
public:

    // *piid is the IID of the enumerator class being
    // created (like IID_IEnumAddressType)
    typedef CTapiTypeEnum<Base, T, Copy, piid> _CTapiTypeEnumBase;
    
    BEGIN_COM_MAP(_CTapiTypeEnumBase)
            COM_INTERFACE_ENTRY_IID(*piid, _CTapiTypeEnumBase)
            COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
            COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
    END_COM_MAP()
    DECLARE_QI()
    DECLARE_MARSHALQI(CTapiTypeEnum)
	DECLARE_TRACELOG_CLASS(CTapiTypeEnum)
	
protected:

        CTArray<T>              m_Array;
        int                     m_iCurrentLocation;
    
public:

    //
    // initialize the enumerator
    //
    HRESULT Initialize(CTArray<T> array)
    {
        int         iSize, iCount;

        iSize = array.GetSize();

        for (iCount = 0; iCount < iSize; iCount++ )
        {
            m_Array.Add(array[iCount]);
        }

        m_iCurrentLocation = 0;
        
        //
        // addref ourself
        //
        this->AddRef();

        
        return S_OK;
    }

    //
    // FinalRelease
    //
    void FinalRelease()
    {
        m_Array.Shutdown();
    }

    HRESULT STDMETHODCALLTYPE Next(
                                    ULONG celt,
                                    T * pElements,
                                    ULONG* pceltFetched
                                  )
    {
        DWORD       dwCount = 0;

        if ((NULL == pElements) || (NULL == pceltFetched && celt > 1))
        {
            return E_POINTER;
        }

        //
        // special case
        //
        if (celt == 0)
        {
            return E_INVALIDARG;
        }

        if (TAPIIsBadWritePtr( pElements, celt * sizeof(T) ) )
        {
            return E_POINTER;
        }
        
        if ( (NULL != pceltFetched) &&
             TAPIIsBadWritePtr( pceltFetched, sizeof(ULONG) ) )
        {
            return E_POINTER;
        }
        
        //
        // iterator over elements and copy
        //
        while ((m_iCurrentLocation != m_Array.GetSize()) && (dwCount < celt))
        {   
            Copy::copy(
                       &(pElements[dwCount]),
                       &(m_Array[m_iCurrentLocation])
                      );

            m_iCurrentLocation++;
            dwCount++;
        }

        //
        // return number copied
        //
        if (NULL != pceltFetched)
        {
            *pceltFetched = dwCount;
        }

        //
        // indicate if we've reached the end
        // of the enumeration.
        //
        if (dwCount < celt)
        {
            return S_FALSE;
        }

        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE Skip(
                                   ULONG celt
                                  )
    {
        long        lCount = 0;
        
        while ( (lCount < celt) && (m_iCurrentLocation < m_Array.GetSize()) )
        {
            m_iCurrentLocation++;
            lCount++;
        }

        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE Reset(void)
    {
        m_iCurrentLocation = 0;
        
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE Clone(
                                    Base ** ppEnum
                                   )
    {
        HRESULT                        hr = S_OK;
        CComObject< _CTapiTypeEnumBase > * pNewEnum;

        if (TAPIIsBadWritePtr( ppEnum, sizeof (Base *) ) )
        {
            return E_POINTER;
        }

        CComObject< _CTapiTypeEnumBase >::CreateInstance(&pNewEnum);

        if (pNewEnum == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pNewEnum->Initialize(m_Array);

            pNewEnum->m_iCurrentLocation = m_iCurrentLocation;

            *ppEnum = pNewEnum;
        }
        
        return hr;
    }
};

////////////////////////////////////////////////////////////////////////
// CTerminalClassEnum
////////////////////////////////////////////////////////////////////////
class CTerminalClassEnum :
    public IEnumTerminalClass,
    public CTAPIComObjectRoot<CTerminalClassEnum>
{
public:

    DECLARE_MARSHALQI(CTerminalClassEnum)
	DECLARE_TRACELOG_CLASS(CTerminalClassEnum)
		
    BEGIN_COM_MAP(CTerminalClassEnum)
            COM_INTERFACE_ENTRY(IEnumTerminalClass)
            COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
            COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
    END_COM_MAP()

protected:

    TerminalClassPtrList            m_list;
    TerminalClassPtrList::iterator  m_iter;
    
public:

    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppvObject) = 0;
	virtual ULONG STDMETHODCALLTYPE AddRef() = 0;
	virtual ULONG STDMETHODCALLTYPE Release() = 0;


    // initialize the enumerator
    HRESULT Initialize(
                       TerminalClassPtrList List
                      )
    {
        // copy the array
        m_list.clear();
        m_list.insert(m_list.begin(), List.begin(), List.end());

        m_iter = m_list.begin();

        this->AddRef();
        
        return S_OK;
    }

    // FinalRelease -- added by ZoltanS
    void FinalRelease(void)
    {
        // go through the list
        for ( m_iter = m_list.begin(); m_iter != m_list.end(); m_iter++ )
        {
            SysFreeString(*m_iter); // this is the real way to free a BSTR

            *m_iter = NULL; // destructor for list will delete(NULL)
        }
    }
    
    
    HRESULT STDMETHODCALLTYPE Next(
                                   ULONG celt,
                                   GUID * pElements,
                                   ULONG* pceltFetched
                                  )
    {
        DWORD       dwCount = 0;
        HRESULT     hr = S_OK;

        if ((NULL == pElements) || (NULL == pceltFetched && celt > 1))
        {
            return E_POINTER;
        }

        // special case
        if (celt == 0)
        {
            return E_INVALIDARG;
        }

        // iterator over elements
        try
        {
            while ( (m_iter != m_list.end()) &&
                    (dwCount < celt) )
            {
                hr = IIDFromString( *m_iter, &(pElements[dwCount]) );

                if (!SUCCEEDED(hr))
                {
                    break;
                }
                
                m_iter++;
                dwCount++;
            }
        }
        catch(...)
        {
            hr = E_INVALIDARG;
        }

        if (S_OK != hr)
        {
            return hr;
        }
            

        if (NULL != pceltFetched)
        {
            try
            {
                *pceltFetched = dwCount;
            }
            catch(...)
            {
                hr = E_INVALIDARG;
            }
        }

        if (S_OK != hr)
        {
            return hr;
        }

        // indicate that we've reached the end
        // of the enumeration.
        if (dwCount < celt)
        {
            return S_FALSE;
        }

        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE Skip(
                                   ULONG celt
                                  )
    {
        long        lCount = 0;
        
        while ( (lCount < celt) && (m_iter != m_list.end()) )
        {
            m_iter++;
            lCount++;
        }

        // check to see if we reached the end
        if (lCount != celt)
        {
            return S_OK;
        }
        
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE Reset(void)
    {
        m_iter = m_list.begin();
        
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE Clone(
                                    IEnumTerminalClass ** ppEnum
                                   )
    {
        HRESULT         hr = S_OK;
        
        CComObject< CTerminalClassEnum > * pNewEnum;

        CComObject< CTerminalClassEnum >::CreateInstance(&pNewEnum);

        if (pNewEnum == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pNewEnum->Initialize( m_list );

            try
            {
                *ppEnum = pNewEnum;
            }
            catch(...)
            {
                hr = E_INVALIDARG;
            }
        }
        
        return hr;
    }
};



#endif // __ENUM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\objectwithsite.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ObjectWithSite.cpp

Abstract:

--*/



#include "stdafx.h"    
#include "ObjectWithSite.h"    


CComAutoCriticalSection CObjectWithSite::s_ObjectWithSiteCritSection;
CObjectWithSite::EnValidation CObjectWithSite::s_enValidation = CObjectWithSite::UNVALIDATED;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\phone.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    phone.h

Abstract:

    Declaration of the CPhone class
    
Notes:

Revision History:

--*/

#ifndef __PHONE_H_
#define __PHONE_H_

#include "resource.h"       // main symbols

#include "address.h"
#include "ObjectSafeImpl.h"

class CTAPI;

extern CHashTable             * gpPhoneHashTable;

/////////////////////////////////////////////////////////////////
// Intermediate classes  used for DISPID encoding
template <class T>
class  ITPhoneVtbl : public ITPhone
{
	DECLARE_TRACELOG_CLASS(ITPhoneVtbl)
};

template <class T>
class  ITAutomatedPhoneControlVtbl : public ITAutomatedPhoneControl
{
	DECLARE_TRACELOG_CLASS(ITAutomatedPhoneControlVtbl)
};

/////////////////////////////////////////////////////////////////
// Constants defining default values for certain properties.

const DWORD APC_DEFAULT_AEONT = 3000;
const DWORD APC_DEFAULT_AKTMD = 100;
const DWORD APC_DEFAULT_VCS = 4096;
const DWORD APC_DEFAULT_VCRD = 500;
const DWORD APC_DEFAULT_VCRP = 100;

const DWORD APC_MAX_NUMBERS_GATHERED = 100;

/////////////////////////////////////////////////////////////////
// Types

typedef enum AUTOMATED_PHONE_STATE
{
    APS_ONHOOK_IDLE,
    APS_OFFHOOK_DIALTONE,
    APS_OFFHOOK_WARNING,
    APS_ONHOOK_RINGING_IN,
    APS_OFFHOOK_DIALING,
    APS_OFFHOOK_DEAD_LINE,
    APS_OFFHOOK_CALL_INIT,
    APS_OFFHOOK_CONNECTED,
    APS_ONHOOK_CONNECTED,
    APS_OFFHOOK_BUSY_TONE,
    APS_OFFHOOK_RINGING_OUT,
    APS_ONHOOK_RINGING_OUT
} AUTOMATED_PHONE_STATE;

/////////////////////////////////////////////////////////////////////////////
// CPhone
class CPhone : 
	public CTAPIComObjectRoot<CPhone>,
    public IDispatchImpl<ITPhoneVtbl<CPhone>, &IID_ITPhone, &LIBID_TAPI3Lib>,
    public IDispatchImpl<ITAutomatedPhoneControlVtbl<CPhone>,
                         &IID_ITAutomatedPhoneControl, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
public:

	CPhone() : m_pTAPI(NULL),
               m_hPhoneApp(NULL),
               m_dwAPIVersion(0),
               m_dwDeviceID(0),
               m_hPhone(NULL),
               m_dwPrivilege(0),
               m_pPhoneCaps(NULL),
               m_pdwLineDeviceIDs(NULL),
               m_dwNumLineDeviceIDs(0),
               m_Tone(PT_SILENCE),
               m_fRinger(FALSE),
               m_fPhoneHandlingEnabled(FALSE),
               m_dwAutoEndOfNumberTimeout(APC_DEFAULT_AEONT),
               m_fAutoDialtone(TRUE),
               m_fAutoStopTonesOnOnHook(TRUE),
               m_fAutoStopRingOnOffHook(TRUE),
               m_fAutoKeypadTones(TRUE),
               m_dwAutoKeypadTonesMinimumDuration(APC_DEFAULT_AKTMD),
               m_pCall(NULL),
               m_hTimerQueue(NULL),
               m_hTimerEvent(NULL),
               m_hToneTimer(NULL),
               m_hDTMFTimer(NULL),
               m_hRingTimer(NULL),
               m_hVolumeTimer(NULL),
               m_hAutoEndOfNumberTimer(NULL),
               m_fUseWaveForRinger(FALSE),
               m_wszNumbersGathered(NULL),
               m_AutomatedPhoneState(APS_ONHOOK_IDLE),
               m_fAutoVolumeControl(TRUE),
               m_dwAutoVolumeControlStep(APC_DEFAULT_VCS),
               m_dwAutoVolumeControlRepeatDelay(APC_DEFAULT_VCRD),
               m_dwAutoVolumeControlRepeatPeriod(APC_DEFAULT_VCRP),
               m_dwOffHookCount(0),
               m_fInitialized(FALSE)
    {
        LOG((TL_TRACE, "CPhone[%p] - enter", this ));
        LOG((TL_TRACE, "CPhone - finished" ));
    }

    ~CPhone()
    {
        LOG((TL_TRACE, "~CPhone[%p] - enter", this ));
        LOG((TL_TRACE, "~CPhone - finished" ));
    }


DECLARE_DEBUG_ADDREF_RELEASE(CPhone)
DECLARE_QI()
DECLARE_MARSHALQI(CPhone)
DECLARE_TRACELOG_CLASS(CPhone)

BEGIN_COM_MAP(CPhone)
	COM_INTERFACE_ENTRY2(IDispatch, ITPhone)
    COM_INTERFACE_ENTRY(ITPhone)
    // ITAutomatedPhoneControlQI will fall thru on SUCCESS, so we need to keep COM_INTERFACE_ENTRY(ITAutomatedPhoneControl)
    COM_INTERFACE_ENTRY_FUNC(IID_ITAutomatedPhoneControl, 0, CPhone::ITAutomatedPhoneControlQI)
    COM_INTERFACE_ENTRY(ITAutomatedPhoneControl)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

    void FinalRelease();    

private:
    ITTAPI      * m_pTAPI;
    HPHONEAPP     m_hPhoneApp;
    DWORD         m_dwAPIVersion;
    DWORD         m_dwDeviceID;
    HPHONE        m_hPhone;
    DWORD         m_dwPrivilege;
    LPPHONECAPS   m_pPhoneCaps;
    DWORD       * m_pdwLineDeviceIDs;
    DWORD         m_dwNumLineDeviceIDs;
    BOOL          m_fInitialized;

    // AutomatedPhoneControl Variables
    CWavePlayer   m_WavePlayer;
    BOOL          m_fUseWaveForRinger;    
    BOOL          m_fRinger;
    BOOL          m_fPhoneHandlingEnabled;
    DWORD         m_dwAutoEndOfNumberTimeout;
    BOOL          m_fAutoDialtone;
    BOOL          m_fAutoStopTonesOnOnHook;
    BOOL          m_fAutoStopRingOnOffHook;
    BOOL          m_fAutoKeypadTones;    
    DWORD         m_dwAutoKeypadTonesMinimumDuration;
    BOOL          m_fAutoVolumeControl;
    DWORD         m_dwAutoVolumeControlStep;
    DWORD         m_dwAutoVolumeControlRepeatDelay;
    DWORD         m_dwAutoVolumeControlRepeatPeriod;
    DWORD         m_dwOffHookCount;
    ITCallInfo  * m_pCall;
    LPWSTR        m_wszNumbersGathered;  
    PHONE_TONE    m_Tone;
    DWORD         m_dwToneDuration;
    DWORD         m_dwTonePeriodOn;
    DWORD         m_dwTonePeriodOff;    
    PHONE_TONE    m_DTMF;
    DWORD         m_dwDTMFStart;
    DWORD         m_dwRingDuration;
    DWORD         m_dwRingPeriod;
    BOOL          m_fVolumeUp;
    AUTOMATED_PHONE_STATE m_AutomatedPhoneState;
    BOOL          m_fDefaultTerminalsSelected;

    // Timer Handles
    HANDLE        m_hTimerQueue;
    HANDLE        m_hTimerEvent;
    HANDLE        m_hToneTimer;
    HANDLE        m_hDTMFTimer;
    HANDLE        m_hRingTimer;
    HANDLE        m_hVolumeTimer;
    HANDLE        m_hAutoEndOfNumberTimer;

    // Critical Sections
    CRITICAL_SECTION m_csAutomatedPhoneState;
    CRITICAL_SECTION m_csToneTimer;
    CRITICAL_SECTION m_csRingTimer;

public:

    static HRESULT WINAPI ITAutomatedPhoneControlQI(void* pv, REFIID riid, LPVOID* ppv, DWORD_PTR dw);

    DWORD GetDeviceID(){ return m_dwDeviceID; }
    DWORD GetAPIVersion(){ return m_dwAPIVersion; }
    HPHONEAPP GetHPhoneApp(){ return m_hPhoneApp; }

    HRESULT Initialize(
                       ITTAPI * pTAPI,
                       HPHONEAPP hPhoneApp,
                       DWORD dwAPIVersion,
                       DWORD dwDeviceID
                      );

    void SetPhoneCapBuffer( LPVOID pBuf );

    HRESULT UpdatePhoneCaps();
    HRESULT InvalidatePhoneCaps();

    BOOL IsPhoneOnAddress(ITAddress * pAddress);
    BOOL IsPhoneOnPreferredAddress(ITAddress *pAddress);
    BOOL IsPhoneUsingWaveID(DWORD dwWaveID, TERMINAL_DIRECTION nDir);

    CTAPI * GetTapi();

    void ForceClose();

    void Automation_CallState( ITCallInfo * pCall, CALL_STATE cs, CALL_STATE_EVENT_CAUSE cause );
    void Automation_ButtonDown( DWORD dwButtonId );
    void Automation_ButtonUp( DWORD dwButtonId );
    void Automation_OnHook( PHONE_HOOK_SWITCH_DEVICE phsd );
    void Automation_OffHook( PHONE_HOOK_SWITCH_DEVICE phsd );
    void Automation_EndOfNumberTimeout();

    //
    // IDispatch
    //

    STDMETHOD(GetIDsOfNames)(REFIID riid, 
                             LPOLESTR* rgszNames,
                             UINT cNames, 
                             LCID lcid, 
                             DISPID* rgdispid
                            );

    STDMETHOD(Invoke)(DISPID dispidMember, 
                      REFIID riid, 
                      LCID lcid,
                      WORD wFlags, 
                      DISPPARAMS* pdispparams, 
                      VARIANT* pvarResult,
                      EXCEPINFO* pexcepinfo, 
                      UINT* puArgErr
                      );

    STDMETHOD_(ULONG, InternalAddRef)();

    STDMETHOD_(ULONG, InternalRelease)();

    //
    // ITPhone
    //

    STDMETHOD(Open)(
            IN   PHONE_PRIVILEGE Privilege
            );
            
    STDMETHOD(Close)();
    
    STDMETHOD(get_Addresses)(
            OUT  VARIANT * pAddresses
            );

    STDMETHOD(EnumerateAddresses)(
            OUT  IEnumAddress ** ppEnumAddress
            );

    STDMETHOD(get_PreferredAddresses)(
            OUT  VARIANT * pAddresses
            );

    STDMETHOD(EnumeratePreferredAddresses)(
            OUT  IEnumAddress ** ppEnumAddress
            );

    STDMETHOD(get_PhoneCapsLong)(
            IN   PHONECAPS_LONG   pclCap,
            OUT  long           * plCapability
            );

    STDMETHOD(get_PhoneCapsString)(
            IN   PHONECAPS_STRING   pcsCap,
            OUT  BSTR             * ppCapability
            );

    STDMETHOD(GetPhoneCapsBuffer)(
            IN PHONECAPS_BUFFER pcbCaps,
            OUT DWORD *pdwSize,
            OUT BYTE **ppPhoneCapsBuffer
            );

    STDMETHOD(get_PhoneCapsBuffer)(
            IN PHONECAPS_BUFFER pcbCaps,
            OUT VARIANT *pVarBuffer
            );

    STDMETHOD(get_Terminals)(
            IN   ITAddress * pAddress,
            OUT  VARIANT   * pTerminals
            );

    STDMETHOD(EnumerateTerminals)(
            IN   ITAddress      * pAddress,
            OUT  IEnumTerminal ** ppEnumTerminal
            );

    STDMETHOD(get_ButtonMode)(
            IN   long                lButtonID,
            OUT  PHONE_BUTTON_MODE * pButtonMode
            );

    STDMETHOD(put_ButtonMode)(
            IN   long                lButtonID,
            IN   PHONE_BUTTON_MODE   ButtonMode
            );


    STDMETHOD(get_LampMode)(
            IN long lLampID,
            OUT PHONE_LAMP_MODE* pLampMode
            );

    STDMETHOD(put_LampMode)(
            IN long lLampID,
            IN PHONE_LAMP_MODE pLampMode
            );

    STDMETHOD(get_ButtonFunction)(
            IN   long                    lButtonID,
            OUT  PHONE_BUTTON_FUNCTION * pButtonFunction
            );

    STDMETHOD(put_ButtonFunction)(
            IN long                  lButtonID, 
            IN PHONE_BUTTON_FUNCTION ButtonFunction
            );

    STDMETHOD(get_ButtonText)(
            IN   long   lButtonID, 
            OUT  BSTR * ppButtonText
            );

    STDMETHOD(put_ButtonText)(
            IN   long   lButtonID, 
            IN   BSTR   bstrButtonText
            );

    STDMETHOD(get_ButtonState)(
            IN   long                 lButtonID,
            OUT  PHONE_BUTTON_STATE * pButtonState
            );

    STDMETHOD(get_HookSwitchState)(
            IN   PHONE_HOOK_SWITCH_DEVICE   HookSwitchDevice,
            OUT  PHONE_HOOK_SWITCH_STATE  * pHookSwitchState
            );

    STDMETHOD(put_HookSwitchState)(
            IN   PHONE_HOOK_SWITCH_DEVICE HookSwitchDevice,
            OUT  PHONE_HOOK_SWITCH_STATE  HookSwitchState
            );

    STDMETHOD(put_RingMode)(
            IN   long lRingMode
            );

    STDMETHOD(get_RingMode)(
            OUT  long * plRingMode
            );

    STDMETHOD(put_RingVolume)(
            IN   long lRingVolume
            );

    STDMETHOD(get_RingVolume)(
            OUT  long * plRingVolume
            );

    STDMETHOD(get_Privilege)(
            OUT  PHONE_PRIVILEGE * pPrivilege
            );

    STDMETHOD(get_Display)(
            BSTR *pbstrDisplay
            );

    
    //
    // put display string at a specified location
    //

    STDMETHOD(SetDisplay)(
            IN long lRow,
            IN long lColumn,
            IN BSTR bstrDisplay
            );

    STDMETHOD(DeviceSpecific)(
	         IN BYTE *pParams,
	         IN DWORD dwSize
            );

    STDMETHOD(DeviceSpecificVariant)(
	         IN VARIANT varDevSpecificByteArray
            );

    STDMETHOD(NegotiateExtVersion)(
	         IN long lLowVersion,
	         IN long lHighVersion,
	         IN long *plExtVersion
            );

    //
    // ITAutomatedPhoneControl
    //

public:
    STDMETHOD (StartTone)(
            IN   PHONE_TONE Tone,
            IN   long       lDuration
            );

    STDMETHOD (StopTone)();

    STDMETHOD (get_Tone)(
            OUT   PHONE_TONE * pTone
            );

    STDMETHOD (StartRinger)(
            IN    long lRingMode,
            IN    long lDuration
            );

    STDMETHOD (StopRinger)();

    STDMETHOD (get_Ringer)(
            OUT   VARIANT_BOOL * pfRinging
            );

    STDMETHOD (put_PhoneHandlingEnabled)(
            IN    VARIANT_BOOL fEnabled
            );

    STDMETHOD (get_PhoneHandlingEnabled)(
            OUT   VARIANT_BOOL * pfEnabled
            );

    STDMETHOD (put_AutoEndOfNumberTimeout)(
            IN    long lTimeout
            );

    STDMETHOD (get_AutoEndOfNumberTimeout)(
            OUT   long * plTimeout
            );

    STDMETHOD (put_AutoDialtone)(
            IN    VARIANT_BOOL fEnabled
            );

    STDMETHOD (get_AutoDialtone)(
            OUT   VARIANT_BOOL * pfEnabled
            );

    STDMETHOD (put_AutoStopTonesOnOnHook)(
            IN    VARIANT_BOOL fEnabled
            );

    STDMETHOD (get_AutoStopTonesOnOnHook)(
            OUT   VARIANT_BOOL * pfEnabled
            );

    STDMETHOD (put_AutoStopRingOnOffHook)(
            IN    VARIANT_BOOL fEnabled
            );

    STDMETHOD (get_AutoStopRingOnOffHook)(
            OUT   VARIANT_BOOL * pfEnabled
            );

    STDMETHOD (put_AutoKeypadTones)(
            IN    VARIANT_BOOL fEnabled
            );

    STDMETHOD (get_AutoKeypadTones)(
            OUT   VARIANT_BOOL * pfEnabled
            );

    STDMETHOD (put_AutoKeypadTonesMinimumDuration)(
            IN    long lDuration
            );

    STDMETHOD (get_AutoKeypadTonesMinimumDuration)(
            OUT   long * plDuration
            );

    STDMETHOD (put_AutoVolumeControl)(
            IN    VARIANT_BOOL fEnabled
            );

    STDMETHOD (get_AutoVolumeControl)(
            OUT   VARIANT_BOOL * pfEnabled
            );

    STDMETHOD (put_AutoVolumeControlStep)(
            IN    long lStepSize
            );

    STDMETHOD (get_AutoVolumeControlStep)(
            OUT   long * plStepSize
            );

    STDMETHOD (put_AutoVolumeControlRepeatDelay)(
            IN    long lDelay
            );

    STDMETHOD (get_AutoVolumeControlRepeatDelay)(
            OUT   long * plDelay
            );

    STDMETHOD (put_AutoVolumeControlRepeatPeriod)(
            IN    long lPeriod
            );

    STDMETHOD (get_AutoVolumeControlRepeatPeriod)(
            OUT   long * plPeriod
            );

    STDMETHOD (SelectCall)(
            IN    ITCallInfo   * pCall,
            IN    VARIANT_BOOL   fSelectDefaultTerminals
            );

    STDMETHOD (UnselectCall)(
            IN    ITCallInfo * pCall
            );

    STDMETHOD (EnumerateSelectedCalls)(
            OUT   IEnumCall ** ppCallEnum
            );

    STDMETHOD (get_SelectedCalls)(
            OUT   VARIANT * pVariant
            );

    // Private helper methods for ITAutomatedPhoneControl implementation
private:
    void UnselectAllPreviouslySelectedTerminals(
            IN   ITBasicCallControl2 * pCall,
            IN   ITTerminal          * pTerminalThatFailed,
            IN   IEnumTerminal       * pEnum
            );

    HRESULT InternalUnselectCall(
            IN    ITCallInfo * pCall
            );

    HRESULT SelectDefaultTerminalsOnCall(
            IN   ITCallInfo * pCall
            );

    HRESULT UnselectDefaultTerminalsOnCall(
            IN   ITCallInfo * pCall
            );

    HRESULT GetPhoneWaveRenderID(
            IN   DWORD * pdwWaveID
            );

    void OpenWaveDevice(
            );

    void CloseWaveDevice(
            );   

    static VOID CALLBACK ToneTimerCallback(
      PVOID lpParameter,    
      BOOLEAN TimerOrWaitFired
    );

    static VOID CALLBACK DTMFTimerCallback(
      PVOID lpParameter,    
      BOOLEAN TimerOrWaitFired
    );

    static VOID CALLBACK RingTimerCallback(
      PVOID lpParameter,    
      BOOLEAN TimerOrWaitFired
    );

    static VOID CALLBACK VolumeTimerCallback(
      PVOID lpParameter,    
      BOOLEAN TimerOrWaitFired
    );

    static VOID CALLBACK AutoEndOfNumberTimerCallback(
      PVOID lpParameter,    
      BOOLEAN TimerOrWaitFired
    );
};

class CPhoneEvent : 
    public CTAPIComObjectRoot<CPhoneEvent, CComMultiThreadModelNoCS>, // no need to have a cs
    public CComDualImpl<ITPhoneEvent, &IID_ITPhoneEvent, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
public:

DECLARE_MARSHALQI(CPhoneEvent)
DECLARE_TRACELOG_CLASS(CPhoneEvent)

BEGIN_COM_MAP(CPhoneEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITPhoneEvent)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

    static HRESULT FireEvent(
                             CPhone * pCPhone,
                             PHONE_EVENT Event,
                             PHONE_BUTTON_STATE ButtonState,
                             PHONE_HOOK_SWITCH_STATE HookSwitchState,
                             PHONE_HOOK_SWITCH_DEVICE HookSwitchDevice,
                             DWORD dwRingMode,
                             DWORD dwButtonLampId,
                             PWSTR pNumber,
                             ITCallInfo * pCallInfo
                            );
    void FinalRelease();
                      
protected:
    ITPhone                 * m_pPhone;
    PHONE_EVENT               m_Event;
    PHONE_BUTTON_STATE        m_ButtonState;
    PHONE_HOOK_SWITCH_STATE   m_HookSwitchState;
    PHONE_HOOK_SWITCH_DEVICE  m_HookSwitchDevice;
    DWORD                     m_dwRingMode;
    DWORD                     m_dwButtonLampId;
    BSTR                      m_pNumber;
    ITCallInfo              * m_pCallInfo;

#if DBG
    PWSTR                     m_pDebug;
#endif

    
public:
    STDMETHOD(get_Phone)( ITPhone ** ppPhone );
    STDMETHOD(get_Event)( PHONE_EVENT * pEvent );
    STDMETHOD(get_ButtonState)( PHONE_BUTTON_STATE * pState );
    STDMETHOD(get_HookSwitchState)( PHONE_HOOK_SWITCH_STATE * pState );
    STDMETHOD(get_HookSwitchDevice)( PHONE_HOOK_SWITCH_DEVICE * pDevice );
    STDMETHOD(get_RingMode)( long * plRingMode );
    STDMETHOD(get_ButtonLampId)( LONG * plButtonLampId );
    STDMETHOD(get_NumberGathered)( BSTR * ppNumber );
    STDMETHOD(get_Call)( ITCallInfo ** ppCallInfo );
};
            
class CPhoneDevSpecificEvent : 
    public CTAPIComObjectRoot<CPhoneDevSpecificEvent, CComMultiThreadModelNoCS>, // no need to have a cs
    public CComDualImpl<ITPhoneDeviceSpecificEvent, &IID_ITPhoneDeviceSpecificEvent, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
public:

DECLARE_MARSHALQI(CPhoneDevSpecificEvent)
DECLARE_TRACELOG_CLASS(CPhoneDevSpecificEvent)

BEGIN_COM_MAP(CPhoneDevSpecificEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITPhoneDeviceSpecificEvent)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

    static HRESULT FireEvent(
                             CPhone *pPhone,
                             long lParam1,
                             long lParam2,
                             long lParam3
                            );
    void FinalRelease();
                      
    CPhoneDevSpecificEvent();

protected:




    //
    // phone for which the event was fired
    //

    ITPhone *m_pPhone;

    
    //
    // data received from the TSP
    //

    long m_l1;
    long m_l2;
    long m_l3;


#if DBG
    PWSTR           m_pDebug;
#endif

    
public:

    STDMETHOD(get_Phone)( ITPhone **ppPhone );
    STDMETHOD(get_lParam1)( long *plParam1 );
    STDMETHOD(get_lParam2)( long *plParam2 );
    STDMETHOD(get_lParam3)( long *plParam3 );
    
};


#endif //__PHONE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\phonemsp.cpp ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    phonemsp.cpp

Abstract:

    Implements an MSP object for addresses that have phone terminals
    this makes the MSP abstraction in the address object much easier,
    since there will be no special cases for phone devices/terminals
    
Author:

    mquinton - 9/24/98

Notes:


Revision History:

--*/

#include "stdafx.h"

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CPhoneMSP::Initialize
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CPhoneMSP::Initialize(
        MSP_HANDLE hEvent
        )
{
    HRESULT             hr = S_OK;

    LOG((TL_TRACE, "Initialize - enter"));

    Lock();

    m_hEvent = (HANDLE)hEvent;

    #if DBG
    m_pDebug = (PWSTR) ClientAlloc( 1 );
    #endif

    
    Unlock();
    
    LOG((TL_TRACE, "Initialize - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CPhoneMSP::Shutdown
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CPhoneMSP::Shutdown()
{
    HRESULT             hr = E_NOTIMPL;

    LOG((TL_TRACE, "Shutdown - enter"));

    LOG((TL_TRACE, "Shutdown - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CPhoneMSP::CreateMSPCall
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CPhoneMSP::CreateMSPCall(
        MSP_HANDLE hCall,
        DWORD dwReserved,
        DWORD dwMediaType,
        IUnknown * pOuterUnknown,
        IUnknown ** ppStreamControl
        )
{
    HRESULT                         hr;
    CComAggObject<CPhoneMSPCall>  * pPhoneMSPCall;
    ITPhoneMSPCallPrivate         * pPhoneMSPCallPrivate;
    
    LOG((TL_TRACE, "CreateMSPCall - enter"));

    pPhoneMSPCall = new CComAggObject<CPhoneMSPCall>(pOuterUnknown);

    if ( NULL == pPhoneMSPCall )
    {
    }

    //
    // save the aggregated interface in
    // the msppointer
    //
    pPhoneMSPCall->QueryInterface(
                                  IID_IUnknown,
                                  (void **)ppStreamControl
                                 );

    //
    // get to the real object
    //
    hr = (*ppStreamControl)->QueryInterface(
                                            IID_ITPhoneMSPCallPrivate,
                                            (void **)&pPhoneMSPCallPrivate
                                           );
    
    
    //
    // initialize it
    //
    hr = pPhoneMSPCallPrivate->Initialize( this );

    Lock();

    AddCall( *ppStreamControl );
    
    Unlock();
    
    pPhoneMSPCallPrivate->Release();

    LOG((TL_TRACE, "CreateMSPCall - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CPhoneMSP::ShutdownMSPCall
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CPhoneMSP::ShutdownMSPCall(
        IUnknown * pStreamControl
        )
{
    HRESULT             hr = S_OK;

    LOG((TL_TRACE, "ShutdownMSPCall - enter"));

    Lock();

    RemoveCall( pStreamControl );

    Unlock();
    
    LOG((TL_TRACE, "ShutdownMSPCall - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CPhoneMSP::ReceiveTSPData
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CPhoneMSP::ReceiveTSPData(
        IUnknown * pMSPCall,
        BYTE * pBuffer,
        DWORD dwSize
        )
{
    HRESULT                     hr = S_OK;
    DWORD                       dwCommand;
    ITPhoneMSPCallPrivate     * pCall;

    LOG((TL_TRACE, "ReceiveTSPData - enter"));

    if ( NULL == pMSPCall )
    {
        LOG((TL_ERROR, "ReceiveTSPData - null call"));

        return E_INVALIDARG;
    }
    
    dwCommand = *((LPDWORD)(pBuffer));

    hr = pMSPCall->QueryInterface(
                                  IID_ITPhoneMSPCallPrivate,
                                  (void**)&pCall
                                 );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "ReceiveTSPData - bad call"));

        return E_FAIL;
    }

    LOG((TL_INFO, "ReceiveTSPData - command %d", dwCommand));
    
    switch (dwCommand)
    {
        case 1: // Start Streaming
            
            hr = pCall->OnConnect();
            break;
            
        case 2: // Stop Streaming
            
            hr = pCall->OnDisconnect();
            break;
            
        default:
            
            LOG((TL_ERROR, "ReceiveTSPData - invalid command "));
            hr = E_FAIL;
            break;
    }

    pCall->Release();
    
    LOG((TL_TRACE, "ReceiveTSPData - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CPhoneMSP::GetEvent
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CPhoneMSP::GetEvent(
        DWORD * pdwSize,
        byte * pEventBuffer
        )
{
    HRESULT             hr = E_NOTIMPL;

    LOG((TL_TRACE, "GetEvent - enter"));

    LOG((TL_TRACE, "GetEvent - exit - return %lx", hr));
    
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CPhoneMSP::InitializeTerminals(
        HPHONEAPP hPhoneApp,
        DWORD dwAPIVersion,
        DWORD dwPhoneDevice,
        CAddress * pAddress
        )
{
    LPPHONECAPS          pPhoneCaps = NULL;
    HRESULT              hr;
    BOOL                 bSucceeded = FALSE;
    ITStream           * pStream;
    
    
    LOG((TL_TRACE, "InitializeTerminals - enter"));

    //
    // get the phone caps
    //
    hr = PhoneGetDevCapsWithAlloc(
                         hPhoneApp,
                         dwPhoneDevice,
                         dwAPIVersion,
                         &pPhoneCaps
                        );

    if (S_OK != hr)
    {
        if (NULL != pPhoneCaps)
        {
            ClientFree( pPhoneCaps );
        }

        LOG((TL_ERROR, "CreatePhoneTerminals - PhoneGetDevCaps failed - %lx", hr ));

        return hr;
    }


    //
    // check the hook switch devs
    //
    if (0 == pPhoneCaps->dwHookSwitchDevs)
    {
        LOG((TL_ERROR, "CreatePhoneTerminal - no hook switch devs!" ));

        ClientFree( pPhoneCaps );
        
        return E_UNEXPECTED;
    }


    //
    // create terminal devices for each hook switch dev
    // need to create an audio in and audio out terminal
    // for each
    //
    ITTerminal * pTerminal;

    
    if (pPhoneCaps->dwHookSwitchDevs & PHONEHOOKSWITCHDEV_HANDSET)
    {
        hr = CTerminal::Create(
                               hPhoneApp,
                               dwPhoneDevice,
                               pPhoneCaps,
                               PHONEHOOKSWITCHDEV_HANDSET,
                               TD_RENDER,
                               dwAPIVersion,
                               &pTerminal
                              );

        if (SUCCEEDED(hr))
        {
            bSucceeded = TRUE;
            
            AddTerminal( pTerminal );

            pTerminal->Release();
        }

        hr = CTerminal::Create(
                               hPhoneApp,
                               dwPhoneDevice,
                               pPhoneCaps,
                               PHONEHOOKSWITCHDEV_HANDSET,
                               TD_CAPTURE,
                               dwAPIVersion,
                               &pTerminal
                              );

        if (SUCCEEDED(hr))
        {
            bSucceeded = TRUE;
            
            AddTerminal( pTerminal );

            pTerminal->Release();
        }
    }

    if (pPhoneCaps->dwHookSwitchDevs & PHONEHOOKSWITCHDEV_HEADSET)
    {
        hr = CTerminal::Create(
                               hPhoneApp,
                               dwPhoneDevice,
                               pPhoneCaps,
                               PHONEHOOKSWITCHDEV_HEADSET,
                               TD_RENDER,
                               dwAPIVersion,
                               &pTerminal
                              );

        if (SUCCEEDED(hr))
        {
            bSucceeded = TRUE;
            
            AddTerminal( pTerminal );

            pTerminal->Release();
        }
        
        hr = CTerminal::Create(
                               hPhoneApp,
                               dwPhoneDevice,
                               pPhoneCaps,
                               PHONEHOOKSWITCHDEV_HEADSET,
                               TD_CAPTURE,
                               dwAPIVersion,
                               &pTerminal
                              );

        if (SUCCEEDED(hr))
        {
            bSucceeded = TRUE;
            
            AddTerminal( pTerminal );

            pTerminal->Release();
        }
    }

    if (pPhoneCaps->dwHookSwitchDevs & PHONEHOOKSWITCHDEV_SPEAKER)
    {
        hr = CTerminal::Create(
                               hPhoneApp,
                               dwPhoneDevice,
                               pPhoneCaps,
                               PHONEHOOKSWITCHDEV_SPEAKER,
                               TD_RENDER,
                               dwAPIVersion,
                               &pTerminal
                              );

        if (SUCCEEDED(hr))
        {
            bSucceeded = TRUE;
            
            AddTerminal( pTerminal );

            pTerminal->Release();
        }

        hr = CTerminal::Create(
                               hPhoneApp,
                               dwPhoneDevice,
                               pPhoneCaps,
                               PHONEHOOKSWITCHDEV_SPEAKER,
                               TD_CAPTURE,
                               dwAPIVersion,
                               &pTerminal
                              );

        if (SUCCEEDED(hr))
        {
            bSucceeded = TRUE;
            
            AddTerminal( pTerminal );

            pTerminal->Release();
        }

    }

    //
    // free memory
    //
    if (NULL != pPhoneCaps)
    {
        ClientFree( pPhoneCaps );
    }

    if ( !bSucceeded )
    {
        LOG((TL_WARN, "No phone terminals created"));

        return E_FAIL;
    }

    LOG((TL_TRACE, "InitializeTerminals - exit"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CPhoneMSP::VerifyTerminal( ITTerminal * pTerminal )
{
    int         iReturn;

    Lock();
    
    iReturn = m_TerminalArray.Find( pTerminal );

    Unlock();

    if ( -1 == iReturn )
    {
        return TAPI_E_INVALIDTERMINAL;
    }

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CPhoneMSP::AddTerminal( ITTerminal * pTerminal )
{
    Lock();
    
    m_TerminalArray.Add( pTerminal );
    
    Unlock();
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// called in lock
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CPhoneMSP::AddCall( IUnknown * pCall )
{
    m_CallArray.Add( pCall );
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// called in lock
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CPhoneMSP::RemoveCall( IUnknown * pCall )
{
    m_CallArray.Remove( pCall );
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CPhoneMSP::FinalRelease()
{
    LOG((TL_TRACE, "FinalRelease - enter"));

    #if DBG
        ClientFree( m_pDebug );
    #endif

    m_TerminalArray.Shutdown();
    m_CallArray.Shutdown();

    LOG((TL_TRACE, "FinalRelease - exit"));
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CPhoneMSP::get_StaticTerminals
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CPhoneMSP::get_StaticTerminals(
                               VARIANT * pVariant
                              )
{
    HRESULT             hr = S_OK;
    IDispatch         * pDisp;

    
    LOG((TL_TRACE, "get_StaticTerminals - enter"));

    if (TAPIIsBadWritePtr( pVariant, sizeof(VARIANT) ) )
    {
        LOG((TL_ERROR, "get_StaticTerminals - bad pointer"));

        return E_POINTER;
    }

    
    CComObject< CTapiCollection< ITTerminal > > * p;
    CComObject< CTapiCollection< ITTerminal > >::CreateInstance( &p );
    
    if (NULL == p)
    {
        LOG((TL_ERROR, "get_StaticTerminals - could not create collection" ));
        
        return E_OUTOFMEMORY;
    }

    Lock();
    
    // initialize
    hr = p->Initialize( m_TerminalArray );

    Unlock();

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "get_StaticTerminals - could not initialize collection" ));
        
        delete p;
        return hr;
    }

    //
    // get the IDispatch interface
    //
    hr = p->_InternalQueryInterface(
                                    IID_IDispatch,
                                    (void **) &pDisp
                                   );

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "get_StaticTerminals - could not get IDispatch interface" ));
        
        delete p;
        return hr;
    }

    //
    // put it in the variant
    //
    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDisp;
    

    LOG((
           TL_TRACE,
           "get_StaticTerminals - exit - return %lx",
           hr
          ));
    
    LOG((TL_TRACE, "get_StaticTerminals - exit"));
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CPhoneMSP::EnumerateStaticTerminals
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CPhoneMSP::EnumerateStaticTerminals(IEnumTerminal ** ppEnumTerminal)
{
    HRESULT             hr = S_OK;

    LOG((TL_TRACE, "EnumerateStaticTerminals - enter"));

    if (TAPIIsBadWritePtr(ppEnumTerminal, sizeof( IEnumTerminal * ) ) )
    {
        LOG((TL_ERROR, "EnumerateStaticTerminals - bad pointer"));

        return E_POINTER;
    }
    
    //
    // create the enumerator
    //
    CComObject< CTapiEnum< IEnumTerminal, ITTerminal, &IID_IEnumTerminal > > * p;
    hr = CComObject< CTapiEnum< IEnumTerminal, ITTerminal, &IID_IEnumTerminal > >
         ::CreateInstance( &p );

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "EnumerateStaticTerminals - could not create enum" ));
        
        return hr;
    }


    Lock();
    
    //
    // initialize it with our terminal array
    //
    p->Initialize( m_TerminalArray );

    Unlock();

    //
    // return it
    //
    *ppEnumTerminal = p;
    
    LOG((
           TL_TRACE,
           "EnumerateStaticTerminals - exit - return %lx",
           hr
          ));
    
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CPhoneMSP::get_DynamicTerminalClasses
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CPhoneMSP::get_DynamicTerminalClasses(VARIANT * pVariant)
{
    HRESULT                                  hr = S_OK;
    CComObject< CTerminalClassCollection > * p;
    IDispatch                              * pDisp = NULL;
    TerminalClassPtrList                     classlist;
    

    
    LOG((TL_TRACE, "get_DynamicTerminalClasses - enter"));

    if (TAPIIsBadWritePtr( pVariant, sizeof(VARIANT) ) )
    {
        LOG((TL_ERROR, "get_DynamicTerminalClasses - bad pointer"));

        return E_POINTER;
    }

    classlist.clear();
    
    //
    // create the object
    //
    CComObject< CTerminalClassCollection >::CreateInstance( &p );

    //
    // init it
    //
    hr = p->Initialize(  classlist );

    //
    // get the IDispatch interface
    //
    hr = p->_InternalQueryInterface( IID_IDispatch, (void **) &pDisp );

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "get_dynamicterminalclasses - could not get the IDispatch interface" ));
        
        delete p;
        return hr;
    }


    //
    // put it in the variant
    //
    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDisp;
    
    LOG((
           TL_TRACE,
           "get_DynamicTerminalClasses - exit - return %lx",
           hr
          ));
    
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CPhoneMSP::EnumerateDynamicTerminalClasses
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CPhoneMSP::EnumerateDynamicTerminalClasses(
      IEnumTerminalClass ** ppTerminalClassEnumerator
      )
{
    HRESULT                     hr = S_OK;
    TerminalClassPtrList        termlist;

    LOG((TL_TRACE, "EnumerateDynamicTerminalClasses - enter"));

    if (TAPIIsBadWritePtr( ppTerminalClassEnumerator, sizeof(IEnumTerminalClass *) ) )
    {
        LOG((TL_ERROR, "EnumerateDynamicTerminalClasses - bad pointer"));

        return E_POINTER;
    }

    termlist.clear();
    
    //
    // create the enumerator
    //
    CComObject< CTerminalClassEnum > * p;
    CComObject< CTerminalClassEnum >::CreateInstance( &p );

    if (NULL == p)
    {
        LOG((TL_TRACE, "_EnumDynTermClasses - create enum failed - return %lx", hr ));

        return hr;
    }

    //
    // init it
    //
    hr = p->Initialize( termlist );

    if (!SUCCEEDED( hr ))
    {
        LOG((TL_TRACE, "_EnumDynTermClasses - init enum failed - return %lx", hr ));

        delete p;

        return hr;
    }

    *ppTerminalClassEnumerator = p;
    
    LOG((
           TL_TRACE,
           "EnumerateDynamicTerminalClasses - exit - return %lx",
           hr
          ));
    
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CPhoneMSP::CreateTerminal
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CPhoneMSP::CreateTerminal(
                          BSTR TerminalClass,
                          long lMediaType,
                          TERMINAL_DIRECTION TerminalDirection,
                          ITTerminal ** ppTerminal
                         )
{
    HRESULT             hr = TAPI_E_NOTSUPPORTED;

    LOG((TL_TRACE, "CreateTerminal - enter"));

    LOG((
           TL_TRACE,
           "CreateTerminal - exit - return %lx",
           hr
          ));
    
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CPhoneMSP::GetDefaultStaticTerminal
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CPhoneMSP::GetDefaultStaticTerminal(
                                    long lMediaType,
                                    TERMINAL_DIRECTION Dir,
                                    ITTerminal ** ppTerminal
                                   )
{
    HRESULT             hr = S_OK;
    int                 iSize, iCount;

    
    LOG((TL_TRACE, "GetDefaultStaticTerminal - enter"));

    if ( TAPIIsBadWritePtr( ppTerminal, sizeof (ITTerminal *) ) )
    {
        LOG((TL_TRACE, "GetDefaultStaticTerminal - bad pointer"));

        return E_POINTER;
    }

    Lock();

    iSize = m_TerminalArray.GetSize();
    
    for ( iCount = 0; iCount < iSize; iCount++ )
    {
        TERMINAL_DIRECTION          td;
        long                        lTermMediaType;

        hr = m_TerminalArray[iCount]->get_Direction( &td );

        if ( SUCCEEDED(hr) )
        {
            hr = m_TerminalArray[iCount]->get_MediaType( &lTermMediaType );

            if ( SUCCEEDED(hr) )
            {
                if ( ( td == Dir ) &&
                     ( lTermMediaType == lMediaType ) )
                {
                    *ppTerminal = m_TerminalArray[iCount];
                    (*ppTerminal)->AddRef();

                    Unlock();

                    LOG((
                           TL_TRACE,
                           "GetDefaultStaticTerminal - exit - return S_OK"
                          ));
                    
                    return S_OK;
                }
            }
        }
    }

    Unlock();

    hr = TAPI_E_INVALIDTERMINAL;
    
    LOG((
           TL_TRACE,
           "GetDefaultStaticTerminal - exit - return %lx",
           hr
          ));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CreateStream
//
// dwMediaType - mediatype of new stream
//
// td - direction of new stream
//
// ppStream - returned stream
//
// always fails - phone terminals don't handle this type of
// functionality
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CPhoneMSPCall::CreateStream(
        long dwMediaType,
        TERMINAL_DIRECTION td,
        ITStream ** ppStream
        )
{
    HRESULT             hr = TAPI_E_NOTSUPPORTED;

    LOG((TL_TRACE, "CreateStream - enter"));

    LOG((TL_TRACE, "CreateStream - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// RemoveStream
//
// pStream - stream to remove
//
// always fail - phone terminals don't handle this type of
// functionality.
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CPhoneMSPCall::RemoveStream(
        ITStream * pStream
        )
{
    HRESULT             hr = TAPI_E_NOTSUPPORTED;

    LOG((TL_TRACE, "RemoveStream - enter"));

    LOG((TL_TRACE, "RemoveStream - exit - return %lx", hr));
    
    return hr;
    
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// EnumerateStreams
//
// ppEnumStream - returned enumerator
//
// enumerates the streams available.  this should always be
// audio in and audio out
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CPhoneMSPCall::EnumerateStreams(
        IEnumStream ** ppEnumStream
        )
{
    HRESULT             hr = S_OK;

    LOG((TL_TRACE, "EnumerateStreams - enter"));

    if (TAPIIsBadWritePtr(ppEnumStream, sizeof( IEnumStream * ) ) )
    {
        LOG((TL_ERROR, "EnumerateStreams - bad pointer"));

        return E_POINTER;
    }
    
    //
    // create the enumerator
    //
    CComObject< CTapiEnum< IEnumStream, ITStream, &IID_IEnumStream > > * p;
    hr = CComObject< CTapiEnum< IEnumStream, ITStream, &IID_IEnumStream > >
         ::CreateInstance( &p );

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "EnumerateStreams - could not create enum" ));
        
        return hr;
    }


    Lock();
    
    //
    // initialize it with our Stream array
    //
    p->Initialize( m_StreamArray );

    Unlock();

    //
    // return it
    //
    *ppEnumStream = p;
    
    LOG((TL_TRACE, "EnumerateStreams - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// get_Streams
//
// pStreams - returned collection
//
// collection of streams - like enumeratestreams
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CPhoneMSPCall::get_Streams(
        VARIANT * pStreams
        )
{
    HRESULT             hr = S_OK;
    IDispatch         * pDisp;

    
    LOG((TL_TRACE, "get_Streams - enter"));

    if (TAPIIsBadWritePtr( pStreams, sizeof(VARIANT) ) )
    {
        LOG((TL_ERROR, "get_Streams - bad pointer"));

        return E_POINTER;
    }

    
    CComObject< CTapiCollection< ITStream > > * p;
    CComObject< CTapiCollection< ITStream > >::CreateInstance( &p );
    
    if (NULL == p)
    {
        LOG((TL_ERROR, "get_Streams - could not create collection" ));
        
        return E_OUTOFMEMORY;
    }

    Lock();
    
    // initialize
    hr = p->Initialize( m_StreamArray );

    Unlock();

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "get_Streams - could not initialize collection" ));
        
        delete p;
        return hr;
    }

    //
    // get the IDispatch interface
    //
    hr = p->_InternalQueryInterface(
                                    IID_IDispatch,
                                    (void **) &pDisp
                                   );

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "get_Streams - could not get IDispatch interface" ));
        
        delete p;
        return hr;
    }

    //
    // put it in the variant
    //
    VariantInit(pStreams);
    pStreams->vt = VT_DISPATCH;
    pStreams->pdispVal = pDisp;
    
    LOG((TL_TRACE, "get_Streams - exit - return %lx", hr));
    
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CPhoneMSPCall::Initialize(
                          CPhoneMSP * pPhoneMSP
                         )
{
    HRESULT                           hr;
    ITStream                        * pStream;
    ITPhoneMSPCallPrivate           * pCallPrivate;

    hr = QueryInterface(
                        IID_ITPhoneMSPCallPrivate,
                        (void**)&pCallPrivate
                       );
    
    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "Initialize - out of memory" ));
        return E_OUTOFMEMORY;
    }

    m_t3Phone.hPhone = NULL;
    m_t3Phone.pMSPCall = pCallPrivate;

    m_pPhoneMSP = pPhoneMSP;
    
    hr = CStream::InternalCreateStream(
                                       TAPIMEDIATYPE_AUDIO,
                                       TD_RENDER,
                                       pCallPrivate,
                                       &pStream
                                      );

    if ( !SUCCEEDED(hr) )
    {
        pCallPrivate->Release();

        LOG((TL_ERROR, "Initialize - out of memory" ));
        return E_OUTOFMEMORY;
    }
    
    AddStream( pStream );

    pStream->Release();
    
    hr = CStream::InternalCreateStream(
                                       TAPIMEDIATYPE_AUDIO,
                                       TD_CAPTURE,
                                       pCallPrivate,
                                       &pStream
                                      );
    
    if ( !SUCCEEDED(hr) )
    {
        pCallPrivate->Release();

        LOG((TL_ERROR, "Initialize - out of memory" ));
        return E_OUTOFMEMORY;
    }

    AddStream( pStream );

    pStream->Release();

    pCallPrivate->Release();
    
    return S_OK;
}   


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CPhoneMSPCall::FinalRelease()
{
    m_StreamArray.Shutdown();
    m_TerminalArray.Shutdown();
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CPhoneMSPCall::AddStream( ITStream * pStream )
{
    Lock();
    
    m_StreamArray.Add( pStream );
    
    Unlock();
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CPhoneMSPCall::AddTerminal( ITTerminalPrivate * pTerminal )
{
    Lock();

    m_TerminalArray.Add( pTerminal );

    pTerminal->SetMSPCall( this );

    if ( PHONEMSP_CONNECTED == m_State )
    {
    }

    Unlock();
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CPhoneMSPCall::RemoveTerminal( ITTerminalPrivate * pTerminal )
{
    BOOL        bRemoved;
    
    Lock();

    bRemoved = m_TerminalArray.Remove( pTerminal );

    if ( bRemoved && (PHONEMSP_DISCONNECTED == m_State) )
    {
        pTerminal->SetMSPCall( NULL );
    }

    Unlock();
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CPhoneMSPCall::OnConnect()
{
    HRESULT             hr = S_OK;
    int                 iSize, iCount;
    DWORD               dwHookSwitchDev = 0;
    HPHONEAPP           hPhoneApp = NULL;
    DWORD               dwPhoneID = 0;
    DWORD               dwAPIVersion;
    
    LOG((TL_TRACE, "OnConnect - enter"));

    Lock();

    m_State = PHONEMSP_CONNECTED;

    iSize = m_TerminalArray.GetSize();

    if ( 0 == iSize )
    {
        Unlock();
        
        return S_OK;
    }

    for ( iCount = 0; iCount < iSize; iCount++ )
    {
        DWORD           dwHoldHookSwitchDev;
        
        m_TerminalArray[iCount]->GetHookSwitchDev( &dwHoldHookSwitchDev );
        
        dwHookSwitchDev |= dwHoldHookSwitchDev;

    }

    m_TerminalArray[0]->GetHPhoneApp( &hPhoneApp );
    m_TerminalArray[0]->GetPhoneID( &dwPhoneID );
    m_TerminalArray[0]->GetAPIVersion( &dwAPIVersion );

    if (m_t3Phone.hPhone == NULL)
    {
        hr = PhoneOpen(
                       hPhoneApp,
                       dwPhoneID,
                       &m_t3Phone,
                       dwAPIVersion,
                       PHONEPRIVILEGE_OWNER
                      );

        if ( !SUCCEEDED(hr) )
        {
        }
    }
    
    ASYNCEVENTMSG   Msg;

    Msg.Msg = PRIVATE_PHONESETHOOKSWITCH;
    Msg.TotalSize = sizeof (ASYNCEVENTMSG);
    Msg.hDevice = (ULONG_PTR) this;
    Msg.Param1 = PHONEHOOKSWITCHMODE_MICSPEAKER;
    Msg.Param2 = dwHookSwitchDev;

    AddRef();

    QueueCallbackEvent( &Msg );
    
    Unlock();

    LOG((TL_TRACE,hr, "OnConnect - exit"));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CPhoneMSPCall::OnDisconnect()
{
    HRESULT             hr = S_OK;

    
    LOG((TL_TRACE, "OnDisconnect - enter"));

    Lock();

    if (m_t3Phone.hPhone != NULL)
    {
        hr = PhoneClose(m_t3Phone.hPhone);
        m_t3Phone.hPhone = NULL;

    }

    m_State = PHONEMSP_DISCONNECTED;

    Unlock();
    LOG((TL_TRACE,hr, "OnDisconnect - exit"));
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CPhoneMSPCall::SelectTerminal( ITTerminalPrivate * pTerminal )
{
    ITTerminal          * pITTerminal;
    HRESULT               hr;
    
    hr = pTerminal->QueryInterface(
                                   IID_ITTerminal,
                                   (void**) &pITTerminal
                                  );

    if ( SUCCEEDED(hr) )
    {

        hr = m_pPhoneMSP->VerifyTerminal( pITTerminal );

        pITTerminal->Release();

        if ( SUCCEEDED(hr) )
        {
            AddTerminal( pTerminal );
        }
    }
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CPhoneMSPCall::UnselectTerminal( ITTerminalPrivate * pTerminal )
{
    RemoveTerminal( pTerminal );
    
    return S_OK;
}

STDMETHODIMP
CPhoneMSPCall::GetGain(long *pVal, DWORD dwHookSwitch)
{
    HRESULT             hr;
    
    hr = PhoneGetGain(
                      m_t3Phone.hPhone,
                      dwHookSwitch,
                      (DWORD *)pVal
                     );
    
    if ( ((long)hr) > 0 )
    {
        hr = WaitForPhoneReply( hr );
    }


    return hr;
}

STDMETHODIMP
CPhoneMSPCall::PutGain(long newVal, DWORD dwHookSwitch)
{
    HRESULT             hr;
    
    hr = PhoneSetGain(
                      m_t3Phone.hPhone,
                      dwHookSwitch,
                      newVal
                     );
    
    if ( ((long)hr) > 0 )
    {
        hr = WaitForPhoneReply( hr );
    }


    return hr;
}

STDMETHODIMP
CPhoneMSPCall::GetVolume(long *pVal, DWORD dwHookSwitch)
{
    HRESULT             hr;
    
    hr = PhoneGetVolume(
                        m_t3Phone.hPhone,
                        dwHookSwitch,
                        (DWORD *)pVal
                       );
    
    if ( ((long)hr) > 0 )
    {
        hr = WaitForPhoneReply( hr );
    }


    return hr;
}

STDMETHODIMP
CPhoneMSPCall::PutVolume(long newVal, DWORD dwHookSwitch)
{
    HRESULT             hr;
    
    hr = PhoneSetVolume(
                        m_t3Phone.hPhone,
                        dwHookSwitch,
                        newVal
                       );
    
    if ( ((long)hr) > 0 )
    {
        hr = WaitForPhoneReply( hr );
    }


    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CPhoneMSPCall::HandlePrivateHookSwitch( PASYNCEVENTMSG pParams )
{
    CPhoneMSPCall               * pMSPCall;
    HRESULT                       hr;

    pMSPCall = (CPhoneMSPCall *)(pParams->hDevice);
    
    hr = PhoneSetHookSwitch(
                            pMSPCall->m_t3Phone.hPhone,
                            pParams->Param2,
                            pParams->Param1
                           );

    if ( SUCCEEDED(hr) )
    {
        hr = WaitForPhoneReply(hr);
    }

    pMSPCall->Release();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\phonemsp.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    phonemsp.h

Abstract:

    Declaration of the CPhoneMSP class
    
Author:

    mquinton  09-25-98
    
Notes:

Revision History:

--*/

#ifndef __PHONEMSP_H__
#define __PHONEMSP_H__

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CPhoneMSP
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
class CPhoneMSP : 
	public CTAPIComObjectRoot<CPhoneMSP>,
	public CComDualImpl<ITMSPAddress, &IID_ITMSPAddress, &LIBID_TAPI3Lib>,
	public CComDualImpl<ITTerminalSupport, &IID_ITTerminalSupport, &LIBID_TAPI3Lib>,
    public ITPhoneMSPAddressPrivate,
    public CObjectSafeImpl
{
public:
    
	CPhoneMSP()
    {}

    void FinalRelease();

DECLARE_MARSHALQI(CPhoneMSP)
DECLARE_AGGREGATABLE(CPhoneMSP)
DECLARE_QI()
DECLARE_TRACELOG_CLASS(CPhoneMSP)

BEGIN_COM_MAP(CPhoneMSP)
	COM_INTERFACE_ENTRY2(IDispatch, ITTerminalSupport)
    COM_INTERFACE_ENTRY(ITMSPAddress)
    COM_INTERFACE_ENTRY(ITTerminalSupport)
    COM_INTERFACE_ENTRY(ITPhoneMSPAddressPrivate)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

HRESULT InitializeTerminals(
        HPHONEAPP hPhoneApp,
        DWORD dwAPIVersion,
        DWORD dwPhoneDevice,
        CAddress * pAddress
        );

HRESULT VerifyTerminal( ITTerminal * pTerminal );

protected:

private:
    
    // TAPI terminals owned by this address
    TerminalArray       m_TerminalArray;
    UnknownArray        m_CallArray;

    HANDLE              m_hEvent;
    #if DBG
    PWSTR           	m_pDebug;
	#endif

    
    void AddTerminal( ITTerminal * pTerminal );
    void AddCall( IUnknown * pCall );
    void RemoveCall( IUnknown * pCall );
    

public:

    //
    // itmspaddress methods
    //
    STDMETHOD(Initialize)(
        MSP_HANDLE hEvent
        );
    STDMETHOD(Shutdown)();
    STDMETHOD(CreateMSPCall)(
        MSP_HANDLE hCall,
        DWORD dwReserved,
        DWORD dwMediaType,
        IUnknown * pOuterUnknown,
        IUnknown ** ppStreamControl
        );
    STDMETHOD(ShutdownMSPCall)(
        IUnknown * pStreamControl
        );

    STDMETHOD(ReceiveTSPData)(
        IUnknown * pMSPCall,
        BYTE * pBuffer,
        DWORD dwSize
        );

    STDMETHOD(GetEvent)(
        DWORD * pdwSize,
        byte * pEventBuffer
        );

    //
    //ITTerminalSupport methods
    //
    STDMETHOD(get_StaticTerminals)(VARIANT * pVariant);
    STDMETHOD(EnumerateStaticTerminals)(IEnumTerminal ** ppEnumTerminal);
    STDMETHOD(get_DynamicTerminalClasses)(VARIANT * pVariant);
    STDMETHOD(EnumerateDynamicTerminalClasses)(
        IEnumTerminalClass ** ppTerminalClassEnumerator);
    STDMETHOD(CreateTerminal)( 
        BSTR TerminalClass,
        long lMediaType,
        TERMINAL_DIRECTION TerminalDirection,
        ITTerminal ** ppTerminal
        );
    STDMETHOD(GetDefaultStaticTerminal)( 
        long lMediaType,
        TERMINAL_DIRECTION,
        ITTerminal ** ppTerminal
        );

};

typedef enum
{
    PHONEMSP_CONNECTED,
    PHONEMSP_DISCONNECTED
    
} PhoneMSPCallState;


class CPhoneMSPCall : 
	public CTAPIComObjectRoot<CPhoneMSPCall>,
	public CComDualImpl<ITStreamControl, &IID_ITStreamControl, &LIBID_TAPI3Lib>,
    public ITPhoneMSPCallPrivate,
    public CObjectSafeImpl
{
public:
    
	CPhoneMSPCall() : m_State(PHONEMSP_DISCONNECTED)
    {}

    void FinalRelease();

DECLARE_MARSHALQI(CPhoneMSPCall)
DECLARE_AGGREGATABLE(CPhoneMSPCall)
DECLARE_QI()
DECLARE_TRACELOG_CLASS(CPhoneMSPCall)

BEGIN_COM_MAP(CPhoneMSPCall)
	COM_INTERFACE_ENTRY2(IDispatch, ITStreamControl)
    COM_INTERFACE_ENTRY(ITStreamControl)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(ITPhoneMSPCallPrivate)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()


protected:

    StreamArray             m_StreamArray;
    TerminalPrivateArray    m_TerminalArray;
    PhoneMSPCallState       m_State;
    T3PHONE                 m_t3Phone;
    CPhoneMSP             * m_pPhoneMSP;
    
    void AddStream( ITStream * pStream );
    void AddTerminal( ITTerminalPrivate * pTerminal );
    void RemoveTerminal( ITTerminalPrivate * pTerminal );

public:

    void static HandlePrivateHookSwitch( PASYNCEVENTMSG pParams );

    STDMETHOD(CreateStream)(
        long lMediaType,
        TERMINAL_DIRECTION td,
        ITStream ** ppStream
        );
    STDMETHOD(RemoveStream)(ITStream * pStream);
    STDMETHOD(EnumerateStreams)(IEnumStream ** ppEnumStream);
    STDMETHOD(get_Streams)(VARIANT * pVariant);

    //
    // ITPhoneMSPCallPrivate
    //
    STDMETHOD(Initialize)( CPhoneMSP * pPhoneMSP );
    STDMETHOD(OnConnect)();
    STDMETHOD(OnDisconnect)();
    STDMETHOD(SelectTerminal)( ITTerminalPrivate * );
    STDMETHOD(UnselectTerminal)( ITTerminalPrivate * );
	STDMETHOD(GetGain)(long *pVal, DWORD dwHookSwitch);
	STDMETHOD(PutGain)(long newVal, DWORD dwHookSwitch);
	STDMETHOD(GetVolume)(long *pVal, DWORD dwHookSwitch);
	STDMETHOD(PutVolume)(long newVal, DWORD dwHookSwitch);
    
};
            
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\priviids.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    priviids.h

Abstract:

Author:

    mquinton  10-08-98
    
Notes:

Revision History:

--*/

#ifndef __TAPI3_IIDS_H___
#define __TAPI3_IIDS_H___

#include <initguid.h>

// {E024B01A-4197-11d1-8F33-00C04FB6809F}
DEFINE_GUID(IID_ITTerminalPrivate,
0xe024b01a, 0x4197, 0x11d1, 0x8f, 0x33, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f);

// {D5CDB359-5D7D-11d2-A053-00C04FB6809F}
DEFINE_GUID(IID_ITPhoneMSPCallPrivate, 
0xd5cdb359, 0x5d7d, 0x11d2, 0xa0, 0x53, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f);

// {D5CDB35A-5D7D-11d2-A053-00C04FB6809F}
DEFINE_GUID(IID_ITPhoneMSPStreamPrivate, 
0xd5cdb35a, 0x5d7d, 0x11d2, 0xa0, 0x53, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f);

// {D5CDB35B-5D7D-11d2-A053-00C04FB6809F}
DEFINE_GUID(IID_ITPhoneMSPAddressPrivate, 
0xd5cdb35b, 0x5d7d, 0x11d2, 0xa0, 0x53, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\phone.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    phone.cpp

Abstract:

    Implementation of phone object for TAPI 3.1

Notes:

    optional-notes

Revision History:

--*/

#include "stdafx.h"

#define TIMER_KEEP_ALIVE 0x0FFFFFFF

/////////////////////////////////////////////////////////////////////////////
// IDispatch implementation
//

typedef IDispatchImpl<ITPhoneVtbl<CPhone>,
                      &IID_ITPhone,
                      &LIBID_TAPI3Lib>
        PhoneType;

typedef IDispatchImpl<ITAutomatedPhoneControlVtbl<CPhone>, 
                      &IID_ITAutomatedPhoneControl,
                      &LIBID_TAPI3Lib>
        AutomatedPhoneControlType;



extern HRESULT mapTAPIErrorCode(long lErrorCode);



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CPhone::GetIDsOfNames
//
// Overidden IDispatch method
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP CPhone::GetIDsOfNames(REFIID riid, 
                                  LPOLESTR* rgszNames, 
                                  UINT cNames, 
                                  LCID lcid, 
                                  DISPID* rgdispid
                                 ) 
{ 
   HRESULT hr = DISP_E_UNKNOWNNAME;


    // See if the requsted method belongs to the default interface
    hr = PhoneType::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((TL_INFO, "GetIDsOfNames - found %S on ITPhone", *rgszNames));
        rgdispid[0] |= IDISPPHONE;
        return hr;
    }

    // If not, then try the ITAutomatedPhoneControl interface
    hr = AutomatedPhoneControlType::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((TL_INFO, "GetIDsOfNames - found %S on ITAutomatedPhoneControl", *rgszNames));
        rgdispid[0] |= IDISPAPC;
        return hr;
    }

    LOG((TL_INFO, "GetIDsOfNames - Didn't find %S on our iterfaces", *rgszNames));
    return hr; 
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CPhone::Invoke
//
// Overide if IDispatch method
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP CPhone::Invoke(DISPID dispidMember, 
                              REFIID riid, 
                              LCID lcid, 
                              WORD wFlags, 
                              DISPPARAMS* pdispparams, 
                              VARIANT* pvarResult, 
                              EXCEPINFO* pexcepinfo, 
                              UINT* puArgErr
                             )
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    DWORD   dwInterface = (dispidMember & INTERFACEMASK);
   
    
    LOG((TL_TRACE, "Invoke - dispidMember %X", dispidMember));

    // Call invoke for the required interface
    switch (dwInterface)
    {
    case IDISPPHONE:
    {
        hr = PhoneType::Invoke(dispidMember, 
                                    riid, 
                                    lcid, 
                                    wFlags, 
                                    pdispparams,
                                    pvarResult, 
                                    pexcepinfo, 
                                    puArgErr
                                   );
        break;
    }
    case IDISPAPC:
    {
        hr = AutomatedPhoneControlType::Invoke(dispidMember, 
                                            riid, 
                                            lcid, 
                                            wFlags, 
                                            pdispparams,
                                            pvarResult, 
                                            pexcepinfo, 
                                            puArgErr
                                           );
        break;
    }

    } // end switch (dwInterface)

    
    LOG((TL_TRACE, hr, "Invoke - exit" ));
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CPhone::InternalAddRef
//
// Overidden IDispatch method
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP_(ULONG) CPhone::InternalAddRef()
{
    DWORD dwR;

    dwR = InterlockedIncrement(&m_dwRef);

    LOG((TL_INFO, "InternalAddRef - dwR %d",dwR ));

    #if DBG
        LogDebugAddRef(m_dwRef);
    #endif

    return dwR;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CPhone::InternalRelease
//
// Overidden IDispatch method
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=  
STDMETHODIMP_(ULONG) CPhone::InternalRelease()
{
    DWORD               dwR;
    PtrList::iterator   iter, end;
    T3LINE            * pt3Line;

    LOG((TL_INFO, "InternalRelease - m_dwRef %d",m_dwRef ));
    Lock();
    
    gpPhoneHashTable->Lock();
    
    dwR = InterlockedDecrement(&m_dwRef);

    // if ref count is 0 (means we entered function with 1) then we final release
    if (0 == dwR)
    {
        // remove from the hash table, so any more messages
        // from tapisrv are ignored
        //

        if (m_hPhone)
        {
            if(FAILED(gpPhoneHashTable->Remove( (ULONG_PTR)(m_hPhone) ) ))
            {
                LOG((TL_INFO, "InternalRelease - pLineHashTable->Remove failed" ));
            }
        }

        gpPhoneHashTable->Unlock();

        dwR = m_dwRef = 0;

        Unlock();
        LOG((TL_INFO, "InternalRelease - final OK dwR %d",dwR ));
    }
    else
    {
        gpPhoneHashTable->Unlock();
        Unlock();
        LOG((TL_INFO, "InternalRelease - not final dwR %d",dwR ));
    }     

    #if DBG  
        LogDebugRelease( dwR );
    #endif

    return dwR;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// ITPhone methods
//


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Open
//    
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhone::Open( 
    PHONE_PRIVILEGE Privilege
    )
{
    DWORD   dwPrivilege;
    T3PHONE t3Phone;
    HRESULT hr;

    LOG((TL_TRACE, "Open - enter" ));

    Lock();

    //
    // We cannot be opened multiple time simultaneously
    // return TAPI_E_INUSE if someone else has us open
    //
    if (m_hPhone)
    {
        LOG((TL_TRACE, "Open - phone in use" ));
        
        Unlock();
        return TAPI_E_INUSE;
    }

    switch(Privilege)
    {
    case PP_OWNER:
        dwPrivilege = PHONEPRIVILEGE_OWNER;
        break;
    case PP_MONITOR:
        dwPrivilege = PHONEPRIVILEGE_MONITOR;
        break;
    default:
        {
            LOG((TL_TRACE, "Open - invalid privilege" ));
        
            Unlock();
            return TAPI_E_INVALPRIVILEGE;
        }
        break;
    }

    t3Phone.hPhone = NULL;
    t3Phone.pPhone = this;

    hr = PhoneOpen(m_hPhoneApp, m_dwDeviceID, &t3Phone, m_dwAPIVersion, dwPrivilege);

    if ( SUCCEEDED(hr) )
    {
        
        hr = PhoneSetStatusMessages(&t3Phone, 
                                    PHONESTATE_CAPSCHANGE |
                                    PHONESTATE_HANDSETHOOKSWITCH |
                                    PHONESTATE_HEADSETHOOKSWITCH |
                                    PHONESTATE_LAMP |
                                    PHONESTATE_RINGMODE |
                                    PHONESTATE_RINGVOLUME |
                                    PHONESTATE_SPEAKERHOOKSWITCH |
                                    PHONESTATE_DISPLAY,
                                    PHONEBUTTONMODE_CALL |
                                    PHONEBUTTONMODE_DISPLAY |
                                    PHONEBUTTONMODE_DUMMY |
                                    PHONEBUTTONMODE_FEATURE |
                                    PHONEBUTTONMODE_KEYPAD |
                                    PHONEBUTTONMODE_LOCAL,
                                    PHONEBUTTONSTATE_UP |
                                    PHONEBUTTONSTATE_DOWN |
                                    PHONEBUTTONSTATE_UNKNOWN |
                                    PHONEBUTTONSTATE_UNAVAIL);

        if ( SUCCEEDED(hr) )
        {
            m_hPhone = t3Phone.hPhone;

            m_dwPrivilege = dwPrivilege;                       
        }
        else
        {
            PhoneClose(t3Phone.hPhone);
        }
    }

    //
    // Defaults for phone automation settings
    //
    
    m_fPhoneHandlingEnabled = FALSE;
    m_dwAutoEndOfNumberTimeout = APC_DEFAULT_AEONT;
    m_fAutoDialtone = TRUE;
    m_fAutoStopTonesOnOnHook = TRUE;
    m_fAutoStopRingOnOffHook = TRUE;
    m_fAutoKeypadTones = TRUE;
    m_dwAutoKeypadTonesMinimumDuration = APC_DEFAULT_AKTMD;
    m_fAutoVolumeControl = TRUE;
    m_dwAutoVolumeControlStep = APC_DEFAULT_VCS;
    m_dwAutoVolumeControlRepeatDelay = APC_DEFAULT_VCRD;
    m_dwAutoVolumeControlRepeatPeriod = APC_DEFAULT_VCRP;

    Unlock();

    if ( FAILED(hr) )
    {
        LOG((TL_TRACE, "Open - PhoneOpen returned failure - "
                                    "exit 0x%08x", hr ));
        
        return hr;
    }

    LOG((TL_TRACE, "Open - exit S_OK"));

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Close
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhone::Close()
{
    HRESULT hr;

    LOG((TL_TRACE, "Close - enter" ));

    Lock();

    if ( m_hPhone == NULL )
    {
        LOG((TL_WARN, "Close - phone not open - return S_OK"));
        Unlock();

        return S_OK;
    }

    if (m_dwPrivilege == PHONEPRIVILEGE_OWNER)
    {
        //
        // Turn off automatic phone handling
        //

        m_fPhoneHandlingEnabled = FALSE;

        //
        // Stop any ringers or tones
        //

        if (m_fRinger == TRUE) 
        {
            StopRinger();
        }

        if (m_Tone != PT_SILENCE) 
        {
            StopTone();
        }

        CloseWaveDevice();

        //
        // Unselect any calls
        //

        if (m_pCall != NULL)
        {
            InternalUnselectCall(m_pCall);
        }
    }
   
    //
    // Finally, actually close the phone
    //

    hr = PhoneClose(m_hPhone);

    m_hPhone = NULL;       
   
    Unlock();

    LOG((TL_TRACE, "Close - exit - return %lx", hr));
    
    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Addresses
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhone::get_Addresses(
                      VARIANT *pAddresses
                     )
{
    IEnumAddress * pEnum;
    ITAddress    * pAddress;
    AddressArray   aAddresses; 
    HRESULT        hr;
    IDispatch    * pDisp;

    LOG((TL_TRACE, "get_Addresses - enter" ));

    if ( TAPIIsBadWritePtr( pAddresses, sizeof (VARIANT) ) )
    {
        LOG((TL_ERROR, "get_Addresses - bad pointer"));
        
        return E_POINTER;
    }

    Lock();

    //
    // get the addresses from tapi
    //
    hr = m_pTAPI->EnumerateAddresses( &pEnum );

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "get_Addresses - could not enumerate addresses from tapi - return %lx", hr));
        Unlock();

        return hr;
    }

    //
    // choose only addresses that this phone is on
    //
    while ( S_OK == pEnum->Next( 1, &pAddress, NULL ) )
    {
         if (IsPhoneOnAddress( pAddress ))
         {
             if ( !aAddresses.Add( pAddress ) )
             {
                 LOG((TL_ERROR, "get_Addresses - could add address to array"));
             }
         }

         pAddress->Release();
    }

    pEnum->Release();

    Unlock();

    //
    // create the collection
    //
    CComObject< CTapiCollection< ITAddress > > * p;
    hr = CComObject< CTapiCollection< ITAddress > >::CreateInstance( &p );
    
    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((TL_ERROR, "get_Addresses - could not create collection" ));
        
        return E_OUTOFMEMORY;
    }

    //
    // get the IDispatch interface
    //
    hr = p->_InternalQueryInterface( IID_IDispatch, (void **) &pDisp );

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "get_Addresses - could not get IDispatch interface" ));
        
        delete p;
        return hr;
    }
    
    hr = p->Initialize( aAddresses );

    aAddresses.Shutdown();

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "get_Addresses - could not initialize collection" ));
        
        pDisp->Release();
        return hr;
    }

    //
    // put it in the variant
    //

    VariantInit(pAddresses);
    pAddresses->vt = VT_DISPATCH;
    pAddresses->pdispVal = pDisp;

    LOG((TL_TRACE, "get_Addresses - exit - return %lx", hr));
    
    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// EnumerateAddresses
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhone::EnumerateAddresses(
    IEnumAddress ** ppEnumAddress
    )
{
    IEnumAddress * pEnumAddress;
    ITAddress    * pAddress;
    AddressArray   aAddresses; 
    HRESULT        hr;

    LOG((TL_TRACE, "EnumerateAddresses - enter" ));

    if ( TAPIIsBadWritePtr( ppEnumAddress, sizeof (IEnumAddress *) ) )
    {
        LOG((TL_ERROR, "EnumerateAddresses - bad pointer"));
        
        return E_POINTER;
    }

    Lock();

    //
    // get the addresses from tapi
    //
    hr = m_pTAPI->EnumerateAddresses( &pEnumAddress );

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "EnumerateAddresses - could not enumerate addresses from tapi - return %lx", hr));
        Unlock();

        return hr;
    }

    //
    // choose only addresses that this phone is on
    //
    while ( S_OK == pEnumAddress->Next( 1, &pAddress, NULL ) )
    {
         if (IsPhoneOnAddress( pAddress ))
         {
             if ( !aAddresses.Add( pAddress ) )
             {
                 LOG((TL_ERROR, "EnumerateAddresses - could add address to array"));
             }
         }

         pAddress->Release();
    }

    pEnumAddress->Release();

    Unlock();

    //
    // create the enum
    //
    CComObject< CTapiEnum<IEnumAddress, ITAddress, &IID_IEnumAddress> > * pEnum;
    hr = CComObject< CTapiEnum<IEnumAddress, ITAddress, &IID_IEnumAddress> >::CreateInstance( &pEnum );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((TL_ERROR, "EnumerateAddresses - could not create enum - return %lx", hr));

        return hr;
    }

    //
    // initialize
    //
    hr = pEnum->Initialize( aAddresses );

    aAddresses.Shutdown();

    if ( FAILED(hr) )
    {
        pEnum->Release();
        
        LOG((TL_ERROR, "EnumerateAddresses - could not initialize enum - return %lx", hr));

        return hr;
    }

    *ppEnumAddress = pEnum;

    LOG((TL_TRACE, "EnumerateAddresses - exit - return %lx", hr));
    
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_PreferredAddresses
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhone::get_PreferredAddresses(
                               VARIANT *pAddresses
                              )
{
    IEnumAddress * pEnum;
    ITAddress    * pAddress;
    AddressArray   aAddresses; 
    HRESULT        hr;
    IDispatch    * pDisp;

    LOG((TL_TRACE, "get_PreferredAddresses - enter" ));

    if ( TAPIIsBadWritePtr( pAddresses, sizeof (VARIANT) ) )
    {
        LOG((TL_ERROR, "get_PreferredAddresses - bad pointer"));
        
        return E_POINTER;
    }

    Lock();

    //
    // get the addresses from tapi
    //
    hr = m_pTAPI->EnumerateAddresses( &pEnum );

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "get_PreferredAddresses - could not enumerate addresses from tapi - return %lx", hr));
        Unlock();

        return hr;
    }

    //
    // choose only addresses that this phone is on
    //
    while ( S_OK == pEnum->Next( 1, &pAddress, NULL ) )
    {
         if (IsPhoneOnPreferredAddress( pAddress ))
         {
             if ( !aAddresses.Add( pAddress ) )
             {
                 LOG((TL_ERROR, "get_PreferredAddresses - could add address to array"));
             }
         }

         pAddress->Release();
    }

    pEnum->Release();

    Unlock();

    //
    // create the collection
    //
    CComObject< CTapiCollection< ITAddress > > * p;
    hr = CComObject< CTapiCollection< ITAddress > >::CreateInstance( &p );
    
    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((TL_ERROR, "get_PreferredAddresses - could not create collection" ));
        
        return E_OUTOFMEMORY;
    }

    //
    // get the IDispatch interface
    //
    hr = p->_InternalQueryInterface( IID_IDispatch, (void **) &pDisp );

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "get_PreferredAddresses - could not get IDispatch interface" ));
        
        delete p;
        return hr;
    }
    
    hr = p->Initialize( aAddresses );

    aAddresses.Shutdown();

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "get_PreferredAddresses - could not initialize collection" ));
        
        pDisp->Release();
        return hr;
    }

    //
    // put it in the variant
    //

    VariantInit(pAddresses);
    pAddresses->vt = VT_DISPATCH;
    pAddresses->pdispVal = pDisp;

    LOG((TL_TRACE, "get_PreferredAddresses - exit - return %lx", hr));
    
    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// EnumeratePreferredAddresses
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhone::EnumeratePreferredAddresses(
    IEnumAddress ** ppEnumAddress
    )
{
    IEnumAddress * pEnumAddress;
    ITAddress    * pAddress;
    AddressArray   aAddresses; 
    HRESULT        hr;

    LOG((TL_TRACE, "EnumeratePreferredAddresses - enter" ));

    if ( TAPIIsBadWritePtr( ppEnumAddress, sizeof (IEnumAddress *) ) )
    {
        LOG((TL_ERROR, "EnumeratePreferredAddresses - bad pointer"));
        
        return E_POINTER;
    }

    Lock();

    //
    // get the addresses from tapi
    //
    hr = m_pTAPI->EnumerateAddresses( &pEnumAddress );

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "EnumeratePreferredAddresses - could not enumerate addresses from tapi - return %lx", hr));
        Unlock();

        return hr;
    }

    //
    // choose only addresses that this phone is on
    //
    while ( S_OK == pEnumAddress->Next( 1, &pAddress, NULL ) )
    {
         if (IsPhoneOnPreferredAddress( pAddress ))
         {
             if ( !aAddresses.Add( pAddress ) )
             {
                 LOG((TL_ERROR, "EnumeratePreferredAddresses - could add address to array"));
             }
         }

         pAddress->Release();
    }

    pEnumAddress->Release();

    Unlock();

    //
    // create the enum
    //
    CComObject< CTapiEnum<IEnumAddress, ITAddress, &IID_IEnumAddress> > * pEnum;
    hr = CComObject< CTapiEnum<IEnumAddress, ITAddress, &IID_IEnumAddress> >::CreateInstance( &pEnum );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((TL_ERROR, "EnumeratePreferredAddresses - could not create enum - return %lx", hr));

        return hr;
    }

    //
    // initialize
    //
    hr = pEnum->Initialize( aAddresses );

    aAddresses.Shutdown();

    if ( FAILED(hr) )
    {
        pEnum->Release();
        
        LOG((TL_ERROR, "EnumeratePreferredAddresses - could not initialize enum - return %lx", hr));

        return hr;
    }

    *ppEnumAddress = pEnum;

    LOG((TL_TRACE, "EnumeratePreferredAddresses - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_PhoneCapsLong
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhone::get_PhoneCapsLong(
    PHONECAPS_LONG pclCap,
    long * plCapability
    )
{
    HRESULT         hr = S_OK;

    if ( TAPIIsBadWritePtr( plCapability, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_PhoneCapsLong - bad pointer"));

        return E_POINTER;
    }

    LOG((TL_TRACE, "get_PhoneCapsLong - enter" ));

    Lock();
    
    //
    // Update the cache
    //
    hr = UpdatePhoneCaps();

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "get_PhoneCapsLong - could not get phonecaps"));

        Unlock();
        
        return hr;
    }

    switch (pclCap)
    {
        case PCL_HOOKSWITCHES:
            *plCapability = m_pPhoneCaps->dwHookSwitchDevs;
            break;
    
        case PCL_HANDSETHOOKSWITCHMODES:
            *plCapability = m_pPhoneCaps->dwHandsetHookSwitchModes;
            break;     
            
        case PCL_HEADSETHOOKSWITCHMODES:
            *plCapability = m_pPhoneCaps->dwHeadsetHookSwitchModes;
            break;  
            
        case PCL_SPEAKERPHONEHOOKSWITCHMODES:
            *plCapability = m_pPhoneCaps->dwSpeakerHookSwitchModes;
            break;

        case PCL_DISPLAYNUMROWS:
            *plCapability = m_pPhoneCaps->dwDisplayNumRows;
            break;

        case PCL_DISPLAYNUMCOLUMNS:
            *plCapability = m_pPhoneCaps->dwDisplayNumColumns;
            break;

        case PCL_NUMRINGMODES:
            *plCapability = m_pPhoneCaps->dwNumRingModes;
            break;

        case PCL_NUMBUTTONLAMPS:
            *plCapability = m_pPhoneCaps->dwNumButtonLamps;
            break;

        case PCL_GENERICPHONE:
            if( m_dwAPIVersion >= TAPI_VERSION2_0 )
            {
                *plCapability = (m_pPhoneCaps->dwPhoneFeatures & PHONEFEATURE_GENERICPHONE) ? 1:0;
            }
            else
            {
                *plCapability = 0;
            }
            break;

        default:
            LOG((TL_ERROR, "get_PhoneCapsLong - bad pclCap"));

            Unlock();
            
            return E_INVALIDARG;
    }  

    Unlock();

    LOG((TL_TRACE, "get_PhoneCapsLong - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_PhoneCapsString
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhone::get_PhoneCapsString(
    PHONECAPS_STRING pcsCap,
    BSTR * ppCapability
    )
{
    HRESULT         hr;

    if ( TAPIIsBadWritePtr( ppCapability, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_PhoneCapsString - bad pointer"));

        return E_POINTER;
    }

    LOG((TL_TRACE, "get_PhoneCapsString - enter" ));

    Lock();
    
    //
    // Update the cache
    //
    hr = UpdatePhoneCaps();

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "get_PhoneCapsString - could not get phonecaps - %lx", hr));

        Unlock();
        
        return hr;
    }

    DWORD dwSize;
    DWORD dwOffset;

    //
    // Get the size and offset of the string in the phone caps
    //
    switch (pcsCap)
    {
        case PCS_PHONENAME:
            dwSize = m_pPhoneCaps->dwPhoneNameSize;
            dwOffset = m_pPhoneCaps->dwPhoneNameOffset;         
            break;
    
        case PCS_PHONEINFO:
            dwSize = m_pPhoneCaps->dwPhoneInfoSize;
            dwOffset = m_pPhoneCaps->dwPhoneInfoOffset;
            break;     
            
        case PCS_PROVIDERINFO:
            dwSize = m_pPhoneCaps->dwProviderInfoSize;
            dwOffset = m_pPhoneCaps->dwProviderInfoOffset;
            break;

        default:
            LOG((TL_ERROR, "get_PhoneCapsString - bad pcsCap"));

            Unlock();
            
            return E_INVALIDARG;
    }  

    //
    // Allocate the BSTR
    //
    if ( dwSize != 0 )
    {
        *ppCapability = SysAllocString( (LPWSTR)(((LPBYTE)(m_pPhoneCaps)) + dwOffset) );

        if ( NULL == *ppCapability )
        {
            LOG((TL_ERROR, "get_PhoneCapsString - SysAllocString failed - E_OUTOFMEMORY"));
            
            Unlock();
            
            return E_OUTOFMEMORY;
        }
    } 

    Unlock();

    LOG((TL_TRACE, "get_PhoneCapsString - exit - return S_OK"));
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Terminals
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhone::get_Terminals(
    ITAddress * pAddress,
    VARIANT * pTerminals
    )
{
    IEnumTerminal         * pEnumTerminal;
    ITTerminal            * pTerminal;
    ITStaticAudioTerminal * pStaticAudioTerminal;
    TerminalArray           aTerminals; 
    HRESULT                 hr;
    IDispatch             * pDisp;
    ITTerminalSupport     * pTerminalSupport;
    LONG                    lMediaType;
    TERMINAL_DIRECTION      nDir;

    LOG((TL_TRACE, "get_Terminals - enter" ));

    if ( IsBadReadPtr( pAddress, sizeof (ITAddress) ) )
    {
        LOG((TL_ERROR, "get_Terminals - bad pointer"));
        
        return E_POINTER;
    }

    if ( TAPIIsBadWritePtr( pTerminals, sizeof (VARIANT) ) )
    {
        LOG((TL_ERROR, "get_Terminals - bad pointer"));
        
        return E_POINTER;
    }

    Lock();

    //
    // Get the ITTerminalSupport interface
    //
    hr = pAddress->QueryInterface(IID_ITTerminalSupport, (void **) &pTerminalSupport);

    if ( SUCCEEDED(hr) )
    {
        //
        // Get all the terminals on this address
        //
        hr = pTerminalSupport->EnumerateStaticTerminals( &pEnumTerminal );

        if ( SUCCEEDED(hr) )
        {
            while ( S_OK == pEnumTerminal->Next( 1, &pTerminal, NULL ) )
            {
                hr = pTerminal->get_MediaType(&lMediaType);

                if ( SUCCEEDED(hr) )
                {
                    hr = pTerminal->get_Direction(&nDir);

                    if ( SUCCEEDED(hr) )
                    {
                        //
                        // we only care about audio terminals
                        //

                        if (lMediaType == TAPIMEDIATYPE_AUDIO)
                        {
                            //
                            // we only care about terminals which implement ITStaticAudioTerminal
                            // because we need to get the wave ID
                            //

                            hr = pTerminal->QueryInterface(IID_ITStaticAudioTerminal,
                                                        (void **) &pStaticAudioTerminal);

                            if ( SUCCEEDED(hr) )
                            {
                                LONG lWaveId;

                                hr = pStaticAudioTerminal->get_WaveId(&lWaveId);

                                if ( SUCCEEDED(hr) )
                                {
                                    LOG((TL_INFO, "get_Terminals - got terminal wave id %d", lWaveId));

                                    if (IsPhoneUsingWaveID( lWaveId, nDir ))
                                    {
                                        if ( !aTerminals.Add( pTerminal ) )
                                        {
                                            LOG((TL_ERROR, "get_Terminals - could add terminal to array"));
                                        }
                                    }
                                }
                                pStaticAudioTerminal->Release();
                            }
                        }
                    }
                    else
                    {
                        LOG((TL_WARN, "get_Terminals - could not get terminal direction - %lx", hr));
                    }
                }
                else
                {
                    LOG((TL_WARN, "get_Terminals - could not get terminal media type - %lx", hr));
                }

                pTerminal->Release();
            }
            pEnumTerminal->Release();
        }
        pTerminalSupport->Release();
    }

    Unlock();

    //
    // create the collection
    //
    CComObject< CTapiCollection< ITTerminal > > * p;
    hr = CComObject< CTapiCollection< ITTerminal > >::CreateInstance( &p );
    
    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((TL_ERROR, "get_Terminals - could not create collection" ));
        
        return E_OUTOFMEMORY;
    }

    //
    // get the IDispatch interface
    //
    hr = p->_InternalQueryInterface( IID_IDispatch, (void **) &pDisp );

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "get_Terminals - could not get IDispatch interface" ));
        
        delete p;
        return hr;
    }
    
    //
    // initialize
    //
    hr = p->Initialize( aTerminals );

    aTerminals.Shutdown();

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "get_Terminals - could not initialize collection" ));
        
        pDisp->Release();
        return hr;
    }

    //
    // put it in the variant
    //

    VariantInit(pTerminals);
    pTerminals->vt = VT_DISPATCH;
    pTerminals->pdispVal = pDisp;

    LOG((TL_TRACE, "get_Terminals - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// EnumerateTerminals
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhone::EnumerateTerminals(
    ITAddress * pAddress,
    IEnumTerminal ** ppEnumTerminal
    )
{
    IEnumTerminal         * pEnumTerminal;
    ITTerminal            * pTerminal;
    ITStaticAudioTerminal * pStaticAudioTerminal;
    TerminalArray           aTerminals; 
    HRESULT                 hr;
    ITTerminalSupport     * pTerminalSupport;
    LONG                    lMediaType;
    TERMINAL_DIRECTION      nDir;

    LOG((TL_TRACE, "EnumerateTerminals - enter" ));

    if ( IsBadReadPtr( pAddress, sizeof (ITAddress) ) )
    {
        LOG((TL_ERROR, "get_Terminals - bad pointer"));
        
        return E_POINTER;
    }

    if ( TAPIIsBadWritePtr( ppEnumTerminal, sizeof (IEnumTerminal *) ) )
    {
        LOG((TL_ERROR, "EnumerateTerminals - bad pointer"));
        
        return E_POINTER;
    }

    Lock();

    //
    // Get the ITTerminalSupport interface
    //
    hr = pAddress->QueryInterface(IID_ITTerminalSupport, (void **) &pTerminalSupport);

    if ( SUCCEEDED(hr) )
    {
        //
        // Get all the terminals on this address
        //
        hr = pTerminalSupport->EnumerateStaticTerminals( &pEnumTerminal );

        if ( SUCCEEDED(hr) )
        {
            while ( S_OK == pEnumTerminal->Next( 1, &pTerminal, NULL ) )
            {
                hr = pTerminal->get_MediaType(&lMediaType);

                if ( SUCCEEDED(hr) )
                {
                    hr = pTerminal->get_Direction(&nDir);

                    if ( SUCCEEDED(hr) )
                    {
                        //
                        // we only care about audio terminals
                        //

                        if (lMediaType == TAPIMEDIATYPE_AUDIO)
                        {
                            //
                            // we only care about terminals which implement ITStaticAudioTerminal
                            // because we need to get the wave ID
                            //

                            hr = pTerminal->QueryInterface(IID_ITStaticAudioTerminal,
                                                        (void **) &pStaticAudioTerminal);

                            if ( SUCCEEDED(hr) )
                            {
                                LONG lWaveId;

                                hr = pStaticAudioTerminal->get_WaveId(&lWaveId);

                                if ( SUCCEEDED(hr) )
                                {
                                    LOG((TL_INFO, "get_Terminals - got terminal wave id %d", lWaveId));

                                    if (IsPhoneUsingWaveID( lWaveId, nDir ))
                                    {
                                        if ( !aTerminals.Add( pTerminal ) )
                                        {
                                            LOG((TL_ERROR, "get_Terminals - could add terminal to array"));
                                        }
                                    }
                                }
                                pStaticAudioTerminal->Release();
                            }
                        }
                    }
                    else
                    {
                        LOG((TL_WARN, "get_Terminals - could not get terminal direction - %lx", hr));
                    }
                }
                else
                {
                    LOG((TL_WARN, "get_Terminals - could not get terminal media type - %lx", hr));
                }

                pTerminal->Release();
            }
            pEnumTerminal->Release();
        }
        pTerminalSupport->Release();
    }

    Unlock();

    //
    // create the enum
    //
    CComObject< CTapiEnum<IEnumTerminal, ITTerminal, &IID_IEnumTerminal> > * pEnum;
    hr = CComObject< CTapiEnum<IEnumTerminal, ITTerminal, &IID_IEnumTerminal> >::CreateInstance( &pEnum );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((TL_ERROR, "EnumerateTerminals - could not create enum - return %lx", hr));

        return hr;
    }

    //
    // initialize
    //
    hr = pEnum->Initialize( aTerminals );

    aTerminals.Shutdown();

    if ( FAILED(hr) )
    {
        pEnum->Release();
        
        LOG((TL_ERROR, "EnumerateTerminals - could not initialize enum - return %lx", hr));

        return hr;
    }

    *ppEnumTerminal = pEnum;

    LOG((TL_TRACE, "EnumerateTerminals - exit - return %lx", hr ));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_ButtonMode
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhone::get_ButtonMode(
    long lButtonID,
    PHONE_BUTTON_MODE * pButtonMode
    )
{
    HRESULT           hr = S_OK;
    DWORD             dwNumButtons;
    LPPHONEBUTTONINFO pButtonInfo;

    LOG((TL_TRACE, "get_ButtonMode - enter" ));

    if ( TAPIIsBadWritePtr( pButtonMode, sizeof(PHONE_BUTTON_MODE) ) )
    {
        LOG((TL_ERROR, "get_ButtonMode - bad pointer"));

        return E_POINTER;
    }

    Lock();

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "get_ButtonMode - phone not open"));
        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    //
    // Get the ButtonInfo buffer
    //
    hr = PhoneGetButtonInfo(
                        m_hPhone,
                        lButtonID,
                        &pButtonInfo
                       );

    Unlock();

    if ( SUCCEEDED(hr) )
    {
        switch ( pButtonInfo->dwButtonMode )
        {
            case PHONEBUTTONMODE_CALL:
                *pButtonMode = PBM_CALL;
                break;

            case PHONEBUTTONMODE_DISPLAY:
                *pButtonMode = PBM_DISPLAY;
                break; 
                
            case PHONEBUTTONMODE_DUMMY:
                *pButtonMode = PBM_DUMMY;
                break;

            case PHONEBUTTONMODE_FEATURE:
                *pButtonMode = PBM_FEATURE;
                break;

            case PHONEBUTTONMODE_KEYPAD:
                *pButtonMode = PBM_KEYPAD;
                break;

            case PHONEBUTTONMODE_LOCAL:
                *pButtonMode = PBM_LOCAL;
                break;

            default:
                LOG((TL_ERROR, "get_ButtonMode - bad button mode"));

                hr = E_FAIL;
        }

        //
        // Free the ButtonInfo buffer
        //
        ClientFree( pButtonInfo );
    }

    LOG((TL_TRACE, "get_ButtonMode - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// put_ButtonMode
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhone::put_ButtonMode(
    long lButtonID,
    PHONE_BUTTON_MODE ButtonMode
    )
{
    HRESULT hr;

    LOG((TL_TRACE, "put_ButtonMode - enter" ));

    Lock();

    //
    // Make sure the phone is open with owner privilege.
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "put_ButtonMode - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    if ( m_dwPrivilege != PHONEPRIVILEGE_OWNER )
    {
        LOG((TL_ERROR, "put_ButtonMode - wrong phone privilege - "
                                 "exit TAPI_E_NOTOWNER"));

        Unlock();

        return TAPI_E_NOTOWNER;
    }
 
    //
    // get info for this button
    //

    PHONEBUTTONINFO *pButtonInfo = NULL;

    hr = PhoneGetButtonInfo(m_hPhone, lButtonID, &pButtonInfo);

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "put_ButtonMode - failed to get button info"));

        Unlock();
        
        return hr;
    }


    //
    // make sure the memory we got back is writeable
    //

    if (TAPIIsBadWritePtr(pButtonInfo, sizeof(PHONEBUTTONINFO)))
    {
        LOG((TL_ERROR, "put_ButtonMode - PhoneGetButtonInfo returned a bad memory block"));

        Unlock();
        
        return E_UNEXPECTED;
    }
    

    //
    // set the appropriate button mode in the structure that we have. leave everything else unchanged
    //

    switch (ButtonMode)
    {
    case PBM_DUMMY:
        pButtonInfo->dwButtonMode = PHONEBUTTONMODE_DUMMY;
        break;

    case PBM_CALL:
        pButtonInfo->dwButtonMode = PHONEBUTTONMODE_CALL;
        break;

    case PBM_FEATURE:
        pButtonInfo->dwButtonMode = PHONEBUTTONMODE_FEATURE;
        break;

    case PBM_KEYPAD:
        pButtonInfo->dwButtonMode = PHONEBUTTONMODE_KEYPAD;
        break;

    case PBM_LOCAL:
        pButtonInfo->dwButtonMode = PHONEBUTTONMODE_LOCAL;
        break;

    case PBM_DISPLAY:
        pButtonInfo->dwButtonMode = PHONEBUTTONMODE_DISPLAY;
        break;

    default:
        LOG((TL_ERROR, "put_ButtonMode - bad ButtonMode"));

        Unlock();

        ClientFree(pButtonInfo);
        pButtonInfo = NULL;

        return E_INVALIDARG;
    }

    
    //
    // set the new button mode
    //

    hr = PhoneSetButtonInfo(m_hPhone, lButtonID, pButtonInfo);

    Unlock();
    
    //
    // free memory returned to us by PhoneGetButtonInfo
    //

    ClientFree(pButtonInfo);
    pButtonInfo = NULL;

    LOG((TL_TRACE, "put_ButtonMode - put_ButtonMode - return %lx", hr ));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// put_ButtonText
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhone::put_ButtonText(
    long lButtonID,
    BSTR bstrButtonText
    )
{
    HRESULT hr;

    LOG((TL_TRACE, "put_ButtonText - enter" ));

    if ( IsBadStringPtrW(bstrButtonText, -1) )
    {
        LOG((TL_ERROR, "put_ButtonText - invalid parameter",
                                 "exit E_POINTER"));

        return E_POINTER;
    }

    Lock();

    //
    // Make sure the phone is open with owner privilege.
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "put_ButtonText - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    if ( m_dwPrivilege != PHONEPRIVILEGE_OWNER )
    {
        LOG((TL_ERROR, "put_ButtonText - wrong phone privilege - "
                                 "exit TAPI_E_NOTOWNER"));

        Unlock();

        return TAPI_E_NOTOWNER;
    }

    //
    // get info for this button
    //

    PHONEBUTTONINFO *pButtonInfo = NULL;

    hr = PhoneGetButtonInfo(m_hPhone, lButtonID, &pButtonInfo);

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "put_ButtonText - failed to get button info"));

        Unlock();
        
        return hr;
    }


    //
    // make sure the memory we got back is writeable
    //

    if ( TAPIIsBadWritePtr(pButtonInfo, sizeof(PHONEBUTTONINFO)) )
    {
        LOG((TL_ERROR, "put_ButtonText - PhoneGetButtonInfo returned a bad memory block"));

        Unlock();
        
        return E_UNEXPECTED;
    }   
    
    DWORD dwButtonTextLength = SysStringByteLen(bstrButtonText);

    //
    // add the string to the structure we have. if the new string fits in 
    // place of the old string, put it in there. otherwise, allocate a bigger 
    // structure and append the new string at the end
    //

    if ( dwButtonTextLength <= pButtonInfo->dwButtonTextSize )
    {
        CopyMemory((BYTE*)pButtonInfo + pButtonInfo->dwButtonTextOffset,
                   bstrButtonText, 
                   dwButtonTextLength);
        
        pButtonInfo->dwButtonTextSize = dwButtonTextLength;
    }
    else
    {
        //
        // create the new structure that will have everything the old one does + the new string
        //
        
        DWORD dwBiggerStructureSize = pButtonInfo->dwTotalSize + dwButtonTextLength;

        //
        // allocate the new, bigger structure
        //

        PHONEBUTTONINFO *pBiggerButtonInfo = (PHONEBUTTONINFO *)ClientAlloc(dwBiggerStructureSize);

        if ( NULL == pBiggerButtonInfo )
        {
            LOG((TL_ERROR, "put_ButtonText - failed to allocate memory for the new structure"));

            ClientFree(pButtonInfo);

            Unlock();

            return E_OUTOFMEMORY;
        }

        //
        // copy the old data into the bigger structure
        //

        CopyMemory(pBiggerButtonInfo, pButtonInfo, pButtonInfo->dwTotalSize);

        //
        // append the new structure with the new string (the new text starts after the old data)
        //

        //
        // set the offset and size for the text in the new structure
        //

        pBiggerButtonInfo->dwButtonTextOffset = pButtonInfo->dwTotalSize;
        pBiggerButtonInfo->dwButtonTextSize = dwButtonTextLength;

        //
        // copy the text to the end of the new structure
        //

        CopyMemory((BYTE*)pBiggerButtonInfo + pBiggerButtonInfo->dwButtonTextOffset,
                   bstrButtonText,
                   dwButtonTextLength);

        //
        // set the size of the new structure
        //

        pBiggerButtonInfo->dwTotalSize = dwBiggerStructureSize;

        //
        // free memory allocated by the old structure
        //

        ClientFree(pButtonInfo);

        //
        // pButtonInfo will now point to the new structure
        //

        pButtonInfo = pBiggerButtonInfo;
        pBiggerButtonInfo = NULL;
    }
    
    //
    // set the new button text
    //

    hr = PhoneSetButtonInfo(m_hPhone, lButtonID, pButtonInfo);

    Unlock();

    //
    // free memory returned to us by PhoneGetButtonInfo
    //

    ClientFree(pButtonInfo);
    pButtonInfo = NULL;

    LOG((TL_TRACE, "put_ButtonText - exit - return %lx", hr ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_PhoneCapsBuffer
//
// returns the requested buffer from phone capapabilities array -- 
// the scriptable version
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhone::get_PhoneCapsBuffer(
    IN PHONECAPS_BUFFER pcbCaps,
    OUT VARIANT *pVarBuffer
    )
{
    LOG((TL_TRACE, "get_PhoneCapsBuffer[%p] - enter", this ));

    //
    // check arguments
    //

    if ( TAPIIsBadWritePtr( pVarBuffer, sizeof(VARIANT) ) )
    {
        LOG((TL_ERROR, "get_PhoneCapsBuffer - bad pointer"));

        return E_POINTER;
    }

    //
    // get the buffer
    //

    DWORD dwBufferSize = 0;

    BYTE *pBuffer = NULL;

    
    HRESULT hr = GetPhoneCapsBuffer(pcbCaps, &dwBufferSize, &pBuffer);

    if (FAILED(hr))
    {
        LOG((TL_ERROR, "get_PhoneCapsBuffer - failed to get phone caps buffer"));

        return hr;
    }


    VariantInit(pVarBuffer);

    //
    // fill the variant with the data buffer
    //

    hr = FillVariantFromBuffer(dwBufferSize, pBuffer, pVarBuffer);
    
    //
    // no longer need the buffer -- we hope that now have all the data in the variant
    //

    CoTaskMemFree(pBuffer);

    if (FAILED(hr))
    {
        LOG((TL_ERROR, "get_PhoneCapsBuffer - failed to copy phone caps buffer to a variant"));

        return hr;
    }
     
    LOG((TL_TRACE, "get_PhoneCapsBuffer - exit - return S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetPhoneCapsBuffer
//
// returns the requested buffer from phone capapabilities array
//
// on success, the caller must call CoTaskMemFree to free the buffer that is
// returned by this method
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhone::GetPhoneCapsBuffer(
    IN PHONECAPS_BUFFER pcbCaps,
    OUT DWORD *pdwSize,
    OUT BYTE **ppPhoneCapsBuffer
    )
{
    LOG((TL_TRACE, "GetPhoneCapsBuffer - enter" ));

    //
    // check arguments
    //

    if ( TAPIIsBadWritePtr( ppPhoneCapsBuffer, sizeof(BYTE*) ) )
    {
        LOG((TL_ERROR, "GetPhoneCapsBuffer - bad pointer"));

        return E_POINTER;
    }
  
    *ppPhoneCapsBuffer = NULL;

    if ( TAPIIsBadWritePtr( pdwSize, sizeof(DWORD) ) )
    {
        LOG((TL_ERROR, "GetPhoneCapsBuffer - bad pointer"));

        return E_POINTER;
    }

    *pdwSize = 0;

    Lock();

    //
    // update phone capabilities cache
    //

    HRESULT hr = UpdatePhoneCaps();

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "GetPhoneCapsBuffer - could not get phonecaps"));

        Unlock();
        
        return hr;
    }

    switch (pcbCaps)
    {

    case PCB_DEVSPECIFICBUFFER:
        {
            //
            // allocate the buffer for device-specific caps
            //

            *pdwSize = m_pPhoneCaps->dwDevSpecificSize;

            *ppPhoneCapsBuffer = static_cast<BYTE*>(CoTaskMemAlloc(*pdwSize));

            if (NULL == *ppPhoneCapsBuffer)
            {
                LOG((TL_ERROR, "GetPhoneCapsBuffer - could not allocate memory for the output buffer"));

                Unlock();
    
                return E_OUTOFMEMORY;
            }

            //
            // copy data to the buffer to be returned to the caller
            //

            CopyMemory( *ppPhoneCapsBuffer, 
                        (BYTE*)m_pPhoneCaps + m_pPhoneCaps->dwDevSpecificOffset, 
                        *pdwSize);

            break;
        }
    default:
        
        Unlock();

        LOG((TL_ERROR, "GetPhoneCapsBuffer - unknown capability type %x", pcbCaps));

        return E_INVALIDARG;

        break;
    }

    Unlock();

    LOG((TL_TRACE, "GetPhoneCapsBuffer - exit - return S_OK"));
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Display
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhone::get_Display(
    BSTR *pbstrDisplay
    )
{
    HRESULT     hr;
    LONG        lResult;
    LPVARSTRING pVarString = NULL;

    LOG((TL_TRACE, "get_Display - enter" ));

    //
    // check arguments
    //

    if ( TAPIIsBadWritePtr( pbstrDisplay, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_Display - bad pointer"));

        return E_POINTER;
    }

    Lock();

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "get_Display - phone not open"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    hr = PhoneGetDisplay(m_hPhone, &pVarString);

    Unlock();

    if (FAILED(hr))
    {
        LOG((TL_ERROR, "get_Display - failed to get display. hr = %lx", hr));

        if (NULL != pVarString)
        {
            ClientFree(pVarString);
        }

        return hr;
    }
    
    //
    // succeeded. extract display information and place it in the the output bstr
    //

    hr = S_OK;

    switch (pVarString->dwStringFormat)
    {
    
    case STRINGFORMAT_ASCII:
        {
            int nWCHARSNeeded = MultiByteToWideChar(CP_ACP,
                                                    0,
                                                    (char*)((BYTE*)pVarString + pVarString->dwStringOffset),
                                                    pVarString->dwStringSize,
                                                    NULL,
                                                    0);

            if (0 == nWCHARSNeeded)
            {
                LOG((TL_ERROR, "get_Display - failed to get the size of the buffer needed for the display. LastError = %lx", GetLastError()));

                hr = E_FAIL;

                break;
            }
    
            //
            // allocate the buffer required for conversion
            //

            LPWSTR lpWideCharStr = (LPWSTR)ClientAlloc(sizeof(WCHAR) * nWCHARSNeeded);

            if (NULL == lpWideCharStr)
            {
                LOG((TL_ERROR, "get_Display - failed to allocate memory for lpWideCharStr" ));

                hr = E_OUTOFMEMORY;

                break;
            }

            //
            // perform conversion
            //

            int nResult = MultiByteToWideChar(CP_ACP,
                                              0,
                                              (char*)((BYTE*)pVarString + pVarString->dwStringOffset),
                                              pVarString->dwStringSize,
                                              lpWideCharStr,
                                              nWCHARSNeeded);

            if (0 == nResult)
            {
                LOG((TL_ERROR, "get_Display - failed to convert string to wchar. last error %lx", GetLastError()));

                ClientFree(lpWideCharStr);

                hr = E_FAIL;

                break;
            }

            //
            // allocate bstr and initialize it with the converted string
            //

            *pbstrDisplay = SysAllocString(lpWideCharStr);
            
            //
            // no longer need the wchar string -- we hope the data is in bstr
            //

            ClientFree(lpWideCharStr);

            if (NULL == *pbstrDisplay)
            {
                LOG((TL_ERROR, "get_Display - failed to allocate memory for bstr"));

                hr = E_OUTOFMEMORY;

                break;
            }
        }

        break;
    
    case STRINGFORMAT_BINARY:

        //
        // allocate bstr and copy data as is
        //

        *pbstrDisplay = SysAllocStringByteLen(NULL, pVarString->dwStringSize);

        if (NULL == *pbstrDisplay)
        {
            LOG((TL_ERROR, "get_Display - failed to allocate memory for bstr"));

            hr = E_OUTOFMEMORY;

            break;
        }

        CopyMemory(*pbstrDisplay, ((BYTE*)pVarString + pVarString->dwStringOffset), pVarString->dwStringSize);

        break;

    case STRINGFORMAT_DBCS:

        LOG((TL_ERROR, "get_Display - unsupported string format"));

        hr = E_FAIL;

        break;

    case STRINGFORMAT_UNICODE:
        {
            WCHAR *pwcDisplay = (WCHAR*)((BYTE*)pVarString + pVarString->dwStringOffset);

            *pbstrDisplay = SysAllocString(pwcDisplay);


            if (NULL == *pbstrDisplay)
            {
                LOG((TL_ERROR, "get_Display - failed to allocate memory for bstr"));

                hr = E_OUTOFMEMORY;

                break;
            }
        }

        break;
    
    default:

        ClientFree(pVarString);
        pVarString = NULL;

        LOG((TL_ERROR, "get_Display - tapisrv returned unrecognized string type %lx", pVarString->dwStringFormat));

        hr = E_FAIL;

        break;
    }

    ClientFree(pVarString);
    pVarString = NULL;

    LOG((TL_TRACE, "get_Display - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// SetDisplay
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhone::SetDisplay(
                long lRow,
                long lColumn,
                BSTR bstrDisplay
               )
{
    HRESULT hr;

    LOG((TL_TRACE, "SetDisplay - enter" ));

    if (bstrDisplay == NULL)
    {
        LOG((TL_ERROR, "SetDisplay - invalid parameter",
                                 "exit E_POINTER"));

        return E_POINTER;
    }

    Lock();

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "SetDisplay - phone not open"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    //
    // pass the text to tapisrv
    //

    hr = PhoneSetDisplay(
                    m_hPhone,
                    lRow,
                    lColumn,
                    (char*)bstrDisplay,
                    SysStringByteLen(bstrDisplay));

    Unlock();

    LOG((TL_TRACE, "SetDisplay - exit - return %lx", hr));
    
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_ButtonFunction
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhone::get_ButtonFunction(
    long lButtonID,
    PHONE_BUTTON_FUNCTION * pButtonFunction
    )
{
    HRESULT           hr = S_OK;
    DWORD             dwNumButtons;
    LPPHONEBUTTONINFO pButtonInfo;

    LOG((TL_TRACE, "get_ButtonFunction - enter" ));

    if ( TAPIIsBadWritePtr( pButtonFunction, sizeof(PHONE_BUTTON_FUNCTION) ) )
    {
        LOG((TL_ERROR, "get_ButtonFunction - bad pointer"));

        return E_POINTER;
    }

    Lock();

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "get_ButtonFunction - phone not open"));
        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    //
    // get the ButtonInfo buffer
    //
    hr = PhoneGetButtonInfo(
                        m_hPhone,
                        lButtonID,
                        &pButtonInfo
                       );

    if ( SUCCEEDED(hr) )
    {
        switch ( pButtonInfo->dwButtonFunction )
        {
        case PHONEBUTTONFUNCTION_ABBREVDIAL:
            *pButtonFunction = PBF_ABBREVDIAL;
            break;

        case PHONEBUTTONFUNCTION_BUSY:
            *pButtonFunction = PBF_BUSY;
            break;

        case PHONEBUTTONFUNCTION_BRIDGEDAPP:
            *pButtonFunction = PBF_BRIDGEDAPP;
            break;

        case PHONEBUTTONFUNCTION_CALLAPP:
            *pButtonFunction = PBF_CALLAPP;
            break;

        case PHONEBUTTONFUNCTION_CALLID:
            *pButtonFunction = PBF_CALLID;
            break;

        case PHONEBUTTONFUNCTION_CAMPON:
            *pButtonFunction = PBF_CAMPON;
            break;

        case PHONEBUTTONFUNCTION_COVER:
            *pButtonFunction = PBF_COVER;
            break;

        case PHONEBUTTONFUNCTION_CONFERENCE:
            *pButtonFunction = PBF_CONFERENCE;
            break;

        case PHONEBUTTONFUNCTION_CONNECT:
            *pButtonFunction = PBF_CONNECT;
            break;

        case PHONEBUTTONFUNCTION_DATAOFF:
            *pButtonFunction = PBF_DATAOFF;
            break;

        case PHONEBUTTONFUNCTION_DATAON:
            *pButtonFunction = PBF_DATAON;
            break;

        case PHONEBUTTONFUNCTION_DATETIME:
            *pButtonFunction = PBF_DATETIME;
            break;

        case PHONEBUTTONFUNCTION_DIRECTORY:
            *pButtonFunction = PBF_DIRECTORY;
            break;

        case PHONEBUTTONFUNCTION_DISCONNECT:
            *pButtonFunction = PBF_DISCONNECT;
            break;

        case PHONEBUTTONFUNCTION_DONOTDISTURB:
            *pButtonFunction = PBF_DONOTDISTURB;
            break;

        case PHONEBUTTONFUNCTION_DROP:
            *pButtonFunction = PBF_DROP;
            break;

        case PHONEBUTTONFUNCTION_FLASH:
            *pButtonFunction = PBF_FLASH;
            break;

        case PHONEBUTTONFUNCTION_FORWARD:
            *pButtonFunction = PBF_FORWARD;
            break;

        case PHONEBUTTONFUNCTION_HOLD:
            *pButtonFunction = PBF_HOLD;
            break;

        case PHONEBUTTONFUNCTION_INTERCOM:
            *pButtonFunction = PBF_INTERCOM;
            break;

        case PHONEBUTTONFUNCTION_LASTNUM:
            *pButtonFunction = PBF_LASTNUM;
            break;

        case PHONEBUTTONFUNCTION_MSGINDICATOR:
            *pButtonFunction = PBF_MSGINDICATOR;
            break;

        case PHONEBUTTONFUNCTION_MSGWAITOFF:
            *pButtonFunction = PBF_MSGWAITOFF;
            break;

        case PHONEBUTTONFUNCTION_MSGWAITON:
            *pButtonFunction = PBF_MSGWAITON;
            break;

        case PHONEBUTTONFUNCTION_MUTE:
            *pButtonFunction = PBF_MUTE;
            break;

        case PHONEBUTTONFUNCTION_NIGHTSRV:
            *pButtonFunction = PBF_NIGHTSRV;
            break;

        case PHONEBUTTONFUNCTION_NONE:
            *pButtonFunction = PBF_NONE;
            break;

        case PHONEBUTTONFUNCTION_PARK:
            *pButtonFunction = PBF_PARK;
            break;

        case PHONEBUTTONFUNCTION_PICKUP:
            *pButtonFunction = PBF_PICKUP;
            break;

        case PHONEBUTTONFUNCTION_QUEUECALL:
            *pButtonFunction = PBF_QUEUECALL;
            break;

        case PHONEBUTTONFUNCTION_RECALL:
            *pButtonFunction = PBF_RECALL;
            break;

        case PHONEBUTTONFUNCTION_REDIRECT:
            *pButtonFunction = PBF_REDIRECT;
            break;

        case PHONEBUTTONFUNCTION_REJECT:
            *pButtonFunction = PBF_REJECT;
            break;

        case PHONEBUTTONFUNCTION_REPDIAL:
            *pButtonFunction = PBF_REPDIAL;
            break;

        case PHONEBUTTONFUNCTION_RINGAGAIN:
            *pButtonFunction = PBF_RINGAGAIN;
            break;

        case PHONEBUTTONFUNCTION_SAVEREPEAT:
            *pButtonFunction = PBF_SAVEREPEAT;
            break;

        case PHONEBUTTONFUNCTION_SELECTRING:
            *pButtonFunction = PBF_SELECTRING;
            break;

        case PHONEBUTTONFUNCTION_SETREPDIAL:
            *pButtonFunction = PBF_SETREPDIAL;
            break;

        case PHONEBUTTONFUNCTION_SENDCALLS:
            *pButtonFunction = PBF_SENDCALLS;
            break;

        case PHONEBUTTONFUNCTION_SPEAKEROFF:
            *pButtonFunction = PBF_SPEAKEROFF;
            break;

        case PHONEBUTTONFUNCTION_SPEAKERON:
            *pButtonFunction = PBF_SPEAKERON;
            break;

        case PHONEBUTTONFUNCTION_STATIONSPEED:
            *pButtonFunction = PBF_STATIONSPEED;
            break;

        case PHONEBUTTONFUNCTION_SYSTEMSPEED:
            *pButtonFunction = PBF_SYSTEMSPEED;
            break;

        case PHONEBUTTONFUNCTION_TRANSFER:
            *pButtonFunction = PBF_TRANSFER;
            break;

        case PHONEBUTTONFUNCTION_UNKNOWN:
            *pButtonFunction = PBF_UNKNOWN;
            break;

        case PHONEBUTTONFUNCTION_VOLUMEDOWN:
            *pButtonFunction = PBF_VOLUMEDOWN;
            break;

        case PHONEBUTTONFUNCTION_VOLUMEUP:
            *pButtonFunction = PBF_VOLUMEUP;
            break;

        case PHONEBUTTONFUNCTION_SEND:
            *pButtonFunction = PBF_SEND;
            break;

        default:
                LOG((TL_ERROR, "get_ButtonFunction - bad button function"));

                hr = E_FAIL;
        }

        //
        // Free the ButtonInfo buffer
        //
        ClientFree( pButtonInfo );
    }

    Unlock();

    LOG((TL_TRACE, "get_ButtonFunction - exit - return %lx", hr));
    
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// put_ButtonFunction
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhone::put_ButtonFunction(
            IN long                  lButtonID, 
            IN PHONE_BUTTON_FUNCTION ButtonFunction
            )
{
    HRESULT hr;

    LOG((TL_TRACE, "put_ButtonFunction - enter" ));

    Lock();

    //
    // Make sure the phone is open with owner privilege.
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "put_ButtonFunction - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    if ( m_dwPrivilege != PHONEPRIVILEGE_OWNER )
    {
        LOG((TL_ERROR, "put_ButtonFunction - wrong phone privilege - "
                                 "exit TAPI_E_NOTOWNER"));

        Unlock();

        return TAPI_E_NOTOWNER;
    }

    //
    // get info for this button
    //

    PHONEBUTTONINFO *pButtonInfo = NULL;

    hr = PhoneGetButtonInfo(m_hPhone, lButtonID, &pButtonInfo);

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "put_ButtonFunction - failed to get button info - %lx", hr));

        Unlock();
        
        return hr;
    }

    //
    // make sure the memory we got back is writeable
    //

    if (TAPIIsBadWritePtr(pButtonInfo, sizeof(PHONEBUTTONINFO)))
    {
        LOG((TL_ERROR, "put_ButtonFunction - PhoneGetButtonInfo returned a bad memory block"));

        Unlock();
        
        return E_UNEXPECTED;
    }
      
    //
    // translate PHONE_BUTTON_FUNCTION to a DWORD value understood by tapisrv
    //

    DWORD dwButtonFunction = 0;

    switch ( ButtonFunction )
    {
        case PBF_ABBREVDIAL:
            dwButtonFunction = PHONEBUTTONFUNCTION_ABBREVDIAL;
            break;

        case PBF_BUSY:
            dwButtonFunction = PHONEBUTTONFUNCTION_BUSY;
            break;

        case PBF_BRIDGEDAPP:
            dwButtonFunction = PHONEBUTTONFUNCTION_BRIDGEDAPP;
            break;

        case PBF_CALLAPP:
            dwButtonFunction = PHONEBUTTONFUNCTION_CALLAPP;
            break;

        case PBF_CALLID:
            dwButtonFunction = PHONEBUTTONFUNCTION_CALLID;
            break;

        case PBF_CAMPON:
            dwButtonFunction = PHONEBUTTONFUNCTION_CAMPON;
            break;

        case PBF_COVER:
            dwButtonFunction = PHONEBUTTONFUNCTION_COVER;
            break;

        case PBF_CONFERENCE:
            dwButtonFunction = PHONEBUTTONFUNCTION_CONFERENCE;
            break;

        case PBF_CONNECT:
            dwButtonFunction = PHONEBUTTONFUNCTION_CONNECT;
            break;

        case PBF_DATAOFF:
            dwButtonFunction = PHONEBUTTONFUNCTION_DATAOFF;
            break;

        case PBF_DATAON:
            dwButtonFunction = PHONEBUTTONFUNCTION_DATAON;
            break;

        case PBF_DATETIME:
            dwButtonFunction = PHONEBUTTONFUNCTION_DATETIME;
            break;

        case PBF_DIRECTORY:
            dwButtonFunction = PHONEBUTTONFUNCTION_DIRECTORY;
            break;

        case PBF_DISCONNECT:
            dwButtonFunction = PHONEBUTTONFUNCTION_DISCONNECT;
            break;

        case PBF_DONOTDISTURB:
            dwButtonFunction = PHONEBUTTONFUNCTION_DONOTDISTURB;
            break;

        case PBF_DROP:
            dwButtonFunction = PHONEBUTTONFUNCTION_DROP;
            break;

        case PBF_FLASH:
            dwButtonFunction = PHONEBUTTONFUNCTION_FLASH;
            break;

        case PBF_FORWARD:
            dwButtonFunction = PHONEBUTTONFUNCTION_FORWARD;
            break;

        case PBF_HOLD:
            dwButtonFunction = PHONEBUTTONFUNCTION_HOLD;
            break;

        case PBF_INTERCOM:
            dwButtonFunction = PHONEBUTTONFUNCTION_INTERCOM;
            break;

        case PBF_LASTNUM:
            dwButtonFunction = PHONEBUTTONFUNCTION_LASTNUM;
            break;

        case PBF_MSGINDICATOR:
            dwButtonFunction = PHONEBUTTONFUNCTION_MSGINDICATOR;
            break;

        case PBF_MSGWAITOFF:
            dwButtonFunction = PHONEBUTTONFUNCTION_MSGWAITOFF;
            break;

        case PBF_MSGWAITON:
            dwButtonFunction = PHONEBUTTONFUNCTION_MSGWAITON;
            break;

        case PBF_MUTE:
            dwButtonFunction = PHONEBUTTONFUNCTION_MUTE;
            break;

        case PBF_NIGHTSRV:
            dwButtonFunction = PHONEBUTTONFUNCTION_NIGHTSRV;
            break;

        case PBF_NONE:
            dwButtonFunction = PHONEBUTTONFUNCTION_NONE;
            break;

        case PBF_PARK:
            dwButtonFunction = PHONEBUTTONFUNCTION_PARK;
            break;

        case PBF_PICKUP:
            dwButtonFunction = PHONEBUTTONFUNCTION_PICKUP;
            break;

        case PBF_QUEUECALL:
            dwButtonFunction = PHONEBUTTONFUNCTION_QUEUECALL;
            break;

        case PBF_RECALL:
            dwButtonFunction = PHONEBUTTONFUNCTION_RECALL;
            break;

        case PBF_REDIRECT:
            dwButtonFunction = PHONEBUTTONFUNCTION_REDIRECT;
            break;

        case PBF_REJECT:
            dwButtonFunction = PHONEBUTTONFUNCTION_REJECT;
            break;

        case PBF_REPDIAL:
            dwButtonFunction = PHONEBUTTONFUNCTION_REPDIAL;
            break;

        case PBF_RINGAGAIN:
            dwButtonFunction = PHONEBUTTONFUNCTION_RINGAGAIN;
            break;

        case PBF_SAVEREPEAT:
            dwButtonFunction = PHONEBUTTONFUNCTION_SAVEREPEAT;
            break;

        case PBF_SELECTRING:
            dwButtonFunction = PHONEBUTTONFUNCTION_SELECTRING;
            break;

        case PBF_SETREPDIAL:
            dwButtonFunction = PHONEBUTTONFUNCTION_SETREPDIAL;
            break;

        case PBF_SENDCALLS:
            dwButtonFunction = PHONEBUTTONFUNCTION_SENDCALLS;
            break;

        case PBF_SPEAKEROFF:
            dwButtonFunction = PHONEBUTTONFUNCTION_SPEAKEROFF;
            break;

        case PBF_SPEAKERON:
            dwButtonFunction = PHONEBUTTONFUNCTION_SPEAKERON;
            break;

        case PBF_STATIONSPEED:
            dwButtonFunction = PHONEBUTTONFUNCTION_STATIONSPEED;
            break;

        case PBF_SYSTEMSPEED:
            dwButtonFunction = PHONEBUTTONFUNCTION_SYSTEMSPEED;
            break;

        case PBF_TRANSFER:
            dwButtonFunction = PHONEBUTTONFUNCTION_TRANSFER;
            break;

        case PBF_UNKNOWN:
            dwButtonFunction = PHONEBUTTONFUNCTION_UNKNOWN;
            break;

        case PBF_VOLUMEDOWN:
            dwButtonFunction = PHONEBUTTONFUNCTION_VOLUMEDOWN;
            break;

        case PBF_VOLUMEUP:
            dwButtonFunction = PHONEBUTTONFUNCTION_VOLUMEUP;
            break;

        case PBF_SEND:
            dwButtonFunction = PHONEBUTTONFUNCTION_SEND;
            break;

        default:
            LOG((TL_ERROR, "put_ButtonFunction - bad ButtonFunction"));

            Unlock();
            
            ClientFree(pButtonInfo);
            pButtonInfo = NULL;

            return E_INVALIDARG;
    }

    //
    // put the value into the structure to be passed to tapisrv
    //

    pButtonInfo->dwButtonFunction = dwButtonFunction;

    //
    // set the new button function
    //

    hr = PhoneSetButtonInfo(m_hPhone, lButtonID, pButtonInfo);

    Unlock();

    //
    // free memory returned to us by PhoneGetButtonInfo
    //

    ClientFree(pButtonInfo);
    pButtonInfo = NULL;

    LOG((TL_TRACE, "put_ButtonFunction - exit - return %lx", hr ));

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_ButtonText
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhone::get_ButtonText(
    long lButtonID, 
    BSTR * ppButtonText
    )
{
    LPPHONEBUTTONINFO   pButtonInfo;
    HRESULT             hr;

    LOG((TL_TRACE, "get_ButtonText - enter" ));

    if ( TAPIIsBadWritePtr( ppButtonText, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_ButtonText - bad pointer"));

        return E_POINTER;
    }

    Lock();

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "get_ButtonText - phone not open"));
        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    //
    // Get the ButtonInfo buffer
    //
    hr = PhoneGetButtonInfo(
                        m_hPhone,
                        lButtonID,
                        &pButtonInfo
                       );

    if ( SUCCEEDED(hr) )
    {
        if ( pButtonInfo->dwButtonTextSize != 0 )
        {
            // 
            // Allocate the BSTR
            //
            *ppButtonText = SysAllocString( (LPWSTR)(((LPBYTE)(pButtonInfo)) + pButtonInfo->dwButtonTextOffset) );

            if ( NULL == *ppButtonText )
            {
                LOG((TL_ERROR, "get_ButtonText - SysAllocString Failed"));
                hr = E_OUTOFMEMORY;
            }
        } 
        else
        {
            LOG((TL_ERROR, "get_ButtonText - button has no text"));

            hr = E_FAIL;
        }

        //
        // Free the ButtonInfo buffer
        //
        ClientFree( pButtonInfo );
    }

    Unlock();

    LOG((TL_TRACE, "get_ButtonText - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_ButtonState
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhone::get_ButtonState(
    long lButtonID,
    PHONE_BUTTON_STATE * pButtonState
    )
{
    LPPHONEBUTTONINFO   pButtonInfo;
    HRESULT             hr;

    LOG((TL_TRACE, "get_ButtonState - enter" ));

    if ( TAPIIsBadWritePtr( pButtonState, sizeof(PHONE_BUTTON_STATE) ) )
    {
        LOG((TL_ERROR, "get_ButtonState - bad pointer"));

        return E_POINTER;
    }

    Lock();

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "get_ButtonState - phone not open"));
        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    //
    // Get the ButtonInfo buffer
    //
    hr = PhoneGetButtonInfo(
                        m_hPhone,
                        lButtonID,
                        &pButtonInfo
                       );

    if (FAILED(hr))
    {
        LOG((TL_ERROR, "get_ButtonState - failed to get get button info"));
        
        Unlock();

        return hr;
    }

    switch (pButtonInfo->dwButtonState)
    {
    case PHONEBUTTONSTATE_UP:
        *pButtonState = PBS_UP;
        break;
    case PHONEBUTTONSTATE_DOWN:
        *pButtonState = PBS_DOWN;
        break;
    case PHONEBUTTONSTATE_UNKNOWN:
        *pButtonState = PBS_UNKNOWN;
        break;
    case PHONEBUTTONSTATE_UNAVAIL:
        *pButtonState = PBS_UNAVAIL;
        break;
    default:
        LOG((TL_ERROR, "get_ButtonState - bad button state"));

        hr = E_FAIL;           
    }

    //
    // Free the ButtonInfo buffer
    //
    ClientFree( pButtonInfo );

    Unlock();

    LOG((TL_TRACE, "get_ButtonState - exit - return %lx", hr));
    
    return hr;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_LampMode
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhone::get_LampMode(
    long lLampID,
    PHONE_LAMP_MODE* pLampMode
    )
{
    LOG((TL_TRACE, "get_LampMode - enter" ));

    if ( TAPIIsBadWritePtr( pLampMode, sizeof(PHONE_LAMP_MODE) ) )
    {
        LOG((TL_ERROR, "get_LampMode - bad pointer"));

        return E_POINTER;
    }


    Lock();

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "get_LampMode - phone not open"));
        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    //
    // get lamp mode from tapisrv
    //

    DWORD dwLampMode = 0;

    HRESULT hr = PhoneGetLamp(m_hPhone, lLampID, &dwLampMode);

    Unlock();

    if (FAILED(hr))
    {
        LOG((TL_ERROR, "get_LampMode  - failed to get lamp mode - %lx", hr));

        return hr;
    }

    //
    // map the value returned by tapisrv to tapi3.x value
    //

    switch (dwLampMode)
    {
    case PHONELAMPMODE_DUMMY:
        *pLampMode = LM_DUMMY;
        break;

    case PHONELAMPMODE_BROKENFLUTTER:
        *pLampMode = LM_BROKENFLUTTER;
        break;

    case PHONELAMPMODE_FLASH:
        *pLampMode = LM_FLASH;
        break;

    case PHONELAMPMODE_FLUTTER:
        *pLampMode = LM_FLUTTER;
        break;

    case PHONELAMPMODE_OFF:
        *pLampMode = LM_OFF;
        break;

    case PHONELAMPMODE_STEADY:
        *pLampMode = LM_STEADY;
        break;

    case PHONELAMPMODE_UNKNOWN:
        *pLampMode = LM_UNKNOWN;
        break;

    case PHONELAMPMODE_WINK :
        *pLampMode = LM_WINK;
        break;

    default:
        LOG((TL_ERROR, "get_LampMode - bad lamp mode received from tapisrv"));

        return E_FAIL;           
    }

    LOG((TL_TRACE, "get_LampMode - exit - return S_OK"));
    
    return S_OK;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// put_LampMode
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhone::put_LampMode(
    long lLampID,
    PHONE_LAMP_MODE enLampMode
    )
{

    LOG((TL_TRACE, "put_LampMode - enter" ));

    Lock();

    //
    // Make sure the phone is open with owner privilege.
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "put_LampMode - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    if ( m_dwPrivilege != PHONEPRIVILEGE_OWNER )
    {
        LOG((TL_ERROR, "put_LampMode - wrong phone privilege - "
                                 "exit TAPI_E_NOTOWNER"));

        Unlock();

        return TAPI_E_NOTOWNER;
    }

    //
    // map PHONE_LAMP_MODE to the dword value understood by tapisrv
    //

    DWORD dwLampMode = 0;

    switch (enLampMode)
    {
    case LM_DUMMY:
        dwLampMode = PHONELAMPMODE_DUMMY;
        break;

    case LM_BROKENFLUTTER:
        dwLampMode = PHONELAMPMODE_BROKENFLUTTER;
        break;

    case LM_FLASH:
        dwLampMode = PHONELAMPMODE_FLASH;
        break;

    case LM_FLUTTER:
        dwLampMode = PHONELAMPMODE_FLUTTER;
        break;

    case LM_OFF:
        dwLampMode = PHONELAMPMODE_OFF;
        break;

    case LM_STEADY:
        dwLampMode = PHONELAMPMODE_STEADY;
        break;

    case LM_UNKNOWN:
        dwLampMode = PHONELAMPMODE_UNKNOWN;
        break;

    case LM_WINK:
        dwLampMode = PHONELAMPMODE_WINK;
        break;

    default:
        LOG((TL_ERROR, "put_LampMode - unknown lamp mode"));

        Unlock();

        return E_INVALIDARG;           
    }

    
    //
    // make a call to tapisrv to set lamp mode
    //
    
    HRESULT hr = PhoneSetLamp(m_hPhone, lLampID, dwLampMode);

    Unlock();

    LOG((TL_TRACE, "put_LampMode - exit - return %lx", hr ));

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_HookSwitchState
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhone::get_HookSwitchState(
    PHONE_HOOK_SWITCH_DEVICE HookSwitchDevice,
    PHONE_HOOK_SWITCH_STATE * pHookSwitchState
    )
{
    HRESULT         hr;
    LPPHONESTATUS   pPhoneStatus;
    DWORD           dwHookSwitchMode;

    LOG((TL_TRACE, "get_HookSwitchState - enter" ));

    if ( 0 == HookSwitchDevice )
    {
        LOG((TL_ERROR, "get_HookSwitchState - invalid hookswitch"));
        
        return E_INVALIDARG;
    }

    if ( TAPIIsBadWritePtr( pHookSwitchState, sizeof(PHONE_HOOK_SWITCH_STATE) ) )
    {
        LOG((TL_ERROR, "get_HookSwitchState - bad pointer"));

        return E_POINTER;
    }

    Lock();

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "get_HookSwitchState - phone not open"));
        Unlock();
        
        return TAPI_E_PHONENOTOPEN;
    }

    //
    // Update the phone caps cache
    //
    hr = UpdatePhoneCaps();

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "get_HookSwitchState - could not get phonecaps - %lx", hr));

        Unlock();
        
        return hr;
    }

    if ( !(m_pPhoneCaps->dwHookSwitchDevs & HookSwitchDevice) )
    {
        LOG((TL_ERROR, "get_HookSwitchState - invalid hookswitch"));
        Unlock();
        
        return TAPI_E_RESOURCEUNAVAIL;
    }

    //
    // Get the PhoneStatus buffer
    //
    hr = PhoneGetStatusWithAlloc(m_hPhone, &pPhoneStatus);

    if ( SUCCEEDED(hr) )
    {
        //
        // get the proper hookswitch mode from the phone status struct
        //
        switch (HookSwitchDevice)
        {
        case PHSD_HANDSET:
            dwHookSwitchMode = pPhoneStatus->dwHandsetHookSwitchMode;
            break;
        case PHSD_SPEAKERPHONE:
            dwHookSwitchMode = pPhoneStatus->dwSpeakerHookSwitchMode;
            break;
        case PHSD_HEADSET:
            dwHookSwitchMode = pPhoneStatus->dwHeadsetHookSwitchMode;
            break;
        default:
            LOG((TL_ERROR, "get_HookSwitchState - bad HookSwitchDevice"));

            hr = E_INVALIDARG;
        }        
    }

    if ( pPhoneStatus != NULL )
    {
        //
        // Free the PhoneStatusBuffer
        // 
        ClientFree( pPhoneStatus );
    }

    if ( SUCCEEDED(hr) )
    {
        //
        // translate the hookswitch mode to a tapi3 value
        //
        switch (dwHookSwitchMode)
        {
        case PHONEHOOKSWITCHMODE_ONHOOK:
            *pHookSwitchState = PHSS_ONHOOK;
            break;
        case PHONEHOOKSWITCHMODE_MIC:
            *pHookSwitchState = PHSS_OFFHOOK_MIC_ONLY;
            break;
        case PHONEHOOKSWITCHMODE_SPEAKER:
            *pHookSwitchState = PHSS_OFFHOOK_SPEAKER_ONLY;
            break;
        case PHONEHOOKSWITCHMODE_MICSPEAKER:
            *pHookSwitchState = PHSS_OFFHOOK;
            break;

        default:
            LOG((TL_ERROR, "get_HookSwitchState - bad dwHookSwitchMode"));

            hr = E_FAIL;
        }
    }

    Unlock();

    LOG((TL_TRACE, "get_HookSwitchState - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// put_HookSwitchState
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhone::put_HookSwitchState(
    PHONE_HOOK_SWITCH_DEVICE HookSwitchDevice,
    PHONE_HOOK_SWITCH_STATE HookSwitchState
    )
{
    DWORD   dwHookSwitchMode;
    HRESULT hr;

    LOG((TL_TRACE, "put_HookSwitchState - enter" ));

    if ( 0 == HookSwitchDevice )
    {
        LOG((TL_ERROR, "put_HookSwitchState - invalid hookswitch"));
        
        return E_INVALIDARG;
    }

    Lock();

    //
    // Make sure the phone is open with owner privilege.
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "put_HookSwitchState - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    if ( m_dwPrivilege != PHONEPRIVILEGE_OWNER )
    {
        LOG((TL_ERROR, "put_HookSwitchState - wrong phone privilege - "
                                 "exit TAPI_E_NOTOWNER"));

        Unlock();

        return TAPI_E_NOTOWNER;
    }

    //
    // Update the phone caps cache
    //
    hr = UpdatePhoneCaps();

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "put_HookSwitchState - could not get phonecaps - %lx", hr));

        Unlock();
        
        return hr;
    }

    if ( !(m_pPhoneCaps->dwHookSwitchDevs & HookSwitchDevice) )
    {
        LOG((TL_ERROR, "put_HookSwitchState - invalid hookswitch"));
        Unlock();
        
        return TAPI_E_RESOURCEUNAVAIL;
    }

    //
    // Translate the hookswithstate from tapi3 to tapi2 values
    //
    switch (HookSwitchState)
    {
    case PHSS_ONHOOK:
        dwHookSwitchMode = PHONEHOOKSWITCHMODE_ONHOOK;
        break;

    case PHSS_OFFHOOK_MIC_ONLY:
        dwHookSwitchMode = PHONEHOOKSWITCHMODE_MIC;
        break;

    case PHSS_OFFHOOK_SPEAKER_ONLY:
        dwHookSwitchMode = PHONEHOOKSWITCHMODE_SPEAKER;
        break;

    case PHSS_OFFHOOK:
        dwHookSwitchMode = PHONEHOOKSWITCHMODE_MICSPEAKER;
        break;

    default:
        LOG((TL_ERROR, "put_HookSwitchState - bad HookSwitchMode"));
        Unlock();

        return E_INVALIDARG;
    }
    
    //
    // Set the proper hookswitch
    //
    switch (HookSwitchDevice)
    {
    case PHSD_HANDSET:
        hr = PhoneSetHookSwitch(m_hPhone, PHONEHOOKSWITCHDEV_HANDSET, dwHookSwitchMode);
        break;

    case PHSD_SPEAKERPHONE:
        hr = PhoneSetHookSwitch(m_hPhone, PHONEHOOKSWITCHDEV_SPEAKER, dwHookSwitchMode);
        break;

    case PHSD_HEADSET:
        hr = PhoneSetHookSwitch(m_hPhone, PHONEHOOKSWITCHDEV_HEADSET, dwHookSwitchMode);
        break;

    default:
        LOG((TL_ERROR, "put_HookSwitchState - bad HookSwitchDevice"));

        hr = E_INVALIDARG;
    }

    Unlock();

    LOG((TL_TRACE, "put_HookSwitchState - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// put_RingMode
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhone::put_RingMode(
    long lRingMode
    )
{
    HRESULT hr;
    DWORD   dwDummy;
    DWORD   dwVolume;

    LOG((TL_TRACE, "put_RingMode - enter" ));

    Lock();

    //
    // Make sure the phone is open with owner privilege.
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "put_RingMode - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    if ( m_dwPrivilege != PHONEPRIVILEGE_OWNER )
    {
        LOG((TL_ERROR, "put_RingMode - wrong phone privilege - "
                                 "exit TAPI_E_NOTOWNER"));

        Unlock();

        return TAPI_E_NOTOWNER;
    }

    hr = PhoneGetRing(m_hPhone, &dwDummy, &dwVolume);

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "put_RingMode - PhoneGetRing failed"));
        Unlock();
        
        return hr;
    }
    
    hr = PhoneSetRing(m_hPhone, lRingMode, dwVolume );

    Unlock();

    LOG((TL_TRACE, "put_RingMode - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_RingMode
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhone::get_RingMode(
    long * plRingMode
    )
{
    HRESULT hr;
    DWORD   dwDummy;

    LOG((TL_TRACE, "get_RingMode - enter" ));

    if ( TAPIIsBadWritePtr( plRingMode, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_RingMode - bad pointer"));

        return E_POINTER;
    }

    Lock();

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "get_RingMode - phone not open"));
        Unlock();
        
        return TAPI_E_PHONENOTOPEN;
    }
    
    hr = PhoneGetRing(m_hPhone, (LPDWORD)plRingMode, &dwDummy);

    Unlock();

    LOG((TL_TRACE, "get_RingMode - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// put_RingVolume
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhone::put_RingVolume(
    long lRingVolume
    )
{
    HRESULT hr;
    DWORD dwDummy;
    DWORD dwMode;

    LOG((TL_TRACE, "put_RingVolume - enter" ));

    Lock();

    //
    // Make sure the phone is open with owner privilege.
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "put_RingVolume - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    if ( m_dwPrivilege != PHONEPRIVILEGE_OWNER )
    {
        LOG((TL_ERROR, "put_RingVolume - wrong phone privilege - "
                                 "exit TAPI_E_NOTOWNER"));

        Unlock();

        return TAPI_E_NOTOWNER;
    }

    hr = PhoneGetRing(m_hPhone, &dwMode, &dwDummy);

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "put_RingVolume - PhoneGetRing failed"));
        Unlock();
        
        return hr;
    }
    
    hr = PhoneSetRing(m_hPhone, dwMode, lRingVolume );

    Unlock();

    LOG((TL_TRACE, "put_RingVolume - exit" ));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_RingVolume
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhone::get_RingVolume(
    long * plRingVolume
    )
{
    HRESULT hr;
    DWORD   dwDummy;

    LOG((TL_TRACE, "get_RingVolume - enter" ));

    if ( TAPIIsBadWritePtr( plRingVolume, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_RingVolume - bad pointer"));

        return E_POINTER;
    }

    Lock();

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "get_RingVolume - phone not open"));
        Unlock();
        
        return TAPI_E_PHONENOTOPEN;
    }
    
    hr = PhoneGetRing(m_hPhone, &dwDummy, (LPDWORD)plRingVolume );

    Unlock();

    LOG((TL_TRACE, "get_RingVolume - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Privilege
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhone::get_Privilege(
    PHONE_PRIVILEGE * pPrivilege
    )
{
    HRESULT hr = S_OK;

    LOG((TL_TRACE, "get_Privilege - enter" ));

    if ( TAPIIsBadWritePtr( pPrivilege, sizeof(PHONE_PRIVILEGE) ) )
    {
        LOG((TL_ERROR, "get_Privilege - bad pointer"));

        return E_POINTER;
    }

    Lock();

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "get_Privilege - phone not open"));
        Unlock();
        
        return TAPI_E_PHONENOTOPEN;
    }

    switch(m_dwPrivilege)
    {
    case PHONEPRIVILEGE_OWNER:
        *pPrivilege = PP_OWNER;
        break;
    case PHONEPRIVILEGE_MONITOR:
        *pPrivilege = PP_MONITOR;
        break;
    default:
        _ASSERTE(FALSE);
        hr = E_UNEXPECTED;
        break;
    }

    Unlock();

    LOG((TL_TRACE, "get_Privilege - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Initialize
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CPhone::Initialize(
                   ITTAPI * pTAPI,
                   HPHONEAPP hPhoneApp,
                   DWORD dwAPIVersion,
                   DWORD dwDeviceID
                  )
{
    LPVARSTRING         pVarString = NULL;
    LONG                lResult;
    T3PHONE             t3Phone;
    HRESULT             hr;

    LOG((TL_TRACE, "Initialize - enter" ));
    LOG((TL_INFO, "   hPhoneApp --------->%lx", hPhoneApp ));
    LOG((TL_INFO, "   dwAPIVersion ------>%lx", dwAPIVersion ));
    LOG((TL_INFO, "   dwDeviceID -------->%lx", dwDeviceID ));


    Lock();
            
    //
    // save relevant info
    //
    m_pTAPI                         = NULL;
    m_dwDeviceID                    = dwDeviceID;
    m_hPhoneApp                     = hPhoneApp;
    m_dwAPIVersion                  = dwAPIVersion;
    m_pPhoneCaps                    = NULL;
    m_hPhone                        = NULL;
    m_pdwLineDeviceIDs              = NULL;
    m_dwNumLineDeviceIDs            = 0;

    try
    {
        InitializeCriticalSection( &m_csAutomatedPhoneState );
    }
    catch(...)
    {
        LOG((TL_ERROR, "Initialize - out of memory" ));
   
        Unlock();
        return E_OUTOFMEMORY;
    }

    try
    {
        InitializeCriticalSection( &m_csToneTimer );
    }
    catch(...)
    {
        LOG((TL_ERROR, "Initialize - out of memory" ));

        DeleteCriticalSection( &m_csAutomatedPhoneState );
   
        Unlock();
        return E_OUTOFMEMORY;
    }

    try
    {        
        InitializeCriticalSection( &m_csRingTimer );
    }
    catch(...)
    {
        LOG((TL_ERROR, "Initialize - out of memory" ));

        DeleteCriticalSection( &m_csAutomatedPhoneState );
        DeleteCriticalSection( &m_csToneTimer );

        Unlock();
        return E_OUTOFMEMORY;
    }

    //
    // allocate a buffer for the numbers gathered
    //
    m_wszNumbersGathered = (LPWSTR)ClientAlloc( (APC_MAX_NUMBERS_GATHERED + 1) * sizeof( WCHAR ) );

    if (m_wszNumbersGathered == NULL)
    {
        LOG((TL_ERROR, "Initialize - out of memory" ));

        DeleteCriticalSection( &m_csAutomatedPhoneState );
        DeleteCriticalSection( &m_csToneTimer );
        DeleteCriticalSection( &m_csRingTimer );

        Unlock();
        return E_OUTOFMEMORY;
    }

    //
    // get line device ids associated with this phone
    // we need to open the phone device to do this
    //

    t3Phone.hPhone = NULL;
    t3Phone.pPhone = this;

    hr = PhoneOpen(m_hPhoneApp, m_dwDeviceID, &t3Phone, m_dwAPIVersion, PHONEPRIVILEGE_MONITOR);

    if ( SUCCEEDED(hr) )
    {
        hr = PhoneGetID(
                       t3Phone.hPhone,
                       &pVarString,
                       L"tapi/line"
                      );

        PhoneClose(t3Phone.hPhone);

        if ( SUCCEEDED(hr) )
        {
            m_pdwLineDeviceIDs = (DWORD *)ClientAlloc( pVarString->dwUsedSize );

            if (m_pdwLineDeviceIDs == NULL)
            {
                LOG((TL_ERROR, "Initialize - out of memory" ));               
    
                ClientFree( pVarString );

                ClientFree( m_wszNumbersGathered );
                m_wszNumbersGathered = NULL;

                DeleteCriticalSection( &m_csAutomatedPhoneState );
                DeleteCriticalSection( &m_csToneTimer );
                DeleteCriticalSection( &m_csRingTimer );

                Unlock();
                return E_OUTOFMEMORY;
            }

            CopyMemory(
                       m_pdwLineDeviceIDs,
                       ((LPBYTE)pVarString)+pVarString->dwStringOffset,
                       pVarString->dwStringSize
                      );

            m_dwNumLineDeviceIDs = pVarString->dwStringSize / sizeof(DWORD);

            LOG((TL_INFO, "   dwNumLineDeviceIDs -->%lx", m_dwNumLineDeviceIDs ));
        }
    
        if ( NULL != pVarString )
        {
            ClientFree( pVarString );
        }
    }
    else
    {
        LOG((TL_ERROR, "Initialize - PhoneOpen failed %lx", hr ));

        ClientFree( m_wszNumbersGathered );
        m_wszNumbersGathered = NULL;

        DeleteCriticalSection( &m_csAutomatedPhoneState );
        DeleteCriticalSection( &m_csToneTimer );
        DeleteCriticalSection( &m_csRingTimer );

        Unlock();
        return hr;
    }

    m_hTimerQueue = CreateTimerQueue();

    if (m_hTimerQueue == NULL)
    {
        LOG((TL_ERROR, "Initialize - CreateTimerQueue failed %lx", hr ));

        ClientFree( m_wszNumbersGathered );   
        m_wszNumbersGathered = NULL;

        if (m_pdwLineDeviceIDs != NULL)
        {
            ClientFree( m_pdwLineDeviceIDs );
            m_pdwLineDeviceIDs = NULL;
        }

        DeleteCriticalSection( &m_csAutomatedPhoneState );
        DeleteCriticalSection( &m_csToneTimer );
        DeleteCriticalSection( &m_csRingTimer );

        Unlock();
        return E_OUTOFMEMORY;
    }

    m_hTimerEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (m_hTimerEvent == NULL)
    {
        LOG((TL_ERROR, "Initialize - CreateEvent failed %lx", hr ));

        ClientFree( m_wszNumbersGathered );
        m_wszNumbersGathered = NULL;

        if (m_pdwLineDeviceIDs != NULL)
        {
            ClientFree( m_pdwLineDeviceIDs );
            m_pdwLineDeviceIDs = NULL;
        }

        DeleteCriticalSection( &m_csAutomatedPhoneState );
        DeleteCriticalSection( &m_csToneTimer );
        DeleteCriticalSection( &m_csRingTimer );
        
        DeleteTimerQueue( m_hTimerQueue );
        m_hTimerQueue = NULL;

        Unlock();
        return E_OUTOFMEMORY;
    }  
    
    AddRef();
    
    // 
    // Save a pointer to TAPI
    //
    m_pTAPI = pTAPI;
    m_pTAPI->AddRef();

    m_fInitialized = TRUE;
    

    Unlock();

    LOG((TL_TRACE, S_OK, "Initialize - exit"));

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// FinalRelease
//      Clean up anything in the phone object.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void CPhone::FinalRelease()
{
    LOG((TL_TRACE, "FinalRelease enter, this %p", this ));

    Lock();

    if (m_fInitialized == TRUE)
    {
        //
        // Deallocate the phone caps cache
        //
        InvalidatePhoneCaps();   

        //
        // Close the phone if it is open
        //
        if ( m_hPhone != NULL )
        {
            if (m_dwPrivilege == PHONEPRIVILEGE_OWNER)
            {
                if (m_fRinger == TRUE) 
                {
                    StopRinger();
                }

                if (m_Tone != PT_SILENCE)
                {
                    StopTone();
                }

                CloseWaveDevice();
            }

            PhoneClose(m_hPhone);
        }

        //
        // Delete timers
        //
        if (m_hTimerQueue != NULL)
        {
            DeleteTimerQueue(m_hTimerQueue);
            m_hTimerQueue = NULL;
        }

        if (m_hTimerEvent != NULL)
        {
            CloseHandle( m_hTimerEvent );
            m_hTimerEvent = NULL;
        }

        //
        // Deallocate memory
        //
        if (m_wszNumbersGathered != NULL)
        {
            ClientFree( m_wszNumbersGathered );
            m_wszNumbersGathered = NULL;
        }

        if (m_pdwLineDeviceIDs != NULL)
        {
            ClientFree( m_pdwLineDeviceIDs );
            m_pdwLineDeviceIDs = NULL;
        }

        DeleteCriticalSection( &m_csAutomatedPhoneState );
        DeleteCriticalSection( &m_csToneTimer );
        DeleteCriticalSection( &m_csRingTimer );

        if ( m_pCall != NULL )
        {
            m_pCall->Release();
            m_pCall = NULL;
        }

        //
        // Release our refernece to the Tapi object
        //
        if (m_pTAPI != NULL)
        {
            m_pTAPI->Release();
            m_pTAPI = NULL;
        }
    }

    Unlock();

    LOG((TL_TRACE, "FinalRelease - exit, this %p", this  ));
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// SetPhoneCapsBuffer
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void
CPhone::SetPhoneCapBuffer( LPVOID pBuf )
{
    Lock();

    //
    // This allow the phone caps cache to notify us that our phone
    // caps buffer has changed (or more likely it will pass us NULL
    // to say out buffer has been destroyed)
    //
    m_pPhoneCaps = (LPPHONECAPS)pBuf;
    
    Unlock();
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// UpdatePhoneCaps
//
// must be called in lock
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT
CPhone::UpdatePhoneCaps()
{
    HRESULT             hr = S_OK;

    //
    // Only do something if we don't have a current phone caps buffer
    //
    if ( NULL == m_pPhoneCaps )
    {
        LPPHONECAPS           pTemp;
        CTAPI                 * pCTapi;

        pCTapi = GetTapi();
        
        if( NULL == pCTapi )
        {
            LOG((TL_ERROR, "UpdatePhoneCaps - dynamic cast operation failed"));

            _ASSERTE(FALSE);

            hr = E_UNEXPECTED;
        }
        else
        {
            //
            // Get a new buffer from the cache
            //
            hr = pCTapi->GetBuffer( BUFFERTYPE_PHONECAP,
                                    (UINT_PTR)this,
                                    (LPVOID*)&m_pPhoneCaps
                                  );
        }

        if ( FAILED(hr) )
        {
            LOG((TL_ERROR, "UpdatePhoneCaps - GetBuffer failed - %lx", hr));
            m_pPhoneCaps = NULL;

            return hr;
        }

        pTemp = m_pPhoneCaps;
        
        //
        // Get the phone caps from tapi2
        //
        hr = PhoneGetDevCaps(
                            m_hPhoneApp,
                            m_dwDeviceID,
                            m_dwAPIVersion,
                            &m_pPhoneCaps
                           );

        if ( FAILED(hr) )
        {
            LOG((TL_ERROR, "UpdatePhoneCaps - PhoneGetDevCaps failed - %lx", hr));

            //
            // Invalidate our buffer which is no good
            //

            InvalidatePhoneCaps();

            return hr;
        }

        //
        // PhoneGetDevsCaps may have reallocated our buffer. If so, tell the tapiobject
        // cache mechanism what our new buffer is.
        //

        if ( m_pPhoneCaps != pTemp )
        {
            pCTapi->SetBuffer( BUFFERTYPE_PHONECAP, (UINT_PTR)this, (LPVOID)m_pPhoneCaps );
        }
    }

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// InvalidatePhoneCaps
//
// must be called in lock
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT
CPhone::InvalidatePhoneCaps()
{  
    HRESULT hr = S_OK;

    if ( NULL != m_pPhoneCaps )
    {
        CTAPI  * pCTapi;

        pCTapi = GetTapi();
        
        if( NULL == pCTapi )
        {
            LOG((TL_ERROR, "InvalidatePhoneCaps - dynamic cast operation failed"));

            _ASSERTE(FALSE);

            hr = E_UNEXPECTED;
        }
        else
        {
            pCTapi->InvalidateBuffer( BUFFERTYPE_PHONECAP, (UINT_PTR)this );
        }
        
        m_pPhoneCaps = NULL;
    }

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// IsPhoneOnAddress
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

BOOL
CPhone::IsPhoneOnAddress(ITAddress *pAddress)
{
    BOOL                bResult = FALSE;
    HRESULT             hr;
    ITTerminalSupport * pTerminalSupport;
    ITMediaSupport    * pMediaSupport;
    LONG                lMediaType;

    Lock();

    //
    // Update phone caps cache
    //

    hr = UpdatePhoneCaps();

    if ( FAILED(hr) )
    {
        Unlock();

        LOG((TL_ERROR, "IsPhoneOnAddress - UpdatePhoneCaps failed %lx", hr ));
        return FALSE;
    }

    if ( (m_dwAPIVersion >= TAPI_VERSION2_0) && (m_pPhoneCaps->dwPhoneFeatures & PHONEFEATURE_GENERICPHONE) )
    {
        //
        // We are a generic phone, therefore we
        // are on any address that has a MSP and audio media types.
        //

        //
        // get the terminal support interface
        //

        hr = pAddress->QueryInterface(
                                      IID_ITTerminalSupport,
                                      (void **)&pTerminalSupport
                                     );

        if ( FAILED(hr) )
        {
            Unlock();

            LOG((TL_ERROR, "IsPhoneOnAddress - QueryInterface IID_ITTerminalSupport failed %lx", hr ));
            return FALSE;
        }

        pTerminalSupport->Release();

        //
        // get the media support interface
        //
        hr = pAddress->QueryInterface(
                                      IID_ITMediaSupport,
                                      (void **)&pMediaSupport
                                     );

        if ( FAILED(hr) )
        {
            Unlock();

            LOG((TL_ERROR, "IsPhoneOnAddress - QueryInterface IID_ITMediaSupport failed %lx", hr ));
            return FALSE;
        }

        //
        // get the mediatype
        //
        hr = pMediaSupport->get_MediaTypes(&lMediaType);

        pMediaSupport->Release();

        if ( FAILED(hr) )
        {
            Unlock();

            LOG((TL_ERROR, "IsPhoneOnAddress - get_MediaTypes failed %lx", hr ));
            return FALSE;
        }

        //
        // make sure address supports audio
        //
        if (lMediaType & (LINEMEDIAMODE_INTERACTIVEVOICE | LINEMEDIAMODE_AUTOMATEDVOICE))
        {
            bResult = TRUE;
        }
    }

    //
    // If we haven't already decided that we support this address
    // check to see if this a preferred address.
    //

    if ( bResult == FALSE )
    {
        bResult = IsPhoneOnPreferredAddress(pAddress);
    }

    Unlock();

    return bResult;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// IsPhoneOnPreferredAddress
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

BOOL
CPhone::IsPhoneOnPreferredAddress(ITAddress *pAddress)
{
    BOOL                bResult = FALSE;
    HRESULT             hr;
    CAddress          * pCAddress;

    Lock();

    if ( m_dwNumLineDeviceIDs > 0 )
    {
        //
        // Check out list of line device IDs to see if we are 
        // preferred on this address
        //

        pCAddress = dynamic_cast<CAddress *>(pAddress);

        if (NULL == pCAddress)
        {
            Unlock();

            LOG((TL_ERROR, "IsPhoneOnPreferredAddress - dynamic cast failed" ));
            return FALSE;
        }

        for (int i = 0; i < m_dwNumLineDeviceIDs; i++ )
        {
            if ( m_pdwLineDeviceIDs[i] == pCAddress->GetDeviceID() ) 
            {
                //
                // Yes, we matched this device ID to one in our list
                //
                bResult = TRUE;
                break;
            }
        }
    }

    Unlock();

    return bResult;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// IsPhoneUsingWaveID
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

BOOL CPhone::IsPhoneUsingWaveID(DWORD dwWaveID, TERMINAL_DIRECTION nDir)
{
    T3PHONE     t3Phone;
    BOOL        bResult = FALSE;
    HRESULT     hr;
    LPVARSTRING pVarString = NULL;
    DWORD       dwPhoneWaveID;

    //
    // get wave device ids associated with this phone
    // we need to open the phone device to do this
    // Must use monitor privilege, because owner privilege open will
    // fail if anyone happens to have the phone open as owner.
    //

    t3Phone.hPhone = NULL;
    t3Phone.pPhone = this;

    Lock();

    hr = PhoneOpen(m_hPhoneApp, m_dwDeviceID, &t3Phone, m_dwAPIVersion, PHONEPRIVILEGE_MONITOR);

    if ( SUCCEEDED(hr) )
    {
        switch(nDir)
        {
        case TD_CAPTURE:
            {
                hr = PhoneGetID(
                               t3Phone.hPhone,
                               &pVarString,
                               L"wave/in"
                              );

                if ( SUCCEEDED(hr) )
                {
                    if (pVarString->dwStringSize == sizeof(DWORD))
                    {
                        CopyMemory(
                               &dwPhoneWaveID,
                               ((LPBYTE)pVarString)+pVarString->dwStringOffset,
                               pVarString->dwStringSize
                              );

                        if ( dwWaveID == dwPhoneWaveID )
                        {
                            LOG((TL_INFO, "IsPhoneUsingWaveID - matched phone wave capture id %d", dwPhoneWaveID ));
                            bResult = TRUE;
                        }
                    }
                }
                break;
            }

        case TD_RENDER:
            {
                hr = PhoneGetID(
                               t3Phone.hPhone,
                               &pVarString,
                               L"wave/out"
                              );

                if ( SUCCEEDED(hr) )
                {
                    if (pVarString->dwStringSize == sizeof(DWORD))
                    {
                        CopyMemory(
                               &dwPhoneWaveID,
                               ((LPBYTE)pVarString)+pVarString->dwStringOffset,
                               pVarString->dwStringSize
                              );

                        if ( dwWaveID == dwPhoneWaveID )
                        {
                            LOG((TL_INFO, "IsPhoneUsingWaveID - matched phone wave render id %d", dwPhoneWaveID ));
                            bResult = TRUE;
                        }
                    }
                }
                break;
            }
        }

        if ( NULL != pVarString )
        {
            ClientFree( pVarString );
        }

        PhoneClose(t3Phone.hPhone);
    }
    else
    {
        LOG((TL_ERROR, "IsPhoneUsingWaveID - PhoneOpen failed %lx", hr ));
    }

    Unlock();

    return bResult;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetTapi
//
// private method to get the tapi object
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CTAPI *
CPhone::GetTapi()
{
    CTAPI * p = NULL;

    Lock();
    
    if( m_pTAPI != NULL )
    {
        p = dynamic_cast<CTAPI *>(m_pTAPI);
    }

    Unlock();

    return p;
}


//
// handle dev specific message
//

void HandlePhoneDevSpecificMessage(  PASYNCEVENTMSG pParams )
{

    LOG((TL_INFO, "HandlePhoneDevSpecificMessage - enter"));


    //
    // find the phone corresponding to this event
    //
    
    CPhone *pPhone = NULL;

    if (!FindPhoneObject((HPHONE)pParams->hDevice, &pPhone))
    {
        LOG((TL_WARN, "HandlePhoneDevSpecificMessage - FindPhoneObject failed to find matching phone."));
    
        return;
    }


    //
    // fire event
    //

    CPhoneDevSpecificEvent::FireEvent(
                             pPhone,
                             pParams->Param1,
                             pParams->Param2,
                             pParams->Param3
                            );

    //
    // undo findphoneobject's addref
    //

    pPhone->Release();
    pPhone = NULL;


    LOG((TL_INFO, "HandlePhoneDevSpecificMessage - exit. "));
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// HandlePhoneButtonMessage
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

HRESULT HandlePhoneButtonMessage( PASYNCEVENTMSG pParams )
{
    LOG((TL_TRACE, "HandlePhoneButtonMessage - enter"));
    
    CPhone * pCPhone;

    if (!FindPhoneObject((HPHONE)pParams->hDevice, &pCPhone))
    {
        LOG((TL_TRACE, "HandlePhoneButtonMessage - bad phone handle"));
        
        return E_FAIL;
    }

    switch ( pParams->Param3 )
    {
    case PHONEBUTTONSTATE_DOWN:

        //
        // Automation event hook
        //
        pCPhone->Automation_ButtonDown( pParams->Param1 );

        CPhoneEvent::FireEvent(
                               pCPhone, 
                               PE_BUTTON,
                               PBS_DOWN,
                               (PHONE_HOOK_SWITCH_STATE)0, 
                               (PHONE_HOOK_SWITCH_DEVICE)0, 
                               0,
                               pParams->Param1,
                               NULL,
                               NULL
                              );
        break;

    case PHONEBUTTONSTATE_UNAVAIL:
        CPhoneEvent::FireEvent(
                               pCPhone, 
                               PE_BUTTON,
                               PBS_UNAVAIL,
                               (PHONE_HOOK_SWITCH_STATE)0, 
                               (PHONE_HOOK_SWITCH_DEVICE)0, 
                               0,
                               pParams->Param1,
                               NULL,
                               NULL
                              );
        break;

    case PHONEBUTTONSTATE_UNKNOWN:
        CPhoneEvent::FireEvent(
                               pCPhone, 
                               PE_BUTTON,
                               PBS_UNKNOWN,
                               (PHONE_HOOK_SWITCH_STATE)0, 
                               (PHONE_HOOK_SWITCH_DEVICE)0, 
                               0,
                               pParams->Param1,
                               NULL,
                               NULL
                              );
        break;

    case PHONEBUTTONSTATE_UP:

        //
        // Automation event hook
        //
        pCPhone->Automation_ButtonUp( pParams->Param1 );

        CPhoneEvent::FireEvent(
                               pCPhone, 
                               PE_BUTTON,
                               PBS_UP,
                               (PHONE_HOOK_SWITCH_STATE)0, 
                               (PHONE_HOOK_SWITCH_DEVICE)0, 
                               0,
                               pParams->Param1,
                               NULL,
                               NULL
                              );
        break;

    }

    pCPhone->Release();

    LOG((TL_TRACE, "HandlePhoneButtonMessage - exit"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// HandlePhoneStateMessage
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

HRESULT HandlePhoneStateMessage( PASYNCEVENTMSG pParams )
{
    LOG((TL_TRACE, "HandlePhoneStateMessage - enter"));

    CPhone                   * pCPhone;
    PHONE_HOOK_SWITCH_STATE    HookSwitchState;

    if (!FindPhoneObject((HPHONE)pParams->hDevice, &pCPhone))
    {
        LOG((TL_TRACE, "HandlePhoneStateMessage - bad phone handle"));
        
        return E_FAIL;
    }

    switch( pParams->Param1 )  // PhoneState
    {
    case PHONESTATE_CAPSCHANGE:

        pCPhone->Lock();

        //
        // Phone caps have changed, so invalidate out cache
        //
        pCPhone->InvalidatePhoneCaps();

        pCPhone->Unlock();

        CPhoneEvent::FireEvent(
                               pCPhone, 
                               PE_CAPSCHANGE, 
                               (PHONE_BUTTON_STATE)0,
                               (PHONE_HOOK_SWITCH_STATE)0, 
                               (PHONE_HOOK_SWITCH_DEVICE)0,
                               0,
                               0, 
                               NULL,
                               NULL
                              );
        break;

    case PHONESTATE_HANDSETHOOKSWITCH:

        if ( pParams->Param2 == PHONEHOOKSWITCHMODE_ONHOOK )
        {
            //
            // Automation event hook
            //
            pCPhone->Automation_OnHook( PHSD_HANDSET );
        }
        else
        {
            //
            // Automation event hook
            //
            pCPhone->Automation_OffHook( PHSD_HANDSET );
        }

        switch (pParams->Param2)
        {
        case PHONEHOOKSWITCHMODE_ONHOOK:
            HookSwitchState = PHSS_ONHOOK;
            break;
        case PHONEHOOKSWITCHMODE_MIC:
            HookSwitchState = PHSS_OFFHOOK_MIC_ONLY;
            break;
        case PHONEHOOKSWITCHMODE_SPEAKER:
            HookSwitchState = PHSS_OFFHOOK_SPEAKER_ONLY;
            break;
        case PHONEHOOKSWITCHMODE_MICSPEAKER:
            HookSwitchState = PHSS_OFFHOOK;
            break;

        default:
            LOG((TL_ERROR, "HandlePhoneStateMessage - bad HookSwitchMode"));
            pCPhone->Release();
            return E_FAIL;
        }

        CPhoneEvent::FireEvent(
                               pCPhone,
                               PE_HOOKSWITCH,
                               (PHONE_BUTTON_STATE)0,
                               HookSwitchState,
                               PHSD_HANDSET,
                               0,
                               0, 
                               NULL,
                               NULL
                              );
        break;

    case PHONESTATE_HEADSETHOOKSWITCH:

        if ( pParams->Param2 == PHONEHOOKSWITCHMODE_ONHOOK )
        {
            //
            // Automation event hook
            //
            pCPhone->Automation_OnHook( PHSD_HEADSET );
        }
        else
        {
            //
            // Automation event hook
            //
            pCPhone->Automation_OffHook( PHSD_HEADSET );
        }

        switch (pParams->Param2)
        {
        case PHONEHOOKSWITCHMODE_ONHOOK:
            HookSwitchState = PHSS_ONHOOK;
            break;
        case PHONEHOOKSWITCHMODE_MIC:
            HookSwitchState = PHSS_OFFHOOK_MIC_ONLY;
            break;
        case PHONEHOOKSWITCHMODE_SPEAKER:
            HookSwitchState = PHSS_OFFHOOK_SPEAKER_ONLY;
            break;
        case PHONEHOOKSWITCHMODE_MICSPEAKER:
            HookSwitchState = PHSS_OFFHOOK;
            break;

        default:
            LOG((TL_ERROR, "HandlePhoneStateMessage - bad HookSwitchMode"));
            pCPhone->Release();
            return E_FAIL;
        }

        CPhoneEvent::FireEvent(
                               pCPhone,
                               PE_HOOKSWITCH,
                               (PHONE_BUTTON_STATE)0, 
                               HookSwitchState, 
                               PHSD_HEADSET, 
                               0,
                               0,
                               NULL,
                               NULL
                              );
        break;

    case PHONESTATE_LAMP:
        CPhoneEvent::FireEvent(
                               pCPhone,
                               PE_LAMPMODE,
                               (PHONE_BUTTON_STATE)0,
                               (PHONE_HOOK_SWITCH_STATE)0,
                               (PHONE_HOOK_SWITCH_DEVICE)0,
                               0,
                               pParams->Param2,
                               NULL,
                               NULL
                              );
        break;

    case PHONESTATE_RINGMODE:
        CPhoneEvent::FireEvent(
                               pCPhone,
                               PE_RINGMODE,
                               (PHONE_BUTTON_STATE)0,
                               (PHONE_HOOK_SWITCH_STATE)0,
                               (PHONE_HOOK_SWITCH_DEVICE)0,
                               pParams->Param2,
                               0,
                               NULL,
                               NULL
                              );
        break;

    case PHONESTATE_RINGVOLUME:
        CPhoneEvent::FireEvent(
                               pCPhone,
                               PE_RINGVOLUME,
                               (PHONE_BUTTON_STATE)0,
                               (PHONE_HOOK_SWITCH_STATE)0,
                               (PHONE_HOOK_SWITCH_DEVICE)0,
                               0,
                               0,
                               NULL,
                               NULL
                              );
        break;

    case PHONESTATE_SPEAKERHOOKSWITCH:

        if ( pParams->Param2 == PHONEHOOKSWITCHMODE_ONHOOK )
        {
            //
            // Automation event hook
            //
            pCPhone->Automation_OnHook( PHSD_SPEAKERPHONE );
        }
        else
        {
            //
            // Automation event hook
            //
            pCPhone->Automation_OffHook( PHSD_SPEAKERPHONE );
        }

        switch (pParams->Param2)
        {
        case PHONEHOOKSWITCHMODE_ONHOOK:
            HookSwitchState = PHSS_ONHOOK;
            break;
        case PHONEHOOKSWITCHMODE_MIC:
            HookSwitchState = PHSS_OFFHOOK_MIC_ONLY;
            break;
        case PHONEHOOKSWITCHMODE_SPEAKER:
            HookSwitchState = PHSS_OFFHOOK_SPEAKER_ONLY;
            break;
        case PHONEHOOKSWITCHMODE_MICSPEAKER:
            HookSwitchState = PHSS_OFFHOOK;
            break;

        default:
            LOG((TL_ERROR, "HandlePhoneStateMessage - bad HookSwitchMode"));
            pCPhone->Release();
            return E_FAIL;
        }

        CPhoneEvent::FireEvent(
                               pCPhone,
                               PE_HOOKSWITCH,
                               (PHONE_BUTTON_STATE)0,
                               HookSwitchState, 
                               PHSD_SPEAKERPHONE,
                               0, 
                               0,
                               NULL,
                               NULL
                              );
        break;

    case PHONESTATE_DISPLAY:
        CPhoneEvent::FireEvent(
                               pCPhone,
                               PE_DISPLAY, 
                               (PHONE_BUTTON_STATE)0,
                               (PHONE_HOOK_SWITCH_STATE)0,
                               (PHONE_HOOK_SWITCH_DEVICE)0,
                               0,
                               0,
                               NULL,
                               NULL
                              );
        break;

    default:
        LOG((TL_INFO, "HandlePhoneStateMessage - PHONE_STATE %lx event not handled", pParams->Param1));
    }

    pCPhone->Release();

    LOG((TL_TRACE, "HandlePhoneStateMessage - exit"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// HandlePhoneCloseMessage
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

HRESULT HandlePhoneCloseMessage( PASYNCEVENTMSG pParams )
{
    LOG((TL_TRACE, "HandlePhoneCloseMessage - enter"));

    CPhone * pCPhone;

    if (!FindPhoneObject((HPHONE)pParams->hDevice, &pCPhone))
    {
        LOG((TL_TRACE, "HandlePhoneCloseMessage - bad phone handle"));
        
        return E_FAIL;
    }

    pCPhone->ForceClose();

    pCPhone->Release();

    LOG((TL_TRACE, "HandlePhoneCloseMessage - exit"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ForceClose
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

void CPhone::ForceClose()
{
    Lock();

    //
    // If phone isn't open then get out of here
    //
    if ( m_hPhone == NULL )
    {
        Unlock();

        return;
    }

    Unlock();

    //
    // Close the phone
    //
    Close();

    //
    // Fire a PE_CLOSE event
    //
    CPhoneEvent::FireEvent(
                       this,
                       PE_CLOSE,
                       (PHONE_BUTTON_STATE)0,
                       (PHONE_HOOK_SWITCH_STATE)0,
                       (PHONE_HOOK_SWITCH_DEVICE)0,
                       0,
                       0,
                       NULL,
                       NULL
                      );
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ITAutomatedPhoneControl implementation
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// Automation_CallState
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CPhone::Automation_CallState( ITCallInfo * pCall, CALL_STATE cs, CALL_STATE_EVENT_CAUSE cause )
{
    LOG((TL_TRACE, "Automation_CallState - enter"));

    EnterCriticalSection(&m_csAutomatedPhoneState);

    LOG((TL_INFO, "Automation_CallState - phone[%p]",
        this));
    LOG((TL_INFO, "Automation_CallState - selected call [%p]",
        m_pCall));
    LOG((TL_INFO, "Automation_CallState - current phone state [%d]",
        m_AutomatedPhoneState));
    LOG((TL_INFO, "Automation_CallState - phone control enabled [%s]",
        m_fPhoneHandlingEnabled ? "TRUE" : "FALSE"));
    LOG((TL_INFO, "Automation_CallState - new call state [%d]",
        cs));

    if (m_fPhoneHandlingEnabled)
    {
        if ( pCall == m_pCall )
        {
            switch( cs )
            {

            case CS_IDLE:
                LOG((TL_INFO, "Automation_CallState - CS_IDLE"));
                break;

            case CS_INPROGRESS:
                LOG((TL_INFO, "Automation_CallState - CS_INPROGRESS"));
                switch(m_AutomatedPhoneState)
                {
                case APS_ONHOOK_IDLE:
                case APS_ONHOOK_RINGING_IN:
                    {
                        StartRinger( 0, 0 );

                        m_AutomatedPhoneState = APS_ONHOOK_RINGING_OUT;
                    }   
                    break;
                case APS_OFFHOOK_DIALTONE:
                case APS_OFFHOOK_WARNING:  
                case APS_OFFHOOK_DIALING:
                case APS_OFFHOOK_DEAD_LINE:
                case APS_OFFHOOK_CALL_INIT:
                case APS_OFFHOOK_BUSY_TONE:   
                    {
                        StartTone( PT_RINGBACK, 0);

                        m_AutomatedPhoneState = APS_OFFHOOK_RINGING_OUT;
                    }
                    break;
                }
                break;

            case CS_CONNECTED:
                LOG((TL_INFO, "Automation_CallState - CS_CONNECTED"));
                switch(m_AutomatedPhoneState)
                {
                case APS_OFFHOOK_CALL_INIT:                 
                    {
                        m_AutomatedPhoneState = APS_OFFHOOK_CONNECTED;
                    }
                    break;
                case APS_OFFHOOK_RINGING_OUT: 
                    { 
                        // stop ringback
                        StopTone();

                        m_AutomatedPhoneState = APS_OFFHOOK_CONNECTED;
                    }
                    break;
                case APS_ONHOOK_RINGING_OUT:
                    {
                        m_AutomatedPhoneState = APS_ONHOOK_CONNECTED;
                    }
                    break;
                case APS_ONHOOK_IDLE:
                    {
                        StartRinger( 0, 0 );

                        m_AutomatedPhoneState = APS_ONHOOK_CONNECTED;
                    }
                    break;
                case APS_ONHOOK_RINGING_IN:
                    {
                        m_AutomatedPhoneState = APS_ONHOOK_CONNECTED;
                    }
                    break;
                case APS_OFFHOOK_DIALTONE:
                case APS_OFFHOOK_WARNING:
                case APS_OFFHOOK_DIALING:
                case APS_OFFHOOK_DEAD_LINE:
                case APS_OFFHOOK_BUSY_TONE:
                    {
                        // An app shouldn't do this to us, but stop the
                        // tone and move to the connected state
                        StopTone();

                        m_AutomatedPhoneState = APS_OFFHOOK_CONNECTED;
                    }
                }
                break;

            case CS_DISCONNECTED:
                LOG((TL_INFO, "Automation_CallState - CS_DISCONNECTED"));
                switch(m_AutomatedPhoneState)
                {
                case APS_ONHOOK_RINGING_IN:
                case APS_ONHOOK_RINGING_OUT:
                case APS_ONHOOK_CONNECTED:
                    {
                        //
                        // Stop the ringer
                        //

                        if (m_fRinger == TRUE) 
                        {
                            StopRinger();
                        }

                        // unselect the call
                        InternalUnselectCall( pCall );

                        m_AutomatedPhoneState = APS_ONHOOK_IDLE;
                    }
                    break;
                case APS_ONHOOK_IDLE:
                    {
                        // unselect the call
                        InternalUnselectCall( pCall );
                    }
                    break;
                case APS_OFFHOOK_DIALTONE:
                case APS_OFFHOOK_DIALING:
                case APS_OFFHOOK_RINGING_OUT:
                case APS_OFFHOOK_CALL_INIT:
                case APS_OFFHOOK_CONNECTED:                
                    {
                        switch( cause )
                        {
                        case CEC_DISCONNECT_BUSY:
                            {
                                // start busy tone
                                StartTone( PT_BUSY, 0 );

                                m_AutomatedPhoneState = APS_OFFHOOK_BUSY_TONE;
                            }
                            break;
                        case CEC_DISCONNECT_NORMAL:
                            {
                                 // stop any playing tone
                                StopTone();

                                m_AutomatedPhoneState = APS_OFFHOOK_DEAD_LINE;
                            }
                            break;
                        default:
                            {
                                // start error tone
                                StartTone( PT_ERRORTONE, 0 );

                                m_AutomatedPhoneState = APS_OFFHOOK_WARNING;
                            }
                        }

                        // unselect the call
                        InternalUnselectCall( pCall );
                    }
                    break;             
                }
                break;

            case CS_OFFERING:
                LOG((TL_INFO, "Automation_CallState - CS_OFFERING"));
                switch(m_AutomatedPhoneState)
                {
                case APS_ONHOOK_IDLE:
                case APS_ONHOOK_RINGING_OUT:
                    {
                        StartRinger( 0, 0 );

                        m_AutomatedPhoneState = APS_ONHOOK_RINGING_IN;
                    }
                    break;
                case APS_OFFHOOK_DIALTONE:
                case APS_OFFHOOK_WARNING:  
                case APS_OFFHOOK_DIALING:
                case APS_OFFHOOK_DEAD_LINE:
                case APS_OFFHOOK_CALL_INIT:
                case APS_OFFHOOK_BUSY_TONE:
                    {
                        StopTone();

                        ITBasicCallControl * pCallBCC;
                        ITCallInfo         * pCall;

                        HRESULT hr;

                        pCall = m_pCall;
                        pCall->AddRef();                        

                        hr = pCall->QueryInterface( IID_ITBasicCallControl,
                                                    (void **) & pCallBCC );

                        if ( SUCCEEDED(hr) )
                        {
                            LeaveCriticalSection(&m_csAutomatedPhoneState);

                            hr = pCallBCC->Answer();

                            pCallBCC->Release();
                            
                            if ( FAILED(hr) )
                            {
                                LOG((TL_ERROR, "Automation_CallState - Answer failed %08x", hr ));
                            }
                            else
                            {
                                CPhoneEvent::FireEvent(
                                   this,
                                   PE_ANSWER,
                                   (PHONE_BUTTON_STATE)0,
                                   (PHONE_HOOK_SWITCH_STATE)0,
                                   (PHONE_HOOK_SWITCH_DEVICE)0,
                                   0,
                                   0,
                                   NULL,
                                   pCall
                                  );
                            }  

                            pCall->Release();
                            
                            EnterCriticalSection(&m_csAutomatedPhoneState);
                        }

                        m_AutomatedPhoneState = APS_OFFHOOK_CALL_INIT;
                    }
                    break;
                }
                break;

            case CS_HOLD:
                LOG((TL_INFO, "Automation_CallState - CS_HOLD"));
                break;

            case CS_QUEUED:
                LOG((TL_INFO, "Automation_CallState - CS_QUEUED"));
                break;
            }            
        }
    } //m_fPhoneHandlingEnabled

    LOG((TL_INFO, "Automation_CallState - new phone state [%d]",
        m_AutomatedPhoneState));

    LeaveCriticalSection(&m_csAutomatedPhoneState);

    LOG((TL_TRACE, "Automation_CallState - exit"));
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// Automation_EndOfNumberTimeout
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CPhone::Automation_EndOfNumberTimeout()
{
    LOG((TL_TRACE, "Automation_EndOfNumberTimeout - enter"));

    EnterCriticalSection(&m_csAutomatedPhoneState);

    if (m_fPhoneHandlingEnabled && m_dwAutoEndOfNumberTimeout)
    {
        if (m_hAutoEndOfNumberTimer)  // make sure the timer hasn't been cancelled
                                      // while waiting for the critical section
        {
            switch (m_AutomatedPhoneState)
            {
            case APS_OFFHOOK_DIALING:
                {
                    //
                    // We need to fire and event with the number we have
                    // collected
                    //

                    CPhoneEvent::FireEvent(
                               this,
                               PE_NUMBERGATHERED,
                               (PHONE_BUTTON_STATE)0,
                               (PHONE_HOOK_SWITCH_STATE)0,
                               (PHONE_HOOK_SWITCH_DEVICE)0,
                               0,
                               0,
                               m_wszNumbersGathered,
                               NULL
                              );

                    m_AutomatedPhoneState = APS_OFFHOOK_CALL_INIT;
                }
                break;
            }
        }
    } //m_fPhoneHandlingEnabled

    LeaveCriticalSection(&m_csAutomatedPhoneState);

    LOG((TL_TRACE, "Automation_EndOfNumberTimeout - exit"));
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// Automation_ButtonDown
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

void CPhone::Automation_ButtonDown( DWORD dwButtonId )
{
    PHONE_BUTTON_MODE ButtonMode;
    WCHAR wszNumber[11];  // enough to hold a big number in case dwButtonId is bad
    HRESULT hr;
    BOOL fResult;

    LOG((TL_TRACE, "Automation_ButtonDown - enter"));

    EnterCriticalSection(&m_csAutomatedPhoneState);

    if (m_fPhoneHandlingEnabled)
    {
        hr = get_ButtonMode((LONG)dwButtonId, &ButtonMode);

        if ( SUCCEEDED(hr) )
        {
            if (ButtonMode == PBM_KEYPAD)
            {
                switch (m_AutomatedPhoneState)
                {
                case APS_OFFHOOK_DIALTONE:
                    {
                        if (m_fAutoDialtone)
                        {
                            // Stop the dial tone
                            StopTone();
                        }

                        CPhoneEvent::FireEvent(
                                   this,
                                   PE_DIALING,
                                   (PHONE_BUTTON_STATE)0,
                                   (PHONE_HOOK_SWITCH_STATE)0,
                                   (PHONE_HOOK_SWITCH_DEVICE)0,
                                   0,
                                   0,
                                   NULL,
                                   NULL
                                  );
                
                        m_AutomatedPhoneState = APS_OFFHOOK_DIALING;
                    }
                    // Fall Thru

                case APS_OFFHOOK_DIALING:
                    {
                        // Kill auto end of number timer
                        if (m_hAutoEndOfNumberTimer)
                        {
                            DeleteTimerQueueTimer(m_hTimerQueue,
                                                  m_hAutoEndOfNumberTimer,
                                                  m_hTimerEvent  // non-blocking
                                                 );

                            m_hAutoEndOfNumberTimer = NULL;
                        }

                        if ( dwButtonId <= 10 ) // digit key
                        {   
                            //
                            // We have a dialed digit. Append it to the phone
                            // number we have so far.
                            //

                            if ( dwButtonId == 10) // star
                            {
                                wsprintfW(wszNumber, L"*");
                            }
                            else // regular digit
                            {
                                wsprintfW(wszNumber, L"%d", dwButtonId);
                            }

                            if ( (lstrlenW(m_wszNumbersGathered) + lstrlenW(wszNumber)) < APC_MAX_NUMBERS_GATHERED )
                            {
                                lstrcatW(m_wszNumbersGathered, wszNumber);
                            }  
                            
                            LOG((TL_INFO, "Automation_ButtonDown - '%s'", wszNumber));
                        }
                        else if ( dwButtonId == 11 ) // pound key
                        {              
                            LOG((TL_INFO, "Automation_ButtonDown - '#'"));

                            // Kill auto end of number timer
                            if (m_hAutoEndOfNumberTimer)
                            {
                                DeleteTimerQueueTimer(m_hTimerQueue,
                                                      m_hAutoEndOfNumberTimer,
                                                      m_hTimerEvent  // non-blocking
                                                     );

                                m_hAutoEndOfNumberTimer = NULL;
                            }

                            //
                            // We have dialed a #. Send a number gathered event
                            //

                            CPhoneEvent::FireEvent(
                                       this,
                                       PE_NUMBERGATHERED,
                                       (PHONE_BUTTON_STATE)0,
                                       (PHONE_HOOK_SWITCH_STATE)0,
                                       (PHONE_HOOK_SWITCH_DEVICE)0,
                                       0,
                                       0,
                                       m_wszNumbersGathered,
                                       NULL
                                      );

                            m_AutomatedPhoneState = APS_OFFHOOK_CALL_INIT;
                        }
                    }
                    // Fall Thru

                case APS_OFFHOOK_WARNING:
                case APS_OFFHOOK_DEAD_LINE:
                case APS_OFFHOOK_CALL_INIT:
                case APS_OFFHOOK_CONNECTED:
                case APS_OFFHOOK_BUSY_TONE:
                case APS_OFFHOOK_RINGING_OUT:
                    {
                        if (m_fAutoKeypadTones)
                        {
                            // Kill DTMF timer
                            if (m_hDTMFTimer)
                            {
                                DeleteTimerQueueTimer(m_hTimerQueue,
                                                      m_hDTMFTimer,
                                                      INVALID_HANDLE_VALUE  // blocking
                                                     );

                                m_hDTMFTimer = NULL;
                            }

                            // Stop the old DTMF tone
                            if (m_DTMF != PT_SILENCE)
                            {
                                m_WavePlayer.StopTone( (long) m_DTMF);
                            }

                            // Play the DTMF tone
                            m_WavePlayer.StartTone( (long) dwButtonId );
                            m_DTMF = (PHONE_TONE) dwButtonId;
                            m_dwDTMFStart = GetTickCount();
                        }
                    }
                    break;
                }
            }
            else if ( ButtonMode == PBM_FEATURE )
            {
                PHONE_BUTTON_FUNCTION ButtonFunction;

                hr = get_ButtonFunction((LONG)dwButtonId, &ButtonFunction);

                if ( SUCCEEDED(hr) )
                {
                    switch (ButtonFunction)
                    {
                    case PBF_VOLUMEUP:
                        {
                             DWORD dwVolume;

                             LOG((TL_INFO, "Automation_ButtonDown - VOLUMEUP"));
                            
                             if (m_fAutoVolumeControl)
                             {
                                 // Kill volume timer
                                 if (m_hVolumeTimer)
                                 {
                                     DeleteTimerQueueTimer(m_hTimerQueue,
                                                           m_hVolumeTimer,
                                                           INVALID_HANDLE_VALUE  // blocking
                                                          );

                                     m_hVolumeTimer = NULL;
                                 }

                                 hr = m_WavePlayer.GetVolume( &dwVolume );

                                 if ( SUCCEEDED(hr) )
                                 {
                                     dwVolume += m_dwAutoVolumeControlStep;

                                     if (dwVolume > 0xFFFF) dwVolume = 0xFFFF;

                                     hr = m_WavePlayer.SetVolume( dwVolume );

                                     if ( SUCCEEDED(hr) )
                                     {
                                        LOG((TL_INFO, "Automation_ButtonDown - Volume: %d", dwVolume));

                                        m_fVolumeUp = TRUE;

                                        fResult = CreateTimerQueueTimer(&m_hVolumeTimer,
                                                              m_hTimerQueue,
                                                              &CPhone::VolumeTimerCallback,
                                                              (PVOID)this,
                                                              max(m_dwAutoVolumeControlRepeatDelay,m_dwAutoVolumeControlRepeatPeriod),
                                                              m_dwAutoVolumeControlRepeatPeriod,
                                                              WT_EXECUTEINIOTHREAD
                                                             );

                                        if (fResult == FALSE)
                                        {
                                            // CreateTimerQueueTimer failed, not much to do but log the error
                                            LOG((TL_ERROR, "Automation_ButtonDown - CreateTimerQueueTimer failed - %lx", GetLastError()));
                                        }
                                     }
                                 }
                             }
                        }
                        break;

                    case PBF_VOLUMEDOWN:
                        {
                             DWORD dwVolume;

                             LOG((TL_INFO, "Automation_ButtonDown - VOLUMEDOWN"));

                             if (m_fAutoVolumeControl)
                             {
                                 // Kill volume timer
                                 if (m_hVolumeTimer)
                                 {
                                     DeleteTimerQueueTimer(m_hTimerQueue,
                                                           m_hVolumeTimer,
                                                           INVALID_HANDLE_VALUE  // blocking
                                                          );

                                     m_hVolumeTimer = NULL;
                                 }

                                 hr = m_WavePlayer.GetVolume( &dwVolume );
                             
                                 if ( SUCCEEDED(hr) )
                                 {
                                     dwVolume -= m_dwAutoVolumeControlStep;

                                     if (dwVolume > 0xFFFF) dwVolume = 0x0000;

                                     hr = m_WavePlayer.SetVolume( dwVolume );

                                     if ( SUCCEEDED(hr) )
                                     {
                                        LOG((TL_INFO, "Automation_ButtonDown - Volume: %d", dwVolume));

                                        m_fVolumeUp = FALSE;

                                        fResult = CreateTimerQueueTimer(&m_hVolumeTimer,
                                                              m_hTimerQueue,
                                                              &CPhone::VolumeTimerCallback,
                                                              (PVOID)this,
                                                              max(m_dwAutoVolumeControlRepeatDelay,m_dwAutoVolumeControlRepeatPeriod),
                                                              m_dwAutoVolumeControlRepeatPeriod,
                                                              WT_EXECUTEINIOTHREAD
                                                             );

                                        if (fResult == FALSE)
                                        {
                                            // CreateTimerQueueTimer failed, not much to do but log the error
                                            LOG((TL_ERROR, "Automation_ButtonDown - CreateTimerQueueTimer failed - %lx", GetLastError()));
                                        }
                                     }
                                 }
                             }
                        }
                        break;

                    case PBF_SEND:
                        {
                            LOG((TL_INFO, "Automation_ButtonDown - PBF_SEND"));

                            switch (m_AutomatedPhoneState)
                            {
                            case APS_OFFHOOK_DIALING:
                                {
                                    // Kill auto end of number timer
                                    if (m_hAutoEndOfNumberTimer)
                                    {
                                        DeleteTimerQueueTimer(m_hTimerQueue,
                                                              m_hAutoEndOfNumberTimer,
                                                              m_hTimerEvent  // non-blocking
                                                             );

                                        m_hAutoEndOfNumberTimer = NULL;
                                    }

                                    //
                                    // We have pressed send. Send a number gathered event.
                                    //

                                    CPhoneEvent::FireEvent(
                                               this,
                                               PE_NUMBERGATHERED,
                                               (PHONE_BUTTON_STATE)0,
                                               (PHONE_HOOK_SWITCH_STATE)0,
                                               (PHONE_HOOK_SWITCH_DEVICE)0,
                                               0,
                                               0,
                                               m_wszNumbersGathered,
                                               NULL
                                              );

                                    m_AutomatedPhoneState = APS_OFFHOOK_CALL_INIT;
                                }
                                break;
                            } // switch (m_AutomatedPhoneState)
                        }
                        break;
                    } // switch (ButtonFunction)
                }
            }
        }
    } //m_fPhoneHandlingEnabled

    LeaveCriticalSection(&m_csAutomatedPhoneState);

    LOG((TL_TRACE, "Automation_ButtonDown - exit"));
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

void CPhone::Automation_ButtonUp( DWORD dwButtonId )
{
    PHONE_BUTTON_MODE   ButtonMode;
    HRESULT             hr;
    BOOL                fResult;

    LOG((TL_TRACE, "Automation_ButtonUp - enter"));

    EnterCriticalSection(&m_csAutomatedPhoneState);

    if (m_fPhoneHandlingEnabled)
    {
        hr = get_ButtonMode((LONG)dwButtonId, &ButtonMode);

        if ( SUCCEEDED(hr) )
        {
            if ( ButtonMode == PBM_KEYPAD )
            {
                switch (m_AutomatedPhoneState)
                {
                case APS_OFFHOOK_DIALING:
                    {
                        if ( dwButtonId <= 10 ) // digit key
                        { 
                            if (m_dwAutoEndOfNumberTimeout)
                            {
                                fResult = CreateTimerQueueTimer(&m_hAutoEndOfNumberTimer,
                                                      m_hTimerQueue,
                                                      &CPhone::AutoEndOfNumberTimerCallback,
                                                      (PVOID)this,
                                                      m_dwAutoEndOfNumberTimeout,
                                                      0,
                                                      WT_EXECUTEINIOTHREAD
                                                     );

                                if (fResult == FALSE)
                                {
                                    // CreateTimerQueueTimer failed, not much to do but log the error
                                    LOG((TL_ERROR, "Automation_ButtonUp - CreateTimerQueueTimer failed - %lx", GetLastError()));
                                }
                            }
                        }
                    }
                    // Fall Thru

                case APS_OFFHOOK_CONNECTED:
                case APS_OFFHOOK_CALL_INIT:
                case APS_OFFHOOK_DEAD_LINE:
                case APS_OFFHOOK_DIALTONE:
                case APS_OFFHOOK_WARNING:
                case APS_OFFHOOK_BUSY_TONE:
                case APS_OFFHOOK_RINGING_OUT:
                    {
                        if (m_fAutoKeypadTones)
                        {
                            if ((PHONE_TONE)dwButtonId == m_DTMF)
                            {
                                DWORD dwElapsed = GetTickCount() - m_dwDTMFStart;

                                if ( dwElapsed > m_dwAutoKeypadTonesMinimumDuration )
                                {
                                    // Stop the DTMF tone
                                    m_WavePlayer.StopTone( (long) m_DTMF);
                                    m_DTMF = PT_SILENCE;
                                }
                                else
                                {
                                    // Limit the DTMF tone
                                    fResult = CreateTimerQueueTimer(&m_hDTMFTimer,
                                                          m_hTimerQueue,
                                                          &CPhone::DTMFTimerCallback,
                                                          (PVOID)this,
                                                          m_dwAutoKeypadTonesMinimumDuration - dwElapsed,
                                                          0,
                                                          WT_EXECUTEINIOTHREAD
                                                         );

                                    if (fResult == FALSE)
                                    {
                                        // CreateTimerQueueTimer failed, not much to do but log the error
                                        LOG((TL_ERROR, "Automation_ButtonUp - CreateTimerQueueTimer failed - %lx", GetLastError()));
                                    }
                                }
                            }
                        }
                    }
                    break;
                }
            }
            else if ( ButtonMode == PBM_FEATURE )
            {
                PHONE_BUTTON_FUNCTION ButtonFunction;

                hr = get_ButtonFunction((LONG)dwButtonId, &ButtonFunction);

                if ( SUCCEEDED(hr) )
                {
                    switch (ButtonFunction)
                    {
                    case PBF_VOLUMEUP:
                        {
                             DWORD dwVolume;

                             LOG((TL_INFO, "Automation_ButtonUp - VOLUMEUP"));
                            
                             if (m_fAutoVolumeControl)
                             {
                                 // Kill volume timer
                                 if (m_hVolumeTimer)
                                 {
                                     DeleteTimerQueueTimer(m_hTimerQueue,
                                                           m_hVolumeTimer,
                                                           INVALID_HANDLE_VALUE  // blocking
                                                          );

                                     m_hVolumeTimer = NULL;
                                 }
                             }
                        }
                        break;

                    case PBF_VOLUMEDOWN:
                        {
                             DWORD dwVolume;

                             LOG((TL_INFO, "Automation_ButtonUp - VOLUMEDOWN"));

                             if (m_fAutoVolumeControl)
                             {
                                 // Kill volume timer
                                 if (m_hVolumeTimer)
                                 {
                                     DeleteTimerQueueTimer(m_hTimerQueue,
                                                           m_hVolumeTimer,
                                                           INVALID_HANDLE_VALUE  // blocking
                                                          );

                                     m_hVolumeTimer = NULL;
                                 }
                             }
                        }
                        break;
                    }
                }
            }                    
        }
    } //m_fPhoneHandlingEnabled

    LeaveCriticalSection(&m_csAutomatedPhoneState);

    LOG((TL_TRACE, "Automation_ButtonUp - exit"));
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

void CPhone::Automation_OnHook( PHONE_HOOK_SWITCH_DEVICE phsd )
{
    LOG((TL_TRACE, "Automation_OnHook - enter"));

    EnterCriticalSection(&m_csAutomatedPhoneState);

    if (m_fPhoneHandlingEnabled)
    {
        if (m_dwOffHookCount > 0) m_dwOffHookCount--;

        if (m_dwOffHookCount == 0)
        {
            switch (m_AutomatedPhoneState)
            {
            case APS_ONHOOK_IDLE:
            case APS_ONHOOK_RINGING_IN:
            case APS_ONHOOK_CONNECTED:
            case APS_ONHOOK_RINGING_OUT:
                {
                    //
                    // Something is wrong!! Most likely this phone was offhook on startup, but told
                    // us it was onhook. Lets clean up the best we can
                    //

                    LOG((TL_WARN, "Automation_OnHook - Phone is already in onhook state!" ));

                    if (m_fAutoStopTonesOnOnHook)
                    {
                        // Kill DTMF timer
                        if (m_hDTMFTimer)
                        {
                            DeleteTimerQueueTimer(m_hTimerQueue,
                                                  m_hDTMFTimer,
                                                  INVALID_HANDLE_VALUE  // blocking
                                                 );

                            m_hDTMFTimer = NULL;
                        }

                        // Stop any DTMF that may be playing
                        if (m_DTMF != PT_SILENCE)
                        {                            
                            // Stop the DTMF tone
                            m_WavePlayer.StopTone( (long) m_DTMF );
                            m_DTMF = PT_SILENCE;
                        }

                        // Stop any tone that may be playing
                        StopTone();
                    }

                    m_AutomatedPhoneState = APS_ONHOOK_IDLE;
                }
                break;

            case APS_OFFHOOK_DIALTONE:
            case APS_OFFHOOK_WARNING:
            case APS_OFFHOOK_DEAD_LINE:
            case APS_OFFHOOK_DIALING:
            case APS_OFFHOOK_CONNECTED:
            case APS_OFFHOOK_CALL_INIT:
            case APS_OFFHOOK_BUSY_TONE:
            case APS_OFFHOOK_RINGING_OUT:
                {
                    if (m_fAutoStopTonesOnOnHook)
                    {
                        // Kill DTMF timer
                        if (m_hDTMFTimer)
                        {
                            DeleteTimerQueueTimer(m_hTimerQueue,
                                                  m_hDTMFTimer,
                                                  INVALID_HANDLE_VALUE  // blocking
                                                 );

                            m_hDTMFTimer = NULL;
                        }

                        // Stop any DTMF that may be playing
                        if (m_DTMF != PT_SILENCE)
                        {                            
                            // Stop the DTMF tone
                            m_WavePlayer.StopTone( (long) m_DTMF );
                            m_DTMF = PT_SILENCE;
                        }

                        // Stop any tone that may be playing
                        StopTone();
                    }

                    // Kill automated end of number timer
                    if (m_hAutoEndOfNumberTimer)
                    {
                        DeleteTimerQueueTimer(m_hTimerQueue,
                                              m_hAutoEndOfNumberTimer,
                                              m_hTimerEvent  // non-blocking
                                             );

                        m_hAutoEndOfNumberTimer = NULL;
                    }

                    if (m_pCall)
                    {
                        CALL_STATE cs;
                        HRESULT hr;

                        hr = m_pCall->get_CallState( &cs );

                        if ( SUCCEEDED(hr) )
                        {
                            if ( cs != CS_DISCONNECTED )
                            {
                                ITBasicCallControl * pCallBCC;
                                ITCallInfo         * pCall;

                                pCall = m_pCall;
                                pCall->AddRef();

                                hr = pCall->QueryInterface( IID_ITBasicCallControl,
                                                            (void **) & pCallBCC );

                                if ( SUCCEEDED(hr) )
                                {   
                                    LeaveCriticalSection(&m_csAutomatedPhoneState);

                                    hr = pCallBCC->Disconnect( DC_NORMAL );

                                    pCallBCC->Release();  
                                                            
                                    if ( FAILED(hr) )
                                    {
                                        LOG((TL_ERROR, "Automation_OnHook - Disconnect failed %08x", hr ));
                                    }
                                    else
                                    {
                                        CPhoneEvent::FireEvent(
                                           this,
                                           PE_DISCONNECT,
                                           (PHONE_BUTTON_STATE)0,
                                           (PHONE_HOOK_SWITCH_STATE)0,
                                           (PHONE_HOOK_SWITCH_DEVICE)0,
                                           0,
                                           0,
                                           NULL,
                                           pCall
                                          );
                                    }

                                    pCall->Release();
                                    
                                    EnterCriticalSection(&m_csAutomatedPhoneState);            
                                }
                            }
                            else
                            {
                                // If we are already disconnected we can unselect the call, otherwise
                                // the CS_DISCONNECT event will do it for us.
                                InternalUnselectCall( m_pCall );
                            }
                        }
                    }

                    m_AutomatedPhoneState = APS_ONHOOK_IDLE;
                }
                break;
            }
        }
    } //m_fPhoneHandlingEnabled

    LeaveCriticalSection(&m_csAutomatedPhoneState);

    LOG((TL_TRACE, "Automation_OnHook - exit"));
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

void CPhone::Automation_OffHook( PHONE_HOOK_SWITCH_DEVICE phsd )
{
    LOG((TL_TRACE, "Automation_OffHook - enter"));

    EnterCriticalSection(&m_csAutomatedPhoneState);

    if (m_fPhoneHandlingEnabled)
    {
        m_dwOffHookCount++;

        // We just went offhook
        if (m_dwOffHookCount == 1)
        {
            switch (m_AutomatedPhoneState)
            {
            case APS_ONHOOK_IDLE:
                {
                    if (m_fAutoStopRingOnOffHook)
                    {
                        // Stop incoming ring
                        StopRinger();
                    }
                    
                    if (m_fAutoDialtone)
                    {
                        // Start the dialtone
                        StartTone( PT_NORMALDIALTONE, 0 );
                    }

                    // Clear the numbers gathered
                    lstrcpyW(m_wszNumbersGathered, L"");

                    m_AutomatedPhoneState = APS_OFFHOOK_DIALTONE;
                }
                break;

            case APS_ONHOOK_RINGING_IN:
                {
                    if (m_fAutoStopRingOnOffHook)
                    {
                        // Stop incoming ring
                        StopRinger();
                    }

                    if (m_pCall)
                    {
                        CALL_STATE cs;
                        HRESULT hr;

                        hr = m_pCall->get_CallState( &cs );

                        if ( SUCCEEDED(hr) )
                        {
                            if ( cs == CS_OFFERING )
                            {
                                ITBasicCallControl * pCallBCC;
                                ITCallInfo         * pCall;

                                pCall = m_pCall;
                                pCall->AddRef();

                                hr = pCall->QueryInterface( IID_ITBasicCallControl,
                                                            (void **) & pCallBCC );

                                if ( SUCCEEDED(hr) )
                                {     
                                    LeaveCriticalSection(&m_csAutomatedPhoneState);

                                    hr = pCallBCC->Answer();

                                    pCallBCC->Release();                                    

                                    if ( FAILED(hr) )
                                    {
                                        LOG((TL_ERROR, "Automation_OffHook - Answer failed %08x", hr ));
                                    }
                                    else
                                    {
                                        CPhoneEvent::FireEvent(
                                           this,
                                           PE_ANSWER,
                                           (PHONE_BUTTON_STATE)0,
                                           (PHONE_HOOK_SWITCH_STATE)0,
                                           (PHONE_HOOK_SWITCH_DEVICE)0,
                                           0,
                                           0,
                                           NULL,
                                           pCall
                                          );
                                    }  
                                    
                                    pCall->Release();

                                    EnterCriticalSection(&m_csAutomatedPhoneState);
                                }
                            }
                        }
                    }

                    m_AutomatedPhoneState = APS_OFFHOOK_CALL_INIT;
                }
                break;

            case APS_ONHOOK_RINGING_OUT:
                {
                    if (m_fAutoStopRingOnOffHook)
                    {
                        // Stop incoming ring
                        StopRinger();
                    }

                    if (m_pCall)
                    {
                        CALL_STATE cs;
                        HRESULT hr;

                        hr = m_pCall->get_CallState( &cs );

                        if ( SUCCEEDED(hr) )
                        {
                            switch( cs )
                            {
                            case CS_INPROGRESS:
                                {
                                    StartTone( PT_RINGBACK, 0 );

                                    m_AutomatedPhoneState = APS_OFFHOOK_RINGING_OUT;
                                }
                                break;

                            case CS_CONNECTED:
                                {
                                    m_AutomatedPhoneState = APS_OFFHOOK_CONNECTED;
                                }
                                break;
                            }
                        }
                    }
                }
                break;
            case APS_ONHOOK_CONNECTED:
                {
                    if (m_fAutoStopRingOnOffHook)
                    {
                        // Stop incoming ring
                        StopRinger();
                    }

                    m_AutomatedPhoneState = APS_OFFHOOK_CONNECTED;
                }
                break;
            }
        }
    } //m_fPhoneHandlingEnabled

    LeaveCriticalSection(&m_csAutomatedPhoneState);

    LOG((TL_TRACE, "Automation_OffHook - exit"));
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

VOID CALLBACK CPhone::ToneTimerCallback(
                                PVOID lpParameter,    
                                BOOLEAN TimerOrWaitFired
                               )
{
    CPhone * pCPhone = (CPhone *)(lpParameter);

    STATICLOG((TL_TRACE, "ToneTimerCallback - enter"));

    BOOL Stopped = TRUE;

    if (pCPhone != NULL)
    {
        if (TryEnterCriticalSection( &pCPhone->m_csToneTimer ))
        {
            if (pCPhone->m_WavePlayer.PlayingTone( (long) pCPhone->m_Tone ))
            {
                //
                // Tone was on
                //

                pCPhone->m_WavePlayer.StopTone( (long) pCPhone->m_Tone );

                if (pCPhone->m_dwTonePeriodOn > 0)
                {
                    //
                    // Tone is periodic
                    //

                    if (pCPhone->m_dwToneDuration > 0)
                    {
                        //
                        // Tone is periodic with limited duration
                        //

                        if ( pCPhone->m_dwToneDuration > pCPhone->m_dwTonePeriodOn )
                        {
                            pCPhone->m_dwToneDuration -= pCPhone->m_dwTonePeriodOn;

                            if ( pCPhone->m_dwTonePeriodOff < pCPhone->m_dwToneDuration )
                            {
                                //
                                // Remaining duration is greater than the period
                                //                           

                                ChangeTimerQueueTimer(
                                                      pCPhone->m_hTimerQueue,
                                                      pCPhone->m_hToneTimer,
                                                      pCPhone->m_dwTonePeriodOff,
                                                      TIMER_KEEP_ALIVE
                                                     );

                                Stopped = FALSE;
                            }
                            else
                            {
                                //
                                // Remaining duration is less than the period
                                //

                                ChangeTimerQueueTimer(
                                                      pCPhone->m_hTimerQueue,
                                                      pCPhone->m_hToneTimer,
                                                      pCPhone->m_dwToneDuration,
                                                      0
                                                     );

                                Stopped = FALSE;
                            }
                        }
              
                    }
                    else
                    {
                        //
                        // Tone is periodic with infinite duration
                        //

                        ChangeTimerQueueTimer(
                                              pCPhone->m_hTimerQueue,
                                              pCPhone->m_hToneTimer,
                                              pCPhone->m_dwTonePeriodOff,
                                              TIMER_KEEP_ALIVE
                                             );

                        Stopped = FALSE;
                    }
                }
            }
            else
            {          
                //
                // Tone was off
                //

                if (pCPhone->m_dwTonePeriodOff > 0)
                {
                    //
                    // Tone is periodic
                    //

                    if (pCPhone->m_dwToneDuration > 0)
                    {                
                        //
                        // Tone is periodic with limited duration
                        //

                        if ( pCPhone->m_dwToneDuration > pCPhone->m_dwTonePeriodOff )
                        {
                            pCPhone->m_dwToneDuration -= pCPhone->m_dwTonePeriodOff;

                            if ( pCPhone->m_dwTonePeriodOn < pCPhone->m_dwToneDuration )
                            {
                                //
                                // Remaining duration is greater than the period
                                //

                                pCPhone->m_WavePlayer.StartTone( (long) pCPhone->m_Tone );

                                ChangeTimerQueueTimer(
                                                      pCPhone->m_hTimerQueue,
                                                      pCPhone->m_hToneTimer,
                                                      pCPhone->m_dwTonePeriodOn,
                                                      TIMER_KEEP_ALIVE
                                                     );

                                Stopped = FALSE;
                            }
                            else
                            {
                                //
                                // Remaining duration is less than the period
                                //

                                pCPhone->m_WavePlayer.StartTone( (long) pCPhone->m_Tone );

                                ChangeTimerQueueTimer(
                                                      pCPhone->m_hTimerQueue,
                                                      pCPhone->m_hToneTimer,
                                                      pCPhone->m_dwToneDuration,
                                                      0
                                                     );

                                Stopped = FALSE;
                            }
                        }
                    }
                    else
                    {
                        //
                        // Tone is periodic with infinite duration
                        //

                        pCPhone->m_WavePlayer.StartTone( (long) pCPhone->m_Tone );

                        ChangeTimerQueueTimer(
                                              pCPhone->m_hTimerQueue,
                                              pCPhone->m_hToneTimer,
                                              pCPhone->m_dwTonePeriodOn,
                                              TIMER_KEEP_ALIVE
                                             );

                        Stopped = FALSE;
                    }
                }
            }

            if (Stopped) pCPhone->m_Tone = PT_SILENCE;

            LeaveCriticalSection( &pCPhone->m_csToneTimer );
        }
    }

    STATICLOG((TL_TRACE, "ToneTimerCallback - exit"));
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

VOID CALLBACK CPhone::DTMFTimerCallback(
                                PVOID lpParameter,    
                                BOOLEAN TimerOrWaitFired
                               )
{
    CPhone * pCPhone = (CPhone *)(lpParameter);

    STATICLOG((TL_TRACE, "DTMFTimerCallback - enter"));

    if (pCPhone != NULL)
    {       
        pCPhone->m_WavePlayer.StopTone( (long) pCPhone->m_DTMF );
        pCPhone->m_DTMF = PT_SILENCE;
    }

    STATICLOG((TL_TRACE, "DTMFTimerCallback - exit"));
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

VOID CALLBACK CPhone::RingTimerCallback(
                                PVOID lpParameter,    
                                BOOLEAN TimerOrWaitFired
                               )
{
    HRESULT     hr;
    DWORD       dwDummy;
    DWORD       dwVolume;
    CPhone    * pCPhone = (CPhone *)(lpParameter);

    STATICLOG((TL_TRACE, "RingTimerCallback - enter"));

    BOOL Stopped = TRUE;

    if (pCPhone != NULL)
    {
        if ( TryEnterCriticalSection( &pCPhone->m_csRingTimer ))
        {
            if ( pCPhone->m_fUseWaveForRinger )
            {
                //
                // Using wave player for ring
                //
            
                if ( pCPhone->m_dwRingDuration > 0 )
                {
                    //
                    // Ring has a limited duration
                    //

                    if ( pCPhone->m_dwRingDuration > pCPhone->m_dwRingPeriod )
                    {
                        pCPhone->m_dwRingDuration -= pCPhone->m_dwRingPeriod;

                        if ( pCPhone->m_dwRingPeriod < pCPhone->m_dwRingDuration )
                        {
                            //
                            // Remaining duration is greater than period
                            //

                            hr = pCPhone->m_WavePlayer.StartRing();

                            Stopped = FALSE;
                        }
                        else
                        {
                            //
                            // Remaining duration is less than period
                            //

                            ChangeTimerQueueTimer(
                                                  pCPhone->m_hTimerQueue,
                                                  pCPhone->m_hRingTimer,
                                                  pCPhone->m_dwRingDuration,
                                                  0
                                                 );

                            hr = pCPhone->m_WavePlayer.StartRing();

                            Stopped = FALSE;
                        }
                    }
                }
                else
                {
                    //
                    // Ring has an infinite duration
                    //

                    hr = pCPhone->m_WavePlayer.StartRing();

                    Stopped = FALSE;
                }

                //
                // Stop the ring if needed
                //

                if (Stopped) 
                {
                    hr = pCPhone->m_WavePlayer.StopRing();
                }
            }
            else
            {
                //
                // Using phone's ringer, duration must have elapsed because
                // this is not periodic
                //
                hr = PhoneGetRing(pCPhone->m_hPhone, &dwDummy, &dwVolume);

                if ( FAILED(hr) )
                {
                    STATICLOG((TL_TRACE, "RingTimerCallback - PhoneGetRing failed - %lx", hr));

                    LeaveCriticalSection( &pCPhone->m_csRingTimer );

                    return;
                }

                hr = PhoneSetRing(pCPhone->m_hPhone, 0, dwVolume );
            }

            if (Stopped) 
            {
                pCPhone->m_fRinger = FALSE;
            }

            LeaveCriticalSection( &pCPhone->m_csRingTimer );
        }
    }   

    STATICLOG((TL_TRACE, "RingTimerCallback - exit"));
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

VOID CALLBACK CPhone::VolumeTimerCallback(
                                          PVOID lpParameter,    
                                          BOOLEAN TimerOrWaitFired
                                         )
{
    HRESULT     hr;
    DWORD       dwVolume;
    CPhone    * pCPhone = (CPhone *)(lpParameter);

    STATICLOG((TL_TRACE, "VolumeTimerCallback - enter"));

    if (pCPhone != NULL)
    {
        hr = pCPhone->m_WavePlayer.GetVolume( &dwVolume );
                             
        if ( SUCCEEDED(hr) )
        {
            if (pCPhone->m_fVolumeUp)
            {
                dwVolume += pCPhone->m_dwAutoVolumeControlStep;

                if (dwVolume > 0xFFFF) 
                {
                    dwVolume = 0xFFFF;
                }
            }
            else
            {
                dwVolume -= pCPhone->m_dwAutoVolumeControlStep;

                if (dwVolume > 0xFFFF)
                {
                    dwVolume = 0x0000;
                }
            }

            hr = pCPhone->m_WavePlayer.SetVolume( dwVolume );

            if ( SUCCEEDED(hr) )
            {
               STATICLOG((TL_INFO, "VolumeTimerCallback - Volume: %lx", dwVolume));
            }
            else
            {
               STATICLOG((TL_INFO, "VolumeTimerCallback - SetVolume failed - %lx", hr));
            }
        }
        else
        {
            STATICLOG((TL_INFO, "VolumeTimerCallback - GetVolume failed - %lx", hr));
        }
    }

    STATICLOG((TL_TRACE, "VolumeTimerCallback - exit"));
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

VOID CALLBACK CPhone::AutoEndOfNumberTimerCallback(
                                           PVOID lpParameter,    
                                           BOOLEAN TimerOrWaitFired
                                          )
{
    HRESULT     hr;
    CPhone    * pCPhone = (CPhone *)(lpParameter);

    STATICLOG((TL_TRACE, "AutoEndOfNumberTimerCallback - enter"));

    if (pCPhone != NULL)
    {
        pCPhone->Automation_EndOfNumberTimeout();
    }

    STATICLOG((TL_TRACE, "AutoEndOfNumberTimerCallback - exit"));
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetPhoneWaveRenderID
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

HRESULT CPhone::GetPhoneWaveRenderID(DWORD * pdwWaveID)
{
    T3PHONE     t3Phone;
    HRESULT     hr;
    LPVARSTRING pVarString = NULL;
    DWORD       dwPhoneWaveID;

    //
    // get wave device ids associated with this phone
    // we need to open the phone device to do this
    // Must use monitor privilege, because owner privilege open will
    // fail if anyone happens to have the phone open as owner.
    //

    t3Phone.hPhone = NULL;
    t3Phone.pPhone = this;

    Lock();

    hr = PhoneOpen(m_hPhoneApp,
                   m_dwDeviceID,
                   &t3Phone,
                   m_dwAPIVersion,
                   PHONEPRIVILEGE_MONITOR
                   );

    if ( SUCCEEDED(hr) )
    {
        hr = PhoneGetID(
                       t3Phone.hPhone,
                       &pVarString,
                       L"wave/out"
                      );

        if ( SUCCEEDED(hr) )
        {
            if (pVarString->dwStringSize == sizeof(DWORD))
            {
                CopyMemory(
                       pdwWaveID,
                       ((LPBYTE)pVarString)+pVarString->dwStringOffset,
                       pVarString->dwStringSize
                      );

                LOG((TL_INFO, "GetPhoneWaveRenderID - got phone wave "
                                     "render id %d", *pdwWaveID ));
            }
        }
        else
        {
            LOG((TL_ERROR, "GetPhoneRenderWaveID - PhoneGetID failed %08x", hr ));
        }

        if ( NULL != pVarString )
        {
            ClientFree( pVarString );
        }

        PhoneClose(t3Phone.hPhone);
    }
    else
    {
        LOG((TL_ERROR, "GetPhoneRenderWaveID - PhoneOpen failed %08x", hr ));
    }

    Unlock();

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

void CPhone::OpenWaveDevice(
        )
{
    HRESULT hr;

    LOG((TL_TRACE, "OpenWaveDevice - enter" ));

    if (!m_WavePlayer.IsInitialized())
    {      
        hr = m_WavePlayer.Initialize();

        if ( FAILED(hr) )
        {
            LOG((TL_ERROR, "OpenWaveDevice - Initialize failed %08x", hr ));

            return;
        }
    }

    if (!m_WavePlayer.IsInUse())
    {
        if (m_fUseWaveForRinger)
        {
            hr = m_WavePlayer.OpenWaveDeviceForRing( WAVE_MAPPER );

            if ( FAILED(hr) )
            {
                LOG((TL_ERROR, "OpenWaveDevice - OpenWaveDeviceForRing failed %08x", hr ));
            }
        }

        long lWaveId;

        hr = GetPhoneWaveRenderID( (DWORD *) & lWaveId );
    
        if ( FAILED(hr) )
        {
            LOG((TL_ERROR, "OpenWaveDevice - GetPhoneWaveRenderID failed %08x", hr ));

            return;
        }

        hr = m_WavePlayer.OpenWaveDeviceForTone( lWaveId );

        if ( FAILED(hr) )
        {
            LOG((TL_ERROR, "OpenWaveDevice - OpenWaveDeviceForTone failed %08x", hr ));
        }

        hr = m_WavePlayer.OpenMixerDevice( lWaveId );

        if ( FAILED(hr) )
        {
            LOG((TL_ERROR, "OpenWaveDevice - OpenMixerDevice failed %08x", hr ));
        }
    }

    LOG((TL_TRACE, "OpenWaveDevice - exit" ));
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

void CPhone::CloseWaveDevice(
        )
{
    LOG((TL_TRACE, "CloseWaveDevice - enter" ));

    if (m_WavePlayer.IsInUse())
    {
        if (m_fUseWaveForRinger)
        {
            m_WavePlayer.CloseWaveDeviceForRing();        
        }

        m_WavePlayer.CloseWaveDeviceForTone();

        m_WavePlayer.CloseMixerDevice();
    }

    LOG((TL_TRACE, "CloseWaveDevice - exit" ));
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ITAutomatedPhoneControlQI
//      Don't give out the ITAutomatedPhoneControl interface
//      if the application does not have the phone open.
//      Also, open the wave devices if owner.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

HRESULT
WINAPI
CPhone::ITAutomatedPhoneControlQI(void* pv, REFIID riid, LPVOID* ppv, DWORD_PTR dw)
{
    STATICLOG((TL_TRACE,"AutomatedPhoneControlQI - enter"));

    *ppv = NULL;

    CPhone * pPhone = ((CPhone *)pv);

    pPhone->Lock();

    if (pPhone->m_hPhone == NULL)
    {
        STATICLOG((TL_WARN,"The application does not have this phone open"));
        STATICLOG((TL_WARN,"so it cannot access the AutomatedPhoneControl interface"));

        pPhone->Unlock();

        return TAPI_E_PHONENOTOPEN;
    }
            
    if (pPhone->m_dwPrivilege != PHONEPRIVILEGE_OWNER)
    {
        STATICLOG((TL_WARN,"The application does not have owner privilege"));
        STATICLOG((TL_WARN,"so it cannot access the AutomatedPhoneControl interface"));

        pPhone->Unlock();

        return TAPI_E_NOTOWNER;
    }

    HRESULT hr = pPhone->UpdatePhoneCaps();

    if ( FAILED(hr) )
    {
        STATICLOG((TL_ERROR,"UpdatePhoneCaps failed 0x%lx", hr));

        pPhone->Unlock();

        return hr;
    }

    if ( ( pPhone->GetAPIVersion() < TAPI_VERSION2_0 ) || 
        !(pPhone->m_pPhoneCaps->dwPhoneFeatures & PHONEFEATURE_GENERICPHONE) )
    {
        STATICLOG((TL_TRACE,"The phone does not have PCL_GENERICPHONE capability"));
        STATICLOG((TL_TRACE,"so it cannot access the AutomatedPhoneControl interface"));

        pPhone->Unlock();

        return E_NOINTERFACE;
    }

    if ( pPhone->m_pPhoneCaps->dwNumRingModes == 0) 
    {
        //
        // The hardware doesn't have a ringer, so use the wave
        // device as a ringer
        //

        pPhone->m_fUseWaveForRinger = TRUE;
    }
    else
    {
        //
        // Use the hardware ringer
        //

        pPhone->m_fUseWaveForRinger = FALSE;
    }

    pPhone->OpenWaveDevice();

    pPhone->Unlock();

    //
    // S_FALSE tells atl to continue querying for the interface
    //

    STATICLOG((TL_TRACE, "AutomatedPhoneControlQI - exit"));

    return S_FALSE;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP
CPhone::StartTone(
        IN   PHONE_TONE Tone,
        IN   long       lDuration
        )
{
    HRESULT hr;
    BOOL    fResult;

    LOG((TL_TRACE, "StartTone - enter"));

    //
    // Check arguments.
    //

    if ( ( Tone < PT_KEYPADZERO) || ( Tone > PT_SILENCE ) )
    {
        LOG((TL_ERROR, "StartTone - "
                                 "invalid tone type - exit E_INVALIDARG"));

        return E_INVALIDARG;
    }
    
    if ( lDuration < 0 )
    {
        LOG((TL_ERROR, "StartTone - "
                                 "negative argument - exit E_INVALIDARG"));

        return E_INVALIDARG;
    }

    Lock();

    //
    // Make sure the phone is open with owner privilege.
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "StartTone - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    if ( m_dwPrivilege != PHONEPRIVILEGE_OWNER )
    {
        LOG((TL_ERROR, "StartTone - wrong phone privilege - "
                                 "exit TAPI_E_NOTOWNER"));

        Unlock();

        return TAPI_E_NOTOWNER;
    }
   
    //
    // Kill the tone timer
    //

    if (m_hToneTimer)
    {
        EnterCriticalSection( &m_csToneTimer );

        DeleteTimerQueueTimer(m_hTimerQueue,
                              m_hToneTimer,
                              INVALID_HANDLE_VALUE  // blocking
                             );

        m_hToneTimer = NULL;

        LeaveCriticalSection( &m_csToneTimer );
    }

    //
    // Stop the old tone if there was one
    //

    if (m_Tone != PT_SILENCE)
    {
        m_WavePlayer.StopTone( (long) m_Tone );
        m_Tone = PT_SILENCE;
    }

    //
    // Start the new tone if needed
    //

    if ( Tone != PT_SILENCE )
    {
        //
        // Set duration and period
        // 

        m_dwToneDuration = lDuration;

        switch ( Tone )
        {
            case PT_BUSY:
                m_dwTonePeriodOn = 500;
                m_dwTonePeriodOff = 500;
                break;

            case PT_RINGBACK:
                m_dwTonePeriodOn = 2000;
                m_dwTonePeriodOff = 4000;
                break;

            case PT_ERRORTONE:
                m_dwTonePeriodOn = 100;
                m_dwTonePeriodOff = 100;
                break;

            default: // not periodic
                m_dwTonePeriodOn = 0;
                m_dwTonePeriodOff = 0;
                break;
        }

        hr = m_WavePlayer.StartTone( (long) Tone );

        if ( SUCCEEDED(hr) )
        {
            if ( (m_dwTonePeriodOn > 0) &&
                 ((m_dwTonePeriodOn < m_dwToneDuration) || (m_dwToneDuration == 0)) )
            {
                //
                // Tone is periodic and duration is greater than the period
                //

                fResult = CreateTimerQueueTimer(&m_hToneTimer,
                              m_hTimerQueue,
                              &CPhone::ToneTimerCallback,
                              (PVOID)this,
                              m_dwTonePeriodOn,
                              TIMER_KEEP_ALIVE,
                              WT_EXECUTEINIOTHREAD
                             );

                if (fResult == FALSE)
                {
                    // CreateTimerQueueTimer failed, lets stop the tone and bail out
                    LOG((TL_ERROR, "StartTone - CreateTimerQueueTimer failed - %lx", GetLastError()));

                    hr = HRESULT_FROM_WIN32(GetLastError());

                    m_WavePlayer.StopTone( (long) Tone );
                }
            }
            else if (m_dwToneDuration > 0)
            {                             
                //
                // Tone is not periodic, or duration is less than the period
                //

                fResult = CreateTimerQueueTimer(&m_hToneTimer,
                              m_hTimerQueue,
                              &CPhone::ToneTimerCallback,
                              (PVOID)this,
                              m_dwToneDuration,
                              0,
                              WT_EXECUTEINIOTHREAD
                             );

                if (fResult == FALSE)
                {
                    // CreateTimerQueueTimer failed, lets stop the tone and bail out
                    LOG((TL_ERROR, "StartTone - CreateTimerQueueTimer failed - %lx", GetLastError()));

                    hr = HRESULT_FROM_WIN32(GetLastError());

                    m_WavePlayer.StopTone( (long) Tone );
                }
            }
        }        
    
        if ( FAILED(hr) )
        {
            LOG((TL_ERROR, "StartTone - exit 0x%08x", hr));
            Unlock();

            return hr;
        }

        m_Tone = Tone;
    }

    Unlock();

    LOG((TL_TRACE, "StartTone - exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP
CPhone::StopTone()
{
    HRESULT hr = S_OK;

    LOG((TL_TRACE, "StopTone - enter"));

    Lock();

    //
    // Make sure the phone is open with owner privilege.
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "StopTone - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    if ( m_dwPrivilege != PHONEPRIVILEGE_OWNER )
    {
        LOG((TL_ERROR, "StopTone - wrong phone privilege - "
                                 "exit TAPI_E_NOTOWNER"));

        Unlock();

        return TAPI_E_NOTOWNER;
    }

    //
    // Kill the tone timer
    //

    if (m_hToneTimer)
    {
        EnterCriticalSection( &m_csToneTimer );

        DeleteTimerQueueTimer(m_hTimerQueue,
                              m_hToneTimer,
                              INVALID_HANDLE_VALUE  // blocking
                             );

        m_hToneTimer = NULL;

        LeaveCriticalSection( &m_csToneTimer );
    }

    //
    // Stop the old tone if there was one
    //

    if (m_Tone != PT_SILENCE)
    {
        hr = m_WavePlayer.StopTone( (long) m_Tone );
        m_Tone = PT_SILENCE;
    }

    Unlock();

    LOG((TL_ERROR, "StopTone - exit - return %lx", hr));

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP
CPhone::get_Tone(
            OUT   PHONE_TONE * pTone
            )
{
    LOG((TL_TRACE, "get_Tone - "
                                "enter"));

    if ( TAPIIsBadWritePtr( pTone, sizeof( PHONE_TONE ) ) )
    {
        LOG((TL_ERROR, "get_Tone - "
                                 "bad parameter - exit E_POINTER"));

        return E_POINTER;
    }

    Lock();

    //
    // Make sure the phone is open
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "get_Tone - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    *pTone = m_Tone;

    Unlock();

    LOG((TL_TRACE, "get_Tone - "
                                "exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP
CPhone::StartRinger(
            IN    long lRingMode,
            IN    long lDuration
            )
{
    HRESULT hr;
    DWORD   dwDummy;
    DWORD   dwVolume;
    BOOL    fResult;

    LOG((TL_TRACE, "StartRinger - enter"));
    
    if ( lDuration < 0 )
    {
        LOG((TL_ERROR, "StartRinger - "
                                 "negative argument - exit E_INVALIDARG"));

        return E_INVALIDARG;
    }

    Lock();

    //
    // Make sure the phone is open with owner privilege.
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "StartRinger - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    if ( m_dwPrivilege != PHONEPRIVILEGE_OWNER )
    {
        LOG((TL_ERROR, "StartRinger - wrong phone privilege - "
                                 "exit TAPI_E_NOTOWNER"));

        Unlock();

        return TAPI_E_NOTOWNER;
    }

    //
    // Kill ring timer
    //

    if (m_hRingTimer)
    {
        EnterCriticalSection( &m_csRingTimer );

        DeleteTimerQueueTimer(m_hTimerQueue,
                              m_hRingTimer,
                              INVALID_HANDLE_VALUE  // blocking
                             );

        m_hRingTimer = NULL;

        LeaveCriticalSection( &m_csRingTimer );
    }

    //
    // Start ring and set duration and period
    //

    m_dwRingDuration = lDuration;

    if (lRingMode == 0)
    {
        if (m_fUseWaveForRinger)
        {         
            m_dwRingPeriod = 4000;

            hr = m_WavePlayer.StartRing();
        }
        else
        {
            m_dwRingPeriod = 0;

            hr = put_RingMode(1);
        }
    }
    else
    {
        m_dwRingPeriod = 0;

        hr = put_RingMode(lRingMode);
    }

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "StartRinger - exit 0x%08x", hr));
        Unlock();

        return hr;
    }

    if ( (m_dwRingPeriod > 0) &&
         ((m_dwRingPeriod < m_dwRingDuration) || (m_dwRingDuration == 0)) )
    {
        //
        // Ring is periodic (wave generated) and duration is greater than the period
        //
        fResult = CreateTimerQueueTimer(&m_hRingTimer,
                      m_hTimerQueue,
                      &CPhone::RingTimerCallback,
                      (PVOID)this,
                      m_dwRingPeriod,
                      m_dwRingPeriod,
                      WT_EXECUTEINIOTHREAD
                     );

        if (fResult == FALSE)
        {
            // CreateTimerQueueTimer failed, lets stop the ring and bail out
            LOG((TL_ERROR, "StartRinger - CreateTimerQueueTimer failed - %lx", GetLastError()));

            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else if (m_dwRingDuration > 0)
    {
        //
        // Ring is not periodic (ringer generated), or duration is less than period
        //
        fResult = CreateTimerQueueTimer(&m_hRingTimer,
                      m_hTimerQueue,
                      &CPhone::RingTimerCallback,
                      (PVOID)this,
                      m_dwRingDuration,
                      0,
                      WT_EXECUTEINIOTHREAD
                     );

        if (fResult == FALSE)
        {
            // CreateTimerQueueTimer failed, lets stop the ring and bail out
            LOG((TL_ERROR, "StartRinger - CreateTimerQueueTimer failed - %lx", GetLastError()));

            hr = HRESULT_FROM_WIN32(GetLastError());                       
        }
    }

    if ( FAILED(hr) )
    {
        if (m_fUseWaveForRinger)
        {         
            m_WavePlayer.StopRing();
        }
        else
        {
            put_RingMode(0);
        } 

        LOG((TL_ERROR, "StartRinger - exit 0x%08x", hr));
        Unlock();

        return hr;
    }

    m_fRinger = TRUE;

    Unlock();

    LOG((TL_TRACE, "StartRinger - exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP
CPhone::StopRinger()
{
    HRESULT hr;
    DWORD dwDummy;
    DWORD dwVolume;

    LOG((TL_TRACE, "StopRinger - enter"));

    Lock();

    //
    // Make sure the phone is open with owner privilege.
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "StopRinger - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    if ( m_dwPrivilege != PHONEPRIVILEGE_OWNER )
    {
        LOG((TL_ERROR, "StopRinger - wrong phone privilege - "
                                 "exit TAPI_E_NOTOWNER"));

        Unlock();

        return TAPI_E_NOTOWNER;
    }

    //
    // Kill ring timer
    //

    if (m_hRingTimer)
    {
        EnterCriticalSection( &m_csRingTimer );

        DeleteTimerQueueTimer(m_hTimerQueue,
                              m_hRingTimer,
                              INVALID_HANDLE_VALUE  // blocking
                             );

        m_hRingTimer = NULL;

        LeaveCriticalSection( &m_csRingTimer );
    }

    if (m_fUseWaveForRinger)
    {
        hr = m_WavePlayer.StopRing();
    }
    else
    {
        hr = put_RingMode( 0 );
    }

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "StopRinger - exit 0x%08x", hr));

        Unlock();
        return hr;
    }

    m_fRinger = FALSE;

    Unlock();

    LOG((TL_TRACE, "StopRinger - exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP
CPhone::get_Ringer(
            OUT   VARIANT_BOOL * pfRinging
            )
{
    LOG((TL_TRACE, "get_Ringer - "
                                "enter"));

    if ( TAPIIsBadWritePtr( pfRinging, sizeof( VARIANT_BOOL ) ) )
    {
        LOG((TL_ERROR, "get_Ringer - "
                                 "bad parameter - exit E_POINTER"));

        return E_POINTER;
    }

    Lock();

    //
    // Make sure the phone is open
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "get_Ringer - phone not open"));
        Unlock();
        
        return TAPI_E_PHONENOTOPEN;
    }

    //
    // Translate from BOOL to VARIANT_BOOL.
    //

    *pfRinging = m_fRinger ? VARIANT_TRUE : VARIANT_FALSE;

    Unlock();

    LOG((TL_TRACE, "get_Ringer - "
                                "exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP
CPhone::put_PhoneHandlingEnabled(
            IN    VARIANT_BOOL fEnabled
            )
{
    LOG((TL_TRACE, "put_PhoneHandlingEnabled - "
                                "enter"));

    //
    // Translate from VARIANT_BOOL to BOOL. If someone mistakenly
    // passes in TRUE instead of VARIANT_TRUE, we are still ok.
    //

    Lock();

    //
    // Make sure the phone is open with owner privilege.
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "put_PhoneHandlingEnabled - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    if ( m_dwPrivilege != PHONEPRIVILEGE_OWNER )
    {
        LOG((TL_ERROR, "put_PhoneHandlingEnabled - wrong phone privilege - "
                                 "exit TAPI_E_NOTOWNER"));

        Unlock();

        return TAPI_E_NOTOWNER;
    }

    //
    // Make sure there is no call selected on the phone
    //

    if ( m_pCall != NULL )
    {
        LOG((TL_ERROR, "put_PhoneHandlingEnabled - a call is "
                                 "selected - exit TAPI_E_INUSE"));

        Unlock();
    
        return TAPI_E_INUSE;
    }

    EnterCriticalSection(&m_csAutomatedPhoneState);
    
    m_fPhoneHandlingEnabled = fEnabled ? TRUE : FALSE;

    if (m_fPhoneHandlingEnabled)
    {
        HRESULT hr;
        DWORD dwHookSwitchDevs;

        m_dwOffHookCount = 0;

        hr = PhoneGetHookSwitch(m_hPhone, &dwHookSwitchDevs);
  
        if ( SUCCEEDED(hr) )
        {            
            if (dwHookSwitchDevs & PHONEHOOKSWITCHDEV_HANDSET) m_dwOffHookCount++;
            if (dwHookSwitchDevs & PHONEHOOKSWITCHDEV_SPEAKER) m_dwOffHookCount++;
            if (dwHookSwitchDevs & PHONEHOOKSWITCHDEV_HEADSET) m_dwOffHookCount++;

            if (m_dwOffHookCount > 0)
            {
                // phone is off hook
                m_AutomatedPhoneState = APS_OFFHOOK_DEAD_LINE;
            }
            else
            {
                // phone is on hook
                m_AutomatedPhoneState = APS_ONHOOK_IDLE;
            }
        }
        else
        {
            LOG((TL_ERROR, "put_PhoneHandlingEnabled - PhoneGetHookSwitch failed - %lx", hr));
        }
    }

    LeaveCriticalSection(&m_csAutomatedPhoneState);

    Unlock();

    LOG((TL_TRACE, "put_PhoneHandlingEnabled - "
                                "exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP
CPhone::get_PhoneHandlingEnabled(
            OUT   VARIANT_BOOL * pfEnabled
            )
{
    LOG((TL_TRACE, "get_PhoneHandlingEnabled - "
                                "enter"));

    if ( TAPIIsBadWritePtr( pfEnabled, sizeof( VARIANT_BOOL ) ) )
    {
        LOG((TL_ERROR, "get_PhoneHandlingEnabled - "
                                 "bad parameter - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // Translate from BOOL to VARIANT_BOOL.
    //

    Lock();

    //
    // Make sure the phone is open
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "get_PhoneHandlingEnabled - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    EnterCriticalSection(&m_csAutomatedPhoneState);

    *pfEnabled = m_fPhoneHandlingEnabled ? VARIANT_TRUE : VARIANT_FALSE;

    LeaveCriticalSection(&m_csAutomatedPhoneState);

    Unlock();

    LOG((TL_TRACE, "get_PhoneHandlingEnabled - "
                                "exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP
CPhone::put_AutoEndOfNumberTimeout(
            IN    long lTimeout
            )
{
    LOG((TL_TRACE, "put_AutoEndOfNumberTimeout - "
                                "enter"));

    if ( lTimeout < 0 )
    {
        LOG((TL_ERROR, "put_AutoEndOfNumberTimeout - "
                                 "negative argument - exit E_INVALIDARG"));

        return E_INVALIDARG;
    }

    Lock();

    //
    // Make sure the phone is open with owner privilege
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "put_AutoEndOfNumberTimeout - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    if ( m_dwPrivilege != PHONEPRIVILEGE_OWNER )
    {
        LOG((TL_ERROR, "put_AutoEndOfNumberTimeout - wrong phone privilege - "
                                 "exit TAPI_E_NOTOWNER"));

        Unlock();

        return TAPI_E_NOTOWNER;
    }

    EnterCriticalSection(&m_csAutomatedPhoneState);

    m_dwAutoEndOfNumberTimeout = lTimeout;

    LeaveCriticalSection(&m_csAutomatedPhoneState);

    Unlock();

    LOG((TL_TRACE, "put_AutoEndOfNumberTimeout - "
                                "exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP
CPhone::get_AutoEndOfNumberTimeout(
            OUT   long * plTimeout
            )
{
    LOG((TL_TRACE, "get_AutoEndOfNumberTimeout - "
                                "enter"));

    if ( TAPIIsBadWritePtr( plTimeout, sizeof( long ) ) )
    {
        LOG((TL_ERROR, "get_AutoEndOfNumberTimeout - "
                                 "bad parameter - exit E_POINTER"));

        return E_POINTER;
    }

    Lock();

    //
    // Make sure the phone is open
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "get_AutoEndOfNumberTimeout - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    EnterCriticalSection(&m_csAutomatedPhoneState);

    *plTimeout = m_dwAutoEndOfNumberTimeout;

    LeaveCriticalSection(&m_csAutomatedPhoneState);

    Unlock();

    LOG((TL_TRACE, "get_AutoEndOfNumberTimeout - "
                                "exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP
CPhone::put_AutoDialtone(
            IN    VARIANT_BOOL fEnabled
            )
{
    LOG((TL_TRACE, "put_AutoDialtone - "
                                "enter"));

    //
    // Translate from VARIANT_BOOL to BOOL. If someone mistakenly
    // passes in TRUE instead of VARIANT_TRUE, we are still ok.
    //

    Lock();

    //
    // Make sure the phone is open with owner privilege
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "put_AutoDialtone - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    if ( m_dwPrivilege != PHONEPRIVILEGE_OWNER )
    {
        LOG((TL_ERROR, "put_AutoDialtone - wrong phone privilege - "
                                 "exit TAPI_E_NOTOWNER"));

        Unlock();

        return TAPI_E_NOTOWNER;
    }

    EnterCriticalSection(&m_csAutomatedPhoneState);

    m_fAutoDialtone = fEnabled ? TRUE : FALSE;

    LeaveCriticalSection(&m_csAutomatedPhoneState);

    Unlock();

    LOG((TL_TRACE, "put_AutoDialtone - "
                                "exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP
CPhone::get_AutoDialtone(
            OUT   VARIANT_BOOL * pfEnabled
            )
{
    LOG((TL_TRACE, "get_AutoDialtone - "
                                "enter"));

    if ( TAPIIsBadWritePtr( pfEnabled, sizeof( VARIANT_BOOL ) ) )
    {
        LOG((TL_ERROR, "get_AutoDialtone - "
                                 "bad parameter - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // Translate from BOOL to VARIANT_BOOL.
    //

    Lock();

    //
    // Make sure the phone is open
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "get_AutoDialtone - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    EnterCriticalSection(&m_csAutomatedPhoneState);

    *pfEnabled = m_fAutoDialtone ? VARIANT_TRUE : VARIANT_FALSE;

    LeaveCriticalSection(&m_csAutomatedPhoneState);

    Unlock();

    LOG((TL_TRACE, "get_AutoDialtone - "
                                "exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP
CPhone::put_AutoStopTonesOnOnHook(
            IN    VARIANT_BOOL fEnabled
            )
{
    LOG((TL_TRACE, "put_AutoStopTonesOnOnHook - "
                                "enter"));

    //
    // Translate from VARIANT_BOOL to BOOL. If someone mistakenly
    // passes in TRUE instead of VARIANT_TRUE, we are still ok.
    //

    Lock();

    //
    // Make sure the phone is open with owner privilege
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "put_AutoStopTonesOnOnHook - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    if ( m_dwPrivilege != PHONEPRIVILEGE_OWNER )
    {
        LOG((TL_ERROR, "put_AutoStopTonesOnOnHook - wrong phone privilege - "
                                 "exit TAPI_E_NOTOWNER"));

        Unlock();

        return TAPI_E_NOTOWNER;
    }

    EnterCriticalSection(&m_csAutomatedPhoneState);

    m_fAutoStopTonesOnOnHook = fEnabled ? TRUE : FALSE;

    LeaveCriticalSection(&m_csAutomatedPhoneState);

    Unlock();

    LOG((TL_TRACE, "put_AutoStopTonesOnOnHook - "
                                "exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP
CPhone::get_AutoStopTonesOnOnHook(
            OUT   VARIANT_BOOL * pfEnabled
            )
{
    LOG((TL_TRACE, "get_AutoStopTonesOnOnHook - "
                                "enter"));

    if ( TAPIIsBadWritePtr( pfEnabled, sizeof( VARIANT_BOOL ) ) )
    {
        LOG((TL_ERROR, "get_AutoStopTonesOnOnHook - "
                                 "bad parameter - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // Translate from BOOL to VARIANT_BOOL.
    //

    Lock();

    //
    // Make sure the phone is open
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "get_AutoDialtone - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    EnterCriticalSection(&m_csAutomatedPhoneState);

    *pfEnabled = m_fAutoStopTonesOnOnHook ? VARIANT_TRUE : VARIANT_FALSE;

    LeaveCriticalSection(&m_csAutomatedPhoneState);

    Unlock();

    LOG((TL_TRACE, "get_AutoStopTonesOnOnHook - "
                                "exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP
CPhone::put_AutoStopRingOnOffHook(
            IN    VARIANT_BOOL fEnabled
            )
{
    LOG((TL_TRACE, "put_AutoStopRingOnOffHook - "
                                "enter"));

    //
    // Translate from VARIANT_BOOL to BOOL. If someone mistakenly
    // passes in TRUE instead of VARIANT_TRUE, we are still ok.
    //

    Lock();

    //
    // Make sure the phone is open with owner privilege
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "put_AutoStopRingOnOffHook - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    if ( m_dwPrivilege != PHONEPRIVILEGE_OWNER )
    {
        LOG((TL_ERROR, "put_AutoStopRingOnOffHook - wrong phone privilege - "
                                 "exit TAPI_E_NOTOWNER"));

        Unlock();

        return TAPI_E_NOTOWNER;
    }

    EnterCriticalSection(&m_csAutomatedPhoneState);

    m_fAutoStopRingOnOffHook = fEnabled ? TRUE : FALSE;

    LeaveCriticalSection(&m_csAutomatedPhoneState);

    Unlock();

    LOG((TL_TRACE, "put_AutoStopRingOnOffHook - "
                                "exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP
CPhone::get_AutoStopRingOnOffHook(
            OUT   VARIANT_BOOL * pfEnabled
            )
{
    LOG((TL_TRACE, "get_AutoStopRingOnOffHook - "
                                "enter"));

    if ( TAPIIsBadWritePtr( pfEnabled, sizeof( VARIANT_BOOL ) ) )
    {
        LOG((TL_ERROR, "get_AutoStopRingOnOffHook - "
                                 "bad parameter - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // Translate from BOOL to VARIANT_BOOL.
    //

    Lock();

    //
    // Make sure the phone is open
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "get_AutoStopRingOnOffHook - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    EnterCriticalSection(&m_csAutomatedPhoneState);

    *pfEnabled = m_fAutoStopRingOnOffHook ? VARIANT_TRUE : VARIANT_FALSE;

    LeaveCriticalSection(&m_csAutomatedPhoneState);

    Unlock();

    LOG((TL_TRACE, "get_AutoStopRingOnOffHook - "
                                "exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP
CPhone::put_AutoKeypadTones(
            IN    VARIANT_BOOL fEnabled
            )
{
    LOG((TL_TRACE, "put_AutoKeypadTones - "
                                "enter"));

    //
    // Translate from VARIANT_BOOL to BOOL. If someone mistakenly
    // passes in TRUE instead of VARIANT_TRUE, we are still ok.
    //

    Lock();

    //
    // Make sure the phone is open with owner privilege
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "put_AutoKeypadTones - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    if ( m_dwPrivilege != PHONEPRIVILEGE_OWNER )
    {
        LOG((TL_ERROR, "put_AutoKeypadTones - wrong phone privilege - "
                                 "exit TAPI_E_NOTOWNER"));

        Unlock();

        return TAPI_E_NOTOWNER;
    }

    EnterCriticalSection(&m_csAutomatedPhoneState);

    m_fAutoKeypadTones = fEnabled ? TRUE : FALSE;

    LeaveCriticalSection(&m_csAutomatedPhoneState);

    Unlock();

    LOG((TL_TRACE, "put_AutoKeypadTones - "
                                "exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP
CPhone::get_AutoKeypadTones (
            OUT   VARIANT_BOOL * pfEnabled
            )
{
    LOG((TL_TRACE, "get_AutoKeypadTones - "
                                "enter"));

    if ( TAPIIsBadWritePtr( pfEnabled, sizeof( VARIANT_BOOL ) ) )
    {
        LOG((TL_ERROR, "get_AutoKeypadTones - "
                                 "bad parameter - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // Translate from BOOL to VARIANT_BOOL.
    //

    Lock();

    //
    // Make sure the phone is open
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "get_AutoKeypadTones - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    EnterCriticalSection(&m_csAutomatedPhoneState);

    *pfEnabled = m_fAutoKeypadTones ? VARIANT_TRUE : VARIANT_FALSE;

    LeaveCriticalSection(&m_csAutomatedPhoneState);

    Unlock();

    LOG((TL_TRACE, "get_AutoKeypadTones - "
                                "exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP
CPhone::put_AutoKeypadTonesMinimumDuration(
            IN    long lDuration
            )
{
    LOG((TL_TRACE, "put_AutoKeypadTonesMinimumDuration - "
                                "enter"));

    if ( lDuration < 0 )
    {
        LOG((TL_ERROR, "put_AutoKeypadTonesMinimumDuration - "
                                 "negative argument - exit E_INVALIDARG"));

        return E_INVALIDARG;
    }

    Lock();

    //
    // Make sure the phone is open with owner privilege
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "put_AutoKeypadTonesMinimumDuration - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    if ( m_dwPrivilege != PHONEPRIVILEGE_OWNER )
    {
        LOG((TL_ERROR, "put_AutoKeypadTonesMinimumDuration - wrong phone privilege - "
                                 "exit TAPI_E_NOTOWNER"));

        Unlock();

        return TAPI_E_NOTOWNER;
    }

    EnterCriticalSection(&m_csAutomatedPhoneState);

    m_dwAutoKeypadTonesMinimumDuration = lDuration;

    LeaveCriticalSection(&m_csAutomatedPhoneState);

    Unlock();

    LOG((TL_TRACE, "put_AutoKeypadTonesMinimumDuration - "
                                "exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP
CPhone::get_AutoKeypadTonesMinimumDuration(
            OUT   long * plDuration
            )
{
    LOG((TL_TRACE, "get_AutoKeypadTonesMinimumDuration - "
                                "enter"));

    if ( TAPIIsBadWritePtr( plDuration, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_AutoKeypadTonesMinimumDuration - "
                                 "bad parameter - exit E_POINTER"));

        return E_POINTER;
    }

    Lock();

    //
    // Make sure the phone is open
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "get_AutoKeypadTonesMinimumDuration - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    EnterCriticalSection(&m_csAutomatedPhoneState);

    *plDuration = m_dwAutoKeypadTonesMinimumDuration;

    LeaveCriticalSection(&m_csAutomatedPhoneState);

    Unlock();

    LOG((TL_TRACE, "get_AutoKeypadTonesMinimumDuration - "
                                "exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP
CPhone::put_AutoVolumeControl(
            IN    VARIANT_BOOL fEnabled
            )
{
    LOG((TL_TRACE, "put_AutoVolumeControl - "
                                "enter"));

    //
    // Translate from VARIANT_BOOL to BOOL. If someone mistakenly
    // passes in TRUE instead of VARIANT_TRUE, we are still ok.
    //

    Lock();

    //
    // Make sure the phone is open with owner privilege
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "put_AutoVolumeControl - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    if ( m_dwPrivilege != PHONEPRIVILEGE_OWNER )
    {
        LOG((TL_ERROR, "put_AutoVolumeControl - wrong phone privilege - "
                                 "exit TAPI_E_NOTOWNER"));

        Unlock();

        return TAPI_E_NOTOWNER;
    }

    EnterCriticalSection(&m_csAutomatedPhoneState);

    m_fAutoVolumeControl = fEnabled ? TRUE : FALSE;

    LeaveCriticalSection(&m_csAutomatedPhoneState);

    Unlock();

    LOG((TL_TRACE, "put_AutoVolumeControl - "
                                "exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP
CPhone::get_AutoVolumeControl (
            OUT   VARIANT_BOOL * pfEnabled
            )
{
    LOG((TL_TRACE, "get_AutoVolumeControl - "
                                "enter"));

    if ( TAPIIsBadWritePtr( pfEnabled, sizeof( VARIANT_BOOL ) ) )
    {
        LOG((TL_ERROR, "get_AutoVolumeControl - "
                                 "bad parameter - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // Translate from BOOL to VARIANT_BOOL.
    //

    Lock();

    //
    // Make sure the phone is open
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "get_AutoVolumeControl - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    EnterCriticalSection(&m_csAutomatedPhoneState);

    *pfEnabled = m_fAutoVolumeControl ? VARIANT_TRUE : VARIANT_FALSE;

    LeaveCriticalSection(&m_csAutomatedPhoneState);

    Unlock();

    LOG((TL_TRACE, "get_AutoVolumeControl - "
                                "exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP
CPhone::put_AutoVolumeControlStep(
            IN    long lStepSize
            )
{
    LOG((TL_TRACE, "put_AutoVolumeControlStep - "
                                "enter"));

    if ( (lStepSize < 0) || (lStepSize > 0xFFFF) )
    {
        LOG((TL_ERROR, "put_AutoVolumeControlStep - "
                                 "invalid argument - exit E_INVALIDARG"));

        return E_INVALIDARG;
    }

    Lock();

    //
    // Make sure the phone is open with owner privilege
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "put_AutoVolumeControlStep - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    if ( m_dwPrivilege != PHONEPRIVILEGE_OWNER )
    {
        LOG((TL_ERROR, "put_AutoVolumeControlStep - wrong phone privilege - "
                                 "exit TAPI_E_NOTOWNER"));

        Unlock();

        return TAPI_E_NOTOWNER;
    }

    EnterCriticalSection(&m_csAutomatedPhoneState);

    m_dwAutoVolumeControlStep = lStepSize;

    LeaveCriticalSection(&m_csAutomatedPhoneState);

    Unlock();

    LOG((TL_TRACE, "put_AutoVolumeControlStep - "
                                "exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP
CPhone::get_AutoVolumeControlStep(
            OUT   long * plStepSize
            )
{
    LOG((TL_TRACE, "get_AutoVolumeControlStep - "
                                "enter"));

    if ( TAPIIsBadWritePtr( plStepSize, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_AutoVolumeControlStep - "
                                 "bad parameter - exit E_POINTER"));

        return E_POINTER;
    }

    Lock();

    //
    // Make sure the phone is open
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "get_AutoVolumeControlStep - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    EnterCriticalSection(&m_csAutomatedPhoneState);

    *plStepSize = m_dwAutoVolumeControlStep;

    LeaveCriticalSection(&m_csAutomatedPhoneState);

    Unlock();

    LOG((TL_TRACE, "get_AutoVolumeControlStep - "
                                "exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP
CPhone::put_AutoVolumeControlRepeatDelay(
            IN    long lDelay
            )
{
    LOG((TL_TRACE, "put_AutoVolumeControlRepeatDelay - "
                                "enter"));

    if ( lDelay < 0 )
    {
        LOG((TL_ERROR, "put_AutoVolumeControlRepeatDelay - "
                                 "invalid argument - exit E_INVALIDARG"));

        return E_INVALIDARG;
    }

    Lock();

    //
    // Make sure the phone is open with owner privilege
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "put_AutoVolumeControlRepeatDelay - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    if ( m_dwPrivilege != PHONEPRIVILEGE_OWNER )
    {
        LOG((TL_ERROR, "put_AutoVolumeControlRepeatDelay - wrong phone privilege - "
                                 "exit TAPI_E_NOTOWNER"));

        Unlock();

        return TAPI_E_NOTOWNER;
    }

    EnterCriticalSection(&m_csAutomatedPhoneState);

    m_dwAutoVolumeControlRepeatDelay = lDelay;

    LeaveCriticalSection(&m_csAutomatedPhoneState);

    Unlock();

    LOG((TL_TRACE, "put_AutoVolumeControlRepeatDelay - "
                                "exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP
CPhone::get_AutoVolumeControlRepeatDelay(
            OUT   long * plDelay
            )
{
    LOG((TL_TRACE, "get_AutoVolumeControlRepeatDelay - "
                                "enter"));

    if ( TAPIIsBadWritePtr( plDelay, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_AutoVolumeControlRepeatDelay - "
                                 "bad parameter - exit E_POINTER"));

        return E_POINTER;
    }

    Lock();

    //
    // Make sure the phone is open
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "get_AutoVolumeControlRepeatDelay - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    EnterCriticalSection(&m_csAutomatedPhoneState);

    *plDelay = m_dwAutoVolumeControlRepeatDelay;

    LeaveCriticalSection(&m_csAutomatedPhoneState);

    Unlock();

    LOG((TL_TRACE, "get_AutoVolumeControlRepeatDelay - "
                                "exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP
CPhone::put_AutoVolumeControlRepeatPeriod(
            IN    long lPeriod
            )
{
    LOG((TL_TRACE, "put_AutoVolumeControlRepeatPeriod - "
                                "enter"));

    if ( lPeriod < 0 )
    {
        LOG((TL_ERROR, "put_AutoVolumeControlRepeatPeriod - "
                                 "invalid argument - exit E_INVALIDARG"));

        return E_INVALIDARG;
    }

    Lock();

    //
    // Make sure the phone is open with owner privilege
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "put_AutoVolumeControlRepeatPeriod - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    if ( m_dwPrivilege != PHONEPRIVILEGE_OWNER )
    {
        LOG((TL_ERROR, "put_AutoVolumeControlRepeatPeriod - wrong phone privilege - "
                                 "exit TAPI_E_NOTOWNER"));

        Unlock();

        return TAPI_E_NOTOWNER;
    }

    EnterCriticalSection(&m_csAutomatedPhoneState);

    m_dwAutoVolumeControlRepeatPeriod = lPeriod;

    LeaveCriticalSection(&m_csAutomatedPhoneState);

    Unlock();

    LOG((TL_TRACE, "put_AutoVolumeControlRepeatPeriod - "
                                "exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP
CPhone::get_AutoVolumeControlRepeatPeriod(
            OUT   long * plPeriod
            )
{
    LOG((TL_TRACE, "get_AutoVolumeControlRepeatPeriod - "
                                "enter"));

    if ( TAPIIsBadWritePtr( plPeriod, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_AutoVolumeControlRepeatPeriod - "
                                 "bad parameter - exit E_POINTER"));

        return E_POINTER;
    }

    Lock();

    //
    // Make sure the phone is open
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "get_AutoVolumeControlRepeatPeriod - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    EnterCriticalSection(&m_csAutomatedPhoneState);

    *plPeriod = m_dwAutoVolumeControlRepeatPeriod;

    LeaveCriticalSection(&m_csAutomatedPhoneState);

    Unlock();

    LOG((TL_TRACE, "get_AutoVolumeControlRepeatPeriod - "
                                "exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// UnselectAllPreviouslySelectedTerminals
//
// pCallBCC2 -- the call on which we started to select terminals
// pTerminal -- the last terminal we tried to select; it failed
// pEnum     -- the enumerator that gave us the terminals we tried to select
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

void
CPhone::UnselectAllPreviouslySelectedTerminals(
           IN   ITBasicCallControl2 * pCall,
           IN   ITTerminal          * pTerminalThatFailed,
           IN   IEnumTerminal       * pEnum
           )
{
    HRESULT hr;

    LOG((TL_TRACE, "UnselectAllPreviouslySelectedTerminals - "
                                "enter"));

    //
    // Reset the enumerator. If this fails, stop -- we don't want to risk
    // unselecting terminals that were selected independently of SelectCall().
    //

    hr = pEnum->Reset();

    if ( FAILED(hr) )
    {
        LOG((TL_WARN,
                "UnselectAllPreviouslySelectedTerminals - "
                "failed to reset enumerator %p - "
                "hr = 0x%08x. Not unselecting terminals.", pEnum, hr ));

        return;
    }

    ITTerminal * pTerminal;
    BOOL         fDone = FALSE;

    while ( S_OK == pEnum->Next( 1, & pTerminal, NULL ) )
    {
        if ( pTerminal == pTerminalThatFailed )
        {
            fDone = TRUE;
        }
        else
        {
            //
            // Try to unselect the terminal. If it fails to unselect, there's
            // nothing more we can do... just continue trying to unselect the
            // rest of the terminals.
            //
        
            hr = pCall->UnselectTerminalOnCall( pTerminal );

            if ( FAILED(hr) )
            {
                LOG((TL_WARN,
                        "UnselectAllPreviouslySelectedTerminals - "
                        "cannot unselect terminal %p on ITBCC2 %p - "
                        "hr = 0x%08x. Continuing...", pTerminal, pCall, hr ));
            }
        }

        pTerminal->Release();

        if ( fDone == TRUE )
        {
            break;
        }
    }

    LOG((TL_TRACE, "UnselectAllPreviouslySelectedTerminals - "
                                "normal exit"));
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

HRESULT
CPhone::SelectDefaultTerminalsOnCall(
            IN   ITCallInfo * pCall
            )
{
    LOG((TL_TRACE, "SelectDefaultTerminalsOnCall - enter" ));

    //
    // Get the address for the call
    //

    HRESULT     hr;
    ITAddress * pAddress;

    hr = pCall->get_Address( & pAddress );

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "SelectDefaultTerminalsOnCall - "
                                 "cannot get call's "
                                 "address - exit 0x%08x", hr ));

        return hr;
    }

    //
    // Find the default terminals for this phone.
    //

    IEnumTerminal * pEnum;

    hr = EnumerateTerminals( pAddress, & pEnum );

    pAddress->Release();

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "SelectDefaultTerminalsOnCall - "
                                 "cannot enum phone's "
                                 "terminals - exit 0x%08x", hr ));

        return hr;
    }

    //
    // Get the terminal selection interface on the call.
    //

    ITBasicCallControl2 * pCallBCC2;

    hr = pCall->QueryInterface( IID_ITBasicCallControl2,
                                (void **) & pCallBCC2 );

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "SelectDefaultTerminalsOnCall - "
                                 "cannot get call's "
                                 "ITBasicCallControl2 interface - "
                                 "exit 0x%08x", hr ));

        pEnum->Release();
        
        return hr;
    }

    //
    // Select each of the default terminals on the call.
    //

    ITTerminal * pTerminal;

    while ( S_OK == pEnum->Next( 1, & pTerminal, NULL ) )
    {
        //
        // Select each terminal on the call.
        // If one selection fails, unselect all the terminals
        // that were successfully selected.
        //

        hr = pCallBCC2->SelectTerminalOnCall( pTerminal );

        if ( FAILED(hr) )
        {
            LOG((TL_ERROR, "SelectDefaultTerminalsOnCall - "
                                     "cannot select "
                                     "terminal %p on ITBCC2 %p - "
                                     "unselecting other terminals",
                                     pTerminal, pCallBCC2 ));

            UnselectAllPreviouslySelectedTerminals(pCallBCC2,
                                                   pTerminal,
                                                   pEnum);

            LOG((TL_ERROR, "SelectDefaultTerminalsOnCall - "
                                     "exit 0x%08x", hr ));

            pTerminal->Release();

            pEnum->Release();
            
            pCallBCC2->Release();

            return hr;
         }

         pTerminal->Release();
    }

    pEnum->Release();
    
    pCallBCC2->Release();

    LOG((TL_TRACE, "SelectDefaultTerminalsOnCall - exit S_OK" ));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

HRESULT
CPhone::UnselectDefaultTerminalsOnCall(
            IN   ITCallInfo * pCall
            )
{
    LOG((TL_TRACE, "UnselectDefaultTerminalsOnCall - enter" ));

    //
    // Get the address for the call
    //

    HRESULT     hr;
    ITAddress * pAddress;

    hr = pCall->get_Address( & pAddress );

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "UnselectDefaultTerminalsOnCall - "
                                 "cannot get call's "
                                 "address - exit 0x%08x", hr ));

        return hr;
    }

    //
    // Find the default terminals for this phone.
    //

    IEnumTerminal * pEnum;

    hr = EnumerateTerminals( pAddress, & pEnum );

    pAddress->Release();

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "UnselectDefaultTerminalsOnCall - "
                                 "cannot enum phone's "
                                 "terminals - exit 0x%08x", hr ));

        return hr;
    }

    //
    // Get the terminal selection interface on the call.
    //

    ITBasicCallControl2 * pCallBCC2;

    hr = pCall->QueryInterface( IID_ITBasicCallControl2,
                                (void **) & pCallBCC2 );

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "UnselectDefaultTerminalsOnCall - "
                                 "cannot get call's "
                                 "ITBasicCallControl2 interface - "
                                 "exit 0x%08x", hr ));

        pEnum->Release();
        
        return hr;
    }

    //
    // Unselect each of the default terminals on the call.
    //

    ITTerminal * pTerminal;

    while ( S_OK == pEnum->Next( 1, & pTerminal, NULL ) )
    {
        //
        // Unselect each terminal on the call.
        // If one unselection fails, keep on going
        //

        hr = pCallBCC2->UnselectTerminalOnCall( pTerminal );

        if ( FAILED(hr) )
        {
            LOG((TL_ERROR, "UnselectDefaultTerminalsOnCall - "
                                     "cannot unselect "
                                     "terminal %p on ITBCC2 %p",                                   
                                     pTerminal, pCallBCC2 ));
        }

        pTerminal->Release();
    }

    pEnum->Release();
    
    pCallBCC2->Release();

    LOG((TL_TRACE, "UnselectDefaultTerminalsOnCall - exit S_OK" ));

    return S_OK;
}
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP
CPhone::SelectCall(
            IN    ITCallInfo   * pCall,
            IN    VARIANT_BOOL   fSelectDefaultTerminals
            )
{
    HRESULT         hr;
    CALL_STATE      cs;
    CALL_PRIVILEGE  priv;

    LOG((TL_TRACE, "SelectCall - enter"));

    //
    // check argument
    //

    if ( IsBadReadPtr( pCall, sizeof( ITCallInfo ) ) )
    {
        LOG((TL_ERROR, "SelectCall - exit E_POINTER"));
        
        return E_POINTER;
    }

    //
    // Check if the app has owner privilege on this call.
    //

    hr = pCall->get_Privilege( & priv );

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "SelectCall - cannot get call privilege - "
                                 "exit 0x%08x", hr ));

        return hr;
    }

    if ( priv != CP_OWNER )
    {
        LOG((TL_ERROR, "SelectCall - wrong call privilege - "
                                 "exit TAPI_E_NOTOWNER"));

        return TAPI_E_NOTOWNER;
    }

    //
    // check to make sure the call state isn't disconnected
    //

    hr = pCall->get_CallState( & cs );

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "SelectCall - cannot get call state - "
                                 "exit 0x%08x", hr ));

        return hr;
    }

    if ( cs == CS_DISCONNECTED )
    {
        LOG((TL_ERROR, "SelectCall - call is disconnected - "
                                 "exit TAPI_E_INVALCALLSTATE"));

        return TAPI_E_INVALCALLSTATE;
    }

    //
    // check if another call already selected
    //

    Lock();

    if ( m_pCall != NULL )
    {
        LOG((TL_ERROR, "SelectCall - another call already "
                                 "selected - exit TAPI_E_INUSE"));

        Unlock();
    
        return TAPI_E_INUSE;
    }

    //
    // Make sure the phone is open with owner privilege.
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "SelectCall - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    if ( m_dwPrivilege != PHONEPRIVILEGE_OWNER )
    {
        LOG((TL_ERROR, "SelectCall - wrong phone privilege - "
                                 "exit TAPI_E_NOTOWNER"));

        Unlock();

        return TAPI_E_NOTOWNER;
    }

    m_fDefaultTerminalsSelected = FALSE;

    //
    // Perform default terminal selection if the invoker wants it.
    //

    if ( fSelectDefaultTerminals != VARIANT_FALSE )
    {
        hr = SelectDefaultTerminalsOnCall( pCall );

        if ( FAILED(hr) )
        {
            LOG((TL_ERROR, "SelectCall - failed to select "
                                     "terminals - exit 0x%08x", hr ));

            Unlock();

            return hr;
        }

        //
        // Set this flag so that we know to unselect the terminals from the call when
        // the call is unselected
        //

        m_fDefaultTerminalsSelected = TRUE;
    }

    m_pCall = pCall;
    m_pCall->AddRef();

    Unlock();

    //
    // Now that the call is selected, get the callstate
    // so we can call Automation_CallState
    //

    hr = pCall->get_CallState( & cs );

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "SelectCall - cannot get call state - "
                                 "exit 0x%08x", hr ));

        return hr;
    }

    Automation_CallState( pCall, cs, CEC_NONE );

    LOG((TL_TRACE, "SelectCall - exit"));
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

HRESULT
CPhone::InternalUnselectCall(
            IN    ITCallInfo * pCall
            )
{
    HRESULT hr;

    LOG((TL_TRACE, "InternalUnselectCall - enter"));

    Lock();

    if ( pCall != m_pCall )
    {
        LOG((TL_ERROR, "InternalUnselectCall - call was not selected; "
                                 "exit TAPI_E_CALLNOTSELECTED"));

        Unlock();

        return TAPI_E_CALLNOTSELECTED;
    }

    //
    // Make sure the phone is open with owner privilege
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "InternalUnselectCall - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    if ( m_dwPrivilege != PHONEPRIVILEGE_OWNER )
    {
        LOG((TL_ERROR, "InternalUnselectCall - wrong phone privilege - "
                                 "exit TAPI_E_NOTOWNER"));

        Unlock();

        return TAPI_E_NOTOWNER;
    }  

    //
    // If we selected the default terminals on the call when the call was selected on this phone,
    // then we need to unselect the default terminals from the call.
    //

    if ( m_fDefaultTerminalsSelected == TRUE )
    {
        hr = UnselectDefaultTerminalsOnCall( pCall );

        if ( FAILED(hr) )
        {
            LOG((TL_ERROR, "InternalUnselectCall - UnselectDefaultTerminalsOnCall %p failed - %lx", pCall, hr ));

            // If we fail here then maybe the app already unselected the terminals. In any case
            // just continue...
        }   
        
        m_fDefaultTerminalsSelected = FALSE;
    }

    //
    // Release our reference to the call.
    //

    m_pCall->Release();
    m_pCall = NULL;

    LOG((TL_TRACE, "InternalUnselectCall - exit S_OK"));

    Unlock();
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP
CPhone::UnselectCall(
            IN    ITCallInfo * pCall
            )
{
    HRESULT hr;

    LOG((TL_TRACE, "UnselectCall - enter"));

    //
    // Check arguments.
    //

    if (IsBadReadPtr(pCall, sizeof( ITCallInfo ) ) )
    {
        LOG((TL_ERROR, "UnselectCall - "
                                 "returning E_POINTER"));

        return E_POINTER;
    }

    hr = InternalUnselectCall( pCall );

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "UnselectCall - "
            "InternalUnselectCall failed 0x%lx", hr));

        return hr;
    }

    EnterCriticalSection(&m_csAutomatedPhoneState);

    if (m_fPhoneHandlingEnabled)
    {
        switch(m_AutomatedPhoneState)
        {
        case APS_ONHOOK_RINGING_IN:
        case APS_ONHOOK_RINGING_OUT:
        case APS_ONHOOK_CONNECTED:
            {
                //
                // Stop the ringer
                //

                if (m_fRinger == TRUE) 
                {
                    StopRinger();
                }

                m_AutomatedPhoneState = APS_ONHOOK_IDLE;
            }
            break;

        case APS_OFFHOOK_RINGING_OUT:
        case APS_OFFHOOK_CALL_INIT:
        case APS_OFFHOOK_CONNECTED:                
            {
                //
                // Stop any playing tone
                //

                if (m_Tone != PT_SILENCE) 
                {
                    StopTone();
                }

                m_AutomatedPhoneState = APS_OFFHOOK_DEAD_LINE;
            }
            break;             
        }
    } //m_fPhoneHandlingEnabled

    LeaveCriticalSection(&m_csAutomatedPhoneState);

    LOG((TL_TRACE, "UnselectCall - exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP
CPhone::EnumerateSelectedCalls(
            OUT   IEnumCall ** ppCallEnum
            )
{
    HRESULT     hr = S_OK;
    
    LOG((TL_TRACE, "EnumerateSelectedCalls enter" ));
    LOG((TL_TRACE, "   ppCallEnum----->%p", ppCallEnum ));

    //
    // Check arguments.
    //

    if (TAPIIsBadWritePtr(ppCallEnum, sizeof( IEnumCall * ) ) )
    {
        LOG((TL_ERROR, "EnumerateSelectedCalls - "
                                 "returning E_POINTER"));

        return E_POINTER;
    }
    
    //
    // Create and initialize the enumerator.
    //

    CComObject< CTapiEnum< IEnumCall, ITCallInfo, &IID_IEnumCall > > * p;
    hr = CComObject< CTapiEnum< IEnumCall, ITCallInfo, &IID_IEnumCall > >
         ::CreateInstance( &p );

    if ( hr != S_OK ) // CreateInstance deletes object on S_FALSE
    {
        LOG((TL_ERROR, "EnumerateSelectedCalls - "
                                 "could not create enum - "
                                 "exit 0x%08x", hr ));
        
        return hr;
    }

    // Initialize adds a reference to p
    hr = p->Initialize( );

    if ( FAILED(hr) )
    {
        delete p;
        
        LOG((TL_ERROR, "EnumerateSelectedCalls - "
                                 "could not init enum - "
                                 "exit 0x%08x", hr ));

        return hr;
    }


    //
    // Add our single call to the enumerator, if we have one.
    //

    Lock();

    //
    // Make sure the phone is open
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "EnumerateSelectedCalls - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        p->Release();

        return TAPI_E_PHONENOTOPEN;
    }
    
    if ( m_pCall != NULL )
    {
        hr = p->Add( m_pCall );
    }
    else
    {
        hr = S_OK;
    }

    Unlock();

    //
    // Return the enum if we succeeded, else throw it away.
    //

    if ( SUCCEEDED(hr) )
    {
        *ppCallEnum = p;

        LOG((TL_TRACE, "EnumerateSelectedCalls exit - "
                                    "hr = 0x%08x", hr ));
    }
    else
    {
        p->Release();
        
        LOG((TL_ERROR, "EnumerateSelectedCalls - "
                                 "could not add call to enum - "
                                 "exit 0x%08x", hr ));
    }

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

STDMETHODIMP
CPhone::get_SelectedCalls(
            OUT   VARIANT * pVariant
            )
{
    HRESULT     hr = S_OK;
    
    LOG((TL_TRACE, "get_SelectedCalls enter" ));
    LOG((TL_TRACE, "   pVariant----->%p", pVariant ));

    //
    // Check arguments.
    //

    if ( TAPIIsBadWritePtr(pVariant, sizeof( pVariant ) ) )
    {
        LOG((TL_ERROR, "get_SelectedCalls - "
                                 "returning E_POINTER"));

        return E_POINTER;
    }

    //
    // Create an array containing no calls or our single call. This
    // type of array does not keep any COM refcounts. We will pass this
    // array into the collection object initialization, and then we will
    // shut down the array.
    //

    CTArray<ITCallInfo *> aCalls;
    BOOL                  fResult;

    Lock();

    //
    // Make sure the phone is open
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR, "get_SelectedCalls - phone is not open - "
                                 "exit TAPI_E_PHONENOTOPEN"));

        Unlock();

        aCalls.Shutdown();

        return TAPI_E_PHONENOTOPEN;
    }
    
    if ( m_pCall != NULL )
    {
        fResult = aCalls.Add( m_pCall );
    }
    else
    {
        fResult = TRUE;
    }

    Unlock();

    if ( fResult == FALSE )
    {
        LOG((TL_ERROR, "get_SelectedCalls - "
                                 "could not add call to array; "
                                 "exit E_OUTOFMEMORY" ));
        
        return E_OUTOFMEMORY;
    }
    
    //
    // Create and initialize the Collection.
    //

    CComObject< CTapiCollection< ITCallInfo > > * p;

    hr = CComObject< CTapiCollection< ITCallInfo > >
            ::CreateInstance( &p );

    if ( hr != S_OK ) // CreateInstance deleted object on S_FALSE
    {
        LOG((TL_ERROR, "get_SelectedCalls - "
                                 "could not create Collection - "
                                 "exit 0x%08x", hr ));
        
        aCalls.Shutdown();

        return hr;
    }

    //
    // Get the collection object's IDispatch interface.
    //

    IDispatch * pDisp;
    
    hr = p->_InternalQueryInterface( IID_IDispatch,
                                     (void **) & pDisp );

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "get_SelectedCalls - "
                                 "could not get IDispatch interface" ));
                
        delete p;

        return hr;
    }

    hr = p->Initialize( aCalls );

    aCalls.Shutdown();

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "get_SelectedCalls - "
                                 "could not init Collection - "
                                 "exit 0x%08x", hr ));

        pDisp->Release();
        
        return hr;
    }

    //
    // Put the collection object's IDispatch pointer into the variant.
    //

    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDisp;

    LOG((TL_TRACE, "get_SelectedCalls exit - "
                                "hr = 0x%08x", hr ));
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CPhone
// Interface : ITPhone
// Method    : DeviceSpecific
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT CPhone::DeviceSpecific(
	     IN BYTE *pbDataArray,
	     IN DWORD dwSize
        )
{
    LOG((TL_TRACE, "DeviceSpecific - enter"));


    //
    // check if arguments are any good
    //

    if ( NULL == pbDataArray )
    {
        LOG((TL_ERROR, "DeviceSpecific - pbDataArray is NULL. E_INVALIDARG"));

        return E_INVALIDARG;
    }

    if ( 0 == dwSize )
    {
        LOG((TL_ERROR, "DeviceSpecific - dwSize is 0. E_INVALIDARG"));

        return E_INVALIDARG;
    }


    //
    // check if the buffer is valid
    //

    if ( IsBadReadPtr(pbDataArray, dwSize) )
    {
        LOG((TL_ERROR, "DeviceSpecific - bad array passed in [%p] of size %ld", pbDataArray, dwSize));

        return E_POINTER;
    }


    //
    // starting to access data members. lock.
    //

    Lock();


    //
    // see if the phone is open
    //

    if ( m_hPhone == NULL )
    {
        LOG((TL_ERROR,
            "DeviceSpecific - phone not open. TAPI_E_PHONENOTOPEN"));

        Unlock();

        return TAPI_E_PHONENOTOPEN;
    }

    
    //
    // keep the phone handle
    //

    HPHONE  hPhone = m_hPhone;


    Unlock();


    //
    // make the tapisrv call. if hPhone becomes invalid, the call will simply
    // fail. this is ok.
    //

    HRESULT hr = phoneDevSpecific(hPhone, pbDataArray, dwSize);



    LOG((TL_TRACE, "DeviceSpecific - exit. hr = %lx", hr));

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CPhone
// Interface : ITPhone
// Method    : DeviceSpecificVariant
//
// this is the scriptable version of DeviceSpecific
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT CPhone::DeviceSpecificVariant(
	     IN VARIANT varDevSpecificByteArray
        )
{
    LOG((TL_TRACE, "DeviceSpecificVariant - enter"));


    //
    // extract buffer from the variant
    //

    DWORD dwByteArraySize = 0;
    BYTE *pBuffer = NULL;

    HRESULT hr = E_FAIL;
    
    hr = MakeBufferFromVariant(varDevSpecificByteArray, &dwByteArraySize, &pBuffer);

    if (FAILED(hr))
    {
        LOG((TL_TRACE, "DeviceSpecificVariant - MakeBufferFromVariant failed. hr = %lx", hr));

        return hr;
    }


    //
    // call the non-scriptable version and pass it the nonscriptable implementation
    //
    
    hr = DeviceSpecific(pBuffer, dwByteArraySize);


    //
    // success or failure, free the buffer allocated by MakeBufferFromVariant
    //

    ClientFree(pBuffer);
    pBuffer = NULL;


    //
    // log rc and exit
    //

    LOG((TL_TRACE, "DeviceSpecificVariant - exit. hr = %lx", hr));

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CPhone
// Interface : ITPhone
// Method    : NegotiateExtVersion
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT CPhone::NegotiateExtVersion (
	     IN long lLowVersion,
	     IN long lHighVersion,
	     OUT long *plExtVersion
        )
{
    
    LOG((TL_TRACE, "NegotiateExtVersion - enter"));

    
    //
    // make sure the out parameter is writable
    //

    if (IsBadWritePtr(plExtVersion, sizeof(long)) )
    {
        LOG((TL_ERROR, "NegotiateExtVersion - output arg [%p] not writeable", plExtVersion));

        return E_POINTER;
    }


    Lock();


    //
    // make a call to tapisrv
    //

    DWORD dwNegotiatedVersion = 0;

    LONG lResult = phoneNegotiateExtVersion(m_hPhoneApp, 
                                            m_dwDeviceID, 
                                            m_dwAPIVersion, 
                                            lLowVersion, 
                                            lHighVersion, 
                                            &dwNegotiatedVersion );

    Unlock();


    HRESULT hr = mapTAPIErrorCode(lResult);


    //
    // return the value on success
    //

    if ( SUCCEEDED(hr) )
    {
        LOG((TL_TRACE, "NegotiateExtVersion - negotiated version %ld", dwNegotiatedVersion));

        *plExtVersion = dwNegotiatedVersion;
    }


    LOG((TL_TRACE, "NegotiateExtVersion - exit. hr = %lx", hr));

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// ITPhoneEvent methods
//

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// FireEvent
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CPhoneEvent::FireEvent(
                       CPhone * pCPhone,
                       PHONE_EVENT Event,
                       PHONE_BUTTON_STATE ButtonState,
                       PHONE_HOOK_SWITCH_STATE HookSwitchState,
                       PHONE_HOOK_SWITCH_DEVICE HookSwitchDevice,
                       DWORD dwRingMode,
                       DWORD dwButtonLampId,
                       PWSTR pNumber,
                       ITCallInfo * pCallInfo
                      )
{
    HRESULT                    hr = S_OK;
    CComObject<CPhoneEvent>  * p;
    IDispatch                * pDisp;

    STATICLOG((TL_TRACE, "FireEvent enter" ));

    //
    // We have to filter Phoneevents because
    // Tapisrv doesn't. Tapi3 receive always phone events
    // and use them to keep alive the Phone object
    //

    CTAPI* pTapi = pCPhone->GetTapi();
    if( pTapi == NULL )
    {
        STATICLOG((TL_ERROR, "Tapi object is invalid - %lx", E_UNEXPECTED));
        return E_UNEXPECTED;
    }

    long nFilterMask = 0;
    pTapi->get_EventFilter( &nFilterMask );
    if( (nFilterMask & TE_PHONEEVENT) == 0 )
    {
        //
        // The user didn't set the mask for TE_PHONEEVENT
        // so we don't fire the event to the application
        //
        STATICLOG((TL_INFO, "The user didn't set the mask for TE_PHONEEVENT."
            " Don't fire the event to app  - %lx", S_OK));
        return S_OK;
    }

    //
    // create event
    //
    hr = CComObject<CPhoneEvent>::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        STATICLOG((TL_ERROR, "Could not create PhoneEvent object - %lx", hr));
        return hr;
    }

    //
    // get idisp interface
    //
    hr = p->QueryInterface(
                           IID_IDispatch,
                           (void **)&pDisp
                          );

    if ( FAILED(hr) )
    {
        STATICLOG((TL_ERROR, "Could not get disp interface of PhoneEvent object - %lx", hr));
        
        delete p;
        
        return hr;
    }

    //
    // initialize
    //

    if (pNumber != NULL)
    {
        p->m_pNumber = SysAllocString( pNumber );

        if (p->m_pNumber == NULL)
        {
            STATICLOG((TL_ERROR, "Out of memory allocating phone number"));
        
            pDisp->Release();

            return E_OUTOFMEMORY;
        }
    }
    else
    {
        p->m_pNumber = NULL;
    }

    p->m_Event = Event;
    p->m_pPhone = dynamic_cast<ITPhone *>(pCPhone);
    p->m_pPhone->AddRef();
    p->m_ButtonState = ButtonState;
    p->m_HookSwitchState = HookSwitchState;
    p->m_HookSwitchDevice = HookSwitchDevice;
    p->m_dwRingMode = dwRingMode;
    p->m_dwButtonLampId = dwButtonLampId;
    p->m_pCallInfo = pCallInfo;
    if (p->m_pCallInfo != NULL)
    {
        p->m_pCallInfo->AddRef();
    }
        
#if DBG
    p->m_pDebug = (PWSTR) ClientAlloc( 1 );
#endif

    //
    // get callback
    //
    //
    // fire event
    //
    (pCPhone->GetTapi())->Event(
                                 TE_PHONEEVENT,
                                 pDisp
                               );

    //
    // release stuff
    //
    pDisp->Release();

    STATICLOG((TL_TRACE, "FireEvent exit - return S_OK" ));
    
    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// finalrelease
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void
CPhoneEvent::FinalRelease()
{
    LOG((TL_INFO, "CPhoneEvent - FinalRelease"));
    
    m_pPhone->Release();
    m_pPhone = NULL;

    if (m_pCallInfo != NULL)
    {
        m_pCallInfo->Release();
        m_pCallInfo = NULL;
    }

    if (m_pNumber != NULL)
    {
        SysFreeString(m_pNumber);
        m_pNumber = NULL;
    }

#if DBG
    ClientFree( m_pDebug );
    m_pDebug = NULL;
#endif
}




//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Phone
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhoneEvent::get_Phone(
                       ITPhone ** ppPhone
                      )
{
    if (TAPIIsBadWritePtr(ppPhone , sizeof(ITPhone *) ) )
    {
        LOG((TL_ERROR, "get_Phone - bad pointer"));

        return E_POINTER;
    }

    *ppPhone = m_pPhone;
    (*ppPhone)->AddRef();

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Event
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhoneEvent::get_Event(
                       PHONE_EVENT * pEvent
                      )
{
    if (TAPIIsBadWritePtr(pEvent , sizeof(PHONE_EVENT) ) )
    {
        LOG((TL_ERROR, "get_Event - bad pointer"));

        return E_POINTER;
    }

    *pEvent = m_Event;

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_ButtonState
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhoneEvent::get_ButtonState(
                             PHONE_BUTTON_STATE * pState
                            )
{
    if (TAPIIsBadWritePtr(pState , sizeof(PHONE_BUTTON_STATE) ) )
    {
        LOG((TL_ERROR, "get_ButtonState - bad pointer"));

        return E_POINTER;
    }

    if (m_Event != PE_BUTTON)
    {
        LOG((TL_ERROR, "get_ButtonState - wrong event"));

        return TAPI_E_WRONGEVENT;
    }

    *pState = m_ButtonState;

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_HookSwitchState
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhoneEvent::get_HookSwitchState(
                                 PHONE_HOOK_SWITCH_STATE * pState
                                )
{
    if (TAPIIsBadWritePtr(pState , sizeof(PHONE_HOOK_SWITCH_STATE) ) )
    {
        LOG((TL_ERROR, "get_HookSwitchState - bad pointer"));

        return E_POINTER;
    }

    if (m_Event != PE_HOOKSWITCH)
    {
        LOG((TL_ERROR, "get_HookSwitchState - wrong event"));

        return TAPI_E_WRONGEVENT;
    }

    *pState = m_HookSwitchState;

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_HookSwitchDevice
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhoneEvent::get_HookSwitchDevice(
                                 PHONE_HOOK_SWITCH_DEVICE * pDevice
                                )
{
    if (TAPIIsBadWritePtr(pDevice , sizeof(PHONE_HOOK_SWITCH_DEVICE) ) )
    {
        LOG((TL_ERROR, "get_HookSwitchDevice - bad pointer"));

        return E_POINTER;
    }

    if (m_Event != PE_HOOKSWITCH)
    {
        LOG((TL_ERROR, "get_HookSwitchDevice - wrong event"));

        return TAPI_E_WRONGEVENT;
    }

    *pDevice = m_HookSwitchDevice;

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_RingMode
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhoneEvent::get_RingMode(
                          long * plRingMode
                         )
{
    if (TAPIIsBadWritePtr(plRingMode , sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_RingMode - bad pointer"));

        return E_POINTER;
    }

    if (m_Event != PE_RINGMODE)
    {
        LOG((TL_ERROR, "get_RingMode - wrong event"));

        return TAPI_E_WRONGEVENT;
    }

    *plRingMode = m_dwRingMode;

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_ButtonLampId
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhoneEvent::get_ButtonLampId(
                              long *plButtonLampId
                             )
{
    if (TAPIIsBadWritePtr(plButtonLampId , sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_ButtonLampId - bad pointer"));

        return E_POINTER;
    }

    if ((m_Event != PE_LAMPMODE) && (m_Event != PE_BUTTON))
    {
        LOG((TL_ERROR, "get_ButtonLampId - wrong event"));

        return TAPI_E_WRONGEVENT;
    }

    *plButtonLampId = m_dwButtonLampId;

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_NumberGathered
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhoneEvent::get_NumberGathered(
                                BSTR * ppNumber
                               )
{
    if (TAPIIsBadWritePtr(ppNumber , sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_NumberGathered - bad pointer"));

        return E_POINTER;
    }

    if (m_Event != PE_NUMBERGATHERED)
    {
        LOG((TL_ERROR, "get_NumberGathered - wrong event"));

        return TAPI_E_WRONGEVENT;
    }

    *ppNumber = SysAllocString(m_pNumber);

    if (*ppNumber == NULL)
    {
        LOG((TL_ERROR, "get_NumberGathered - out of memory"));

        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Call
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhoneEvent::get_Call(
                      ITCallInfo ** ppCallInfo
                     )
{
    if (TAPIIsBadWritePtr(ppCallInfo , sizeof(ITCallInfo *) ) )
    {
        LOG((TL_ERROR, "get_Call - bad pointer"));

        return E_POINTER;
    }

    if ((m_Event != PE_ANSWER) &&
        (m_Event != PE_DISCONNECT))
    {
        LOG((TL_ERROR, "get_Call - wrong event"));

        return TAPI_E_WRONGEVENT;
    }

    if ( m_pCallInfo == NULL )
    {
        LOG((TL_ERROR, "get_Call - NULL call pointer"));

        return E_UNEXPECTED;
    }

    *ppCallInfo = m_pCallInfo;
    (*ppCallInfo)->AddRef();

    return S_OK;
}




///////////////////////////////////////////////////////////////////////////////
//
// CPhoneDevSpecificEvent
//

// static
HRESULT CPhoneDevSpecificEvent::FireEvent(  CPhone * pCPhone,
                                            long l1,
                                            long l2,
                                            long l3
                                          )
{
    STATICLOG((TL_INFO, "CPhoneDevSpecificEvent::FireEvent - enter"));


    //
    // try to create the event
    //

    CComObject<CPhoneDevSpecificEvent> *pEventObject = NULL;

    HRESULT hr = CComObject<CPhoneDevSpecificEvent>::CreateInstance(&pEventObject);

    if ( FAILED(hr) )
    {
        STATICLOG((TL_ERROR, 
            "CPhoneDevSpecificEvent::FireEvent - failed to create CPhoneDevSpecificEvent. hr = %lx", 
            hr));

        return hr;
    }


    //
    // initialize the event with the data we received
    //


    //
    // get ITPhone from CPhone we received
    //

    hr = pCPhone->_InternalQueryInterface(IID_ITPhone, (void**)(&(pEventObject->m_pPhone)) );

    if (FAILED(hr))
    {
        STATICLOG((TL_ERROR, 
            "CPhoneDevSpecificEvent::FireEvent - failed to get ITPhone interface from phone. hr = %lx", 
            hr));

        delete pEventObject;

        return hr;
    }


    //
    // keep the actual data
    //

    pEventObject->m_l1 = l1;
    pEventObject->m_l2 = l2;
    pEventObject->m_l3 = l3;


#if DBG
    pEventObject->m_pDebug = (PWSTR) ClientAlloc( 1 );
#endif


    //
    // get event's idispatch interface
    //

    IDispatch *pDispatch = NULL;

    hr = pEventObject->QueryInterface( IID_IDispatch,
                                       (void **)&pDispatch );

    if ( FAILED(hr) )
    {
        STATICLOG((TL_ERROR, 
            "CPhoneDevSpecificEvent::FireEvent - Could not get disp interface of AddressEvent object %lx", 
            hr));

        
        //
        // undo the QI we have performed earlier
        //

        pEventObject->m_pPhone->Release();
        pEventObject->m_pPhone = NULL;


        //
        // delete the event object
        //

        delete pEventObject;
        
        return hr;
    }


    //
    // from this point on, we will be using events pDispatch
    //

    pEventObject = NULL;


    //
    // get callback
    //
    //
    // fire event to tapi
    //

    hr = (pCPhone->GetTapi())->Event( TE_PHONEDEVSPECIFIC, pDispatch);


    //
    // succeeded or not, we no longer need a reference to the event object
    //

    pDispatch->Release();
    pDispatch = NULL;
    
    STATICLOG((TL_INFO, "CPhoneDevSpecificEvent::FireEvent - exit. hr = %lx", hr));

    return hr;
}


CPhoneDevSpecificEvent::CPhoneDevSpecificEvent()
    :m_pPhone(NULL)
{
    LOG((TL_INFO, "CPhoneDevSpecificEvent - enter"));

#if DBG

    m_pDebug = NULL;

#endif

    LOG((TL_INFO, "CPhoneDevSpecificEvent - exit"));
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// finalrelease
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CPhoneDevSpecificEvent::FinalRelease()
{
    LOG((TL_INFO, "FinalRelease - enter"));

    
    if (NULL != m_pPhone)
    {
        m_pPhone->Release();
        m_pPhone = NULL;
    }
    else
    {
        //
        // we must have a phone -- if not, there is a bug in our code
        //

        _ASSERTE(FALSE);
    }


#if DBG
    ClientFree( m_pDebug );
#endif

    LOG((TL_INFO, "FinalRelease - exit"));

}




//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Phone
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CPhoneDevSpecificEvent::get_Phone(
                           ITPhone ** ppPhone
                          )
{
    LOG((TL_TRACE, "get_Phone - enter"));


    //
    // good out pointer?
    //

    if (TAPIIsBadWritePtr(ppPhone , sizeof(ITPhone *) ) )
    {
        LOG((TL_ERROR, "get_Phone - bad pointer at [%p]", ppPhone));

        return E_POINTER;
    }


    //
    // return addreff'd address
    //

    *ppPhone = m_pPhone;
    (*ppPhone)->AddRef();


    LOG((TL_TRACE, "get_Phone- enter. phone[%p]", (*ppPhone) ));

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_lParam1
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CPhoneDevSpecificEvent::get_lParam1( long *pl1 )
{
    LOG((TL_TRACE, "get_lParam1 - enter"));


    //
    // good out pointer?
    //

    if (TAPIIsBadWritePtr(pl1, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_lParam1 - bad pointer at %p", pl1));

        return E_POINTER;
    }


    //
    // log and return the value
    //

    *pl1 = m_l1;

    LOG((TL_TRACE, "get_lParam1 - exit. p1[%ld]", *pl1));


    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_lParam2
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CPhoneDevSpecificEvent::get_lParam2( long *pl2 )
{
    LOG((TL_TRACE, "get_lParam2 - enter"));


    //
    // good out pointer?
    //

    if (TAPIIsBadWritePtr(pl2, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_lParam2 - bad pointer at %p", pl2));

        return E_POINTER;
    }


    //
    // log and return the value
    //

    *pl2 = m_l2;

    LOG((TL_TRACE, "get_lParam2 - exit. p2[%ld]", *pl2));


    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_lParam3
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CPhoneDevSpecificEvent::get_lParam3( long *pl3 )
{
    LOG((TL_TRACE, "get_lParam3 - enter"));


    //
    // good out pointer?
    //

    if ( TAPIIsBadWritePtr(pl3, sizeof(long)) )
    {
        LOG((TL_ERROR, "get_lParam3 - bad pointer at %p", pl3));

        return E_POINTER;
    }


    //
    // log and return the value
    //

    *pl3 = m_l3;

    LOG((TL_TRACE, "get_lParam3 - exit. p3[%ld]", *pl3));


    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\private.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    private.h

Abstract:

Author:

    noela  01-20-98
    
Notes:

Revision History:

--*/

extern HINSTANCE ghUIInst;
//extern const WCHAR     gszCardKeyW[];

//***************************************************************************
//***************************************************************************
//***************************************************************************
void AllocNewID( HKEY MainKey, LPDWORD lpdw );
void PASCAL WideStringToNotSoWideString( LPBYTE lpBase, LPDWORD lpdwThing );
PWSTR PASCAL MultiToWide( LPCSTR  lpStr );
PWSTR PASCAL NotSoWideStringToWideString( LPCSTR lpStr, DWORD dwLength );



//***************************************************************************
//***************************************************************************
//***************************************************************************
typedef enum
{
    Dword,
    lpDword,
    hXxxApp,
    hXxxApp_NULLOK,
//    lpsz,
    lpszW,
    lpGet_SizeToFollow,
    lpSet_SizeToFollow,
    lpSet_Struct,
    lpGet_Struct,
    Size,
    Hwnd

} ARG_TYPE;


typedef struct _FUNC_ARGS
{
    DWORD               Flags;

    ULONG_PTR           Args[MAX_TAPI_FUNC_ARGS];

    BYTE                ArgTypes[MAX_TAPI_FUNC_ARGS];

} FUNC_ARGS, *PFUNC_ARGS;


typedef struct _UI_REQUEST_THREAD_PARAMS
{
    BOOL                bRequestCompleted;

    PFUNC_ARGS          pFuncArgs;

    LONG                lResult;

} UI_REQUEST_THREAD_PARAMS, *PUI_REQUEST_THREAD_PARAMS;


typedef struct _INIT_DATA
{
    DWORD               dwKey;

    DWORD               dwInitOptions;

    union
    {
        HWND            hwnd;

        HANDLE          hEvent;

        HANDLE          hCompletionPort;
    };

    union
    {
        LINECALLBACK    lpfnCallback;

        DWORD           dwCompletionKey;
    };

    HANDLE              hXxxApp;

    BOOL                bPendingAsyncEventMsg;

    DWORD               dwNumTotalEntries;

    DWORD               dwNumUsedEntries;

    PASYNC_EVENT_PARAMS pEventBuffer;

    PASYNC_EVENT_PARAMS pValidEntry;

    PASYNC_EVENT_PARAMS pFreeEntry;

    DWORD               dwNumLines;

    BOOL                bLine;

} INIT_DATA, *PINIT_DATA;



#if DBG

#define DBGOUT(arg) DbgPrt arg

VOID
DbgPrt(
    IN DWORD  dwDbgLevel,
    IN PUCHAR DbgMessage,
    IN ...
    );

//DWORD   gdwDebugLevel;

#define DOFUNC(arg1,arg2) DoFunc(arg1,arg2)

LONG
WINAPI
DoFunc(
    PFUNC_ARGS  pFuncArgs,
    char       *pszFuncName
    );

#else

#define DBGOUT(arg)

#define DOFUNC(arg1,arg2) DoFunc(arg1)

LONG
WINAPI
DoFunc(
    PFUNC_ARGS  pFuncArgs
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\privobj.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    privobjs.h

Abstract:

    Declaration of the CPrivateData class
    
Author:

    mquinton  08-19-98
    
Notes:

Revision History:

--*/

#ifndef __PRIVATE_H_
#define __PRIVATE_H_

#include "resource.h"       // main symbols


class CPrivateEvent :
    public CTAPIComObjectRoot<CPrivateEvent>,
    public CComDualImpl<ITPrivateEvent, &IID_ITPrivateEvent, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
public:

    CPrivateEvent() : m_pCall(NULL),
                      m_pAddress(NULL),
                      m_pCallHub(NULL),
                      m_pEventInterface(NULL),
                      m_lEventCode(0)    
                     {}
 

    void
    FinalRelease();

    static HRESULT FireEvent(
                             CTAPI      * pTapi,
                             ITCallInfo * pCall,
                             ITAddress  * pAddress,
                             ITCallHub  * pCallHub,
                             IDispatch  * pEventInterface,
                             long         lEventCode
                            );


DECLARE_MARSHALQI(CPrivateEvent)
DECLARE_QI()
DECLARE_TRACELOG_CLASS(CPrivateEvent)

BEGIN_COM_MAP(CPrivateEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITPrivateEvent)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

protected:

    ITCallInfo * m_pCall;
    ITAddress  * m_pAddress;
    ITCallHub  * m_pCallHub;
    IDispatch  * m_pEventInterface;
    long         m_lEventCode;

#if DBG
    PWSTR        m_pDebug;
#endif
    
    
public:

    STDMETHOD(get_Address)(ITAddress ** ppAddress);
    STDMETHOD(get_Call)(ITCallInfo ** ppCallInfo);
    STDMETHOD(get_CallHub)(ITCallHub ** ppCallHub);
    STDMETHOD(get_EventCode)(long * plEventCode);
    STDMETHOD(get_EventInterface)(IDispatch ** pEventInterface);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\privobj.cpp ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    privobj.cpp

Abstract:


Author:

    mquinton - 11/13/97

Notes:



Revision History:

--*/

#include "stdafx.h"

extern CHashTable * gpCallHubHashTable;
extern CHashTable * gpLineHashTable;


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CPrivateEvent -
//          implementation of the ITPrivateEvent interface
//          This object is given to applications for Private events
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CPrivateEvent::FireEvent
//      static function to create and fire a new CPrivateEvent
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CPrivateEvent::FireEvent(
                         CTAPI      * pTapi,
                         ITCallInfo * pCall,
                         ITAddress  * pAddress,
                         ITCallHub  * pCallHub,
                         IDispatch  * pEventInterface,
                         long         lEventCode
                        )
{
    CComObject< CPrivateEvent > * p;
    IDispatch                   * pDisp;
    HRESULT                       hr = S_OK;

    
    STATICLOG((TL_TRACE, "FireEvent - enter" ));
    STATICLOG((TL_INFO, "     pCall -----------> %p", pCall ));
    STATICLOG((TL_INFO, "     pAddress --------> %p", pAddress ));
    STATICLOG((TL_INFO, "     pCallHub --------> %p", pCallHub ));
    STATICLOG((TL_INFO, "     pEventInterface -> %p", pEventInterface ));
    STATICLOG((TL_INFO, "     EventCode -------> %lX", lEventCode ));

    //
    // Check the event filter mask
    // These events are MSP events and are filter by
    // TapiSrv
    //

    DWORD dwEventFilterMask = 0;
    CAddress* pCAddress = (CAddress*)pAddress;
    if( pCAddress )
    {
        dwEventFilterMask = pCAddress->GetSubEventsMask( TE_PRIVATE );
        if( dwEventFilterMask == 0)
        {
            STATICLOG((TL_ERROR, "This private event is filtered"));
            return S_OK;
        }
    }

    CCall* pCCall = (CCall*)pCall;
    if( pCCall )
    {
        dwEventFilterMask = pCCall->GetSubEventsMask( TE_PRIVATE );
        if( dwEventFilterMask == 0)
        {
            STATICLOG((TL_ERROR, "This private event is filtered"));
            return S_OK;
        }
    }

    //
    // create the event object
    //
    hr = CComObject< CPrivateEvent >::CreateInstance( &p );

    if ( SUCCEEDED(hr) )
    {
        //
        // save event info
        //
        p->m_pCall = pCall;
        p->m_pAddress = pAddress;
        p->m_pCallHub = pCallHub;
        p->m_pEventInterface = pEventInterface;
        p->m_lEventCode = lEventCode;

        #if DBG
        p->m_pDebug = (PWSTR) ClientAlloc( 1 );
        #endif


        // AddRef pointers
        if(pCall)
        {
            pCall->AddRef();
        }    
        if(pAddress)
        {
            pAddress->AddRef();
        }  
        if(pEventInterface)
        {
            pEventInterface->AddRef();
        }    
        if(pCallHub)
        {
            pCallHub->AddRef();
        }    

        //
        // get the dispatch interface
        //
        hr = p->_InternalQueryInterface( IID_IDispatch, (void **)&pDisp );
        if (SUCCEEDED(hr))
        {
            //
            // fire the event
            //
            if(pTapi)
            {
                pTapi->Event(TE_PRIVATE, pDisp);
            }
            
            // release our reference
            pDisp->Release();
            
        }
        else // couldn't get IDispatch
        {
            delete p;
            STATICLOG((TL_ERROR, "FireEvent - could not get IDispatch "));
        }
    }
    else // Couldn't create instance
    {
        STATICLOG((TL_ERROR, "FireEvent - could not createinstance" ));
    }

    
    STATICLOG((TL_TRACE, hr, "FireEvent - exit " ));
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  FinalRelease
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void
CPrivateEvent::FinalRelease()
{
    if(m_pCall)
    {
        m_pCall->Release();
    }    

    if(m_pAddress)
    {
        m_pAddress->Release();
    }  
    
    if(m_pCallHub)
    {
        m_pCallHub->Release();
    }  

    if(m_pEventInterface)
    {
        m_pEventInterface->Release();
    }    

#if DBG
    ClientFree( m_pDebug );
#endif
}


// ITPrivateEvent methods

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Address
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CPrivateEvent::get_Address(
                           ITAddress ** ppAddress
                          )
{
    HRESULT hr = S_OK;

    LOG((TL_TRACE, "get_Address - enter" ));
    LOG((TL_TRACE, "     ppAddress ---> %p", ppAddress ));

    if (TAPIIsBadWritePtr( ppAddress, sizeof( ITAddress * ) ) )
    {
        LOG((TL_ERROR, "get_Address - bad pointer"));

        hr = E_POINTER;
    }
    else
    {
        *ppAddress = m_pAddress;

        if(m_pAddress)
        {
            m_pAddress->AddRef();
        }
    }

    LOG((TL_TRACE,hr, "get_Address - exit "));
    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Call
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CPrivateEvent::get_Call(
                        ITCallInfo ** ppCallInfo
                       )
{
    HRESULT hr = S_OK;

    LOG((TL_TRACE, "get_Call - enter" ));
    LOG((TL_TRACE, "     ppCallInfo ---> %p", ppCallInfo ));

    if (TAPIIsBadWritePtr( ppCallInfo, sizeof( ITCallInfo * ) ) )
    {
        LOG((TL_ERROR, "get_Call - bad pointer"));

        hr = E_POINTER;
    }
    else
    {
        *ppCallInfo = m_pCall;

        if(m_pCall)
        {
            m_pCall->AddRef();
        }
    }
    
    LOG((TL_TRACE,hr, "get_Call - exit "));
    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_CallHub
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CPrivateEvent::get_CallHub(
                           ITCallHub ** ppCallHub
                          )
{
    HRESULT hr = S_OK;

    LOG((TL_TRACE, "get_CallHub - enter" ));
    LOG((TL_TRACE, "     ppCallHub ---> %p", ppCallHub ));

    if (TAPIIsBadWritePtr( ppCallHub, sizeof( ITCallHub * ) ) )
    {
        LOG((TL_ERROR, "get_CallHub - bad pointer"));

        hr = E_POINTER;
    }
    else
    {
        *ppCallHub = m_pCallHub;

        if(m_pCallHub)
        {
            m_pCallHub->AddRef();
        }
        else
        {

            LOG((TL_WARN, "get_CallHub - no callhub"));

            hr = TAPI_E_WRONGEVENT;
        }

    }

    LOG((TL_TRACE,hr, "get_CallHub - exit "));
    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_EventInterface
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CPrivateEvent::get_EventInterface(
                                  IDispatch ** pEventInterface
                                 )
{
    HRESULT hr = S_OK;

    LOG((TL_TRACE, "get_EventInterface - enter" ));
    LOG((TL_TRACE, "     pEventInterface ---> %p", pEventInterface ));

    if (TAPIIsBadWritePtr( pEventInterface, sizeof( IDispatch * ) ) )
    {
        LOG((TL_ERROR, "get_EventInterface - bad pointer"));

        hr = E_POINTER;
    }
    else
    {
        *pEventInterface = m_pEventInterface;

        if(m_pEventInterface)
        {
            m_pEventInterface->AddRef();
        }
    }

    LOG((TL_TRACE,hr, "get_EventInterface - exit "));
    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_EventCode
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CPrivateEvent::get_EventCode(
                             long * plEventCode
                            )
{
    HRESULT hr = S_OK;

    LOG((TL_TRACE, "get_EventCode - enter" ));
    LOG((TL_TRACE, "     pEventInterface ---> %p", plEventCode ));

    if (TAPIIsBadWritePtr( plEventCode, sizeof( long ) ) )
    {
        LOG((TL_ERROR, "get_EventCode - bad pointer"));

        hr = E_POINTER;
    }
    else
    {
        *plEventCode = m_lEventCode;
    }

    LOG((TL_TRACE,hr, "get_EventCode - exit "));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\queue.cpp ===
/*++

Copyright (c) 1997 - 1999 Microsoft Corporation

Module Name:

    queue.cpp

Abstract:

    Implementation of the Queue object for TAPI 3.0.
    CQueue class

Author:

    noela - 11/04/97

Notes:

    optional-notes

Revision History:

--*/



#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////
// CQueue

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CQueue
// Method    : Constructor
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CQueue::CQueue()
    {
    Lock();
    m_dwHandle                 = 0;               
    m_bRequiresUpdating        = TRUE;

    m_dwMeasurementPeriod      = 0;
    m_dwTotalCallsQueued       = 0;
    m_dwCurrentCallsQueued     = 0;
    m_dwTotalCallsAdandoned    = 0;
    m_dwTotalCallsFlowedIn     = 0;
    m_dwTotalCallsFlowedOut    = 0;
    m_dwLongestEverWaitTime    = 0;
    m_dwCurrentLongestWaitTime = 0;
    m_dwAverageWaitTime        = 0;
    m_dwFinalDisposition       = 0;
    Unlock();
        
    }



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CQueue
// Method    : UpdateInfo
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CQueue::UpdateInfo()
{
    HRESULT             hr = S_OK;
    LINEQUEUEINFO       QueueInfo;


    LOG((TL_TRACE, "UpdateInfo - enter" ));
 

    QueueInfo.dwTotalSize = sizeof(LINEQUEUEINFO);
    QueueInfo.dwNeededSize = sizeof(LINEQUEUEINFO);
    QueueInfo.dwUsedSize = sizeof(LINEQUEUEINFO);
    
    // **************************************************
    // Get Queue Info from Proxy
    hr = lineGetQueueInfo(
                        m_pHandler->getHLine(),
                        m_dwHandle, 
                        &QueueInfo);

    if( SUCCEEDED(hr) )
    {
        // wait for async reply
        hr = WaitForReply( hr );
        if ( SUCCEEDED(hr) )
        {
            Lock();
                              
            m_dwMeasurementPeriod      = QueueInfo.dwMeasurementPeriod;       
            m_dwTotalCallsQueued       = QueueInfo.dwTotalCallsQueued;       
            m_dwCurrentCallsQueued     = QueueInfo.dwCurrentCallsQueued;
            m_dwTotalCallsAdandoned    = QueueInfo.dwTotalCallsAbandoned;
            m_dwTotalCallsFlowedIn     = QueueInfo.dwTotalCallsFlowedIn;
            m_dwTotalCallsFlowedOut    = QueueInfo.dwTotalCallsFlowedOut;
            m_dwLongestEverWaitTime    = QueueInfo.dwLongestEverWaitTime;
            m_dwCurrentLongestWaitTime = QueueInfo.dwCurrentLongestWaitTime;
            m_dwAverageWaitTime        = QueueInfo.dwAverageWaitTime;
            m_dwFinalDisposition       = QueueInfo.dwFinalDisposition;
            
            m_bRequiresUpdating = FALSE;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "UpdateInfo - call to LineGetQueueInfo failed async" ));
        }
    }    
    else
    {
        LOG((TL_ERROR, "UpdateInfo - call to LineGetQueueInfo failed" ));
    }



    LOG((TL_TRACE, hr, "UpdateInfo - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CQueue
// Method    : CheckIfUpToDate
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CQueue::CheckIfUpToDate()
{
    HRESULT     hr = S_OK;

    if (m_bRequiresUpdating)
    {
        hr = UpdateInfo();
    }
    return hr;
}





//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CQueue
// Method    : Initialize
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CQueue::Initialize
        (
        DWORD dwQueueID, 
        PWSTR pszName, 
        CAgentHandler * pHandler
        )
{
    HRESULT         hr = S_OK;


    LOG((TL_TRACE, "Initialize - enter" ));

    m_dwHandle =  dwQueueID;    
    m_pHandler = pHandler;      
    m_bRequiresUpdating = TRUE;


    // copy the destination address
    if (pszName != NULL)
    {
        m_szName = (PWSTR) ClientAlloc((lstrlenW(pszName) + 1) * sizeof (WCHAR));
        if (m_szName != NULL)
        {
            lstrcpyW(m_szName,pszName);
        }
    else    
        {
            LOG((TL_ERROR, "Initialize - Alloc m_szName failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        LOG((TL_ERROR, "Initialize - name is NULL" ));
        m_szName = NULL;
    }

    
    // Add this object into the Agnet Handler Hash table
    m_pHandler->AddQueueToHash(m_dwHandle, this);
    

    // Get Queue Info from Proxy
    // UpdateInfo();

    if ( SUCCEEDED(hr) )
    {
        CQueueEvent::FireEvent(this, ACDQE_NEW_QUEUE);
    }

    LOG((TL_TRACE, hr, "Initialize - exit" ));
    return hr;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CQueue
// Method    : FinalRelease
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CQueue::FinalRelease()
{
    LOG((TL_TRACE, "FinalRelease Queue - %S", m_szName ));
    if ( m_szName != NULL )
    {
         ClientFree(m_szName);
    }

    // Add this object into the Agnet Handler Hash table
    m_pHandler->RemoveQueueFromHash(m_dwHandle);

    LOG((TL_TRACE, "FinalRelease Queue - exit"));

}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CQueue
// Interface : ITQueue
// Method    : get_Name
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CQueue::get_Name(BSTR * Name)
{
    HRESULT hr = S_OK;

    LOG((TL_TRACE, "Name - enter" ));
    Lock();
    if (!TAPIIsBadWritePtr( Name, sizeof(BSTR ) ) )
    {
        *Name = SysAllocString(m_szName);
    
        if (*Name == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        LOG((TL_ERROR, "Name - bad Name pointer"));
        hr = E_POINTER;
    }

    Unlock();
    LOG((TL_TRACE, hr, "Name - exit" ));
    return hr;
}





//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CQueue
// Interface : ITQueue
// Method    : put_MeasurementPeriod
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CQueue::put_MeasurementPeriod(long ulPeriod)
{
    HRESULT hr = S_OK;
    

    LOG((TL_TRACE, "put_MeasurementPeriod - enter" ));


    // ***************************************************
    // Tell Proxy
    hr = lineSetQueueMeasurementPeriod(
                    m_pHandler->getHLine(),
                    m_dwHandle, 
                    ulPeriod);

    if( SUCCEEDED(hr) )
    {
        // wait for async reply
        hr = WaitForReply( hr );
        if ( SUCCEEDED(hr) )
        {
            Lock();
            m_dwMeasurementPeriod = ulPeriod;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "put_MeasurementPeriod - call to LineSetQueueMeasurementPeriod failed async" ));
        }
    }
    else
    {
        LOG((TL_ERROR, "put_MeasurementPeriod - call to LineSetQueueMeasurementPeriod failed" ));
    }

    LOG((TL_TRACE, hr, "put_MeasurementPeriod - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CQueue
// Interface : ITQueue
// Method    : get_MeasurementPeriod 
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CQueue::get_MeasurementPeriod (long * pulPeriod)
{
    HRESULT hr = S_OK;

    
    LOG((TL_TRACE, "get_MeasurementPeriod  - enter" ));

    if (!TAPIIsBadWritePtr( pulPeriod, sizeof(long) ) )
    {
        hr = CheckIfUpToDate();
        if ( SUCCEEDED(hr) )
        {
            Lock();
            *pulPeriod = m_dwMeasurementPeriod;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "get_MeasurementPeriod  - Object update failed"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_MeasurementPeriod  - bad pulPeriod pointer"));
        hr = E_POINTER;
    }

    LOG((TL_TRACE, hr, "get_MeasurementPeriod  - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CQueue
// Interface : ITQueue
// Method    : TotalCallsQueued 
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CQueue::get_TotalCallsQueued (long * pulCalls)
{
    HRESULT hr = S_OK;


    LOG((TL_TRACE, "TotalCallsQueued  - enter" ));
    if (!TAPIIsBadWritePtr( pulCalls, sizeof(long) ) )
    {
        hr = CheckIfUpToDate();
        if ( SUCCEEDED(hr) )
        {
            Lock();
            *pulCalls = m_dwTotalCallsQueued;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "get_TotalCallsQueued  - Object update failed"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_TotalCallsQueued  - bad pulCalls pointer"));
        hr = E_POINTER;
    }
  
    LOG((TL_TRACE, hr, "TotalCallsQueued  - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CQueue
// Interface : ITQueue
// Method    : CurrentCallsQueued 
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CQueue::get_CurrentCallsQueued (long * pulCalls)
{
    HRESULT hr = S_OK;


    LOG((TL_TRACE, "CurrentCallsQueued  - enter" ));
    if (!TAPIIsBadWritePtr( pulCalls, sizeof(long) ) )
    {
        hr = CheckIfUpToDate();
        if ( SUCCEEDED(hr) )
        {
            Lock();
            *pulCalls = m_dwCurrentCallsQueued;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "get_CurrentCallsQueued  - Object update failed"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_CurrentCallsQueued  - bad pulCalls pointer"));
        hr = E_POINTER;
    }
  
    LOG((TL_TRACE, hr, "CurrentCallsQueued  - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CQueue
// Interface : ITQueue
// Method    : TotalCallsAbandoned 
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CQueue::get_TotalCallsAbandoned (long * pulCalls)
{
    HRESULT hr = S_OK;
    
    
    LOG((TL_TRACE, "TotalCallsAbandoned  - enter" ));
    if (!TAPIIsBadWritePtr( pulCalls, sizeof(long) ) )
    {
        hr = CheckIfUpToDate();
        if (SUCCEEDED(hr) )
        {
            Lock();
            *pulCalls = m_dwTotalCallsAdandoned;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "get_TotalCallsAbandoned - Object update failed"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_TotalCallsAbandoned  - bad pulCalls pointer"));
        hr = E_POINTER;
    }
  
    LOG((TL_TRACE, hr, "TotalCallsAbandoned  - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CQueue
// Interface : ITQueue
// Method    : TotalCallsFlowedIn 
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CQueue::get_TotalCallsFlowedIn (long * pulCalls)
{
    HRESULT hr = S_OK;


    LOG((TL_TRACE, "TotalCallsFlowedIn  - enter" ));
    if (!TAPIIsBadWritePtr( pulCalls, sizeof(long) ) )
    {
        hr = CheckIfUpToDate();
        if (SUCCEEDED(hr) )
        {
            Lock();
            *pulCalls = m_dwTotalCallsFlowedIn;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "get_TotalCallsFlowedIn - Object update failed"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_TotalCallsFlowedIn  - bad pulCalls pointer"));
        hr = E_POINTER;
    }
  
    LOG((TL_TRACE, hr, "TotalCallsFlowedIn  - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CQueue
// Interface : ITQueue
// Method    : TotalCallsFlowedIn 
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CQueue::get_TotalCallsFlowedOut (long * pulCalls)
{
    HRESULT hr = S_OK;


    LOG((TL_TRACE, "TotalCallsFlowedOut  - enter" ));
    if (!TAPIIsBadWritePtr( pulCalls, sizeof(long) ) )
    {
        hr = CheckIfUpToDate();
        if (SUCCEEDED(hr) )
        {
            Lock();
            *pulCalls = m_dwTotalCallsFlowedOut;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "get_TotalCallsFlowedOut - Object update failed"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_TotalCallsFlowedOut  - bad pulCalls pointer"));
        hr = E_POINTER;
    }
  
    LOG((TL_TRACE, hr, "TotalCallsFlowedOut  - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CQueue
// Interface : ITQueue
// Method    : LongestEverWaitTime 
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CQueue::get_LongestEverWaitTime (long * pulWaitTime)
{
    HRESULT hr = S_OK;


    LOG((TL_TRACE, "LongestEverWaitTime  - enter" ));
    if (!TAPIIsBadWritePtr( pulWaitTime, sizeof(long) ) )
    {
        hr = CheckIfUpToDate();
        if (SUCCEEDED(hr) )
        {
            Lock();
            *pulWaitTime = m_dwLongestEverWaitTime;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "get_LongestEverWaitTime - Object update failed"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_LongestEverWaitTime  - bad pulWaitTime pointer"));
        hr = E_POINTER;
    }
  
    LOG((TL_TRACE, hr, "LongestEverWaitTime  - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CQueue
// Interface : ITQueue
// Method    : CurrentLongestWaitTime 
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CQueue::get_CurrentLongestWaitTime (long * pulWaitTime)
{
    HRESULT hr = S_OK;


    LOG((TL_TRACE, "CurrentLongestWaitTime  - enter" ));
    if (!TAPIIsBadWritePtr( pulWaitTime, sizeof(long) ) )
    {
        hr = CheckIfUpToDate();
        if (SUCCEEDED(hr) )
        {
            Lock();
            *pulWaitTime = m_dwCurrentLongestWaitTime;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "get_CurrentLongestWaitTime - Object update failed"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_CurrentLongestWaitTime  - bad pulWaitTime pointer"));
        hr = E_POINTER;
    }
  
    LOG((TL_TRACE, hr, "CurrentLongestWaitTime  - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CQueue
// Interface : ITQueue
// Method    : AverageWaitTime 
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CQueue::get_AverageWaitTime (long * pulWaitTime)
{
    HRESULT hr = S_OK;
    
    
    LOG((TL_TRACE, "AverageWaitTime  - enter" ));
    if (!TAPIIsBadWritePtr( pulWaitTime, sizeof(long) ) )
    {
        hr = CheckIfUpToDate();
        if (SUCCEEDED(hr) )
        {
            Lock();
            *pulWaitTime = m_dwAverageWaitTime;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "get_AverageWaitTime - Object update failed"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_AverageWaitTime  - bad pulWaitTime pointer"));
        hr = E_POINTER;
    }
  
    LOG((TL_TRACE, hr, "AverageWaitTime  - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CQueue
// Interface : ITQueue
// Method    : FinalDisposition 
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CQueue::get_FinalDisposition (long * pulCalls)
{
    HRESULT hr = S_OK;


    LOG((TL_TRACE, "FinalDisposition  - enter" ));
    if (!TAPIIsBadWritePtr( pulCalls, sizeof(long) ) )
    {
        hr = CheckIfUpToDate();
        if (SUCCEEDED(hr) )
        {
            Lock();
            *pulCalls = m_dwFinalDisposition;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "get_FinalDisposition - Object update failed"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_FinalDisposition  - bad pulCalls pointer"));
        hr = E_POINTER;
    }
  
    LOG((TL_TRACE, hr, "FinalDisposition  - exit" ));
    return hr;
}





/////////////////////////////////////////////////////////////////////////////
// CQueueEvent


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CQueueEvent
// Method    : FireEvent
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CQueueEvent::FireEvent(CQueue* pQueue, ACDQUEUE_EVENT Event)
{
    HRESULT                    hr = S_OK;
    CComObject<CQueueEvent>  * pEvent;
    IDispatch                * pIDispatch;

    if ( IsBadReadPtr(pQueue, sizeof(CQueue)) )
    {
        STATICLOG((TL_ERROR, "FireEvent - pQueue is an invalid pointer"));
        return E_POINTER;
    }

    //
    // create event
    //
    hr = CComObject<CQueueEvent>::CreateInstance( &pEvent );

    if ( SUCCEEDED(hr) )
    {
        //
        // initialize
        //
        pEvent->m_QueueEvent = Event;
        pEvent->m_pQueue= dynamic_cast<ITQueue *>(pQueue);
        pEvent->m_pQueue->AddRef();
    
        //
        // get idisp interface
        //
        hr = pEvent->QueryInterface( IID_IDispatch, (void **)&pIDispatch );

        if ( SUCCEEDED(hr) )
        {
            //
            // get callback & fire event

            //
            CTAPI *pTapi = (pQueue->GetAgentHandler() )->GetTapi();
            pTapi->Event( TE_QUEUE, pIDispatch );
        
            // release stuff
            //
            pIDispatch->Release();
            
        }
        else
        {
            STATICLOG((TL_ERROR, "FireEvent - Could not get disp interface of QueueEvent object"));
            delete pEvent;
        }
    }
    else
    {
        STATICLOG((TL_ERROR, "FireEvent - Could not create QueueEvent object"));
    }

   
    STATICLOG((TL_TRACE, hr, "FireEvent - exit"));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CQueueEvent
// Method    : FinalRelease
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CQueueEvent::FinalRelease()
{
    m_pQueue->Release();

}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CQueueEvent
// Interface : ITQueueEvent
// Method    : Queue
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CQueueEvent::get_Queue(ITQueue ** ppQueue)
{
    HRESULT hr = S_OK;


    LOG((TL_TRACE, "(Event)Queue - enter" ));
    if (!TAPIIsBadWritePtr( ppQueue, sizeof(ITQueue *) ) )
    {
        *ppQueue = m_pQueue;
        m_pQueue->AddRef();
    }
    else
    {
        LOG((TL_ERROR, "(Event)Queue - bad ppQueue pointer"));
        hr = E_POINTER;
    }
        
    LOG((TL_TRACE, hr, "(Event)Queue - exit"));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CQueueEvent
// Interface : ITQueueEvent
// Method    : Event
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CQueueEvent::get_Event(ACDQUEUE_EVENT * pEvent)
{
    HRESULT hr = S_OK;


    LOG((TL_TRACE, "Event - enter" ));
    if (!TAPIIsBadWritePtr( pEvent, sizeof(ACDQUEUE_EVENT) ) )
    {
        *pEvent = m_QueueEvent;
    }
    else
    {
        LOG((TL_ERROR, "Event - bad pEvent pointer"));
        hr = E_POINTER;
    }
    
    LOG((TL_TRACE, hr, "Event - exit"));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\queue.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    Queue.h

Abstract:

    Declaration of the CQueue class
    
Author:

    noela  11-04-97
    
Notes:

Revision History:

--*/

#ifndef __QUEUE_H_
#define __QUEUE_H_

#include "resource.h"       // main symbols

class CAgentHandler;


/////////////////////////////////////////////////////////////////////////////
// CQueue
class ATL_NO_VTABLE CQueue : 
	public CTAPIComObjectRoot<CQueue>,
	public IDispatchImpl<ITQueue, &IID_ITQueue, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
private:
    PWSTR               m_szName;
    DWORD               m_dwHandle;
    CAgentHandler     * m_pHandler;      
    BOOL                m_bRequiresUpdating;

    DWORD               m_dwMeasurementPeriod;         
    DWORD               m_dwTotalCallsQueued;         
    DWORD               m_dwCurrentCallsQueued;       
    DWORD               m_dwTotalCallsAdandoned;      
    DWORD               m_dwTotalCallsFlowedIn;       
    DWORD               m_dwTotalCallsFlowedOut;      
    DWORD               m_dwLongestEverWaitTime;      
    DWORD               m_dwCurrentLongestWaitTime;   
    DWORD               m_dwAverageWaitTime;          
    DWORD               m_dwFinalDisposition;


public:
	CQueue();

	~CQueue()
	    {
	    //DeleteCriticalSection( &m_csDataLock );
        }

    STDMETHOD(UpdateInfo) ();       
    STDMETHOD(CheckIfUpToDate) ();       

    inline DWORD getID() {return m_dwHandle;}
    inline void  SetRequiresUpdate() {m_bRequiresUpdating = TRUE;}

    void FinalRelease();
    CAgentHandler * GetAgentHandler() { return m_pHandler; }

DECLARE_MARSHALQI(CQueue)
DECLARE_TRACELOG_CLASS(CQueue)

BEGIN_COM_MAP(CQueue)
	COM_INTERFACE_ENTRY(ITQueue)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

// ITQueue
public:

	STDMETHOD(get_Name)(BSTR * ppName);
    STDMETHOD(put_MeasurementPeriod)(long ulPeriod);
    STDMETHOD(get_MeasurementPeriod) (long *pulPeriod);
    STDMETHOD(get_TotalCallsQueued) (long * pulCalls);
    STDMETHOD(get_CurrentCallsQueued) (long * pulCalls);
    STDMETHOD(get_TotalCallsAbandoned) (long * pulCalls);
    STDMETHOD(get_TotalCallsFlowedIn) (long * pulCalls);
    STDMETHOD(get_TotalCallsFlowedOut) (long * pulCalls);
    STDMETHOD(get_LongestEverWaitTime) (long * pulWaitTime);
    STDMETHOD(get_CurrentLongestWaitTime) (long * pulWaitTime);
    STDMETHOD(get_AverageWaitTime) (long * pulWaitTime);
    STDMETHOD(get_FinalDisposition) (long * pulCalls);       

    STDMETHOD(Initialize) 
        (
        DWORD dwQueueID, 
        PWSTR pszName, 
        CAgentHandler * pHandler
        );       


};






/////////////////////////////////////////////////////////////////////////////
// CQueueEvent
class ATL_NO_VTABLE CQueueEvent : 
	public CTAPIComObjectRoot<CQueueEvent>,
	public IDispatchImpl<ITQueueEvent, &IID_ITQueueEvent, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
protected:
    ACDQUEUE_EVENT      m_QueueEvent;
    ITQueue           * m_pQueue;

public:
	CQueueEvent()
	{
	}

	static HRESULT FireEvent(
                             CQueue * pQueue,
                             ACDQUEUE_EVENT Event
                            );

    void FinalRelease();
    
DECLARE_MARSHALQI(CQueueEvent)
DECLARE_TRACELOG_CLASS(CQueueEvent)

BEGIN_COM_MAP(CQueueEvent)
	COM_INTERFACE_ENTRY(ITQueueEvent)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

// ITQueueEvent
public:
	STDMETHOD(get_Event)(ACDQUEUE_EVENT * pEvent);
	STDMETHOD(get_Queue)(ITQueue ** ppQueue);
};



#endif //__QUEUE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\request.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    request.h

Abstract:

    Declaration of the CRequest class
    
Author:

    mquinton  06-03-98
    
Notes:

Revision History:

--*/

#ifndef __REQUEST_H__
#define __REQUEST_H__

#include "resource.h"
//#include "objsafe.h"
#include "atlctl.h"
#include "TAPIObjectSafety.h"


/////////////////////////////////////////////////////////////////////////////
// CDispatchMapper
class CRequest : 
    public CTAPIComObjectRoot<CRequest>,
	public CComCoClass<CRequest, &CLSID_RequestMakeCall>,
	public CComDualImpl<ITRequest, &IID_ITRequest, &LIBID_TAPI3Lib>,
    public CTAPIObjectSafety
{
public:                                    
	CRequest() 
	{
    }

DECLARE_REGISTRY_RESOURCEID(IDR_REQUESTMAKECALL)
DECLARE_QI()
DECLARE_MARSHALQI(CRequest)
DECLARE_TRACELOG_CLASS(CRequest)

BEGIN_COM_MAP(CRequest)
	COM_INTERFACE_ENTRY2(IDispatch, ITRequest)
	COM_INTERFACE_ENTRY(ITRequest)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(IObjectWithSite)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

    STDMETHOD(MakeCall)(
        BSTR pDestAddress,
#ifdef NEWREQUEST
        long lAddressType,
#endif
        BSTR pAppName,
        BSTR pCalledParty,
        BSTR pComment
        );

};


class CRequestEvent : 
    public CTAPIComObjectRoot<CRequestEvent>,
    public CComDualImpl<ITRequestEvent, &IID_ITRequestEvent, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
public:

    CRequestEvent(){}

    void
    FinalRelease();

    static
    HRESULT
    FireEvent(
              CTAPI * pTapi,
              DWORD dwReg,
              LPLINEREQMAKECALLW pReqMakeCall
             );

DECLARE_MARSHALQI(CRequestEvent)
DECLARE_TRACELOG_CLASS(CRequestEvent)

BEGIN_COM_MAP(CRequestEvent)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITRequestEvent)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppvObject) = 0;
	virtual ULONG STDMETHODCALLTYPE AddRef() = 0;
	virtual ULONG STDMETHODCALLTYPE Release() = 0;

protected:

    long                    m_lRegistrationInstance;
    long                    m_lRequestMode;
#ifdef NEWREQUEST
    long                    m_lAddressType;
#endif
    LINEREQMAKECALLW      * m_pReqMakeCall;
    
#if DBG
    PWSTR                   m_pDebug;
#endif
    
public:
    
    STDMETHOD(get_RegistrationInstance)( long * plRegistrationInstance );
    STDMETHOD(get_RequestMode)(long * plRequestMode );
    STDMETHOD(get_DestAddress)(BSTR * ppDestAddress );
#ifdef NEWREQUEST
    STDMETHOD(get_AddressType)(long * plAddressType );
#endif
    STDMETHOD(get_AppName)(BSTR * ppAppName );
    STDMETHOD(get_CalledParty)(BSTR * ppCalledParty );
    STDMETHOD(get_Comment)(BSTR * ppComment );

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\stdafx.cpp ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    stdafx.cpp
    
Abstract:

    source file that includes just the standard includes
    stdafx.pch will be the pre-compiled header
    stdafx.obj will contain the pre-compiled type information    
    
Author:

    mquinton  06-12-97

Notes:

Revision History:

--*/

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>
#include <atlctl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\resource.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    resource.h

Abstract:
  
Author:

    mquinton  06-12-97
    
Notes:

Revision History:

--*/

//
// Used by tapi3.rc
//

#define IDS_TAPI_SEC_PROMPT             90

#define IDS_PROJNAME                    100
#define IDR_TAPI                        101
#define IDS_TERMINAL                    113
#define IDS_SPEAKERTERMINAL             114
#define IDS_HANDSETTERMINAL             115
#define IDS_HEADSETTERMINAL             116
#define IDS_AUDIOIN                     117
#define IDS_AUDIOOUT                    118
#define IDS_LINE                        119
#define IDS_DIGITDETECTTERMINAL         120
#define IDS_DATAMODEM                   134
#define IDS_G3FAX                       135
#define IDS_DIGITGENERATETERMINAL       136
#define IDS_ADDRESS                     141
#define IDR_DISPATCHMAPPER              142
#define IDR_REQUESTMAKECALL             143
#define IDS_PHONEDEVICE                 144
#define IDS_STREAM                      145

#define IDD_TAPI_SECURITY_DIALOG        500
#define IDC_SECURITY_WARNING_TEXT       502
#define IDC_DONOT_PROMPT_IN_THE_FUTURE  503
#define ID_YES                          505
#define ID_NO                           506
#define ID_YES_DONT_ASK_AGAIN           557

#define IDR_WAV_DTMF0                   601
#define IDR_WAV_DTMF1                   602
#define IDR_WAV_DTMF2                   603
#define IDR_WAV_DTMF3                   604
#define IDR_WAV_DTMF4                   605
#define IDR_WAV_DTMF5                   606
#define IDR_WAV_DTMF6                   607
#define IDR_WAV_DTMF7                   608
#define IDR_WAV_DTMF8                   609
#define IDR_WAV_DTMF9                   610
#define IDR_WAV_DTMFSTAR                611
#define IDR_WAV_DTMFPOUND               612
#define IDR_WAV_DTMFA                   613
#define IDR_WAV_DTMFB                   614
#define IDR_WAV_DTMFC                   615
#define IDR_WAV_DTMFD                   616
#define IDR_WAV_DIALTONE                617
#define IDR_WAV_EXTDIALTONE             618
#define IDR_WAV_BUSY                    619
#define IDR_WAV_RINGBACK                620
#define IDR_WAV_ERROR                   621
#define IDR_WAV_RINGIN                  622

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        801
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\request.cpp ===
/*++

Copyright (c) 1998 - 1999  Microsoft Corporation

Module Name:

    request.cpp

Abstract:

    Implements all the methods on ITRequest interfaces.

Author:

    mquinton - 6/3/98

Notes:


Revision History:

--*/

#include "stdafx.h"
#include "windows.h"
#include "wownt32.h"
#include "stdarg.h"
#include "stdio.h"
#include "shellapi.h"

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CRequest::MakeCall(
                   BSTR pDestAddress,
#ifdef NEWREQUEST
                   long lAddressType,
#endif
                   BSTR pAppName,
                   BSTR pCalledParty,
                   BSTR pComment
                  )
{
    return TapiMakeCall(
                        pDestAddress,
                        pAppName,
                        pCalledParty,
                        pComment
                       );
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CRequestEvent::get_RegistrationInstance(
     long * plRegistrationInstance
     )
{
    if ( TAPIIsBadWritePtr( plRegistrationInstance, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_RegistrationInstance - bad pointer"));

        return E_POINTER;
    }

    *plRegistrationInstance = m_lRegistrationInstance;

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CRequestEvent::get_RequestMode(long * plRequestMode )
{
    if ( TAPIIsBadWritePtr( plRequestMode, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_RequestMode - bad pointer"));

        return E_POINTER;
    }

    Lock();
    *plRequestMode = m_lRequestMode;
    Unlock();

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CRequestEvent::get_DestAddress(BSTR * ppDestAddress )
{
    if ( TAPIIsBadWritePtr( ppDestAddress, sizeof (BSTR) ) )
    {
        LOG((TL_ERROR, "get_DestAddress - bad pointer"));

        return E_POINTER;
    }
    
    Lock();
    *ppDestAddress = SysAllocString( m_pReqMakeCall->szDestAddress );
    Unlock();

    if ( ( NULL == *ppDestAddress ) && ( NULL != m_pReqMakeCall->szDestAddress ) )
    {
        LOG((TL_ERROR, "get_DestAddress - SysAllocString Failed"));
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

#ifdef NEWREQUEST
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CRequestEvent::get_AddressType(long * plAddressType )
{
    return E_NOTIMPL;
}
#endif

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CRequestEvent::get_AppName(BSTR * ppAppName )
{
    if ( TAPIIsBadWritePtr( ppAppName, sizeof (BSTR) ) )
    {
        LOG((TL_ERROR, "get_AppName - bad pointer"));

        return E_POINTER;
    }

    Lock();
    *ppAppName = SysAllocString( m_pReqMakeCall->szAppName );
    Unlock();
    
    if ( ( NULL == *ppAppName ) && ( NULL != m_pReqMakeCall->szAppName ) )
    {
        LOG((TL_ERROR, "get_AppName - SysAllocString Failed"));
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CRequestEvent::get_CalledParty(BSTR * ppCalledParty )
{
    if ( TAPIIsBadWritePtr( ppCalledParty, sizeof (BSTR) ) )
    {
        LOG((TL_ERROR, "get_CalledParty - bad pointer"));

        return E_POINTER;
    }
    
    Lock();
    *ppCalledParty = SysAllocString( m_pReqMakeCall->szCalledParty );
    Unlock();

    if ( ( NULL == *ppCalledParty ) && ( NULL != m_pReqMakeCall->szCalledParty ) )
    {
        LOG((TL_ERROR, "get_CalledParty - SysAllocString Failed"));
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CRequestEvent::get_Comment(BSTR * ppComment )
{
    if ( TAPIIsBadWritePtr( ppComment, sizeof (BSTR) ) )
    {
        LOG((TL_ERROR, "get_Comment - bad pointer"));

        return E_POINTER;
    }

    Lock();
    *ppComment = SysAllocString( m_pReqMakeCall->szComment );
    Unlock();

    if ( ( NULL == *ppComment ) && ( NULL != m_pReqMakeCall->szComment ) )
    {
        LOG((TL_ERROR, "get_Comment - SysAllocString Failed"));
        return E_OUTOFMEMORY;
    }


    return S_OK;
}

HRESULT
CRequestEvent::FireEvent(
                         CTAPI * pTapi,
                         DWORD dwReg,
                         LPLINEREQMAKECALLW pReqMakeCall
                        )
{
    HRESULT                       hr;
    IDispatch                   * pDisp;
    CComObject< CRequestEvent > * p;

    hr = CComObject< CRequestEvent >::CreateInstance( &p );

    if ( NULL == p )
    {
        return E_OUTOFMEMORY;
    }

    p->m_lRegistrationInstance = dwReg;
    p->m_lRequestMode = LINEREQUESTMODE_MAKECALL;
    p->m_pReqMakeCall = pReqMakeCall;


#if DBG
    p->m_pDebug = (PWSTR)ClientAlloc(1);
#endif

    
    //
    // get the dispatch interface
    //
    hr = p->_InternalQueryInterface( IID_IDispatch, (void **)&pDisp );

    if (!SUCCEEDED(hr))
    {
        STATICLOG((TL_ERROR, "RequestEvent - could not get IDispatch %lx", hr));

        return hr;
    }

    //
    // fire the event
    //
    pTapi->Event(
                 TE_REQUEST,
                 pDisp
                );


    //
    // release our reference
    //
    pDisp->Release();
    
    return S_OK;
}

void
CRequestEvent::FinalRelease()
{
    if ( NULL != m_pReqMakeCall )
    {
        ClientFree( m_pReqMakeCall );
    }

#if DBG
    if ( NULL != m_pDebug )
    {
        ClientFree( m_pDebug );
    }
#endif
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void HandleLineRequest( CTAPI * pTapi, PASYNCEVENTMSG pParams )
{
    HRESULT              hr;
    LINEREQMAKECALLW *   pReqMakeCall;
    
    LOG((TL_TRACE, "HandleLineRequest - enter"));

    if ( CTAPI::FindTapiObject( pTapi ) )
    {
        while( 1 )
        {
            hr = LineGetRequest( pTapi->GetHLineApp(), LINEREQUESTMODE_MAKECALL, &pReqMakeCall );

            if ( !SUCCEEDED(hr) )
            {
                LOG((TL_ERROR, "LineGetRequest failed - %lx", hr));
                
                //release the reference added by FindTapiObject.
                pTapi->Release();
                return;
            }

            LOG((TL_INFO, "HandleLineRequest - destAddress: %S", pReqMakeCall->szDestAddress));
            LOG((TL_INFO, "HandleLineRequest - AppName    : %S", pReqMakeCall->szAppName));
            LOG((TL_INFO, "HandleLineRequest - CalledParty: %S", pReqMakeCall->szCalledParty));
            LOG((TL_INFO, "HandleLineRequest - Comment    : %S", pReqMakeCall->szComment));

            LOG((TL_INFO, "HandleLineRequest - about to fire event"));

            hr = CRequestEvent::FireEvent(
                                     pTapi,
                                     pParams->OpenContext,
                                     pReqMakeCall
                                    );

            LOG((TL_INFO, "HandleLineRequest - fire event result %d", hr));
        }

        //release the reference added by FindTapiObject.
        pTapi->Release();
    }

    LOG((TL_TRACE, "HandleLineRequest - exit"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\stdafx.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    stdafx.h

Abstract:

    include file for standard system include files,
    or project specific include files that are used frequently,
    but are changed infrequently.
    
Author:

    mquinton  06-12-97
    
Notes:

Revision History:

--*/

#if !defined(AFX_STDAFX_H__21D6D484_A88B_11D0_83DD_00AA003CCABD__INCLUDED_)
#define AFX_STDAFX_H__21D6D484_A88B_11D0_83DD_00AA003CCABD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _ATL_FREE_THREADED


#if DBG

// 
// by default, atl query interface logging is disabled. if you need to enable
// it, you will need to defile _ATL_DEBUG_QI
//

// #define _ATL_DEBUG_QI

#endif


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>
#include <atlwin.h>
#include <atlctl.h>

#define TAPI_CURRENT_VERSION 0x00030001
#include <tapi.h>
#include <tspi.h>
#include <tapi3.h>
#include <tapi3err.h>


#include "client.h"
#include "tapibase.h"

#include "tapi3p.h"
#include "common.h"
#include "resource.h"
#include "hash.h"
#include "acdgroup.h"
#include "address.h"
#include "agent.h"
#include "agenthand.h"
#include "agentsess.h"

#include "call.h"
#include "callcent.h"
#include "callevnt.h"
#include "callhub.h"
#include "card.h"
#include "connect.h"
#include "dispmap.h"
#include "enum.h"
#include "waves.h"
#include "phone.h"

#ifdef USE_PHONEMSP
#include "phonemsp.h"
#endif USE_PHONEMSP

#include "privobj.h"
#include "queue.h"
#include "request.h"
#include "stream.h"
#include "tapiobj.h"

#ifdef USE_PHONEMSP
#include "terminal.h"
#endif USE_PHONEMSP


const LPWSTR CLSID_String_VideoWindowTerm = L"{F7438990-D6EB-11D0-82A6-00AA00B5CA1B}";
const LPWSTR CLSID_String_VideoInputTerminal = L"{AAF578EC-DC70-11D0-8ED3-00C04FB6809F}";
const LPWSTR CLSID_String_HandsetTerminal = L"{AAF578EB-DC70-11D0-8ED3-00C04FB6809F}";
const LPWSTR CLSID_String_HeadsetTerminal = L"{AAF578ED-DC70-11D0-8ED3-00C04FB6809F}";
const LPWSTR CLSID_String_SpeakerphoneTerminal = L"{AAF578EE-DC70-11D0-8ED3-00C04FB6809F}";
const LPWSTR CLSID_String_MicrophoneTerminal = L"{AAF578EF-DC70-11D0-8ED3-00C04FB6809F}";
const LPWSTR CLSID_String_SpeakersTerminal = L"{AAF578F0-DC70-11D0-8ED3-00C04FB6809F}";
const LPWSTR CLSID_String_MediaStreamTerminal = L"{E2F7AEF7-4971-11D1-A671-006097C9A2E8}";
const LPWSTR CLSID_String_FileTerminal = L"{AAF578F1-DC70-11D0-8ED3-00C04FB6809F}";
const LPWSTR CLSID_String_DigitTerminal = L"{FBCDFF91-40E2-11D1-8F33-00C04FB6809F}";
const LPWSTR CLSID_String_DataTerminal = L"{749F0020-7010-11D1-8F55-00C04FB6809F}";
const LPWSTR CLSID_String_CompoundRenderTerminal = L"{F6EEDCDC-4FE4-11D1-A671-006097C9A2E8}";

#if defined(_DEBUG)
#define new new(_NORMAL_BLOCK, __FILE__, __LINE__)
#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__21D6D484_A88B_11D0_83DD_00AA003CCABD__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\stream.cpp ===
/*++

Copyright (c) 1998 - 1999  Microsoft Corporation

Module Name:

    stream.cpp

Abstract:

    implementation of the CStream objects

    these objects are used when a TSP has phone devices that have
    been made into terminals
        
Author:

    mquinton - 9/15/98

Notes:

    optional-notes

Revision History:

--*/

#include "stdafx.h"
#include "priviids.h"

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CStream implementation
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CStream::get_MediaType
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CStream::get_MediaType(long * plMediaType)
{
    LOG((TL_TRACE, "get_MediaType - enter"));

    if ( TAPIIsBadWritePtr( plMediaType, sizeof( long ) ) )
    {
        LOG((TL_ERROR, "get_MediaType - bad pointer"));

        return E_POINTER;
    }

    Lock();

    *plMediaType = m_lMediaType;

    Unlock();
    
    LOG((TL_TRACE, "get_MediaType - exit - return SUCCESS"));
    
    return S_OK;
}
   
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CStream::get_Direction
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CStream::get_Direction(TERMINAL_DIRECTION * pTD)
{
    LOG((TL_TRACE, "get_Direction - enter"));

    if ( TAPIIsBadWritePtr( pTD, sizeof( TERMINAL_DIRECTION ) ) )
    {
        LOG((TL_ERROR, "get_Direction - bad pointer"));

        return E_POINTER;
    }

    Lock();

    *pTD = m_Dir;

    Unlock();
    
    LOG((TL_TRACE, "get_Direction - exit - return S_OK"));
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CStream::get_Name
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CStream::get_Name(BSTR * ppName)
{
    LOG((TL_TRACE, "get_Name - enter"));

    if ( TAPIIsBadWritePtr( ppName, sizeof( BSTR ) ) )
    {
        LOG((TL_ERROR, "get_Name - bad pointer"));

        return E_POINTER;
    }

    Lock();

    *ppName = SysAllocString( m_pName );

    Unlock();

    if ( ( NULL == *ppName ) && ( NULL != m_pName ) )
    {
        LOG((TL_TRACE, "get_Name - SysAllocString Failed" ));
        return E_OUTOFMEMORY;
    }

    LOG((TL_TRACE, "get_Name - exit - return S_OK"));
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CStream::StartStream
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CStream::StartStream(void)
{
    HRESULT             hr = E_NOTIMPL;

    LOG((TL_TRACE, "StartStream - enter"));

    LOG((TL_TRACE, "StartStream - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CStream::PauseStream
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CStream::PauseStream(void)
{
    HRESULT             hr = E_NOTIMPL;

    LOG((TL_TRACE, "PauseStream - enter"));

    LOG((TL_TRACE, "PauseStream - exit - return %lx", hr));
    
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CStream::StopStream
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CStream::StopStream(void)
{
    HRESULT             hr = E_NOTIMPL;

    LOG((TL_TRACE, "StopStream - enter"));

    LOG((TL_TRACE, "StopStream - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CStream::SelectTerminal
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CStream::SelectTerminal(ITTerminal * pTerminal)
{
    HRESULT             hr = S_OK;
    ITTerminalPrivate * pTerminalPrivate;
    long                lMediaType;
    TERMINAL_DIRECTION  Dir;
    

    LOG((TL_TRACE, "SelectTerminal - enter"));

    if ( IsBadReadPtr( pTerminal, sizeof( ITTerminal ) ) )
    {
        LOG((TL_ERROR, "SelectTerminal - bad pTerminal"));

        return E_INVALIDARG;
    }


    hr = pTerminal->QueryInterface(
                                   IID_ITTerminalPrivate,
                                   (void**)&pTerminalPrivate
                                  );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "SelectTerminal - Terminal not valid on this address"));

        return TAPI_E_INVALIDTERMINAL;
    }

    hr = pTerminal->get_MediaType( &lMediaType );

    if ( SUCCEEDED(hr) )
    {
        hr = pTerminal->get_Direction( &Dir );
    }

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "SelectTerminal - ITTerminal method failed - %lx", hr));

        pTerminalPrivate->Release();
    
        return hr;
    }

    Lock();

    if ( (lMediaType != m_lMediaType) ||
         (Dir != m_Dir) )
    {
        LOG((TL_ERROR, "SelectTerminal - terminal wrong mediatype or dir"));

        pTerminalPrivate->Release();
    
        Unlock();
        
        return TAPI_E_INVALIDTERMINAL;
    }

    AddTerminal( pTerminalPrivate );

    Unlock();
    
    pTerminalPrivate->Release();
    
    LOG((TL_TRACE, "SelectTerminal - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CStream::UnselectTerminal
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CStream::UnselectTerminal(ITTerminal * pTerminal)
{
    HRESULT             hr = S_OK;
    ITTerminalPrivate * pTerminalPrivate;
    
    LOG((TL_TRACE, "UnselectTerminal - enter"));

    if ( IsBadReadPtr( pTerminal, sizeof( ITTerminal ) ) )
    {
        LOG((TL_ERROR, "UnselectTerminal - bad pTerminal"));

        return E_INVALIDARG;
    }

    hr = pTerminal->QueryInterface(
                                   IID_ITTerminalPrivate,
                                   (void**)&pTerminalPrivate
                                  );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_TRACE, "UnselectTerminal - terminal not selected"));

        return TAPI_E_INVALIDTERMINAL;
    }
    
    hr = RemoveTerminal( pTerminal );

    pTerminalPrivate->Release();

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_TRACE, "UnselectTerminal - terminal not selected"));

        return TAPI_E_INVALIDTERMINAL;
    }
    
    LOG((TL_TRACE, "UnselectTerminal - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CStream::EnumerateTerminals
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CStream::EnumerateTerminals(IEnumTerminal ** ppEnumTerminal)
{
    HRESULT             hr = S_OK;

    LOG((TL_TRACE, "EnumerateTerminals - enter"));

    if (TAPIIsBadWritePtr(ppEnumTerminal, sizeof( IEnumTerminal * ) ) )
    {
        LOG((TL_ERROR, "EnumerateTerminals - bad pointer"));

        return E_POINTER;
    }
    
    //
    // create the enumerator
    //
    CComObject< CTapiEnum< IEnumTerminal, ITTerminal, &IID_IEnumTerminal > > * p;
    hr = CComObject< CTapiEnum< IEnumTerminal, ITTerminal, &IID_IEnumTerminal > >
         ::CreateInstance( &p );

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "EnumerateTerminals - could not create enum" ));
        
        return hr;
    }


    Lock();
    
    //
    // initialize it with our terminal array
    //
    p->Initialize( m_TerminalArray );

    Unlock();

    //
    // return it
    //
    *ppEnumTerminal = p;
    
    LOG((TL_TRACE, "EnumerateTerminals - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CStream::get_Terminals
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CStream::get_Terminals(VARIANT * pTerminals)
{
    HRESULT             hr = S_OK;
    IDispatch         * pDisp;
    
    LOG((TL_TRACE, "get_Terminals - enter"));

    if (TAPIIsBadWritePtr( pTerminals, sizeof(VARIANT) ) )
    {
        LOG((TL_ERROR, "get_Terminals - bad pointer"));

        return E_POINTER;
    }

    
    CComObject< CTapiCollection< ITTerminal > > * p;
    CComObject< CTapiCollection< ITTerminal > >::CreateInstance( &p );
    
    if (NULL == p)
    {
        LOG((TL_ERROR, "get_Terminals - could not create collection" ));
        
        return E_OUTOFMEMORY;
    }

    Lock();
    
    // initialize
    hr = p->Initialize( m_TerminalArray );

    Unlock();

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "get_Terminals - could not initialize collection" ));
        
        delete p;
        return hr;
    }

    //
    // get the IDispatch interface
    //
    hr = p->_InternalQueryInterface(
                                    IID_IDispatch,
                                    (void **) &pDisp
                                   );

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "get_Terminals - could not get IDispatch interface" ));
        
        delete p;
        return hr;
    }

    //
    // put it in the variant
    //
    VariantInit(pTerminals);
    pTerminals->vt = VT_DISPATCH;
    pTerminals->pdispVal = pDisp;
    

    LOG((TL_TRACE, "get_Terminals - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CStream::InternalCreateStream
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CStream::InternalCreateStream(
                              long lMediaType,
                              TERMINAL_DIRECTION td,
                              ITPhoneMSPCallPrivate * pCall,
                              ITStream ** ppStream
                             )

{
    CComObject< CStream >           * p;
    HRESULT                           hr = S_OK;
    PWSTR                             pPhoneDevice;
    PWSTR                             pStream;
    PWSTR                             pAudio;
    
    hr = CComObject< CStream >::CreateInstance( &p );

    if ( !SUCCEEDED(hr) )
    {
        STATICLOG((TL_ERROR, "InternalCreateStream failed - %lx", hr));

        return hr;
    }

    p->m_Dir = td;
    p->m_lMediaType = lMediaType;
    p->m_pCall = pCall;
    p->AddRef();

    pPhoneDevice = MyLoadString( IDS_PHONEDEVICE );
    pStream = MyLoadString( IDS_STREAM );
    pAudio = MyLoadString( (td == TD_CAPTURE) ? IDS_AUDIOOUT : IDS_AUDIOIN );

    if ( ( NULL == pPhoneDevice ) ||
         ( NULL == pStream ) ||
         ( NULL == pAudio ) )
    {
        STATICLOG((TL_ERROR, "Couldn't load string in InternalCreateStream"));

        p->Release();
        
        return E_OUTOFMEMORY;
    }

    p->m_pName = (BSTR) ClientAlloc( ( lstrlenW( pPhoneDevice ) + lstrlenW( pStream ) +
                                    lstrlenW( pAudio ) + 64 ) * sizeof (WCHAR) );

    if ( NULL == p->m_pName )
    {
        STATICLOG((TL_ERROR, "Alloc failed in InternalCreateStream"));

        p->Release();

        ClientFree( pPhoneDevice );
        ClientFree( pStream );
        ClientFree( pAudio );

        return E_OUTOFMEMORY;
    }

    wsprintfW(
              p->m_pName,
              L"%s %s %s",
              pPhoneDevice,
              pStream,
              pAudio
             );
    
    ClientFree( pPhoneDevice );
    ClientFree( pStream );
    ClientFree( pAudio );

    *ppStream = p;
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CStream::FinalRelease()
{
    if ( NULL != m_pName )
    {
        ClientFree( m_pName );
    }

    m_TerminalArray.Shutdown();
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CStream::AddTerminal
//
// saves terminal as selected
//
// called in lock
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CStream::AddTerminal( ITTerminalPrivate * pTerminal )
{
    ITTerminal          * pLocalTerminal;
    HRESULT               hr;

    hr = pTerminal->QueryInterface(
                                   IID_ITTerminal,
                                   (void**)&pLocalTerminal
                                  );

    m_TerminalArray.Add( pLocalTerminal );

    pLocalTerminal->Release();

    m_pCall->SelectTerminal( pTerminal );
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CStream::RemoveTerminal
//
// removes terminal from being selected
//
// called in lock
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CStream::RemoveTerminal( ITTerminal * pTerminal )
{
    BOOL            bRemoved;
    
    bRemoved = m_TerminalArray.Remove( pTerminal );
    
    if (bRemoved)
    {
        ITTerminalPrivate               * pTerminalPrivate;
        HRESULT                           hr;

        hr = pTerminal->QueryInterface(
                                       IID_ITTerminalPrivate,
                                       (void**)&pTerminalPrivate
                                      );
        
        m_pCall->UnselectTerminal( pTerminalPrivate );

        pTerminalPrivate->Release();
        
        return S_OK;
    }

    return TAPI_E_INVALIDTERMINAL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\stream.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    stream.h

Abstract:

    Declaration of the CStream class
    
Author:

    mquinton  09-24-98

Notes:

Revision History:

--*/

#ifndef __STREAM_H__
#define __STREAM_H__

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CStream
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
class CStream : 
	public CTAPIComObjectRoot<CStream>,
	public CComDualImpl<ITStream, &IID_ITStream, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
public:
    
	CStream() : m_pName( NULL ),
                m_pCall( NULL )
    {}

    void FinalRelease();

DECLARE_MARSHALQI(CStream)
DECLARE_TRACELOG_CLASS(CStream)

BEGIN_COM_MAP(CStream)
	COM_INTERFACE_ENTRY2(IDispatch, ITStream)
    COM_INTERFACE_ENTRY(ITStream)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()


   static HRESULT InternalCreateStream(
                                       long lMediaType,
                                       TERMINAL_DIRECTION td,
                                       ITPhoneMSPCallPrivate * pCall,
                                       ITStream ** ppStream
                                      );
void AddTerminal( ITTerminalPrivate * pTerminal );
HRESULT RemoveTerminal( ITTerminal * pTerminal );

protected:

    TERMINAL_DIRECTION          m_Dir;
    long                        m_lMediaType;
    BSTR                        m_pName;
    TerminalArray               m_TerminalArray;
    ITPhoneMSPCallPrivate     * m_pCall;
    
public:

    STDMETHOD(get_MediaType)(long * plMediaType);
    STDMETHOD(get_Direction)(TERMINAL_DIRECTION * pTD);
    STDMETHOD(get_Name)(BSTR * ppName);
    STDMETHOD(StartStream)(void);
    STDMETHOD(PauseStream)(void);
    STDMETHOD(StopStream)(void);
    STDMETHOD(SelectTerminal)(ITTerminal * pTerminal);
    STDMETHOD(UnselectTerminal)(ITTerminal * pTerminal);
    STDMETHOD(EnumerateTerminals)(IEnumTerminal ** ppEnumTerminal);
    STDMETHOD(get_Terminals)(VARIANT * pTerminals);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\tapi3p.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    tapi3p.h

Abstract:

    Private tapi3 includes
    
Author:

    mquinton  10-06-98
    
Notes:

Revision History:

--*/

#ifndef __TAPI3_PRIVATE_INCLUDES
#define __TAPI3_PRIVATE_INCLUDES

class CCall;
class CPhoneMSP;
interface ITPhoneMSPCallPrivate;

// {E024B01A-4197-11d1-8F33-00C04FB6809F}
DEFINE_GUID(IID_ITTerminalPrivate,
0xe024b01a, 0x4197, 0x11d1, 0x8f, 0x33, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f);

// {D5CDB35B-5D7D-11d2-A053-00C04FB6809F}
DEFINE_GUID(IID_ITPhoneMSPAddressPrivate, 
0xd5cdb35b, 0x5d7d, 0x11d2, 0xa0, 0x53, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f);

// {D5CDB359-5D7D-11d2-A053-00C04FB6809F}
DEFINE_GUID(IID_ITPhoneMSPCallPrivate, 
0xd5cdb359, 0x5d7d, 0x11d2, 0xa0, 0x53, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f);

// {D5CDB35A-5D7D-11d2-A053-00C04FB6809F}
DEFINE_GUID(IID_ITPhoneMSPStreamPrivate, 
0xd5cdb35a, 0x5d7d, 0x11d2, 0xa0, 0x53, 0x0, 0xc0, 0x4f, 0xb6, 0x80, 0x9f);

interface ITTerminalPrivate : IUnknown
{
public:
    STDMETHOD(GetHookSwitchDev)( DWORD * ) = 0;
    STDMETHOD(GetPhoneID)( DWORD * ) = 0;
    STDMETHOD(GetHPhoneApp)( HPHONEAPP * ) = 0;
    STDMETHOD(GetAPIVersion)( DWORD * ) = 0;
    STDMETHOD(SetMSPCall)(ITPhoneMSPCallPrivate *) = 0;
};

interface ITPhoneMSPAddressPrivate : IUnknown
{
public:
};

interface ITPhoneMSPCallPrivate : IUnknown
{
public:
    STDMETHOD(Initialize)( CPhoneMSP * ) = 0;
    STDMETHOD(OnConnect)() = 0;
    STDMETHOD(OnDisconnect)() = 0;
    STDMETHOD(SelectTerminal)( ITTerminalPrivate * ) = 0;
    STDMETHOD(UnselectTerminal)( ITTerminalPrivate * ) = 0;
	STDMETHOD(GetGain)(long *pVal, DWORD) = 0;
	STDMETHOD(PutGain)(long newVal, DWORD) = 0;
	STDMETHOD(GetVolume)(long *pVal, DWORD) = 0;
	STDMETHOD(PutVolume)(long newVal, DWORD) = 0;
};

interface ITPhoneMSPStreamPrivate : IUnknown
{
public:
};

#endif // #ifndef __TAPI3_PRIVATE_INCLUDES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\tapi3.cpp ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    tapi3.cpp

Abstract:

    Implementation of DLL Exports.

Author:

    mquinton - 6/12/97

Notes:


Revision History:

--*/

// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f tapi3ps.mk in the project directory.

#include "stdafx.h"
//#include "initguid.h"

//#include "dlldatax.h"

//
// For the ntbuild environment we need to include this file to get the base
//  class implementations.
//
#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif


#include <atlimpl.cpp>


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

/*extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
    {
		_Module.Term();
    }
    
	return TRUE;    // ok
}*/

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
	if (PrxDllCanUnloadNow() != S_OK)
		return S_FALSE;
#endif
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
	if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
		return S_OK;
#endif
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
	HRESULT hRes = PrxDllRegisterServer();
	if (FAILED(hRes))
		return hRes;
#endif
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
	PrxDllUnregisterServer();
#endif
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\tapibase.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    tapibase.h

Abstract:

    Declaration of the CTAPIComObjectRoot template
    
Author:

    mquinton  09-23-98
    
Notes:

Revision History:

--*/

#ifndef __TAPIBASE_H__
#define __TAPIBASE_H__



template <class base, class CComThreadingModel = CComMultiThreadModel>
class CTAPIComObjectRoot :
   public CComObjectRootEx<CComThreadingModel>
{
protected:
    IUnknown                      * m_pFTM;

public:
    CTAPIComObjectRoot()
    {
        m_pFTM = NULL;
    }
    
    ~CTAPIComObjectRoot()
    {
        //
        // release the free threaded marshaller
        //
        if ( NULL != m_pFTM )
        {
            m_pFTM->Release();
        }
    }    


    //virtual HRESULT WINAPI IMarshalQI( void * pv, REFIID riid, LPVOID * ppv, DWORD_PTR dw )= 0;
};

template <class base>
   class CTAPIComDispatchObject :
   public CComObjectRootEx<CComMultiThreadModel>,
   public IDispatch
{
protected:
    base * m_pBase;

public:

	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppvObject);
	virtual ULONG STDMETHODCALLTYPE AddRef();
	virtual ULONG STDMETHODCALLTYPE Release();

    void Initialize( base * p )
    {
        m_pBase = p;
        m_pBase->AddRef();
    }

    void helpme()
    {
        const _ATL_INTMAP_ENTRY* pEntries = m_pBase->_GetEntries();

        while ( pEntries->pFunc != NULL )
        {
            if (pEntries->pFunc == _ATL_SIMPLEMAPENTRY)
            {
                IDispatch * pDisp = (IDispatch*)((LONG_PTR)m_pBase+pEntries->dw);
            }

            pEntries++;
        }

    }


    STDMETHOD(GetTypeInfoCount)(UINT * pctinfo);
    STDMETHOD(GetTypeInfo)(
        UINT iTInfo,
        LCID lcid,
        ITypeInfo ** ppTInfo
        );
    STDMETHOD(GetIDsOfNames)(
        REFIID riid,
        LPOLESTR * rgszNames,
        UINT cNames,
        LCID lcid,
        DISPID * rgDispId
        );
    STDMETHOD(Invoke)(
        DISPID dispIdMember,
        REFIID riid,
        LCID lcid,
        WORD wFlags,
        DISPPARAMS * pDispParams,
        VARIANT * pVarResult,
        EXCEPINFO * pExcepInfo,
        UINT * puArgErr
        );
};




#define DECLARE_MARSHALQI(__base__)                                                \
static HRESULT WINAPI IMarshalQI( void * pv, REFIID riid, LPVOID * ppv, DWORD_PTR dw ) \
{                                                                                  \
    HRESULT                   hr;                                                  \
    IUnknown                * pUnk;                                                \
                                                                                   \
    __base__ * pObject = (__base__ *)pv;                                           \
                                                                                   \
    *ppv = NULL;                                                                   \
                                                                                   \
    pObject->Lock();                                                               \
                                                                                   \
    if ( NULL == pObject->m_pFTM )                                                 \
    {                                                                              \
        pObject->_InternalQueryInterface(IID_IUnknown, (void **)&pUnk);            \
                                                                                   \
        hr = CoCreateFreeThreadedMarshaler(                                        \
                                           pUnk,                                   \
                                           &(pObject->m_pFTM)                      \
                                          );                                       \
                                                                                   \
        pUnk->Release();                                                           \
                                                                                   \
        if ( !SUCCEEDED(hr) )                                                      \
        {                                                                          \
            pObject->Unlock();                                                     \
                                                                                   \
            return E_NOINTERFACE;                                                  \
        }                                                                          \
    }                                                                              \
                                                                                   \
    pObject->Unlock();                                                             \
                                                                                   \
    return S_FALSE;                                                                \
}                                                                                  \


           

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\tapiobj.cpp ===
/*++

Copyright (c) 1997 - 1999 Microsoft Corporation

Module Name:

    tapiobj.cpp

Abstract:

    Implementation of the TAPI object for TAPI 3.0.

    The TAPI object represents the application's entry point
    into TAPI - it is similar to the hLineApp / hPhoneApp.

Author:

    mquinton - 4/17/97

Notes:

    optional-notes

Revision History:

--*/

#include "stdafx.h"
#include "common.h"
#include "atlwin.cpp"
#include "tapievt.h"

extern "C" {
#include "..\..\inc\tapihndl.h"
}

extern CRITICAL_SECTION        gcsTapiObjectArray;
extern CRITICAL_SECTION        gcsGlobalInterfaceTable;

//
// handle for heap for the handle table
//
// does not need to be exported, hence static
//

static HANDLE ghTapiHeap = 0;


//
// handle table handle
//

HANDLE ghHandleTable = 0;


///////////////////////////////////////////////////////////////////////////////
//
// FreeContextCallback
//
// callback function called by the handle table when a table entry 
// is removed. No need to do anything in this case.
//

VOID
CALLBACK
FreeContextCallback(
    LPVOID      Context,
    LPVOID      Context2
    )
{
    
}


///////////////////////////////////////////////////////////////////////////////
//
// AllocateAndInitializeHandleTable
// 
// this function creates heap for handle table and the handle table itself
//
// Note: this function is not thread-safe. It is only called from 
// ctapi::Initialize() from ghTapiInitShutdownSerializeMutex lock
//

HRESULT AllocateAndInitializeHandleTable()
{

    LOG((TL_TRACE, "AllocateAndInitializeHandleTable - entered"));


    //
    // heap should not exist at this point
    //

    _ASSERTE(NULL == ghTapiHeap);
    
    if (NULL != ghTapiHeap)
    {
        LOG((TL_ERROR, "AllocateAndInitializeHandleTable() heap already exists"));

        return E_UNEXPECTED;
    }


    //
    // handle table should not exist at this point
    //

    _ASSERTE(NULL == ghHandleTable);
    
    if (NULL != ghHandleTable)
    {
        LOG((TL_ERROR, "AllocateAndInitializeHandleTable() handle table already exists"));

        return E_UNEXPECTED;
    }
    
    //
    // attempt to create heap
    //

    if (!(ghTapiHeap = HeapCreate (0, 0x10000, 0)))
    {
        
        //
        // heap creation failed, use process's heap
        //

        LOG((TL_WARN, "AllocateAndInitializeHandleTable() failed to allocate private heap. using process's heap"));


        ghTapiHeap = GetProcessHeap();

        if (NULL == ghTapiHeap)
        {
            LOG((TL_ERROR, "AllocateAndInitializeHandleTable failed to get process's heap"));
            
            return E_OUTOFMEMORY;
        }

    } // HeapCreate()


    //
    // we have the heap. use it to create handle table
    //

    ghHandleTable = CreateHandleTable(  ghTapiHeap,
                                        FreeContextCallback,
                                        1,            // min handle value
                                        MAX_DWORD     // max handle value
                                        );


    if (NULL == ghHandleTable)
    {
        LOG((TL_ERROR, "AllocateAndInitializeHandleTable failed to create handle table"));

        HeapDestroy (ghTapiHeap);
        ghTapiHeap = NULL;

        return E_OUTOFMEMORY;
    }


    //
    // succeeded creating heap and handle table
    //

    LOG((TL_INFO, "AllocateAndInitializeHandleTable - succeeded"));

    return S_OK;
        

}


///////////////////////////////////////////////////////////////////////////////
//
// ShutdownAndDeallocateHandleTable
//
// this function deletes handle table, and destroys heap on which it was 
// allocated (if not process heap)
//
// Note: this function is not thread-safe. It is only called from 
// ctapi::Initialize() and Shutdown() from ghTapiInitShutdownSerializeMutex lock
//

HRESULT ShutdownAndDeallocateHandleTable()
{

    LOG((TL_TRACE, "ShutdownAndDeallocateHandleTable - entered"));


    //
    // heap should exist at this point
    //

    _ASSERTE(NULL != ghTapiHeap);
    
    if (NULL == ghTapiHeap)
    {
        LOG((TL_ERROR, "ShutdownAndDeallocateHandleTable heap does not exist"));

        return E_UNEXPECTED;
    }


    //
    // handle table should exist at this point
    //

    _ASSERTE(NULL != ghHandleTable);
    
    if (NULL == ghHandleTable)
    {
        LOG((TL_ERROR, "ShutdownAndDeallocateHandleTable handle table does not exist"));

        return E_UNEXPECTED;
    }


    //
    // delete handle table
    //

    DeleteHandleTable (ghHandleTable);
    ghHandleTable = NULL;
    
    
    //
    // if we created heap for it, destroy it
    //

    if (ghTapiHeap != GetProcessHeap())
    {
        LOG((TL_INFO, "ShutdownAndDeallocateHandleTable destroying heap"));

        HeapDestroy (ghTapiHeap);
    }
    else
    {
        LOG((TL_INFO, "ShutdownAndDeallocateHandleTable not destroyng current heap -- used process's heap"));
    }


    //
    // in any case, loose reference to the heap.
    //

    ghTapiHeap = NULL;


    LOG((TL_INFO, "ShutdownAndDeallocateHandleTable - succeeded"));

    return S_OK;
}




IGlobalInterfaceTable * gpGIT = NULL;

LONG
WINAPI
AllocClientResources(
    DWORD   dwErrorClass
    );

extern HRESULT mapTAPIErrorCode(long lErrorCode);
 
/////////////////////////////////////////////////////////////////////////////
// CTAPI
//

// Static data members

TAPIObjectArrayNR   CTAPI::m_sTAPIObjectArray;

extern HANDLE ghTapiInitShutdownSerializeMutex;

extern ULONG_PTR GenerateHandleAndAddToHashTable( ULONG_PTR Element);
extern void RemoveHandleFromHashTable(ULONG_PTR dwHandle);
extern CHashTable * gpHandleHashTable;


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CTAPI::ReleaseGIT
//
// releases Global Interface Table
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

void CTAPI::ReleaseGIT()
{
        
    EnterCriticalSection( &gcsGlobalInterfaceTable );


    if ( NULL != gpGIT )
    {

        LOG((TL_TRACE, "Shutdown - release GIT"));
        gpGIT->Release();
        
        gpGIT = NULL;

    }

    LeaveCriticalSection( &gcsGlobalInterfaceTable );

}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CTAPI::AllocateInitializeAllCaches
//
// allocates and initializes cache objects (address, line, phone). 
//
// returns S_OK on success or E_OUTOFMEMORY on failure
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

HRESULT CTAPI::AllocateInitializeAllCaches()
{
    
    LOG((TL_TRACE, "AllocateInitializeAllCaches - enter"));


    //
    // all caches already initialized?
    //

    if ( (NULL != m_pAddressCapCache) &&
         (NULL != m_pLineCapCache)    &&
         (NULL != m_pPhoneCapCache) )
    {
        LOG((TL_TRACE, "AllocateInitializeAllCaches - already initialized. nothing to do"));

        return S_OK;
    }


    //
    // only some caches are initialized? that's a bug!
    //

    if ( (NULL != m_pAddressCapCache) ||
         (NULL != m_pLineCapCache)    ||
         (NULL != m_pPhoneCapCache) )
    {
        LOG((TL_ERROR, "AllocateInitializeAllCaches - already initialized"));

        _ASSERTE(FALSE);


        //
        // we could try to complete cleanup and continue, but this would be too
        // risky since we don't really know how we got here to begin with. 
        // simply failing is much safer.
        //

        return E_UNEXPECTED;
    }

    
    ////////////////////////
    
    //
    // allocate address cache
    //

    try
    {
        m_pAddressCapCache = new CStructCache;
    }
    catch(...)
    {
        // Initialize critical section in the constructor most likely threw this exception
        LOG((TL_ERROR, "AllocateInitializeAllCaches - m_pAddressCapCache constructor threw an exception"));
        m_pAddressCapCache = NULL;
    }

    if (NULL == m_pAddressCapCache)
    {
        LOG((TL_ERROR, "AllocateInitializeAllCaches - failed to allocate m_pAddressCapCache"));

        FreeAllCaches();

        return E_OUTOFMEMORY;
    }


    //
    // attempt to initialize address cache
    //


    HRESULT hr = m_pAddressCapCache->Initialize(5,
                                                sizeof(LINEADDRESSCAPS) + 500,
                                                BUFFERTYPE_ADDRCAP
                                               );
    if (FAILED(hr))
    {
        LOG((TL_ERROR, "AllocateInitializeAllCaches - failed to initialize m_pAddressCapCache. hr = %lx", hr));

        FreeAllCaches();

        return hr;
    }


    ////////////////////////

    //
    // allocate line cache
    //

    try
    {
        m_pLineCapCache    = new CStructCache;
    }
    catch(...)
    {
        // Initialize critical section in the constructor most likely threw this exception
        LOG((TL_ERROR, "AllocateInitializeAllCaches - m_pLineCapCache constructor threw an exception"));
        m_pLineCapCache = NULL;
    }

    if (NULL == m_pLineCapCache )
    {
        LOG((TL_ERROR, "AllocateInitializeAllCaches - failed to allocate m_pLineCapCache"));

        FreeAllCaches();

        return E_OUTOFMEMORY;
    }


    //
    // attempt to initialize line cache
    //

    hr = m_pLineCapCache->Initialize(5,
                                     sizeof(LINEDEVCAPS) + 500,
                                     BUFFERTYPE_LINEDEVCAP
                                    );

    if (FAILED(hr))
    {
        LOG((TL_ERROR, "AllocateInitializeAllCaches - failed to initialize m_pLineCapCache. hr = %lx", hr));

        FreeAllCaches();

        return hr;
    }

    ////////////////////////

    //
    // allocate phone cache
    //

    try
    {
        m_pPhoneCapCache   = new CStructCache;
    }
    catch(...)
    {
        // Initialize critical section in the constructor most likely threw this exception
        LOG((TL_ERROR, "AllocateInitializeAllCaches - m_pPhoneCapCache constructor threw an exception"));
        m_pPhoneCapCache = NULL;
    }    

    //
    // succeeded?
    //

    if (NULL == m_pPhoneCapCache)
    {
        LOG((TL_ERROR, "AllocateInitializeAllCaches - failed to allocate m_pPhoneCapCache"));

        FreeAllCaches();

        return E_OUTOFMEMORY;
    }


    //
    // initialize phone cache
    //

    hr = m_pPhoneCapCache->Initialize(5,
                                      sizeof(PHONECAPS) + 500,
                                      BUFFERTYPE_PHONECAP
                                     );


    if (FAILED(hr))
    {
        LOG((TL_ERROR, "AllocateInitializeAllCaches - failed to initialize m_pPhoneCapCache. hr = %lx", hr));

        FreeAllCaches();

        return hr;
    }


    LOG((TL_TRACE, "AllocateInitializeAllCaches - finish"));

    return S_OK;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CTAPI::FreeAllCaches
//
// shuts down and deletes all allocated cache objects (address, line, phone)
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

void CTAPI::FreeAllCaches()
{
    LOG((TL_TRACE, "FreeAllCaches - enter"));


    //
    // Note: it is safe to shutdown a cache that failed initialization or was
    // not initialized at all
    //

    if (NULL != m_pAddressCapCache)
    {
        LOG((TL_TRACE, "FreeAllCaches - freeing AddressCapCache"));

        m_pAddressCapCache->Shutdown();
        delete m_pAddressCapCache;
        m_pAddressCapCache = NULL;
    }


    if (NULL != m_pLineCapCache)
    {
        LOG((TL_TRACE, "FreeAllCaches - freeing LineCapCache"));

        m_pLineCapCache->Shutdown();
        delete m_pLineCapCache;
        m_pLineCapCache = NULL;
    }


    if (NULL != m_pPhoneCapCache)
    {
        LOG((TL_TRACE, "FreeAllCaches - freeing PhoneCapCache"));

        m_pPhoneCapCache->Shutdown();
        delete m_pPhoneCapCache;
        m_pPhoneCapCache = NULL;
    }

    LOG((TL_TRACE, "FreeAllCaches - exit"));
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CTAPI::Initialize
//
// Intialize the TAPI object
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT 
STDMETHODCALLTYPE 
CTAPI::Initialize( 
		   void
		   )
{
    HRESULT hr;
    int     tapiObjectArraySize=0;

    LOG((TL_TRACE, "Initialize[%p] enter", this ));


    //Serialize the Init and Shutdown code
    WaitForSingleObject( ghTapiInitShutdownSerializeMutex, INFINITE );
    
    //
    // if we're already initialized
    // just return
    //
    Lock();

    if ( m_dwFlags & TAPIFLAG_INITIALIZED )
    {
        LOG((TL_TRACE, "Already initialized - return S_FALSE"));
        
        Unlock();
        ReleaseMutex( ghTapiInitShutdownSerializeMutex );
        return S_FALSE;
    }

    //
    // start up TAPI if we haven't already
    //
    EnterCriticalSection( &gcsTapiObjectArray );

    tapiObjectArraySize = m_sTAPIObjectArray.GetSize();
    
    LeaveCriticalSection ( &gcsTapiObjectArray );

    if ( 0 == tapiObjectArraySize )
    {

        //
        // create handle table
        //

        hr = AllocateAndInitializeHandleTable();

        if (FAILED(hr))
        {
            LOG((TL_ERROR, "Initialize failed to create handle table"));

            Unlock();
            ReleaseMutex( ghTapiInitShutdownSerializeMutex );

            return hr;
        }


        hr = mapTAPIErrorCode( AllocClientResources (1) );

        if ( 0 != hr )
        {
            LOG((TL_ERROR, "AllocClientResources failed - %lx", hr));

            ShutdownAndDeallocateHandleTable();

            Unlock();
            ReleaseMutex( ghTapiInitShutdownSerializeMutex );
            return hr;
        }
        
        EnterCriticalSection( &gcsGlobalInterfaceTable );
        //
        // get/create the global interface table
        //
        hr = CoCreateInstance(
                              CLSID_StdGlobalInterfaceTable,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IGlobalInterfaceTable,
                              (void **)&gpGIT
                             );

        LeaveCriticalSection( &gcsGlobalInterfaceTable );


        if ( !SUCCEEDED(hr) )
        {
            LOG((TL_ERROR, "Initialize - cocreate git failed - %lx", hr));

            ShutdownAndDeallocateHandleTable();

            Unlock();
            ReleaseMutex( ghTapiInitShutdownSerializeMutex );
            return hr;
        }
    }


    //
    // allocate and initialize all caches
    //
    // note: if something fails in Initialize later on, we don't really need
    // to clean caches in initialize itself, because the caches will be freed 
    // in CTAPI::FinalRelease when the tapi object is destroyed.
    //

    hr = AllocateInitializeAllCaches();

    if ( FAILED(hr))
    {
        LOG((TL_ERROR, "Initialize - failed to create and initialize caches"));

        if ( 0 == tapiObjectArraySize )
        {
            EnterCriticalSection( &gcsGlobalInterfaceTable );
            if ( NULL != gpGIT )
            {
                LOG((TL_TRACE, "Shutdown - release GIT"));
                gpGIT->Release();
            
                gpGIT = NULL;
            }
            LeaveCriticalSection( &gcsGlobalInterfaceTable );
            ShutdownAndDeallocateHandleTable();
        }

        Unlock();
        ReleaseMutex( ghTapiInitShutdownSerializeMutex );
        return E_OUTOFMEMORY;
    }


    //
    // Call LineInitialize
    //
    hr = NewInitialize();

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "Initialize - NewInitialize returned %lx", hr));

        if ( 0 == tapiObjectArraySize )
        {
            EnterCriticalSection( &gcsGlobalInterfaceTable );
            if ( NULL != gpGIT )
            {
                LOG((TL_TRACE, "Shutdown - release GIT"));
                gpGIT->Release();
            
                gpGIT = NULL;
            }
            LeaveCriticalSection( &gcsGlobalInterfaceTable );
            ShutdownAndDeallocateHandleTable();
        }

    
        FreeAllCaches();

        Unlock();
        ReleaseMutex( ghTapiInitShutdownSerializeMutex );
        return hr;
    }

    //
    // create the address objects
    //
    hr = CreateAllAddressesOnAllLines();

    if (S_OK != hr)
    {
        LOG((TL_INFO, "Initialize - CreateAddresses returned %lx", hr));

        NewShutdown();

        if ( 0 == tapiObjectArraySize )
        {
            EnterCriticalSection( &gcsGlobalInterfaceTable );
            if ( NULL != gpGIT )
            {
                LOG((TL_TRACE, "Shutdown - release GIT"));
                gpGIT->Release();
            
                gpGIT = NULL;
            }
            LeaveCriticalSection( &gcsGlobalInterfaceTable );
            ShutdownAndDeallocateHandleTable();
        }


        FreeAllCaches();


        Unlock();
        ReleaseMutex( ghTapiInitShutdownSerializeMutex );
        return hr;
    }

    //
    // create the phone objects
    //
    hr = CreateAllPhones();

    if (S_OK != hr)
    {
        LOG((TL_INFO, "Initialize - CreateAllPhones returned %lx", hr));

        NewShutdown();

        m_AddressArray.Shutdown ();

        if ( 0 == tapiObjectArraySize )
        {
            EnterCriticalSection( &gcsGlobalInterfaceTable );
            if ( NULL != gpGIT )
            {
                LOG((TL_TRACE, "Shutdown - release GIT"));
                gpGIT->Release();
            
                gpGIT = NULL;
            }
            LeaveCriticalSection( &gcsGlobalInterfaceTable );
            ShutdownAndDeallocateHandleTable();
        }


        FreeAllCaches();
        
        Unlock();
        ReleaseMutex( ghTapiInitShutdownSerializeMutex );
        return hr;
    }

    //
    // create the connectionpoint object
    //
    CComObject< CTAPIConnectionPoint > * p;
    hr = CComObject< CTAPIConnectionPoint >::CreateInstance( &p );
    
    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "new CTAPIConnectionPoint failed"));


        NewShutdown();

        m_AddressArray.Shutdown ();
        m_PhoneArray.Shutdown ();

        if ( 0 == tapiObjectArraySize )
        {
            EnterCriticalSection( &gcsGlobalInterfaceTable );
            if ( NULL != gpGIT )
            {
                LOG((TL_TRACE, "Shutdown - release GIT"));
                gpGIT->Release();
            
                gpGIT = NULL;
            }
            LeaveCriticalSection( &gcsGlobalInterfaceTable );
            ShutdownAndDeallocateHandleTable();
        }


        FreeAllCaches();

        Unlock();
        ReleaseMutex( ghTapiInitShutdownSerializeMutex );
        return hr;
    }        

    //
    // init the connection point
    //
    hr = p->Initialize(
                       (IConnectionPointContainer *)this,
                       IID_ITTAPIEventNotification
                      );

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "initialize CTAPIConnectionPoint failed"));

        delete p;

        NewShutdown();

        m_AddressArray.Shutdown ();
        m_PhoneArray.Shutdown ();

        if ( 0 == tapiObjectArraySize )
        {
            EnterCriticalSection( &gcsGlobalInterfaceTable );
            if ( NULL != gpGIT )
            {
                LOG((TL_TRACE, "Shutdown - release GIT"));
                gpGIT->Release();
            
                gpGIT = NULL;
            }
            LeaveCriticalSection( &gcsGlobalInterfaceTable );
            ShutdownAndDeallocateHandleTable();
        }


        FreeAllCaches();

        Unlock();
        ReleaseMutex( ghTapiInitShutdownSerializeMutex );
        return hr;
    }

    m_pCP = p;

    //
    // this object is initialized
    //

    m_dwFlags = TAPIFLAG_INITIALIZED;

    //
    // save object in global list
    //
    CTAPI * pTapi = this;

    EnterCriticalSection( &gcsTapiObjectArray );

    m_sTAPIObjectArray.Add( pTapi );

    // Set the event filter mask
    // Always ask for 
    // TE_CALLSTATE,
    // TE_CALLNOTIFICATION,
    // TE_PHONEVENET,
    // TE_CALLHUB,
    // TE_CALLINFOCHANGE
    // events. These events are used internally by Tapi3

    ULONG64 ulMask = 
        EM_LINE_CALLSTATE |     // TE_CALLSTATE
        EM_LINE_APPNEWCALL |    // TE_CALLNOTIFICATION 
        EM_PHONE_CLOSE |        // TE_PHONEEVENT
        EM_PHONE_STATE |        // TE_PHONEEVENT
        EM_PHONE_BUTTONMODE |   // TE_PHONEEVENT
        EM_PHONE_BUTTONSTATE |  // TE_PHONEVENT
        EM_LINE_APPNEWCALLHUB | // TE_CALLHUB
        EM_LINE_CALLHUBCLOSE |  // TE_CALLHUB
        EM_LINE_CALLINFO |      // TE_CALLINFOCHANGE
        EM_LINE_CREATE |        // TE_TAPIOBJECT
        EM_LINE_REMOVE |        // TE_TAPIOBJECT
        EM_LINE_CLOSE |         // TE_TAPIOBJECT
        EM_PHONE_CREATE |       // TE_TAPIOBJECT
        EM_PHONE_REMOVE |       // TE_TAPIOBJECT
        EM_LINE_DEVSPECIFICEX | // TE_ADDRESSDEVSPECIFIC
        EM_LINE_DEVSPECIFIC   | // TE_ADDRESSDEVSPECIFIC
        EM_PHONE_DEVSPECIFIC;   // TE_PHONEDEVSPECIFIC


     DWORD dwLineDevStateSubMasks = 
         LINEDEVSTATE_REINIT |          // TE_TAPIOBJECT
         LINEDEVSTATE_TRANSLATECHANGE ; // TE_TAPIOBJECT


    tapiSetEventFilterMasks (
        TAPIOBJ_NULL,
        NULL,
        ulMask
        );

    tapiSetEventFilterSubMasks (
        TAPIOBJ_NULL,
        NULL,
        EM_LINE_LINEDEVSTATE,
        dwLineDevStateSubMasks
        );


    LeaveCriticalSection ( &gcsTapiObjectArray );

    Unlock();
    ReleaseMutex( ghTapiInitShutdownSerializeMutex );
    
    LOG((TL_TRACE, "Initialize exit - return SUCCESS"));
    
    return S_OK;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CTAPI::get_Addresses
//
// Creates & returns the collection of address objects
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
STDMETHODCALLTYPE
CTAPI::get_Addresses(VARIANT * pVariant)
{
    LOG((TL_TRACE, "get_Addresses enter"));
    LOG((TL_TRACE, "   pVariant ------->%p", pVariant));

    HRESULT         hr;
    IDispatch *     pDisp;

    Lock();
    if (!( m_dwFlags & TAPIFLAG_INITIALIZED ) )
    {
        LOG((TL_ERROR, "get_Addresses - tapi object must be initialized first" ));
        
        Unlock();    
        return E_INVALIDARG;
    }
    Unlock();

    if (TAPIIsBadWritePtr( pVariant, sizeof (VARIANT) ) )
    {
        LOG((TL_ERROR, "get_Addresses - bad pointer"));

        return E_POINTER;
    }
    
    CComObject< CTapiCollection< ITAddress > > * p;
    CComObject< CTapiCollection< ITAddress > >::CreateInstance( &p );
    
    if (NULL == p)
    {
        LOG((TL_ERROR, "get_Addresses - could not create collection" ));
        
        return E_OUTOFMEMORY;
    }

    Lock();
    
    // initialize
    hr = p->Initialize( m_AddressArray );

    Unlock();

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "get_Addresses - could not initialize collection" ));
        
        delete p;
        return hr;
    }

    // get the IDispatch interface
    hr = p->_InternalQueryInterface( IID_IDispatch, (void **) &pDisp );

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "get_Addresses - could not get IDispatch interface" ));
        
        delete p;
        return hr;
    }

    // put it in the variant

    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDisp;
    
    LOG((TL_TRACE, "get_Addressess exit - return %lx", hr ));
    
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CTAPI::EnumerateAddresses
//
// Create & return an address enumerator
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT 
STDMETHODCALLTYPE
CTAPI::EnumerateAddresses( 
                          IEnumAddress ** ppEnumAddresses
                         )
{
    HRESULT         hr = S_OK;

    CComObject< CTapiEnum<IEnumAddress, ITAddress, &IID_IEnumAddress> > * pEnum;

    LOG((TL_TRACE, "EnumerateAddresses enter"));

    Lock();

    if (!( m_dwFlags & TAPIFLAG_INITIALIZED ))
    {
        LOG((TL_ERROR, "EnumerateAddresses - tapi object must be initialized first" ));
        
        Unlock();
        return TAPI_E_REINIT;
    }
    
    Unlock();

    if ( TAPIIsBadWritePtr( ppEnumAddresses, sizeof (IEnumAddress *) ) )
    {
        LOG((TL_ERROR, "EnumerateAddresses - bad pointer"));
        
        return E_POINTER;
    }
    
    // create the object
    hr = CComObject< CTapiEnum<IEnumAddress, ITAddress, &IID_IEnumAddress> >::CreateInstance( &pEnum );

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "EnumerateAddresses - could not create enum - return %lx", hr));

        return hr;
    }

    // initialize
    Lock();
    hr = pEnum->Initialize( m_AddressArray );
    Unlock();

    if (S_OK != hr)
    {
        pEnum->Release();
        
        LOG((TL_ERROR, "EnumerateAddresses - could not initialize enum - return %lx", hr));

        return hr;
    }

    *ppEnumAddresses = pEnum;
    
    LOG((TL_TRACE, "EnumerateAddresses exit - return %lx", hr));
    
	return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CTAPI::GetPhoneArray
//
// Fill a phone array. The array will have references to all
// of the phone objects it contains. 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT 
CTAPI::GetPhoneArray( 
                     PhoneArray *pPhoneArray
                    )
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "GetPhoneArray enter"));

    Lock();

    if (!( m_dwFlags & TAPIFLAG_INITIALIZED ))
    {
        LOG((TL_ERROR, "GetPhoneArray - tapi object must be initialized first" ));
        
        Unlock();
        return E_INVALIDARG;
    }
    
    Unlock();

    if ( IsBadReadPtr( pPhoneArray, sizeof (PhoneArray) ) )
    {
        LOG((TL_ERROR, "GetPhoneArray - bad pointer"));
        
        return E_POINTER;
    }

    Lock();

    // initialize the array
    for(int iCount = 0; iCount < m_PhoneArray.GetSize(); iCount++)
    {
        pPhoneArray->Add(m_PhoneArray[iCount]);
    }

    Unlock();
    
    LOG((TL_TRACE, "GetPhoneArray exit - return %lx", hr));
    
	return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CTAPI::RegisterCallHubNotifications
//
// This method is used to tell TAPI that the application is interested in
// receiving callhub events.
//
// RETURNS
//
//      S_OK
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
STDMETHODCALLTYPE
CTAPI::RegisterCallHubNotifications( 
                                    VARIANT_BOOL bNotify
                                   )
{
    LOG((TL_TRACE, "RegisterCallHubNotifications - enter"));

    Lock();
    
    if (!( m_dwFlags & TAPIFLAG_INITIALIZED ))
    {
        LOG((TL_ERROR, "RCHN - tapi object must be initialized first" ));

        Unlock();
        return E_INVALIDARG;
    }
    
    if ( bNotify )
    {
        LOG((TL_INFO, "RCHN - callhub notify on"));
        m_dwFlags |= TAPIFLAG_CALLHUBNOTIFY;
    }
    else
    {
        LOG((TL_INFO, "RCHN - callhub notify off"));
        m_dwFlags &= ~TAPIFLAG_CALLHUBNOTIFY;
    }
    
    Unlock();

    LOG((TL_TRACE, "RegisterCallHubNotifications - exit - success"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// SetCallHubTracking
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CTAPI::SetCallHubTracking(
                          VARIANT pAddresses,
                          VARIANT_BOOL bSet
                         )
{
    HRESULT                     hr = S_OK;
    SAFEARRAY *                 pAddressArray;
    LONG                        llBound, luBound;
    int                         iCount;

    
    LOG((TL_TRACE, "SetCallHubTracking - enter"));

    Lock();
    
    if (!( m_dwFlags & TAPIFLAG_INITIALIZED ))
    {
        LOG((TL_ERROR, "SCHT - tapi object must be initialized first" ));

        Unlock();
        return E_INVALIDARG;
    }

    Unlock();
    
    hr = VerifyAndGetArrayBounds(
                                 pAddresses,
                                 &pAddressArray,
                                 &llBound,
                                 &luBound
                                );

    if (!SUCCEEDED(hr))
    {
        LOG((TL_ERROR, "SCHT - invalid address array - return %lx", hr));

        return hr;
    }

    //
    // all addresses
    //
    if (NULL == pAddressArray)
    {
        Lock();
        
        //
        // go through all the addresses
        //
        for (iCount = 0; iCount < m_AddressArray.GetSize(); iCount++ )
        {
            CAddress * pCAddress;
            
            //
            // register
            //
            pCAddress = dynamic_cast<CAddress *>(m_AddressArray[iCount]);
            
            if (NULL == pCAddress)
            {
                LOG((TL_ERROR, "SCHT - out of memory"));

                Unlock();
                return E_OUTOFMEMORY;
            }
            
            hr = (pCAddress)->SetCallHubTracking( bSet );

            if (!SUCCEEDED(hr))
            {
                LOG((TL_WARN,
                         "SCHT failed %lx on address %lx",
                         hr,
                         iCount
                        ));
                
            }
        }

        m_dwFlags |= TAPIFLAG_ALLCALLHUBTRACKING;
        
        Unlock();
        
        return S_OK;
    
    }


    //
    // if here, only registering addresses
    // from array
    
    //
    // go through array
    //
    for ( ; llBound <=luBound; llBound++ )
    {
        ITAddress * pAddress;
        CAddress *  pCAddress;

        
        hr = SafeArrayGetElement(
                                 pAddressArray,
                                 &llBound,
                                 &pAddress
                                );

        if ( (!SUCCEEDED(hr)) || (NULL == pAddress) )
        {
            continue;
        }

        pCAddress = dynamic_cast<CAddress *>(pAddress);
        
        hr = pCAddress->SetCallHubTracking( bSet );

        //
        // safearragetelement addrefs
        //
        pAddress->Release();

        if (!SUCCEEDED(hr))
        {
            LOG(( 
                     TL_WARN,
                     "SCHT failed %lx on address %p",
                     hr,
                     pAddress
                    ));

            return hr;
        }

    }

    LOG((TL_TRACE, "SetCallHubTracking - exit - success"));
    
    return S_OK;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CTAPI::RegisterCallNotifications
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT
STDMETHODCALLTYPE
CTAPI::RegisterCallNotifications( 
                                 ITAddress * pAddress,
                                 VARIANT_BOOL fMonitor,
                                 VARIANT_BOOL fOwner,
                                 long lMediaTypes,
                                 long lCallbackInstance,
                                 long * plRegister
                                )
{
    HRESULT                     hr = S_OK;
    PVOID                       pRegister;
    DWORD                       dwMediaModes = 0, dwPrivs = 0;
    REGISTERITEM              * pRegisterItem;
    CAddress                  * pCAddress;
    
    LOG((TL_TRACE, "RegisterCallNotifications - enter"));

    Lock();
    if (!( m_dwFlags & TAPIFLAG_INITIALIZED ))
    {
        LOG((TL_ERROR, "RegisterCallNotifications - tapi object must be initialized first" ));

        Unlock();
        return E_INVALIDARG;
    }
    Unlock();

    if (TAPIIsBadWritePtr( plRegister, sizeof(long) ) )
    {
        LOG((TL_ERROR, "RegisterCallNotifications - invalid plRegister"));

        return E_POINTER;
    }

    try
    {
        pCAddress = dynamic_cast<CAddress *>(pAddress);
    }
    catch(...)
    {
        hr = E_POINTER;
    }

    if ( ( NULL == pCAddress ) || !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "RegisterCallNotifications - bad address"));

        return E_POINTER;
    }
    
    //
    // determine the privileges
    //
    if (fOwner)
    {
        dwPrivs |= LINECALLPRIVILEGE_OWNER;
    }
    if (fMonitor)
    {
        dwPrivs |= LINECALLPRIVILEGE_MONITOR;
    }

    if ( 0 == dwPrivs )
    {
        LOG((TL_ERROR, "RegisterCallNotifications - fMonitor and/or fOwner must be true"));
        return E_INVALIDARG;
    }

    if (! (pCAddress->GetMediaMode(
                                   lMediaTypes,
                                   &dwMediaModes
                                  ) ) )
    {
        LOG((TL_ERROR, "RegisterCallNotifications - bad mediamodes"));
        return E_INVALIDARG;
    }
    
    Lock();

    pRegisterItem = (REGISTERITEM *)ClientAlloc( sizeof(REGISTERITEM) );
    
    if ( NULL == pRegisterItem )
    {
        LOG((TL_ERROR, "RegisterCallNotifications - Alloc registrationarray failed"));

        Unlock();

        return E_OUTOFMEMORY;
    }

    hr = pCAddress->AddCallNotification(
                                        dwPrivs,
                                        dwMediaModes,
                                        lCallbackInstance,
                                        &pRegister
                                       );

    if (!SUCCEEDED(hr))
    {
        LOG((TL_ERROR, "RegisterCallNotifications - AddCallNotification failed"));

        ClientFree( pRegisterItem );

        Unlock();

        return hr;
    }

    pRegisterItem->dwType = RA_ADDRESS;
    pRegisterItem->pInterface = (PVOID)pCAddress;
    pRegisterItem->pRegister = pRegister;

    try
    {
        m_RegisterItemPtrList.push_back( (PVOID)pRegisterItem );
    }
    catch(...)
    {
        hr = E_OUTOFMEMORY;
        LOG((TL_ERROR, "RegisterCallNotifications- failed - because of alloc failure"));
        ClientFree( pRegisterItem );
    }

    #if DBG
    if (m_dwEventFilterMask == 0)
    {
        LOG((TL_WARN, "RegisterCallNotifications - no Event Mask set !!!"));
    }
    #endif


    Unlock();
    
    //
    // return registration cookie 
    //

    if( S_OK == hr )
    {
        

        //
        // create a 32-bit handle for the RegisterItem pointer
        //

        DWORD dwCookie = CreateHandleTableEntry((ULONG_PTR)pRegisterItem);

        if (0 == dwCookie)
        {
            hr = E_OUTOFMEMORY;
            
            LOG((TL_ERROR, "RegisterCallNotifications - failed to create a handle for REGISTERITEM object %p", pRegisterItem));
        }
        else
        {
            LOG((TL_INFO, 
                "RegisterCallNotifications - Mapped handle %lx (to be returned as cookie) to REGISTERITEM object %p", 
                dwCookie, pRegisterItem ));
              
            // register the cookie with the address object, so address can remove it if 
            // the address is deallocated before the call to CTAPI::UnregisterNotifications

            pCAddress->RegisterNotificationCookie(dwCookie);
        
            *plRegister = dwCookie;
        }

    }


    LOG((TL_TRACE, "RegisterCallNotifications - return %lx", hr));

    return hr;
}


STDMETHODIMP
CTAPI::UnregisterNotifications(
                               long ulRegister
                              )
{
    DWORD           dwType;
    HRESULT         hr = S_OK;
    REGISTERITEM  * pRegisterItem =  NULL;

    LOG((TL_TRACE, "UnregisterNotifications - enter. Cookie %lx", ulRegister));

    Lock();
    if (!( m_dwFlags & TAPIFLAG_INITIALIZED ))
    {
        LOG((TL_ERROR, "UnregNot - tapi object must be initialized first" ));

        Unlock();
        return E_INVALIDARG;
    }


    //
    // convert cookie to registration object pointer
    //

    pRegisterItem = (REGISTERITEM*) GetHandleTableEntry(ulRegister);


    //
    // remove cookie from the table 
    //

    DeleteHandleTableEntry(ulRegister);

    
    Unlock();


    if ( NULL != pRegisterItem )
    {
        LOG((TL_INFO, "UnregisterNotifications - Matched cookie %lx to REGISTERITEM object %p", ulRegister, pRegisterItem ));


        if (IsBadReadPtr( pRegisterItem, sizeof(REGISTERITEM) ) )
        {
            LOG((TL_ERROR, "UnregNot - invalid pRegisterItem returned from the handle table search"));
    
            return E_POINTER;
        }
    }
    else
    {
        LOG((TL_WARN, "UnregisterNotifications - invalid lRegister"));

        return E_INVALIDARG;
    }
    


    dwType = pRegisterItem->dwType;

    //
    // switch on the type of notification
    //
    switch ( dwType )
    {
        case RA_ADDRESS:

            CAddress *  pCAddress;
            ITAddress * pAddress;
            
            pCAddress = (CAddress *) (pRegisterItem->pInterface);

            //
            // try to get the address
            //
            try
            {
                hr = pCAddress->QueryInterface(
                                               IID_ITAddress,
                                               (void **)&pAddress
                                              );
            }
            catch(...)
            {
                hr = E_POINTER;
            }

            if ( !SUCCEEDED(hr) )
            {
                LOG((TL_ERROR, "Invalid interface in unregisternotifications"));

                return hr;
            }

            //
            // tell the address
            //
            pCAddress->RemoveCallNotification( pRegisterItem->pRegister );

            //
            // tell the address to remove a cookie from its list
            //
            pCAddress->RemoveNotificationCookie(ulRegister);

            pAddress->Release();

            Lock();

            //
            // remove array from our list
            //
            m_RegisterItemPtrList.remove( pRegisterItem );

            Unlock();

            //
            // free structure
            //
            ClientFree( pRegisterItem );

            break;

        case RA_CALLHUB:

            break;
    }

    LOG((TL_TRACE, "UnregisterNotifications - exit - success"));
    
    return S_OK;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CTAPI::get_CallHubs(
             VARIANT * pVariant
            )
{
    LOG((TL_TRACE, "get_CallHubs enter"));
    LOG((TL_TRACE, "   pVariant ------->%p", pVariant));

    HRESULT         hr;
    IDispatch *     pDisp;

    Lock();
    if (!( m_dwFlags & TAPIFLAG_INITIALIZED ) )
    {
        LOG((TL_ERROR, "get_CallHubs - tapi object must be initialized first" ));
        
        Unlock();
        return E_INVALIDARG;
    }
    Unlock();

    if ( TAPIIsBadWritePtr( pVariant, sizeof(VARIANT) ) )
    {
        LOG((TL_ERROR, "get_CallHubs - bad pointer"));

        return E_POINTER;
    }
    
    CComObject< CTapiCollection< ITCallHub > > * p;
    CComObject< CTapiCollection< ITCallHub > >::CreateInstance( &p );
    
    if (NULL == p)
    {
        LOG((TL_ERROR, "get_CallHubs - could not create collection" ));
        
        return E_OUTOFMEMORY;
    }

    Lock();

    //
    // initialize
    //
    hr = p->Initialize( m_CallHubArray );

    Unlock();

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "get_CallHubs - could not initialize collection" ));
        
        delete p;
        return hr;
    }

    //
    // get the IDispatch interface
    //
    hr = p->_InternalQueryInterface( IID_IDispatch, (void **) &pDisp );

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "get_CallHubs - could not get IDispatch interface" ));
        
        delete p;
        return hr;
    }

    //
    // put it in the variant
    //
    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDisp;
    
    LOG((TL_TRACE, "get_CallHubss exit - return %lx", hr ));
    
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// EnumerateCallHubs
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CTAPI::EnumerateCallHubs(
                         IEnumCallHub ** ppEnumCallHub
                        )
{
    HRESULT         hr = S_OK;

    CComObject< CTapiEnum<IEnumCallHub, ITCallHub, &IID_IEnumCallHub> > * pEnum;

    LOG((TL_TRACE, "EnumerateCallHubs enter"));
    
    Lock();
    if (!( m_dwFlags & TAPIFLAG_INITIALIZED ))
    {
        LOG((TL_ERROR, "EnumerateCallHubs - tapi object must be initialized first" ));

        Unlock();
        return E_INVALIDARG;
    }
    Unlock();

    if ( TAPIIsBadWritePtr( ppEnumCallHub, sizeof( IEnumCallHub *) ) )
    {
        LOG((TL_ERROR, "EnumerateCallHubs - bad pointer"));

        return E_POINTER;
    }
    
    //
    // create the object
    //
    hr = CComObject< CTapiEnum<IEnumCallHub, ITCallHub, &IID_IEnumCallHub> >::CreateInstance( &pEnum );

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "EnumerateCallHubs - could not create enum - return %lx", hr));

        return hr;
    }

    //
    // initialize
    //
    Lock();
    hr = pEnum->Initialize( m_CallHubArray );
    Unlock();

    if (S_OK != hr)
    {
        pEnum->Release();
        
        LOG((TL_ERROR, "EnumerateCallHubs - could not initialize enum - return %lx", hr));

        return hr;
    }

    *ppEnumCallHub = pEnum;
    
    LOG((TL_TRACE, "EnumerateCallHubs exit - return %lx", hr));

	return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CTAPI::EnumConnectionPoints
//
// Standard IConnectionPoint method
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT 
__stdcall 
CTAPI::EnumConnectionPoints(
                     IEnumConnectionPoints **ppEnum
                     )
{
    HRESULT     hr;

    LOG((TL_TRACE, "EnumConnectionPoints enter"));

    hr = E_NOTIMPL;
    
    LOG((TL_TRACE, "EnumConnectionPointer exit - return %lx", hr));

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  FindConnectionPoint
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT 
__stdcall 
CTAPI::FindConnectionPoint(
                    REFIID riid, 
                    IConnectionPoint **ppCP
                    )
{
    LOG((TL_TRACE, "FindConnectionPoint enter"));

    #if DBG
    {
        WCHAR guidName[100];

        StringFromGUID2(riid, (LPOLESTR)&guidName, 100);
        LOG((TL_INFO, "FindConnectionPoint - RIID : %S", guidName));
    }
    #endif

    Lock();    
    
    if (!( m_dwFlags & TAPIFLAG_INITIALIZED ))
    {
        LOG((TL_ERROR, "FindConnectionPoint - tapi object must be initialized first" ));
        
        Unlock();
        return TAPI_E_NOT_INITIALIZED;
    }

    Unlock();

    if ( TAPIIsBadWritePtr( ppCP, sizeof(IConnectionPoint *) ) )
    {
        LOG((TL_ERROR, "FindConnectionPoint - bad pointer"));

        return E_POINTER;
    }


    //
    // is this the right interface?
    //
    if ( (IID_ITTAPIEventNotification != riid ) && (DIID_ITTAPIDispatchEventNotification != riid ) )
    {
        * ppCP = NULL;

        LOG((TL_ERROR, "FindConnectionPoint - do not support this riid"));
        
       return CONNECT_E_NOCONNECTION;
    }

    //
    // if it's the right interface, create a new connection point
    // and return it
    //
    Lock();

    *ppCP = m_pCP;
    (*ppCP)->AddRef();
        
    Unlock();
    
    //
    // success
    //
    LOG((TL_TRACE, "FindConnectionPoint - Success"));
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CreateAllAddressesOnAllLines
//      This is called when the first TAPI object is created.
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CTAPI::CreateAllAddressesOnAllLines(
                                    void
                                   )
{
    DWORD               dwCount;

    LOG((TL_TRACE, "CreateAllAddressesOnAllLines enter"));

    Lock();

    // go through all line devs
    for (dwCount = 0; dwCount < m_dwLineDevs; dwCount++)
    {
        CreateAddressesOnSingleLine( dwCount, FALSE );
    }

    Unlock();
    
    return S_OK;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CreateAddressesOnSingleLine
//
// assumed called in lock!
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CTAPI::CreateAddressesOnSingleLine( DWORD dwDeviceID, BOOL bFireEvent )
{
    DWORD               dwRealAddresses = 0, dwAddress;
    DWORD               dwAPIVersion;
    HRESULT             hr;
    LPLINEDEVCAPS       pDevCaps = NULL;
    LPLINEADDRESSCAPS   pAddressCaps = NULL;

    LOG((TL_TRACE, "CreateAddressesOnSingleLine: entered."));

    hr = LineNegotiateAPIVersion(
                                 (HLINEAPP)m_dwLineInitDataHandle,
                                 dwDeviceID,
                                 &dwAPIVersion
                                );

    if (S_OK != hr)
    {
        LOG((TL_WARN, "CreateAddressesOnSingleLine: LineNegotiateAPIVersion failed on device %d", dwDeviceID));

        return hr;
    }

    LOG((TL_INFO, "CreateAddressesOnSingleLine: LineNegotiateAPIVersion returned version %lx", dwAPIVersion));

    hr = LineGetDevCapsWithAlloc(
                                 (HLINEAPP)m_dwLineInitDataHandle,
                                 dwDeviceID,
                                 dwAPIVersion,
                                 &pDevCaps
                                );

    if (S_OK != hr)
    {
        LOG((TL_WARN, "CreateAddressesOnSingleLine: LineGetDevCaps failed for device %d", dwDeviceID));
        
        if ( NULL != pDevCaps )
        {
            ClientFree( pDevCaps );
        }

        return hr;
    }

    if (pDevCaps->dwNumAddresses == 0)
    {
        LOG((TL_WARN, "CreateAddressesOnSingleLine: Device %d has no addressess - will assume 1 address", dwDeviceID));

        pDevCaps->dwNumAddresses = 1;
    }

    LPVARSTRING         pVarString;
    DWORD               dwProviderID;


    //
    // get the permanent provider ID for this line.
    //
    hr = LineGetID(
                   NULL,
                   dwDeviceID,
                   NULL,
                   LINECALLSELECT_DEVICEID,
                   &pVarString,
                   L"tapi/providerid"
                  );

    if (S_OK != hr)
    {
        if (NULL != pVarString)
        {
            ClientFree( pVarString);
        }

        if ( NULL != pDevCaps )
        {
            ClientFree( pDevCaps );
        }

        LOG((TL_ERROR, "CreateAddressesOnSingleLine: get_ServiceProviderName - LineGetID returned %lx", hr ));

        return hr;
    }


    //
    // get the id DWORD at the end of the structure
    //
    dwProviderID = *((LPDWORD) (((LPBYTE) pVarString) + pVarString->dwStringOffset));

    ClientFree( pVarString );


    // go through all the addresses on each line, and
    // create an address object.
    for (dwAddress = 0; dwAddress < pDevCaps->dwNumAddresses; dwAddress++)
    {
        CComObject<CAddress> * pAddress;
        ITAddress            * pITAddress;

        try
        {

            hr = CComObject<CAddress>::CreateInstance( &pAddress );
        }
        catch(...)
        {
            LOG((TL_ERROR, "CreateAddressesOnSingleLine: CreateInstance - Address - threw"));

            continue;
        }
        
        if ( !SUCCEEDED(hr) || (NULL == pAddress) )
        {
            LOG((TL_ERROR, "CreateAddressesOnSingleLine: CreateInstance - Address - failed - %lx", hr));

            continue;
        }

        //
        // initialize the address
        // if there are no phone devices,
        // give NULL for the hPhoneApp, so the address
        // doesn't think that there may be a phone device
        //
        hr = pAddress->Initialize(
                                  this,
                                  (HLINEAPP)m_dwLineInitDataHandle,
#ifdef USE_PHONEMSP
                                  (m_dwPhoneDevs)?((HPHONEAPP)m_dwPhoneInitDataHandle):NULL,
#endif USE_PHONEMSP
                                  dwAPIVersion,
                                  dwDeviceID,
                                  dwAddress,
                                  dwProviderID,
                                  pDevCaps,
                                  m_dwEventFilterMask
                                 );

        if (S_OK != hr)
        {
            LOG((TL_ERROR, "CreateAddressesOnSingleLine: failed for device %d, address %d", dwDeviceID, dwAddress));

            delete pAddress;

            continue;
        }

        //
        // add to list
        //
        pITAddress = dynamic_cast<ITAddress *>(pAddress);
        
        m_AddressArray.Add( pITAddress );

        pAddress->Release();

        if ( bFireEvent )
        {
            CTapiObjectEvent::FireEvent(
                                        this,
                                        TE_ADDRESSCREATE,
                                        pAddress,
                                        0,
                                        NULL
                                       );
        }

    }

    if ( NULL != pDevCaps )
    {
        ClientFree( pDevCaps );
    }

    LOG((TL_INFO, "CreateAddressesOnSingleLine: completed."));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CreateAllPhones
//      This is called when the first TAPI object is created.
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CTAPI::CreateAllPhones(
                       void
                      )
{
    DWORD               dwCount;

    LOG((TL_TRACE, "CreateAllPhones enter"));

    Lock();

    // go through all phone devs
    for (dwCount = 0; dwCount < m_dwPhoneDevs; dwCount++)
    {
        CreatePhone( dwCount, FALSE );
    }

    Unlock();
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CreatePhone
//
// assumed called in lock!
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CTAPI::CreatePhone( DWORD dwDeviceID, BOOL bFireEvent )
{
    DWORD               dwAPIVersion;
    HRESULT             hr;

    hr = PhoneNegotiateAPIVersion(
                                 (HPHONEAPP)m_dwPhoneInitDataHandle,
                                 dwDeviceID,
                                 &dwAPIVersion
                                );

    if (S_OK != hr)
    {
        LOG((TL_WARN, "CreatePhone - phoneNegotiateAPIVersion failed on device %d", dwDeviceID));

        return hr;
    }

    LOG((TL_INFO, "CreatePhone - phoneNegotiateAPIVersion returned version %lx", dwAPIVersion));

    // create a phone object.

    CComObject<CPhone> * pPhone;
    ITPhone            * pITPhone;

    __try
    {
        hr = CComObject<CPhone>::CreateInstance( &pPhone );
    }
    __except( (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION) ?
            EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH )
    {
        LOG((TL_ERROR, "CreatePhone - CreateInstancefailed - because of alloc failure"));

        return hr;
    }
    
    if ( !SUCCEEDED(hr) || (NULL == pPhone) )
    {
        LOG((TL_ERROR, "CreatePhone - CreateInstance failed - %lx", hr));

        return hr;
    }

    //
    // initialize the phone
    //
    hr = pPhone->Initialize(
                              this,
                              (HLINEAPP)m_dwPhoneInitDataHandle,
                              dwAPIVersion,
                              dwDeviceID
                             );

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "CreatePhone failed for device %d", dwDeviceID));

        delete pPhone;

        return hr;
    }

    //
    // add to list
    //
    pITPhone = dynamic_cast<ITPhone *>(pPhone);
    
    m_PhoneArray.Add( pITPhone );

    pPhone->Release();

    if ( bFireEvent )
    {
        CTapiObjectEvent::FireEvent(this,
                                    TE_PHONECREATE,
                                    NULL,
                                    0,
                                    pITPhone
                                   );
    }

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// Shutdown
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
STDMETHODCALLTYPE
CTAPI::Shutdown()
{
    PtrList::iterator        iter, end;
    int                      iCount;
    DWORD                    dwSignalled;
    int                      tapiObjectArraySize=0;
    CTAPI                    *pTapi;

    LOG((TL_TRACE, "Shutdown[%p] - enter", this));
    LOG((TL_TRACE, "Shutdown - enter"));

    CoWaitForMultipleHandles (0,
                              INFINITE,
                              1,
                              &ghTapiInitShutdownSerializeMutex,
                              &dwSignalled
                             );

    Lock();
            
    if ( (!( m_dwFlags & TAPIFLAG_INITIALIZED )) &&
         (!( m_dwFlags & TAPIFLAG_REINIT)))
    {
        
        LOG((TL_WARN, "Shutdown - already shutdown - return S_FALSE"));
        
        Unlock();
        ReleaseMutex( ghTapiInitShutdownSerializeMutex );
        return S_FALSE;
    }

    m_dwFlags &= ~TAPIFLAG_INITIALIZED;
    m_dwFlags &= ~TAPIFLAG_REINIT;    
    pTapi = this;

    //
    // close all the phones
    //

    for(iCount = 0; iCount < m_PhoneArray.GetSize(); iCount++)
    {
        CPhone *pCPhone = NULL;

	    try
        {
            pCPhone = dynamic_cast<CPhone *>(m_PhoneArray[iCount]);
        }
        catch(...)
        {
            
            LOG((TL_ERROR, "Shutdown - phone array contains a bad phone pointer"));

            pCPhone = NULL;
        }

        if (NULL != pCPhone)
        {
            pCPhone->ForceClose();
        }
    }

    EnterCriticalSection( &gcsTapiObjectArray );
    
    m_sTAPIObjectArray.Remove ( pTapi );

    tapiObjectArraySize = m_sTAPIObjectArray.GetSize();
    
    LeaveCriticalSection ( &gcsTapiObjectArray );

    m_AgentHandlerArray.Shutdown();

    gpLineHashTable->Flush(this);
    gpCallHashTable->Flush(this);
    gpCallHubHashTable->Flush(this);
    gpPhoneHashTable->Flush(this);


    //
    // tell each address in the array that it is time to toss all
    // the cookies
    //

    int nAddressArraySize = m_AddressArray.GetSize();

    for (int i = 0; i < nAddressArraySize; i++)
    {

        //
        // we need a pointer to CAddress to unregister cookies
        //

        CAddress *pAddress = NULL; 

        
        //
        // in case address array contains a pointer to nonreadable memory, 
        // do dynamic cast inside try/catch
        //

        try
        {

            pAddress = dynamic_cast<CAddress*>(m_AddressArray[i]);
        }
        catch(...)
        {
            
            LOG((TL_ERROR, "Shutdown - address array contains a bad address pointer"));

            pAddress = NULL;
        }


        //
        // attempt to unregister address' notifications
        //

        if (NULL != pAddress)
        {

            //
            // unregister all notification cookies
            //

            pAddress->UnregisterAllCookies();


            //
            // notify address that tapi is being shutdown, so it can do 
            // whatever clean up is necessary
            //

            pAddress->AddressOnTapiShutdown();

        }
        else
        {
            //
            // we have an address that is not an address. debug!
            //

            LOG((TL_ERROR, 
                "Shutdown - address array contains a bad address pointer."));

            _ASSERTE(FALSE);
        }

    }

    m_AddressArray.Shutdown();



    m_PhoneArray.Shutdown();

    m_CallHubArray.Shutdown();
  
    Unlock();

    NewShutdown();

    Lock();
    if ( NULL != m_pCP )
    {
        m_pCP->Release();
        m_pCP = NULL;
    }

    
    iter = m_RegisterItemPtrList.begin();
    end  = m_RegisterItemPtrList.end();

    while (iter != end)
    {
        ClientFree( *iter );
        iter ++;
    }

    m_RegisterItemPtrList.clear();

    Unlock();

    if ( 0 == tapiObjectArraySize )
    {
    
        FinalTapiCleanup();

        EnterCriticalSection( &gcsGlobalInterfaceTable );

        ReleaseGIT();

        LeaveCriticalSection( &gcsGlobalInterfaceTable );

        
        //
        // no longer need handle table.
        //

        ShutdownAndDeallocateHandleTable();

    }

    ReleaseMutex( ghTapiInitShutdownSerializeMutex );

    LOG((TL_TRACE, "Shutdown - exit"));
        
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// finalrelease of tapi object
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CTAPI::FinalRelease()
{
    LOG((TL_TRACE, "FinalRelease - enter"));

    Lock();

    FreeAllCaches();

    Unlock();
    
    LOG((TL_TRACE, "FinalRelease - exit"));
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// VerifyAndGetArrayBounds
//
// Helper function for variant/safearrays
//
// Array
//      IN Variant that contains a safearray
//
// ppsa
//      OUT safearray returned here
//
// pllBound
//      OUT array lower bound returned here
//
// pluBound
//      OUT array upper boudn returned here
//
// RETURNS
//
// verifies that Array contains an array, and returns the array, upper
// and lower bounds.
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
VerifyAndGetArrayBounds(
                        VARIANT Array,
                        SAFEARRAY ** ppsa,
                        long * pllBound,
                        long * pluBound
                       )
{
    UINT                uDims;
    HRESULT             hr = S_OK;

    
    //
    // see if the variant & safearray are valid
    //
    try
    {
        if (!(V_ISARRAY(&Array)))
        {
            if ( VT_NULL ==Array.vt )
            {
                //
                // null is usually valid
                //

                *ppsa = NULL;

                LOG((TL_INFO, "Returning NULL array"));

                return S_FALSE;
            }
            
            LOG((TL_ERROR, "Array - not an array"));

            return E_INVALIDARG;
        }

        if ( NULL == Array.parray )
        {
            //
            // null is usually valide
            //
            *ppsa = NULL;

            LOG((TL_INFO, "Returning NULL array"));
            
            return S_FALSE;
        }

        *ppsa = V_ARRAY(&Array);
        
        uDims = SafeArrayGetDim( *ppsa );
        
    }
    catch(...)
    {
        hr = E_POINTER;
    }


    if (!SUCCEEDED(hr))
    {
        LOG((TL_ERROR, "Array - invalid array"));

        return hr;
    }


    //
    // verify array
    //
    if (1 != uDims)
    {
        if (0 == uDims)
        {
            LOG((TL_ERROR, "Array - has 0 dim"));

            return E_INVALIDARG;
        }
        else
        {
            LOG((TL_WARN, "Array - has > 1 dim - will only use 1"));
        }
    }


    //
    // Get array bounds
    //
    SafeArrayGetUBound(
                       *ppsa,
                       1,
                       pluBound
                      );

    SafeArrayGetLBound(
                       *ppsa,
                       1,
                       pllBound
                      );

    return S_OK;
    
}

BOOL QueueCallbackEvent(CTAPI * pTapi, TAPI_EVENT te, IDispatch * pEvent);

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CTAPI::Event(
             TAPI_EVENT te,
             IDispatch * pEvent
            )
{
    HRESULT hr = S_OK;
    DWORD   dwEventFilterMask;

    LOG((TL_TRACE, "Event[%p] - enter. Event[0x%x]", this, te));

    
    Lock();
    dwEventFilterMask = m_dwEventFilterMask;
    Unlock();
    
    if( (te != TE_ADDRESS)          &&
        (te != TE_CALLHUB)          &&
        (te != TE_CALLINFOCHANGE)   &&
        (te != TE_CALLMEDIA)        &&
        (te != TE_CALLNOTIFICATION) &&
        (te != TE_CALLSTATE)        &&
        (te != TE_FILETERMINAL)     &&
        (te != TE_PRIVATE)          &&
        (te != TE_QOSEVENT)         &&
        (te != TE_TAPIOBJECT)       &&
        (te != TE_ADDRESSDEVSPECIFIC) &&
        (te != TE_PHONEDEVSPECIFIC) )
    {
        if( (te & dwEventFilterMask) == 0)
        {
            //
            // Don't fire the event
            //
            hr = S_FALSE;
            LOG((TL_INFO, "Event - This Event not Enabled %x", te));
            return hr;
        }
    }

    //
    // It's an event from the event filtering mechanism
    // TE_ADDRESS, TE_CALLHUB, TE_CALLINFOCHANGE, TE_CALLMEDIA,
    // TE_CALLNOTIFICATION, TE_CALLSTATE, TE_FILETERMINAL,
    // TE_PRIVATE, TE_QOSEVENT, TE_TAPIOBJECT
    //

    AddRef();
    pEvent->AddRef();

    if(QueueCallbackEvent(this, te, pEvent) == TRUE)
    {
        LOG((TL_INFO, "Event queued"));
    }
    else
    {
        Release();
        pEvent->Release();
        LOG((TL_INFO, "Event queuing Failed"));
    }

    LOG((TL_TRACE, "Event - exit"));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CTAPI::EventFire(
             TAPI_EVENT te,
             IDispatch * pEvent
            )
{

    ITTAPIEventNotification * pCallback = NULL;
    IDispatch               * pDispatch = NULL;
    HRESULT hr = S_OK;
    CTAPIConnectionPoint     * pCP;

    LOG((TL_TRACE, "EventFire - enter"));

    Lock();
    
    if( NULL != m_pCP )
    {
        m_pCP->AddRef();
    }

    pCP = m_pCP;    

    Unlock();

    if ( NULL != pCP )
    {
        pDispatch = (IDispatch *)pCP->GrabEventCallback();

        if ( NULL != pDispatch )
        {
            hr = pDispatch->QueryInterface(IID_ITTAPIEventNotification,
                                   (void **)&pCallback
                                  );

            if (SUCCEEDED(hr) )
            {
                if ( NULL != pCallback )
                {
                    LOG((TL_TRACE, "EventFire - fire on ITTAPIEventNotification"));
                    pCallback->Event( te, pEvent );
                    pCallback->Release(); 
                }
                #if DBG
                else
                {
                    LOG((TL_WARN, "EventFire - can't fire event on ITTAPIEventNotification - no callback"));
                }
                #endif
            }
            else
            {

                CComVariant varResult;
                CComVariant* pvars = new CComVariant[2];
                
                LOG((TL_TRACE, "EventFire - fire on IDispatch"));
            
                VariantClear(&varResult);
                pvars[1] = te;
                pvars[0] = pEvent;
                DISPPARAMS disp = { pvars, NULL, 2, 0 };
                pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
                delete[] pvars;
                
                hr = varResult.scode;
        
            }
            
            pDispatch->Release();
        }    
        #if DBG
        else
        {
            LOG((TL_WARN, "Event - can't fire event on IDispatch - no callback"));
        }
        #endif
    }
    #if DBG
    else
    {
        LOG((TL_WARN, "Event - can't fire event - no m_pCP"));
    }
    #endif

    if(NULL != pCP)
    {
        pCP->Release();
    }

    pEvent->Release();

    LOG((TL_TRACE, "EventFire - exit"));

    return S_OK;

}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddCallHub
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CTAPI::AddCallHub( CCallHub * pCallHub )
{
    ITCallHub           * pITCallHub;
    
    Lock();

    pITCallHub = dynamic_cast<ITCallHub *>(pCallHub);
    
    m_CallHubArray.Add( pITCallHub );

    Unlock();
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// RemoveCallHub
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CTAPI::RemoveCallHub( CCallHub * pCallHub )
{
    ITCallHub           * pITCallHub;
    
    Lock();

    pITCallHub = dynamic_cast<ITCallHub *>(pCallHub);
    
    m_CallHubArray.Remove( pITCallHub );

    Unlock();
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CTAPI::get_PrivateTAPIObjects(VARIANT*)
{
    LOG((TL_TRACE, "get_PrivateTAPIObjects - enter"));
    
    LOG((TL_ERROR, "get_PrivateTAPIObjects - exit E_NOTIMPL"));
    
    return E_NOTIMPL;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// former EnumeratePrivateTAPIObjects
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CTAPI::EnumeratePrivateTAPIObjects(IEnumUnknown**)
{
    LOG((TL_TRACE, "EnumeratePrivateTAPIObjects - enter"));

    LOG((TL_ERROR, "EnumeratePrivateTAPIObjects - return E_NOTIMPL"));
    
    return E_NOTIMPL;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// RegisterRequestRecipient
//
// simply call LineRegisterRequestRecipient - registers as assisted
// telephony application
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CTAPI::RegisterRequestRecipient(
                                long lRegistrationInstance,
                                long lRequestMode,
#ifdef NEWREQUEST
                                long lAddressTypes,
#endif
                                VARIANT_BOOL fEnable
                               )
{
    HRESULT             hr;
    
    LOG((TL_TRACE, "RegisterRequestRecipient - enter"));

    Lock();

    if (!( m_dwFlags & TAPIFLAG_INITIALIZED ))
    {
        LOG((TL_ERROR, "RegisterRequestRecipient - tapi object must be initialized first" ));
        
        Unlock();
        return E_INVALIDARG;
    }

    Unlock();

    hr = LineRegisterRequestRecipient(
                                      (HLINEAPP)m_dwLineInitDataHandle,
                                      lRegistrationInstance,
                                      lRequestMode,
#ifdef NEWREQUEST
                                      lAddressTypes,
#endif
                                      fEnable?TRUE : FALSE
                                     );

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// SetAssistedTelephonyPriority
//
// set the app priority for assisted telephony
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CTAPI::SetAssistedTelephonyPriority(
                                    BSTR pAppFilename,
                                    VARIANT_BOOL fPriority
                                   )
{
    HRESULT             hr;

    LOG((TL_TRACE, "SetAssistedTelephonyPriority - enter"));
    
    hr = LineSetAppPriority(
                            pAppFilename,
                            0,
                            LINEREQUESTMODE_MAKECALL,
                            fPriority?1:0
                           );

    LOG((TL_TRACE, "SetAssistedTelephonyPriority - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// SetApplicationPriority
//
// sets the app priority for incoming calls and handoff.
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CTAPI::SetApplicationPriority(
                              BSTR pAppFilename,
                              long lMediaType,
                              VARIANT_BOOL fPriority
                             )
{
    HRESULT             hr;

    LOG((TL_TRACE, "SetApplicationPriority - enter"));
            
    hr = LineSetAppPriority(
                            pAppFilename,
                            lMediaType,
                            0,
                            fPriority?1:0
                           );

    LOG((TL_TRACE, "SetApplicationPriority - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// put_EventFilter
//
// sets the Event filter mask
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP 
CTAPI::put_EventFilter(long lFilterMask)
{
    HRESULT     hr = S_OK;
    DWORD       dwOldFilterMask;
    ULONG64     ulEventMasks;
    DWORD       dwLineDevStateSubMasks;
    DWORD       dwAddrStateSubMasks;


    LOG((TL_TRACE, "put_EventFilter - enter"));

    if (~ALL_EVENT_FILTER_MASK & lFilterMask)
    {
        LOG((TL_ERROR, "put_EventFilter - Unknown Event type in mask %x", lFilterMask ));
        hr = E_INVALIDARG;
    }
    else
    {
        Lock();

        //
        // Event Filtering, we should pass the mask
        // to all addresses
        //

        HRESULT hr = E_FAIL;
        hr = SetEventFilterToAddresses( lFilterMask );
        if( FAILED(hr) )
        {
            Unlock();
            LOG((TL_ERROR, "put_EventFilter - exit"
                "CopyEventFilterMaskToAddresses failed. Returns 0x%08x", hr));
            return hr;
        }

        //
        // Set the event filter
        //
        dwOldFilterMask = m_dwEventFilterMask;
        m_dwEventFilterMask = lFilterMask;

        Unlock();

        // Convert lFilterMask to server side 64 bit masks
        // we alway should receive:
        // TE_CALLSTATE,
        // TE_CALLNOTIFICATION,
        // TE_PHONEEVENT
        // TE_CALLHUB
        // TE_CALLINFOCHANGE
        // TE_TAPIOBJECT
        // events because these events are used internally 
        // by Tapi3 objets

        ulEventMasks = EM_LINE_CALLSTATE    // TE_CALLSTATE
            | EM_LINE_APPNEWCALL            // TE_CALLNOTIFICATION
            | EM_PHONE_CLOSE                // TE_PHONEEVENT
            | EM_PHONE_STATE                // TE_PHONEEVENT
            | EM_PHONE_BUTTONMODE           // TE_PHONEEVENT
            | EM_PHONE_BUTTONSTATE          // TE_PHONEVENT
            | EM_LINE_APPNEWCALLHUB         // TE_CALLHUB
            | EM_LINE_CALLHUBCLOSE          // TE_CALLHUB
            | EM_LINE_CALLINFO              // TE_CALLINFOCHANGE
            | EM_LINE_CREATE                // TE_TAPIOBJECT
            | EM_LINE_REMOVE                // TE_TAPIOBJECT
            | EM_LINE_CLOSE                 // TE_TAPIOBJECT
            | EM_PHONE_CREATE               // TE_TAPIOBJECT
            | EM_PHONE_REMOVE               // TE_TAPIOBJECT
            ;

        dwLineDevStateSubMasks = LINEDEVSTATE_REINIT    // TE_TAPIOBJECT
            | LINEDEVSTATE_TRANSLATECHANGE; // TE_TAPIOBJECT

        dwAddrStateSubMasks = 0;

        if (lFilterMask & TE_ADDRESS)
        {
            // AE_STATE
            dwLineDevStateSubMasks |=
                LINEDEVSTATE_CONNECTED | 
                LINEDEVSTATE_INSERVICE |
                LINEDEVSTATE_OUTOFSERVICE |
                LINEDEVSTATE_MAINTENANCE |
                LINEDEVSTATE_REMOVED |
                LINEDEVSTATE_DISCONNECTED |
                LINEDEVSTATE_LOCK;

            // AE_MSGWAITON, AAE_MSGWAITOFF
            dwLineDevStateSubMasks |=
                LINEDEVSTATE_MSGWAITON |
                LINEDEVSTATE_MSGWAITOFF ;

            // AE_CAPSCHANGE
            dwAddrStateSubMasks |=
                LINEADDRESSSTATE_CAPSCHANGE;
            dwLineDevStateSubMasks |=
                LINEDEVSTATE_CAPSCHANGE; 

            dwLineDevStateSubMasks |=
                LINEDEVSTATE_RINGING |      // AE_RINGING
                LINEDEVSTATE_CONFIGCHANGE;  // AE_CONFIGCHANGE

            dwAddrStateSubMasks |=
                LINEADDRESSSTATE_FORWARD;   // AE_FORWARD

            // AE_NEWTERMINAL : ignore private MSP events
            // AE_REMOVETERMINAL : ignore private MSP events

        }
        if (lFilterMask & TE_CALLMEDIA)
        {
            //  Skil media event
        }
        if (lFilterMask & TE_PRIVATE)
        {
            //  skip MSP private event
        }
        if (lFilterMask & TE_REQUEST)
        {
            //  LINE_REQUEST is not masked by the server
        }
        if (lFilterMask & TE_AGENT)
        {
            ulEventMasks |= EM_LINE_AGENTSTATUSEX | EM_LINE_AGENTSTATUS;
        }
        if (lFilterMask & TE_AGENTSESSION)
        {
            ulEventMasks |= EM_LINE_AGENTSESSIONSTATUS;
        }
        if (lFilterMask & TE_QOSEVENT)
        {
            ulEventMasks |= EM_LINE_QOSINFO;
        }
        if (lFilterMask & TE_AGENTHANDLER)
        {
            //  TAPI 3 client side only?
        }
        if (lFilterMask & TE_ACDGROUP)
        {
            ulEventMasks |= EM_LINE_GROUPSTATUS;
        }
        if (lFilterMask & TE_QUEUE)
        {
            ulEventMasks |= EM_LINE_QUEUESTATUS;
        }
        if (lFilterMask & TE_DIGITEVENT)
        {
            //  LINE_MONITORDIGITS not controled by event filtering
        }
        if (lFilterMask & TE_GENERATEEVENT)
        {
            //  LINE_GENERATE not controled by event filtering
        }
        if (lFilterMask & TE_TONEEVENT)
        {
            //  LINE_MONITORTONE not controled by event filtering
        }
        if (lFilterMask & TE_GATHERDIGITS)
        {
            //  LINE_GATHERDIGITS not controled by event filtering
        }

        if (lFilterMask & TE_ADDRESSDEVSPECIFIC)
        {
            ulEventMasks |= EM_LINE_DEVSPECIFICEX | EM_LINE_DEVSPECIFIC;
        }

        if (lFilterMask & TE_PHONEDEVSPECIFIC)
        {
            ulEventMasks |= EM_PHONE_DEVSPECIFIC;
        }
        

        hr = tapiSetEventFilterMasks (
            TAPIOBJ_NULL,
            NULL,
            ulEventMasks
            );
        if (hr == 0)
        {
            hr = tapiSetEventFilterSubMasks (
                TAPIOBJ_NULL,
                NULL,
                EM_LINE_LINEDEVSTATE,
                dwLineDevStateSubMasks
                );
        }
        if (hr == 0)
        {
            hr = tapiSetEventFilterSubMasks (
                TAPIOBJ_NULL,
                NULL,
                EM_LINE_ADDRESSSTATE,
                dwAddrStateSubMasks
                );
        }

        if (hr != 0)
        {
            hr = mapTAPIErrorCode(hr);
        }
        
        LOG((TL_INFO, "put_EventFilter - mask changed %x to %x", dwOldFilterMask, lFilterMask ));

    }

    LOG((TL_TRACE,hr, "put_EventFilter - exit "));
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// get_EventFilter
//
// gets the Event filter mask
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP 
CTAPI::get_EventFilter(long * plFilterMask)
{
    HRESULT    hr = S_OK;


    LOG((TL_TRACE, "get_EventFilter - enter"));

    if ( TAPIIsBadWritePtr( plFilterMask, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_EventFilter - bad plFilterMask pointer"));
        hr = E_POINTER;
    }
    else
    {
        Lock();
        *plFilterMask = m_dwEventFilterMask;
        Unlock();
    }
    

    LOG((TL_TRACE, hr, "get_EventFilter - exit "));
    return hr;
  
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Interface : ITTAPI2
// Method    : get_Phones
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CTAPI::get_Phones(
                     VARIANT * pPhones
                     )
{
    HRESULT         hr;
    IDispatch     * pDisp;

    LOG((TL_TRACE, "get_Phones enter"));

    Lock();
    if (!( m_dwFlags & TAPIFLAG_INITIALIZED ) )
    {
        LOG((TL_ERROR, "get_Phones - tapi object must be initialized first" ));
        
        Unlock();    
        return TAPI_E_NOT_INITIALIZED;
    }
    Unlock();

    if ( TAPIIsBadWritePtr( pPhones, sizeof( VARIANT ) ) )
    {
        LOG((TL_ERROR, "get_Phones - bad pointer"));

        return E_POINTER;
    }

    CComObject< CTapiCollection< ITPhone > > * p;
    CComObject< CTapiCollection< ITPhone > >::CreateInstance( &p );

    if (NULL == p)
    {
        LOG((TL_ERROR, "get_Phones - could not create collection" ));

        return E_OUTOFMEMORY;
    }

    // get the IDispatch interface
    hr = p->_InternalQueryInterface( IID_IDispatch, (void **) &pDisp );

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "get_Phones - could not get IDispatch interface" ));
    
        delete p;
        return hr;
    }

    Lock();

    // initialize
    hr = p->Initialize( m_PhoneArray );

    Unlock();

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "get_Phones - could not initialize collection" ));
    
        pDisp->Release();
        return hr;
    }

    // put it in the variant

    VariantInit(pPhones);
    pPhones->vt = VT_DISPATCH;
    pPhones->pdispVal = pDisp;

    LOG((TL_TRACE, "get_Phones - exit - return %lx", hr ));
    
    return hr;
}
   
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Interface : ITTAPI2
// Method    : EnumeratePhones
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CTAPI::EnumeratePhones(
                          IEnumPhone ** ppEnumPhone
                          )
{
    HRESULT     hr;

    LOG((TL_TRACE, "EnumeratePhones - enter"));
    LOG((TL_TRACE, "   ppEnumPhone----->%p", ppEnumPhone ));

    Lock();
    if (!( m_dwFlags & TAPIFLAG_INITIALIZED ) )
    {
        LOG((TL_ERROR, "EnumeratePhones - tapi object must be initialized first" ));
        
        Unlock();    
        return TAPI_E_NOT_INITIALIZED;
    }
    Unlock();

    if ( TAPIIsBadWritePtr( ppEnumPhone, sizeof( IEnumPhone * ) ) )
    {
        LOG((TL_ERROR, "EnumeratePhones - bad pointer"));

        return E_POINTER;
    }

    //
    // create the enumerator
    //
    CComObject< CTapiEnum< IEnumPhone, ITPhone, &IID_IEnumPhone > > * p;
    hr = CComObject< CTapiEnum< IEnumPhone, ITPhone, &IID_IEnumPhone > >
         ::CreateInstance( &p );

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "EnumeratePhones - could not create enum" ));
    
        return hr;
    }

    Lock();

    // initialize it with our phone list, initialize adds a reference to p
    p->Initialize( m_PhoneArray );

    Unlock();

    //
    // return it
    //
    *ppEnumPhone = p;

    LOG((TL_TRACE, "EnumeratePhones - exit - return %lx", hr ));
    
    return hr;
} 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
// Interface : ITTAPI2
// Method    : CreateEmptyCollectionObject
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CTAPI::CreateEmptyCollectionObject(
                                   ITCollection2 ** ppCollection
                                  )
{
    HRESULT         hr;

    LOG((TL_TRACE, "CreateEmptyCollectionObject enter"));

    if ( TAPIIsBadWritePtr( ppCollection, sizeof( ITCollection2 * ) ) )
    {
        LOG((TL_ERROR, "CreateEmptyCollectionObject - bad pointer"));

        return E_POINTER;
    }

    // Initialize the return value in case we fail
    *ppCollection = NULL;

    CComObject< CTapiCollection< IDispatch > > * p;
    hr = CComObject< CTapiCollection< IDispatch > >::CreateInstance( &p );

    if ( S_OK != hr )
    {
        LOG((TL_ERROR, "CreateEmptyCollectionObject - could not create CTapiCollection" ));

        return E_OUTOFMEMORY;
    }

    // get the ITCollection2 interface
    hr = p->QueryInterface( IID_ITCollection2, (void **) ppCollection );

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "CreateEmptyCollectionObject - could not get ITCollection2 interface" ));
    
        delete p;
        return hr;
    }

    LOG((TL_TRACE, "CreateEmptyCollectionObject - exit - return %lx", hr ));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// DoLineCreate
//
// handles line_create message.  basically, creates a new
// address object
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CTAPI::DoLineCreate( DWORD dwDeviceID )
{
    HRESULT         hr;
    
    Lock();

    CreateAddressesOnSingleLine( dwDeviceID, TRUE );
    
    Unlock();
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// DoLineRemove( DWORD dwDeviceID )
//
// tapisrv has sent a LINE_REMOVE message.  find the corresponding
// address object(s), remove them from our list, and send a
// message to the app
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CTAPI::DoLineRemove( DWORD dwDeviceID )
{
    HRESULT                 hr;
    ITAddress             * pAddress;
    CAddress              * pCAddress;
    int                     iCount;
#if DBG
    BOOL                    bFound = FALSE;
#endif

    LOG((TL_TRACE, "DoLineRemove - enter - dwDeviceID %d", dwDeviceID));
    
    Lock();
    
    //
    // go through the addresses
    //
    for(iCount = 0; iCount < m_AddressArray.GetSize(); iCount++)
    {
        pAddress = m_AddressArray[iCount];

        pCAddress = dynamic_cast<CAddress *>(pAddress);

        if (pCAddress != NULL)
        {
            //
            // does the device ID match?
            //
            if ( dwDeviceID == pCAddress->GetDeviceID() )
            {
                LOG((TL_INFO, "DoLineRemove - found matching address - %p", pAddress));

                //
                // make sure the address is in the correct state
                //
                pCAddress->OutOfService(LINEDEVSTATE_REMOVED);
            
                //
                // fire event
                //
                CTapiObjectEvent::FireEvent(
                                            this,
                                            TE_ADDRESSREMOVE,
                                            pAddress,
                                            0,
                                            NULL
                                           );

                //
                // remove from our list
                //
                LOG((TL_INFO, "DoLineRemove - removing address %p", pAddress));
                m_AddressArray.RemoveAt(iCount);

                iCount--;
#if DBG
                bFound = TRUE;
#endif
            }
        }
    }

#if DBG
    if ( !bFound )
    {
        LOG((TL_WARN, "Receive LINE_REMOVE but couldn't find address object"));
    }
#endif
    
    LOG((TL_TRACE, "DoLineRemove - exiting"));
    Unlock();
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// DoPhoneCreate
//
// handles PHONE_CREATE message.  basically, creates a new
// phone object
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CTAPI::DoPhoneCreate( DWORD dwDeviceID )
{
    HRESULT         hr;
    
    Lock();

    CreatePhone( dwDeviceID, TRUE );
    
    Unlock();
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// DoPhoneRemove( DWORD dwDeviceID )
//
// tapisrv has sent a PHONE_REMOVE message.  find the corresponding
// phone object(s), remove them from our list, and send a
// message to the app
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CTAPI::DoPhoneRemove( DWORD dwDeviceID )
{
    HRESULT                 hr;
    ITPhone               * pPhone;
    CPhone                * pCPhone;
    int                     iPhoneCount;
    int                     iAddressCount;
#if DBG
    BOOL                    bFound;
#endif

    LOG((TL_TRACE, "DoPhoneRemove - enter - dwDeviceID %d", dwDeviceID));
    
    Lock();
    
    //
    // go through the phones
    //
    for(iPhoneCount = 0; iPhoneCount < m_PhoneArray.GetSize(); iPhoneCount++)
    {
        pPhone = m_PhoneArray[iPhoneCount];

        pCPhone = dynamic_cast<CPhone *>(pPhone);

        if (NULL == pCPhone)
        {
            //
            // something went terribly wrong
            //
            
            LOG((TL_ERROR, "DoPhoneRemove - failed to cast ptr %p to a phone object", pPhone));

            _ASSERTE(FALSE);

            continue;
        }

        //
        // does the device ID match?
        //
        if ( dwDeviceID == pCPhone->GetDeviceID() )
        {
            LOG((TL_INFO, "DoPhoneRemove - found matching phone - %p", pPhone));
            
            //
            // fire event
            //
            CTapiObjectEvent::FireEvent(this,
                                    TE_PHONEREMOVE,
                                    NULL,
                                    0,
                                    pPhone
                                   );

            //
            // remove from our list
            //
            LOG((TL_INFO, "DoPhoneRemove - removing phone %p", pPhone));
            m_PhoneArray.RemoveAt(iPhoneCount);

            iPhoneCount--;
#if DBG
            bFound = TRUE;
#endif
        }
    }

#if DBG
    if ( !bFound )
    {
        LOG((TL_WARN, "Receive PHONE_REMOVE but couldn't find phone object"));
    }
#endif
    
    LOG((TL_TRACE, "DoPhoneRemove - exiting"));
    Unlock();
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL
CTAPI::FindTapiObject( CTAPI * pTapi )
{
    PtrList::iterator           iter, end;
    BOOL bFound = FALSE;
    int iReturn = -1;
    
    EnterCriticalSection( &gcsTapiObjectArray );

    //
    // go through the list
    //
    iReturn = m_sTAPIObjectArray.Find( pTapi );

    if (iReturn != -1)
    {
        pTapi->AddRef();
        bFound = TRUE;
    }
    
    LeaveCriticalSection ( &gcsTapiObjectArray );

    return bFound;
}


////////////////////////////////////////////////////////////////////////////
//
//  GetTapiObjectFromAsyncEventMSG 
//
// this method attempts to get tapi object pointer from PASYNCEVENTMSG
//
// it returns NULL on failure or addref'ed tapi object on success
//
////////////////////////////////////////////////////////////////////////////

CTAPI *GetTapiObjectFromAsyncEventMSG(PASYNCEVENTMSG pParams)
{
    LOG((TL_TRACE, "GetTapiObjectFromAsyncEventMSG - entered"));    


    //
    // get pInitData from the structure we have
    //

    PT3INIT_DATA pInitData = (PT3INIT_DATA) GetHandleTableEntry(pParams->InitContext);

    if (IsBadReadPtr(pInitData, sizeof(T3INIT_DATA)))
    {
        LOG((TL_WARN, "GetTapiObjectFromAsyncEventMSG - could not recover pInitData"));
        return NULL;
    }

    
    //
    // get tapi object from pInitData
    //

    CTAPI *pTapi = pInitData->pTAPI;

    
    //
    // is it any good?
    //

    if (IsBadReadPtr(pTapi, sizeof(CTAPI)))
    {

        LOG((TL_WARN, 
            "GetTapiObjectFromAsyncEventMSG - tapi pointer [%p] does not point to readable memory",
            pTapi));

        return NULL;
    }


    //
    // double check that this is a known tapi object...
    //

    if (!CTAPI::FindTapiObject(pTapi))
    {
        
        //
        // the object is not in the list of tapi objects
        //

        LOG((TL_WARN,
            "GetTapiObjectFromAsyncEventMSG - CTAPI::FindTapiObject did not find the tapi object [%p]", 
            pTapi));

        return NULL;
    }


    LOG((TL_TRACE, "GetTapiObjectFromAsyncEventMSG - exit. pTapi %p", pTapi));

    return pTapi;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
HandleLineCreate( PASYNCEVENTMSG pParams )
{
    LOG((TL_TRACE,  "HandleLineCreate - enter"));

    
    //
    // get tapi object
    //

    CTAPI *pTapi = GetTapiObjectFromAsyncEventMSG(pParams);

    if (NULL == pTapi)
    {
        LOG((TL_WARN, 
            "HandleLineCreate - tapi object not present [%p]",
            pTapi));

        return;
    }


    //
    // we have tapi object, do what we have to do.
    //

    pTapi->DoLineCreate( pParams->Param1 );
    
    
    //
    // GetTapiObjectFromAsyncEventMSG returned a addref'ed tapi object. release
    //

    pTapi->Release();
    pTapi = NULL;

    LOG((TL_TRACE,  "HandleLineCreate - exit"));
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
HandleLineRemove( PASYNCEVENTMSG pParams )
{

    LOG((TL_TRACE, "HandleLineRemove - enter"));    

    
    //
    // get tapi object
    //

    CTAPI *pTapi = GetTapiObjectFromAsyncEventMSG(pParams);

    if (NULL == pTapi)
    {
        LOG((TL_WARN, 
            "HandleLineRemove - tapi object not present [%p]",
            pTapi));

        return;
    }


    //
    // we have tapi object, do what we have to do.
    //

    pTapi->DoLineRemove( pParams->Param1 );


    //
    // GetTapiObjectFromAsyncEventMSG returned a addref'ed tapi object. release
    //

    pTapi->Release();
    pTapi = NULL;

    LOG((TL_TRACE, "HandleLineRemove - exit"));    
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void 
HandlePhoneCreate( PASYNCEVENTMSG pParams )
{
    LOG((TL_TRACE, "HandlePhoneCreate - enter"));    

    
    //
    // get tapi object
    //

    CTAPI *pTapi = GetTapiObjectFromAsyncEventMSG(pParams);

    if (NULL == pTapi)
    {
        LOG((TL_WARN, 
            "HandlePhoneCreate - tapi object not present [%p]",
            pTapi));

        return;
    }


    //
    // we have tapi object, do what we have to do.
    //

    pTapi->DoPhoneCreate( pParams->Param1 );


    //
    // GetTapiObjectFromAsyncEventMSG returned a addref'ed tapi object. release
    //

    pTapi->Release();
    pTapi = NULL;

    LOG((TL_TRACE, "HandlePhoneCreate - exit"));    
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void 
HandlePhoneRemove( PASYNCEVENTMSG pParams )
{

    LOG((TL_TRACE, "HandlePhoneRemove - enter"));    

    
    //
    // get tapi object
    //

    CTAPI *pTapi = GetTapiObjectFromAsyncEventMSG(pParams);

    if (NULL == pTapi)
    {
        LOG((TL_WARN, 
            "HandlePhoneRemove - tapi object not present [%p]",
            pTapi));

        return;
    }


    //
    // we have tapi object, do what we have to do.
    //

    pTapi->DoPhoneRemove(pParams->Param1);


    //
    // GetTapiObjectFromAsyncEventMSG returned a addref'ed tapi object. release
    //

    pTapi->Release();
    pTapi = NULL;

    LOG((TL_TRACE, "HandlePhoneRemove - exit"));    

}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CTapiObjectEvent::FireEvent(
                            CTAPI * pTapi,
                            TAPIOBJECT_EVENT Event,
                            ITAddress * pAddress,
                            long lCallbackInstance,
                            ITPhone * pPhone
                           )
{
    HRESULT                           hr = S_OK;
    CComObject<CTapiObjectEvent>    * p;
    IDispatch                       * pDisp;

    //
    // Check the event filter mask
    // This event is not filtered by TapiSrv because is
    // related with TE_TAPIOBJECT, a specific TAPI3 event.
    //

    DWORD dwEventFilterMask = Event;
    long nTapiEventFilter = 0;
    pTapi->get_EventFilter( &nTapiEventFilter );

    STATICLOG((TL_INFO, "     TapiObjectEventMask ---> %ld", dwEventFilterMask ));

    if( !( nTapiEventFilter & TE_TAPIOBJECT))
    {
        STATICLOG((TL_WARN, "FireEvent - filtering out this event [%lx]", Event));
        return S_OK;
    }

    //
    // create event
    //
    hr = CComObject<CTapiObjectEvent>::CreateInstance( &p );

    if ( !SUCCEEDED(hr) )
    {
        STATICLOG((TL_ERROR, "Could not create TapiObjectEvent object - %lx", hr));
        return hr;
    }

    //
    // initialize
    //
    p->m_Event = Event;
    p->m_pTapi = dynamic_cast<ITTAPI *>(pTapi);
    p->m_pTapi->AddRef();
    p->m_pAddress = pAddress;
    p->m_lCallbackInstance = lCallbackInstance;
    p->m_pPhone = pPhone;

    if ( NULL != pAddress )
    {
        pAddress->AddRef();
    }

    if ( NULL != pPhone )
    {
        pPhone->AddRef();
    } 
    
#if DBG
    p->m_pDebug = (PWSTR) ClientAlloc( 1 );
#endif

    //
    // get idisp interface
    //
    hr = p->QueryInterface(
                           IID_IDispatch,
                           (void **)&pDisp
                          );

    if ( !SUCCEEDED(hr) )
    {
        STATICLOG((TL_ERROR, "Could not get disp interface of TapiObjectEvent object %lx", hr));
        
        delete p;
        
        return hr;
    }

    //
    // fire event
    //
    pTapi->Event(
                 TE_TAPIOBJECT,
                 pDisp
                );

    //
    // release stuff
    //
    pDisp->Release();
    
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void
CTapiObjectEvent::FinalRelease(void)
{
    m_pTapi->Release();

    if ( NULL != m_pAddress )
    {
        m_pAddress->Release();
    }

    if ( NULL != m_pPhone )
    {
        m_pPhone->Release();
    }

#if DBG

    ClientFree( m_pDebug );

#endif
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CTapiObjectEvent::get_TAPIObject( ITTAPI ** ppTapi )
{
    if ( TAPIIsBadWritePtr( ppTapi, sizeof( ITTAPI *) ) )
    {
        return E_POINTER;
    }

    *ppTapi = m_pTapi;
    (*ppTapi)->AddRef();

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CTapiObjectEvent::get_Event( TAPIOBJECT_EVENT * pEvent )
{
    if ( TAPIIsBadWritePtr( pEvent, sizeof( TAPIOBJECT_EVENT ) ) )
    {
        return E_POINTER;
    }

    *pEvent = m_Event;

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CTapiObjectEvent::get_Address( ITAddress ** ppAddress )
{
    if ( TAPIIsBadWritePtr( ppAddress, sizeof( ITAddress *) ) )
    {
        return E_POINTER;
    }

    if ((m_Event != TE_ADDRESSCREATE) && (m_Event != TE_ADDRESSREMOVE) &&
        (m_Event != TE_ADDRESSCLOSE))
    {
        return TAPI_E_WRONGEVENT;
    }

    *ppAddress = m_pAddress;

    if ( NULL != m_pAddress )
    {
        m_pAddress->AddRef();
    }

    return S_OK;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CTapiObjectEvent::get_CallbackInstance( long * plCallbackInstance )
{
    if ( TAPIIsBadWritePtr( plCallbackInstance, sizeof( long ) ) )
    {
        return E_POINTER;
    }

    *plCallbackInstance = m_lCallbackInstance;

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Phone
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CTapiObjectEvent::get_Phone(
                            ITPhone ** ppPhone
                           )
{
    if ( TAPIIsBadWritePtr( ppPhone , sizeof(ITPhone *) ) )
    {
        return E_POINTER;
    }

    if ((m_Event != TE_PHONECREATE) && (m_Event != TE_PHONEREMOVE))
    {
        return TAPI_E_WRONGEVENT;
    }

    *ppPhone = m_pPhone;

    if ( NULL != m_pPhone )
    {
        m_pPhone->AddRef();
    }
       
    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// HandleReinit
//
// we got a reinit message, so go through all the tapi objects, and
// fire the event
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void
CTAPI::HandleReinit()
{

    LOG((TL_TRACE, "HandleReinit - enter"));
    
    //
    // Fire the event
    //
    CTapiObjectEvent::FireEvent(
								this,
                                TE_REINIT,
                                NULL,
                                0,
                                NULL
                               );

    Lock();

    m_dwFlags |= TAPIFLAG_REINIT;
    
    Unlock();

}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CTAPI::GetBuffer(
                 DWORD dwType,
                 UINT_PTR pObject,
                 LPVOID * ppBuffer
                )
{
    switch (dwType)
    {
        case BUFFERTYPE_ADDRCAP:
            return m_pAddressCapCache->GetBuffer(
                pObject,
                ppBuffer
                );
            break;

        case BUFFERTYPE_LINEDEVCAP:
            return m_pLineCapCache->GetBuffer(
                pObject,
                ppBuffer
                );
            break;

        case BUFFERTYPE_PHONECAP:
            return m_pPhoneCapCache->GetBuffer(
                pObject,
                ppBuffer
                );
            break;

        default:
            return E_FAIL;
    }

    return E_UNEXPECTED;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CTAPI::SetBuffer(
                 DWORD dwType,
                 UINT_PTR pObject,
                 LPVOID pBuffer
                )
{
    switch (dwType)
    {
        case BUFFERTYPE_ADDRCAP:
            return m_pAddressCapCache->SetBuffer(
                pObject,
                pBuffer
                );
            break;

        case BUFFERTYPE_LINEDEVCAP:
            return m_pLineCapCache->SetBuffer(
                pObject,
                pBuffer
                );
            break;

        case BUFFERTYPE_PHONECAP:
            return m_pPhoneCapCache->SetBuffer(
                pObject,
                pBuffer
                );
            break;

        default:
            return E_FAIL;
    }

    return E_UNEXPECTED;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CTAPI::InvalidateBuffer(
                 DWORD dwType,
                 UINT_PTR pObject
                )
{
    switch (dwType)
    {
        case BUFFERTYPE_ADDRCAP:
            return m_pAddressCapCache->InvalidateBuffer(
                pObject
                );
            break;

        case BUFFERTYPE_LINEDEVCAP:
            return m_pLineCapCache->InvalidateBuffer(
                pObject
                );
            break;

        case BUFFERTYPE_PHONECAP:
            return m_pPhoneCapCache->InvalidateBuffer(
                pObject
                );
            break;

        default:
            return E_FAIL;
    }

    return E_UNEXPECTED;
}

BOOL
CTAPI::FindRegistration( PVOID pRegistration )
{
    PtrList::iterator           iter, end;

    
    Lock();

    iter = m_RegisterItemPtrList.begin();
    end  = m_RegisterItemPtrList.end();

    for ( ; iter != end; iter++ )
    {
        REGISTERITEM            * pItem;

        pItem = (REGISTERITEM *)(*iter);
        
        if ( pRegistration == pItem->pRegister )
        {
            Unlock();

            return TRUE;
        }
    }
    
    Unlock();

    return FALSE;
}




/////////////////////////////////////////////////////////////////////////////
// IDispatch implementation
//
typedef IDispatchImpl<ITapi2Vtbl<CTAPI>, &IID_ITTAPI2, &LIBID_TAPI3Lib> TapiType;
typedef IDispatchImpl<ICallCenterVtbl<CTAPI>, &IID_ITTAPICallCenter, &LIBID_TAPI3Lib> CallCenterType;


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CTAPI::GetIDsOfNames
//
// Overide if IDispatch method
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP CTAPI::GetIDsOfNames(REFIID riid, 
                                  LPOLESTR* rgszNames, 
                                  UINT cNames, 
                                  LCID lcid, 
                                  DISPID* rgdispid
                                 ) 
{ 
   HRESULT hr = DISP_E_UNKNOWNNAME;


    // See if the requsted method belongs to the default interface
    hr = TapiType::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((TL_INFO, "GetIDsOfNames - found %S on ITTAPI", *rgszNames));
        rgdispid[0] |= IDISPTAPI;
        return hr;
    }


    // If not, then try the Call Center interface
    hr = CallCenterType::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((TL_TRACE, "GetIDsOfNames - found %S on ITTAPICallCenter", *rgszNames));

        Lock();
        if (!( m_dwFlags & TAPIFLAG_CALLCENTER_INITIALIZED ) )
        {
            LOG((TL_INFO, "GetIDsOfNames - Call Center not initialized" ));
            UpdateAgentHandlerArray();
            m_dwFlags |= TAPIFLAG_CALLCENTER_INITIALIZED;

            LOG((TL_INFO, "GetIDsOfNames - Call Center initialized" ));
        }

        Unlock();
        rgdispid[0] |= IDISPTAPICALLCENTER;
        return hr;
    }


    LOG((TL_INFO, "GetIDsOfNames - Didn't find %S on our iterfaces", *rgszNames));
    return hr; 
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CTAPI::Invoke
//
// Overide if IDispatch method
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP CTAPI::Invoke(DISPID dispidMember, 
                           REFIID riid, 
                           LCID lcid, 
                           WORD wFlags, 
                           DISPPARAMS* pdispparams, 
                           VARIANT* pvarResult, 
                           EXCEPINFO* pexcepinfo, 
                           UINT* puArgErr
                          )
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    DWORD   dwInterface = (dispidMember & INTERFACEMASK);
    
    
    LOG((TL_TRACE, "Invoke - dispidMember %X", dispidMember));

    // Call invoke for the required interface
    switch (dwInterface)
    {
    case IDISPTAPI:
    {
        hr = TapiType::Invoke(dispidMember, 
                              riid, 
                              lcid, 
                              wFlags, 
                              pdispparams,
                              pvarResult, 
                              pexcepinfo, 
                              puArgErr
                             );
        break;
    }
    case IDISPTAPICALLCENTER:
    {
        hr = CallCenterType::Invoke(dispidMember, 
                                    riid, 
                                    lcid, 
                                    wFlags, 
                                    pdispparams,
                                    pvarResult, 
                                    pexcepinfo, 
                                    puArgErr
                                   );
        break;
    }

    } // end switch (dwInterface)
    

    LOG((TL_TRACE, hr, "Invoke - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CTAPI::SetEventFilterToAddresses
//
// Copy the event filter down to all addresses
// It's called by put_EventFilter() method
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT CTAPI::SetEventFilterToAddresses(
    DWORD dwEventFilterMask
    )
{
    LOG((TL_TRACE, "CopyEventFilterMaskToAddresses enter"));

    CAddress* pAddress = NULL;
    HRESULT hr = S_OK;

    //
    // Enumerate the addresses
    //
    for ( int iAddress = 0; iAddress < m_AddressArray.GetSize(); iAddress++ )
    {
        pAddress = dynamic_cast<CAddress *>(m_AddressArray[iAddress]);

        if( pAddress != NULL )
        {
            hr = pAddress->SetEventFilterMask( 
                dwEventFilterMask
                );

            if( FAILED(hr) )
            {
                break;
            }
        }
    }         

    LOG((TL_TRACE, "CopyEventFilterMaskToAddresses exit 0x%08x", hr));
    return hr;
}



///////////////////////////////////////////////////////////////////////////////
//
// CTAPI::IsValidTapiObject
//
// a helper static function that checks if it was passed a valid tapi object
//
// if the object is valid, the function addrefs it and returns TRUE
// if the object is not valid, the function returns true
//
// static 
BOOL CTAPI::IsValidTapiObject(CTAPI *pTapiObject)
{

    STATICLOG((TL_TRACE, "CTAPI::IsValidTapiObject enter[%p]", pTapiObject));


    //
    // before we go into trouble of checking tapi object array see if the ptr 
    // is readable at all
    //

    if ( IsBadReadPtr(pTapiObject, sizeof(CTAPI) ) )
    {
        STATICLOG((TL_WARN, "CTAPI::IsValidTapiObject - object not readabe"));

        return FALSE;
    }


    //
    // see if this object is in the array of tapi objects
    //

    EnterCriticalSection( &gcsTapiObjectArray );
    
    if (-1 == m_sTAPIObjectArray.Find(pTapiObject) )
    {

        LeaveCriticalSection ( &gcsTapiObjectArray );

        STATICLOG((TL_WARN, "CTAPI::IsValidTapiObject - object not in the array"));

        return FALSE;
    }


    //
    // the object is in the array, so it must be valid, addref it
    //

    try 
    {

        //
        // inside try, in case something else went bad
        //

        pTapiObject->AddRef();

    }
    catch(...)
    {


        //
        // the object is in the array, but we had problems addrefing. 
        // something's not kosher.
        //

        STATICLOG((TL_ERROR, 
            "CTAPI::IsValidTapiObject - object in in the array but addref threw"));

        LeaveCriticalSection ( &gcsTapiObjectArray );

        _ASSERTE(FALSE);

        return FALSE;
    }

    
    LeaveCriticalSection ( &gcsTapiObjectArray );

    STATICLOG((TL_TRACE, "CTAPI::IsValidTapiObject -- finish. the object is valid"));

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\tapiobj.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    tapiobj.h

Abstract:

    Declaration of the CTAPI class
    
Author:

    mquinton  06-12-97
    
Notes:

Revision History:

--*/

#ifndef __TAPIOBJ_H_
#define __TAPIOBJ_H_

#include "resource.h"       // main symbols
#include "address.h"
#include "connect.h"
#include "callcent.h"
#include "utils.h"
#include "shellapi.h"
#include "atlctl.h"
#include "TAPIObjectSafety.h"


#define TAPIFLAG_INITIALIZED                0x00000001
#define TAPIFLAG_CALLHUBNOTIFY              0x00000002
#define TAPIFLAG_ALLCALLHUBTRACKING         0x00000004
#define TAPIFLAG_ALLCALLNOTIFY              0x00000008
#define TAPIFLAG_REINIT                     0x00000010
#define TAPIFLAG_CALLCENTER_INITIALIZED     0x00000020

#define ALL_EVENT_FILTER_MASK              (TE_TAPIOBJECT         | \
                                            TE_ADDRESS            | \
                                            TE_CALLNOTIFICATION   | \
                                            TE_CALLSTATE          | \
                                            TE_CALLMEDIA          | \
                                            TE_CALLHUB            | \
                                            TE_CALLINFOCHANGE     | \
                                            TE_PRIVATE            | \
                                            TE_REQUEST            | \
                                            TE_AGENT              | \
                                            TE_AGENTSESSION       | \
                                            TE_QOSEVENT           | \
                                            TE_AGENTHANDLER       | \
                                            TE_ACDGROUP           | \
                                            TE_QUEUE              | \
                                            TE_DIGITEVENT         | \
                                            TE_GENERATEEVENT      | \
                                            TE_ASRTERMINAL        | \
                                            TE_TTSTERMINAL        | \
                                            TE_FILETERMINAL       | \
                                            TE_TONETERMINAL       | \
                                            TE_PHONEEVENT         | \
                                            TE_TONEEVENT          | \
                                            TE_GATHERDIGITS       | \
                                            TE_ADDRESSDEVSPECIFIC | \
                                            TE_PHONEDEVSPECIFIC )



class CCallHub;

HRESULT
WINAPI
MyCallCenterQI(void* pvClassObject, REFIID riid, LPVOID* ppv, DWORD_PTR dw);


/////////////////////////////////////////////////////////////////
// Intermediate classes  used for DISPID encoding
template <class T>
class /*ATL_NO_VTABLE*/ ITapi2Vtbl : public ITTAPI2
{
};

template <class T>
class /*ATL_NO_VTABLE*/ ICallCenterVtbl : public ITTAPICallCenter
{
};





/////////////////////////////////////////////////////////////////////////////
// CTAPI
class CTAPI : 
    public CTAPIComObjectRoot<CTAPI>,
	public CComCoClass<CTAPI, &CLSID_TAPI>,
	//public CComDualImpl<ITTAPI, &IID_ITTAPI, &LIBID_TAPI3Lib>,
    //public CComDualImpl<IConnectionPointContainer, &IID_IConnectionPointContainer, &LIBID_TAPI3Lib>,
    //public CComDualImpl<ITTAPICallCenter, &IID_ITTAPICallCenter, &LIBID_TAPI3Lib>,
    public IDispatchImpl<IConnectionPointContainer, &IID_IConnectionPointContainer, &LIBID_TAPI3Lib>,
	public IDispatchImpl<ITapi2Vtbl<CTAPI>, &IID_ITTAPI2, &LIBID_TAPI3Lib>,
	public IDispatchImpl<ICallCenterVtbl<CTAPI>, &IID_ITTAPICallCenter, &LIBID_TAPI3Lib>,
    public CTAPIObjectSafety,
    public IProvideClassInfo2Impl<&CLSID_TAPI, &DIID_ITTAPIDispatchEventNotification,&LIBID_TAPI3Lib> 

{
public:                                    

    CTAPI() :     m_hLineApp(NULL),
                  m_hPhoneApp(NULL),
                  m_pLineInitData(NULL),
                  m_pPhoneInitData(NULL),
                  m_dwLineInitDataHandle(0),
                  m_dwPhoneInitDataHandle(0),
                  m_dwLineDevs(0),
                  m_dwPhoneDevs(0),
                  m_dwFlags(0),
                  m_pCP(NULL),
                  m_pAddressCapCache(NULL),
                  m_pLineCapCache(NULL),
                  m_pPhoneCapCache(NULL),
                  m_dwEventFilterMask(0)
    {
        LOG((TL_TRACE, "CTAPI[%p] - enter", this));
        LOG((TL_TRACE, "CTAPI - finish"));
    }

    ~CTAPI()
    {
       LOG((TL_TRACE, "~CTAPI[%p] - enter", this));
       LOG((TL_TRACE, "~CTAPI - finish"));
    }

    void FinalRelease();
    
DECLARE_REGISTRY_RESOURCEID(IDR_TAPI)
DECLARE_QI()
DECLARE_MARSHALQI(CTAPI)
DECLARE_TRACELOG_CLASS(CTAPI)

BEGIN_COM_MAP(CTAPI)
	COM_INTERFACE_ENTRY2(IDispatch, ITTAPI2)
	COM_INTERFACE_ENTRY(ITTAPI)
    COM_INTERFACE_ENTRY(ITTAPI2)
    COM_INTERFACE_ENTRY(IConnectionPointContainer)
    COM_INTERFACE_ENTRY_FUNC(IID_ITTAPICallCenter, 0, MyCallCenterQI)
    COM_INTERFACE_ENTRY(ITTAPICallCenter)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
END_COM_MAP()

    static BOOL IsValidTapiObject(CTAPI *pTapiObject);

    static void FinalTapiCleanup();
    void AddCallHub( CCallHub * pCallHub );
    void RemoveCallHub( CCallHub * pCallHub );
    BOOL DoCallHubNotifications()
    {
        BOOL bReturn;
        
        Lock();

        bReturn = (m_dwFlags & TAPIFLAG_CALLHUBNOTIFY);

        Unlock();

        return bReturn;
    }

    HRESULT Event(
                  TAPI_EVENT te,
                  IDispatch * pEvent
                 );
    
    HRESULT EventFire(
                     TAPI_EVENT te,
                     IDispatch * pEvent
                     );

    HRESULT UpdateAgentHandlerArray(void);

    void DoLineCreate( DWORD dwDeviceID );
    void DoLineRemove( DWORD dwDeviceID );
    void DoPhoneCreate( DWORD dwDeviceID );
    void DoPhoneRemove( DWORD dwDeviceID );
    void HandleReinit();
    HLINEAPP GetHLineApp(){ return (HLINEAPP)m_dwLineInitDataHandle; }
    static FindTapiObject( CTAPI * pTapi );
    HRESULT GetBuffer( DWORD, UINT_PTR, LPVOID * );
    HRESULT SetBuffer( DWORD, UINT_PTR, LPVOID );
    HRESULT InvalidateBuffer( DWORD, UINT_PTR );
    BOOL FindRegistration( PVOID );

    HRESULT GetPhoneArray( 
                          PhoneArray *pPhoneArray
                         );   

private:

    DWORD                      m_dwPhoneDevs;
    DWORD                      m_dwLineDevs;
    HLINEAPP                   m_hLineApp;
    HPHONEAPP                  m_hPhoneApp;
    PT3INIT_DATA               m_pLineInitData;
    PT3INIT_DATA               m_pPhoneInitData;
    

    //
    // the 32-bit handles (corresponding m_pLineInitData and m_pPhoneInitData) 
    // that are marshaled to tapisrv in place of the actual ptr values 
    // (which can be 64 bit).
    //
    // we want to keep them around in order to be able 
    // to remove the handle table entries on tapi shutdown
    //

    DWORD                      m_dwLineInitDataHandle;
    DWORD                      m_dwPhoneInitDataHandle;


    AddressArray               m_AddressArray;
    PhoneArray                 m_PhoneArray;
    

    DWORD                      m_dwFlags;
    CTAPIConnectionPoint     * m_pCP;
    PtrList                    m_RegisterItemPtrList;
    CallHubArrayNR             m_CallHubArray;
    AgentHandlerArray          m_AgentHandlerArray;

    CStructCache             * m_pAddressCapCache;
    CStructCache             * m_pLineCapCache;
    CStructCache             * m_pPhoneCapCache;
    DWORD                      m_dwEventFilterMask;
    
    
    HRESULT NewInitialize(void);
    HRESULT NewShutdown(void);
    HRESULT CreateAllAddressesOnAllLines(void);
    HRESULT CreateAddressesOnSingleLine( DWORD dwDeviceID, BOOL bFireEvent );
    HRESULT CreateAllPhones(void);
    HRESULT CreatePhone( DWORD dwDeviceID, BOOL bFireEvent );

    void ReleaseGIT();
    

    //
    // allocate and cleanup functions for address, phone, and line caps caches
    //

    HRESULT AllocateInitializeAllCaches();
    void FreeAllCaches();

    
// ITAPI
public:

    static TAPIObjectArrayNR   m_sTAPIObjectArray;
    
    // ITTapi Methods
    STDMETHOD(Initialize)( void );
    STDMETHOD(Shutdown)( void );
         
    STDMETHOD(get_Addresses)(VARIANT * pVariant);
    
    STDMETHOD(EnumerateAddresses)( 
        IEnumAddress ** ppEnumAddresses
        );
        
    STDMETHOD(RegisterCallHubNotifications)( 
        VARIANT_BOOL bNotify
        );
        
    STDMETHOD(RegisterCallNotifications)( 
            ITAddress * pAddress,
            VARIANT_BOOL fMonitor,
            VARIANT_BOOL fOwner,
            long lMediaTypes,
            long ulAdvise,
            long * pulRegister
            );
    STDMETHOD(get_CallHubs)(VARIANT * pVariant);
    STDMETHOD(EnumerateCallHubs)(IEnumCallHub ** ppCallHub);
    STDMETHOD(UnregisterNotifications)(long ulRegister);
    STDMETHOD(SetCallHubTracking)(
                                  VARIANT pAddresses,
                                  VARIANT_BOOL bSet
                                 );
    STDMETHOD(EnumeratePrivateTAPIObjects)(IEnumUnknown**);
    STDMETHOD(get_PrivateTAPIObjects)(VARIANT * pVariant);
    STDMETHOD(RegisterRequestRecipient)(
            long lRegistrationInstance,
            long lRequestMode,
#ifdef NEWREQUEST
            long lAddressTypes,
#endif
            VARIANT_BOOL fEnable
            );
    STDMETHOD(SetAssistedTelephonyPriority)(
            BSTR pAppFilename,
            VARIANT_BOOL fPriority
            );
    STDMETHOD(SetApplicationPriority)(
            BSTR pAppFilename,
            long lMediaType,
            VARIANT_BOOL fPriority
            );

    STDMETHOD(put_EventFilter)( 
            long lFilterMask
            );
    STDMETHOD(get_EventFilter)( 
            long * plFilterMask
            );

    // ITTAPI2 methods
    STDMETHOD(get_Phones)(VARIANT * pPhones);
    STDMETHOD(EnumeratePhones)(IEnumPhone ** ppEnumPhone);

    STDMETHOD(CreateEmptyCollectionObject)(
                                           ITCollection2 ** ppCollection
                                          );

    // IConnectionPointContainer Methods
	STDMETHOD(EnumConnectionPoints)(IEnumConnectionPoints **ppEnum) ;
	STDMETHOD(FindConnectionPoint)(REFIID riid, IConnectionPoint **ppCP) ;

	// ITTAPICallCenter Methods
    STDMETHOD(EnumerateAgentHandlers) (IEnumAgentHandler ** ppEnumAgentHandler);
    STDMETHOD(get_AgentHandlers) (VARIANT  * pVariant);

    // IDispatch  Methods
    STDMETHOD(GetIDsOfNames)(REFIID riid, 
                             LPOLESTR* rgszNames,
                             UINT cNames, 
                             LCID lcid, 
                             DISPID* rgdispid
                            );
    STDMETHOD(Invoke)(DISPID dispidMember, 
                      REFIID riid, 
                      LCID lcid,
                      WORD wFlags, 
                      DISPPARAMS* pdispparams, 
                      VARIANT* pvarResult,
                      EXCEPINFO* pexcepinfo, 
                      UINT* puArgErr
                      );


private:
    //
    // Event Filtering helper methods
    //

    HRESULT SetEventFilterToAddresses(
        DWORD dwEventFilterMask);
};


class CTapiObjectEvent : 
    public CTAPIComObjectRoot<CTapiObjectEvent>,
    public CComDualImpl<ITTAPIObjectEvent2, &IID_ITTAPIObjectEvent2, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
public:
    
DECLARE_MARSHALQI(CTapiObjectEvent)
DECLARE_TRACELOG_CLASS(CTapiObjectEvent)

BEGIN_COM_MAP(CTapiObjectEvent)
    COM_INTERFACE_ENTRY2(IDispatch, ITTAPIObjectEvent2)
    COM_INTERFACE_ENTRY(ITTAPIObjectEvent)
    COM_INTERFACE_ENTRY(ITTAPIObjectEvent2)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

    static HRESULT FireEvent(
                             CTAPI * pTapi,
                             TAPIOBJECT_EVENT Event,
                             ITAddress * pAddress,
                             long lCallbackInstance,
                             ITPhone * pPhone
                            );
    void FinalRelease();
                      
protected:
    ITTAPI        * m_pTapi;
    TAPIOBJECT_EVENT m_Event;
    ITAddress     * m_pAddress;
    long            m_lCallbackInstance;
    ITPhone       * m_pPhone;
    
#if DBG
    PWSTR           m_pDebug;
#endif

    
public:
    //
    // itaddressstateevent
    //
    STDMETHOD(get_TAPIObject)( ITTAPI ** ppTapi );
    STDMETHOD(get_Event)( TAPIOBJECT_EVENT * pEvent );
    STDMETHOD(get_Address)( ITAddress ** ppAddress );
    STDMETHOD(get_CallbackInstance)( long * plCallbackInstance );  
    
    //
    // itaddressstateevent2
    //
    STDMETHOD(get_Phone)( ITPhone ** ppPhone );
};


#endif //__TAPIOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\termevnt.h ===
/*

Copyright (c) 2000  Microsoft Corporation

Module Name:

    termevnt.cpp

Abstract:

    This module contains declarations for terminal event classes


*/



#ifndef _TERMEVNT_DOT_H_
#define _TERMEVNT_DOT_H_


//
// ASR Terminal Event class
//

class CASRTerminalEvent :
    public CTAPIComObjectRoot<CASRTerminalEvent>,
    public CComDualImpl<ITASRTerminalEvent, &IID_ITASRTerminalEvent, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{

public:

DECLARE_MARSHALQI(CASRTerminalEvent)
DECLARE_TRACELOG_CLASS(CASRTerminalEvent)

BEGIN_COM_MAP(CASRTerminalEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITASRTerminalEvent)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

    static HRESULT FireEvent(
                             CTAPI * pTapi,
                             ITCallInfo *pCall,
                             ITTerminal  * pTerminal,
                             HRESULT hr
                            );

    CASRTerminalEvent();
    virtual ~CASRTerminalEvent();


    //
    // ITASRTerminalEvent methods
    //

    virtual HRESULT STDMETHODCALLTYPE get_Terminal(
            OUT ITTerminal **ppTerminal
            );


    virtual HRESULT STDMETHODCALLTYPE get_Call(
            OUT ITCallInfo **ppCallInfo
            );
    
    virtual HRESULT STDMETHODCALLTYPE get_Error(
            OUT HRESULT *phrErrorCode
            );



    //
    // methods for setting data members
    //

    virtual HRESULT STDMETHODCALLTYPE put_Terminal(
            IN ITTerminal *pTerminal
            );

    virtual HRESULT STDMETHODCALLTYPE put_Call(
            IN ITCallInfo *pCallInfo
            );
    
    virtual HRESULT STDMETHODCALLTYPE put_ErrorCode(
            IN HRESULT hrErrorCode
            );


private:


    //
    // the call on which the event was generated
    //

    ITCallInfo *m_pCallInfo;


    //
    // the terminal that caused the event (or whose tracks cause the event)
    //

    ITTerminal *m_pTerminal;


    //
    // HRESULT of the last error
    //

    HRESULT m_hr;

};


//
// File Terminal Event class
//

class CFileTerminalEvent :
    public CTAPIComObjectRoot<CFileTerminalEvent, CComMultiThreadModelNoCS>,
	public CComDualImpl<ITFileTerminalEvent, &IID_ITFileTerminalEvent, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{

public:

DECLARE_MARSHALQI(CFileTerminalEvent)
DECLARE_TRACELOG_CLASS(CFileTerminalEvent)

BEGIN_COM_MAP(CFileTerminalEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITFileTerminalEvent)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

    static HRESULT FireEvent(
                             CAddress *pCAddress,
                             CTAPI * pTapi,
                             ITCallInfo *pCall,
                             TERMINAL_MEDIA_STATE tmsMediaState,
                             FT_STATE_EVENT_CAUSE ftecEventCause,
                             ITTerminal  * pTerminal,
                             ITFileTrack * pFileTrack,
                             HRESULT hr
                            );

    CFileTerminalEvent ();
    virtual ~CFileTerminalEvent();


    //
    // ITFileTerminalEvent methods
    //

    virtual HRESULT STDMETHODCALLTYPE get_Terminal(
            OUT ITTerminal **ppTerminal
            );

    virtual HRESULT STDMETHODCALLTYPE get_Track(
            OUT ITFileTrack **ppFileTrack
            );

    virtual HRESULT STDMETHODCALLTYPE get_Call(
            OUT ITCallInfo **ppCallInfo
            );
    
    virtual HRESULT STDMETHODCALLTYPE get_State(
            OUT TERMINAL_MEDIA_STATE *pMediaState
            );
    
    virtual HRESULT STDMETHODCALLTYPE get_Cause(
            OUT FT_STATE_EVENT_CAUSE *pCause
            );

    virtual HRESULT STDMETHODCALLTYPE get_Error(
            OUT HRESULT *phrErrorCode
            );



    //
    // methods for setting data members
    //

    virtual HRESULT STDMETHODCALLTYPE put_Terminal(
            IN ITTerminal *pTerminal
            );

    virtual HRESULT STDMETHODCALLTYPE put_Track(
            IN ITFileTrack *pFileTrack
            );

    virtual HRESULT STDMETHODCALLTYPE put_Call(
            IN ITCallInfo *pCallInfo
            );
    
    virtual HRESULT STDMETHODCALLTYPE put_State(
            IN TERMINAL_MEDIA_STATE tmsTerminalMediaState
            );
    
    virtual HRESULT STDMETHODCALLTYPE put_Cause(
            IN FT_STATE_EVENT_CAUSE Cause
            );

    virtual HRESULT STDMETHODCALLTYPE put_ErrorCode(
            IN HRESULT hrErrorCode
            );


private:
    

    //
    // the call on which the event was generated
    //

    ITCallInfo *m_pCallInfo;


    //
    // the state to which the terminal transitioned in the result of the action that caused the event
    //

    TERMINAL_MEDIA_STATE m_tmsTerminalState;


    //
    // the cause of the event 
    //

    FT_STATE_EVENT_CAUSE m_ftecEventCause;


    //
    // the controlling parent terminal that caused the event (or whose tracks cause the event)
    //

    ITTerminal *m_pParentFileTerminal;

    
    //
    // the track involved in the event
    //

    ITFileTrack *m_pFileTrack;


    //
    // HRESULT of the last error
    //

    HRESULT m_hr;

};


//
// Tone Terminal Event class
//

class CToneTerminalEvent :
    public CTAPIComObjectRoot<CToneTerminalEvent>,
    public CComDualImpl<ITToneTerminalEvent, &IID_ITToneTerminalEvent, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{

public:


DECLARE_MARSHALQI(CToneTerminalEvent)
DECLARE_TRACELOG_CLASS(CToneTerminalEvent)

BEGIN_COM_MAP(CToneTerminalEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITToneTerminalEvent)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

    static HRESULT FireEvent(
                             CTAPI * pTapi,
                             ITCallInfo *pCall,
                             ITTerminal  * pTerminal,
                             HRESULT hr
                            );

    CToneTerminalEvent();
    virtual ~CToneTerminalEvent();


    //
    // ITToneTerminalEvent methods
    //

    virtual HRESULT STDMETHODCALLTYPE get_Terminal(
            OUT ITTerminal **ppTerminal
            );


    virtual HRESULT STDMETHODCALLTYPE get_Call(
            OUT ITCallInfo **ppCallInfo
            );
    
    virtual HRESULT STDMETHODCALLTYPE get_Error(
            OUT HRESULT *phrErrorCode
            );



    //
    // methods for setting data members
    //

    virtual HRESULT STDMETHODCALLTYPE put_Terminal(
            IN ITTerminal *pTerminal
            );

    virtual HRESULT STDMETHODCALLTYPE put_Call(
            IN ITCallInfo *pCallInfo
            );
    
    virtual HRESULT STDMETHODCALLTYPE put_ErrorCode(
            IN HRESULT hrErrorCode
            );


private:


    //
    // the call on which the event was generated
    //

    ITCallInfo *m_pCallInfo;


    //
    // the terminal that caused the event (or whose tracks cause the event)
    //

    ITTerminal *m_pTerminal;


    //
    // HRESULT of the last error
    //

    HRESULT m_hr;

};


//
// text to speech terminal event class
//


class CTTSTerminalEvent :
    public CTAPIComObjectRoot<CTTSTerminalEvent>,
	public CComDualImpl<ITTTSTerminalEvent, &IID_ITTTSTerminalEvent, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{

public:

DECLARE_MARSHALQI(CTTSTerminalEvent)
DECLARE_TRACELOG_CLASS(CTTSTerminalEvent)

BEGIN_COM_MAP(CTTSTerminalEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITTTSTerminalEvent)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

    static HRESULT FireEvent(
                             CTAPI * pTapi,
                             ITCallInfo *pCall,
                             ITTerminal  * pTerminal,
                             HRESULT hr
                            );

    CTTSTerminalEvent();
    virtual ~CTTSTerminalEvent();


    //
    // ITTTSTerminalEvent methods
    //

    virtual HRESULT STDMETHODCALLTYPE get_Terminal(
            OUT ITTerminal **ppTerminal
            );


    virtual HRESULT STDMETHODCALLTYPE get_Call(
            OUT ITCallInfo **ppCallInfo
            );
    
    virtual HRESULT STDMETHODCALLTYPE get_Error(
            OUT HRESULT *phrErrorCode
            );



    //
    // methods for setting data members
    //

    virtual HRESULT STDMETHODCALLTYPE put_Terminal(
            IN ITTerminal *pTerminal
            );

    virtual HRESULT STDMETHODCALLTYPE put_Call(
            IN ITCallInfo *pCallInfo
            );
    
    virtual HRESULT STDMETHODCALLTYPE put_ErrorCode(
            IN HRESULT hrErrorCode
            );


private:


    //
    // the call on which the event was generated
    //

    ITCallInfo *m_pCallInfo;


    //
    // the terminal that caused the event (or whose tracks cause the event)
    //

    ITTerminal *m_pTerminal;


    //
    // HRESULT of the last error
    //

    HRESULT m_hr;

};



#endif // _TTS_TERMIAL_EVENT_DOT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\terminal.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    terminal.h

Abstract:

    Declaration of the CTerminal class
    
Author:

    mquinton  06-12-97
    
Notes:

Revision History:

--*/

#ifndef __TERMINAL_H_
#define __TERMINAL_H_

#include "address.h"
#include "resource.h"       // main symbols
#include "connect.h"

class CTAPI;

/////////////////////////////////////////////////////////////////////////////
// CTerminal
class CTerminal : 
	public CTAPIComObjectRoot<CTerminal>,
	public CComDualImpl<ITTerminal, &IID_ITTerminal, &LIBID_TAPI3Lib>,
   	public CComDualImpl<ITBasicAudioTerminal, &IID_ITBasicAudioTerminal, &LIBID_TAPI3Lib>,
    public ITTerminalPrivate,
    public CObjectSafeImpl
{
public:
    
	CTerminal() : m_pName(NULL),
                  m_State(TS_NOTINUSE),
                  m_TerminalType(TT_STATIC),
                  m_Direction(TD_RENDER),
                  m_Class(CLSID_NULL),
                  m_lMediaType(LINEMEDIAMODE_AUTOMATEDVOICE),
                  m_pMSPCall(NULL),
                  m_dwAPIVersion(0)
    {}

    void FinalRelease();

DECLARE_MARSHALQI(CTerminal)
DECLARE_TRACELOG_CLASS(CTerminal)

BEGIN_COM_MAP(CTerminal)
	COM_INTERFACE_ENTRY2(IDispatch, ITTerminal)
    COM_INTERFACE_ENTRY(ITTerminal)
	COM_INTERFACE_ENTRY(ITBasicAudioTerminal)
    COM_INTERFACE_ENTRY(ITTerminalPrivate)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

protected:

    PWSTR                   m_pName;
    TERMINAL_STATE          m_State;
    TERMINAL_TYPE           m_TerminalType;
    TERMINAL_DIRECTION      m_Direction;
    DWORD                   m_dwAPIVersion;
    CLSID                   m_Class;
    long                    m_lMediaType;
    DWORD                   m_dwHookSwitchDev;
    DWORD                   m_dwPhoneID;
    HPHONEAPP               m_hPhoneApp;
    ITPhoneMSPCallPrivate * m_pMSPCall;
    #if DBG
    PWSTR           	    m_pDebug;
	#endif


public:

HRESULT
   static Create(
                 HPHONEAPP hPhoneApp,
                 DWORD dwPhoneID,
                 LPPHONECAPS pPhoneCaps,
                 DWORD dwHookSwitchDev,
                 TERMINAL_DIRECTION td,
                 DWORD dwAPIVersion,
                 ITTerminal ** ppTerminal
                );

    //
    // ITTerminal
    //
    STDMETHOD(get_Name)(BSTR * ppName);
    STDMETHOD(get_State)(TERMINAL_STATE * pTerminalState);
    STDMETHOD(get_TerminalType)(TERMINAL_TYPE * pType);
    STDMETHOD(get_TerminalClass)(BSTR * pTerminalClass);
    STDMETHOD(get_MediaType)(long * plMediaType);
    STDMETHOD(get_Direction)(TERMINAL_DIRECTION * pTerminalDirection);

    // itterminalprivate
    STDMETHOD(GetHookSwitchDev)(DWORD * pdwHookSwitchDev);
    STDMETHOD(GetPhoneID)(DWORD * pdwPhoneID);
    STDMETHOD(GetHPhoneApp)(HPHONEAPP * phPhoneApp);
    STDMETHOD(GetAPIVersion)(DWORD * pdwAPIVersion);
    STDMETHOD(SetMSPCall)(ITPhoneMSPCallPrivate * pPhoneMSPCall);
    
    // itbasicaudio
	STDMETHOD(get_Gain)(long *pVal);
	STDMETHOD(put_Gain)(long newVal);
	STDMETHOD(get_Balance)(long *pVal);
	STDMETHOD(put_Balance)(long newVal);
	STDMETHOD(get_Volume)(long *pVal);
	STDMETHOD(put_Volume)(long newVal);
};


            
#endif //__TERMINAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\utils.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    utils.h

Abstract:

Author:

    mquinton  06-30-98
    
Notes:

Revision History:

--*/

#ifndef __UTILS_H__
#define __UTILS_H__

#ifdef TRACELOG

    #include <rtutils.h>
    //#include <windef.h>
    //#include <winnt.h>

    extern BOOL g_bLoggingEnabled;
	
    #define MAXDEBUGSTRINGLENGTH 1024

    #define TL_ERROR ((DWORD)0x00010000 | TRACE_USE_MASK)
    #define TL_WARN  ((DWORD)0x00020000 | TRACE_USE_MASK)
    #define TL_INFO  ((DWORD)0x00040000 | TRACE_USE_MASK)
    #define TL_TRACE ((DWORD)0x00080000 | TRACE_USE_MASK)
    #define TL_EVENT ((DWORD)0x00100000 | TRACE_USE_MASK)

    BOOL  TRACELogRegister(LPCTSTR szName);
    void  TRACELogDeRegister();
    void  TRACELogPrint(IN DWORD dwDbgLevel, IN LPCSTR DbgMessage, IN ...);
    void  TRACELogPrint(IN DWORD dwDbgLevel, HRESULT hr, IN LPCSTR lpszFormat, IN ...);

    extern char *TraceLevel(DWORD dwDbgLevel);
    extern void TAPIFormatMessage(HRESULT hr, LPVOID lpMsgBuf);

    #define TRACELOGREGISTER(arg) TRACELogRegister(arg)
    #define TRACELOGDEREGISTER() g_bLoggingEnabled?TRACELogDeRegister():0
    #define LOG(arg) g_bLoggingEnabled?TRACELogPrint arg:0
    #define STATICLOG(arg) g_bLoggingEnabled?StaticTRACELogPrint arg:0

	extern char    sg_szTraceName[100];
	extern DWORD   sg_dwTracingToDebugger;
	extern DWORD   sg_dwDebuggerMask;
    extern DWORD   sg_dwTraceID;

    #define DECLARE_DEBUG_ADDREF_RELEASE(x)                                                             \
    void LogDebugAddRef(DWORD dw)                                                                       \
    { TRACELogPrint(TL_INFO, "%s::AddRef() = %d - this %lx", _T(#x), dw, this); }               \
    void LogDebugRelease(DWORD dw)                                                                      \
    { TRACELogPrint(TL_INFO, "%s::Release() = %d - this %lx", _T(#x), dw, this); }


    #define DECLARE_TRACELOG_CLASS(x)                                                                   \
        void  TRACELogPrint(IN DWORD dwDbgLevel, IN LPCSTR lpszFormat, IN ...)                          \
        {																								\
			char    szTraceBuf[MAXDEBUGSTRINGLENGTH + 1];												\
			va_list arglist;																			\
																										\
			if ( ( sg_dwTracingToDebugger > 0 ) &&														\
				 ( 0 != ( dwDbgLevel & sg_dwDebuggerMask ) ) )											\
			{																							\
				SYSTEMTIME SystemTime;																	\
				GetLocalTime(&SystemTime);																\
																										\
				wsprintfA(szTraceBuf,																	\
						  "%s:[%02u:%02u:%02u.%03u,tid=%x:] [%s] (%p) %s::",							\
						  sg_szTraceName,																\
						  SystemTime.wHour,																\
						  SystemTime.wMinute,															\
						  SystemTime.wSecond,															\
						  SystemTime.wMilliseconds,														\
						  GetCurrentThreadId(),															\
						  TraceLevel(dwDbgLevel),														\
						  this,																			\
						  _T(#x));																		\
																										\
				va_list ap;																				\
				va_start(ap, lpszFormat);																\
																										\
				_vsnprintf(&szTraceBuf[lstrlenA(szTraceBuf)],											\
					MAXDEBUGSTRINGLENGTH - lstrlenA(szTraceBuf),										\
					lpszFormat,																			\
					ap																					\
					);																					\
																										\
				lstrcatA (szTraceBuf, "\n");															\
																										\
				OutputDebugStringA (szTraceBuf);														\
																										\
				va_end(ap);																				\
			}																							\
																										\
			if (sg_dwTraceID != INVALID_TRACEID)														\
			{																							\
				wsprintfA(szTraceBuf, "[%s] (%p) %s::%s", TraceLevel(dwDbgLevel), this, _T(#x), lpszFormat);	\
																										\
				va_start(arglist, lpszFormat);															\
				TraceVprintfExA(sg_dwTraceID, dwDbgLevel | TRACE_USE_MSEC, szTraceBuf, arglist);							\
				va_end(arglist);																		\
			}																							\
        }                                                                                               \
                                                                                                        \
        void  TRACELogPrint(IN DWORD dwDbgLevel,IN HRESULT hr, IN LPCSTR lpszFormat, IN ...)            \
        {                                                                                               \
			char    szTraceBuf[MAXDEBUGSTRINGLENGTH + 1];												\
			LPVOID  lpMsgBuf = NULL;																	\
			va_list arglist;																			\
																										\
			TAPIFormatMessage(hr, &lpMsgBuf);															\
																										\
			if ( ( sg_dwTracingToDebugger > 0 ) &&														\
				 ( 0 != ( dwDbgLevel & sg_dwDebuggerMask ) ) )											\
			{																							\
				SYSTEMTIME SystemTime;																	\
				GetLocalTime(&SystemTime);																\
																										\
				wsprintfA(szTraceBuf,																	\
						  "%s:[%02u:%02u:%02u.%03u,tid=%x:] [%s] (%p) %s::",							\
						  sg_szTraceName,																\
						  SystemTime.wHour,																\
						  SystemTime.wMinute,															\
						  SystemTime.wSecond,															\
						  SystemTime.wMilliseconds,														\
						  GetCurrentThreadId(),															\
						  TraceLevel(dwDbgLevel),														\
						  this,																			\
						  _T(#x)																		\
						  );																			\
																										\
				va_list ap;																				\
				va_start(ap, lpszFormat);																\
																										\
				_vsnprintf(&szTraceBuf[lstrlenA(szTraceBuf)],											\
					MAXDEBUGSTRINGLENGTH - lstrlenA(szTraceBuf),										\
					lpszFormat,																			\
					ap																					\
					);																					\
																										\
				wsprintfA(&szTraceBuf[lstrlenA(szTraceBuf)],											\
						  " Returned[%lx] %s\n",														\
						  hr,																			\
						  lpMsgBuf);																	\
																										\
				OutputDebugStringA (szTraceBuf);														\
																										\
				va_end(ap);																				\
			}																							\
																										\
			if (sg_dwTraceID != INVALID_TRACEID)														\
			{																							\
				wsprintfA(szTraceBuf, "[%s] (%p) %s::%s  Returned[%lx] %s", TraceLevel(dwDbgLevel), this, _T(#x), lpszFormat,hr, lpMsgBuf );	\
																										\
				va_start(arglist, lpszFormat);															\
				TraceVprintfExA(sg_dwTraceID, dwDbgLevel | TRACE_USE_MSEC, szTraceBuf, arglist);							\
				va_end(arglist);																		\
			}																							\
																										\
			if(lpMsgBuf != NULL)																		\
			{																							\
				LocalFree( lpMsgBuf );																	\
			}																							\
        }																								\
                                                                                                        \
        static void  StaticTRACELogPrint(IN DWORD dwDbgLevel, IN LPCSTR lpszFormat, IN ...)                    \
        {																								\
			char    szTraceBuf[MAXDEBUGSTRINGLENGTH + 1];												\
			va_list arglist;																			\
																										\
			if ( ( sg_dwTracingToDebugger > 0 ) &&														\
				 ( 0 != ( dwDbgLevel & sg_dwDebuggerMask ) ) )											\
			{																							\
				SYSTEMTIME SystemTime;																	\
				GetLocalTime(&SystemTime);																\
																										\
				wsprintfA(szTraceBuf,																	\
						  "%s:[%02u:%02u:%02u.%03u,tid=%x:] [%s] %s::",									\
						  sg_szTraceName,																\
						  SystemTime.wHour,																\
						  SystemTime.wMinute,															\
						  SystemTime.wSecond,															\
						  SystemTime.wMilliseconds,														\
						  GetCurrentThreadId(),															\
						  TraceLevel(dwDbgLevel),														\
						  _T(#x));																		\
																										\
				va_list ap;																				\
				va_start(ap, lpszFormat);																\
																										\
				_vsnprintf(&szTraceBuf[lstrlenA(szTraceBuf)],											\
					MAXDEBUGSTRINGLENGTH - lstrlenA(szTraceBuf),										\
					lpszFormat,																			\
					ap																					\
					);																					\
																										\
				lstrcatA (szTraceBuf, "\n");															\
																										\
				OutputDebugStringA (szTraceBuf);														\
																										\
				va_end(ap);																				\
			}																							\
																										\
			if (sg_dwTraceID != INVALID_TRACEID)														\
			{																							\
				wsprintfA(szTraceBuf, "[%s] %s::%s", TraceLevel(dwDbgLevel), _T(#x), lpszFormat);		\
																										\
				va_start(arglist, lpszFormat);															\
				TraceVprintfExA(sg_dwTraceID, dwDbgLevel | TRACE_USE_MSEC, szTraceBuf, arglist);							\
				va_end(arglist);																		\
			}																							\
        }                                                                                               \
                                                                                                        \
        static void StaticTRACELogPrint(IN DWORD dwDbgLevel,IN HRESULT hr, IN LPCSTR lpszFormat, IN ...)      \
        {                                                                                               \
			char    szTraceBuf[MAXDEBUGSTRINGLENGTH + 1];												\
			LPVOID  lpMsgBuf = NULL;																	\
			va_list arglist;																			\
																										\
			TAPIFormatMessage(hr, &lpMsgBuf);															\
																										\
			if ( ( sg_dwTracingToDebugger > 0 ) &&														\
				 ( 0 != ( dwDbgLevel & sg_dwDebuggerMask ) ) )											\
			{																							\
				SYSTEMTIME SystemTime;																	\
				GetLocalTime(&SystemTime);																\
																										\
				wsprintfA(szTraceBuf,																	\
						  "%s:[%02u:%02u:%02u.%03u,tid=%x:] [%s] %s::",									\
						  sg_szTraceName,																\
						  SystemTime.wHour,																\
						  SystemTime.wMinute,															\
						  SystemTime.wSecond,															\
						  SystemTime.wMilliseconds,														\
						  GetCurrentThreadId(),															\
						  TraceLevel(dwDbgLevel),														\
						  _T(#x)																		\
						  );																			\
																										\
				va_list ap;																				\
				va_start(ap, lpszFormat);																\
																										\
				_vsnprintf(&szTraceBuf[lstrlenA(szTraceBuf)],											\
					MAXDEBUGSTRINGLENGTH - lstrlenA(szTraceBuf),										\
					lpszFormat,																			\
					ap																					\
					);																					\
																										\
				wsprintfA(&szTraceBuf[lstrlenA(szTraceBuf)],											\
						  " Returned[%lx] %s\n",														\
						  hr,																			\
						  lpMsgBuf);																	\
																										\
				OutputDebugStringA (szTraceBuf);														\
																										\
				va_end(ap);																				\
			}																							\
																										\
			if (sg_dwTraceID != INVALID_TRACEID)														\
			{																							\
				wsprintfA(szTraceBuf, "[%s] %s::%s  Returned[%lx] %s", TraceLevel(dwDbgLevel), _T(#x), lpszFormat,hr, lpMsgBuf );	\
																										\
				va_start(arglist, lpszFormat);															\
				TraceVprintfExA(sg_dwTraceID, dwDbgLevel | TRACE_USE_MSEC, szTraceBuf, arglist);							\
				va_end(arglist);																		\
			}																							\
																										\
			if(lpMsgBuf != NULL)																		\
			{																							\
				LocalFree( lpMsgBuf );																	\
			}																							\
        }

#else // TRACELOG not defined

    #define TRACELOGREGISTER(arg)
    #define TRACELOGDEREGISTER() 
    #define LOG(arg)
    #define STATICLOG(arg)
    #define DECLARE_DEBUG_ADDREF_RELEASE(x)
    #define DECLARE_TRACELOG_CLASS(x)

#endif // TRACELOG

class CAsyncRequestReply
{
private:
    HANDLE      hRepliedSemaphore;
    DWORD       dwID;
    BOOL        bReply;
    HRESULT     hResult;

public:
DECLARE_TRACELOG_CLASS(CAsyncRequestReply)
    CAsyncRequestReply(DWORD id, BOOL b, HRESULT hr)
    {
        if( (hRepliedSemaphore = CreateSemaphore(NULL,0,1,NULL)) == NULL )
        {
            LOG((TL_INFO, "create CAsyncRequest - CreateSemaphore failed"));
            hResult = E_OUTOFMEMORY;
        }
        else
        {
            dwID = id;
            bReply = b;
            hResult = hr;
            LOG((TL_INFO, "create CAsyncRequest %d ",dwID));
        }
    }

    ~CAsyncRequestReply() 
    {
        LOG((TL_INFO, "delete CAsyncRequest %d ",dwID));

        if( NULL != hRepliedSemaphore )
        {
            CloseHandle(hRepliedSemaphore);
        }
    }

    inline DWORD getID() {return dwID;};
    inline BOOL IsReply() {return bReply;};
    inline HRESULT getResult() {return hResult;};
    inline void setResult(HRESULT hr) {hResult = hr;};

    HRESULT wait()
    {
        LOG((TL_INFO, "wait CAsyncRequest %d ",dwID));

        extern DWORD gdwTapi2AsynchronousCallTimeout;

        DWORD rc = WaitForSingleObject(hRepliedSemaphore, gdwTapi2AsynchronousCallTimeout);
		              
        switch (rc)
        {
        case WAIT_ABANDONED:
            LOG((TL_ERROR, "wait CAsyncRequest %d WaitForSingle object returned WAIT_ABANDONED",dwID));
            hResult = TAPIERR_REQUESTFAILED;
            break;

        case WAIT_OBJECT_0:
            break;
		  
        case WAIT_TIMEOUT:
            LOG((TL_WARN, "wait CAsyncRequest %d WaitForSingle object returned WAIT_TIMEOUT",dwID));
            // -1 won't overlap with any value that may be returned from tapi2 calls.
            hResult = -1;
            break;
		  
        case WAIT_FAILED:
        {
            DWORD nLastError = GetLastError();
            LOG((TL_ERROR, "wait CAsyncRequest %d WaitForSingle object returned WAIT_FAILED, LastError = %d", dwID, nLastError));
            hResult = TAPIERR_REQUESTFAILED;
            break;
        }
		  
        default:
            break;

        }

        return hResult;
    }

    void signal()
    {
        LOG((TL_INFO, "signal CAsyncRequest %d ",dwID));
        ReleaseSemaphore(hRepliedSemaphore, 1, NULL);
    }

}; 


typedef list<CAsyncRequestReply *> RequestReplyList;

class   CAsyncReplyList
{
public:
	DECLARE_TRACELOG_CLASS(CAsyncReplyList)
private:
    RequestReplyList        replyList;
    CRITICAL_SECTION        csReply;

    CAsyncRequestReply *find(DWORD dwID)
    {
        RequestReplyList::iterator i;
        CAsyncRequestReply *pResult = NULL;

        // walk list searching for match
        i = replyList.begin();
        // iterate over current replies
        while ( i != replyList.end() )
        {
            // found it
            if ((*i)->getID() == dwID )
            {
                pResult = *i;
                break;
            }

            i++;
        }

        //returning pointer to matching entry or NULL
        return pResult;
    }

public:
    CAsyncReplyList() {InitializeCriticalSection( &csReply );};

    ~CAsyncReplyList()
    {
        FreeList();
        DeleteCriticalSection( &csReply );
    }

    void FreeList()
    {
        RequestReplyList::iterator i;

        EnterCriticalSection( &csReply );
        // walk list deleting entries
        i = replyList.begin();
        while ( i != replyList.end() )
            delete *i++;

        replyList.clear();
        LeaveCriticalSection( &csReply );
    };


    void remove(CAsyncRequestReply *a)
    {
        EnterCriticalSection( &csReply );
        replyList.remove(a);    
        LeaveCriticalSection( &csReply );
    }

    CAsyncRequestReply *addRequest(DWORD id)
    {
        CAsyncRequestReply *pReply;

        EnterCriticalSection( &csReply );

        // Check list to see if we're already on the list ( i.e. the response LINE_REPLY got here before us)
        pReply = find(id);
        if (pReply == NULL || !pReply->IsReply())
        {
            // No so we got here before the reply, create a new request entry on the list
            pReply = new CAsyncRequestReply(id, FALSE, 0);
            
            if (NULL == pReply)
            {
                LOG((TL_ERROR, "Could not alloc for CAsyncRequestReply"));
            }
            else if( pReply->getResult() == E_OUTOFMEMORY )
            {
                delete pReply;
                pReply = NULL;
                LOG((TL_ERROR, "addRequest - Create Semaphore failed"));
            }
            else 
            {
                try
                {
                    replyList.push_back(pReply);
                }
                catch(...)
                {
                    delete pReply;
                    pReply = NULL;
                    LOG((TL_ERROR, "addRequest- failed - because of alloc failure"));

                }
     
            }
        }
        //  Else, the reply comes before me, remove it from the list
        else
        {
            replyList.remove (pReply);
        }

        LeaveCriticalSection( &csReply );
        return pReply;
    }

    CAsyncRequestReply *addReply(DWORD id, HRESULT hr)
    {
        CAsyncRequestReply *pReply;

        EnterCriticalSection( &csReply );

        // Check list to see if we have a matching entry
        pReply = find(id);
        if (pReply == NULL || pReply->IsReply())
        {
            // No so we got here before the request returned, create a new entry on the list
            pReply = new CAsyncRequestReply(id, TRUE, hr);
            if (NULL == pReply)
            {
                LOG((TL_ERROR, "Could not alloc for CAsyncRequestReply"));
            }
            else if( pReply->getResult() == E_OUTOFMEMORY )
            {
                delete pReply;
                pReply = NULL;
                LOG((TL_ERROR, "addReply - Create Semaphore failed"));
            }
            else
            {
                try
                {
                    replyList.push_back(pReply);
                }
                catch(...)
                {
                    delete pReply;
                    pReply = NULL;
                    LOG((TL_ERROR, "addReply- failed - because of alloc failure"));
                }
            }
        }
        else
        {
            // Use the existing entry, set its return code & signal to the waiting request code
            pReply->setResult(hr);
            replyList.remove (pReply);
        }

        LeaveCriticalSection( &csReply );
        return pReply;
    }


};

////////////////////////////////////////////////////////////////////
//
// Class CRetryQueue
// Maintains queue of Async messages for retry.
// Typically these relate to calls not yet entered in the call hash-
// table, such that findCallObject failed.  These are reprocessed
// once the call is entered & the ghAsyncRetryQueueEvent event is 
// signalled.
//
// Added criticalsection - thread safe now
//
////////////////////////////////////////////////////////////////////
class CRetryQueue
{
    typedef struct _tagRetryQueueEntry
    {
        DWORD           dwRetryCount;
        PASYNCEVENTMSG  pMessage;
    } RETRY_QUEUE_ENTRY, *PRETRY_QUEUE_ENTRY;
    typedef list<RETRY_QUEUE_ENTRY *> RetryQueueListType;
    
    #define MAX_REQUEUE_TRIES   3

private:

    RetryQueueListType      m_RetryQueueList;
    CRITICAL_SECTION        m_cs;


    //
    // is the queue open for new entries?
    //
    
    BOOL                    m_bAcceptNewEntries;


private:

    //
    // requeue the entry that failed processing. don't do this if the queue is
    // closed.
    //
    
    void RequeueEvent(PRETRY_QUEUE_ENTRY pQueueEntry);


public:
DECLARE_TRACELOG_CLASS(CRetryQueue)

    CRetryQueue()
    :m_bAcceptNewEntries(FALSE)
    { 
        InitializeCriticalSection( &m_cs ); 
    }

    ~CRetryQueue();

    void Lock(){ EnterCriticalSection( &m_cs ); }
    void Unlock(){ LeaveCriticalSection( &m_cs ); }
    
    BOOL QueueEvent(PASYNCEVENTMSG  pEvent);
    BOOL DequeueEvent(PRETRY_QUEUE_ENTRY * ppEvent);
    void ProcessQueue();
    void RemoveNewCallHub(DWORD);
    inline BOOL ItemsInQueue()
    {
        BOOL        bReturn;

        Lock();
        bReturn = !m_RetryQueueList.empty();
        Unlock();

        return bReturn;
    }


    //
    // after this function returns, the queue will accept new entries
    //

    void OpenForNewEntries();


    //
    // new entries will be denied after this function returns
    //

    void CloseForNewEntries();

};


#define MAXCACHEENTRIES             5
#define BUFFERTYPE_ADDRCAP          1
#define BUFFERTYPE_LINEDEVCAP       2
#define BUFFERTYPE_PHONECAP         3

typedef struct
{
    UINT_PTR    pObject;
    LPVOID      pBuffer;

} CACHEENTRY;


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CStructCache
//
// A simple class to cache TAPI structures in tapi3.dll
//
// This implementation has an array of CACHEENTRY structures.  Each
// CACHEENTRY structure has 2 member:
//      pObject - the object that currently owns the buffer
//      pBuffer - the buffer
//
// The array is a fixed size, which is set when the class is initialized
// The memory for the buffers is allocated during initialization as
// well.  It is possible that a buffer gets realloced (replaced)
// at some time.
//
// This implementation assumes that the object that owns the buffer
// uses it's critical sections correctly.  That is, it is locked when
// SetXxxBuffer is called, and it is locked when getting and using
// a buffer If not, the buffer can disapper from the object at any time.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class CStructCache
{
private:
    CRITICAL_SECTION    m_cs;
    DWORD               m_dwType;
    DWORD               m_dwMaxEntries;
    DWORD               m_dwUsedEntries;
    CACHEENTRY          m_aEntries[MAXCACHEENTRIES];

public:
DECLARE_TRACELOG_CLASS(CStructCache)

    CStructCache()
    {
        int iCount;

        InitializeCriticalSection( &m_cs );

        for( iCount=0; iCount<MAXCACHEENTRIES; iCount++)
        {
            m_aEntries[iCount].pObject = NULL;
            m_aEntries[iCount].pBuffer = NULL;
        }

        m_dwType = 0;
        m_dwMaxEntries = 0;
        m_dwUsedEntries = 0;
    }

    ~CStructCache()
    {
        DeleteCriticalSection( &m_cs );
    }

    void Lock()
    {
        EnterCriticalSection( &m_cs );
    }
    void Unlock()
    {
        LeaveCriticalSection( &m_cs );
    }

    HRESULT Initialize( DWORD dwMaxEntries, DWORD dwSize, DWORD dwType );
    HRESULT Shutdown();
    HRESULT GetBuffer( UINT_PTR pNewObject, LPVOID * ppReturnStruct );
    HRESULT SetBuffer( UINT_PTR pObject, LPVOID pNewStruct );
    HRESULT InvalidateBuffer( UINT_PTR pObject );
};


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CArray - based on from CSimpleArray from atl
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
template <class T>
class CTObjectArray
{
private:
    
	T           * m_aT;
	int           m_nSize;
    int           m_nUsed;

public:
DECLARE_TRACELOG_CLASS(CTObjectArray)
	CTObjectArray() : m_aT(NULL), m_nSize(0), m_nUsed(0){}

	~CTObjectArray()
	{}

	int GetSize() const
	{
		return m_nUsed;
	}
    
	BOOL Add(T& t)
	{
		if(m_nSize == m_nUsed)
		{
			T       * aT;
            int       nNewSize;
                    
			nNewSize = (m_nSize == 0) ? 1 : (m_nSize * 2);
            
			aT = (T*) ClientAlloc (nNewSize * sizeof(T));
            
			if(aT == NULL)
            {
				return FALSE;
            }

            CopyMemory(
                       aT,
                       m_aT,
                       m_nUsed * sizeof(T)
                      );

            ClientFree( m_aT );

            m_aT = aT;
            
			m_nSize = nNewSize;
		}

        m_aT[m_nUsed] = t;

        t->AddRef();

		m_nUsed++;
        
		return TRUE;
	}
    
	BOOL Remove(T& t)
	{
		int nIndex = Find(t);
        
		if(nIndex == -1)
			return FALSE;
        
		return RemoveAt(nIndex);
	}
    
	BOOL RemoveAt(int nIndex)
	{
        m_aT[nIndex]->Release();

        if(nIndex != (m_nUsed - 1))
        {
			MoveMemory(
                       (void*)&m_aT[nIndex],
                       (void*)&m_aT[nIndex + 1],
                       (m_nUsed - (nIndex + 1)) * sizeof(T)
                      );
        }
        

		m_nUsed--;
        
		return TRUE;
	}
    
	void Shutdown()
	{
		if( NULL != m_aT )
		{
            int     index;

            for (index = 0; index < m_nUsed; index++)
            {
                m_aT[index]->Release();
            }

			ClientFree(m_aT);
            
			m_aT = NULL;
			m_nUsed = 0;
			m_nSize = 0;
		}
	}
    
	T& operator[] (int nIndex) const
	{
		_ASSERTE(nIndex >= 0 && nIndex < m_nUsed);
		return m_aT[nIndex];
	}
    
	int Find(T& t) const
	{
		for(int i = 0; i < m_nUsed; i++)
		{
			if(m_aT[i] == t)
				return i;
		}
		return -1;	// not found
	}
};


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CArray - based on from CSimpleArray from atl
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
template <class T>
class CTArray
{
private:
    
	T           * m_aT;
	int           m_nSize;
    int           m_nUsed;

public:
DECLARE_TRACELOG_CLASS(CTArray)

	CTArray() : m_aT(NULL), m_nSize(0), m_nUsed(0){}

	~CTArray()
	{}

	int GetSize() const
	{
		return m_nUsed;
	}
    
	BOOL Add(T& t)
	{
		if(m_nSize == m_nUsed)
		{
			T       * aT;
            int       nNewSize;
                    
			nNewSize = (m_nSize == 0) ? 1 : (m_nSize * 2);
            
			aT = (T*) ClientAlloc (nNewSize * sizeof(T));
            
			if(aT == NULL)
            {
				return FALSE;
            }

            CopyMemory(
                       aT,
                       m_aT,
                       m_nUsed * sizeof(T)
                      );

            ClientFree( m_aT );

            m_aT = aT;
            
			m_nSize = nNewSize;
		}

        m_aT[m_nUsed] = t;

		m_nUsed++;
        
		return TRUE;
	}
    
	BOOL Remove(T& t)
	{
		int nIndex = Find(t);
        
		if(nIndex == -1)
			return FALSE;
        
		return RemoveAt(nIndex);
	}
    
	BOOL RemoveAt(int nIndex)
	{
		if(nIndex != (m_nUsed - 1))
        {
			MoveMemory(
                       (void*)&m_aT[nIndex],
                       (void*)&m_aT[nIndex + 1],
                       (m_nUsed - (nIndex + 1)) * sizeof(T)
                      );
        }

		m_nUsed--;
        
		return TRUE;
	}
    
	void Shutdown()
	{
		if( NULL != m_aT )
		{
            int     index;

			ClientFree(m_aT);
            
			m_aT = NULL;
			m_nUsed = 0;
			m_nSize = 0;
		}
	}
    
	T& operator[] (int nIndex) const
	{
		_ASSERTE(nIndex >= 0 && nIndex < m_nUsed);
		return m_aT[nIndex];
	}
    
	int Find(T& t) const
	{
		for(int i = 0; i < m_nUsed; i++)
		{
			if(m_aT[i] == t)
				return i;
		}
		return -1;	// not found
	}
};




    
#endif // __UTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\termevnt.cpp ===
#include "stdafx.h"

#include "termevnt.h"


HRESULT CASRTerminalEvent::FireEvent(
                                     CTAPI * pTapi,
                                     ITCallInfo *pCall,
                                     ITTerminal  * pTerminal,
                                     HRESULT hrErrorCode
                                     )
{

    STATICLOG((TL_TRACE, "FireEvent - enter" ));


    CCall *pCCall = NULL;

    pCCall = dynamic_cast<CComObject<CCall>*>(pCall);
    
    if (NULL == pCCall)
    {
        STATICLOG((TL_ERROR, "FireEvent - bad call pointer" ));
        return E_FAIL;
    }

    if( pCCall->DontExpose())
    {
        STATICLOG((TL_INFO, "FireEvent - Don't expose this call %p", pCCall));
        return S_OK;
    }

    if (NULL == pTapi)
    {
        STATICLOG((TL_ERROR, "FireEvent - tapi object is NULL" ));
        return E_POINTER;
    }


    //
    // create the event object
    //

    HRESULT hr = E_FAIL;

    CComObject<CASRTerminalEvent> *p;

    hr = CComObject<CASRTerminalEvent>::CreateInstance( &p );

    if (FAILED(hr))
    {
        STATICLOG((TL_ERROR, "FireEvent - could not createinstance" ));
        return E_OUTOFMEMORY;
    }


    //
    // save event information to the event object
    //

    hr = p->put_Call(pCall);
    if (FAILED(hr))
    {
        STATICLOG((TL_ERROR, "FireEvent - put_Call failed" ));

        delete p;
        return hr;
    }

    hr = p->put_Terminal(pTerminal);
    if (FAILED(hr))
    {
        STATICLOG((TL_ERROR, "FireEvent - put_Terminal failed" ));

        delete p;
        return hr;
    }


    hr = p->put_ErrorCode(hrErrorCode);
    if (FAILED(hr))
    {
        STATICLOG((TL_ERROR, "FireEvent - put_ErrorCode failed" ));

        delete p;
        return hr;
    }


    //
    // get the dispatch interface
    //

    IDispatch *pDisp = NULL;

    hr = p->_InternalQueryInterface( IID_IDispatch, (void **)&pDisp );

    if (FAILED(hr))
    {
        delete p;
        STATICLOG((TL_ERROR, "FireEvent - could not get IDispatch %lx", hr));

        return hr;
    }

    
    //
    // fire the event
    //

    pTapi->Event(
                 TE_ASRTERMINAL,
                 pDisp
                );


    //
    // release our reference
    //
    pDisp->Release();
    
    STATICLOG((TL_TRACE, "FireEvent - exit - returing SUCCESS" ));

    
    return S_OK;
}


CASRTerminalEvent::CASRTerminalEvent()
    :m_pCallInfo(NULL),
    m_pTerminal(NULL),
    m_hr(S_OK)
{
    LOG((TL_TRACE, "CASRTerminalEvent[%p] - enter", this));
    
    LOG((TL_TRACE, "CASRTerminalEvent - finish"));
}


CASRTerminalEvent::~CASRTerminalEvent()
{
    LOG((TL_INFO, "~CASRTerminalEvent[%p] - enter", this));

 
    //
    // remember to release all the references we may hold
    //

    if (NULL != m_pCallInfo)
    {
        LOG((TL_INFO, "~CASRTerminalEvent - releasing m_pCallInfo %p", m_pCallInfo));

        m_pCallInfo->Release();
        m_pCallInfo = NULL;
    }


    if ( NULL != m_pTerminal) 
    {
        LOG((TL_INFO, "~CASRTerminalEvent - releasing m_pTerminal %p", m_pTerminal));

        m_pTerminal->Release();
        m_pTerminal = NULL;
    }


    LOG((TL_TRACE, "~CASRTerminalEvent - finish"));
}



HRESULT STDMETHODCALLTYPE CASRTerminalEvent::get_Call(
        OUT ITCallInfo **ppCallInfo
        )
{
    LOG((TL_TRACE, "get_Call[%p] - enter", this));


    //
    // check arguments
    //

    if (TAPIIsBadWritePtr(ppCallInfo, sizeof(ITCallInfo *)))
    {
        LOG((TL_ERROR, "get_Call - bad pointer passed in"));

        return E_POINTER;
    }

    
    //
    // no garbage out
    //

    *ppCallInfo = NULL;


    //
    // return call info if we have it
    //

    if (NULL != m_pCallInfo)
    {

        *ppCallInfo = m_pCallInfo;
        (*ppCallInfo)->AddRef();
    }


    LOG((TL_TRACE, "get_Call - finish"));

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CASRTerminalEvent::get_Terminal(
        OUT ITTerminal **ppTerminal
        )
{
    LOG((TL_TRACE, "get_Terminal[%p] - enter", this));

    
    //
    // check arguments
    //

    if (TAPIIsBadWritePtr(ppTerminal, sizeof(ITTerminal*)))
    {
        LOG((TL_ERROR, "get_Terminal - bad pointer passed in"));

        return E_POINTER;
    }

    
    //
    // no garbage out
    //

    *ppTerminal = NULL;


    //
    // return terminal if we have it
    //
    
    if (NULL != m_pTerminal)
    {

        *ppTerminal = m_pTerminal;
        (*ppTerminal)->AddRef();
    }


    LOG((TL_TRACE, "get_Terminal - finish"));

    return S_OK;
}



HRESULT STDMETHODCALLTYPE CASRTerminalEvent::get_Error(
        OUT HRESULT *phrErrorCode
        )
{
    LOG((TL_TRACE, "get_Error[%p] - enter", this));


    //
    // check arguments
    //

    if (TAPIIsBadWritePtr(phrErrorCode, sizeof(HRESULT)))
    {
        LOG((TL_ERROR, "get_Error - bad pointer passed in"));

        return E_POINTER;
    }


    //
    // return error code
    //
    
    *phrErrorCode = m_hr;


    LOG((TL_TRACE, "get_Error - finish. hr = [%lx]", m_hr));

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CASRTerminalEvent::put_Terminal(
            IN ITTerminal *pTerminal
            )
{
    LOG((TL_TRACE, "put_Terminal[%p] - enter", this));

    
    //
    // check the argument
    //

    if ((NULL != pTerminal) && IsBadReadPtr(pTerminal, sizeof(ITTerminal)))
    {
        LOG((TL_ERROR, "put_Terminal - bad pointer passed in"));


        //
        // if we get here, we have a bug. debug to see what happened.
        //

        _ASSERTE(FALSE);

        return E_POINTER;
    }

    

    //
    // keep the pointer
    //

    m_pTerminal = pTerminal;

    
    //
    // keep a reference if not null
    //

    if (NULL != m_pTerminal)
    {
        m_pTerminal->AddRef();
    }


    LOG((TL_TRACE, "put_Terminal - finished"));

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CASRTerminalEvent::put_Call(
            IN ITCallInfo *pCallInfo
            )
{
    LOG((TL_TRACE, "put_Call[%p] - enter", this));

    
    //
    // check the argument
    //

    if ((NULL != pCallInfo) && IsBadReadPtr(pCallInfo, sizeof(ITCallInfo)))
    {
        LOG((TL_ERROR, "put_Call - bad pointer passed in"));


        //
        // if we get here, we have a bug. debug to see what happened.
        //

        _ASSERTE(FALSE);

        return E_POINTER;
    }

    

    //
    // keep the pointer
    //

    m_pCallInfo = pCallInfo;

    
    //
    // keep a reference if not null
    //

    if (NULL != m_pCallInfo)
    {
        m_pCallInfo->AddRef();
    }


    LOG((TL_TRACE, "put_Call - finished"));

    return S_OK;
}



HRESULT STDMETHODCALLTYPE CASRTerminalEvent::put_ErrorCode(
            IN HRESULT hrErrorCode
            )
{
    
    LOG((TL_TRACE, "put_ErrorCode[%p] - enter. hr = [%lx]", this, hrErrorCode));
  

    //
    // keep the value
    //

    m_hr = hrErrorCode;

    
    LOG((TL_TRACE, "put_ErrorCode - finished"));

    return S_OK;
}



HRESULT CFileTerminalEvent::FireEvent(
                                     CAddress *pCAddress,
                                     CTAPI * pTapi,
                                     ITCallInfo *pCall,
                                     TERMINAL_MEDIA_STATE tmsTerminalState,
                                     FT_STATE_EVENT_CAUSE ftecEventCause,
                                     ITTerminal  * pTerminal,
                                     ITFileTrack * pFileTrack,
                                     HRESULT hrErrorCode
                                     )
{

    STATICLOG((TL_TRACE, "FireEvent - enter" ));
    STATICLOG((TL_INFO, "     File Terminal State -------------> %d", tmsTerminalState));
    STATICLOG((TL_INFO, "     File Terminal Event Cause -------> %d", ftecEventCause));
    STATICLOG((TL_INFO, "     File Terminal -------------------> %p", pTerminal));


    CCall *pCCall = NULL;

    pCCall = dynamic_cast<CComObject<CCall>*>(pCall);
    
    if (NULL == pCCall)
    {
        STATICLOG((TL_ERROR, "FireEvent - bad call pointer" ));
        return E_FAIL;
    }

    if( pCCall->DontExpose())
    {
        STATICLOG((TL_INFO, "FireEvent - Don't expose this call %p", pCCall));
        return S_OK;
    }

    if (NULL == pTapi)
    {
        STATICLOG((TL_ERROR, "FireEvent - tapi object is NULL" ));
        return E_POINTER;
    }

    
    //
    // Check the event filter mask
    // This are MSP events and are not filtered by
    // TapiSrv
    //

    DWORD dwEventFilterMask = 0;
    dwEventFilterMask = pCAddress->GetSubEventsMask( TE_FILETERMINAL );
    if( !( dwEventFilterMask & GET_SUBEVENT_FLAG(tmsTerminalState)))
    {
        STATICLOG((TL_WARN, "FireEvent - filtering out this event [%lx]", tmsTerminalState));
        return S_OK;
    }


    //
    // create the event object
    //

    HRESULT hr = E_FAIL;

    CComObject<CFileTerminalEvent> *p;

    hr = CComObject<CFileTerminalEvent>::CreateInstance( &p );

    if (FAILED(hr))
    {
        STATICLOG((TL_ERROR, "FireEvent - could not createinstance" ));
        return E_OUTOFMEMORY;
    }


    //
    // save event information to the event object
    //

    hr = p->put_Call(pCall);

    if (FAILED(hr))
    {
        STATICLOG((TL_ERROR, "FireEvent - put_Call failed" ));

        delete p;
        return hr;
    }

    hr = p->put_Terminal(pTerminal);
    if (FAILED(hr))
    {
        STATICLOG((TL_ERROR, "FireEvent - put_Terminal failed" ));

        delete p;
        return hr;
    }

    hr = p->put_Track(pFileTrack);
    if (FAILED(hr))
    {
        STATICLOG((TL_ERROR, "FireEvent - put_Track failed" ));

        delete p;
        return hr;
    }

    hr = p->put_State(tmsTerminalState);
    if (FAILED(hr))
    {
        STATICLOG((TL_ERROR, "FireEvent - put_State failed" ));

        delete p;
        return hr;
    }

    hr = p->put_Cause(ftecEventCause);
    if (FAILED(hr))
    {
        STATICLOG((TL_ERROR, "FireEvent - put_Cause failed" ));

        delete p;
        return hr;
    }

    hr = p->put_ErrorCode(hrErrorCode);
    if (FAILED(hr))
    {
        STATICLOG((TL_ERROR, "FireEvent - put_ErrorCode failed" ));

        delete p;
        return hr;
    }


    //
    // get the dispatch interface
    //

    IDispatch *pDisp = NULL;

    hr = p->_InternalQueryInterface( IID_IDispatch, (void **)&pDisp );

    if (FAILED(hr))
    {
        delete p;
        STATICLOG((TL_ERROR, "FireEvent - could not get IDispatch %lx", hr));

        return hr;
    }

    
    //
    // fire the event
    //

    pTapi->Event(
                 TE_FILETERMINAL,
                 pDisp
                );


    //
    // release our reference
    //
    pDisp->Release();
    
    STATICLOG((TL_TRACE, "FireEvent - exit - returing SUCCESS" ));

    
    return S_OK;
}


CFileTerminalEvent::CFileTerminalEvent()
    :m_pCallInfo(NULL),
    m_pParentFileTerminal(NULL),
    m_pFileTrack(NULL),
    m_tmsTerminalState(TMS_IDLE),
    m_ftecEventCause(FTEC_NORMAL),
    m_hr(S_OK)
{
    LOG((TL_TRACE, "CFileTerminalEvent[%p] - enter", this));
    
    LOG((TL_TRACE, "CFileTerminalEvent - finish"));
}


CFileTerminalEvent::~CFileTerminalEvent()
{
    LOG((TL_TRACE, "~CFileTerminalEvent[%p] - enter", this));

 
    //
    // remember to release all the references we may hold
    //

    if (NULL != m_pCallInfo)
    {
        LOG((TL_INFO, "~CFileTerminalEvent - releasing m_pCallInfo %p", m_pCallInfo));

        m_pCallInfo->Release();
        m_pCallInfo = NULL;
    }


    if ( NULL != m_pParentFileTerminal) 
    {
        LOG((TL_INFO, "~CFileTerminalEvent - releasing m_pParentFileTerminal %p", m_pParentFileTerminal));

        m_pParentFileTerminal->Release();
        m_pParentFileTerminal = NULL;
    }

    
    if (NULL != m_pFileTrack)
    {
        LOG((TL_INFO, "~CFileTerminalEvent - releasing m_pFileTrack %p", m_pFileTrack));

        m_pFileTrack->Release();
        m_pFileTrack = NULL;
    }


    LOG((TL_TRACE, "~CFileTerminalEvent - finish"));
}



HRESULT STDMETHODCALLTYPE CFileTerminalEvent::get_Call(
        OUT ITCallInfo **ppCallInfo
        )
{
    LOG((TL_TRACE, "get_Call[%p] - enter", this));


    //
    // check arguments
    //

    if (TAPIIsBadWritePtr(ppCallInfo, sizeof(ITCallInfo *)))
    {
        LOG((TL_ERROR, "get_Call - bad pointer passed in"));

        return E_POINTER;
    }

    
    //
    // no garbage out
    //

    *ppCallInfo = NULL;


    //
    // return call info if we have it
    //

    if (NULL != m_pCallInfo)
    {

        *ppCallInfo = m_pCallInfo;
        (*ppCallInfo)->AddRef();
    }


    LOG((TL_TRACE, "get_Call - finish"));

    return S_OK;
}
    
HRESULT STDMETHODCALLTYPE CFileTerminalEvent::get_State(
        OUT TERMINAL_MEDIA_STATE *pFileTerminallState
        )
{
    LOG((TL_TRACE, "get_State[%p] - enter", this));


    //
    // check arguments
    //

    if (TAPIIsBadWritePtr(pFileTerminallState, sizeof(TERMINAL_MEDIA_STATE)))
    {
        LOG((TL_ERROR, "get_State - bad pointer passed in"));

        return E_POINTER;
    }

    
    //
    // return state
    //

    *pFileTerminallState = m_tmsTerminalState;

 
    LOG((TL_TRACE, "get_State - finish. state = [%lx]", m_tmsTerminalState));

    return S_OK;
}

    
HRESULT STDMETHODCALLTYPE CFileTerminalEvent::get_Cause(
        OUT FT_STATE_EVENT_CAUSE *pCause
        )
{
    LOG((TL_TRACE, "get_Cause[%p] - enter", this));


    //
    // check arguments
    //

    if (TAPIIsBadWritePtr(pCause, sizeof(FT_STATE_EVENT_CAUSE)))
    {
        LOG((TL_ERROR, "get_Cause - bad pointer passed in"));

        return E_POINTER;
    }


    //
    // return cause
    //
    
    *pCause = m_ftecEventCause;


    LOG((TL_TRACE, "get_Cause - finish. cause = [%lx]", m_ftecEventCause));

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CFileTerminalEvent::get_Terminal(
        OUT ITTerminal **ppTerminal
        )
{
    LOG((TL_TRACE, "get_Terminal[%p] - enter", this));

    
    //
    // check arguments
    //

    if (TAPIIsBadWritePtr(ppTerminal, sizeof(ITTerminal*)))
    {
        LOG((TL_ERROR, "get_Terminal - bad pointer passed in"));

        return E_POINTER;
    }

    
    //
    // no garbage out
    //

    *ppTerminal = NULL;


    //
    // return terminal if we have it
    //
    
    if (NULL != m_pParentFileTerminal)
    {

        *ppTerminal = m_pParentFileTerminal;
        (*ppTerminal)->AddRef();
    }


    LOG((TL_TRACE, "get_Terminal - finish"));

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CFileTerminalEvent::get_Track(
        OUT ITFileTrack **ppFileTrack
        )
{
    LOG((TL_TRACE, "get_Track[%p] - enter", this));


    //
    // check arguments
    //

    if (TAPIIsBadWritePtr(ppFileTrack, sizeof(ITFileTrack*)))
    {
        LOG((TL_ERROR, "get_Track - bad pointer passed in"));

        return E_POINTER;
    }

    
    //
    // no garbage out
    //

    *ppFileTrack = NULL;


    //
    // return track terminal if we have it
    //
    
    if (NULL != m_pFileTrack)
    {

        *ppFileTrack = m_pFileTrack;
        (*ppFileTrack)->AddRef();
    }


    LOG((TL_TRACE, "get_Track - finish"));

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CFileTerminalEvent::get_Error(
        OUT HRESULT *phrErrorCode
        )
{
    LOG((TL_TRACE, "get_Error[%p] - enter", this));


    //
    // check arguments
    //

    if (TAPIIsBadWritePtr(phrErrorCode, sizeof(HRESULT)))
    {
        LOG((TL_ERROR, "get_Error - bad pointer passed in"));

        return E_POINTER;
    }


    //
    // return error code
    //
    
    *phrErrorCode = m_hr;


    LOG((TL_TRACE, "get_Error - finish. hr = [%lx]", m_hr));

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CFileTerminalEvent::put_Terminal(
            IN ITTerminal *pTerminal
            )
{
    LOG((TL_TRACE, "put_Terminal[%p] - enter", this));

    
    //
    // check the argument
    //

    if ((NULL != pTerminal) && IsBadReadPtr(pTerminal, sizeof(ITTerminal)))
    {
        LOG((TL_ERROR, "put_Terminal - bad pointer passed in"));


        //
        // if we get here, we have a bug. debug to see what happened.
        //

        _ASSERTE(FALSE);

        return E_POINTER;
    }

    

    //
    // keep the pointer
    //

    m_pParentFileTerminal = pTerminal;

    
    //
    // keep a reference if not null
    //

    if (NULL != m_pParentFileTerminal)
    {
        m_pParentFileTerminal->AddRef();
    }


    LOG((TL_TRACE, "put_Terminal - finished"));

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CFileTerminalEvent::put_Track(
            IN ITFileTrack *pFileTrack
            )
{
    LOG((TL_TRACE, "put_Track[%p] - enter", this));

    
    //
    // check the argument
    //

    if ((NULL != pFileTrack) && IsBadReadPtr(pFileTrack, sizeof(ITFileTrack)))
    {
        LOG((TL_ERROR, "put_Track - bad pointer passed in"));


        //
        // if we get here, we have a bug. debug to see what happened.
        //

        _ASSERTE(FALSE);

        return E_POINTER;
    }

    

    //
    // keep the pointer
    //

    m_pFileTrack = pFileTrack;

    
    //
    // keep a reference if not null
    //

    if (NULL != m_pFileTrack)
    {
        m_pFileTrack->AddRef();
    }


    LOG((TL_TRACE, "put_Track - finished"));

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CFileTerminalEvent::put_Call(
            IN ITCallInfo *pCallInfo
            )
{
    LOG((TL_TRACE, "put_Call[%p] - enter", this));

    
    //
    // check the argument
    //

    if ((NULL != pCallInfo) && IsBadReadPtr(pCallInfo, sizeof(ITCallInfo)))
    {
        LOG((TL_ERROR, "put_Call - bad pointer passed in"));


        //
        // if we get here, we have a bug. debug to see what happened.
        //

        _ASSERTE(FALSE);

        return E_POINTER;
    }

    

    //
    // keep the pointer
    //

    m_pCallInfo = pCallInfo;

    
    //
    // keep a reference if not null
    //

    if (NULL != m_pCallInfo)
    {
        m_pCallInfo->AddRef();
    }


    LOG((TL_TRACE, "put_Call - finished"));

    return S_OK;
}

    
HRESULT STDMETHODCALLTYPE CFileTerminalEvent::put_State(
            IN TERMINAL_MEDIA_STATE tmsTerminalState
            )
{
    
    LOG((TL_TRACE, "put_State[%p] - enter. State = [%x]", this, tmsTerminalState));
  

    //
    // keep the value
    //

    m_tmsTerminalState = tmsTerminalState;

    
    LOG((TL_TRACE, "put_State - finished"));

    return S_OK;
}
    
HRESULT STDMETHODCALLTYPE CFileTerminalEvent::put_Cause(
            IN FT_STATE_EVENT_CAUSE Cause
            )
{
    
    LOG((TL_TRACE, "put_Cause[%p] - enter. Cause = [%x]", this, Cause));
  

    //
    // keep the value
    //

    m_ftecEventCause = Cause;

    
    LOG((TL_TRACE, "put_Cause - finished"));

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CFileTerminalEvent::put_ErrorCode(
            IN HRESULT hrErrorCode
            )
{
    
    LOG((TL_TRACE, "put_ErrorCode[%p] - enter. hr = [%lx]", this, hrErrorCode));
  

    //
    // keep the value
    //

    m_hr = hrErrorCode;

    
    LOG((TL_TRACE, "put_ErrorCode - finished"));

    return S_OK;
}


HRESULT CToneTerminalEvent::FireEvent(
                                     CTAPI * pTapi,
                                     ITCallInfo *pCall,
                                     ITTerminal  * pTerminal,
                                     HRESULT hrErrorCode
                                     )
{

    STATICLOG((TL_TRACE, "FireEvent - enter" ));


    CCall *pCCall = NULL;

    pCCall = dynamic_cast<CComObject<CCall>*>(pCall);
    
    if (NULL == pCCall)
    {
        STATICLOG((TL_ERROR, "FireEvent - bad call pointer" ));
        return E_FAIL;
    }

    if( pCCall->DontExpose())
    {
        STATICLOG((TL_INFO, "FireEvent - Don't expose this call %p", pCCall));
        return S_OK;
    }

    if (NULL == pTapi)
    {
        STATICLOG((TL_ERROR, "FireEvent - tapi object is NULL" ));
        return E_POINTER;
    }


    //
    // create the event object
    //

    HRESULT hr = E_FAIL;

    CComObject<CToneTerminalEvent> *p;

    hr = CComObject<CToneTerminalEvent>::CreateInstance( &p );

    if (FAILED(hr))
    {
        STATICLOG((TL_ERROR, "FireEvent - could not createinstance" ));
        return E_OUTOFMEMORY;
    }


    //
    // save event information to the event object
    //

    hr = p->put_Call(pCall);
    if (FAILED(hr))
    {
        STATICLOG((TL_ERROR, "FireEvent - put_Call failed" ));

        delete p;
        return hr;
    }

    hr = p->put_Terminal(pTerminal);
    if (FAILED(hr))
    {
        STATICLOG((TL_ERROR, "FireEvent - put_Terminal failed" ));

        delete p;
        return hr;
    }


    hr = p->put_ErrorCode(hrErrorCode);
    if (FAILED(hr))
    {
        STATICLOG((TL_ERROR, "FireEvent - put_ErrorCode failed" ));

        delete p;
        return hr;
    }


    //
    // get the dispatch interface
    //

    IDispatch *pDisp = NULL;

    hr = p->_InternalQueryInterface( IID_IDispatch, (void **)&pDisp );

    if (FAILED(hr))
    {
        delete p;
        STATICLOG((TL_ERROR, "FireEvent - could not get IDispatch %lx", hr));

        return hr;
    }

    
    //
    // fire the event
    //

    pTapi->Event(
                 TE_TONETERMINAL,
                 pDisp
                );


    //
    // release our reference
    //
    pDisp->Release();
    
    STATICLOG((TL_TRACE, "FireEvent - exit - returing SUCCESS" ));

    
    return S_OK;
}


CToneTerminalEvent::CToneTerminalEvent()
    :m_pCallInfo(NULL),
    m_pTerminal(NULL),
    m_hr(S_OK)
{
    LOG((TL_TRACE, "CToneTerminalEvent[%p] - enter", this));
    
    LOG((TL_TRACE, "CToneTerminalEvent - finish"));
}


CToneTerminalEvent::~CToneTerminalEvent()
{
    LOG((TL_TRACE, "~CToneTerminalEvent[%p] - enter", this));

 
    //
    // remember to release all the references we may hold
    //

    if (NULL != m_pCallInfo)
    {
        LOG((TL_INFO, "~CToneTerminalEvent - releasing m_pCallInfo %p", m_pCallInfo));

        m_pCallInfo->Release();
        m_pCallInfo = NULL;
    }


    if ( NULL != m_pTerminal) 
    {
        LOG((TL_INFO, "~CToneTerminalEvent - releasing m_pTerminal %p", m_pTerminal));

        m_pTerminal->Release();
        m_pTerminal = NULL;
    }


    LOG((TL_TRACE, "~CToneTerminalEvent - finish"));
}



HRESULT STDMETHODCALLTYPE CToneTerminalEvent::get_Call(
        OUT ITCallInfo **ppCallInfo
        )
{
    LOG((TL_TRACE, "get_Call[%p] - enter", this));


    //
    // check arguments
    //

    if (TAPIIsBadWritePtr(ppCallInfo, sizeof(ITCallInfo *)))
    {
        LOG((TL_ERROR, "get_Call - bad pointer passed in"));

        return E_POINTER;
    }

    
    //
    // no garbage out
    //

    *ppCallInfo = NULL;


    //
    // return call info if we have it
    //

    if (NULL != m_pCallInfo)
    {

        *ppCallInfo = m_pCallInfo;
        (*ppCallInfo)->AddRef();
    }


    LOG((TL_TRACE, "get_Call - finish"));

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CToneTerminalEvent::get_Terminal(
        OUT ITTerminal **ppTerminal
        )
{
    LOG((TL_TRACE, "get_Terminal[%p] - enter", this));

    
    //
    // check arguments
    //

    if (TAPIIsBadWritePtr(ppTerminal, sizeof(ITTerminal*)))
    {
        LOG((TL_ERROR, "get_Terminal - bad pointer passed in"));

        return E_POINTER;
    }

    
    //
    // no garbage out
    //

    *ppTerminal = NULL;


    //
    // return terminal if we have it
    //
    
    if (NULL != m_pTerminal)
    {

        *ppTerminal = m_pTerminal;
        (*ppTerminal)->AddRef();
    }


    LOG((TL_TRACE, "get_Terminal - finish"));

    return S_OK;
}



HRESULT STDMETHODCALLTYPE CToneTerminalEvent::get_Error(
        OUT HRESULT *phrErrorCode
        )
{
    LOG((TL_TRACE, "get_Error[%p] - enter", this));


    //
    // check arguments
    //

    if (TAPIIsBadWritePtr(phrErrorCode, sizeof(HRESULT)))
    {
        LOG((TL_ERROR, "get_Error - bad pointer passed in"));

        return E_POINTER;
    }


    //
    // return error code
    //
    
    *phrErrorCode = m_hr;


    LOG((TL_TRACE, "get_Error - finish. hr = [%lx]", m_hr));

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CToneTerminalEvent::put_Terminal(
            IN ITTerminal *pTerminal
            )
{
    LOG((TL_TRACE, "put_Terminal[%p] - enter", this));

    
    //
    // check the argument
    //

    if ((NULL != pTerminal) && IsBadReadPtr(pTerminal, sizeof(ITTerminal)))
    {
        LOG((TL_ERROR, "put_Terminal - bad pointer passed in"));


        //
        // if we get here, we have a bug. debug to see what happened.
        //

        _ASSERTE(FALSE);

        return E_POINTER;
    }

    

    //
    // keep the pointer
    //

    m_pTerminal = pTerminal;

    
    //
    // keep a reference if not null
    //

    if (NULL != m_pTerminal)
    {
        m_pTerminal->AddRef();
    }


    LOG((TL_TRACE, "put_Terminal - finished"));

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CToneTerminalEvent::put_Call(
            IN ITCallInfo *pCallInfo
            )
{
    LOG((TL_TRACE, "put_Call[%p] - enter", this));

    
    //
    // check the argument
    //

    if ((NULL != pCallInfo) && IsBadReadPtr(pCallInfo, sizeof(ITCallInfo)))
    {
        LOG((TL_ERROR, "put_Call - bad pointer passed in"));


        //
        // if we get here, we have a bug. debug to see what happened.
        //

        _ASSERTE(FALSE);

        return E_POINTER;
    }

    

    //
    // keep the pointer
    //

    m_pCallInfo = pCallInfo;

    
    //
    // keep a reference if not null
    //

    if (NULL != m_pCallInfo)
    {
        m_pCallInfo->AddRef();
    }


    LOG((TL_TRACE, "put_Call - finished"));

    return S_OK;
}



HRESULT STDMETHODCALLTYPE CToneTerminalEvent::put_ErrorCode(
            IN HRESULT hrErrorCode
            )
{
    
    LOG((TL_TRACE, "put_ErrorCode[%p] - enter. hr = [%lx]", this, hrErrorCode));
  

    //
    // keep the value
    //

    m_hr = hrErrorCode;

    
    LOG((TL_TRACE, "put_ErrorCode - finished"));

    return S_OK;
}



HRESULT CTTSTerminalEvent::FireEvent(
                                     CTAPI * pTapi,
                                     ITCallInfo *pCall,
                                     ITTerminal  * pTerminal,
                                     HRESULT hrErrorCode
                                     )
{

    STATICLOG((TL_TRACE, "FireEvent - enter" ));


    CCall *pCCall = NULL;

    pCCall = dynamic_cast<CComObject<CCall>*>(pCall);
    
    if (NULL == pCCall)
    {
        STATICLOG((TL_ERROR, "FireEvent - bad call pointer" ));
        return E_FAIL;
    }

    if( pCCall->DontExpose())
    {
        STATICLOG((TL_INFO, "FireEvent - Don't expose this call %p", pCCall));
        return S_OK;
    }

    if (NULL == pTapi)
    {
        STATICLOG((TL_ERROR, "FireEvent - tapi object is NULL" ));
        return E_POINTER;
    }


    //
    // create the event object
    //

    HRESULT hr = E_FAIL;

    CComObject<CTTSTerminalEvent> *p;

    hr = CComObject<CTTSTerminalEvent>::CreateInstance( &p );

    if (FAILED(hr))
    {
        STATICLOG((TL_ERROR, "FireEvent - could not createinstance" ));
        return E_OUTOFMEMORY;
    }


    //
    // save event information to the event object
    //

    hr = p->put_Call(pCall);
    if (FAILED(hr))
    {
        STATICLOG((TL_ERROR, "FireEvent - put_Call failed" ));

        delete p;
        return hr;
    }

    hr = p->put_Terminal(pTerminal);
    if (FAILED(hr))
    {
        STATICLOG((TL_ERROR, "FireEvent - put_Terminal failed" ));

        delete p;
        return hr;
    }


    hr = p->put_ErrorCode(hrErrorCode);
    if (FAILED(hr))
    {
        STATICLOG((TL_ERROR, "FireEvent - put_ErrorCode failed" ));

        delete p;
        return hr;
    }


    //
    // get the dispatch interface
    //

    IDispatch *pDisp = NULL;

    hr = p->_InternalQueryInterface( IID_IDispatch, (void **)&pDisp );

    if (FAILED(hr))
    {
        delete p;
        STATICLOG((TL_ERROR, "FireEvent - could not get IDispatch %lx", hr));

        return hr;
    }

    
    //
    // fire the event
    //

    pTapi->Event(
                 TE_TTSTERMINAL,
                 pDisp
                );


    //
    // release our reference
    //
    pDisp->Release();
    
    STATICLOG((TL_TRACE, "FireEvent - exit - returing SUCCESS" ));

    
    return S_OK;
}


CTTSTerminalEvent::CTTSTerminalEvent()
    :m_pCallInfo(NULL),
    m_pTerminal(NULL),
    m_hr(S_OK)
{
    LOG((TL_TRACE, "CTTSTerminalEvent[%p] - enter", this));
    
    LOG((TL_TRACE, "CTTSTerminalEvent - finish"));
}


CTTSTerminalEvent::~CTTSTerminalEvent()
{
    LOG((TL_TRACE, "~CTTSTerminalEvent[%p] - enter", this));

 
    //
    // remember to release all the references we may hold
    //

    if (NULL != m_pCallInfo)
    {
        LOG((TL_INFO, "~CTTSTerminalEvent - releasing m_pCallInfo %p", m_pCallInfo));

        m_pCallInfo->Release();
        m_pCallInfo = NULL;
    }


    if ( NULL != m_pTerminal) 
    {
        LOG((TL_INFO, "~CTTSTerminalEvent - releasing m_pTerminal %p", m_pTerminal));

        m_pTerminal->Release();
        m_pTerminal = NULL;
    }


    LOG((TL_TRACE, "~CTTSTerminalEvent - finish"));
}



HRESULT STDMETHODCALLTYPE CTTSTerminalEvent::get_Call(
        OUT ITCallInfo **ppCallInfo
        )
{
    LOG((TL_TRACE, "get_Call[%p] - enter", this));


    //
    // check arguments
    //

    if (TAPIIsBadWritePtr(ppCallInfo, sizeof(ITCallInfo *)))
    {
        LOG((TL_ERROR, "get_Call - bad pointer passed in"));

        return E_POINTER;
    }

    
    //
    // no garbage out
    //

    *ppCallInfo = NULL;


    //
    // return call info if we have it
    //

    if (NULL != m_pCallInfo)
    {

        *ppCallInfo = m_pCallInfo;
        (*ppCallInfo)->AddRef();
    }


    LOG((TL_TRACE, "get_Call - finish"));

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CTTSTerminalEvent::get_Terminal(
        OUT ITTerminal **ppTerminal
        )
{
    LOG((TL_TRACE, "get_Terminal[%p] - enter", this));

    
    //
    // check arguments
    //

    if (TAPIIsBadWritePtr(ppTerminal, sizeof(ITTerminal*)))
    {
        LOG((TL_ERROR, "get_Terminal - bad pointer passed in"));

        return E_POINTER;
    }

    
    //
    // no garbage out
    //

    *ppTerminal = NULL;


    //
    // return terminal if we have it
    //
    
    if (NULL != m_pTerminal)
    {

        *ppTerminal = m_pTerminal;
        (*ppTerminal)->AddRef();
    }


    LOG((TL_TRACE, "get_Terminal - finish"));

    return S_OK;
}



HRESULT STDMETHODCALLTYPE CTTSTerminalEvent::get_Error(
        OUT HRESULT *phrErrorCode
        )
{
    LOG((TL_TRACE, "get_Error[%p] - enter", this));


    //
    // check arguments
    //

    if (TAPIIsBadWritePtr(phrErrorCode, sizeof(HRESULT)))
    {
        LOG((TL_ERROR, "get_Error - bad pointer passed in"));

        return E_POINTER;
    }


    //
    // return error code
    //
    
    *phrErrorCode = m_hr;


    LOG((TL_TRACE, "get_Error - finish. hr = [%lx]", m_hr));

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CTTSTerminalEvent::put_Terminal(
            IN ITTerminal *pTerminal
            )
{
    LOG((TL_TRACE, "put_Terminal[%p] - enter", this));

    
    //
    // check the argument
    //

    if ((NULL != pTerminal) && IsBadReadPtr(pTerminal, sizeof(ITTerminal)))
    {
        LOG((TL_ERROR, "put_Terminal - bad pointer passed in"));


        //
        // if we get here, we have a bug. debug to see what happened.
        //

        _ASSERTE(FALSE);

        return E_POINTER;
    }

    

    //
    // keep the pointer
    //

    m_pTerminal = pTerminal;

    
    //
    // keep a reference if not null
    //

    if (NULL != m_pTerminal)
    {
        m_pTerminal->AddRef();
    }


    LOG((TL_TRACE, "put_Terminal - finished"));

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CTTSTerminalEvent::put_Call(
            IN ITCallInfo *pCallInfo
            )
{
    LOG((TL_TRACE, "put_Call[%p] - enter", this));

    
    //
    // check the argument
    //

    if ((NULL != pCallInfo) && IsBadReadPtr(pCallInfo, sizeof(ITCallInfo)))
    {
        LOG((TL_ERROR, "put_Call - bad pointer passed in"));


        //
        // if we get here, we have a bug. debug to see what happened.
        //

        _ASSERTE(FALSE);

        return E_POINTER;
    }

    

    //
    // keep the pointer
    //

    m_pCallInfo = pCallInfo;

    
    //
    // keep a reference if not null
    //

    if (NULL != m_pCallInfo)
    {
        m_pCallInfo->AddRef();
    }


    LOG((TL_TRACE, "put_Call - finished"));

    return S_OK;
}



HRESULT STDMETHODCALLTYPE CTTSTerminalEvent::put_ErrorCode(
            IN HRESULT hrErrorCode
            )
{
    
	LOG((TL_TRACE, "put_ErrorCode[%p] - enter. hr = [%lx]", this, hrErrorCode));
  

    //
    // keep the value
    //

    m_hr = hrErrorCode;

    
    LOG((TL_TRACE, "put_ErrorCode - finished"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\tapi3\waves.cpp ===
//
// Copyright (c) 1995-2000  Microsoft Corporation
//
// Waves.cpp
//

#include "stdafx.h"

BOOL DSParseWaveResource(void *pvRes, WAVEFORMATEX **ppWaveHeader, BYTE ** ppbWaveData, DWORD *pdwWaveSize);
static const char c_szWAV[] = "WAVE";

///////////////////////////////////////////////////////////////////////////////
//
// DSGetWaveResource
//
///////////////////////////////////////////////////////////////////////////////

BOOL DSGetWaveResource(HMODULE hModule, LPCTSTR lpName,
    WAVEFORMATEX **ppWaveHeader, BYTE **ppbWaveData, DWORD *pcbWaveSize)
{
    HRSRC hResInfo;
    HGLOBAL hResData;
    void *pvRes;

    if (((hResInfo = FindResource(hModule, lpName, c_szWAV)) != NULL) &&
        ((hResData = LoadResource(hModule, hResInfo)) != NULL) &&
        ((pvRes = LockResource(hResData)) != NULL) &&
        DSParseWaveResource(pvRes, ppWaveHeader, ppbWaveData, pcbWaveSize))
    {
        return TRUE;
    }

    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

BOOL DSParseWaveResource(void *pvRes, WAVEFORMATEX **ppWaveHeader, BYTE **
ppbWaveData,DWORD *pcbWaveSize)
{
    DWORD *pdw;
    DWORD *pdwEnd;
    DWORD dwRiff;
    DWORD dwType;
    DWORD dwLength;

    if (ppWaveHeader)
    {
        *ppWaveHeader = NULL;
    }

    if (ppbWaveData)
    {
        *ppbWaveData = NULL;
    }

    if (pcbWaveSize)
    {
        *pcbWaveSize = 0;
    }

    pdw = (DWORD *)pvRes;
    dwRiff = *pdw++;
    dwLength = *pdw++;
    dwType = *pdw++;

    if (dwRiff != mmioFOURCC('R', 'I', 'F', 'F'))
        goto exit;      // not even RIFF

    if (dwType != mmioFOURCC('W', 'A', 'V', 'E'))
        goto exit;      // not a WAV

    pdwEnd = (DWORD *)((BYTE *)pdw + dwLength-4);

    while (pdw < pdwEnd)
    {
        dwType = *pdw++;
        dwLength = *pdw++;

        switch (dwType)
        {
        case mmioFOURCC('f', 'm', 't', ' '):
            if (ppWaveHeader && !*ppWaveHeader)
            {
                if (dwLength < sizeof(WAVEFORMAT))
                {
                    goto exit;      // not a WAV
                }

                *ppWaveHeader = (WAVEFORMATEX *)pdw;

                if ((!ppbWaveData || *ppbWaveData) &&
                    (!pcbWaveSize || *pcbWaveSize))
                {
                    return TRUE;
                }
            }
            break;

        case mmioFOURCC('d', 'a', 't', 'a'):
            if ((ppbWaveData && !*ppbWaveData) ||
                (pcbWaveSize && !*pcbWaveSize))
            {
                if (ppbWaveData)
                {
                    *ppbWaveData = (LPBYTE)pdw;
                }

                if (pcbWaveSize)
                {
                    *pcbWaveSize = dwLength;
                }

                if (!ppWaveHeader || *ppWaveHeader)
                {
                    return TRUE;
                }
            }
            break;
        }

        pdw = (DWORD *)((BYTE *)pdw + ((dwLength+1)&~1));
    }

exit:
    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
//

CWavePlayer::CWavePlayer()
{
    m_hWaveOutTone = NULL;
    m_hWaveOutRing = NULL;
    m_hMixer = NULL;
    m_fInitialized = FALSE;

    memset(m_fPlaying, 0, NUM_TONES * sizeof(BOOL));
    m_lCurrentTone = -1;
}

//////////////////////////////////////////////////////////////////////////////
//

CWavePlayer::~CWavePlayer()
{
    //
    // We should have closed the wave device by now.
    //

    if ( m_fInitialized == TRUE )
    {
        _ASSERTE( m_hWaveOutTone == NULL );
        _ASSERTE( m_hWaveOutRing == NULL );
        _ASSERTE( m_hMixer == NULL );
    }
}

//////////////////////////////////////////////////////////////////////////////
//

HRESULT CWavePlayer::Initialize(void)
{
    int i;

    //
    // It's wasteful to initialize twice, but it won't break anything.
    //

    _ASSERTE( m_fInitialized == FALSE );

    //
    // Read all wave data resources.
    // We ignore the size and the wave header -- since these are our own
    // resources, we do not expect any surprises.
    //

    BOOL fResult;

    //
    // For each wave
    //

    for ( i = 0; i < NUM_WAVES; i ++ )
    {
        //
        // Read the wave resource for this tone.
        //

       fResult = DSGetWaveResource(
            _Module.GetModuleInstance(), // HMODULE hModule,
            (LPCTSTR)IDR_WAV_DTMF0 + i,  // LPCTSTR lpName,
            NULL,                        // WAVEFORMATEX **ppWaveHeader,
            &m_lpWaveform[i],            // BYTE **ppbWaveData,
            &m_dwWaveformSize[i]         // DWORD *pcbWaveSize
            );

        if ( fResult == FALSE )
        { 
            return E_FAIL;
        }
    }

    //
    // We can now go ahead with the other methods.
    //

    m_fInitialized = TRUE;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//

HRESULT CWavePlayer::StartTone(
    long lTone
    )
{
    MMRESULT mmresult;
    HRESULT hr;

    if ( lTone < 0 )
    {
        _ASSERTE( FALSE );
        return E_UNEXPECTED;
    }

    if ( lTone > NUM_TONES )
    {
        _ASSERTE( FALSE );
        return E_UNEXPECTED;
    }

    if ( m_fInitialized == FALSE )
    {
        _ASSERTE( FALSE );
        return E_UNEXPECTED;
    }

    if ( m_hWaveOutTone == NULL )
    {
        _ASSERTE( FALSE );
        return E_UNEXPECTED;
    }
     
    m_fPlaying[lTone] = TRUE;

    hr = ChangeTone();

    if ( FAILED( hr ) )
    {
        m_fPlaying[lTone] = FALSE;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//

HRESULT CWavePlayer::StopTone(
    long lTone
    )
{
    if ( lTone < 0 )
    {
        _ASSERTE( FALSE );
        return E_UNEXPECTED;
    }

    if ( lTone > NUM_TONES )
    {
        _ASSERTE( FALSE );
        return E_UNEXPECTED;
    }

    if ( m_fInitialized == FALSE )
    {
        _ASSERTE( FALSE );
        return E_UNEXPECTED;
    }

    if ( m_hWaveOutTone == NULL )
    {
        _ASSERTE( FALSE );
        return E_UNEXPECTED;
    }

    m_fPlaying[lTone] = FALSE;

    return ChangeTone();
}

//////////////////////////////////////////////////////////////////////////////
//

HRESULT CWavePlayer::ChangeTone()
{
    MMRESULT mmresult;

    for (int i=0; i < NUM_TONES; i++)
    {
        if (m_fPlaying[i])
        {
            //
            // If already playing it, just return
            //

            if (m_lCurrentTone == i)
            {
                return S_OK;
            }

            //
            // Reset the wave device to flush out any pending buffers.
            //

            mmresult = waveOutReset( m_hWaveOutTone );

            if ( mmresult != MMSYSERR_NOERROR )
            {
                return E_FAIL;
            }

            //
            // Construct a wave header structure that will indicate what to play
            // in waveOutWrite.
            //
 
            ZeroMemory( & m_WaveHeaderTone, sizeof( m_WaveHeaderTone ) );

            m_WaveHeaderTone.lpData          = (LPSTR)m_lpWaveform[i];
            m_WaveHeaderTone.dwBufferLength  = m_dwWaveformSize[i];
            m_WaveHeaderTone.dwFlags         = WHDR_BEGINLOOP | WHDR_ENDLOOP;
            m_WaveHeaderTone.dwLoops         = (DWORD) -1;

            //
            // Submit the data to the wave device. The wave header indicated that
            // we want to loop. Need to prepare the header first, but it can
            // only be prepared after the device has been opened.
            //

            mmresult = waveOutPrepareHeader(m_hWaveOutTone,
                                            & m_WaveHeaderTone,
                                            sizeof(WAVEHDR)
                                            );

            if ( mmresult != MMSYSERR_NOERROR )
            {
                m_lCurrentTone = -1;

                return E_FAIL;
            }

            mmresult = waveOutWrite(m_hWaveOutTone,
                                    & m_WaveHeaderTone,
                                    sizeof(WAVEHDR)
                                    );

            if ( mmresult != MMSYSERR_NOERROR )
            {
                m_lCurrentTone = -1;

                return E_FAIL;
            }

            m_lCurrentTone = i;

            return S_OK;
        }
    }

    //
    // Stop the tone
    //

    if ( m_lCurrentTone != -1 )
    {
        mmresult = waveOutReset( m_hWaveOutTone );

        if ( mmresult != MMSYSERR_NOERROR )
        {
            return E_FAIL;
        }

        m_lCurrentTone = -1;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//

BOOL CWavePlayer::PlayingTone(
    long lTone
    )
{
    if ( lTone < 0 )
    {
        _ASSERTE( FALSE );
        return FALSE;
    }

    if ( lTone > NUM_TONES )
    {
        _ASSERTE( FALSE );
        return FALSE;
    }

    return m_fPlaying[lTone];
}


//////////////////////////////////////////////////////////////////////////////
//

HRESULT CWavePlayer::StartRing()
{
    MMRESULT mmresult;

    if ( m_fInitialized == FALSE )
    {
        _ASSERTE( FALSE );
        return E_UNEXPECTED;
    }

    if ( m_hWaveOutRing == NULL )
    {
        _ASSERTE( FALSE );
        return E_UNEXPECTED;
    }
     
    //
    // Reset the wave device to flush out any pending buffers.
    //

    mmresult = waveOutReset( m_hWaveOutRing );

    if ( mmresult != MMSYSERR_NOERROR )
    {
        return E_FAIL;
    }

    //
    // Construct a wave header structure that will indicate what to play
    // in waveOutWrite.
    //
 
    ZeroMemory( & m_WaveHeaderRing, sizeof( m_WaveHeaderRing ) );

    m_WaveHeaderRing.lpData          = (LPSTR)m_lpWaveform[NUM_WAVES-1];
    m_WaveHeaderRing.dwBufferLength  = m_dwWaveformSize[NUM_WAVES-1];
    m_WaveHeaderRing.dwFlags         = 0;
    m_WaveHeaderRing.dwLoops         = (DWORD) 0;

    //
    // Submit the data to the wave device. The wave header indicated that
    // we want to loop. Need to prepare the header first, but it can
    // only be prepared after the device has been opened.
    //

    mmresult = waveOutPrepareHeader(m_hWaveOutRing,
                                    & m_WaveHeaderRing,
                                    sizeof(WAVEHDR)
                                    );

    if ( mmresult != MMSYSERR_NOERROR )
    {
        return E_FAIL;
    }

    mmresult = waveOutWrite(m_hWaveOutRing,
                            & m_WaveHeaderRing,
                            sizeof(WAVEHDR)
                            );

    if ( mmresult != MMSYSERR_NOERROR )
    {
        return E_FAIL;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//

HRESULT CWavePlayer::StopRing( void )
{
    MMRESULT mmresult;

    if ( m_fInitialized == FALSE )
    {
        _ASSERTE( FALSE );
        return E_UNEXPECTED;
    }

    if ( m_hWaveOutRing == NULL )
    {
        _ASSERTE( FALSE );
        return E_UNEXPECTED;
    }

    mmresult = waveOutReset( m_hWaveOutRing );

    if ( mmresult != MMSYSERR_NOERROR )
    {
        return E_FAIL;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//

HRESULT CWavePlayer::OpenWaveDeviceForTone(
    long lWaveID
    )
{
    MMRESULT mmresult; 

    if ( m_fInitialized == FALSE )
    {
        _ASSERTE( FALSE );
        return E_UNEXPECTED;
    }

    //
    // We expect that the wave device will not be opened twice. This is
    // dependent on the calling code.
    //

    _ASSERTE( m_hWaveOutTone == NULL );

    //
    // Open the wave device. Here we specify a hard-coded audio format.
    //

    WAVEFORMATEX waveFormat;

    waveFormat.wFormatTag      = WAVE_FORMAT_PCM; // linear PCM
    waveFormat.nChannels       = 1;               // mono
    waveFormat.nSamplesPerSec  = 8000;            // 8 KHz
    waveFormat.wBitsPerSample  = 16;              // 16-bit samples
    waveFormat.nBlockAlign     = waveFormat.nChannels * waveFormat.wBitsPerSample / 8;
    waveFormat.nAvgBytesPerSec = waveFormat.nSamplesPerSec *  waveFormat.nBlockAlign;
    waveFormat.cbSize          = 0;               // no extra format info

    mmresult = waveOutOpen(& m_hWaveOutTone,        // returned handle
                           lWaveID,             // which device to use
                           &waveFormat,         // wave format to use
                           0,                   // callback function pointer
                           0,                   // callback instance data
                           WAVE_FORMAT_DIRECT   // we don't want ACM
                           );

    if ( mmresult != MMSYSERR_NOERROR )
    {
        m_hWaveOutTone = NULL;
        return E_FAIL;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//

HRESULT CWavePlayer::OpenWaveDeviceForRing(
    long lWaveID
    )
{
    MMRESULT mmresult; 

    if ( m_fInitialized == FALSE )
    {
        _ASSERTE( FALSE );
        return E_UNEXPECTED;
    }

    //
    // We expect that the wave device will not be opened twice. This is
    // dependent on the calling code.
    //

    _ASSERTE( m_hWaveOutRing == NULL );

    //
    // Open the wave device. Here we specify a hard-coded audio format.
    //

    WAVEFORMATEX waveFormat;

    waveFormat.wFormatTag      = WAVE_FORMAT_PCM; // linear PCM
    waveFormat.nChannels       = 1;               // mono
    waveFormat.nSamplesPerSec  = 8000;            // 8 KHz
    waveFormat.wBitsPerSample  = 16;              // 16-bit samples
    waveFormat.nBlockAlign     = waveFormat.nChannels * waveFormat.wBitsPerSample / 8;
    waveFormat.nAvgBytesPerSec = waveFormat.nSamplesPerSec *  waveFormat.nBlockAlign;
    waveFormat.cbSize          = 0;               // no extra format info

    mmresult = waveOutOpen(& m_hWaveOutRing,        // returned handle
                           lWaveID,             // which device to use
                           &waveFormat,         // wave format to use
                           0,                   // callback function pointer
                           0,                   // callback instance data
                           WAVE_FORMAT_DIRECT   // we don't want ACM
                           );

    if ( mmresult != MMSYSERR_NOERROR )
    {
        m_hWaveOutRing = NULL;
        return E_FAIL;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//

void CWavePlayer::CloseWaveDeviceForTone(void)
{
    if ( m_fInitialized == FALSE )
    {
        _ASSERTE( FALSE );
    }

    if ( m_hWaveOutTone != NULL )
    {
        waveOutReset( m_hWaveOutTone );

        memset(m_fPlaying, 0, NUM_TONES * sizeof(BOOL));
        m_lCurrentTone = -1;

        waveOutClose( m_hWaveOutTone );

        m_hWaveOutTone = NULL;
    }
}

//////////////////////////////////////////////////////////////////////////////
//

void CWavePlayer::CloseWaveDeviceForRing(void)
{
    if ( m_fInitialized == FALSE )
    {
        _ASSERTE( FALSE );
    }

    if ( m_hWaveOutRing != NULL )
    {
        waveOutReset( m_hWaveOutRing );

        waveOutClose( m_hWaveOutRing );

        m_hWaveOutRing = NULL;
    }
}


//////////////////////////////////////////////////////////////////////////////
//

HRESULT CWavePlayer::OpenMixerDevice(
    long lWaveID
    )
{
    MMRESULT mmresult;
    MIXERLINECONTROLS mxlc;

    mmresult = mixerOpen( &m_hMixer, lWaveID, 0, 0, MIXER_OBJECTF_WAVEOUT);

    if ( mmresult != MMSYSERR_NOERROR )
    {
        m_hMixer = NULL;
        return E_FAIL;
    }

    mxlc.cbStruct = sizeof(MIXERLINECONTROLS);
    mxlc.dwLineID = 0;
    mxlc.dwControlType = MIXERCONTROL_CONTROLTYPE_VOLUME;
    mxlc.pamxctrl = &m_mxctrl;
    mxlc.cbmxctrl = sizeof(m_mxctrl);

    mmresult = mixerGetLineControls( (HMIXEROBJ)m_hMixer, &mxlc, MIXER_GETLINECONTROLSF_ONEBYTYPE );

    if ( mmresult != MMSYSERR_NOERROR )
    {
        //
        // Close the mixer
        //

        mixerClose( m_hMixer );
        m_hMixer = NULL;

        return E_FAIL;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//

void CWavePlayer::CloseMixerDevice(void)
{
    if ( m_hMixer != NULL )
    {
        mixerClose( m_hMixer );

        m_hMixer = NULL;
    }
}

//////////////////////////////////////////////////////////////////////////////
//

HRESULT CWavePla