)
#define      _AMRTPSS_TEMPLATE_H_

#define AMRTP_SILENCE_SUPRESSOR        L"PCM Silence Suppressor"
#define AMRTP_SILENCE_SUPRESSOR_PROP   L"PCM Silence Suppressor Properties"

#define CFT_AMRTPSS_SILENCE_SUPRESSOR \
{ \
	  AMRTP_SILENCE_SUPRESSOR, \
	  &CLSID_SilenceSuppressionFilter, \
	  CSilenceSuppressor::CreateInstance, \
	  NULL, \
	  &sudSilence \
	  }

#define CFT_AMRTPSS_SILENCE_SUPRESSOR_PROP \
{ \
	  AMRTP_SILENCE_SUPRESSOR_PROP, \
	  &CLSID_SilenceSuppressionProperties, \
	  CSilenceProperties::CreateInstance \
	  }

#define CFT_AMRTPSS_ALL_FILTERS \
CFT_AMRTPSS_SILENCE_SUPRESSOR, \
CFT_AMRTPSS_SILENCE_SUPRESSOR_PROP

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpss\silence.cpp ===
//
// silence.cpp - Copyright (C) Microsoft Corporation, 1996 - 1999
//

#include <streams.h>
#if !defined(AMRTPSS_IN_DXMRTP)
#include <initguid.h>
#endif
#include "amrtpss.h"
#include "siprop.h"

#include <silence.h>
#include <math.h>

#include "template.h"

///////////////////////////////////////////////////////////////////////////////
//=============================================================================
// setup data
//=============================================================================
///////////////////////////////////////////////////////////////////////////////

const AMOVIESETUP_MEDIATYPE sudPinTypes =   
{ 
    &MEDIATYPE_Audio         // clsMajorType
  , &MEDIASUBTYPE_WAVE
};     // clsMinorType  /BUGBUG

const AMOVIESETUP_PIN psudPins[] = 
{ 
    { 
         L"Input"            // strName
       , FALSE               // bRendered
       , FALSE               // bOutput
       , FALSE               // bZero
       , FALSE               // bMany
       , &CLSID_NULL         // clsConnectsToFilter
       , L"Output"           // strConnectsToPin
       , 1                   // nTypes
       , &sudPinTypes 
    }      // lpTypes
     , 
    { 
         L"Output"           // strName
       , FALSE               // bRendered
       , TRUE                // bOutput
       , FALSE               // bZero
       , FALSE               // bMany
       , &CLSID_NULL         // clsConnectsToFilter
       , L"Input"            // strConnectsToPin
       , 1                   // nTypes
       , &sudPinTypes 
     } 
};   // lpTypes


AMOVIESETUP_FILTER sudSilence = 
{ 
    &CLSID_SilenceSuppressionFilter // clsID
    , L"PCM Silence Suppressor"       // strName
    , MERIT_DO_NOT_USE                // dwMerit
    , 2                               // nPins
    , psudPins 
};                     // lpPin

//
// Needed for the CreateInstance mechanism
//
#if !defined(AMRTPSS_IN_DXMRTP)
CFactoryTemplate g_Templates[]=
{
    CFT_AMRTPSS_ALL_FILTERS
};
int g_cTemplates = sizeof(g_Templates)/sizeof(g_Templates[0]);
#endif

///////////////////////////////////////////////////////////////////////////////
//=============================================================================
// CSilenceSuppressor class implementation
//=============================================================================
///////////////////////////////////////////////////////////////////////////////

//
// c'tor
//
CSilenceSuppressor::CSilenceSuppressor(
    TCHAR *tszName, 
    LPUNKNOWN punk, 
    HRESULT *phr
    )
    : CTransInPlaceFilter(tszName, punk, CLSID_SilenceSuppressionFilter, phr)
    , CPersistStream(punk, phr)
{
    //
    // Property defaults
    //
    
    // the time to play after a word to catch pauses between words.
    m_dwPostPlayTime            = 30;     // tenths of a second

    // the time adapt the threshold after playing for a while.
    m_dwKeepPlayTime            = 5;     // tenths of a second

    // tenths of a percent of highest possible peak.
    m_dwThresholdIncPercent     = 5;
    m_dwBaseThresholdPercent    = 35;
    m_dwMaxThresholdPercent     = 300;

    // if the PCM sample is bigger than 95% of the MAX, it is highly probable
    // that it is clipped.
    m_dwClipThresholdPercent    = 950;

    m_dwLastEventTime           = 0;
    m_dwEventInterval           = 2000;   // 2 seconds.

    // if 40% of the sample are clipped, we need to adjust the gain.
    m_dwClipCountThresholdPercent   = 40;
    m_dwGainAdjustmentPercent       = 5;


#ifdef PERF
    RegisterPerfId();
#endif // PERF

}

//
// d'tor
//
CSilenceSuppressor::~CSilenceSuppressor()
{
#ifdef PERF
    HANDLE hFile;
    
    hFile = CreateFile(
        TEXT("c:\\temp\\ssperf.log"), 
        GENERIC_WRITE, 
        0, 
        NULL, 
        CREATE_ALWAYS, 
        0,
        NULL);

    Msr_Dump(hFile);           // This writes the log out to the file
    CloseHandle(hFile);
#endif // PERF
}

//
// CreateInstance - Provide the way for COM to create a 
//  CSilenceSuppressor object.
//
CUnknown * CALLBACK CSilenceSuppressor::CreateInstance(
    LPUNKNOWN punk, 
    HRESULT *phr
    )
{
    CSilenceSuppressor *pNewObject = 
        new CSilenceSuppressor(
            NAME("PCM Silence Suppression Filter"), 
            punk, 
            phr 
            );

    if (pNewObject == NULL)
    {
        *phr = E_OUTOFMEMORY;
    }

    return pNewObject;

}

//
// NonDelegatingQueryInterface - Reveal our property page, 
//  persistence, and control interfaces
//
STDMETHODIMP CSilenceSuppressor::NonDelegatingQueryInterface(
    REFIID riid, 
    void **ppv
    )
{
    CheckPointer(ppv,E_POINTER);
    //CAutoLock l(&m_cStateLock);

    if (riid == IID_ISilenceSuppressor)
    {
        return GetInterface((ISilenceSuppressor *) this, ppv);
    }
    else if (riid == IID_IPersistStream)
    {
        return GetInterface((IPersistStream *) this, ppv);
    }
    else if (riid == IID_ISpecifyPropertyPages)
    {
        return GetInterface((ISpecifyPropertyPages *) this, ppv);
    } 
    else
    {
        return CTransInPlaceFilter::NonDelegatingQueryInterface(riid, ppv);
    }
}

//
// ISilenceSuppressor - GetSet Methods
//

STDMETHODIMP CSilenceSuppressor::GetPostplayTime
    (LPDWORD lpdwPostplayBufferTime
    )
{
    CheckPointer(lpdwPostplayBufferTime, E_POINTER);
    CAutoLock cObjectLock(m_pLock);

    *lpdwPostplayBufferTime = m_dwPostPlayTime;

    DbgLog((LOG_TRACE, 1, 
        TEXT("GetPostplayBufferTime() Called with %d"), m_dwPostPlayTime));
    return NOERROR;
}

STDMETHODIMP CSilenceSuppressor::SetPostplayTime
    (DWORD dwPostplayBufferTime
    )
{
    CAutoLock cObjectLock(m_pLock);

    m_dwPostPlayTime = dwPostplayBufferTime;

    // ZCS: make sure we are saved in the persistent stream
    SetDirty(TRUE);

    DbgLog((LOG_TRACE, 1, 
        TEXT("SetPostplayBufferTime() Called with %d"), m_dwPostPlayTime));
    return NOERROR;
}

STDMETHODIMP CSilenceSuppressor::GetKeepPlayTime
    (LPDWORD lpdwKeepPlayTime
    )
{
    CheckPointer(lpdwKeepPlayTime, E_POINTER);
    CAutoLock cObjectLock(m_pLock);

    *lpdwKeepPlayTime = m_dwKeepPlayTime;

    DbgLog((LOG_TRACE, 1, 
        TEXT("GetKeepPlayTime() Called with %d"), m_dwKeepPlayTime));
    return NOERROR;
}

STDMETHODIMP CSilenceSuppressor::SetKeepPlayTime
    (DWORD dwKeepPlayTime
    )
{
    CAutoLock cObjectLock(m_pLock);

    m_dwKeepPlayTime = dwKeepPlayTime;

    // ZCS: make sure we are saved in the persistent stream
    SetDirty(TRUE);

    DbgLog((LOG_TRACE, 1, 
        TEXT("SetKeepPlayTime() Called with %d"), m_dwKeepPlayTime));
    return NOERROR;
}

STDMETHODIMP CSilenceSuppressor::GetThresholdIncrementor
    (LPDWORD lpdwThresholdIncrementor
    )
{
    CheckPointer(lpdwThresholdIncrementor, E_POINTER);
    CAutoLock cObjectLock(m_pLock);

    *lpdwThresholdIncrementor = m_dwThresholdIncPercent;

    DbgLog((LOG_TRACE, 1, 
        TEXT("GetThresholdIncrementor() Called with %d"), m_dwThresholdIncPercent));
    return NOERROR;
}

STDMETHODIMP CSilenceSuppressor::SetThresholdIncrementor
    (DWORD dwThresholdIncrementor
    )
{
    // ZCS: this is an integer percentage!
    if (dwThresholdIncrementor > 100) return E_INVALIDARG;

    CAutoLock cObjectLock(m_pLock);

    // ZCS: make sure we are saved in the persistent stream
    SetDirty(TRUE);

    m_dwThresholdIncPercent = dwThresholdIncrementor;

    DbgLog((LOG_TRACE, 1, 
        TEXT("SetThresholdIncrementor() Called with %d"), m_dwThresholdIncPercent));
    return NOERROR;
}

STDMETHODIMP CSilenceSuppressor::GetBaseThreshold
    (LPDWORD lpdwBaseThreshold
    )
{
    CheckPointer(lpdwBaseThreshold, E_POINTER);
    CAutoLock cObjectLock(m_pLock);

    *lpdwBaseThreshold = m_dwBaseThresholdPercent;

    DbgLog((LOG_TRACE, 1, 
        TEXT("GetBaseThreshold() Called with %d"), m_dwBaseThresholdPercent));
    return NOERROR;
}

STDMETHODIMP CSilenceSuppressor::SetBaseThreshold
    (DWORD dwBaseThreshold
    )
{
    // ZCS: this is an integer percentage!
    if (dwBaseThreshold > 100) return E_INVALIDARG;

    CAutoLock cObjectLock(m_pLock);

    // ZCS: make sure we are saved in the persistent stream
    SetDirty(TRUE);

    m_dwBaseThresholdPercent = dwBaseThreshold;

    DbgLog((LOG_TRACE, 1, 
        TEXT("SetBaseThreshold() Called with %d"), m_dwBaseThresholdPercent));
    return NOERROR;
}

STDMETHODIMP CSilenceSuppressor::EnableEvents(
    DWORD dwMask, 
    DWORD dwMinimumInterval
    )
{
    m_dwEventMask = dwMask;
    m_dwEventInterval = dwMinimumInterval;

    return NOERROR;
}
//
// Supply the CLSID for our property page.
//
STDMETHODIMP CSilenceSuppressor::GetPages(CAUUID * pPages)
{
    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
    if (pPages->pElems == NULL)
    {
        return E_OUTOFMEMORY;
    }
    *(pPages->pElems) = CLSID_SilenceSuppressionProperties;

    return NOERROR;
}

//
// GetSetupData - Part of the self-registration mechanism
//
LPAMOVIESETUP_FILTER CSilenceSuppressor::GetSetupData()
{
  return &sudSilence;
}

/* Override this if your state changes are not done synchronously */
// Since the property page might call this function during state
// changes, we need to override this function.
STDMETHODIMP
CSilenceSuppressor::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    UNREFERENCED_PARAMETER(dwMSecs);
    
    CheckPointer(State,E_POINTER);
    ValidateReadWritePtr(State,sizeof(FILTER_STATE));

    CAutoLock cObjectLock(m_pLock);

    *State = m_State;
    return S_OK;
}

static BOOL 
GetRegValue(
    IN  LPCTSTR szName, 
    OUT DWORD   *pdwValue
    )
/*++

Routine Description:

    Get a dword from the registry in the silence suppressor key.

Arguments:
    
    szName  - The name of the value.

    pdwValue  - a pointer to the dword returned.

Return Value:

    TURE    - SUCCEED.

    FALSE   - MSP_ERROR

--*/
{
    const TCHAR gszFilterKey[]   =
       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Silence\\");


    HKEY  hKey;
    DWORD dwDataSize, dwDataType, dwValue;

    if (::RegOpenKeyEx(
        HKEY_CURRENT_USER,
        gszFilterKey,
        0,
        KEY_READ,
        &hKey) != NOERROR)
    {
        return FALSE;
    }

    dwDataSize = sizeof(DWORD);
    if (::RegQueryValueEx(
        hKey,
        szName,
        0,
        &dwDataType,
        (LPBYTE) &dwValue,
        &dwDataSize) != NOERROR)
    {
        RegCloseKey (hKey);
        return FALSE;
    }

    *pdwValue = dwValue;

    RegCloseKey (hKey);
    
    return TRUE;
}

HRESULT CSilenceSuppressor::StartStreaming()
{
// This is the function we reinterpret all the parameters. This means all
// the setting only take effect when the stream is restarting again.

    CAutoLock cObjectLock(m_pLock);

    // reinit parameters before the stream starts.
    m_dwSampleSize = 0;

    DWORD dwMaxEnergy       = (1 << ((DWORD)(m_WaveFormatEx.wBitsPerSample - 1)));

    // convert one tenth of a percent values to dwords.
    m_dwThresholdInc        = dwMaxEnergy * m_dwThresholdIncPercent / 1000;
    m_dwBaseThreshold       = dwMaxEnergy * m_dwBaseThresholdPercent / 1000;
    m_dwClipThreshold       = dwMaxEnergy * m_dwClipThresholdPercent  / 1000;

    // the unit of m_dwMaxThresholdPercent is tenth of a percent.
    DWORD dwMaxThresholdPercend = m_dwMaxThresholdPercent / 10;
    
    // read the max threshold setting from the registry.
    GetRegValue(TEXT("MaxThreshold"), &dwMaxThresholdPercend);

    m_dwMaxThreshold    = dwMaxEnergy * dwMaxThresholdPercend  / 100;

    DbgLog((LOG_TRACE, 1, 
        TEXT("silence suppressor: max threshold %d percent"), dwMaxThresholdPercend));
    

    m_dwKeepPlayCount       = 0;
    m_dwPostPlayCount       = 0;
    m_dwThreshold           = m_dwBaseThreshold;
    m_dwSilenceAverage      = 0;

    m_dwSoundFrameCount     = 0;
    m_dwSilentFrameCount    = 0;

    m_fSuppressMode         = TRUE;
    if (m_dwEventMask & (1 << AGC_SILENCE))
    {
        NotifyEvent(AGC_EVENTBASE + AGC_SILENCE, 0, 0); 
    }


    return S_OK;
}

HRESULT CSilenceSuppressor::Statistics(
    IN  IMediaSample *  pSample,
    IN  DWORD           dwSize,
    OUT DWORD *         pdwPeak
    )
{
    //
    //  Calculate the peak energy level;
    //
    BYTE *pbData;
    if (FAILED(pSample->GetPointer(&pbData))) 
    { 
        // Stop the clock and log it (if PERF is defined)
        MSR_STOP(m_idSilence);
        return E_INVALIDARG; 
    }

    short *psData = (short*)pbData;
   
    DWORD dwPeak = 0;
    DWORD dwClipCount = 0;

    DWORD dwSampleCount = dwSize / 2; 
    for (DWORD i = 0; i < dwSampleCount; i ++)
    {
        DWORD dwPCMValue = (DWORD)abs(psData[i]);
        
        dwPeak = max(dwPeak, dwPCMValue);
        
        if (dwPCMValue > m_dwClipThreshold)
        {
            dwClipCount ++;
        }
    }

    if ((m_dwEventMask & (1 << AGC_DECREASE_GAIN)) && dwSampleCount > 0)
    {
        if (dwClipCount * 100 / dwSampleCount > m_dwClipCountThresholdPercent)
        {
            DWORD dwCurrentTime = timeGetTime();
            if (m_dwLastEventTime == 0 || 
                dwCurrentTime - m_dwLastEventTime > m_dwEventInterval)
            {
                // the gain is too high, send event to adjust the gain down.
                NotifyEvent(
                    AGC_EVENTBASE + AGC_DECREASE_GAIN, 
                    m_dwGainAdjustmentPercent, 
                    0
                    ); 
                m_dwLastEventTime = dwCurrentTime;
            }
        }
    }

    *pdwPeak = dwPeak;

    return S_OK;
}

HRESULT CSilenceSuppressor::Transform(IMediaSample *pSample)
{
// For perfomance reason, we try to avoid locking in this function.
// Since this function will only be called after StartStreaming, no member
// varialbe used in this function will be changed. It is safe to have no
// locks.  - muhan

    ASSERT(pSample != NULL);

    // Start timing the TransInPlace (if PERF is defined)
    MSR_START(m_idSilence);

    DWORD dwSize = pSample->GetActualDataLength();
    if (dwSize == 0)
    {
        // Stop the clock and log it (if PERF is defined)
        MSR_STOP(m_idSilence);

        return E_INVALIDARG;
    }

    if (m_dwSampleSize == 0)
    {
        m_dwSampleSize = dwSize;

        // The buffer sizes and running average count were specified in tenths
        // of a second; turn them into numbers of packets.
        m_dwPostPlayCount   = TimeToPackets(m_dwPostPlayTime);
        m_dwKeepPlayCount   = TimeToPackets(m_dwKeepPlayTime);
    }

    DWORD dwPeak;
    HRESULT hr = Statistics(pSample, dwSize, &dwPeak);
    if (FAILED(hr))
    {
        return hr;
    }
    
    //
    //  decide if we want to suppress the sample based on the energy level.
    //
    if (m_fSuppressMode)
    {
        //
        // We are in silent suppression mode now. If there is a sound sample,
        // the sample will be sent and the mode will be changed to non-suppress
        // mode. If there is a silence sample, it is suppressed.
        // 
        DbgLog((LOG_TRACE, 2, TEXT(" 100 %8d %8d %8d"),
            dwPeak, m_dwThreshold, m_dwSilenceAverage));

        if (dwPeak > m_dwThreshold)
        {
            // we found a sound sample
    
            m_fSuppressMode = FALSE;

            if (m_dwEventMask & (1 << AGC_TALKING))
            {
                NotifyEvent(AGC_EVENTBASE + AGC_TALKING, 0, 0); 
            }

            m_dwSilentFrameCount = 0;
            m_dwSoundFrameCount = 1;
        }
        else
        {
            // Average' = (1-1/16)Average + 1/16*Energy;
            m_dwSilenceAverage = m_dwSilenceAverage - 
                (m_dwSilenceAverage >> 4) + (dwPeak >> 4);

            m_dwThreshold  = m_dwSilenceAverage + m_dwBaseThreshold;

            // Stop the clock and log it (if PERF is defined)
            MSR_STOP(m_idSilence);
            return S_FALSE; // ::Receive DOES NOT deliver this sample
        }
    }
    else
    {
        //
        // We are in non-suppress mode now. If there is a sound sample,
        // just play it. If there are a number of continues silence, the mode
        // will be switched to suppress mode.
        // 
        DbgLog((LOG_TRACE, 2, TEXT("1000 %8d %8d %8d"),
            dwPeak, m_dwThreshold, m_dwSilenceAverage));

        if (dwPeak > m_dwThreshold)
        {
            // We keep getting sound samples.

            m_dwSilentFrameCount = 0;
            m_dwSoundFrameCount ++;

            if (m_dwSoundFrameCount > m_dwKeepPlayCount)
            {
                // Addjust the threshold when there are too many 
                // continous sound samples.
                m_dwThreshold = m_dwThreshold + m_dwThresholdInc;

                if (m_dwThreshold > m_dwMaxThreshold)
                {
                    m_dwThreshold = m_dwMaxThreshold;
                }
                m_dwSoundFrameCount = 1;
            }
        }
        else
        {
            // We got a silent sample within sound samples.
            m_dwSilentFrameCount ++;
            m_dwSoundFrameCount = 0;

            // Average' = (1-1/16)Average + 1/16*Energy;
            m_dwSilenceAverage = m_dwSilenceAverage - 
                (m_dwSilenceAverage >> 4) + (dwPeak >> 4);

            m_dwThreshold  = m_dwSilenceAverage + m_dwBaseThreshold;

            if (m_dwSilentFrameCount > m_dwPostPlayCount)
            {
                // We have got enough silent sample. 
                m_fSuppressMode = TRUE;

                if (m_dwEventMask & (1 << AGC_SILENCE))
                {
                    NotifyEvent(AGC_EVENTBASE + AGC_SILENCE, 0, 0); 
                }
            }
        }
    }

    // Stop the clock and log it (if PERF is defined)
    MSR_STOP(m_idSilence);
    return S_OK;
}

//
// Verify that we actually know how to support the data that we will be
//  passed.  Also at this point it's nice to set up some internal data.
//
HRESULT CSilenceSuppressor::CheckInputType(const CMediaType* pMediaType)
{
    //
    // Gross checks first.
    //
    if (*pMediaType->Type() != MEDIATYPE_Audio)
    {
        return E_FAIL;
    }

    //
    // Store this for later use
    //
    memcpy(&m_WaveFormatEx, pMediaType->Format(), sizeof(WAVEFORMATEX));

    //
    // Check the basic requirements

    switch (m_WaveFormatEx.wFormatTag)
    {
    // linearly scaled, so no conversion necessary
    case WAVE_FORMAT_PCM:
        DbgLog((LOG_TRACE, 1, TEXT("silence suppressor: input pin format tag is PCM")));
        break;

    // we don't know about this type, so give up.
    default:
        return E_FAIL;
    }

    if (m_WaveFormatEx.wBitsPerSample != 16)
    {
        // We only support 16bit PCM 
        return E_FAIL;
    }

    ASSERT(m_WaveFormatEx.nSamplesPerSec != 0);

    // ZCS
    DbgLog((LOG_TRACE, 1, TEXT("silence suppressor: input pin bits-per-sample is %d"),
            m_WaveFormatEx.wBitsPerSample));
    DbgLog((LOG_TRACE, 1, TEXT("silence suppressor: number of channels is %d"),
            m_WaveFormatEx.nChannels));
    DbgLog((LOG_TRACE, 1, TEXT("silence suppressor: samples per second is %d"),
            m_WaveFormatEx.nSamplesPerSec));
    DbgLog((LOG_TRACE, 1, TEXT("silence suppressor: block alignment is %d"),
            m_WaveFormatEx.nBlockAlign));
    DbgLog((LOG_TRACE, 1, TEXT("silence suppressor: average bytes per second is %d"),
            m_WaveFormatEx.nAvgBytesPerSec));
    DbgLog((LOG_TRACE, 1, TEXT("silence suppressor: cbSize is %d"),
            m_WaveFormatEx.cbSize));
    
    //
    // Finally if the output is connected we must use the same media
    //  type as the output!!!!!
    //
    if (m_pOutput->IsConnected())
    {
        if (*pMediaType != m_pOutput->CurrentMediaType())
        {
            return E_FAIL;
        }
    }
    
    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//=============================================================================
// Exported routines for self registration
//=============================================================================
///////////////////////////////////////////////////////////////////////////////

#if !defined(AMRTPSS_IN_DXMRTP)
STDAPI
DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI
DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}
#endif

///////////////////////////////////////////////////////////////////////////////
//=============================================================================
// CPersistStream overriden methods
//=============================================================================
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//  Name    : ReadEntry
//  Purpose : A macro that implements the stuff we do to read
//            a property of this filter from its persistent stream.
//  Context : Used in ReadFromStream() to improve readability.
//  Returns : Will only return if an error is detected.
//  Params  : 
//      Entry       Pointer to a buffer containing the value to read.
//      InSize      Integer indicating the length of the buffer
//      OutSize     Integer to store the written length.
//      Description Char string used to describe the entry.
//  Notes   : 

#define ReadEntry(Entry, InSize, OutSize, Description) \
  { DbgLog((LOG_TRACE, 4, TEXT("CSilenceSuppressor::ReadFromStream: Reading %s"), Description)); \
    hr = pStream->Read(Entry, InSize, &OutSize); \
    if (FAILED(hr)) { \
        DbgLog((LOG_ERROR, 2, TEXT("CSilenceSuppressor::ReadFromStream: Error 0x%08x reading %s"), hr, Description)); \
        return hr; \
    } else if (OutSize != InSize) { \
        DbgLog((LOG_ERROR, 2,  \
                TEXT("CSilenceSuppressor::ReadFromStream: Too few (%d/%d) bytes read for %s"), \
                OutSize, InSize, Description)); \
        return E_INVALIDARG; \
    } /* if */ }

///////////////////////////////////////////////////////////////////////////////
// ReadFromStream
//
// Read the persistent properties of this filter from the persistence stream when
// the graph is loaded from a file.

HRESULT CSilenceSuppressor::ReadFromStream(IStream *pStream) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("silence suppressor: ReadFromStream")));
    if ((pStream == NULL) || IsBadReadPtr(pStream, sizeof(pStream))) return E_POINTER;

    if (mPS_dwFileVersion != 1)
    {
        DbgLog((LOG_ERROR, 2, 
                TEXT("silence suppressor: ReadFromStream: Incompatible stream format")));
        return E_FAIL;
    }

    DWORD   dwChunk = 0;        // buffer to use when reading DWORDs from the stream
    BOOL    bChunk = FALSE;     // buffer to use when reading BOOLs from the stream
    DWORD   dwBytesWritten = 0; // used in the ReadEntry macro to check the number
                                // of bytes written to dwChunk
    HRESULT hr;

    ReadEntry(&dwChunk, sizeof(dwChunk), dwBytesWritten, "Postplay time");
    hr = SetPostplayTime(dwChunk);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 2,
                TEXT("silence suppressor: ReadFromStream: failed to set postplay time %d"),
                dwChunk));
        return hr;
    }

    ReadEntry(&dwChunk, sizeof(dwChunk), dwBytesWritten, "Keep play time");
    hr = SetKeepPlayTime(dwChunk);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 2,
                TEXT("silence suppressor: ReadFromStream: failed to set keep play time %d"),
                dwChunk));
        return hr;
    }

    ReadEntry(&dwChunk, sizeof(dwChunk), dwBytesWritten, "Threshold incrementor(percent)");
    hr = SetThresholdIncrementor(dwChunk);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 2,
                TEXT("silence suppressor: ReadFromStream: failed to set threshold incrementor %d"),
                dwChunk));
        return hr;
    }

    ReadEntry(&dwChunk, sizeof(dwChunk), dwBytesWritten, "Base threshold (percent)");
    hr = SetBaseThreshold(dwChunk);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 2,
                TEXT("silence suppressor: ReadFromStream: failed to set base threshold %d"),
                dwChunk));
        return hr;
    }

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
//  Name    : WriteEntry
//  Purpose : A macro that implements the stuff we do to write
//            a property of this filter to its persistent stream.
//  Context : Used in WriteToStream() to improve readability.
//  Returns : Will only return if an error is detected.
//  Params  : 
//      Entry       Pointer to a buffer containing the value to write.
//      InSize      Integer indicating the length of the buffer
//      OutSize     Integer to store the written length.
//      Description Char string used to describe the entry.
//  Notes   : 

#define WriteEntry(Entry, InSize, OutSize, Description) \
  { DbgLog((LOG_TRACE, 4, TEXT("CSilenceSuppressor::WriteToStream: Writing %s"), Description)); \
    hr = pStream->Write(Entry, InSize, &OutSize); \
    if (FAILED(hr)) { \
        DbgLog((LOG_ERROR, 2, TEXT("CSilenceSuppressor::WriteToStream: Error 0x%08x writing %s"), hr, Description)); \
        return hr; \
    } else if (OutSize != InSize) { \
        DbgLog((LOG_ERROR, 2,  \
                TEXT("CSilenceSuppressor::WriteToStream: Too few (%d/%d) bytes written for %s"), \
                OutSize, InSize, Description)); \
        return E_INVALIDARG; \
    } /* if */ }

///////////////////////////////////////////////////////////////////////////////
// WriteToStream
//
// Write the persistent properties of this filter to the persistence stream when
// the graph is saved.

HRESULT CSilenceSuppressor::WriteToStream(IStream *pStream) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("silence suppressor::WriteToStream")));
    if ((pStream == NULL) || IsBadWritePtr(pStream, sizeof(pStream))) return E_POINTER;
    
    DWORD dwBytesWritten = 0;
    HRESULT hr;

    WriteEntry(&m_dwPostPlayTime, sizeof(m_dwPostPlayTime), dwBytesWritten, "Postplay time");
    WriteEntry(&m_dwKeepPlayTime, sizeof(m_dwKeepPlayTime), dwBytesWritten, "Keep play time");
    WriteEntry(&m_dwThresholdIncPercent, sizeof(m_dwThresholdIncPercent), dwBytesWritten, "Threshold increment");
    WriteEntry(&m_dwBaseThresholdPercent, sizeof(m_dwBaseThresholdPercent), dwBytesWritten, "Base threshold");
    
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// SizeMax
//
// Returns the amount of storage space required for this filter's persistent data.

int CSilenceSuppressor::SizeMax(void) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("silence suppressor: SizeMax")));
    
    return (4 * sizeof(DWORD));
}

///////////////////////////////////////////////////////////////////////////////
// GetClassID
//
// Returns this filter's CLSID.

HRESULT _stdcall CSilenceSuppressor::GetClassID(CLSID *pCLSID) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("silence suppressor: GetClassID")));
    
    if (!pCLSID) return E_POINTER;

    *pCLSID = CLSID_SilenceSuppressionFilter;
    
    return S_OK; 
}

///////////////////////////////////////////////////////////////////////////////
// GetSoftwareVersion
//
// Returns the version of this filter to be stored with the persistent data.

DWORD CSilenceSuppressor::GetSoftwareVersion(void) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("silence suppressor::GetSoftwareVersion")));

    // first version
    return 1; 
}

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpss\siprop.cpp ===
//
// siprop.cpp - Copyright (C) Microsoft Corporation, 1996 - 1999
//

#include <streams.h>
#include "resource.h"
#include "amrtpss.h"
#include "siprop.h"

///////////////////////////////////////////////////////////////////////////////
//=============================================================================
// CSilenceProperties class implementation
//=============================================================================
///////////////////////////////////////////////////////////////////////////////

CSilenceProperties::CSilenceProperties(LPUNKNOWN pUnk, HRESULT *phr)
    : CBasePropertyPage(NAME("Silence Suppression Property Page"), pUnk, 
        IDD_SILENCE, IDS_SILENCE)
    , m_pSilenceSuppressor(NULL)
{
    ASSERT(phr);
}

//
// Support for OLE creation
//
CUnknown * CALLBACK CSilenceProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    CUnknown *punk = new CSilenceProperties(lpunk, phr);
    if (punk == NULL)
    {
        *phr = E_OUTOFMEMORY;
    }

    return punk;
}

//
// Get the interface used to communicate the properties and get
//  their initial values
//
HRESULT CSilenceProperties::OnConnect(IUnknown *pUnknown)
{
    ASSERT(m_pSilenceSuppressor == NULL);

    //
    // Ask the filter for it's control interface
    //
    HRESULT hr = pUnknown->QueryInterface(IID_ISilenceSuppressor,
			(void **)&m_pSilenceSuppressor);
    if (FAILED(hr))
    {
        return E_NOINTERFACE;
    }

    ASSERT(m_pSilenceSuppressor);

    //
    // Get current filter state
    //
    m_pSilenceSuppressor->GetPostplayTime(&m_dwPostPlayTimeCurrent);
	m_pSilenceSuppressor->GetKeepPlayTime(&m_dwKeepPlayTimeCurrent);
	m_pSilenceSuppressor->GetThresholdIncrementor(&m_dwThresholdIncCurrent);
	m_pSilenceSuppressor->GetBaseThreshold(&m_dwBaseThresholdCurrent);

    
    IMediaFilter* pFilter;

    hr = m_pSilenceSuppressor->QueryInterface(
            IID_IMediaFilter, (void **)&pFilter);

    if (FAILED(hr))
    {
        return hr;
    }

    FILTER_STATE state = State_Running;
    DWORD        dwMilliSecsTimeout = 0; // we ignore this

    // Ignore the return code, because we only enable the window
    // when it is in stopped state. 
    pFilter->GetState(dwMilliSecsTimeout, &state);
    pFilter->Release();

    // ZCS and if it's not stopped, let's gray out all the properties.
    if (state == State_Stopped)
        EnableWindow(m_Dlg, TRUE);
    else
        EnableWindow(m_Dlg, FALSE);
    
    return NOERROR;
}

//
// Release the interface pointer obtained in connect!
//
HRESULT CSilenceProperties::OnDisconnect()
{
    if (m_pSilenceSuppressor == NULL)
    {
        //
        // BUGBUG: SetObjects is called twice once directly from graphedt
        //  and a second time when the base class property page is released!
        //  A bug should be filed against ActiveMovie when we get access to
        //  their database.  The bug is harmless.
        //
        return E_UNEXPECTED;
    }
    
    m_pSilenceSuppressor->Release();
    m_pSilenceSuppressor = NULL;
    return NOERROR;
}

//
// Initialize the dialog controls
//
HRESULT CSilenceProperties::OnActivate()
{
    SetDlgItemInt(m_hwnd, IDC_POSTPLAY, m_dwPostPlayTimeCurrent, FALSE);
	SetDlgItemInt(m_hwnd, IDC_KEEPPLAY, m_dwKeepPlayTimeCurrent, FALSE);
	SetDlgItemInt(m_hwnd, IDC_THRESHOLDINC, m_dwThresholdIncCurrent, FALSE);
	SetDlgItemInt(m_hwnd, IDC_BASETHRESHOLD, m_dwBaseThresholdCurrent, FALSE);

    return NOERROR;
}

//
// Set a property and handle any failure, including bringing up a message box.
//

HRESULT CSilenceProperties::ChangeProperty
	   (SetMethod  pfSetMethod,					// pointer to function to make the property change
		DWORD     *pSetting,					// pointer to our copy of the property value
		int        iControl,					// identifier for the control that shows it
		GetMethod  pfGetMethod,					// pointer to function to revert property change
		UINT	   uiText,						// resource identifier for error message text
		UINT	   uiCaption)					// resource identifier for error message caption
{
	// We assume the member function offsets are ok, because we can't do much checking on them.
	// (Once converted to function pointers they can only be called, not passed to IsBadCodePtr(),
	// and they will certainly never be NULL. Anyway, we can definitely trust our filter pointer
	// and filter interface definition; otherwise all bets are off.)
	
	if ((pSetting == NULL) ||
		IsBadReadPtr(pSetting, sizeof(pSetting)) ||
		IsBadWritePtr(pSetting, sizeof(pSetting)))
		return E_POINTER;
	
    // Get the user's new value from the dialog. As long as it's a number
	// we'll accept any screwy thing at this point.

    BOOL fOk;
    *pSetting = GetDlgItemInt(m_hwnd, iControl, &fOk, FALSE);
	HRESULT hr;

    if (fOk)
		// set the property
		hr = (m_pSilenceSuppressor->*pfSetMethod)(*pSetting);
	else
		hr = E_FAIL;

	if (FAILED(hr))
	{	
        DbgLog((LOG_ERROR, 3,
			TEXT("CSilenceSuppressor::OnApplyChanges: Error 0x%08x"
			" setting a property. Aborting apply!"), hr));

		// Load in the strings from the string table resource
		TCHAR szText[256], szCaption[256];
		LoadString(g_hInst, uiText,	   szText,    255);
		LoadString(g_hInst, uiCaption, szCaption, 255);

		// now display it
		MessageBox(m_hwnd, szText, szCaption, MB_OK);
		// ...we don't care what they clicked
		
		// reset our private copy of the property
		(m_pSilenceSuppressor->*pfGetMethod)(pSetting);

		// ignore failure of pfGetMethod, because we're talking about a
		// possibly-invalid value versus a definitely-invalid value. Wing it.

		// reset the UI control
		SetDlgItemInt(m_hwnd, iControl, *pSetting, FALSE);
	}

	return hr;
}

//
// Validate input and give the obtained settings back to the filter.
//

HRESULT CSilenceProperties::OnApplyChanges()
{
    //
    // Set up the filter. If any of these fail, the property page stays up.
    //

	HRESULT hr;

	hr = ChangeProperty(&ISilenceSuppressor::SetPostplayTime,
						&m_dwPostPlayTimeCurrent,
						IDC_POSTPLAY,
						&ISilenceSuppressor::GetPostplayTime,
						IDS_ERROR_POSTPLAY, IDS_ERROR_CAPTION);
	if (FAILED(hr)) return hr;

	hr = ChangeProperty(&ISilenceSuppressor::SetKeepPlayTime,
						&m_dwKeepPlayTimeCurrent,
						IDC_KEEPPLAY,
						&ISilenceSuppressor::GetKeepPlayTime,
						IDS_ERROR_KEEPPLAY, IDS_ERROR_CAPTION);
	if (FAILED(hr)) return hr;

	hr = ChangeProperty(&ISilenceSuppressor::SetThresholdIncrementor,
						&m_dwThresholdIncCurrent,
						IDC_THRESHOLDINC,
						&ISilenceSuppressor::GetThresholdIncrementor,
						IDS_ERROR_THRESHOLDINC, IDS_ERROR_CAPTION);
	if (FAILED(hr)) return hr;

	hr = ChangeProperty(&ISilenceSuppressor::SetBaseThreshold,
						&m_dwBaseThresholdCurrent,
						IDC_BASETHRESHOLD,
						&ISilenceSuppressor::GetBaseThreshold,
						IDS_ERROR_BASETHRESHOLD, IDS_ERROR_CAPTION);
	if (FAILED(hr)) return hr;

    return NOERROR;
}

//
// Handle messages that need more than defualt processing.
//
INT_PTR CSilenceProperties::OnReceiveMessage
            ( HWND hwnd
            , UINT uMsg
            , WPARAM wParam
            , LPARAM lParam
            )
{
    int iIdCtl = (int) LOWORD(wParam);
    DWORD dwVal, *pdwValCurrent;
    BOOL fOk;

    switch (uMsg)
    {
    case WM_COMMAND:
        switch(HIWORD(wParam))
        {
        case EN_CHANGE:
            switch (iIdCtl)
            {
            case IDC_POSTPLAY:
                pdwValCurrent = &m_dwPostPlayTimeCurrent;
                break;
            case IDC_KEEPPLAY:
                pdwValCurrent = &m_dwKeepPlayTimeCurrent;
                break;
            case IDC_THRESHOLDINC:
                pdwValCurrent = &m_dwThresholdIncCurrent;
                break;
            case IDC_BASETHRESHOLD:
                pdwValCurrent = &m_dwBaseThresholdCurrent;
                break;
            default:
                ASSERT(FALSE); // Don't know how!!
            }
            dwVal = GetDlgItemInt(m_hwnd, iIdCtl, &fOk, FALSE);
            if (fOk && dwVal != *pdwValCurrent)
            {
                SetDirty();
            }
            break;
        }
    }

    return FALSE;
}

//
// SetDirty - notifies the property page site of changes
//
void CSilenceProperties::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\codecs\g711\algdefs.h ===
/*--------------------------------------------------------------

 INTEL Corporation Proprietary Information  

 This listing is supplied under the terms of a license agreement  
 with INTEL Corporation and may not be copied nor disclosed 
 except in accordance with the terms of that agreement.

 Copyright (c) 1996 Intel Corporation.
 All rights reserved.

 $Workfile:   algdefs.h  $
 $Revision:   1.13  $
 $Date:   10 Dec 1996 22:31:20  $ 
 $Author:   mdeisher  $

--------------------------------------------------------------

header.h

The coder-specific header for G.711.

NOTE: GUIDs for basic companding like G711 should probably be 
      standardized by MS not me.

--------------------------------------------------------------*/

//
// Coder-specific functions
//
extern void Short2Ulaw(const unsigned short *in, unsigned char *out,long len);
extern void Ulaw2Short(const unsigned char *in, unsigned short *out,long len);
extern void Short2Alaw(const unsigned short *in, unsigned char *out,long len);
extern void Alaw2Short(const unsigned char *in, unsigned short *out,long len);

//
// GUIDs
//
// G711 Codec Filter Object
// {AF7D8180-A8F9-11cf-9A46-00AA00B7DAD1}
DEFINE_GUID(CLSID_G711Codec, 
0xaf7d8180, 0xa8f9, 0x11cf, 0x9a, 0x46, 0x0, 0xaa, 0x0, 0xb7, 0xda, 0xd1);

// G711 Codec Filter Property Page Object
// {480D5CA0-F032-11cf-A7D3-00A0C9056683}
DEFINE_GUID(CLSID_G711CodecPropertyPage, 
0x480D5CA0, 0xF032, 0x11cf, 0xA7, 0xD3, 0x0, 0xA0, 0xC9, 0x05, 0x66, 0x83);

// {827FA280-CDFC-11cf-9A9D-00AA00B7DAD1}
DEFINE_GUID(MEDIASUBTYPE_MULAWAudio, 
0x827fa280, 0xcdfc, 0x11cf, 0x9a, 0x9d, 0x0, 0xaa, 0x0, 0xb7, 0xda, 0xd1);

// {9E17EE50-CDFC-11cf-9A9D-00AA00B7DAD1}
DEFINE_GUID(MEDIASUBTYPE_ALAWAudio, 
0x9e17ee50, 0xcdfc, 0x11cf, 0x9a, 0x9d, 0x0, 0xaa, 0x0, 0xb7, 0xda, 0xd1);

//
// Some constants
//

#define ENCODERobj      int   // codec state structure
#define MyEncStatePtr   int*  // encoder state pointer type
#define DECODERobj      int   // codec state structure
#define MyDecStatePtr   int*  // decoder state pointer type
//
// Default filter transform
//
#define DEFINPUTSUBTYPE   MEDIASUBTYPE_PCM
#define DEFINPUTFORMTAG   WAVE_FORMAT_PCM
#define DEFOUTPUTSUBTYPE  MEDIASUBTYPE_MULAWAudio
#define DEFOUTPUTFORMTAG  WAVE_FORMAT_MULAW
#define DEFCODFRMSIZE     0            // G.711 is not frame-based
#define DEFPCMFRMSIZE     0            // G.711 is not frame-based
#define DEFCHANNELS       1
#define DEFSAMPRATE       8000         // well, if we have to guess...
#define DEFBITRATE        0
#define DEFSDENABLED      FALSE

#define NATURALSAMPRATE   8000         // well, if we have to guess...

#define MAXCOMPRATIO      2            // maximum compression ratio

#define CODOFFSET   0   // for unit testing

#define MINSNR    11.0  // the minimum SNR required for the encode/decode
                        //  test from the unit test suite to pass.
#define MINSEGSNR  9.0  // the minimum segmental SNR required for the

#define NUMCHANNELS  2   // number of channel configurations supported

//
//
#define NUMSUBTYPES  3   // Number of input/output buttons
#define NUMSAMPRATES 0   // no sampling rate restriction
#define NUMBITRATES  0   // number of bit rate buttons
#define NUMENCCTRLS  0   // number of encoder control buttons
#define NUMDECCTRLS  0   // number of decoder control buttons

//
// Pin types for automatic registration
//

//
// Transform types:  these must be ordered properly for SetButtons().
//
enum
{
  PCMTOPCM,   PCMTOMULAW,   PCMTOALAW, 
  MULAWTOPCM, MULAWTOMULAW, MULAWTOALAW, 
  ALAWTOPCM,  ALAWTOMULAW,  ALAWTOALAW
};


#ifdef DEFG711GLOBALS
//
// Button IDs:  these must be ordered as in .rc file for SetButtons().
//
UINT INBUTTON[]  = { IDC_PCM_IN, IDC_MULAW_IN, IDC_ALAW_IN };
UINT OUTBUTTON[] = { IDC_PCM_OUT, IDC_MULAW_OUT, IDC_ALAW_OUT };
UINT SRBUTTON[]  = { 0 };
UINT BRBUTTON[]  = { 0 };
UINT ENCBUTTON[] = { 0 };
UINT DECBUTTON[] = { 0 };

//
// Transform validity:  these must correspond to enumerated constants above
//
UINT VALIDTRANS[] =
{
  FALSE, TRUE,  TRUE,
  TRUE,  FALSE, FALSE,
  TRUE,  FALSE, FALSE
};

//
// list of valid media subtypes for pins (PCM must come first)
//
const GUID *VALIDSUBTYPE[] =
{
  &MEDIASUBTYPE_PCM,
  &MEDIASUBTYPE_MULAWAudio,
  &MEDIASUBTYPE_ALAWAudio
};

//
// list of valid format tags for pins (PCM must come first)
//
WORD VALIDFORMATTAG[] =
{
  WAVE_FORMAT_PCM,
  WAVE_FORMAT_MULAW,
  WAVE_FORMAT_ALAW
};

//
// list of valid number of channels
//
UINT VALIDCHANNELS[] =
{
  1,
  2
};

//
// list of valid format tags for pins (PCM must come first)
//
UINT VALIDBITSPERSAMP[] =
{
  16,  // PCM
   8,  // MULAW
   8   // ALAW
};

//
// List of valid sampling rates (PCM side)
//
UINT VALIDSAMPRATE[] =
{
  DEFSAMPRATE
};

//
// List of valid bit rates.
//
UINT VALIDBITRATE[] =
{
  0
};

//
// List of valid code frame sizes
//
UINT VALIDCODSIZE[] =
{
  1  // G.711 is not frame-based
};

//
// encodes 2:1, decodes 1:2
//
// NOTE: this assumes that 13 and 14 bit linear samples are left 
// justified and padded to 16 bits.
//
int COMPRESSION_RATIO[] =
{
  2
};
#else
extern UINT INBUTTON[3];
extern UINT OUTBUTTON[3];
extern UINT SRBUTTON[1];
extern UINT BRBUTTON[1];
extern UINT ENCBUTTON[1];
extern UINT DECBUTTON[1];
extern UINT VALIDTRANS[9];
extern const GUID *VALIDSUBTYPE[3];
extern WORD VALIDFORMATTAG[3];
extern UINT VALIDCHANNELS[2];
extern UINT VALIDBITSPERSAMP[3];
extern UINT VALIDSAMPRATE[1];
extern UINT VALIDBITRATE[1];
extern UINT VALIDCODSIZE[1];
extern int COMPRESSION_RATIO[1];
#endif


//
// initialization macros
//
//   a = pointer to state structure
//   b = bit rate
//   c = silence detection flag
//   d = ptr to flag enabling/disabling use of MMX assembly
//
#define ENC_create(a,b,c,d) {}    // encoder state creation function
#define DEC_create(a,b,c,d) {}    // decoder state creation function
//
// transform macros
//
//   a = pointer to input buffer
//   b = pointer to output buffer
//   c = input buffer length (bytes)
//   d = output buffer length (bytes)
//   e = pointer to state structure
//   f = media subtype guid
//   g = wave format tag
//   h = ptr to flag enabling/disabling use of MMX assembly
//
#define ENC_transform(a,b,c,d,e,f,h) \
        { \
          if (f == MEDIASUBTYPE_MULAWAudio) \
            Short2Ulaw((const unsigned short *) a, \
                       (unsigned char *) b, \
                       c / COMPRESSION_RATIO[m_nBitRate]); \
          else \
            Short2Alaw((const unsigned short *) a, \
                       (unsigned char *) b, \
                       c / COMPRESSION_RATIO[m_nBitRate]); \
        }
#define DEC_transform(a,b,c,d,e,f,g,h) \
        { \
          if ((f == MEDIASUBTYPE_MULAWAudio) \
              || ((f == MEDIASUBTYPE_WAVE || f == MEDIASUBTYPE_NULL) \
                  && (g == WAVE_FORMAT_MULAW))) \
            Ulaw2Short((const unsigned char *) a, \
                       (unsigned short *) b, c); \
          else \
            Alaw2Short((const unsigned char *) a, \
                       (unsigned short *) b, c); \
        }

//
// multiple bit-rate support is not necessary
//
#define SETCODFRAMESIZE(a,b) ;


/*

;$Log:   K:\proj\g711\quartz\src\vcs\algdefs.h_v  $
;// 
;//    Rev 1.13   10 Dec 1996 22:31:20   mdeisher
;// 
;// added ifdef DEFG711GLOBALS and prototypes.
;// 
;//    Rev 1.12   26 Nov 1996 17:06:44   MDEISHER
;// added multi-channel support for new interface.
;// 
;//    Rev 1.11   11 Nov 1996 16:04:22   mdeisher
;// added defines for unit test
;// 
;//    Rev 1.10   11 Nov 1996 16:02:56   mdeisher
;// 
;// added ifdefs for unit test
;// 
;//    Rev 1.9   21 Oct 1996 11:07:32   mdeisher
;// changed VALIDCODSIZE to { 1 }.
;// 
;//    Rev 1.8   21 Oct 1996 10:53:50   mdeisher
;// 
;// removed definition of IID.
;// 
;//    Rev 1.7   01 Oct 1996 15:38:18   MDEISHER
;// made changes to bring G.711 up-to-date with latest mycodec.
;//  - made COMPRESSION_RATIO into a single entry array.
;//  - changed definitions of DEFCODFRMSIZE and DEFPCMFRMSIZE.
;//  - added definition of NATURALSAMPRATE and MAXCOMPRATIO.
;//  - added empty VALIDCODSIZE array.
;//  - modified ENC_transform to accomodate new COMPRESSION_RATIO[].
;//  - added definition of SETCODFRAMESIZE macro.
;// 
;//    Rev 1.6   20 Sep 1996 10:08:26   MDEISHER
;// added default output format tag.
;// 
;//    Rev 1.5   10 Sep 1996 13:43:42   MDEISHER
;// put default sample rate into VALIDSAMPRATE array
;// 
;//    Rev 1.4   09 Sep 1996 11:39:06   MDEISHER
;// completed changes to add mmx flag to macros.
;// 
;//    Rev 1.3   09 Sep 1996 11:26:46   MDEISHER
;// added modifications for mmx flag
;// 
;//    Rev 1.2   04 Sep 1996 13:23:56   MDEISHER
;// 
;// brought up to date with latest mycodec interface.
;// 
;//    Rev 1.1   27 Aug 1996 14:45:06   MDEISHER
;// added pin type list for self-registration.
;// 
;//    Rev 1.0   27 Aug 1996 07:19:34   MDEISHER
;// Initial revision.
;// 
;//    Rev 1.2   26 Aug 1996 11:47:42   MDEISHER
;// changed initialization macro definitions
;// 
;//    Rev 1.1   26 Aug 1996 11:06:00   MWALKER
;// 
;// Changed ENC_create & DEC_create into macros.
;// Renamed MyEncoder & MyDecoder to ENC_transform & DEC_transform
;// 
;//    Rev 1.0   23 Aug 1996 10:07:42   MDEISHER
;// Initial revision.
;// 
;//    Rev 1.2   22 Aug 1996 20:06:18   MDEISHER
;// 
;// first complete version that compiles and passes minimal tests.
;// 
;//    Rev 1.1   13 Aug 1996 21:58:26   MDEISHER
;// 
;// further refinement
;// 
;//    Rev 1.0   13 Aug 1996 20:38:18   MDEISHER
;// Initial revision.

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpss\silence.h ===
/*********************************************************************
 *
 * Copyright (C) Microsoft Corporation, 1997 - 1999
 *
 * File: silence.h
 *
 * Abstract:
 *     This class used to be in silence.cpp, but as is needed
 *     to implement dxmrtp.dll I put it in a separate file.
 *
 * History:
 *     10/21/97    Created by AndresVG
 *
 **********************************************************************/
#if !defined(_SILENCE_H_)
#define      _SILENCE_H_

extern AMOVIESETUP_FILTER sudSilence; // for dxmrtp.cpp

///////////////////////////////////////////////////////////////////////////////
//=============================================================================
// Class Definitions
//=============================================================================
///////////////////////////////////////////////////////////////////////////////
//
// This is the filter implementation
//
class CSilenceSuppressor
        : public ISilenceSuppressor
        , public ISpecifyPropertyPages
        , public CTransInPlaceFilter
		, public CPersistStream
{
public:
    // Construction/destruction
    CSilenceSuppressor(TCHAR *tszName, LPUNKNOWN punk, HRESULT *phr);
    ~CSilenceSuppressor();

    // CreateInstance provided for class factory
    static CUnknown * CALLBACK CreateInstance(LPUNKNOWN punk, HRESULT *phr);

    // Active Movie macro to give us IUnknown implementations
    DECLARE_IUNKNOWN;

    STDMETHOD(NonDelegatingQueryInterface) (REFIID riid, void **ppv);

    // setup helper
    LPAMOVIESETUP_FILTER GetSetupData();

    // ActiveMovie Overrides
    virtual HRESULT CheckInputType(const CMediaType *pMediaType);
    virtual HRESULT Transform(IMediaSample *pSample);
    virtual HRESULT StartStreaming();
    STDMETHOD(GetState) (DWORD dwMSecs, FILTER_STATE *State);
    STDMETHOD(GetPages) (CAUUID * pPages);

    //
    // --- ISilenceSuppressor ---
    //
    STDMETHOD(GetPostplayTime) (LPDWORD lpdwPostplayBufferTime);
    STDMETHOD(SetPostplayTime) (DWORD dwPostplayBufferTime);
    STDMETHOD(GetKeepPlayTime) (LPDWORD lpdwKeepPlayTime);
    STDMETHOD(SetKeepPlayTime) (DWORD dwKeepPlayTime);
    STDMETHOD(GetThresholdIncrementor) (LPDWORD lpdwThresholdIncrementor);
    STDMETHOD(SetThresholdIncrementor) (DWORD dwThresholdIncrementor);
    STDMETHOD(GetBaseThreshold) (LPDWORD lpdwBaseThreshold);
    STDMETHOD(SetBaseThreshold) (DWORD dwBaseThreshold);
    STDMETHOD(EnableEvents) (DWORD dwMask, DWORD dwMinimumInterval);

	// 
	// --- IPersistStream --- (ZCS 7-25-97)
	//
	virtual HRESULT ReadFromStream(IStream *pStream);
	virtual HRESULT WriteToStream(IStream *pStream);
	virtual int SizeMax(void);
	virtual HRESULT _stdcall GetClassID(CLSID *pCLSID);
	virtual DWORD GetSoftwareVersion(void);

#ifdef PERF
    // Override to register performance measurement with a less generic string
    virtual void RegisterPerfId()
         {m_idSilence = MSR_REGISTER(TEXT("Silence"));}
#endif // PERF

private:

#ifdef PERF
    int m_idSilence;   
#endif // PERF

    BOOL  m_fSuppressMode;
	DWORD m_dwThreshold;     // Current threshold
	DWORD m_dwSilenceAverage;    // Current Silence Average

    // number of continuous silent frames.
	DWORD m_dwSilentFrameCount;

    // number of continuous sound frames.
    DWORD m_dwSoundFrameCount;

	WAVEFORMATEX m_WaveFormatEx;

    //
    // Property page items
    //
    DWORD m_dwPostPlayTime;
    DWORD m_dwPostPlayCount;

    DWORD m_dwKeepPlayTime;
	DWORD m_dwKeepPlayCount;

    DWORD m_dwThresholdInc;
	DWORD m_dwThresholdIncPercent;   // tenth of a percent.

	DWORD m_dwBaseThreshold;
	DWORD m_dwBaseThresholdPercent;

	DWORD m_dwMaxThreshold;
    DWORD m_dwMaxThresholdPercent;


    DWORD m_dwClipThreshold;
    DWORD m_dwClipThresholdPercent;

    DWORD m_dwClipCountThresholdPercent;
    DWORD m_dwGainAdjustmentPercent;

    DWORD m_dwEventMask;
    DWORD m_dwLastEventTime;
    DWORD m_dwEventInterval;

	// ZCS: zero if any of the time-based parameters have changed, indicating
	// that it must be fetched again and the count-based parameters recalculated.
	// This value is determined from the data using the GetActualDataLength member
	// in the IMediaSample interface.

	DWORD m_dwSampleSize;

	// ZCS: a helper function to convert time (tenths of a second) to packets.
	DWORD   TimeToPackets(DWORD dwTime);

    // ZCS: a helper function to reinterpret all parameters when they've changed.
	HRESULT ReinterpretParameters(IMediaSample *pSample);

    HRESULT Statistics(
        IN  IMediaSample *  pSample,
        IN  DWORD           dwSize,
        OUT DWORD *         pdwPeak
        );
};

//
// ZCS 7-23-97
// This private method converts a value from tenths of a second to number of packets.
//
//										 y bytes    1 packet        1 second
// # Packets = (x tenths of a second) * --------- * -------- * ---------------------
//                                      1 second    z bytes    10 tenths of a second
//

inline DWORD CSilenceSuppressor::TimeToPackets(DWORD dwTime)
{
	return ((dwTime * m_WaveFormatEx.nAvgBytesPerSec) / (m_dwSampleSize * 10));
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\codecs\g711\iamacbr.cpp ===
/*--------------------------------------------------------------

 INTEL Corporation Proprietary Information  

 This listing is supplied under the terms of a license agreement  
 with INTEL Corporation and may not be copied nor disclosed 
 except in accordance with the terms of that agreement.

 Copyright (c) 1996 Intel Corporation.
 All rights reserved.

 $Workfile:   iamacbr.cpp  $
 $Revision:   1.1  $
 $Date:   10 Dec 1996 15:28:38  $ 
 $Author:   MDEISHER  $

--------------------------------------------------------------

iamacbr.cpp

The generic ActiveMovie audio compression filter bit rate
settings methods.

--------------------------------------------------------------*/

#include <streams.h>
#include "resource.h"
#include "amacodec.h"

#if NUMBITRATES > 0
///////////////////////////////////////////////////////////////////////
// *
// * ICodecBitRate interface methods
// *

//
// get_BitRate
//
STDMETHODIMP CG711Codec::get_BitRate(int *bitrate, int index)
{
  HRESULT ReturnVal=NOERROR;

  // Since bit-rate information is passed "in-band" to the decoder
  // only the encoder has a bit-rate setting.

  if ((m_InputSubType == MEDIASUBTYPE_PCM)      // compressing?
      || (m_InputSubType == MEDIASUBTYPE_WAVE
          && m_InputFormatTag == WAVE_FORMAT_PCM)
      || (m_InputSubType == MEDIASUBTYPE_NULL
          && m_InputFormatTag == WAVE_FORMAT_PCM))
  {
    if (index == -1)
    {
      *bitrate = m_nBitRate;
    }
    else if (index != -1 && (index < 0 || index >= NUMBITRATES))
    {
      ReturnVal = E_INVALIDARG;
    }
    else  // enumerate bit rates
    {
      *bitrate = VALIDBITRATE[index];
    }
  }
  else ReturnVal = E_FAIL;

  return ReturnVal;
}


//
// put_BitRate
//
STDMETHODIMP CG711Codec::put_BitRate(int bitrate)
{
  int i;

  // Since bit-rate information is passed "in-band" to the decoder
  // only the encoder has a bit-rate setting.

  if ((m_InputSubType == MEDIASUBTYPE_PCM)      // compressing?
      || (m_InputSubType == MEDIASUBTYPE_WAVE
          && m_InputFormatTag == WAVE_FORMAT_PCM)
      || (m_InputSubType == MEDIASUBTYPE_NULL
          && m_InputFormatTag == WAVE_FORMAT_PCM))
  {
    // if the filter is disconnected, then change bitrate

    if (IsUnPlugged())
    {
      for(i=0;i<NUMBITRATES;i++)
        if (VALIDBITRATE[i] == (UINT)bitrate)
          break;

      if (i == NUMBITRATES)
      {
        DbgMsg("Bad bit-rate in put_BitRate!");
        return(E_INVALIDARG);
      }

      m_nBitRate      = bitrate;
      m_nBitRateIndex = i;
      m_nCODFrameSize = VALIDCODSIZE[m_nBitRateIndex];

      ResetState();  // change in bitrate means need to re-initialize coder

      // restrict capabilities to those set from the properties page

      m_RestrictCaps = TRUE;
  
      return NOERROR;
    }
    else return E_FAIL;
  }
  else return E_FAIL;
}
#endif

/*
//$Log:   K:\proj\mycodec\quartz\vcs\iamacbr.cpv  $
# 
#    Rev 1.1   10 Dec 1996 15:28:38   MDEISHER
# 
# added includes, removed include of algdefs.h.
# 
#    Rev 1.0   09 Dec 1996 08:58:46   MDEISHER
# Initial revision.
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\codecs\g711\amacodec.h ===
/*--------------------------------------------------------------

 INTEL Corporation Proprietary Information  

 This listing is supplied under the terms of a license agreement  
 with INTEL Corporation and may not be copied nor disclosed 
 except in accordance with the terms of that agreement.

 Copyright (c) 1996 Intel Corporation.
 All rights reserved.

 $Workfile:   amacodec.h  $
 $Revision:   1.3  $
 $Date:   10 Dec 1996 22:40:50  $ 
 $Author:   mdeisher  $

--------------------------------------------------------------

amacodec.h

The generic ActiveMovie audio compression filter header.

--------------------------------------------------------------*/

#include "algdefs.h"
#include "iamacset.h"
#if NUMBITRATES > 0
#include "iamacbr.h"
#endif
#ifdef USESILDET
#include "iamacsd.h"
#endif
#ifdef REQUIRE_LICENSE
#include "iamaclic.h"
#endif
#if NUMSAMPRATES > 1
#include "amacsrc.h"
#endif


////////////////////////////////////////////////////////////////////
// constant and macro definitions
//

#define FLOATTOSHORT(b) ((b < -32768.) ? (short)(-32768) : \
                        ((b >  32767.) ? (short)(32767)  : \
                        ((b <      0.) ? (short)(b-0.5)  : \
                                         (short)(b+0.5))))

// with these macros it is possible to add a file name to the
// software\debug\graphedt registry to turn on logging to a file.
// this information is also available in MCVS under the output window.
// The DbgLog has 5 different types each with several different
// levels. all controllable via the registry.

#define DbgFunc(a) DbgLog(( LOG_TRACE,                      \
                            2,                              \
                            TEXT("CG711Codec(Instance %d)::%s"), \
                            m_nThisInstance,                \
                            TEXT(a)                         \
                         ));

#ifdef POPUPONERROR
#define DbgMsg(a) DbgBreak(a)
#else
#define DbgMsg(a) DbgFunc(a)
#endif


////////////////////////////////////////////////////////////////////
// CMyTransformInputPin:  Derived from CTransformInputPin to support
//                        input pin type enumeration
//
class CMyTransformInputPin
    : public CTransformInputPin
{
  public:
    HRESULT CheckMediaType(const CMediaType *mtIn);     
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);

    CMyTransformInputPin(TCHAR *pObjectName, 
                         CTransformFilter *pTransformFilter, 
                         HRESULT * phr, LPCWSTR pName);

  private:
    static int  m_nInstanceCount; // Global count of input pin instances
    int         m_nThisInstance;  // This instance's count
};


////////////////////////////////////////////////////////////////////
// CMyTransformOutputPin:  Derived from CTransformOutputPin to fix
//                         the connection model when input pin type
//                         enumeration is required.
//
class CMyTransformOutputPin
    : public CTransformOutputPin
{
  public:
    HRESULT CheckMediaType(const CMediaType *mtIn);     

    CMyTransformOutputPin(TCHAR *pObjectName, 
                          CTransformFilter *pTransformFilter, 
                          HRESULT * phr, LPCWSTR pName);

  private:
    static int  m_nInstanceCount; // Global count of input pin instances
    int         m_nThisInstance;  // This instance's count
};


////////////////////////////////////////////////////////////////////
// MyCodec:  CTranform derived Codec filter
//
class CG711Codec
    : public CTransformFilter       // perform transform across allocators
    , public CPersistStream         // implements IPersistStream
    , public ISpecifyPropertyPages  // property pages class ???
    , public ICodecSettings         // basic settings interface
#if NUMBITRATES > 0
    , public ICodecBitRate          // bit rate interface
#endif
#ifdef REQUIRE_LICENSE
    , public ICodecLicense          // license interface
#endif
#ifdef USESILDET
    , public ICodecSilDetector      // silence detector interface
#endif
{
    friend class CMyTransformInputPin;
    friend class CMyTransformOutputPin;

  public:

    static CUnknown *CreateInstance(LPUNKNOWN punk, HRESULT *phr);

    DECLARE_IUNKNOWN;

    // Basic COM - used here to reveal our persistent interface.
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    // CPersistStream overrides
    HRESULT      WriteToStream(IStream *pStream);
    HRESULT      ReadFromStream(IStream *pStream);
    int          SizeMax();
    STDMETHODIMP GetClassID(CLSID *pClsid);

    // Other Methods    
    LPAMOVIESETUP_FILTER GetSetupData();    // setup helper
    STDMETHODIMP         GetPages(CAUUID *pPages);

    // ICodecSettings Interface Methods
    STDMETHODIMP         get_Channels(int *channels, int index);
    STDMETHODIMP         put_Channels(int channels);
    STDMETHODIMP         get_SampleRate(int *samprate, int index);
    STDMETHODIMP         put_SampleRate(int samprate);
    STDMETHODIMP         get_Transform(int *transform);
    STDMETHODIMP         put_Transform(int transform);
    STDMETHODIMP         get_InputBufferSize(int *numbytes);
    STDMETHODIMP         put_InputBufferSize(int numbytes);
    STDMETHODIMP         get_OutputBufferSize(int *numbytes);
    STDMETHODIMP         put_OutputBufferSize(int numbytes);
    STDMETHODIMP         put_InputMediaSubType(REFCLSID rclsid);
    STDMETHODIMP         put_OutputMediaSubType(REFCLSID rclsid);
    STDMETHODIMP         ReleaseCaps();     // for Roger
    BOOL                 IsUnPlugged();

    // ICodecBitRate Interface Methods
#if NUMBITRATES > 0
    STDMETHODIMP         get_BitRate(int *bitrate, int index);
    STDMETHODIMP         put_BitRate(int bitrate);
#endif

    // ICodecSilDetector Interface Methods
#ifdef USESILDET
    STDMETHODIMP         put_SilDetEnabled(int sdenabled);
    STDMETHODIMP         get_SilDetThresh(int *sdthreshold);
    STDMETHODIMP         put_SilDetThresh(int sdthreshold);
    BOOL                 IsSilDetEnabled();
#endif

    // ICodecLicense Interface Methods
#ifdef REQUIRE_LICENSE
    STDMETHODIMP         put_LicenseKey(DWORD magicword0, DWORD magicword1);
#endif

    // CTransformFilter Overrides
    HRESULT  Transform(IMediaSample *pIn, IMediaSample *pOut);
    HRESULT  CheckInputType(const CMediaType *mtIn);
    HRESULT  CheckTransform(const CMediaType *mtIn, const CMediaType *mtOut);
    HRESULT  GetMediaType(int iPosition, CMediaType *pMediaType);
    HRESULT  DecideBufferSize(IMemAllocator *pAlloc,
                              ALLOCATOR_PROPERTIES *pProperties);
    HRESULT  SetMediaType(PIN_DIRECTION direction, const CMediaType *pmt);
    HRESULT  StopStreaming();
    CBasePin *GetPin(int n);

    CG711Codec(TCHAR *tszName, LPUNKNOWN punk, HRESULT *phr);
    ~CG711Codec();

    HRESULT MyTransform(IMediaSample *pSource, IMediaSample *pDest);

  private:

    HRESULT InitializeState(PIN_DIRECTION direction);
    HRESULT ValidateMediaType(const CMediaType* pmt, PIN_DIRECTION direction);

    // Internally Used Methods    
    STDMETHODIMP         ResetState();
    STDMETHODIMP         RevealCaps(int *restricted);
#if NUMSAMPRATES > 1
    HRESULT SRConvert(BYTE *ibuffer, int  israte, int  ilen,
                      BYTE *obuffer, int  osrate, int  *olen);
#endif

    CCritSec      m_MyCodecLock;    // To serialise access.
    static int    m_nInstanceCount; // Global count of filter instances
    int           m_nThisInstance;  // This instance's count
    UINT          m_nBitRate;       // Coder bit rate
    UINT          m_nBitRateIndex;  // Coder bit rate index
    int           m_nChannels;      // Current sample format, mono or stereo
    UINT          m_nSampleRate;    // PCM sample rate
    int           m_RestrictCaps;   // Boolean: capabilities are restricted
    GUID          m_OutputSubType;
    DWORD         m_OutputFormatTag;
    GUID          m_InputSubType;
    DWORD         m_InputFormatTag;
    MyEncStatePtr m_EncStatePtr;    // Pointer to encoder state structure
    MyDecStatePtr m_DecStatePtr;    // Pointer to decoder state structure
    int           m_nInBufferSize;  // Size of input buffer
    int           m_nOutBufferSize; // Size of output buffer

    BYTE          *m_pPCMBuffer;    // Pointer to PCM spanning buffer
    int           m_nPCMFrameSize;  // Size of speech buffer in bytes
    int           m_nPCMLeftover;   // Number of bytes of leftover PCM

    BYTE          *m_pCODBuffer;    // Pointer to code spanning buffer
    int           m_nCODFrameSize;  // Size of code buffer in bytes
    int           m_nCODLeftover;   // Number of bytes of leftover code

#if NUMSAMPRATES > 1
    BYTE          *m_pSRCCopyBuffer; // Pointer to SRC copy buffer
    BYTE          *m_pSRCBuffer;     // Pointer to SRC spanning buffer
    short         *m_pSRCState;      // Sample rate converter state
    int           m_nSRCCBufSize;    // SRC copy buffer size
    int           m_nSRCCount;       // Cumulative bytes of leftover SRC PCM
    int           m_nSRCLeftover;    // Number of bytes of leftover SRC PCM
#endif

    UINT          *m_UseMMX;         // Ptr to boolean flag.
                                     //   TRUE=use mmx assembly paths

    int           m_nSilDetEnabled;  // silence detection enabled (boolean)
    int           m_nSilDetThresh;   // silence detection threshold
    BOOL          m_nLicensedToEnc;  // approved for encoding
    BOOL          m_nLicensedToDec;  // approved for decoding
};

/*
//$Log:   K:\proj\mycodec\quartz\vcs\amacodec.h_v  $
;// 
;//    Rev 1.3   10 Dec 1996 22:40:50   mdeisher
;// ifdef'ed out SRC vars when SRC not used.
;// 
;//    Rev 1.2   10 Dec 1996 15:22:00   MDEISHER
;// 
;// moved debug macros into header.
;// cosmetic changes.
;// made revealcaps and resetstate methods private.
;// ifdef'ed out interface methods.
;// 
;//    Rev 1.1   09 Dec 1996 09:21:40   MDEISHER
;// 
;// added $log$
;// moved SRC stuff to separate file.
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\codecs\g711\amacodec.cpp ===
/*--------------------------------------------------------------

 INTEL Corporation Proprietary Information  

 This listing is supplied under the terms of a license agreement  
 with INTEL Corporation and may not be copied nor disclosed 
 except in accordance with the terms of that agreement.

 Copyright (c) 1996 Intel Corporation.
 All rights reserved.

 $Workfile:   amacodec.cpp  $
 $Revision:   1.3  $
 $Date:   10 Dec 1996 22:41:18  $ 
 $Author:   mdeisher  $

--------------------------------------------------------------

amacodec.cpp

The generic ActiveMovie audio compression filter.

--------------------------------------------------------------*/

#include <streams.h>
#if !defined(CODECS_IN_DXMRTP)
#include <initguid.h>
#define INITGUID
#endif
#include <uuids.h>
#include <olectl.h>
#include <memory.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <mmsystem.h>
#include <mmreg.h>

#include "resource.h"
#define  DEFG711GLOBALS
#include "amacodec.h"
#include "amacprop.h"

#include "template.h"

///////////////////////////////////////////////////////////////////////
// *
// * Automatic registration
// *

static AMOVIESETUP_MEDIATYPE sudPinTypes[] = {
  {
     &MEDIATYPE_Audio,
     &MEDIASUBTYPE_PCM
  },
  {
     &MEDIATYPE_Audio,
     &MEDIASUBTYPE_MULAWAudio
  },
  {
     &MEDIATYPE_Audio,
     &MEDIASUBTYPE_ALAWAudio
  }
};



static AMOVIESETUP_PIN sudpPins [] =
{
  { L"Input"             // strName
    , FALSE              // bRendered
    , FALSE              // bOutput
    , FALSE              // bZero
    , FALSE              // bMany
    , &CLSID_NULL        // clsConnectsToFilter
    , L"Output"          // strConnectsToPin
    , NUMSUBTYPES        // nTypes
    , sudPinTypes        // lpTypes
  },
  { L"Output"            // strName
    , FALSE              // bRendered
    , TRUE               // bOutput
    , FALSE              // bZero
    , FALSE              // bMany
    , &CLSID_NULL        // clsConnectsToFilter
    , L"Input"           // strConnectsToPin
    , NUMSUBTYPES        // nTypes
    , sudPinTypes        // lpTypes
  }
};


AMOVIESETUP_FILTER sudG711Codec =
{
  &CLSID_G711Codec      // clsID
  , CODECG711LNAME        // strName
  , MERIT_DO_NOT_USE  // MERIT_NORMAL   // dwMerit
  , 2                 // nPins
  , sudpPins          // lpPin
};


// COM Global table of objects in this dll

#if !defined(CODECS_IN_DXMRTP)
CFactoryTemplate g_Templates[] =
{
	CFT_G711_ALL_FILTERS
};

// Count of objects listed in g_cTemplates
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);
#endif


// exported entry points for registration and unregistration (in this
// case they only call through to default implmentations).

#if !defined(CODECS_IN_DXMRTP)
HRESULT DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}


HRESULT DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}
#endif

///////////////////////////////////////////////////////////////////////
// *
// * CG711Codec
// *


// Initialise our instance count for debugging purposes
int CG711Codec::m_nInstanceCount = 0;


//
// CG711Codec Constructor
//

CG711Codec::CG711Codec(TCHAR *tszName, LPUNKNOWN punk, HRESULT *phr)
    : CTransformFilter(tszName, punk, CLSID_G711Codec)
    , CPersistStream(punk, phr)
    , m_InputSubType     (DEFINPUTSUBTYPE)
    , m_InputFormatTag   (DEFINPUTFORMTAG)
    , m_OutputSubType    (DEFOUTPUTSUBTYPE)
    , m_OutputFormatTag  (DEFOUTPUTFORMTAG)
    , m_nBitRateIndex    (0)
    , m_RestrictCaps     (FALSE)
    , m_EncStatePtr      (NULL)
    , m_DecStatePtr      (NULL)
    , m_nPCMFrameSize    (DEFPCMFRMSIZE)
    , m_nPCMLeftover     (0)
    , m_nCODLeftover     (0)
    , m_nCODFrameSize    (DEFCODFRMSIZE)
    , m_nInBufferSize    (0)
    , m_nOutBufferSize   (0)
    , m_nSilDetEnabled   (DEFSDENABLED)
#ifdef USESILDET
    , m_nSilDetThresh    (DEFSDTHRESH)
#endif
#if NUMSAMPRATES > 1
    , m_pSRCCopyBuffer   (NULL)
    , m_nSRCCBufSize     (0)
    , m_nSRCCount        (0)
    , m_nSRCLeftover     (0)
#endif
#ifdef REQUIRE_LICENSE
    , m_nLicensedToDec   (FALSE)
    , m_nLicensedToEnc   (FALSE)
#else
    , m_nLicensedToDec   (TRUE)
    , m_nLicensedToEnc   (TRUE)
#endif
{
    DbgFunc("CG711Codec");
    m_nThisInstance = ++m_nInstanceCount;
    m_nBitRate      = VALIDBITRATE[0];
    m_nChannels     = VALIDCHANNELS[0];
    m_nSampleRate   = VALIDSAMPRATE[0];

    m_pPCMBuffer  = (BYTE *) CoTaskMemAlloc(DEFPCMFRMSIZE);
    m_pCODBuffer  = (BYTE *) CoTaskMemAlloc(DEFCODFRMSIZE);

    if (m_pPCMBuffer == NULL || m_pCODBuffer == NULL)
    {
        *phr = E_OUTOFMEMORY;

        // the destructor will free all memory.
        return;
    }
} // end Constructor


//
// CG711Codec Destructor
//

CG711Codec::~CG711Codec()
{
  // free the state dword.  
  ResetState();
   
  // Delete the pins

  if (m_pInput)
  {
    delete m_pInput;
    m_pInput = NULL;
  }

  if (m_pOutput)
  {
    delete m_pOutput;
    m_pOutput = NULL;
  }

  // Free buffers

  if (m_pPCMBuffer != NULL) CoTaskMemFree(m_pPCMBuffer);
  if (m_pCODBuffer != NULL) CoTaskMemFree(m_pCODBuffer);
}


//
// CreateInstance:  Provide the way for COM to create a CG711Codec object
//

CUnknown *CG711Codec::CreateInstance(LPUNKNOWN punk, HRESULT *phr)
{
    CG711Codec *pNewObject = new CG711Codec(NAME(CODECG711NAME), punk, phr);

    if (pNewObject == NULL)
    {
      *phr = E_OUTOFMEMORY;
      return NULL;
    }

    if (FAILED(*phr))
    {
      delete pNewObject; 
      return NULL;
    }

    return pNewObject;
}


//
// GetSetupData
//

LPAMOVIESETUP_FILTER CG711Codec::GetSetupData()
{
  return &sudG711Codec;
}


//
// NonDelegatingQueryInterface
//
//   Reveals IIPEffect & ISpecifyPropertyPages
//
STDMETHODIMP CG711Codec::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
   if (riid == IID_ICodecSettings)
     return GetInterface((ICodecSettings *) this, ppv);
#if NUMBITRATES > 0
   else if (riid == IID_ICodecBitRate)
     return GetInterface((ICodecBitRate *) this, ppv);
#endif
#ifdef REQUIRE_LICENSE
   else if (riid == IID_ICodecLicense)
     return GetInterface((ICodecLicense *) this, ppv);
#endif
#ifdef USESILDET
   else if (riid == IID_ICodecSilDetector)
     return GetInterface((ICodecSilDetector *) this, ppv);
#endif
   else if (riid == IID_ISpecifyPropertyPages)
     return GetInterface((ISpecifyPropertyPages *) this, ppv);
   else
     return CTransformFilter::NonDelegatingQueryInterface(riid, ppv);
}


//
// Transform
//
// This is the generic transform member function.  It's task is to
// move data from one buffer, through the transform, and into the
// output buffer.
//
HRESULT CG711Codec::Transform(IMediaSample *pSource, IMediaSample *pDest)
{
  CAutoLock l(&m_MyCodecLock); // enter critical section auto free
                               // at end of scope

  DbgFunc("Transform");

  {
    BYTE  *pSourceBuffer, *pDestBuffer;

    // extract the actual buffer size in bytes
    unsigned long lSourceSize = pSource->GetActualDataLength();
    unsigned long lDestSize   = pDest->GetSize();

    // we need to have a sample to proceed
    ASSERT(lSourceSize);
    ASSERT(lDestSize);

    // NOTE: for stereo channels we just crank through the buffer.
    // if indivitual channel data analysis is required then m_nChannels is
    // available at (this->)

    // set i/o pointers
    pSource->GetPointer(&pSourceBuffer);
    pDest->GetPointer(&pDestBuffer);


    // call the proper transform
    // NOTE: dlg clean this up too many compares and should sizeof
    // BYTEs and format for len field, plus remove mult and divides

    if ((m_InputSubType == MEDIASUBTYPE_PCM)
        || (m_InputSubType == MEDIASUBTYPE_WAVE
            && m_InputFormatTag == WAVE_FORMAT_PCM)
        || (m_InputSubType == MEDIASUBTYPE_NULL
            && m_InputFormatTag == WAVE_FORMAT_PCM))    // compressing?
    {
#if NUMSAMPRATES > 1
      ASSERT(lDestSize
             >= lSourceSize * NATURALSAMPRATE
                / (COMPRESSION_RATIO[m_nBitRateIndex] * m_nSampleRate));
#else
      ASSERT(lDestSize >= lSourceSize / COMPRESSION_RATIO[m_nBitRateIndex]);
#endif

#ifdef REQUIRE_LICENSE
      if (!m_nLicensedToEnc)
      {
        ASSERT(NOTLICENSED);
        return E_UNEXPECTED;
      }
#endif

      if (m_nPCMFrameSize <= 2)  // *** codec is sample-based ***
      {
        ENC_transform(pSourceBuffer, pDestBuffer, lSourceSize,
                      lDestSize, m_EncStatePtr, m_OutputSubType, m_UseMMX);

        pDest->SetActualDataLength(lSourceSize
                                   / COMPRESSION_RATIO[m_nBitRateIndex]);
      }
      else                       // *** codec is frame-based ***
      {
        int  codeframesize = m_nCODFrameSize;  // actual code frame size
        BOOL done          = FALSE;
        int  inbytes;
        BYTE *inptr;
        BYTE *inend;
        int  outbytes;
        BYTE *outptr       = pDestBuffer;
        BYTE *outend       = pDestBuffer + lDestSize;

        // perform sample rate conversion if necessary

#if NUMSAMPRATES > 1
        if (m_nSampleRate != NATURALSAMPRATE)
        {
          inptr = m_pSRCCopyBuffer;
          SRConvert(pSourceBuffer, m_nSampleRate, lSourceSize, 
                    m_pSRCCopyBuffer, NATURALSAMPRATE, &inbytes);
        }
        else
        {
          inptr = pSourceBuffer;
          inbytes = lSourceSize;
        }
#else
        inptr = pSourceBuffer;
        inbytes = lSourceSize;
#endif

        inend = inptr + inbytes;

        if (inbytes + m_nPCMLeftover < m_nPCMFrameSize)
        {
          memcpy(m_pPCMBuffer + m_nPCMLeftover, inptr, inbytes);
          m_nPCMLeftover += inbytes;
          outbytes = 0;
        }
        else
        {
          // fill first speech frame

          memcpy(m_pPCMBuffer + m_nPCMLeftover, inptr,
                 m_nPCMFrameSize - m_nPCMLeftover);

          inptr += (m_nPCMFrameSize - m_nPCMLeftover);

          // start filling output buffer with leftovers from last time

          memcpy(outptr, m_pCODBuffer, m_nCODLeftover);

          outptr += m_nCODLeftover;

          // encode all of the available data, frame-by-frame

          while (!done)
          {
            // encode a frame

            ENC_transform(m_pPCMBuffer, m_pCODBuffer, m_nPCMFrameSize,
                          m_nCODFrameSize, m_EncStatePtr, m_OutputSubType,
                          m_UseMMX);

            // refill input buffer

            inbytes  = (int)(inend - inptr);
            if (inbytes > m_nPCMFrameSize)
              inbytes = m_nPCMFrameSize;

            memcpy(m_pPCMBuffer, inptr, inbytes);
            inptr += inbytes;

            // determine actual size of code frame (if applicable)

            SETCODFRAMESIZE(codeframesize, m_pCODBuffer);

            // write to output buffer

            outbytes = (int)(outend - outptr);
            if (outbytes > codeframesize)
              outbytes = codeframesize;

            memcpy(outptr, m_pCODBuffer, outbytes);
            outptr += outbytes;

            // check to see if buffers are exhausted

            if (inbytes < m_nPCMFrameSize)
            {
              m_nPCMLeftover = inbytes;

              m_nCODLeftover = codeframesize - outbytes;
              memmove(m_pCODBuffer, m_pCODBuffer + outbytes, m_nCODLeftover);

              done = TRUE;
            }
          }
        }
        pDest->SetActualDataLength((int)(outptr - pDestBuffer));
      }
    } 
    else    // decompressing
    {
#if NUMSAMPRATES > 1
      ASSERT(lDestSize >= lSourceSize * COMPRESSION_RATIO[m_nBitRateIndex]
                          * m_nSampleRate / NATURALSAMPRATE);
#else
      ASSERT(lDestSize >= lSourceSize * COMPRESSION_RATIO[m_nBitRateIndex]);
#endif

#ifdef REQUIRE_LICENSE
      if (!m_nLicensedToDec)
      {
        ASSERT(NOTLICENSED);
        return E_UNEXPECTED;
      }
#endif

      if (m_nPCMFrameSize <= 2)  // *** codec is sample-based ***
      {
        DEC_transform(pSourceBuffer, pDestBuffer, lSourceSize, lDestSize,
                      m_DecStatePtr, m_InputSubType, m_InputFormatTag, 
                      m_UseMMX);

        pDest->SetActualDataLength(lSourceSize
                                   * COMPRESSION_RATIO[m_nBitRateIndex]);
      }
      else                       // *** codec is frame-based ***
      {
        BOOL done    = FALSE;
        BYTE *inptr  = pSourceBuffer;
        BYTE *inend  = pSourceBuffer + lSourceSize;
        BYTE *outptr;
        BYTE *outend;
        int  inbytes = lSourceSize;
        int  outbytes;

#if NUMSAMPRATES > 1
        if (m_nSampleRate != NATURALSAMPRATE)
        {
          outptr = m_pSRCCopyBuffer;
          outend = m_pSRCCopyBuffer + m_nSRCCBufSize;
        }
        else
        {
          outptr = pDestBuffer;
          outend = pDestBuffer + lDestSize;
        }
#else
        outptr = pDestBuffer;
        outend = pDestBuffer + lDestSize;
#endif

        if (m_nCODLeftover == 0)  // is this a new frame?
        {
          // in multiple bit-rate decoders determine code
          // frame size from in-band information
        
          SETCODFRAMESIZE(m_nCODFrameSize,inptr);
        }
          
        if (inbytes + m_nCODLeftover < m_nCODFrameSize)
        {
          memcpy(m_pCODBuffer + m_nCODLeftover, inptr, inbytes);
          m_nCODLeftover += inbytes;
        }
        else
        {
          // complete the first code frame

          memcpy(m_pCODBuffer + m_nCODLeftover, inptr,
                 m_nCODFrameSize - m_nCODLeftover);

          inptr += (m_nCODFrameSize - m_nCODLeftover);

          // start filling output buffer with leftovers from last time

          memcpy(outptr, m_pPCMBuffer, m_nPCMLeftover);

          outptr += m_nPCMLeftover;

          // decode all of the available data, frame-by-frame

          while (!done)
          {
            // decode a frame

            DEC_transform(m_pCODBuffer, m_pPCMBuffer,
                          m_nCODFrameSize, m_nPCMFrameSize,
                          m_DecStatePtr, m_InputSubType, 
                          m_InputFormatTag, m_UseMMX);

            // determine size of next code frame (if applicable)

            inbytes  = (int)(inend - inptr);

            if (inbytes > 0)
            {
              // in multiple bit-rate decoders determine code
              // frame size from in-band information

              SETCODFRAMESIZE(m_nCODFrameSize,inptr);
            }

            // refill input buffer

            if (inbytes > m_nCODFrameSize)
              inbytes = m_nCODFrameSize;

            memcpy(m_pCODBuffer, inptr, inbytes);
            inptr += inbytes;

            // write to output buffer

            outbytes = (int)(outend - outptr);
            if (outbytes > m_nPCMFrameSize)
              outbytes = m_nPCMFrameSize;

            memcpy(outptr, m_pPCMBuffer, outbytes);
            outptr += outbytes;

            // check to see if buffers are exhausted

            if (inbytes < m_nCODFrameSize)
            {
              m_nCODLeftover = inbytes;

              m_nPCMLeftover = m_nPCMFrameSize - outbytes;
              memmove(m_pPCMBuffer, m_pPCMBuffer + outbytes, m_nPCMLeftover);

              done = TRUE;
            }
          }

#if NUMSAMPRATES > 1
          // perform sample rate conversion if necessary
          if (m_nSampleRate != NATURALSAMPRATE)
          {
            inbytes = outptr - m_pSRCCopyBuffer;

            SRConvert(m_pSRCCopyBuffer, NATURALSAMPRATE, inbytes,
                      pDestBuffer,      m_nSampleRate,   &outbytes);
          }
          else outbytes = outptr - pDestBuffer;
#else
          outbytes = (int)(outptr - pDestBuffer);
#endif
        }
        pDest->SetActualDataLength(outbytes);
      }
    }
  } // end scope for pointers 

  // transform is complete so now copy the necessary out-of-band
  // information

  {
    //
    // This section rewritten by ZoltanS 8-10-98
    //
    // Copy the sample time, making extra sure that we propagate all the
    // state from the source sample to the destination sample. (We are concerned
    // about the Sample_TimeValid and Sample_StopValid flags; see
    // amovie\sdk\blass\bases\amfilter.cpp.)
    // 

    REFERENCE_TIME TimeStart, TimeEnd;

    HRESULT hr = pSource->GetTime((REFERENCE_TIME *)&TimeStart,
                                  (REFERENCE_TIME *)&TimeEnd);

    if ( hr == VFW_S_NO_STOP_TIME )
    {
        // Got start time only; set start time only.

        pDest->SetTime( (REFERENCE_TIME *)&TimeStart,
                        NULL                          );
    }
    else if ( SUCCEEDED(hr) )
    {
        // Got both start and end times; set both.

        pDest->SetTime( (REFERENCE_TIME *)&TimeStart,
                        (REFERENCE_TIME *)&TimeEnd    );
    }
    else
    {
        // this is a hack for the media streaming terminal.
        TimeStart = 0;
        TimeEnd = 0;
        pDest->SetTime( (REFERENCE_TIME *)&TimeStart,
                        (REFERENCE_TIME *)&TimeEnd    );
    }

    //
    // ... any error return from GetTime, such as VFW_E_SAMPLE_TIME_NOT_SET,
    // means that we don't set the time on the outgoing sample.
    //
  }

  {
    // Copy the Sync point property

    HRESULT hr = pSource->IsSyncPoint();
    if (hr == S_OK) {
      pDest->SetSyncPoint(TRUE);
    }
    else if (hr == S_FALSE) {
      pDest->SetSyncPoint(FALSE);
    }
    else {      // an unexpected error has occured...
      return E_UNEXPECTED;
    }
  }

  return NOERROR;

} // end Transform


//
// ValidateMediaType
//
// This is called to check that the input or output pin type is
// appropriate.
//
HRESULT CG711Codec::ValidateMediaType(const CMediaType *pmt,
                                    PIN_DIRECTION direction)
{
  int format;
  int i;

  CAutoLock l(&m_MyCodecLock); // enter critical section auto free
                               // at end of scope

  DbgFunc("ValidateMediaType");
    
  LPWAVEFORMATEX lpWf = (LPWAVEFORMATEX)pmt->pbFormat;

  // reject up front any non-Audio types

  if (*pmt->Type() != MEDIATYPE_Audio)
  {
    DbgMsg("MediaType is not an audio type!");
    return E_INVALIDARG;
  }

  // we require that a wave format structure be present

  if (*pmt->FormatType() != FORMAT_WaveFormatEx )
  {
    DbgMsg("Invalid FormatType!");
    return E_INVALIDARG;
  }

  // reject unsupported subtypes

  if (*pmt->Subtype() != MEDIASUBTYPE_WAVE
      && *pmt->Subtype() != MEDIASUBTYPE_NULL)
  {
    for(i=0,format=-1;i<NUMSUBTYPES;i++)
      if (*pmt->Subtype() == *VALIDSUBTYPE[i])
        format = i;

    if (format == -1)
    {
      DbgMsg("Invalid MediaSubType!");
      return E_INVALIDARG;
    }
  }
  else        // format tag must be valid if subtype is not
  {
    for(i=0,format=-1;i<NUMSUBTYPES;i++)
      if (lpWf->wFormatTag == VALIDFORMATTAG[i])
        format = i;

    if (format == -1)
    {
      DbgMsg("Invalid FormatTag!");
      return E_INVALIDARG;
    }
  }

  // Reject invalid format blocks

  if (pmt->cbFormat < sizeof(PCMWAVEFORMAT))
  {
    DbgMsg("Invalid block format!");
    return E_INVALIDARG;
  }

  // Check bits per sample

  for(i=0;i<NUMSUBTYPES;i++)
    if (lpWf->wFormatTag == VALIDFORMATTAG[i])
      if (lpWf->wBitsPerSample != VALIDBITSPERSAMP[i])
      {
        DbgMsg("Wrong BitsPerSample!");
        return E_INVALIDARG;
      }
        
  // Check sampling rate

  if (lpWf->nSamplesPerSec <= 0)  // need positive rate for 
  {                               // downstream filters
    DbgMsg("Sample rate is invalid!");
    return E_INVALIDARG;
  }

#if NUMSAMPRATES > 0

  // NUMSAMPRATES==0 means that sample rate is unrestricted

  if (*pmt->Subtype() == MEDIASUBTYPE_PCM
      || ((*pmt->Subtype() == MEDIASUBTYPE_WAVE
           || *pmt->Subtype() == MEDIASUBTYPE_NULL)
          && lpWf->wFormatTag == WAVE_FORMAT_PCM))   // PCM
  {
    if (m_RestrictCaps && (lpWf->nSamplesPerSec != m_nSampleRate))
    {
      DbgMsg("Wrong SamplesPerSec in restricted mode!");
      return E_INVALIDARG;
    }

    for(int i=0;i<NUMSAMPRATES;i++)
      if (lpWf->nSamplesPerSec == VALIDSAMPRATE[i])
        break;

    if (i == NUMSAMPRATES)
    {
      DbgMsg("Wrong SamplesPerSec!");
      return E_INVALIDARG;
    }
  }
  else                                              // compressed
  {
    if (lpWf->nSamplesPerSec != NATURALSAMPRATE)
    {
      DbgMsg("Wrong SamplesPerSec!");
      return E_UNEXPECTED;
    }
  }

#endif

  // Check number of channels

#ifdef MONO_ONLY
  if (lpWf->nChannels != 1)
  {
    DbgMsg("Wrong nChannels!");
    return E_INVALIDARG;
  }
#endif

  // Pin-specific checks

  switch(direction)
  {
    case PINDIR_INPUT:

      // If capabilities are restricted, formats must match

      if (m_RestrictCaps)
      {
        if (*pmt->Subtype() != m_InputSubType)
        {
          if ((*pmt->Subtype() != MEDIASUBTYPE_WAVE
               && *pmt->Subtype() != MEDIASUBTYPE_NULL)
              || (lpWf->wFormatTag != m_InputFormatTag))
          {
            DbgMsg("Formats must match in restricted mode!");
            return E_INVALIDARG;
          }
        }
      }

      if (m_pOutput->IsConnected())
      {
        // determine output type index

        for(i=0;i<NUMSUBTYPES;i++)
          if (m_OutputSubType == *VALIDSUBTYPE[i])
            break;

        if (i == NUMSUBTYPES)
        {
          // subtype isn't valid so check format tag

          for(i=0;i<NUMSUBTYPES;i++)
            if (m_OutputFormatTag == VALIDFORMATTAG[i])
              break;

          if (((m_OutputSubType != MEDIASUBTYPE_NULL)
               && (m_OutputSubType != MEDIASUBTYPE_WAVE))
              || (i == NUMSUBTYPES))
          {
            DbgMsg("Bad output format in ValidateMediaType!");
            return E_INVALIDARG;
          }
        }

        if (!VALIDTRANS[format * NUMSUBTYPES + i])
        {
          DbgMsg("Inappropriate input type given output type!");
          return E_INVALIDARG;
        }
      }

      break;

    case PINDIR_OUTPUT:

      // If capabilities are restricted, subtypes must match

      if (m_RestrictCaps)
      {
        if (*pmt->Subtype() != m_OutputSubType)
        {
          if ((*pmt->Subtype() != MEDIASUBTYPE_WAVE
               && *pmt->Subtype() != MEDIASUBTYPE_NULL)
              || (lpWf->wFormatTag != m_OutputFormatTag))
          {
            DbgMsg("Formats must match in restricted mode!");
            return E_INVALIDARG;
          }
        }
      }

      if (m_pInput->IsConnected())
      {
        // determine input type index

        for(i=0;i<NUMSUBTYPES;i++)
          if (m_InputSubType == *VALIDSUBTYPE[i])
            break;

        if (i == NUMSUBTYPES)
        {
          // subtype isn't valid so check format tag

          for(i=0;i<NUMSUBTYPES;i++)
            if (m_InputFormatTag == VALIDFORMATTAG[i])
              break;

          if (((m_InputSubType != MEDIASUBTYPE_NULL)
               && (m_InputSubType != MEDIASUBTYPE_WAVE))
              || (i == NUMSUBTYPES))
          {
            DbgMsg("Bad input format in ValidateMediaType!");
            return E_INVALIDARG;
          }
        }

        if (!VALIDTRANS[i * NUMSUBTYPES + format])
        {
          DbgMsg("Inappropriate output type given input type!");
          return E_INVALIDARG;
        }

#if NUMSAMPRATES==0
        // if the filter has no sample rate restrictions, then we force
        // the output sampling rate to match the input

        if (lpWf->nSamplesPerSec != m_nSampleRate)
        {
          DbgMsg("Sampling rate doesn't match input!");
          return E_INVALIDARG;
        }
#endif

      }
      break;

    default :
      ASSERT(FALSE);
      return E_UNEXPECTED;
  }

  return NOERROR;

} // end ValidateMediaType


//
// CheckInputType
//
// This is called to make sure the input type requested up stream is
// acceptable. We do not lock access during this call because we are
// just checking information rather than writing.
//
HRESULT CG711Codec::CheckInputType(const CMediaType *pmt)
{
  DbgFunc("CheckInputType");
    
  return(ValidateMediaType(pmt, PINDIR_INPUT));
}


//
// CheckTransform
//
// Before the SetMediaTypes are called for each direction this
// function is given one last veto right.  Since we are a transformation
// the input and output formats are not the same, however, the rate and 
// channels should be identical.
// 

HRESULT CG711Codec::CheckTransform(const CMediaType *mtIn,
                                 const CMediaType *mtOut)
{
  int i,j;

  CAutoLock l(&m_MyCodecLock); // enter critical section auto free
                               // at end of scope

  DbgFunc("CheckTransform");

  LPWAVEFORMATEX lpWfIn = (LPWAVEFORMATEX) mtIn->Format();
  LPWAVEFORMATEX lpWfOut = (LPWAVEFORMATEX) mtOut->Format();

  // get input type index

  if (*mtIn->Subtype()==MEDIASUBTYPE_WAVE
      || *mtIn->Subtype()==MEDIASUBTYPE_NULL)
  {
    for(i=0;i<NUMSUBTYPES;i++)
      if (lpWfIn->wFormatTag == VALIDFORMATTAG[i])
        break;

    if (i == NUMSUBTYPES)
    {
      DbgMsg("Bad input SubType/FormatTag in CheckTransform!");
      return E_UNEXPECTED;
    }
  }
  else
  {
    for(i=0;i<NUMSUBTYPES;i++)
      if (*mtIn->Subtype() == *VALIDSUBTYPE[i])
        break;

    if (i == NUMSUBTYPES)
    {
      DbgMsg("Bad input SubType in CheckTransform!");
      return E_UNEXPECTED;
    }
  }

  // get output type index

  if (*mtOut->Subtype()==MEDIASUBTYPE_WAVE
      || *mtOut->Subtype()==MEDIASUBTYPE_NULL)
  {
    for(j=0;j<NUMSUBTYPES;j++)
      if (lpWfOut->wFormatTag == VALIDFORMATTAG[j])
        break;

    if (j == NUMSUBTYPES)
    {
      DbgMsg("Bad output SubType/FormatTag in CheckTransform!");
      return E_UNEXPECTED;
    }
  }
  else
  {
    for(j=0;j<NUMSUBTYPES;j++)
      if (*mtOut->Subtype() == *VALIDSUBTYPE[j])
        break;

    if (j == NUMSUBTYPES)
    {
      DbgMsg("Bad output SubType in CheckTransform!");
      return E_UNEXPECTED;
    }
  }

  // Check input/output type pair

  if (!VALIDTRANS[i * NUMSUBTYPES + j])
  {
    DbgMsg("Invalid transform pair!");
    return E_UNEXPECTED;
  }

  // Check that number of channels match

  if(lpWfIn->nChannels != lpWfOut->nChannels)
  {
    DbgMsg("Number of channels do not match!");
    return E_UNEXPECTED;
  }

  // Check that sample rates are supported

#if NUMSAMPRATES==0

  // if unrestricted, make sure input & output match

  if (lpWfIn->nSamplesPerSec != lpWfOut->nSamplesPerSec)
  {
    DbgMsg("Input and output sample rates do not match!");
    return E_UNEXPECTED;
  }

#else

  // if sample rate is restricted, make sure it is supported

  if (m_InputSubType == MEDIASUBTYPE_PCM
      || ((m_InputSubType == MEDIASUBTYPE_WAVE
           || m_InputSubType == MEDIASUBTYPE_NULL)
          && m_InputFormatTag == WAVE_FORMAT_PCM))   // compressing?
  {
    for(int i=0;i<NUMSAMPRATES;i++)
      if (lpWfIn->nSamplesPerSec == VALIDSAMPRATE[i])
        break;

    if (i == NUMSAMPRATES)
    {
      DbgMsg("Wrong input SamplesPerSec!");
      return E_UNEXPECTED;
    }

    if (lpWfOut->nSamplesPerSec != NATURALSAMPRATE)
    {
      DbgMsg("Wrong output SamplesPerSec!");
      return E_UNEXPECTED;
    }
  }
  else        // decompressing
  {
    for(int i=0;i<NUMSAMPRATES;i++)
      if (lpWfOut->nSamplesPerSec == VALIDSAMPRATE[i])
        break;

    if (i == NUMSAMPRATES)
    {
      DbgMsg("Wrong output SamplesPerSec!");
      return E_UNEXPECTED;
    }

    if (lpWfIn->nSamplesPerSec != NATURALSAMPRATE)
    {
      DbgMsg("Wrong input SamplesPerSec!");
      return E_UNEXPECTED;
    }
  }
#endif

  return NOERROR;
} // end CheckTransform


//
// DecideBufferSize
//
// Here we need to tell the output pin's allocator what size buffers we
// require. This can only be known when the input is connected and the 
// transform is established.  Are stands is - the output must be >=
// the input after the transform has been applied.
//

HRESULT CG711Codec::DecideBufferSize(IMemAllocator *pAlloc,
                                ALLOCATOR_PROPERTIES *pProperties)
{
    CAutoLock l(&m_MyCodecLock); // enter critical section auto free
                                 // at end of scope

    IMemAllocator *pMemAllocator;
    ALLOCATOR_PROPERTIES Request,Actual;
    int cbBuffer;

    DbgFunc("DecideBufferSize");

    // can only proceed if there's a media type on the input
    if (!m_pInput->IsConnected())
    {
        DbgMsg("Input pin not connected--cannot decide buffer size!");
        return E_UNEXPECTED;
    }

    
    // Get the input pin allocator, and get its size and count.
    // we don't care about his alignment and prefix.

    HRESULT hr = m_pInput->GetAllocator(&pMemAllocator);
    
    if (FAILED(hr))
    {
        DbgMsg("Out of memory in DecideBufferSize!");
        return hr;
    }

    hr = pMemAllocator->GetProperties(&Request);
    
    // we are read only so release
    pMemAllocator->Release();

    if (FAILED(hr))
    {
        return hr;
    }

    m_nInBufferSize  = Request.cbBuffer;

    DbgLog((LOG_MEMORY,1,TEXT("Setting Allocator Requirements")));
    DbgLog((LOG_MEMORY,1,TEXT("Input Buffer Count %d, Size %d"),
           Request.cBuffers, Request.cbBuffer));

    // check buffer requirements against our compression ratio

    if ((m_InputSubType == MEDIASUBTYPE_PCM)      // compressing?
        || (m_InputSubType == MEDIASUBTYPE_WAVE
            && m_InputFormatTag == WAVE_FORMAT_PCM)
          || (m_InputSubType == MEDIASUBTYPE_NULL
              && m_InputFormatTag == WAVE_FORMAT_PCM))
    {
#if NUMSAMPRATES > 1
      cbBuffer = Request.cbBuffer * NATURALSAMPRATE
                 / (COMPRESSION_RATIO[m_nBitRateIndex] * m_nSampleRate);

      if (cbBuffer * (COMPRESSION_RATIO[m_nBitRateIndex] * m_nSampleRate)
          != (Request.cbBuffer * ((UINT)NATURALSAMPRATE)))
      {
        cbBuffer += 1;  // add extra space for non-integer (on avg) part
      }
#else
      cbBuffer = Request.cbBuffer / COMPRESSION_RATIO[m_nBitRateIndex];

      if (cbBuffer * COMPRESSION_RATIO[m_nBitRateIndex] != Request.cbBuffer)
      {
        cbBuffer += 1;  // add extra space for non-integer (on avg) part
      }
#endif
      // force buffer size to be multiple of code frame size

      if (cbBuffer % VALIDCODSIZE[m_nBitRateIndex] != 0)
        cbBuffer = ((1 + cbBuffer / VALIDCODSIZE[m_nBitRateIndex])
                    * VALIDCODSIZE[m_nBitRateIndex]);
    }
    else     // decompressing
    {
      // Since we assume that the decoder can handle changes in bit
      // rate on the fly (or silence frames), we must consider the
      // maximum compression ratio when allocating buffers.

#if NUMSAMPRATES > 1
      cbBuffer = Request.cbBuffer * MAXCOMPRATIO * m_nSampleRate
                 / NATURALSAMPRATE;
#else
      cbBuffer = Request.cbBuffer * MAXCOMPRATIO;
#endif
    }

    // Pass the allocator requirements to our output side
    pProperties->cBuffers = Request.cBuffers; // the # of buffers must match
    pProperties->cbBuffer = cbBuffer;         // compression adjusted buffer
                                              // size

    m_nOutBufferSize = 0;                // clear this in case the set fails

    hr = pAlloc->SetProperties(pProperties, &Actual);

    if (FAILED(hr))
    {
        DbgMsg("Out of memory in DecideBufferSize!");
        return hr;
    }

    DbgLog((LOG_MEMORY,1,TEXT("Obtained Allocator Requirements")));
    DbgLog((LOG_MEMORY,1,
           TEXT("Output Buffer Count %d, Size %d, Alignment %d"),
           Actual.cBuffers, Actual.cbBuffer, Actual.cbAlign));

    // Make sure we obtained at least the minimum required size

    if ((Request.cBuffers > Actual.cBuffers) || (cbBuffer > Actual.cbBuffer))
    {
        DbgMsg("Allocator cannot satisfy request in DecideBufferSize!");
        return E_FAIL;
    }

    m_nOutBufferSize = Actual.cbBuffer;
            
  return NOERROR;

} // end DecideBufferSize


//
// StopStreaming
// 
// This member function resets some buffer variables when the stream
// is stopped.
//
HRESULT CG711Codec::StopStreaming()
{
  m_nPCMLeftover = 0;
  m_nCODLeftover = 0;

#if NUMSAMPRATES > 1
  m_nSRCCount    = 0;
  m_nSRCLeftover = 0;
#endif

  return(NOERROR);
}


//
// GetMediaType
// 
// This member function returns our preffered output media types by
// position.  It is called when an output pin is to be connected.  The
// types that are emumerated are based on the input format already
// connected.  If the input is linear PCM then we enumerate the 
// compressed types at the rate and channels of the input.  If the input
// is compressed, then we enumorate only 16 bit PCM.
//
HRESULT CG711Codec::GetMediaType(int iPosition, CMediaType *pMediaType)
{
    LPWAVEFORMATEX lpWf;
    HRESULT returnValue = NOERROR;  // we're optimistic
    int     ForceiPos = 0;
    int     i;

    CAutoLock l(&m_MyCodecLock);    // freed on end of scope

    DbgFunc("GetMediaType");

    // we must be connected to know our output pin media type
    if(!m_pInput->IsConnected())
    {
      DbgMsg("Input pin not connected in MyCodec::GetMediaType!");
      return E_UNEXPECTED;
    }

    // must be +
    if(iPosition < 0 )
    {
      DbgMsg("Negative index in MyCodec::GetMediaType!");
      return E_INVALIDARG;
    }

    // copy input to output with operator override
    *pMediaType = m_pInput->CurrentMediaType();

    // reflect compression type by overwriting params
    lpWf = (LPWAVEFORMATEX)pMediaType->pbFormat;

    // dlg this is not realy out of memory
    if(lpWf == NULL)
    {
      DbgMsg("Missing WAVEFORMAT in MyCodec::GetMediaType!");
      return E_INVALIDARG;
    }

    // Enumeration doesn't make sense if capabilities have been restricted.
    // In this case, the current pin types are the only types supported.
    //
    if (m_RestrictCaps)
    {
      if (iPosition > 0)
        returnValue = VFW_S_NO_MORE_ITEMS;
      else
      {
        ForceiPos = 0;                 // PCM output case
        for(i=1;i<NUMSUBTYPES;i++)     // compressed cases
          if (m_OutputSubType == *VALIDSUBTYPE[i])
            ForceiPos = i-1;
      }
    }
    else ForceiPos = iPosition;

    // Check to see if there are any more formats left

    if (ForceiPos >= NUMSUBTYPES-1)  // subtract one for PCM
    {
      returnValue = VFW_S_NO_MORE_ITEMS;
    }
    else
    {
      // Based on input format enumerate output formats

      if ((m_InputSubType == MEDIASUBTYPE_PCM)      // compressing?
          || (m_InputSubType == MEDIASUBTYPE_WAVE
              && lpWf->wFormatTag == WAVE_FORMAT_PCM)
          || (m_InputSubType == MEDIASUBTYPE_NULL
              && lpWf->wFormatTag == WAVE_FORMAT_PCM))
      {
        pMediaType->SetSubtype(VALIDSUBTYPE[ForceiPos+1]);
        lpWf->wFormatTag       = VALIDFORMATTAG[ForceiPos+1];
        lpWf->wBitsPerSample   = lpWf->wBitsPerSample
                                 / COMPRESSION_RATIO[m_nBitRateIndex];
        lpWf->nBlockAlign      = lpWf->wBitsPerSample * lpWf->nChannels / 8;
#if NUMSAMPRATES==0
        lpWf->nSamplesPerSec = m_nSampleRate;
#else
        lpWf->nSamplesPerSec = NATURALSAMPRATE;
#endif
        lpWf->nAvgBytesPerSec  = (int) ((DWORD) lpWf->nBlockAlign *
                                               lpWf->nSamplesPerSec);
      }
      else
      {
        pMediaType->SetSubtype(&MEDIASUBTYPE_PCM);
        lpWf->wFormatTag      = WAVE_FORMAT_PCM;
        lpWf->wBitsPerSample  = 16;        // only 16-bit PCM is supported
        lpWf->nBlockAlign     = lpWf->wBitsPerSample * lpWf->nChannels / 8;
        lpWf->nSamplesPerSec  = m_nSampleRate;
        lpWf->nAvgBytesPerSec = (int) ((DWORD) lpWf->nBlockAlign *
                                               lpWf->nSamplesPerSec);
      }
    }
    return returnValue;

} // end GetMediaType


//
// SetMediaType
//
// This function is called when a connection attempt has succeeded.
// It indicates to the filter that a wave type has been settled upon
// for this pin.  Here we snap shot the format tag and channel.  The
// format allows us to easily know which conversion to perform during
// the transform function.  This information could be condensed down
// by establishing a function pointer based on this information.
// (rather than checking these flags in the transform).  Also it MIGHT
// be necessary to locking access to these format values incase they
// change on the fly. Our current assumption is the transform will
// cease prior to these values changing in this function call.
//
//
HRESULT CG711Codec::SetMediaType(PIN_DIRECTION direction,
                                 const CMediaType *pmt){

    CAutoLock l(&m_MyCodecLock); // enter critical section auto free
                                 // at end of scope

    DbgFunc("SetMediaType");

    // Record what we need for doing the actual transform 
    // this could be done by querying the media type also 

    LPWAVEFORMATEX lpWf = (LPWAVEFORMATEX) pmt->Format();

    switch(direction)
    {
      case PINDIR_INPUT:
        m_InputSubType   = *pmt->Subtype();
        m_InputFormatTag = lpWf->wFormatTag;
        m_nChannels      = lpWf->nChannels;
#if NUMSAMPRATES==0
        // sample rate is unrestricted

        m_nSampleRate    = lpWf->nSamplesPerSec;
#else
        // when sample rate is restricted, the sample rate of the
        // compressed data is fixed at NATURALSAMPRATE and the sample
        // rate of the PCM data is one of the supported rates

        if ((m_InputSubType == MEDIASUBTYPE_PCM)
            || ((m_InputSubType == MEDIASUBTYPE_WAVE
                 || m_InputSubType == MEDIASUBTYPE_NULL)
                && m_InputFormatTag == WAVE_FORMAT_PCM))
          m_nSampleRate    = lpWf->nSamplesPerSec;
#endif
        break;
    
      case PINDIR_OUTPUT:
        m_OutputSubType   = *pmt->Subtype();
        m_OutputFormatTag = lpWf->wFormatTag;
        m_nChannels       = lpWf->nChannels;
        break;

      default:
        ASSERT(0);
        return E_UNEXPECTED;
    } // end of direction switch 
     

    // Call the base class to do its thing
    HRESULT hr = CTransformFilter::SetMediaType(direction, pmt);

    if (FAILED(hr)) return hr;

    hr = InitializeState(direction);

    return hr;

} // end SetMediaType


//
// InitializeState
//
HRESULT CG711Codec::InitializeState(PIN_DIRECTION direction)
{
  if (direction == PINDIR_OUTPUT)
  {
    // dynamically allocate encoder or decoder structure

    if ((m_InputSubType == MEDIASUBTYPE_PCM)      // compressing?
        || (m_InputSubType == MEDIASUBTYPE_WAVE
            && m_InputFormatTag == WAVE_FORMAT_PCM)
          || (m_InputSubType == MEDIASUBTYPE_NULL
              && m_InputFormatTag == WAVE_FORMAT_PCM))
    {
      //encoder

      if (m_EncStatePtr == NULL)
      {
        m_EncStatePtr = (ENCODERobj *)CoTaskMemAlloc(sizeof(ENCODERobj));

        if (m_EncStatePtr == NULL)
        {
          return E_OUTOFMEMORY;
        }

        // call the encoder initialization function
        // This macro is empty for this codec.
        // ENC_create(m_EncStatePtr, m_nBitRate, m_nSilDetEnabled, m_UseMMX);

#ifdef USESILDET
        SILDETTHRESH(m_EncStatePtr, m_nSilDetThresh);
#endif
      }
    }
    else
    {
      //decoder

      if (m_DecStatePtr == NULL)
      {
        m_DecStatePtr = (DECODERobj *)CoTaskMemAlloc(sizeof(DECODERobj));

        if (m_DecStatePtr == NULL)
        {
          return E_OUTOFMEMORY;
        }

        //call the decoder initialization function
        // This macro is empty for this codec.
        // DEC_create(m_DecStatePtr, m_nBitRate, m_nSilDetEnabled, m_UseMMX);
      }
    }
  }
  return NOERROR;

} // end of InitializeState


//
//  GetPin - allocates the MyCodec input and output pins
//
//  This function will be called to get the pointer to
//  the input and output pins by the filter graph manager,
//  once after instantiating the object.
//
CBasePin* CG711Codec::GetPin(int n)
{
    HRESULT hr = S_OK;

    if (m_pInput == NULL )        // Instantiate the INPUT pin
    {
        m_pInput = new CMyTransformInputPin(
                NAME("MyTransform input pin"),
                this,      // Owner filter
                &hr,       // Result code
                L"Input"   // Pin name 
                );
    
        // a failed return code should delete the object
        if (FAILED(hr))
        {
            delete m_pInput;
            m_pInput = NULL;
            return NULL;
        }
    }
    
    if (m_pOutput == NULL)      // Instantiate the OUTPUT pin
    {
        m_pOutput = new CMyTransformOutputPin(
                NAME("MyTransform output pin"),
                this,       // Owner filter
                &hr,        // Result code
                L"Output"   // Pin name 
                ); 
        
        // failed return codes cause both objects to be deleted
        if (FAILED(hr))
        {
            delete m_pInput;
            m_pInput = NULL;

            delete m_pOutput;
            m_pOutput = NULL;
            return NULL;
        }
    }

    // Find which pin is required
    switch(n)
    {
    case 0:
        return m_pInput;
    
    case 1:
        return m_pOutput;
    }

    return NULL;
}


///////////////////////////////////////////////////////////////////////
// *
// * Input Pin (supports enumeration of input pin types)
// *

//
// CMyTransformInputPin - Constructor
//
CMyTransformInputPin::CMyTransformInputPin(TCHAR *pObjectName,
                                       CTransformFilter *pTransformFilter,
                                       HRESULT * phr,
                                       LPCWSTR pName)
    : CTransformInputPin(pObjectName, pTransformFilter, phr, pName)
{
    m_nThisInstance = ++m_nInstanceCount;
    DbgFunc("CMyTransformInputPin");
}


// Initialise our instance count for debugging purposes
int CMyTransformInputPin::m_nInstanceCount = 0;

//
// GetMediaType - an override so that we can enumerate input types
//
HRESULT CMyTransformInputPin::GetMediaType(int iPosition, 
                                           CMediaType *pMediaType)
{
    LPWAVEFORMATEX lpWf;
    CG711Codec *pMyCodec;
    int ForceiPos;
    int channels;
    int restricted;
    int samprate;
    int transform;

    CAutoLock l(m_pLock);                       // freed on end of scope

    DbgFunc("CBaseInputPin::GetMediaType");

    pMyCodec = (CG711Codec *) m_pTransformFilter; // access MyCodec interface

    // we must be disconnected to set our input pin media type

	// ZCS bugfix 6-26-97
    //if(!pMyCodec->IsUnPlugged())
    //{
    //  DbgMsg("Must be disconnected to query input pin!");
    //  return E_UNEXPECTED;
    //}

    // must be +
    if(iPosition < 0 )
    {
      DbgMsg("Negative index!");
      return E_INVALIDARG;
    }

    pMyCodec->get_Channels(&channels, -1);
    pMyCodec->RevealCaps(&restricted);
    pMyCodec->get_SampleRate(&samprate, -1);
    pMyCodec->get_Transform(&transform);

    // initialize mediatype

    pMediaType->SetType(&MEDIATYPE_Audio);
    pMediaType->SetFormatType(&FORMAT_WaveFormatEx);
    pMediaType->ReallocFormatBuffer(sizeof(WAVEFORMATEX));
    lpWf = (LPWAVEFORMATEX)pMediaType->pbFormat;
    if(lpWf == NULL)
    {
      DbgMsg("Unable to allocate WAVEFORMATEX structure!");
      return E_OUTOFMEMORY;
    }
    lpWf->nChannels      = (WORD)channels;
    lpWf->nSamplesPerSec = samprate;
    lpWf->cbSize = 0;

    // Enumeration doesn't make sense if capabilities have been restricted.
    // In this case, the current pin types are the only types supported.
    //
    if (restricted)
    {
      if (iPosition > 0)
        return VFW_S_NO_MORE_ITEMS;
      else
        ForceiPos = transform / NUMSUBTYPES;  // input type index
    }
    else ForceiPos = iPosition;

    // Check to see if there are any more formats left

    if (ForceiPos >= NUMSUBTYPES)
    {
      return VFW_S_NO_MORE_ITEMS;
    }
    else
    {
      pMediaType->SetSubtype(VALIDSUBTYPE[ForceiPos]);

      lpWf->wFormatTag      = VALIDFORMATTAG[ForceiPos];
      lpWf->wBitsPerSample  = (WORD)VALIDBITSPERSAMP[ForceiPos];
      lpWf->nChannels       = (WORD)channels;
      lpWf->nBlockAlign     = lpWf->wBitsPerSample * lpWf->nChannels / 8;

      if (VALIDFORMATTAG[ForceiPos] == WAVE_FORMAT_PCM)
        lpWf->nSamplesPerSec = samprate;
      else
        lpWf->nSamplesPerSec = NATURALSAMPRATE;

      lpWf->nAvgBytesPerSec = (int) ((DWORD) lpWf->nBlockAlign *
                                             lpWf->nSamplesPerSec);
      lpWf->cbSize = 0;
      return NOERROR;
    }
} // end CBaseInputPin::GetMediaType

//
//  CheckMediaType - check if mediatype is supported by MyCodec
//
//  Called from the Connect\AgreeMediaType\TryMediaType of the 
//  upstream filter's output pin.
//
HRESULT CMyTransformInputPin::CheckMediaType(const CMediaType *mtIn )
{
  DbgFunc("CMyTransformInputPin::CheckMediaType");

  // Validate the parameter
  CheckPointer(mtIn,E_INVALIDARG);
  ValidateReadWritePtr(mtIn,sizeof(CMediaType));

  return ((CG711Codec *)m_pTransformFilter)->ValidateMediaType(mtIn,
                                                             PINDIR_INPUT);
}


///////////////////////////////////////////////////////////////////////
// *
// * Output Pin (fixes the connection model when enumeration of input
// * pin types is required)
// *

//
// CMyTransformOutputPin - Constructor
//
CMyTransformOutputPin::CMyTransformOutputPin(TCHAR *pObjectName,
                                       CTransformFilter *pTransformFilter,
                                       HRESULT * phr,
                                       LPCWSTR pName)
    : CTransformOutputPin(pObjectName, pTransformFilter, phr, pName)
{
    m_nThisInstance = ++m_nInstanceCount;
    DbgFunc("CMyTransformOutputPin");
}


// Initialise our instance count for debugging purposes
int CMyTransformOutputPin::m_nInstanceCount = 0;

//
//  CheckMediaType - check if mediatype is supported by MyCodec
//
//  Called by MyCodec's output pin.
//
HRESULT CMyTransformOutputPin::CheckMediaType(const CMediaType *mtIn )
{
  DbgFunc("CMyTransformOutputPin::CheckMediaType");

  // Validate the parameter
  CheckPointer(mtIn,E_INVALIDARG);
  ValidateReadWritePtr(mtIn,sizeof(CMediaType));

  return ((CG711Codec *)m_pTransformFilter)->ValidateMediaType(mtIn,
                                                             PINDIR_OUTPUT);
}


///////////////////////////////////////////////////////////////////////
// *
// * Persistent stream (supports saving filter graph to .grf file)
// *

STDMETHODIMP CG711Codec::GetClassID(CLSID *pClsid)
{
  *pClsid = CLSID_G711Codec;

  return NOERROR;
}


// This return value must be >= the persistent data size stored
int CG711Codec::SizeMax()
{
  return (5*sizeof(int) + 4);   // 4 for good luck only
}

//
// WriteToStream
//
// Dump necessary member variables to an unknown stream for later use.
// This information is necessary for the filter to properly transform
// without type negotiation.  you must change SizeMax above if these
// change.
//
HRESULT CG711Codec::WriteToStream(IStream *pStream)
{
    HRESULT hr;
    int     transform;

    get_Transform(&transform);

    hr = WriteInt(pStream, transform);

    if (FAILED(hr)) return hr;
    
    hr = WriteInt(pStream, m_nChannels);
    if (FAILED(hr)) return hr;
    
    hr = WriteInt(pStream, m_nSampleRate);
    if (FAILED(hr)) return hr;
    
    hr = WriteInt(pStream, m_nBitRateIndex);
    if (FAILED(hr)) return hr;
    
    hr = WriteInt(pStream, m_nSilDetEnabled);
    if (FAILED(hr)) return hr;
    
    return NOERROR;
}

//
// ReadFromStream
//
// Read back the above persistent information in the same order? 
// NOTE: any info captured during negotiation that is needed 
//       during run time must be restored at this point. 
//
HRESULT CG711Codec::ReadFromStream(IStream *pStream)
{
    HRESULT hr;
    int i,j,k;

    i = ReadInt(pStream, hr);
    if (FAILED(hr)) return hr;

    j = i / NUMSUBTYPES;
    k = i - j * NUMSUBTYPES;

    if (j < 0 || k < 0 || j >= NUMSUBTYPES || k >= NUMSUBTYPES)
    {
      DbgMsg("Invalid transform type in saved filter graph!");
      return(E_UNEXPECTED);
    }

    m_InputSubType    = *VALIDSUBTYPE[j];
    m_InputFormatTag  = VALIDFORMATTAG[j];
    m_OutputSubType   = *VALIDSUBTYPE[k];
    m_OutputFormatTag = VALIDFORMATTAG[k];

    m_nChannels = ReadInt(pStream, hr);
    if (FAILED(hr)) return hr;

    m_nSampleRate = ReadInt(pStream, hr);
    if (FAILED(hr)) return hr;

    m_nBitRateIndex = ReadInt(pStream, hr);
    if (FAILED(hr)) return hr;
    m_nBitRate = VALIDBITRATE[m_nBitRateIndex];

    m_nSilDetEnabled = ReadInt(pStream, hr);
    if (FAILED(hr)) return hr;

    m_RestrictCaps = TRUE;     // restrict capabilities to those read
                               // from the persistence file

    hr = InitializeState(PINDIR_OUTPUT);

    return hr;
}


//
// GetPages
//
// Returns the clsid's of the property pages we support
STDMETHODIMP CG711Codec::GetPages(CAUUID *pPages)
{
    if (IsBadWritePtr(pPages, sizeof(CAUUID)))
    {
        return E_POINTER;
    }

    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
    if (pPages->pElems == NULL)
    {
        return E_OUTOFMEMORY;
    }

    *(pPages->pElems) = CLSID_G711CodecPropertyPage;

    return NOERROR;
}


//
// ResetState:  Deallocates coder state if necessary
//
STDMETHODIMP  CG711Codec::ResetState()
{
  if (m_EncStatePtr != NULL)
    CoTaskMemFree(m_EncStatePtr);

  if (m_DecStatePtr != NULL)
    CoTaskMemFree(m_DecStatePtr);

  m_EncStatePtr = NULL;
  m_DecStatePtr = NULL;

  return NOERROR;
}


//
// RevealCaps:  Return restrictions
//
STDMETHODIMP  CG711Codec::RevealCaps(int *restricted)
{
  *restricted = m_RestrictCaps;

  return NOERROR;
}


/*
//$Log:   K:\proj\mycodec\quartz\vcs\amacodec.cpv  $
# 
#    Rev 1.3   10 Dec 1996 22:41:18   mdeisher
# ifdef'ed out SRC vars when SRC not used.
# 
#    Rev 1.2   10 Dec 1996 15:19:48   MDEISHER
# removed unnecessary includes.
# moved debugging macros to header.
# added DEFG711GLOBALS so that globals are only defined once.
# ifdef'ed out the licensing checks when license interface not present.
# 
#    Rev 1.1   09 Dec 1996 09:26:58   MDEISHER
# 
# moved sample rate conversion method to separate file.
# 
#    Rev 1.0   09 Dec 1996 09:05:56   MDEISHER
# Initial revision.
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\codecs\g711\amacprop.h ===
/*--------------------------------------------------------------

 INTEL Corporation Proprietary Information  

 This listing is supplied under the terms of a license agreement  
 with INTEL Corporation and may not be copied nor disclosed 
 except in accordance with the terms of that agreement.

 Copyright (c) 1996 Intel Corporation.
 All rights reserved.

 $Workfile:   amacprop.h  $
 $Revision:   1.0  $
 $Date:   09 Dec 1996 09:06:52  $ 
 $Author:   MDEISHER  $

--------------------------------------------------------------

amacprop.h

The generic ActiveMovie audio compression filter property page
header.

--------------------------------------------------------------*/

#define WM_PROPERTYPAGE_ENABLE  (WM_USER + 100)

////////////////////////////////////////////////////////////////////
// CG711CodecProperties:  Property page class definition
//
class CG711CodecProperties : public CBasePropertyPage
{
  public:

    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

  private:

    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnDeactivate();
    HRESULT OnApplyChanges();
    void    RefreshSettings();
    void    SetButtons(HWND hwndParent);

    CG711CodecProperties(LPUNKNOWN lpunk, HRESULT *phr);

    static int        m_nInstanceCount; // Global count of prop page instances
    int               m_nThisInstance;  // This instance's count
    int               m_iTransformType;
    int               m_iBitRate;
    int               m_iSampleRate;
    ICodecSettings    *m_pCodecSettings;

#if NUMBITRATES > 0
    ICodecBitRate     *m_pCodecBitRate;
#endif

#ifdef USESILDET
    ICodecSilDetector *m_pCodecSilDet;
    void        OnSliderNotification(WPARAM wParam, WORD wPosition);
    HWND        m_hwndSDThreshSlider;
    int         m_iSilDetEnabled;
    int         m_iSilDetThresh;
    int         *m_pDetection;
#endif
};

/*
//$Log:   K:\proj\mycodec\quartz\vcs\amacprop.h_v  $
;// 
;//    Rev 1.0   09 Dec 1996 09:06:52   MDEISHER
;// Initial revision.
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\codecs\g711\amacprop.cpp ===
/*--------------------------------------------------------------

 INTEL Corporation Proprietary Information  

 This listing is supplied under the terms of a license agreement  
 with INTEL Corporation and may not be copied nor disclosed 
 except in accordance with the terms of that agreement.

 Copyright (c) 1996 Intel Corporation.
 All rights reserved.

 $Workfile:   amacprop.cpp  $
 $Revision:   1.1  $
 $Date:   10 Dec 1996 15:24:30  $ 
 $Author:   MDEISHER  $

--------------------------------------------------------------

amacprop.cpp

The generic ActiveMovie audio compression filter property page.

--------------------------------------------------------------*/

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <streams.h>
#include "resource.h"
#include "amacodec.h"
#include "amacprop.h"

///////////////////////////////////////////////////////////////////////
// *
// * CG711CodecProperties
// *

//
// CreateInstance
//
// The only allowed way to create Bouncing ball's!
CUnknown *CG711CodecProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
  CUnknown *punk = new CG711CodecProperties(lpunk, phr);
  if (punk == NULL)
  {
    *phr = E_OUTOFMEMORY;
  }

  return punk;
}


//
// CG711CodecProperties::Constructor
//
CG711CodecProperties::CG711CodecProperties(LPUNKNOWN pUnk, HRESULT *phr)
    : CBasePropertyPage(NAME("MyCodec Property Page"),pUnk,
        IDD_G711CodecPROP, IDS_TITLE)
    , m_pCodecSettings(NULL)
#if NUMBITRATES > 0
    , m_pCodecBitRate(NULL)
#endif
#ifdef USESILDET
    , m_pCodecSilDet(NULL)
#endif
    , m_iTransformType(0)
    , m_iBitRate(0)
    , m_iSampleRate(0)
#ifdef USESILDET
    , m_iSilDetEnabled(FALSE)
    , m_iSilDetThresh(DEFSDTHRESH)
#endif
{
}


//
// OnReceiveMessages
//
// Handles the messages for our property window

INT_PTR CG711CodecProperties::OnReceiveMessage( HWND hwnd
                                , UINT uMsg
                                , WPARAM wParam
                                , LPARAM lParam) 
{
  int i,j,k;

  switch (uMsg)
  {
    case WM_PROPERTYPAGE_ENABLE:

      // private message to enable/disable controls.  if lParam, then
      // enable the controls that affect the format; if not lParam,
      // then disable the controls that affect the format.

      for(i=0;i<NUMSUBTYPES;i++)
        EnableWindow(GetDlgItem (hwnd, INBUTTON[i]), (BOOL) lParam);

      for(i=0;i<NUMSUBTYPES;i++)
        EnableWindow(GetDlgItem (hwnd, OUTBUTTON[i]), (BOOL) lParam);

      for(i=0;i<NUMSAMPRATES;i++)
        EnableWindow(GetDlgItem (hwnd, SRBUTTON[i]), (BOOL) lParam);

      if (m_iTransformType / NUMSUBTYPES)  // 0 ==> compressing
      {
        for(i=0;i<NUMENCCTRLS;i++)
          EnableWindow(GetDlgItem (hwnd, ENCBUTTON[i]), (BOOL) FALSE);

        for(i=0;i<NUMDECCTRLS;i++)
          EnableWindow(GetDlgItem (hwnd, DECBUTTON[i]), (BOOL) lParam);

#ifdef USESILDET
        EnableWindow(GetDlgItem (hwnd, IDC_SDTHRESH), (BOOL) FALSE);
#endif
      }
      else
      {
        for(i=0;i<NUMENCCTRLS;i++)
          EnableWindow(GetDlgItem (hwnd, ENCBUTTON[i]), (BOOL) lParam);

        for(i=0;i<NUMDECCTRLS;i++)
          EnableWindow(GetDlgItem (hwnd, DECBUTTON[i]), (BOOL) FALSE);

#ifdef USESILDET
        if (m_iSilDetEnabled)
          EnableWindow(GetDlgItem (hwnd, IDC_SDTHRESH), (BOOL) TRUE);
        else
          EnableWindow(GetDlgItem (hwnd, IDC_SDTHRESH), (BOOL) FALSE);
#endif
      }

      break;

    case WM_HSCROLL:
    case WM_VSCROLL:
#ifdef USESILDET
      if ((HWND) lParam == m_hwndSDThreshSlider)
        OnSliderNotification(LOWORD (wParam), HIWORD (wParam));
#endif
      return TRUE;

    case WM_COMMAND:

      // find input & output types

      i = m_iTransformType / NUMSUBTYPES;     // current input type
      j = m_iTransformType - i * NUMSUBTYPES; // current output type

      // if input button was pushed then set transform

      for(k=0;k<NUMSUBTYPES;k++)
        if (LOWORD(wParam) == INBUTTON[k])
        {
          // if transform is not valid then find one that is

          if (! VALIDTRANS[k*NUMSUBTYPES+j])
            for(j=0;j<NUMSUBTYPES;j++)
              if (VALIDTRANS[k*NUMSUBTYPES+j])
                break;

          m_pCodecSettings->put_Transform(k*NUMSUBTYPES+j);

          break;
        }

      // if output button was pushed then set transform

      for(k=0;k<NUMSUBTYPES;k++)
        if (LOWORD(wParam) == OUTBUTTON[k])
        {
          // if transform is not valid then find one that is

          if (! VALIDTRANS[i*NUMSUBTYPES+k])
            for(i=0;i<NUMSUBTYPES;i++)
              if (VALIDTRANS[i*NUMSUBTYPES+k])
                break;

          m_pCodecSettings->put_Transform(i*NUMSUBTYPES+k);

          break;
        }

      // if sample rate button was pushed then set it

      for(k=0;k<NUMSAMPRATES;k++)
        if (LOWORD(wParam) == SRBUTTON[k])
        {
          m_pCodecSettings->put_SampleRate(VALIDSAMPRATE[k]);

          break;
        }

#if NUMBITRATES > 0
      // if bit rate button was pushed then set it

      for(k=0;k<NUMBITRATES;k++)
        if (LOWORD(wParam) == BRBUTTON[k])
        {
          m_pCodecBitRate->put_BitRate(VALIDBITRATE[k]);

          break;
        }
#endif

#ifdef USESILDET
      if (LOWORD(wParam) == IDC_SILDET)
      {
        if (m_iSilDetEnabled)                     // toggle state
          m_pCodecSilDet->put_SilDetEnabled(FALSE);
        else
          m_pCodecSilDet->put_SilDetEnabled(TRUE);
      }
#endif

      SetButtons(m_hwnd);
      return TRUE;

      case WM_DESTROY:
        return TRUE;

      default:
        return FALSE;

    }
    return TRUE;
}


//
// RefreshSettings
//
// Read the filter settings

void CG711CodecProperties::RefreshSettings()
{
  int i,j;

  m_pCodecSettings->get_Transform(&m_iTransformType);

#if NUMBITRATES > 0
  m_pCodecBitRate->get_BitRate(&j,-1);
  for(i=0;i<NUMBITRATES;i++)
    if (VALIDBITRATE[i] == (UINT)j)
      break;
  m_iBitRate = i;
#endif

  m_pCodecSettings->get_SampleRate(&j,-1);
  for(i=0;i<NUMSAMPRATES;i++)
    if (VALIDSAMPRATE[i] == (UINT)j)
      break;
  m_iSampleRate = i;

#ifdef USESILDET
  m_iSilDetEnabled = m_pCodecSilDet->IsSilDetEnabled();
  m_pCodecSilDet->get_SilDetThresh(&m_iSilDetThresh);
#endif

}


//
// OnConnect
//
// Give us the filter to communicate with

HRESULT CG711CodecProperties::OnConnect(IUnknown *punk)
{
  HRESULT hr;

  //
  // Get ICodecSettings interface
  //

  if (punk == NULL)
  {
    DbgMsg("You can't call OnConnect() with a NULL pointer!!");
    return(E_POINTER);
  }

  ASSERT(m_pCodecSettings == NULL);
  hr = punk->QueryInterface(IID_ICodecSettings, (void **)&m_pCodecSettings);
  if (FAILED(hr))
  {
    DbgMsg("Can't get ICodecSettings interface.");
    return E_NOINTERFACE;
  }
  ASSERT(m_pCodecSettings);

#if NUMBITRATES > 0
  ASSERT(m_pCodecBitRate == NULL);
  hr = punk->QueryInterface(IID_ICodecBitRate, (void **)&m_pCodecBitRate);
  if (FAILED(hr))
  {
    DbgMsg("Can't get ICodecBitRate interface.");
    return E_NOINTERFACE;
  }
  ASSERT(m_pCodecBitRate);
#endif

#ifdef USESILDET
  ASSERT(m_pCodecSilDet == NULL);
  hr = punk->QueryInterface(IID_ICodecSilDetector, (void **)&m_pCodecSilDet);
  if (FAILED(hr))
  {
    DbgMsg("Can't get ICodecSilDetector interface.");
    return E_NOINTERFACE;
  }
  ASSERT(m_pCodecSilDet);
#endif

  // Get current filter state

  RefreshSettings();

  return NOERROR;
}


//
// OnDisconnect
//
// Release the interface

HRESULT CG711CodecProperties::OnDisconnect()
{
  int i,j;

  // Release the interface

  if (m_pCodecSettings == NULL)
    return(E_UNEXPECTED);

#if NUMBITRATES > 0
  if (m_pCodecBitRate == NULL)
    return(E_UNEXPECTED);
#endif

#ifdef USESILDET
  if (m_pCodecSilDet == NULL)
    return(E_UNEXPECTED);
#endif

  // write settings if possible

  if(m_pCodecSettings->put_Transform(m_iTransformType) != NOERROR)
    m_pCodecSettings->get_Transform(&m_iTransformType);

  if(m_pCodecSettings->put_SampleRate(VALIDSAMPRATE[m_iSampleRate]) != NOERROR)
  {
    m_pCodecSettings->get_SampleRate(&j,-1);
    for(i=0;i<NUMSAMPRATES;i++)
      if (VALIDSAMPRATE[i] == (UINT)j)
        break;
    m_iSampleRate = i;
  }

  m_pCodecSettings->Release();
  m_pCodecSettings = NULL;

#if NUMBITRATES > 0
  if(m_pCodecBitRate->put_BitRate(VALIDSAMPRATE[m_iBitRate]) != NOERROR)
  {
    m_pCodecBitRate->get_BitRate(&j,-1);
    for(i=0;i<NUMBITRATES;i++)
      if (VALIDBITRATE[i] == (UINT)j)
        break;
    m_iBitRate = i;
  }

  m_pCodecBitRate->Release();
  m_pCodecBitRate = NULL;
#endif

#ifdef USESILDET
  if(m_pCodecSilDet->put_SilDetEnabled(m_iSilDetEnabled) != NOERROR)
    m_iSilDetEnabled = m_pCodecSilDet->IsSilDetEnabled();

  if(m_pCodecSilDet->put_SilDetThresh(m_iSilDetThresh) != NOERROR)
    m_pCodecSilDet->get_SilDetThresh(&m_iSilDetThresh);

  m_pCodecSilDet->Release();
  m_pCodecSilDet = NULL;
#endif  // USESILDET

  return(NOERROR);
}


//
// OnActivate
//
// Called on dialog creation

HRESULT CG711CodecProperties::OnActivate(void)
{

#ifdef USESILDET
  // get slider handle
  m_hwndSDThreshSlider = GetDlgItem (m_hwnd, IDC_SDTHRESH);

  // set slider range
  SendMessage(m_hwndSDThreshSlider, TBM_SETRANGE, TRUE,
              MAKELONG(MINSDTHRESH, MAXSDTHRESH) );
#endif

  // initialize button settings

  SetButtons(m_hwnd);

  // Disable the buttons if filter is plugged in

  if (m_pCodecSettings->IsUnPlugged())
    PostMessage (m_hwnd, WM_PROPERTYPAGE_ENABLE, 0, TRUE);
  else
    PostMessage (m_hwnd, WM_PROPERTYPAGE_ENABLE, 0, FALSE);

  return NOERROR;
}


//
// OnDeactivate
//
// We are being deactivated
HRESULT CG711CodecProperties::OnDeactivate(void)
{
  ASSERT(m_pCodecSettings);
#if NUMBITRATES > 0
  ASSERT(m_pCodecBitRate);
#endif
#ifdef USESILDET
  ASSERT(m_pCodecSilDet);
#endif

  RefreshSettings();

  return NOERROR;
}


//
// OnApplyChanges
//
// User pressed the Apply button, remember the current settings

HRESULT CG711CodecProperties::OnApplyChanges(void)
{
  ASSERT(m_pCodecSettings);

  m_pCodecSettings->put_Transform(m_iTransformType);
  m_pCodecSettings->put_SampleRate(VALIDSAMPRATE[m_iSampleRate]);

#if NUMBITRATES > 0
  ASSERT(m_pCodecBitRate);
  m_pCodecBitRate->put_BitRate(VALIDBITRATE[m_iBitRate]);
#endif

#ifdef USESILDET
  ASSERT(m_pCodecSilDet);
  m_pCodecSilDet->put_SilDetEnabled(m_iSilDetEnabled);
  m_pCodecSilDet->put_SilDetThresh(m_iSilDetThresh);
#endif  // USESILDET

  return NOERROR;
}


//
// SetButtons
//

void CG711CodecProperties::SetButtons(HWND hwndParent) 
{
  int i,j;

  // read settings from filter

  RefreshSettings();

  // decode input / output types
    
  if (m_iTransformType < 0 || m_iTransformType >= NUMSUBTYPES*NUMSUBTYPES)
  {
    DbgMsg("Transform type is invalid!");
    i = j = 0;
  }
  else
  {
    i = m_iTransformType / NUMSUBTYPES;
    j = m_iTransformType - i * NUMSUBTYPES;
  }

  // set radio buttons

  CheckRadioButton(hwndParent, INBUTTON[0], INBUTTON[NUMSUBTYPES-1],
                   INBUTTON[i]);

  CheckRadioButton(hwndParent, OUTBUTTON[0], OUTBUTTON[NUMSUBTYPES-1],
                   OUTBUTTON[j]);

  if (NUMBITRATES > 0)
    CheckRadioButton(hwndParent,BRBUTTON[0], BRBUTTON[NUMBITRATES-1],
                     BRBUTTON[m_iBitRate]);

  if (NUMSAMPRATES > 0)
    CheckRadioButton(hwndParent, SRBUTTON[0], SRBUTTON[NUMSAMPRATES-1],
                     SRBUTTON[m_iSampleRate]);

  if (m_iTransformType / NUMSUBTYPES)  // 0 ==> compressing
  {
    for(i=0;i<NUMENCCTRLS;i++)
      EnableWindow(GetDlgItem (hwndParent, ENCBUTTON[i]), (BOOL) FALSE);

    for(i=0;i<NUMDECCTRLS;i++)
      EnableWindow(GetDlgItem (hwndParent, DECBUTTON[i]), (BOOL) TRUE);
 
#ifdef USESILDET
   EnableWindow(GetDlgItem (hwndParent, IDC_SDTHRESH), (BOOL) FALSE);
#endif
  }
  else
  {
    for(i=0;i<NUMENCCTRLS;i++)
      EnableWindow(GetDlgItem (hwndParent, ENCBUTTON[i]), (BOOL) TRUE);
  
    for(i=0;i<NUMDECCTRLS;i++)
      EnableWindow(GetDlgItem (hwndParent, DECBUTTON[i]), (BOOL) FALSE);

#ifdef USESILDET
    CheckDlgButton(hwndParent, IDC_SILDET, m_iSilDetEnabled);

    if (m_iSilDetEnabled)  // enabled?
      EnableWindow(GetDlgItem (hwndParent, IDC_SDTHRESH), (BOOL) TRUE);
    else
      EnableWindow(GetDlgItem (hwndParent, IDC_SDTHRESH), (BOOL) FALSE);

    SendMessage(m_hwndSDThreshSlider, TBM_SETPOS, TRUE,
                (LPARAM) m_iSilDetThresh);
#endif
  }
}


#ifdef USESILDET
//
// OnSliderNotification
//
// Handle the notification messages from the slider control

void CG711CodecProperties::OnSliderNotification(WPARAM wParam, WORD wPosition)
{
  switch (wParam)
  {
    case TB_ENDTRACK:
    case TB_THUMBTRACK:
    case TB_LINEDOWN:
    case TB_LINEUP:
      m_iSilDetThresh = (int)
                        SendMessage(m_hwndSDThreshSlider, TBM_GETPOS, 0, 0L);
      m_pCodecSilDet->put_SilDetThresh(m_iSilDetThresh);
      break;
  }
}
#endif

/*
//$Log:   K:\proj\mycodec\quartz\vcs\amacprop.cpv  $
# 
#    Rev 1.1   10 Dec 1996 15:24:30   MDEISHER
# 
# moved property page specific includes into file.
# removed include of algdefs.h
# 
#    Rev 1.0   09 Dec 1996 09:06:16   MDEISHER
# Initial revision.
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\codecs\g711\iamacsd.cpp ===
/*--------------------------------------------------------------

 INTEL Corporation Proprietary Information  

 This listing is supplied under the terms of a license agreement  
 with INTEL Corporation and may not be copied nor disclosed 
 except in accordance with the terms of that agreement.

 Copyright (c) 1996 Intel Corporation.
 All rights reserved.

 $Workfile:   iamacsd.cpp  $
 $Revision:   1.1  $
 $Date:   10 Dec 1996 15:32:46  $ 
 $Author:   MDEISHER  $

--------------------------------------------------------------

iamacsd.cpp

The generic ActiveMovie audio compression filter silence
detector settings methods.

--------------------------------------------------------------*/

#include <streams.h>
#include "resource.h"
#include "amacodec.h"

#ifdef USESILDET
///////////////////////////////////////////////////////////////////////
// *
// * ICodecSilDetector interface methods
// *

//
// IsSilDetEnabled
//
BOOL CG711Codec::IsSilDetEnabled()
{
  BOOL ReturnVal;

  if ((m_InputSubType == MEDIASUBTYPE_PCM)      // compressing?
      || (m_InputSubType == MEDIASUBTYPE_WAVE
          && m_InputFormatTag == WAVE_FORMAT_PCM)
      || (m_InputSubType == MEDIASUBTYPE_NULL
          && m_InputFormatTag == WAVE_FORMAT_PCM))
  {
    ReturnVal = m_nSilDetEnabled;
  }
  else
  {
    ReturnVal = FALSE;
  }

  return ReturnVal;
}


//
// put_SilDetEnabled
//
STDMETHODIMP CG711Codec::put_SilDetEnabled(int sdenabled)
{
  HRESULT ReturnVal;

  if ((m_InputSubType == MEDIASUBTYPE_PCM)      // compressing?
      || (m_InputSubType == MEDIASUBTYPE_WAVE
          && m_InputFormatTag == WAVE_FORMAT_PCM)
      || (m_InputSubType == MEDIASUBTYPE_NULL
          && m_InputFormatTag == WAVE_FORMAT_PCM))
  {
    m_nSilDetEnabled = sdenabled;

    SILDETENABLE(m_EncStatePtr, m_nSilDetEnabled);

    ReturnVal = NOERROR;
  }
  else ReturnVal = E_FAIL;

  return(ReturnVal);
}

 
//
// get_SilDetThresh
//
STDMETHODIMP CG711Codec::get_SilDetThresh(int *sdthreshold)
{
  HRESULT ReturnVal;

  if ((m_InputSubType == MEDIASUBTYPE_PCM)      // compressing?
      || (m_InputSubType == MEDIASUBTYPE_WAVE
          && m_InputFormatTag == WAVE_FORMAT_PCM)
      || (m_InputSubType == MEDIASUBTYPE_NULL
          && m_InputFormatTag == WAVE_FORMAT_PCM))
  {
    *sdthreshold = m_nSilDetThresh;
    ReturnVal = NOERROR;
  }
  else ReturnVal = E_FAIL;

  return(ReturnVal);
}


//
// put_SilDetThresh
//
STDMETHODIMP CG711Codec::put_SilDetThresh(int sdthreshold)
{
  HRESULT ReturnVal;

  if ((m_InputSubType == MEDIASUBTYPE_PCM)      // compressing?
      || (m_InputSubType == MEDIASUBTYPE_WAVE
          && m_InputFormatTag == WAVE_FORMAT_PCM)
      || (m_InputSubType == MEDIASUBTYPE_NULL
          && m_InputFormatTag == WAVE_FORMAT_PCM))
  {
    if (sdthreshold >= MINSDTHRESH && sdthreshold <= MAXSDTHRESH)
    {
      m_nSilDetThresh = sdthreshold;

      SILDETTHRESH(m_EncStatePtr, m_nSilDetThresh);

      ReturnVal = NOERROR;
    }
    else  ReturnVal = E_INVALIDARG;
  }
  else ReturnVal = E_FAIL;

  return(ReturnVal);
}
#endif

/*
//$Log:   K:\proj\mycodec\quartz\vcs\iamacsd.cpv  $
# 
#    Rev 1.1   10 Dec 1996 15:32:46   MDEISHER
# 
# added includes, removed include of algdefs.h.
# put ifdef USESILDET around code and removed ifdefs inside code.
# 
#    Rev 1.0   09 Dec 1996 09:03:20   MDEISHER
# Initial revision.
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\codecs\g711\mk711.cpp ===
/*---------------------------------------------------------------

 INTEL Corporation Proprietary Information  

 This listing is supplied under the terms of a license agreement  
 with INTEL Corporation and may not be copied nor disclosed 
 except in accordance with the terms of that agreement.

 Copyright (c) 1996 Intel Corporation.
 All rights reserved.

 $Workfile:   MK711.CPP  $
 $Revision:   1.2  $
 $Date:   24 May 1996 15:42:28  $ 
 $Author:   DGRAUMAN  $

---------------------------------------------------------------

MK711.cpp

 These are the Alaw and uLaw conversion functions.  They index into 
 the tables in MK711tab.h for the appropriate conversion value.  This
 is extrememly fast.  There is another way to perform 711 that takes 
 more time but does not use over 8K of memory. left for as an excersize 
 for the student.(me)

---------------------------------------------------------------*/

#include "mk711tab.h"

void Short2Ulaw(const unsigned short *in, unsigned char *out, long len)
{
long i;

    for (i=0; i<len; i++)
        out[i] = short2ulaw[in[i] >> 3];
} // end short2ulaw


void Ulaw2Short(const unsigned char *in, unsigned short *out, long len)
{
long i;

    for (i=0; i<len; i++)
        out[i] = ulaw2short[in[i]];
} // end ulaw2short


void Short2Alaw(const unsigned short *in, unsigned char *out, long len)
{
long i;

    for (i=0; i<len; i++)
        out[i] = ulaw2alaw[short2ulaw[in[i] >> 3]];
} // end short2alaw


void Alaw2Short(const unsigned char *in, unsigned short *out, long len)
{
long i;

    for (i=0; i<len; i++)
        out[i] = ulaw2short[alaw2ulaw[in[i]]];
} // end alaw2 short

/* 

//$Log:   N:\proj\quartz\g711\src\vcs\mk711.cpv  $
// 
//    Rev 1.2   24 May 1996 15:42:28   DGRAUMAN
// cleaned up code, detabbed, etc...
// 
//    Rev 1.1   23 May 1996 11:33:16   DGRAUMAN
// trying to make logging work

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\codecs\g711\iamacset.cpp ===
/*--------------------------------------------------------------

 INTEL Corporation Proprietary Information  

 This listing is supplied under the terms of a license agreement  
 with INTEL Corporation and may not be copied nor disclosed 
 except in accordance with the terms of that agreement.

 Copyright (c) 1996 Intel Corporation.
 All rights reserved.

 $Workfile:   iamacset.cpp  $
 $Revision:   1.1  $
 $Date:   10 Dec 1996 15:34:50  $ 
 $Author:   MDEISHER  $

--------------------------------------------------------------

iamacset.cpp

The generic ActiveMovie audio compression filter basic
settings methods.

--------------------------------------------------------------*/

#include <streams.h>
#include "resource.h"
#include "amacodec.h"

///////////////////////////////////////////////////////////////////////
// *
// * ICodecSettings interface methods
// *

//
// ReleaseCaps:  Turn off capability restrictions
//
STDMETHODIMP  CG711Codec::ReleaseCaps()
{
  m_RestrictCaps = FALSE;

  return NOERROR;
}


//
// UnPlugged:  Check if filter is unplugged
//
BOOL CG711Codec::IsUnPlugged()
{
  int unplugged = TRUE;

  if (m_pInput != NULL)
  {
    if (m_pInput->IsConnected())  unplugged = FALSE;
  }

  if (m_pOutput != NULL)
  {
    if (m_pOutput->IsConnected()) unplugged = FALSE;
  }

  return(unplugged);
}


//
// get_InputBufferSize
//
STDMETHODIMP CG711Codec::get_InputBufferSize(int *numbytes)
{
  HRESULT ReturnVal = NOERROR;

  // if the filter is disconnected, then can't tell buffer size

  if (!IsUnPlugged())
  {
    *numbytes = m_nInBufferSize;
  }
  else ReturnVal = E_FAIL;

  return(ReturnVal);
}


//
// put_InputBufferSize
//
STDMETHODIMP CG711Codec::put_InputBufferSize(int numbytes)
{
  return(E_NOTIMPL);
}


//
// get_OutputBufferSize
//
STDMETHODIMP CG711Codec::get_OutputBufferSize(int *numbytes)
{
  HRESULT ReturnVal = NOERROR;

  // if the filter is disconnected, then can't tell buffer size

  if (!IsUnPlugged())
  {
    *numbytes = m_nOutBufferSize;
  }
  else ReturnVal = E_FAIL;

  return(ReturnVal);
}


//
// put_OutputBufferSize
//
STDMETHODIMP CG711Codec::put_OutputBufferSize(int numbytes)
{
  return(E_NOTIMPL);
}


//
// get_Channels
//
STDMETHODIMP CG711Codec::get_Channels(int *channels, int index)
{
  HRESULT ReturnVal = NOERROR;

  if (index == -1)
  {
    *channels = m_nChannels;
  }
  else if (index < 0 || index >= NUMCHANNELS)
  {
    ReturnVal = E_INVALIDARG;
  }
  else  // enumerate channels
  {
    *channels = VALIDCHANNELS[index];
  }

  return(ReturnVal);
}


//
// put_Channels
//
STDMETHODIMP CG711Codec::put_Channels(int channels)
{
  int i;

  // if the filter is disconnected, then change nChannels

  if (IsUnPlugged())
  {
    for(i=0;i<NUMCHANNELS;i++)
      if (VALIDCHANNELS[i] == (UINT)channels)
        break;

    if (i == NUMCHANNELS)
    {
      DbgMsg("Bad channels in put_Channels!");
      return(E_INVALIDARG);
    }

#ifdef MONO_ONLY
    if (channels != 1)
    {
      DbgMsg("Bad nChannels in put_Channels!");
      return(E_INVALIDARG);
    }
#endif

    m_nChannels = channels;

    return NOERROR;
  }
  else return E_FAIL;
}

 
//
// get_SampleRate
//
STDMETHODIMP CG711Codec::get_SampleRate(int *samprate, int index)
{
  HRESULT ReturnVal=NOERROR;

  if (index == -1)
  {
    *samprate = m_nSampleRate;
  }
  else if (index != -1 && (index < 0 || index >= NUMSAMPRATES))
  {
    ReturnVal = E_INVALIDARG;
  }
  else  // enumerate sample rates
  {
    *samprate = VALIDSAMPRATE[index];
  }

  return ReturnVal;
}


//
// put_SampleRate
//
STDMETHODIMP CG711Codec::put_SampleRate(int samprate)
{
#if NUMSAMPRATES > 0
  int i;

  // if the filter is disconnected, then change sample rate

  if (IsUnPlugged())
  {
    for(i=0;i<NUMSAMPRATES;i++)
      if (VALIDSAMPRATE[i] == (UINT)samprate)
        break;

    if (i == NUMSAMPRATES)
    {
      DbgMsg("Bad sample rate in put_SampleRate!");
      return(E_INVALIDARG);
    }

    m_nSampleRate = samprate;

    // restrict capabilities to those set from the properties page

    m_RestrictCaps = TRUE;

    return NOERROR;
  }
  else return E_FAIL;

#else

  // no sample rate restrictions

  m_nSampleRate = samprate;

  // restrict capabilities to those set from the properties page

  m_RestrictCaps = TRUE;

  return NOERROR;

#endif
}

//
// get_Transform
//
STDMETHODIMP CG711Codec::get_Transform(int *transform)
{
  HRESULT ReturnVal=NOERROR;
  int i,j;

  // determine input type index

  if (m_InputSubType==MEDIASUBTYPE_WAVE || m_InputSubType==MEDIASUBTYPE_NULL)
  {
    for(i=0;i<NUMSUBTYPES;i++)
      if (m_InputFormatTag == VALIDFORMATTAG[i])
        break;

    if (i == NUMSUBTYPES)
    {
      DbgMsg("Bad m_InputSubType/m_InputFormatTag in get_Transform!");
      i = 0;
      ReturnVal = E_UNEXPECTED;
    }
  }
  else
  {
    for(i=0;i<NUMSUBTYPES;i++)
      if (m_InputSubType == *VALIDSUBTYPE[i])
        break;

    if (i == NUMSUBTYPES)
    {
      DbgMsg("Bad m_InputSubType in get_Transform!");
      i = 0;
      ReturnVal = E_UNEXPECTED;
    }
  }

  // determine output type index

  if (m_OutputSubType==MEDIASUBTYPE_WAVE
      || m_OutputSubType==MEDIASUBTYPE_NULL)
  {
    for(j=0;j<NUMSUBTYPES;j++)
      if (m_OutputFormatTag == VALIDFORMATTAG[j])
        break;

    if (j == NUMSUBTYPES)
    {
      DbgMsg("Bad m_OutputSubType/m_OutputFormatTag in get_Transform!");
      j = 0;
      ReturnVal = E_UNEXPECTED;
    }
  }
  else
  {
    for(j=0;j<NUMSUBTYPES;j++)
      if (m_OutputSubType == *VALIDSUBTYPE[j])
        break;

    if (j == NUMSUBTYPES)
    {
      DbgMsg("Bad m_OutputSubType in get_Transform!");
      j = 0;
      ReturnVal = E_UNEXPECTED;
    }
  }

  *transform = i * NUMSUBTYPES + j;

  return ReturnVal;
}


//
// put_Transform
//
STDMETHODIMP CG711Codec::put_Transform(int transform)
{
  int i,j;

  // if the filter is disconnected, then change transform configuration

  if (IsUnPlugged())
  {
    i = transform / NUMSUBTYPES;
    j = transform - i * NUMSUBTYPES;

    if (i < 0 || j < 0 || i >= NUMSUBTYPES || j >= NUMSUBTYPES)
    {
      DbgMsg("Bad transform type in put_Transform!");
      return(E_INVALIDARG);
    }

    m_InputSubType    = *VALIDSUBTYPE[i];
    m_InputFormatTag  = VALIDFORMATTAG[i];
    m_OutputSubType   = *VALIDSUBTYPE[j];
    m_OutputFormatTag = VALIDFORMATTAG[j];

    // reset state since filter may have changed from encoder to decoder

    ResetState();

    // restrict capabilities to those set from the properties page

    m_RestrictCaps = TRUE;
  
    return NOERROR;
  }
  else return E_FAIL;
}

 
//
// put_InputMediaSubType
//
STDMETHODIMP CG711Codec::put_InputMediaSubType(REFCLSID rclsid)
{
  int i;

  // if the filter is disconnected, then change transform configuration

  if (IsUnPlugged())
  {
    for(i=0;i<NUMSUBTYPES;i++)
      if (rclsid == *VALIDSUBTYPE[i]) break;

    if (i == NUMSUBTYPES)
      return(E_INVALIDARG);

    m_InputSubType    = *VALIDSUBTYPE[i];
    m_InputFormatTag  = VALIDFORMATTAG[i];

    // reset state since filter may have changed from encoder to decoder

    ResetState();

    // restrict capabilities to those set from the properties page

    m_RestrictCaps = TRUE;
  
    return NOERROR;
  }
  else return E_FAIL;
}

 
//
// put_OutputMediaSubType
//
STDMETHODIMP CG711Codec::put_OutputMediaSubType(REFCLSID rclsid)
{
  int j;

  // if the filter is disconnected, then change transform configuration

  if (IsUnPlugged())
  {
    for(j=0;j<NUMSUBTYPES;j++)
      if (rclsid == *VALIDSUBTYPE[j]) break;

    if (j == NUMSUBTYPES)
      return(E_INVALIDARG);

    m_OutputSubType   = *VALIDSUBTYPE[j];
    m_OutputFormatTag = VALIDFORMATTAG[j];

    // reset state since filter may have changed from encoder to decoder

    ResetState();

    // restrict capabilities to those set from the properties page

    m_RestrictCaps = TRUE;
  
    return NOERROR;
  }
  else return E_FAIL;
}

/*
//$Log:   K:\proj\mycodec\quartz\vcs\iamacset.cpv  $
# 
#    Rev 1.1   10 Dec 1996 15:34:50   MDEISHER
# 
# added includes and removed include of algdefs.h
# 
#    Rev 1.0   09 Dec 1996 09:04:06   MDEISHER
# Initial revision.
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\codecs\g711\mk711tab.h ===
/*------------------------------------------------------------------- 

 INTEL Corporation Proprietary Information  

 This listing is supplied under the terms of a license agreement  
 with INTEL Corporation and may not be copied nor disclosed 
 except in accordance with the terms of that agreement.

 Copyright (c) 1996 Intel Corporation.
 All rights reserved.

 $Workfile:   MK711TAB.H  $
 $Revision:   1.3  $
 $Date:   24 May 1996 15:50:44  $ 
 $Author:   DGRAUMAN  $

-------------------------------------------------------------------

MK711Tab.h

 Tables for performing Alaw and uLaw conversion. Alaw is a subset of
 the uLaw table.

-------------------------------------------------------------------*/

#pragma warning( once : 4305) // there is a lot of truncation going on

const unsigned char ulaw2alaw[256] = {
0x2a, 0x2b, 0x28, 0x29, 0x2e, 0x2f, 0x2c, 0x2d, 
0x22, 0x23, 0x20, 0x21, 0x26, 0x27, 0x24, 0x25, 
0x3a, 0x3b, 0x38, 0x39, 0x3e, 0x3f, 0x3c, 0x3d, 
0x32, 0x33, 0x30, 0x31, 0x36, 0x37, 0x34, 0x35, 
0x0a, 0x0b, 0x08, 0x09, 0x0e, 0x0f, 0x0c, 0x0d, 
0x02, 0x03, 0x00, 0x01, 0x06, 0x07, 0x04, 0x05, 
0x1b, 0x18, 0x19, 0x1e, 0x1f, 0x1c, 0x1d, 0x12, 
0x13, 0x10, 0x11, 0x16, 0x17, 0x14, 0x15, 0x6a, 
0x68, 0x69, 0x6e, 0x6f, 0x6c, 0x6d, 0x62, 0x63, 
0x60, 0x61, 0x66, 0x67, 0x64, 0x65, 0x7a, 0x78, 
0x7e, 0x7f, 0x7c, 0x7d, 0x72, 0x73, 0x70, 0x71, 
0x76, 0x77, 0x74, 0x75, 0x4b, 0x49, 0x4f, 0x4d, 
0x42, 0x43, 0x40, 0x41, 0x46, 0x47, 0x44, 0x45, 
0x5a, 0x5b, 0x58, 0x59, 0x5e, 0x5f, 0x5c, 0x5d, 
0x52, 0x52, 0x53, 0x53, 0x50, 0x50, 0x51, 0x51, 
0x56, 0x56, 0x57, 0x57, 0x54, 0x54, 0x55, 0x55, 
0xaa, 0xab, 0xa8, 0xa9, 0xae, 0xaf, 0xac, 0xad, 
0xa2, 0xa3, 0xa0, 0xa1, 0xa6, 0xa7, 0xa4, 0xa5, 
0xba, 0xbb, 0xb8, 0xb9, 0xbe, 0xbf, 0xbc, 0xbd, 
0xb2, 0xb3, 0xb0, 0xb1, 0xb6, 0xb7, 0xb4, 0xb5, 
0x8a, 0x8b, 0x88, 0x89, 0x8e, 0x8f, 0x8c, 0x8d, 
0x82, 0x83, 0x80, 0x81, 0x86, 0x87, 0x84, 0x85, 
0x9b, 0x98, 0x99, 0x9e, 0x9f, 0x9c, 0x9d, 0x92, 
0x93, 0x90, 0x91, 0x96, 0x97, 0x94, 0x95, 0xea, 
0xe8, 0xe9, 0xee, 0xef, 0xec, 0xed, 0xe2, 0xe3, 
0xe0, 0xe1, 0xe6, 0xe7, 0xe4, 0xe5, 0xfa, 0xf8, 
0xfe, 0xff, 0xfc, 0xfd, 0xf2, 0xf3, 0xf0, 0xf1, 
0xf6, 0xf7, 0xf4, 0xf5, 0xcb, 0xc9, 0xcf, 0xcd, 
0xc2, 0xc3, 0xc0, 0xc1, 0xc6, 0xc7, 0xc4, 0xc5, 
0xda, 0xdb, 0xd8, 0xd9, 0xde, 0xdf, 0xdc, 0xdd, 
0xd2, 0xd2, 0xd3, 0xd3, 0xd0, 0xd0, 0xd1, 0xd1, 
0xd6, 0xd6, 0xd7, 0xd7, 0xd4, 0xd4, 0xd5, 0xd5
};


const unsigned char alaw2ulaw[256] = {
0x2a, 0x2b, 0x28, 0x29, 0x2e, 0x2f, 0x2c, 0x2d, 
0x22, 0x23, 0x20, 0x21, 0x26, 0x27, 0x24, 0x25, 
0x39, 0x3a, 0x37, 0x38, 0x3d, 0x3e, 0x3b, 0x3c, 
0x31, 0x32, 0x30, 0x30, 0x35, 0x36, 0x33, 0x34, 
0x0a, 0x0b, 0x08, 0x09, 0x0e, 0x0f, 0x0c, 0x0d, 
0x02, 0x03, 0x00, 0x01, 0x06, 0x07, 0x04, 0x05, 
0x1a, 0x1b, 0x18, 0x19, 0x1e, 0x1f, 0x1c, 0x1d, 
0x12, 0x13, 0x10, 0x11, 0x16, 0x17, 0x14, 0x15, 
0x62, 0x63, 0x60, 0x61, 0x66, 0x67, 0x64, 0x65, 
0x5d, 0x5d, 0x5c, 0x5c, 0x5f, 0x5f, 0x5e, 0x5e, 
0x74, 0x76, 0x70, 0x72, 0x7c, 0x7e, 0x78, 0x7a, 
0x6a, 0x6b, 0x68, 0x69, 0x6e, 0x6f, 0x6c, 0x6d, 
0x48, 0x49, 0x46, 0x47, 0x4c, 0x4d, 0x4a, 0x4b, 
0x40, 0x41, 0x3f, 0x3f, 0x44, 0x45, 0x42, 0x43, 
0x56, 0x57, 0x54, 0x55, 0x5a, 0x5b, 0x58, 0x59, 
0x4f, 0x4f, 0x4e, 0x4e, 0x52, 0x53, 0x50, 0x51, 
0xaa, 0xab, 0xa8, 0xa9, 0xae, 0xaf, 0xac, 0xad, 
0xa2, 0xa3, 0xa0, 0xa1, 0xa6, 0xa7, 0xa4, 0xa5, 
0xb9, 0xba, 0xb7, 0xb8, 0xbd, 0xbe, 0xbb, 0xbc, 
0xb1, 0xb2, 0xb0, 0xb0, 0xb5, 0xb6, 0xb3, 0xb4, 
0x8a, 0x8b, 0x88, 0x89, 0x8e, 0x8f, 0x8c, 0x8d, 
0x82, 0x83, 0x80, 0x81, 0x86, 0x87, 0x84, 0x85, 
0x9a, 0x9b, 0x98, 0x99, 0x9e, 0x9f, 0x9c, 0x9d, 
0x92, 0x93, 0x90, 0x91, 0x96, 0x97, 0x94, 0x95, 
0xe2, 0xe3, 0xe0, 0xe1, 0xe6, 0xe7, 0xe4, 0xe5, 
0xdd, 0xdd, 0xdc, 0xdc, 0xdf, 0xdf, 0xde, 0xde, 
0xf4, 0xf6, 0xf0, 0xf2, 0xfc, 0xfe, 0xf8, 0xfa, 
0xea, 0xeb, 0xe8, 0xe9, 0xee, 0xef, 0xec, 0xed, 
0xc8, 0xc9, 0xc6, 0xc7, 0xcc, 0xcd, 0xca, 0xcb, 
0xc0, 0xc1, 0xbf, 0xbf, 0xc4, 0xc5, 0xc2, 0xc3, 
0xd6, 0xd7, 0xd4, 0xd5, 0xda, 0xdb, 0xd8, 0xd9, 
0xcf, 0xcf, 0xce, 0xce, 0xd2, 0xd3, 0xd0, 0xd1
};

  
const unsigned short ulaw2short[256] = {
0x8284, 0x8684, 0x8a84, 0x8e84, 0x9284, 0x9684, 0x9a84, 0x9e84, 
0xa284, 0xa684, 0xaa84, 0xae84, 0xb284, 0xb684, 0xba84, 0xbe84, 
0xc184, 0xc384, 0xc584, 0xc784, 0xc984, 0xcb84, 0xcd84, 0xcf84, 
0xd184, 0xd384, 0xd584, 0xd784, 0xd984, 0xdb84, 0xdd84, 0xdf84, 
0xe104, 0xe204, 0xe304, 0xe404, 0xe504, 0xe604, 0xe704, 0xe804, 
0xe904, 0xea04, 0xeb04, 0xec04, 0xed04, 0xee04, 0xef04, 0xf004, 
0xf0c4, 0xf144, 0xf1c4, 0xf244, 0xf2c4, 0xf344, 0xf3c4, 0xf444, 
0xf4c4, 0xf544, 0xf5c4, 0xf644, 0xf6c4, 0xf744, 0xf7c4, 0xf844, 
0xf8a4, 0xf8e4, 0xf924, 0xf964, 0xf9a4, 0xf9e4, 0xfa24, 0xfa64, 
0xfaa4, 0xfae4, 0xfb24, 0xfb64, 0xfba4, 0xfbe4, 0xfc24, 0xfc64, 
0xfc94, 0xfcb4, 0xfcd4, 0xfcf4, 0xfd14, 0xfd34, 0xfd54, 0xfd74, 
0xfd94, 0xfdb4, 0xfdd4, 0xfdf4, 0xfe14, 0xfe34, 0xfe54, 0xfe74, 
0xfe8c, 0xfe9c, 0xfeac, 0xfebc, 0xfecc, 0xfedc, 0xfeec, 0xfefc, 
0xff0c, 0xff1c, 0xff2c, 0xff3c, 0xff4c, 0xff5c, 0xff6c, 0xff7c, 
0xff88, 0xff90, 0xff98, 0xffa0, 0xffa8, 0xffb0, 0xffb8, 0xffc0, 
0xffc8, 0xffd0, 0xffd8, 0xffe0, 0xffe8, 0xfff0, 0xfff8, 0x0000, 
0x7d7c, 0x797c, 0x757c, 0x717c, 0x6d7c, 0x697c, 0x657c, 0x617c, 
0x5d7c, 0x597c, 0x557c, 0x517c, 0x4d7c, 0x497c, 0x457c, 0x417c, 
0x3e7c, 0x3c7c, 0x3a7c, 0x387c, 0x367c, 0x347c, 0x327c, 0x307c, 
0x2e7c, 0x2c7c, 0x2a7c, 0x287c, 0x267c, 0x247c, 0x227c, 0x207c, 
0x1efc, 0x1dfc, 0x1cfc, 0x1bfc, 0x1afc, 0x19fc, 0x18fc, 0x17fc, 
0x16fc, 0x15fc, 0x14fc, 0x13fc, 0x12fc, 0x11fc, 0x10fc, 0x0ffc, 
0x0f3c, 0x0ebc, 0x0e3c, 0x0dbc, 0x0d3c, 0x0cbc, 0x0c3c, 0x0bbc, 
0x0b3c, 0x0abc, 0x0a3c, 0x09bc, 0x093c, 0x08bc, 0x083c, 0x07bc, 
0x075c, 0x071c, 0x06dc, 0x069c, 0x065c, 0x061c, 0x05dc, 0x059c, 
0x055c, 0x051c, 0x04dc, 0x049c, 0x045c, 0x041c, 0x03dc, 0x039c, 
0x036c, 0x034c, 0x032c, 0x030c, 0x02ec, 0x02cc, 0x02ac, 0x028c, 
0x026c, 0x024c, 0x022c, 0x020c, 0x01ec, 0x01cc, 0x01ac, 0x018c, 
0x0174, 0x0164, 0x0154, 0x0144, 0x0134, 0x0124, 0x0114, 0x0104, 
0x00f4, 0x00e4, 0x00d4, 0x00c4, 0x00b4, 0x00a4, 0x0094, 0x0084, 
0x0078, 0x0070, 0x0068, 0x0060, 0x0058, 0x0050, 0x0048, 0x0040, 
0x0038, 0x0030, 0x0028, 0x0020, 0x0018, 0x0010, 0x0008, 0x0000
};


const unsigned char short2ulaw[8192] = {
0xff, 0xfe, 0xfd, 0xfc, 0xfb, 0xfa, 0xf9, 0xf8, 
0xf7, 0xf6, 0xf5, 0xf4, 0xf3, 0xf2, 0xf1, 0xf0, 
0xef, 0xef, 0xee, 0xee, 0xed, 0xed, 0xec, 0xec, 
0xeb, 0xeb, 0xea, 0xea, 0xe9, 0xe9, 0xe8, 0xe8, 
0xe7, 0xe7, 0xe6, 0xe6, 0xe5, 0xe5, 0xe4, 0xe4, 
0xe3, 0xe3, 0xe2, 0xe2, 0xe1, 0xe1, 0xe0, 0xe0, 
0xdf, 0xdf, 0xdf, 0xdf, 0xde, 0xde, 0xde, 0xde, 
0xdd, 0xdd, 0xdd, 0xdd, 0xdc, 0xdc, 0xdc, 0xdc, 
0xdb, 0xdb, 0xdb, 0xdb, 0xda, 0xda, 0xda, 0xda, 
0xd9, 0xd9, 0xd9, 0xd9, 0xd8, 0xd8, 0xd8, 0xd8, 
0xd7, 0xd7, 0xd7, 0xd7, 0xd6, 0xd6, 0xd6, 0xd6, 
0xd5, 0xd5, 0xd5, 0xd5, 0xd4, 0xd4, 0xd4, 0xd4, 
0xd3, 0xd3, 0xd3, 0xd3, 0xd2, 0xd2, 0xd2, 0xd2, 
0xd1, 0xd1, 0xd1, 0xd1, 0xd0, 0xd0, 0xd0, 0xd0, 
0xcf, 0xcf, 0xcf, 0xcf, 0xcf, 0xcf, 0xcf, 0xcf, 
0xce, 0xce, 0xce, 0xce, 0xce, 0xce, 0xce, 0xce, 
0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 
0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 
0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 
0xca, 0xca, 0xca, 0xca, 0xca, 0xca, 0xca, 0xca, 
0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 
0xc8, 0xc8, 0xc8, 0xc8, 0xc8, 0xc8, 0xc8, 0xc8, 
0xc7, 0xc7, 0xc7, 0xc7, 0xc7, 0xc7, 0xc7, 0xc7, 
0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 
0xc5, 0xc5, 0xc5, 0xc5, 0xc5, 0xc5, 0xc5, 0xc5, 
0xc4, 0xc4, 0xc4, 0xc4, 0xc4, 0xc4, 0xc4, 0xc4, 
0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 
0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 
0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 
0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 
0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 
0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 
0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 
0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 
0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 
0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 
0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 
0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 
0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 
0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 
0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 
0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 
0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 
0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 
0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 
0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 
0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 
0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 
0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 
0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 
0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 
0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 
0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 
0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 
0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 
0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 
0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 
0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 
0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 
0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 
0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 
0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 
0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 
0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 
0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 
0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 
0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 
0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 
0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 
0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 
0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 
0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 
0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 
0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 
0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 
0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 
0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 
0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 
0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 
0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 
0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 
0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 
0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 
0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 
0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 
0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 
0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 
0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 
0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 
0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 
0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 
0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 
0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 
0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 
0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 
0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 
0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 
0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 
0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 
0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 
0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 
0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 
0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 
0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 
0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 
0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 
0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 
0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 
0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 
0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 
0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 
0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 
0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 
0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 
0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 
0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 
0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 
0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 
0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 
0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 
0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 
0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 
0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 
0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 
0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 
0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 
0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 
0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 
0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 
0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 
0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 
0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 
0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 
0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 
0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 
0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 
0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 
0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 
0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 
0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 
0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 
0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 
0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 
0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 
0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 
0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 
0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 
0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 
0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 
0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 
0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 
0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 
0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 
0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 
0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 
0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 
0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 
0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 
0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 
0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 
0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 
0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 
0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 
0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 
0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 
0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 
0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 
0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 
0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 
0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 
0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 
0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 
0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 
0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 
0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 
0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 
0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 
0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 
0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 
0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 
0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 
0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 
0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 
0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 
0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 
0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 
0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 
0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 
0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 
0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 
0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 
0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 
0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 
0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 
0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 
0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 
0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 
0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 
0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 
0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 
0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 
0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 
0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 
0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 
0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 
0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 
0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 
0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 
0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 
0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 
0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 
0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 
0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 
0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 
0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 
0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 
0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 
0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 
0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 
0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 
0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 
0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 
0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 
0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 
0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 
0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 
0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 
0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 
0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 
0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 
0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 
0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 
0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 
0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 
0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 
0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 
0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 
0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 
0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 
0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 
0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 
0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 
0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 
0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 
0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 
0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 
0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 
0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 
0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 
0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 
0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 
0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 
0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 
0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 
0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 
0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 
0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 
0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 
0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 
0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 
0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 
0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 
0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 
0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 
0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 
0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 
0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 
0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 
0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 
0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 
0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 
0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 
0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 
0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 
0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 
0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 
0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 
0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 
0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 
0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 
0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 
0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 
0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 
0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 
0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 
0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 
0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 
0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 
0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 
0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 
0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 
0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 
0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 
0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 
0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 
0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 
0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 
0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 
0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 
0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 
0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 
0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 
0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 
0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 
0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 
0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 
0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 
0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 
0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 
0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 
0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 
0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 
0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 
0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 
0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 
0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 
0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 
0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 
0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 
0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 
0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 
0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 
0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 
0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 
0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 
0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 
0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 
0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 
0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 
0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 
0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 
0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 
0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 
0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 
0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 
0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 
0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 
0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 
0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 
0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 
0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 
0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 
0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 
0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 
0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 
0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 
0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 
0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 
0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 
0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 
0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 
0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 
0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 
0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 
0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 
0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 
0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 
0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 
0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 
0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 
0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 
0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 
0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 
0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 
0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 
0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 
0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 
0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 
0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 
0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 
0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 
0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 
0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 
0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 
0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 
0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 
0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 
0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 
0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 
0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 
0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 
0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 
0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 
0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 
0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 
0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 
0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 
0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 
0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 
0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 
0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 
0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 
0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 
0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 
0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 
0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 
0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x04, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x05, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
0x09, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
0x0a, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
0x0b, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x0c, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
0x0d, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 
0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 
0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 
0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 
0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 
0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 
0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 
0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 
0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 
0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 
0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 
0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 
0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 
0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 
0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 
0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 
0x0e, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
0x11, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
0x12, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 
0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 
0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 
0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 
0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 
0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 
0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 
0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 
0x13, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 
0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 
0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 
0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 
0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 
0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 
0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 
0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 
0x14, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 
0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 
0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 
0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 
0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 
0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 
0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 
0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 
0x15, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 
0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 
0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 
0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 
0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 
0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 
0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 
0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 
0x16, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 
0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 
0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 
0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 
0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 
0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 
0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 
0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 
0x17, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
0x18, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 
0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 
0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 
0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 
0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 
0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 
0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 
0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 
0x19, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 
0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 
0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 
0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 
0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 
0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 
0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 
0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 
0x1a, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 
0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 
0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 
0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 
0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 
0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 
0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 
0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 
0x1b, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 
0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 
0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 
0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 
0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 
0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 
0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 
0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 
0x1c, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 
0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 
0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 
0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 
0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 
0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 
0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 
0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 
0x1d, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 
0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 
0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 
0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 
0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 
0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 
0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 
0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 
0x1e, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 
0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 
0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 
0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 
0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 
0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 
0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 
0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 
0x1f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
0x20, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 
0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 
0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 
0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 
0x21, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 
0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 
0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 
0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 
0x22, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 
0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 
0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 
0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 
0x23, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 
0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 
0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 
0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 
0x24, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 
0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 
0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 
0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 
0x25, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 
0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 
0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 
0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 
0x26, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 
0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 
0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 
0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 
0x27, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 
0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 
0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 
0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 
0x28, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 
0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 
0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 
0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 
0x29, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 
0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 
0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 
0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 
0x2a, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 
0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 
0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 
0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 
0x2b, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 
0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 
0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 
0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 
0x2c, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 
0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 
0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 
0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 
0x2d, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 
0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 
0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 
0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 
0x2e, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 
0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 
0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 
0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 
0x2f, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 
0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 
0x31, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 
0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 
0x32, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 
0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 
0x33, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 
0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 
0x34, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 
0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 
0x35, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
0x36, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 
0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 
0x37, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 
0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 
0x38, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 
0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 
0x39, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 
0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 
0x3a, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 
0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 
0x3b, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 
0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 
0x3c, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 
0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 
0x3d, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 
0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 
0x3e, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 
0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 
0x3f, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 
0x40, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 
0x41, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 
0x42, 0x43, 0x43, 0x43, 0x43, 0x43, 0x43, 0x43, 
0x43, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 
0x44, 0x45, 0x45, 0x45, 0x45, 0x45, 0x45, 0x45, 
0x45, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 
0x46, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 
0x47, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 
0x48, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 
0x49, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 
0x4a, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 
0x4b, 0x4c, 0x4c, 0x4c, 0x4c, 0x4c, 0x4c, 0x4c, 
0x4c, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 
0x4d, 0x4e, 0x4e, 0x4e, 0x4e, 0x4e, 0x4e, 0x4e, 
0x4e, 0x4f, 0x4f, 0x4f, 0x4f, 0x4f, 0x4f, 0x4f, 
0x4f, 0x50, 0x50, 0x50, 0x50, 0x51, 0x51, 0x51, 
0x51, 0x52, 0x52, 0x52, 0x52, 0x53, 0x53, 0x53, 
0x53, 0x54, 0x54, 0x54, 0x54, 0x55, 0x55, 0x55, 
0x55, 0x56, 0x56, 0x56, 0x56, 0x57, 0x57, 0x57, 
0x57, 0x58, 0x58, 0x58, 0x58, 0x59, 0x59, 0x59, 
0x59, 0x5a, 0x5a, 0x5a, 0x5a, 0x5b, 0x5b, 0x5b, 
0x5b, 0x5c, 0x5c, 0x5c, 0x5c, 0x5d, 0x5d, 0x5d, 
0x5d, 0x5e, 0x5e, 0x5e, 0x5e, 0x5f, 0x5f, 0x5f, 
0x5f, 0x60, 0x60, 0x61, 0x61, 0x62, 0x62, 0x63, 
0x63, 0x64, 0x64, 0x65, 0x65, 0x66, 0x66, 0x67, 
0x67, 0x68, 0x68, 0x69, 0x69, 0x6a, 0x6a, 0x6b, 
0x6b, 0x6c, 0x6c, 0x6d, 0x6d, 0x6e, 0x6e, 0x6f, 
0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 
0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e
};

/* 

;// $Log:   N:\proj\quartz\g711\src\vcs\mk711tab.h_v  $
;// 
;//    Rev 1.3   24 May 1996 15:50:44   DGRAUMAN
;// fixed comments for PVCS logging
;// 
;//    Rev 1.2   24 May 1996 15:40:56   DGRAUMAN
;// cleaned up code, detabbed, etc...
;// 
;//    Rev 1.1   23 May 1996 11:32:04   DGRAUMAN
;// trying to make logging work

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\codecs\g711\template.h ===
/*********************************************************************
 *
 * Copyright (c) 1997 Microsoft Corporation
 *
 * File: codecs\g711\template.h
 *
 * Abstract:
 *     Macros to define CFactoryTemplate templates
 *
 * History:
 *     10/30/97    Created by AndresVG
 *
 **********************************************************************/
#if !defined(_G711_TEMPLATE_H_)
#define      _G711_TEMPLATE_H_

extern AMOVIESETUP_FILTER sudG711Codec;

#define CODECG711NAME  "G.711 Codec"
#define CODECG711LNAME L"G.711 Codec"
#define CODECG711LPROP L"G.711 Codec Property Page"

#define CFT_G711_FILTER \
{ \
	  CODECG711LNAME, \
	  &CLSID_G711Codec, \
	  CG711Codec::CreateInstance, \
	  NULL, \
	  &sudG711Codec \
	  }

#define CFT_G711_FILTER_PROP \
{ \
	  CODECG711LPROP, \
	  &CLSID_G711CodecPropertyPage, \
	  CG711CodecProperties::CreateInstance \
	  }

#define CFT_G711_ALL_FILTERS \
CFT_G711_FILTER, \
CFT_G711_FILTER_PROP

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\codecs\g711\resource.h ===
//{{NO_DEPENDENCIES}}
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// Microsoft Visual C++ generated include file.
// Used by G711.rc
//
#define IDD_G711CodecPROP               3500
#define IDC_G711Codec                   3501
#define IDB_DEFAULT                     3502
#define IDC_INPUT                       3503
#define IDC_PCM_IN                      3504
#define IDC_MULAW_IN                    3505
#define IDC_ALAW_IN                     3506
#define IDC_OUTPUT                      3507
#define IDC_PCM_OUT                     3508
#define IDC_MULAW_OUT                   3509
#define IDC_ALAW_OUT                    3510
#define IDS_TITLE                       3511
#define IDS_STATIC                      -1

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1012
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\codecs\g711\mk711.h ===
/*--------------------------------------------------------------

 INTEL Corporation Proprietary Information  

 This listing is supplied under the terms of a license agreement  
 with INTEL Corporation and may not be copied nor disclosed 
 except in accordance with the terms of that agreement.

 Copyright (c) 1996 Intel Corporation.
 All rights reserved.

 $Workfile:   MK711.h  $
 $Revision:   1.4  $
 $Date:   03 Aug 1996 13:35:30  $ 
 $Author:   MDEISHER  $

--------------------------------------------------------------

MK711.h

 prototype and declarations for MK711 routines and tables.
 NOTE: The Silence Detection routines are not currently implemented in 
 the BETA release.

--------------------------------------------------------------*/

#ifdef SILENCE_DETECTION // NOTE: this is not implemented in beta

#include "sdstruct.h"

typedef struct INSTANCE{

  long SDFlags;
  
  //COMFORT_PARMS ComfortParms;

  SD_STATE_VALS SDstate;

} INSTANCE;

extern int  	initializeSD(INSTANCE *SD_inst);
extern int 		silenceDetect(INSTANCE *SD_inst);
extern void 	glblSDinitialize(INSTANCE *SD_inst, int buffersize);
extern int 		classify(float Energy_val,float Alpha1val,float Zc_count,
                    float energymean,float energystdev,float alpha1_mean,
                    float alpha1stdev,float ZC_mean,float ZC_stdev,int s, INSTANCE *SD_inst);
extern void 	update(float *histarray,int histsize,float *mean,float *stdev);
extern int 		zeroCross(float x[], int n);
extern void 	getParams(INSTANCE *SD_inst, float *inbuff, int buffersize);
extern void 	prefilter(INSTANCE *SD_inst, float *sbuf, float *fbuf, int buffersize);
extern void		execSDloop(INSTANCE *SD_inst, int *isFrameSilent, int *isFrameCoded);

extern float 	DotProd(register const float in1[], register const float in2[], register int npts);
#endif

// prototypes for all conversion routines 
void Short2Ulaw(const unsigned short *in, unsigned char *out, long len);
void Ulaw2Short(const unsigned char *in, unsigned short *out, long len);
void Short2Alaw(const unsigned short *in, unsigned char *out, long len);
void Alaw2Short(const unsigned char *in, unsigned short *out, long len);

/* 

$Log:   K:\proj\g711\quartz\src\vcs\mk711.h_v  $
;// 
;//    Rev 1.4   03 Aug 1996 13:35:30   MDEISHER
;// changed function prototypes so that they match functions.
;// (changed int to long).
;// 
;//    Rev 1.3   29 Jul 1996 14:42:40   MDEISHER
;// 
;// added SILENCE_DETECTION constant and moved rest of SID declarations
;// inside the ifdef.
;// 
;//    Rev 1.2   24 May 1996 15:42:08   DGRAUMAN
;// cleaned up code, detabbed, etc...
;// 
;//    Rev 1.1   23 May 1996 11:33:00   DGRAUMAN
;// trying to make logging work

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\dxmrtp\dxmrtp.cpp ===
/*********************************************************************
 *
 * Copyright (C) Microsoft Corporation, 1997 - 1999
 *
 * File: dxmrtp.cpp
 *
 * Abstract:
 *     Include all factory templates to create a single DLL with
 *     all the filters.
 *
 * History:
 *     05/03/99    AndresVG - Added rtutil tracing facilities
 *     10/21/97    AndresVG - Created
 *
 **********************************************************************/

#define INCL_WINSOCK_API_TYPEDEFS 1
#include <winsock2.h>
#include <windows.h>

#include <qossp.h>

#include <streams.h>

#include <crtdbg.h>

#include <objbase.h>
#include <initguid.h>   // add GUIDs to this module...
#define INITGUID

#include "trace.h"

/*********************************************************************
 * Include below what is needed for every module
 *********************************************************************/

/*********************************************************************
 * AM RTP Demux
 *********************************************************************/
#if defined(AMRTPDMX_IN_DXMRTP)
// avoid compiler warning C4786:
// 'identifier' : identifier was truncated to 'number'
// characters in the debug information
#pragma warning( disable : 4786 )
#include <map.h>
#include <multimap.h>
#include <amrtpuid.h>
#include <amrtpdmx.h>
#include "rtpdtype.h"
#include "rtpdmx.h"
#include "rtpdprop.h"
#include "..\amrtpdmx\globals.h"
#include "..\amrtpdmx\template.h"
#endif

/*********************************************************************
 * AM RTP Network
 *********************************************************************/
#if defined(AMRTPNET_IN_DXMRTP)
#include <olectl.h>
#include <ws2tcpip.h>
#include <amrtpuid.h>
#include <amrtpnet.h>
#include <rrcm_dll.h>
#include <rrcmprot.h>
#include "..\amrtpnet\queue.h"
#include "..\amrtpnet\shared.h"
#include "..\amrtpnet\classes.h"
#include "..\amrtpnet\template.h"
#endif

/*********************************************************************
 * AM RTP Silence Supressor
 *********************************************************************/
#if defined(AMRTPSS_IN_DXMRTP)
#include <amrtpss.h>
#include <silence.h>
#include <siprop.h>
#include "..\amrtpss\template.h"
#endif

/*********************************************************************
 * Receive Paylod Handler RPH
 *********************************************************************/
#if defined(RPH_IN_DXMRTP)
#include <amrtpuid.h>
#if !defined(_UUIDS_H_INCLUDED_)
#define      _UUIDS_H_INCLUDED_
#include <uuids.h>
#endif
#include "ppmclsid.h"
#include "auduids.h"
#include "ippm.h"
#include "rph.h"
#include "rphprop.h"
#include "rphaud.h"
#include "rphgena.h"
#include "..\rph\rphgena\genaprop.h"
#include "rphgenv.h"
#include "..\rph\rphgenv\genvprop.h"
#include "rphh26x.h"
#include "rphprop2.h"
#include "..\rph\rphaud\template.h"
#include "..\rph\rphgena\template.h"
#include "..\rph\rphgenv\template.h"
#include "..\rph\rphh26x\template.h"
#endif

/*********************************************************************
 * Sender Paylod Handler SPH
 *********************************************************************/
#if defined(SPH_IN_DXMRTP)
#include <amrtpuid.h>
#if !defined(_UUIDS_H_INCLUDED_)
#define      _UUIDS_H_INCLUDED_
#include <uuids.h>
#endif
#include "ppmclsid.h"
#include "auduids.h"
#include "ippm.h"
#include "sph.h"
#include "sphprop.h"
#include "sphaud.h"
#include "sphgena.h"
#include "..\sph\sphgena\genaprop.h"
#include "sphgenv.h"
#include "..\sph\sphgenv\genvprop.h"
#include "sphh26x.h"
#include "..\sph\sphaud\template.h"
#include "..\sph\sphgena\template.h"
#include "..\sph\sphgenv\template.h"
#include "..\sph\sphh26x\template.h"
#endif

/*********************************************************************
 * PCM Mixer
 *********************************************************************/
#if defined(MIXER_IN_DXMRTP)
#if !defined(_UUIDS_H_INCLUDED_)
#define      _UUIDS_H_INCLUDED_
#include <uuids.h>
#endif
#include "..\mixer\stdafx.h"
#include "mxfilter.h"
#include "..\mixer\template.h"
#endif

/*********************************************************************
 * PPM
 *********************************************************************/
#if defined(PPM_IN_DXMRTP)

STDAPI PPMDllGetClassObject( REFCLSID rclsid, REFIID riid, LPVOID FAR* ppvObj );
STDAPI PPMDllCanUnloadNow( void );
STDAPI PPMDllRegisterServer( void );
STDAPI PPMDllUnregisterServer( void );

#endif
		
/*********************************************************************
 * Codecs: G711, H261, H263
 *********************************************************************/
#if defined(CODECS_IN_DXMRTP)
#if !defined(_UUIDS_H_INCLUDED_)
#define      _UUIDS_H_INCLUDED_
#include <uuids.h>
#endif
#include "amacodec.h"
#include "amacprop.h"
#include "..\codecs\g711\template.h"
#include "..\codecs\h261\template.h"
#endif

/*********************************************************************
 * Bridge Filters
 *********************************************************************/
#if defined(BRIDGE_IN_DXMRTP)
#include "..\bridge\precomp.h"
#include "..\bridge\template.h"
#include "ibfilter.h"
#include "..\bridge\bsource.h"
#include "..\bridge\brender.h"
#include "..\bridge\bprop.h"
#endif


/*********************************************************************
 * Entry point
 *********************************************************************/

extern "C" BOOL WINAPI DllMain(HINSTANCE, ULONG, LPVOID);
extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE, ULONG, LPVOID);

BOOL WINAPI
DllMain(
		HINSTANCE hInstance, 
		ULONG     ulReason, 
		LPVOID    pv
    )
{
    if (ulReason == DLL_PROCESS_ATTACH)
    {
        TRACEREGISTER(TEXT("dxmrtp")); // rtutil tracing facilities
        _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
    }

    BOOL res = DllEntryPoint(hInstance, ulReason, pv);

    if (ulReason == DLL_PROCESS_DETACH)
    {
        _RPT0( _CRT_WARN, "Going to call dump memory leaks.\n");
        _CrtDumpMemoryLeaks();
        TRACEDEREGISTER(); // rtutil tracing facilities
    }
    return res;
}

STDAPI
DxmDllGetClassObject(REFCLSID rClsID, REFIID riid, void **pv)
{
#if defined(PPM_IN_DXMRTP)
	if (PPMDllGetClassObject(rClsID, riid, pv) == NOERROR)
		return(NOERROR);
#endif

	return(DllGetClassObject(rClsID, riid, pv));
}

STDAPI
DxmDllCanUnloadNow()
{
#if defined(PPM_IN_DXMRTP)
	if (PPMDllCanUnloadNow() != S_OK)
		return(S_FALSE);
#endif

	return(DllCanUnloadNow());
}

HRESULT
DllRegisterServer()
{
#if defined(AMRTPDMX_IN_DXMRTP)
	RtpDemuxRegisterResources();
#endif
#if defined(PPM_IN_DXMRTP)
	PPMDllRegisterServer();
#endif

    // forward to amovie framework
    return AMovieDllRegisterServer2( TRUE );
}

HRESULT
DllUnregisterServer()
{
#if defined(PPM_IN_DXMRTP)
	PPMDllUnregisterServer();
#endif
    // forward to amovie framework
    return AMovieDllRegisterServer2( FALSE );
}

CFactoryTemplate g_Templates[] = {
#if defined(AMRTPDMX_IN_DXMRTP)
	CFT_AMRTPDMX_ALL_FILTERS,
#endif
#if defined(AMRTPNET_IN_DXMRTP)
    CFT_AMRTPNET_ALL_FILTERS,
#endif
#if defined(AMRTPSS_IN_DXMRTP)
    CFT_AMRTPSS_ALL_FILTERS,
#endif
#if defined(RPH_IN_DXMRTP)
    CFT_RPHAUD_ALL_FILTERS,
    CFT_RPHGENA_ALL_FILTERS,
#if !defined(NO_GENERIC_VIDEO)
    CFT_RPHGENV_ALL_FILTERS,
#endif
    CFT_RPHH26X_ALL_FILTERS,
#endif
#if defined(SPH_IN_DXMRTP)
    CFT_SPHAUD_ALL_FILTERS,
    CFT_SPHGENA_ALL_FILTERS,
#if !defined(NO_GENERIC_VIDEO)
    CFT_SPHGENV_ALL_FILTERS,
#endif
    CFT_SPHH26X_ALL_FILTERS,
#endif
#if defined(MIXER_IN_DXMRTP)
	CFT_MIXER_ALL_FILTERS,
#endif
#if defined(CODECS_IN_DXMRTP)
	CFT_G711_ALL_FILTERS,
#endif
#if defined(BRIDGE_IN_DXMRTP)
    CFT_BRIDGE_ALL_FILTERS,
#endif
};

int g_cTemplates = (sizeof(g_Templates)/sizeof(g_Templates[0]));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\dxmrtp\trace.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    trace.cpp

Abstract:

    This module contains the debugging support for the MSPs. 

--*/

#if defined(DXMRTPTRACE)

#include <windows.h>
#include <stdio.h>

#include "trace.h"

#define MAXDEBUGSTRINGLENGTH 512

static DWORD   sg_dwTraceID = INVALID_TRACEID;

static char    sg_szTraceName[100];   // saves name of dll
static DWORD   sg_dwEnableDebuggerTracing = 0;
static DWORD   sg_dwConsoleTracingMask = 0;


BOOL NTAPI DxmTraceRegister(LPCTSTR szName)
{
    HKEY       hTracingKey;

    char       szTracingKey[100];
    const char szTracingEnableValue[] = "EnableDebuggerTracing";
    const char szTracingMaskValue[]   = "ConsoleTracingMask";

    sg_dwEnableDebuggerTracing = 0;

#ifdef UNICODE
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%ls", szName);
#else
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%s", szName);
#endif

    if ( ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                        szTracingKey,
                                        0,
                                        KEY_READ,
                                        &hTracingKey) )
    {
		DWORD      dwDataSize = sizeof (DWORD);
		DWORD      dwDataType;

        RegQueryValueExA(hTracingKey,
                         szTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwEnableDebuggerTracing,
                         &dwDataSize);

        RegQueryValueExA(hTracingKey,
                         szTracingMaskValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwConsoleTracingMask,
                         &dwDataSize);

        RegCloseKey (hTracingKey);
    }

#ifdef UNICODE
    wsprintfA(sg_szTraceName, "%ls", szName);
#else
    wsprintfA(sg_szTraceName, "%s", szName);
#endif

    sg_dwTraceID = TraceRegister(szName);

    return (sg_dwTraceID != INVALID_TRACEID);
}

void NTAPI DxmTraceDeRegister()
{
    sg_dwEnableDebuggerTracing = 0;

    if (sg_dwTraceID != INVALID_TRACEID)
    {
        TraceDeregister(sg_dwTraceID);
        sg_dwTraceID = INVALID_TRACEID;
    }
}

char *trace_message[] = {
    "TRACE", 
    "ERROR", 
    "WARN", 
    "INFO", 
    "INVALID TRACE LEVEL"
};

void NTAPI DxmTracePrint(IN DWORD dwDbgLevel,
                         IN DWORD dwDbgType,
                         IN LPCSTR lpszFormat,
                         IN ...)
/*++

Routine Description:

    Formats the incoming debug message & calls TraceVprintfEx to print it.

Arguments:

    dwDbgLevel   - The type of the message.

    lpszFormat - printf-style format string, followed by appropriate
                 list of arguments

Return Value:

--*/
{
    char  szTraceBuf[MAXDEBUGSTRINGLENGTH + 1];
    
    DWORD dwIndex, dwLevel;

    if (dwDbgType > 4)
        dwDbgType = 4;

    dwLevel = dwDbgLevel & 0x000f0000;
    
    switch(dwDbgLevel) {
    case TRACE_TRACE: dwIndex = 0; break;
    case TRACE_ERROR: dwIndex = 1; break;
    case TRACE_WARN:  dwIndex = 2; break;
    case TRACE_INFO:  dwIndex = 3; break;
    default:          dwIndex = 4;
    }

    // based on the 4 basic levels, use Type to build up to 4 levels
    // including the basic one
    dwDbgLevel = (dwLevel << (dwDbgType-1)) | (dwDbgLevel & 0xffff);
    
    if ( ( sg_dwEnableDebuggerTracing > 0 ) &&
         ( 0 != ( dwDbgLevel & sg_dwConsoleTracingMask ) ) )
    {
        // retrieve local time
        SYSTEMTIME SystemTime;
        GetLocalTime(&SystemTime);

        wsprintfA(szTraceBuf,
                  "%s:[%02u:%02u:%02u.%03u,tid=%x:]%s: ",
                  sg_szTraceName,
                  SystemTime.wHour,
                  SystemTime.wMinute,
                  SystemTime.wSecond,
                  SystemTime.wMilliseconds,
                  GetCurrentThreadId(), 
                  trace_message[dwIndex]);

        va_list ap;
        va_start(ap, lpszFormat);

        _vsnprintf(&szTraceBuf[lstrlenA(szTraceBuf)], 
            MAXDEBUGSTRINGLENGTH - lstrlenA(szTraceBuf), 
            lpszFormat, 
            ap
            );

        lstrcatA (szTraceBuf, "\n");

        OutputDebugStringA (szTraceBuf);

        va_end(ap);
    }

    if (sg_dwTraceID != INVALID_TRACEID)
    {
        wsprintfA(szTraceBuf, "[%s] %s", trace_message[dwIndex], lpszFormat);

        va_list arglist;
        va_start(arglist, lpszFormat);
        TraceVprintfExA(sg_dwTraceID, dwDbgLevel, szTraceBuf, arglist);
        va_end(arglist);
    }
}

#endif // DXMRTPTRACE

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\am_dmx.h ===
/*********************************************************************
 *
 * Copyright (c) 1997 Microsoft Corporation
 *
 * File: am_dmx.h
 *
 * Abstract:
 *     Events sent by the RTP Demux.
 *
 * History:
 *     12/01/97    Created by AndresVG
 *
 **********************************************************************/
#if !defined(_AM_DMX_H_)
#define      _AM_DMX_H_

#if !defined(RTPDMX_EVENTBASE)
#define RTPDMX_EVENTBASE (EC_USER+100)

typedef enum {
	RTPDEMUX_SSRC_MAPPED,       // The specific SSRC has been mapped
	RTPDEMUX_SSRC_UNMAPPED,     // The specific SSRC has been unmapped
	RTPDEMUX_PIN_MAPPED,        // The specific Pin has been mapped
	RTPDEMUX_PIN_UNMAPPED,      // The specific Pin has been unmapped
	RTPDEMUX_NO_PINS_AVAILABLE, // PT was found, but pin was already mapped
	RTPDEMUX_NO_PAYLOAD_TYPE    // PT was not found
} RTPDEMUX_EVENT_t;
// The Pin passed as a parameter along with PIN_MAPPED and PIN_UNMAPPED
// is a pointer to the connected pin

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\auduids.h ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : auduid.h
// Purpose  : Define the Audio UIDs used by the G.711 and G.723 codecs
// Contents : 
//*M*/

#ifndef _AUDUIDS_H_
#define _AUDUIDS_H_

#include "g711uids.h"
#include "g723uids.h"

#endif _AUDUIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\iamacset.h ===
/*--------------------------------------------------------------

 INTEL Corporation Proprietary Information  

 This listing is supplied under the terms of a license agreement  
 with INTEL Corporation and may not be copied nor disclosed 
 except in accordance with the terms of that agreement.

 Copyright (c) 1996 Intel Corporation.
 All rights reserved.

 $Workfile:   iamacset.h  $
 $Revision:   1.1  $
 $Date:   10 Dec 1996 15:35:20  $ 
 $Author:   MDEISHER  $

--------------------------------------------------------------

iamacset.h

The generic ActiveMovie audio compression filter settings
interface header.

--------------------------------------------------------------*/

////////////////////////////////////////////////////////////////////
// ICodecSettings:  Basic codec settings interface
//
// This interface is exported and used by the code in amacodec.cpp.
//

// {AEF332D0-46E6-11d0-9DA0-00AA00AF3494}
DEFINE_GUID(IID_ICodecSettings, 
0xaef332d0, 0x46e6, 0x11d0, 0x9d, 0xa0, 0x0, 0xaa, 0x0, 0xaf, 0x34, 0x94);

DECLARE_INTERFACE_(ICodecSettings, IUnknown)
{
    // Compare these with the functions in class CMyCodec

    STDMETHOD(get_Transform)
        ( THIS_
          int *transform  // [out] transformation type
        ) PURE;

    STDMETHOD(put_Transform)
        ( THIS_
          int transform   // [in] transformation type
        ) PURE;

    STDMETHOD(get_InputBufferSize)
        ( THIS_
          int *numbytes   // [out] input buffer size
        ) PURE;

    STDMETHOD(put_InputBufferSize)
        ( THIS_
          int numbytes   // [out] input buffer size
        ) PURE;

    STDMETHOD(get_OutputBufferSize)
        ( THIS_
          int *numbytes   // [out] output buffer size
        ) PURE;

    STDMETHOD(put_OutputBufferSize)
        ( THIS_
          int numbytes   // [out] output buffer size
        ) PURE;

    STDMETHOD(put_InputMediaSubType)
        ( THIS_
          REFCLSID rclsid // [in] output mediasubtype guid
        ) PURE;

    STDMETHOD(put_OutputMediaSubType)
        ( THIS_
          REFCLSID rclsid // [in] output mediasubtype guid
        ) PURE;

    STDMETHOD(get_Channels)
        ( THIS_
          int *channels, // [out] number of channels
          THIS_
          int index      // [in] enumeration index
        ) PURE;

    STDMETHOD(put_Channels)
        ( THIS_
          int channels  // [in] number of channels
        ) PURE;

    STDMETHOD(get_SampleRate)
        ( THIS_
          int *samprate, // [out] sample rate
          THIS_
          int index      // [in] enumeration index
        ) PURE;

    STDMETHOD(put_SampleRate)
        ( THIS_
          int samprate   // [in] sample rate
        ) PURE;

    STDMETHOD(ReleaseCaps)
        (
        ) PURE;

    virtual BOOL(IsUnPlugged)
        (
        ) PURE;
};

/*
//$Log:   K:\proj\mycodec\quartz\vcs\iamacset.h_v  $
;// 
;//    Rev 1.1   10 Dec 1996 15:35:20   MDEISHER
;// 
;// added ifdef DEFGLOBAL and prototype.
;// 
;//    Rev 1.0   09 Dec 1996 09:05:32   MDEISHER
;// Initial revision.
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\rrcmdata.h ===
/*---------------------------------------------------------------------------
 * File : RRCMDATA.H
 *
 * RRCM data structures information.
 *
 * $Workfile:   rrcmdata.h  $
 * $Author:   CMACIOCC  $
 * $Date:   20 May 1997 11:41:52  $
 * $Revision:   1.14  $
 * $Archive:   R:\rtp\src\rrcm\rrcminc\rrcmdata.h_v  $
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/

#ifndef __RRCMDATA_H_
#define __RRCMDATA_H_

// force 8 byte structure packing
#include <pshpack8.h>   

#define MAX_DWORD                   4294967295
#define HASH_MODULO                 255 
#define FILENAME_LENGTH             128
#define RTCP_FEEDBACK_LIST          0


// RTP/RTCP collision data
typedef struct _rtp_collision
    {
    char                collideAddr[MAX_ADDR_LEN];
    int                 addrLen;
    DWORD               dwCollideTime;
    DWORD               dwCurRecvRTCPrptNumber;
    DWORD               SSRC;
    } RTP_COLLISION, *PRTP_COLLISION;

// Time to wait (in ms) before a stored SSRC is timed out. I.e. how
// long packets with same SSRC arriving after BYE was received will
// not create a new participant (same one) and will not be processed
#define OLD_SSRC_TIME   (5*1000)

typedef struct _rtp_bye_ssrc
{
    DWORD               SSRC; // host order
    DWORD               dwDeleteTime; // in ms
} RTP_BYE_SSRC;
   

//  RTCP Session Information data structure
typedef struct _RTCP_SESSION
    {                              
    LINK_LIST   RTCPList;                   // Next/prev RTCP session ptrs
    
    // Synchronization elements
    CRITICAL_SECTION    critSect;           // Critical section 
    HANDLE      hExitEvent;                 // Exit RTCP event handle

#ifdef ENABLE_ISDM2
    // ISDM2 Handle
    KEY_HANDLE  hSessKey;                   // Key to this sessions ISDM info
#endif

    // List of SSRC(s) on the transmit list, i.e., our own transmit SSRC's
    //  and list of SSRC(s) received
    CRITICAL_SECTION SSRCListCritSect;      // Critical section 
    HEAD_TAIL   RcvSSRCList;                // Rcv SSRC list head/tail ptrs
    HEAD_TAIL   XmtSSRCList;                // Xmt SSRC list head/tail ptrs

    // List of Rcv/Xmt data structure. The data resides in a heap
    //  in order to avoid page fault
    CRITICAL_SECTION BfrCritSect;           // Critical section 
    HEAD_TAIL   RTCPrcvBfrList;             // Rcv buffers head/tail ptrs
    HEAD_TAIL   RTCPrcvBfrListUsed;         // Rcv buffers head/tail ptrs
    HEAD_TAIL   RTCPxmtBfrList;             // Xmt buffers head/tail ptrs   
    HANDLE      hHeapRcvBfrList;            // Heap handle to Rcv bfrs list 
    HANDLE      hHeapXmtBfrList;            // Heap handle to Xmt bfrs list 

    // Rcv/Xmt buffers have their own heap 
    HANDLE      hHeapRcvBfr;                // Heap handle to Rcv Bfrs mem. 
    HANDLE      hHeapXmtBfr;                // Heap handle to Xmt Bfrs      

    // Application provided list of buffers where RRCM will copy the raw
    //  RTCP buffers
    HEAD_TAIL   appRtcpBfrList;             // Head/tail ptrs for app bfr list

    DWORD       dwInitNumFreeRcvBfr;        // Number of Free Rcv Buffers   
    DWORD       dwRcvBfrSize;               // Receive Buffer size          
    DWORD       dwInitNumFreeXmtBfr;        // Number of Free Xmt Buffers   
    DWORD       dwXmtBfrSize;               // Transmit Buffer size         
                
    DWORD       dwSessionStatus;            // Entry status:                

    SOCKADDR    toAddr;                     // Destination address          
    int         toAddrLen;                  // Size of toAddr

    int         avgRTCPpktSizeRcvd;         // Average RTCP pckt size       

    DWORD       dwNumStreamPerSes;          // Num of streams per Session
    DWORD       dwCurNumSSRCperSes;         // Num of SSRC per Session      

#ifdef MONITOR_STATS
    DWORD       dwHiNumSSRCperSes;          // High Num of SSRC per Session 
#endif

    // Receive information (shared by all streams of this session)
	HANDLE		hLastPendingRecv;			// Shutdown procedure done
    long        lNumRcvIoPending;           // Number of receive I/O pending

    // Some fields to debug the hang in RTCP
    void       *pvRTPSession;
    DWORD       dwLastRecvTime;
        
    // Notification callback of RRCM events if desired by the application
    PRRCM_EVENT_CALLBACK    pRRCMcallback;

    // User information on callback
    void       *pvCallbackUserInfo[2];
    DWORD       dwEventMask[2];
    DWORD       dwSdesMask;
    long        lRTCP_ID;   
        
    // RTP Loop/Collision information
    RTP_COLLISION   collInfo[NUM_COLLISION_ENTRIES];

    // Deleted SSRCs from which BYE was received
    RTP_BYE_SSRC    byessrc[NUM_COLLISION_ENTRIES];

    } RTCP_SESSION, *PRTCP_SESSION;


// RTCP Xmt information
typedef struct _XMIT_INFO 
    {
    DWORD       dwNumPcktSent;              // Number of packet sent        
    DWORD       dwNumBytesSent;             // Number of bytes sent         
    DWORD       dwNTPmsw;                   // NTP most significant word    
    DWORD       dwNTPlsw;                   // NTP least significant word   
    DWORD       dwRTPts;                    // RTP timestamp                
    DWORD       dwCurXmtSeqNum;             // Current Xmt sequence number  
    DWORD       dwPrvXmtSeqNum;             // Previous Xmt sequence number 
    DWORD       dwRtcpStreamMinBW;          // Minimal session's bandwidth
#ifdef DYNAMIC_RTCP_BW
    DWORD       dwCalculatedXmtBW;          // Session's calculated bandwidth
    DWORD       dwLastTimeBwCalculated;     // Last time BW was calculated
    DWORD       dwLastTimeNumBytesSent;     // Last time number of bytes send
    DWORD       dwLastTimeNumPcktSent;      // Last time number of bytes send
#endif
    DWORD       dwLastSR;                   // Last sender report (RTP format)
    DWORD       dwLastSRLocalTime;          // Last sender report local time
    DWORD       dwLastSendRTPSystemTime;    // Last RTP packet send time
    DWORD       dwLastSendRTPTimeStamp;     // RTP timestamp of the last packet
    } XMIT_INFO, *PXMIT_INFO;


// RTCP receive information
typedef struct _RECV_INFO 
    {
    DWORD       dwNumPcktRcvd;              // Number of packet received    
    DWORD       dwPrvNumPcktRcvd;           // Previous number of pckt rcvd 
    DWORD       dwExpectedPrior;            // Number previously expected   
    DWORD       dwNumBytesRcvd;             // Number of bytes rcvd         
    DWORD       dwBaseRcvSeqNum;            // Initial sequence number rcvd 
    DWORD       dwBadSeqNum;                // Potential new valid seq num  
    DWORD       dwProbation;                // # consec pkts for validation 
    RTP_SEQ_NUM XtendedSeqNum;              // Xtnded highest seq. num rcvd 
    DWORD       dwPropagationTime;          // Last packet's transmit time  
    DWORD       interJitter;                // Interarrival jitter          
#ifdef DYNAMIC_RTCP_BW
    DWORD       dwCalculatedRcvBW;          // Session's calculated bandwidth
    DWORD       dwLastTimeBwCalculated;     // Last time BW was calculated
    DWORD       dwLastTimeNumBytesRcvd;     // Last time number of bytes rcvd
    DWORD       dwLastTimeNumPcktRcvd;      // Last time number of bytes rcvd
#endif
    } RECV_INFO, *PRECV_INFO;


//  RTP process data structure 
typedef struct _RTP_SESSION
    {                    
    LINK_LIST       RTPList;                // Next/Prev RTP session

    CRITICAL_SECTION    critSect;           // Critical section 

    PRTCP_SESSION   pRTCPSession;           // Pointer to my RTCP side      
    HANDLE          hHeapFreeList;          // Heap handle
    HEAD_TAIL       pRTPFreeList;           // Head/tail of free list
    HEAD_TAIL       pRTPUsedListRecv;       // Head/tail of used list
    HEAD_TAIL       pRTPUsedListSend;       // Head/tail of used list
    DWORD           dwNumTimesFreeListAllocated;
    long            lNumRecvIoPending;      // Buffers installed
    DWORD           dwSessionStatus;        // Entry status:                
    HANDLE          hSendTo;                // Event handle to sync SendTo
    DWORD           dwID;
    DWORD           dwKind;                 // SHUTDOWN:2, SEND:1, RECV:0
    long            RefCount[2];
    // This code to debug the hang in RTCP
    SOCKET          pSocket[3]; // RTP recv, RTP send, and RTCP sockets
    DWORD           dwStatus;   
    DWORD           dwLastError;
    DWORD           dwCloseTime;
    } RTP_SESSION, *PRTP_SESSION;
                  

//  RTP Ordered buffer structure
typedef struct _RTP_BFR_LIST
    {
    LINK_LIST           RTPBufferLink;      // Next/prev                    

    LPWSAOVERLAPPED_COMPLETION_ROUTINE  
                pfnCompletionNotification;  // Pointer to Rcv notif. func   
    WSAEVENT            hEvent;             // WSAOverlapped handle         
    LPWSABUF            pBuffer;            // Pointer to WSABuffers        
    PRTP_SESSION        pSession;           // This session's ID            
    DWORD               dwBufferCount;      // Number of bufs in LPWSABUF   
    LPDWORD             pNumBytesRecvd;     // Pointer to number of bytes recvd
    LPDWORD             pFlags;             // Pointer to flags             
    PSOCKADDR           pFrom;              // Pointer to source address    
    LPINT               pFromlen;           // Pointer to source address    
    WSAOVERLAPPED      *pOverlapped;        // -> to user's Overlapped struct
    WSAOVERLAPPED       Overlapped;         // Overlapped structure
    DWORD               dwKind;
    } RTP_BFR_LIST, *PRTP_BFR_LIST;


// Selects which address to update in SSRC_ENTRY
enum {UPDATE_RTP_ADDR, UPDATE_RTCP_ADDR};

//  RRCM statistics table entry data structure
typedef struct _SSRC_ENTRY 
{
    LINK_LIST   SSRCList;                   // Next/prev SSRC entry 

    CRITICAL_SECTION    critSect;           // Critical section synch.      

    PRTP_SESSION    pRTPses;                // Point to the parent RTP session
    PRTCP_SESSION   pRTCPses;               // Point to the parent RTCP session

    DWORD       SSRC;                       // Source SSRC                  
    DWORD       PayLoadType;                // payload associated with this SSRC

    DWORD       dwSSRCStatus;               // Entry status                 
#define NETWK_RTPADDR_UPDATED   0x80000000  // Network RTP Address already done
#define NETWK_RTCPADDR_UPDATED  0x40000000  // Network RTCPAddress already done
#define SEQ_NUM_UPDATED         0x20000000  // XMT Sequence already done    
#define THIRD_PARTY_COLLISION   0x10000000  // Third party collsion detected
#define CLOSE_RTCP_SOCKET       0x08000000  // RTCP will close the RTCP socket
#define RTCP_XMT_USER_CTRL      0x04000000  // User's has RTCP timeout control
#define RTCP_INACTIVE_EVENT     0x02000000  // Event has been posted

    // SSRC Transmit information  
    // If on our transmit list, this is our SSRC information, and if on our 
    // receive list, this is a SR feedback information.
    XMIT_INFO   xmtInfo;

    // SSRC Receive information 
    // If on our transmit list, this is undefined information, and if on our 
    // receive list, this is the SSRC's receive information, ie, this SSRC 
    // is an active sender somewhere on the network. This information is 
    // maintained by RTP, and used by RTCP to generate RR.
    RECV_INFO   rcvInfo;

    // Feedback information received about ourselve if we're an active source
    RTCP_FEEDBACK   rrFeedback;             // Feedback information

    DWORD       dwLastReportRcvdTime;       // Time of last report received
    DWORD       dwNextReportSendTime;       // Next scheduled report time (ms)

#if defined(DEBUG) || defined(_DEBUG)
    DWORD       dwPrvTime;                  // Elapsed time between report  
#endif

    // SSRC SDES information

    SDES_DATA   sdesItem[RTCP_SDES_LAST-RTCP_SDES_FIRST-1];
    //SDES_DATA cnameInfo;                  // CNAME information
    //SDES_DATA nameInfo;                   // NAME information
    //SDES_DATA emailInfo;                  // EMAIL address information
    //SDES_DATA phoneInfo;                  // PHONE number information
    //SDES_DATA locInfo;                    // LOCation (users) information
    //SDES_DATA toolInfo;                   // TOOL name information
    //SDES_DATA txtInfo;                    // TEXT (NOTE) information
    //SDES_DATA privInfo;                   // PRIVate information

    // SSRC network address information 
    int         fromRTPLen;                 // From RTP address length
    SOCKADDR    fromRTP;                    // From RTP address

    int         fromRTCPLen;                // From RTCP address length
    SOCKADDR    fromRTCP;                   // From RTCP address

    // !!! Not implemented (entries will grow exponentionally) !!!
    // List of SSRCs in RR received by this SSRC. It might be useful for a 
    // sender or a controller to know how other active sources are received
    // by others. 
    // The drawback is that the number of entries will grow exponentially 
    // with the number of participants. 
    // Currently not implemented. 
#if RTCP_FEEDBACK_LIST
    HEAD_TAIL   rrFeedbackList;             // Head/Tail of feedback list
#endif

#ifdef ENABLE_ISDM2
    DWORD       hISDM;                      // ISDM session handle
#endif

    // All variables below should be in an additional linked list one layer 
    // up this one, under the RTCP session link list.
    // They have been moved here when we added multiple streams per session 
    // !!! NOTE !!!: There is only 1 transmit thread per stream. It's ID is
    // found in this data structure which is on the Xmt list.
    // Refer to RTP for the sockets
    HANDLE      hXmtThread;                 // RTCP session thread handle   
    DWORD       dwXmtThreadID;              // RTCP session thread ID       
    HANDLE      hExitXmtEvent;              // Xmt thread Exit event - 
                                            //  Used to terminate a session
                                            //  among multiple stream on the
                                            //  same session
    DWORD       dwNumRptSent;               // Number of RTCP report sent   
    DWORD       dwNumRptRcvd;               // Number of RTCP report rcvd   
    DWORD       dwNumXmtIoPending;          // Number of transmit I/O pending
    DWORD       dwStreamClock;              // Sampling frequency
    DWORD       dwUserXmtTimeoutCtrl;       // User's xmt timer control
                                            //      0x0     -> RRCM control
                                            //      0xFFFF  -> No RTCP send
                                            //      value   -> timer value
    DWORD       dwTimeStampOffset;          // Timestamp offset
    // All the above variables should move in the intermediate layer for 
    // multiple stream per session support

} SSRC_ENTRY, *PSSRC_ENTRY;


    

enum {RTP_KIND_RECV, RTP_KIND_SEND, RTP_KIND_LAST};

#define RTP_KIND_FIRST RTP_KIND_RECV
#define RTP_KIND_RTCP (RTP_KIND_SEND+1)

#define SOCK_RECV RTP_KIND_RECV
#define SOCK_SEND RTP_KIND_SEND
#define SOCK_RTCP RTP_KIND_RTCP

#define RTP_KIND_BIT(b)   (1<<(b))
#define RTP_KIND_MASK (RTP_KIND_BIT(RTP_KIND_RECV) | \
                       RTP_KIND_BIT(RTP_KIND_SEND))
#define RTP_KIND_SHUTDOWN RTP_KIND_LAST
        
//  RTP Ordered buffer structure
typedef struct _RTP_HASH_LIST {
    LINK_LIST           RTPHashLink;        // Next/prev                    

    PRTP_SESSION        pSession;           // This session's ID
    
    // RTP recv and send sockets may or may not be the same, in
    // unicast they may be different, but they must be the same for
    // multicast
    // RTP recv, RTP send, and RTCP sockets
    SOCKET              pSocket[3]; 
    
    } RTP_HASH_LIST, *PRTP_HASH_LIST;



//  RTP registry initialization 
typedef struct _RRCM_REGISTRY
    {
    DWORD               NumSessions;        // RTP/RTCP sessions
    DWORD               NumFreeSSRC;        // Initial number of free SSRCs
    DWORD               NumRTCPPostedBfr;   // Number of RTCP recv bfr posted
    DWORD               RTCPrcvBfrSize;     // RTCP rcv bfr size

    // Dynamically loaded DLL & Send/Recv function name
    CHAR                WSdll[FILENAME_LENGTH];
    } RRCM_REGISTRY, *PRRCM_REGISTRY;



//  RTP Context Sensitive structure 
typedef struct _RTP_CONTEXT
    {                    
    HEAD_TAIL       pRTPSession;            // Head/tail of RTP session(s)

    CRITICAL_SECTION    critSect;           
    HINSTANCE       hInst;                  // DLL instance                 
    HANDLE          hHashFreeList;          // Heap for hash table          

    HEAD_TAIL       pRTPHashList;           // Ptr to linked list of hash bufs
    RTP_HASH_LIST   RTPHashTable[HASH_MODULO+1];
                                            // Hash table used for sessions

    RRCM_REGISTRY   registry;               // Registry initialization
    } RTP_CONTEXT, *PRTP_CONTEXT;


enum { //       Flags in RTCP_CONTEXT.dwStatus
    STAT_RTCPTHREAD,
    STAT_TERMRTCPEVENT,
    STAT_RTCPRQEVENT,
    STAT_RTCPQOSEVENT,
    STAT_RTCP_SHUTDOWN,
    STAT_RTCP_LAST
};

//  RTCP Context Sensitive structure 
typedef struct _RTCP_CONTEXT
    {                    
    HEAD_TAIL       RTCPSession;            // RTCP sessions head/tail ptrs 
    CRITICAL_SECTION critSect;              // Critical section synch.      

    CRITICAL_SECTION CreateThreadCritSect;  // Critical section synch.      

    CRITICAL_SECTION HeapCritSect;          // Critical section synch.      
    HANDLE          hHeapRTCPSes;           // Heap handle to RTCP sessions 
    HEAD_TAIL       RRCMFreeStat;           // RRCM entries head/tail ptrs  
    HANDLE          hHeapRRCMStat;          // Heap handle to RRCM stats    
    DWORD           dwInitNumFreeRRCMStat;  // Number of Free SSRC entries  


    DWORD           dwRtcpThreadID;         // RTCP thread ID
    HANDLE          hRtcpThread;            // RTCP thread hdle
    HANDLE          hTerminateRtcpEvent;    // RTCP terminate thread event hdl
    HANDLE          hRtcpRptRequestEvent;   // RTCP report request event
    HANDLE          hRtcpQOSControlEvent;   // RTCP QOS notifications
    DWORD           dwStatus;
        
#ifdef MONITOR_STATS
    DWORD           dwRTCPSesCurNum;        // Num of RTCP Session          
    DWORD           dwRTCPSesHiNum;         // High num RTCP per Session    

    DWORD           dwRRCMStatFreeLoNum;    // Low num of RRCM free Stat    
    DWORD           dwRRCMStatFreeCurNum;   // Cur num of RRCM Free Stat    
    DWORD           dwRRCMStatFreeHiNum;    // High num of RRCM Free Stat   

    DWORD           dwCurNumRTCPThread;     // Current num of RTCP thread   
    DWORD           dwHiNumRTCPThread;      // High number of RTCP thread   

    DWORD           dwNumRTCPhdrErr;        // Num of RTCP pckt header err. 
    DWORD           dwNumRTCPlenErr;        // Num of RTCP pckt length err. 
#endif
    } RTCP_CONTEXT, *PRTCP_CONTEXT;



//  RTCP Free Buffers List
typedef struct _RTCP_BFR_LIST
    {
    LINK_LIST           bfrList;            // Next/prev buffer in list     

    WSAOVERLAPPED       overlapped;         // Overlapped I/O structure     
    WSABUF              bfr;                // WSABuffers                   
    DWORD               dwBufferCount;      // Number of bufs in WSABUF     

    DWORD               dwNumBytesXfr;      // Number of bytes rcv/xmt      
    DWORD               dwFlags;            // Flags                        
    SOCKADDR            addr;               // Network Address
    int                 addrLen;            // Address length           

    PSSRC_ENTRY         pSSRC;              // Pointer to SSRC entry address
    DWORD               dwKind;      
    } RTCP_BFR_LIST, *PRTCP_BFR_LIST;

enum {RTCP_KIND_RECV, RTCP_KIND_SEND, RTCP_KIND_LAST};

#define RTCP_KIND_FIRST RTCP_KIND_RECV

#define RTCP_KIND_BIT(b)   (1<<(b))
#define RTCP_KIND_MASK (RTCP_KIND_BIT(RTCP_KIND_RECV) | \
                        RTCP_KIND_BIT(RTCP_KIND_SEND))
#define RTCP_KIND_SHUTDOWN RTCP_KIND_LAST

// Dynamically loaded functions
typedef struct _RRCM_WS
    {
    HINSTANCE                       hWSdll;
    LPFN_WSASENDTO                  sendTo;
    LPFN_WSARECVFROM                recvFrom;
    LPFN_WSASEND                    send;
    LPFN_WSARECV                    recv;
    LPFN_WSANTOHL                   ntohl;
    LPFN_WSANTOHS                   ntohs;
    LPFN_WSAHTONL                   htonl;
    LPFN_WSAHTONS                   htons;
    LPFN_GETSOCKNAME                getsockname;
    LPFN_GETHOSTNAME                gethostname;
    LPFN_GETHOSTBYNAME              gethostbyname;
    LPFN_CLOSESOCKET                closesocket;
    } RRCM_WS, *PRRCM_WS;


#ifdef ENABLE_ISDM2
// ISDM support
typedef struct _ISDM2
    {
    CRITICAL_SECTION    critSect;           // Critical section synch.      
    ISDM2API            ISDMEntry;          // DLL entry point
    HINSTANCE           hISDMdll;
    DWORD               hIsdmSession;       // ISDM Session's handle
    } ISDM2, *PISDM2;
#endif // #ifdef ENABLE_ISDM2


//////////////////////////////////////////////////////////////////////
//
// RTPQOSNotify
//
//////////////////////////////////////////////////////////////////////

#define QOS_BUFFER_SIZE (sizeof(QOS) + \
                         sizeof(RSVP_STATUS_INFO) + \
                         sizeof(RSVP_RESERVE_INFO) + \
                         sizeof(RSVP_ADSPEC))

#define QOS_MAX_BUFFER_SIZE 32000

#define QOS_BFR_LIST_HEAP_SIZE (sizeof(RTP_QOSNOTIFY)*4)

#define fg_set(flag, b) (flag |=  (1 << (b)))
#define fg_rst(flag, b) (flag &= ~(1 << (b)))
#define fg_tst(flag, b) (flag &   (1 << (b)))
#define fg_par(b)       (1 << (b))

typedef struct _RTP_QOSNOTIFY {
    LINK_LIST        RTPQOSBufferLink;      // Next/prev                    
    
    SOCKET           m_Socket;

    void            *m_pvCRtpSession[2];  // 0 for receiver; 1 for sender
    DWORD            m_dwQOSEventMask[2]; // 0 for receiver; 1 for sender
    // thread ID who created 
    DWORD            m_dwThreadID[2];     // 0 for receiver; 1 for sender
    // thread ID who last start/stop
    DWORD            m_dwThreadID2[2];    // 0 for receiver; 1 for sender

    long             m_lStarted;
    long             m_lPending;
    
    DWORD            m_dwBytesReturned;

    PCRTPSESSION_QOS_NOTIFY_FUNCTION m_pCRtpSessionQOSNotify;

    WSAOVERLAPPED    m_Overlapped;

    DWORD            dwBufferLen;
    char            *pBuffer;
} RTP_QOSNOTIFY, *PRTP_QOSNOTIFY;


// restore structure packing
#include <poppack.h> 

#endif // __RRCMDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\rrcmprot.h ===
/*
 * Filename: RRCMPROT.H
 *
 * Functions prototyping.
 *
 * $Workfile:   rrcmprot.h  $
 * $Author:   CMACIOCC  $
 * $Date:   10 Mar 1997 17:13:26  $
 * $Revision:   1.8  $
 * $Archive:   R:\rtp\src\rrcm\rrcminc\rrcmprot.h_v  $
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/

#ifndef _RRCMPROT_H_
#define _RRCMPROT_H_

#include "rrcm.h"
#include "rrcm_rtp.h"

#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)


/*
    RRCMqueu.CPP
*/                   
extern DWORD allocateLinkedList (PLINK_LIST, 
                                 HANDLE, 
                                 PDWORD,
                                 DWORD,
                                 CRITICAL_SECTION *);
extern void addToHeadOfList (PLINK_LIST, 
                             PLINK_LIST,
                             CRITICAL_SECTION *);
extern void addToTailOfList (PLINK_LIST, 
                             PLINK_LIST,
                             CRITICAL_SECTION *);
extern PLINK_LIST removePcktFromTail (PLINK_LIST,
                                      CRITICAL_SECTION *);
extern PLINK_LIST removePcktFromHead (PLINK_LIST,
                                      CRITICAL_SECTION *);

extern PLINK_LIST removePcktFromQueue(PLINK_LIST pQueue,
                                      PLINK_LIST pRemoveQ,
                                      CRITICAL_SECTION *pCritSect);
extern PLINK_LIST movePcktFromQueue(PLINK_LIST pToQueue,
                                    PLINK_LIST pFromQueue,
                                    PLINK_LIST pRemoveQ,
                                    CRITICAL_SECTION *pCritSect);
/*
    RTCPINIT.CPP
*/
extern DWORD initRTCP(void);
extern DWORD deleteRTCP(void);

/*
    RTCPSESS.CPP
*/                   
extern DWORD allocateRTCPContextHeaps (PRTCP_CONTEXT);
extern DWORD allocateRTCPSessionHeaps (PRTCP_SESSION *);
extern DWORD allocateRTCPsessionResources (PRTCP_SESSION *, 
                                           PSSRC_ENTRY *);
extern HRESULT CreateRTCPSession (void *pvRTCPSession,
                                  SOCKET *pSocket, 
                                  LPVOID lpTo, 
                                  DWORD toLen,
                                  PSDES_DATA pSdesInfo,
                                  DWORD dwStreamClock,
                                  PENCRYPT_INFO pEncryptInfo,
                                  DWORD ssrc, 
                                  PRRCM_EVENT_CALLBACK pRRCMcallback,
                                  void *pvCallbackInfo,
                                  DWORD miscInfo, 
                                  DWORD dwRtpSessionBw);

extern DWORD ShutdownRTCPSession(PRTCP_SESSION pRTCPSession);

// ZCS -- new version
extern DWORD deleteRTCPSession(SOCKET RTCPsd, 
                               PRTCP_SESSION    pRTCP,
                               DWORD closeRTCPSocket);
extern DWORD buildSDESinfo (PSSRC_ENTRY, 
                            PSDES_DATA);
//extern DWORD frequencyToPckt (DWORD);
extern DWORD CreateRTCPthread (void);
extern void terminateRtcpThread (void);
extern DWORD RTCPflushIO (PSSRC_ENTRY);
extern DWORD flushIO (PSSRC_ENTRY);
extern void CALLBACK RTCPflushCallback (DWORD,
                                        DWORD,
                                        LPWSAOVERLAPPED,
                                        DWORD);


/*
    RTCPSSRC.CPP
*/
extern PSSRC_ENTRY getOneSSRCentry (PLINK_LIST, 
                                    HANDLE, 
                                    PDWORD,
                                    CRITICAL_SECTION *);
extern DWORD getSSRC (LINK_LIST, 
                      LINK_LIST);
extern DWORD isSSRCunique (PSSRC_ENTRY, 
                           PDWORD);
extern PSSRC_ENTRY createSSRCEntry (DWORD SSRCnum, 
                                    PRTCP_SESSION pRTCP,
                                    PSOCKADDR fromAddr, 
                                    DWORD fromLen,
                                    int   rtp_rtcp,
                                    DWORD headOfList);
extern DWORD RRCMChkCollisionTable (PRTP_BFR_LIST,
                                    PSSRC_ENTRY);
extern DWORD RRCMAddEntryToCollisionTable (PRTP_BFR_LIST, 
                                           PSSRC_ENTRY);
extern void RRCMTimeOutCollisionTable (PRTCP_SESSION);
extern DWORD deleteSSRCEntry (DWORD, 
                              PRTCP_SESSION);
extern void  deleteSSRClist (PRTCP_SESSION, 
                             PLINK_LIST,
                             PRTCP_CONTEXT);
void clearSSRCEntry (PSSRC_ENTRY);

/*
    RTCPMEM.CPP
*/
extern DWORD allocateRTCPBfrList (PLINK_LIST, 
                                  HANDLE, 
                                  HANDLE, 
                                  PDWORD, 
                                  DWORD,
                                  CRITICAL_SECTION *); 


/*
    RTCPTIME.CPP
*/
extern DWORD RTCPxmitInterval (DWORD, 
                               DWORD, 
                               DWORD, 
                               DWORD, 
                               DWORD, 
                               int *, 
                               DWORD);


/* 
    RTCPRECV.CPP
*/
extern DWORD RTCPrcvInit (PSSRC_ENTRY);
extern void CALLBACK RTCPrcvCallback (DWORD, 
                                      DWORD,
                                      LPWSAOVERLAPPED, 
                                      DWORD);
extern DWORD parseRTCPsr (SOCKET, 
                          RTCP_T *, 
                          PRTCP_SESSION, 
                          PRTCP_BFR_LIST);
extern DWORD parseRTCPrr (SOCKET, 
                          RTCP_RR_T *, 
                          PRTCP_SESSION, 
                          PRTCP_BFR_LIST,
                          DWORD);
extern PCHAR parseRTCPsdes (SOCKET, 
                            PCHAR, 
                            PRTCP_SESSION, 
                            PRTCP_BFR_LIST);
extern DWORD parseRTCPbye (SOCKET, 
                           DWORD, 
                           PRTCP_SESSION,
                           PRTCP_BFR_LIST);
extern DWORD ownLoopback (SOCKET, 
                          DWORD, 
                          PRTCP_SESSION);
extern DWORD updateRRfeedback (SOCKET, 
                               DWORD, 
                               DWORD,
                               RTCP_RR_T *,
                               PSSRC_ENTRY);
extern DWORD RTCPpostRecvBfr (PSSRC_ENTRY,
                             PRTCP_BFR_LIST);
extern DWORD clearFeedbackStatus (PRTCP_SESSION,
                                  DWORD);



/* 
    RTCPSEND.CPP
*/
extern void CALLBACK RTCPxmtCallback (DWORD, 
                                      DWORD,
                                      LPWSAOVERLAPPED, 
                                      DWORD);
extern PRTCP_BFR_LIST FormatRTCPReport (PRTCP_SESSION, 
                                        PSSRC_ENTRY, 
                                        DWORD);
extern DWORD getSSRCpcktLoss (PSSRC_ENTRY, 
                              DWORD);
extern DWORD *RTCPbuildSDES (RTCP_COMMON_T *, 
                             PSSRC_ENTRY, 
                             SOCKET, 
                             char *, 
                             PSDES_DATA);
extern DWORD RTCPcheckSDEStoXmit (PSSRC_ENTRY, 
                                  PSDES_DATA,
                                  DWORD dwSdesMask);
extern void RTCPbuildSenderRpt (PSSRC_ENTRY, 
                                RTCP_COMMON_T *, 
                                SENDER_RPT  **,
                                SOCKET);
extern  DWORD usec2ntp (DWORD);
extern  DWORD usec2ntpFrac (long);
extern void RTCPbuildReceiverRpt (PSSRC_ENTRY, 
                                  RTCP_RR_T *,
                                  SOCKET);
extern void RTCPsendBYE (PSSRC_ENTRY, 
                         PCHAR);
extern DWORD getDLSR (PSSRC_ENTRY);

#ifdef DYNAMIC_RTCP_BW
extern DWORD updateRtpXmtBW (PSSRC_ENTRY);
extern DWORD updateRtpRcvBW (PSSRC_ENTRY);
#endif


/*
    RTPINIT.CPP
*/                   
#if defined(RRCMLIB)
extern DWORD deleteRTP ();
extern DWORD initRTP ();
#else
extern DWORD deleteRTP (HINSTANCE);
extern DWORD initRTP (HINSTANCE);
#endif
extern void addBuf (void);
extern void RRCMreadRegistry (PRTP_CONTEXT);
extern void RRCMgetRegistryValue (HKEY, 
                                  LPTSTR, 
                                  PDWORD,
                                  DWORD,
                                  DWORD);
extern DWORD RRCMgetDynamicLink (void);
extern DWORD deleteRTPSession(PRTP_CONTEXT, 
                              PRTP_SESSION);


/*
    RTPSEND.CPP
*/                   
extern void CALLBACK RTPTransmitCallback (DWORD, 
                                          DWORD, 
                                          LPWSAOVERLAPPED, 
                                          DWORD);
extern DWORD CALLBACK  saveWinsockContext(LPWSAOVERLAPPED,
                                          LPWSAOVERLAPPED_COMPLETION_ROUTINE,
                                          PRTP_SESSION);

extern RTP_BFR_LIST *getNewRTPBfrList(RTP_SESSION *pSession);

#if 0
extern void updateNtpRtpTimeStampOffset (RTP_HDR_T *,
                                         PSSRC_ENTRY);
#endif



/*
    RTPRECV.CPP
*/                 
extern void CALLBACK RTPReceiveCallback (DWORD, 
                                         DWORD, 
                                         LPWSAOVERLAPPED, 
                                         DWORD);
//extern DWORD CALLBACK  saveRCVWinsockContext(LPWSAOVERLAPPED,
//                                            LPWSABUF,
//                                            LPWSAOVERLAPPED_COMPLETION_ROUTINE,
//                                            PRTP_SESSION,
//                                            DWORD,
//                                            LPDWORD, 
//                                            LPDWORD,
//                                            LPVOID,
//                                            LPINT,
//                                            SOCKET);
extern BOOL validateRTPHeader(RTP_HDR_T *);                    
extern void RTPpostRecvBfr (DWORD,
                            DWORD,
                            LPWSAOVERLAPPED,
                            DWORD);


/*
    RTP_STAT.CPP
*/
extern DWORD calculateJitter (RTP_HDR_T *, 
                              PSSRC_ENTRY);
extern DWORD updateRTPStats (RTP_HDR_T *, 
                             PSSRC_ENTRY, 
                             DWORD);

/*
    RTPMISC.CPP
*/
extern DWORD saveNetworkAddress (PSSRC_ENTRY pSSRC, 
                                 PSOCKADDR pNetAddr,
                                 int addrLen,
                                 int rtp_rtcp);
extern PSSRC_ENTRY searchforSSRCatHead(PSSRC_ENTRY pSSRC,
                                       DWORD ssrc,
                                       PCRITICAL_SECTION pCritSect);
extern PSSRC_ENTRY searchforSSRCatTail(PSSRC_ENTRY pSSRC,
                                       DWORD ssrc,
                                       PCRITICAL_SECTION pCritSect);
extern PSSRC_ENTRY searchForMySSRC(PSSRC_ENTRY pSSRC,
                                   SOCKET RTCPsocket);

#ifdef ENABLE_ISDM2
extern void registerSessionToISDM (PSSRC_ENTRY, 
                                   PRTCP_SESSION, 
                                   PISDM2);
extern void updateISDMstat (PSSRC_ENTRY, 
                            PISDM2, 
                            DWORD,
                            BOOL);
#endif
extern void RRCMdebugMsg (PCHAR, 
                          DWORD, 
                          PCHAR, 
                          DWORD,
                          DWORD);
extern void RRCMnotification (DXMRTP_EVENT_T,
                              PSSRC_ENTRY,
                              DWORD,
                              DWORD);


/*
    RTP_HASH.CPP
*/                   
extern DWORD createHashEntry (PRTP_SESSION pSession);

extern DWORD deleteHashEntry (PRTP_SESSION pSession);

extern PRTP_SESSION findSessionID(SOCKET *pSocket,
                                  PCRITICAL_SECTION pCritSect);

extern PRTP_SESSION findSessionID2(SOCKET *pSocket,
                                   PCRITICAL_SECTION pCritSect);

/*
    RRCMCRT.CPP
*/                   
extern void RRCMsrand (unsigned int);
extern int  RRCMrand (void);
extern char *RRCMitoa (int, char *, int);
extern char *RRCMultoa (unsigned long, char *, int);
extern char *RRCMltoa (long, char *, int);

/*
    RTCPTHRD.CPP
*/                   
extern void RTCPThread (PRTCP_CONTEXT);
#if 0
extern PSSRC_ENTRY SSRCTimeoutCheck (PRTCP_SESSION, 
                                     DWORD);
#endif

#if defined(__cplusplus)
}
#endif  // (__cplusplus)


#endif /* ifndef _RRCMPROT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\rrcm_dll.h ===
/*
 * Filename: RRCM_DLL.H
 *
 * Description: Declares imported/exported RRCM functions.
 *
 * $Workfile:   rrcm_dll.h  $
 * $Author:   CMACIOCC  $
 * $Date:   20 May 1997 11:40:04  $
 * $Revision:   1.23  $
 * $Archive:   R:\rtp\src\include\rrcm_dll.h_v  $
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 * 
 */

#ifndef _RRCMDLL_H_
#define _RRCMDLL_H_

// force 8 byte structure packing
#include <pshpack8.h>   

#if !defined(RRCMLIB)
#  if !defined(RRCMDLL)
#    define RRCMAPI __declspec (dllimport)
#  else
#    define RRCMAPI __declspec (dllexport)
#  endif
#  define RRCMSTDAPI RRCMAPI HRESULT __cdecl
#else
#  define RRCMSTDAPI HRESULT
#endif

#define RRCMTHREAD DWORD WINAPI

#ifdef __cplusplus
extern "C" {
#endif


#include <rtp.h>
    
#define MAX_ENCRYPT_KEY_SIZE    8

#define RTCP_SDES_FIRST RTCP_SDES_END
    
#define SDES_INDEX(__sdes) (__sdes-1)
#define RRCM_BIT(x) (1<<(x))

#define MAX_SDES_LEN RTP_MAX_SDES
    
// RRCM events callback
typedef void (CALLBACK *PRRCM_EVENT_CALLBACK) (DXMRTP_EVENT_T sEventType,
                                               DWORD          dwP_1,
                                               DWORD          dwP_2,
                                               void          *pvUserInfo);

// RRCM SSRC entry update
typedef enum 
    {
    RRCM_UPDATE_SDES,
    RRCM_UPDATE_CALLBACK,
    RRCM_UPDATE_STREAM_FREQUENCY,
    RRCM_UPDATE_RTCP_STREAM_MIN_BW
    } RRCM_UPDATE_SSRC_ENTRY;


// RTP/RTCP session bits mask
#define RTCP_DEST_LEARNED       0x00000001  // RTCP destination address known ?
#define H323_CONFERENCE         0x00000002  // H.323 conference control
#define ENCRYPT_SR_RR           0x00000004  // Encrypt SR/RR
#define RTCP_ON                 0x00000008
#define NEW_RTCP_SESSION        0x00000010
#define RTCP_OFF                0x00000020
#define SHUTDOWN_IN_PROGRESS    0x80000000  // Shutdown in progress

// RTCP control
#define RRCM_CTRL_RTCP          0x00000000
#define RTCP_XMT_OFF            0x7FFFFFFF
#define RTCP_ONE_SEND_ONLY      0x80000000

// Encryption data
typedef struct _encryption_info
    {
    DWORD               dwEncryptType;          // DES/Triple DES/...
    DWORD               dwKeyLen;                   // Encryption key length
    char                keyVal[MAX_ENCRYPT_KEY_SIZE];
    } ENCRYPT_INFO, *PENCRYPT_INFO;


//  Received sequence numbers/cycles.  Union allows access as combined 
//  cycle/sequence number or as either field alone for optimizations
typedef struct _RTP_SEQUENCE 
    {
    WORD    wSequenceNum;
    WORD    wCycle;
    } RTP_SEQUENCE, *PRTP_SEQUENCE;


typedef struct _RTP_SEQ_NUM 
    {
    union
        {
        DWORD       dwXtndedHighSeqNumRcvd; // Combined cycle/sequence number 
        RTP_SEQUENCE RTPSequence;           // Cycle/sequence number separate 
        } seq_union;
    } RTP_SEQ_NUM, *PRTP_SEQ_NUM;


//  Link list elements
typedef struct _LINK_LIST 
    {
    struct _LINK_LIST   *next;              // Next in list / Head of list
    struct _LINK_LIST   *prev;              // Previous in list / Tail of list
    } LINK_LIST, *PLINK_LIST, HEAD_TAIL, *PHEAD_TAIL;


//  Application provided buffer for RTCP to copy the raw RTCP report into
typedef struct _APP_RTCP_BFR
    {
    LINK_LIST           bfrList;            // Next/prev buffer in list     
    char                *bfr;
    DWORD               dwBfrLen;
    DWORD               dwBfrStatus;        // RTCP Operation on this Bfr
#define RTCP_SR_ONLY    0x00000001          // Only copy RTCP packet
    DWORD               dwBytesRcvd;
    HANDLE              hBfrEvent;
    } APP_RTCP_BFR, *PAPP_RTCP_BFR;


// RTCP sender's feedback data structure
typedef struct _RTCP_FEEDBACK 
    {
    DWORD       SSRC;
    DWORD       fractionLost:8;             // Fraction lost                
    int         cumNumPcktLost:24;          // Cumulative num of pckts lost 
    RTP_SEQ_NUM XtendedSeqNum;              // Xtnded highest seq. num rcvd 
    DWORD       dwInterJitter;              // Interarrival jitter          
    DWORD       dwLastSR;                   // Last sender report           
    DWORD       dwDelaySinceLastSR;         // Delay since last SR          
    DWORD       dwLastRcvRpt;               // Time of last Receive Report
    } RTCP_FEEDBACK, *PRTCP_FEEDBACK;


//  RTCPReportRequestEx bitmasks used to specify filter values
typedef enum 
    {
    FLTR_SSRC   = 1,        // Filters report on SSRC value
    FLTR_CNAME,             // Filters report on CName
    FLTR_TIME_WITHIN        // Filters report receive within a time period
    } RRCM_RPT_FILTER_OPTION;


//  RTCP report data structure
typedef struct _RTCP_REPORT
    {
    // SSRC for this entry's information. Local SSRC if it's one of
    // are local stream, or a remote SSRC otherwise.
    DWORD               ssrc;               

    DWORD               status;
#define LOCAL_SSRC_RPT                      0x1
#define REMOTE_SSRC_RPT                     0x2
#define FEEDBACK_FOR_LOCAL_SSRC_PRESENT     0x4
    // LOCAL_SSRC_RPT identifies to the application that this entry is
    // one of our local stream. 
    // Only 'dwSrcNumPcktRealTime & dwSrcNumByteRealTime' which
    // reflect the number of Pckt/byte transmitted are meaningful.

    // FEEDBACK_FOR_LOCAL_SSRC_PRESENT is set if the entry is for a 
    // remote stream and if this remote stream has ever send us any 
    // feedback about ourselve. Feedback send by the remote stream to 
    // other SSRC are filtered out. Only feedback about ourselve is kept.

    // Number of Pckt/Byte send if this entry is for a local stream, or 
    // number of Pckt/Byte received if this entry is for a remote stream
    // This counters are updated in real-time.
    DWORD               dwSrcNumPcktRealTime;
    DWORD               dwSrcNumByteRealTime;

    // This is the information we would be sending in a receiver report
    // for the stream identified by 'ssrc' if this 'ssrc' has been active
    // during the last report interval. This information is provided when the
    // API is queried, and will most likely be different than the one send
    // out by the receiver report. (RR will be send at some different time)
    DWORD               SrcFraction:8;
    int                 SrcNumLost:24;
    DWORD               dwSrcXtndNum;
    DWORD               SrcJitter;
    // The next variable is not used and should be removed.
    // DLSR is used to estimate RTT by the sender and is send by
    // the receiver in the RR
    DWORD               dwSrcDlsr;      // Always set to 0

    // This information has been received from 'ssrc' has part of an 
    // RTCP sender report if 'ssrc' has been active, otherwise all 0s
    DWORD               dwSrcNumPckt;
    DWORD               dwSrcNumByte;
    DWORD               dwSrcNtpMsw;
    DWORD               dwSrcNtpLsw;
    DWORD               dwSrcRtpTs;
    DWORD               dwSrcLsr;       

    // This is the feedback information about us from the SSRC identified
    // in the 'feedback' data structure. Currently we only store feedback 
    // information about ourselve and we filter out feedback information
    // about additional streams. We'll have feedback information only if 
    // our stream has been active. If our stream goes from active to inactive
    // the feedback information will be set, but not updated.
    RTCP_FEEDBACK       feedback;           

    // Generic information for the SSRC entry 
    // Payload type for this SSRC. If a sender, it is assume that the 
    // application knows what it is sending, and the type will be set
    // to 0. If a receiver, this is the last value seen on an RTP data packet
    DWORD               PayLoadType;        
    DWORD               dwStreamClock;          // Sampling frequency
    DWORD               dwLastReportRcvdTime;   // Time of last report rcvd
    char                fromAddr[MAX_ADDR_LEN]; 
    DWORD               dwFromLen;          
    CHAR                cname[MAX_SDES_LEN];
    DWORD               dwCnameLen;
    CHAR                name[MAX_SDES_LEN];
    DWORD               dwNameLen;
    } RTCP_REPORT, *PRTCP_REPORT;



//----------------------------------------------------------------------------
//  ISDM Information
//----------------------------------------------------------------------------

#ifdef ENABLE_ISDM2

// RTCP Xmt information
typedef struct _XMIT_INFO_ISDM 
    {
    DWORD       dwNumPcktSent;              // Number of packet sent        
    DWORD       dwNumBytesSent;             // Number of bytes sent         
    DWORD       dwNTPmsw;                   // NTP most significant word    
    DWORD       dwNTPlsw;                   // NTP least significant word   
    DWORD       dwRTPts;                    // RTP timestamp                
    DWORD       dwCurXmtSeqNum;             // Current Xmt sequence number  
    DWORD       dwPrvXmtSeqNum;             // Previous Xmt sequence number 
    DWORD       sessionBW;                  // Session's bandwidth          
    DWORD       dwLastSR;                   // Last sender report           
    DWORD       dwLastSRLocalTime;          // Last sender report local time
    DWORD       dwLastSendRTPSystemTime;    // Last RTP packet send time
    DWORD       dwLastSendRTPTimeStamp;     // RTP timestamp of the last packet
    } XMIT_INFO_ISDM, *PXMIT_INFO_ISDM;



// RTCP receive information
typedef struct _RECV_INFO_ISDM
    {
    DWORD       dwNumPcktRcvd;              // Number of packet received    
    DWORD       dwPrvNumPcktRcvd;           // Previous number of pckt rcvd 
    DWORD       dwExpectedPrior;            // Number previously expected   
    DWORD       dwNumBytesRcvd;             // Number of bytes rcvd         
    DWORD       dwBaseRcvSeqNum;            // Initial sequence number rcvd 
    DWORD       dwBadSeqNum;                // Potential new valid seq num  
    DWORD       dwProbation;                // # consec pkts for validation 
    RTP_SEQ_NUM XtendedSeqNum;              // Xtnded highest seq. num rcvd 
    DWORD       dwPropagationTime;          // Last packet's transmit time  
    DWORD       interJitter;                // Interarrival jitter          
    } RECV_INFO_ISDM, *PRECV_INFO_ISDM;


//----------------------------------------------------------------------------
// RTP/RTCP: Registry information under:
//----------------------------------------------------------------------------
#define szRRCMISDM          TEXT("RRCM_2")


// Structure used by new ISDM features

typedef struct _ISDM2_ENTRY 
    {
    DWORD       SSRC;               // Source SSRC          
    DWORD       dwSSRCStatus;       // Entry status
    #define XMITR   0x00000001
    #define RECVR   0x00000002

    DWORD       PayLoadType;        // Payload type for this SSRC
                                    // taken from the RTP header.

    // SSRC Transmit information  
    // If on our transmit list, this is our SSRC information, and if on our 
    // receive list, this is a SR feedback information.
    XMIT_INFO_ISDM  xmitinfo;

    // SSRC Receive information 
    // If on our transmit list, this is undefined information, and if on our 
    // receive list, this is the SSRC's receive information, ie, this SSRC 
    // is an active sender somewhere on the network. This information is 
    // maintained by RTP, and used by RTCP to generate RR.
    RECV_INFO_ISDM  rcvInfo;

    // Feedback information received about ourselve if we're an active source
    RTCP_FEEDBACK   rrFeedback;             // Feedback information

    DWORD       dwLastReportRcvdTime;   // Time of last report received

    // SSRC SDES information 
    SDES_DATA   cnameInfo;      // CNAME information
    SDES_DATA   nameInfo;       // NAME information

    // SSRC network address information 
    int     fromLen;            // From address length
    char    from[MAX_ADDR_LEN]; // From address
        
    DWORD       dwNumRptSent;       // Number of RTCP report sent   
    DWORD       dwNumRptRcvd;       // Number of RTCP report rcvd   
    DWORD       dwNumXmtIoPending;  // Number of transmit I/O pending
    DWORD       dwStreamClock;      // Sampling frequency

    } ISDM2_ENTRY, *PISDM2_ENTRY;

#endif // #ifdef ENABLE_ISDM2

//----------------------------------------------------------------------------
//  RTP/RTCP Error Codes
//----------------------------------------------------------------------------
#define RRCM_NoError                    NO_ERROR
#define RTP_ERROR_BASE                  0x8100
#define RTCP_ERROR_BASE                 0x8200

// Macro to create a custom HRESULT
// S: Severity Code
// C: Customer subsystem (TRUE)
// F: Facility code
// E: Error code
#define MAKE_RRCM_HRESULT(S,C,F,E)  \
((((DWORD)(S)<<31)|((DWORD)(C)<<29)|((DWORD)(F)<<16)|((DWORD)(E))))

// Custom facility codes
#define FACILITY_BASE              0x080
#define FACILITY_RRCM              (FACILITY_BASE+9)

// Sample macro to support custom error reporting //
#define MAKE_RRCM_ERROR(error)  \
MAKE_RRCM_HRESULT(SEVERITY_ERROR,TRUE,FACILITY_RRCM,error)

// RTP Error Codes
#define RRCMError_RTPReInit                 RTP_ERROR_BASE
#define RRCMError_RTPResources              (RTP_ERROR_BASE+1)
#define RRCMError_RTPInvalidDelete          (RTP_ERROR_BASE+2)
#define RRCMError_RTPNoContext              (RTP_ERROR_BASE+3)
#define RRCMError_RTPSessResources          (RTP_ERROR_BASE+4)
#define RRCMError_RTPInvalid                (RTP_ERROR_BASE+5)
#define RRCMError_RTPInvSocket              (RTP_ERROR_BASE+6)
#define RRCMError_RTPSSRCNotFound           (RTP_ERROR_BASE+7)
#define RRCMError_RTCPCreateError           (RTP_ERROR_BASE+8)
#define RRCMError_RTPInvalidSession         (RTP_ERROR_BASE+9)
#define RRCMError_RTPStreamNotFound         (RTP_ERROR_BASE+10)
#define RRCMError_WinsockLibNotFound        (RTP_ERROR_BASE+11)
#define RRCMError_RTPNoSession              (RTP_ERROR_BASE+12)
#define RRCMError_InvalidPointer            (RTP_ERROR_BASE+13)


// RTCP Error Codes
#define RRCMError_RTCPReInit                RTCP_ERROR_BASE
#define RRCMError_RTCPResources             (RTCP_ERROR_BASE+1)
#define RRCMError_RTCPInvalidDelete         (RTCP_ERROR_BASE+2)
#define RRCMError_RTCPNoContext             (RTCP_ERROR_BASE+3) 
#define RRCMError_RTCPInvalidRequest        (RTCP_ERROR_BASE+4)
#define RRCMError_RTCPheapError             (RTCP_ERROR_BASE+5)
#define RRCMError_RTCPThreadCreation        (RTCP_ERROR_BASE+6)
#define RRCMError_RTCPInvalidSession        (RTCP_ERROR_BASE+7)
#define RRCMError_RTCPNotimer               (RTCP_ERROR_BASE+8)
#define RRCMError_RTCPMaxStreamPerSession   (RTCP_ERROR_BASE+9)
#define RRCMError_RTCPInvalidSSRCentry      (RTCP_ERROR_BASE+10)
#define RRCMError_RTCPNoXmtList             (RTCP_ERROR_BASE+11)
#define RRCMError_RTCPNoCname               (RTCP_ERROR_BASE+12)
#define RRCMError_RTCPInvalidArg            (RTCP_ERROR_BASE+13)
#define RRCMError_RTCPNotImpl               (RTCP_ERROR_BASE+14)


// New SSRC detected
#define RRCM_NEW_SOURCE_EVENT DXMRTP_NEW_SOURCE_EVENT

// RTCP RR received
#define RRCM_RECV_RTCP_RECV_REPORT_EVENT DXMRTP_RECV_RTCP_RECV_REPORT_EVENT

// RTCP SR received     
#define RRCM_RECV_RTCP_SNDR_REPORT_EVENT DXMRTP_RECV_RTCP_SNDR_REPORT_EVENT

// Collision detected with our own SSRC
#define RRCM_LOCAL_COLLISION_EVENT DXMRTP_LOCAL_COLLISION_EVENT

// Remote collision detected        
#define RRCM_REMOTE_COLLISION_EVENT DXMRTP_REMOTE_COLLISION_EVENT

// SSRC timed-out       
#define RRCM_TIMEOUT_EVENT DXMRTP_TIMEOUT_EVENT

// SSRC has been silent (probably a temporary network failure)
#define RRCM_INACTIVE_EVENT DXMRTP_INACTIVE_EVENT

// SSRC has been heard again
#define RRCM_ACTIVE_EVENT DXMRTP_ACTIVE_AGAIN_EVENT

// RTCP Bye received
#define RRCM_BYE_EVENT DXMRTP_BYE_EVENT

// Winsock error on RTCP rcv
#define RRCM_RTCP_WS_RCV_ERROR DXMRTP_RTCP_WS_RCV_ERROR

// Winsock error on RTCP xmt        
#define RRCM_RTCP_WS_XMT_ERROR DXMRTP_RTCP_WS_XMT_ERROR

// Loss rate reported for our sender (RR)
#define RRCM_LOSS_RATE_RR_EVENT DXMRTP_LOSS_RATE_RR_EVENT

// Loss rate localy detected
#define RRCM_LOSS_RATE_LOCAL_EVENT DXMRTP_LOSS_RATE_LOCAL_EVENT
    
#define RRCM_NO_EVENT   DXMRTP_NO_EVENT
#define RRCM_LAST_EVENT DXMRTP_LAST_EVENT
    
// RRCM Exported API
RRCMSTDAPI
CreateRTPSession (
        void **ppvRTPSession,
        SOCKET *pSocket,
        LPVOID pRTCPTo, 
        DWORD toRTCPLen,
        PSDES_DATA pSdesInfo,
        DWORD dwStreamClock,
        PENCRYPT_INFO pEncryptInfo,
        DWORD ssrc,
        PRRCM_EVENT_CALLBACK pRRCMcallback,
        void *pvCallbackInfo,
        DWORD miscInfo,
        DWORD dwRtpSessionBw,
        DWORD dwKind,
        long  *MaxShare);

RRCMSTDAPI
CloseRTPSession(
        void *pvRTPSession, 
        DWORD closeRTCPSocket,
        DWORD dwKind);

RRCMSTDAPI
ShutdownRTPSession(void *pvRTPSession,
                   PCHAR byeReason,
                   DWORD dwKind);

RRCMSTDAPI
RTPSendTo(SOCKET *pSocket,
          LPWSABUF pBufs,
          DWORD  dwBufCount,
          LPDWORD pNumBytesSent, 
          int socketFlags,
          LPVOID pTo,
          int toLen,
          LPWSAOVERLAPPED pOverlapped, 
          LPWSAOVERLAPPED_COMPLETION_ROUTINE pCompletionRoutine);

RRCMSTDAPI
RTPRecvFrom(SOCKET *pSocket,
            LPWSABUF pBuffers,
            DWORD  dwBufferCount,
            LPDWORD pNumBytesRecvd, 
            LPDWORD pFlags,
            PSOCKADDR pFrom,
            LPINT pFromlen,
            LPWSAOVERLAPPED pOverlapped, 
            LPWSAOVERLAPPED_COMPLETION_ROUTINE pCompletionRoutine);

RRCMSTDAPI
RTCPReportRequest (
    SOCKET, 
    DWORD, 
    PDWORD,
    PDWORD, 
    DWORD, 
    PRTCP_REPORT,
    DWORD,
    LPVOID,
    DWORD);

#if 0
RRCMSTDAPI
updateRTCPDestinationAddress (
    SOCKET,
    PSOCKADDR,
    int);
#endif
    
RRCMSTDAPI 
getAnSSRC (void);

RRCMTHREAD
RTCPThreadCtrl (DWORD);

RRCMSTDAPI 
RTCPSendSessionCtrl (void *pvRTPSession, DWORD dwTimeOut);

RRCMSTDAPI
updateSSRCentry (
    SOCKET,
    DWORD,
    DWORD,
    DWORD);

RRCMSTDAPI 
addApplicationRtcpBfr (
    DWORD, 
    PAPP_RTCP_BFR);

#if defined(_0_)
RRCMAPI PAPP_RTCP_BFR __cdecl 
removeApplicationRtcpBfr (DWORD);
#endif
RRCMSTDAPI
getRtcpSessionList (void *pvSockBfr, 
                    DWORD dwNumEntries,
                    PDWORD pNumUpdated);

RRCMSTDAPI
getSSRCinSession(void  *pvRTCPSession,
                 PDWORD pdwSSRC,
                 PDWORD pdwNum);

RRCMSTDAPI
getSSRCSDESItem(void  *pvRTCPSession,
                DWORD  dwSSRC,
                DWORD  dwSDESItem,
                PCHAR  psSDESData,
                PDWORD dwLen);

RRCMSTDAPI
getSSRCSDESAll(void      *pvRTCPSession,
               DWORD      dwSSRC,
               PSDES_DATA pSdes,
               DWORD      dwNum);

RRCMSTDAPI
getSSRCAddress(void  *pvRTCPSession,
               DWORD  dwSSRC,
               LPBYTE pbAddr,
               int    *piAddrLen,
               int    rtp_rtcp /* 0=RTP, 1=RTCP*/);

RRCMSTDAPI
updateSDESinfo(void  *pvRTCPSession,
               DWORD  dwSDESItem,
               LPBYTE psSDESData,
               DWORD  dwSDESLen);

// QOS notifications: callback function, start/stop functions
typedef
void (* PCRTPSESSION_QOS_NOTIFY_FUNCTION)(
        DWORD        dwError,
        void        *pvCRtpSession,
        QOS         *pQOS);


RRCMSTDAPI
RTCPStartQOSNotify(SOCKET sock,
                   void  *pvCRtpSession,
                   DWORD  dwRecvSend,     // 0 == receiver; other == sender
                   DWORD  dwQOSEventMask, // QOS event mask
                   PCRTPSESSION_QOS_NOTIFY_FUNCTION  pCRtpSessionQOSNotify
    );

RRCMSTDAPI
RTCPStopQOSNotify(SOCKET sock,
                  void  *pvCRtpSession,
                  DWORD  dwRecvSend   // 0 == receiver; other == sender
    );

RRCMSTDAPI
RTCPSetQOSEventMask(SOCKET sock,
                    void  *pvCRtpSession,
                    DWORD  dwRecvSend,  // 0 == receiver; other == sender
                    DWORD  dwQOSEventMask // new mask
    );
    
#ifdef __cplusplus
}
#endif

// restore structure packing
#include <poppack.h> 

#endif /* #ifndef _RRCMDLL_H_ */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\rrcm_rtp.h ===
/*------------------------------------------------------------------------- 
 * Filename: RTP.H
 *
 * RTP related data structures.
 *
 * $Workfile:   rrcm_rtp.h  $
 * $Author:   CMACIOCC  $
 * $Date:   13 Feb 1997 14:44:08  $
 * $Revision:   1.2  $
 * $Archive:   R:\rtp\src\include\rtp.h_v  $
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *
 * !!! This file was renamed from rtp.h to rrcm_rtp.h due
 *     to the conflicting existence of file filters\inc\rtp.h
 *--------------------------------------------------------------------------*/

#ifndef _RRCM_RTP_H_
#define _RRCM_RTP_H_

#define RTP_HDR_MIN_LEN	12
#define RTP_SEQ_MOD 	(1<<16)
#define RTP_TS_MOD  	(0xffffffff)

#define RTP_TYPE		2		/* Current version */
#define RTP_MAX_SDES	256		/* maximum text length for SDES */

#define RTCP_SIZE_GAIN	(1./16.)
#define NTWRK_HDR_SIZE	28

typedef enum {
	RTCP_SR   = 200,
	RTCP_RR   = 201,
	RTCP_SDES = 202,
	RTCP_BYE  = 203,
	RTCP_APP  = 204
	} RTCP_TYPE_T;

typedef struct {                             
	// !!! WARNING !!!
	// The following word doesn't need to be swapped for NtoH()
	WORD 			cc:4;       /* CSRC count */  
	WORD 			x:1;        /* header extension flag */  
	WORD 			p:1;        /* padding flag */  
	WORD 			type:2;     /* version type 1/2 */
	WORD		 	pt:7;       /* payload type */
	WORD			m:1;        /* marker bit */  

	WORD			seq;		/* sequence number */
	DWORD 			ts;         /* timestamp */
	DWORD 			ssrc;       /* synchronization source */
	DWORD 			csrc[1];    /* optional CSRC list */
	} RTP_HDR_T;

typedef struct {
	// !!! WARNING !!!
	// The following word doesn't need to be swapped for NtoH()
	WORD 			count:5;    /* varies by payload type */  
	WORD 			p:1;        /* padding flag */  
	WORD 			type:2;     /* protocol version */
	WORD		 	pt:8;       /* payload type */

    WORD			length;     /* packet length in words, without this word */
	} RTCP_COMMON_T;

/* reception report */
typedef struct {
	DWORD			ssrc;       /* data source being reported */
	DWORD			received;   /* cumulative number of packets received */
	DWORD			expected;   /* cumulative number of packets expected */
	DWORD			jitter;     /* interarrival jitter */
	DWORD			lsr;        /* last SR packet from this source */
	DWORD			dlsr;       /* delay since last SR packet */
	} RTCP_RR_T;

typedef struct {
	BYTE			dwSdesType;       /* type of SDES item (rtcp_sdes_type_t) */
	BYTE			dwSdesLength;     /* length of SDES item (in octets) */
	char 			sdesData[1];    /* text, not zero-terminated */
	} RTCP_SDES_ITEM_T;

typedef struct {
	DWORD 		ssrc;       /* source this RTCP packet refers to */
	DWORD 		ntp_sec;    /* NTP timestamp */
	DWORD 		ntp_frac;
	DWORD 		rtp_ts;     /* RTP timestamp */
	DWORD 		psent;      /* packets sent */
	DWORD 		osent;      /* octets sent */ 
		
	RTCP_RR_T 	rr[1];		/* variable-length list */
	} SENDER_RPT;

typedef struct {
	DWORD 		ssrc;        /* source this generating this report */
	RTCP_RR_T rr[1];		 /* variable-length list */
	} RECEIVER_RPT;

typedef struct {
	DWORD 		src[1];   	 /* list of sources */
		
	/* can't express trailing text */
	} BYE_PCKT;

typedef struct {
	DWORD 	src;              /* first SSRC/CSRC */
	RTCP_SDES_ITEM_T item[1]; /* list of SDES items */
	} RTCP_SDES_T;

/* one RTCP packet */
typedef struct {
	RTCP_COMMON_T	common;     /* common header */
	
	union 
		{
		SENDER_RPT		sr;		/* sender report (SR) */
		RECEIVER_RPT	rr;		/* reception report (RR) */
		BYE_PCKT		bye;	/* BYE */
		RTCP_SDES_T		sdes;	/* source description (SDES) */
		} r;
	} RTCP_T;


typedef DWORD MEMBER_T;


#endif /* ifndef _RRCM_RTP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\compddk.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *
 *
 *  Compddk.h - include file for implementing installable compressors
 *
 *  Copyright (c) 1990-1995, Microsoft Corp.  All rights reserved.
 *
 **********************************************************************
 *
 * To register FOURCC's for codec types please obtain a
 * copy of the Multimedia Developer Registration Kit from:
 *
 *  Microsoft Corporation
 *  Multimedia Systems Group
 *  Product Marketing
 *  One Microsoft Way
 *  Redmond, WA 98052-6399
 *
 *
*/

#ifndef _INC_COMPDDK
#define _INC_COMPDDK	50	/* version number */

#ifndef RC_INVOKED
#ifndef _WIN32
#pragma pack(1)         /* Assume byte packing throughout */
#endif
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

// begin_vfw32

#define ICVERSION       0x0104

DECLARE_HANDLE(HIC);     /* Handle to a Installable Compressor */

//
// this code in biCompression means the DIB must be accesed via
// 48 bit pointers! using *ONLY* the selector given.
//
#define BI_1632  0x32333631     // '1632'

#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )				\
		( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
		( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

#ifndef aviTWOCC
#define aviTWOCC(ch0, ch1) ((WORD)(BYTE)(ch0) | ((WORD)(BYTE)(ch1) << 8))
#endif

#ifndef ICTYPE_VIDEO
#define ICTYPE_VIDEO    mmioFOURCC('v', 'i', 'd', 'c')
#define ICTYPE_AUDIO    mmioFOURCC('a', 'u', 'd', 'c')
#endif

#ifndef ICERR_OK
#define ICERR_OK                0L
#define ICERR_DONTDRAW          1L
#define ICERR_NEWPALETTE        2L
#define ICERR_GOTOKEYFRAME	3L
#define ICERR_STOPDRAWING 	4L

#define ICERR_UNSUPPORTED      -1L
#define ICERR_BADFORMAT        -2L
#define ICERR_MEMORY           -3L
#define ICERR_INTERNAL         -4L
#define ICERR_BADFLAGS         -5L
#define ICERR_BADPARAM         -6L
#define ICERR_BADSIZE          -7L
#define ICERR_BADHANDLE        -8L
#define ICERR_CANTUPDATE       -9L
#define ICERR_ABORT	       -10L
#define ICERR_ERROR            -100L
#define ICERR_BADBITDEPTH      -200L
#define ICERR_BADIMAGESIZE     -201L

#define ICERR_CUSTOM           -400L    // errors less than ICERR_CUSTOM...
#endif

/* Values for dwFlags of ICOpen() */
#ifndef ICMODE_COMPRESS
#define ICMODE_COMPRESS		1
#define ICMODE_DECOMPRESS	2
#define ICMODE_FASTDECOMPRESS   3
#define ICMODE_QUERY            4
#define ICMODE_FASTCOMPRESS     5
#define ICMODE_DRAW             8
#endif

/* Flags for AVI file index */
#define AVIIF_LIST	0x00000001L
#define AVIIF_TWOCC	0x00000002L
#define AVIIF_KEYFRAME	0x00000010L

/* quality flags */
#define ICQUALITY_LOW       0
#define ICQUALITY_HIGH      10000
#define ICQUALITY_DEFAULT   -1

/************************************************************************
************************************************************************/

#define ICM_USER          (DRV_USER+0x0000)

#define ICM_RESERVED      ICM_RESERVED_LOW
#define ICM_RESERVED_LOW  (DRV_USER+0x1000)
#define ICM_RESERVED_HIGH (DRV_USER+0x2000)

/************************************************************************

    messages.

************************************************************************/

#define ICM_GETSTATE                (ICM_RESERVED+0)    // Get compressor state
#define ICM_SETSTATE                (ICM_RESERVED+1)    // Set compressor state
#define ICM_GETINFO                 (ICM_RESERVED+2)    // Query info about the compressor

#define ICM_CONFIGURE               (ICM_RESERVED+10)   // show the configure dialog
#define ICM_ABOUT                   (ICM_RESERVED+11)   // show the about box

#define ICM_GETDEFAULTQUALITY       (ICM_RESERVED+30)   // get the default value for quality
#define ICM_GETQUALITY              (ICM_RESERVED+31)   // get the current value for quality
#define ICM_SETQUALITY              (ICM_RESERVED+32)   // set the default value for quality

#define ICM_SET			    (ICM_RESERVED+40)	// Tell the driver something
#define ICM_GET			    (ICM_RESERVED+41)	// Ask the driver something

// Constants for ICM_SET:
#define ICM_FRAMERATE       mmioFOURCC('F','r','m','R')
#define ICM_KEYFRAMERATE    mmioFOURCC('K','e','y','R')

/************************************************************************

    ICM specific messages.

************************************************************************/

#define ICM_COMPRESS_GET_FORMAT     (ICM_USER+4)    // get compress format or size
#define ICM_COMPRESS_GET_SIZE       (ICM_USER+5)    // get output size
#define ICM_COMPRESS_QUERY          (ICM_USER+6)    // query support for compress
#define ICM_COMPRESS_BEGIN          (ICM_USER+7)    // begin a series of compress calls.
#define ICM_COMPRESS                (ICM_USER+8)    // compress a frame
#define ICM_COMPRESS_END            (ICM_USER+9)    // end of a series of compress calls.

#define ICM_DECOMPRESS_GET_FORMAT   (ICM_USER+10)   // get decompress format or size
#define ICM_DECOMPRESS_QUERY        (ICM_USER+11)   // query support for dempress
#define ICM_DECOMPRESS_BEGIN        (ICM_USER+12)   // start a series of decompress calls
#define ICM_DECOMPRESS              (ICM_USER+13)   // decompress a frame
#define ICM_DECOMPRESS_END          (ICM_USER+14)   // end a series of decompress calls
#define ICM_DECOMPRESS_SET_PALETTE  (ICM_USER+29)   // fill in the DIB color table
#define ICM_DECOMPRESS_GET_PALETTE  (ICM_USER+30)   // fill in the DIB color table

#define ICM_DRAW_QUERY              (ICM_USER+31)   // query support for dempress
#define ICM_DRAW_BEGIN              (ICM_USER+15)   // start a series of draw calls
#define ICM_DRAW_GET_PALETTE        (ICM_USER+16)   // get the palette needed for drawing
#define ICM_DRAW_START              (ICM_USER+18)   // start decompress clock
#define ICM_DRAW_STOP               (ICM_USER+19)   // stop decompress clock
#define ICM_DRAW_END                (ICM_USER+21)   // end a series of draw calls
#define ICM_DRAW_GETTIME            (ICM_USER+32)   // get value of decompress clock
#define ICM_DRAW                    (ICM_USER+33)   // generalized "render" message
#define ICM_DRAW_WINDOW             (ICM_USER+34)   // drawing window has moved or hidden
#define ICM_DRAW_SETTIME            (ICM_USER+35)   // set correct value for decompress clock
#define ICM_DRAW_REALIZE            (ICM_USER+36)   // realize palette for drawing
#define ICM_DRAW_FLUSH	            (ICM_USER+37)   // clear out buffered frames
#define ICM_DRAW_RENDERBUFFER       (ICM_USER+38)   // draw undrawn things in queue

#define ICM_DRAW_START_PLAY         (ICM_USER+39)   // start of a play
#define ICM_DRAW_STOP_PLAY          (ICM_USER+40)   // end of a play

#define ICM_DRAW_SUGGESTFORMAT      (ICM_USER+50)   // Like ICGetDisplayFormat
#define ICM_DRAW_CHANGEPALETTE      (ICM_USER+51)   // for animating palette

#define ICM_GETBUFFERSWANTED        (ICM_USER+41)   // ask about prebuffering

#define ICM_GETDEFAULTKEYFRAMERATE  (ICM_USER+42)   // get the default value for key frames

#define ICM_DECOMPRESSEX_BEGIN      (ICM_USER+60)   // start a series of decompress calls
#define ICM_DECOMPRESSEX_QUERY      (ICM_USER+61)   // start a series of decompress calls
#define ICM_DECOMPRESSEX            (ICM_USER+62)   // decompress a frame
#define ICM_DECOMPRESSEX_END        (ICM_USER+63)   // end a series of decompress calls

#define ICM_COMPRESS_FRAMES_INFO    (ICM_USER+70)   // tell about compress to come
#define ICM_SET_STATUS_PROC	        (ICM_USER+72)   // set status callback

/************************************************************************
************************************************************************/

typedef struct {
    DWORD               dwSize;         // sizeof(ICOPEN)
    DWORD               fccType;        // 'vidc'
    DWORD               fccHandler;     //
    DWORD               dwVersion;      // version of compman opening you
    DWORD               dwFlags;        // LOWORD is type specific
    LRESULT             dwError;        // error return.
    LPVOID              pV1Reserved;    // Reserved
    LPVOID              pV2Reserved;    // Reserved
    DWORD               dnDevNode;      // Devnode for PnP devices
} ICOPEN;

/************************************************************************
************************************************************************/

typedef struct {
    DWORD   dwSize;                 // sizeof(ICINFO)
    DWORD   fccType;                // compressor type     'vidc' 'audc'
    DWORD   fccHandler;             // compressor sub-type 'rle ' 'jpeg' 'pcm '
    DWORD   dwFlags;                // flags LOWORD is type specific
    DWORD   dwVersion;              // version of the driver
    DWORD   dwVersionICM;           // version of the ICM used
// end_vfw32
#ifdef _WIN32
// begin_vfw32
    //
    // under Win32, the driver always returns UNICODE strings.
    //
    WCHAR   szName[16];             // short name
    WCHAR   szDescription[128];     // long name
    WCHAR   szDriver[128];          // driver that contains compressor
// end_vfw32
#else
    char    szName[16];             // short name
    char    szDescription[128];     // long name
    char    szDriver[128];          // driver that contains compressor
#endif
// begin_vfw32
}   ICINFO;

/* Flags for the <dwFlags> field of the <ICINFO> structure. */
#define VIDCF_QUALITY        0x0001  // supports quality
#define VIDCF_CRUNCH         0x0002  // supports crunching to a frame size
#define VIDCF_TEMPORAL       0x0004  // supports inter-frame compress
#define VIDCF_COMPRESSFRAMES 0x0008  // wants the compress all frames message
#define VIDCF_DRAW           0x0010  // supports drawing
#define VIDCF_FASTTEMPORALC  0x0020  // does not need prev frame on compress
#define VIDCF_FASTTEMPORALD  0x0080  // does not need prev frame on decompress
//#define VIDCF_QUALITYTIME    0x0040  // supports temporal quality

//#define VIDCF_FASTTEMPORAL   (VIDCF_FASTTEMPORALC|VIDCF_FASTTEMPORALD)

/************************************************************************
************************************************************************/

#define ICCOMPRESS_KEYFRAME	0x00000001L

typedef struct {
    DWORD               dwFlags;        // flags

    LPBITMAPINFOHEADER  lpbiOutput;     // output format
    LPVOID              lpOutput;       // output data

    LPBITMAPINFOHEADER  lpbiInput;      // format of frame to compress
    LPVOID              lpInput;        // frame data to compress

    LPDWORD             lpckid;         // ckid for data in AVI file
    LPDWORD             lpdwFlags;      // flags in the AVI index.
    LONG                lFrameNum;      // frame number of seq.
    DWORD               dwFrameSize;    // reqested size in bytes. (if non zero)

    DWORD               dwQuality;      // quality

    // these are new fields
    LPBITMAPINFOHEADER  lpbiPrev;       // format of previous frame
    LPVOID              lpPrev;         // previous frame

} ICCOMPRESS;

/************************************************************************
************************************************************************/

#define ICCOMPRESSFRAMES_PADDING	0x00000001

typedef struct {
    DWORD               dwFlags;        // flags

    LPBITMAPINFOHEADER  lpbiOutput;     // output format
    LPARAM              lOutput;        // output identifier

    LPBITMAPINFOHEADER  lpbiInput;      // format of frame to compress
    LPARAM              lInput;         // input identifier

    LONG                lStartFrame;    // start frame
    LONG                lFrameCount;    // # of frames

    LONG                lQuality;       // quality
    LONG                lDataRate;      // data rate
    LONG                lKeyRate;       // key frame rate

    DWORD		dwRate;		// frame rate, as always
    DWORD		dwScale;

    DWORD		dwOverheadPerFrame;
    DWORD		dwReserved2;

    LONG (CALLBACK *GetData)(LPARAM lInput, LONG lFrame, LPVOID lpBits, LONG len);
    LONG (CALLBACK *PutData)(LPARAM lOutput, LONG lFrame, LPVOID lpBits, LONG len);
} ICCOMPRESSFRAMES;

typedef struct {
    DWORD		dwFlags;
    LPARAM		lParam;

    // messages for Status callback
    #define ICSTATUS_START	    0
    #define ICSTATUS_STATUS	    1	    // l == % done
    #define ICSTATUS_END	    2
    #define ICSTATUS_ERROR	    3	    // l == error string (LPSTR)
    #define ICSTATUS_YIELD	    4
    // return nonzero means abort operation in progress

    LONG (CALLBACK *Status) (LPARAM lParam, UINT message, LONG l);
} ICSETSTATUSPROC;

/************************************************************************
************************************************************************/

#define ICDECOMPRESS_HURRYUP      0x80000000L   // don't draw just buffer (hurry up!)
#define ICDECOMPRESS_UPDATE       0x40000000L   // don't draw just update screen
#define ICDECOMPRESS_PREROLL      0x20000000L   // this frame is before real start
#define ICDECOMPRESS_NULLFRAME    0x10000000L   // repeat last frame
#define ICDECOMPRESS_NOTKEYFRAME  0x08000000L   // this frame is not a key frame

typedef struct {
    DWORD               dwFlags;    // flags (from AVI index...)

    LPBITMAPINFOHEADER  lpbiInput;  // BITMAPINFO of compressed data
                                    // biSizeImage has the chunk size
    LPVOID              lpInput;    // compressed data

    LPBITMAPINFOHEADER  lpbiOutput; // DIB to decompress to
    LPVOID              lpOutput;
    DWORD		ckid;	    // ckid from AVI file
} ICDECOMPRESS;

typedef struct {
    //
    // same as ICM_DECOMPRESS
    //
    DWORD               dwFlags;

    LPBITMAPINFOHEADER  lpbiSrc;    // BITMAPINFO of compressed data
    LPVOID              lpSrc;      // compressed data

    LPBITMAPINFOHEADER  lpbiDst;    // DIB to decompress to
    LPVOID              lpDst;      // output data

    //
    // new for ICM_DECOMPRESSEX
    //
    int                 xDst;       // destination rectangle
    int                 yDst;
    int                 dxDst;
    int                 dyDst;

    int                 xSrc;       // source rectangle
    int                 ySrc;
    int                 dxSrc;
    int                 dySrc;

} ICDECOMPRESSEX;

/************************************************************************
************************************************************************/

#define ICDRAW_QUERY        0x00000001L   // test for support
#define ICDRAW_FULLSCREEN   0x00000002L   // draw to full screen
#define ICDRAW_HDC          0x00000004L   // draw to a HDC/HWND
#define ICDRAW_ANIMATE	    0x00000008L	  // expect palette animation
#define ICDRAW_CONTINUE	    0x00000010L	  // draw is a continuation of previous draw
#define ICDRAW_MEMORYDC	    0x00000020L	  // DC is offscreen, by the way
#define ICDRAW_UPDATING	    0x00000040L	  // We're updating, as opposed to playing
#define ICDRAW_RENDER       0x00000080L   // used to render data not draw it
#define ICDRAW_BUFFER       0x00000100L   // please buffer this data offscreen, we will need to update it

typedef struct {
    DWORD               dwFlags;        // flags

    HPALETTE            hpal;           // palette to draw with
    HWND                hwnd;           // window to draw to
    HDC                 hdc;            // HDC to draw to

    int                 xDst;           // destination rectangle
    int                 yDst;
    int                 dxDst;
    int                 dyDst;

    LPBITMAPINFOHEADER  lpbi;           // format of frame to draw

    int                 xSrc;           // source rectangle
    int                 ySrc;
    int                 dxSrc;
    int                 dySrc;

    DWORD               dwRate;         // frames/second = (dwRate/dwScale)
    DWORD               dwScale;

} ICDRAWBEGIN;

/************************************************************************
************************************************************************/

#define ICDRAW_HURRYUP      0x80000000L   // don't draw just buffer (hurry up!)
#define ICDRAW_UPDATE       0x40000000L   // don't draw just update screen
#define ICDRAW_PREROLL	    0x20000000L	  // this frame is before real start
#define ICDRAW_NULLFRAME    0x10000000L	  // repeat last frame
#define ICDRAW_NOTKEYFRAME  0x08000000L   // this frame is not a key frame

typedef struct {
    DWORD               dwFlags;        // flags
    LPVOID		lpFormat;       // format of frame to decompress
    LPVOID              lpData;         // frame data to decompress
    DWORD               cbData;
    LONG                lTime;          // time in drawbegin units (see dwRate and dwScale)
} ICDRAW;

typedef struct {
    LPBITMAPINFOHEADER	lpbiIn;		// format to be drawn
    LPBITMAPINFOHEADER	lpbiSuggest;	// location for suggested format (or NULL to get size)
    int			dxSrc;		// source extent or 0
    int			dySrc;
    int			dxDst;		// dest extent or 0
    int			dyDst;
    HIC			hicDecompressor;// decompressor you can talk to
} ICDRAWSUGGEST;

/************************************************************************
************************************************************************/

typedef struct {
    DWORD               dwFlags;    // flags (from AVI index...)
    int                 iStart;     // first palette to change
    int                 iLen;       // count of entries to change.
    LPPALETTEENTRY      lppe;       // palette
} ICPALETTE;

// end_vfw32

#ifndef RC_INVOKED
#ifndef _WIN32
#pragma pack()          /* Revert to default packing */
#endif
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_COMPDDK */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\rrcm.h ===
/*-------------------------------------------------------------------------
// File : RRCM.H
//
// RRCM's include files .
//
// $Workfile:   rrcm.h  $
// $Author:   CMACIOCC  $
// $Date:   18 Feb 1997 13:23:28  $
// $Revision:   1.10  $
// $Archive:   R:\rtp\src\rrcm\rrcminc\rrcm.h_v  $
//
//  INTEL Corporation Proprietary Information
// This listing is supplied under the terms of a license agreement with 
// Intel Corporation and may not be copied nor disclosed except in 
// accordance with the terms of that agreement.
// Copyright (c) 1995 Intel Corporation. 
//-----------------------------------------------------------------------*/


#ifndef __RRCM_H_
#define __RRCM_H_

#if !defined(USE_RRCM)

#ifdef INCL_WINSOCK_API_TYPEDEFS
#undef INCL_WINSOCK_API_TYPEDEFS
#endif
#define INCL_WINSOCK_API_TYPEDEFS 1
#include <winsock2.h>
#include <qossp.h>
#include <stdio.h>
#include <io.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>  
#include <math.h>  
#include <process.h> 
#include <mmsystem.h>   
#include <assert.h>

#endif

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
#include "interop.h"
#include "rtpplog.h"
#endif

typedef CHAR	*PCHAR;

#ifdef ENABLE_ISDM2
#include "isdmapi2.h"
#endif
#include <rrcm_dll.h>
#include <rrcmdata.h>
#include "rrcmprot.h"
#include "rrcm_rtp.h"
// #include "isrg.h"



//----------------------------------------------------------------------------
// RTP/RTCP: Registry information under:
//				HKEY_LOCAL_MACHINE\SOFTWARE\INTEL\RRCM
//----------------------------------------------------------------------------
#define szRegRRCMSubKey				TEXT("RRCM")
#define szRegRRCMSubKeyIntel		TEXT("iRRCM")
#define szRegRRCMKey				TEXT("SOFTWARE\\Intel\\")
#define szRegRRCMWsLib				TEXT("WsLib")
#define szRegRRCMNumSessions		TEXT("NumSessions")
#define szRegRRCMNumFreeSSRC		TEXT("NumFreeSSRC")
#define szRegRRCMNumRTCPPostedBfr	TEXT("NumRTCPPostedBfr")
#define szRegRRCMRTCPrcvBfrSize		TEXT("RTCPrcvBfrSize")


//----------------------------------------------------------------------------
// RTP/RTCP: Dynamically loaded DLL
//----------------------------------------------------------------------------
#ifdef ENABLE_ISDM2
#define szISDMdll					TEXT("ISDM2")
#endif

#define szRRCMdefaultLib			TEXT("ws2_32")


#ifdef ENABLE_ISDM2
//----------------------------------------------------------------------------
// RTP/RTCP: ISDM module
//----------------------------------------------------------------------------
#define szSSRCtoken					TEXT("SSRC")
#define szPcktSentToken				TEXT("Number of packets send")
#define szByteSentToken				TEXT("Number of bytes send")
#define szPcktRcvdToken				TEXT("Number of packets received")
#define szByteRcvdToken				TEXT("Number of bytes received")
#define szFractionLostToken			TEXT("Fraction lost")
#define szCumNumPcktLostToken		TEXT("Cumulative number of packets lost")
#define szXntHighSeqNumToken		TEXT("Extended highest sequence number")
#define szInterarrivalJitterToken	TEXT("Interarrival jitter")
#define szLastSRtoken				TEXT("Last sender report")
#define szDSLRtoken					TEXT("Delay since last sender report")
#define szNTPfracToken				TEXT("NTP fraction")
#define szNTPsecToken				TEXT("NTP seconds")
#define szWhoAmItoken				TEXT("Who Am I")
#define szFdbkFractionLostToken		TEXT("Fraction lost feedback")
#define szFdbkCumNumPcktLostToken	\
	TEXT("Cumulative number of packets lost feedback")
#define szFdbkLastSRtoken			TEXT("Last sender report feedback")
#define szFdbkDSLRtoken				\
	TEXT("Delay since last sender report feedback")
#define szFdbkInterarrivalJitterToken	TEXT("Interarrival jitter feedback")
#endif


//----------------------------------------------------------------------------
// RTP: Bitmaps used to isolate errors detected for incoming received packets
//----------------------------------------------------------------------------
#define SSRC_LOOP_DETECTED			(1)
#define SSRC_COLLISION_DETECTED		(2)
#define INVALID_RTP_HEADER			(3)
#define MCAST_LOOPBACK_NOT_OFF		(4)

//----------------------------------------------------------------------------
// RTP: Default number of RTP sessions
//----------------------------------------------------------------------------
#define NUM_RRCM_SESS				50
#define MIN_NUM_RRCM_SESS			5
#define MAX_NUM_RRCM_SESS			100

//----------------------------------------------------------------------------
// RTP: Number of entries in the hash table
//----------------------------------------------------------------------------
#define NUM_RTP_HASH_SESS			65		

//---------------------------------------------------------------------------- 
//	RTP: DEFINES TO DETERMINE SEQUENCE NUMBER WRAP or STALENESS (per RFC)
//----------------------------------------------------------------------------
#define MAX_DROPOUT					3000
#define MAX_MISORDER				100
#define MIN_SEQUENTIAL				2

//----------------------------------------------------------------------------
//	RTCP: Defined
//----------------------------------------------------------------------------
#define	MAX_RR_ENTRIES				31			// Max # of Receiver Reports
#define TIMEOUT_CHK_FREQ			(8*1000)	// Timeout check freq. - 8s
#define RTCP_TIME_OUT		        (30*60*1000) // 30 minutes timeout
#define	RTCP_XMT_MINTIME			2500
#define RTCP_TIMEOUT_WITHIN_RANGE	100
#define	ONE_K						1024

#define	NUM_FREE_SSRC				100
#define	MIN_NUM_FREE_SSRC			5
#define	MAX_NUM_FREE_SSRC			500

#define NUM_FREE_CONTEXT_CELLS			10
#define MAXNUM_CONTEXT_CELLS_REALLOC	10

#define	NUM_FREE_RCV_BFR			8
#define	NUM_FREE_XMT_BFR			2
#define NUM_RCV_BFR_POSTED			4
#define MIN_NUM_RCV_BFR_POSTED		1
#define MAX_NUM_RCV_BFR_POSTED		8
#define RRCM_RCV_BFR_SIZE			(8*ONE_K)
#define MIN_RRCM_RCV_BFR_SIZE		(1*ONE_K)
#define MAX_RRCM_RCV_BFR_SIZE		(8*ONE_K)
#define RRCM_XMT_BFR_SIZE			(8*ONE_K)
#define	RCV_BFR_LIST_HEAP_SIZE		(4*ONE_K)	// Rcv bfr list heap size
#define	XMT_BFR_LIST_HEAP_SIZE		(4*ONE_K)	// Xmt bfr list heap size
#define INITIAL_RTCP_BANDWIDTH		50			// BW in bytes/sec (~ G.723)
												//   5% of 6.3Kb/s = 35 bytes
#define	MAX_STREAMS_PER_SESSION		64			// Max number of active 
												//   streams per RTP session
#define MAX_NUM_SDES				9			// Number of SDES support


//----------------------------------------------------------------------------
//	RTP/RTCP Misc defined
//----------------------------------------------------------------------------
#define UNKNOWN_PAYLOAD_TYPE		0xFFFFFFFF
#define szDfltCname					TEXT("No Cname")


//----------------------------------------------------------------------------
//	RTP/RTCP: Debug Defined
//----------------------------------------------------------------------------
#define	DBG_STRING_LEN			200
#define	IO_CHECK				0
#define	FLUSH_RTP_PAYLOAD_TYPE	90

enum ISRBDG_CODE{
	DBG_NOTIFY = 1,
	DBG_CRITICAL,
	DBG_ERROR,
	DBG_WARNING,
	DBG_TRACE,
	DBG_TEMP
	};

#if !defined(DXMRTP) && !defined(USE_RRCM)

// DXMRTP is defined while building dxmrtp.dll
// that contains all the filtersi, or amrtpnet.ax that 
// includes the rrcm stuff

#ifdef _DEBUG

#define ASSERT(x)				assert(x)
//#define ASSERT(x)
#define RRCM_DEV_MSG(x,e,f,l,t)	RRCMdebugMsg(x,e,f,l,t)

#if defined(DEBUG_RRCM)
#define RRCM_DBG_MSG(x,e,f,l,t)	RRCMdebugMsg(x,e,f,l,t)
#else
#define RRCM_DBG_MSG(x,e,f,l,t)	{}	// DO NOT DELETE BRACKETS ...
#endif

enum {  LOG_TIMING = 0x01,    // Timing and performance measurements
        LOG_TRACE = 0x02,     // General step point call tracing
        LOG_MEMORY =  0x04,   // Memory and object allocation/destruction
        LOG_LOCKING = 0x08,   // Locking/unlocking of critical sections
        LOG_ERROR = 0x10 };   // Debug error notification

#define LOG_DEVELOP             1
#define LOG_DEVELOP1            1
#define LOG_DEVELOP2            2
#define LOG_DEVELOP3            3
#define LOG_DEVELOP4            4
#define LOG_ALWAYS              0x8
#define LOG_CRITICAL            0XF
#define LOG_EVERYTHING          0xFFFFFFFF

void RRCMDebugLogInfo(DWORD Type, DWORD Level, const char *pFormat,...);

#define RRCMDbgLog(_x_)  RRCMDebugLogInfo _x_

#else // #ifde _DEBUG

#define ASSERT(x)
#define RRCM_DBG_MSG(x,e,f,l,t)	{}	// DO NOT DELETE BRACKETS ...
#define RRCM_DEV_MSG(x,e,f,l,t)	{}	// DO NOT DELETE BRACKETS ...

#define RRCMDbgLog(_x_)

#endif // #ifdef _DEBUG

#ifdef IN_OUT_CHK
#define	IN_OUT_STR(x)			OutputDebugString (x);
#else
#define	IN_OUT_STR(x)	
#endif

#endif // #if !defined(USE_RRCM)

#endif // #ifndef __RRCM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\trace.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    trace.h

Abstract:

    Definitions for logging support.

--*/

#ifndef _DXMRTP_TRACE_H_
#define _DXMRTP_TRACE_H_

/**********************************************************************/
#if defined(DXMRTPTRACE)
/**********************************************************************/

#include <rtutils.h>

#define MSP_ERROR ((DWORD)0x00010000 | TRACE_USE_MASK)
#define MSP_WARN  ((DWORD)0x00020000 | TRACE_USE_MASK)
#define MSP_INFO  ((DWORD)0x00040000 | TRACE_USE_MASK)
#define MSP_TRACE ((DWORD)0x00080000 | TRACE_USE_MASK)
#define MSP_EVENT ((DWORD)0x00100000 | TRACE_USE_MASK)

BOOL NTAPI DxmTraceRegister(LPCTSTR szName);
void NTAPI DxmTraceDeRegister();
void NTAPI DxmTracePrint(IN DWORD dwDbgLevel,
                         IN DWORD dwDbgType,
                         IN LPCSTR DbgMessage,
                         IN ...);

#define TRACEREGISTER(arg) DxmTraceRegister(arg)
#define TRACEDEREGISTER()  DxmTraceDeRegister()
#define TraceRetail(arg)   DxmTracePrint arg

#if defined(DEBUG)
#define TraceDebug(arg)    DxmTracePrint  arg
#else
#define TraceDebug(arg)
#endif

// types
#define TRACE_ERROR    ((DWORD)0x00010000 | TRACE_USE_MASK)
#define TRACE_WARN     ((DWORD)0x00020000 | TRACE_USE_MASK)
#define TRACE_INFO     ((DWORD)0x00040000 | TRACE_USE_MASK)
#define TRACE_TRACE    ((DWORD)0x00080000 | TRACE_USE_MASK)

#define TRACE_EVENT   TRACE_TRACE
#define TRACE_TIMING  TRACE_TRACE
#define TRACE_MEMORY  TRACE_INFO
#define TRACE_LOCKING TRACE_TRACE

// levels
#define TRACE_DEVELOP    LOG_DEVELOP
#define TRACE_DEVELOP1   LOG_DEVELOP1
#define TRACE_DEVELOP2   LOG_DEVELOP2
#define TRACE_DEVELOP3   LOG_DEVELOP3
#define TRACE_DEVELOP4   LOG_DEVELOP4
#define TRACE_ALWAYS     LOG_DEVELOP4
#define TRACE_CRITICAL   LOG_DEVELOP4
#define TRACE_EVERYTHING LOG_DEVELOP4

#define TRACE_TYPES      (LOG_TRACE|LOG_ERROR|LOG_TIMING|LOG_LOCKING)
#define TRACE_LEVELS     (TRACE_EVERYTHING)

/**********************************************************************/
#else
/**********************************************************************/

// if rtutils debuging facilities are not used, used those from DShow
// base classes
#define TRACEREGISTER(arg)
#define TRACEDEREGISTER() 
#define TraceRetail(arg) DbgLog(arg)
#define TraceDebug(arg)  DbgLog(arg)

// types
#define TRACE_ERROR    LOG_ERROR
#define TRACE_WARN     LOG_ERROR
#define TRACE_INFO     LOG_TRACE
#define TRACE_TRACE    LOG_TRACE

#define TRACE_TIMING  LOG_TIMING
#define TRACE_MEMORY  LOG_MEMORY
#define TRACE_LOCKING LOG_LOCKING

// levels
#define TRACE_DEVELOP    LOG_DEVELOP
#define TRACE_DEVELOP1   LOG_DEVELOP1
#define TRACE_DEVELOP2   LOG_DEVELOP2
#define TRACE_DEVELOP3   LOG_DEVELOP3
#define TRACE_DEVELOP4   LOG_DEVELOP4
#define TRACE_ALWAYS     LOG_ALWAYS
#define TRACE_CRITICAL   LOG_CRITICAL
#define TRACE_EVERYTHING 0xffffffff

#define TRACE_TYPES      (LOG_TRACE|LOG_ERROR|LOG_TIMING|LOG_LOCKING)
#define TRACE_LEVELS     (TRACE_EVERYTHING)

/**********************************************************************/
#endif
/**********************************************************************/

#endif // _DXMRTP_TRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\ph\ippm.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: ippm.h
//  Abstract:    Header file for PPM Interface
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////

#ifndef IPPM_H
#define IPPM_H

#include "isubmit.h"

#ifdef __cplusplus
#define DEFAULT_PARAM_ZERO	=0
#else
#define DEFAULT_PARAM_ZERO
#endif

// Used to report outstanding messages and the fragments from PPM
struct OutstandingDataHdr 
	{
		DWORD	MsgId;			
		int		FragCount;
		void	*pFrag;
	};

typedef struct
{
	int payload_type;
	DWORD delta_time; // Amount of time we will wait for missing packets
                     // before processing audio packets or video frames
} PPMSESSPARAM_T;

typedef struct : PPMSESSPARAM_T
{
	BOOL	ExtendedBitstream;
} H26XPPMSESSPARAM_T;


#define HRESULT_BUFFER_DROP				0x60000001
#define HRESULT_BUFFER_SILENCE			0x60000002
#define HRESULT_BUFFER_NORMAL			0x60000003
#define HRESULT_BUFFER_START_STREAM		0x60000004

#undef INTERFACE
#define INTERFACE IPPMSend
DECLARE_INTERFACE_(IPPMSend,IUnknown)
{
 // *** IUnknown methods ***
 STDMETHOD(QueryInterface) ( THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
 STDMETHOD_(ULONG,AddRef)  (THIS) PURE;
 STDMETHOD_(ULONG,Release) (THIS) PURE;
 
 STDMETHOD(InitPPMSend)(THIS_ int MaxPacketSize, DWORD dwCookie DEFAULT_PARAM_ZERO) PURE;
 STDMETHOD(SetSession)(THIS_ PPMSESSPARAM_T *pSessparam)PURE;
 STDMETHOD(SetAlloc)(THIS_ IMalloc *pIMalloc)PURE;
};

#undef INTERFACE
#define INTERFACE IPPMReceive
DECLARE_INTERFACE_(IPPMReceive,IUnknown)
{
 // *** IUnknown methods ***
 STDMETHOD(QueryInterface) ( THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
 STDMETHOD_(ULONG,AddRef)  (THIS) PURE;
 STDMETHOD_(ULONG,Release) (THIS) PURE;
 
 STDMETHOD(InitPPMReceive)(THIS_ int MaxBufferSize DEFAULT_PARAM_ZERO, DWORD dwCookie DEFAULT_PARAM_ZERO) PURE;
 STDMETHOD(SetSession)(THIS_ PPMSESSPARAM_T *pSessparam)PURE;
 STDMETHOD(SetAlloc)(THIS_ IMalloc *pIMalloc)PURE;
};

#undef INTERFACE
#define INTERFACE IPPMData
DECLARE_INTERFACE_(IPPMData,IUnknown)
{
 // *** IUnknown methods ***
 STDMETHOD(QueryInterface) ( THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
 STDMETHOD_(ULONG,AddRef)  (THIS) PURE;
 STDMETHOD_(ULONG,Release) (THIS) PURE;
 
 STDMETHOD(ReportOutstandingData)(THIS_ DWORD** pDataHdr, DWORD* DataCount)PURE;
 STDMETHOD(ReleaseOutstandingDataBuffer)(THIS_ DWORD *pData )PURE;
 STDMETHOD(FlushData)(THIS_ void )PURE;
};


#undef INTERFACE
#define INTERFACE IPPMSendExperimental
DECLARE_INTERFACE_(IPPMSendExperimental, IUnknown)
{
 // *** IUnknown methods ***
 STDMETHOD(QueryInterface) ( THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
 STDMETHOD_(ULONG,AddRef)  (THIS) PURE;
 STDMETHOD_(ULONG,Release) (THIS) PURE;
 
 STDMETHOD(InitPPMSend)(THIS_
                        int     MaxPacketSize, 
                        int     iBufferRecords DEFAULT_PARAM_ZERO,
                        int     iPacketRecords DEFAULT_PARAM_ZERO,
                        DWORD   dwCookie DEFAULT_PARAM_ZERO) PURE;
 STDMETHOD(SetSession)(THIS_ PPMSESSPARAM_T *pSessparam)PURE;
 STDMETHOD(SetAlloc)(THIS_ IMalloc *pIMalloc)PURE;
};


#undef INTERFACE
#define INTERFACE IPPMReceiveExperimental
DECLARE_INTERFACE_(IPPMReceiveExperimental,IUnknown)
{
 // *** IUnknown methods ***
 STDMETHOD(QueryInterface) ( THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
 STDMETHOD_(ULONG,AddRef)  (THIS) PURE;
 STDMETHOD_(ULONG,Release) (THIS) PURE;
 
 STDMETHOD(InitPPMReceive)(THIS_ 
                           int      MaxBufferSize DEFAULT_PARAM_ZERO,
                           int      iBufferRecords DEFAULT_PARAM_ZERO,
                           int      iPacketRecords DEFAULT_PARAM_ZERO,
                           DWORD    dwCookie DEFAULT_PARAM_ZERO) PURE;
 STDMETHOD(SetSession)(THIS_ PPMSESSPARAM_T *pSessparam)PURE;
 STDMETHOD(SetAlloc)(THIS_ IMalloc *pIMalloc)PURE;
};

#undef INTERFACE
#define INTERFACE IPPMSendSession
DECLARE_INTERFACE_(IPPMSendSession,IUnknown)
{
 // *** IUnknown methods ***
 STDMETHOD(QueryInterface) ( THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
 STDMETHOD_(ULONG,AddRef)  (THIS) PURE;
 STDMETHOD_(ULONG,Release) (THIS) PURE;
 
 STDMETHOD(GetPayloadType)(THIS_ LPBYTE			lpcPayloadType) PURE;
 STDMETHOD(SetPayloadType)(THIS_ BYTE			cPayloadType) PURE;
};

#undef INTERFACE
#define INTERFACE IPPMReceiveSession
DECLARE_INTERFACE_(IPPMReceiveSession,IUnknown)
{
 // *** IUnknown methods ***
 STDMETHOD(QueryInterface) ( THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
 STDMETHOD_(ULONG,AddRef)  (THIS) PURE;
 STDMETHOD_(ULONG,Release) (THIS) PURE;
 
 STDMETHOD(GetPayloadType)(THIS_ LPBYTE			lpcPayloadType) PURE;
 STDMETHOD(SetPayloadType)(THIS_ BYTE			cPayloadType) PURE;
 STDMETHOD(GetTimeoutDuration)(THIS_ LPDWORD    lpdwLostPacketTime) PURE;
 STDMETHOD(SetTimeoutDuration)(THIS_ DWORD      dwLostPacketTime) PURE;
 STDMETHOD(GetResiliency)(THIS_ LPBOOL			lpbResiliency) PURE;
 STDMETHOD(SetResiliency)(THIS_ BOOL			pbResiliency) PURE;
};





////////////////////////////////////////////////////////////////////////////
// Interface ids
// 
// {6DE88011-2BA6-11d0-9CA2-00A0C9081C19}
DEFINE_GUID( IID_IPPMSend,	0x6de88011, 0x2ba6, 0x11d0, 0x9c, 0xa2, 0x0, 0xa0, 0xc9, 0x8, 0x1c, 0x19);

// {6DE88012-2BA6-11d0-9CA2-00A0C9081C19}
DEFINE_GUID( IID_IPPMReceive, 0x6de88012, 0x2ba6, 0x11d0, 0x9c, 0xa2, 0x0, 0xa0, 0xc9, 0x8, 0x1c, 0x19);

// {E721B4E0-8F3C-11d0-9643-00AA00A89C1D}
DEFINE_GUID(IID_IPPMData, 0xe721b4e0, 0x8f3c, 0x11d0, 0x96, 0x43, 0x0, 0xaa, 0x0, 0xa8, 0x9c, 0x1d);

// {D25DF7E1-4C71-11d0-9CBF-00A0C9081C19}
DEFINE_GUID( IID_IPPMSendExperimental, 0xd25df7e1, 0x4c71, 0x11d0, 0x9c, 0xbf, 0x0, 0xa0, 0xc9, 0x8, 0x1c, 0x19);

// {D25DF7E2-4C71-11d0-9CBF-00A0C9081C19}
DEFINE_GUID( IID_IPPMReceiveExperimental, 0xd25df7e2, 0x4c71, 0x11d0, 0x9c, 0xbf, 0x0, 0xa0, 0xc9, 0x8, 0x1c, 0x19);

// {E36B0450-94DB-11d0-95E4-00A0C9220B7D}
DEFINE_GUID(IID_IPPMSendSession, 0xe36b0450, 0x94db, 0x11d0, 0x95, 0xe4, 0x0, 0xa0, 0xc9, 0x22, 0xb, 0x7d);

// {E36B0451-94DB-11d0-95E4-00A0C9220B7D}
DEFINE_GUID(IID_IPPMReceiveSession, 0xe36b0451, 0x94db, 0x11d0, 0x95, 0xe4, 0x0, 0xa0, 0xc9, 0x22, 0xb, 0x7d);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\ph\lh.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: lh.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#ifndef LH_H
#define LH_H

#ifdef __cplusplus

typedef struct : public PPMSESSPARAM_T
{
	DWORD msec;
} LHSESSPARAM_T;

#else /* __cplusplus */

typedef struct {
    PPMSESSPARAM_T ppmSessParam;
	DWORD msec;
} LHSESSPARAM_T;

#endif /* __cplusplus */

#endif // LH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\ph\isrg.h ===
/****************************************************************************

	INTEL CORPORATION PROPRIETARY INFORMATION
	Copyright (c) 1992 Intel Corporation
	All Rights Reserved

	This software is supplied under the terms of a license
	agreement or non-disclosure agreement with Intel Corporation
	and may not be copied or disclosed except in accordance
	with the terms of that agreement

    $Source: q:/prism/include/rcs/isrg.h $
  $Revision:   1.1  $
      $Date:   22 Nov 1996 17:50:10  $
    $Author:   CMACIOCC  $
    $Locker:  $

	Description
	-----------
	Interrupt Service Routine debug header file
	This module allows for a way of doing OutputDebugString()
	at interrupt time.

****************************************************************************/

#ifndef ISRG_H
#define ISRG_H

#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus

// Use for Win16
//#define DllExport
//#define DllImport
//#define DLL_EXPORT	_export

// Use for Win32
#define DllExport		__declspec( dllexport )
#define DllImport		__declspec( dllimport )
#define DLL_EXPORT

//
//	directions
//		Pick a number (mod 100) and create a base for the next 
//		100 entries.  Do it this way so that your numbers can
//		be easily moved.  The string assigned to the base you select
//		will be displayed as the filter string in a list box when
//		viewing.  After defining your constants go to isrdsp.rc
//		and assign strings to them.  You will need to build the
//		isrdsp.exe but not the isrdbg.dll.  You only need to
//		inlude this h file and import the functions from this
//		file into your def file.  Happy debugging.


//------------------------------------------------------------------------------
#define kModSNameSize		16
#define kModLNameSize		32

//------------------------------------------------------------------------------
// defines for tISRModule.Flags
#define kCaptureOn			0x01

//------------------------------------------------------------------------------
typedef struct _tISRModule
{
	WORD	Flags;
	BYTE	CaptureFilter;
	BYTE	DisplayFilter;
	char	zSName[kModSNameSize];	// Short name of user registered debug module
	char	zLName[kModLNameSize];	// Long name of user registered debug module
} tISRModule, FAR *ptISRModule;

//------------------------------------------------------------------------------
#define kModuleBufSize		((DWORD) (16*1024L))
#define kMaxModules			((UINT) (kModuleBufSize/sizeof(tISRModule)))


//------------------------------------------------------------------------------
typedef struct _tISRItem
{
	WORD	hISRInst;		// Our handle to registered modules
	BYTE	DbgLevel;		// Caller determined debug level
	BYTE	Flags;
	UINT	IP;				// Callers Instruction Ptr address
	DWORD	Param1;
	DWORD	Param2;
} tISRItem, FAR *ptISRItem;

//------------------------------------------------------------------------------
#define kISRBufSize			((DWORD) (32*1024L))
#define kMaxISRItems		((UINT) (kISRBufSize/sizeof(tISRItem)))
#define kMaxStrTab			((UINT) (60*1024L))


//------------------------------------------------------------------------------
// defines for tISRItem.Flags
#define kParam1IsStr		0x01
#define kParam1IsRes		0x02
#define kParam1IsNum		0x04		// Use only if passed two numbers.


//------------------------------------------------------------------------------
// Supported DbgMsg state values.
//------------------------------------------------------------------------------
#define _DBG				0
#define _ERR				1

#define kISRCritical		0x01	// Progammer errors that should never happen
#define kISRError			0x02	// Errors that need to be fixed
#define kISRWarning			0x04	// The user could have problems if not corrected
#define kISRNotify			0x08	// Status, events, settings...
#define kISRTrace			0x10	// Trace info that will not overrun the system
#define kISRTemp			0x20	// Trace info that may be reproduced in heavy loops
#define kISRReserved1		0x40	// Future use
#define kISRReserved2		0x80	// Future use
#define kISRDefault			kISRReserved2	// Historical use only

#define TT_CRITICAL			kISRCritical
#define TT_ERROR			kISRError
#define TT_WARNING			kISRWarning
#define TT_NOTIFY			kISRNotify
#define TT_TRACE			kISRTrace
#define TT_TEMP				kISRTemp


//------------------------------------------------------------------------------
// exports from isrdbg.dll
// Include these in your def file if you want to output at interrupt time.
// The ISR_Hook*() functions are the same as their counterparts.  The only
// difference is that these functions need the Instruction Pointer passed
// in.  If you are using an intermediate library to encapsulate the debug
// functions then you must be responsible for pulling the IP off the stack.

// Register the module and get a handle for making debug calls.  If a debug
// call is made with an invalid handle then the results are not defined.
// It is possible to drop the debug event or to place the event into the 
// compatibility module.  If no more module handles are available then
// the handle returned will be the compatibility handle.
DllExport void WINAPI DLL_EXPORT
ISR_RegisterModule (LPWORD phISRInst, LPSTR zShortName, LPSTR zLongName);


// Allow two strings to be concatenated togeter.
DllExport void WINAPI DLL_EXPORT
ISR_HookDbgStrStr (UINT IP, WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, LPSTR pzStr2);

// Use a resource to format a number.
DllExport void WINAPI DLL_EXPORT
ISR_HookDbgRes (UINT IP, WORD hISRInst, BYTE DbgLevel, UINT uResId, DWORD Param1);

// Use a str to format a number.
DllExport void WINAPI DLL_EXPORT
ISR_HookDbgStr (UINT IP, WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, DWORD Param1);

// Allow two strings to be concatenated togeter.
DllExport void WINAPI DLL_EXPORT
ISR_DbgStrStr (WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, LPSTR pzStr2);

// Use a resource to format a number.
DllExport void WINAPI DLL_EXPORT
ISR_DbgRes (WORD hISRInst, BYTE DbgLevel, UINT uResId, DWORD Param1);

// Use a str to format a number.
DllExport void WINAPI DLL_EXPORT
ISR_DbgStr (WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, DWORD Param1);


// WARNING: Call at task time only.  Not reentrant.
DllExport void FAR cdecl DLL_EXPORT
TTDbgMsg 
(
	WORD		hISRInst,	// Module's ISRDBG handle.
	BYTE		DbgLevel,	// Appropriate ISRDBG level.
	LPCSTR		zMsgFmt,	// Output format string (like printf).
	... 					// Optional parameter list.
);


// Old functions for compatibility only.
DllExport void WINAPI DLL_EXPORT
ISR_OutputDbgStr (LPSTR pzStr);

DllExport void WINAPI DLL_EXPORT
ISR_OutputStr (UINT uResId);

DllExport void WINAPI DLL_EXPORT
ISR_OutputNum (UINT uResId, DWORD Num);

// WARNING: Call at task time only.  Not reentrant.
DllExport void FAR cdecl DLL_EXPORT
DbgMsg
	(
	LPCSTR		module,
	int			state,
	LPCSTR		format_str,
	...
	);


//------------------------------------------------------------------------------
// exports from isrdbg.dll
// Include these in your def file if you need to know the state of isrdbg.dll.
// isrdsp.exe needs to do this to display the data at task time.

DllExport void WINAPI DLL_EXPORT
ISR_ClearItems (void);

DllExport UINT WINAPI DLL_EXPORT
ISR_GetNumItems (void);

DllExport ptISRItem WINAPI DLL_EXPORT
ISR_GetItem (UINT uItem,ptISRItem pItem);

DllExport ptISRModule WINAPI DLL_EXPORT
ISR_GetModule (UINT hISRInst);

DllExport int WINAPI DLL_EXPORT
ISR_SetCaptureFilter (WORD hISRInst, BYTE CaptureFilter,  BYTE DisplayFilter);


//------------------------------------------------------------------------------
//	The caller of ISR debug functions can call these Macros and then the
//	retail release will just drop all of the debug statement code.
//------------------------------------------------------------------------------
#if (_DEBUG >= 1)
#define ISRDEBUGINFO	1
extern WORD	ghISRInst;
#define ISRREGISTERMODULE(pghISRInst, ShortName, LongName)	ISR_RegisterModule(pghISRInst, ShortName, LongName)
#define ISRNOTIFY(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRNotify, Str, Num)
#define ISRCRITICAL(ghISRInst, Str, Num)	ISR_DbgStr(ghISRInst, kISRCritical, Str, Num)
#define ISRERROR(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRError, Str, Num)
#define ISRWARNING(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRWarning, Str, Num)
#define ISRTRACE(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRTrace, Str, Num)
#define ISRTEMP(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRTemp, Str, Num)
#define ISRRESERVED1(ghISRInst, Str, Num)	ISR_DbgStr(ghISRInst, kISRReserved1, Str, Num)
#define ISRRESERVED2(ghISRInst, Str, Num)	ISR_DbgStr(ghISRInst, kISRReserved2, Str, Num)

#define ISRSNOTIFY(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRNotify, Str, Str2)
#define ISRSCRITICAL(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRCritical, Str, Str2)
#define ISRSERROR(ghISRInst, Str, Str2)		ISR_DbgStrStr(ghISRInst, kISRError, Str, Str2)
#define ISRSWARNING(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRWarning, Str, Str2)
#define ISRSTRACE(ghISRInst, Str, Str2)		ISR_DbgStrStr(ghISRInst, kISRTrace, Str, Str2)
#define ISRSTEMP(ghISRInst, Str, Str2)		ISR_DbgStrStr(ghISRInst, kISRTemp, Str, Str2)
#define ISRSRESERVED1(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRReserved1, Str, Str2)
#define ISRSRESERVED2(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRReserved2, Str, Str2)

#define TTDBG			TTDbgMsg

#else

#define ISRNOTIFY(ghISRInst, Str, Num)
#define ISRREGISTERMODULE(pghISRInst, ShortName, LongName)
#define ISRCRITICAL(ghISRInst, Str, Num)
#define ISRERROR(ghISRInst, Str, Num)
#define ISRWARNING(ghISRInst, Str, Num)
#define ISRTRACE(ghISRInst, Str, Num)
#define ISRTEMP(ghISRInst, Str, Num)
#define ISRRESERVED1(ghISRInst, Str, Num)
#define ISRRESERVED2(ghISRInst, Str, Num)

#define ISRSNOTIFY(ghISRInst, Str, Str2)
#define ISRSCRITICAL(ghISRInst, Str, Str2)
#define ISRSERROR(ghISRInst, Str, Str2)
#define ISRSWARNING(ghISRInst, Str, Str2)
#define ISRSTRACE(ghISRInst, Str, Str2)
#define ISRSTEMP(ghISRInst, Str, Str2)
#define ISRSRESERVED1(ghISRInst, Str, Str2)
#define ISRSRESERVED2(ghISRInst, Str, Str2)

#define ghISRInst		0
#define TTDBG			1 ? (void)0 : TTDbgMsg

#endif


//------------------------------------------------------------------------------
// Local Functions
static void
InitModules (void);

static UINT
ValidCaptureMsg (WORD hISRInst, BYTE DbgLevel);

// Local function but thunk needs to get to it
DllExport void WINAPI
OutputRec
	(
	WORD	hISRInst,		// Our handle to registered modules
	BYTE	DbgLevel,		// Caller determined debug level
	BYTE	Flags,
	UINT	IP,				// Callers Instruction Ptr address
	DWORD	Param1,
	DWORD	Param2
	);

// Local function but thunk needs to get to it
DllExport void WINAPI
OutputRecStr
	(
	WORD	hISRInst,		// Our handle to registered modules
	BYTE	DbgLevel,		// Caller determined debug level
	BYTE	Flags,
	UINT	IP,				// Callers Instruction Ptr address
	LPSTR	pzStr1,
	LPSTR	pzStr2,
	DWORD	Param1
	);


//------------------------------------------------------------------------------
// do not use a base of 0.  Reserved for system use.
#define ID_SysBase			0
#define ID_SysStr			(ID_SysBase + 1)
#define ID_SysSInt			(ID_SysBase + 2)
#define ID_SysUInt			(ID_SysBase + 3)
#define ID_SysDWord			(ID_SysBase + 4)
#define ID_SysLong			(ID_SysBase + 5)
#define ID_SysHex			(ID_SysBase + 6)


//------------------------------------------------------------------------------
// IsrDbg.dll
#define ID_IsrDbgBase		100
#define ID_IsrDbgLibMain	(ID_IsrDbgBase + 1)
#define ID_IsrDbgWep		(ID_IsrDbgBase + 2)
#define ID_IsrDbgReentrant	(ID_IsrDbgBase + 3)


//------------------------------------------------------------------------------
// IsrDsp.exe
#define ID_IsrDspBase		200
#define ID_IsrDspInit		(ID_IsrDspBase + 1)
#define ID_IsrDspExit		(ID_IsrDspBase + 2)


//------------------------------------------------------------------------------
// stMem.dll
#define ID_stMemBase		300
#define ID_stMemLibMain		(ID_stMemBase + 1)
#define ID_stMemWep			(ID_stMemBase + 2)
#define ID_stMemPreAlloc	(ID_stMemBase + 3)
#define ID_stMemPageLock	(ID_stMemBase + 4)
#define ID_stMemNoPageLock	(ID_stMemBase + 5)
#define ID_stMemAlloc		(ID_stMemBase + 6)
#define ID_stMemTotMem		(ID_stMemBase + 7)
#define ID_stMemstFree		(ID_stMemBase + 8)

                                                      
//-------------------------------------------------------------------------------
// DLM.dll

// Errors
#define ID_DLMErrorBase		400
#define ID_DLMEnqError      (ID_DLMErrorBase + 1)
#define ID_DLMDeqError      (ID_DLMErrorBase + 2)
#define ID_DLMFreeError     (ID_DLMErrorBase + 3)
#define ID_DLMChanError     (ID_DLMErrorBase + 4)
#define ID_DLMChanNIUErr    (ID_DLMErrorBase + 5)
#define ID_DLMChanNumErr    (ID_DLMErrorBase + 6)
#define ID_DLMInConnErr     (ID_DLMErrorBase + 7)
#define ID_DLMInSessErr     (ID_DLMErrorBase + 8)
#define ID_DLMSessNIU       (ID_DLMErrorBase + 9)
#define ID_DLMSessNO        (ID_DLMErrorBase + 10)
#define ID_DLMConnNIU       (ID_DLMErrorBase + 11)
#define ID_DLMConnNO        (ID_DLMErrorBase + 12)
#define ID_DLMIDErr         (ID_DLMErrorBase + 13)
#define ID_DLMConnErr       (ID_DLMErrorBase + 14)
#define ID_DLMSessErr       (ID_DLMErrorBase + 15)
#define ID_DLMSessNF        (ID_DLMErrorBase + 16)
#define ID_DLMNoFreeConn    (ID_DLMErrorBase + 17)
#define ID_DLMConnCloseErr  (ID_DLMErrorBase + 18)
#define ID_DLMConnNF        (ID_DLMErrorBase + 19)
#define ID_DLMConnNC        (ID_DLMErrorBase + 20)
#define ID_DLMMDMError      (ID_DLMErrorBase + 21)
#define ID_DLMNoSess        (ID_DLMErrorBase + 22)
#define ID_DLMInvalidSess   (ID_DLMErrorBase + 23)
#define ID_DLMEventErr      (ID_DLMErrorBase + 24)
#define ID_DLMNoConn        (ID_DLMErrorBase + 25)
#define ID_DLMChanCloseErr  (ID_DLMErrorBase + 26) 
#define ID_DLMInvalidConn   (ID_DLMErrorBase + 27)
#define ID_DLMCorruptQueue  (ID_DLMErrorBase + 28)
#define ID_DLMInvChanID     (ID_DLMErrorBase + 29)
#define ID_DLMChanInUse     (ID_DLMErrorBase + 30)
#define ID_DLMInvalidChan   (ID_DLMErrorBase + 31)
#define ID_DLMNoBufHdr      (ID_DLMErrorBase + 32)
#define ID_DLMEnqueueErr    (ID_DLMErrorBase + 33)
#define ID_DLMNMBufInProg   (ID_DLMErrorBase + 34)
#define ID_DLMNoBuffer      (ID_DLMErrorBase + 35)
#define ID_DLMEnterDumping  (ID_DLMErrorBase + 36)
#define ID_DLMSizeError     (ID_DLMErrorBase + 37)
#define ID_DLMNoBuf         (ID_DLMErrorBase + 38)
#define ID_DLMInitAlready   (ID_DLMErrorBase + 39)
#define ID_DLMGDLError      (ID_DLMErrorBase + 40)
#define ID_DLMNoEntryPoint  (ID_DLMErrorBase + 41)
#define ID_DLMNoEvent       (ID_DLMErrorBase + 42)
#define ID_DLMNoPackets     (ID_DLMErrorBase + 43)

// Debug level 1 messages
#define ID_DLMDebug1Base         500
#define ID_DLMCloseAllEntered    (ID_DLMDebug1Base + 1)
#define ID_DLMEstabHEntered      (ID_DLMDebug1Base + 2)
#define ID_DLMEstabHExit         (ID_DLMDebug1Base + 3)
#define ID_DLMReqHEntered        (ID_DLMDebug1Base + 4)
#define ID_DLMReqHAlloc          (ID_DLMDebug1Base + 5)
#define ID_DLMReqHExit           (ID_DLMDebug1Base + 6)
#define ID_DLMRejHEntered        (ID_DLMDebug1Base + 7)
#define ID_DLMRejHExit           (ID_DLMDebug1Base + 8)
#define ID_DLMCNoteHEntered      (ID_DLMDebug1Base + 9)
#define ID_DLMCNoteHExit         (ID_DLMDebug1Base + 10)
#define ID_DLMCComHEntered       (ID_DLMDebug1Base + 11)
#define ID_DLMCComHExit          (ID_DLMDebug1Base + 12)
#define ID_DLMSessCloseHEntered  (ID_DLMDebug1Base + 13)
#define ID_DLMSessCloseHExit     (ID_DLMDebug1Base + 14)
#define ID_DLMSessHEntered       (ID_DLMDebug1Base + 15)
#define ID_DLMSessHExit          (ID_DLMDebug1Base + 16)
#define ID_DLMBegSessEntered     (ID_DLMDebug1Base + 17)
#define ID_DLMBegSessExit        (ID_DLMDebug1Base + 18)
#define ID_DLMEndSessEntered     (ID_DLMDebug1Base + 19)
#define ID_DLMEndSessExit        (ID_DLMDebug1Base + 20)
#define ID_DLMListenEntered      (ID_DLMDebug1Base + 21)
#define ID_DLMListenExit         (ID_DLMDebug1Base + 22)
#define ID_DLMDoCloseEntered     (ID_DLMDebug1Base + 23)
#define ID_DLMDoCloseExit        (ID_DLMDebug1Base + 24)
#define ID_DLMMakeConnEntered    (ID_DLMDebug1Base + 25)
#define ID_DLMMakeConnExit       (ID_DLMDebug1Base + 26)
#define ID_DLMRejEntered         (ID_DLMDebug1Base + 27)
#define ID_DLMRejExit            (ID_DLMDebug1Base + 28)
#define ID_DLMAccEntered         (ID_DLMDebug1Base + 29)
#define ID_DLMAccExit            (ID_DLMDebug1Base + 30)
#define ID_DLMCloseConnEntered   (ID_DLMDebug1Base + 31)
#define ID_DLMCloseConnExit      (ID_DLMDebug1Base + 32)
#define ID_DLMTryEntered         (ID_DLMDebug1Base + 33)
#define ID_DLMTryExit            (ID_DLMDebug1Base + 34)
#define ID_DLMOpenEntered        (ID_DLMDebug1Base + 35)
#define ID_DLMOpenExit           (ID_DLMDebug1Base + 36)
#define ID_DLMSendEntered        (ID_DLMDebug1Base + 37)
#define ID_DLMSendExit           (ID_DLMDebug1Base + 38)
#define ID_DLMSendComEntered     (ID_DLMDebug1Base + 39)
#define ID_DLMSendComExit        (ID_DLMDebug1Base + 40)
#define ID_DLMPostEntered        (ID_DLMDebug1Base + 41)
#define ID_DLMPostExit           (ID_DLMDebug1Base + 42)
#define ID_DLMNewMsgEntered      (ID_DLMDebug1Base + 43)
#define ID_DLMNewMsgExit         (ID_DLMDebug1Base + 44)
#define ID_DLMContMsgEntered     (ID_DLMDebug1Base + 45)
#define ID_DLMContMsgExit        (ID_DLMDebug1Base + 46)
#define ID_DLMRecEntered         (ID_DLMDebug1Base + 47)
#define ID_DLMRecExit            (ID_DLMDebug1Base + 48)
#define ID_DLMCloseEntered       (ID_DLMDebug1Base + 49)
#define ID_DLMCloseExit          (ID_DLMDebug1Base + 50)
#define ID_DLMGetCharEntered     (ID_DLMDebug1Base + 51)
#define ID_DLMGetCharExit        (ID_DLMDebug1Base + 52)
#define ID_DLMInitEntered        (ID_DLMDebug1Base + 53)
#define ID_DLMInitExit           (ID_DLMDebug1Base + 54)
#define ID_DLMDeInitEntered      (ID_DLMDebug1Base + 55)
#define ID_DLMDeInitExit         (ID_DLMDebug1Base + 56)
#define ID_DLMCloseAllExit       (ID_DLMDebug1Base + 57)
#define ID_DLMEnqEntered         (ID_DLMDebug1Base + 58)
#define ID_DLMEnqExit            (ID_DLMDebug1Base + 59)
#define ID_DLMDeqEntered         (ID_DLMDebug1Base + 60)
#define ID_DLMDeqExit            (ID_DLMDebug1Base + 61)
#define ID_DLMEnqPEntered        (ID_DLMDebug1Base + 62)
#define ID_DLMEnqPExit           (ID_DLMDebug1Base + 63)


// Debug level 2 messages
#define ID_DLMDebug2Base         600
#define ID_DLMCallback           (ID_DLMDebug2Base + 1)
#define ID_DLMConnection         (ID_DLMDebug2Base + 2)
#define ID_DLMBuffer             (ID_DLMDebug2Base + 3)
#define ID_DLMSize               (ID_DLMDebug2Base + 4)
#define ID_DLMRemaining          (ID_DLMDebug2Base + 5)
#define ID_DLMReceived           (ID_DLMDebug2Base + 6)
#define ID_DLMToken              (ID_DLMDebug2Base + 7)
#define ID_DLMOChannel           (ID_DLMDebug2Base + 8)
#define ID_DLMRChannel           (ID_DLMDebug2Base + 9)
#define ID_DLMStatus             (ID_DLMDebug2Base + 10)
#define ID_DLMEndSessClosing     (ID_DLMDebug2Base + 11)
#define ID_DLMBufferSize         (ID_DLMDebug2Base + 12)
#define ID_DLMLinkPacket         (ID_DLMDebug2Base + 13)
#define ID_DLMChannel            (ID_DLMDebug2Base + 14)
#define ID_DLMInDumping          (ID_DLMDebug2Base + 15)
#define ID_DLMByteCount          (ID_DLMDebug2Base + 16)
#define ID_DLMDeqNoBuf           (ID_DLMDebug2Base + 17)
#define ID_DLMEnqPSkip           (ID_DLMDebug2Base + 18)


//------------------------------------------------------------------------------
// MDM -> mdmnbios.dll

#define ID_mdmBase				700
#define ID_mdmLibMain			(ID_mdmBase + 1)
#define ID_mdmWep				(ID_mdmBase + 2)
#define ID_mdmBadhSesUser		(ID_mdmBase + 3)
#define ID_mdmBadhConUser		(ID_mdmBase + 4)
#define ID_mdmBadhSesFree		(ID_mdmBase + 5)
#define ID_mdmBadhConFree		(ID_mdmBase + 6)
#define ID_mdmBadhSesInt		(ID_mdmBase + 7)
#define ID_mdmBadhConInt		(ID_mdmBase + 8)
#define ID_mdmNoMorehSes		(ID_mdmBase + 9)
#define ID_mdmNoMorehCon		(ID_mdmBase + 10)
#define ID_mdmWepConFree		(ID_mdmBase + 11)
#define ID_mdmActiveCon			(ID_mdmBase + 12)
#define ID_mdmBBegSes			(ID_mdmBase + 13)
#define ID_mdmEBegSes			(ID_mdmBase + 14)
#define ID_mdmBEndSes			(ID_mdmBase + 15)
#define ID_mdmEEndSes			(ID_mdmBase + 16)
#define ID_mdmBListen			(ID_mdmBase + 17)
#define ID_mdmEListen			(ID_mdmBase + 18)
#define ID_mdmBMakeCon			(ID_mdmBase + 19)
#define ID_mdmEMakeCon			(ID_mdmBase + 20)
#define ID_mdmBAcceptCon		(ID_mdmBase + 21)
#define ID_mdmEAcceptCon		(ID_mdmBase + 22)
#define ID_mdmBRejectCon		(ID_mdmBase + 23)
#define ID_mdmERejectCon		(ID_mdmBase + 24)
#define ID_mdmBCloseCon			(ID_mdmBase + 25)
#define ID_mdmECloseCon			(ID_mdmBase + 26)
#define ID_mdmErrNetBios		(ID_mdmBase + 27)
#define ID_mdmNoSendNcb			(ID_mdmBase + 28)
#define ID_mdmNoFreeSndNcbSlot	(ID_mdmBase + 29)
#define ID_mdmInvalidConState	(ID_mdmBase + 30)
#define ID_mdmInvalidParams		(ID_mdmBase + 31)
#define ID_mdmToManyListens		(ID_mdmBase + 32)
#define ID_mdmKillTheListen		(ID_mdmBase + 33)
#define ID_mdmBListenCB			(ID_mdmBase + 34)
#define ID_mdmEListenCB			(ID_mdmBase + 35)
#define ID_mdmBConnectCB		(ID_mdmBase + 36)
#define ID_mdmEConnectCB		(ID_mdmBase + 37)
#define ID_mdmBCloseCB			(ID_mdmBase + 38)
#define ID_mdmECloseCB			(ID_mdmBase + 39)
#define ID_mdmBSndCB			(ID_mdmBase + 40)
#define ID_mdmESndCB			(ID_mdmBase + 41)
#define ID_mdmBRcvCB			(ID_mdmBase + 42)
#define ID_mdmERcvCB			(ID_mdmBase + 43)


//---------------------------------------------------------------------------------
// MDM -> MDM Teleos

// Errors
#define ID_MDMTEBASE               1000
#define ID_MDMTEDeqUnackNoHead     (ID_MDMTEBASE + 1)
#define ID_MDMTEDeqUnackNoNext     (ID_MDMTEBASE + 2)
#define ID_MDMTEDeqUnackNoPrev     (ID_MDMTEBASE + 3)
#define ID_MDMTEDeqArrNoTail       (ID_MDMTEBASE + 4)
#define ID_MDMTENullTCB            (ID_MDMTEBASE + 5)
#define ID_MDMTETCBRet             (ID_MDMTEBASE + 6)
#define ID_MDMTEWinSize            (ID_MDMTEBASE + 7)
#define ID_MDMTENoLinkPacket       (ID_MDMTEBASE + 8)
#define ID_MDMTETooLarge           (ID_MDMTEBASE + 9)
#define ID_MDMTELPNotFound         (ID_MDMTEBASE + 10)
#define ID_MDMTENoTCB              (ID_MDMTEBASE + 11)
#define ID_MDMTEInitAlready        (ID_MDMTEBASE + 12)
#define ID_MDMTETCBInitFail        (ID_MDMTEBASE + 13)
#define ID_MDMTELSNErr             (ID_MDMTEBASE + 14)
#define ID_MDMTESizeError          (ID_MDMTEBASE + 15)
#define ID_MDMTEReceived           (ID_MDMTEBASE + 16)
#define ID_MDMTEExpected           (ID_MDMTEBASE + 17)
#define ID_MDMTECorruptQ           (ID_MDMTEBASE + 18)
#define ID_MDMTENoInit             (ID_MDMTEBASE + 19)
#define ID_MDMTEAbanPack           (ID_MDMTEBASE + 20)
#define ID_MDMTESeqNum             (ID_MDMTEBASE + 21)
#define ID_MDMTESipPend            (ID_MDMTEBASE + 22)
#define ID_MDMTENoConn             (ID_MDMTEBASE + 23)
#define ID_MDMTEInvalidID          (ID_MDMTEBASE + 24)
#define ID_MDMTENoSess             (ID_MDMTEBASE + 25)
#define ID_MDMTENoLPM              (ID_MDMTEBASE + 26)
#define ID_MDMTESessID             (ID_MDMTEBASE + 27)
#define ID_MDMTESessNIU            (ID_MDMTEBASE + 28)
#define ID_MDMTESize               (ID_MDMTEBASE + 29)
#define ID_MDMTEState              (ID_MDMTEBASE + 30)
#define ID_MDMTEConnID             (ID_MDMTEBASE + 31)
#define ID_MDMTEConnNIU            (ID_MDMTEBASE + 32)
#define ID_MDMTETinyPacket         (ID_MDMTEBASE + 33)
#define ID_MDMTEPacketOOS          (ID_MDMTEBASE + 34)
#define ID_MDMTEECBNotFound        (ID_MDMTEBASE + 35)

// Trace Information
#define ID_MDMTTBASE               1100
#define ID_MDMTTB1CEnter         (ID_MDMTTBASE + 1)
#define ID_MDMTTB1CExit          (ID_MDMTTBASE + 2)
#define ID_MDMTTSB1Enter         (ID_MDMTTBASE + 3)
#define ID_MDMTTSB1Exit          (ID_MDMTTBASE + 4)
#define ID_MDMTTB2CEnter         (ID_MDMTTBASE + 5)
#define ID_MDMTTB2CExit          (ID_MDMTTBASE + 6)
#define ID_MDMTTSB2Enter         (ID_MDMTTBASE + 7)
#define ID_MDMTTSB2Exit          (ID_MDMTTBASE + 8)
#define ID_MDMTTSendEnter        (ID_MDMTTBASE + 9)
#define ID_MDMTTSendExit         (ID_MDMTTBASE + 10)
#define ID_MDMTTInitEnter        (ID_MDMTTBASE + 11)
#define ID_MDMTTInitExit         (ID_MDMTTBASE + 12)
#define ID_MDMTTDeInitEnter      (ID_MDMTTBASE + 13)
#define ID_MDMTTDeInitExit       (ID_MDMTTBASE + 14)
#define ID_MDMTTLB1Enter         (ID_MDMTTBASE + 15)
#define ID_MDMTTLB1Exit          (ID_MDMTTBASE + 16)
#define ID_MDMTTLB2Enter         (ID_MDMTTBASE + 17)
#define ID_MDMTTLB2Exit          (ID_MDMTTBASE + 18)
#define ID_MDMTTNBSEnter         (ID_MDMTTBASE + 19)
#define ID_MDMTTNBSExit          (ID_MDMTTBASE + 20)
#define ID_MDMTTRecEnter         (ID_MDMTTBASE + 21)
#define ID_MDMTTRecExit          (ID_MDMTTBASE + 22)
#define ID_MDMTTCTSEnter         (ID_MDMTTBASE + 23)
#define ID_MDMTTCTSExit          (ID_MDMTTBASE + 24)
#define ID_MDMTTGCEnter          (ID_MDMTTBASE + 25)
#define ID_MDMTTGCExit           (ID_MDMTTBASE + 26)
#define ID_MDMTTBegSessEnter     (ID_MDMTTBASE + 27)
#define ID_MDMTTBegSessExit      (ID_MDMTTBASE + 28)
#define ID_MDMTTEndSessEnter     (ID_MDMTTBASE + 29)
#define ID_MDMTTEndSessExit      (ID_MDMTTBASE + 30)
#define ID_MDMTTMakeConEnter     (ID_MDMTTBASE + 31)
#define ID_MDMTTMakeConExit      (ID_MDMTTBASE + 32)
#define ID_MDMTTCloseConEnter    (ID_MDMTTBASE + 33)
#define ID_MDMTTCloseConExit     (ID_MDMTTBASE + 34)
#define ID_MDMTTListEnter        (ID_MDMTTBASE + 35)
#define ID_MDMTTListExit         (ID_MDMTTBASE + 36)
#define ID_MDMTTAccEnter         (ID_MDMTTBASE + 37)
#define ID_MDMTTAccExit          (ID_MDMTTBASE + 38)
#define ID_MDMTTRejEnter         (ID_MDMTTBASE + 39)
#define ID_MDMTTRejExit          (ID_MDMTTBASE + 40)
#define ID_MDMTTRecLookEnter     (ID_MDMTTBASE + 41)
#define ID_MDMTTRecLookExit      (ID_MDMTTBASE + 42)

// Comment Information
#define ID_MDMTCBASE               1200
#define ID_MDMTCSeqNum             (ID_MDMTCBASE + 1)
#define ID_MDMTCFound              (ID_MDMTCBASE + 2)
#define ID_MDMTCWaiting            (ID_MDMTCBASE + 3)
#define ID_MDMTCCTSFail            (ID_MDMTCBASE + 4)
#define ID_MDMTCCTSPass            (ID_MDMTCBASE + 5)
#define ID_MDMTCCTSize             (ID_MDMTCBASE + 6)
#define ID_MDMTCCTSOut             (ID_MDMTCBASE + 7)
#define ID_MDMTCTCB                (ID_MDMTCBASE + 8)
#define ID_MDMTCECBPMAddr          (ID_MDMTCBASE + 9)
#define ID_MDMTCECBRMAddr          (ID_MDMTCBASE + 10)

#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus

#endif	// h file included already
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\ph\ppmclsid.h ===
/****************************************************************************
 *  $Header:   J:\rtp\src\include\ppmclsid.h_v   1.11   03 Mar 1997 16:52:34   lscline  $ 
 *
 *  INTEL Corporation Proprietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *  Copyright (c) 1995, 1996 Intel Corporation. All rights reserved.
 *
 *  $Revision:   1.11  $
 *  $Date:   03 Mar 1997 16:52:34  $
 *  $Author:   lscline  $
 *
 *  Log at end of file.
 *
 *  Module Name:   PPMGUID.h
 *  Abstract:       PPM Class Ids
 *  Environment:    MSVC 4.0, OLE 2
 *  Notes:
 *      This file should be included in exactly one source file per module
 *      after '#include <initguid.h>' and '#define INITGUID' to define the
 *      GUIDs, and in other source files without '#include <initguid.h>'
 *      to declare them. This file is included in psavcomp.h so it does not
 *      need to be explicitly included for the declarations.
 *
 ***************************************************************************/
#ifndef PPMCLSID_H
#define PPMCLSID_H


/////////////////////////////////////////////////////////////////////////////
// Class ids
//

#ifndef USE_OLD_CLSIDS

// {4AFBBA8C-FE10-11d0-B607-00C04FB6E866}
DEFINE_GUID(CLSID_GenPPMSend, 
0x4afbba8c, 0xfe10, 0x11d0, 0xb6, 0x7, 0x0, 0xc0, 0x4f, 0xb6, 0xe8, 0x66);

// {4AFBBA8D-FE10-11d0-B607-00C04FB6E866}
DEFINE_GUID(CLSID_GenPPMReceive, 
0x4afbba8d, 0xfe10, 0x11d0, 0xb6, 0x7, 0x0, 0xc0, 0x4f, 0xb6, 0xe8, 0x66);

// {4AFBBA8E-FE10-11d0-B607-00C04FB6E866}
DEFINE_GUID(CLSID_H261PPMSend, 
0x4afbba8e, 0xfe10, 0x11d0, 0xb6, 0x7, 0x0, 0xc0, 0x4f, 0xb6, 0xe8, 0x66);

// {4AFBBA8F-FE10-11d0-B607-00C04FB6E866}
DEFINE_GUID(CLSID_H261PPMReceive, 
0x4afbba8f, 0xfe10, 0x11d0, 0xb6, 0x7, 0x0, 0xc0, 0x4f, 0xb6, 0xe8, 0x66);

// {4AFBBA90-FE10-11d0-B607-00C04FB6E866}
DEFINE_GUID(CLSID_H263PPMSend, 
0x4afbba90, 0xfe10, 0x11d0, 0xb6, 0x7, 0x0, 0xc0, 0x4f, 0xb6, 0xe8, 0x66);

// {4AFBBA91-FE10-11d0-B607-00C04FB6E866}
DEFINE_GUID(CLSID_H263PPMReceive, 
0x4afbba91, 0xfe10, 0x11d0, 0xb6, 0x7, 0x0, 0xc0, 0x4f, 0xb6, 0xe8, 0x66);

// {4AFBBA92-FE10-11d0-B607-00C04FB6E866}
DEFINE_GUID(CLSID_G711PPMSend, 
0x4afbba92, 0xfe10, 0x11d0, 0xb6, 0x7, 0x0, 0xc0, 0x4f, 0xb6, 0xe8, 0x66);

// {4AFBBA93-FE10-11d0-B607-00C04FB6E866}
DEFINE_GUID(CLSID_G711PPMReceive, 
0x4afbba93, 0xfe10, 0x11d0, 0xb6, 0x7, 0x0, 0xc0, 0x4f, 0xb6, 0xe8, 0x66);

// {4AFBBA94-FE10-11d0-B607-00C04FB6E866}
DEFINE_GUID(CLSID_G723PPMSend, 
0x4afbba94, 0xfe10, 0x11d0, 0xb6, 0x7, 0x0, 0xc0, 0x4f, 0xb6, 0xe8, 0x66);

// {4AFBBA95-FE10-11d0-B607-00C04FB6E866}
DEFINE_GUID(CLSID_G723PPMReceive, 
0x4afbba95, 0xfe10, 0x11d0, 0xb6, 0x7, 0x0, 0xc0, 0x4f, 0xb6, 0xe8, 0x66);

// {4AFBBA96-FE10-11d0-B607-00C04FB6E866}
DEFINE_GUID(CLSID_IV41PPMSend, 
0x4afbba96, 0xfe10, 0x11d0, 0xb6, 0x7, 0x0, 0xc0, 0x4f, 0xb6, 0xe8, 0x66);

// {4AFBBA97-FE10-11d0-B607-00C04FB6E866}
DEFINE_GUID(CLSID_IV41PPMReceive, 
0x4afbba97, 0xfe10, 0x11d0, 0xb6, 0x7, 0x0, 0xc0, 0x4f, 0xb6, 0xe8, 0x66);

// {4AFBBA98-FE10-11d0-B607-00C04FB6E866}
DEFINE_GUID(CLSID_G711APPMSend, 
0x4afbba98, 0xfe10, 0x11d0, 0xb6, 0x7, 0x0, 0xc0, 0x4f, 0xb6, 0xe8, 0x66);

// {4AFBBA99-FE10-11d0-B607-00C04FB6E866}
DEFINE_GUID(CLSID_G711APPMReceive, 
0x4afbba99, 0xfe10, 0x11d0, 0xb6, 0x7, 0x0, 0xc0, 0x4f, 0xb6, 0xe8, 0x66);

// {4AFBBA9B-FE10-11d0-B607-00C04FB6E866}
DEFINE_GUID(CLSID_LHPPMReceive, 
0x4afbba9b, 0xfe10, 0x11d0, 0xb6, 0x7, 0x0, 0xc0, 0x4f, 0xb6, 0xe8, 0x66);

// {4AFBBA9A-FE10-11d0-B607-00C04FB6E866}
DEFINE_GUID(CLSID_LHPPMSend,
0x4afbba9a, 0xfe10, 0x11d0, 0xb6, 0x7, 0x0, 0xc0, 0x4f, 0xb6, 0xe8, 0x66);

// {4AFBBA9C-FE10-11d0-B607-00C04FB6E866}
DEFINE_GUID(CLSID_IMCPPMSend, 
0x4afbba9c, 0xfe10, 0x11d0, 0xb6, 0x7, 0x0, 0xc0, 0x4f, 0xb6, 0xe8, 0x66);

// {4AFBBA9D-FE10-11d0-B607-00C04FB6E866}
DEFINE_GUID(CLSID_IMCPPMReceive, 
0x4afbba9d, 0xfe10, 0x11d0, 0xb6, 0x7, 0x0, 0xc0, 0x4f, 0xb6, 0xe8, 0x66);

// {4AFBBA9E-FE10-11d0-B607-00C04FB6E866}
DEFINE_GUID(CLSID_GEN_A_PPMSend, 
0x4afbba9e, 0xfe10, 0x11d0, 0xb6, 0x7, 0x0, 0xc0, 0x4f, 0xb6, 0xe8, 0x66);

// {4AFBBA9F-FE10-11d0-B607-00C04FB6E866}
DEFINE_GUID(CLSID_GEN_A_PPMReceive, 
0x4afbba9f, 0xfe10, 0x11d0, 0xb6, 0x7, 0x0, 0xc0, 0x4f, 0xb6, 0xe8, 0x66);

#else // #ifndef USE_OLD_CLSIDS

// {1df95360-f1fe-11cf-ba07-00aa003419d3}
DEFINE_GUID( CLSID_GenPPMSend,			 0x1df95360,0xf1fe,0x11cf,  0xba, 0x07, 0x00, 0xaa, 0x00, 0x34, 0x19, 0xd3);

// {1df95361-f1fe-11cf-ba07-00aa003419d3}
DEFINE_GUID( CLSID_GenPPMReceive,		0x1df95361, 0xf1fe,0x11cf, 0xba, 0x07, 0x00, 0xaa, 0x00, 0x34, 0x19, 0xd3);

// {1df95362-f1fe-11cf-ba07-00aa003419d3}
DEFINE_GUID( CLSID_H261PPMSend,			0x1df95362,0xf1fe, 0x11cf, 0xba, 0x07, 0x00, 0xaa, 0x00, 0x34, 0x19, 0xd3);

// {1df95363-f1fe-11cf-ba07-00aa003419d3}
DEFINE_GUID( CLSID_H261PPMReceive,		0x1df95363,0xf1fe, 0x11cf, 0xba, 0x07, 0x00, 0xaa, 0x00, 0x34, 0x19, 0xd3);

// {1df95364-f1fe-11cf-ba07-00aa003419d3 }
DEFINE_GUID( CLSID_H263PPMSend,			0x1df95364,0xf1fe, 0x11cf, 0xba, 0x07, 0x00, 0xaa, 0x00, 0x34, 0x19, 0xd3);

// {1df95365-f1fe-11cf-ba07-00aa003419d3}
DEFINE_GUID( CLSID_H263PPMReceive,		0x1df95365, 0xf1fe, 0x11cf, 0xba, 0x07, 0x00, 0xaa, 0x00, 0x34, 0x19, 0xd3);

// {1df95366-f1fe-11cf-ba07-00aa003419d3}
DEFINE_GUID( CLSID_G711PPMSend,			0x1df95366,	0xf1fe, 0x11cf,  0xba, 0x07, 0x00, 0xaa, 0x00, 0x34, 0x19, 0xd3);

// {1df95367-f1fe-11cf-ba07-00aa003419d3}
DEFINE_GUID( CLSID_G711PPMReceive,		0x1df95367, 0xf1fe, 0x11cf,  0xba, 0x07, 0x00, 0xaa, 0x00, 0x34, 0x19, 0xd3);

// {1df95368-f1fe-11cf-ba07-00aa003419d3}
DEFINE_GUID( CLSID_G723PPMSend,			0x1df95368,	0xf1fe, 0x11cf, 0xba, 0x07, 0x00, 0xaa, 0x00, 0x34, 0x19, 0xd3);

// {1df95369-f1fe-11cf-ba07-00aa003419d3}
DEFINE_GUID( CLSID_G723PPMReceive,		0x1df95369, 0xf1fe, 0x11cf, 0xba, 0x07, 0x00, 0xaa, 0x00, 0x34, 0x19, 0xd3);

// {1df9536a-f1fe-11cf-ba07-00aa003419d3}
DEFINE_GUID( CLSID_IV41PPMSend,			0x1df9536a, 0xf1fe, 0x11cf, 0xba, 0x07, 0x00, 0xaa, 0x00, 0x34, 0x19, 0xd3);

// {1df9536b-f1fe-11cf-ba07-00aa003419d3}
DEFINE_GUID( CLSID_IV41PPMReceive,		0x1df9536b, 0xf1fe, 0x11cf, 0xba, 0x07, 0x00, 0xaa, 0x00, 0x34, 0x19, 0xd3);

// {1df9536c-f1fe-11cf-ba07-00aa003419d3}
DEFINE_GUID( CLSID_G711APPMSend,		0x1df9536c,	0xf1fe, 0x11cf, 0xba, 0x07, 0x00, 0xaa, 0x00, 0x34, 0x19, 0xd3);

// {1df9536d-f1fe-11cf-ba07-00aa003419d3}
DEFINE_GUID( CLSID_G711APPMReceive,		0x1df9536d,	0xf1fe, 0x11cf, 0xba, 0x07, 0x00, 0xaa, 0x00, 0x34, 0x19, 0xd3);

// {1df9536e-f1fe-11cf-ba07-00aa003419d3}
DEFINE_GUID( CLSID_LHPPMSend,			0x1df9536e,	0xf1fe, 0x11cf, 0xba, 0x07, 0x00, 0xaa, 0x00, 0x34, 0x19, 0xd3);

// {1df9536f-f1fe-11cf-ba07-00aa003419d3}
DEFINE_GUID( CLSID_LHPPMReceive,		0x1df9536f,	0xf1fe, 0x11cf, 0xba, 0x07, 0x00, 0xaa, 0x00, 0x34, 0x19, 0xd3);

// {E7FD6DC1-7383-11d0-BA07-00AA003419D3}
DEFINE_GUID( CLSID_IMCPPMSend,			0xe7fd6dc1, 0x7383, 0x11d0, 0xba, 0x7, 0x0, 0xaa, 0x0, 0x34, 0x19, 0xd3);

// {E7FD6DC2-7383-11d0-BA07-00AA003419D3}
DEFINE_GUID( CLSID_IMCPPMReceive,		0xe7fd6dc2, 0x7383, 0x11d0, 0xba, 0x7, 0x0, 0xaa, 0x0, 0x34, 0x19, 0xd3);

// {0DE58B60-8E66-11d0-BA07-00AA003419D3}
DEFINE_GUID(CLSID_GEN_A_PPMSend,		0xde58b60, 0x8e66, 0x11d0, 0xba, 0x7, 0x0, 0xaa, 0x0, 0x34, 0x19, 0xd3);

// {0DE58B61-8E66-11d0-BA07-00AA003419D3}
DEFINE_GUID(CLSID_GEN_A_PPMReceive,		0xde58b61, 0x8e66, 0x11d0, 0xba, 0x7, 0x0, 0xaa, 0x0, 0x34, 0x19, 0xd3);

#endif // #ifndef USE_OLD_CLSIDS

#endif //PPMGUID
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\ph\isubmit.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 11/95 Intel Corporation. 
//
//
//  Module Name: isubmit.h
//  Abstract:    Header file for Generic Submit Interfaces
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////

#ifndef ISUBMIT_H
#define ISUBMIT_H

#include <winsock2.h>

#ifdef __cplusplus
#define DEFAULT_PARAM_ZERO	=0
#else
#define DEFAULT_PARAM_ZERO
#endif

//Interfaces
#undef INTERFACE
#define INTERFACE ISubmitCallback

DECLARE_INTERFACE_(ISubmitCallback,IUnknown) 
{ 
  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj)PURE;
  STDMETHOD_(ULONG,AddRef)(THIS)PURE;
  STDMETHOD_(ULONG,Release)(THIS)PURE;

  STDMETHOD_(void,SubmitComplete)(THIS_ void *pUserToken, HRESULT Error)PURE;	
  STDMETHOD_(void,ReportError)(THIS_ HRESULT Error, int DEFAULT_PARAM_ZERO)PURE;
};

#undef INTERFACE
#define INTERFACE ISubmit
DECLARE_INTERFACE_(ISubmit,IUnknown)
{
  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj)PURE;
  STDMETHOD_(ULONG,AddRef)(THIS)PURE;
  STDMETHOD_(ULONG,Release)(THIS)PURE;

  STDMETHOD(InitSubmit)(THIS_ ISubmitCallback *pSubmitCallback)PURE;
  STDMETHOD(Submit)(THIS_ WSABUF *pWSABuffer, DWORD BufferCount, 
						void *pUserToken, HRESULT Error)PURE;
  STDMETHOD_(void,ReportError)(THIS_ HRESULT Error)PURE;
  STDMETHOD(Flush)(THIS)PURE;
};

#undef INTERFACE
#define INTERFACE ISubmitUser
DECLARE_INTERFACE_(ISubmitUser,IUnknown)
{
  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj)PURE;
  STDMETHOD_(ULONG,AddRef)(THIS)PURE;
  STDMETHOD_(ULONG,Release)(THIS)PURE;

  STDMETHOD(SetOutput)(THIS_ IUnknown *pSubmit)PURE;
};
		 

/////////////////////////////////////////////////////////////////////////////
// Interface ids
// 
// {A92D97A1-66CD-11cf-B9BA-00AA00A89C1D}
DEFINE_GUID( IID_ISubmitCallback,	0xa92d97a1, 0x66cd, 0x11cf, 0xb9, 0xba, 0x0, 0xaa, 0x0, 0xa8, 0x9c, 0x1d);

// {A92D97A2-66CD-11cf-B9BA-00AA00A89C1D}
DEFINE_GUID( IID_ISubmit,			0xa92d97a2, 0x66cd, 0x11cf, 0xb9, 0xba, 0x0, 0xaa, 0x0, 0xa8, 0x9c, 0x1d);

// {0C1EA742-C917-11cf-A9C3-00AA00A4BE0C}
DEFINE_GUID( IID_ISubmitUser,       0xc1ea742, 0xc917, 0x11cf, 0xa9, 0xc3, 0x0, 0xaa, 0x0, 0xa4, 0xbe, 0xc);

#endif /* ISUBMIT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\ph\ppmerr.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//  Module Name: ppmerr.h
//  Abstract:    Contains error codes and error macro for ppm dll.
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////


#ifndef PPMERR_H
#define PPMERR_H

// #define MAKE_CUSTOM_HRESULT(sev,cus,fac,code) \
// ((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(cus)<<29) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )

// #define FACILITY_PPM  0x8004 - Illegal to define our own facility. Have to use FACILITY_ITF
#define PPMERR(error) MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, error )

// OLE2 mandates that interface specific error codes
// be HRESULTs of type FACILITY_ITF (eg, 0x8004 for the
// first two bytes) and that the second two bytes be
// in the range of 0x0200 to 0xFFFF. I've arbitrarily
// chosed 0x1000 as the lower two bytes for the PPM,
// as I chose 0xBB00- arbitrarily as a value within 
// that range. Note that OLE2 explicitly states that two 
// different interfaces may return numerically identical error 
// values, so it is critical that an app not only take into 
// account the numerical value of a returned error code but 
// the function & interface which returned the error as well.
#define PPM_E_FAIL           0xBB01
#define PPM_E_CORRUPTED      0xBB02
#define PPM_E_EMPTYQUE       0xBB03
#define PPM_E_OUTOFMEMORY    0xBB04
#define PPM_E_NOTIMPL        0xBB05
#define PPM_E_DUPLICATE      0xBB06
#define PPM_E_INVALID_PARAM  0xBB07
#define PPM_E_DROPFRAME      0xBB08
#define PPM_E_PARTIALFRAME   0xBB09
#define PPM_E_DROPFRAG       0xBB0A
#define PPM_E_CLIENTERR	     0xBB0B

// Note that we can't legally use flags in the error code
// part of a returned HRESULT.  So what we do instead is
// define a flag that is internally used, then define new
// HRESULTs for each error code that can be returned with
// the flag bit.
#define PPM_FLAG_IO_PENDING	 0x0080
#define PPM_E_FAIL_PARTIAL          (PPM_E_FAIL        | PPM_FLAG_IO_PENDING)
#define PPM_E_OUTOFMEMORY_PARTIAL   (PPM_E_OUTOFMEMORY | PPM_FLAG_IO_PENDING)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\ph\rtpclass.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: rtpclass.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////

#ifndef RTPCLASS_H
#define RTPCLASS_H

#ifdef _DEBUG
#include <rtp.h>
//#include "..\..\rrcm\rrcminc\rrcm.h"
#endif

//Note:  RTP header data generated by PPM are in network order

class RTP_Header {
public:
        enum { fixed_header_size = 12 };

private:
#if defined(_DEBUG) && !defined(MICROSOFT) && defined(_0_)
        union {
            unsigned char bytes[fixed_header_size];
            RTP_HDR_T     header;       /* This is here for convenience in debugging only */
        };
#else
        unsigned char bytes[fixed_header_size];
#endif

public:
        int v() const { return (bytes[0] >> 6) & 3; }
        void set_v(int v) { bytes[0] = (bytes[0] & 0x3f) | ((v & 3) << 6); }
        
        int p() const { return (bytes[0] >> 5) & 1; }
        void set_p(int v) { bytes[0] = (bytes[0] & 0xdf) | ((v & 1) << 5); }
        
        int x() const { return (bytes[0] >> 4) & 1; }
        void set_x(int v) { bytes[0] = (bytes[0] & 0xef) | ((v & 1) << 4); }
        
        int cc() const { return bytes[0] & 0x0f; }
        void set_cc(int v) { bytes[0] = (bytes[0] & 0xf0) | (v & 0x0f); }
        
        int m() const { return (bytes[1] >> 7) & 1; }
        void set_m(int v) { bytes[1] = (bytes[1] & 0x7f) | ((v & 1) << 7); }
        
        int pt() const { return (bytes[1] & 0x7f); }
        void set_pt(int v) { bytes[1] = (bytes[1] & 0x80) | (v & 0x7f); }
        
        unsigned short seq() const { return bytes[2] << 8 | bytes[3]; };
        void set_seq(unsigned short v) { bytes[2] = (unsigned char)(v >> 8);
                                         bytes[3] = (unsigned char)(v);
                                       }
        
        unsigned long ts() const { return (unsigned long)bytes[4] << 24
                                    | (unsigned long)bytes[5] << 16
                                    | (unsigned long)bytes[6] << 8
                                    | (unsigned long)bytes[7];
                           }
        void set_ts(unsigned long v) { bytes[4] = (unsigned char)(v >> 24);
                                       bytes[5] = (unsigned char)(v >> 16);
                                       bytes[6] = (unsigned char)(v >> 8);
                                       bytes[7] = (unsigned char)(v);
                                     }
        
        unsigned long ssrc() const {  return (unsigned long)bytes[8] << 24
                                       | (unsigned long)bytes[9] << 16
                                       | (unsigned long)bytes[10] << 8
                                       | (unsigned long)bytes[11];
   	                     }
        void set_ssrc(unsigned long v) { bytes[8] = (unsigned char)(v >> 24);
                                         bytes[9] = (unsigned char)(v >> 16);
                                         bytes[10] = (unsigned char)(v >> 8);
                                         bytes[11] = (unsigned char)(v);
                                       }


        //refer to section 5.3.1 of the RTP spec to understand the RTP Extension header.
        int header_size() const
        {
            int NumCSRCBytes = cc() * 4;
            int NumExtensionBytes = 0;

            if ( x() == 1 )
            {   
                //tmp points to the first word of the extended header.
                //bytes 2 and 3 of this word contain the length of the extended header
                //in 32-bit words (not counting the first word)
                const unsigned char *tmp = bytes + fixed_header_size + NumCSRCBytes;
                unsigned short x_len = ((unsigned short)tmp[2] << 8) | (unsigned short)tmp[3];
      
                //number of words plus the length field itself.
                NumExtensionBytes = (x_len + 1) * 4;
            }

            //the fixed header  plus  the csrc list  plus the extended header
            return ( fixed_header_size + NumCSRCBytes + NumExtensionBytes ); 
        }
};

class RTCPSR_Header {
public:
        enum { fixed_header_size = 28 };

private:
        unsigned char bytes[fixed_header_size];

public:
        int v() const { return (bytes[0] >> 6) & 3; }
        void set_v(int v) { bytes[0] = (bytes[0] & 0x3f) | ((v & 3) << 6); }
        
        int p() const { return (bytes[0] >> 5) & 1; }
        void set_p(int v) { bytes[0] = (bytes[0] & 0xdf) | ((v & 1) << 5); }
        
        int cc() const { return bytes[0] & 0x1f; }
        void set_cc(int v) { bytes[0] = (bytes[0] & 0xe0) | (v & 0x1f); }
        
        int pt() const { return (bytes[1]); }
        void set_pt(int v) { bytes[1] = (unsigned char)v; }
        
        unsigned short length() const { return bytes[2] << 8 | bytes[3]; };
        void set_length(unsigned short v) { bytes[2] = (unsigned char)(v >> 8);
                                         bytes[3] = (unsigned char)(v);
                                       }
        
        unsigned long ssrc() const { return (unsigned long)bytes[4] << 24
                                    | (unsigned long)bytes[5] << 16
                                    | (unsigned long)bytes[6] << 8
                                    | (unsigned long)bytes[7];
                           }
        void set_ssrc(unsigned long v) { bytes[4] = (unsigned char)(v >> 24);
                                       bytes[5] = (unsigned char)(v >> 16);
                                       bytes[6] = (unsigned char)(v >> 8);
                                       bytes[7] = (unsigned char)(v);
                                     }
        
        unsigned long ntp_mid() const { return (unsigned long)bytes[10] << 24
                                    | (unsigned long)bytes[11] << 16
                                    | (unsigned long)bytes[12] << 8
                                    | (unsigned long)bytes[13];
                           }
        void set_ntp_mid(unsigned long v) { bytes[10] = (unsigned char)(v >> 24);
                                       bytes[11] = (unsigned char)(v >> 16);
                                       bytes[12] = (unsigned char)(v >> 8);
                                       bytes[13] = (unsigned char)(v);
                                     }
        
        unsigned long ntp_sec() const {  return (unsigned long)bytes[8] << 24
                                       | (unsigned long)bytes[9] << 16
                                       | (unsigned long)bytes[10] << 8
                                       | (unsigned long)bytes[11];
   	                     }
        void set_ntp_sec(unsigned long v) { bytes[8] = (unsigned char)(v >> 24);
                                         bytes[9] = (unsigned char)(v >> 16);
                                         bytes[10] = (unsigned char)(v >> 8);
                                         bytes[11] = (unsigned char)(v);
                                       }

        unsigned long ntp_frac() const {  return (unsigned long)bytes[12] << 24
                                       | (unsigned long)bytes[13] << 16
                                       | (unsigned long)bytes[14] << 8
                                       | (unsigned long)bytes[15];
   	                     }
        void set_ntp_frac(unsigned long v) { bytes[12] = (unsigned char)(v >> 24);
                                         bytes[13] = (unsigned char)(v >> 16);
                                         bytes[14] = (unsigned char)(v >> 8);
                                         bytes[15] = (unsigned char)(v);
                                       }

        unsigned long ts() const {  return (unsigned long)bytes[16] << 24
                                       | (unsigned long)bytes[17] << 16
                                       | (unsigned long)bytes[18] << 8
                                       | (unsigned long)bytes[19];
   	                     }
        void set_ts(unsigned long v) { bytes[16] = (unsigned char)(v >> 24);
                                         bytes[17] = (unsigned char)(v >> 16);
                                         bytes[18] = (unsigned char)(v >> 8);
                                         bytes[19] = (unsigned char)(v);
                                       }

        unsigned long packets() const {  return (unsigned long)bytes[20] << 24
                                       | (unsigned long)bytes[21] << 16
                                       | (unsigned long)bytes[22] << 8
                                       | (unsigned long)bytes[23];
   	                     }
        void set_packets(unsigned long v) { bytes[20] = (unsigned char)(v >> 24);
                                         bytes[21] = (unsigned char)(v >> 16);
                                         bytes[22] = (unsigned char)(v >> 8);
                                         bytes[23] = (unsigned char)(v);
                                       }

        unsigned long octets() const {  return (unsigned long)bytes[24] << 24
                                       | (unsigned long)bytes[25] << 16
                                       | (unsigned long)bytes[26] << 8
                                       | (unsigned long)bytes[27];
   	                     }
        void set_octets(unsigned long v) { bytes[24] = (unsigned char)(v >> 24);
                                         bytes[25] = (unsigned char)(v >> 16);
                                         bytes[26] = (unsigned char)(v >> 8);
                                         bytes[27] = (unsigned char)(v);
                                       }

        int header_size() const
        {
            return length(); 
        }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\ph\ppmver.h ===
// Version control file maintained by Buildmeister 
 
#include <ver.h>

 
#ifndef VER_FILETYPE                         
#define VER_FILETYPE             VFT_DLL     
#endif                                       
 
#define VER_FILESUBTYPE          0 
#define VER_FILEDESCRIPTION_STR  "Intel\256 RTP Payload Handler\0" 
#define VER_INTERNALNAME_STR     "PPM.DLL\0" 
#define VER_ORIGINALFILENAME_STR "PPM.DLL\0" 
#define VER_SYSTEMNAME_STR       "\0"         
 
#if defined(DEBUG) || defined(_DEBUG)

#define VER_DEBUG VS_FF_DEBUG              
#else                                      
#define VER_DEBUG 0                        
#endif                                     
                                           
#define VER_PRODUCTVERSION_STR   "2.0.0.08\0" 
                                                     
#undef VER_FILEVERSION_STR                           
#define VER_FILEVERSION_STR      "2.0.0.08\0" 
                                                     
#undef VER_FILEVERSION                               
#define VER_FILEVERSION          2,0,0,08 
#define VER_PRODUCTVERSION       2,0,0,08 
                                                 
#define VER_PRODUCTNAME_STR      "Intel\256 Payload Preparation Manager\0"            
#define VER_LEGALCOPYRIGHT_STR   "Copyright \251 1995-1996, Intel Corp. All rights reserved.\0" 
#define VER_LEGALTRADEMARKS_STR  "PPM is a trademark of Intel Corporation.\0"                 
#define VER_COMPANYNAME_STR      "Intel Corporation\0"   
#define VER_PRIVATEBLD_STR       "\0"        
#define VER_SPECIALBLD_STR       "\0"        
#define VER_COMMENTS_STR         "\0"          
#define VER_FILEFLAGSMASK (VS_FF_DEBUG|VS_FF_INFOINFERRED\

                          |VS_FF_PATCHED|VS_FF_PRERELEASE\

                          |VS_FF_PRIVATEBUILD|VS_FF_SPECIALBUILD)

                                                                 
#define VER_TESTING_STR "Release\0" 
                                                                 
#ifdef _DEBUG                     
#define VER_FILEFLAGS VS_FF_DEBUG 
#else                             
#define VER_FILEFLAGS 0x0L        
#endif                            
                                  
#undef VER_FILEOS                 
#define VER_FILEOS 0x40004L       
                                  
#include "verstmp.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\algobase.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef ALGOBASE_H
#define ALGOBASE_H

#include <pair.h>
#include <iterator.h>

template <class ForwardIterator1, class ForwardIterator2, class T>
inline void __iter_swap(ForwardIterator1 a, ForwardIterator2 b, T*) {
    T tmp = *a;
    *a = *b;
    *b = tmp;
}

template <class ForwardIterator1, class ForwardIterator2>
inline void iter_swap(ForwardIterator1 a, ForwardIterator2 b) {
    __iter_swap(a, b, value_type(a));
}

template <class T>
inline void swap(T& a, T& b) {
    T tmp = a;
    a = b;
    b = tmp;
}

template <class T>
inline const T& stlmin(const T& a, const T& b) {
    return b < a ? b : a;
}

template <class T, class Compare>
inline const T& stlmin(const T& a, const T& b, Compare comp) {
    return comp(b, a) ? b : a;
}

template <class T>
inline const T& stlmax(const T& a, const T& b) {
    return  a < b ? b : a;
}

template <class T, class Compare>
inline const T& stlmax(const T& a, const T& b, Compare comp) {
    return comp(a, b) ? b : a;
}

template <class InputIterator, class Distance>
void __distance(InputIterator first, InputIterator last, Distance& n, 
		input_iterator_tag) {
    while (first != last) { ++first; ++n; }
}

template <class ForwardIterator, class Distance>
void __distance(ForwardIterator first, ForwardIterator last, Distance& n, 
		forward_iterator_tag) {
    while (first != last) { ++first; ++n; }
}

template <class BidirectionalIterator, class Distance>
void __distance(BidirectionalIterator first, BidirectionalIterator last, 
		Distance& n, bidirectional_iterator_tag) {
    while (first != last) { ++first; ++n; }
}

template <class RandomAccessIterator, class Distance>
inline void __distance(RandomAccessIterator first, RandomAccessIterator last, 
		       Distance& n, random_access_iterator_tag) {
    n += last - first;
}

template <class InputIterator, class Distance>
inline void distance(InputIterator first, InputIterator last, Distance& n) {
    __distance(first, last, n, iterator_category(first));
}

template <class InputIterator, class Distance>
void __advance(InputIterator& i, Distance n, input_iterator_tag) {
    while (n--) ++i;
}

template <class ForwardIterator, class Distance>
void __advance(ForwardIterator& i, Distance n, forward_iterator_tag) {
    while (n--) ++i;
}

template <class BidirectionalIterator, class Distance>
void __advance(BidirectionalIterator& i, Distance n, 
	       bidirectional_iterator_tag) {
    if (n >= 0)
	while (n--) ++i;
    else
	while (n++) --i;
}

template <class RandomAccessIterator, class Distance>
inline void __advance(RandomAccessIterator& i, Distance n, 
		      random_access_iterator_tag) {
    i += n;
}

template <class InputIterator, class Distance>
inline void advance(InputIterator& i, Distance n) {
    __advance(i, n, iterator_category(i));
}

template <class ForwardIterator>
void destroy(ForwardIterator first, ForwardIterator last) {
    while (first != last) {
	/* Borland bug */
	destroy(&*first);
	++first;
	//destroy(&*first++);
    }
}

template <class InputIterator, class ForwardIterator>
ForwardIterator uninitialized_copy(InputIterator first, InputIterator last,
				   ForwardIterator result) {
    while (first != last) construct(&*result++, *first++);
    return result;
}

template <class ForwardIterator, class T>
void uninitialized_fill(ForwardIterator first, ForwardIterator last, 
			const T& x) {
    while (first != last) construct(&*first++, x);
}

template <class ForwardIterator, class Size, class T>
ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n,
				     const T& x) {
    while (n--) construct(&*first++, x);
    return first;
}

template <class InputIterator, class OutputIterator>
OutputIterator copy(InputIterator first, InputIterator last,
		    OutputIterator result) {
    while (first != last) *result++ = *first++;
    return result;
}

template <class BidirectionalIterator1, class BidirectionalIterator2>
BidirectionalIterator2 copy_backward(BidirectionalIterator1 first, 
				     BidirectionalIterator1 last, 
				     BidirectionalIterator2 result) {
    while (first != last) *--result = *--last;
    return result;
}

template <class ForwardIterator, class T>
void fill(ForwardIterator first, ForwardIterator last, const T& value) {
    while (first != last) *first++ = value;
}

template <class OutputIterator, class Size, class T>
OutputIterator fill_n(OutputIterator first, Size n, const T& value) {
    while (n-- > 0) *first++ = value;
    return first;
}

template <class InputIterator1, class InputIterator2>
pair<InputIterator1, InputIterator2> mismatch(InputIterator1 first1,
					      InputIterator1 last1,
					      InputIterator2 first2) {
    while (first1 != last1 && *first1 == *first2) {
	++first1;
	++first2;
    }
    return pair<InputIterator1, InputIterator2>(first1, first2);
}

template <class InputIterator1, class InputIterator2, class BinaryPredicate>
pair<InputIterator1, InputIterator2> mismatch(InputIterator1 first1,
					      InputIterator1 last1,
					      InputIterator2 first2,
					      BinaryPredicate binary_pred) {
    while (first1 != last1 && binary_pred(*first1, *first2)) {
	++first1;
	++first2;
    }
    return pair<InputIterator1, InputIterator2>(first1, first2);
}

template <class InputIterator1, class InputIterator2>
inline bool equal(InputIterator1 first1, InputIterator1 last1,
		  InputIterator2 first2) {
    return mismatch(first1, last1, first2).first == last1;
}

template <class InputIterator1, class InputIterator2, class BinaryPredicate>
inline bool equal(InputIterator1 first1, InputIterator1 last1,
		  InputIterator2 first2, BinaryPredicate binary_pred) {
    return mismatch(first1, last1, first2, binary_pred).first == last1;
}

template <class InputIterator1, class InputIterator2>
bool lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
			     InputIterator2 first2, InputIterator2 last2) {
    while (first1 != last1 && first2 != last2) {
	if (*first1 < *first2) return true;
	if (*first2++ < *first1++) return false;
    }
    return first1 == last1 && first2 != last2;
}

template <class InputIterator1, class InputIterator2, class Compare>
bool lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
			     InputIterator2 first2, InputIterator2 last2,
			     Compare comp) {
    while (first1 != last1 && first2 != last2) {
	if (comp(*first1, *first2)) return true;
	if (comp(*first2++, *first1++)) return false;
    }
    return first1 == last1 && first2 != last2;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\bool.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

//#include <yvals.h>
// Compatibility fix with MS' /msdev/include/yvals.h

//#define bool int
//#define true 1
//#define false 0
//#define __BOOL_DEFINED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\algo.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef ALGO_H
#define ALGO_H

#include <stdlib.h>
#include <bool.h>
#include <pair.h>
#include <iterator.h>
#include <algobase.h>
#include <heap.h>
#include <tempbuf.h>

template <class T>
inline const T& __median(const T& a, const T& b, const T& c) {
    if (a < b)
	if (b < c)
	    return b;
	else if (a < c)
	    return c;
	else
	    return a;
    else if (a < c)
	return a;
    else if (b < c)
	return c;
    else
	return b;
}

template <class T, class Compare>
inline const T& __median(const T& a, const T& b, const T& c, Compare comp) {
    if (comp(a, b))
	if (comp(b, c))
	    return b;
	else if (comp(a, c))
	    return c;
	else
	    return a;
    else if (comp(a, c))
	return a;
    else if (comp(b, c))
	return c;
    else
	return b;
}

template <class InputIterator, class Function>
Function for_each(InputIterator first, InputIterator last, Function f) {
    while (first != last) f(*first++);
    return f;
}

template <class InputIterator, class T>
InputIterator find(InputIterator first, InputIterator last, const T& value) {
    while (first != last && *first != value) ++first;
    return first;
}

template <class InputIterator, class Predicate>
InputIterator find_if(InputIterator first, InputIterator last,
		      Predicate pred) {
    while (first != last && !pred(*first)) ++first;
    return first;
}

template <class ForwardIterator>
ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last) {
    if (first == last) return last;
    ForwardIterator next = first;
    while(++next != last) {
	if (*first == *next) return first;
	first = next;
    }
    return last;
}

template <class ForwardIterator, class BinaryPredicate>
ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last,
			      BinaryPredicate binary_pred) {
    if (first == last) return last;
    ForwardIterator next = first;
    while(++next != last) {
	if (binary_pred(*first, *next)) return first;
	first = next;
    }
    return last;
}

template <class InputIterator, class T, class Size>
void count(InputIterator first, InputIterator last, const T& value,
	   Size& n) {
    while (first != last) 
	if (*first++ == value) ++n;
}

template <class InputIterator, class Predicate, class Size>
void count_if(InputIterator first, InputIterator last, Predicate pred,
	      Size& n) {
    while (first != last)
	if (pred(*first++)) ++n;
}

template <class ForwardIterator1, class ForwardIterator2, class Distance1,
	  class Distance2>
ForwardIterator1 __search(ForwardIterator1 first1, ForwardIterator1 last1,
			  ForwardIterator2 first2, ForwardIterator2 last2,
			  Distance1*, Distance2*) {
    Distance1 d1 = 0;
    distance(first1, last1, d1);
    Distance2 d2 = 0;
    distance(first2, last2, d2);

    if (d1 < d2) return last1;

    ForwardIterator1 current1 = first1;
    ForwardIterator2 current2 = first2;

    while (current2 != last2)
	if (*current1++ != *current2++)
	    if (d1-- == d2)
		return last1;
	    else {
		current1 = ++first1;
		current2 = first2;
	    }
    return (current2 == last2) ? first1 : last1;
}

template <class ForwardIterator1, class ForwardIterator2>
inline ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1,
			       ForwardIterator2 first2, ForwardIterator2 last2)
{
    return __search(first1, last1, first2, last2, distance_type(first1),
		    distance_type(first2));
}

template <class ForwardIterator1, class ForwardIterator2,
	  class BinaryPredicate, class Distance1, class Distance2>
ForwardIterator1 __search(ForwardIterator1 first1, ForwardIterator1 last1,
			  ForwardIterator2 first2, ForwardIterator2 last2,
			  BinaryPredicate binary_pred, Distance1*, Distance2*) {
    Distance1 d1 = 0;
    distance(first1, last1, d1);
    Distance2 d2 = 0;
    distance(first2, last2, d2);

    if (d1 < d2) return last1;

    ForwardIterator1 current1 = first1;
    ForwardIterator2 current2 = first2;

    while (current2 != last2)
	if (!binary_pred(*current1++, *current2++))
	    if (d1-- == d2)
		return last1;
	    else {
		current1 = ++first1;
		current2 = first2;
	    }
    return (current2 == last2) ? first1 : last1;
}

template <class ForwardIterator1, class ForwardIterator2,
	  class BinaryPredicate>
inline ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1,
			       ForwardIterator2 first2, ForwardIterator2 last2,
			       BinaryPredicate binary_pred) {
    return __search(first1, last1, first2, last2, binary_pred,
		    distance_type(first1), distance_type(first2));
}

template <class ForwardIterator1, class ForwardIterator2>
ForwardIterator2 swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1,
			     ForwardIterator2 first2) {
    while (first1 != last1) iter_swap(first1++, first2++);
    return first2;
}

template <class InputIterator, class OutputIterator, class UnaryOperation>
OutputIterator transform(InputIterator first, InputIterator last,
			 OutputIterator result, UnaryOperation op) {
    while (first != last) *result++ = op(*first++);
    return result;
}

template <class InputIterator1, class InputIterator2, class OutputIterator,
	  class BinaryOperation>
OutputIterator transform(InputIterator1 first1, InputIterator1 last1,
			 InputIterator2 first2, OutputIterator result,
			 BinaryOperation binary_op) {
    while (first1 != last1) *result++ = binary_op(*first1++, *first2++);
    return result;
}

template <class ForwardIterator, class T>
void replace(ForwardIterator first, ForwardIterator last, const T& old_value,
	     const T& new_value) {
    while (first != last) {
	if (*first == old_value) *first = new_value;
	++first;
    }
}

template <class ForwardIterator, class Predicate, class T>
void replace_if(ForwardIterator first, ForwardIterator last, Predicate pred,
		const T& new_value) {
    while (first != last) {
	if (pred(*first)) *first = new_value;
	++first;
    }
}

template <class InputIterator, class OutputIterator, class T>
OutputIterator replace_copy(InputIterator first, InputIterator last,
			    OutputIterator result, const T& old_value,
			    const T& new_value) {
    while (first != last) {
	*result++ = *first == old_value ? new_value : *first;
	++first;
    }
    return result;
}

template <class Iterator, class OutputIterator, class Predicate, class T>
OutputIterator replace_copy_if(Iterator first, Iterator last,
			       OutputIterator result, Predicate pred,
			       const T& new_value) {
    while (first != last) {
	*result++ = pred(*first) ? new_value : *first;
	++first;
    }
    return result;
}

template <class ForwardIterator, class Generator>
void generate(ForwardIterator first, ForwardIterator last, Generator gen) {
    while (first != last) *first++ = gen();
}

template <class OutputIterator, class Size, class Generator>
OutputIterator generate_n(OutputIterator first, Size n, Generator gen) {
    while (n-- > 0) *first++ = gen();
    return first;
}

template <class InputIterator, class OutputIterator, class T>
OutputIterator remove_copy(InputIterator first, InputIterator last,
			   OutputIterator result, const T& value) {
    while (first != last) {
	if (*first != value) *result++ = *first;
	++first;
    }
    return result;
}

template <class InputIterator, class OutputIterator, class Predicate>
OutputIterator remove_copy_if(InputIterator first, InputIterator last,
			      OutputIterator result, Predicate pred) {
    while (first != last) {
	if (!pred(*first)) *result++ = *first;
	++first;
    }
    return result;
}

template <class ForwardIterator, class T>
ForwardIterator remove(ForwardIterator first, ForwardIterator last,
		       const T& value) {
    first = find(first, last, value);
    ForwardIterator next = first;
    return first == last ? first : remove_copy(++next, last, first, value);
}

template <class ForwardIterator, class Predicate>
ForwardIterator remove_if(ForwardIterator first, ForwardIterator last,
			  Predicate pred) {
    first = find_if(first, last, pred);
    ForwardIterator next = first;
    return first == last ? first : remove_copy_if(++next, last, first, pred);
}

template <class InputIterator, class ForwardIterator>
ForwardIterator __unique_copy(InputIterator first, InputIterator last,
			      ForwardIterator result, forward_iterator_tag) {
    *result = *first;
    while (++first != last)
        if (*result != *first) *++result = *first;
    return ++result;
}

template <class InputIterator, class BidirectionalIterator>
inline BidirectionalIterator __unique_copy(InputIterator first, 
					   InputIterator last,
			            	   BidirectionalIterator result, 
				    	   bidirectional_iterator_tag) {
    return __unique_copy(first, last, result, forward_iterator_tag());
}

template <class InputIterator, class RandomAccessIterator>
inline RandomAccessIterator __unique_copy(InputIterator first, 
					  InputIterator last,
			           	  RandomAccessIterator result, 
				   	  random_access_iterator_tag) {
    return __unique_copy(first, last, result, forward_iterator_tag());
}

template <class InputIterator, class OutputIterator, class T>
OutputIterator __unique_copy(InputIterator first, InputIterator last,
			     OutputIterator result, T*) {
    T value = *first;
    *result = value;
    while (++first != last)
	if (value != *first) {
	    value = *first;
	    *++result = value;
	}
    return ++result;
}

template <class InputIterator, class OutputIterator>
inline OutputIterator __unique_copy(InputIterator first, InputIterator last,
                             	    OutputIterator result, 
				    output_iterator_tag) {
    return __unique_copy(first, last, result, value_type(first));
}

template <class InputIterator, class OutputIterator>
inline OutputIterator unique_copy(InputIterator first, InputIterator last,
			   	  OutputIterator result) {
    if (first == last) return result;
    return __unique_copy(first, last, result, iterator_category(result));
}
template <class InputIterator, class ForwardIterator, class BinaryPredicate>
ForwardIterator __unique_copy(InputIterator first, InputIterator last,
			      ForwardIterator result, 
			      BinaryPredicate binary_pred,
			      forward_iterator_tag) {
    *result = *first;
    while (++first != last)
        if (!binary_pred(*result, *first)) *++result = *first;
    return ++result;
}

template <class InputIterator, class BidirectionalIterator,
          class BinaryPredicate>
inline BidirectionalIterator __unique_copy(InputIterator first, 
					   InputIterator last,
			            	   BidirectionalIterator result, 
					   BinaryPredicate binary_pred,
				    	   bidirectional_iterator_tag) {
    return __unique_copy(first, last, result, binary_pred,
			 forward_iterator_tag());
}

template <class InputIterator, class RandomAccessIterator,
          class BinaryPredicate>
inline RandomAccessIterator __unique_copy(InputIterator first, 
					  InputIterator last,
			           	  RandomAccessIterator result, 
					  BinaryPredicate binary_pred,
				   	  random_access_iterator_tag) {
    return __unique_copy(first, last, result, binary_pred, 
			 forward_iterator_tag());
}

template <class InputIterator, class OutputIterator, class BinaryPredicate,
          class T>
OutputIterator __unique_copy(InputIterator first, InputIterator last,
			     OutputIterator result,
			     BinaryPredicate binary_pred, T*) {
    T value = *first;
    *result = value;
    while (++first != last)
	if (!binary_pred(value, *first)) {
	    value = *first;
	    *++result = value;
	}
    return ++result;
}

template <class InputIterator, class OutputIterator, class BinaryPredicate>
inline OutputIterator __unique_copy(InputIterator first, InputIterator last,
                             	    OutputIterator result,
				    BinaryPredicate binary_pred,
				    output_iterator_tag) {
    return __unique_copy(first, last, result, binary_pred, value_type(first));
}

template <class InputIterator, class OutputIterator, class BinaryPredicate>
inline OutputIterator unique_copy(InputIterator first, InputIterator last,
			   	  OutputIterator result,
				  BinaryPredicate binary_pred) {
    if (first == last) return result;
    return __unique_copy(first, last, result, binary_pred,
			 iterator_category(result));
}

template <class ForwardIterator>
ForwardIterator unique(ForwardIterator first, ForwardIterator last) {
    first = adjacent_find(first, last);
    return unique_copy(first, last, first);
}

template <class ForwardIterator, class BinaryPredicate>
ForwardIterator unique(ForwardIterator first, ForwardIterator last,
		       BinaryPredicate binary_pred) {
    first = adjacent_find(first, last, binary_pred);
    return unique_copy(first, last, first, binary_pred);
}

template <class BidirectionalIterator>
void __reverse(BidirectionalIterator first, BidirectionalIterator last, 
	       bidirectional_iterator_tag) {
    while (true)
        if (first == last || first == --last)
	    return;
        else
	    iter_swap(first++, last);
}

template <class RandomAccessIterator>
void __reverse(RandomAccessIterator first, RandomAccessIterator last,
	       random_access_iterator_tag) {
    while (first < last) iter_swap(first++, --last);
}

template <class BidirectionalIterator>
inline void reverse(BidirectionalIterator first, BidirectionalIterator last) {
    __reverse(first, last, iterator_category(first));
}

template <class BidirectionalIterator, class OutputIterator>
OutputIterator reverse_copy(BidirectionalIterator first,
			    BidirectionalIterator last,
			    OutputIterator result) {
    while (first != last) *result++ = *--last;
    return result;
}

template <class ForwardIterator, class Distance>
void __rotate(ForwardIterator first, ForwardIterator middle,
	      ForwardIterator last, Distance*, forward_iterator_tag) {
    for (ForwardIterator i = middle; ;) {
	iter_swap(first++, i++);
	if (first == middle) {
	    if (i == last) return;
	    middle = i;
	} else if (i == last)
	    i = middle;
    }
}

template <class BidirectionalIterator, class Distance>
void __rotate(BidirectionalIterator first, BidirectionalIterator middle,
	      BidirectionalIterator last, Distance*,
	      bidirectional_iterator_tag) {
    reverse(first, middle);
    reverse(middle, last);
    reverse(first, last);
}

template <class EuclideanRingElement>
EuclideanRingElement __gcd(EuclideanRingElement m, EuclideanRingElement n)
{
    while (n != 0) {
	EuclideanRingElement t = m % n;
	m = n;
	n = t;
    }
    return m;
}

template <class RandomAccessIterator, class Distance, class T>
void __rotate_cycle(RandomAccessIterator first, RandomAccessIterator last,
		    RandomAccessIterator initial, Distance shift, T*) {
    T value = *initial;
    RandomAccessIterator ptr1 = initial;
    RandomAccessIterator ptr2 = ptr1 + shift;
    while (ptr2 != initial) {
	*ptr1 = *ptr2;
	ptr1 = ptr2;
	if (last - ptr2 > shift)
	    ptr2 += shift;
	else
	    ptr2 = first + (shift - (last - ptr2));
    }
    *ptr1 = value;
}

template <class RandomAccessIterator, class Distance>
void __rotate(RandomAccessIterator first, RandomAccessIterator middle,
	      RandomAccessIterator last, Distance*,
	      random_access_iterator_tag) {
    Distance n = __gcd(last - first, middle - first);
    while (n--)
	__rotate_cycle(first, last, first + n, middle - first,
		       value_type(first));
}

template <class ForwardIterator>
inline void rotate(ForwardIterator first, ForwardIterator middle,
		   ForwardIterator last) {
    if (first == middle || middle == last) return;
    __rotate(first, middle, last, distance_type(first),
	     iterator_category(first));
}

template <class ForwardIterator, class OutputIterator>
OutputIterator rotate_copy(ForwardIterator first, ForwardIterator middle,
			   ForwardIterator last, OutputIterator result) {
    return copy(first, middle, copy(middle, last, result));
}

unsigned long __long_random(unsigned long);

template <class RandomAccessIterator, class Distance>
void __random_shuffle(RandomAccessIterator first, RandomAccessIterator last,
		      Distance*) {
    if (first == last) return;
    for (RandomAccessIterator i = first + 1; i != last; ++i)
	iter_swap(i, first + Distance(__long_random((i - first) + 1)));
}

template <class RandomAccessIterator>
inline void random_shuffle(RandomAccessIterator first,
			   RandomAccessIterator last) {
    __random_shuffle(first, last, distance_type(first));
}

template <class RandomAccessIterator, class RandomNumberGenerator>
void random_shuffle(RandomAccessIterator first, RandomAccessIterator last,
		    RandomNumberGenerator& rand) {
    if (first == last) return;
    for (RandomAccessIterator i = first + 1; i != last; ++i)
	iter_swap(i, first + rand((i - first) + 1));
}

template <class BidirectionalIterator, class Predicate>
BidirectionalIterator partition(BidirectionalIterator first,
				BidirectionalIterator last, Predicate pred) {
    while (true) {
	while (true)
	    if (first == last)
		return first;
	    else if (pred(*first))
		++first;
	    else
		break;
	--last;
	while (true)
	    if (first == last)
		return first;
	    else if (!pred(*last))
		--last;
	    else
		break;
	iter_swap(first, last);
	++first;
    }
}

template <class ForwardIterator, class Predicate, class Distance>
ForwardIterator __inplace_stable_partition(ForwardIterator first,
					   ForwardIterator last,
					   Predicate pred, Distance len) {
    if (len == 1) return pred(*first) ? last : first;
    ForwardIterator middle = first;
    advance(middle, len / 2);
    ForwardIterator 
	first_cut = __inplace_stable_partition(first, middle, pred, len / 2);
    ForwardIterator 
	second_cut = __inplace_stable_partition(middle, last, pred,
						len - len / 2);
    rotate(first_cut, middle, second_cut);
    len = 0;
    distance(middle, second_cut, len);
    advance(first_cut, len);
    return first_cut;
}

template <class ForwardIterator, class Pointer, class Predicate,
	  class Distance, class T>
ForwardIterator __stable_partition_adaptive(ForwardIterator first,
					    ForwardIterator last,
					    Predicate pred, Distance len,
					    Pointer buffer,
					    Distance buffer_size,
					    Distance& fill_pointer, T*) {
    if (len <= buffer_size) {
	len = 0;
	ForwardIterator result1 = first;
	Pointer result2 = buffer;
	while (first != last && len < fill_pointer)
	    if (pred(*first))
		*result1++ = *first++;
	    else {
		*result2++ = *first++;
		++len;
	    }
	if (first != last) {
	    raw_storage_iterator<Pointer, T> result3 = result2;
	    while (first != last)           
		if (pred(*first))
		    *result1++ = *first++;
		else {
		    *result3++ = *first++;
		    ++len;
		}
	    fill_pointer = len;
	}
	copy(buffer, buffer + len, result1);
	return result1;
    }
    ForwardIterator middle = first;
    advance(middle, len / 2);
    ForwardIterator first_cut = __stable_partition_adaptive
	(first, middle, pred, len / 2, buffer, buffer_size, fill_pointer, 
	 (T*)0);
    ForwardIterator second_cut = __stable_partition_adaptive
	(middle, last, pred, len - len / 2, buffer, buffer_size, 
	 fill_pointer, (T*)0);
    rotate(first_cut, middle, second_cut);
    len = 0;
    distance(middle, second_cut, len);
    advance(first_cut, len);
    return first_cut;
}

template <class ForwardIterator, class Predicate, class Pointer,
	  class Distance>
ForwardIterator __stable_partition(ForwardIterator first, ForwardIterator last,
				   Predicate pred, Distance len,
				   pair<Pointer, Distance> p) {
    if (p.first == 0)
	return __inplace_stable_partition(first, last, pred, len);
    Distance fill_pointer = 0;
    ForwardIterator result = 
	__stable_partition_adaptive(first, last, pred, len, p.first, p.second,
				    fill_pointer, value_type(first)); 
    destroy(p.first, p.first + fill_pointer);
    return_temporary_buffer(p.first);
    return result;
}

template <class ForwardIterator, class Predicate, class Distance>
inline ForwardIterator __stable_partition_aux(ForwardIterator first,
					      ForwardIterator last, 
					      Predicate pred, Distance*) {
    Distance len = 0;
    distance(first, last, len);
    return __stable_partition(first, last, pred, len,
			      get_temporary_buffer(len, value_type(first)));
}

template <class ForwardIterator, class Predicate>
inline ForwardIterator stable_partition(ForwardIterator first,
					ForwardIterator last, 
					Predicate pred) {
    return __stable_partition_aux(first, last, pred, distance_type(first));
}

template <class RandomAccessIterator, class T>
RandomAccessIterator __unguarded_partition(RandomAccessIterator first, 
					   RandomAccessIterator last, 
					   T pivot) {
    while (1) {
	while (*first < pivot) ++first;
	--last;
	while (pivot < *last) --last;
	if (!(first < last)) return first;
	iter_swap(first, last);
	++first;
    }
}    

template <class RandomAccessIterator, class T, class Compare>
RandomAccessIterator __unguarded_partition(RandomAccessIterator first, 
					   RandomAccessIterator last, 
					   T pivot, Compare comp) {
    while (1) {
	while (comp(*first, pivot)) ++first;
	--last;
	while (comp(pivot, *last)) --last;
	if (!(first < last)) return first;
	iter_swap(first, last);
	++first;
    }
}

const int __stl_threshold = 16;

template <class RandomAccessIterator, class T>
void __quick_sort_loop_aux(RandomAccessIterator first,
			   RandomAccessIterator last, T*) {
    while (last - first > __stl_threshold) {
	RandomAccessIterator cut = __unguarded_partition
	    (first, last, T(__median(*first, *(first + (last - first)/2),
				     *(last - 1))));
	if (cut - first >= last - cut) {
	    __quick_sort_loop(cut, last);
	    last = cut;
	} else {
	    __quick_sort_loop(first, cut);
	    first = cut;
	}
    }
}

template <class RandomAccessIterator>
inline void __quick_sort_loop(RandomAccessIterator first,
			      RandomAccessIterator last) {
    __quick_sort_loop_aux(first, last, value_type(first));
}

template <class RandomAccessIterator, class T, class Compare>
void __quick_sort_loop_aux(RandomAccessIterator first, 
			   RandomAccessIterator last, T*, Compare comp) {
    while (last - first > __stl_threshold) {
	RandomAccessIterator cut = __unguarded_partition
	    (first, last, T(__median(*first, *(first + (last - first)/2), 
				   *(last - 1), comp)), comp);
	if (cut - first >= last - cut) {
	    __quick_sort_loop(cut, last, comp);
	    last = cut;
	} else {
	    __quick_sort_loop(first, cut, comp);
	    first = cut;
	}
    }
}

template <class RandomAccessIterator, class Compare>
inline void __quick_sort_loop(RandomAccessIterator first, 
			      RandomAccessIterator last, Compare comp) {
    __quick_sort_loop_aux(first, last, value_type(first), comp);
}

template <class RandomAccessIterator, class T>
void __unguarded_linear_insert(RandomAccessIterator last, T value) {
    RandomAccessIterator next = last;
    --next;
    while (value < *next) {
	*last = *next;
	last = next--;
    }
    *last = value;
}

template <class RandomAccessIterator, class T, class Compare>
void __unguarded_linear_insert(RandomAccessIterator last, T value, 
			       Compare comp) {
    RandomAccessIterator next = last;
    --next;  
    while (comp(value , *next)) {
	*last = *next;
	last = next--;
    }
    *last = value;
}

template <class RandomAccessIterator, class T>
inline void __linear_insert(RandomAccessIterator first, 
			    RandomAccessIterator last, T*) {
    T value = *last;
    if (value < *first) {
	copy_backward(first, last, last + 1);
	*first = value;
    } else
	__unguarded_linear_insert(last, value);
}

template <class RandomAccessIterator, class T, class Compare>
inline void __linear_insert(RandomAccessIterator first, 
			    RandomAccessIterator last, T*, Compare comp) {
    T value = *last;
    if (comp(value, *first)) {
	copy_backward(first, last, last + 1);
	*first = value;
    } else
	__unguarded_linear_insert(last, value, comp);
}

template <class RandomAccessIterator>
void __insertion_sort(RandomAccessIterator first, RandomAccessIterator last) {
    if (first == last) return; 
    for (RandomAccessIterator i = first + 1; i != last; ++i)
	__linear_insert(first, i, value_type(first));
}

template <class RandomAccessIterator, class Compare>
void __insertion_sort(RandomAccessIterator first,
		      RandomAccessIterator last, Compare comp) {
    if (first == last) return;
    for (RandomAccessIterator i = first + 1; i != last; ++i)
	__linear_insert(first, i, value_type(first), comp);
}

template <class RandomAccessIterator, class T>
void __unguarded_insertion_sort_aux(RandomAccessIterator first, 
				    RandomAccessIterator last, T*) {
    for (RandomAccessIterator i = first; i != last; ++i)
	__unguarded_linear_insert(i, T(*i));
}

template <class RandomAccessIterator>
inline void __unguarded_insertion_sort(RandomAccessIterator first, 
				RandomAccessIterator last) {
    __unguarded_insertion_sort_aux(first, last, value_type(first));
}

template <class RandomAccessIterator, class T, class Compare>
void __unguarded_insertion_sort_aux(RandomAccessIterator first, 
				    RandomAccessIterator last,
				    T*, Compare comp) {
    for (RandomAccessIterator i = first; i != last; ++i)
	__unguarded_linear_insert(i, T(*i), comp);
}

template <class RandomAccessIterator, class Compare>
inline void __unguarded_insertion_sort(RandomAccessIterator first, 
				       RandomAccessIterator last,
				       Compare comp) {
    __unguarded_insertion_sort_aux(first, last, value_type(first), comp);
}

template <class RandomAccessIterator>
void __final_insertion_sort(RandomAccessIterator first, 
			    RandomAccessIterator last) {
    if (last - first > __stl_threshold) {
	__insertion_sort(first, first + __stl_threshold);
	__unguarded_insertion_sort(first + __stl_threshold, last);
    } else
	__insertion_sort(first, last);
}

template <class RandomAccessIterator, class Compare>
void __final_insertion_sort(RandomAccessIterator first, 
			    RandomAccessIterator last, Compare comp) {
    if (last - first > __stl_threshold) {
	__insertion_sort(first, first + __stl_threshold, comp);
	__unguarded_insertion_sort(first + __stl_threshold, last, comp);
    } else
	__insertion_sort(first, last, comp);
}

template <class RandomAccessIterator>
void sort(RandomAccessIterator first, RandomAccessIterator last) {
    __quick_sort_loop(first, last);
    __final_insertion_sort(first, last);
}

template <class RandomAccessIterator, class Compare>
void sort(RandomAccessIterator first, RandomAccessIterator last,
	  Compare comp) {
   __quick_sort_loop(first, last, comp);
   __final_insertion_sort(first, last, comp);
}

template <class RandomAccessIterator>
void __inplace_stable_sort(RandomAccessIterator first,
			   RandomAccessIterator last) {
    if (last - first < 15) {
	__insertion_sort(first, last);
	return;
    }
    RandomAccessIterator middle = first + (last - first) / 2;
    __inplace_stable_sort(first, middle);
    __inplace_stable_sort(middle, last);
    __merge_without_buffer(first, middle, last, middle - first, last - middle);
}

template <class RandomAccessIterator, class Compare>
void __inplace_stable_sort(RandomAccessIterator first,
			   RandomAccessIterator last, Compare comp) {
    if (last - first < 15) {
	__insertion_sort(first, last, comp);
	return;
    }
    RandomAccessIterator middle = first + (last - first) / 2;
    __inplace_stable_sort(first, middle, comp);
    __inplace_stable_sort(middle, last, comp);
    __merge_without_buffer(first, middle, last, middle - first,
			   last - middle, comp);
}

template <class RandomAccessIterator1, class RandomAccessIterator2,
	  class Distance>
void __merge_sort_loop(RandomAccessIterator1 first,
		       RandomAccessIterator1 last, 
		       RandomAccessIterator2 result, Distance step_size) {
    Distance two_step = 2 * step_size;

    while (last - first >= two_step) {
	result = merge(first, first + step_size,
		       first + step_size, first + two_step, result);
	first += two_step;
    }
    step_size = stlmin(Distance(last - first), step_size);

    merge(first, first + step_size, first + step_size, last, result);
}

template <class RandomAccessIterator1, class RandomAccessIterator2,
	  class Distance, class Compare>
void __merge_sort_loop(RandomAccessIterator1 first,
		       RandomAccessIterator1 last, 
		       RandomAccessIterator2 result, Distance step_size,
		       Compare comp) {
    Distance two_step = 2 * step_size;

    while (last - first >= two_step) {
	result = merge(first, first + step_size,
		       first + step_size, first + two_step, result, comp);
	first += two_step;
    }
    step_size = stlmin(Distance(last - first), step_size);

    merge(first, first + step_size, first + step_size, last, result, comp);
}

const int __stl_chunk_size = 7;
	
template <class RandomAccessIterator, class Distance>
void __chunk_insertion_sort(RandomAccessIterator first, 
			      RandomAccessIterator last, Distance chunk_size) {
    while (last - first >= chunk_size) {
	__insertion_sort(first, first + chunk_size);
	first += chunk_size;
    }
    __insertion_sort(first, last);
}

template <class RandomAccessIterator, class Distance, class Compare>
void __chunk_insertion_sort(RandomAccessIterator first, 
			    RandomAccessIterator last,
			    Distance chunk_size, Compare comp) {
    while (last - first >= chunk_size) {
	__insertion_sort(first, first + chunk_size, comp);
	first += chunk_size;
    }
    __insertion_sort(first, last, comp);
}

template <class RandomAccessIterator, class Pointer, class Distance, class T>
void __merge_sort_with_buffer(RandomAccessIterator first, 
			      RandomAccessIterator last,
			      Pointer buffer, Distance*, T*) {
    Distance len = last - first;
    Pointer buffer_last = buffer + len;

    Distance step_size = __stl_chunk_size;
    __chunk_insertion_sort(first, last, step_size);

    while (step_size < len) {
	__merge_sort_loop(first, last, buffer, step_size);
	step_size *= 2;
	__merge_sort_loop(buffer, buffer_last, first, step_size);
	step_size *= 2;
    }
}

template <class RandomAccessIterator, class Pointer, class Distance, class T,
	  class Compare>
void __merge_sort_with_buffer(RandomAccessIterator first, 
			      RandomAccessIterator last, Pointer buffer,
			      Distance*, T*, Compare comp) {
    Distance len = last - first;
    Pointer buffer_last = buffer + len;

    Distance step_size = __stl_chunk_size;
    __chunk_insertion_sort(first, last, step_size, comp);

    while (step_size < len) {
	__merge_sort_loop(first, last, buffer, step_size, comp);
	step_size *= 2;
	__merge_sort_loop(buffer, buffer_last, first, step_size, comp);
	step_size *= 2;
    }
}

template <class RandomAccessIterator, class Pointer, class Distance, class T>
void __stable_sort_adaptive(RandomAccessIterator first, 
			    RandomAccessIterator last, Pointer buffer,
			    Distance buffer_size, T*) {
    Distance len = (last - first + 1) / 2;
    RandomAccessIterator middle = first + len;
    if (len > buffer_size) {
	__stable_sort_adaptive(first, middle, buffer, buffer_size, (T*)0);
	__stable_sort_adaptive(middle, last, buffer, buffer_size, (T*)0);
    } else {
	__merge_sort_with_buffer(first, middle, buffer, (Distance*)0, (T*)0);
	__merge_sort_with_buffer(middle, last, buffer, (Distance*)0, (T*)0);
    }
    __merge_adaptive(first, middle, last, Distance(middle - first), 
		     Distance(last - middle), buffer, buffer_size, (T*)0);
}

template <class RandomAccessIterator, class Pointer, class Distance, class T,
	  class Compare>
void __stable_sort_adaptive(RandomAccessIterator first, 
			    RandomAccessIterator last, Pointer buffer,
			    Distance buffer_size, T*, Compare comp) {
    Distance len = (last - first + 1) / 2;
    RandomAccessIterator middle = first + len;
    if (len > buffer_size) {
	__stable_sort_adaptive(first, middle, buffer, buffer_size, (T*)0, comp);
	__stable_sort_adaptive(middle, last, buffer, buffer_size, (T*)0, comp);
    } else {
	__merge_sort_with_buffer(first, middle, buffer, (Distance*)0, (T*)0,
				 comp);
	__merge_sort_with_buffer(middle, last, buffer, (Distance*)0, (T*)0,
				 comp);
    }
    __merge_adaptive(first, middle, last, Distance(middle - first), 
		     Distance(last - middle), buffer, buffer_size, (T*)0, comp);
}

template <class RandomAccessIterator, class Pointer, class Distance, class T>
inline void __stable_sort(RandomAccessIterator first,
			  RandomAccessIterator last,
			  pair<Pointer, Distance> p, T*) {
    if (p.first == 0) {
	__inplace_stable_sort(first, last);
	return;
    }
    Distance len = stlmin(p.second, last - first);
    copy(first, first + len, raw_storage_iterator<Pointer, T>(p.first));
    __stable_sort_adaptive(first, last, p.first, p.second, (T*)0);
    destroy(p.first, p.first + len);
    return_temporary_buffer(p.first);
}

template <class RandomAccessIterator, class Pointer, class Distance, class T,
	  class Compare>
inline void __stable_sort(RandomAccessIterator first,
			  RandomAccessIterator last,
			  pair<Pointer, Distance> p, T*, Compare comp) {
    if (p.first == 0) {
	__inplace_stable_sort(first, last, comp);
	return;
    }
    Distance len = stlmin(p.second, last - first);
    copy(first, first + len, raw_storage_iterator<Pointer, T>(p.first));
    __stable_sort_adaptive(first, last, p.first, p.second, (T*)0, comp);
    destroy(p.first, p.first + len);
    return_temporary_buffer(p.first);
}

template <class RandomAccessIterator, class T, class Distance>
inline void __stable_sort_aux(RandomAccessIterator first,
			      RandomAccessIterator last, T*, Distance*) {
    __stable_sort(first, last, get_temporary_buffer(Distance(last - first),
						    (T*)0), (T*)0);
}

template <class RandomAccessIterator, class T, class Distance, class Compare>
inline void __stable_sort_aux(RandomAccessIterator first,
			      RandomAccessIterator last, T*, Distance*,
			      Compare comp) {
    __stable_sort(first, last, get_temporary_buffer(Distance(last - first),
						    (T*)0), (T*)0, comp);
}

template <class RandomAccessIterator>
inline void stable_sort(RandomAccessIterator first,
			RandomAccessIterator last) {
    __stable_sort_aux(first, last, value_type(first), distance_type(first));
}

template <class RandomAccessIterator, class Compare>
inline void stable_sort(RandomAccessIterator first,
			RandomAccessIterator last, Compare comp) {
    __stable_sort_aux(first, last, value_type(first), distance_type(first), 
		      comp);
}

template <class RandomAccessIterator, class T>
void __partial_sort(RandomAccessIterator first, RandomAccessIterator middle,
		    RandomAccessIterator last, T*) {
    make_heap(first, middle);
    for (RandomAccessIterator i = middle; i < last; ++i)
	if (*i < *first) 
	  __pop_heap(first, middle, i, T(*i), distance_type(first));
    sort_heap(first, middle);
}

template <class RandomAccessIterator>
inline void partial_sort(RandomAccessIterator first,
			 RandomAccessIterator middle,
			 RandomAccessIterator last) {
    __partial_sort(first, middle, last, value_type(first));
}

template <class RandomAccessIterator, class T, class Compare>
void __partial_sort(RandomAccessIterator first, RandomAccessIterator middle,
		    RandomAccessIterator last, T*, Compare comp) {
    make_heap(first, middle, comp);
    for (RandomAccessIterator i = middle; i < last; ++i)
	if (comp(*i, *first))
	  __pop_heap(first, middle, i, T(*i), comp, distance_type(first));
    sort_heap(first, middle, comp);
}

template <class RandomAccessIterator, class Compare>
inline void partial_sort(RandomAccessIterator first,
			 RandomAccessIterator middle,
			 RandomAccessIterator last, Compare comp) {
    __partial_sort(first, middle, last, value_type(first), comp);
}

template <class InputIterator, class RandomAccessIterator, class Distance,
          class T>
RandomAccessIterator __partial_sort_copy(InputIterator first,
					 InputIterator last,
					 RandomAccessIterator result_first,
					 RandomAccessIterator result_last, 
					 Distance*, T*) {
    if (result_first == result_last) return result_last;
    RandomAccessIterator result_real_last = result_first;
    while(first != last && result_real_last != result_last)
	*result_real_last++ = *first++;
    make_heap(result_first, result_real_last);
    while (first != last) {
	if (*first < *result_first) 
	    __adjust_heap(result_first, Distance(0),
			  Distance(result_real_last - result_first), T(*first));
	++first;
    }
    sort_heap(result_first, result_real_last);
    return result_real_last;
}

template <class InputIterator, class RandomAccessIterator>
inline RandomAccessIterator
partial_sort_copy(InputIterator first, InputIterator last,
		  RandomAccessIterator result_first,
		  RandomAccessIterator result_last) {
    return __partial_sort_copy(first, last, result_first, result_last, 
			       distance_type(result_first), value_type(first));
}

template <class InputIterator, class RandomAccessIterator, class Compare,
          class Distance, class T>
RandomAccessIterator __partial_sort_copy(InputIterator first,
					 InputIterator last,
					 RandomAccessIterator result_first,
					 RandomAccessIterator result_last,
					 Compare comp, Distance*, T*) {
    if (result_first == result_last) return result_last;
    RandomAccessIterator result_real_last = result_first;
    while(first != last && result_real_last != result_last)
	*result_real_last++ = *first++;
    make_heap(result_first, result_real_last, comp);
    while (first != last) {
	if (comp(*first, *result_first))
	    __adjust_heap(result_first, Distance(0),
			  Distance(result_real_last - result_first), T(*first),
			  comp);
	++first;
    }
    sort_heap(result_first, result_real_last, comp);
    return result_real_last;
}

template <class InputIterator, class RandomAccessIterator, class Compare>
inline RandomAccessIterator
partial_sort_copy(InputIterator first, InputIterator last,
		  RandomAccessIterator result_first,
		  RandomAccessIterator result_last, Compare comp) {
    return __partial_sort_copy(first, last, result_first, result_last, comp,
			       distance_type(result_first), value_type(first));
}

template <class RandomAccessIterator, class T>
void __nth_element(RandomAccessIterator first, RandomAccessIterator nth,
		   RandomAccessIterator last, T*) {
    while (last - first > 3) {
	RandomAccessIterator cut = __unguarded_partition
	    (first, last, T(__median(*first, *(first + (last - first)/2),
				     *(last - 1))));
	if (cut <= nth)
	    first = cut;
	else 
	    last = cut;
    }
    __insertion_sort(first, last);
}

template <class RandomAccessIterator>
inline void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
			RandomAccessIterator last) {
    __nth_element(first, nth, last, value_type(first));
}

template <class RandomAccessIterator, class T, class Compare>
void __nth_element(RandomAccessIterator first, RandomAccessIterator nth,
		   RandomAccessIterator last, T*, Compare comp) {
    while (last - first > 3) {
	RandomAccessIterator cut = __unguarded_partition
	    (first, last, T(__median(*first, *(first + (last - first)/2), 
				     *(last - 1), comp)), comp);
	if (cut <= nth)
	    first = cut;
	else 
	    last = cut;
    }
    __insertion_sort(first, last, comp);
}

template <class RandomAccessIterator, class Compare>
inline void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
		 RandomAccessIterator last, Compare comp) {
    __nth_element(first, nth, last, value_type(first), comp);
}

template <class ForwardIterator, class T, class Distance>
ForwardIterator __lower_bound(ForwardIterator first, ForwardIterator last,
			      const T& value, Distance*,
			      forward_iterator_tag) {
    Distance len = 0;
    distance(first, last, len);
    Distance half;
    ForwardIterator middle;

    while (len > 0) {
	half = len / 2;
	middle = first;
	advance(middle, half);
	if (*middle < value) {
	    first = middle;
	    ++first;
	    len = len - half - 1;
	} else
	    len = half;
    }
    return first;
}

template <class ForwardIterator, class T, class Distance>
inline ForwardIterator __lower_bound(ForwardIterator first,
				     ForwardIterator last,
				     const T& value, Distance*,
				     bidirectional_iterator_tag) {
    return __lower_bound(first, last, value, (Distance*)0,
			 forward_iterator_tag());
}

template <class RandomAccessIterator, class T, class Distance>
RandomAccessIterator __lower_bound(RandomAccessIterator first,
				   RandomAccessIterator last, const T& value,
				   Distance*, random_access_iterator_tag) {
    Distance len = last - first;
    Distance half;
    RandomAccessIterator middle;

    while (len > 0) {
	half = len / 2;
	middle = first + half;
	if (*middle < value) {
	    first = middle + 1;
	    len = len - half - 1;
	} else
	    len = half;
    }
    return first;
}

template <class ForwardIterator, class T>
inline ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last,
				   const T& value) {
    return __lower_bound(first, last, value, distance_type(first),
			 iterator_category(first));
}

template <class ForwardIterator, class T, class Compare, class Distance>
ForwardIterator __lower_bound(ForwardIterator first, ForwardIterator last,
			      const T& value, Compare comp, Distance*,
			      forward_iterator_tag) {
    Distance len = 0;
    distance(first, last, len);
    Distance half;
    ForwardIterator middle;

    while (len > 0) {
	half = len / 2;
	middle = first;
	advance(middle, half);
	if (comp(*middle, value)) {
	    first = middle;
	    ++first;
	    len = len - half - 1;
	} else
	    len = half;
    }
    return first;
}

template <class ForwardIterator, class T, class Compare, class Distance>
inline ForwardIterator __lower_bound(ForwardIterator first,
				     ForwardIterator last,
				     const T& value, Compare comp, Distance*,
				     bidirectional_iterator_tag) {
    return __lower_bound(first, last, value, comp, (Distance*)0,
			 forward_iterator_tag());
}

template <class RandomAccessIterator, class T, class Compare, class Distance>
RandomAccessIterator __lower_bound(RandomAccessIterator first,
				   RandomAccessIterator last,
				   const T& value, Compare comp, Distance*,
				   random_access_iterator_tag) {
    Distance len = last - first;
    Distance half;
    RandomAccessIterator middle;

    while (len > 0) {
	half = len / 2;
	middle = first + half;
	if (comp(*middle, value)) {
	    first = middle + 1;
	    len = len - half - 1;
	} else
	    len = half;
    }
    return first;
}

template <class ForwardIterator, class T, class Compare>
inline ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last,
				   const T& value, Compare comp) {
    return __lower_bound(first, last, value, comp, distance_type(first),
			 iterator_category(first));
}

template <class ForwardIterator, class T, class Distance>
ForwardIterator __upper_bound(ForwardIterator first, ForwardIterator last,
			      const T& value, Distance*,
			      forward_iterator_tag) {
    Distance len = 0;
    distance(first, last, len);
    Distance half;
    ForwardIterator middle;

    while (len > 0) {
	half = len / 2;
	middle = first;
	advance(middle, half);
	if (value < *middle)
	    len = half;
	else {
	    first = middle;
	    ++first;
	    len = len - half - 1;
	}
    }
    return first;
}

template <class ForwardIterator, class T, class Distance>
inline ForwardIterator __upper_bound(ForwardIterator first,
				     ForwardIterator last,
				     const T& value, Distance*,
				     bidirectional_iterator_tag) {
    return __upper_bound(first, last, value, (Distance*)0,
			 forward_iterator_tag());
}

template <class RandomAccessIterator, class T, class Distance>
RandomAccessIterator __upper_bound(RandomAccessIterator first,
				   RandomAccessIterator last, const T& value,
				   Distance*, random_access_iterator_tag) {
    Distance len = last - first;
    Distance half;
    RandomAccessIterator middle;

    while (len > 0) {
	half = len / 2;
	middle = first + half;
	if (value < *middle)
	    len = half;
	else {
	    first = middle + 1;
	    len = len - half - 1;
	}
    }
    return first;
}

template <class ForwardIterator, class T>
inline ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last,
				   const T& value) {
    return __upper_bound(first, last, value, distance_type(first),
			 iterator_category(first));
}

template <class ForwardIterator, class T, class Compare, class Distance>
ForwardIterator __upper_bound(ForwardIterator first, ForwardIterator last,
			      const T& value, Compare comp, Distance*,
			      forward_iterator_tag) {
    Distance len = 0;
    distance(first, last, len);
    Distance half;
    ForwardIterator middle;

    while (len > 0) {
	half = len / 2;
	middle = first;
	advance(middle, half);
	if (comp(value, *middle))
	    len = half;
	else {
	    first = middle;
	    ++first;
	    len = len - half - 1;
	}
    }
    return first;
}

template <class ForwardIterator, class T, class Compare, class Distance>
inline ForwardIterator __upper_bound(ForwardIterator first,
				     ForwardIterator last,
				     const T& value, Compare comp, Distance*,
				     bidirectional_iterator_tag) {
    return __upper_bound(first, last, value, comp, (Distance*)0,
			 forward_iterator_tag());
}

template <class RandomAccessIterator, class T, class Compare, class Distance>
RandomAccessIterator __upper_bound(RandomAccessIterator first,
				   RandomAccessIterator last,
				   const T& value, Compare comp, Distance*,
				   random_access_iterator_tag) {
    Distance len = last - first;
    Distance half;
    RandomAccessIterator middle;

    while (len > 0) {
	half = len / 2;
	middle = first + half;
	if (comp(value, *middle))
	    len = half;
	else {
	    first = middle + 1;
	    len = len - half - 1;
	}
    }
    return first;
}

template <class ForwardIterator, class T, class Compare>
inline ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last,
				   const T& value, Compare comp) {
    return __upper_bound(first, last, value, comp, distance_type(first),
			 iterator_category(first));
}

template <class ForwardIterator, class T, class Distance>
pair<ForwardIterator, ForwardIterator>
__equal_range(ForwardIterator first, ForwardIterator last, const T& value,
	      Distance*, forward_iterator_tag) {
    Distance len = 0;
    distance(first, last, len);
    Distance half;
    ForwardIterator middle, left, right;

    while (len > 0) {
	half = len / 2;
	middle = first;
	advance(middle, half);
	if (*middle < value) {
	    first = middle;
	    ++first;
	    len = len - half - 1;
	} else if (value < *middle)
	    len = half;
	else {
	    left = lower_bound(first, middle, value);
	    advance(first, len);
	    right = upper_bound(++middle, first, value);
	    return pair<ForwardIterator, ForwardIterator>(left, right);
	}
    }
    return pair<ForwardIterator, ForwardIterator>(first, first);
}

template <class ForwardIterator, class T, class Distance>
inline pair<ForwardIterator, ForwardIterator>
__equal_range(ForwardIterator first, ForwardIterator last, const T& value,
	      Distance*, bidirectional_iterator_tag) {
    return __equal_range(first, last, value, (Distance*)0, 
			 forward_iterator_tag());
}

template <class RandomAccessIterator, class T, class Distance>
pair<RandomAccessIterator, RandomAccessIterator>
__equal_range(RandomAccessIterator first, RandomAccessIterator last,
	      const T& value, Distance*, random_access_iterator_tag) {
    Distance len = last - first;
    Distance half;
    RandomAccessIterator middle, left, right;

    while (len > 0) {
	half = len / 2;
	middle = first + half;
	if (*middle < value) {
	    first = middle + 1;
	    len = len - half - 1;
	} else if (value < *middle)
	    len = half;
	else {
	    left = lower_bound(first, middle, value);
	    right = upper_bound(++middle, first + len, value);
	    return pair<RandomAccessIterator, RandomAccessIterator>(left,
								    right);
	}
    }
    return pair<RandomAccessIterator, RandomAccessIterator>(first, first);
}

template <class ForwardIterator, class T>
inline pair<ForwardIterator, ForwardIterator>
equal_range(ForwardIterator first, ForwardIterator last, const T& value) {
    return __equal_range(first, last, value, distance_type(first),
			 iterator_category(first));
}

template <class ForwardIterator, class T, class Compare, class Distance>
pair<ForwardIterator, ForwardIterator>
__equal_range(ForwardIterator first, ForwardIterator last, const T& value,
	      Compare comp, Distance*, forward_iterator_tag) {
    Distance len = 0;
    distance(first, last, len);
    Distance half;
    ForwardIterator middle, left, right;

    while (len > 0) {
	half = len / 2;
	middle = first;
	advance(middle, half);
	if (comp(*middle, value)) {
	    first = middle;
	    ++first;
	    len = len - half - 1;
	} else if (comp(value, *middle))
	    len = half;
	else {
	    left = lower_bound(first, middle, value, comp);
	    advance(first, len);
	    right = upper_bound(++middle, first, value, comp);
	    return pair<ForwardIterator, ForwardIterator>(left, right);
	}
    }
    return pair<ForwardIterator, ForwardIterator>(first, first);
}           

template <class ForwardIterator, class T, class Compare, class Distance>
inline pair<ForwardIterator, ForwardIterator>
__equal_range(ForwardIterator first, ForwardIterator last, const T& value,
	      Compare comp, Distance*, bidirectional_iterator_tag) {
    return __equal_range(first, last, value, comp, (Distance*)0, 
			 forward_iterator_tag());
}

template <class RandomAccessIterator, class T, class Compare, class Distance>
pair<RandomAccessIterator, RandomAccessIterator>
__equal_range(RandomAccessIterator first, RandomAccessIterator last,
	      const T& value, Compare comp, Distance*,
	      random_access_iterator_tag) {
    Distance len = last - first;
    Distance half;
    RandomAccessIterator middle, left, right;

    while (len > 0) {
	half = len / 2;
	middle = first + half;
	if (comp(*middle, value)) {
	    first = middle + 1;
	    len = len - half - 1;
	} else if (comp(value, *middle))
	    len = half;
	else {
	    left = lower_bound(first, middle, value, comp);
	    right = upper_bound(++middle, first + len, value, comp);
	    return pair<RandomAccessIterator, RandomAccessIterator>(left,
								    right);
	}
    }
    return pair<RandomAccessIterator, RandomAccessIterator>(first, first);
}           

template <class ForwardIterator, class T, class Compare>
inline pair<ForwardIterator, ForwardIterator>
equal_range(ForwardIterator first, ForwardIterator last, const T& value,
	    Compare comp) {
    return __equal_range(first, last, value, comp, distance_type(first),
			 iterator_category(first));
}    

template <class ForwardIterator, class T>
bool binary_search(ForwardIterator first, ForwardIterator last,
		   const T& value) {
    ForwardIterator i = lower_bound(first, last, value);
    return i != last && !(value < *i);
}

template <class ForwardIterator, class T, class Compare>
bool binary_search(ForwardIterator first, ForwardIterator last, const T& value,
		   Compare comp) {
    ForwardIterator i = lower_bound(first, last, value, comp);
    return i != last && !comp(value, *i);
}

template <class InputIterator1, class InputIterator2, class OutputIterator>
OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
		     InputIterator2 first2, InputIterator2 last2,
		     OutputIterator result) {
    while (first1 != last1 && first2 != last2)
	if (*first2 < *first1)
	    *result++ = *first2++;
	else
	    *result++ = *first1++;
    return copy(first2, last2, copy(first1, last1, result));
}

template <class InputIterator1, class InputIterator2, class OutputIterator,
	  class Compare>
OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
		     InputIterator2 first2, InputIterator2 last2,
		     OutputIterator result, Compare comp) {
    while (first1 != last1 && first2 != last2)
	if (comp(*first2, *first1))
	    *result++ = *first2++;
	else
	    *result++ = *first1++;
    return copy(first2, last2, copy(first1, last1, result));
}

template <class BidirectionalIterator, class Distance>
void __merge_without_buffer(BidirectionalIterator first,
			    BidirectionalIterator middle,
			    BidirectionalIterator last,
			    Distance len1, Distance len2) {
    if (len1 == 0 || len2 == 0) return;
    if (len1 + len2 == 2) {
	if (*middle < *first) iter_swap(first, middle);
	return;
    }
    BidirectionalIterator first_cut = first;
    BidirectionalIterator second_cut = middle;
    Distance len11 = 0;
    Distance len22 = 0;
    if (len1 > len2) {
	len11 = len1 / 2;
	advance(first_cut, len11);
	second_cut = lower_bound(middle, last, *first_cut);
	distance(middle, second_cut, len22);
    } else {
	len22 = len2 / 2;
	advance(second_cut, len22);
	first_cut = upper_bound(first, middle, *second_cut);
	distance(first, first_cut, len11);
    }
    rotate(first_cut, middle, second_cut);
    BidirectionalIterator new_middle = first_cut;
    advance(new_middle, len22);
    __merge_without_buffer(first, first_cut, new_middle, len11, len22);
    __merge_without_buffer(new_middle, second_cut, last, len1 - len11,
			   len2 - len22);
}

template <class BidirectionalIterator, class Distance, class Compare>
void __merge_without_buffer(BidirectionalIterator first,
			    BidirectionalIterator middle,
			    BidirectionalIterator last,
			    Distance len1, Distance len2, Compare comp) {
    if (len1 == 0 || len2 == 0) return;
    if (len1 + len2 == 2) {
	if (comp(*middle, *first)) iter_swap(first, middle);
	return;
    }
    BidirectionalIterator first_cut = first;
    BidirectionalIterator second_cut = middle;
    Distance len11 = 0;
    Distance len22 = 0;
    if (len1 > len2) {
	len11 = len1 / 2;
	advance(first_cut, len11);
	second_cut = lower_bound(middle, last, *first_cut, comp);
	distance(middle, second_cut, len22);
    } else {
	len22 = len2 / 2;
	advance(second_cut, len22);
	first_cut = upper_bound(first, middle, *second_cut, comp);
	distance(first, first_cut, len11);
    }
    rotate(first_cut, middle, second_cut);
    BidirectionalIterator new_middle = first_cut;
    advance(new_middle, len22);
    __merge_without_buffer(first, first_cut, new_middle, len11, len22, comp);
    __merge_without_buffer(new_middle, second_cut, last, len1 - len11,
			   len2 - len22, comp);
}


template <class InputIterator, class OutputIterator>
OutputIterator __borland_bugfix_copy(InputIterator first, InputIterator last,
		    OutputIterator result) {
// this is used in __rotate_adaptive to work around some obscure Borland
// bug. It is the same as copy, but with a different (and appropriate) name.
    while (first != last) *result++ = *first++;
    return result;
}

template <class BidirectionalIterator1, class BidirectionalIterator2,
	  class Distance>
BidirectionalIterator1 __rotate_adaptive(BidirectionalIterator1 first,
					 BidirectionalIterator1 middle,
					 BidirectionalIterator1 last,
					 Distance len1, Distance len2,
					 BidirectionalIterator2 buffer,
					 Distance buffer_size) {
    BidirectionalIterator2 buffer_end;
    if (len1 > len2 && len2 <= buffer_size) {
	buffer_end = __borland_bugfix_copy(middle, last, buffer);
	copy_backward(first, middle, last);
	return copy(buffer, buffer_end, first);
    } else if (len1 <= buffer_size) {
	buffer_end = __borland_bugfix_copy(first, middle, buffer);
	copy(middle, last, first);
	return copy_backward(buffer, buffer_end, last);
    } else  {
	rotate(first, middle, last);
	advance(first, len2);
	return first;
    }
}

template <class BidirectionalIterator1, class BidirectionalIterator2,
	  class BidirectionalIterator3>
BidirectionalIterator3 __merge_backward(BidirectionalIterator1 first1,
					BidirectionalIterator1 last1,
					BidirectionalIterator2 first2,
					BidirectionalIterator2 last2,
					BidirectionalIterator3 result) {
    if (first1 == last1) return copy_backward(first2, last2, result);
    if (first2 == last2) return copy_backward(first1, last1, result);
    --last1;
    --last2;
    while (true) {
	if (*last2 < *last1) {
	    *--result = *last1;
	    if (first1 == last1) return copy_backward(first2, ++last2, result);
	    --last1;
	} else {
	    *--result = *last2;
	    if (first2 == last2) return copy_backward(first1, ++last1, result);
	    --last2;
	}
    }
}

template <class BidirectionalIterator1, class BidirectionalIterator2,
	  class BidirectionalIterator3, class Compare>
BidirectionalIterator3 __merge_backward(BidirectionalIterator1 first1,
					BidirectionalIterator1 last1,
					BidirectionalIterator2 first2,
					BidirectionalIterator2 last2,
					BidirectionalIterator3 result,
					Compare comp) {
    if (first1 == last1) return copy_backward(first2, last2, result);
    if (first2 == last2) return copy_backward(first1, last1, result);
    --last1;
    --last2;
    while (true) {
	if (comp(*last2, *last1)) {
	    *--result = *last1;
	    if (first1 == last1) return copy_backward(first2, ++last2, result);
	    --last1;
	} else {
	    *--result = *last2;
	    if (first2 == last2) return copy_backward(first1, ++last1, result);
	    --last2;
	}
    }
}

template <class BidirectionalIterator, class Distance, class Pointer, class T>
void __merge_adaptive(BidirectionalIterator first, 
		      BidirectionalIterator middle, 
		      BidirectionalIterator last, Distance len1, Distance len2,
		      Pointer buffer, Distance buffer_size, T*) {
    if (len1 <= len2 && len1 <= buffer_size) {
        Pointer end_buffer = copy(first, middle, buffer);
        merge(buffer, end_buffer, middle, last, first);
    } else if (len2 <= buffer_size) {
        Pointer end_buffer = copy(middle, last, buffer);
        __merge_backward(first, middle, buffer, end_buffer, last);
    } else {
	BidirectionalIterator first_cut = first;
	BidirectionalIterator second_cut = middle;
	Distance len11 = 0;
	Distance len22 = 0;
	if (len1 > len2) {
	    len11 = len1 / 2;
	    advance(first_cut, len11);
	    second_cut = lower_bound(middle, last, *first_cut);
	    distance(middle, second_cut, len22);   
	} else {
	    len22 = len2 / 2;
	    advance(second_cut, len22);
	    first_cut = upper_bound(first, middle, *second_cut);
	    distance(first, first_cut, len11);
	}
	BidirectionalIterator new_middle =
	    __rotate_adaptive(first_cut, middle, second_cut, len1 - len11,
			      len22, buffer, buffer_size);
	__merge_adaptive(first, first_cut, new_middle, len11, len22, buffer,
			 buffer_size, (T*)0);
	__merge_adaptive(new_middle, second_cut, last, len1 - len11,
			 len2 - len22, buffer, buffer_size, (T*)0);
    }
}

template <class BidirectionalIterator, class Distance, class Pointer, class T,
	  class Compare>
void __merge_adaptive(BidirectionalIterator first, 
		      BidirectionalIterator middle, 
		      BidirectionalIterator last, Distance len1, Distance len2,
		      Pointer buffer, Distance buffer_size, T*, Compare comp) {
    if (len1 <= len2 && len1 <= buffer_size) {
	Pointer end_buffer = copy(first, middle, buffer);
	merge(buffer, end_buffer, middle, last, first, comp);
    } else if (len2 <= buffer_size) {
	Pointer end_buffer = copy(middle, last, buffer);
	__merge_backward(first, middle, buffer, end_buffer, last, comp);
    } else {
	BidirectionalIterator first_cut = first;
	BidirectionalIterator second_cut = middle;
	Distance len11 = 0;
	Distance len22 = 0;
	if (len1 > len2) {
	    len11 = len1 / 2;
	    advance(first_cut, len11);
	    second_cut = lower_bound(middle, last, *first_cut, comp);
	    distance(middle, second_cut, len22);   
	} else {
	    len22 = len2 / 2;
	    advance(second_cut, len22);
	    first_cut = upper_bound(first, middle, *second_cut, comp);
	    distance(first, first_cut, len11);
	}
	BidirectionalIterator new_middle =
	    __rotate_adaptive(first_cut, middle, second_cut, len1 - len11,
			      len22, buffer, buffer_size);
	__merge_adaptive(first, first_cut, new_middle, len11, len22, buffer,
			 buffer_size, (T*)0, comp);
	__merge_adaptive(new_middle, second_cut, last, len1 - len11,
			 len2 - len22, buffer, buffer_size, (T*)0, comp);
    }
}

template <class BidirectionalIterator, class Distance, class Pointer, class T>
void __inplace_merge(BidirectionalIterator first,
		     BidirectionalIterator middle, 
		     BidirectionalIterator last, Distance len1, Distance len2,
		     pair<Pointer, Distance> p, T*) {
    if (p.first == 0) {
	__merge_without_buffer(first, middle, last, len1, len2);
	return;
    }
    Distance len = stlmin(p.second, len1 + len2);
    fill_n(raw_storage_iterator<Pointer, T>(p.first), len, *first);
    __merge_adaptive(first, middle, last, len1, len2, p.first, p.second, (T*)0);
    destroy(p.first, p.first + len);
    return_temporary_buffer(p.first);
}

template <class BidirectionalIterator, class Distance, class Pointer, class T,
	  class Compare>
void __inplace_merge(BidirectionalIterator first,
		     BidirectionalIterator middle, 
		     BidirectionalIterator last, Distance len1, Distance len2,
		     pair<Pointer, Distance> p, T*, Compare comp) {
    if (p.first == 0) {
	__merge_without_buffer(first, middle, last, len1, len2, comp);
	return;
    }
    Distance len = stlmin(p.second, len1 + len2);
    fill_n(raw_storage_iterator<Pointer, T>(p.first), len, *first);
    __merge_adaptive(first, middle, last, len1, len2, p.first, p.second, (T*)0,
		     comp); 
    destroy(p.first, p.first + len);
    return_temporary_buffer(p.first);
}

template <class BidirectionalIterator, class T, class Distance>
inline void __inplace_merge_aux(BidirectionalIterator first,
				BidirectionalIterator middle,
				BidirectionalIterator last, T*, Distance*) {
    Distance len1 = 0;
    distance(first, middle, len1);
    Distance len2 = 0;
    distance(middle, last, len2);
    __inplace_merge(first, middle, last, len1, len2,
		    get_temporary_buffer(len1 + len2, (T*)0), (T*)0);
}

template <class BidirectionalIterator, class T, class Distance, class Compare>
inline void __inplace_merge_aux(BidirectionalIterator first,
				BidirectionalIterator middle,
				BidirectionalIterator last, T*, Distance*,
				Compare comp) {
    Distance len1 = 0;
    distance(first, middle, len1);
    Distance len2 = 0;
    distance(middle, last, len2);
    __inplace_merge(first, middle, last, len1, len2,
		    get_temporary_buffer(len1 + len2, (T*)0), (T*)0,
		    comp);
}

template <class BidirectionalIterator>
inline void inplace_merge(BidirectionalIterator first,
			  BidirectionalIterator middle,
			  BidirectionalIterator last) {
    if (first == middle || middle == last) return;
    __inplace_merge_aux(first, middle, last, value_type(first),
			distance_type(first));
}

template <class BidirectionalIterator, class Compare>
inline void inplace_merge(BidirectionalIterator first,
			  BidirectionalIterator middle,
			  BidirectionalIterator last, Compare comp) {
    if (first == middle || middle == last) return;
    __inplace_merge_aux(first, middle, last, value_type(first),
			distance_type(first), comp);
}

template <class InputIterator1, class InputIterator2>
bool includes(InputIterator1 first1, InputIterator1 last1,
	      InputIterator2 first2, InputIterator2 last2) {
    while (first1 != last1 && first2 != last2)
	if (*first2 < *first1)
	    return false;
	else if(*first1 < *first2) 
	    ++first1;
	else
	    ++first1, ++first2;

    return first2 == last2;
}

template <class InputIterator1, class InputIterator2, class Compare>
bool includes(InputIterator1 first1, InputIterator1 last1,
	      InputIterator2 first2, InputIterator2 last2, Compare comp) {
    while (first1 != last1 && first2 != last2)
	if (comp(*first2, *first1))
	    return false;
	else if(comp(*first1, *first2)) 
	    ++first1;
	else
	    ++first1, ++first2;

    return first2 == last2;
}

template <class InputIterator1, class InputIterator2, class OutputIterator>
OutputIterator set_union(InputIterator1 first1, InputIterator1 last1,
			 InputIterator2 first2, InputIterator2 last2,
			 OutputIterator result) {
    while (first1 != last1 && first2 != last2)
	if (*first1 < *first2)
	    *result++ = *first1++;
	else if (*first2 < *first1)
	    *result++ = *first2++;
	else {
	    *result++ = *first1++;
	    first2++;
	}
    return copy(first2, last2, copy(first1, last1, result));
}

template <class InputIterator1, class InputIterator2, class OutputIterator,
	  class Compare>
OutputIterator set_union(InputIterator1 first1, InputIterator1 last1,
			 InputIterator2 first2, InputIterator2 last2,
			 OutputIterator result, Compare comp) {
    while (first1 != last1 && first2 != last2)
	if (comp(*first1, *first2))
	    *result++ = *first1++;
	else if (comp(*first2, *first1))
	    *result++ = *first2++;
	else {
	    *result++ = *first1++;
	    ++first2;
	}
    return copy(first2, last2, copy(first1, last1, result));
}

template <class InputIterator1, class InputIterator2, class OutputIterator>
OutputIterator set_intersection(InputIterator1 first1, InputIterator1 last1,
				InputIterator2 first2, InputIterator2 last2,
				OutputIterator result) {
    while (first1 != last1 && first2 != last2)
	if (*first1 < *first2)
	    ++first1;
	else if (*first2 < *first1)
	    ++first2;
	else {
	    *result++ = *first1++;
	    ++first2;
	}
    return result;
}

template <class InputIterator1, class InputIterator2, class OutputIterator,
	  class Compare>
OutputIterator set_intersection(InputIterator1 first1, InputIterator1 last1,
				InputIterator2 first2, InputIterator2 last2,
				OutputIterator result, Compare comp) {
    while (first1 != last1 && first2 != last2)
	if (comp(*first1, *first2))
	    ++first1;
	else if (comp(*first2, *first1))
	    ++first2;
	else {
	    *result++ = *first1++;
	    ++first2;
	}
    return result;
}

template <class InputIterator1, class InputIterator2, class OutputIterator>
OutputIterator set_difference(InputIterator1 first1, InputIterator1 last1,
			      InputIterator2 first2, InputIterator2 last2,
			      OutputIterator result) {
    while (first1 != last1 && first2 != last2)
	if (*first1 < *first2)
	    *result++ = *first1++;
	else if (*first2 < *first1)
	    ++first2;
	else {
	    ++first1;
	    ++first2;
	}
    return copy(first1, last1, result);
}

template <class InputIterator1, class InputIterator2, class OutputIterator, 
	  class Compare>
OutputIterator set_difference(InputIterator1 first1, InputIterator1 last1,
			      InputIterator2 first2, InputIterator2 last2, 
			      OutputIterator result, Compare comp) {
    while (first1 != last1 && first2 != last2)
	if (comp(*first1, *first2))
	    *result++ = *first1++;
	else if (comp(*first2, *first1))
	    ++first2;
	else {
	    ++first1;
	    ++first2;
	}
    return copy(first1, last1, result);
}

template <class InputIterator1, class InputIterator2, class OutputIterator>
OutputIterator set_symmetric_difference(InputIterator1 first1,
					InputIterator1 last1,
					InputIterator2 first2,
					InputIterator2 last2,
					OutputIterator result) {
    while (first1 != last1 && first2 != last2)
	if (*first1 < *first2)
	    *result++ = *first1++;
	else if (*first2 < *first1)
	    *result++ = *first2++;
	else {
	    ++first1;
	    ++first2;
	}
    return copy(first2, last2, copy(first1, last1, result));
}

template <class InputIterator1, class InputIterator2, class OutputIterator,
	  class Compare>
OutputIterator set_symmetric_difference(InputIterator1 first1,
					InputIterator1 last1,
					InputIterator2 first2,
					InputIterator2 last2,
					OutputIterator result, Compare comp) {
    while (first1 != last1 && first2 != last2)
	if (comp(*first1, *first2))
	    *result++ = *first1++;
	else if (comp(*first2, *first1))
	    *result++ = *first2++;
	else {
	    ++first1;
	    ++first2;
	}
    return copy(first2, last2, copy(first1, last1, result));
}

template <class ForwardIterator>
ForwardIterator max_element(ForwardIterator first, ForwardIterator last) {
    if (first == last) return first;
    ForwardIterator result = first;
    while (++first != last) 
	if (*result < *first) result = first;
    return result;
}

template <class ForwardIterator, class Compare>
ForwardIterator max_element(ForwardIterator first, ForwardIterator last,
			    Compare comp) {
    if (first == last) return first;
    ForwardIterator result = first;
    while (++first != last) 
	if (comp(*result, *first)) result = first;
    return result;
}

template <class ForwardIterator>
ForwardIterator min_element(ForwardIterator first, ForwardIterator last) {
    if (first == last) return first;
    ForwardIterator result = first;
    while (++first != last) 
	if (*first < *result) result = first;
    return result;
}

template <class ForwardIterator, class Compare>
ForwardIterator min_element(ForwardIterator first, ForwardIterator last,
			    Compare comp) {
    if (first == last) return first;
    ForwardIterator result = first;
    while (++first != last) 
	if (comp(*first, *result)) result = first;
    return result;
}

template <class BidirectionalIterator>
bool next_permutation(BidirectionalIterator first,
		      BidirectionalIterator last) {
    if (first == last) return false;
    BidirectionalIterator i = first;
    ++i;
    if (i == last) return false;
    i = last;
    --i;

    for(;;) {
	BidirectionalIterator ii = i--;
	if (*i < *ii) {
	    BidirectionalIterator j = last;
	    while (!(*i < *--j));
	    iter_swap(i, j);
	    reverse(ii, last);
	    return true;
	}
	if (i == first) {
	    reverse(first, last);
	    return false;
	}
    }
}

template <class BidirectionalIterator, class Compare>
bool next_permutation(BidirectionalIterator first, BidirectionalIterator last,
		      Compare comp) {
    if (first == last) return false;
    BidirectionalIterator i = first;
    ++i;
    if (i == last) return false;
    i = last;
    --i;

    for(;;) {
	BidirectionalIterator ii = i--;
	if (comp(*i, *ii)) {
	    BidirectionalIterator j = last;
	    while (!comp(*i, *--j));
	    iter_swap(i, j);
	    reverse(ii, last);
	    return true;
	}
	if (i == first) {
	    reverse(first, last);
	    return false;
	}
    }
}

template <class BidirectionalIterator>
bool prev_permutation(BidirectionalIterator first,
		      BidirectionalIterator last) {
    if (first == last) return false;
    BidirectionalIterator i = first;
    ++i;
    if (i == last) return false;
    i = last;
    --i;

    for(;;) {
	BidirectionalIterator ii = i--;
	if (*ii < *i) {
	    BidirectionalIterator j = last;
	    while (!(*--j < *i));
	    iter_swap(i, j);
	    reverse(ii, last);
	    return true;
	}
	if (i == first) {
	    reverse(first, last);
	    return false;
	}
    }
}

template <class BidirectionalIterator, class Compare>
bool prev_permutation(BidirectionalIterator first, BidirectionalIterator last,
		      Compare comp) {
    if (first == last) return false;
    BidirectionalIterator i = first;
    ++i;
    if (i == last) return false;
    i = last;
    --i;

    for(;;) {
	BidirectionalIterator ii = i--;
	if (comp(*ii, *i)) {
	    BidirectionalIterator j = last;
	    while (!comp(*--j, *i));
	    iter_swap(i, j);
	    reverse(ii, last);
	    return true;
	}
	if (i == first) {
	    reverse(first, last);
	    return false;
	}
    }
}

template <class InputIterator, class T>
T accumulate(InputIterator first, InputIterator last, T init) {
    while (first != last) 
	init = init + *first++;
    return init;
}

template <class InputIterator, class T, class BinaryOperation>
T accumulate(InputIterator first, InputIterator last, T init,
	     BinaryOperation binary_op) {
    while (first != last) 
	init = binary_op(init, *first++);
    return init;
}

template <class InputIterator1, class InputIterator2, class T>
T inner_product(InputIterator1 first1, InputIterator1 last1,
		InputIterator2 first2, T init) {
    while (first1 != last1) 
	init = init + (*first1++ * *first2++);
    return init;
}

template <class InputIterator1, class InputIterator2, class T,
	  class BinaryOperation1, class BinaryOperation2>
T inner_product(InputIterator1 first1, InputIterator1 last1,
		InputIterator2 first2, T init, BinaryOperation1 binary_op1,
		BinaryOperation2 binary_op2) {
    while (first1 != last1) 
	init = binary_op1(init, binary_op2(*first1++, *first2++));
    return init;
}

template <class InputIterator, class OutputIterator, class T>
OutputIterator __partial_sum(InputIterator first, InputIterator last,
			     OutputIterator result, T*) {
    T value = *first;
    while (++first != last) {
	value = value + *first;
	*++result = value;
    }
    return ++result;
}

template <class InputIterator, class OutputIterator>
OutputIterator partial_sum(InputIterator first, InputIterator last,
			   OutputIterator result) {
    if (first == last) return result;
    *result = *first;
    return __partial_sum(first, last, result, value_type(first));
}

template <class InputIterator, class OutputIterator, class T,
	  class BinaryOperation>
OutputIterator __partial_sum(InputIterator first, InputIterator last,
			     OutputIterator result, T*,
			     BinaryOperation binary_op) {
    T value = *first;
    while (++first != last) {
	value = binary_op(value, *first);
	*++result = value;
    }
    return ++result;
}

template <class InputIterator, class OutputIterator, class BinaryOperation>
OutputIterator partial_sum(InputIterator first, InputIterator last,
			   OutputIterator result, BinaryOperation binary_op) {
    if (first == last) return result;
    *result = *first;
    return __partial_sum(first, last, result, value_type(first), binary_op);
}

template <class InputIterator, class OutputIterator, class T>
OutputIterator __adjacent_difference(InputIterator first, InputIterator last, 
				     OutputIterator result, T*) {
    T value = *first;
    while (++first != last) {
	T tmp = *first;
	*++result = tmp - value;
	value = tmp;
    }
    return ++result;
}

template <class InputIterator, class OutputIterator>
OutputIterator adjacent_difference(InputIterator first, InputIterator last, 
				   OutputIterator result) {
    if (first == last) return result;
    *result = *first;
    return __adjacent_difference(first, last, result, value_type(first));
}

template <class InputIterator, class OutputIterator, class T, 
	  class BinaryOperation>
OutputIterator __adjacent_difference(InputIterator first, InputIterator last, 
				     OutputIterator result, T*,
				     BinaryOperation binary_op) {
    T value = *first;
    while (++first != last) {
	T tmp = *first;
	*++result = binary_op(tmp, value);
	value = tmp;
    }
    return ++result;
}

template <class InputIterator, class OutputIterator, class BinaryOperation>
OutputIterator adjacent_difference(InputIterator first, InputIterator last,
				   OutputIterator result,
				   BinaryOperation binary_op) {
    if (first == last) return result;
    *result = *first;
    return __adjacent_difference(first, last, result, value_type(first),
				 binary_op);
}

template <class ForwardIterator, class T>
void iota(ForwardIterator first, ForwardIterator last, T value) {
    while (first != last) *first++ = value++;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\defalloc.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef DEFALLOC_H
#define DEFALLOC_H

#include <new.h>
#include <stddef.h>
#include <stdlib.h>
#include <limits.h>
#include <iostream.h>
#include <algobase.h>

#ifndef _MSC_VER
inline void* operator new(size_t, void* p) {return p;}
#endif
 
/*
 * the following template function is replaced by the following two functions
 * due to the fact that the Borland compiler doesn't change prediff_t type
 * to type long when compile with -ml or -mh.

template <class T>
inline T* allocate(ptrdiff_t size, T*) {
    set_new_handler(0);
    T* tmp = (T*)(::operator new((size_t)(size * sizeof(T))));
    if (tmp == 0) {
	cerr << "out of memory" << endl; 
	exit(1);
    }
    return tmp;
}
*/

template <class T>
inline T* allocate(int size, T*) {
    _set_new_handler(0);
    // FIXED by David Putzolu - used to use set_new_handler(0) instead
    // of _set_new_handler. MSVC 4.2b chokes on the former.
    T* tmp = (T*)(::operator new((unsigned int)(size * sizeof(T))));
    if (tmp == 0) {
	cerr << "out of memory" << endl; 
	exit(1);
    }
    return tmp;
}

template <class T>
inline T* allocate(long size, T*) {
    _set_new_handler(0);
    // FIXED by David Putzolu - used to use set_new_handler(0) instead
    // of _set_new_handler. MSVC 4.2b chokes on the former.
    T* tmp = (T*)(::operator new((unsigned long)(size * sizeof(T))));
    if (tmp == 0) {
	cerr << "out of memory" << endl; 
	exit(1);
    }
    return tmp;
}

template <class T>
inline T* allocate(size_t size, T*) {
    _set_new_handler(0);
    // FIXED by David Putzolu - used to use set_new_handler(0) instead
    // of _set_new_handler. MSVC 4.2b chokes on the former.
    T* tmp = (T*)(::operator new((size_t)(size * sizeof(T))));
    if (tmp == 0) {
	cerr << "out of memory" << endl; 
	exit(1);
    }
    return tmp;
}

template <class T>
inline void deallocate(T* buffer) {
    ::operator delete((PVOID) buffer);
}

template <class T>
inline void destroy(T* pointer) {
    pointer->~T();
}

inline void destroy(char*) {}
inline void destroy(unsigned char*) {}
inline void destroy(short*) {}
inline void destroy(unsigned short*) {}
inline void destroy(int*) {}
inline void destroy(unsigned int*) {}
inline void destroy(long*) {}
inline void destroy(unsigned long*) {}
inline void destroy(float*) {}
inline void destroy(double*) {}
inline void destroy(char**) {}
inline void destroy(unsigned char**) {}
inline void destroy(short**) {}
inline void destroy(unsigned short**) {}
inline void destroy(int**) {}
inline void destroy(unsigned int**) {}
inline void destroy(long**) {}
inline void destroy(unsigned long**) {}
inline void destroy(float**) {}
inline void destroy(double**) {}

inline void destroy(char*, char*) {}
inline void destroy(unsigned char*, unsigned char*) {}
inline void destroy(short*, short*) {}
inline void destroy(unsigned short*, unsigned short*) {}
inline void destroy(int*, int*) {}
inline void destroy(unsigned int*, unsigned int*) {}
inline void destroy(long*, long*) {}
inline void destroy(unsigned long*, unsigned long*) {}
inline void destroy(float*, float*) {}
inline void destroy(double*, double*) {}
inline void destroy(char**, char**) {}
inline void destroy(unsigned char**, unsigned char**) {}
inline void destroy(short**, short**) {}
inline void destroy(unsigned short**, unsigned short**) {}
inline void destroy(int**, int**) {}
inline void destroy(unsigned int**, unsigned int**) {}
inline void destroy(long**, long**) {}
inline void destroy(unsigned long**, unsigned long**) {}
inline void destroy(float**, float**) {}
inline void destroy(double**, double**) {}

template <class T1, class T2>
inline void construct(T1* p, const T2& value) {
    new (p) T1(value);
}

template <class T>
class allocator {
public:
    typedef T value_type;
    typedef T* pointer;
    typedef const T* const_pointer;
    typedef T& reference;
    typedef const T& const_reference;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    pointer allocate(size_type n) { 
	return ::allocate(n, (pointer)0);
    }
    void deallocate(pointer p) { ::deallocate(p); }
    pointer address(reference x) { return (pointer)&x; }
    const_pointer const_address(const_reference x) { 
	return (const_pointer)&x; 
    }
    size_type init_page_size() { 
	return stlmax(size_type(1), size_type(4096/sizeof(T))); 
    }
    size_type max_size() const { 
	return stlmax(size_type(1), size_type(UINT_MAX/sizeof(T))); 
    }
};

class allocator<void> {
public:
    typedef void* pointer;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\fdeque.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef FDEQUE_H
#define FDEQUE_H

#ifdef DEQUE_H
#undef DEQUE_H
#define __DEQUE_WAS_DEFINED
#endif

#define Allocator far_allocator
#define deque far_deque
#include <faralloc.h>
#include <deque.h>

#undef DEQUE_H

#ifdef __DEQUE_WAS_DEFINED
#define DEQUE_H
#undef  __DEQUE_WAS_DEFINED
#endif

#undef Allocator
#undef deque

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\deque.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef DEQUE_H
#define DEQUE_H

#include <function.h>
#include <algobase.h>
#include <iterator.h>
#include <bool.h>

#ifndef Allocator
#define Allocator allocator
#include <defalloc.h>
#endif

#ifndef deque 
#define deque deque
#endif

template <class T> 
class deque {
public:
    class iterator;
    class const_iterator;
    friend class iterator;
    friend class const_iterator;
public:
    typedef T value_type;
    typedef Allocator<T> data_allocator_type;
    typedef Allocator<T>::pointer pointer;
    typedef Allocator<T>::reference reference;
    typedef Allocator<T>::const_reference const_reference;
    typedef Allocator<T>::size_type size_type;
    typedef Allocator<T>::difference_type difference_type;
    typedef Allocator<pointer> map_allocator_type;   
protected:
    static data_allocator_type data_allocator;
    static size_type buffer_size;
    static map_allocator_type map_allocator;
    typedef Allocator<pointer>::pointer map_pointer;
public:
    class iterator : public random_access_iterator<T, difference_type> {
    friend class deque<T>;
    friend class const_iterator;
    protected:
	pointer current;
	pointer first;
	pointer last;
	map_pointer node;
	iterator(pointer x, map_pointer y) 
	    : current(x), first(*y), last(*y + buffer_size), node(y) {}
    public:
	iterator() : current(0), first(0), last(0), node(0) {}
	reference operator*() const { return *current; }
	difference_type operator-(const iterator& x) const {
	    return node == x.node 
		? current - x.current 
		: difference_type(buffer_size * (node - x.node - 1) +
				  (current - first) + (x.last - x.current));
	}
	iterator& operator++() {
	    if (++current == last) {
		first = *(++node);
		current = first;
		last = first + buffer_size;
	    }
	    return *this; 
	}
	iterator operator++(int)  {
	    iterator tmp = *this;
	    ++*this;
	    return tmp;
	}
	iterator& operator--() {
	    if (current == first) {
		first = *(--node);
		last = first + buffer_size;
		current = last;
	    }
	    --current;
	    return *this;
	}
	iterator operator--(int) {
	    iterator tmp = *this;
	    --*this;
	    return tmp;
	}
	iterator& operator+=(difference_type n) {
	    difference_type offset = n + (current - first);
	    difference_type num_node_to_jump = offset >= 0
		? offset / buffer_size
		: -((-offset + buffer_size - 1) / buffer_size);
	    if (num_node_to_jump == 0)
		current += n;
	    else {
		node = node + num_node_to_jump;
		first = *node;
		last = first + buffer_size;
		current = first + (offset - num_node_to_jump * buffer_size);
	    }
	    return *this;
	}
	iterator& operator-=(difference_type n) { return *this += -n; }
	iterator operator+(difference_type n) const {
	    iterator tmp = *this;
	    return tmp += n;
	}
	iterator operator-(difference_type n) const {
	    iterator tmp = *this;
	    return tmp -= n;
	}
	reference operator[](difference_type n) const { return *(*this + n); }
	bool operator==(const iterator& x) const {      
	    return current == x.current || 
		((current == first || x.current == x.first) && 
		 *this - x == 0);
	}
	bool operator<(const iterator& x) const {
	    return (node == x.node) ? (current < x.current) : (node < x.node);
	}
    };
    class const_iterator : public random_access_iterator<T, difference_type> {
    friend class deque<T>;
    protected:
	pointer current;
	pointer first;
	pointer last;
	map_pointer node;
	const_iterator(pointer x, map_pointer y) 
	    : current(x), first(*y), last(*y + buffer_size), node(y) {}
    public:
	const_iterator() : current(0), first(0), last(0), node(0) {}
	const_iterator(const iterator& x) 
	    : current(x.current), first(x.first), last(x.last), node(x.node) {}     
	const_reference operator*() const { return *current; }
	difference_type operator-(const const_iterator& x) const {
	    return node == x.node 
		? current - x.current 
		: difference_type(buffer_size * (node - x.node - 1) +
				  (current - first) + (x.last - x.current));
	}
	const_iterator& operator++() {
	    if (++current == last) {
		first = *(++node);
		current = first;
		last = first + buffer_size;
	    }
	    return *this; 
	}
	const_iterator operator++(int)  {
	    const_iterator tmp = *this;
	    ++*this;
	    return tmp;
	}
	const_iterator& operator--() {
	    if (current == first) {
		first = *(--node);
		last = first + buffer_size;
		current = last;
	    }
	    --current;
	    return *this;
	}
	const_iterator operator--(int) {
	    const_iterator tmp = *this;
	    --*this;
	    return tmp;
	}
	const_iterator& operator+=(difference_type n) {
	    difference_type offset = n + (current - first);
	    difference_type num_node_to_jump = offset >= 0
		? offset / buffer_size
		: -((-offset + buffer_size - 1) / buffer_size);
	    if (num_node_to_jump == 0)
		current += n;
	    else {
		node = node + num_node_to_jump;
		first = *node;
		last = first + buffer_size;
		current = first + (offset - num_node_to_jump * buffer_size);
	    }
	    return *this;
	}
	const_iterator& operator-=(difference_type n) { return *this += -n; }
	const_iterator operator+(difference_type n) const {
	    const_iterator tmp = *this;
	    return tmp += n;
	}
	const_iterator operator-(difference_type n) const {
	    const_iterator tmp = *this;
	    return tmp -= n;
	}
	const_reference operator[](difference_type n) const { 
	    return *(*this + n); 
	}
	bool operator==(const const_iterator& x) const {      
	    return current == x.current || 
		((current == first || x.current == x.first) && 
		 *this - x == 0);
	}
	bool operator<(const const_iterator& x) const {
	    return (node == x.node) ? (current < x.current) : (node < x.node);
	}
    };
    typedef reverse_iterator<const_iterator, value_type, const_reference, 
                             difference_type>  const_reverse_iterator;
    typedef reverse_iterator<iterator, value_type, reference, difference_type>
        reverse_iterator; 
protected:    
    iterator start;
    iterator finish;
    size_type length;
    map_pointer map;
    size_type map_size;

    void allocate_at_begin();
    void allocate_at_end();
    void deallocate_at_begin();
    void deallocate_at_end();

public:
    deque() : start(), finish(), length(0), map(0), map_size(0) {
	buffer_size = data_allocator.init_page_size();
    }
    iterator begin() { return start; }
    const_iterator begin() const { return start; }
    iterator end() { return finish; }
    const_iterator end() const { return finish; }
    reverse_iterator rbegin() { return reverse_iterator(end()); }
    const_reverse_iterator rbegin() const { 
        return const_reverse_iterator(end()); 
    }
    reverse_iterator rend() { return reverse_iterator(begin()); }
    const_reverse_iterator rend() const { 
        return const_reverse_iterator(begin()); 
    } 
    bool empty() const { return length == 0; }
    size_type size() const { return length; }
    size_type max_size() const { return data_allocator.max_size(); }
    reference operator[](size_type n) { return *(begin() + n); }
    const_reference operator[](size_type n) const { return *(begin() + n); }
    reference front() { return *begin(); }
    const_reference front() const { return *begin(); }
    reference back() { return *(end() - 1); }
    const_reference back() const { return *(end() - 1); }
    void push_front(const T& x) {
	if (empty() || begin().current == begin().first)
	    allocate_at_begin();
	--start.current;
	construct(start.current, x);
	++length;
	if (end().current == end().last) allocate_at_end();
    }
    void push_back(const T& x) {
	if (empty()) allocate_at_end();
	construct(finish.current, x);
	++finish.current;
	++length;
	if (end().current == end().last) allocate_at_end();
    }
    void pop_front() {
	destroy(start.current);
	++start.current;
	--length; 
	if (empty() || begin().current == begin().last)
	    deallocate_at_begin();
    }
    void pop_back() {
	if (end().current == end().first) deallocate_at_end();
	--finish.current;
	destroy(finish.current);
	--length; 
	if (empty()) deallocate_at_end();
    }
    void swap(deque<T>& x) {
	::swap(start, x.start);
	::swap(finish, x.finish);
	::swap(length, x.length);
	::swap(map, x.map);
	::swap(map_size, x.map_size);
    }
    iterator insert(iterator position, const T& x);
    void insert(iterator position, size_type n, const T& x);
//  template <class Iterator> void insert(iterator position,
//                                        Iterator first, Iterator last);
    void insert(iterator position, const T* first, const T* last);
    void erase(iterator position);
    void erase(iterator first, iterator last);    
    deque(size_type n, const T& value = T())
	: start(), finish(), length(0), map(0), map_size(0) {
	buffer_size = data_allocator.init_page_size();  
	insert(begin(), n, value);
    }
//  template <class Iterator> deque(Iterator first, Iterator last);
    deque(const T* first, const T* last)
	: start(), finish(), length(0), map(0), map_size(0) {
	buffer_size = data_allocator.init_page_size();  
	copy(first, last, back_inserter(*this));
    }
    deque(const deque<T>& x)
	: start(), finish(), length(0), map(0), map_size(0) {
	buffer_size = data_allocator.init_page_size();  
	copy(x.begin(), x.end(), back_inserter(*this));
    }
    deque<T>& operator=(const deque<T>& x) {
	if (this != &x)
	    if (size() >= x.size()) 
		erase(copy(x.begin(), x.end(), begin()), end());
	    else 
		copy(x.begin() + size(), x.end(),
		     inserter(*this, copy(x.begin(), x.begin() + size(),
					  begin())));
	return *this;
    }
    ~deque();
};

template <class T>
deque<T>::data_allocator_type deque<T>::data_allocator;

template <class T>
deque<T>::map_allocator_type deque<T>::map_allocator;

template <class T>
deque<T>::size_type deque<T>::buffer_size = 0; 
// should be data_allocator.init_page_size(); // Borland bug

template <class T>
bool operator==(const deque<T>& x, const deque<T>& y) {
    return x.size() == y.size() && equal(x.begin(), x.end(), y.begin());
}

template <class T>
bool operator<(const deque<T>& x, const deque<T>& y) {
    return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
}

template <class T>
deque<T>::~deque() { while (!empty()) pop_front(); }     

template <class T>
void deque<T>::allocate_at_begin() {
    pointer p = data_allocator.allocate(buffer_size);
    if (!empty()) {
	if (start.node == map) {
	    difference_type i = finish.node - start.node;
	    map_size = (i + 1) * 2;
	    map_pointer tmp = map_allocator.allocate(map_size);
	    copy(start.node, finish.node + 1, tmp + map_size / 4 + 1);
	    map_allocator.deallocate(map);
	    map = tmp;
	    map[map_size / 4] = p;
	    start = iterator(p + buffer_size, map + map_size / 4);
	    finish = iterator(finish.current, map + map_size / 4 + i + 1);
	} else {
	    *--start.node = p;
	    start = iterator(p + buffer_size, start.node);
	}
    } else {
	map_size = map_allocator.init_page_size();
	map = map_allocator.allocate(map_size);
	map[map_size / 2] = p;
	start = iterator(p + buffer_size / 2 + 1, map + map_size / 2);
	finish = start;
    }
}

template <class T>
void deque<T>::allocate_at_end() {
    pointer p = data_allocator.allocate(buffer_size);
    if (!empty()) {
	if (finish.node == map + map_size - 1) {
	    difference_type i = finish.node - start.node;
	    map_size = (i + 1) * 2;
	    map_pointer tmp = map_allocator.allocate(map_size);
	    copy(start.node, finish.node + 1, tmp + map_size / 4);
	    map_allocator.deallocate(map);
	    map = tmp;
	    map[map_size / 4 + i + 1] = p;
	    start = iterator(start.current, map + map_size / 4);
	    finish = iterator(p, map + map_size / 4 + i + 1);
	} else {
	    *++finish.node = p;
	    finish = iterator(p, finish.node);
	}
    } else {
	map_size = map_allocator.init_page_size();
	map = map_allocator.allocate(map_size);
	map[map_size / 2] = p;
	start = iterator(p + buffer_size / 2, map + map_size / 2);
	finish = start;
    }
}

template <class T>
void deque<T>::deallocate_at_begin() {
    data_allocator.deallocate(*start.node++);
    if (empty()) {
	if (finish.current == finish.first) 
	    data_allocator.deallocate(*start.node);
	start = iterator();
	finish = start;
	map_allocator.deallocate(map);
    } else
	start = iterator(*start.node, start.node);
}

template <class T>
void deque<T>::deallocate_at_end() {
    data_allocator.deallocate(*finish.node--);
    if (empty()) {
	start = iterator();
	finish = start;
	map_allocator.deallocate(map);
    } else
	finish = iterator(*finish.node + buffer_size, finish.node);
}

template <class T>
deque<T>::iterator deque<T>::insert(iterator position, const T& x) {
    if (position == begin()) {
	push_front(x);
	return begin();
    } else if (position == end()) {
	push_back(x);
	return end() - 1;
    } else {
	difference_type index = position - begin();
	if (index < length) {
	    push_front(*begin());
	    copy(begin() + 2, begin() + index + 1, begin() + 1); 
	} else {
	    push_back(*(end() - 1));
	    copy_backward(begin() + index, end() - 2, end() - 1); 
        }
	*(begin() + index) = x;
	return begin() + index;
    }
}

template <class T>
void deque<T>::insert(iterator position, size_type n, const T& x) {
    difference_type index = position - begin();
    difference_type remainder = length - index;
    if (remainder > index) {
	if (n > index) {
	    difference_type m = n - index;
	    while (m-- > 0) push_front(x);
	    difference_type i = index;
	    while (i--) push_front(*(begin() + n - 1));
	    fill(begin() + n, begin() + n + index, x);
	} else {
	    difference_type i = n;
	    while (i--) push_front(*(begin() + n - 1));
	    copy(begin() + n + n, begin() + n + index, begin() + n);
	    fill(begin() + index, begin() + n + index, x);
	}
    } else {
	difference_type orig_len = index + remainder;
	if (n > remainder) {
	    difference_type m = n - remainder;
	    while (m-- > 0) push_back(x);
	    difference_type i = 0;
	    while (i < remainder) push_back(*(begin() + index + i++));
	    fill(begin() + index, begin() + orig_len, x);
	} else {
	    difference_type i = 0;
	    while (i < n) push_back(*(begin() + orig_len - n + i++));
	    copy_backward(begin() + index, begin() + orig_len - n, 
			  begin() + orig_len);
	    fill(begin() + index, begin() + index + n, x);
	}
    }
}

template <class T>
void deque<T>::insert(iterator position, const T* first, const T* last) {
    difference_type index = position - begin();
    difference_type remainder = length - index;
    size_type n = 0;
    distance(first, last, n);
    if (remainder > index) {
	if (n > index) {
	    const T* m = last - index;
	    while (m != first) push_front(*--m);
	    difference_type i = index;
	    while (i--) push_front(*(begin() + n - 1));
	    copy(last - index, last, begin() + n);
	} else {
	    difference_type i = n;
	    while (i--) push_front(*(begin() + n - 1));
	    copy(begin() + n + n, begin() + n + index, begin() + n);
	    copy(first, last, begin() + index);
	}
    } else {
	difference_type orig_len = index + remainder;
	if (n > remainder) {
	    const T* m = first + remainder;
	    while (m != last) push_back(*m++);
	    difference_type i = 0;
	    while (i < remainder) push_back(*(begin() + index + i++));
	    copy(first, first + remainder, begin() + index);
	} else {
	    difference_type i = 0;
	    while (i < n) push_back(*(begin() + orig_len - n + i++));
	    copy_backward(begin() + index, begin() + orig_len - n, 
			  begin() + orig_len);
	    copy(first, last, begin() + index);
	}
    }
}

template <class T>
void deque<T>::erase(iterator position) {
    if (end() - position > position - begin()) {
	copy_backward(begin(), position, position + 1);
	pop_front();
    } else {
	copy(position + 1, end(), position);
	pop_back();
    }
}
    
template <class T>
void deque<T>::erase(iterator first, iterator last) {
	 difference_type n = last - first;
    if (end() - last > first - begin()) {
	copy_backward(begin(), first, last);
	while(n-- > 0) pop_front();
    } else   {
	copy(last, end(), first);
	while(n-- > 0) pop_back();
    }
}

#undef Allocator
#undef deque

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\bvector.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

// vector<bool> is replaced by bit_vector at present because bool is not
// implemented.  

#ifndef BVECTOR_H
#define BVECTOR_H

#include <function.h>
#include <algobase.h>
#include <iterator.h>
#include <bool.h>

#ifndef Allocator
#define Allocator allocator
#include <defalloc.h>
#endif

#define __WORD_BIT (int(CHAR_BIT*sizeof(unsigned int)))

class bit_vector {
public:
    typedef Allocator<unsigned int> vector_allocator;
    typedef bool value_type;
    typedef vector_allocator::size_type size_type;
    typedef vector_allocator::difference_type difference_type; 

    class iterator;
    class const_iterator;

    class reference {
    friend class iterator;
    friend class const_iterator;
    protected:
	unsigned int* p;
	unsigned int mask;
	reference(unsigned int* x, unsigned int y) : p(x), mask(y) {}
    public:
	reference() : p(0), mask(0) {}
	operator bool() const { return !(!(*p & mask)); }
	reference& operator=(bool x) {
	    if (x)      
		*p |= mask;
	    else 
		*p &= ~mask;
	    return *this;
	}
	reference& operator=(const reference& x) { return *this = bool(x); }
	bool operator==(const reference& x) const {
	    return bool(*this) == bool(x);
	}
	bool operator<(const reference& x) const {
	    return bool(*this) < bool(x);
	}
	void flip() { *p ^= mask; }
    };
    typedef bool const_reference;
    class iterator : public random_access_iterator<bool, difference_type> {
    friend class bit_vector;
    friend class const_iterator;
    protected:
	unsigned int* p;
	unsigned int offset;
	void bump_up() {
	    if (offset++ == __WORD_BIT - 1) {
		offset = 0;
		++p;
	    }
	}
    void bump_down() {
	if (offset-- == 0) {
	    offset = __WORD_BIT - 1;
	    --p;
	}
    }
    public:
	iterator() : p(0), offset(0) {}
	iterator(unsigned int* x, unsigned int y) : p(x), offset(y) {}
	reference operator*() const { return reference(p, 1U << offset); }
	iterator& operator++() {
	    bump_up();
	    return *this;
	}
	iterator operator++(int) {
	    iterator tmp = *this;
	    bump_up();
	    return tmp;
	}
	iterator& operator--() {
	    bump_down();
	    return *this;
	}
	iterator operator--(int) {
	    iterator tmp = *this;
	    bump_down();
	    return tmp;
	}
	iterator& operator+=(difference_type i) {
	    difference_type n = i + offset;
	    p += n / __WORD_BIT;
	    n = n % __WORD_BIT;
	    if (n < 0) {
		offset = n + __WORD_BIT;
		--p;
	    } else
		offset = n;
	    return *this;
	}
	iterator& operator-=(difference_type i) {
	    *this += -i;
	    return *this;
	}
	iterator operator+(difference_type i) const {
	    iterator tmp = *this;
	    return tmp += i;
	}
	iterator operator-(difference_type i) const {
	    iterator tmp = *this;
	    return tmp -= i;
	}
	difference_type operator-(iterator x) const {
	    return __WORD_BIT * (p - x.p) + offset - x.offset;
	}
	reference operator[](difference_type i) { return *(*this + i); }
	bool operator==(const iterator& x) const {
	    return p == x.p && offset == x.offset;
	}
	bool operator<(iterator x) const {
	    return p < x.p || (p == x.p && offset < x.offset);
	}
    };

    class const_iterator 
	: public random_access_iterator<bool, difference_type> {
    friend class bit_vector;
    protected:
	unsigned int* p;
	unsigned int offset;
	void bump_up() {
	    if (offset++ == __WORD_BIT - 1) {
		offset = 0;
		++p;
	    }
	}
    void bump_down() {
	if (offset-- == 0) {
	    offset = __WORD_BIT - 1;
	    --p;
	}
    }
    public:
	const_iterator() : p(0), offset(0) {}
	const_iterator(unsigned int* x, unsigned int y) : p(x), offset(y) {}
	const_iterator(const iterator& x) : p(x.p), offset(x.offset) {}
	const_reference operator*() const {
	    return reference(p, 1U << offset);
	}
	const_iterator& operator++() {
	    bump_up();
	    return *this;
	}
	const_iterator operator++(int) {
	    const_iterator tmp = *this;
	    bump_up();
	    return tmp;
	}
	const_iterator& operator--() {
	    bump_down();
	    return *this;
	}
	const_iterator operator--(int) {
	    const_iterator tmp = *this;
	    bump_down();
	    return tmp;
	}
	const_iterator& operator+=(difference_type i) {
	    difference_type n = i + offset;
	    p += n / __WORD_BIT;
	    n = n % __WORD_BIT;
	    if (n < 0) {
		offset = n + __WORD_BIT;
		--p;
	    } else
		offset = n;
	    return *this;
	}
	const_iterator& operator-=(difference_type i) {
	    *this += -i;
	    return *this;
	}
	const_iterator operator+(difference_type i) const {
	    const_iterator tmp = *this;
	    return tmp += i;
	}
	const_iterator operator-(difference_type i) const {
	    const_iterator tmp = *this;
	    return tmp -= i;
	}
	difference_type operator-(const_iterator x) const {
	    return __WORD_BIT * (p - x.p) + offset - x.offset;
	}
	const_reference operator[](difference_type i) { 
	    return *(*this + i); 
	}
	bool operator==(const const_iterator& x) const {
	    return p == x.p && offset == x.offset;
	}
	bool operator<(const_iterator x) const {
	    return p < x.p || (p == x.p && offset < x.offset);
	}
    };

    typedef reverse_iterator<const_iterator, value_type, const_reference, 
                             difference_type> const_reverse_iterator;
    typedef reverse_iterator<iterator, value_type, reference, difference_type>
        reverse_iterator;

protected:
    static Allocator<unsigned int> static_allocator;
    iterator start;
    iterator finish;
    unsigned int* end_of_storage;
    unsigned int* bit_alloc(size_type n) {
	return static_allocator.allocate((n + __WORD_BIT - 1)/__WORD_BIT);
    }
    void initialize(size_type n) {
	unsigned int* q = bit_alloc(n);
	end_of_storage = q + (n + __WORD_BIT - 1)/__WORD_BIT;
	start = iterator(q, 0);
	finish = start + n;
    }
    void insert_aux(iterator position, bool x);
    typedef bit_vector self;
public:
    iterator begin() { return start; }
    const_iterator begin() const { return start; }
    iterator end() { return finish; }
    const_iterator end() const { return finish; }

    reverse_iterator rbegin() { return reverse_iterator(end()); }
    const_reverse_iterator rbegin() const { 
        return const_reverse_iterator(end()); 
    }
    reverse_iterator rend() { return reverse_iterator(begin()); }
    const_reverse_iterator rend() const { 
        return const_reverse_iterator(begin()); 
    }

    size_type size() const { return size_type(end() - begin()); }
    size_type max_size() const { return static_allocator.max_size(); }
    size_type capacity() const {
	return size_type(const_iterator(end_of_storage, 0) - begin());
    }
    bool empty() const { return begin() == end(); }
    reference operator[](size_type n) { return *(begin() + n); }
    const_reference operator[](size_type n) const { return *(begin() + n); }
    bit_vector() : start(iterator()), finish(iterator()), end_of_storage(0) {}
    bit_vector(size_type n, bool value = bool()) {
	initialize(n);
	fill(start.p, end_of_storage, value ? ~0 : 0);
    }
    bit_vector(const self& x) {
	initialize(x.size());
	copy(x.begin(), x.end(), start);
    }
    bit_vector(const_iterator first, const_iterator last) {
	size_type n = 0;
	distance(first, last, n);
	initialize(n);
	copy(first, last, start);
    }
    ~bit_vector() { static_allocator.deallocate(start.p); }
    self& operator=(const self& x) {
	if (&x == this) return *this;
	if (x.size() > capacity()) {
	    static_allocator.deallocate(start.p); 
	    initialize(x.size());
	}
	copy(x.begin(), x.end(), begin());
	finish = begin() + x.size();
	return *this;
    }
    void reserve(size_type n) {
	if (capacity() < n) {
	    unsigned int* q = bit_alloc(n);
	    finish = copy(begin(), end(), iterator(q, 0));
	    static_allocator.deallocate(start.p);
	    start = iterator(q, 0);
	    end_of_storage = q + (n + __WORD_BIT - 1)/__WORD_BIT;
	}
    }
    reference front() { return *begin(); }
    const_reference front() const { return *begin(); }
    reference back() { return *(end() - 1); }
    const_reference back() const { return *(end() - 1); }
    void push_back(bool x) {
	if (finish.p != end_of_storage)
	    *finish++ = x;
	else
	    insert_aux(end(), x);
    }
    void swap(bit_vector& x) {
	::swap(start, x.start);
	::swap(finish, x.finish);
	::swap(end_of_storage, x.end_of_storage);
    }
    iterator insert(iterator position, bool x) {
	size_type n = position - begin();
	if (finish.p != end_of_storage && position == end())
	    *finish++ = x;
	else
	    insert_aux(position, x);
	return begin() + n;
    }
    void insert(iterator position, const_iterator first, 
		const_iterator last);
    void insert(iterator position, size_type n, bool x);
    void pop_back() { --finish; }
    void erase(iterator position) {
	if (position + 1 != end())
	    copy(position + 1, end(), position);
	--finish;
    }
    void erase(iterator first, iterator last) {
	finish = copy(last, end(), first);
    }
};

Allocator<unsigned int> bit_vector::static_allocator;

inline bool operator==(const bit_vector& x, const bit_vector& y) {
    return x.size() == y.size() && equal(x.begin(), x.end(), y.begin());
}

inline bool operator<(const bit_vector& x, const bit_vector& y) {
    return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
}

void swap(bit_vector::reference x, bit_vector::reference y) {
    bool tmp = x;
    x = y;
    y = tmp;
}

void bit_vector::insert_aux(iterator position, bool x) {
    if (finish.p != end_of_storage) {
	copy_backward(position, finish - 1, finish);
	*position = x;
	++finish;
    } else {
	size_type len = size() ? 2 * size() : __WORD_BIT;
	unsigned int* q = bit_alloc(len);
	iterator i = copy(begin(), position, iterator(q, 0));
	*i++ = x;
	finish = copy(position, end(), i);
	static_allocator.deallocate(start.p);
	end_of_storage = q + (len + __WORD_BIT - 1)/__WORD_BIT;
	start = iterator(q, 0);
    }
}

void bit_vector::insert(iterator position, size_type n, bool x) {
    if (n == 0) return;
    if (capacity() - size() >= n) {
	copy_backward(position, end(), finish + n);
	fill(position, position + n, x);
	finish += n;
    } else {
	size_type len = size() + stlmax(size(), n);
	unsigned int* q = bit_alloc(len);
	iterator i = copy(begin(), position, iterator(q, 0));
	fill_n(i, n, x);
	finish = copy(position, end(), i + n);
	static_allocator.deallocate(start.p);
	end_of_storage = q + (n + __WORD_BIT - 1)/__WORD_BIT;
	start = iterator(q, 0);
    }
}

void bit_vector::insert(iterator position, const_iterator first, 
			const_iterator last) {
    if (first == last) return;
    size_type n = 0;
    distance(first, last, n);
    if (capacity() - size() >= n) {
	copy_backward(position, end(), finish + n);
	copy(first, last, position);
	finish += n;
    } else {
	size_type len = size() + stlmax(size(), n);
	unsigned int* q = bit_alloc(len);
	iterator i = copy(begin(), position, iterator(q, 0));
	i = copy(first, last, i);
	finish = copy(position, end(), i);
	static_allocator.deallocate(start.p);
	end_of_storage = q + (len + __WORD_BIT - 1)/__WORD_BIT;
	start = iterator(q, 0);
    }
}

#undef Allocator
#undef __WORD_BIT

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\faralloc.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef FARALLOC_H
#define FARALLOC_H

#include <new.h>
#include <stddef.h>
#include <stdlib.h>
#include <limits.h>
#include <iostream.h>
#include <algobase.h>

template <class T>
inline random_access_iterator_tag iterator_category(const T __far *) {
    return random_access_iterator_tag();
}

template <class T>
inline T* value_type(const T __far *) { return (T*)(0); }

template <class T>
inline long* distance_type(const T __far*) { return (long*)(0); }

inline void destroy(char __far *) {}
inline void destroy(unsigned char __far *) {}
inline void destroy(short __far *) {}
inline void destroy(unsigned short __far *) {}
inline void destroy(int __far *) {}
inline void destroy(unsigned int __far *) {}
inline void destroy(long __far *) {}
inline void destroy(unsigned long __far *) {}
inline void destroy(float __far *) {}
inline void destroy(double __far *) {}

inline void destroy(char __far *, char __far *) {}
inline void destroy(unsigned char __far *, unsigned char __far *) {}
inline void destroy(short __far *, short __far *) {}
inline void destroy(unsigned short __far *, unsigned short __far *) {}
inline void destroy(int __far *, int __far *) {}
inline void destroy(unsigned int __far *, unsigned int __far *) {}
inline void destroy(long __far *, long __far *) {}
inline void destroy(unsigned long __far *, unsigned long __far *) {}
inline void destroy(float __far *, float __far *) {}
inline void destroy(double __far *, double __far *) {}

inline void __far * operator new(size_t, void __far *p) { return p; }

template <class T>
inline T __far * allocate(long size, T __far * p) {
    set_new_handler(0);
    T __far * tmp = 
        (T __far *)(::operator new((unsigned long)(size * sizeof(T))));
    if (tmp == 0) {
	cerr << "out of memory" << endl; 
	exit(1);
    }
    return tmp;
}

template <class T>
inline void deallocate(T __far * buffer) {
    ::operator delete(buffer);
}

template <class T1, class T2>
inline void construct( T1 __far *p, const T2& value )
{
    new(p)T1(value);
}

template <class T>
inline void destroy( T __far * pointer ) {
    pointer->~T();
}

template <class T>
class far_allocator {
public:
    typedef T value_type;
    typedef T __far * pointer;
    typedef const T __far * const_pointer;
    typedef T __far & reference;
    typedef const T __far & const_reference;
    typedef unsigned long size_type;
    typedef long difference_type;
    pointer allocate(size_type n) {
        return ::allocate((difference_type)n, (pointer)0);
    }
    void deallocate(pointer p) { ::deallocate(p); }
    pointer address(reference x) { return (pointer)&x; }
    const_pointer const_address(const_reference x) { 
	return (const_pointer)&x; 
    }
    size_type init_page_size() { 
	return stlmax(size_type(1), size_type(4096/sizeof(T))); 
    }
    size_type max_size() const { 
	return stlmax(size_type(1), size_type(ULONG_MAX/sizeof(T))); 
    }
};

class far_allocator<void> {
public:
    typedef void __far * pointer;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\fmap.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef FMAP_H
#define FMAP_H

#ifdef MAP_H
#undef MAP_H
#undef TREE_H
#define __MAP_WAS_DEFINED
#endif

#define Allocator far_allocator
#define map far_map
#define rb_tree far_rb_tree
#include <faralloc.h>
#include <map.h>

#undef MAP_H
#undef TREE_H

#ifdef __MAP_WAS_DEFINED
#define MAP_H
#define TREE_H
#undef  __MAP_WAS_DEFINED
#endif

#undef Allocator
#undef map
#undef rb_tree

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\flist.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef FLIST_H
#define FLIST_H

#ifdef LIST_H
#undef LIST_H
#define __LIST_WAS_DEFINED
#endif

#define Allocator far_allocator
#define list far_list
#include <faralloc.h>
#include <list.h>

#undef LIST_H

#ifdef __LIST_WAS_DEFINED
#define LIST_H
#undef  __LIST_WAS_DEFINED
#endif

#undef Allocator
#undef list

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\fmultset.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef FMULTISET_H
#define FMULTISET_H

#ifdef MULTISET_H
#undef MULTISET_H
#undef TREE_H
#define __MULTISET_WAS_DEFINED
#endif

#define Allocator far_allocator
#define multiset far_multiset
#define rb_tree far_rb_tree
#include <faralloc.h>
#include <multiset.h>

#undef MULTISET_H
#undef TREE_H

#ifdef __MULTISET_WAS_DEFINED
#define MULTISET_H
#define TREE_H
#undef  __MULTISET_WAS_DEFINED
#endif

#undef Allocator
#undef multiset
#undef rb_tree

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\fset.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef FSET_H
#define FSET_H

#ifdef SET_H
#undef SET_H
#undef TREE_H
#define __SET_WAS_DEFINED
#endif

#define Allocator far_allocator
#define set far_set
#define rb_tree far_rb_tree
#include <faralloc.h>
#include <set.h>

#undef SET_H
#undef TREE_H

#ifdef __SET_WAS_DEFINED
#define SET_H
#define TREE_H
#undef  __SET_WAS_DEFINED
#endif

#undef Allocator
#undef set
#undef rb_tree

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\fmultmap.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef FMULTIMAP_H
#define FMULTIMAP_H

#ifdef MULTIMAP_H
#undef MULTIMAP_H
#undef TREE_H
#define __MULTIMAP_WAS_DEFINED
#endif

#define Allocator far_allocator
#define multimap far_multimap
#define rb_tree far_rb_tree
#include <faralloc.h>
#include <multimap.h>

#undef MULTIMAP_H
#undef TREE_H

#ifdef __MULTIMAP_WAS_DEFINED
#define MULTIMAP_H
#define TREE_H
#undef  __MULTIMAP_WAS_DEFINED
#endif

#undef Allocator
#undef multimap
#undef rb_tree

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\hdeque.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef HDEQUE_H
#define HDEQUE_H

#ifdef DEQUE_H
#undef DEQUE_H
#define __DEQUE_WAS_DEFINED
#endif

#define Allocator huge_allocator
#define deque huge_deque
#include <hugalloc.h>
#include <deque.h>

#undef DEQUE_H

#ifdef __DEQUE_WAS_DEFINED
#define DEQUE_H
#undef  __DEQUE_WAS_DEFINED
#endif

#undef Allocator
#undef deque

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\hlist.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef HLIST_H
#define HLIST_H

#ifdef LIST_H
#undef LIST_H
#define __LIST_WAS_DEFINED
#endif

#define Allocator huge_allocator
#define list huge_list
#include <hugalloc.h>
#include <list.h>

#undef LIST_H

#ifdef __LIST_WAS_DEFINED
#define LIST_H
#undef  __LIST_WAS_DEFINED
#endif

#undef Allocator
#undef list

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\heap.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef HEAP_H
#define HEAP_H

template <class RandomAccessIterator, class Distance, class T>
void __push_heap(RandomAccessIterator first, Distance holeIndex,
		 Distance topIndex, T value) {
    Distance parent = (holeIndex - 1) / 2;
    while (holeIndex > topIndex && *(first + parent) < value) {
	*(first + holeIndex) = *(first + parent);
	holeIndex = parent;
	parent = (holeIndex - 1) / 2;
    }    
    *(first + holeIndex) = value;
}

template <class RandomAccessIterator, class Distance, class T>
inline void __push_heap_aux(RandomAccessIterator first,
			    RandomAccessIterator last, Distance*, T*) {
    __push_heap(first, Distance((last - first) - 1), Distance(0), 
		T(*(last - 1)));
}

template <class RandomAccessIterator>
inline void push_heap(RandomAccessIterator first, RandomAccessIterator last) {
    __push_heap_aux(first, last, distance_type(first), value_type(first));
}

template <class RandomAccessIterator, class Distance, class T, class Compare>
void __push_heap(RandomAccessIterator first, Distance holeIndex,
		 Distance topIndex, T value, Compare comp) {
    Distance parent = (holeIndex - 1) / 2;
    while (holeIndex > topIndex && comp(*(first + parent), value)) {
	*(first + holeIndex) = *(first + parent);
	holeIndex = parent;
	parent = (holeIndex - 1) / 2;
    }
    *(first + holeIndex) = value;
}

template <class RandomAccessIterator, class Compare, class Distance, class T>
inline void __push_heap_aux(RandomAccessIterator first,
			    RandomAccessIterator last, Compare comp,
			    Distance*, T*) {
    __push_heap(first, Distance((last - first) - 1), Distance(0), 
		T(*(last - 1)), comp);
}

template <class RandomAccessIterator, class Compare>
inline void push_heap(RandomAccessIterator first, RandomAccessIterator last,
		      Compare comp) {
    __push_heap_aux(first, last, comp, distance_type(first), value_type(first));
}

template <class RandomAccessIterator, class Distance, class T>
void __adjust_heap(RandomAccessIterator first, Distance holeIndex,
		   Distance len, T value) {
    Distance topIndex = holeIndex;
    Distance secondChild = 2 * holeIndex + 2;
    while (secondChild < len) {
	if (*(first + secondChild) < *(first + (secondChild - 1)))
	    secondChild--;
	*(first + holeIndex) = *(first + secondChild);
	holeIndex = secondChild;
	secondChild = 2 * (secondChild + 1);
    }
    if (secondChild == len) {
	*(first + holeIndex) = *(first + (secondChild - 1));
	holeIndex = secondChild - 1;
    }
    __push_heap(first, holeIndex, topIndex, value);
}

template <class RandomAccessIterator, class T, class Distance>
inline void __pop_heap(RandomAccessIterator first, RandomAccessIterator last,
		       RandomAccessIterator result, T value, Distance*) {
    *result = *first;
    __adjust_heap(first, Distance(0), Distance(last - first), value);
}

template <class RandomAccessIterator, class T>
inline void __pop_heap_aux(RandomAccessIterator first,
			   RandomAccessIterator last, T*) {
    __pop_heap(first, last - 1, last - 1, T(*(last - 1)), distance_type(first));
}

template <class RandomAccessIterator>
inline void pop_heap(RandomAccessIterator first, RandomAccessIterator last) {
    __pop_heap_aux(first, last, value_type(first));
}

template <class RandomAccessIterator, class Distance, class T, class Compare>
void __adjust_heap(RandomAccessIterator first, Distance holeIndex,
		   Distance len, T value, Compare comp) {
    Distance topIndex = holeIndex;
    Distance secondChild = 2 * holeIndex + 2;
    while (secondChild < len) {
	if (comp(*(first + secondChild), *(first + (secondChild - 1))))
	    secondChild--;
	*(first + holeIndex) = *(first + secondChild);
	holeIndex = secondChild;
	secondChild = 2 * (secondChild + 1);
    }
    if (secondChild == len) {
	*(first + holeIndex) = *(first + (secondChild - 1));
	holeIndex = secondChild - 1;
    }
    __push_heap(first, holeIndex, topIndex, value, comp);
}

template <class RandomAccessIterator, class T, class Compare, class Distance>
inline void __pop_heap(RandomAccessIterator first, RandomAccessIterator last,
		       RandomAccessIterator result, T value, Compare comp,
		       Distance*) {
    *result = *first;
    __adjust_heap(first, Distance(0), Distance(last - first), value, comp);
}

template <class RandomAccessIterator, class T, class Compare>
inline void __pop_heap_aux(RandomAccessIterator first,
			   RandomAccessIterator last, T*, Compare comp) {
    __pop_heap(first, last - 1, last - 1, T(*(last - 1)), comp,
	       distance_type(first));
}

template <class RandomAccessIterator, class Compare>
inline void pop_heap(RandomAccessIterator first, RandomAccessIterator last,
		     Compare comp) {
    __pop_heap_aux(first, last, value_type(first), comp);
}

template <class RandomAccessIterator, class T, class Distance>
void __make_heap(RandomAccessIterator first, RandomAccessIterator last, T*,
		 Distance*) {
    if (last - first < 2) return;
    Distance len = last - first;
    Distance parent = (len - 2)/2;
    
    while (true) {
	__adjust_heap(first, parent, len, T(*(first + parent)));
	if (parent == 0) return;
	parent--;
    }
}

template <class RandomAccessIterator>
inline void make_heap(RandomAccessIterator first, RandomAccessIterator last) {
    __make_heap(first, last, value_type(first), distance_type(first));
}

template <class RandomAccessIterator, class Compare, class T, class Distance>
void __make_heap(RandomAccessIterator first, RandomAccessIterator last,
		 Compare comp, T*, Distance*) {
    if (last - first < 2) return;
    Distance len = last - first;
    Distance parent = (len - 2)/2;
    
    while (true) {
	__adjust_heap(first, parent, len, T(*(first + parent)), comp);
	if (parent == 0) return;
	parent--;
    }
}

template <class RandomAccessIterator, class Compare>
inline void make_heap(RandomAccessIterator first, RandomAccessIterator last,
		      Compare comp) {
    __make_heap(first, last, comp, value_type(first), distance_type(first));
}

template <class RandomAccessIterator>
void sort_heap(RandomAccessIterator first, RandomAccessIterator last) {
    while (last - first > 1) pop_heap(first, last--);
}

template <class RandomAccessIterator, class Compare>
void sort_heap(RandomAccessIterator first, RandomAccessIterator last,
	       Compare comp) {
    while (last - first > 1) pop_heap(first, last--, comp);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\hmap.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef HMAP_H
#define HMAP_H

#ifdef MAP_H
#undef MAP_H
#undef TREE_H
#define __MAP_WAS_DEFINED
#endif

#define Allocator huge_allocator
#define map huge_map
#define rb_tree huge_rb_tree
#include <hugalloc.h>
#include <map.h>

#undef MAP_H
#undef TREE_H

#ifdef __MAP_WAS_DEFINED
#define MAP_H
#define TREE_H
#undef  __MAP_WAS_DEFINED
#endif

#undef Allocator
#undef map
#undef rb_tree

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\hmultmap.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef HMULTIMAP_H
#define HMULTIMAP_H

#ifdef MULTIMAP_H
#undef MULTIMAP_H
#undef TREE_H
#define __MULTIMAP_WAS_DEFINED
#endif

#define Allocator huge_allocator
#define multimap huge_multimap
#define rb_tree huge_rb_tree
#include <hugalloc.h>
#include <multimap.h>

#undef MULTIMAP_H
#undef TREE_H

#ifdef __MULTIMAP_WAS_DEFINED
#define MULTIMAP_H
#define TREE_H
#undef  __MULTIMAP_WAS_DEFINED
#endif

#undef Allocator
#undef multimap
#undef rb_tree

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\hmultset.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef HMULTISET_H
#define HMULTISET_H

#ifdef MULTISET_H
#undef MULTISET_H
#undef TREE_H
#define __MULTISET_WAS_DEFINED
#endif

#define Allocator huge_allocator
#define multiset huge_multiset
#define rb_tree huge_rb_tree
#include <hugalloc.h>
#include <multiset.h>

#undef MULTISET_H
#undef TREE_H

#ifdef __MULTISET_WAS_DEFINED
#define MULTISET_H
#define TREE_H
#undef  __MULTISET_WAS_DEFINED
#endif

#undef Allocator
#undef multiset
#undef rb_tree

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\hset.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef HSET_H
#define HSET_H

#ifdef SET_H
#undef SET_H
#undef TREE_H
#define __SET_WAS_DEFINED
#endif

#define Allocator huge_allocator
#define set huge_set
#define rb_tree huge_rb_tree
#include <hugalloc.h>
#include <set.h>

#undef SET_H
#undef TREE_H

#ifdef __SET_WAS_DEFINED
#define SET_H
#define TREE_H
#undef  __SET_WAS_DEFINED
#endif

#undef Allocator
#undef set
#undef rb_tree

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\hugalloc.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef HUGALLOC_H
#define HUGALLOC_H

#ifdef FARALLOC_H
#undef FARALLOC_H
#define __FARALLOC_WAS_DEFINED
#endif

#define __far __huge
#define far_allocator huge_allocator
#include <faralloc.h>
#undef __far
#undef far_allocator

#undef FARALLOC_H

#ifdef __FARALLOC_WAS_DEFINED
#define FARALLOC_H
#undef  __FARALLOC_WAS_DEFINED
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\lbvector.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef LBVECTOR_H
#define LBVECTOR_H

#ifdef BVECTOR_H
#undef BVECTOR_H
#define __BVECTOR_WAS_DEFINED
#endif

#define Allocator long_allocator
#define bit_vector long_bit_vector
#include <lngalloc.h>
#include <bvector.h>

#undef BVECTOR_H

#ifdef __BVECTOR_WAS_DEFINED
#define BVECTOR_H
#undef  __BVECTOR_WAS_DEFINED
#endif

#undef Allocator
#undef bit_vector

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\hvector.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef HVECTOR_H
#define HVECTOR_H

#ifdef VECTOR_H
#undef VECTOR_H
#define __VECTOR_WAS_DEFINED
#endif

#define Allocator huge_allocator
#define vector huge_vector
#include <hugalloc.h>
#include <vector.h>

#undef VECTOR_H

#ifdef __VECTOR_WAS_DEFINED
#define VECTOR_H
#undef  __VECTOR_WAS_DEFINED
#endif

#undef Allocator
#undef vector

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\ldeque.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef LDEQUE_H
#define LDEQUE_H

#ifdef DEQUE_H
#undef DEQUE_H
#define __DEQUE_WAS_DEFINED
#endif

#define Allocator long_allocator
#define deque long_deque
#include <lngalloc.h>
#include <deque.h>

#undef DEQUE_H

#ifdef __DEQUE_WAS_DEFINED
#define DEQUE_H
#undef  __DEQUE_WAS_DEFINED
#endif

#undef Allocator
#undef deque

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\function.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef FUNCTION_H
#define FUNCTION_H

#include <bool.h>

template <class T1, class T2>
inline bool operator!=(const T1& x, const T2& y) {
    return !(x == y);
}

template <class T1, class T2>
inline bool operator>(const T1& x, const T2& y) {
    return y < x;
}

template <class T1, class T2>
inline bool operator<=(const T1& x, const T2& y) {
    return !(y < x);
}

template <class T1, class T2>
inline bool operator>=(const T1& x, const T2& y) {
    return !(x < y);
}

template <class Arg, class Result>
struct unary_function {
    typedef Arg argument_type;
    typedef Result result_type;
};

template <class Arg1, class Arg2, class Result>
struct binary_function {
    typedef Arg1 first_argument_type;
    typedef Arg2 second_argument_type;
    typedef Result result_type;
};      

template <class T>
struct plus : public binary_function<T, T, T> {
    T operator()(const T& x, const T& y) const { return x + y; }
};

template <class T>
struct minus : public binary_function<T, T, T> {
    T operator()(const T& x, const T& y) const { return x - y; }
};

template <class T>
struct times : public binary_function<T, T, T> {
    T operator()(const T& x, const T& y) const { return x * y; }
};

template <class T>
struct divides : public binary_function<T, T, T> {
    T operator()(const T& x, const T& y) const { return x / y; }
};

template <class T>
struct modulus : public binary_function<T, T, T> {
    T operator()(const T& x, const T& y) const { return x % y; }
};

template <class T>
struct negate : public unary_function<T, T> {
    T operator()(const T& x) const { return -x; }
};

template <class T>
struct equal_to : public binary_function<T, T, bool> {
    bool operator()(const T& x, const T& y) const { return x == y; }
};

template <class T>
struct not_equal_to : public binary_function<T, T, bool> {
    bool operator()(const T& x, const T& y) const { return x != y; }
};

template <class T>
struct greater : public binary_function<T, T, bool> {
    bool operator()(const T& x, const T& y) const { return x > y; }
};

template <class T>
struct less : public binary_function<T, T, bool> {
    bool operator()(const T& x, const T& y) const { return x < y; }
};

template <class T>
struct greater_equal : public binary_function<T, T, bool> {
    bool operator()(const T& x, const T& y) const { return x >= y; }
};

template <class T>
struct less_equal : public binary_function<T, T, bool> {
    bool operator()(const T& x, const T& y) const { return x <= y; }
};

template <class T>
struct logical_and : public binary_function<T, T, bool> {
    bool operator()(const T& x, const T& y) const { return x && y; }
};

template <class T>
struct logical_or : public binary_function<T, T, bool> {
    bool operator()(const T& x, const T& y) const { return x || y; }
};

template <class T>
struct logical_not : public unary_function<T, bool> {
    bool operator()(const T& x) const { return !x; }
};

template <class Predicate>
class unary_negate : public unary_function<Predicate::argument_type, bool> {
protected:
    Predicate pred;
public:
    unary_negate(const Predicate& x) : pred(x) {}
    bool operator()(const argument_type& x) const { return !pred(x); }
};

template <class Predicate>
unary_negate<Predicate> not1(const Predicate& pred) {
    return unary_negate<Predicate>(pred);
}

template <class Predicate> 
class binary_negate 
   : public binary_function<Predicate::first_argument_type,
			     Predicate::second_argument_type, bool> {
protected:
    Predicate pred;
public:
    binary_negate(const Predicate& x) : pred(x) {}
    bool operator()(const first_argument_type& x, 
		    const second_argument_type& y) const {
	return !pred(x, y); 
    }
};

template <class Predicate>
binary_negate<Predicate> not2(const Predicate& pred) {
    return binary_negate<Predicate>(pred);
}

template <class Operation> 
class binder1st : public unary_function<Operation::second_argument_type,
					Operation::result_type> {
protected:
    Operation op;
    Operation::first_argument_type value;
public:
    binder1st(const Operation& x, const Operation::first_argument_type& y)
	: op(x), value(y) {}
    result_type operator()(const argument_type& x) const {
	return op(value, x); 
    }
};

template <class Operation, class T>
binder1st<Operation> bind1st(const Operation& op, const T& x) {
    return binder1st<Operation>(op, Operation::first_argument_type(x));
}

template <class Operation> 
class binder2nd : public unary_function<Operation::first_argument_type,
					Operation::result_type> {
protected:
    Operation op;
    Operation::second_argument_type value;
public:
    binder2nd(const Operation& x, const Operation::second_argument_type& y) 
	: op(x), value(y) {}
    result_type operator()(const argument_type& x) const {
	return op(x, value); 
    }
};

template <class Operation, class T>
binder2nd<Operation> bind2nd(const Operation& op, const T& x) {
    return binder2nd<Operation>(op, Operation::second_argument_type(x));
}

template <class Operation1, class Operation2>
class unary_compose : public unary_function<Operation2::argument_type,
                                            Operation1::result_type> {
protected:
    Operation1 op1;
    Operation2 op2;
public:
    unary_compose(const Operation1& x, const Operation2& y) : op1(x), op2(y) {}
    result_type operator()(const argument_type& x) const {
	return op1(op2(x));
    }
};

template <class Operation1, class Operation2>
unary_compose<Operation1, Operation2> compose1(const Operation1& op1, 
					       const Operation2& op2) {
    return unary_compose<Operation1, Operation2>(op1, op2);
}

template <class Operation1, class Operation2, class Operation3>
class binary_compose : public unary_function<Operation2::argument_type,
                                             Operation1::result_type> {
protected:
    Operation1 op1;
    Operation2 op2;
    Operation3 op3;
public:
    binary_compose(const Operation1& x, const Operation2& y, 
		   const Operation3& z) : op1(x), op2(y), op3(z) { }
    result_type operator()(const argument_type& x) const {
	return op1(op2(x), op3(x));
    }
};

template <class Operation1, class Operation2, class Operation3>
binary_compose<Operation1, Operation2, Operation3> 
compose2(const Operation1& op1, const Operation2& op2, const Operation3& op3) {
    return binary_compose<Operation1, Operation2, Operation3>(op1, op2, op3);
}

template <class Arg, class Result>
class pointer_to_unary_function : public unary_function<Arg, Result> {
protected:
    Result (*ptr)(Arg);
public:
    pointer_to_unary_function() {}
    pointer_to_unary_function(Result (*x)(Arg)) : ptr(x) {}
    Result operator()(Arg x) const { return ptr(x); }
};

template <class Arg, class Result>
pointer_to_unary_function<Arg, Result> ptr_fun(Result (*x)(Arg)) {
    return pointer_to_unary_function<Arg, Result>(x);
}

template <class Arg1, class Arg2, class Result>
class pointer_to_binary_function : public binary_function<Arg1, Arg2, Result> {
protected:
    Result (*ptr)(Arg1, Arg2);
public:
    pointer_to_binary_function() {}
    pointer_to_binary_function(Result (*x)(Arg1, Arg2)) : ptr(x) {}
    Result operator()(Arg1 x, Arg2 y) const { return ptr(x, y); }
};

template <class Arg1, class Arg2, class Result>
pointer_to_binary_function<Arg1, Arg2, Result> 
ptr_fun(Result (*x)(Arg1, Arg2)) {
    return pointer_to_binary_function<Arg1, Arg2, Result>(x);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\lmap.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef LMAP_H
#define LMAP_H

#ifdef MAP_H
#undef MAP_H
#undef TREE_H
#define __MAP_WAS_DEFINED
#endif

#define Allocator long_allocator
#define map long_map
#define rb_tree long_rb_tree
#include <lngalloc.h>
#include <map.h>

#undef MAP_H
#undef TREE_H

#ifdef __MAP_WAS_DEFINED
#define MAP_H
#define TREE_H
#undef  __MAP_WAS_DEFINED
#endif

#undef Allocator
#undef map
#undef rb_tree

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\iterator.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef ITERATOR_H
#define ITERATOR_H

#include <stddef.h>
#include <iostream.h>
#include <bool.h>
#include <function.h>

struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag {};
struct bidirectional_iterator_tag {};
struct random_access_iterator_tag {};

template <class T, class Distance> struct input_iterator {};
struct output_iterator {};
template <class T, class Distance> struct forward_iterator {};
template <class T, class Distance> struct bidirectional_iterator {};
template <class T, class Distance> struct random_access_iterator {};

template <class T, class Distance> 
inline input_iterator_tag 
iterator_category(const input_iterator<T, Distance>&) {
    return input_iterator_tag();
}

inline output_iterator_tag iterator_category(const output_iterator&) {
    return output_iterator_tag();
}

template <class T, class Distance> 
inline forward_iterator_tag
iterator_category(const forward_iterator<T, Distance>&) {
    return forward_iterator_tag();
}

template <class T, class Distance> 
inline bidirectional_iterator_tag
iterator_category(const bidirectional_iterator<T, Distance>&) {
    return bidirectional_iterator_tag();
}

template <class T, class Distance> 
inline random_access_iterator_tag
iterator_category(const random_access_iterator<T, Distance>&) {
    return random_access_iterator_tag();
}

template <class T>
inline random_access_iterator_tag iterator_category(const T*) {
    return random_access_iterator_tag();
}

template <class T, class Distance> 
inline T* value_type(const input_iterator<T, Distance>&) {
    return (T*)(0); 
}

template <class T, class Distance> 
inline T* value_type(const forward_iterator<T, Distance>&) {
    return (T*)(0);
}

template <class T, class Distance> 
inline T* value_type(const bidirectional_iterator<T, Distance>&) {
    return (T*)(0);
}

template <class T, class Distance> 
inline T* value_type(const random_access_iterator<T, Distance>&) {
    return (T*)(0);
}

template <class T>
inline T* value_type(const T*) { return (T*)(0); }

template <class T, class Distance> 
inline Distance* distance_type(const input_iterator<T, Distance>&) {
    return (Distance*)(0);
}

template <class T, class Distance> 
inline Distance* distance_type(const forward_iterator<T, Distance>&) {
    return (Distance*)(0);
}

template <class T, class Distance> 
inline Distance* 
distance_type(const bidirectional_iterator<T, Distance>&) {
    return (Distance*)(0);
}

template <class T, class Distance> 
inline Distance* 
distance_type(const random_access_iterator<T, Distance>&) {
    return (Distance*)(0);
}

template <class T>
inline ptrdiff_t* distance_type(const T*) { return (ptrdiff_t*)(0); }

template <class Container>
class back_insert_iterator : public output_iterator {
protected:
    Container& container;
public:
    back_insert_iterator(Container& x) : container(x) {}
    back_insert_iterator<Container>&
    operator=(const Container::value_type& value) { 
	container.push_back(value);
	return *this;
    }
    back_insert_iterator<Container>& operator*() { return *this; }
    back_insert_iterator<Container>& operator++() { return *this; }
    back_insert_iterator<Container>& operator++(int) { return *this; }
};

template <class Container>
back_insert_iterator<Container> back_inserter(Container& x) {
    return back_insert_iterator<Container>(x);
}

template <class Container>
class front_insert_iterator : public output_iterator {
protected:
    Container& container;
public:
    front_insert_iterator(Container& x) : container(x) {}
    front_insert_iterator<Container>&
    operator=(const Container::value_type& value) { 
	container.push_front(value);
	return *this;
    }
    front_insert_iterator<Container>& operator*() { return *this; }
    front_insert_iterator<Container>& operator++() { return *this; }
    front_insert_iterator<Container>& operator++(int) { return *this; }
};

template <class Container>
front_insert_iterator<Container> front_inserter(Container& x) {
    return front_insert_iterator<Container>(x);
}

template <class Container>
class insert_iterator : public output_iterator {
protected:
    Container& container;
    Container::iterator iter;
public:
    insert_iterator(Container& x, Container::iterator i) 
	: container(x), iter(i) {}
    insert_iterator<Container>&
    operator=(const Container::value_type& value) { 
	iter = container.insert(iter, value);
	++iter;
	return *this;
    }
    insert_iterator<Container>& operator*() { return *this; }
    insert_iterator<Container>& operator++() { return *this; }
    insert_iterator<Container>& operator++(int) { return *this; }
};

template <class Container, class Iterator>
insert_iterator<Container> inserter(Container& x, Iterator i) {
    return insert_iterator<Container>(x, Container::iterator(i));
}

template <class BidirectionalIterator, class T, class Reference, 
          class Distance> 
// Reference = T& 
// Distance = ptrdiff_t
class reverse_bidirectional_iterator 
    : public bidirectional_iterator<T, Distance> {
    typedef reverse_bidirectional_iterator<BidirectionalIterator, T, Reference,
                                           Distance> self;
    friend bool operator==(const self& x, const self& y);
protected:
    BidirectionalIterator current;
public:
    reverse_bidirectional_iterator() {}
    reverse_bidirectional_iterator(BidirectionalIterator x) : current(x) {}
    BidirectionalIterator base() { return current; }
    Reference operator*() const {
	BidirectionalIterator tmp = current;
	return *--tmp;
    }
    self& operator++() {
	--current;
	return *this;
    }
    self operator++(int) {
	self tmp = *this;
	--current;
	return tmp;
    }
    self& operator--() {
	++current;
	return *this;
    }
    self operator--(int) {
	self tmp = *this;
	++current;
	return tmp;
    }
};

template <class BidirectionalIterator, class T, class Reference,
          class Distance>
inline bool operator==(
    const reverse_bidirectional_iterator<BidirectionalIterator, T, Reference,
		                         Distance>& x, 
    const reverse_bidirectional_iterator<BidirectionalIterator, T, Reference,
		                         Distance>& y) {
    return x.current == y.current;
}

template <class RandomAccessIterator, class T, class Reference,
          class Distance> 
// Reference = T&
// Distance = ptrdiff_t
class reverse_iterator : public random_access_iterator<T, Distance> {
    typedef reverse_iterator<RandomAccessIterator, T, Reference, Distance>
	self;
    friend bool operator==(const self& x, const self& y);
    friend bool operator<(const self& x, const self& y);
    friend Distance operator-(const self& x, const self& y);
    friend self operator+(Distance n, const self& x);
protected:
    RandomAccessIterator current;
public:
    reverse_iterator() {}
    reverse_iterator(RandomAccessIterator x) : current(x) {}
    RandomAccessIterator base() { return current; }
    Reference operator*() const { return *(current - 1); }
    self& operator++() {
	--current;
	return *this;
    }
    self operator++(int) {
	self tmp = *this;
	--current;
	return tmp;
    }
    self& operator--() {
	++current;
	return *this;
    }
    self operator--(int) {
	self tmp = *this;
	++current;
	return tmp;
    }
    self operator+(Distance n) const {
	return self(current - n);
    }
    self& operator+=(Distance n) {
	current -= n;
	return *this;
    }
    self operator-(Distance n) const {
	return self(current + n);
    }
    self& operator-=(Distance n) {
	current += n;
	return *this;
    }
    Reference operator[](Distance n) { return *(*this + n); }
};

template <class RandomAccessIterator, class T, class Reference, class Distance>
inline bool operator==(const reverse_iterator<RandomAccessIterator, T,
		                              Reference, Distance>& x, 
		       const reverse_iterator<RandomAccessIterator, T,
		                              Reference, Distance>& y) {
    return x.current == y.current;
}

template <class RandomAccessIterator, class T, class Reference, class Distance>
inline bool operator<(const reverse_iterator<RandomAccessIterator, T,
		                             Reference, Distance>& x, 
		      const reverse_iterator<RandomAccessIterator, T,
		                             Reference, Distance>& y) {
    return y.current < x.current;
}

template <class RandomAccessIterator, class T, class Reference, class Distance>
inline Distance operator-(const reverse_iterator<RandomAccessIterator, T,
			                         Reference, Distance>& x, 
			  const reverse_iterator<RandomAccessIterator, T,
			                         Reference, Distance>& y) {
    return y.current - x.current;
}

template <class RandomAccessIterator, class T, class Reference, class Distance>
inline reverse_iterator<RandomAccessIterator, T, Reference, Distance> 
operator+(Distance n,
	  const reverse_iterator<RandomAccessIterator, T, Reference,
	                         Distance>& x) {
    return reverse_iterator<RandomAccessIterator, T, Reference, Distance>
	(x.current - n);
}


template <class OutputIterator, class T>
class raw_storage_iterator : public output_iterator {
protected:
    OutputIterator iter;
public:
    raw_storage_iterator(OutputIterator x) : iter(x) {}
    raw_storage_iterator<OutputIterator, T>& operator*() { return *this; }
    raw_storage_iterator<OutputIterator, T>& operator=(const T& element) {
	construct(iter, element);
	return *this;
    }        
    raw_storage_iterator<OutputIterator, T>& operator++() {
	++iter;
	return *this;
    }
    raw_storage_iterator<OutputIterator, T> operator++(int) {
	raw_storage_iterator<OutputIterator, T> tmp = *this;
	++iter;
	return tmp;
    }
};


template <class T, class Distance> // Distance == ptrdiff_t
class istream_iterator : public input_iterator<T, Distance> {
friend bool operator==(const istream_iterator<T, Distance>& x,
		       const istream_iterator<T, Distance>& y);
protected:
    istream* stream;
    T value;
    bool end_marker;
    void read() {
	end_marker = (*stream) ? true : false;
	if (end_marker) *stream >> value;
	end_marker = (*stream) ? true : false;
    }
public:
    istream_iterator() : stream(&cin), end_marker(false) {}
    istream_iterator(istream& s) : stream(&s) { read(); }
    const T& operator*() const { return value; }
    istream_iterator<T, Distance>& operator++() { 
	read(); 
	return *this;
    }
    istream_iterator<T, Distance> operator++(int)  {
	istream_iterator<T, Distance> tmp = *this;
	read();
	return tmp;
    }
};

template <class T, class Distance>
bool operator==(const istream_iterator<T, Distance>& x,
		const istream_iterator<T, Distance>& y) {
    return x.stream == y.stream && x.end_marker == y.end_marker ||
	x.end_marker == false && y.end_marker == false;
}

template <class T>
class ostream_iterator : public output_iterator {
protected:
    ostream* stream;
    char* string;
public:
    ostream_iterator(ostream& s) : stream(&s), string(0) {}
    ostream_iterator(ostream& s, char* c) : stream(&s), string(c)  {}
    ostream_iterator<T>& operator=(const T& value) { 
	*stream << value;
	if (string) *stream << string;
	return *this;
    }
    ostream_iterator<T>& operator*() { return *this; }
    ostream_iterator<T>& operator++() { return *this; } 
    ostream_iterator<T>& operator++(int) { return *this; } 
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\llist.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef LLIST_H
#define LLIST_H

#ifdef LIST_H
#undef LIST_H
#define __LIST_WAS_DEFINED
#endif

#define Allocator long_allocator
#define list long_list
#include <lngalloc.h>
#include <list.h>

#undef LIST_H

#ifdef __LIST_WAS_DEFINED
#define LIST_H
#undef  __LIST_WAS_DEFINED
#endif

#undef Allocator
#undef list

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\list.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef LIST_H
#define LIST_H

// rajeevb - added windows.h for the critical section
#include <windows.h>

#include <function.h>
#include <algobase.h>
#include <iterator.h>
#include <bool.h>
    
#ifndef Allocator
#define Allocator allocator
#include <defalloc.h>
#endif

#ifndef list 
#define list list
#endif

// rajeevb - added critical section to protect 
// access to static variables
class ListCritSec
{
public:
    CRITICAL_SECTION m_CritSec;
    ListCritSec() { ::InitializeCriticalSection(&m_CritSec); }
    ~ListCritSec() { ::DeleteCriticalSection(&m_CritSec); }
};

class CSAutoLock
{
public:
    ListCritSec &m_Lock;
    CSAutoLock(ListCritSec &Lock) : m_Lock(Lock)
        { ::EnterCriticalSection(&m_Lock.m_CritSec); }
    ~CSAutoLock() { ::LeaveCriticalSection(&m_Lock.m_CritSec); }
};

template <class T>
class list {
protected:
    typedef Allocator<void>::pointer void_pointer;
    struct list_node;
    friend list_node;
    struct list_node {
	void_pointer next;
	void_pointer prev;
	T data;
    };

    // rajeevb - global critical section for protecting access
    // to all the list static variables
    static ListCritSec gs_CritSec;

    static Allocator<list_node> list_node_allocator;
    static Allocator<T> value_allocator;
public:      
    typedef T value_type;
    typedef Allocator<T> value_allocator_type;
    typedef Allocator<T>::pointer pointer;
    typedef Allocator<T>::reference reference;
    typedef Allocator<T>::const_reference const_reference;
    typedef Allocator<list_node> list_node_allocator_type;
    typedef Allocator<list_node>::pointer link_type;
    typedef Allocator<list_node>::size_type size_type;
    typedef Allocator<list_node>::difference_type difference_type;
protected:
    size_type buffer_size() {
    // rajeevb - this doesn't need critical section
	return list_node_allocator.init_page_size();
    }
    struct list_node_buffer;
    friend list_node_buffer;
    struct list_node_buffer {
	void_pointer next_buffer;
	link_type buffer;
    };
public:
    typedef Allocator<list_node_buffer> buffer_allocator_type;
    typedef Allocator<list_node_buffer>::pointer buffer_pointer;     
protected:
    static Allocator<list_node_buffer> buffer_allocator;
    static buffer_pointer buffer_list;
    static link_type free_list;
    static link_type next_avail;
    static link_type last;
    void add_new_buffer() {
    // rajeevb - get critical section. released when function returns
    CSAutoLock AutoLock(gs_CritSec);

	buffer_pointer tmp = buffer_allocator.allocate((size_type)1);
	tmp->buffer = list_node_allocator.allocate(buffer_size());
	tmp->next_buffer = buffer_list;
	buffer_list = tmp;
	next_avail = buffer_list->buffer;
	last = next_avail + buffer_size();
    }
    static size_type number_of_lists;
    void deallocate_buffers();
    link_type get_node() {
    // rajeevb - get critical section. released when function returns
    CSAutoLock AutoLock(gs_CritSec);

	link_type tmp = free_list;
	return free_list ? (free_list = (link_type)(free_list->next), tmp) 
	    : (next_avail == last ? (add_new_buffer(), next_avail++) 
		: next_avail++);
	// ugly code for inlining - avoids multiple returns
    }
    void put_node(link_type p) {
    // rajeevb - get critical section. released when function returns
    CSAutoLock AutoLock(gs_CritSec);

	p->next = free_list;
	free_list = p;
    }

protected:
    link_type node;
    size_type length;
public:
    class iterator;
    class const_iterator;
    class iterator : public bidirectional_iterator<T, difference_type> {
    friend class list<T>;
    friend class const_iterator;
//  friend bool operator==(const iterator& x, const iterator& y);
    protected:
	link_type node;
	iterator(link_type x) : node(x) {}
    public:
	iterator() {}
	bool operator==(const iterator& x) const { return node == x.node; }
	reference operator*() const { return (*node).data; }
	iterator& operator++() { 
	    node = (link_type)((*node).next);
	    return *this;
	}
	iterator operator++(int) { 
	    iterator tmp = *this;
	    ++*this;
	    return tmp;
	}
	iterator& operator--() { 
	    node = (link_type)((*node).prev);
	    return *this;
	}
	iterator operator--(int) { 
	    iterator tmp = *this;
	    --*this;
	    return tmp;
	}
    };
    class const_iterator : public bidirectional_iterator<T, difference_type> {
    friend class list<T>;
    protected:
	link_type node;
	const_iterator(link_type x) : node(x) {}
    public:     
	const_iterator() {}
	const_iterator(const iterator& x) : node(x.node) {}
	bool operator==(const const_iterator& x) const { return node == x.node; } 
	const_reference operator*() const { return (*node).data; }
	const_iterator& operator++() { 
	    node = (link_type)((*node).next);
	    return *this;
	}
	const_iterator operator++(int) { 
	    const_iterator tmp = *this;
	    ++*this;
	    return tmp;
	}
	const_iterator& operator--() { 
	    node = (link_type)((*node).prev);
	    return *this;
	}
	const_iterator operator--(int) { 
	    const_iterator tmp = *this;
	    --*this;
	    return tmp;
	}
    };
    typedef reverse_bidirectional_iterator<const_iterator, value_type,
                                           const_reference, difference_type>
	const_reverse_iterator;
    typedef reverse_bidirectional_iterator<iterator, value_type, reference,
                                           difference_type>
        reverse_iterator; 
    list() : length(0) {
    // rajeevb - get critical section. released when function returns
    CSAutoLock AutoLock(gs_CritSec);

	++number_of_lists;
	node = get_node();
	(*node).next = node;
	(*node).prev = node;
    }
    iterator begin() { return (link_type)((*node).next); }
    const_iterator begin() const { return (link_type)((*node).next); }
    iterator end() { return node; }
    const_iterator end() const { return node; }
    reverse_iterator rbegin() { return reverse_iterator(end()); }
    const_reverse_iterator rbegin() const { 
        return const_reverse_iterator(end()); 
    }
    reverse_iterator rend() { return reverse_iterator(begin()); }
    const_reverse_iterator rend() const { 
        return const_reverse_iterator(begin());
    } 
    bool empty() const { return length == 0; }
    size_type size() const { return length; }
    size_type max_size() const { 
        // rajeevb - this doesn't require a crit sec
        return list_node_allocator.max_size(); 
    }
    reference front() { return *begin(); }
    const_reference front() const { return *begin(); }
    reference back() { return *(--end()); }
    const_reference back() const { return *(--end()); }
    void swap(list<T>& x) {
	::swap(node, x.node);
	::swap(length, x.length);
    }
    iterator insert(iterator position, const T& x) {
	link_type tmp = get_node();

    // rajeevb - this doesn't require crit sec
	construct(value_allocator.address((*tmp).data), x);
	(*tmp).next = position.node;
	(*tmp).prev = (*position.node).prev;
	(*(link_type((*position.node).prev))).next = tmp;
	(*position.node).prev = tmp;
	++length;
	return tmp;
    }
    void insert(iterator position, const T* first, const T* last);
    void insert(iterator position, const_iterator first,
		const_iterator last);
    void insert(iterator position, size_type n, const T& x);
    void push_front(const T& x) { insert(begin(), x); }
    void push_back(const T& x) { insert(end(), x); }
    void erase(iterator position) {
	(*(link_type((*position.node).prev))).next = (*position.node).next;
	(*(link_type((*position.node).next))).prev = (*position.node).prev;

    // rajeevb - this doesn't require a crit sec
	destroy(value_allocator.address((*position.node).data));
	put_node(position.node);
	--length;
    }
    void erase(iterator first, iterator last);
    void pop_front() { erase(begin()); }
    void pop_back() { 
	iterator tmp = end();
	erase(--tmp);
    }
    list(size_type n, const T& value = T()) : length(0) {
    // rajeevb - get critical section. released when function returns
    CSAutoLock AutoLock(gs_CritSec);

	++number_of_lists;
	node = get_node();
	(*node).next = node;
	(*node).prev = node;
	insert(begin(), n, value);
    }
    list(const T* first, const T* last) : length(0) {
    // rajeevb - get critical section. released when function returns
    CSAutoLock AutoLock(gs_CritSec);

	++number_of_lists;
	node = get_node();
	(*node).next = node;
	(*node).prev = node;
	insert(begin(), first, last);
    }
    list(const list<T>& x) : length(0) {
    // rajeevb - get critical section. released when function returns
    CSAutoLock AutoLock(gs_CritSec);

	++number_of_lists;
	node = get_node();
	(*node).next = node;
	(*node).prev = node;
	insert(begin(), x.begin(), x.end());
    }
    ~list() {
    // rajeevb - get critical section. released when function returns
    CSAutoLock AutoLock(gs_CritSec);

	erase(begin(), end());
	put_node(node);
	if (--number_of_lists == 0) deallocate_buffers();
    }
    list<T>& operator=(const list<T>& x);
protected:
    void transfer(iterator position, iterator first, iterator last) {
	(*(link_type((*last.node).prev))).next = position.node;
	(*(link_type((*first.node).prev))).next = last.node;
	(*(link_type((*position.node).prev))).next = first.node;  
	link_type tmp = link_type((*position.node).prev);
	(*position.node).prev = (*last.node).prev;
	(*last.node).prev = (*first.node).prev; 
	(*first.node).prev = tmp;
    }
public:
    void splice(iterator position, list<T>& x) {
	if (!x.empty()) {
	    transfer(position, x.begin(), x.end());
	    length += x.length;
	    x.length = 0;
	}
    }
    void splice(iterator position, list<T>& x, iterator i) {
	iterator j = i;
	if (position == i || position == ++j) return;
	transfer(position, i, j);
	++length;
	--x.length;
    }
    void splice(iterator position, list<T>& x, iterator first, iterator last) {
	if (first != last) {
	    if (&x != this) {
		difference_type n = 0;
	    	distance(first, last, n);
	    	x.length -= n;
	    	length += n;
	    }
	    transfer(position, first, last);
	}
    }
    void remove(const T& value);
    void unique();
    void merge(list<T>& x);
    void reverse();
    void sort();
};

template <class T>
ListCritSec list<T>::gs_CritSec;

template <class T>
list<T>::buffer_pointer list<T>::buffer_list = 0;

template <class T>
list<T>::link_type list<T>::free_list = 0;

template <class T>
list<T>::link_type list<T>::next_avail = 0;

template <class T>
list<T>::link_type list<T>::last = 0;

template <class T>
list<T>::size_type list<T>::number_of_lists = 0;

template <class T>
list<T>::list_node_allocator_type list<T>::list_node_allocator;

template <class T>
list<T>::value_allocator_type list<T>::value_allocator;

template <class T>
list<T>::buffer_allocator_type list<T>::buffer_allocator;

/* 
 * currently the following does not work - made into a member function

template <class T>
inline bool operator==(const list<T>::iterator& x, const list<T>::iterator& y) { 
    return x.node == y.node; 
}
*/

template <class T>
inline bool operator==(const list<T>& x, const list<T>& y) {
    return x.size() == y.size() && equal(x.begin(), x.end(), y.begin());
}

template <class T>
inline bool operator<(const list<T>& x, const list<T>& y) {
    return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
}

template <class T>
void list<T>::deallocate_buffers() {
    // rajeevb - get critical section. released when function returns
    CSAutoLock AutoLock(gs_CritSec);

    while (buffer_list) {
	buffer_pointer tmp = buffer_list;
	buffer_list = (buffer_pointer)(buffer_list->next_buffer);
	list_node_allocator.deallocate(tmp->buffer);
	buffer_allocator.deallocate(tmp);
    }
    free_list = 0;
    next_avail = 0;
    last = 0;
}

template <class T>
void list<T>::insert(iterator position, const T* first, const T* last) {
    while (first != last) insert(position, *first++);
}
	 
template <class T>
void list<T>::insert(iterator position, const_iterator first,
		     const_iterator last) {
    while (first != last) insert(position, *first++);
}

template <class T>
void list<T>::insert(iterator position, size_type n, const T& x) {
    while (n--) insert(position, x);
}

template <class T>
void list<T>::erase(iterator first, iterator last) {
    while (first != last) erase(first++);
}

template <class T>
list<T>& list<T>::operator=(const list<T>& x) {
    if (this != &x) {
	iterator first1 = begin();
	iterator last1 = end();
	const_iterator first2 = x.begin();
	const_iterator last2 = x.end();
	while (first1 != last1 && first2 != last2) *first1++ = *first2++;
	if (first2 == last2)
	    erase(first1, last1);
	else
	    insert(last1, first2, last2);
    }
    return *this;
}

template <class T>
void list<T>::remove(const T& value) {
    iterator first = begin();
    iterator last = end();
    while (first != last) {
	iterator next = first;
	++next;
	if (*first == value) erase(first);
	first = next;
    }
}

template <class T>
void list<T>::unique() {
    iterator first = begin();
    iterator last = end();
    if (first == last) return;
    iterator next = first;
    while (++next != last) {
	if (*first == *next)
	    erase(next);
	else
	    first = next;
	next = first;
    }
}

template <class T>
void list<T>::merge(list<T>& x) {
    iterator first1 = begin();
    iterator last1 = end();
    iterator first2 = x.begin();
    iterator last2 = x.end();
    while (first1 != last1 && first2 != last2)
	if (*first2 < *first1) {
	    iterator next = first2;
	    transfer(first1, first2, ++next);
	    first2 = next;
	} else
	    ++first1;
    if (first2 != last2) transfer(last1, first2, last2);
    length += x.length;
    x.length= 0;
}

template <class T>
void list<T>::reverse() {
    if (size() < 2) return;
    for (iterator first = ++begin(); first != end();) {
	iterator old = first++;
	transfer(begin(), old, first);
    }
}    

template <class T>
void list<T>::sort() {
    if (size() < 2) return;
    list<T> carry;
    list<T> counter[64];
    int fill = 0;
    while (!empty()) {
	carry.splice(carry.begin(), *this, begin());
	int i = 0;
	while(i < fill && !counter[i].empty()) {
	    counter[i].merge(carry);
	    carry.swap(counter[i++]);
	}
	carry.swap(counter[i]);         
	if (i == fill) ++fill;
    } 

    for (int i = 1; i < fill; ++i) counter[i].merge(counter[i-1]);
    swap(counter[fill-1]);
}

#undef Allocator
#undef list

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\lmultmap.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef LMULTIMAP_H
#define LMULTIMAP_H

#ifdef MULTIMAP_H
#undef MULTIMAP_H
#undef TREE_H
#define __MULTIMAP_WAS_DEFINED
#endif

#define Allocator long_allocator
#define multimap long_multimap
#define rb_tree long_rb_tree
#include <lngalloc.h>
#include <multimap.h>

#undef MULTIMAP_H
#undef TREE_H

#ifdef __MULTIMAP_WAS_DEFINED
#define MULTIMAP_H
#define TREE_H
#undef  __MULTIMAP_WAS_DEFINED
#endif

#undef Allocator
#undef multimap
#undef rb_tree

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\lmultset.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef LMULTISET_H
#define LMULTISET_H

#ifdef MULTISET_H
#undef MULTISET_H
#undef TREE_H
#define __MULTISET_WAS_DEFINED
#endif

#define Allocator long_allocator
#define multiset long_multiset
#define rb_tree long_rb_tree
#include <lngalloc.h>
#include <multiset.h>

#undef MULTISET_H
#undef TREE_H

#ifdef __MULTISET_WAS_DEFINED
#define MULTISET_H
#define TREE_H
#undef  __MULTISET_WAS_DEFINED
#endif

#undef Allocator
#undef multiset
#undef rb_tree

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\lngalloc.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef LNGALLOC_H
#define LNGALLOC_H

#include <limits.h>
#include <algobase.h>
#include <defalloc.h>

template <class T>
class long_allocator {
public:
    typedef T value_type;
    typedef T* pointer;
    typedef const T* const_pointer;
    typedef T& reference;
    typedef const T& const_reference;
    typedef unsigned long size_type;
    typedef long difference_type;
    pointer allocate(size_type n) { 
	return ::allocate((difference_type)n, (pointer)0);
    }
    void deallocate(pointer p) { ::deallocate(p); }
    pointer address(reference x) { return (pointer)&x; }
    const_pointer const_address(const_reference x) { 
	return (const_pointer)&x; 
    }
    size_type init_page_size() { 
	return stlmax(size_type(1), size_type(4096/sizeof(T))); 
    }
    size_type max_size() const { 
	return stlmax(size_type(1), size_type(ULONG_MAX/sizeof(T))); 
    }
};

class long_allocator<void> {
public:
    typedef void* pointer;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\lset.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef LSET_H
#define LSET_H

#ifdef SET_H
#undef SET_H
#undef TREE_H
#define __SET_WAS_DEFINED
#endif

#define Allocator long_allocator
#define set long_set
#define rb_tree long_rb_tree
#include <lngalloc.h>
#include <set.h>

#undef SET_H
#undef TREE_H

#ifdef __SET_WAS_DEFINED
#define SET_H
#define TREE_H
#undef  __SET_WAS_DEFINED
#endif

#undef Allocator
#undef set
#undef rb_tree

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\neralloc.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef NEARALLOC_H
#define NEARALLOC_H

#ifdef FARALLOC_H
#undef FARALLOC_H
#define __FARALLOC_WAS_DEFINED
#endif

#define __far __near
#define far_allocator near_allocator
#include <faralloc.h>
#undef __far
#undef far_allocator

#undef FARALLOC_H

#ifdef __FARALLOC_WAS_DEFINED
#define FARALLOC_H
#undef  __FARALLOC_WAS_DEFINED
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\nmultmap.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef NMULTIMAP_H
#define NMULTIMAP_H

#ifdef MULTIMAP_H
#undef MULTIMAP_H
#undef TREE_H
#define __MULTIMAP_WAS_DEFINED
#endif

#define Allocator near_allocator
#define multimap near_multimap
#define rb_tree near_rb_tree
#include <neralloc.h>
#include <multimap.h>

#undef MULTIMAP_H
#undef TREE_H

#ifdef __MULTIMAP_WAS_DEFINED
#define MULTIMAP_H
#define TREE_H
#undef  __MULTIMAP_WAS_DEFINED
#endif

#undef Allocator
#undef multimap
#undef rb_tree

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\nmap.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef NMAP_H
#define NMAP_H

#ifdef MAP_H
#undef MAP_H
#undef TREE_H
#define __MAP_WAS_DEFINED
#endif

#define Allocator near_allocator
#define map near_map
#define rb_tree near_rb_tree
#include <neralloc.h>
#include <map.h>

#undef MAP_H
#undef TREE_H

#ifdef __MAP_WAS_DEFINED
#define MAP_H
#define TREE_H
#undef  __MAP_WAS_DEFINED
#endif

#undef Allocator
#undef map
#undef rb_tree

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\nmultset.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef NMULTISET_H
#define NMULTISET_H

#ifdef MULTISET_H
#undef MULTISET_H
#undef TREE_H
#define __MULTISET_WAS_DEFINED
#endif

#define Allocator near_allocator
#define multiset near_multiset
#define rb_tree near_rb_tree
#include <neralloc.h>
#include <multiset.h>

#undef MULTISET_H
#undef TREE_H

#ifdef __MULTISET_WAS_DEFINED
#define MULTISET_H
#define TREE_H
#undef  __MULTISET_WAS_DEFINED
#endif

#undef Allocator
#undef multiset
#undef rb_tree

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\multiset.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef MULTISET_H
#define MULTISET_H

#ifndef Allocator
#define Allocator allocator
#include <defalloc.h>
#endif

#include <tree.h>

template <class Key, class Compare>
class multiset {
public:
// typedefs:

    typedef Key key_type;
    typedef Key value_type;
    typedef Compare key_compare;
    typedef Compare value_compare;
private:
    typedef rb_tree<key_type, value_type, 
                    ident<value_type, key_type>, key_compare> rep_type;
    rep_type t;  // red-black tree representing multiset
public:
    typedef rep_type::const_reference reference;
    typedef rep_type::const_reference const_reference;
    typedef rep_type::const_iterator iterator;
    typedef rep_type::const_iterator const_iterator;
    typedef rep_type::const_reverse_iterator reverse_iterator;
    typedef rep_type::const_reverse_iterator const_reverse_iterator;
    typedef rep_type::size_type size_type;
    typedef rep_type::difference_type difference_type;

// allocation/deallocation

    multiset(const Compare& comp = Compare()) : t(comp, true) {}
    multiset(const value_type* first, const value_type* last, 
        const Compare& comp = Compare()) : t(comp, true) {
        for (const value_type* i = first; i != last; ++i)
           t.insert(*i);
    }
    multiset(const multiset<Key, Compare>& x) : t(x.t, true) {}
    multiset<Key, Compare>& operator=(const multiset<Key, Compare>& x) { 
        t = x.t; 
        return *this;
    }

// accessors:

    key_compare key_comp() const { return t.key_comp(); }
    value_compare value_comp() const { return t.key_comp(); }
    iterator begin() const { return t.begin(); }
    iterator end() const { return t.end(); }
    reverse_iterator rbegin() const { return t.rbegin(); } 
    reverse_iterator rend() const { return t.rend(); }
    bool empty() const { return t.empty(); }
    size_type size() const { return t.size(); }
    size_type max_size() const { return t.max_size(); }
    void swap(multiset<Key, Compare>& x) { t.swap(x.t); }

// insert/erase
    iterator insert(const value_type& x) { 
        return t.insert(x).first;
    }
    iterator insert(iterator position, const value_type& x) {
        return t.insert((rep_type::iterator&)position, x);
    }
    void insert(const value_type* first, const value_type* last) {
        for (const value_type* i = first; i != last; ++i)
            t.insert(*i);
    }
    void erase(iterator position) { 
        t.erase((rep_type::iterator&)position); 
    }
    size_type erase(const key_type& x) { 
        return t.erase(x); 
    }
    void erase(iterator first, iterator last) { 
        t.erase((rep_type::iterator&)first, 
                (rep_type::iterator&)last); 
    }

// multiset operations:

    iterator find(const key_type& x) const { return t.find(x); }
    size_type count(const key_type& x) const { return t.count(x); }
    iterator lower_bound(const key_type& x) const {
        return t.lower_bound(x);
    }
    iterator upper_bound(const key_type& x) const {
        return t.upper_bound(x); 
    }
    typedef  pair<iterator, iterator> pair_iterator_iterator; 
    // typedef done to get around compiler bug
    pair_iterator_iterator equal_range(const key_type& x) const {
        return t.equal_range(x);
    }
};

template <class Key, class Compare>
inline bool operator==(const multiset<Key, Compare>& x, 
                       const multiset<Key, Compare>& y) {
    return x.size() == y.size() && equal(x.begin(), x.end(), y.begin());
}

template <class Key, class Compare>
inline bool operator<(const multiset<Key, Compare>& x, 
                      const multiset<Key, Compare>& y) {
    return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
}

#undef Allocator

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\nset.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef NSET_H
#define NSET_H

#ifdef SET_H
#undef SET_H
#undef TREE_H
#define __SET_WAS_DEFINED
#endif

#define Allocator near_allocator
#define set near_set
#define rb_tree near_rb_tree
#include <neralloc.h>
#include <set.h>

#undef SET_H
#undef TREE_H

#ifdef __SET_WAS_DEFINED
#define SET_H
#define TREE_H
#undef  __SET_WAS_DEFINED
#endif

#undef Allocator
#undef set
#undef rb_tree

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\map.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef MAP_H
#define MAP_H

#ifndef Allocator
#define Allocator allocator
#include <defalloc.h>
#endif

#include <tree.h>

template <class Key, class T, class Compare>
class map {
public:

// typedefs:

    typedef Key key_type;
    typedef pair<const Key, T> value_type;
    typedef Compare key_compare;
    
    class value_compare
        : public binary_function<value_type, value_type, bool> {
    friend class map<Key, T, Compare>;
    protected :
        Compare comp;
        value_compare(Compare c) : comp(c) {}
    public:
        bool operator()(const value_type& x, const value_type& y) const {
            return comp(x.first, y.first);
        }
    };

private:
    typedef rb_tree<key_type, value_type, 
                    select1st<value_type, key_type>, key_compare> rep_type;
    rep_type t;  // red-black tree representing map
public:
    typedef rep_type::pointer pointer;
    typedef rep_type::reference reference;
    typedef rep_type::const_reference const_reference;
    typedef rep_type::iterator iterator;
    typedef rep_type::const_iterator const_iterator;
    typedef rep_type::reverse_iterator reverse_iterator;
    typedef rep_type::const_reverse_iterator const_reverse_iterator;
    typedef rep_type::size_type size_type;
    typedef rep_type::difference_type difference_type;

// allocation/deallocation

    map(const Compare& comp = Compare()) : t(comp, false) {}
    map(const value_type* first, const value_type* last, 
        const Compare& comp = Compare()) : t(first, last, comp, false) {}
    map(const map<Key, T, Compare>& x) : t(x.t, false) {}
    map<Key, T, Compare>& operator=(const map<Key, T, Compare>& x) {
        t = x.t;
        return *this; 
    }

// accessors:

    key_compare key_comp() const { return t.key_comp(); }
    value_compare value_comp() const { return value_compare(t.key_comp()); }
    iterator begin() { return t.begin(); }
    const_iterator begin() const { return t.begin(); }
    iterator end() { return t.end(); }
    const_iterator end() const { return t.end(); }
    reverse_iterator rbegin() { return t.rbegin(); }
    const_reverse_iterator rbegin() const { return t.rbegin(); }
    reverse_iterator rend() { return t.rend(); }
    const_reverse_iterator rend() const { return t.rend(); }
    bool empty() const { return t.empty(); }
    size_type size() const { return t.size(); }
    size_type max_size() const { return t.max_size(); }
    Allocator<T>::reference operator[](const key_type& k) {
        return (*((insert(value_type(k, T()))).first)).second;
    }
    void swap(map<Key, T, Compare>& x) { t.swap(x.t); }

// insert/erase

    typedef pair<iterator, bool> pair_iterator_bool; 
    // typedef done to get around compiler bug
    pair_iterator_bool insert(const value_type& x) { return t.insert(x); }
    iterator insert(iterator position, const value_type& x) {
        return t.insert(position, x);
    }
    void insert(const value_type* first, const value_type* last) {
        t.insert(first, last);
    }
    void erase(iterator position) { t.erase(position); }
    size_type erase(const key_type& x) { return t.erase(x); }
    void erase(iterator first, iterator last) { t.erase(first, last); }

// map operations:

    iterator find(const key_type& x) { return t.find(x); }
    const_iterator find(const key_type& x) const { return t.find(x); }
    size_type count(const key_type& x) const { return t.count(x); }
    iterator lower_bound(const key_type& x) {return t.lower_bound(x); }
    const_iterator lower_bound(const key_type& x) const {
        return t.lower_bound(x); 
    }
    iterator upper_bound(const key_type& x) {return t.upper_bound(x); }
    const_iterator upper_bound(const key_type& x) const {
        return t.upper_bound(x); 
    }
    typedef pair<iterator, iterator> pair_iterator_iterator; 
    // typedef done to get around compiler bug
    pair_iterator_iterator equal_range(const key_type& x) {
        return t.equal_range(x);
    }
    typedef pair<const_iterator, const_iterator> pair_citerator_citerator; 
    // typedef done to get around compiler bug
    pair_citerator_citerator equal_range(const key_type& x) const {
        return t.equal_range(x);
    }
};

template <class Key, class T, class Compare>
inline bool operator==(const map<Key, T, Compare>& x, 
                       const map<Key, T, Compare>& y) {
    return x.size() == y.size() && equal(x.begin(), x.end(), y.begin());
}

template <class Key, class T, class Compare>
inline bool operator<(const map<Key, T, Compare>& x, 
                      const map<Key, T, Compare>& y) {
    return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
}

#undef Allocator

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\multimap.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef MULTIMAP_H
#define MULTIMAP_H

#ifndef Allocator
#define Allocator allocator
#include <defalloc.h>
#endif

#include <tree.h>

template <class Key, class T, class Compare>
class multimap {
public:

// typedefs:

    typedef Key key_type;
    typedef pair<const Key, T> value_type;
    typedef Compare key_compare;

    class value_compare
        : public binary_function<value_type, value_type, bool> {
    friend class multimap<Key, T, Compare>;
    protected:
        Compare comp;
        value_compare(Compare c) : comp(c) {}
    public:
        bool operator()(const value_type& x, const value_type& y) const {
            return comp(x.first, y.first);
        }
    };

private:
    typedef rb_tree<key_type, value_type, 
                    select1st<value_type, key_type>, key_compare> rep_type;
    rep_type t;  // red-black tree representing multimap
public:
    typedef rep_type::reference reference;
    typedef rep_type::const_reference const_reference;
    typedef rep_type::iterator iterator;
    typedef rep_type::const_iterator const_iterator; 
    typedef rep_type::reverse_iterator reverse_iterator;
    typedef rep_type::const_reverse_iterator const_reverse_iterator;
    typedef rep_type::size_type size_type;
    typedef rep_type::difference_type difference_type;

// allocation/deallocation

    multimap(const Compare& comp = Compare()) : t(comp, true) { }
    multimap(const value_type* first, const value_type* last, 
             const Compare& comp = Compare()) : t(first, last, comp, true) { }
    multimap(const multimap<Key, T, Compare>& x) : t(x.t, true) { }
    multimap<Key, T, Compare>& operator=(const multimap<Key, T, Compare>& x) {
        t = x.t;
        return *this; 
    }

// accessors:

    key_compare key_comp() const { return t.key_comp(); }
    value_compare value_comp() const { return value_compare(t.key_comp()); }
    iterator begin() { return t.begin(); }
    const_iterator begin() const { return t.begin(); }
    iterator end() { return t.end(); }
    const_iterator end() const { return t.end(); }
    reverse_iterator rbegin() { return t.rbegin(); }
    const_reverse_iterator rbegin() const { return t.rbegin(); }
    reverse_iterator rend() { return t.rend(); }
    const_reverse_iterator rend() const { return t.rend(); }
    bool empty() const { return t.empty(); }
    size_type size() const { return t.size(); }
    size_type max_size() const { return t.max_size(); }
    void swap(multimap<Key, T, Compare>& x) { t.swap(x.t); }

// insert/erase

    iterator insert(const value_type& x) { return t.insert(x).first; }
    iterator insert(iterator position, const value_type& x) {
        return t.insert(position, x);
    }
    void insert(const value_type* first, const value_type* last) {
        t.insert(first, last);
    }
    void erase(iterator position) { t.erase(position); }
    size_type erase(const key_type& x) { return t.erase(x); }
    void erase(iterator first, iterator last) { t.erase(first, last); }

// multimap operations:

    iterator find(const key_type& x) { return t.find(x); }
    const_iterator find(const key_type& x) const { return t.find(x); }
    size_type count(const key_type& x) const { return t.count(x); }
    iterator lower_bound(const key_type& x) {return t.lower_bound(x); }
    const_iterator lower_bound(const key_type& x) const {
        return t.lower_bound(x); 
    }
    iterator upper_bound(const key_type& x) {return t.upper_bound(x); }
    const_iterator upper_bound(const key_type& x) const {
        return t.upper_bound(x); 
    }
    typedef  pair<iterator, iterator> pair_iterator_iterator; 
    // typedef done to get around compiler bug
    pair_iterator_iterator equal_range(const key_type& x) {
        return t.equal_range(x);
    }
    typedef  pair<const_iterator, const_iterator> pair_citerator_citerator; 
    // typedef done to get around compiler bug
    pair_citerator_citerator equal_range(const key_type& x) const {
        return t.equal_range(x);
    }
};

template <class Key, class T, class Compare>
inline bool operator==(const multimap<Key, T, Compare>& x, 
                       const multimap<Key, T, Compare>& y) {
    return x.size() == y.size() && equal(x.begin(), x.end(), y.begin());
}

template <class Key, class T, class Compare>
inline bool operator<(const multimap<Key, T, Compare>& x, 
                      const multimap<Key, T, Compare>& y) {
    return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
}

#undef Allocator

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\random.cpp ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#include <stddef.h>

#define __SEED 161803398

class __random_generator {
protected:
    unsigned long table[55];
    size_t index1;
    size_t index2;
public:
    unsigned long operator()(unsigned long limit) {
	index1 = (index1 + 1) % 55;
	index2 = (index2 + 1) % 55;
	table[index1] = table[index1] - table[index2];
	return table[index1] % limit;
    }
    void seed(unsigned long j);
    __random_generator(unsigned long j) { seed(j); }
};

void __random_generator::seed(unsigned long j) {
    unsigned long k = 1;
    table[54] = j;
    size_t i;
    for (i = 0; i < 54; i++) {
 	size_t ii = (21 * (i + 1) % 55) - 1;
        table[ii] = k;
        k = j - k;
        j = table[ii];
    }
    for (int loop = 0; loop < 4; loop++) {
        for (i = 0; i < 55; i++)
            table[i] = table[i] - table[(1 + i + 30) % 55];
    }
    index1 = 0;
    index2 = 31;
}

static __random_generator rd(__SEED);

unsigned long __long_random(unsigned long limit) {
    return rd(limit);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\tempbuf.cpp ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#include <tempbuf.h>

char __stl_temp_buffer[__stl_buffer_size];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\projectn.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef PROJECTN_H
#define PROJECTN_H

#include <function.h>

template <class T, class U>
struct select1st : public unary_function<T, U> {
    const U& operator()(const T& x) const { return x.first; }
};

template <class T, class U>
struct ident : public unary_function<T, U> {
    const U& operator()(const T& x) const { return x; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\random.c ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#include <stddef.h>

#define __SEED 161803398

class __random_generator {
protected:
    unsigned long table[55];
    size_t index1;
    size_t index2;
public:
    unsigned long operator()(unsigned long limit) {
	index1 = (index1 + 1) % 55;
	index2 = (index2 + 1) % 55;
	table[index1] = table[index1] - table[index2];
	return table[index1] % limit;
    }
    void seed(unsigned long j);
    __random_generator(unsigned long j) { seed(j); }
};

void __random_generator::seed(unsigned long j) {
    unsigned long k = 1;
    table[54] = j;
    size_t i;
    for (i = 0; i < 54; i++) {
 	size_t ii = (21 * (i + 1) % 55) - 1;
        table[ii] = k;
        k = j - k;
        j = table[ii];
    }
    for (int loop = 0; loop < 4; loop++) {
        for (i = 0; i < 55; i++)
            table[i] = table[i] - table[(1 + i + 30) % 55];
    }
    index1 = 0;
    index2 = 31;
}

static __random_generator rd(__SEED);

unsigned long __long_random(unsigned long limit) {
    return rd(limit);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\pair.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef PAIR_H
#define PAIR_H

#include <bool.h>

template <class T1, class T2>
struct pair {
    T1 first;
    T2 second;
    pair() : first(T1()), second(T2()) {}
    pair(const T1& a, const T2& b) : first(a), second(b) {}
    friend void destroy(pair<T1, T2>* p) {
      p->~pair();
    }
};

template <class T1, class T2>
inline bool operator==(const pair<T1, T2>& x, const pair<T1, T2>& y) { 
    return x.first == y.first && x.second == y.second; 
}

template <class T1, class T2>
inline bool operator<(const pair<T1, T2>& x, const pair<T1, T2>& y) { 
    return x.first < y.first || (!(y.first < x.first) && x.second < y.second); 
}

template <class T1, class T2>
inline pair<T1, T2> make_pair(const T1& x, const T2& y) {
    return pair<T1, T2>(x, y);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\tempbuf.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef TEMPBUF_H
#define TEMPBUF_H

#include <limits.h>
#include <pair.h>

#ifndef __stl_buffer_size
#define __stl_buffer_size 16384 // 16k
#endif

extern char __stl_temp_buffer[__stl_buffer_size];

//not reentrant code

template <class T>
pair<T*, int> get_temporary_buffer(int len, T*) {
    while (len > __stl_buffer_size / sizeof(T)) {
	set_new_handler(0);
        T* tmp = (T*)(::operator new((unsigned int)len * sizeof(T)));
        if (tmp) return pair<T*, int>(tmp, len);
        len = len / 2;
    }
    return pair<T*, int>((T*)__stl_temp_buffer, 
                         (int)(__stl_buffer_size / sizeof(T)));
}

template <class T>
void return_temporary_buffer(T* p) {
    if ((char*)(p) != __stl_temp_buffer) deallocate(p);
}

template <class T>
pair<T*, long> get_temporary_buffer(long len, T* p) {
    if (len > INT_MAX/sizeof(T)) 
	len = INT_MAX/sizeof(T);
    pair<T*, int> tmp = get_temporary_buffer((int)len, p);
    return pair<T*, long>(tmp.first, (long)(tmp.second));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\stack.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef STACK_H
#define STACK_H

#include <bool.h>
#include <heap.h>

template <class Container>
class stack {
friend bool operator==(const stack<Container>& x, const stack<Container>& y);
friend bool operator<(const stack<Container>& x, const stack<Container>& y);
public:
    typedef Container::value_type value_type;
    typedef Container::size_type size_type;
protected:
    Container c;
public:
    bool empty() const { return c.empty(); }
    size_type size() const { return c.size(); }
    value_type& top() { return c.back(); }
    const value_type& top() const { return c.back(); }
    void push(const value_type& x) { c.push_back(x); }
    void pop() { c.pop_back(); }
};

template <class Container>
bool operator==(const stack<Container>& x, const stack<Container>& y) {
    return x.c == y.c;
}

template <class Container>
bool operator<(const stack<Container>& x, const stack<Container>& y) {
    return x.c < y.c;
}

template <class Container>
class queue {
friend bool operator==(const queue<Container>& x, const queue<Container>& y);
friend bool operator<(const queue<Container>& x, const queue<Container>& y);
public:
    typedef Container::value_type value_type;
    typedef Container::size_type size_type;
protected:
    Container c;
public:
    bool empty() const { return c.empty(); }
    size_type size() const { return c.size(); }
    value_type& front() { return c.front(); }
    const value_type& front() const { return c.front(); }
    value_type& back() { return c.back(); }
    const value_type& back() const { return c.back(); }
    void push(const value_type& x) { c.push_back(x); }
    void pop() { c.pop_front(); }
};

template <class Container>
bool operator==(const queue<Container>& x, const queue<Container>& y) {
    return x.c == y.c;
}

template <class Container>
bool operator<(const queue<Container>& x, const queue<Container>& y) {
    return x.c < y.c;
}

template <class Container, class Compare> 
// Compare = less<Container::value_type> >
class  priority_queue {
public:
    typedef Container::value_type value_type;
    typedef Container::size_type size_type;
protected:
    Container c;
    Compare comp;
public:
    priority_queue(const Compare& x = Compare()) :  c(), comp(x) {}
    priority_queue(const value_type* first, const value_type* last, 
		   const Compare& x = Compare()) : c(first, last), comp(x) {
	make_heap(c.begin(), c.end(), comp);
    }
/*
    template <class InputIterator>
    priority_queue(InputIterator first, InputIterator last, 
		   const Compare& x = Compare()) : c(first, last), comp(x) {
	make_heap(c.begin(), c.end(), comp);
    }
*/
    bool empty() const { return c.empty(); }
    size_type size() const { return c.size(); }
    value_type& top() { return c.front(); }
    const value_type& top() const { return c.front(); }
    void push(const value_type& x) { 
	c.push_back(x); 
	push_heap(c.begin(), c.end(), comp);
    }
    void pop() { 
	pop_heap(c.begin(), c.end(), comp);
	c.pop_back(); 
    }
};

// no equality is provided

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\set.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef SET_H
#define SET_H

#ifndef Allocator
#define Allocator allocator
#include <defalloc.h>
#endif

#include <tree.h>

template <class Key, class Compare>
class set {
public:
// typedefs:

    typedef Key key_type;
    typedef Key value_type;
    typedef Compare key_compare;
    typedef Compare value_compare;
private:
    typedef rb_tree<key_type, value_type, 
                    ident<value_type, key_type>, key_compare> rep_type;
    rep_type t;  // red-black tree representing set
public:
    typedef rep_type::const_reference reference;
    typedef rep_type::const_reference const_reference;
    typedef rep_type::const_iterator iterator;
    typedef rep_type::const_iterator const_iterator;
    typedef rep_type::const_reverse_iterator reverse_iterator;
    typedef rep_type::const_reverse_iterator const_reverse_iterator;
    typedef rep_type::size_type size_type;
    typedef rep_type::difference_type difference_type;

// allocation/deallocation

    set(const Compare& comp = Compare()) : t(comp, false) {}
    set(const value_type* first, const value_type* last, 
        const Compare& comp = Compare()) : t(comp, false) {
        for (const value_type* i = first; i != last; ++i)
           t.insert(*i);
    }
    set(const set<Key, Compare>& x) : t(x.t, false) {}
    set<Key, Compare>& operator=(const set<Key, Compare>& x) { 
        t = x.t; 
        return *this;
    }

// accessors:

    key_compare key_comp() const { return t.key_comp(); }
    value_compare value_comp() const { return t.key_comp(); }
    iterator begin() const { return t.begin(); }
    iterator end() const { return t.end(); }
    reverse_iterator rbegin() const { return t.rbegin(); } 
    reverse_iterator rend() const { return t.rend(); }
    bool empty() const { return t.empty(); }
    size_type size() const { return t.size(); }
    size_type max_size() const { return t.max_size(); }
    void swap(set<Key, Compare>& x) { t.swap(x.t); }

// insert/erase
    typedef  pair<iterator, bool> pair_iterator_bool; 
    // typedef done to get around compiler bug
    pair_iterator_bool insert(const value_type& x) { 
        pair<rep_type::iterator, bool> p = t.insert(x); 
        return pair<iterator, bool>(p.first, p.second);
    }
    iterator insert(iterator position, const value_type& x) {
        return t.insert((rep_type::iterator&)position, x);
    }
    void insert(const value_type* first, const value_type* last) {
        for (const value_type* i = first; i != last; ++i)
            t.insert(*i);
    }
    void erase(iterator position) { 
        t.erase((rep_type::iterator&)position); 
    }
    size_type erase(const key_type& x) { 
        return t.erase(x); 
    }
    void erase(iterator first, iterator last) { 
        t.erase((rep_type::iterator&)first, 
                (rep_type::iterator&)last); 
    }

// set operations:

    iterator find(const key_type& x) const { return t.find(x); }
    size_type count(const key_type& x) const { return t.count(x); }
    iterator lower_bound(const key_type& x) const {
        return t.lower_bound(x);
    }
    iterator upper_bound(const key_type& x) const {
        return t.upper_bound(x); 
    }
    typedef  pair<iterator, iterator> pair_iterator_iterator; 
    // typedef done to get around compiler bug
    pair_iterator_iterator equal_range(const key_type& x) const {
        return t.equal_range(x);
    }
};

template <class Key, class Compare>
inline bool operator==(const set<Key, Compare>& x, 
                       const set<Key, Compare>& y) {
    return x.size() == y.size() && equal(x.begin(), x.end(), y.begin());
}

template <class Key, class Compare>
inline bool operator<(const set<Key, Compare>& x, 
                      const set<Key, Compare>& y) {
    return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
}

#undef Allocator

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\intldbg\port32.h ===
//////////////////////////////////////////////////////////////////////////////
//
//              INTEL CORPORATION PROPRIETARY INFORMATION
//  
//   This source is supplied under the terms of a licence agreement or
//   non-disclosure statement with Intel Corporation and may not be copied
//   nor disclosed except in accordance with the terms of that agreement.
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// PORT32.H
// Stuff to make porting from Win3.1 to Win32 a little less hellish.
//////////////////////////////////////////////////////////////////////////////
#ifndef PORT32_H
#define PORT32_H


//////////////////////////////////////////////////////////////////////////////
// some convenient, explicit types
//////////////////////////////////////////////////////////////////////////////
typedef short INTEGER_16;
typedef int INTEGER_32;
typedef unsigned short UINTEGER_16;
typedef unsigned int UINTEGER_32;
typedef short BOOLEAN_16;

typedef short INT16;
typedef int INT32;
typedef unsigned short UINT16;
typedef unsigned int UINT32;
typedef short BOOL16;
	
//////////////////////////////////////////////////////////////////////////////
// macros to make old keywords go away
//////////////////////////////////////////////////////////////////////////////
#define __pascal
#define _pascal
#define _far
#define __far
#define _export
#define __export
#define _huge
#define huge
#define __huge
#define  __segment
#define _HFAR_
#define _loadds
#define __loadds

//////////////////////////////////////////////////////////////////////////////
// other macros that may or may not be handy
//////////////////////////////////////////////////////////////////////////////
#define WRITE OF_WRITE

#define OFFSETOF(lp)        (int) (lp)
#define SELECTOROF

#define GLOBALHANDLE(lp)      GlobalHandle(lp)
#define GLOBALHANDLEFUNC(lp)  GlobalHandle(lp)
#define LOCALHANDLE(lp)       LocalHandle(lp)
#define LOCALHANDLEFUNC(lp)   LocalHandle(lp)


#define _AfxGetPtrFromFarPtr(p)   ((void*)(p))
#define GETWINDOWHINSTANCE(hWnd)  GetWindowLong(hWnd ,GWL_HINSTANCE)
#define GETWINDOWHPARENT(hWnd)    GetWindowLong(hWnd, GWL_HWNDPARENT)
#define GETWINDOWID(hWnd)         GetWindowLong(hWnd, GWL_ID)

#define SETCLASSCURSOR(hWnd,NewVal)  SetClassLong(hWnd ,GCL_HCURSOR,NewVal)

//////////////////////////////////////////////////////////////////////////////
// Name of shared mutex for serializing access to 16-bit data stack
//////////////////////////////////////////////////////////////////////////////
#define STR_DATASTACKMUX "_mux_DataStack"

#endif // PORT32_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\tree.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef TREE_H
#define TREE_H

/*

Red-black tree class, designed for use in implementing STL
associative containers (set, multiset, map, and multimap). The
insertion and deletion algorithms are based on those in Cormen,
Leiserson, and Rivest, Introduction to Algorithms (MIT Press, 1990),
except that

(1) the header cell is maintained with links not only to the root
but also to the leftmost node of the tree, to enable constant time
begin(), and to the rightmost node of the tree, to enable linear time
performance when used with the generic set algorithms (set_union,
etc.);

(2) when a node being deleted has two children its successor node is
relinked into its place, rather than copied, so that the only
iterators invalidated are those referring to the deleted node.

*/

#include <algobase.h>
#include <iterator.h>
#include <function.h>
#include <bool.h>
#include <projectn.h>

#ifndef rb_tree 
#define rb_tree rb_tree
#endif

class TreeCritSec
{
public:
    CRITICAL_SECTION m_CritSec;
    TreeCritSec() { ::InitializeCriticalSection(&m_CritSec); }
    ~TreeCritSec() { ::DeleteCriticalSection(&m_CritSec); }
};

class CTAutoLock
{
public:
    TreeCritSec *m_pLock;
    CTAutoLock(TreeCritSec *pLock) : m_pLock(pLock)
        { ::EnterCriticalSection(&m_pLock->m_CritSec); }
    ~CTAutoLock() { ::LeaveCriticalSection(&m_pLock->m_CritSec); }
};

template <class Key, class Value, class KeyOfValue, class Compare>
class rb_tree {
protected:
    enum color_type {red, black};
    typedef Allocator<void>::pointer void_pointer;
    struct rb_tree_node;
    friend rb_tree_node;
    struct rb_tree_node {
        color_type color_field; 
        void_pointer parent_link;
        void_pointer left_link;
        void_pointer right_link;
        Value value_field;
    };
    static Allocator<rb_tree_node> rb_tree_node_allocator;
    static Allocator<Value> value_allocator;
public:
    typedef Key key_type;
    typedef Value value_type;
    typedef Allocator<Value>::pointer pointer;
    typedef Allocator<Value>::reference reference;
    typedef Allocator<Value>::const_reference const_reference;
    typedef Allocator<rb_tree_node> rb_tree_node_allocator_type;
    typedef Allocator<rb_tree_node>::pointer link_type;
    typedef Allocator<rb_tree_node>::size_type size_type;
    typedef Allocator<rb_tree_node>::difference_type difference_type;
protected:
    size_type buffer_size() {
        return rb_tree_node_allocator.init_page_size();
    }
    struct rb_tree_node_buffer;
    friend rb_tree_node_buffer;
    struct rb_tree_node_buffer {
        void_pointer next_buffer;
        link_type buffer;
    };
public:
    typedef Allocator<rb_tree_node_buffer> buffer_allocator_type;
    typedef Allocator<rb_tree_node_buffer>::pointer buffer_pointer;     

	static TreeCritSec treeCritSec;
protected:
    static Allocator<rb_tree_node_buffer> buffer_allocator;
    static buffer_pointer buffer_list;
    static link_type free_list;
    static link_type next_avail;
    static link_type last;
    void add_new_buffer() {
		CTAutoLock _lock(&treeCritSec);
        buffer_pointer tmp = buffer_allocator.allocate((size_type)1);
        tmp->buffer = rb_tree_node_allocator.allocate(buffer_size());
        tmp->next_buffer = buffer_list;
        buffer_list = tmp;
        next_avail = buffer_list->buffer;
        last = next_avail + buffer_size();
    }
    static size_type number_of_trees;
    void deallocate_buffers();
    link_type get_node() {
        link_type tmp = free_list;
        return free_list ? 
            (free_list = (link_type)(free_list->right_link), tmp) 
                : (next_avail == last ? (add_new_buffer(), next_avail++) 
                   : next_avail++);
        // ugly code for inlining - avoids multiple returns
    }
    void put_node(link_type p) {
        p->right_link = free_list;
        free_list = p;
    }
protected:
    link_type header;  
    link_type& root() { return parent(header); }
    link_type& root() const { return parent(header); }
    link_type& leftmost() { return left(header); }
    link_type& leftmost() const { return left(header); }
    link_type& rightmost() { return right(header); }
    link_type& rightmost() const { return right(header); }
    size_type node_count; // keeps track of size of tree
    bool insert_always;  // controls whether an element already in the
                         // tree is inserted again
//public:
    Compare key_compare;
    static link_type NIL;
    static link_type& left(link_type x) { 
        return (link_type&)((*x).left_link);
    }
    static link_type& right(link_type x) {
        return (link_type&)((*x).right_link); 
    }
    static link_type& parent(link_type x) {
        return (link_type&)((*x).parent_link);
    }
    static reference value(link_type x) { return (*x).value_field; }
    static Allocator<Key>::const_reference key(link_type x) {
        return KeyOfValue()(value(x));
    }
    static color_type& color(link_type x) { 
        return (color_type&)(*x).color_field; }
    static link_type minimum(link_type x) {
        while (left(x) != NIL)
            x = left(x);
        return x;
    }
    static link_type maximum(link_type x) {
        while (right(x) != NIL)
            x = right(x);
        return x;
    }
public:
    class iterator;
    friend iterator;
    class const_iterator;
    friend const_iterator;
    class iterator : public bidirectional_iterator<Value, difference_type> {
    friend class rb_tree<Key, Value, KeyOfValue, Compare>;
    friend class const_iterator;
/*      
    friend bool operator==(const iterator& x, const iterator& y) {
        return x.node == y.node;
    }
*/
    protected:
        link_type node;
        iterator(link_type x) : node(x) {}
    public:
        iterator() {}
        bool operator==(const iterator& y) const { return node == y.node; }
        reference operator*() const { return value(node); }
        iterator& operator++() {
			CTAutoLock _lock(&treeCritSec);
            if (right(node) != NIL) {
                node = right(node);
                while (left(node) != NIL)
                    node = left(node);
            } else {
                link_type y = parent(node);
                while (node == right(y)) {
                    node = y;
                    y = parent(y);
                }
                if (right(node) != y) // necessary because of rightmost 
                    node = y;
            }
            return *this;
        }
        iterator operator++(int) {
			CTAutoLock _lock(&treeCritSec);
            iterator tmp = *this;
            ++*this;
            return tmp;
        }
        iterator& operator--() {
			CTAutoLock _lock(&treeCritSec);
            if (color(node) == red && parent(parent(node)) == node)  
                // check for header
                node = right(node);   // return rightmost
            else if (left(node) != NIL) {
                link_type y = left(node);
                while (right(y) != NIL)
                    y = right(y);
                node = y;
            } else {
                link_type y = parent(node);
                while (node == left(y)) {
                    node = y;
                    y = parent(y);
                }
                node = y;
            }
            return *this;
        }
        iterator operator--(int) {
			CTAutoLock _lock(&treeCritSec);
            iterator tmp = *this;
            --*this;
            return tmp;
        }
    };
    class const_iterator 
        : public bidirectional_iterator<Value,difference_type> {
    friend class rb_tree<Key, Value, KeyOfValue, Compare>;
    friend class iterator;
/*      
    friend bool operator==(const const_iterator& x, const const_iterator& y) {
        return x.node == y.node;
    }
*/
    protected:
        link_type node;
        const_iterator(link_type x) : node(x) {}
    public:
        const_iterator() {}
        const_iterator(const iterator& x) : node(x.node) {}
        bool operator==(const const_iterator& y) const { 
            return node == y.node; 
        }
        bool operator!=(const const_iterator& y) const { 
            return node != y.node; 
        }
        const_reference operator*() const { return value(node); }
        const_iterator& operator++() {
			CTAutoLock _lock(&treeCritSec);
            if (right(node) != NIL) {
                node = right(node);
                while (left(node) != NIL)
                    node = left(node);
            } else {
                link_type y = parent(node);
                while (node == right(y)) {
                    node = y;
                    y = parent(y);
                }
                if (right(node) != y) // necessary because of rightmost 
                    node = y;
            }
            return *this;
        }
        const_iterator operator++(int) {
			CTAutoLock _lock(&treeCritSec);
            const_iterator tmp = *this;
            ++*this;
            return tmp;
        }
        const_iterator& operator--() {
			CTAutoLock _lock(&treeCritSec);
            if (color(node) == red && parent(parent(node)) == node)  
                // check for header
                node = right(node);   // return rightmost
            else if (left(node) != NIL) {
                link_type y = left(node);
                while (right(y) != NIL)
                    y = right(y);
                node = y;
            } else {
                link_type y = parent(node);
                while (node == left(y)) {
                    node = y;
                    y = parent(y);
                }
                node = y;
            }
            return *this;
        }
        const_iterator operator--(int) {
			CTAutoLock _lock(&treeCritSec);
            const_iterator tmp = *this;
            --*this;
            return tmp;
        }
    };
    typedef reverse_bidirectional_iterator<iterator, value_type, reference,
                                           difference_type>
        reverse_iterator; 
    typedef reverse_bidirectional_iterator<const_iterator, value_type,
                                           const_reference, difference_type>
	const_reverse_iterator;
private:
    iterator __insert(link_type x, link_type y, const value_type& v);
    link_type __copy(link_type x, link_type p);
    void __erase(link_type x);
    void init() {
        ++number_of_trees;
        if (NIL == 0) {
            NIL = get_node();
            color(NIL) = black;
            parent(NIL) = 0;
            left(NIL) = 0;
            right(NIL) = 0;
        }
        header = get_node();
        color(header) = red;  // used to distinguish header from root,
                              // in iterator.operator++
        root() = NIL;
        leftmost() = header;
        rightmost() = header;
    }
public:
    
// allocation/deallocation
    
    rb_tree(const Compare& comp = Compare(), bool always = true) 
           : node_count(0), key_compare(comp), insert_always(always) { 
		CTAutoLock _lock(&treeCritSec);
        init();
    }
    rb_tree(const value_type* first, const value_type* last, 
            const Compare& comp = Compare(), bool always = true)
          : node_count(0), key_compare(comp), insert_always(always) { 
		CTAutoLock _lock(&treeCritSec);
        init();
        insert(first, last);
    }
    rb_tree(const rb_tree<Key, Value, KeyOfValue, Compare>& x, 
            bool always = true) : node_count(x.node_count), 
		key_compare(x.key_compare), insert_always(always) {
		CTAutoLock _lock(&treeCritSec);
        ++number_of_trees;
        header = get_node();
        color(header) = red;
        root() = __copy(x.root(), header);
        if (root() == NIL) {
            leftmost() = header;
            rightmost() = header;
        } else {
	    leftmost() = minimum(root());
            rightmost() = maximum(root());
        }
    }
    ~rb_tree() {
		CTAutoLock _lock(&treeCritSec);
        erase(begin(), end());
        put_node(header);
        if (--number_of_trees == 0) {
            put_node(NIL);
            NIL = 0;
            deallocate_buffers();
            free_list = 0;    
            next_avail = 0;
            last = 0;
        }
    }
    rb_tree<Key, Value, KeyOfValue, Compare>& 
        operator=(const rb_tree<Key, Value, KeyOfValue, Compare>& x);
    
// accessors:

    Compare key_comp() const { return key_compare; }
    iterator begin() { return leftmost(); }
    const_iterator begin() const { return leftmost(); }
    iterator end() { return header; }
    const_iterator end() const { return header; }
    reverse_iterator rbegin() { return reverse_iterator(end()); }
    const_reverse_iterator rbegin() const { 
        return const_reverse_iterator(end()); 
    }
    reverse_iterator rend() { return reverse_iterator(begin()); }
    const_reverse_iterator rend() const { 
        return const_reverse_iterator(begin());
    } 
    bool empty() const { return node_count == 0; }
    size_type size() const { return node_count; }
    size_type max_size() const { 
        return rb_tree_node_allocator.max_size(); 
    }
    void swap(rb_tree<Key, Value, KeyOfValue, Compare>& t) {
        ::swap(header, t.header);
        ::swap(node_count, t.node_count);
        ::swap(insert_always, t.insert_always);
        ::swap(key_compare, t.key_compare);
    }
    
// insert/erase

    typedef  pair<iterator, bool> pair_iterator_bool; 
    // typedef done to get around compiler bug
    pair_iterator_bool insert(const value_type& x);
    iterator insert(iterator position, const value_type& x);
    void insert(iterator first, iterator last);
    void insert(const value_type* first, const value_type* last);
    void erase(iterator position);
    size_type erase(const key_type& x);
    void erase(iterator first, iterator last);
    void erase(const key_type* first, const key_type* last);

// set operations:

    iterator find(const key_type& x);
    const_iterator find(const key_type& x) const;
    size_type count(const key_type& x) const;
    iterator lower_bound(const key_type& x);
    const_iterator lower_bound(const key_type& x) const;
    iterator upper_bound(const key_type& x);
    const_iterator upper_bound(const key_type& x) const;
    typedef  pair<iterator, iterator> pair_iterator_iterator; 
    // typedef done to get around compiler bug
    pair_iterator_iterator equal_range(const key_type& x);
    typedef  pair<const_iterator, const_iterator> pair_citerator_citerator; 
    // typedef done to get around compiler bug
    pair_citerator_citerator equal_range(const key_type& x) const;
    inline void rotate_left(link_type x);
    inline void rotate_right(link_type x);
};

template <class Key, class Value, class KeyOfValue, class Compare>
TreeCritSec rb_tree<Key, Value, KeyOfValue, Compare>::treeCritSec;

template <class Key, class Value, class KeyOfValue, class Compare>
rb_tree<Key, Value, KeyOfValue, Compare>::buffer_pointer 
        rb_tree<Key, Value, KeyOfValue, Compare>::buffer_list = 0;

template <class Key, class Value, class KeyOfValue, class Compare>
rb_tree<Key, Value, KeyOfValue, Compare>::link_type 
        rb_tree<Key, Value, KeyOfValue, Compare>::free_list = 0;

template <class Key, class Value, class KeyOfValue, class Compare>
rb_tree<Key, Value, KeyOfValue, Compare>::link_type 
        rb_tree<Key, Value, KeyOfValue, Compare>::next_avail = 0;

template <class Key, class Value, class KeyOfValue, class Compare>
rb_tree<Key, Value, KeyOfValue, Compare>::link_type 
        rb_tree<Key, Value, KeyOfValue, Compare>::last = 0;

template <class Key, class Value, class KeyOfValue, class Compare>
rb_tree<Key, Value, KeyOfValue, Compare>::size_type 
        rb_tree<Key, Value, KeyOfValue, Compare>::number_of_trees = 0;

template <class Key, class Value, class KeyOfValue, class Compare>
rb_tree<Key, Value, KeyOfValue, Compare>::rb_tree_node_allocator_type 
        rb_tree<Key, Value, KeyOfValue, Compare>::rb_tree_node_allocator;

template <class Key, class Value, class KeyOfValue, class Compare>
Allocator<Value> rb_tree<Key, Value, KeyOfValue, Compare>::value_allocator;

template <class Key, class Value, class KeyOfValue, class Compare>
rb_tree<Key, Value, KeyOfValue, Compare>::buffer_allocator_type 
        rb_tree<Key, Value, KeyOfValue, Compare>::buffer_allocator;

template <class Key, class Value, class KeyOfValue, class Compare>
rb_tree<Key, Value, KeyOfValue, Compare>::link_type 
        rb_tree<Key, Value, KeyOfValue, Compare>::NIL = 0;

template <class Key, class Value, class KeyOfValue, class Compare>
void rb_tree<Key, Value, KeyOfValue, Compare>::deallocate_buffers() {
    while (buffer_list) {
        buffer_pointer tmp = buffer_list;
        buffer_list = (buffer_pointer)(buffer_list->next_buffer);
        rb_tree_node_allocator.deallocate(tmp->buffer);
        buffer_allocator.deallocate(tmp);
    }
}

template <class Key, class Value, class KeyOfValue, class Compare>
inline bool operator==(const rb_tree<Key, Value, KeyOfValue, Compare>& x, 
                       const rb_tree<Key, Value, KeyOfValue, Compare>& y) {
    return x.size() == y.size() && equal(x.begin(), x.end(), y.begin());
}

template <class Key, class Value, class KeyOfValue, class Compare>
inline bool operator<(const rb_tree<Key, Value, KeyOfValue, Compare>& x, 
                      const rb_tree<Key, Value, KeyOfValue, Compare>& y) {
    return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
}

template <class Key, class Value, class KeyOfValue, class Compare>
rb_tree<Key, Value, KeyOfValue, Compare>& 
rb_tree<Key, Value, KeyOfValue, Compare>::
operator=(const rb_tree<Key, Value, KeyOfValue, Compare>& x) {
	CTAutoLock _lock(&treeCritSec);
    if (this != &x) {
        // can't be done as in list because Key may be a constant type
        erase(begin(), end());
        root() = __copy(x.root(), header);
        if (root() == NIL) {
            leftmost() = header;
            rightmost() = header;
        } else {
	    leftmost() = minimum(root());
            rightmost() = maximum(root());
        }
        node_count = x.node_count;
    }
    return *this;
}

template <class Key, class Value, class KeyOfValue, class Compare>
rb_tree<Key, Value, KeyOfValue, Compare>::iterator
rb_tree<Key, Value, KeyOfValue, Compare>::
__insert(link_type x, link_type y, const Value& v) {
    ++node_count;
    link_type z = get_node();
    construct(value_allocator.address(value(z)), v);
    if (y == header || x != NIL || key_compare(KeyOfValue()(v), key(y))) {
        left(y) = z;  // also makes leftmost() = z when y == header
        if (y == header) {
            root() = z;
            rightmost() = z;
        } else if (y == leftmost())
            leftmost() = z;   // maintain leftmost() pointing to minimum node
    } else {
        right(y) = z;
        if (y == rightmost())
            rightmost() = z;   // maintain rightmost() pointing to maximum node
    }
    parent(z) = y;
    left(z) = NIL;
    right(z) = NIL;
    x = z;  // recolor and rebalance the tree
    color(x) = red;
    while (x != root() && color(parent(x)) == red) 
        if (parent(x) == left(parent(parent(x)))) {
            y = right(parent(parent(x)));
            if (color(y) == red) {
                color(parent(x)) = black;
                color(y) = black;
                color(parent(parent(x))) = red;
                x = parent(parent(x));
            } else {
                if (x == right(parent(x))) {
                    x = parent(x);
                    rotate_left(x);
                }
                color(parent(x)) = black;
                color(parent(parent(x))) = red;
                rotate_right(parent(parent(x)));
            }
        } else {
            y = left(parent(parent(x)));
            if (color(y) == red) {
                color(parent(x)) = black;
                color(y) = black;
                color(parent(parent(x))) = red;
                x = parent(parent(x));
            } else {
                if (x == left(parent(x))) {
                    x = parent(x);
                    rotate_right(x);
                }
                color(parent(x)) = black;
                color(parent(parent(x))) = red;
                rotate_left(parent(parent(x)));
            }
        }
    color(root()) = black;
    return iterator(z);
}

template <class Key, class Value, class KeyOfValue, class Compare>
rb_tree<Key, Value, KeyOfValue, Compare>::pair_iterator_bool
rb_tree<Key, Value, KeyOfValue, Compare>::insert(const Value& v) {
	CTAutoLock _lock(&treeCritSec);
    link_type y = header;
    link_type x = root();
    bool comp = true;
    while (x != NIL) {
        y = x;
        comp = key_compare(KeyOfValue()(v), key(x));
        x = comp ? left(x) : right(x);
    }
    if (insert_always)
        return pair_iterator_bool(__insert(x, y, v), true);
    iterator j = iterator(y);   
    if (comp)
        if (j == begin())     
            return pair_iterator_bool(__insert(x, y, v), true);
        else
            --j;
    if (key_compare(key(j.node), KeyOfValue()(v)))
        return pair_iterator_bool(__insert(x, y, v), true);
    return pair_iterator_bool(j, false);
}

template <class Key, class Value, class KeyOfValue, class Compare>
rb_tree<Key, Value, KeyOfValue, Compare>::iterator 
rb_tree<Key, Value, KeyOfValue, Compare>::insert(iterator position,
                                                 const Value& v) {
	CTAutoLock _lock(&treeCritSec);
    if (position == iterator(begin()))
        if (size() > 0 && key_compare(KeyOfValue()(v), key(position.node)))
            return __insert(position.node, position.node, v);
            // first argument just needs to be non-NIL 
        else
            return insert(v).first;
    else if (position == iterator(end()))
        if (key_compare(key(rightmost()), KeyOfValue()(v)))
            return __insert(NIL, rightmost(), v);
        else
            return insert(v).first;
    else {
        iterator before = --position;
        if (key_compare(key(before.node), KeyOfValue()(v))
            && key_compare(KeyOfValue()(v), key(position.node)))
            if (right(before.node) == NIL)
                return __insert(NIL, before.node, v); 
            else
                return __insert(position.node, position.node, v);
                // first argument just needs to be non-NIL 
        else
            return insert(v).first;
    }
}

template <class Key, class Value, class KeyOfValue, class Compare>
void rb_tree<Key, Value, KeyOfValue, Compare>::insert(iterator first, 
                                                      iterator last) {
	CTAutoLock _lock(&treeCritSec);
    while (first != last) insert(*first++);
}

template <class Key, class Value, class KeyOfValue, class Compare>
void rb_tree<Key, Value, KeyOfValue, Compare>::insert(const Value* first, 
                                                      const Value* last) {
	CTAutoLock _lock(&treeCritSec);
    while (first != last) insert(*first++);
}
         
template <class Key, class Value, class KeyOfValue, class Compare>
void rb_tree<Key, Value, KeyOfValue, Compare>::erase(iterator position) {
	CTAutoLock _lock(&treeCritSec);
    link_type z = position.node;
    link_type y = z;
    link_type x;
    if (left(y) == NIL)
        x = right(y);
    else
        if (right(y) == NIL) 
            x = left(y);
        else {
            y = right(y);
            while (left(y) != NIL)
                y = left(y);
            x = right(y);
        }
    if (y != z) { // relink y in place of z
        parent(left(z)) = y; 
        left(y) = left(z);
        if (y != right(z)) {
            parent(x) = parent(y); // possibly x == NIL
            left(parent(y)) = x;   // y must be a left child
            right(y) = right(z);
            parent(right(z)) = y;
        } else
            parent(x) = y;  // needed in case x == NIL
        if (root() == z)
            root() = y;
        else if (left(parent(z)) == z)
            left(parent(z)) = y;
        else 
            right(parent(z)) = y;
        parent(y) = parent(z);
        ::swap(color(y), color(z));
        y = z;
                       // y points to node to be actually deleted
    } else {  // y == z
        parent(x) = parent(y);   // possibly x == NIL
        if (root() == z)
            root() = x;
        else 
            if (left(parent(z)) == z)
                left(parent(z)) = x;
            else
                right(parent(z)) = x;
        if (leftmost() == z) 
            if (right(z) == NIL)  // left(z) must be NIL also
                leftmost() = parent(z);
                // makes leftmost() == header if z == root()
        else
            leftmost() = minimum(x);
        if (rightmost() == z)  
            if (left(z) == NIL) // right(z) must be NIL also
                rightmost() = parent(z);  
                // makes rightmost() == header if z == root()
        else  // x == left(z)
            rightmost() = maximum(x);
    }
    if (color(y) != red) { 
        while (x != root() && color(x) == black)
            if (x == left(parent(x))) {
                link_type w = right(parent(x));
                if (color(w) == red) {
                    color(w) = black;
                    color(parent(x)) = red;
                    rotate_left(parent(x));
                    w = right(parent(x));
                }
                if (color(left(w)) == black && color(right(w)) == black) {
                    color(w) = red;
                    x = parent(x);
                } else {
                    if (color(right(w)) == black) {
                        color(left(w)) = black;
                        color(w) = red;
                        rotate_right(w);
                        w = right(parent(x));
                    }
                    color(w) = color(parent(x));
                    color(parent(x)) = black;
                    color(right(w)) = black;
                    rotate_left(parent(x));
                    break;
                }
            } else {  // same as then clause with "right" and "left" exchanged
                link_type w = left(parent(x));
                if (color(w) == red) {
                    color(w) = black;
                    color(parent(x)) = red;
                    rotate_right(parent(x));
                    w = left(parent(x));
                }
                if (color(right(w)) == black && color(left(w)) == black) {
                    color(w) = red;
                    x = parent(x);
                } else {
                    if (color(left(w)) == black) {
                        color(right(w)) = black;
                        color(w) = red;
                        rotate_left(w);
                        w = left(parent(x));
                    }
                    color(w) = color(parent(x));
                    color(parent(x)) = black;
                    color(left(w)) = black;
                    rotate_right(parent(x));
                    break;
                }
            }
        color(x) = black;
    }
    destroy(value_allocator.address(value(y)));
    put_node(y);
    --node_count;
}

template <class Key, class Value, class KeyOfValue, class Compare>
rb_tree<Key, Value, KeyOfValue, Compare>::size_type 
rb_tree<Key, Value, KeyOfValue, Compare>::erase(const Key& x) {
	CTAutoLock _lock(&treeCritSec);
    pair_iterator_iterator p = equal_range(x);
    size_type n = 0;
    distance(p.first, p.second, n);
    erase(p.first, p.second);
    return n;
}

template <class Key, class Value, class KeyOfValue, class Compare>
rb_tree<Key, Value, KeyOfValue, Compare>::link_type 
rb_tree<Key, Value, KeyOfValue, Compare>::__copy(link_type x, link_type p) {
   // structural copy
   link_type r = x;
   while (x != NIL) {
      link_type y = get_node();
      if (r == x) r = y;  // save for return value
      construct(value_allocator.address(value(y)), value(x));
      left(p) = y;
      parent(y) = p;
      color(y) = color(x);
      right(y) = __copy(right(x), y);
      p = y;
      x = left(x);
   }
   left(p) = NIL;
   return r;
}

template <class Key, class Value, class KeyOfValue, class Compare>
void rb_tree<Key, Value, KeyOfValue, Compare>::__erase(link_type x) {
    // erase without rebalancing
    while (x != NIL) {
       __erase(right(x));
       link_type y = left(x);
       destroy(value_allocator.address(value(x)));
       put_node(x);
       x = y;
    }
}

template <class Key, class Value, class KeyOfValue, class Compare>
void rb_tree<Key, Value, KeyOfValue, Compare>::erase(iterator first, 
                                                     iterator last) {
	CTAutoLock _lock(&treeCritSec);
    if (first == begin() && last == end() && node_count != 0) {
        __erase(root());
        leftmost() = header;
        root() = NIL;
        rightmost() = header;
        node_count = 0;
    } else
        while (first != last) erase(first++);
}

template <class Key, class Value, class KeyOfValue, class Compare>
void rb_tree<Key, Value, KeyOfValue, Compare>::erase(const Key* first, 
                                                     const Key* last) {
	CTAutoLock _lock(&treeCritSec);
    while (first != last) erase(*first++);
}

template <class Key, class Value, class KeyOfValue, class Compare>
rb_tree<Key, Value, KeyOfValue, Compare>::iterator 
rb_tree<Key, Value, KeyOfValue, Compare>::find(const Key& k) {
	CTAutoLock _lock(&treeCritSec);
   link_type y = header; /* Last node which is not less than k. */
   link_type x = root(); /* Current node. */

   while (x != NIL) 
     if (!key_compare(key(x), k))
       y = x, x = left(x);
   else
       x = right(x);

   iterator j = iterator(y);   
   return (j == end() || key_compare(k, key(j.node))) ? end() : j;
}

template <class Key, class Value, class KeyOfValue, class Compare>
rb_tree<Key, Value, KeyOfValue, Compare>::const_iterator 
rb_tree<Key, Value, KeyOfValue, Compare>::find(const Key& k) const {
	CTAutoLock _lock(&treeCritSec);
   link_type y = header; /* Last node which is not less than k. */
   link_type x = root(); /* Current node. */

   while (x != NIL) {
     if (!key_compare(key(x), k))
       y = x, x = left(x);
   else
       x = right(x);
   }
   const_iterator j = const_iterator(y);   
   return (j == end() || key_compare(k, key(j.node))) ? end() : j;
}

template <class Key, class Value, class KeyOfValue, class Compare>
rb_tree<Key, Value, KeyOfValue, Compare>::size_type 
rb_tree<Key, Value, KeyOfValue, Compare>::count(const Key& k) const {
	CTAutoLock _lock(&treeCritSec);
    pair<const_iterator, const_iterator> p = equal_range(k);
    size_type n = 0;
    distance(p.first, p.second, n);
    return n;
}

template <class Key, class Value, class KeyOfValue, class Compare>
rb_tree<Key, Value, KeyOfValue, Compare>::iterator 
rb_tree<Key, Value, KeyOfValue, Compare>::lower_bound(const Key& k) {
	CTAutoLock _lock(&treeCritSec);
   link_type y = header; /* Last node which is not less than k. */
   link_type x = root(); /* Current node. */

   while (x != NIL) 
     if (!key_compare(key(x), k))
       y = x, x = left(x);
     else
       x = right(x);

   return iterator(y);
}

template <class Key, class Value, class KeyOfValue, class Compare>
rb_tree<Key, Value, KeyOfValue, Compare>::const_iterator 
rb_tree<Key, Value, KeyOfValue, Compare>::lower_bound(const Key& k) const {
   link_type y = header; /* Last node which is not less than k. */
   link_type x = root(); /* Current node. */

   while (x != NIL) 
     if (!key_compare(key(x), k))
       y = x, x = left(x);
     else
       x = right(x);

   return const_iterator(y);
}

template <class Key, class Value, class KeyOfValue, class Compare>
rb_tree<Key, Value, KeyOfValue, Compare>::iterator 
rb_tree<Key, Value, KeyOfValue, Compare>::upper_bound(const Key& k) {
	CTAutoLock _lock(&treeCritSec);
  link_type y = header; /* Last node which is greater than k. */
  link_type x = root(); /* Current node. */

   while (x != NIL) 
     if (key_compare(k, key(x)))
       y = x, x = left(x);
     else
       x = right(x);

   return iterator(y);
}

template <class Key, class Value, class KeyOfValue, class Compare>
rb_tree<Key, Value, KeyOfValue, Compare>::const_iterator 
rb_tree<Key, Value, KeyOfValue, Compare>::upper_bound(const Key& k) const {
  link_type y = header; /* Last node which is greater than k. */
  link_type x = root(); /* Current node. */

   while (x != NIL) 
     if (key_compare(k, key(x)))
       y = x, x = left(x);
     else
       x = right(x);

   return const_iterator(y);
}

template <class Key, class Value, class KeyOfValue, class Compare>
rb_tree<Key, Value, KeyOfValue, Compare>::pair_iterator_iterator 
rb_tree<Key, Value, KeyOfValue, Compare>::equal_range(const Key& k) {
    return pair_iterator_iterator(lower_bound(k), upper_bound(k));
}

template <class Key, class Value, class KeyOfValue, class Compare>
rb_tree<Key, Value, KeyOfValue, Compare>::pair_citerator_citerator 
rb_tree<Key, Value, KeyOfValue, Compare>::equal_range(const Key& k) const {
    return pair_citerator_citerator(lower_bound(k), upper_bound(k));
}

template <class Key, class Value, class KeyOfValue, class Compare>
inline void 
rb_tree<Key, Value, KeyOfValue, Compare>::rotate_left(link_type x) {
	CTAutoLock _lock(&treeCritSec);
    link_type y = right(x);
    right(x) = left(y);
    if (left(y) != NIL)
        parent(left(y)) = x;
    parent(y) = parent(x);
    if (x == root())
        root() = y;
    else if (x == left(parent(x)))
        left(parent(x)) = y;
    else
        right(parent(x)) = y;
    left(y) = x;
    parent(x) = y;
}

template <class Key, class Value, class KeyOfValue, class Compare>
inline void 
rb_tree<Key, Value, KeyOfValue, Compare>::rotate_right(link_type x) {
	CTAutoLock _lock(&treeCritSec);
    link_type y = left(x);
    left(x) = right(y);
    if (right(y) != NIL)
        parent(right(y)) = x;
    parent(y) = parent(x);
    if (x == root())
        root() = y;
    else if (x == right(parent(x)))
        right(parent(x)) = y;
    else
        left(parent(x)) = y;
    right(y) = x;
    parent(x) = y;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\intldbg\interop.cpp ===
#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))

#include "interop.h"
#include <stdio.h>
#include "cpls.h"

static int g_nRefCount = 0;

LPInteropLogger INTEROP_EXPORT InteropLoad(CPLProtocol Protocol)
{
	OutputDebugString("Loading CPLS\n");
	LPInteropLogger Logger = (LPInteropLogger) GlobalAlloc (GMEM_FIXED | GMEM_ZEROINIT, sizeof(InteropLogger));
	if (!(Logger))
		return NULL;
    UINT oldMode = SetErrorMode(SEM_NOOPENFILEERRORBOX);    
    
	(Logger)->hInst = LoadLibrary(DLLName);
    
    SetErrorMode(oldMode);
    
    if ((LONG_PTR)(Logger)->hInst > HINSTANCE_ERROR) 
    {
	  g_nRefCount++;

	#ifdef _DEBUG
	  char buf[80];
	  wsprintf (buf, "Loading Generic Protocol Logger: %s\n",DLLName);
      OutputDebugString(buf);
	#endif

      (Logger)->CPLInitialize = (CPLInitialize_t)GetProcAddress((Logger)->hInst, "CPLInitialize");
      (Logger)->CPLUninitialize = (CPLUninitialize_t)GetProcAddress((Logger)->hInst, "CPLUninitialize");
      (Logger)->CPLOpen = (CPLOpen_t)GetProcAddress((Logger)->hInst, "CPLOpen");
      (Logger)->CPLClose = (CPLClose_t)GetProcAddress((Logger)->hInst, "CPLClose");
      (Logger)->CPLOutput = (CPLOutput_t)GetProcAddress((Logger)->hInst, "CPLOutput");
	  Logger->g_ProtocolLogID = Logger->CPLInitialize(Protocol);
	  Logger->g_ComplianceProtocolLogger = Logger->CPLOpen(Logger->g_ProtocolLogID,
													NULL, 
													CPLS_CREATE | CPLS_APPEND);
	} 
    else 
    {
		GlobalFree((Logger));
		(Logger) = NULL;
	#ifdef _DEBUG
		char buf[80];
		wsprintf (buf, "Loading Generic Protocol Logger %s Failed\n",DLLName);
		OutputDebugString(buf);
	#endif
    }
    
    return Logger;
}

void INTEROP_EXPORT InteropUnload(LPInteropLogger Logger)
{
	#ifdef _DEBUG
	char buf[80];
	wsprintf (buf, "Unloading Generic Protocol Logger: %s\n",DLLName);
	OutputDebugString(buf);
	#endif

	if ((Logger))
	{
		if ((LONG_PTR)(Logger)->hInst > HINSTANCE_ERROR)
		{
			Logger->CPLClose(Logger->g_ComplianceProtocolLogger);
			Logger->CPLUninitialize(Logger->g_ProtocolLogID);
			if (--g_nRefCount <= 0)
				FreeLibrary((Logger)->hInst);
		}
		GlobalFree((Logger));
		(Logger) = NULL;
	}

}

void INTEROP_EXPORT InteropOutput(LPInteropLogger Logger, BYTE* buf, 
							int length, unsigned long userData)
{
	if (!Logger)
		return;
	Logger->CPLOutput(Logger->g_ComplianceProtocolLogger, buf, length,userData);

}

#endif // #if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\intldbg\cpls.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************/

#ifndef __CPLS_H
#define __CPLS_H

#include <limits.h>

#ifdef WIN32
	#include <windows.h>
	#include <windowsx.h> 
	#include "port32.h"
#endif

#ifdef _WINDOWS
	#ifndef _MSWINDOWS_
		#define _MSWINDOWS_
	#endif
#endif

typedef int HLOG;                          

#ifndef FALSE
	#define FALSE   0
#endif

#ifndef TRUE
	#define TRUE    1
#endif
#ifdef WIN32
	#ifdef BUILDING_CPLS_DLL
		#define CPLS_FAREXPORT __declspec(dllexport)
		#define CPLS_EXPORT __declspec(dllexport)
	#else
		#define CPLS_FAREXPORT __declspec(dllimport)
		#define CPLS_EXPORT __declspec(dllimport)
	#endif
	#ifndef EXPORT
		#define EXPORT
	#endif	// EXPORT
#elif _MSWINDOWS_
	#ifndef CALLBACK
		#define CALLBACK _far _pascal
	#endif
	#ifdef BUILDING_CPLS_DLL
		#define CPLS_FAREXPORT _far _export _pascal
		#define CPLS_EXPORT _export
	#else
		#define CPLS_FAREXPORT _far _pascal
		#define CPLS_EXPORT
	#endif
	#ifndef EXPORT
		#define EXPORT _export
	#endif	// EXPORT
	#ifndef FAR
		#define FAR _far
	#endif
#else    
	#ifndef CALLBACK
		#define CALLBACK      
	#endif
	#define CPLS_FAREXPORT
	#ifndef EXPORT
		#define EXPORT  
	#endif
	#ifndef FAR
		#define FAR
	#endif
#endif  // _MSWINDOWS_  


typedef int BOOL;
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef const char FAR* CPLProtocol;
typedef int CPLProtocolID;

#define CONFIG_FILENAME "CPLS.INI"    // internal use only

// Pre-defined event and event category constants.
//
#define String_Event USHRT_MAX
#define Binary_Event USHRT_MAX-1

#define String_Category USHRT_MAX
#define Binary_Category USHRT_MAX-1

#ifdef __cplusplus      
	class CProtocolLog;
	class CProtocolEvent;
	typedef CProtocolEvent FAR* (CALLBACK *CPLEventGenesisProc)( 
															BYTE FAR* pObject,              // in
															CProtocolLog FAR* pSourceLog,   // in
															BOOL bCopyObject );             // in
extern "C"{

// This first one is only for C++ clients...
void CPLS_FAREXPORT CPLRegisterEventGenesisProc( CPLProtocolID ProtocolID, CPLEventGenesisProc pfnGenesisProc );

#endif  // __cplusplus

// Possible file mode values for CPLOpen().
//
#define CPLS_CREATE 0		// Will overwrite an existing file.
#define CPLS_APPEND 1		// Will append to an existing file, or create a new one.

/////////////////////////////////////////////////////////////////////////////
// 					PROTOCOL LOGGING FUNCTIONS
//
// Here is the sequence of functions to call for use of a protocol logger:
//		1) CPLInitialize() or CPLINTInitialize()
//		2) CPLOpen()
//		3) CPLOutput*() or CPLINTOutput*() -- repeat as necessary
//		4) CPLClose()
//		5) CPLUninitialize()
//
// CPLInitialize() - Creates a protocol logger.
// CPLINTInitialize() - The version of CPLInitialize() which must be called
//		by clients which will be calling the CPLINTOuptut*() functions within
//		interrupt context.  CPLINTInitialize may not be called within
//		interrupt context.
// CPLUninitialize() - Releases a protocol logger.  This must be called for
//		every initialized logger before shutdown in order to free associated
//		memory.
// CPLOpen() - Associates a protocol logger with a file (output stream).
// CPLClose() - Releases a logger's usage of a stream.  This function does
//		not block.  A "close" event is placed on the event queue of the
//		stream.  Release of the stream occurs when this "close" event is
//		serviced.
// CPLOutputDebug() - 
// CPLINTOutputDebug() - The version of CPLOutputDebug() safely callable
//		within interrupt context.
// CPLOutputAscii() - 
// CPLINTOutputAscii() - The version of CPLOutputAscii() safely callable
//		within interrupt context.
// CPLOutput() - 
// CPLINTOutput() - The version of CPLOutput() safely callable
//		within interrupt context.
// CPLFlush() - Flushes all events to the stream of the specified logger.
//		Blocks until the flush is complete.
// CPLINTFlush() -  The version of CPLFlush() safely callable within
//		interrupt context.  This version does not block.  A "flush" message
//		is sent to CPLS.  The flush occurs when this flush message is
//		serviced.
// CPLFlushAndClose() -
// CPLEnable() - Enables or disables protocol logging at runtime.
// CPLEnableAsync() - Sets synchronous or asynchronous logging output mode.
//		CURRENTLY NOT SUPPORTED.
// CPLLogAscii() - 
// CPLINTLogAscii() - The version of CPLLogAscii() safely callable
//		within interrupt context.
//
// Only these functions may be called from within interrupt context:
//		CPLINTOutputDebug()
//		CPLINTOutputAscii()
//		CPLINTOutput()
//		CPLINTFlush()
//		CPLEnable()
//		CPLINTLogAscii()
/////////////////////////////////////////////////////////////////////////////
CPLProtocolID CPLS_FAREXPORT CPLInitialize( CPLProtocol Protocol );
CPLProtocolID CPLS_FAREXPORT CPLINTInitialize( CPLProtocol Protocol );

int  CPLS_FAREXPORT CPLUninitialize( HLOG hlog );

HLOG CPLS_FAREXPORT CPLOpen( CPLProtocolID ProtocolID, 
							const char FAR* szName, 
							int FileMode );
HLOG CPLS_FAREXPORT CPLINTOpen( CPLProtocolID ProtocolID, 
							const char FAR* szName, 
							int FileMode );
int  CPLS_FAREXPORT CPLClose( HLOG hLog );

int  CPLS_FAREXPORT CPLOutputDebug( HLOG hLog, 
							const char FAR* szString );
int  CPLS_FAREXPORT CPLINTOutputDebug( HLOG hLog, 
							const char FAR* szString );

int  CPLS_FAREXPORT CPLOutputAscii( HLOG hLog, 
							WORD EventID, 
							const char FAR* szEvent, 
							BYTE FAR* pData, 
							int nDataBytes, 
							WORD EventCategory, 
							unsigned long UserData );
int  CPLS_FAREXPORT CPLINTOutputAscii( HLOG hLog, 
							WORD EventID, 
							const char FAR* szEvent, 
							BYTE FAR* pData, 
							int nDataBytes, 
							WORD EventCategory, 
							unsigned long UserData );

int  CPLS_FAREXPORT CPLOutput( HLOG hLog, 
							BYTE FAR* pData, 
							int nDataBytes,
							unsigned long UserData );
int  CPLS_FAREXPORT CPLINTOutput( HLOG hLog, 
							BYTE FAR* pData, 
							int nDataBytes,
							unsigned long UserData );

int  CPLS_FAREXPORT CPLFlush( HLOG hLog );
int  CPLS_FAREXPORT CPLINTFlush( HLOG hLog );
int  CPLS_FAREXPORT CPLFlushAndClose( HLOG hLog );

void CPLS_FAREXPORT CPLEnable( BOOL bEnable );
//void CPLS_FAREXPORT CPLEnableAsync( BOOL bEnable );

#ifdef __cplusplus
};      // extern "C"
#endif  // __cplusplus

#define CPLLogAscii( hLog, \
				EventID, \
				pData, \
				nDataBytes, \
				EventCategory, \
				UserData ) \
		CPLOutputAscii( hLog, EventID, #EventID, pData, nDataBytes, EventCategory, UserData )

#define CPLINTLogAscii( hLog, \
				EventID, \
				pData, \
				nDataBytes, \
				EventCategory, \
				UserData ) \
		CPLINTOutputAscii( hLog, EventID, #EventID, pData, nDataBytes, EventCategory, UserData )
		
#endif  // __CPLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\intldbg\interop.h ===
#ifndef __INTEROP_H
#define __INTEROP_H

#include <windows.h>

#define INTEROP_EXPORT  __declspec(dllexport)

#define DLLName "CPLS.DLL"


typedef int    (WINAPI *CPLInitialize_t)(const char*);
typedef int    (WINAPI *CPLUninitialize_t)(int) ;
typedef int    (WINAPI *CPLOpen_t)(int, 
							const char*, 
							int);
typedef int    (WINAPI *CPLClose_t)( int );
typedef int    (WINAPI *CPLOutput_t)(int, 
							BYTE*, 
							int,
							unsigned long);



typedef struct {
    CPLInitialize_t       CPLInitialize;
	CPLUninitialize_t     CPLUninitialize;
    CPLOpen_t			  CPLOpen;
    CPLClose_t			  CPLClose;
    CPLOutput_t			  CPLOutput;
	int					  g_ComplianceProtocolLogger;
	int					  g_ProtocolLogID;
	HINSTANCE hInst;
} *LPInteropLogger, InteropLogger;

#ifdef __cplusplus
extern "C" {
#endif

LPInteropLogger INTEROP_EXPORT InteropLoad(const char*  Protocol);
void INTEROP_EXPORT InteropUnload(LPInteropLogger Logger);
void INTEROP_EXPORT InteropOutput(LPInteropLogger Logger, BYTE* buf, int length, unsigned long userData);

#ifdef __cplusplus
}
#endif


#endif  // __CPLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\inc\stl\vector.h ===
/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef VECTOR_H
#define VECTOR_H

#include <function.h>
#include <algobase.h>
#include <bool.h>

#ifndef Allocator
#define Allocator allocator
#include <defalloc.h>
#endif

#ifndef vector
#define vector vector
#endif

template <class T>
class vector {
public:
    
    typedef Allocator<T> vector_allocator;
    typedef T value_type;
    typedef vector_allocator::pointer pointer;
    typedef vector_allocator::pointer iterator;
    typedef vector_allocator::const_pointer const_iterator;
    typedef vector_allocator::reference reference;
    typedef vector_allocator::const_reference const_reference;
    typedef vector_allocator::size_type size_type;
    typedef vector_allocator::difference_type difference_type;
    typedef reverse_iterator<const_iterator, value_type, const_reference, 
                             difference_type>  const_reverse_iterator;
    typedef reverse_iterator<iterator, value_type, reference, difference_type>
        reverse_iterator;
protected:
    static Allocator<T> static_allocator;
    iterator start;
    iterator finish;
    iterator end_of_storage;
    void insert_aux(iterator position, const T& x);
public:
    iterator begin() { return start; }
    const_iterator begin() const { return start; }
    iterator end() { return finish; }
    const_iterator end() const { return finish; }
    reverse_iterator rbegin() { return reverse_iterator(end()); }
    const_reverse_iterator rbegin() const { 
        return const_reverse_iterator(end()); 
    }
    reverse_iterator rend() { return reverse_iterator(begin()); }
    const_reverse_iterator rend() const { 
        return const_reverse_iterator(begin()); 
    }
    size_type size() const { return size_type(end() - begin()); }
    size_type max_size() const { return static_allocator.max_size(); }
    size_type capacity() const { return size_type(end_of_storage - begin()); }
    bool empty() const { return begin() == end(); }
    reference operator[](size_type n) { return *(begin() + n); }
    const_reference operator[](size_type n) const { return *(begin() + n); }
    vector() : start(0), finish(0), end_of_storage(0) {}
    vector(size_type n, const T& value = T()) {
	start = static_allocator.allocate(n);
	uninitialized_fill_n(start, n, value);
	finish = start + n;
	end_of_storage = finish;
    }
    vector(const vector<T>& x) {
	start = static_allocator.allocate(x.end() - x.begin());
	finish = uninitialized_copy(x.begin(), x.end(), start);
	end_of_storage = finish;
    }
    vector(const_iterator first, const_iterator last) {
	size_type n = 0;
	distance(first, last, n);
	start = static_allocator.allocate(n);
	finish = uninitialized_copy(first, last, start);
	end_of_storage = finish;
    }
    ~vector() { 
	destroy(start, finish);
	static_allocator.deallocate(start);
    }
    vector<T>& operator=(const vector<T>& x);
    void reserve(size_type n) {
	if (capacity() < n) {
	    iterator tmp = static_allocator.allocate(n);
	    uninitialized_copy(begin(), end(), tmp);
	    destroy(start, finish);
	    static_allocator.deallocate(start);
	    finish = tmp + size();
	    start = tmp;
	    end_of_storage = begin() + n;
	}
    }
    reference front() { return *begin(); }
    const_reference front() const { return *begin(); }
    reference back() { return *(end() - 1); }
    const_reference back() const { return *(end() - 1); }
    void push_back(const T& x) {
	if (finish != end_of_storage) {
	    /* Borland bug */
	    construct(finish, x);
	    finish++;
	} else
	    insert_aux(end(), x);
    }
    void swap(vector<T>& x) {
	::swap(start, x.start);
	::swap(finish, x.finish);
	::swap(end_of_storage, x.end_of_storage);
    }
    iterator insert(iterator position, const T& x) {
	size_type n = position - begin();
	if (finish != end_of_storage && position == end()) {
	    /* Borland bug */
	    construct(finish, x);
	    finish++;
	} else
	    insert_aux(position, x);
	return begin() + n;
    }
    void insert (iterator position, const_iterator first, 
		 const_iterator last);
    void insert (iterator position, size_type n, const T& x);
    void pop_back() {
	/* Borland bug */
        --finish;
        destroy(finish);
    }
    void erase(iterator position) {
	if (position + 1 != end())
	    copy(position + 1, end(), position);
	/* Borland bug */
	--finish;
	destroy(finish);
    }
    void erase(iterator first, iterator last) {
	vector<T>::iterator i = copy(last, end(), first);
	destroy(i, finish);
	// work around for destroy(copy(last, end(), first), finish);
	finish = finish - (last - first); 
    }
};

template <class T>
inline bool operator==(const vector<T>& x, const vector<T>& y) {
    return x.size() == y.size() && equal(x.begin(), x.end(), y.begin());
}

template <class T>
inline bool operator<(const vector<T>& x, const vector<T>& y) {
    return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
}


template <class T>
vector<T>::vector_allocator vector<T>::static_allocator;


template <class T>
vector<T>& vector<T>::operator=(const vector<T>& x) {
    if (&x == this) return *this;
    if (x.size() > capacity()) {
	destroy(start, finish);
	static_allocator.deallocate(start);
	start = static_allocator.allocate(x.end() - x.begin());
	end_of_storage = uninitialized_copy(x.begin(), x.end(), start);
    } else if (size() >= x.size()) {
	vector<T>::iterator i = copy(x.begin(), x.end(), begin());
	destroy(i, finish);
	// work around for destroy(copy(x.begin(), x.end(), begin()), finish);
    } else {
	copy(x.begin(), x.begin() + size(), begin());
	uninitialized_copy(x.begin() + size(), x.end(), begin() + size());
    }
    finish = begin() + x.size();
    return *this;
}

template <class T>
void vector<T>::insert_aux(iterator position, const T& x) {
    if (finish != end_of_storage) {
	construct(finish, *(finish - 1));
	copy_backward(position, finish - 1, finish);
	*position = x;
	++finish;
    } else {
	size_type len = size() ? 2 * size() 
	    : static_allocator.init_page_size();
	iterator tmp = static_allocator.allocate(len);
	uninitialized_copy(begin(), position, tmp);
	construct(tmp + (position - begin()), x);
	uninitialized_copy(position, end(), tmp + (position - begin()) + 1); 
	destroy(begin(), end());
	static_allocator.deallocate(begin());
	end_of_storage = tmp + len;
	finish = tmp + size() + 1;
	start = tmp;
    }
}

template <class T>
void vector<T>::insert(iterator position, size_type n, const T& x) {
    if (n == 0) return;
    if (end_of_storage - finish >= n) {
	if (end() - position > n) {
	    uninitialized_copy(end() - n, end(), end());
	    copy_backward(position, end() - n, end());
	    fill(position, position + n, x);
	} else {
	    uninitialized_copy(position, end(), position + n);
	    fill(position, end(), x);
	    uninitialized_fill_n(end(), n - (end() - position), x);
	}
	finish += n;
    } else {
	size_type len = size() + stlmax(size(), n);
	iterator tmp = static_allocator.allocate(len);
	uninitialized_copy(begin(), position, tmp);
	uninitialized_fill_n(tmp + (position - begin()), n, x);
	uninitialized_copy(position, end(), tmp + (position - begin() + n));
	destroy(begin(), end());
	static_allocator.deallocate(begin());
	end_of_storage = tmp + len;
	finish = tmp + size() + n;
	start = tmp;
    }
}

template <class T>
void vector<T>::insert(iterator position, 
		       const_iterator first, 
		       const_iterator last) {
    if (first == last) return;
    size_type n = 0;
    distance(first, last, n);
    if (end_of_storage - finish >= n) {
	if (end() - position > n) {
	    uninitialized_copy(end() - n, end(), end());
	    copy_backward(position, end() - n, end());
	    copy(first, last, position);
	} else {
	    uninitialized_copy(position, end(), position + n);
	    copy(first, first + (end() - position), position);
	    uninitialized_copy(first + (end() - position), last, end());
	}
	finish += n;
    } else {
	size_type len = size() + stlmax(size(), n);
	iterator tmp = static_allocator.allocate(len);
	uninitialized_copy(begin(), position, tmp);
	uninitialized_copy(first, last, tmp + (position - begin()));
	uninitialized_copy(position, end(), tmp + (position - begin() + n));
	destroy(begin(), end());
	static_allocator.deallocate(begin());
	end_of_storage = tmp + len;
	finish = tmp + size() + n;
	start = tmp;
    }
}

#undef Allocator
#undef vector

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\mixer\mxfilter.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       mxfilter.h
//
//--------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////////////
//
//         File: mxfilter.h
//
//  Description: Defines the mixer filter & pin classes
//
///////////////////////////////////////////////////////////////////////////////

#include <mixflter.h>  // for the CLSID

// If more than X packets are delivered with the time interval of a packet
// the overflow will be disgarded
const DWORD MAX_QUEUE_STORAGE = 8;

//
// These should not change anyway.
//
enum { OUTPUT_PIN, INPUT_PIN0 };


const TCHAR MIXER_KEY[] = 
    TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\DxmRTP\\MIXER");
const TCHAR JITTERBUFFER[]  = TEXT("JitterBuffer");
const TCHAR MIXBUFFER[]  = TEXT("MixDelay");

const DWORD MAX_QUEUES                  = 32;
const DWORD MAX_TIMEDELTA               = 180; // 180ms 

const DWORD DEFAULT_JITTERBUFFERTIME    = 60;  // 60ms of jitter buffer.
const DWORD DEFAULT_MIXDELAYTIME        = 40;  // 40ms of mix delay.

class CMixer;
class CMixerInputPin;
class CMixerOutputPin;

#ifndef CBufferQueue_DEFINED
#include "queue.h"
#endif // #ifndef CBufferQueue_DEFINED


///////////////////////////////////////////////////////////////////////////////
//***************************************************************************//
//***************************************************************************//
///////////////////////////////////////////////////////////////////////////////

class CMixerOutputPin : public CBaseOutputPin
{
    CMixer *m_pMixer;
public:
    CMixerOutputPin(
        TCHAR *pObjName,
        CMixer *pMixer,
        HRESULT *phr,
        LPCWSTR pPinName
        );

    //
    // Connection helpers
    //
    virtual HRESULT DecideBufferSize(IMemAllocator * pAlloc,
                                     ALLOCATOR_PROPERTIES * ppropInputRequest);
    virtual HRESULT CheckMediaType(const CMediaType *pmt);
    virtual HRESULT DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc);
    virtual HRESULT CompleteConnect(IPin *pReceivePin);
    
    IMemInputPin *GetIMemInputPin() { return m_pInputPin; }

    //
    // Media Type related functions
    //
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);
    CMediaType &CurrentMediaType();
};

///////////////////////////////////////////////////////////////////////////////
//***************************************************************************//
//***************************************************************************//
///////////////////////////////////////////////////////////////////////////////

class CMixerInputPin : public CBaseInputPin
{
    CMixer      *m_pMixer;                      // Main filter object
    ULONG        m_cOurRef;                     // Local ref count
    int          m_iPinNumber;                  // Number of this pin

    // queues created for the input pins
    CBufferQueue *m_pQueue;

public:
    //
    // Construction
    //
    CMixerInputPin(
        TCHAR *     pObjName,
        CMixer *    pMixer,
        HRESULT *   phr,
        LPCWSTR     pPinName,
        int         iPin,
        CBufferQueue *pQueue
        );

    //
    // Methods dealing with media type
    //
    HRESULT CheckMediaType(const CMediaType *pmt);
    CMediaType &CurrentMediaType();

    // Connection stuff
    virtual HRESULT CompleteConnect(IPin *pReceivePin);
    virtual HRESULT STDMETHODCALLTYPE Disconnect();

    //
    // Methods dealing with the allocator
    //
    IMemAllocator *GetAllocator() { return m_pAllocator; }
#if 0
    STDMETHODIMP GetAllocator(IMemAllocator **ppAllocator);
    STDMETHODIMP NotifyAllocator(IMemAllocator *pAllocator, BOOL bReadOnly);
#endif
    STDMETHODIMP AllocatorProperties(ALLOCATOR_PROPERTIES * pprop);
    STDMETHODIMP GetAllocatorRequirements(ALLOCATOR_PROPERTIES *pProps);

    // Handles the next block of data from the stream
    STDMETHODIMP Receive(IMediaSample *pSample);

    // Override since the life time of pins and filters are not the same
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();

    // We deal with these because we queue.
    STDMETHODIMP EndOfStream();
    STDMETHODIMP BeginFlush();
    STDMETHODIMP EndFlush();
    HRESULT Inactive();
    HRESULT Active();

};

///////////////////////////////////////////////////////////////////////////////
//***************************************************************************//
//***************************************************************************//
///////////////////////////////////////////////////////////////////////////////

class CMixer : public CCritSec, public CBaseFilter
{
    typedef CGenericList <CMixerInputPin> CInputPinList;

    INT             m_cInputPins;             // Current Input pin count
    CInputPinList   m_listInputPins;          // List of the Input pins
    INT             m_iNextInputPinNumber;    // Increases monotonically.
    CMixerOutputPin *m_pMixerOutput;          // Common Output Pin

    DWORD           m_dwInputBytesPerMS;	
    WORD            m_wInputBitsPerSample;
    WORD            m_wOutputBitsPerSample;
    WORD            m_wInputFormatTag;        // Input format tag
	WORD			m_wPAD;

#if USE_LOCK
    // Critical section for the queues.
    CCritSec        m_cQueues;
#endif
    // queues created for the input pins
    CBufferQueue *  m_queues[MAX_QUEUES];

    // the size of the jitter buffer, in time and in bytes.
    long            m_lJitterBufferTime;
    long            m_lTotalDelayTime;
    long            m_lTotalDelayBufferSize;

    // time reserved for mixing delay
    long            m_lMixDelayTime;
    
    // the size of the sample measued in ms.
    long            m_lSampleTime;

    // the dword value of the system clock of the last sample.
    DWORD           m_dwLastTime;

    // the dword value of the start time of a spurt.
    DWORD           m_dwSpurtStartTime;

    // the dword value of the difference between the wall clock and the
	// the samples played.
    long            m_lTimeDelta;

	
public:
    CMixer(TCHAR *pName,LPUNKNOWN pUnk,HRESULT *hr);
    ~CMixer();

    //
    // Function needed for the class factory
    //
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);

    //
    // External Utilities
    //
    FILTER_STATE GetState() { return m_State; }

    //
    // Exeternal methods for pin management
    //
    CBasePin *GetPin(int n);
    int GetPinCount() { return 1 + m_cInputPins; }
    int GetInputPinCount() { return m_cInputPins; }
    int GetConnectedPinCount() { return m_cInputPins - GetFreePinCount(); }
    int GetFreePinCount();
    BOOL SpawnNewInput();
    void DeleteInputPin(CMixerInputPin *pPin, CBufferQueue *pQueue);
    CMixerInputPin *GetInput0() { return (CMixerInputPin*)GetPin(INPUT_PIN0); }
    CMixerInputPin *GetInput(int n) { return (CMixerInputPin*)GetPin(INPUT_PIN0+n); }
    CMixerOutputPin *GetOutput() { return m_pMixerOutput; }

    //
    // Self Registration
    //
    LPAMOVIESETUP_FILTER GetSetupData();
    
    //
    // Media Type Methods
    //
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT CheckOutputMediaType(const CMediaType* pMediaType);
    CMediaType &CurrentMediaType();
    BOOL MediaTypeKnown();
    HRESULT CopyMTParams(const CMediaType *pmt);

    //
    // Allocator methods
    //
    HRESULT GetAgregateAllocatorProperties(ALLOCATOR_PROPERTIES * pprop);
    HRESULT CompleteConnect();
    HRESULT DecideBufferSize(IMemAllocator * pAlloc, ALLOCATOR_PROPERTIES * pprop);
    HRESULT DisconnectInput();

    // Streaming methods.
    STDMETHOD (Run)(REFERENCE_TIME tStart);

// Public data
public:
    //
    // Keep from rereconnecting the output
    //
    BOOL m_fReconnect;
    
    // called from the input pins.
    void FlushQueue(CBufferQueue *pQueue);
    HRESULT Receive(CBufferQueue *pQueue, IMediaSample * pSample);

// The following manage the list of input pins
protected:
    void InitInputPinsList();
    CMixerInputPin *GetInputPinNFromList(int n);

    HRESULT MixOneSample(
        IMediaSample *pMixedSample, 
        IMediaSample ** ppSample, 
        long lCount
        );

    HRESULT FillSilentBuffer(IMediaSample *, DWORD);   // Fill a buffer with silence
    void FlushAllQueues();
    BOOL    ResetQueuesIfNecessary();
    HRESULT PrePlay();
    HRESULT SendSample();
};

///////////////////////////////////////////////////////////////////////////////
//***************************************************************************//
//*************************** Inline Function Section ***********************//
//***************************************************************************//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
// GetFreePinCount
//
///////////////////////////////////////////////////////////////////////////////
inline int CMixer::GetFreePinCount()
{
    int n = 0;
    POSITION pos = m_listInputPins.GetHeadPosition();
    while(pos)
    {
        CBaseInputPin *pInputPin = (CBaseInputPin *)m_listInputPins.GetNext(pos);
        if (!pInputPin->IsConnected())
            n++;
    }
    return n;
}

///////////////////////////////////////////////////////////////////////////////

inline BOOL CMixer::MediaTypeKnown()
{
    return GetPin(INPUT_PIN0)->IsConnected();
}

///////////////////////////////////////////////////////////////////////////////
//***************************************************************************//
//***************************************************************************//
///////////////////////////////////////////////////////////////////////////////

inline HRESULT CMixerInputPin::CheckMediaType(const CMediaType *pmt)
{ 
    return m_pMixer->CheckMediaType(pmt);
}

///////////////////////////////////////////////////////////////////////////////

inline CMediaType &CMixerInputPin::CurrentMediaType()
{ 
    return m_mt; 
}

///////////////////////////////////////////////////////////////////////////////

inline CMediaType &CMixerOutputPin::CurrentMediaType()
{
    return m_mt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\intldbg\rtpplog.h ===
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1996:  Intel Corporation
// Confidential -- All proprietary rights reserved.
//
// AUTHOR       Stacy Bell
//
// DESCRIPTION
//              This file contains protocol logging definitions needed by RRCM
//              and the RTP PDU logging class.
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

// This define identifies the RTP and RTCP protocols as the ones to be logged.
// In the RRCM code, it is used only in the CPLInitialize() call.  
// For example:  RTPProtocolLogger = CPLInitialize( RTPLOG_PROTOCOL );
//
#define RTPLOG_PROTOCOL "RTP_PDU"

// PDU encoding type flags and PDU type flags.  These flags are passed from
// RRCM to the logging via user data.  Bit zero of the user data represents
// the Protocol type.  Bit 1 represents whether the PDU was sent or received.
//

#define RTCP_PDU                1UL
#define RTP_PDU                 0UL

#define RTPLOG_SENT_PDU		2UL
#define RTPLOG_RECEIVED_PDU	0UL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\mixer\g711tab.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  g711.h
//
//  Description:
//      This file contains encode and decode tables for
//      CCITT Rec. G.711 (u-law).
//
//==========================================================================;


const short UlawToPCM16Table[256] =
{
    -32124, -31100, -30076, -29052, -28028, -27004, -25980, -24956,
    -23932, -22908, -21884, -20860, -19836, -18812, -17788, -16764,
    -15996, -15484, -14972, -14460, -13948, -13436, -12924, -12412,
    -11900, -11388, -10876, -10364, -9852,  -9340,  -8828,  -8316,
    -7932,  -7676,  -7420,  -7164,  -6908,  -6652,  -6396,  -6140,
    -5884,  -5628,  -5372,  -5116,  -4860,  -4604,  -4348,  -4092,
    -3900,  -3772,  -3644,  -3516,  -3388,  -3260,  -3132,  -3004,
    -2876,  -2748,  -2620,  -2492,  -2364,  -2236,  -2108,  -1980,
    -1884,  -1820,  -1756,  -1692,  -1628,  -1564,  -1500,  -1436,
    -1372,  -1308,  -1244,  -1180,  -1116,  -1052,  -988,   -924,
    -876,   -844,   -812,   -780,   -748,   -716,   -684,   -652,
    -620,   -588,   -556,   -524,   -492,   -460,   -428,   -396,
    -372,   -356,   -340,   -324,   -308,   -292,   -276,   -260,
    -244,   -228,   -212,   -196,   -180,   -164,   -148,   -132,
    -120,   -112,   -104,   -96,    -88,    -80,    -72,    -64,
    -56,    -48,    -40,    -32,    -24,    -16,    -8,     0,
    32124,  31100,  30076,  29052,  28028,  27004,  25980,  24956,
    23932,  22908,  21884,  20860,  19836,  18812,  17788,  16764,
    15996,  15484,  14972,  14460,  13948,  13436,  12924,  12412,
    11900,  11388,  10876,  10364,  9852,   9340,   8828,   8316,
    7932,   7676,   7420,   7164,   6908,   6652,   6396,   6140,
    5884,   5628,   5372,   5116,   4860,   4604,   4348,   4092,
    3900,   3772,   3644,   3516,   3388,   3260,   3132,   3004,
    2876,   2748,   2620,   2492,   2364,   2236,   2108,   1980,
    1884,   1820,   1756,   1692,   1628,   1564,   1500,   1436,
    1372,   1308,   1244,   1180,   1116,   1052,   988,    924,
    876,    844,    812,    780,    748,    716,    684,    652,
    620,    588,    556,    524,    492,    460,    428,    396,
    372,    356,    340,    324,    308,    292,    276,    260,
    244,    228,    212,    196,    180,    164,    148,    132,
    120,    112,    104,    96,     88,     80,     72,     64,
    56,     48,     40,     32,     24,     16,     8,      0,
};

const BYTE UlawToPCM8Table[256] =
{
    3,      7,      11,     15,     19,     23,     27,     31,
    35,     39,     43,     47,     51,     55,     59,     63,
    66,     68,     70,     72,     74,     76,     78,     80,
    82,     84,     86,     88,     90,     92,     94,     96,
    97,     98,     99,     100,    101,    102,    103,    104,
    105,    106,    107,    108,    109,    110,    111,    112,
    113,    114,    114,    115,    115,    116,    116,    117,
    117,    118,    118,    119,    119,    120,    120,    121,
    121,    121,    122,    122,    122,    122,    123,    123,
    123,    123,    124,    124,    124,    124,    125,    125,
    125,    125,    125,    125,    126,    126,    126,    126,
    126,    126,    126,    126,    127,    127,    127,    127,
    127,    127,    127,    127,    127,    127,    127,    127,
    128,    128,    128,    128,    128,    128,    128,    128,
    128,    128,    128,    128,    128,    128,    128,    128,
    128,    128,    128,    128,    128,    128,    128,    128,
    253,    249,    245,    241,    237,    233,    229,    225,
    221,    217,    213,    209,    205,    201,    197,    193,
    190,    188,    186,    184,    182,    180,    178,    176,
    174,    172,    170,    168,    166,    164,    162,    160,
    159,    158,    157,    156,    155,    154,    153,    152,
    151,    150,    149,    148,    147,    146,    145,    144,
    143,    142,    142,    141,    141,    140,    140,    139,
    139,    138,    138,    137,    137,    136,    136,    135,
    135,    135,    134,    134,    134,    134,    133,    133,
    133,    133,    132,    132,    132,    132,    131,    131,
    131,    131,    131,    131,    130,    130,    130,    130,
    130,    130,    130,    130,    129,    129,    129,    129,
    129,    129,    129,    129,    129,    129,    129,    129,
    128,    128,    128,    128,    128,    128,    128,    128,
    128,    128,    128,    128,    128,    128,    128,    128,
    128,    128,    128,    128,    128,    128,    128,    128,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\mixer\queue.h ===
///////////////////////////////////////////////////////////////////////////////
//
// queue.h
//
// Copyright (C) Microsoft Corporation, 1996 - 1999  All rights reserved.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef CBufferQueue_DEFINED
#define CBufferQueue_DEFINED

class CBufferQueue
{
public:
    // construction/destruction
    CBufferQueue();
    ~CBufferQueue();

    BOOL Initialize(long lDepth);

    void CBufferQueue::EnQ(
        IMediaSample *  pMS, 
        DWORD           dwStartTime, 
        DWORD           dwSampleTime
        );
    
    IMediaSample *CBufferQueue::DeQ(
        BOOL    fAlways,
        DWORD   dwCurrentTime 
        );

    void Flush();         // Completly empties the Q
    void QueueEOS();      // Queues the end of the stream
    void ResetEOS();      // Make sure we're in a valid start state
    BOOL IsEOS();         // End of the stream

    BOOL IsActive();

private:
    //
    // Buffer Storage Management data
    //
    IMediaSample   **m_ppBuffers;
    long            m_lDepth;
    long            m_lCount;
    long            m_lHead;
    long            m_lTail;

    DWORD           m_dwStartTime;
    DWORD           m_dwSampleTime;
    BOOL            m_fActive;

    CRITICAL_SECTION m_CritSec;

    //
    // sender based stream termination.
    //
    BOOL m_fEOS;
};

inline void CBufferQueue::QueueEOS()
{
    EnterCriticalSection(&m_CritSec); 
    m_fEOS = TRUE;
    LeaveCriticalSection(&m_CritSec);
}

inline void CBufferQueue::ResetEOS()
{
    EnterCriticalSection(&m_CritSec); 
    m_fEOS = FALSE; 
    LeaveCriticalSection(&m_CritSec);
}

inline BOOL CBufferQueue::IsEOS()
{
    EnterCriticalSection(&m_CritSec); 
    BOOL res = m_fEOS; 
    LeaveCriticalSection(&m_CritSec);

    return res;
}

inline BOOL CBufferQueue::IsActive()
{
    EnterCriticalSection(&m_CritSec); 
    BOOL res = m_fActive; 
    LeaveCriticalSection(&m_CritSec);

    return res;
}

#endif // #ifndef CBufferQueue_DEFINED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\mixer\mxfilter.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       mxfilter.cpp
//
//--------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////////////
//
//         File: mxfilter.cpp
//
//  Description: Implements the mixer filter class
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#if !defined(MIXER_IN_DXMRTP)
#include <initguid.h>
#define INITGUID
#endif
#include <uuids.h>
#include "mxfilter.h"
#include "g711tab.h"
#include "template.h"
//
// I know I do this don't tell me anymore!
//
#pragma warning(disable:4355)

///////////////////////////////////////////////////////////////////////////////
//***************************************************************************//
//*                                                                         *//
//*                             Audio Mixing Code                           *//
//*                                                                         *//
//* NOTE: I've used classes and templates to abstract common mixing code    *//
//*       based on the size & type.  The following classes represent data   *//
//*       types.  Each has an operator+ to which implements how data of     *//
//*       that size & type is combined.  It is important that these classes *//
//*       be indisguishable from the data types they represent so each has  *//
//*       a single data member and no virtual functions.  That cannot       *//
//*       change!                                                           *//
//*                                                                         *//
//***************************************************************************//
///////////////////////////////////////////////////////////////////////////////

struct CuLaw
{
    //
    // m_data should be the first and only data member.  This allows casting
    //  from a BYTE.
    //
    BYTE m_data;

    CuLaw() : m_data(0x80) { ASSERT(sizeof(CuLaw) == sizeof(BYTE)); }
    //CuLaw(BYTE data) : m_data(data) { ASSERT(sizeof(CuLaw) == sizeof(BYTE)); }

    inline BYTE data() {return m_data;}
    //operator BYTE() { return m_data; }

    // Peg and CopyBuffer functions only required for destination types

    friend int operator+(const CuLaw &samp1, const CuLaw &samp2);
    friend short operator+(const short samp1, const CuLaw &samp2);
};

inline int operator+(const CuLaw &samp1, const CuLaw &samp2)
    { return UlawToPCM16Table[samp1.m_data] + UlawToPCM16Table[samp2.m_data]; }

inline int operator+(const int samp1, const CuLaw &samp2)
    { return samp1 + + UlawToPCM16Table[samp2.m_data]; }

///////////////////////////////////////////////////////////////////////////////
//***************************************************************************//
///////////////////////////////////////////////////////////////////////////////

struct C8Bit
{
    //
    // m_data should be the first and only data member.  This allows casting
    //  from a BYTE.
    //
    BYTE m_data;

    C8Bit() : m_data(0x80)  { ASSERT(sizeof(C8Bit) == sizeof(BYTE)); }
    C8Bit(BYTE data) : m_data(data)  { ASSERT(sizeof(C8Bit) == sizeof(BYTE)); }

    inline BYTE data() {return m_data;}
    
    static C8Bit Peg(short iInput)
    {
        BYTE bVal;
        if (iInput < 0)
        {
            bVal = 0;
        }
        else if (iInput > 0xFF)
        {
            bVal = 0xFF;
        }

        return bVal;
    }

    static C8Bit Peg(int iInput)
    {
#if 0
        //
        // Scale volume to 50%
        //
        iInput = (int)(iInput * 0.50);
#endif

        // First peg the short
        SHORT sVal;
        if (iInput > MAXSHORT)
        {
            sVal = MAXSHORT;
        }
        else if (iInput < -MAXSHORT)
        {
            sVal = -MAXSHORT;
        }
        else
        {
            sVal = (short)iInput;
        }

        // return converted to byte
        return sVal / 0xFF + 0x80;
    }

    static int InitSum() { return 0x80; }

    void CopyBuffer(C8Bit *psrc, LONG lLen)
    {
        ASSERT(sizeof(C8Bit) == sizeof(BYTE)); 
        memcpy(this, psrc, lLen * sizeof(BYTE));
    }

    void CopyBuffer(CuLaw *psrc, LONG lLen)
    {
        BYTE *pDest = &m_data;
        for (WORD wC = 0; wC < lLen; wC++)
        {
            *pDest++ = UlawToPCM8Table[(psrc + wC)->data()];
        }
    }

    friend short operator+(const C8Bit &samp1, const C8Bit &samp2);
    friend short operator+(const int samp1, const C8Bit &samp2);
};

inline short operator+(const C8Bit &samp1, const C8Bit &samp2)
    { return samp1.m_data + samp2.m_data - 0x80; }

inline short operator+(const int samp1, const C8Bit &samp2)
    { return samp1 + samp2.m_data - 0x80; }

///////////////////////////////////////////////////////////////////////////////
//***************************************************************************//
///////////////////////////////////////////////////////////////////////////////

struct C16Bit
{
    //
    // m_data should be the first and only data member.  This allows casting
    //  from a short.
    //
    short m_data;

    C16Bit() : m_data(0)  { ASSERT(sizeof(C16Bit) == sizeof(short)); }
    C16Bit(short data) : m_data(data) { ASSERT(sizeof(C16Bit) == sizeof(short)); }

    //short operator() () {return m_data;}
    inline short data() {return m_data;}

    static C16Bit Peg(int iInput)
    {
        SHORT sVal;
        if (iInput > MAXSHORT)
        {
            sVal = MAXSHORT;
        }
        else if (iInput < -MAXSHORT)
        {
            sVal = -MAXSHORT;
        }
        else
        {
            sVal = (short)iInput;
        }

        return sVal;
    }

    static int InitSum() { return 0; }

    void CopyBuffer(C16Bit *psrc, LONG lLen)
    {
        ASSERT(sizeof(C16Bit) == sizeof(short));
        memcpy(this, psrc, lLen * sizeof(short));
    }

    void CopyBuffer(CuLaw *psrc, LONG lLen)
    {
        short *pDest = &m_data;
        for (WORD wC = 0; wC < lLen; wC++)
        {
            *pDest++ = UlawToPCM16Table[(psrc + wC)->data()];
        }
    }

    friend int operator+(const C16Bit &samp1, const C16Bit &samp2);
    friend int operator+(const int samp1, const C16Bit &samp2);
};

inline int operator+(const C16Bit &samp1, const C16Bit &samp2)
    { return samp1.m_data + samp2.m_data; }

inline int operator+(const int samp1, const C16Bit &samp2)
    { return samp1 + samp2.m_data; }
///////////////////////////////////////////////////////////////////////////////
//***************************************************************************//
///////////////////////////////////////////////////////////////////////////////

//
// sample mixer
//  the template allows us to have one mix code base and generate different
//  implementations.
//
template<class MXSDEST, class MXSSRC>
void MixBuffers(MXSDEST *pDest, MXSSRC *pWaveSrc[], int iNumWaves, LONG lLenSrc)
{
    int i;
    WORD wC;

    ASSERT(iNumWaves > 0);

    //
    // Switch some special cases to aid the compiler in optimizing.
    //
    switch (iNumWaves)
    {
    case 1:
        //
        // If there is only one wave then this is just a copy.
        //
        if ((void*)pDest != (void*)pWaveSrc[0])
        {
            // memcpy(pDest, pWaveSrc[0], lLen * sizeof(MXSRC));
            //
            // Can't use memcpy now because we may translate
            //
            pDest->CopyBuffer(pWaveSrc[0], lLenSrc);
        }
        break;
    case 2:
        for (wC = 0; wC < lLenSrc; wC++)
        {
            *pDest++ = MXSDEST::Peg
                            ((*(pWaveSrc[0] + wC) 
                            + *(pWaveSrc[1] + wC)) / 2
                            );
        }
        break;
    case 3:
        for (wC = 0; wC < lLenSrc; wC++)
        {
            *pDest++ = MXSDEST::Peg
                            ((*(pWaveSrc[0] + wC) 
                            + *(pWaveSrc[1] + wC)
                            + *(pWaveSrc[2] + wC)) / 3
                            );
        }
        break;
    case 4:
        for (wC = 0; wC < lLenSrc; wC++)
        {
            *pDest++ = MXSDEST::Peg
                            ((*(pWaveSrc[0] + wC) 
                            + *(pWaveSrc[1] + wC)
                            + *(pWaveSrc[2] + wC)
                            + *(pWaveSrc[3] + wC)) / 4
                            );
        }
        break;
    case 5:
        for (wC = 0; wC < lLenSrc; wC++)
        {
            *pDest++ = MXSDEST::Peg
                            ((*(pWaveSrc[0] + wC) 
                            + *(pWaveSrc[1] + wC)
                            + *(pWaveSrc[2] + wC)
                            + *(pWaveSrc[3] + wC)
                            + *(pWaveSrc[4] + wC)) / 5
                            );
        }
        break;
    default:
        //
        // After so many just loop to sum
        //
        for (wC = 0; wC < lLenSrc; wC++)
        {
            int iSum = MXSDEST::InitSum();
            for (i = 0; i < iNumWaves; i++)
            {
                iSum = iSum + *(pWaveSrc[i] + wC);
            }
            *pDest++ = MXSDEST::Peg(iSum / iNumWaves);
        }
        break;
    }

    return;
}

///////////////////////////////////////////////////////////////////////////////
//***************************************************************************//
//*                                                                         *//
//*                                 Setup Data                              *//
//*                                                                         *//
//***************************************************************************//
///////////////////////////////////////////////////////////////////////////////

#define MIXER_FILTER_NAME  "Microsoft PCM Audio Mixer"

static AMOVIESETUP_MEDIATYPE sudPinTypes = 
{
    &MEDIATYPE_Audio,           // clsMajorType
    &MEDIASUBTYPE_PCM           // clsMinorType
};

static AMOVIESETUP_PIN psudPins[] = 
{
    { L"Input"            // strName
    , FALSE               // bRendered
    , FALSE               // bOutput
    , TRUE                // bZero
    , TRUE                // bMany
    , &CLSID_NULL         // clsConnectsToFilter
    , L"Output"           // strConnectsToPin
    , 1                   // nTypes
    , &sudPinTypes },     // lpTypes
    { L"Output"           // strName
    , FALSE               // bRendered
    , TRUE                // bOutput
    , FALSE               // bZero
    , FALSE               // bMany
    , &CLSID_NULL         // clsConnectsToFilter
    , L"Input"            // strConnectsToPin
    , 1                   // nTypes
    , &sudPinTypes }      // lpTypes
};

AMOVIESETUP_FILTER sudMixer = 
{
      &CLSID_AudioMixFilter     // clsID
    , LMIXER_FILTER_NAME        // strName
    , MERIT_DO_NOT_USE          // dwMerit
    , 2                         // nPins
    , psudPins                  // lpPin
};

#if !defined(MIXER_IN_DXMRTP)
CFactoryTemplate g_Templates [] = {
    CFT_MIXER_ALL_FILTERS
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);
#endif

///////////////////////////////////////////////////////////////////////////////
//***************************************************************************//
//*                                                                         *//
//*                          CMixer Implementation                          *//
//*                                                                         *//
//***************************************************************************//
///////////////////////////////////////////////////////////////////////////////

BOOL
GetRegValue(
    IN  LPCTSTR szName,
    OUT DWORD   *pdwValue
    )
/*++

Routine Description:

    Get a dword from the registry in the Mixer key.

Arguments:

    szName  - The name of the value.

    pdwValue  - a pointer to the dword returned.

Return Value:

    TURE    - SUCCEED.

    FALSE   - FAIL

--*/
{
    HKEY  hKey;
    DWORD dwDataSize, dwDataType;

    if (::RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        MIXER_KEY,
        0,
        KEY_READ,
        &hKey) != NOERROR)
    {
        return FALSE;
    }

    dwDataSize = sizeof(DWORD);
    if (::RegQueryValueEx(
        hKey,
        szName,
        0,
        &dwDataType,
        (LPBYTE) pdwValue,
        &dwDataSize) != NOERROR)
    {
        RegCloseKey (hKey);
        return FALSE;
    }

    RegCloseKey (hKey);

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
//
// CreateInstance
//
// Creator function for the class ID
//
///////////////////////////////////////////////////////////////////////////////
CUnknown * WINAPI CMixer::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CMixer(NAME(MIXER_FILTER_NAME), pUnk, phr);
}

///////////////////////////////////////////////////////////////////////////////
//
// Constructor
//
///////////////////////////////////////////////////////////////////////////////
CMixer::CMixer(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr)
    : m_listInputPins(NAME("Mixer Input Pin list"))
    , m_cInputPins(0)
    , m_iNextInputPinNumber(0)
    , m_pMixerOutput(NULL)
    , m_fReconnect(FALSE)
    , CBaseFilter(NAME(MIXER_FILTER_NAME), pUnk, this, CLSID_AudioMixFilter)
    , m_dwSpurtStartTime(0)
    , m_dwLastTime(0)
    , m_lTotalDelayBufferSize(0)
{
    ASSERT(phr);

    // Create a single output pin at this time
    InitInputPinsList();

    m_pMixerOutput = new CMixerOutputPin(
        NAME("Mixer Output"), 
        this, 
        phr, 
        L"Mixer Output");

    if (FAILED(*phr))
    {
        return;
    }
    else if (!m_pMixerOutput)
    {
        *phr = E_OUTOFMEMORY;
        return;
    }

    if (!SpawnNewInput())
    {
        *phr = E_OUTOFMEMORY;
        return;
    }
    
    if (!GetRegValue(JITTERBUFFER, (DWORD *)&m_lJitterBufferTime))
    {
        m_lJitterBufferTime = DEFAULT_JITTERBUFFERTIME;
    }

    if (!GetRegValue(MIXBUFFER, (DWORD *)&m_lMixDelayTime))
    {
        m_lMixDelayTime = DEFAULT_MIXDELAYTIME;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// Destructor
//
///////////////////////////////////////////////////////////////////////////////
CMixer::~CMixer()
{
    InitInputPinsList();
    delete m_pMixerOutput;
    DbgLog((LOG_TRACE, 1, TEXT("~Mixer returns")));
}

///////////////////////////////////////////////////////////////////////////////
//
// GetSetupData - Part of the self-registration mechanism
//
///////////////////////////////////////////////////////////////////////////////
LPAMOVIESETUP_FILTER CMixer::GetSetupData()
{
  return &sudMixer;
}

HRESULT CMixer::FillSilentBuffer(IMediaSample *pSilentSamp, DWORD dwSize)
/*++

Routine Description:

    Fill a media sample with silence.

Arguments:

    pSilentSamp  - The sample being filled with silence.

    dwSize - The length of the silence(in bytes).

Return Value:
    
    HRESULT from GetPointer function or S_OK.
--*/
{
    HRESULT hr;

    BYTE *pSilBuf;
    hr = pSilentSamp->GetPointer(&pSilBuf);
    ASSERT(SUCCEEDED(hr));

    DWORD dwLen = min((DWORD)pSilentSamp->GetSize(), dwSize);

    // Fill the buffer with the appropriate silent data for it's size
    switch(m_wOutputBitsPerSample)
    {
    case 8:
        FillMemory(pSilBuf, dwLen, 128);
        break;
    case 16:
        FillMemory(pSilBuf, dwLen, 0);
        break;
    }

    pSilentSamp->SetActualDataLength(dwLen);

    return S_OK;
}


CBasePin *CMixer::GetPin(int n)
/*++

Routine Description:

    Get the Nth pin on this filter.

Arguments:

    n - The index of the pin. Zero is output. 

Return Value:

    a pointer to the pin.
--*/
{
    // Pin zero is the one and only output pin
    if (n == OUTPUT_PIN)
        return (CBasePin*)m_pMixerOutput;

    // return the input pin at position n (one based)
    return (CBasePin*)GetInputPinNFromList(n);
}

void CMixer::InitInputPinsList()
/*++

Routine Description:

    Initialize the pin list. Relase all the pins currently in the list.

Arguments:

Return Value:

--*/
{
    POSITION pos = m_listInputPins.GetHeadPosition();
    while(pos)
    {
        CMixerInputPin *pInputPin = m_listInputPins.GetNext(pos);
        pInputPin->Release();
    }
    m_cInputPins = 0;
    m_listInputPins.RemoveAll();
}

BOOL CMixer::SpawnNewInput()
/*++

Routine Description:

    Create a new input pin. Also create a queue for the samples of this
    new input pin. The queues are maintained by the filter in a list. 

Arguments:

Return Value:

    TRUE   -  succeed.
    FALSE  -  fail.
--*/
{
    int n = GetFreePinCount();
    ASSERT(n <= 1);

    if (n == 1 || m_cInputPins == MAX_QUEUES) return FALSE;

    // First create a queue for this input pin.
    CBufferQueue *pQueue = new CBufferQueue();
    if (pQueue == NULL)
    {
        DbgLog((LOG_ERROR, 1, TEXT("CMixer, can't create queue.")));
        return NULL;
    }

    if (!pQueue->Initialize(MAX_QUEUE_STORAGE))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CMixer, can't initialize queue.")));
        return NULL;
    }

    // construct a pin name.
    WCHAR szbuf[20];             // Temporary scratch buffer
    wsprintfW(szbuf, L"Input%d", m_iNextInputPinNumber);

    // Create the pin object itself
    HRESULT hr = S_OK;
    CMixerInputPin *pPin = new CMixerInputPin(
        NAME("Mixer Input"), 
        this,
        &hr, 
        szbuf, 
        m_iNextInputPinNumber,
        pQueue
        );

    if (FAILED(hr) || pPin == NULL)
    {
        delete pPin;  // delete NULL ok.
        delete pQueue;
        DbgLog((LOG_ERROR, 1, TEXT("CMixer, can't create a pin.")));
        return FALSE;
    }

    // Add the pin into the list.
    pPin->AddRef();
    m_listInputPins.AddTail(pPin);

    // Add the new queue into the filter's queue list.
    m_queues[m_cInputPins] = pQueue;

    m_iNextInputPinNumber++;     // Next number to use for pin
    m_cInputPins++;

    IncrementPinVersion();

    return TRUE;
}

CMixerInputPin *CMixer::GetInputPinNFromList(int n)
/*++

Routine Description:

    Get the Nth input pin on this filter.

Arguments:

    n - The index of the pin. base 1.

Return Value:

    a pointer to the pin.
--*/
{
    // Validate the position being asked for
    if (n > m_cInputPins) return NULL;

    // Get the head of the list
    POSITION pos = m_listInputPins.GetHeadPosition();

    CMixerInputPin *pInputPin;
    while(n)
    {
        pInputPin = m_listInputPins.GetNext(pos);
        n--;
    }
    return pInputPin;
}

void CMixer::DeleteInputPin(CMixerInputPin *pPin, CBufferQueue *pQueue)
/*++

Routine Description:

    Delete an input pin from the filter. Also involves freeing the sample 
    queue that the pin was using.

Arguments:

    pPin -  A pointer to the pin.

    pQueue - a pointer to the sample queue.

Return Value:

--*/
{
    DbgLog((LOG_TRACE, 1, TEXT("CMixer::DeleteInputPin called")));

    POSITION pos = m_listInputPins.GetHeadPosition();
    while(pos)
    {
        POSITION posold = pos;         // Remember this position
        CMixerInputPin *pInputPin = m_listInputPins.GetNext(pos);
        if (pInputPin == pPin)
        {
            // Found the pin, remove it from the list.
            m_listInputPins.Remove(posold);

            // Find the queue allocated for this pin and remove it.
            for (int i = 0; i < m_cInputPins; i ++)
            {
                if (m_queues[i] == pQueue)
                {
                    m_queues[i] = m_queues[m_cInputPins - 1];
                    break;
                }
            }


            delete pQueue;
            delete pPin;
            m_cInputPins--;

            // ASSERT(pInputPin->m_pInputQueue == NULL);
            IncrementPinVersion();
            break;
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// Verify that we can send this output based on our input.  This filter can
//  do a simple transformation from uLaw to PCM so we account for that here.
//
// One special condition is applied here.  That is, unless we transform from
//  uLaw to PCM we don't do sample size conversions (i.e. we assume the input
//  bits per sample is the same as the output).
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CMixer::CheckOutputMediaType(const CMediaType* pMediaType)
{
    if (!GetInput0()->IsConnected()) {
        DbgLog((LOG_ERROR, 1, 
            TEXT("CMixer::CheckOutputMediaType, input is not connected")
            ));
        return E_UNEXPECTED;
    }
    CMediaType &rMT = GetInput0()->CurrentMediaType();

    //
    // Grose checks first.
    //
    if (pMediaType == NULL) {
        DbgLog((LOG_ERROR, 1, 
            TEXT("CMixer::CheckOutputMediaType, input pin mediatype error")
            ));
        return E_INVALIDARG;
    }

    if (*pMediaType->Type() != MEDIATYPE_Audio) {
        DbgLog((LOG_ERROR, 1, 
            TEXT("CMixer::CheckOutputMediaType, mediatype is not audio")
            ));
        return E_INVALIDARG;
    }

    if (*pMediaType->FormatType() != FORMAT_WaveFormatEx) {
        DbgLog((LOG_ERROR, 1, 
            TEXT("CMixer::CheckOutputMediaType, not wave format")
            ));
        return E_INVALIDARG;
    }

    WAVEFORMATEX *pInFmt, *pOutFmt;
    pInFmt = (WAVEFORMATEX*)rMT.Format();
    pOutFmt = (WAVEFORMATEX*)pMediaType->Format();

    if (pInFmt == NULL) {
        DbgLog((LOG_ERROR, 1, 
            TEXT("CMixer::CheckOutputMediaType, input format error")
            ));
        return E_UNEXPECTED;
    }
    if (pOutFmt == NULL) {
        DbgLog((LOG_ERROR, 1, 
            TEXT("CMixer::CheckOutputMediaType, output format error")
            ));
        return E_INVALIDARG;
    }            

    if (pInFmt->nSamplesPerSec != pOutFmt->nSamplesPerSec)
    {
        DbgLog((LOG_ERROR, 1, 
            TEXT("CMixer::CheckOutputMediaType, wrong sample rate")
            ));
        return E_INVALIDARG;
    }
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// Verify that we actually know how to support the data that we will be
//  passed.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CMixer::CheckMediaType(const CMediaType* pMediaType)
{
    //
    // Grose checks first.
    //
    if (pMediaType == NULL) {
        DbgLog((LOG_ERROR, 1, 
            TEXT("CMixer::CheckMediaType, NULL media type")
            ));
        return E_INVALIDARG;
    }

    if (*pMediaType->Type() != MEDIATYPE_Audio) {
        DbgLog((LOG_ERROR, 1, 
            TEXT("CMixer::CheckMediaType, not audio")
            ));
        return E_INVALIDARG;
    }

    if (*pMediaType->FormatType() != FORMAT_WaveFormatEx) {
        DbgLog((LOG_ERROR, 1, 
            TEXT("CMixer::CheckMediaType, not wave")
            ));
        return E_INVALIDARG;
    }

    WAVEFORMATEX *pwfx = (WAVEFORMATEX *)pMediaType->Format();

    //
    // Attempt to make shure the adjacent filter doesn't mess us
    //
    if (pwfx == NULL)
    {
        DbgLog((LOG_ERROR, 1, 
            TEXT("CMixer::CheckMediaType, can't get wave format")
            ));
        return E_INVALIDARG;
    }

    //
    // Check the basic requirements
    //
    if ((pwfx->wFormatTag != WAVE_FORMAT_PCM)
        && (pwfx->wFormatTag != WAVE_FORMAT_MULAW))
    {
        DbgLog((LOG_ERROR, 1, 
            TEXT("CMixer::CheckMediaType, unsupported format: %d"),
            pwfx->wFormatTag
            ));
        return E_FAIL;
    }

    //
    // If the input pin 0 is connected it dictates this!
    //
    if (GetInput0()->IsConnected())
    {
        if (*pMediaType != GetInput0()->CurrentMediaType())
        {
            DbgLog((LOG_ERROR, 1, 
                TEXT("CMixer::CheckMediaType, different from the first pin.")
                ));
            return E_FAIL;
        }
    }

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
// Return the currently selected media type
//
///////////////////////////////////////////////////////////////////////////////
CMediaType &CMixer::CurrentMediaType()
{
    return ((CMixerInputPin*)GetInput0())->CurrentMediaType();
}


///////////////////////////////////////////////////////////////////////////////
//
// Store some properties deal with allocator negoation.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CMixer::CompleteConnect()
{
    return S_OK; // BUGBUG: This could be removed!
}

///////////////////////////////////////////////////////////////////////////////
//
// Deal with allocator negoation.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CMixer::DisconnectInput()
{
    return S_OK; // BUGBUG: This could be removed!
}

///////////////////////////////////////////////////////////////////////////////
//
// Must set the properties for the allocator.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CMixer::DecideBufferSize(
    IMemAllocator * pAlloc, 
    ALLOCATOR_PROPERTIES * pProperties
    )
{
    IMemAllocator *pMemAllocator;
    ALLOCATOR_PROPERTIES Request, Actual;
    HRESULT hr;

    // If we are connected upstream, get his views
    if (GetInput0()->IsConnected() && GetInput0()->GetAllocator() != NULL)
    {
        // Get the input pin allocator, and get its size and count.
        // we don't care about his alignment and prefix.
        hr = GetInput0()->GetAllocator()->GetProperties(&Request);
        if (FAILED(hr))
        {
            // Input connected but with a secretive allocator - enough!
            return hr;
        }
    }
    else
    {
        // We're reduced to blind guessing.  Let's guess one byte and if
        // this isn't enough then when the other pin does get connected
        // we can revise it.
        ZeroMemory(&Request, sizeof(Request));
    }

    Request.cBuffers = 8;  // limit the buffer size to 8 samples.
    //
    // Input requirements dictate the output requirements.
    //
    pProperties->cBuffers = Request.cBuffers;  // limit the buffer size to 8 samples.
    pProperties->cbBuffer = Request.cbBuffer;
    if (pProperties->cbBuffer == 0) { pProperties->cbBuffer = 1; }
    if (pProperties->cBuffers == 0) { pProperties->cBuffers = 1; }

    //
    // Now adjust the buffersize just in case we translate from uLaw to
    //  PCM16.
    //
    //
    // First look at the input pin.
    //
    CMediaType &pmt = GetInput(0)->CurrentMediaType();
    ASSERT(pmt.formattype == FORMAT_WaveFormatEx);

    WAVEFORMATEX *pwfx  = (WAVEFORMATEX *)pmt.Format();
    ASSERT(pwfx != NULL);

    m_wInputFormatTag = pwfx->wFormatTag;
    
    // remember the input bytes per millisecond.
    m_dwInputBytesPerMS  = pwfx->nAvgBytesPerSec / 1000;
    ASSERT(m_dwInputBytesPerMS != 0);

    // remember the input bits per sample.
    m_wInputBitsPerSample  = pwfx->wBitsPerSample;
    ASSERT(m_wInputBitsPerSample != 0);

    DbgLog((LOG_TRACE, 1, 
        TEXT("CMixer::DecideBufferSizes:\nInput: BitsPerSample %d, BytesPerMS %d"),
        m_wInputBitsPerSample,
        m_dwInputBytesPerMS
        ));

    //
    // Now look at the output pin.
    //
    CMediaType &pmt2 = GetOutput()->CurrentMediaType();
    ASSERT(pmt2.formattype == FORMAT_WaveFormatEx);

    WAVEFORMATEX *pwfx2  = (WAVEFORMATEX *)pmt2.Format();
    ASSERT(pwfx2 != NULL);
    
    // remember the output bits per sample.
    m_wOutputBitsPerSample  = pwfx2->wBitsPerSample;

    ASSERT(m_wOutputBitsPerSample != 0);

    // Adjust the buffer size.
    pProperties->cbBuffer *= m_wOutputBitsPerSample / m_wInputBitsPerSample;

    DbgLog((LOG_TRACE, 1, 
        TEXT("CMixer::DecideBufferSizes:\nOutput: BitsPerSample %d"),
        m_wOutputBitsPerSample
        ));

    //
    // Send these to the downstream filter
    //
    hr = pAlloc->SetProperties(pProperties, &Actual);

    if (FAILED(hr))
    {
        return hr;
    }

    // Make sure we got the right alignment and at least the minimum required

    DbgLog((LOG_TRACE, 1, 
        TEXT("CMixer::DecideBufferSizes:\ncBuffers %d, cbBuffer %d"), 
        Actual.cBuffers,
        Actual.cbBuffer
        ));

    if (  (Request.cBuffers > Actual.cBuffers)
       || (Request.cbBuffer > Actual.cbBuffer)
       || (Request.cbAlign  > Actual.cbAlign)
       )
    {
        DbgLog((LOG_ERROR, 1, 
            TEXT("CMixer::DecideBufferSize, Actual size less that request.")
            ));

        return E_FAIL;
    }

    return NOERROR;
}

STDMETHODIMP CMixer::Run(REFERENCE_TIME tStart)
{
    if (!GetOutput()->IsConnected()) {
        DbgLog((LOG_ERROR, 1, 
            TEXT("CMixer::Run, output is not connected")
            ));
        return E_UNEXPECTED;
    }

// This is the function we reinterpret all the parameters. This means all
// the setting only take effect when the stream is restarting again.

    // This is the length of silence we preplay before the first sample
    // of a spurt of sound. We need more for the mixing case.
    m_lTotalDelayTime = m_lJitterBufferTime + 
        ((m_cInputPins == 2) ? 0 : m_lMixDelayTime);

    m_lTotalDelayBufferSize = m_lTotalDelayTime * m_dwInputBytesPerMS;

    m_lTimeDelta = 0;
    m_lSampleTime = 0;
    m_dwLastTime = timeGetTime();

    DbgLog((LOG_TRACE, 1, 
        TEXT("CMixer::Run: JitterBuffer time: %d, size:%d"),
        m_lTotalDelayTime,
        m_lTotalDelayBufferSize
        ));

    return CBaseFilter::Run(tStart);
}

void CMixer::FlushAllQueues()
{
    for (int i = 0; i < m_cInputPins; i++)
    {
        m_queues[i]->Flush();
    }
}

void CMixer::FlushQueue(CBufferQueue *pQueue)
{
#if USE_LOCK
    CAutoLock l(&m_cQueues);
#endif

    pQueue->Flush();
}

HRESULT CMixer::PrePlay()
/*++

Routine Description:

    Plays certain amount of silence before playing a sound spurt. This will
    keep the waveout device busy for that amount of time while we buffer up
    some samples to play without gap. We could have set a timer to do the 
    same, but that needs another thread and the thread turn around time is
    not accurate. Feed some samples to the waveout device provides a free
    and accurate jitter buffer.

Arguments:

Return Value:

    HRESULT.
--*/
{
    IMediaSample *pMediaSample;

    HRESULT hr = GetOutput()->GetDeliveryBuffer(
        &pMediaSample, NULL, NULL, 0);

    if (FAILED(hr))
    {
        // no free buffer from the wave out device.
        DbgLog((LOG_TRACE, 1, TEXT("get buffer failed: %x"), hr));
        return hr;
    }
    
    // The size of the silence is determined by how long the samples
    // have to wait before playing. In point to point to case, we can
    // deliver buffers as soon as we get them. The mixing case needs
    // longer buffer.
    DWORD dwSilenceSize = m_lTotalDelayBufferSize;
        
    // let's play some silence.
    hr = FillSilentBuffer(pMediaSample, 
        dwSilenceSize * m_wOutputBitsPerSample / m_wInputBitsPerSample);

    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE, 1, TEXT("fill sience failed: %x"), hr));
        pMediaSample->Release();
        return hr;
    }

    // Deliver the silence buffer.
    hr = GetOutput()->Deliver(pMediaSample);
    
    DbgLog((LOG_TRACE, 0x3ff, 
        TEXT("---------Insert silence, size:%d"), 
        dwSilenceSize
        ));
    
    pMediaSample->Release();

    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE, 1, 
            TEXT("deliver failed: %x"), hr));
        return hr;
    }

    // adjust the delta between system time and stream time.
    m_lTimeDelta += dwSilenceSize / m_dwInputBytesPerMS;    

    return hr;
}

BOOL CMixer::ResetQueuesIfNecessary()
/*++

Routine Description:

    Check to see if we have not received any sample for a while. If yes,
    reset all the queues to empty.

    TimeDelta = TotalSampleTime + JitterBufferTime - 
                    (CurrentTime - SpurtStartTime);

    If timedelta is negative, the device is starving. This is the sign of
    a new spurt. We could also set a negative threshold to make the algorithm
    more tolerable to temporary increase of delay.

Arguments:

Return Value:

    TRUE    - yes, the queues are reset.
    FALSE   - no, the queues are not touched.
--*/
{
    // Get current time.
    DWORD dwThisTime = timeGetTime();

    // Calculate the accumulated delta between the system time and stream time.
    m_lTimeDelta -= (dwThisTime - m_dwLastTime);

    DbgLog((LOG_TRACE, 0x3ff, 
        TEXT("*******last:%dms, this:%dms, Delta:%dms"), 
        m_dwLastTime,
        dwThisTime,
        m_lTimeDelta
        ));

    // update with new reading of system time.
    m_dwLastTime = dwThisTime;

    if (m_lTimeDelta < 0)
    {
        // The data is behind the playout. Assume this is a new spurt.
        m_dwSpurtStartTime = dwThisTime;

        // reset the time delta for this new spurt.
        m_lTimeDelta = 0;   

        // Reset the queues that used to be active.
        for (int i = 0; i < m_cInputPins; i ++)
        {
            m_queues[i]->Flush();
        }

        return TRUE;
    }
    
    return FALSE;
}

HRESULT CMixer::SendSample()
/*++

Routine Description:

    There are samples in the queues that need to be sent. Mix them
    and then send them out.

Arguments:

Return Value:
    
    S_OK    - samples are delivered.
    S_FALSE - there is nothing to deliver.
--*/
{
    IMediaSample *pMediaSample;

    HRESULT hr = GetOutput()->GetDeliveryBuffer(
        &pMediaSample, NULL, NULL, 0);

    if (FAILED(hr))
    {
        // no free buffer from the wave out device.
        DbgLog((LOG_TRACE, 1, TEXT("get buffer failed: %x"), hr));
        return hr;
    }

    long lCount = 0; 
    IMediaSample *ppSamples[MAX_QUEUES];

    // Get samples from the active queues.
    for (int i = 0; i < m_cInputPins; i ++)
    {
        if (m_queues[i]->IsActive())
        {
            // only get the samples that meets the schedule.
            IMediaSample *pSample = m_queues[i]->DeQ(
                (m_cInputPins == 2), m_dwLastTime
                );

            if (pSample != NULL)
            {
                ppSamples[lCount++] = pSample;
            }
        }
    }

    if (lCount != 0)
    {
        // The samples are released in this function after mixing.
        hr = MixOneSample(
                pMediaSample,
                ppSamples,
                lCount
                );

        if (FAILED(hr))
        {
            DbgLog((LOG_TRACE, 1, TEXT("mix one sample failed: %x"), hr));
            pMediaSample->Release();
            return hr;
        }

        // deliver the mixed buffer.
        hr = GetOutput()->Deliver(pMediaSample);

        DbgLog((LOG_TRACE, 0x3ff, TEXT("sample deliverd.")));
        if (FAILED(hr))
        {
            DbgLog((LOG_TRACE, 1, TEXT("deliver failed: %x"), hr));
            pMediaSample->Release();
            return hr;
        }

        // adjust the time delta. The input gains some ground.
        m_lTimeDelta += m_lSampleTime;    

        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }
    
    pMediaSample->Release();

    return hr;
}

HRESULT CMixer::Receive(CBufferQueue *pQueue, IMediaSample * pSample)
/*++

Routine Description:

    Get a new sample for a certain queue. If this is the first sample after
    a period of silence, preplay some silence to give us some time to absorb
    the jitter. Otherwise, if this queue has queued long enought sample, this
    queue will trigue a send sample operation. If there is only one queue,
    the sample is delivered without wait.

    We are ignoring timestamps for the samples we send. Waveout filter will
    send this kinds of sample directly to the device, which is just what we
    want.

Arguments:

    pQueue - The queue the the sample is supposed to go.

    pSample - The sample just received.

Return Value:

    TRUE    - yes, the queues are reset.
    FALSE   - no, the queues are not touched.
--*/
{
    ASSERT(pQueue != NULL);

#if USE_LOCK
//  Since there is only one thread delivering audio samples, there is
//  no need to lock.
    CAutoLock l(&m_cQueues);
#endif

    // BUGBUG, we are still assuming all the samples to be mixed are of
    // the same size. Under this assumption, the mixing can be done
    // with n reads and 1 write. Otherwise, it will be n reads and
    // n writes.
    long lDataLen = pSample->GetActualDataLength();
    if (m_lSampleTime == 0)
    {
        m_lSampleTime = lDataLen / m_dwInputBytesPerMS;
        
        ASSERT(m_lSampleTime > 0);

        DbgLog((LOG_TRACE, 1, TEXT("sample size: %dms"), m_lSampleTime));
    }

    // First test if this is the first sample of a new sound spurt.
    BOOL fNewBurst = ResetQueuesIfNecessary();

    // Check if we are in overrun state. Discard the packet if it is true.
    // The sound driver needs some time to render existing samples.
    if (m_lTimeDelta > MAX_TIMEDELTA)
    {
        return S_FALSE;
    }

    DWORD dwStartTime = m_dwSpurtStartTime;
    if (!fNewBurst && !pQueue->IsActive())
    {
        // This is a stream just joined, it is scheduled to join mixing
        // at a later slot in order to have some jitter buffering.
        dwStartTime = 
            ((m_dwLastTime - m_dwSpurtStartTime + m_lTotalDelayTime)
            / m_lSampleTime) * m_lSampleTime + m_dwSpurtStartTime;
    }

    // Put the sample into the queue, set the queue's scheduled deliver time
    // and adjustment for each sample.
    pQueue->EnQ(pSample, dwStartTime, m_lSampleTime);

    // After we put the sample in our queue, we can only return S_OK because
    // we have accepted the sample. 

    if (fNewBurst)
    {
        // If this is the first sample after silence, we need to insert some
        // silence to provide some jitter absorbing time.
        if (FAILED(PrePlay()))
        {
            // If we can send silence, just return.
            return S_OK;
        }
    }

    // If there is only one stream, we can send the sample as soon as
    // we get it.
    if (m_cInputPins == 2)
    {
        SendSample();
        return S_OK;
    }

    // If we are ready to mix, get a sample from each queue and mix them.
    // The following "if" statement is derived as follows:
    //
    // (CurrentTime - SpurtStartTime - PlayedTime > SampleTime) triggers mixing
    //
    // delta = JitterBufferTime + PlayedTime - (CurrentTime - SpurtStartTime);
    //
    // ==> (JitterBufferTime - delta > SampleTime) triggers mixing.
    //

    DbgLog((LOG_TRACE, 0x3ff, TEXT("mix trigger: %dms"), 
        m_lTotalDelayTime - m_lTimeDelta - m_lSampleTime));

    HRESULT hr = S_OK;
    while ((m_lTotalDelayTime - m_lTimeDelta - m_lSampleTime > 0)
         && hr == S_OK)
    {
        hr = SendSample();
        DbgLog((LOG_TRACE, 0x3ff, TEXT("mix trigger: %dms"), 
            m_lTotalDelayTime - m_lTimeDelta - m_lSampleTime));
    }

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// Mix one IMediaSample
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CMixer::MixOneSample(
    IMediaSample *pMixedSample, 
    IMediaSample ** ppSample, 
    long lCount
    )
/*++

Routine Description:

    Mix one sample from an array of samples.

Arguments:
    
    pMixedSample - The sample that stores the mixed data.

    ppSample    - The array of samples to be mixed.

    lCount      - The number of samples in the array.

Return Value:

    HRESULT.

--*/
{
    BYTE  *ppBuffer[MAX_QUEUES];
    BYTE  *pMixBuffer;
    HRESULT hr;

    hr = pMixedSample->GetPointer(&pMixBuffer);
    ASSERT(SUCCEEDED(hr));

    for (int i = 0; i < lCount; i ++)
    {
        hr = ppSample[i]->GetPointer(&ppBuffer[i]);
        ASSERT(SUCCEEDED(hr));
    }
        
    long lDataLen = ppSample[0]->GetActualDataLength();
    long lMixBufferSize = pMixedSample->GetSize();

    long lMixDataLen = lDataLen;
    //
    // Mix based on format and sample size
    //
    switch(m_wInputFormatTag)
    {
    case WAVE_FORMAT_PCM:
        if (m_wInputBitsPerSample != m_wOutputBitsPerSample)
        {
            DbgLog((LOG_ERROR, 1, 
                TEXT("sample size mismatch. Input: %d, output: %d"),
                m_wInputBitsPerSample, m_wOutputBitsPerSample
                ));
            return E_FAIL;
        }

        switch(m_wOutputBitsPerSample)
        {
         case 8:
            if (lMixDataLen > lMixBufferSize)
            {
                DbgLog((LOG_ERROR, 1, 
                    TEXT("Sample too big, sample size:%d, buffer size:%d"),
                    lMixDataLen, lMixBufferSize
                    ));
                break;
            }
            MixBuffers<C8Bit, C8Bit>(
                    (C8Bit*)pMixBuffer, 
                    (C8Bit**) (BYTE**) ppBuffer, 
                    lCount, lDataLen
                    );
            break;
        case 16:
            if (lMixDataLen > lMixBufferSize)
            {
                DbgLog((LOG_ERROR, 1, 
                    TEXT("Sample too big, sample size:%d, buffer size:%d"),
                    lMixDataLen, lMixBufferSize
                    ));
                break;
            }
            MixBuffers<C16Bit, C16Bit>(
                    (C16Bit*)pMixBuffer, 
                    (C16Bit**)(BYTE**)ppBuffer,
                    lCount, lDataLen/2
                    );
            break;
        default:
            DbgLog((LOG_ERROR, 1, 
                TEXT("Unknow bits per sample:%d"),
                m_wOutputBitsPerSample
                ));
        }
        break;
    case WAVE_FORMAT_MULAW:
        switch(m_wOutputBitsPerSample)
        {
        case 8:
            if (lMixDataLen > lMixBufferSize)
            {
                DbgLog((LOG_ERROR, 1, 
                    TEXT("Sample too big, sample size:%d, buffer size:%d"),
                    lMixDataLen, lMixBufferSize
                    ));
                break;
            }
            MixBuffers<C8Bit, CuLaw>(
                    (C8Bit*)pMixBuffer, 
                    (CuLaw**)(BYTE**)ppBuffer,
                    lCount, lDataLen
                    );
            break;
        case 16:
            lMixDataLen *= 2;  // change from 8 bits to 16 bits.

            if (lMixDataLen > lMixBufferSize)
            {
                DbgLog((LOG_ERROR, 1, 
                    TEXT("Sample too big, sample size:%d, buffer size:%d"),
                    lMixDataLen, lMixBufferSize
                    ));
                break;
            }
            MixBuffers<C16Bit, CuLaw>(
                    (C16Bit*)pMixBuffer, 
                    (CuLaw**)(BYTE**)ppBuffer,
                    lCount, lDataLen
                    );
            break;
        default:
            DbgLog((LOG_ERROR, 1, 
                TEXT("Unknow bits per sample:%d"),
                m_wOutputBitsPerSample
                ));
        }
        break;
    default:
        DbgLog((LOG_ERROR, 1, 
            TEXT("Unknow format tag:%d"),
            m_wInputFormatTag
            ));
    }

    DbgLog((LOG_TRACE, 6, 
        TEXT("mixed length:%d, buffer size:%d"),
        lMixDataLen, lMixBufferSize
        ));

    hr = pMixedSample->SetActualDataLength(lMixDataLen);
    ASSERT(SUCCEEDED(hr));

    //
    // Release all the buffers
    //
    for (i = 0; i < lCount; i++)
    {
        ppSample[i]->Release();
    }
    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//***************************************************************************//
//*                                                                         *//
//*                         Automagic registration                          *//
//*                                                                         *//
//***************************************************************************//
///////////////////////////////////////////////////////////////////////////////

//
// DllRegisterServer
//
#if !defined(MIXER_IN_DXMRTP)
STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2(TRUE);
}

//
// DllUnregisterServer
//
STDAPI DllUnregisterServer()
{
    return AMovieDllRegisterServer2(FALSE);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\mixer\mxoutput.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       mxoutput.cpp
//
//--------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////////////
//
//         File: mxoutput.cpp
//
//  Description: Implements the output pin
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "mxfilter.h"

WAVEFORMATEX WaveFormats[] = 
{
    {WAVE_FORMAT_PCM,          1,  8000, 16000,   2, 16,  0},
    {WAVE_FORMAT_PCM,          1,  8000,  8000,   1,  8,  0}
};

int g_cWaveFormats = sizeof(WaveFormats) / sizeof(WAVEFORMATEX);

///////////////////////////////////////////////////////////////////////////////
//
// c'tor
//
///////////////////////////////////////////////////////////////////////////////
CMixerOutputPin::CMixerOutputPin(TCHAR *pObjName,
                                CMixer *pMixer,
                                HRESULT *phr,
                                LPCWSTR pPinName)
    : CBaseOutputPin(pObjName, pMixer, pMixer, phr, pPinName)
    , m_pMixer(pMixer)
{
}

///////////////////////////////////////////////////////////////////////////////
//
// Delegate this duty to the filter
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CMixerOutputPin::DecideBufferSize(IMemAllocator * pAlloc,
                                          ALLOCATOR_PROPERTIES * pprop)
{
    return m_pMixer->DecideBufferSize(pAlloc, pprop);
}

///////////////////////////////////////////////////////////////////////////////
//
// We basically know what formats well except however check with the filter
//  in case we need to transform the data.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CMixerOutputPin::CheckMediaType(const CMediaType *pmt)
{
    if (!m_pMixer->MediaTypeKnown()) 
    {
        return E_UNEXPECTED;
    }

    CMediaType &rMediaType = m_pMixer->CurrentMediaType();
    WAVEFORMATEX *pInFormat;
    pInFormat = (WAVEFORMATEX*)rMediaType.Format();

    if (pInFormat == NULL)
    {
        return E_UNEXPECTED;
    }

    // for PCM data, the Mixer doesn't do any conversion, so the input pin's 
    // format is the only format the mixer will output.
    if (pInFormat->wFormatTag == WAVE_FORMAT_PCM)
    {
        if (rMediaType == *pmt)
        {
            return S_OK;
        }
        return E_INVALIDARG;
    }
    

    AM_MEDIA_TYPE mt;
    mt.majortype = MEDIATYPE_Audio;
    mt.subtype = MEDIASUBTYPE_PCM;
    mt.bFixedSizeSamples = TRUE;
    mt.bTemporalCompression = FALSE;
    mt.lSampleSize = 0;
    mt.formattype = FORMAT_WaveFormatEx;
    mt.pUnk = NULL;
    mt.cbFormat = sizeof(WAVEFORMATEX);

    for (int i = 0; i < g_cWaveFormats; i++)
    {
        mt.pbFormat = (BYTE*)&WaveFormats[i];
        if (*pmt == mt)
        {
            return S_OK;
//            return ((CMixer*)m_pFilter)->CheckOutputMediaType(pmt);
        }
    }

    return E_INVALIDARG;
}

///////////////////////////////////////////////////////////////////////////////
//
// This function is called by the enumerator to enumerate all the media types
// the mixer outputs.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CMixerOutputPin::GetMediaType(int iPosition, CMediaType *pMediaType)
{
    ASSERT(pMediaType);

    // if the input is not connected or we don't have so many output formats,
    // just return.
    if (!m_pMixer->MediaTypeKnown() || iPosition > g_cWaveFormats - 1) 
    {
        return S_FALSE;
    }

    CMediaType &rMediaType = m_pMixer->CurrentMediaType();
    WAVEFORMATEX *pInFormat;
    pInFormat = (WAVEFORMATEX*)rMediaType.Format();

    if (pInFormat == NULL)
    {
        return S_FALSE;
    }

    // for PCM data, the Mixer doesn't do any conversion, so the input pin's 
    // format is the only format the mixer will output.
    if (pInFormat->wFormatTag == WAVE_FORMAT_PCM)
    {
        if (iPosition == 0)
        {
            CopyMediaType(pMediaType, &rMediaType);
            return S_OK;
        }
        return S_FALSE;
    }
    
    WAVEFORMATEX *pwf = (WAVEFORMATEX *) 
        pMediaType->AllocFormatBuffer(sizeof(WAVEFORMATEX));

    if (pwf == NULL)
    {
        return S_FALSE;
    }

    memcpy(pwf, &WaveFormats[iPosition], sizeof(WAVEFORMATEX));

    pMediaType->majortype = MEDIATYPE_Audio;
    pMediaType->subtype = MEDIASUBTYPE_PCM;
    pMediaType->bFixedSizeSamples = TRUE;
    pMediaType->bTemporalCompression = FALSE;
    pMediaType->lSampleSize = 0;
    pMediaType->formattype = FORMAT_WaveFormatEx;
    pMediaType->pUnk = NULL;
    pMediaType->cbFormat = sizeof(WAVEFORMATEX);

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// Here is the story: When this filter is connected with only a single input
//  pin this filter should act as like an inplace transform and just pass the
//  buffer on.  In order to support this we should negotiate to use the
//  allocator selected by our input pin (most likely the allocator of the 
//  upstream filter).  Now when we actually need to mix (i.e. to or more input 
//  pins connected) it really doesn't matter if we move the data between 
//  buffers because we need to visit every byte in the buffer anyway.  So in 
//  this case we select the allocator provided by the downstream filter (or our
//  own if it wont provide one.)
//
//  So, you may ask, why not just always select the allocator from the
//  downstream filter and be done with it?  Well the Quartz architectuer
//  specifies that in any negotiation between two filters the output filter
//  has the final say as to who's allocator is used.  Kind of broken for
//  DirectX but I can't fix that.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CMixerOutputPin::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc)
{
    HRESULT hr = NOERROR;
    *ppAlloc = NULL;

    //    
    // get downstream prop request
    // the derived class may modify this in DecideBufferSize, but
    // we assume that he will consistently modify it the same way,
    // so we only get it once
    //
    ALLOCATOR_PROPERTIES prop;
    ZeroMemory(&prop, sizeof(prop));

    //
    // whatever he returns, we assume prop is either all zeros
    // or he has filled it out.
    //
    pPin->GetAllocatorRequirements(&prop);

    //
    // if he doesn't care about alignment, then set it to 1
    //
    if (prop.cbAlign == 0)
    {
        prop.cbAlign = 1;
    }

    //
    // Either there is not exactly 1 input connected or the upstream
    //  filter refused to fork over an allocator.  Try to get one
    //  from downstream.
    //
    hr = pPin->GetAllocator(ppAlloc);
    if (SUCCEEDED(hr))
    {
	    hr = DecideBufferSize(*ppAlloc, &prop);
	    if (SUCCEEDED(hr))
        {
	        hr = pPin->NotifyAllocator(*ppAlloc, FALSE);
	        if (SUCCEEDED(hr))
            {
		        return NOERROR;
	        }
	    }
    }

    //
    // If the above process failed clean it up.
    //
    if (*ppAlloc)
    {
        (*ppAlloc)->Release();
        *ppAlloc = NULL;
    }

    //
    // Failing all of that we provide our own.
    //
    hr = InitAllocator(ppAlloc);
    if (SUCCEEDED(hr)) 
    {
        //
        // note - the properties passed here are in the same
        // structure as above and may have been modified by
        // the previous call to DecideBufferSize
        //
	    hr = DecideBufferSize(*ppAlloc, &prop);
	    if (SUCCEEDED(hr)) 
        {
    	    hr = pPin->NotifyAllocator(*ppAlloc, FALSE);
	        if (SUCCEEDED(hr))
            {
		        return NOERROR;
	        }
	    }
    }

    /* Likewise we may not have an interface to release */
    if (*ppAlloc) 
    {
	    (*ppAlloc)->Release();
	    *ppAlloc = NULL;
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Force all input pins to be reconnected!!!
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CMixerOutputPin::CompleteConnect(IPin *pReceivePin)
{
    HRESULT hr = DecideAllocator(m_pInputPin, &m_pAllocator);
    if (FAILED(hr)) return hr;

#if 0
    //
    // Don't rereconnect.
    //
    if (m_pMixer->m_fReconnect) return hr;

    for (int i = 0; i < m_pMixer->GetPinCount()-1; i++)
    {
        if (m_pMixer->GetInput(i)->IsConnected())
        {
            m_pMixer->m_fReconnect = TRUE;
            hr = m_pMixer->GetFilterGraph()->Reconnect(m_pMixer->GetInput(i));
            m_pMixer->m_fReconnect = FALSE;
            if (FAILED(hr)) return hr;
        }
    }
#endif

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\mixer\queue.cpp ===
//
// queue.cpp
//
// Copyright (C) Microsoft Corporation, 1996 - 1999  All rights reserved.
//

#include <stdafx.h>
#include "queue.h"

///////////////////////////////////////////////////////////////////////////////
//=============================================================================
// CBufferQueue Implementation
//=============================================================================
///////////////////////////////////////////////////////////////////////////////

CBufferQueue::CBufferQueue()
    : m_fEOS(FALSE),
      m_fActive(FALSE),
      m_lCount(0),
      m_lTail(0),
      m_lHead(0),
      m_lDepth(0),
      m_dwStartTime(0),
      m_dwSampleTime(0),
      m_ppBuffers(NULL)
{
    InitializeCriticalSection(&m_CritSec);
}

BOOL CBufferQueue::Initialize(long lDepth)
{
    EnterCriticalSection(&m_CritSec); 
        
    m_ppBuffers = new IMediaSample * [lDepth];

    if (m_ppBuffers == NULL)
    {
        LeaveCriticalSection(&m_CritSec);
        return FALSE;
    }

    ZeroMemory(m_ppBuffers, sizeof(IMediaSample*) * lDepth);

    m_lDepth = lDepth;
    
    LeaveCriticalSection(&m_CritSec);
    return TRUE;
}

//
// CBufferQueue::~CBufferQueue - delete allocated memory
//
CBufferQueue::~CBufferQueue()
{
    EnterCriticalSection(&m_CritSec); 

    Flush();
    delete [] m_ppBuffers;
    
    DeleteCriticalSection(&m_CritSec);
}

void CBufferQueue::EnQ(
    IMediaSample *  pMS, 
    DWORD           dwStartTime, 
    DWORD           dwSampleTime
    )
/*++

Routine Description:

    Store a new sample in the queue. 

Arguments:

    pMS - a pointer to the media sample.

    dwStartTime - The schduled start time for this queue.

    dwSampleTime - The length of the sample measured in ms.

Return Value:

    HRESULT.

--*/
{
    EnterCriticalSection(&m_CritSec); 

    //
    // Validity checks
    //
    ASSERT(m_ppBuffers != NULL);
    ASSERT(pMS);

    //
    // Release a buffer if one is in the way.
    //
    if (m_ppBuffers[m_lTail] != NULL) 
    {
        m_ppBuffers[m_lTail]->Release();

        // addjust the scheduled play time for the first sample in the queue.
        m_dwStartTime += m_dwSampleTime;
    }

    //
    // Put the data in the queue.
    //
    m_ppBuffers[m_lTail] = pMS;
    pMS->AddRef(); // Resease assumed!!!

    if (!m_fActive)
    {
        m_dwStartTime = dwStartTime;
        m_dwSampleTime = dwSampleTime;

        m_fActive = TRUE;
    }

    //
    // Adjust internal data
    //
    m_lTail = (m_lTail + 1) % m_lDepth;

    //
    // Head follows the tail if the Q is full
    //
    if (m_lCount == m_lDepth)
    {
        m_lHead = (m_lHead + 1) % m_lDepth;
    }
    else
    {
        m_lCount++;
    }

    DbgLog((LOG_TRACE, 0x3ff, TEXT("EnQ, Start: %d, Samples: %d"), 
        m_dwStartTime, m_lCount));

    LeaveCriticalSection(&m_CritSec);
}

IMediaSample *CBufferQueue::DeQ(BOOL fAlways, DWORD dwCurrentTime)
/*++

Routine Description:

    Remove the first sample from the queue.

Arguments:

    fAlways - If true, deq immediately, ignoring the time.

    dwCurrentTime  - The current time.

Return Value:

    HRESULT.

--*/
{
    EnterCriticalSection(&m_CritSec); 
    //
    // Validity checks
    //
    ASSERT(m_ppBuffers != NULL);

    DbgLog((LOG_TRACE, 0x3ff, TEXT("DeQ, Current: %d, Start: %d, Samples: %d"), 
        dwCurrentTime, m_dwStartTime, m_lCount));

    if (m_lCount == 0)
    {
        ASSERT(m_lHead == m_lTail);

        m_fActive = FALSE; // We don't have continous samples.

        LeaveCriticalSection(&m_CritSec);
        return NULL;
    }

    if (!fAlways 
        && m_dwStartTime != dwCurrentTime 
        && m_dwStartTime - dwCurrentTime < (ULONG_MAX >> 2)) //handle wrapping.
    {
        // The time has not come for this queue to deliver.
        LeaveCriticalSection(&m_CritSec);
        return NULL;
    }

    //
    // Remove Buffer
    //
    IMediaSample *pMS = m_ppBuffers[m_lHead];
    ASSERT(pMS);

    m_ppBuffers[m_lHead] = NULL;

    // addjust the start time after we removed the buffer.
    m_dwStartTime += m_dwSampleTime;

    //
    // Adjust internal data
    //
    m_lCount --;
    
    m_lHead = (m_lHead + 1) % m_lDepth;

    LeaveCriticalSection(&m_CritSec);
    return pMS;
}

//
// Flush all the samples out of the queue.
//
void CBufferQueue::Flush()
{
    EnterCriticalSection(&m_CritSec); 

    for (int i = 0; i < m_lCount; i ++)
    {
        m_ppBuffers[m_lHead]->Release();
        m_ppBuffers[m_lHead] = NULL;
        m_lHead = (m_lHead + 1) % m_lDepth;
    }

    m_lHead = m_lTail = m_lCount = 0;
    m_dwStartTime = m_dwSampleTime = 0;
    m_fActive = FALSE;

    LeaveCriticalSection(&m_CritSec);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\mixer\mxinput.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       mxinput.cpp
//
//--------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////////////
//
//         File: mxinput.cpp
//
//  Description: implements the input pin
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "mxfilter.h"

///////////////////////////////////////////////////////////////////////////////
//
// CMixerInputPin constructor
//
///////////////////////////////////////////////////////////////////////////////
CMixerInputPin::CMixerInputPin(
        TCHAR *     pObjName,
        CMixer *    pMixer,
        HRESULT *   phr,
        LPCWSTR     pPinName,
        int         iPin,
        CBufferQueue *pQueue
        )
    : CBaseInputPin(pObjName, pMixer, pMixer, phr, pPinName)
    , m_pQueue(pQueue)
    , m_pMixer(pMixer)
    , m_cOurRef(0)
    , m_iPinNumber(iPin)
{
    ASSERT(pMixer);
}

///////////////////////////////////////////////////////////////////////////////
//
// CompleteConnect
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CMixerInputPin::CompleteConnect(IPin *pReceivePin)
{
    ASSERT(pReceivePin != NULL);
    HRESULT hr;

    hr = CBaseInputPin::CompleteConnect(pReceivePin);
    if (FAILED(hr)) return hr;

    hr = m_pMixer->CompleteConnect();
    if (FAILED(hr)) return hr;

    // Try to generate a new pin for the next connection. 
    // Ignore the return code.
    m_pMixer->SpawnNewInput();

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// Cleanup the connection
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CMixerInputPin::Disconnect()
{
    HRESULT hr = m_pMixer->DisconnectInput();
    if (FAILED(hr)) return hr;
    
    return CBaseInputPin::Disconnect();
}

///////////////////////////////////////////////////////////////////////////////
//
// If the mixer does not have an allocator then we are probably using the
//  allocator of the upstream filter.  So when were asked what our requirements
//  first get the downstream requirements then add ours.
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CMixerInputPin::GetAllocatorRequirements(ALLOCATOR_PROPERTIES *pProps)
{
    if (pProps == NULL) return E_POINTER;

#if 0
    if (m_pMixer->m_pAllocator == NULL)
#endif
    {
        if (m_pMixer->GetOutput()->IsConnected())
        {
            m_pMixer->GetOutput()->
                GetIMemInputPin()->GetAllocatorRequirements(pProps);
        }
    }
#if 0
    else
    {
        //
        // If the mixer has an allocator then we get our requirements from input
        //  pin0.  We don't do any translation in order to mix!!!!!!!!!!!!!!!!!!
        //
        if (m_pMixer->GetInput0()->IsConnected() && m_pMixer->GetInput0()->m_pAllocator != NULL)
        {
            m_pMixer->GetInput0()->m_pAllocator->GetProperties(pProps);
        }
    }            
#endif
    if (pProps->cbBuffer == 0) { pProps->cbBuffer = 1; }
    pProps->cBuffers += MAX_QUEUE_STORAGE + 1;
    
    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
// Receive - the meat of the matter
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CMixerInputPin::Receive(IMediaSample * pSample)
{
    //
    // Store the sample and either mix or wait for more data.
    //
    DbgLog((LOG_TRACE, 0xF, TEXT("InputPin(%d)::Receive - queueing packet."), m_iPinNumber));
    if (m_pQueue->IsEOS())
    {
        return E_FAIL;
    }
    return m_pMixer->Receive(m_pQueue, pSample);
}

///////////////////////////////////////////////////////////////////////////////
//
// NonDelegatingAddRef
//
// We need override this method so that we can do proper reference counting
// on our Input pin. The base class CBasePin does not do any reference
// counting on the pin in RETAIL.
//
// Please refer to the comments for the NonDelegatingRelease method for more
// info on why we need to do this.
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CMixerInputPin::NonDelegatingAddRef()
{
    CAutoLock lock_it(m_pLock);

#ifdef DEBUG
    // Update the debug only variable maintained by the base class
    m_cRef++;
    ASSERT(m_cRef > 0);
#endif

    // Now update our reference count
    m_cOurRef++;
    ASSERT(m_cOurRef > 0);
    return m_cOurRef;
}

///////////////////////////////////////////////////////////////////////////////
//
// NonDelegatingRelease
//
// CMixerInputPin overrides this class so that we can take the pin out of our
// Input pins list and delete it when its reference count drops to 1 and there
// is atleast two free pins.
//
// Note that CreateNextInputPin holds a reference count on the pin so that
// when the count drops to 1, we know that no one else has the pin.
//
// Moreover, the pin that we are about to delete must be a free pin(or else
// the reference would not have dropped to 1, and we must have atleast one
// other free pin(as the filter always wants to have one more free pin)
//
// Also, since CBasePin::NonDelegatingAddRef passes the call to the owning
// filter, we will have to call Release on the owning filter as well.
//
// Also, note that we maintain our own reference count m_cOurRef as the m_cRef
// variable maintained by CBasePin is debug only.
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CMixerInputPin::NonDelegatingRelease()
{
    CAutoLock lock_it(m_pLock);

#ifdef DEBUG
    // Update the debug only variable in CBasePin
    m_cRef--;
    ASSERT(m_cRef >= 0);
#endif

    // Now update our reference count
    m_cOurRef--;
    ASSERT(m_cOurRef >= 0);

    // if the reference count on the object has gone to one, remove
    // the pin from our Input pins list and physically delete it
    // provided there are atealst two free pins in the list(including
    // this one)

    // Also, when the ref count drops to 0, it really means that our
    // filter that is holding one ref count has released it so we
    // should delete the pin as well.

    if (m_cOurRef <= 1)
    {
        int n = 2;                     // default forces pin deletion
        if (m_cOurRef == 1)
        {
            // Walk the list of pins, looking for count of free pins
            n = m_pMixer->GetFreePinCount();
        }

        // If there are two free pins, delete this one.
        // NOTE: normall
        if (n >= 2 )
        {
            m_cOurRef = 0;
#ifdef DEBUG
            m_cRef = 0;
#endif
            m_pMixer->DeleteInputPin(this, m_pQueue);
            return(ULONG) 0;
        }
    }
    return(ULONG) m_cOurRef;
}

///////////////////////////////////////////////////////////////////////////////
//
// When we receive EOS we must queue it along with our data.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CMixerInputPin::EndOfStream(void)
{
    HRESULT hr = NOERROR;
    
    m_pQueue->QueueEOS();
    m_pMixer->FlushQueue(m_pQueue);

    BOOL fAllEOS = TRUE;

    for (int i = 0; i < m_pMixer->GetInputPinCount(); i++)
    {
        if (m_pMixer->GetInput(i)->IsConnected() && !m_pMixer->GetInput(i)->m_pQueue->IsEOS())
        {
            fAllEOS = FALSE;
            break;
        }
    }

    if (fAllEOS)
    {
        m_pMixer->GetOutput()->DeliverEndOfStream();
    }

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// block receives -- done by caller (CBaseInputPin::BeginFlush)
// discard queued data -- we have no queued data
// free anyone blocked on receive - not possible in this filter
// call downstream (if we're input0)
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CMixerInputPin::BeginFlush(void)
{
    HRESULT hr;
    hr = CBaseInputPin::BeginFlush();
    if (FAILED(hr)) return hr;
    m_pMixer->FlushQueue(m_pQueue);
    if (m_pMixer->GetInput0() == this)
    {
	    hr = m_pMixer->GetOutput()->DeliverBeginFlush();
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// sync with pushing thread -- we have no worker thread
// ensure no more data to go downstream -- we have no queued data
// call EndFlush on downstream pins
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CMixerInputPin::EndFlush(void)
{
    HRESULT hr;
    hr = CBaseInputPin::EndFlush();
    if (FAILED(hr)) return hr;

    if (m_pMixer->GetInput0() == this)
    {
        hr = m_pMixer->GetOutput()->DeliverEndFlush();
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Make sure to flush the queue when we're shut off.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CMixerInputPin::Inactive()
{
    m_pMixer->FlushQueue(m_pQueue);
    return CBaseInputPin::Inactive();
}

///////////////////////////////////////////////////////////////////////////////
//
// Make sure to flush the queue when we're shut off.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CMixerInputPin::Active()
{
    m_pQueue->ResetEOS();
    return CBaseInputPin::Active();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\mixer\template.h ===
/*********************************************************************
 *
 * Copyright (C) Microsoft Corporation, 1997 - 1999
 *
 * File: mixer\template.h
 *
 * Abstract:
 *     Macros to define CFactoryTemplate templates
 *
 * History:
 *     10/29/97    Created by AndresVG
 *
 **********************************************************************/
#if !defined(_MIXER_TEMPLATE_H_)
#define      _MIXER_TEMPLATE_H_

#define LMIXER_FILTER_NAME L"Microsoft PCM Audio Mixer"

extern AMOVIESETUP_FILTER sudMixer;

#define CFT_MIXER_FILTER \
{ \
	  LMIXER_FILTER_NAME, \
	  &CLSID_AudioMixFilter, \
	  CMixer::CreateInstance, \
	  NULL, \
	  &sudMixer \
	  }

#define CFT_MIXER_ALL_FILTERS \
CFT_MIXER_FILTER

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\mixer\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////////////
//
//         File: stdafx.cpp
//
//  Description: Precompiled cpp
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\mixer\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////////////
//
//         File: stdafx.h
//
//  Description: precompiled header for mixer filter.
//
///////////////////////////////////////////////////////////////////////////////

#include <limits.h> // ULONG_MAX
#include <streams.h>
#include <mmreg.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\bitstrm.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: bitstrm.h
//  Abstract:    header file. a data structure for maintaining a pool of memory.
//	Environment: MSVC 4.0
/////////////////////////////////////////////////////////////////////////////////
//
// Defines class CBitstream, a utility for parsing buffers at the bit level.
/////////////////////////////////////////////////////////////////////////////////

// $Header:   R:/rtp/src/ppm/bitstrm.h_v   1.1   28 Jan 1997 16:28:18   CPEARSON  $

#ifndef _BITSTRM_H_
#define _BITSTRM_H_


///////////////////////////////////////////////////////////////////////////////
// GetBitsMask(): Return mask to isolate bits 0 through dwBits
///////////////////////////////////////////////////////////////////////////////
inline DWORD GetBitsMask(DWORD dwBits)
{
	// This function implements an optimization of this statement:
	//
	//   return 0xffffffffUL >> (32 - dwBits);

	static const DWORD adwMask[33] =
	{
		0x00000000, 0x00000001, 0x00000003, 0x00000007,
		0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f,
		0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff,
		0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff,
		0x0000ffff, 0x0001ffff, 0x0003ffff, 0x0007ffff,
		0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff,
		0x00ffffff, 0x01ffffff, 0x03ffffff, 0x07ffffff,
		0x0fffffff, 0x1fffffff, 0x3fffffff, 0x7fffffff,
		0xffffffff
	};

	return adwMask[dwBits];
}

///////////////////////////////////////////////////////////////////////////////
// class CBitstream: A manipulator for returning a stream of bits from a
// memory buffer.  This is defined here only because there are currently no
// other clients.
///////////////////////////////////////////////////////////////////////////////
class CBitstream
{
	static DWORD			s_dwIgnore; // default arg to throw away bits

	const unsigned char*	m_puchBuffer;	// buffer traversal pointer
	DWORD					m_dwWork;		// last byte accessed
	unsigned int			m_nBitsReady;	// number bits remaining in last byte

public:

	CBitstream(const void* pBuffer) :
		m_puchBuffer((unsigned char*) pBuffer),
		m_dwWork(0),
		m_nBitsReady(0)
	{;}

	DWORD getFixedBits(unsigned int nBits)
	{
		while (m_nBitsReady < nBits)
		{
			m_dwWork <<= 8;
			m_nBitsReady += 8;
			m_dwWork |= *m_puchBuffer++;
		}

		// setup m_nBitsReady for next time
		m_nBitsReady -= nBits;

		DWORD dwResult = (m_dwWork >> m_nBitsReady);

		m_dwWork &= GetBitsMask(m_nBitsReady);

		return dwResult;
	}

	void getNextBit(DWORD& dwResult = s_dwIgnore)
	{
		// Shift result left and OR in next bit.
		dwResult = (dwResult << 1) | getFixedBits(1);
	}

};

#endif // _BITSTRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\connect.h ===
/*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1996 Intel Corporation. All Rights Reserved.
//
// Filename : Connectable.h
// Purpose  : Header file for a 
// Contents :
//      bGUIDLess   Comparator class to use in STL map data structure.
//      CConnectionPointContainerEnumerator
//                  Enumerator class for use with connection point
//                  container's supported connection points.
//      CConnectionPointContainer
//                  Class declaration for generic connection point
//                  container.
*M*/

#ifndef _CONNECT_H_
#define _CONNECT_H_

#include <list.h>		//STL
#include <algo.h>
#include <olectl.h>

class CConnectionPointContainer; 
// Predeclaration for use in CConnectionPoint.


class
CConnectionPointEnumerator:
    public IEnumConnections
{
    // Interfaces
    public:
        // IEnumConnections interfaces
        HRESULT _stdcall Next(
            ULONG                       cConnections,
            PCONNECTDATA                pConnectData,
            ULONG                       *pcFetched);	
        HRESULT _stdcall Skip(
            ULONG                       uSkipCount);	
        HRESULT _stdcall Reset(void);
        HRESULT _stdcall Clone(
            IEnumConnections            **ppEnum);

        // IUnknown Interfaces
	    HRESULT _stdcall QueryInterface(REFIID riid, void** ppObject);
	    ULONG   _stdcall AddRef(void);
	    ULONG   _stdcall Release(void);

    // Implementation
    public:
        CConnectionPointEnumerator(
            list<CONNECTDATA>&          lConnectList,
            list<CONNECTDATA>::iterator iConnectListCurrentPosition);
        ~CConnectionPointEnumerator();

    private:
        CRITICAL_SECTION                m_csState;
        DWORD                           m_dwRefCount;
        list<CONNECTDATA>&              m_lConnectList;
        list<CONNECTDATA>::iterator     m_iConnectListCurrentPosition;
}; /* class CConnectionPointEnumerator() */


class
CConnectionPoint :
    public IConnectionPoint
{
    // Interfaces
    public:
        // IConnectionPoint
        HRESULT _stdcall GetConnectionInterface(
            IID                         *pIConnection);
        HRESULT _stdcall GetConnectionPointContainer(
            IConnectionPointContainer   **ppIConnPtContainer);
        HRESULT _stdcall Advise(
            IUnknown                    *pIUnknownSink,
            DWORD                       *dwCookie);
        HRESULT _stdcall Unadvise(
            DWORD                       dwCookie);
        HRESULT _stdcall EnumConnections(
            IEnumConnections            **ppIEnumConnections);

        // IUnknown Interfaces
	    HRESULT _stdcall QueryInterface(REFIID riid, void** ppObject);
	    ULONG   _stdcall AddRef(void);
	    ULONG   _stdcall Release(void);

    // Implementation
    public:
        CConnectionPoint(
            CConnectionPointContainer   *pContainer,
            IID                         riid);
        ~CConnectionPoint();
        HRESULT SetContainer(
            CConnectionPointContainer   *pContainer);

    private:
        CRITICAL_SECTION                m_csState;
        DWORD                           m_dwCookie;
        DWORD                           m_dwRefCount;
        IID                             m_iIID;
        CConnectionPointContainer       *m_pContainer;
        list<CONNECTDATA>               m_lConnectList;
}; /* class CConnectionPoint */


/*D*
//  Name    : IConnectionPointList_t
//  Purpose : A list of connection point interfaces supported
//            by a particular Connection Point Container.
*D*/
typedef list<IConnectionPoint *> IConnectionPointList_t;


class
CConnectionPointContainerEnumerator :
    public IEnumConnectionPoints
{
    // Interfaces
    public:
        // IEnumConnectionPoints interfaces
        HRESULT _stdcall Next(
            ULONG                       uPointsToReturn,
            IConnectionPoint            **ppCPArray,
            ULONG                       *puPointsReturned);
        HRESULT _stdcall Skip(
            ULONG                       uSkipCount);
        HRESULT _stdcall Reset(void);
        HRESULT _stdcall Clone(
            IEnumConnectionPoints       **ppIEnumConnPoints);

        // IUnknown Interfaces
		HRESULT _stdcall QueryInterface(REFIID riid, void** ppObject);
		ULONG   _stdcall AddRef(void);
		ULONG   _stdcall Release(void);

    // Implementation
    public:
        CConnectionPointContainerEnumerator(
            IUnknown                            *pIUnknownParent,
            IConnectionPointList_t              IConnectionPointList,
            IConnectionPointList_t::iterator    iConnectionPointListPosition);
        ~CConnectionPointContainerEnumerator();
    private:
        CRITICAL_SECTION                    m_csState;
        IUnknown                            *m_pIUnknownParent;
        IConnectionPointList_t              m_IConnectionPointList;
        IConnectionPointList_t::iterator    m_iConnectionPointListPosition;

        DWORD                               m_dwRefCount;
}; /* class CConnectionPointContainerEnumerator() */


class
CConnectionPointContainer :
    public IConnectionPointContainer
{
    // Interfaces
    public:
        // IConnectionPointContainer interfaces
        HRESULT _stdcall EnumConnectionPoints(
            IEnumConnectionPoints       **ppIEnumConnPoints);
        HRESULT _stdcall FindConnectionPoint(
            REFIID                      rConnPointIID,
            IConnectionPoint            **ppIConnectionPoint);

        // IUnknown Interfaces
		HRESULT _stdcall QueryInterface(REFIID riid, void** ppObject) 
            {return m_pIParentUnknown->QueryInterface(riid, ppObject);}
		ULONG   _stdcall AddRef(void) {return m_pIParentUnknown->AddRef();}
		ULONG   _stdcall Release(void) {return m_pIParentUnknown->Release();}

    // Implementation
    public:
        HRESULT AddConnectionPoint(
            IUnknown                    *pINewConnectionPoint);
        CConnectionPointContainer();
        ~CConnectionPointContainer();
        HRESULT SetUnknown(
            IUnknown                    *pIParentUnknown);

    private:
        friend class CConnectionPointContainerEnumerator;

        CRITICAL_SECTION        m_csState;
        IConnectionPointList_t  m_lConnectionPointList;
        IUnknown                *m_pIParentUnknown;
}; /* class CConnectionPointContainer */

#endif _CONNECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\connect.cpp ===
/*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1996 Intel Corporation. All Rights Reserved.
//
// Filename : Connect.cpp
// Purpose  : Implementation file for a bunch of objects used
//            to generically implement connection points.
// Contents :
*M*/

#ifndef _CONNECT_CPP_
#define _CONNECT_CPP_

#include "connect.h"
#include <wtypes.h>

// These GIUDs are defined in uuid.lib for C++ 4.2, but not in C++ 4.1 or
// earlier.  Add them here for Data Router.
#if _MSC_VER < 1020
static const GUID IID_IConnectionPointContainer =
{0xB196B284,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07};
static const GUID IID_IEnumConnectionPoints =
{0xB196B285,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07};
static const GUID IID_IConnectionPoint =
{0xB196B286,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07};
static const GUID IID_IEnumConnections =
{0xB196B287,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07};
#endif

#include "autolock.h"

/*F*
//  Name    : CConnectionPointEnumerator::AddRef
//  Purpose : Increment the reference count for this object.
//  Context : Called by any program which wants to ensure
//            that this object isn't destroyed before it
//            says it is done with it (via Release(), below.)
//            Called implicitly when a program successfully
//            calls our QueryInterface() method.
//  Returns : Current number of references held for this
//            object.
//  Params  : None.
//  Notes   : Standard COM method.
*F*/
ULONG 
CConnectionPointEnumerator::AddRef() {
    CAutoLock l(&m_csState);
	m_dwRefCount++;
	return m_dwRefCount;
} /* CConnectionPointEnumerator::AddRef() */


/*F*
//  Name    : CConnectionPointEnumerator::CConnectionPointEnumerator()
//  Purpose :
//  Context :
//  Returns :
//  Params  :
//      iConnectList                Reference to the list we are using.
//      iConnectListCurrentPosition Iterator that indicates the
//                                  entry in our connection list we
//                                  are currently indicating.
//  Notes   :
*F*/
CConnectionPointEnumerator::CConnectionPointEnumerator(
    list<CONNECTDATA>&          lConnectList,
    list<CONNECTDATA>::iterator iConnectListCurrentPosition) :
m_lConnectList(lConnectList),
m_iConnectListCurrentPosition(iConnectListCurrentPosition),
m_dwRefCount(0)
{
    InitializeCriticalSection(&m_csState);
} /* CConnectionPointEnumerator::CConnectionPointEnumerator() */


/*F*
//  Name    : CConnectionPointEnumerator::~CConnectionPointEnumerator()
//  Purpose :
//  Context :
//  Returns :
//  Params  :
//  Notes   :
*F*/
CConnectionPointEnumerator::~CConnectionPointEnumerator()
{
    EnterCriticalSection(&m_csState);
    LeaveCriticalSection(&m_csState);
    DeleteCriticalSection(&m_csState);
} /* CConnectionPointEnumerator::CConnectionPointEnumerator() */


/*F*
//  Name    : CConnectionPointEnumerator::Clone()
//  Purpose :
//  Context :
//  Returns :
//  Params  :
//  Notes   :
*F*/
HRESULT
CConnectionPointEnumerator::Clone(
    IEnumConnections                **ppEnum)
{
    CAutoLock l(&m_csState);
    CConnectionPointEnumerator *pNewConnPtEnum;
    pNewConnPtEnum = new CConnectionPointEnumerator(m_lConnectList,
                                                    m_iConnectListCurrentPosition);
    if (pNewConnPtEnum == (CConnectionPointEnumerator *) NULL) {
        return E_OUTOFMEMORY;
    } /* if */

    HRESULT hErr;
    hErr = pNewConnPtEnum->QueryInterface(IID_IEnumConnections,
                                          (PVOID *) ppEnum);
    if (FAILED(hErr)) {
        delete pNewConnPtEnum;
    } /* if */

    return hErr;
} /* CConnectionPointEnumerator::Clone() */


/*F*
//  Name    : CConnectionPointEnumerator::Next
//  Purpose : 
//  Context : 
//  Params  : 
//      E_POINTER   Invalid pcFetched parameter passed in.
//      NOERROR     Successfully created & returned enumerator.
//      S_FALSE     No more connection points to return.
//  Returns : 
//  Notes   : None.
*F*/
HRESULT
CConnectionPointEnumerator::Next(
    ULONG                       cConnections,
    PCONNECTDATA                pConnectData,
    ULONG                       *pcFetched)
{
    CAutoLock l(&m_csState);
    if (IsBadWritePtr(pConnectData, cConnections * sizeof(CONNECTDATA))) {
        return E_POINTER;
    } /* if */

    ULONG uTempCounter;
    if ((cConnections == 1) && (pcFetched == (ULONG *) NULL)) {
        // NULL is allowed to be passed in the pcFetched parameter
        // when cConnections is 1, so rather than writing funny logic
        // to worry about it I'll just create a temporary local to 
        // use instead.
        pcFetched = &uTempCounter;
    } /* if */

    *pcFetched = 0;
    while ((cConnections > 0) && (m_iConnectListCurrentPosition != m_lConnectList.end())) {
        *pConnectData++ = *m_iConnectListCurrentPosition;
        (*pcFetched)++;
        m_iConnectListCurrentPosition++;
        cConnections--;
    } /* while */

    if (*pcFetched > 0) {
        // Successfully returned something.
        return NOERROR;
    } else {
        // Nothing returned.
        return S_FALSE;
    } /* if */
} /* CConnectionPointEnumerator::Next() */


/*F*
//  Name    : CConnectionPointEnumerator::QueryInterface
//  Purpose : Query us for our IConnectionPoint interface. 
//  Context : 
//  Returns : NOERROR if interface successfully found.
//            E_NOINTERFACE otherwise.
//  Params  :
//      riid    IID of the desired interface
//      ppv     Pointer to a VOID * to store the
//              returned interface in.
//  Notes   : Implicitly AddRef()s this object on success.
*F*/
STDMETHODIMP
CConnectionPointEnumerator::QueryInterface(
    REFIID  riid,
    void    **ppv)
{
    CAutoLock l(&m_csState);
    if (riid == IID_IEnumConnections) {
        // Our own interface
        *ppv = (IEnumConnections *) this;
    } else if (riid == IID_IUnknown) {
        *ppv = (IUnknown *) this;
    } else {
        return E_NOINTERFACE;
    } /* if */

    AddRef();
    // Implicit AddRef(). The Release() must be explicitly done
    // by the routine that called QueryInterface().
    return NOERROR;
} /* CConnectionPointEnumerator::QueryInterface() */


/*F*
//  Name    : CConnectionPointEnumerator::Release
//  Purpose : Decrement the reference count for this object.
//  Context : Called by any program which holds a reference
//            to this object which no longer needs it.
//  Returns : Current reference count.
//  Params  : None.
//  Notes   : Should be called once for each AddRef()
//            a program makes and once for each successful
//            QueryInterface() a program made on us.
*F*/
ULONG 
CConnectionPointEnumerator::Release() {
    EnterCriticalSection(&m_csState);
	m_dwRefCount--;

    if (m_dwRefCount==0) {
        LeaveCriticalSection(&m_csState);
		delete this;
		return 0;
		}
    LeaveCriticalSection(&m_csState);
	return m_dwRefCount;
} /* CConnectionPointEnumerator::Release() */


/*F*
//  Name    : CConnectionPointEnumerator::Reset
//  Purpose : Start the enumerator at the beginning of the
//            connection point list again.
//  Context : Any point after construction.
//  Returns : 
//      NOERROR Successfully reset enumerator.
//  Params  : None.
//  Notes   : None.
*F*/
HRESULT
CConnectionPointEnumerator::Reset(void)
{
    CAutoLock l(&m_csState);
    m_iConnectListCurrentPosition = m_lConnectList.begin();
    return NOERROR;
} /* CConnectionPointEnumerator::Reset() */


/*F*
//  Name    : CConnectionPointEnumerator::Skip
//  Purpose : Skip forward over the specified number of connection points.
//  Context : 
//  Params  : 
//      uSkipCount  Number of connection points to skip.
//  Returns : 
//      NOERROR     Successfully created & returned enumerator.
//  Notes   : None.
*F*/
HRESULT
CConnectionPointEnumerator::Skip(
    ULONG                       uSkipCount)
{
    CAutoLock l(&m_csState);
    while ((uSkipCount > 0) && (m_iConnectListCurrentPosition != m_lConnectList.end())) {
        m_iConnectListCurrentPosition++;
        uSkipCount--;
    } /* while */

    return NOERROR;
} /* CConnectionPointEnumerator::Skip() */


/*F*
//  Name    : CConnectionPoint::CConnectionPoint()
//  Purpose : Constructor. Initializes variables and adds us
//            to our connection point container.
//  Context : Called at construction time, usually when
//            a server is just initializing.
//  Returns : Nothing.
//  Params  :
//      pConnptContainer    Pointer to the connection point
//                          container which we belong to.
//      riid                IID of the interface that
//                          this connection point represents.
//  Notes   :
//      If AddConnectionPoint() fails, we are dead in the water.
//      We should change this later to throw an exception. FIX.
*F*/
CConnectionPoint::CConnectionPoint(
    CConnectionPointContainer       *pConnPtContainer,
    IID                             riid) :
m_dwCookie(1),
m_dwRefCount(0),
m_pContainer(pConnPtContainer),
m_iIID(riid)
{
    InitializeCriticalSection(&m_csState);
    CAutoLock l(&m_csState);

    if (m_pContainer != (CConnectionPointContainer *) NULL) {
        m_pContainer->AddConnectionPoint((IUnknown *) this);
    } /* if */
} /* CConnectionPoint::CConnectionPoint() */


/*F*
//  Name    : CConnectionPoint::~CConnectionPoint()
//  Purpose : Destructor. 
//  Context : Called at destruction time.
//  Returns : Nothing.
//  Params  :
//  Notes   :
*F*/
CConnectionPoint::~CConnectionPoint()
{
    EnterCriticalSection(&m_csState);
    // Try to grab the critical section to ensure that nobody else has it.
    LeaveCriticalSection(&m_csState);
    // Can't delete it while we hold it, so release it just before deletion.
    DeleteCriticalSection(&m_csState);
    // Pray for no context switch - as far as I can see, there isn't
    // anything we can do about one occurring. We just have to assert
    // that the application doesn't cause us to be destroyed while still using us.
} /* CConnectionPoint::~CConnectionPoint() */


/*F*
//  Name    : CConnectionPoint::SetContainer()
//  Purpose : Allows the connection point container for this cp to be
//            set after construction. Fail if it has been previously set.
//  Context : Called before this connection point is used for
//            anything which involves its container.
//  Returns :
//      NOERROR         Successfully recorded container.
//      E_UNEXPECTED    Container previously set.
//      E_INVALIDARG    Invalid pContainer parameter.
//  Params  :
//      pContainer  Pointer to the container to use for this cp.
//  Notes   :
*F*/
HRESULT 
CConnectionPoint::SetContainer(
    CConnectionPointContainer   *pContainer)
{
    CAutoLock l(&m_csState);
    if (IsBadReadPtr((PVOID) pContainer, sizeof(CConnectionPointContainer *))) {
        // Bogus container passed in.
        return E_INVALIDARG;
    } /* if */

    if (m_pContainer != (CConnectionPointContainer *) NULL) {
        // Connection point container previously set.
        return E_UNEXPECTED;
    } /* if */

    m_pContainer = pContainer;
    m_pContainer->AddConnectionPoint((IUnknown *) this);
    return NOERROR;
} /* CConnectionPoint::SetContainer() */


/*F*
//  Name    : CConnectionPoint::AddRef
//  Purpose : Increment the reference count for this object.
//  Context : Called by any program which wants to ensure
//            that this object isn't destroyed before it
//            says it is done with it (via Release(), below.)
//            Called implicitly when a program successfully
//            calls our QueryInterface() method.
//  Returns : Current number of references held for this
//            object.
//  Params  : None.
//  Notes   : Standard COM method.
*F*/
ULONG 
CConnectionPoint::AddRef() {
    CAutoLock l(&m_csState);
	m_dwRefCount++;
	return m_dwRefCount;
} /* CConnectionPoint::AddRef() */


/*F*
//  Name    : CConnectionPoint::Advise
//  Purpose : Add a new sink to this connection point.
//  Context : Called by the application which wishes to
//            receive callbacks from this connection point.
//            We will query the callback interface from the
//            application, AddRef() it, and hand back a cookie.
//  Returns :
//      NOERROR         Successfully setup connection
//      E_NOINTERFACE   The application doesn't support the
//                      interface that we expect to callback into.
//      E_INVALIDARG    Bogus pIUnknown or pdwCookie passed in.
//  Params  :
//      pIUnknownSink   Pointer to an IUnknown of the application.
//                      Used to query for the interface we callback into.
//      pdwCookie       Out parameter used to hand a cookie back to
//                      the app that represents this connection.
//                      We put the interator to our list of connections
//                      there to allow constant time access during 
//                      the Unadvise() call that occurs later on.
//  Notes   :
//      No need to release pIUnknownSink because its scope
//          is known to be encapsulated for the life of this function,
//          so the called did not addref it before passing it to us.
*F*/
HRESULT
CConnectionPoint::Advise(
    IUnknown                    *pIUnknownSink,
    DWORD                       *pdwCookie)
{
    CAutoLock l(&m_csState);
    HRESULT hErr;

    if (IsBadReadPtr((PVOID) pIUnknownSink, sizeof(IUnknown *)) ||
        IsBadWritePtr((PVOID) pdwCookie, sizeof(DWORD))) {
        return E_INVALIDARG;
    } /* if */

    IUnknown *pIClient;
    hErr = pIUnknownSink->QueryInterface(m_iIID,
                                         (PVOID *) &pIClient);
    if (FAILED(hErr)) {
        return hErr;
    } /* if */

    CONNECTDATA sNewConnectData;
    sNewConnectData.pUnk = pIUnknownSink;
    sNewConnectData.dwCookie = m_dwCookie++;
    *pdwCookie = sNewConnectData.dwCookie;

    m_lConnectList.push_back(sNewConnectData);
    return NOERROR;
} /* CConnectionPoint::Advise() */


/*F*
//  Name    : CConnectionPoint::EnumConnections()
//  Purpose : Return an enumerator to look at what connections we have made.
//  Context :
//  Returns :
//      NOERROR         Successfully created & returned enumerator.
//      E_OUTOFMEMORY   Insufficient memory to create enumerator.
//  Params  :
//      ppIEnumConnections  Parameter to return enumerator interface pointer in.
//  Notes   :
*F*/
HRESULT
CConnectionPoint::EnumConnections(
    IEnumConnections    **ppIEnumConnections)
{
    CAutoLock l(&m_csState);
    CConnectionPointEnumerator *pNewConnPtEnum;
    pNewConnPtEnum = new CConnectionPointEnumerator(m_lConnectList, m_lConnectList.begin());
    if (pNewConnPtEnum == (CConnectionPointEnumerator *) NULL) {
        return E_OUTOFMEMORY;
    } /* if */

    HRESULT hErr;
    hErr = pNewConnPtEnum->QueryInterface(IID_IEnumConnections,
                                          (PVOID *) ppIEnumConnections);
    if (FAILED(hErr)) {
        delete pNewConnPtEnum;
    } /* if */

    return hErr;
} /* CConnectionPoint::EnumConnections() */


/*F*
//  Name    :
//  Purpose :
//  Context :
//  Returns :
//  Params  :
//  Notes   :
*F*/
HRESULT
CConnectionPoint::GetConnectionInterface(
    IID *pIConnection)
{
    CAutoLock l(&m_csState);
    *pIConnection = m_iIID;
    return NOERROR;
} /* CConnectionPoint::GetConnectionInterface() */


/*F*
//  Name    : CConnectionPoint::GetConnectionPointContainer()
//  Purpose : Return the connection point container that owns this cp.
//  Context : Called by the app when looking for our container (duh).
//  Returns :
//      E_UNEXPECTED    Connection point container for this
//                      connection point hasn't been
//      NOERROR         Successfully returned the connection point container
//                      interface, AddRef()ed.
//  Params  : 
//      ppIConnPtcontainer  Pointer to the connection point container
//                          that is to be returned.
//  Notes   :
*F*/
HRESULT
CConnectionPoint::GetConnectionPointContainer(
    IConnectionPointContainer   **ppIConnPtContainer)
{
    CAutoLock l(&m_csState);
    HRESULT hErr;
    if (m_pContainer != (CConnectionPointContainer *) NULL) {
        // Return an AddRef()ed interface pointer.
        hErr = m_pContainer->QueryInterface(IID_IConnectionPointContainer,
                                            (PVOID *) ppIConnPtContainer);
        return hErr;
    } else {
        // Our connection point container hasn't been set yet
        // via our constructor or via SetContainer().
        return E_UNEXPECTED;
    } /* if */
} /* CConnectionPoint::GetConnectionPointContainer() */


/*F*
//  Name    : CConnectionPoint::QueryInterface
//  Purpose : Query us for our IConnectionPoint interface. 
//  Context : 
//  Returns : NOERROR if interface successfully found.
//            E_NOINTERFACE otherwise.
//  Params  :
//      riid    IID of the desired interface
//      ppv     Pointer to a VOID * to store the
//              returned interface in.
//  Notes   : Implicitly AddRef()s this object on success.
*F*/
STDMETHODIMP
CConnectionPoint::QueryInterface(
    REFIID  riid,
    void    **ppv)
{
    CAutoLock l(&m_csState);
    if (riid == IID_IConnectionPoint) {
        // Our own interface
        *ppv = (IConnectionPoint *) this;
    } else if (riid == IID_IUnknown) {
        *ppv = (IUnknown *) this;
    } else {
        return E_NOINTERFACE;
    } /* if */

    AddRef();
    // Implicit AddRef(). The Release() must be explicitly done
    // by the routine that called QueryInterface().
    return NOERROR;
} /* CConnectionPoint::QueryInterface() */


/*F*
//  Name    : CConnectionPoint::Release
//  Purpose : Decrement the reference count for this object.
//  Context : Called by any program which holds a reference
//            to this object which no longer needs it.
//  Returns : Current reference count.
//  Params  : None.
//  Notes   : Should be called once for each AddRef()
//            a program makes and once for each successful
//            QueryInterface() a program made on us.
*F*/
ULONG 
CConnectionPoint::Release() {
    EnterCriticalSection(&m_csState);
	m_dwRefCount--;
	if (m_dwRefCount==0) {
        LeaveCriticalSection(&m_csState);
		delete this;
		return 0;
		}
    LeaveCriticalSection(&m_csState);
	return m_dwRefCount;
} /* CConnectionPoint::Release() */


struct bCookieMatch : public binary_function<CONNECTDATA, DWORD, bool> {
    bool operator()(const CONNECTDATA& connectData, const DWORD& dwCookie) const {
        if (connectData.dwCookie == dwCookie) {
            return TRUE;
        } else {
            return FALSE;
        } /* if */
    } /* operator() */
}; /* bCookieMatch() */


/*F*
//  Name    : CConnectionPoint::Unadvise()
//  Purpose : The connection sink wishes to break off our mutual
//            connection.
//  Context :
//  Params  :
//      dwCookie    Cookie to use to find connection to tear down.
//  Returns :
//      NOERROR                 Connection broken down.
//      CONNECT_E_NOCONNECTION  No connection matching dwCookie.
//  Notes   :
*F*/
HRESULT
CConnectionPoint::Unadvise(
    DWORD                       dwCookie)
{
    CAutoLock l(&m_csState);
    list<CONNECTDATA>::iterator iConnectListIterator;

	int count = m_lConnectList.size();

    iConnectListIterator = find_if(m_lConnectList.begin(), m_lConnectList.end(), 
                                   bind2nd(bCookieMatch(), dwCookie));
    if (iConnectListIterator != m_lConnectList.end()) {
        // Found the connection we are looking for. 
        (*iConnectListIterator).pUnk->Release();    // Release the interface
        m_lConnectList.erase(iConnectListIterator); // Erase the entry
        return NOERROR;
    } else {
        // No connection matching indicated cookie found!
        return CONNECT_E_NOCONNECTION;
    } /* if */
} /* CConnectionPoint::Unadvise() */



//
//
// Begin CConnectionPointContainerEnumerator
//
//


/*F*
//  Name    : CConnectionPointContainerEnumerator::AddRef
//  Purpose : Increment the reference count for this object.
//  Context : Called by any program which wants to ensure
//            that this object isn't destroyed before it
//            says it is done with it (via Release(), below.)
//            Called implicitly when a program successfully
//            calls our QueryInterface() method.
//  Returns : Current number of references held for this
//            object.
//  Params  : None.
//  Notes   : Standard COM method.
*F*/
ULONG 
CConnectionPointContainerEnumerator::AddRef() {
    CAutoLock l(&m_csState);
    m_pIUnknownParent->AddRef();    // Per BS Pg. 208
	m_dwRefCount++;
	return m_dwRefCount;
} /* CConnectionPointContainerEnumerator::AddRef() */



/*F*
//  Name    : CConnectionPointContainerEnumerator::CConnectionPointContainerEnumerator
//  Purpose : Constructor. Stores which connection point we are pointing at.
//  Context : Called when this object is created.
//  Returns : 
//  Params  : 
//      iConnPointNumber    Integer which indicates which connection point
//                          this enumerator is currently pointing at.
//  Notes   : None.
*F*/
CConnectionPointContainerEnumerator::CConnectionPointContainerEnumerator(
    IUnknown                            *pIUnknownParent,
    IConnectionPointList_t              IConnectionPointList,
    IConnectionPointList_t::iterator    iConnectionPointListPosition)
{
    InitializeCriticalSection(&m_csState);
    CAutoLock l(&m_csState);
    m_dwRefCount = 0;

    // Store these in our member variables.
    m_IConnectionPointList = IConnectionPointList;
    m_iConnectionPointListPosition = iConnectionPointListPosition;
    m_pIUnknownParent = pIUnknownParent;

    // Addref() all of our connection points.
    IConnectionPointList_t::iterator iConnPtIterator;
    for (iConnPtIterator = m_IConnectionPointList.begin();
         iConnPtIterator != m_IConnectionPointList.end();
         iConnPtIterator++) {
        (*iConnPtIterator)->AddRef();
    } /* for */
    pIUnknownParent->AddRef();
} /* CConnectionPointContainerEnumerator::CConnectionPointContainerEnumerator() */


/*F*
//  Name    : CConnectionPointContainerEnumerator::~CConnectionPointContainerEnumerator
//  Purpose : Destructor.
//  Context : Called when this object is destroyed.
//  Returns : 
//  Params  : 
//  Notes   : None.
*F*/
CConnectionPointContainerEnumerator::~CConnectionPointContainerEnumerator(void)
{
    EnterCriticalSection(&m_csState);

    // Release() all of our connection points.
    IConnectionPointList_t::iterator iConnPtIterator;
    for (iConnPtIterator = m_IConnectionPointList.begin();
         iConnPtIterator != m_IConnectionPointList.end();
         iConnPtIterator++) {
        (*iConnPtIterator)->Release();
    } /* for */

    DeleteCriticalSection(&m_csState);
} /* CConnectionPointContainerEnumerator::~CConnectionPointContainerEnumerator() */


/*F*
//  Name    : CConnectionPointContainerEnumerator::Clone
//  Purpose : Return an identical enumerator pointing at the same
//            point in our list of connection points.
//  Context : 
//  Returns : 
//  Params  : 
//      E_OUTOFMEMORY   Insufficient memory to create new enumerator.
//      NOERROR         Successfully created & returned enumerator.
//  Notes   : None.
*F*/
HRESULT
CConnectionPointContainerEnumerator::Clone(
    IEnumConnectionPoints       **ppIEnumConnPoints)
{
    CAutoLock l(&m_csState);
    CConnectionPointContainerEnumerator *pNewConnPtContainerEnum;
    pNewConnPtContainerEnum = new CConnectionPointContainerEnumerator((IUnknown *) this,
                                                                      m_IConnectionPointList,
                                                                      m_iConnectionPointListPosition);
    if (pNewConnPtContainerEnum == (CConnectionPointContainerEnumerator *) NULL) {
        return E_OUTOFMEMORY;
    } /* if */

    HRESULT hErr;
    hErr = pNewConnPtContainerEnum->QueryInterface(IID_IEnumConnectionPoints,
                                                   (PVOID *) ppIEnumConnPoints);
    if (FAILED(hErr)) {
        delete pNewConnPtContainerEnum;
    } /* if */

    return hErr;
} /* CConnectionPointContainerEnumerator::Clone() */


/*F*
//  Name    : CConnectionPointContainerEnumerator::Next
//  Purpose : 
//  Context : 
//  Params  : 
//      E_POINTER   Invalid ppCPArray parameter passed in.
//      NOERROR         Successfully created & returned enumerator.
//  Returns : 
//  Notes   : None.
*F*/
HRESULT
CConnectionPointContainerEnumerator::Next(
    ULONG                       uPointsToReturn,
    IConnectionPoint            **ppCPArray,
    ULONG                       *puPointsReturned)
{
    CAutoLock l(&m_csState);
    if (IsBadWritePtr(ppCPArray, uPointsToReturn * sizeof(IConnectionPoint *))) {
        return E_POINTER;
    } /* if */

    *puPointsReturned = 0;
    HRESULT hErr;
    while ((uPointsToReturn > 0) && 
           (m_iConnectionPointListPosition != m_IConnectionPointList.end())) {
        hErr = (*m_iConnectionPointListPosition)->QueryInterface(IID_IConnectionPoint,
                                                                 (PVOID *) ppCPArray);
        if (SUCCEEDED(hErr)) {
            ppCPArray++;
            (*puPointsReturned)++;
            uPointsToReturn--;
        }/* if */
        m_iConnectionPointListPosition++;
    } /* while */

    return NOERROR;
} /* CConnectionPointContainerEnumerator::Next() */


/*F*
//  Name    : CConnectionPointContainerEnumerator::QueryInterface
//  Purpose : Query us for an interface.
//  Context : 
//  Returns : NOERROR if interface successfully found.
//            E_NOINTERFACE otherwise.
//  Params  :
//      riid    IID of the desired interface
//      ppv     Pointer to a VOID * to store the
//              returned interface in.
//  Notes   : Implicitly AddRef()s this object on success.
*F*/
STDMETHODIMP
CConnectionPointContainerEnumerator::QueryInterface(
    REFIID  riid,
    void    **ppv)
{
    CAutoLock l(&m_csState);
    if (riid == IID_IEnumConnectionPoints) {
        // Our own interface
        *ppv = (IEnumConnectionPoints *) this;
    } else if (riid == IID_IUnknown) {
        *ppv = (IUnknown *) this;
    } else {
        return E_NOINTERFACE;
    } /* if */

    AddRef();
    // Implicit AddRef(). The Release() must be explicitly done
    // by the routine that called QueryInterface().
    return NOERROR;
} /* CConnectionPointContainerEnumerator::QueryInterface() */


/*F*
//  Name    : CConnectionPointContainerEnumerator::Release
//  Purpose : Decrement the reference count for this object.
//  Context : Called by any program which holds a reference
//            to this object which no longer needs it.
//  Returns : Current reference count.
//  Params  : None.
//  Notes   : Should be called once for each AddRef()
//            a program makes and once for each successful
//            QueryInterface() a program made on us.
*F*/
ULONG 
CConnectionPointContainerEnumerator::Release() {
    EnterCriticalSection(&m_csState);
    m_pIUnknownParent->Release();   // Per BS pg.208
	m_dwRefCount--;

    if (m_dwRefCount==0) {
        LeaveCriticalSection(&m_csState);
		delete this;
		return 0;
		}
    LeaveCriticalSection(&m_csState);
	return m_dwRefCount;
} /* CConnectionPointContainerEnumerator::Release() */


/*F*
//  Name    : CConnectionPointContainerEnumerator::Reset
//  Purpose : Start the enumerator at the beginning of the
//            connection point list again.
//  Context : Any point after construction.
//  Returns : 
//      NOERROR Successfully reset enumerator.
//  Params  : None.
//  Notes   : None.
*F*/
HRESULT
CConnectionPointContainerEnumerator::Reset(void)
{
    CAutoLock l(&m_csState);
    m_iConnectionPointListPosition = m_IConnectionPointList.begin();
    return NOERROR;
} /* CConnectionPointContainerEnumerator::Reset() */


/*F*
//  Name    : CConnectionPointContainerEnumerator::Skip
//  Purpose : Skip forward over the specified number of connection points.
//  Context : 
//  Params  : 
//      uSkipCount  Number of connection points to skip.
//  Returns : 
//      NOERROR     Successfully created & returned enumerator.
//  Notes   : None.
*F*/
HRESULT
CConnectionPointContainerEnumerator::Skip(
    ULONG                       uSkipCount)
{
    CAutoLock l(&m_csState);
    while ((uSkipCount > 0) && 
           (m_iConnectionPointListPosition != m_IConnectionPointList.end())) {
        m_iConnectionPointListPosition++;
        uSkipCount--;
    } /* while */

    return NOERROR;
} /* CConnectionPointContainerEnumerator::Skip() */


//
//
// Begin CConnectionPointContainer
//
//

/*F*
//  Name    : CConnectionPointContainer::CConnectionPointContainer
//  Purpose : Constructor. Doesn't do much.
//  Context : Called when this object is created.
//  Returns : 
//  Params  : 
//      pParentUnknown  IUnknown for the parent of this container
//                      so that we can pass QIs and such to it.
//  Notes   : None.
*F*/
CConnectionPointContainer::CConnectionPointContainer() :
    m_pIParentUnknown((IUnknown *) NULL)
{
    InitializeCriticalSection(&m_csState);
    CAutoLock l(&m_csState);
} /* CConnectionPointContainer::CConnectionPointContainer() */


/*F*
//  Name    : CConnectionPointContainer::~CConnectionPointContainer()
//  Purpose : 
//  Context : 
//  Returns : 
//  Params  : None.
//  Notes   : None.
*F*/
CConnectionPointContainer::~CConnectionPointContainer()
{
    IConnectionPointList_t::iterator iConnPtListIterator;
    EnterCriticalSection(&m_csState);

    while (m_lConnectionPointList.begin() != m_lConnectionPointList.end()) {
        iConnPtListIterator = m_lConnectionPointList.begin();
        (*iConnPtListIterator)->Release();
        m_lConnectionPointList.erase(iConnPtListIterator);
    } /* if */
    LeaveCriticalSection(&m_csState);
    DeleteCriticalSection(&m_csState);
} /* CConnectionPointContainer::~CConnectionPointContainer() */


/*F*
//  Name    : CConnectionPointContainer::SetUnknown()
//  Purpose : Store the IUnknown of the parent in order
//            to delegate IUnknown calls to it. We are
//            merely a helper class, not a true COM object.
//  Context : 
//  Returns : 
//      E_UNEXPECTED    Parent IUnknown previously set.
//      NOERROR         Successfully recorded parent IUnknown.
//  Params  : None.
//  Notes   :
//      pIParentUnknown Pointer to the IUnknown of the parent
//                      which we are supposed to delegate to.
*F*/
HRESULT
CConnectionPointContainer::SetUnknown(
    IUnknown                    *pIParentUnknown)
{
    if (m_pIParentUnknown != (IUnknown *) NULL) {
        // Parent unknown previously set.
        return E_UNEXPECTED;
    } /* if */

    m_pIParentUnknown = pIParentUnknown;
    return NOERROR;
} /* CConnectionPointContainer::SetUnknown() */


/*F*
//  Name    : CConnectionPointContainer::EnumConnectionPoints
//  Purpose : Create a connection point container enumerator
//            and return it to the callind program.
//  Context : Called when a program wants to enumerate through
//            the list of connection points we support.
//  Returns : 
//      E_OUTOFMEMORY   Insufficient memory to create new enumerator.
//      NOERROR         Successfully created & returned enumerator.
//  Params  : None.
//  Notes   : None.
*F*/
HRESULT     
CConnectionPointContainer::EnumConnectionPoints(
    IEnumConnectionPoints       **ppIEnumConnPoints)
{
    CAutoLock l(&m_csState);
    CConnectionPointContainerEnumerator *pNewConnPtContainerEnum;
    pNewConnPtContainerEnum = new CConnectionPointContainerEnumerator((IUnknown *) this,
                                                                      m_lConnectionPointList,
                                                                      m_lConnectionPointList.begin());
    if (pNewConnPtContainerEnum == (CConnectionPointContainerEnumerator *) NULL) {
        return E_OUTOFMEMORY;
    } /* if */

    HRESULT hErr;
    hErr = pNewConnPtContainerEnum->QueryInterface(IID_IEnumConnectionPoints,
                                                   (PVOID *) ppIEnumConnPoints);
    if (FAILED(hErr)) {
        delete pNewConnPtContainerEnum;
    } /* if */

    return hErr;
} /* CConnectionPointContainer::EnumConnectionPoints() */


struct bIIDMatch : public binary_function<IConnectionPoint *, IID, bool> {
    bool operator()(IConnectionPoint *pICP, const IID riid) const {
        IID sIConnection;
        HRESULT hErr = pICP->GetConnectionInterface(&sIConnection);
        if (FAILED(hErr)) {
            // Error with this connection point.
            return FALSE;
        } /* if */
        if (sIConnection == riid) {
            // This connection point exposes the requested interface.
            return TRUE;
        } else {
            // This connection point does not expose the requested interface.
            return FALSE;
        } /* if */
    } /* operator() */
}; /* bIIDMatch() */


/*F*
//  Name    : CConnectionPointContainer::FindConnectionPoint
//  Purpose : Check if this connection point container supports
//            a particular connection point.
//  Context : 
//  Returns : 
//      E_POINTER   Invalid ppIConnectionPoint parameter passed in.
//      CONNECT_E_NOCONNECTION  No connection point matching indicated REFIID.
//      NOERROR     Successfully returned AddRef()ed connection point.
//  Params  :
//      rConnPointIID       IID of the desired connection point.
//      ppIConnectionPoint  Indirect pointer to return connection
//                          point matching rConnPointIID (if found.)
//  Notes   : None.
*F*/
HRESULT     
CConnectionPointContainer::FindConnectionPoint(
    REFIID                      rConnPointIID,
    IConnectionPoint            **ppIConnectionPoint)
{
    CAutoLock l(&m_csState);
    if (IsBadWritePtr(ppIConnectionPoint, sizeof(IConnectionPoint *))) {
        return E_POINTER;
    } /* if */

    IConnectionPointList_t::iterator iConnPtListIterator;
    iConnPtListIterator = find_if(m_lConnectionPointList.begin(), m_lConnectionPointList.end(), 
                                  bind2nd(bIIDMatch(), rConnPointIID));

    if (iConnPtListIterator != m_lConnectionPointList.end()) {
        // Found the connection point matching the indicated IID.
        *ppIConnectionPoint = *iConnPtListIterator;
        (*ppIConnectionPoint)->AddRef();
        return NOERROR;
    } else {
        // No connection point matches the requested IID.
        return CONNECT_E_NOCONNECTION;
    } /* if */
} /* CConnectionPointContainer::FindConnectionPoint() */


/*F*
//  Name    : CConnectionPointContainer::AddConnectionPoint
//  Purpose : Class method used to allow parent object to
//            add connection points to this connection point container.
//  Context : 
//  Returns :
//      E_POINTER   Invalid pINewConnectionPoint parameter.
//      NOERROR     Successfully added connection point to our list.
//      Also returns error codes returned by QueryInterface()/
//  Params  :
//      pIUnknownNewConnectionPoint IUnknown of the new connection point.
//  Notes   :
//      All connection points should be added before any calls to
//      the IConnectionPointContainer interface are made.
*F*/
HRESULT 
CConnectionPointContainer::AddConnectionPoint(
    IUnknown    *pIUnknownNewConnectionPoint)
{
    CAutoLock l(&m_csState);
    if (IsBadReadPtr((PVOID) pIUnknownNewConnectionPoint, sizeof(IConnectionPoint *))) {
        return E_POINTER;
    } /* if */

    HRESULT hErr;
    IConnectionPoint *pINewConnectionPoint;
    hErr = pIUnknownNewConnectionPoint->QueryInterface(IID_IConnectionPoint,
                                                       (PVOID *) &pINewConnectionPoint);
    if (FAILED(hErr)) {
        return hErr;
    } /* if */

    m_lConnectionPointList.push_back(pINewConnectionPoint);
    return NOERROR;
} /* CConnectionPointContainer::AddConnectionPoint() */


#endif _CONNECT_CPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\autolock.h ===
/*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1996 Intel Corporation. All Rights Reserved.
//
// Filename : AutoLock.cpp
// Purpose  : Implementation file for the auto-locking C++
//            object which uses scoping to cleanly handle
//            entrance and exiting of critical sections.
// Contents : CAutoLock Class
*M*/

#ifndef _AUTOLOCK_H_
#define _AUTOLOCK_H_

/*C*
// Name     : CAutoLock
// Purpose  : Uses scoping rules to automatically enter and leave
//            a critical section.
// Context  : Enters a specified critical section upon construction.
//            Leaves the critical section upon destruction.
// Params   :
//      pcs     Parameter passed to constructor specifying CS to acquire.
// Members  :
//      m_pcs   Stores critical section for use in leaving upon destructions.
// Notes    :
//      Copied wholesale from ActiveMovie SDK, modified to use CRITICAL_SECTIONs
//          directly instead of the CCritSec construct used in ActiveMovie.
*C*/
#if !defined(PPM_IN_DXMRTP)
struct CAutoLock {
#else
#define CAutoLock PPMCAutoLock
struct PPMCAutoLock {
#endif
public:
    // make copy constructor and assignment operator inaccessible
    CAutoLock(const CAutoLock &refThreadAutoLock);
    CAutoLock &operator=(const CAutoLock &refThreadAutoLock);
    CAutoLock(CRITICAL_SECTION * pcs) : m_pcs(pcs)
    {
        EnterCriticalSection(pcs);
    };
    ~CAutoLock() {
        LeaveCriticalSection(m_pcs);
    };
private:
    CRITICAL_SECTION * m_pcs;
}; /* struct CAutoLock */

#endif _AUTOLOCK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\core.h ===
/****************************************************************************
 *  $Header:   J:\rtp\src\ppm\core.h_v   1.2   20 Mar 1997 18:32:02   lscline  $
 *
 *  INTEL Corporation Proprietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *  Copyright (c) 1995, 1996 Intel Corporation. All rights reserved.
 *
 *  $Revision:   1.2  $
 *  $Date:   20 Mar 1997 18:32:02  $
 *  $Author:   lscline  $
 *
 *  Log at end of file.
 *
 *  Module Name:    psbacore.h
 *  Abstract:       Core ProShare Video COM support
 *  Environment:    MSVC 4.0, OLE 2
 *  Notes:
 *		CClassFactory	- common class factory
 *		CUnknown		- default implementation of IUnknown
 *		CPsObject		- default implementation of IPsObject
 *		CPsApp			- CWinApp derivation
 *
 ***************************************************************************/

#ifndef CORE_H
#define CORE_H

//#include "internat.h"
//#include "psuiaux.h"
#include <winsock2.h>
#include <assert.h>


//***************************************************************************
// CClassFactory
//      CClassFactory is a common OLE 2 class factory that supports creation
//      of single or multiple instance OLE objects via a registration
//      mechanism. To use, an OLE class must implement a static CREATEPROC
//      method, and add a REGISTER_CLASS entry. All REGISTER_CLASS entries
//      must be collected together and wrapped with the BEGIN_CLASS_REGISTRY and
//      END_CLASS_REGISTRY macros.

// UNLOADSERVERPROC in .exe is called by class factory to unload .exe server (not used for .dll)
typedef void (STDMETHODCALLTYPE* UNLOADSERVERPROC)( void );

// DESTROYEDPROC in class factory is called by each object when it is destroyed
typedef void (STDMETHODCALLTYPE* DESTROYEDPROC)( REFCLSID rclsid );

// CREATEPROC in object (static method) is called by class factory to create a new object
typedef HRESULT (STDMETHODCALLTYPE* CREATEPROC)(
    const LPUNKNOWN     pUnkOuter,              // controlling outer if aggregating
    const DESTROYEDPROC pfnObjDestroyed,        // function to call when object is destroyed
    LPUNKNOWN FAR*      ppUnkInner              // inner unknown
    );

#if !defined(PPM_IN_DXMRTP)
class CClassFactory : public IClassFactory
#else
#define CClassFactory PPMCClassFactory
class PPMCClassFactory : public IClassFactory
#endif
{
private:
    // static members
    struct Registry
    {
        const CLSID*    pClsid;
        CREATEPROC      pfnCreate;
        REGCLS          regCls;
        CClassFactory*  pFactory;
        ULONG           cObjects;
	    LPUNKNOWN   	pUnkSingle;
        DWORD           dwRegister;
    };
    static Registry         NEAR s_registry[];
    static UINT             NEAR s_nRegistry;
    static ULONG            NEAR s_cLockServer;
    static ULONG            NEAR s_cObjects;
    static UNLOADSERVERPROC NEAR s_pfnUnloadServer;

private:
    ULONG       m_cRef;
    Registry*   m_pReg;

public:
    CClassFactory( Registry* pReg );
    ~CClassFactory();

    // IUnknown interface
    virtual STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj ); 
    virtual STDMETHODIMP_( ULONG ) AddRef( void );
    virtual STDMETHODIMP_( ULONG ) Release( void );

    // IClassFactory interface
    virtual STDMETHODIMP CreateInstance( LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppvObject );
    virtual STDMETHODIMP LockServer( BOOL fLock );

    // callback to track object destruction
    static STDMETHODIMP_( void ) ObjectDestroyed( REFCLSID rclsid );

    // Exe server helpers
    static void SetUnloadServerProc( UNLOADSERVERPROC pfnUnloadServer );
    static STDMETHODIMP RegisterAllClasses( DWORD dwClsContext );
    static STDMETHODIMP RevokeAllClasses( void );

    // Dll server helpers
    static STDMETHODIMP GetClassObject( REFCLSID rclsid, REFIID riid, LPVOID FAR* ppvObj );
    static STDMETHODIMP CanUnloadNow( void );
    
    // local helpers                         
    static STDMETHODIMP LocalCreateInstance( REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid, LPVOID FAR* ppvObj );

protected:
    static int __cdecl CompareClsids( const void* clsid1, const void* clsid2 );
    static void SortRegistry( void );
    static Registry* FindClass( const CLSID* pClsid );

private:
	static CClassFactory*		newCClassFactory( Registry* pReg );
};

/////////////////////////////////////////////////////////////////////////////
// Class registry definition macros
//
#define BEGIN_CLASS_REGISTRY() \
    CClassFactory::Registry NEAR CClassFactory::s_registry[] = {
#define REGISTER_CLASS( clsid, class_name, regCls ) \
        { &clsid, class_name::_CreateObject, regCls, NULL, 0, NULL, 0 },
#define END_CLASS_REGISTRY() \
        { &CLSID_NULL, NULL, REGCLS_SINGLEUSE, NULL, 0, NULL, 0 } \
    };

/////////////////////////////////////////////////////////////////////////////
// Macros to define and implement a standard CREATEPROC
//
#define DECLARE_CREATEPROC() \
    static STDMETHODIMP _CreateObject( const LPUNKNOWN, const DESTROYEDPROC, LPUNKNOWN FAR* );

#define IMPLEMENT_CREATEPROC( class_name )                                                                      \
STDMETHODIMP                                                                                                    \
class_name::_CreateObject(                                                                                      \
    const LPUNKNOWN     pUnkOuter,              /* pointer to controlling outer if we're being aggregated */    \
    const DESTROYEDPROC pfnObjectDestroyed,     /* pointer to function to call when object is destroyed */      \
    LPUNKNOWN FAR*      ppUnkInner              /* return pointer to object here */                             \
    )                                                                                                           \
{                                                                                                               \
    SetObjectDestroyed( pfnObjectDestroyed );                                                                   \
                                                                                                                \
    /* check the other parameters; if these tests are made in a release build, */                               \
    /* return E_INVALIDARG on failure. */                                                                       \
    assert( pUnkOuter == NULL || ! ::IsBadReadPtr( pUnkOuter, sizeof(LPUNKNOWN)) );                             \
    assert( ! ::IsBadWritePtr( ppUnkInner, sizeof(LPUNKNOWN) ) );                                               \
    *ppUnkInner = NULL;                                                                                         \
                                                                                                                \
	class_name* pNewObject = NULL;                                                                              \
	                                                                                                            \
    /* create the new object */                                                                                 \
                                                                                                                \
                                                                                                                \
    	pNewObject = new class_name( pUnkOuter, ppUnkInner );                                                   \
                                                                                                                \
                                                                                                                \
                                                                                                                \
                                                                                                                \
    /* check the returned pointer */                                                                            \
    if( ! pNewObject )                                                                                          \
        return ResultFromScode( E_OUTOFMEMORY );                                                                \
                                                                                                                \
    /* make sure ppUnkInner is returned. If we're not */                                                        \
    /* aggregated it's ok to use pVideoView */                                                                  \
    if( ! *ppUnkInner )                                                                                         \
    {                                                                                                           \
        if( ! pUnkOuter )                                                                                       \
            return ResultFromScode( E_UNEXPECTED );                                                             \
        else                                                                                                    \
        {                                                                                                       \
            delete pNewObject;                                                                                  \
            return ResultFromScode( CLASS_E_NOAGGREGATION );                                                    \
        }                                                                                                       \
    }                                                                                                           \
                                                                                                                \
    return NOERROR;                                                                                             \
}                                                                                                               \
/* end of IMPLEMENT_CREATEPROC */

#if 0
    /* perform any remaining initialization */                                                                  \
    HRESULT hr = pNewObject->Init();                                                                            \
    if( FAILED( hr ) )                                                                                          \
    {                                                                                                           \
    	pNewObject->OnLastRelease();																			\
        delete pNewObject;                                                                                      \
        *ppUnkInner = NULL;                                                                                     \
        return hr;                                                                                              \
    }                                                                                                           
#endif

//***************************************************************************
// CUnknown - A generic IUnknown component object supporting aggregation
//      and CClassFactory
//
#if !defined(PPM_IN_DXMRTP)
class CUnknown : public IUnknown
#else
#define CUnknown PPMCUnknown
class PPMCUnknown : public IUnknown
#endif
{
private:
    // controlling unknown; this will be the outer unknown if we're
    // aggregated, or our inner unknown if not
    LPUNKNOWN   m_pUnkControl;

    // nested inner IUnknown implementation. This is neccesary for a class
    // implemented using multiple inheritance to be aggregated.
    class CInnerUnknown : public IUnknown
    {
    private:
        // object reference count
        ULONG       m_cRef;
        CUnknown*   m_pThis;

    public:
        CInnerUnknown( CUnknown* pThis );
        ~CInnerUnknown();
//#ifdef _DEBUG
//        virtual void AssertValid( void ) const;
//        virtual void Dump( CDumpContext& dc ) const;
//#endif //_DEBUG

        // IUnknown methods
        STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj );
        STDMETHODIMP_( ULONG ) AddRef( void );
        STDMETHODIMP_( ULONG ) Release( void );
    } m_unkInner;
    friend CInnerUnknown;

    // pointer to object destruction function in common class factory
    // this can be a static (shared) member as all objects will call
    // the same function
    static DESTROYEDPROC s_pfnObjectDestroyed;

protected:
    CUnknown( LPUNKNOWN pUnkOuter, LPUNKNOWN FAR* ppUnkInner );
    static void SetObjectDestroyed( DESTROYEDPROC pfnObjectDestroyed );

public:
    virtual ~CUnknown();
//#ifdef _DEBUG
//    virtual void AssertValid( void ) const;
//    virtual void Dump( CDumpContext& dc ) const;
//#endif // _DEBUG

    // method called just prior to an object being destroyed
    virtual STDMETHODIMP_( void ) OnLastRelease( void );

    // method to get interface pointers supported by derived objects
    // called by CInnerUnknown::QueryInterface; should return S_FALSE
    // if interface is AddRef'd, S_OK if caller needs to AddRef the interface.
    virtual STDMETHODIMP GetInterface( REFIID riid, LPVOID FAR* ppvObj ) = 0;

    virtual STDMETHODIMP_( const CLSID& ) GetCLSID( void ) const = 0;

    // IUnknown methods
    virtual STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj );
    virtual STDMETHODIMP_( ULONG ) AddRef( void );
    virtual STDMETHODIMP_( ULONG ) Release( void );

	// Standard allocator support
//	static LPVOID StdAlloc( ULONG cb );
//	static void StdFree( LPVOID pv );
//	static LPVOID StdRealloc( LPVOID pv, ULONG cb );
//	static ULONG StdGetSize( LPVOID pv );
//	static int StdDidAlloc( LPVOID pv );
//	static void StdHeapMinimize( void );
};

/////////////////////////////////////////////////////////////////////////////
// CUnknown inline methods
//
inline void CUnknown::SetObjectDestroyed( DESTROYEDPROC pfnObjectDestroyed )
{
    // make sure objectDestroyed function hasn't changed. If it could ever change then
    // the pointer should be stored in an instance specific member. The current
    // CClassFactory implementation guarantees that it will be the same function for
    // each object of a class, although not necessarily for each class.
    assert( ! ::IsBadCodePtr( (FARPROC) pfnObjectDestroyed ) || NULL == pfnObjectDestroyed );
    assert( NULL == s_pfnObjectDestroyed || s_pfnObjectDestroyed == pfnObjectDestroyed );

    // store the objectDestroyed function ptr
    s_pfnObjectDestroyed = pfnObjectDestroyed;
}

#endif  // PSBACORE_H

/*****************************************************************************
 * $Log:   J:\rtp\src\ppm\core.h_v  $
 * 
 *    Rev 1.2   20 Mar 1997 18:32:02   lscline
 * Merged small change differences for MS NT 5.0 build environment.
 * 
 * 
 *    Rev 1.1   05 Apr 1996 16:43:46   LSCLINE
 * 
 * Copyright
 * 
 *    Rev 1.0   Dec 08 1995 16:40:26   rnegrin
 * Initial revision.
 * 
 *    Rev 1.24   20 Sep 1995 16:04:48   PCRUTCHE
 * OLEFHK32
 * 
 *    Rev 1.23   13 Jun 1995 19:42:48   DEDEN
 * Dynamic object allocation helper functions\macros
 * 
 *    Rev 1.22   09 Jun 1995 14:45:12   KAWATTS
 * Moved CDebug::LoadLibrary to CPsAppHelper
 * 
 *    Rev 1.21   17 May 1995 21:50:36   DEDEN
 * Derive CPsApp from CDBoxHelper
 * 
 *    Rev 1.20   05 May 1995 14:45:20   DEDEN
 * Override CWinApp::DoMessageBox() with CPsApp::DoMessageBox() to alter AfxMessageBox behavior
 * 
 *    Rev 1.19   25 Apr 1995 12:35:00   DEDEN
 * Fix IMPLEMENT_CREATEPROC with TRY\CATCH for possible memory exception
 * 
 *    Rev 1.18   11 Apr 1995 16:18:24   DEDEN
 * Added GetSettingsPtr method
 * 
 *    Rev 1.17   20 Mar 1995 17:02:10   KAWATTS
 * Command line support
 * 
 *    Rev 1.16   14 Mar 1995 19:26:58   PCRUTCHE
 * _CreateObject now calls OnLastRelease if Init fails
 * 
 *    Rev 1.15   07 Mar 1995 16:38:42   AKHARE
 * ARM complaint sizeof
 * 
 *    Rev 1.14   03 Mar 1995 18:01:58   KAWATTS
 * Added include of internat.h
 * 
 *    Rev 1.13   01 Mar 1995 14:40:10   DEDEN
 * Removed static CUnknown:: variables associated with maintaining a static
 * task allocator pointer for the CUnknown:: static memory functions.
 * Moved implementation of functions to psunk.cpp.  Now use CoGetMalloc
 * every time.
 * 
 *    Rev 1.12   17 Feb 1995 10:59:56   DEDEN
 * Move GetStandardAllocator\ReleaseStandardAllocator to public section
 * 
 *    Rev 1.11   17 Feb 1995 10:51:22   KAWATTS
 * Added CUnknown::{Get,Release}StandardAllocator
 * 
 *    Rev 1.10   15 Feb 1995 16:08:52   KAWATTS
 * Changed CPsApp to use CPsAppHelper
 * 
 *    Rev 1.9   13 Feb 1995 15:27:36   KAWATTS
 * Added CPsAppHelper
 * 
 *    Rev 1.8   07 Feb 1995 14:01:16   KAWATTS
 * Added Load/UnloadResourceDll
 * 
 *    Rev 1.7   06 Feb 1995 11:10:46   KAWATTS
 * Added CPsApp::UseResourceDll
 * 
 *    Rev 1.6   31 Jan 1995 17:52:02   KAWATTS
 * Added error logging support
 * 
 *    Rev 1.5   20 Jan 1995 11:38:44   PCRUTCHE
 * Added lpMalloc parameter to InitInstance
 * 
 *    Rev 1.4   06 Jan 1995 09:56:02   PCRUTCHE
 * Changed registry data structure
 * 
 *    Rev 1.3   14 Dec 1994 19:08:58   DEDEN
 * Added CPsObject::PrefsChanged method
 * 
 *    Rev 1.2   01 Dec 1994 15:04:24   PCRUTCHE
 * Added QueryClose to PsObject
 * 
 *    Rev 1.1   29 Nov 1994 15:12:16   KAWATTS
 * Added standard allocator support to CUnknown
 * 
 *    Rev 1.0   07 Nov 1994 14:24:28   KAWATTS
 * Initial revision.
 * 
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\descrip.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: descrip.h
//  Abstract:    header file. Definitions of two classes of descriptors used in 
//               various linked list structures in the ppm dll.
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
//Descrip.h

#ifndef DESCRIP_H
#define DESCRIP_H

#include "que.h"
#include "freelist.h"
#ifdef RTP_CLASS
#include "rtpclass.h"
#else
#include "rtp.h"
#endif
#include "llist.h"

///////////////////////////////////////////////////////////////////////////////////////
//MsgDescriptor: A class that is used to hold a message and has members that describe 
//               the contents of the message buffer. It is derived from QueueItem so
//               that it can be stored on a queue.
////////////////////////////////////////////////////////////////////////////////////////

class MsgDescriptor : public QueueItem {

public:

void *         m_pBuffer;
DWORD          m_Size;     //???Should this be an unsigned int
DWORD          m_TimeStamp;
void *		   m_pMsgCookie;
int            m_NumFrags;
int			   m_NumFragSubmits;
int            m_IsFree;

MsgDescriptor();
~MsgDescriptor(){} //inline function

};//end MsgDescriptor Class
 
inline MsgDescriptor::MsgDescriptor() //inline function
{
   m_pBuffer    = NULL;
   m_Size       = 0;
   m_TimeStamp  = 0;  //To what value should I initialize this to?
   m_pMsgCookie = NULL;  //To what value should I initialize this to?
   m_NumFrags   = m_NumFragSubmits = 0;  //
   m_IsFree     = 0;
}

////////////////////////////////////////////////////////////////////////////////////////
//FragDescriptor: A class that is used to hold a fragment and has members that describe 
//                the contents of the fragment buffer. It is derived from LListItem so
//                that it can be stored in a sorted linked list.
////////////////////////////////////////////////////////////////////////////////////////

class FragDescriptor : public LListItem {

public:

void          *m_pRecBuffer;     //For Receive holds data from client, not used for Send 
int            m_BytesInPacket;  //Number of bytes returned in Receivecomplete
void 		  *m_pFragCookie;	 //Used on Receive side to hold service layer cookie

#ifdef RTP_CLASS							 
RTP_Header    *m_pRTPHeader;    //These point to offsets in buffer.
#else
RTP_HDR_T    *m_pRTPHeader;    //These point to offsets in buffer.
#endif
void          *m_pProfileHeader;
void          *m_pData;         //for send, will point to somewhere in Msg's buffer 
long  	       m_BytesOfData;	//number of bytes of bit stream (i.e. don't include headers)
MsgDescriptor *m_pMsgBuf;	    //for releasing client's buffer	in Scatter/Gather

FragDescriptor();
~FragDescriptor(){} //inline function

};//end FragDescriptor Class

inline FragDescriptor::FragDescriptor() //inline function
{
   m_pRecBuffer     = NULL;
   m_BytesInPacket  = 0;
   m_pRTPHeader     = NULL;
   m_pProfileHeader = NULL;
   m_pData          = NULL;
   m_BytesOfData    = 0;
   m_pMsgBuf		= NULL;
   m_pFragCookie	= NULL;
}//end FragDescriptor class

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\debug.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: debug.h
//  Abstract:    header file. Debug handling definitions
//	Environment: MSVC 4.0, OLE 2
//
//  This header defines the debugging macro DBG_MSG.  This macro
//  generates no code unless the _DEBUG preprocessor symbol is defined.
//	DBG_MSG supports a standard printf-style format string and
//	associated variable-argument list.  Accordingly, it's necessary to
//	use an extra set of parens to pass the variable-arg list.
//
//		DBG_MSG(DBG_TRACE, ("someInt=%d", someInt)).
//
//	Note that the parens are necessary even when there are no message arguments:
//
//		DBG_MSG(DBG_TRACE, ("A simple msg")).
//
//	DBG_MSG prepends each message with the current thread ID:
//
//		[12345678] Your message here ...
//
//	unless the DBG_NOTHREADID flag is specified.
//
//	DBG_MSG also appends to the formated message the source file name
//	and line number from which it was called, unless the DBG_NONUM flag is
//	specified.
//
//	You may specify the default dwFlags for an entire compilation-unit by
//	defining the DBG_DEFAULTS macro _before_ including this header:
//
//		#define DBG_DEFAULTS	(DBG_NONUM | DBG_NOTHREADID | DBG_WARNING)
//
/////////////////////////////////////////////////////////////////////////////


#ifndef DEBUG_H
#define DEBUG_H

#ifdef ISRDBG
#include "isrg.h"

enum DBGFLAGS
{
	DBG_NOTIFY		= TT_NOTIFY,
	DBG_CRITICAL	= TT_CRITICAL,
	DBG_ERROR		= TT_ERROR,
	DBG_WARNING		= TT_WARNING,
	DBG_TRACE		= TT_TRACE,
	DBG_TEMP		= TT_TEMP,
	DBG_NOTHREADID	= kISRReserved1,
	DBG_NONUM		= kISRReserved2
};

#elif defined(MICROSOFT) // ISRDBG

#define	DBG_NOTIFY		0x01
#define	DBG_CRITICAL	0x02
#define	DBG_ERROR		0x04
#define	DBG_WARNING		0x08
#define	DBG_TRACE		0x10
#define	DBG_TEMP		0x20
#define	DBG_NOTHREADID	0x40
#define DBG_NONUM		0x80
#define DBG_DEVELOP   0x1000

#endif // ISRDBG

#ifdef _DEBUG

#include <assert.h>

#ifndef ASSERT
#define ASSERT(x)             assert(x)
#endif // #ifndef ASSERT

#ifndef DBG_DEFAULTS
#define DBG_DEFAULTS			0
#endif

#define DBG_MSG(_DBGFLAGS, VARGS) \
	CDebugMsg((_DBGFLAGS) | DBG_DEFAULTS, 0, __FILE__, __LINE__).trace VARGS
	
#define DBG_REGISTERMODULE(LPSZSHORTNAME, LPSZLONGNAME) \
	CDebugMsg::registerModule(LPSZSHORTNAME, LPSZLONGNAME)

/////////////////////////////////////////////////////////////////////////////
// class CDebugMsg: Helper class to facilitate variable argument list.
// Since a macro can't accept a variable argument list, the varg list must
// be enclosed in parens.  There's no way to remove the extra parens except
// by using them in a context which requires parens, such as a function or
// macro call.  Also, there's no syntactic way to append values to the arg
// list.
/////////////////////////////////////////////////////////////////////////////
class CDebugMsg
{
public:

	static BOOL registerModule(LPCTSTR lpszShortName, LPCTSTR lpszLongName);

	CDebugMsg(
		DWORD		dwFlags,
		DWORD		dwErr,
		LPCTSTR		lpszFile,
		int			nLine) :
			m_dwFlags(dwFlags),
			m_dwErr(dwErr),
			m_lpszFile(lpszFile),
			m_nLine(nLine)
		{;}
	
	void trace(LPCTSTR lpszMsg, ...) const;

private:

	DWORD		m_dwFlags;
	DWORD		m_dwErr;	// currently unused
	LPCTSTR		m_lpszFile;
	int			m_nLine;
};

#else

#define ASSERT(x)

#define DBG_MSG(DBGFLAGS, VARGS) \
	(void)0 // same return type as CDebugMsg::trace()
	
#define DBG_REGISTERMODULE(LPSZSHORTNAME, LPSZLONGNAME) \
	(BOOL)1 // same return type as CDebugMsg::registerModule()

#endif //_DEBUG

#endif //DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\cunknown.cpp ===
/****************************************************************************
 *  $Header:   R:/Data/RTP/PH/src/vcs/cunknown.cpv   1.4   05 Apr 1996 16:44:28   LSCLINE  $
 *
 *  INTEL Corporation Proprietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *  Copyright (c) 1995, 1996 Intel Corporation. All rights reserved.
 *
 *  $Revision:   1.4  $
 *  $Date:   05 Apr 1996 16:44:28  $
 *  $Author:   LSCLINE  $
 *
 *  Log at end of file.
 *
 *  Module Name:    psunk.cpp
 *  Abstract:       Generic IUnknown component object
 *  Environment:    C++, OLE 2
 *  Notes:
 *
 ***************************************************************************/

//#include "_stable.h"	// standard precompiled headers
#include "core.h"

//***************************************************************************
// CUnknown
//

/////////////////////////////////////////////////////////////////////////////
// static data members
//
DESTROYEDPROC CUnknown::s_pfnObjectDestroyed = NULL;

/////////////////////////////////////////////////////////////////////////////
// constructor & destructor
//
#pragma warning( disable : 4355 )	// don't warn about using 'this' in initializer list
CUnknown::CUnknown( LPUNKNOWN pUnkOuter, LPUNKNOWN FAR* ppUnkInner )
	: m_unkInner( this )	// initialize inner unknown
{
	// parameters aren't checked here because they're checked in Create

	if( pUnkOuter )
	{	// being aggregated into pUnkOuter
		// note: although we're maintaining a reference to pUnkOuter,
		// we mustn't AddRef it or the aggregate object will never die
		m_pUnkControl = pUnkOuter;
		*ppUnkInner = &m_unkInner;
	}
	else
	{	// not aggregated; our inner unknown is our controller
		m_pUnkControl = &m_unkInner;
		*ppUnkInner = this;
	}

	//TRACE1( ">>>CTOR CUnknown::CUnknown() for (this = %lX)\n", this );
}
#pragma warning( default : 4355 )

CUnknown::~CUnknown()
{
	//TRACE1( ">>>DTOR CUnknown::~CUnknown() for (this = %lX)\n", this );
}

/////////////////////////////////////////////////////////////////////////////
// standard allocator support
//
/*
LPVOID 
CUnknown::StdAlloc( ULONG cb )
{
	LPMALLOC lpMalloc = NULL;
	HRESULT hr;

	if( FAILED( hr = CoGetMalloc( MEMCTX_TASK, &lpMalloc ) ) )
	{
		FAILURE1( "CoGetMalloc() failed in CUnknown::StdAlloc(), reason %s", CDebug::Text( hr ) );
		return NULL;
	}
	 
	LPVOID lptr = lpMalloc->Alloc( cb );
	lpMalloc->Release(); 

	return lptr;
}

void 
CUnknown::StdFree( LPVOID pv )
{ 
	LPMALLOC lpMalloc = NULL;
	HRESULT hr;

	if( FAILED( hr = CoGetMalloc( MEMCTX_TASK, &lpMalloc ) ) )
	{
		FAILURE1( "CoGetMalloc() failed in CUnknown::StdFree(), reason %s", CDebug::Text( hr ) );
		return;
	}
	 
	lpMalloc->Free( pv );
	lpMalloc->Release(); 
}

LPVOID 
CUnknown::StdRealloc( LPVOID pv, ULONG cb )
{ 
	LPMALLOC lpMalloc = NULL;
	HRESULT hr;

	if( FAILED( hr = CoGetMalloc( MEMCTX_TASK, &lpMalloc ) ) )
	{
		FAILURE1( "CoGetMalloc() failed in CUnknown::StdRealloc(), reason %s", CDebug::Text( hr ) );
		return NULL;
	}
	 
	LPVOID lptr = lpMalloc->Realloc( pv, cb );
	lpMalloc->Release(); 

	return lptr; 
}

ULONG 
CUnknown::StdGetSize( LPVOID pv )
{ 
	LPMALLOC lpMalloc = NULL;
	HRESULT hr;

	if( FAILED( hr = CoGetMalloc( MEMCTX_TASK, &lpMalloc ) ) )
	{
		FAILURE1( "CoGetMalloc() failed in CUnknown::StdGetSize(), reason %s", CDebug::Text( hr ) );
		return 0;
	}
	 
	ULONG ul = lpMalloc->GetSize( pv );
	lpMalloc->Release(); 

	return ul; 
}

int 
CUnknown::StdDidAlloc( LPVOID pv )
{ 
	LPMALLOC lpMalloc = NULL;
	HRESULT hr;

	if( FAILED( hr = CoGetMalloc( MEMCTX_TASK, &lpMalloc ) ) )
	{
		FAILURE1( "CoGetMalloc() failed in CUnknown::StdDidAlloc(), reason %s", CDebug::Text( hr ) );
		return -1;
	}
	 
	int n = lpMalloc->DidAlloc( pv );
	lpMalloc->Release(); 

	return n; 
}

void 
CUnknown::StdHeapMinimize( void )
{ 
	LPMALLOC lpMalloc = NULL;
	HRESULT hr;

	if( FAILED( hr = CoGetMalloc( MEMCTX_TASK, &lpMalloc ) ) )
	{
		FAILURE1( "CoGetMalloc() failed in CUnknown::StdHeapMinimize(), reason %s", CDebug::Text( hr ) );
		return;
	}
	 
	lpMalloc->HeapMinimize();
	lpMalloc->Release(); 
}

/////////////////////////////////////////////////////////////////////////////
// CUnknown diagnostics
//
#ifdef _DEBUG
void CUnknown::AssertValid( void ) const
{
	ASSERT( AfxIsValidAddress( m_pUnkControl, sizeof(IUnknown), FALSE ) );
	m_unkInner.AssertValid();
	ASSERT( ! ::IsBadCodePtr( (FARPROC) s_pfnObjectDestroyed ) );
}

void CUnknown::Dump( CDumpContext& dc ) const
{
	dc << "\n";
	dc << "m_pUnkControl = " << m_pUnkControl;
	dc << "m_unkInner: ";
	m_unkInner.Dump( dc );
	dc << "s_pfnOjbectDestroyed = " << s_pfnObjectDestroyed;
}
#endif //_DEBUG
*/

/////////////////////////////////////////////////////////////////////////////
// IUnknown methods - all are delegated to m_pUnkControl, which will be
//	our own inner unknown unless we're aggregated
//
STDMETHODIMP
CUnknown::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	return m_pUnkControl->QueryInterface( riid, ppvObj );
}

STDMETHODIMP_(ULONG)
CUnknown::AddRef( void )
{
	//TRACE2( "AddRef for %s (this = %lX) : ", CDebug::Name( GetCLSID() ), this );
	
	return m_pUnkControl->AddRef();
}

STDMETHODIMP_(ULONG)
CUnknown::Release( void )
{
	//TRACE2( "Release for %s (this = %lX) : ", CDebug::Name( GetCLSID() ), this );
	
	return m_pUnkControl->Release();
}

/////////////////////////////////////////////////////////////////////////////
// Inner unknown constructor & destructor
//
CUnknown::CInnerUnknown::CInnerUnknown( CUnknown* pThis )
	: m_pThis( pThis )
{
	// CClassFactory assumes initial ref count is 1
	m_cRef = 1;
}

CUnknown::CInnerUnknown::~CInnerUnknown()
{
}

/////////////////////////////////////////////////////////////////////////////
// Inner IUnknown diagnostics
/*//
#ifdef _DEBUG
void CUnknown::CInnerUnknown::AssertValid( void ) const
{
	ASSERT( AfxIsValidAddress( m_pThis, sizeof(CUnknown), FALSE ) );
}

void CUnknown::CInnerUnknown::Dump( CDumpContext& dc ) const
{
	dc << "\n";
	dc << "m_cRef = " << m_cRef;
	dc << "m_pThis = " << m_pThis;
}
#endif //_DEBUG
*/

STDMETHODIMP_( void )
CUnknown::OnLastRelease( void )
{
	// default is to do nothing
	return;
}

/////////////////////////////////////////////////////////////////////////////
// Inner IUnknown methods
//
STDMETHODIMP
CUnknown::CInnerUnknown::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{

	// if aggregated, this is only called by the controlling unknown
    HRESULT hr = NOERROR;
	if( riid == IID_IUnknown )
	{
		*ppvObj = ( IUnknown * )( this );
	}
	else
	{
		// call the derived object's GetInterface method to get the proper
		// interface pointer
		hr = m_pThis->GetInterface( riid, ppvObj );
		if( FAILED( hr ) )
			return hr;
	}

	// increment the reference count of the returned interface.
	// unless GetInterface returned S_FALSE in which case the 
	// AddRef has already been done
	if( hr == NOERROR )
		( ( IUnknown * ) *ppvObj )->AddRef();
	return NOERROR;


}

STDMETHODIMP_( ULONG )
CUnknown::CInnerUnknown::AddRef( void )
{
	//TRACE1( "count = %lu\n", m_cRef + 1 );

	return ++m_cRef;
}

STDMETHODIMP_( ULONG )
CUnknown::CInnerUnknown::Release( void )
{
	//IF_DEBUG( AssertValid() );

	//TRACE1( "count = %lu\n", m_cRef - 1 );

	if( --m_cRef == 0 )
	{
		// give the derived class a chance to perform additional cleanup
		m_pThis->OnLastRelease();

		// notify the class factory that this object has been (is about to be) destroyed
		if( CUnknown::s_pfnObjectDestroyed )
			CUnknown::s_pfnObjectDestroyed( m_pThis->GetCLSID() );

		delete m_pThis;

		return 0l;
	}
	return m_cRef;
}

/*
/////////////////////////////////////////////////////////////////////////////
// $Log:   R:/Data/RTP/PH/src/vcs/cunknown.cpv  $
   
      Rev 1.4   05 Apr 1996 16:44:28   LSCLINE
   
   Copyright
   
      Rev 1.3   Dec 11 1995 13:34:20   rnegrin
   Fixed the PVCS log at end of file
   
      Rev 1.2   Dec 08 1995 16:41:12   rnegrin
   changed query interface back to how proshare does it. 
   now have a virtual pure GetInterface
// 
//    Rev 1.13   20 Sep 1995 16:05:16   PCRUTCHE
// OLEFHK32
// 
//    Rev 1.12   07 Mar 1995 16:37:34   AKHARE
// ARM compliant sizeof()
// 
//    Rev 1.11   01 Mar 1995 14:39:02   DEDEN
// Changed CUnknown:: static task allocator functions to call CoGetMalloc() every time
// 
//    Rev 1.10   17 Feb 1995 11:06:26   DEDEN
// Return HRESULT in GetStandardAllocator()
// 
//    Rev 1.9   17 Feb 1995 10:50:50   KAWATTS
// Added Get/Release StandardAllocator
// 
//    Rev 1.8   20 Jan 1995 11:34:28   PCRUTCHE
// Set allocator ptr to NULL when release
// 
//    Rev 1.7   29 Nov 1994 15:13:00   KAWATTS
// Added standard allocator support
// 
//    Rev 1.6   26 Oct 1994 17:50:52   JDELLIOT
// Objects are now created with ref count of 1... this was required for 
// aggregation.  CInnerUknown::QueryInterface now test the return value of 
// GetInterface... if it is S_FALSE we don't perform the AddRef.  Again this
// is for aggregation
// 
//    Rev 1.5   24 Oct 1994 16:22:10   KAWATTS
// Removed ASSERT( m_cRef > 0 ) from AssertValid; untrue during last release
// 
//    Rev 1.4   19 Oct 1994 14:57:56   JDELLIOT
// minor changes
// 
//    Rev 1.3   11 Oct 1994 17:09:00   KAWATTS
// Moved delete m_pThis after call through it in inner release
// 
//    Rev 1.2   07 Oct 1994 11:26:48   KAWATTS
// All rights reserved
// 
//    Rev 1.1   07 Oct 1994 09:51:18   JDELLIOT
// fixed PVCS keywords
//
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\fact.cpp ===
/****************************************************************************
 *  $Header:   J:\rtp\src\ppm\fact.cpv   1.3   20 Mar 1997 18:32:04   lscline  $
 *
 *  INTEL Corporation Proprietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *  Copyright (c) 1995, 1996 Intel Corporation. All rights reserved.
 *
 *  $Revision:   1.3  $
 *  $Date:   20 Mar 1997 18:32:04  $
 *  $Author:   lscline  $
 *
 *  Log at end of file.
 *
 *  Module Name:    psfact.cpp
 *  Abstract:       common OLE 2 class factory
 *  Environment:    MSVC 4.0, OLE 2
 *  Notes:
 *
 ***************************************************************************/

//#include "_stable.h"	// standard precompiled headers
#include  "core.h"
#include  <assert.h>

//***************************************************************************
// CClassFactory
//

/////////////////////////////////////////////////////////////////////////////
// static data members
ULONG NEAR CClassFactory::s_cLockServer = 0;
ULONG NEAR CClassFactory::s_cObjects = 0;
UNLOADSERVERPROC NEAR CClassFactory::s_pfnUnloadServer = NULL;
UINT NEAR CClassFactory::s_nRegistry = 0;
// registry defined by REGISTER_CLASS macros

/////////////////////////////////////////////////////////////////////////////
// ctor, dtor
CClassFactory::CClassFactory( Registry* pReg )
{
	m_cRef = 0;

	++s_cObjects;

	assert( pReg );
	assert( ! pReg->pFactory );
	m_pReg = pReg;
	m_pReg->pFactory = this;
}

CClassFactory::~CClassFactory()
{
	assert( m_pReg );
	assert( m_pReg->pFactory == this );
	m_pReg->pFactory = NULL;

	--s_cObjects;
}

/////////////////////////////////////////////////////////////////////////////
// IUnknown implementation
//
STDMETHODIMP
CClassFactory::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	if( riid == IID_IClassFactory || riid == IID_IUnknown )
	{
		*ppvObj = this;
	}
	else
		return ResultFromScode( E_NOINTERFACE );

	LPUNKNOWN( *ppvObj )->AddRef();
	return NOERROR;
}

STDMETHODIMP_(ULONG)
CClassFactory::AddRef( void )
{
	return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CClassFactory::Release( void )
{
	if( ! --m_cRef )
	{
		delete this;
		CanUnloadNow();
		return 0;
	}
	return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////
// IClassFactory implementation
//
STDMETHODIMP
CClassFactory::CreateInstance( LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppvObj )
{
	HRESULT hr;

	assert( ! IsBadWritePtr( ppvObj, sizeof( LPVOID FAR* ) ) );
	*ppvObj = NULL;

	// verify that IUnknown is requested when being aggregated
	if( pUnkOuter && riid != IID_IUnknown )
		return ResultFromScode( E_INVALIDARG );

	assert( m_pReg );

	// if it's a single instance class, return an existing instance if there is one
	if( m_pReg->regCls == REGCLS_SINGLEUSE )
	{
		if( m_pReg->pUnkSingle )
		{
			assert( 1 == m_pReg->cObjects );
			return m_pReg->pUnkSingle->QueryInterface( riid, ppvObj );
		}
	}

	// create the object
	LPUNKNOWN pUnkInner;
	hr = m_pReg->pfnCreate( pUnkOuter, ObjectDestroyed, &pUnkInner );
	if( FAILED( hr ) )
		return hr;
	if( ! pUnkInner )
		return ResultFromScode( E_UNEXPECTED );
    // ref count should now be 1, by our convention
    
	// If the riid is not implemented, the object will be destroyed, at which time
	// these variables will be decremented (see ObjectDestroyed).  If
	// these aren't incremented here we get ASSERTs in ObjectDestroyed.
	// This happens more often now that PsCreateInstance is used to
	// create the Settings object as it passes in IPsObject which is
	// not implemented by Settings.
	m_pReg->cObjects++;
	s_cObjects++;

	hr = pUnkInner->QueryInterface( riid, ppvObj );
	if( FAILED( hr ) )
	{	// delete object; ref count should be 1 here
		pUnkInner->Release();
		return hr;
	}
	
	// release object to account for extra reference on creation
	pUnkInner->Release();

	if( m_pReg->regCls == REGCLS_SINGLEUSE )
	{
		m_pReg->pUnkSingle = pUnkInner;
	}

	return NOERROR;
}

STDMETHODIMP
CClassFactory::LockServer( BOOL fLock )
{
	if( fLock )
	{
		++s_cLockServer;
		// check for overflow
		if( ! s_cLockServer )
			return ResultFromScode( E_UNEXPECTED );
	}
	else
	{
		// check for lock
		if( ! s_cLockServer )
			return ResultFromScode( E_UNEXPECTED );
		--s_cLockServer;
		// might be time to unload
		CanUnloadNow();
	}
	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// Check if server can be unloaded (no locks and no objects serviced).
// Calls s_pfnUnloadServer proc if provided
//
STDMETHODIMP
CClassFactory::CanUnloadNow( void )
{
	if( ! s_cLockServer && ! s_cObjects )
	{
		if( s_pfnUnloadServer )
			s_pfnUnloadServer();
		return ResultFromScode( S_OK );
	}
	return ResultFromScode( S_FALSE );
}

/////////////////////////////////////////////////////////////////////////////
// Callback from class when an object is destroyed. Allows server to be
// unloaded when no objects are being serviced
//
STDMETHODIMP_( void )
CClassFactory::ObjectDestroyed( REFCLSID rclsid )
{
	Registry* pReg = FindClass( &rclsid );
	if( pReg )
	{
		assert( pReg->cObjects );
		pReg->cObjects--;
		if( pReg->regCls == REGCLS_SINGLEUSE )
		{
			assert( ! pReg->cObjects );
			assert( pReg->pUnkSingle );
			pReg->pUnkSingle = NULL;
		}
	}
	assert( s_cObjects );
	s_cObjects--;
	// might be time to unload
	CanUnloadNow();
}

/////////////////////////////////////////////////////////////////////////////
// Find a class in the registry
//
CClassFactory::Registry*
CClassFactory::FindClass( const CLSID* pClsid )
{
	return (Registry*) bsearch( (const void*) &pClsid, (const void*) s_registry, 
								s_nRegistry, sizeof( Registry ), CompareClsids );
}

/////////////////////////////////////////////////////////////////////////////
// qsort/bsearch comparison function - compare class ids (or Registry entries)
//
#ifndef _DEBUG
#pragma function( memcmp )	// specifies that memcmp will be normal
#endif
int __cdecl
CClassFactory::CompareClsids( const void* pClsid1, const void* pClsid2 )
{
	return memcmp( *(const CLSID**)pClsid1, *(const CLSID**)pClsid2, sizeof( CLSID ) );
}
#ifndef _DEBUG
#pragma intrinsic( memcmp )	// specifies that memcmp will be intrinsic
#endif

/////////////////////////////////////////////////////////////////////////////
// sort the registry by clsid
//
void
CClassFactory::SortRegistry( void )
{
	if( ! s_nRegistry )
	{
		// count the registry
		for( Registry* pReg = s_registry; pReg->pClsid != &CLSID_NULL; pReg++ )
		{
			s_nRegistry++;
		}
		// sort the registry
		qsort( (void*) s_registry, s_nRegistry, sizeof( Registry ), CompareClsids );
	}
}

/////////////////////////////////////////////////////////////////////////////
// EXE server helper functions; set unload server callback proc,
// CoRegister/CoRevoke all classes registered with the class factory
//
void
CClassFactory::SetUnloadServerProc( UNLOADSERVERPROC pfnUnloadServer )
{
	assert( ! IsBadCodePtr( (FARPROC) pfnUnloadServer ) );
	s_pfnUnloadServer = pfnUnloadServer;
}

STDMETHODIMP
CClassFactory::RegisterAllClasses( DWORD dwClsContext )
{
	SortRegistry();
	Registry* pReg = s_registry;
	Registry* pEnd = s_registry + s_nRegistry;
	for( ; pReg < pEnd; pReg++ )
	{
		LPCLASSFACTORY pFactory = pReg->pFactory ? pReg->pFactory : newCClassFactory( pReg );
		if( ! pFactory )
			return ResultFromScode( E_OUTOFMEMORY );

		pFactory->AddRef();
		HRESULT hr = CoRegisterClassObject( *pReg->pClsid, pFactory, dwClsContext, pReg->regCls, &pReg->dwRegister );
		if( FAILED( hr ) )
		{
			pFactory->Release();
			return hr;
		}
	}
	return NOERROR;
}

STDMETHODIMP
CClassFactory::RevokeAllClasses( void )
{
	Registry* pReg = s_registry;
	Registry* pEnd = s_registry + s_nRegistry;
	for( ; pReg < pEnd; pReg++ )
	{
		HRESULT hr = CoRevokeClassObject( pReg->dwRegister );
		if( FAILED( hr ) )
			return hr;
		if( pReg->pFactory )
			pReg->pFactory->Release();
	}
	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// DLL server helper function; call from DllGetClassObject
//
STDMETHODIMP
CClassFactory::GetClassObject(
	REFCLSID	rclsid,
	REFIID		riid,
	LPVOID FAR*	ppvObj
	)
{
	assert( ! IsBadWritePtr( ppvObj, sizeof( LPVOID FAR* ) ) );

	SortRegistry();
	Registry* pReg = FindClass( &rclsid );
	if( ! pReg )
		return ResultFromScode( CLASS_E_CLASSNOTAVAILABLE );

	CClassFactory* pFactory = pReg->pFactory ? pReg->pFactory : newCClassFactory( pReg );
	if( ! pFactory )
		return ResultFromScode( E_OUTOFMEMORY );

	HRESULT hr = pFactory->QueryInterface( riid, ppvObj );
	if( FAILED( hr ) )
	{
		// if we just created the factory its ref count will be 0 and we
		// need to delete it. Otherwise it must continue to exist.
		pFactory->AddRef();
		pFactory->Release();
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// local CoCreateInstance; call when creating come objects locally
//   (not via CoCreateInstance)
//
STDMETHODIMP
CClassFactory::LocalCreateInstance(
	REFCLSID	rclsid,
	LPUNKNOWN	pUnkOuter,
	DWORD		dwClsContext,
	REFIID		riid,
	LPVOID FAR*	ppvObj
	)
{
	dwClsContext;	// to statisfy the compiler
	
	// get the class factory for the requested object
	LPCLASSFACTORY	lpClassFactory;
	HRESULT hr = GetClassObject( rclsid, IID_IClassFactory, (LPVOID FAR*) &lpClassFactory );
	if( FAILED( hr ) )
		return hr;

	// create an instance of the requested object and get the requested interface
	hr = lpClassFactory->CreateInstance( pUnkOuter, riid, ppvObj );
	lpClassFactory->Release();
	
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Method to help with dynamic memory allocation of a CClassFactory object.
//

CClassFactory*	CClassFactory::newCClassFactory( Registry* pReg )
{																   
	CClassFactory *p = NULL;											   
//	TRY															   
//	{															   
		p = new CClassFactory( pReg );											   
//	}															   
//	CATCH( CMemoryException, e )								   
//	{															   
//		TRACE0( "Caught memory exception in CClassFactory::newCClassFactory\n" );   
//	}															   
//	END_CATCH													   
	return p;													   
}	


/*
/////////////////////////////////////////////////////////////////////////////
// $Log:   J:\rtp\src\ppm\fact.cpv  $
   
      Rev 1.3   20 Mar 1997 18:32:04   lscline
   Merged small change differences for MS NT 5.0 build environment.
   
   
      Rev 1.2   05 Apr 1996 16:46:00   LSCLINE
   
   Copyright
   
      Rev 1.1   Dec 11 1995 13:39:08   rnegrin
    Fixed the PVCS log at end of file
   
      Rev 1.0   Dec 08 1995 16:41:06   rnegrin
   Initial revision.
// 
//    Rev 1.12   20 Sep 1995 16:05:14   PCRUTCHE
// OLEFHK32
// 
//    Rev 1.11   13 Jun 1995 19:36:00   DEDEN
// Dynamic object allocation helper functions\macros
// 
//    Rev 1.10   06 Jan 1995 09:56:44   PCRUTCHE
// Changed registry data structure
// 
//    Rev 1.9   02 Nov 1994 10:50:00   JDELLIOT
// get rid of compiler warnings
// 
//    Rev 1.8   28 Oct 1994 13:51:16   JDELLIOT
// added LocalCreateInstance for creating local COM objects (not via
// CoCreateInstance)
// 
//    Rev 1.7   26 Oct 1994 17:52:44   JDELLIOT
// in CreateInstance after calling _CreateObject the object now has a ref count
// of 1.  As such when we QueryInterface the ref count goes to 2 and we need
// to Release it back down to one.  This was added for aggregation.
// 
//    Rev 1.6   25 Oct 1994 14:42:42   KAWATTS
// Removed TRACEs again
// 
//    Rev 1.5   25 Oct 1994 10:21:02   JDELLIOT
// added TRACEs for s_cObjects
// 
//    Rev 1.4   19 Oct 1994 14:57:48   JDELLIOT
// minor changes
// 
//    Rev 1.3   12 Oct 1994 18:11:58   JDELLIOT
// changed params to CClassFactory::FindClass
// fixed AddRef inside CClassFactory::QueryInterface
// 
//    Rev 1.2   07 Oct 1994 11:26:46   KAWATTS
// All rights reserved
// 
//    Rev 1.1   07 Oct 1994 09:51:14   JDELLIOT
// fixed PVCS keywords
//
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\freelist.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: freelist.cpp
//  Abstract:    source file. a data structure for maintaining a pool of memory.
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////

#include "freelist.h"
#include "que.h"
#include "ppmerr.h"
#include "debug.h"  // for the ASSERT macro and assert.h; OK since compile time only

long lFreeListHeapCreate = 0;
long lFreeListHeapDestroy = 0;
long lFreeListHeapAlloc = 0;
long lFreeListHeapFree = 0;
long lFreeListHeapCreateFailed = 0;

// Uncomment next line to have some extra debug information
// (also in free builds)
// set to 1 for checking but no messages
// set to 2 for error messages
// set to 3 for the max available and DebugBreak
// DEBUG_FREELIST is defined in sources

#if DEBUG_FREELIST > 0
long lFreeListLeak = 0;
long lFreeListEnqueueTwice = 0;
long lFreeListFreeTwice = 0;
long lFreeListCorruptBegin = 0;
long lFreeListCorruptEnd = 0;

char begin_buf_pattern[FREE_LIST_SIG_SIZE] =
{'F', 'R', 'E', 'E', 'B', 'E','G', 'N'};
char end_buf_pattern[FREE_LIST_SIG_SIZE] =
{'F', 'R', 'E', 'E', ' ', 'E', 'N','D'};
char free_buf_pattern[FREE_LIST_SIG_SIZE] =
{'F', 'R', 'E', 'E', 'B', 'U', 'F','F'};
#endif	

#if DEBUG_FREELIST > 2
#define DEBUGBREAK() DebugBreak()
#else
#define DEBUGBREAK()
#endif

FreeList::FreeList(HRESULT *phr)
{
	DBG_MSG(DBG_ERROR, ("FreeList::FreeList: Constructor with no Params"));
	
	m_Size = 0;
	InitializeCriticalSection(&m_CritSect);
	m_HighWaterCount = 0;
	m_AllocatedCount = 0;
	m_Increment = 0;
	m_Tag = FREE_LIST_TAG;

	*phr = PPMERR(PPM_E_OUTOFMEMORY);

	//m_hMemAlloc = HeapCreate(HEAP_GENERATE_EXCEPTIONS, 1, 0);
	m_hMemAlloc = HeapCreate(0, 1, 0);
	ASSERT(m_hMemAlloc);
	
	if (m_hMemAlloc) {
		SetHandleInformation(m_hMemAlloc,
							 HANDLE_FLAG_PROTECT_FROM_CLOSE,
							 HANDLE_FLAG_PROTECT_FROM_CLOSE);
		InterlockedIncrement(&lFreeListHeapCreate);
		*phr = NOERROR;
	} else {
		InterlockedIncrement(&lFreeListHeapCreateFailed);
	}
}

FreeList::FreeList(int NumElements, size_t Size, HRESULT *phr)
{
	int enqueued = 0;
#ifdef PDEBUG
	DBG_MSG(DBG_TRACE, ("FreeList::Freelist: Constructor with 2 params"));
#endif
	/*
	//Make sure there is enough memory to typecast
	//each item to a QueItem for storage.
   
	ASSERT(Size >= sizeof(QueueItem));
	ASSERT( NumElements > 0 );
   
	InitializeCriticalSection(&m_CritSect);
	EnterCriticalSection(&m_CritSect);

	m_Size = Size;
	m_pMemory = new char [(Size*NumElements)];  //new may not be the best memory allocator here.
   
	if (m_pMemory) {
     
      for (int i=0; i < NumElements; i++)
      {
         m_List.Enqueue((QueueItem*)&(m_pMemory[Size*i]));
      }
	}
	*/
	
	//Make sure there is enough memory to typecast
	//each item to a QueItem for storage.
   
	ASSERT(Size >= sizeof(QueueItem));
	ASSERT( NumElements > 0 );

	InitializeCriticalSection(&m_CritSect);
	m_Size = Size;
	m_AllocatedCount = 0;
	m_Tag = FREE_LIST_TAG;

	*phr = PPMERR(PPM_E_OUTOFMEMORY);

	m_hMemAlloc = HeapCreate(0, 1, 0);
	ASSERT(m_hMemAlloc);
	
	if (m_hMemAlloc) {
		SetHandleInformation(m_hMemAlloc,
							 HANDLE_FLAG_PROTECT_FROM_CLOSE,
							 HANDLE_FLAG_PROTECT_FROM_CLOSE);
		InterlockedIncrement(&lFreeListHeapCreate);
	} else {
		InterlockedIncrement(&lFreeListHeapCreateFailed);
	}
	
	if ( (enqueued = AllocateAndEnqueue( NumElements )) > 0 )
		*phr = NOERROR;

	EnterCriticalSection(&m_CritSect);
	
	m_HighWaterCount = enqueued;
	m_Increment = 0;
		
	LeaveCriticalSection(&m_CritSect);
}

FreeList::FreeList(int NumElements, size_t Size, unsigned HighWaterCount,
				   unsigned Increment, HRESULT *phr)
{
	int enqueued = 0;
	
	ASSERT(HighWaterCount >= (unsigned)NumElements);
	
	//Make sure there is enough memory to typecast
	//each item to a QueItem for storage.
   
	ASSERT(Size >= sizeof(QueueItem));
	ASSERT( NumElements > 0 );
	

	InitializeCriticalSection(&m_CritSect);
	m_Size = Size;
	m_AllocatedCount = 0;
	m_Tag = FREE_LIST_TAG;

	*phr = PPMERR(PPM_E_OUTOFMEMORY);

	m_hMemAlloc = HeapCreate(0, 1, 0);
	ASSERT(m_hMemAlloc);
	
	if (m_hMemAlloc) {
		SetHandleInformation(m_hMemAlloc,
							 HANDLE_FLAG_PROTECT_FROM_CLOSE,
							 HANDLE_FLAG_PROTECT_FROM_CLOSE);
		InterlockedIncrement(&lFreeListHeapCreate);
	} else {
		InterlockedIncrement(&lFreeListHeapCreateFailed);
	}

	if ( (enqueued = AllocateAndEnqueue( NumElements )) > 0 )
		*phr = NOERROR;
	
	EnterCriticalSection(&m_CritSect);
	
	m_HighWaterCount = HighWaterCount;
	
	m_Increment = Increment;
	
	LeaveCriticalSection(&m_CritSect);

}

void * FreeList::Get()
{
	void *v_ptr;
	int enqueued = 0;

	EnterCriticalSection(&m_CritSect);

	v_ptr = (void *) m_List.DequeueHead();

#if DEBUG_FREELIST > 2
	{
		char str[128];
		wsprintf(str, "0x%X +++ %5d %5d/%2d 0x%X\n",
				 this, m_Size, m_List.NumItems(), m_AllocatedCount, v_ptr);
		OutputDebugString(str);
	}
#endif	

	LeaveCriticalSection(&m_CritSect);

	if( v_ptr != NULL )
	{
#ifdef PDEBUG
		DBG_MSG(DBG_TRACE, ("FreeList::Get: Successful deque"));
#endif
#if DEBUG_FREELIST > 0
		// Set signature in boundaries
		memcpy((char *)v_ptr - FREE_LIST_SIG_SIZE,
			   begin_buf_pattern, FREE_LIST_SIG_SIZE);
		memcpy((char *)v_ptr + m_Size, end_buf_pattern, FREE_LIST_SIG_SIZE);
#endif	
		return v_ptr;
	}
	else
	{
#ifdef PDEBUG
		DBG_MSG(DBG_TRACE, ("FreeList::Get: High Water Mark-case deque"));
#endif
		if( m_AllocatedCount < m_HighWaterCount )
		{
#if DEBUG_FREELIST > 1
			{
				char msg[128];
				wsprintf(msg,
						 "0x%X +++ %5d %5d/%2d add +%d\n",
						 this, m_Size, 0, m_AllocatedCount, m_Increment);
				OutputDebugString(msg);
				DEBUGBREAK();
			}
#endif	
			enqueued = AllocateAndEnqueue( m_Increment );
			if( enqueued > 0 )
			{
#ifdef PDEBUG
				DBG_MSG(DBG_TRACE, ("FreeList::Get: High Water Mark-Successful allocate & deque"));
#endif
				EnterCriticalSection(&m_CritSect);

				v_ptr = (void *)m_List.DequeueHead();

#if DEBUG_FREELIST > 2
				{
					char str[128];
					wsprintf(str, "0x%X +++ %5d %5d/%2d 0x%X\n",
							 this, m_Size, m_List.NumItems(),
							 m_AllocatedCount, v_ptr);
					OutputDebugString(str);
				}
#endif	
				LeaveCriticalSection(&m_CritSect);

#if DEBUG_FREELIST > 0
				// Set signature in boundaries
				memcpy((char *)v_ptr - FREE_LIST_SIG_SIZE,
					   begin_buf_pattern, FREE_LIST_SIG_SIZE);
				memcpy((char *)v_ptr + m_Size,
					   end_buf_pattern, FREE_LIST_SIG_SIZE);
#endif	

				return(v_ptr);
			}
			else
			{
				DBG_MSG(DBG_ERROR, ("FreeList::Get: High Water Mark-Could not allocate"));
				return NULL;
			}
		}
		else
		{
			DBG_MSG(DBG_ERROR, ("FreeList::Get: High Water mark-exceeded"));
			return NULL;
		}
	}
}

HRESULT FreeList::Free(void * Element)
{
#if DEBUG_FREELIST > 0
	int error = 0;
	int nofree = 0;
#endif	

	EnterCriticalSection(&m_CritSect);

#if DEBUG_FREELIST > 2
	{
		char str[128];
		wsprintf(str, "0x%X --- %5d %5d/%2d 0x%X\n",
				 this, m_Size, m_List.NumItems()+1, m_AllocatedCount, Element);
		OutputDebugString(str);
	}
#endif	

#if DEBUG_FREELIST > 0
	// Check if the buffer was already released
	if (!memcmp((char *)Element - FREE_LIST_SIG_SIZE,
				free_buf_pattern, FREE_LIST_SIG_SIZE)) {
		
#if DEBUG_FREELIST > 1
		char str[128];
		wsprintf(str,
				 "0x%X --- Heap[0x%X]: Element in 0x%X size=0x%X "
				 "is been freed twice\n",
				 this, m_hMemAlloc,
				 (char *)Element - FREE_LIST_SIG_SIZE,
				 m_Size);
		OutputDebugString(str);
#endif
		InterlockedIncrement(&lFreeListFreeTwice);
		nofree = 1;
	}

	// Check signatures on each boundary
	if (memcmp((char *)Element - FREE_LIST_SIG_SIZE,
			   begin_buf_pattern, FREE_LIST_SIG_SIZE)) {
		
#if DEBUG_FREELIST > 1
		char str[128];
		wsprintf(str,
				 "0x%X --- Heap[0x%X]: Element in 0x%X size=0x%X "
				 "has beginning signature corrupted at: 0x%X\n",
				 this, m_hMemAlloc,
				 (char *)Element - FREE_LIST_SIG_SIZE,
				 m_Size,
				 (char *)Element - FREE_LIST_SIG_SIZE);
		OutputDebugString(str);
#endif
		InterlockedIncrement(&lFreeListCorruptBegin);
		error = 1;
	}

	if (memcmp((char *)Element + m_Size,
			   end_buf_pattern, FREE_LIST_SIG_SIZE)) {

#if DEBUG_FREELIST > 1
		char str[128];
		wsprintf(str,
				 "0x%X --- Heap[0x%X]: Element in 0x%X size=0x%X "
				 "has ending signature corrupted at: 0x%X\n",
				 this, m_hMemAlloc,
				 (char *)Element - FREE_LIST_SIG_SIZE,
				 m_Size,
				 (char *)Element + m_Size);
		OutputDebugString(str);
#endif
		InterlockedIncrement(&lFreeListCorruptEnd);
		error = 1;
	}

	if (error || nofree) {
		DEBUGBREAK();
	}
#endif	
	
	HRESULT err;
		
#if DEBUG_FREELIST > 0
	if (!nofree) {
		memcpy((char *)Element - FREE_LIST_SIG_SIZE,
			   free_buf_pattern, FREE_LIST_SIG_SIZE);
		err = m_List.EnqueueHead((QueueItem *)Element);
	} else {
		err = NOERROR;
	}
#else
	err = m_List.EnqueueHead((QueueItem *)Element);
#endif	

	LeaveCriticalSection(&m_CritSect);
	
	return(err);
}

int FreeList::AllocateAndEnqueue(int NumElements)
{
	int enqueued = 0;
	char * pMemory = NULL;
	
	ASSERT( NumElements > 0 );
   
	// Replacement for the ASSERTs
	
	if( NumElements <= 0 )
	{
		return 0;
	}
	
	EnterCriticalSection(&m_CritSect);

	//pMemory = new char [(m_Size*NumElements)];  //new may not be the best memory allocator here.

	if (m_hMemAlloc) {
		for (int i=0; i < NumElements; i++)
		{
			// Get some more bytes to put a signature
			// at the beggining and end of buffer
#if DEBUG_FREELIST > 0
			pMemory = (char *)HeapAlloc(m_hMemAlloc,
										0,
										m_Size + FREE_LIST_SIG_SIZE*2);
#else
			pMemory = (char *)HeapAlloc(m_hMemAlloc,
										0,
										m_Size);
#endif
			if(pMemory )
			{
#ifdef PDEBUG
				DBG_MSG(DBG_TRACE,
						("FreeList::AllocateAndEnqueue: Allocated"));
#endif
#if DEBUG_FREELIST > 0
				// Shift to make room for beggining signature
				pMemory += FREE_LIST_SIG_SIZE;
#endif	
				
				m_List.EnqueueTail((QueueItem*)(pMemory));
				enqueued++;
				InterlockedIncrement(&lFreeListHeapAlloc);
				pMemory = NULL;
			}
		}
		m_AllocatedCount+= enqueued;
	}

	LeaveCriticalSection(&m_CritSect);
	
	return enqueued;
}

FreeList::~FreeList()
{
	void * v_ptr;
	unsigned free_count = 0;

	EnterCriticalSection(&m_CritSect);
	if (m_hMemAlloc) {
		while( (v_ptr = (void *) m_List.DequeueTail()) != NULL ) {
			// Shift pointer before freeing
			v_ptr = (char *)v_ptr - FREE_LIST_SIG_SIZE;

			if (HeapFree(m_hMemAlloc, 0, v_ptr)) {
				InterlockedIncrement(&lFreeListHeapFree);
				++free_count;
			} else {
#if DEBUG_FREELIST > 1
				char msg[128];
				DWORD error = GetLastError();
				wsprintf(msg,
						 "0x%X FreeList::~FreeList: "
						 "HeapFree failed: %d (0x%x)\n",
						 this, error, error);
				DBG_MSG(DBG_ERROR, (msg));
				OutputDebugString(msg);
				DEBUGBREAK();
#endif	
			}
		}
	}
	LeaveCriticalSection(&m_CritSect);

#if defined(_DEBUG) || DEBUG_FREELIST > 0
	if( free_count != m_AllocatedCount )
	{
#if defined(_DEBUG) || DEBUG_FREELIST > 1
		char msg[128];
		wsprintf(msg,"0x%X FreeList::~FreeList: "
				 "Memory leak in Freelist(size=%d) "
				 "(free_count:%d != %d:m_AllocatedCount)\n",
				 this, m_Size, free_count, m_AllocatedCount);
		OutputDebugString(msg);
#endif
#if DEBUG_FREELIST > 0
		InterlockedIncrement(&lFreeListLeak);
		DEBUGBREAK();
#endif
	}
#endif

	if (m_hMemAlloc) {
		SetHandleInformation(m_hMemAlloc, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0);
		HeapDestroy(m_hMemAlloc);
		InterlockedIncrement(&lFreeListHeapDestroy);
	}
	m_hMemAlloc = NULL;

	DeleteCriticalSection(&m_CritSect);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\g711.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: g711.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#ifndef G711_H
#define G711_H

#define G711_PT   0		//assigned RTP payload number for PCMU

#endif // G711_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\g711a.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: g711a.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#ifndef G711A_H
#define G711A_H

#define G711A_PT   8		//assigned RTP payload number for PCMA

#endif // G711A_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\g711asnd.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: g711asnd.cpp
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#include "g711asnd.h"

G711A_ppmSend::G711A_ppmSend(IUnknown* pUnkOuter, 
						   IUnknown** ppUnkInner) : 
		ppmSend(G711A_PT, 0, 
				8000, pUnkOuter, ppUnkInner),
        
        m_dwLastTimeStamp(0)
{
}

G711A_ppmSend::~G711A_ppmSend()
{
}

IMPLEMENT_CREATEPROC(G711A_ppmSend);

//////////////////////////////////////////////////////////////////////////////////////////
//SetMarkerBit: Determines whether to set the marker bit or not.  lastPacket is TRUE if
//				this is the last packet of the frame; FALSE if not.	 With audio, we don't
//				don't care about fragmentation, just the start of a talkspurt.
//////////////////////////////////////////////////////////////////////////////////////////
BOOL G711A_ppmSend::SetMarkerBit(BOOL lastPacket)
{
	return m_markTalkSpurt;
}

//////////////////////////////////////////////////////////////////////////////////////////
//MakeTimeStamp: Generate a time stamp based on the frequency specified in the Profile Spec.
//////////////////////////////////////////////////////////////////////////////////////////
DWORD G711A_ppmSend::MakeTimeStamp(MsgDescriptor* pMsgDescrip, 
								   BOOL bStartStream,
								   BOOL bUseInputTime)
{

#ifndef TIMESTAMP_OFF 

       
       DWORD ThisTimeStamp;
       DWORD CurTime = timeGetTime();
	   DWORD delta;
       DWORD epsilon;
    
    if (bUseInputTime) CurTime = pMsgDescrip->m_TimeStamp;

	// calculate the time span encoded in this packet
    delta = CountFrames((char *) pMsgDescrip->m_pBuffer, pMsgDescrip->m_Size) / (m_Frequency/1000);
    epsilon = delta/2;

    // init, do it here so it is set when we get the first packet
    // not at init time, they may be significantly different
	// Generate our first time stamp based on the current time.
    if (m_dwStartTime == 0)
    {
		// if the first packet we receive is a drop or silence then the delta will
		// be zero.  We just won't do anything until we receive valid data.
		if (delta != 0)
		{
			m_dwStartTime = CurTime;
			m_dwLastTime = m_dwStartTime -  delta;
			ThisTimeStamp = (((CurTime - m_dwStartTime) + (epsilon)) / delta) * delta * (m_Frequency/1000);
		}
	}
    else
	if (bStartStream)
	{
		// bStartStream will be set if this is the first packet after a break in a 
		// data stream.  We need to get our time stamps back on track, so we'll generate a time
		// based on the current time.  This case can happen if for some reason the capture device
		// gets starved or we are in half duplex and we are switching to talk mode.
		if (delta != 0)
		{
			ThisTimeStamp = (((CurTime - m_dwStartTime) + (epsilon)) / delta) * delta * (m_Frequency/1000);
		}
		else
		{
			ThisTimeStamp = (((CurTime - m_dwStartTime) + (epsilon)) / m_dwLastDelta) * m_dwLastDelta * (m_Frequency/1000);
			ThisTimeStamp -= m_dwLastDelta * (m_Frequency/1000);
		}
    }
	else
	{
	    // if we are in a continuous audio data stream, then we just want to increment our timestamp
		// for this data packet.  We don't want to use the current time because we don't know how long
		// it took from the time the data was acutally captured to the time we got it.  We have to rely
		// on the person feeding us data to let us know more information about the data stream.
		ThisTimeStamp = m_dwLastTimeStamp + CountFrames((char *) pMsgDescrip->m_pBuffer, pMsgDescrip->m_Size);
	}

	m_dwLastTimeStamp = ThisTimeStamp;
    m_dwLastTime = CurTime;
	if (delta != 0)
	{
		m_dwLastDelta = delta;
	}
    return ThisTimeStamp;
#else
//I changed this because the times I was getting were widely spaced.  When I was in debugging
//mode.
static DWORD CurTime = 0;
CurTime++;
#endif 

return CurTime;
}


int G711A_ppmSend::CountFrames(char *ipBuffer, int len)
{
   return len;		//1 byte per frame
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\g711arcv.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: g711arcv.cpp
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#include "ppmerr.h"
#include "g711arcv.h"

G711A_ppmReceive::G711A_ppmReceive(IUnknown* pUnkOuter, 
								 IUnknown** ppUnkInner)
	: ppmReceive(G711A_PT, G711A_BUFFER_SIZE, 0, pUnkOuter, ppUnkInner)
{
	m_FirstAudioChunk = TRUE;
	m_reg_DeltaTime          = 0;    //in miliseconds time to determine a packet is stale

}

G711A_ppmReceive::~G711A_ppmReceive()
{
}

IMPLEMENT_CREATEPROC(G711A_ppmReceive);

//////////////////////////////////////////////////////////////////////////////////////////
//TimeToProcessMessages: Any time a packet comes in, it's time to process messages
//////////////////////////////////////////////////////////////////////////////////////////
BOOL G711A_ppmReceive::TimeToProcessMessages(FragDescriptor *pFragDescrip, MsgHeader *pMsgHdr)
{
   return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////////
//ProcessMessages: 
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT G711A_ppmReceive::ProcessMessages(void)
{

	HRESULT rval;
	int retVal;

	EnterCriticalSection(&m_CritSec);

	while(m_pMsgHeadersHead != NULL)
    {
		retVal = CheckMessageComplete(m_pMsgHeadersHead);
		switch( retVal )
		{
		  case TRUE:
		  {
			
			if FAILED(rval = PrepMessage(TRUE)) 
			{
				DBG_MSG(DBG_ERROR, ("G711A_ppmReceive::ProcessMessages: ERROR - PrepMessage failed"));
				LeaveCriticalSection(&m_CritSec);
				return rval;
		    }
			else
				break;
          }
		  case FALSE:
		  {
			
			if FAILED(rval = PrepMessage(FALSE)) 
			{
				DBG_MSG(DBG_ERROR, ("G711A_ppmReceive::ProcessMessages: ERROR - PrepMessage failed"));
				LeaveCriticalSection(&m_CritSec);
				return rval;
			}
			else
				break;
		  }
		  case DO_NOT_PROCESS:
		  {
                DBG_MSG(DBG_TRACE, ("G711A_ppmReceive::ProcessMessages: CheckMessageComplete returned DO_NOT_PROCESS"));
	            LeaveCriticalSection(&m_CritSec);
                return NOERROR;
		  }
		  default:
		  {
                DBG_MSG(DBG_TRACE, ("G711A_ppmReceive::ProcessMessages: CheckMessageComplete returned unknown"));
	            LeaveCriticalSection(&m_CritSec);
				return NOERROR;
		  }
	    }
    }
   //List is empty
   LeaveCriticalSection(&m_CritSec);
   return NOERROR;
}
          
//////////////////////////////////////////////////////////////////////////////////////////
//G711A_ppmReceive::CheckMessageComplete: //return value is int
//////////////////////////////////////////////////////////////////////////////////////////
int G711A_ppmReceive::CheckMessageComplete(MsgHeader *pMsgHdr) 
{
	//if there is no header then return false.
    if (pMsgHdr  == NULL)
    {
        DBG_MSG(DBG_ERROR, ("G711A_ppmReceive::CheckMessageComplete: ERROR - pMsgHdr == NULL"));
        return FALSE;
    }
     
    //should there be a critical section in this function.  What about wraps?
     
     
    if(m_FirstAudioChunk)                         // handle very first chunk 
    {
         m_FirstAudioChunk = FALSE;               //Send it up, no matter what
     
         return TRUE;
    }
     
    if (m_GlobalLastSeqNum+1 == pMsgHdr->m_pFragList->FirstSeqNum())
	// Is this message in order ?
    {
          return TRUE;
    }
     
    if( CheckMessageStale(pMsgHdr))               // Check if we timed out 
    {
         return TRUE;                              // Send it up as we have waited long enough
    }
     
    return DO_NOT_PROCESS;                    // Continue and wait for next iteration
     
}



//////////////////////////////////////////////////////////////////////////////////////////
// PartialMessageHandler: deals with partial messages
// This overriden version is used by FlushData from ppmrcv.cpp
// Unlike partial message handlers for video, this function sends up all the
// pending data in the audio queues
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT G711A_ppmReceive::PartialMessageHandler(MsgHeader *pMsgHdr)
{
	return (DataCopy( pMsgHdr ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\g711arcv.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: g711arcv.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#ifndef G711ARCV_H
#define G711ARCV_H

#include "ppmrcv.h"
#include "ppmclsid.h"
#include "g711a.h"

#define G711A_BUFFER_SIZE 5000
#define DO_NOT_PROCESS		5

class G711A_ppmReceive : public ppmReceive
{

private:
	BOOL m_FirstAudioChunk;

public:

G711A_ppmReceive(IUnknown* pUnkOuter, 
				IUnknown** ppUnkInner);
~G711A_ppmReceive();

DECLARE_CREATEPROC()

STDMETHODIMP_( const CLSID& ) GetCLSID( void ) const {return CLSID_G711APPMReceive;}

STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{return CUnknown::QueryInterface(riid, ppvObj);}

STDMETHODIMP GetInterface( REFIID riid, LPVOID FAR* ppvObj )
{return ppmReceive::GetInterface( riid, ppvObj );}

STDMETHODIMP_( ULONG )AddRef( void )
{return CUnknown::AddRef();}

STDMETHODIMP_( ULONG )Release( void )
{return CUnknown::Release();}

//////////////////////////////////////////////////////////////////////////////////////////
//TimeToProcessMessages:
//////////////////////////////////////////////////////////////////////////////////////////
virtual BOOL TimeToProcessMessages(FragDescriptor *pFragDescrip, MsgHeader *pMsgHdr);
 
//////////////////////////////////////////////////////////////////////////////////////////
//CheckMessageComplete: 
//////////////////////////////////////////////////////////////////////////////////////////
virtual BOOL CheckMessageComplete(MsgHeader *pMsgHdr); 

//////////////////////////////////////////////////////////////////////////////////////////
//ProcessMessages: 
//////////////////////////////////////////////////////////////////////////////////////////
virtual HRESULT ProcessMessages(void);

//////////////////////////////////////////////////////////////////////////////////////////
//PartialMessageHandler: deals with partial messages
//////////////////////////////////////////////////////////////////////////////////////////
virtual HRESULT PartialMessageHandler(MsgHeader *pMsgHdr);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\freelist.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: freelist.h
//  Abstract:    header file. a data structure for maintaining a pool of memory.
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
//NOTE: This structure is useful if you will be making several calls to new and delete
//      during the course of a program.  To use this structure, you create a new freelist.
//      You must give it a size and quantitity.  To get a chunk of uninitialized memory you use 
//      Get(). This is useful for structures and types that don't need any initialization.  
//
//      If you are planning to use this memory as a class then use the overloaded new operator
//      This will gurantee that the constructor is called. (see bottom of file) the overloaded
//      new operator takes two paramters. A size and a pointer to a free list. The size of the 
//      object must be bigger than sizeof(QueItem).  
//      
//      To put memory back in the free list you call Free().
/////////////////////////////////////////////////////////////////////////////////

#ifndef FREELIST_H
#define FREELIST_H

#include "que.h"
#include "debug.h"	//for ASSERT macro, assert.h
#include <wtypes.h>


extern long numHeapCreate;
extern long numHeapCreateFailed;

#define FREE_LIST_TAG 0x112233aa
#define FREE_LIST_SIG_SIZE 8

class FreeList {

private:
Queue  m_List;
DWORD  m_Tag;	
CRITICAL_SECTION m_CritSect;
size_t m_Size;
unsigned m_HighWaterCount;
unsigned m_AllocatedCount;
unsigned m_Increment;
HANDLE   m_hMemAlloc;
// This is a private function to allocate memory and enqueue in
// the queue. This function will get used by more than one function
// in this class.

int AllocateAndEnqueue( int NumElements );

//only need this if I Get is private. But you might want to call get 
//if you want a free list of things that are not classes and therefore 
//don't need there constructors called.
//friend  void * operator new(size_t size, FreeList *l);

public:

//inline default constructor do I want this?
FreeList(HRESULT *phr);

//2nd constructor. Size must be at least the size of a QueItem
FreeList(int NumElements, size_t Size, HRESULT *phr); 

//3rd constructor. Size must be at least the size of a QueItem
// HighWaterCount is the count till which dynamic allocation will take
// place. Initial allocation will be based on NumElements
FreeList(int NumElements, size_t Size, unsigned HighWaterCount,
		 unsigned Increment, HRESULT *phr); 

~FreeList();
				

//inline. Gets a chunk of memeory from list, but does NOT do any initialization.
//Need to type cast return value to correct type
void * Get();

//inline. Frees piece of memory.
HRESULT  Free(void * Element);

//inline. returns true if list is empty; false otherwise
BOOL   Is_Empty() const
	{return m_List.Is_Empty();};

//returns the size of the fragments that it creates and stores.
size_t    Size() const
	{return m_Size;};

	// returns the current count
	int Count() const
		{
			return(m_List.NumItems());
		}

	int MaxCount() const
		{
			return(m_AllocatedCount);
		}
	
}; //end class FreeList

//inline. Overload the new operator. 
//Gets a chunk of memory from free list and calls the constructor on that chunk of memory.
//The constructor is that of the object new is called on. The returned
//pointer is of the correct type. (just like the real new operator)

//example:
//class FooClass;
// pFoo = new(pSomeFreeList) FooClass;
inline void * operator new(size_t size, FreeList *l)
{
//lsc
ASSERT(l->Size() == size);	//Is this needed beyond compile time?  If so, output message
							//instead
return l->Get();
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\g711asnd.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: g711asnd.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#ifndef G711ASND_H
#define G711ASND_H

#include "ppmsnd.h"
#include "ppmclsid.h"
#include "g711a.h"

class G711A_ppmSend : public ppmSend
{
    DWORD m_dwLastTimeStamp;
    DWORD m_dwStartTime;
    DWORD m_dwLastTime;
    DWORD m_dwLastDelta;
protected:

//////////////////////////////////////////////////////////////////////////////////////////
//CountFrames: Determine how many frames are in the buffer
//////////////////////////////////////////////////////////////////////////////////////////
int CountFrames(char *pBuffer, int len);

////////////////////////////////////////////////////////////////////////////////////
// PPMSend Functions (Overrides)
////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
//SetMarkerBit: Determines whether to set the marker bit or not.  lastPacket is TRUE if
//				this is the last packet of the frame; FALSE if not.
//////////////////////////////////////////////////////////////////////////////////////////
virtual BOOL SetMarkerBit(BOOL lastPacket);

//////////////////////////////////////////////////////////////////////////////////////////
//MakeTimeStamp: Generate a time stamp
//////////////////////////////////////////////////////////////////////////////////////////
virtual DWORD MakeTimeStamp(MsgDescriptor* pMsgDescrip, BOOL bStartStream, BOOL bUseInputTime);

public:
				
G711A_ppmSend(IUnknown* pUnkOuter, IUnknown** ppUnkInner);
~G711A_ppmSend();

DECLARE_CREATEPROC()

STDMETHODIMP_( const CLSID& ) GetCLSID( void ) const {return CLSID_G711APPMSend;}

STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{return CUnknown::QueryInterface(riid, ppvObj);}

STDMETHODIMP GetInterface( REFIID riid, LPVOID FAR* ppvObj )
{return ppmSend::GetInterface( riid, ppvObj );}

STDMETHODIMP_( ULONG )AddRef( void )
{return CUnknown::AddRef();}

STDMETHODIMP_( ULONG )Release( void )
{return CUnknown::Release();}

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\g711rcv.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: g711rcv.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#ifndef G711RCV_H
#define G711RCV_H

#include "ppmrcv.h"
#include "ppmclsid.h"
#include "g711.h"

#define G711_BUFFER_SIZE	5000
#define DO_NOT_PROCESS		5

class G711_ppmReceive : public ppmReceive
{

private:
	BOOL m_FirstAudioChunk;
public:

G711_ppmReceive(IUnknown* pUnkOuter, 
				IUnknown** ppUnkInner);
~G711_ppmReceive();

DECLARE_CREATEPROC()

STDMETHODIMP_( const CLSID& ) GetCLSID( void ) const {return CLSID_G711PPMReceive;}

STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{return CUnknown::QueryInterface(riid, ppvObj);}

STDMETHODIMP GetInterface( REFIID riid, LPVOID FAR* ppvObj )
{return ppmReceive::GetInterface( riid, ppvObj );}

STDMETHODIMP_( ULONG )AddRef( void )
{return CUnknown::AddRef();}

STDMETHODIMP_( ULONG )Release( void )
{return CUnknown::Release();}

//////////////////////////////////////////////////////////////////////////////////////////
//TimeToProcessMessages:
//////////////////////////////////////////////////////////////////////////////////////////
virtual BOOL TimeToProcessMessages(FragDescriptor *pFragDescrip, MsgHeader *pMsgHdr);
 
//////////////////////////////////////////////////////////////////////////////////////////
//CheckMessageComplete: 
//////////////////////////////////////////////////////////////////////////////////////////
virtual int CheckMessageComplete(MsgHeader *pMsgHdr); 

//////////////////////////////////////////////////////////////////////////////////////////
//ProcessMessages: 
//////////////////////////////////////////////////////////////////////////////////////////
virtual HRESULT ProcessMessages(void);

//////////////////////////////////////////////////////////////////////////////////////////
//PartialMessageHandler: deals with partial messages
//////////////////////////////////////////////////////////////////////////////////////////
virtual HRESULT PartialMessageHandler(MsgHeader *pMsgHdr);

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\g711rcv.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: g711rcv.cpp
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#include "ppmerr.h"
#include "g711rcv.h"

G711_ppmReceive::G711_ppmReceive(IUnknown* pUnkOuter, 
								 IUnknown** ppUnkInner)
	: ppmReceive(G711_PT, G711_BUFFER_SIZE, 0, pUnkOuter, ppUnkInner)
{
	m_FirstAudioChunk = TRUE;
	m_reg_DeltaTime          = 0;    //in miliseconds time to determine a packet is stale

}

G711_ppmReceive::~G711_ppmReceive()
{
}

IMPLEMENT_CREATEPROC(G711_ppmReceive);

//////////////////////////////////////////////////////////////////////////////////////////
//TimeToProcessMessages: Any time a packet comes in, it's time to process messages
//////////////////////////////////////////////////////////////////////////////////////////
BOOL G711_ppmReceive::TimeToProcessMessages(FragDescriptor *pFragDescrip, MsgHeader *pMsgHdr)
{
   return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////////
//ProcessMessages: 
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT G711_ppmReceive::ProcessMessages(void)
{

	HRESULT rval;
	int retVal;

	EnterCriticalSection(&m_CritSec);

	while(m_pMsgHeadersHead != NULL)
    {
		retVal = CheckMessageComplete(m_pMsgHeadersHead);
		switch( retVal )
		{
		  case TRUE:
		  {
			
			if FAILED(rval = PrepMessage(TRUE)) 
			{
				DBG_MSG(DBG_ERROR, ("G711_ppmReceive::ProcessMessages: ERROR - PrepMessage failed"));
				LeaveCriticalSection(&m_CritSec);
				return rval;
		    }
			else
				break;
          }
		  case FALSE:
		  {
			
			if FAILED(rval = PrepMessage(FALSE)) 
			{
				DBG_MSG(DBG_ERROR, ("G711_ppmReceive::ProcessMessages: ERROR - PrepMessage failed"));
				LeaveCriticalSection(&m_CritSec);
				return rval;
			}
			else
				break;
		  }
		  case DO_NOT_PROCESS:
		  {
                DBG_MSG(DBG_TRACE, ("G711A_ppmReceive::ProcessMessages: CheckMessageComplete returned DO_NOT_PROCESS"));
	            LeaveCriticalSection(&m_CritSec);
                return NOERROR;
		  }
		  default:
		  {
                DBG_MSG(DBG_TRACE, ("G711A_ppmReceive::ProcessMessages: CheckMessageComplete returned unknown"));
	            LeaveCriticalSection(&m_CritSec);
				return NOERROR;
		  }
	    }
    }
   //List is empty
   LeaveCriticalSection(&m_CritSec);
   return NOERROR;
}
          
//////////////////////////////////////////////////////////////////////////////////////////
//G711_ppmReceive::CheckMessageComplete: //return value is int
//////////////////////////////////////////////////////////////////////////////////////////
int G711_ppmReceive::CheckMessageComplete(MsgHeader *pMsgHdr) 
{
	//if there is no header then return false.
    if (pMsgHdr  == NULL)
    {
        DBG_MSG(DBG_ERROR, ("G711_ppmReceive::CheckMessageComplete: ERROR - pMsgHdr == NULL"));
        return FALSE;
    }
     
    //should there be a critical section in this function.  What about wraps?
     
     
    if(m_FirstAudioChunk)                         // handle very first chunk 
    {
         m_FirstAudioChunk = FALSE;               //Send it up, no matter what
     
         return TRUE;
    }
     
    if (m_GlobalLastSeqNum+1 == pMsgHdr->m_pFragList->FirstSeqNum())
	// Is this message in order ?
    {
          return TRUE;
    }
     
    if( CheckMessageStale(pMsgHdr) ||    // Check if we timed out
		m_PacketsHold >= 8) /* BUGBUG this 8 should be dynamic
							   but right now I know that I can have
							   only 8 buffers per RPH in the RTP
							   source filter, and if we keep 8 here
							   we get into a deadlock.
							   This is different from video because
							   in video the messages are already
							   in a queue, and here we are about
							   to request one */
    {
         return TRUE;                              // Send it up as we have waited long enough
    }
     
    return DO_NOT_PROCESS;                    // Continue and wait for next iteration
     
}

//////////////////////////////////////////////////////////////////////////////////////////
// PartialMessageHandler: deals with partial messages
// This overriden version is used by FlushData from ppmrcv.cpp
// Unlike partial message handlers for video, this function sends up all the
// pending data in the audio queues
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT G711_ppmReceive::PartialMessageHandler(MsgHeader *pMsgHdr)
{
	return (DataCopy( pMsgHdr ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\g723.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: g723.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#ifndef G723_H
#define G723_H

#define G723_PT   4    //assigned RTP payload number for H.261

#endif // G723_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\g711snd.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: g711snd.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#ifndef G711SND_H
#define G711SND_H

#include "ppmsnd.h"
#include "ppmclsid.h"
#include "g711.h"

class G711_ppmSend : public ppmSend
{
    DWORD m_dwLastTimeStamp;
    DWORD m_dwStartTime;
    DWORD m_dwLastTime;
    DWORD m_dwLastDelta;
protected:

//////////////////////////////////////////////////////////////////////////////////////////
//CountFrames: Determine how many frames are in the buffer
//////////////////////////////////////////////////////////////////////////////////////////
int CountFrames(char *pBuffer, int len);

////////////////////////////////////////////////////////////////////////////////////
// PPMSend Functions (Overrides)
////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
//SetMarkerBit: Determines whether to set the marker bit or not.  lastPacket is TRUE if
//				this is the last packet of the frame; FALSE if not.
//////////////////////////////////////////////////////////////////////////////////////////
virtual BOOL SetMarkerBit(BOOL lastPacket);

//////////////////////////////////////////////////////////////////////////////////////////
//MakeTimeStamp: Generate a time stamp
//////////////////////////////////////////////////////////////////////////////////////////
virtual DWORD MakeTimeStamp(MsgDescriptor* pMsgDescrip, BOOL bStartStream, BOOL bUseInputTime);

public:
				
G711_ppmSend(IUnknown* pUnkOuter, IUnknown** ppUnkInner);
~G711_ppmSend();

DECLARE_CREATEPROC()

STDMETHODIMP_( const CLSID& ) GetCLSID( void ) const {return CLSID_G711PPMSend;}

STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{return CUnknown::QueryInterface(riid, ppvObj);}

STDMETHODIMP GetInterface( REFIID riid, LPVOID FAR* ppvObj )
{return ppmSend::GetInterface( riid, ppvObj );}

STDMETHODIMP_( ULONG )AddRef( void )
{return CUnknown::AddRef();}

STDMETHODIMP_( ULONG )Release( void )
{return CUnknown::Release();}

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\g723rcv.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: g723rcv.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#ifndef G723RCV_H
#define G723RCV_H

#include "ppmrcv.h"
#include "ppmclsid.h"
#include "g723.h"

#define G723_BUFFER_SIZE 5000
#define DO_NOT_PROCESS		5


class G723_ppmReceive : public ppmReceive
{
private:
	BOOL m_FirstAudioChunk;

public:

G723_ppmReceive(IUnknown* pUnkOuter, 
				IUnknown** ppUnkInner);
~G723_ppmReceive();

DECLARE_CREATEPROC()

STDMETHODIMP_( const CLSID& ) GetCLSID( void ) const {return CLSID_G723PPMReceive;}

STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{return CUnknown::QueryInterface(riid, ppvObj);}

STDMETHODIMP GetInterface( REFIID riid, LPVOID FAR* ppvObj )
{return ppmReceive::GetInterface( riid, ppvObj );}

STDMETHODIMP_( ULONG )AddRef( void )
{return CUnknown::AddRef();}

STDMETHODIMP_( ULONG )Release( void )
{return CUnknown::Release();}

//////////////////////////////////////////////////////////////////////////////////////////
//TimeToProcessMessages:
//////////////////////////////////////////////////////////////////////////////////////////
virtual BOOL TimeToProcessMessages(FragDescriptor *pFragDescrip, MsgHeader *pMsgHdr);
 
//////////////////////////////////////////////////////////////////////////////////////////
//CheckMessageComplete: 
//////////////////////////////////////////////////////////////////////////////////////////
virtual BOOL CheckMessageComplete(MsgHeader *pMsgHdr); 
//////////////////////////////////////////////////////////////////////////////////////////
//ProcessMessages: 
//////////////////////////////////////////////////////////////////////////////////////////
virtual HRESULT ProcessMessages(void);

//////////////////////////////////////////////////////////////////////////////////////////
//PartialMessageHandler: deals with partial messages
//////////////////////////////////////////////////////////////////////////////////////////
virtual HRESULT PartialMessageHandler(MsgHeader *pMsgHdr);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\g711snd.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: g711snd.cpp
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#include "g711snd.h"

G711_ppmSend::G711_ppmSend(IUnknown* pUnkOuter, 
						   IUnknown** ppUnkInner) : 
		ppmSend(G711_PT, 0, 
				8000, pUnkOuter, ppUnkInner),
        
        m_dwLastTimeStamp(0)
{
}

G711_ppmSend::~G711_ppmSend()
{
}

IMPLEMENT_CREATEPROC(G711_ppmSend);

//////////////////////////////////////////////////////////////////////////////////////////
//SetMarkerBit: Determines whether to set the marker bit or not.  lastPacket is TRUE if
//				this is the last packet of the frame; FALSE if not.	 With audio, we don't
//				don't care about fragmentation, just the start of a talkspurt.
//////////////////////////////////////////////////////////////////////////////////////////
BOOL G711_ppmSend::SetMarkerBit(BOOL lastPacket)
{
	return m_markTalkSpurt;
}

//////////////////////////////////////////////////////////////////////////////////////////
//MakeTimeStamp: Generate a time stamp based on the frequency specified in the Profile Spec.
//////////////////////////////////////////////////////////////////////////////////////////
DWORD G711_ppmSend::MakeTimeStamp(MsgDescriptor* pMsgDescrip, 
								  BOOL bStartStream,
								  BOOL bUseInputTime)
{

#ifndef TIMESTAMP_OFF 

       DWORD ThisTimeStamp;
       DWORD CurTime = timeGetTime();
	   DWORD delta;
       DWORD epsilon;
    
    if (bUseInputTime) CurTime = pMsgDescrip->m_TimeStamp;

    // calculate the time span encoded in this packet
    delta = CountFrames((char *) pMsgDescrip->m_pBuffer, pMsgDescrip->m_Size) / (m_Frequency/1000);
    epsilon = delta/2;

    // init, do it here so it is set when we get the first packet
    // not at init time, they may be significantly different
	// Generate our first time stamp based on the current time.
    if (m_dwStartTime == 0)
    {
		// if the first packet we receive is a drop or silence then the delta will
		// be zero.  We just won't do anything until we receive valid data.
		if (delta != 0)
		{
			m_dwStartTime = CurTime;
			m_dwLastTime = m_dwStartTime -  delta;
			ThisTimeStamp = (((CurTime - m_dwStartTime) + (epsilon)) / delta) * delta * (m_Frequency/1000);
		}
	}
    else
	if (bStartStream)
	{
		// bStartStream will be set if this is the first packet after a break in a 
		// data stream.  We need to get our time stamps back on track, so we'll generate a time
		// based on the current time.  This case can happen if for some reason the capture device
		// gets starved or we are in half duplex and we are switching to talk mode.
		if (delta != 0)
		{
			ThisTimeStamp = (((CurTime - m_dwStartTime) + (epsilon)) / delta) * delta * (m_Frequency/1000);
		}
		else
		{
			ThisTimeStamp = (((CurTime - m_dwStartTime) + (epsilon)) / m_dwLastDelta) * m_dwLastDelta * (m_Frequency/1000);
			ThisTimeStamp -= m_dwLastDelta * (m_Frequency/1000);
		}
    }
	else
	{
	    // if we are in a continuous audio data stream, then we just want to increment our timestamp
		// for this data packet.  We don't want to use the current time because we don't know how long
		// it took from the time the data was acutally captured to the time we got it.  We have to rely
		// on the person feeding us data to let us know more information about the data stream.
		ThisTimeStamp = m_dwLastTimeStamp + CountFrames((char *) pMsgDescrip->m_pBuffer, pMsgDescrip->m_Size);
	}

	m_dwLastTimeStamp = ThisTimeStamp;
    m_dwLastTime = CurTime;
	if (delta != 0)
	{
		m_dwLastDelta = delta;
	}
    return ThisTimeStamp;
#else
//I changed this because the times I was getting were widely spaced.  When I was in debugging
//mode.
static DWORD CurTime = 0;
CurTime++;
#endif 

return CurTime;
}


int G711_ppmSend::CountFrames(char *ipBuffer, int len)
{
   return len;		//1 byte per frame
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\g723rcv.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: g723rcv.cpp
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#include "ppmerr.h"
#include "g723rcv.h"

G723_ppmReceive::G723_ppmReceive(IUnknown* pUnkOuter, 
								 IUnknown** ppUnkInner)
	: ppmReceive(G723_PT, G723_BUFFER_SIZE, 0, pUnkOuter, ppUnkInner)
{
	m_FirstAudioChunk = TRUE;
	m_reg_DeltaTime          = 0;    //in miliseconds time to determine a packet is stale
}

G723_ppmReceive::~G723_ppmReceive()
{
}

IMPLEMENT_CREATEPROC(G723_ppmReceive);

//////////////////////////////////////////////////////////////////////////////////////////
//TimeToProcessMessages: Any time a packet comes in, it's time to process messages
//////////////////////////////////////////////////////////////////////////////////////////
BOOL G723_ppmReceive::TimeToProcessMessages(FragDescriptor *pFragDescrip, MsgHeader *pMsgHdr)
{
   return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////////
//ProcessMessages: 
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT G723_ppmReceive::ProcessMessages(void)
{

	HRESULT rval;
	int retVal;

	EnterCriticalSection(&m_CritSec);

	while(m_pMsgHeadersHead != NULL)
    {
		retVal = CheckMessageComplete(m_pMsgHeadersHead);
		switch( retVal )
		{
		  case TRUE:
		  {
			
			if FAILED(rval = PrepMessage(TRUE)) 
			{
				DBG_MSG(DBG_ERROR, ("G723_ppmReceive::ProcessMessages: ERROR - PrepMessage failed"));
				LeaveCriticalSection(&m_CritSec);
				return rval;
		    }
			else
				break;
          }
		  case FALSE:
		  {
			
			if FAILED(rval = PrepMessage(FALSE)) 
			{
				DBG_MSG(DBG_ERROR, ("G723_ppmReceive::ProcessMessages: ERROR - PrepMessage failed"));
				LeaveCriticalSection(&m_CritSec);
				return rval;
			}
			else
				break;
		  }
		  case DO_NOT_PROCESS:
		  {
                DBG_MSG(DBG_TRACE, ("G711A_ppmReceive::ProcessMessages: CheckMessageComplete returned DO_NOT_PROCESS"));
	            LeaveCriticalSection(&m_CritSec);
                return NOERROR;
		  }
		  default:
		  {
                DBG_MSG(DBG_TRACE, ("G711A_ppmReceive::ProcessMessages: CheckMessageComplete returned unknown"));
	            LeaveCriticalSection(&m_CritSec);
				return NOERROR;
		  }
	    }
    }
   //List is empty
   LeaveCriticalSection(&m_CritSec);
   return NOERROR;
}
          
//////////////////////////////////////////////////////////////////////////////////////////
//G723_ppmReceive::CheckMessageComplete: //return value is int
//////////////////////////////////////////////////////////////////////////////////////////
int G723_ppmReceive::CheckMessageComplete(MsgHeader *pMsgHdr) 
{
	//if there is no header then return false.
    if (pMsgHdr  == NULL)
    {
        DBG_MSG(DBG_ERROR, ("G723_ppmReceive::CheckMessageComplete: ERROR - pMsgHdr == NULL"));
        return FALSE;
    }
     
    //should there be a critical section in this function.  What about wraps?
     
     
    if(m_FirstAudioChunk)                         // handle very first chunk 
    {
         m_FirstAudioChunk = FALSE;               //Send it up, no matter what
     
         return TRUE;
    }
     
    if (m_GlobalLastSeqNum+1 == pMsgHdr->m_pFragList->FirstSeqNum())
	// Is this message in order ?
    {
          return TRUE;
    }
     
    if( CheckMessageStale(pMsgHdr) ||    // Check if we timed out
		m_PacketsHold >= 8) /* BUGBUG this 8 should be dynamic
							   but right now I know that I can have
							   only 8 buffers per RPH in the RTP
							   source filter, and if we keep 8 here
							   we get into a deadlock.
							   This is different from video because
							   in video the messages are already
							   in a queue, and here we are about
							   to request one */
    {
         return TRUE;                              // Send it up as we have waited long enough
    }
     
    return DO_NOT_PROCESS;                    // Continue and wait for next iteration
     
}
//////////////////////////////////////////////////////////////////////////////////////////
// PartialMessageHandler: deals with partial messages
// This overriden version is used by FlushData from ppmrcv.cpp
// Unlike partial message handlers for video, this function sends up all the
// pending data in the audio queues
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT G723_ppmReceive::PartialMessageHandler(MsgHeader *pMsgHdr)
{
	return (DataCopy( pMsgHdr ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\genrcv.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: genrcv.cpp
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#include "genrcv.h"

Generic_ppmReceive::Generic_ppmReceive(IUnknown* pUnkOuter, IUnknown** ppUnkInner)
	: ppmReceive(-1, BUFFER_SIZE, 0, pUnkOuter, ppUnkInner)
{
}

Generic_ppmReceive::~Generic_ppmReceive()
{
}

IMPLEMENT_CREATEPROC(Generic_ppmReceive);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\g723snd.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: g723snd.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#ifndef G723SND_H
#define G723SND_H

#include "ppmsnd.h"
#include "ppmclsid.h"
#include "g723.h"

class G723_ppmSend : public ppmSend
{
    DWORD m_dwLastTimeStamp;
    DWORD m_dwStartTime;
    DWORD m_dwLastTime;
    DWORD m_dwLastDelta;
protected:
//////////////////////////////////////////////////////////////////////////////////////////
//CountFrames: Determine how many frames are in the buffer
//////////////////////////////////////////////////////////////////////////////////////////
int CountFrames(char *pBuffer, int len);

////////////////////////////////////////////////////////////////////////////////////
// PPMSend Functions (Overrides)
////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
//SetMarkerBit: Determines whether to set the marker bit or not.  lastPacket is TRUE if
//				this is the last packet of the frame; FALSE if not.
//////////////////////////////////////////////////////////////////////////////////////////
virtual BOOL SetMarkerBit(BOOL lastPacket);

//////////////////////////////////////////////////////////////////////////////////////////
//MakeTimeStamp: Generate a time stamp
//////////////////////////////////////////////////////////////////////////////////////////
virtual DWORD MakeTimeStamp(MsgDescriptor* pMsgDescrip, BOOL bStartStream, BOOL bUseInputTime);

public:
				
G723_ppmSend(IUnknown* pUnkOuter, IUnknown** ppUnkInner);
~G723_ppmSend();

DECLARE_CREATEPROC()

STDMETHODIMP_( const CLSID& ) GetCLSID( void ) const {return CLSID_G723PPMSend;}

STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{return CUnknown::QueryInterface(riid, ppvObj);}

STDMETHODIMP GetInterface( REFIID riid, LPVOID FAR* ppvObj )
{return ppmSend::GetInterface( riid, ppvObj );}

STDMETHODIMP_( ULONG )AddRef( void )
{return CUnknown::AddRef();}

STDMETHODIMP_( ULONG )Release( void )
{return CUnknown::Release();}

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\g723snd.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: g723snd.cpp
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#include "g723snd.h"

G723_ppmSend::G723_ppmSend(IUnknown* pUnkOuter, 
						   IUnknown** ppUnkInner) : 
		ppmSend(G723_PT, 0, 
				8000, pUnkOuter, ppUnkInner),
        
        m_dwLastTimeStamp(0)
{
}

G723_ppmSend::~G723_ppmSend()
{
}

IMPLEMENT_CREATEPROC(G723_ppmSend);

//////////////////////////////////////////////////////////////////////////////////////////
//SetMarkerBit: Determines whether to set the marker bit or not.  lastPacket is TRUE if
//				this is the last packet of the frame; FALSE if not.	 With audio, we don't
//				don't care about fragmentation, just the start of a talkspurt.
//////////////////////////////////////////////////////////////////////////////////////////
BOOL G723_ppmSend::SetMarkerBit(BOOL lastPacket)
{
	return m_markTalkSpurt;
}

//////////////////////////////////////////////////////////////////////////////////////////
//MakeTimeStamp: Generate a time stamp based on the frequency specified in the Profile Spec.
//////////////////////////////////////////////////////////////////////////////////////////
DWORD G723_ppmSend::MakeTimeStamp(MsgDescriptor* pMsgDescrip, 
								BOOL bStartStream,
								BOOL bUseInputTime)
{

#ifndef TIMESTAMP_OFF 

       DWORD ThisTimeStamp;
       DWORD CurTime = timeGetTime();
	   DWORD delta;
       DWORD epsilon;

    
    if (bUseInputTime) CurTime = pMsgDescrip->m_TimeStamp;

    // calculate the time span encoded in this packet
    delta = 240 * CountFrames((char *) pMsgDescrip->m_pBuffer, pMsgDescrip->m_Size) / (m_Frequency/1000);
    epsilon = delta/2;

    // init, do it here so it is set when we get the first packet
    // not at init time, they may be significantly different
	// Generate our first time stamp based on the current time.
    if (m_dwStartTime == 0)
    {
		// if the first packet we receive is a drop or silence then the delta will
		// be zero.  We just won't do anything until we receive valid data.
		if (delta != 0)
		{
			m_dwStartTime = CurTime;
			m_dwLastTime = m_dwStartTime -  delta;
			ThisTimeStamp = (((CurTime - m_dwStartTime) + (epsilon)) / delta) * delta * (m_Frequency/1000);
		}
	}
    else
	if (bStartStream)
	{
		// bStartStream will be set if this is the first packet after a break in a 
		// data stream.  We need to get our time stamps back on track, so we'll generate a time
		// based on the current time.  This case can happen if for some reason the capture device
		// gets starved or we are in half duplex and we are switching to talk mode.
		if (delta != 0)
		{
			ThisTimeStamp = (((CurTime - m_dwStartTime) + (epsilon)) / delta) * delta * (m_Frequency/1000);
		}
		else
		{
			// we don't have a valid delta, so we'll make do with the previous delta
			ThisTimeStamp = (((CurTime - m_dwStartTime) + (epsilon)) / m_dwLastDelta) * m_dwLastDelta * (m_Frequency/1000);
			ThisTimeStamp -= m_dwLastDelta * (m_Frequency/1000);
		}
    }
	else
	{
	    // if we are in a continuous audio data stream, then we just want to increment our timestamp
		// for this data packet.  We don't want to use the current time because we don't know how long
		// it took from the time the data was acutally captured to the time we got it.  We have to rely
		// on the person feeding us data to let us know more information about the data stream.
		ThisTimeStamp = m_dwLastTimeStamp + 240 * CountFrames((char *) pMsgDescrip->m_pBuffer, pMsgDescrip->m_Size);
	}

	m_dwLastTimeStamp = ThisTimeStamp;
	m_dwLastTime = CurTime;
	if (delta != 0)
	{
		m_dwLastDelta = delta;
	}
    return ThisTimeStamp;
#else
//I changed this because the times I was getting were widely spaced.  When I was in debugging
//mode.
static DWORD CurTime = 0;
CurTime++;
#endif 

return CurTime;
}


int G723_ppmSend::CountFrames(char *ipBuffer, int len)
{
    int Count = 0;
    int Delta = 0;
    int Length = len;
    LPBYTE pBuffer = (LPBYTE) ipBuffer;

    while(Length >= 4)
    {
        if (pBuffer[0] & 2)  // silence frame
        {
            if (Length < 4)  // invalid frame
            {
                break;
            }
            Delta = 4;
			//TTDBG(ghISRInst, TT_NOTIFY, "Dejitter::CountFrames - found silence frame");

        } 

        else if (pBuffer[0] & 1)  // 20 byte frame (5.3k)
        {
            if (Length < 20) // invalid frame
            {
                break;
            }
            Delta = 20;
        } 
        
        else               // 24 byte frame (6.3k)
        { 
            if (Length < 24) // invalid frame
            {
                break;
            }
            Delta = 24;
        }

        Count++;
        pBuffer += Delta;
        Length -= Delta;
   }
   return Count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\gensnd.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: gensnd.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#ifndef GENSND_H
#define GENSND_H

#include "ppmsnd.h"
#include "ppmclsid.h"

class Generic_ppmSend : public ppmSend
{

public:

Generic_ppmSend(IUnknown* pUnkOuter, IUnknown** ppUnkInner);
~Generic_ppmSend();

DECLARE_CREATEPROC()

STDMETHODIMP_( const CLSID& ) GetCLSID( void ) const {return CLSID_GenPPMSend;}

STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{return CUnknown::QueryInterface(riid, ppvObj);}

STDMETHODIMP GetInterface( REFIID riid, LPVOID FAR* ppvObj )
{return ppmSend::GetInterface( riid, ppvObj );}

STDMETHODIMP_( ULONG )AddRef( void )
{return CUnknown::AddRef();}

STDMETHODIMP_( ULONG )Release( void )
{return CUnknown::Release();}

}; // Parameters to ppmSend -> Generic Payload type, size of payload header, frequency,  outer arg, inner arg
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\gen_arcv.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: gen_arcv.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#ifndef GEN_A_RCV_H
#define GEN_A_RCV_H

#include "ppmrcv.h"
#include "ppmclsid.h"
#include "gen_arcv.h"

#define GEN_A_BUFFER_SIZE	5000
#define DO_NOT_PROCESS		5

class Generic_a_ppmReceive : public ppmReceive
{

private:
	BOOL m_FirstAudioChunk;
public:

Generic_a_ppmReceive(IUnknown* pUnkOuter, 
				IUnknown** ppUnkInner);
~Generic_a_ppmReceive();

DECLARE_CREATEPROC()

STDMETHODIMP_( const CLSID& ) GetCLSID( void ) const {return CLSID_GEN_A_PPMReceive;}

STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{return CUnknown::QueryInterface(riid, ppvObj);}

STDMETHODIMP GetInterface( REFIID riid, LPVOID FAR* ppvObj )
{return ppmReceive::GetInterface( riid, ppvObj );}

STDMETHODIMP_( ULONG )AddRef( void )
{return CUnknown::AddRef();}

STDMETHODIMP_( ULONG )Release( void )
{return CUnknown::Release();}

//////////////////////////////////////////////////////////////////////////////////////////
//TimeToProcessMessages:
//////////////////////////////////////////////////////////////////////////////////////////
virtual BOOL TimeToProcessMessages(FragDescriptor *pFragDescrip, MsgHeader *pMsgHdr);
 
//////////////////////////////////////////////////////////////////////////////////////////
//CheckMessageComplete: 
//////////////////////////////////////////////////////////////////////////////////////////
virtual int CheckMessageComplete(MsgHeader *pMsgHdr); 

//////////////////////////////////////////////////////////////////////////////////////////
//ProcessMessages: 
//////////////////////////////////////////////////////////////////////////////////////////
virtual HRESULT ProcessMessages(void);

//////////////////////////////////////////////////////////////////////////////////////////
//PartialMessageHandler: deals with partial messages
//////////////////////////////////////////////////////////////////////////////////////////
virtual HRESULT PartialMessageHandler(MsgHeader *pMsgHdr);

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\gen_arcv.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: gen_arcv.cpp
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#include "ppmerr.h"
#include "gen_arcv.h"

Generic_a_ppmReceive::Generic_a_ppmReceive(IUnknown* pUnkOuter, 
								 IUnknown** ppUnkInner)
	: ppmReceive(-1, GEN_A_BUFFER_SIZE, 0, pUnkOuter, ppUnkInner)
{
	m_FirstAudioChunk = TRUE;
	m_reg_DeltaTime          = 0;    //in miliseconds time to determine a packet is stale

}

Generic_a_ppmReceive::~Generic_a_ppmReceive()
{
}

IMPLEMENT_CREATEPROC(Generic_a_ppmReceive);

//////////////////////////////////////////////////////////////////////////////////////////
//TimeToProcessMessages: Any time a packet comes in, it's time to process messages
//////////////////////////////////////////////////////////////////////////////////////////
BOOL Generic_a_ppmReceive::TimeToProcessMessages(FragDescriptor *pFragDescrip, MsgHeader *pMsgHdr)
{
   return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////////
//ProcessMessages: 
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT Generic_a_ppmReceive::ProcessMessages(void)
{

	HRESULT rval;
	int retVal;

	EnterCriticalSection(&m_CritSec);

	while(m_pMsgHeadersHead != NULL)
    {
		retVal = CheckMessageComplete(m_pMsgHeadersHead);
		switch( retVal )
		{
		  case TRUE:
		  {
			
			if FAILED(rval = PrepMessage(TRUE)) 
			{
				DBG_MSG(DBG_ERROR, ("Generic_a_ppmReceive::ProcessMessages: ERROR - PrepMessage failed"));
				LeaveCriticalSection(&m_CritSec);
				return rval;
		    }
			else
				break;
          }
		  case FALSE:
		  {
			
			if FAILED(rval = PrepMessage(FALSE)) 
			{
				DBG_MSG(DBG_ERROR, ("Generic_a_ppmReceive::ProcessMessages: ERROR - PrepMessage failed"));
				LeaveCriticalSection(&m_CritSec);
				return rval;
			}
			else
				break;
		  }
		  case DO_NOT_PROCESS:
		  {
                DBG_MSG(DBG_TRACE, ("G711A_ppmReceive::ProcessMessages: CheckMessageComplete returned DO_NOT_PROCESS"));
	            LeaveCriticalSection(&m_CritSec);
                return NOERROR;
		  }
		  default:
		  {
                DBG_MSG(DBG_TRACE, ("G711A_ppmReceive::ProcessMessages: CheckMessageComplete returned unknown"));
	            LeaveCriticalSection(&m_CritSec);
				return NOERROR;
		  }
	    }
    }
   //List is empty
   LeaveCriticalSection(&m_CritSec);
   return NOERROR;
}
          
//////////////////////////////////////////////////////////////////////////////////////////
//Generic_a_ppmReceive::CheckMessageComplete: //return value is int
//////////////////////////////////////////////////////////////////////////////////////////
int Generic_a_ppmReceive::CheckMessageComplete(MsgHeader *pMsgHdr) 
{
	//if there is no header then return false.
    if (pMsgHdr  == NULL)
    {
        DBG_MSG(DBG_ERROR, ("Generic_a_ppmReceive::CheckMessageComplete: ERROR - pMsgHdr == NULL"));
        return FALSE;
    }
     
    //should there be a critical section in this function.  What about wraps?
     
     
    if(m_FirstAudioChunk)                         // handle very first chunk 
    {
         m_FirstAudioChunk = FALSE;               //Send it up, no matter what
     
         return TRUE;
    }
     
    if (m_GlobalLastSeqNum+1 == pMsgHdr->m_pFragList->FirstSeqNum())
	// Is this message in order ?
    {
          return TRUE;
    }
     
    if( CheckMessageStale(pMsgHdr))               // Check if we timed out 
    {
         return TRUE;                              // Send it up as we have waited long enough
    }
     
    return DO_NOT_PROCESS;                    // Continue and wait for next iteration
     
}

//////////////////////////////////////////////////////////////////////////////////////////
// PartialMessageHandler: deals with partial messages
// This overriden version is used by FlushData from ppmrcv.cpp
// Unlike partial message handlers for video, this function sends up all the
// pending data in the audio queues
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT Generic_a_ppmReceive::PartialMessageHandler(MsgHeader *pMsgHdr)
{
	return (DataCopy( pMsgHdr ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\gensnd.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: gensnd.cpp
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#include "gensnd.h"


Generic_ppmSend::Generic_ppmSend(IUnknown* pUnkOuter, IUnknown** ppUnkInner)
    : ppmSend(-1, 0, 8000, pUnkOuter, ppUnkInner)
{
}

Generic_ppmSend::~Generic_ppmSend()
{
}


IMPLEMENT_CREATEPROC(Generic_ppmSend);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\gen_asnd.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: gen_asnd.cpp
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#include "gen_asnd.h"

Generic_a_ppmSend::Generic_a_ppmSend(IUnknown* pUnkOuter, 
						   IUnknown** ppUnkInner) : 
		ppmSend(-1, 0, 
				8000, pUnkOuter, ppUnkInner)
{
}

Generic_a_ppmSend::~Generic_a_ppmSend()
{
}

IMPLEMENT_CREATEPROC(Generic_a_ppmSend);

//////////////////////////////////////////////////////////////////////////////////////////
//SetMarkerBit: Determines whether to set the marker bit or not.  lastPacket is TRUE if
//				this is the last packet of the frame; FALSE if not.	 With audio, we don't
//				don't care about fragmentation, just the start of a talkspurt.
//////////////////////////////////////////////////////////////////////////////////////////
BOOL Generic_a_ppmSend::SetMarkerBit(BOOL lastPacket)
{
	return m_markTalkSpurt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\genrcv.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: genrcv.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#ifndef GENRCV_H
#define GENRCV_H

#include "ppmrcv.h"
#include "ppmclsid.h"

#define BUFFER_SIZE 20000

class Generic_ppmReceive : public ppmReceive
{

public:

Generic_ppmReceive(IUnknown* pUnkOuter, IUnknown** ppUnkInner);
~Generic_ppmReceive();

DECLARE_CREATEPROC()

STDMETHODIMP_( const CLSID& ) GetCLSID( void ) const {return CLSID_GenPPMReceive;}

STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{return CUnknown::QueryInterface(riid, ppvObj);}

STDMETHODIMP GetInterface( REFIID riid, LPVOID FAR* ppvObj )
{return ppmReceive::GetInterface( riid, ppvObj );}

STDMETHODIMP_( ULONG )AddRef( void )
{return CUnknown::AddRef();}

STDMETHODIMP_( ULONG )Release( void )
{return CUnknown::Release();}

};  // Parameters to ppmReceive -> Generic Payload type, size of payload header, outer arg, inner arg
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\gen_asnd.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: gen_asnd.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#ifndef GEN_A_SND_H
#define GEN_A_SND_H

#include "ppmsnd.h"
#include "ppmclsid.h"
#include "gen_asnd.h"

class Generic_a_ppmSend : public ppmSend
{
protected:

////////////////////////////////////////////////////////////////////////////////////
// PPMSend Functions (Overrides)
////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
//SetMarkerBit: Determines whether to set the marker bit or not.  lastPacket is TRUE if
//				this is the last packet of the frame; FALSE if not.
//////////////////////////////////////////////////////////////////////////////////////////
virtual BOOL SetMarkerBit(BOOL lastPacket);


public:
				
Generic_a_ppmSend(IUnknown* pUnkOuter, IUnknown** ppUnkInner);
~Generic_a_ppmSend();

DECLARE_CREATEPROC()

STDMETHODIMP_( const CLSID& ) GetCLSID( void ) const {return CLSID_GEN_A_PPMSend;}

STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{return CUnknown::QueryInterface(riid, ppvObj);}

STDMETHODIMP GetInterface( REFIID riid, LPVOID FAR* ppvObj )
{return ppmSend::GetInterface( riid, ppvObj );}

STDMETHODIMP_( ULONG )AddRef( void )
{return CUnknown::AddRef();}

STDMETHODIMP_( ULONG )Release( void )
{return CUnknown::Release();}

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\h261.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: h261.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////

// Note: Payload header data generated by PPM are in network order

#ifndef H261_H
#define H261_H
#include <mmsystem.h>

#define H261_PT   31    //assigned RTP payload number for H.261

// These are used in T_BSINFO_HEADER.dwUniqueCode
#define	H261_CODE		mmioFOURCC('H','2','6','1')
#define H261_VERSION	0

// Per Extended Bitstream document
#define RTP_H26X_PACKET_LOST	0x00000001
#define RTP_H26X_INTRA_CODED	0x00000001

// Per Extended Bitstream document, payload source format codes.  Note that
// enum values must not exceed unsigned char BSINFO_TRAILER::SourceFormat.
enum RTPh261SourceFormat
{
	rtph261SourceFormatQCIF = 0,
	rtph261SourceFormatCIF,
	rtph261SourceFormatUnknown = (unsigned char) 0xff
};

#define BITSPERBYTE	8


// The H261 standard payload header
class H261_Header {
public:

		unsigned char byte0, byte1, byte2, byte3;
		unsigned long padding0;

		H261_Header () : byte0(0), byte1(0), byte2(0), byte3(0), padding0(0) {}

		H261_Header (char *pBuffer) { 
			byte0 = *((unsigned char *) pBuffer);
			byte1 = *((unsigned char *) pBuffer +1);
			byte2 = *((unsigned char *) pBuffer +2);
			byte3 = *((unsigned char *) pBuffer +3);
			padding0 = 0; // not necessary
		}

        int sbit() const { return (byte0 >> 5) & 7; }
        void set_sbit(int sbit) { byte0 = (byte0 & 0x1f) | ((sbit & 7) << 5); }
        
        int ebit() const { return (byte0 >> 2) & 7; }
        void set_ebit(int ebit) { byte0 = (byte0 & 0xe3) | ((ebit & 7) << 2); }
        
        int i() const { return (byte0 >> 1) & 1; }
        void set_i(int i) { byte0 = (byte0 & 0xfd) | ((i & 1) << 1); }
        
        int v() const { return byte0 & 1; }
        void set_v(int v) { byte0 = (byte0 & 0xfe) | (v & 1); }
        
        unsigned char gobn() const { return ((byte1 >> 4) & 0xf); }
        void set_gobn(int gobn) { byte1 = (byte1 & 0x0f) | ((gobn & 0xf) << 4); }
        
        unsigned char mbap() const { return (((byte1 & 0xf) << 1) | ((byte2 >> 7) & 1)); }
        void set_mbap(int mbap) { 
			byte1 = ((byte1 & 0xf0) | ((mbap >> 1) & 0xf));
			byte2 = ((byte2 & 0x7f) | ((mbap & 1) << 7));
		}
        
        unsigned char quant() const { return ((byte2 >> 2) & 0x1f); }
        void set_quant(int quant) { byte2 = (byte2 & 0x83) | ((quant & 0x1f) << 2); }
        
        char hmvd() const { return (((byte2 & 0x3) << 3) | ((byte3 >> 5) & 7)); }
        void set_hmvd(int hmvd) { 
			byte2 = ((byte2 & 0xfc) | ((hmvd >> 3) & 3));
			byte3 = ((byte3 & 0x1f) | ((hmvd & 7) << 5));
		}
        
        char vmvd() const { return (byte3 & 0x1f); }
        void set_vmvd(int vmvd) { byte3 = (byte3 & 0xe0) | (vmvd & 0x1f); }
        
};

/* Old bitset layout
        
typedef struct {                             
    DWORD          vmvd:5;		// vertical motion vector data 
    DWORD          hmvd:5;		// horizontal motion vector data
    DWORD          quant:5;		// quantizer 
    DWORD          mbap:5;		// macroblock address predictor 
    DWORD          gobn:4;		// GOB number  
    DWORD          v:1;			// motion vector flag 
    DWORD          i:1;			// INTRA-frame encoded data   
    DWORD          ebit:3;		// end bit position   
    DWORD          sbit:3;		// start bit position 
} H261_HDR_T;

*/

// The extended H261 bitstream is composed of an array of structures
// of these
typedef struct _T_EX_BITSTREAM_INFO {
	unsigned long	dwFlags;
	unsigned long	dwBitOffset;
	unsigned char	MBAP;
	unsigned char	Quant;
	unsigned char	GOBN;
	char			HMV;
	char			VMV;
	char			padding0;
	short int		padding1;
} BITSTREAM_INFO_H261;

#ifndef _BSINFO_TRAILER_DEFINED
#define _BSINFO_TRAILER_DEFINED
// This is used to locate bitstream info before accessing the extended
// bitstream
typedef struct _T_BSINFO_TRAILER {
	unsigned long	dwVersion;
	unsigned long	dwFlags;
	unsigned long	dwUniqueCode;
	unsigned long	dwCompressedSize;
	unsigned long	dwNumberOfPackets;
	unsigned char	SourceFormat;
	unsigned char	TR;
	unsigned char	TRB;
	unsigned char	DBQ;
} BSINFO_TRAILER;

#endif /* _BSINFO_TRAILER_DEFINED */


#endif /* H261_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\h261rcv.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: h261rcv.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#ifndef H261RCV_H
#define H261RCV_H

#include "ppmrcv.h"
#include "ppmclsid.h"
#include "h261.h"
#include "h261pld.h"

//lsc - For QCIF, if different format, need to adjust size
#define H261_BUFFER_SIZE 5000

class H261_ppmReceive : public ppmReceive
{

unsigned char		m_lastMBAP;
unsigned char		m_lastQuant;
unsigned char		m_lastGOBN; 
char				m_lastVMV;
char				m_lastHMV;
BOOL				m_GlobalLastMarkerBitIn;
RTPh261SourceFormat	m_rtph261SourceFormat;

#ifdef REBUILD_EXBITSTREAM
BOOL            m_ExtendedBitstream;
HRESULT			BuildExtendedBitstream(MsgHeader* const pMsgHdr);
#endif

FreeList        *m_pH261Headers;

public:

H261_ppmReceive(IUnknown* pUnkOuter, IUnknown** ppUnkInner);
~H261_ppmReceive();

DECLARE_CREATEPROC()

STDMETHODIMP_( const CLSID& ) GetCLSID( void ) const {return CLSID_H261PPMReceive;}

STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{return CUnknown::QueryInterface(riid, ppvObj);}

STDMETHODIMP GetInterface( REFIID riid, LPVOID FAR* ppvObj )
{return ppmReceive::GetInterface( riid, ppvObj );}

STDMETHODIMP_( ULONG )AddRef( void )
{return CUnknown::AddRef();}

STDMETHODIMP_( ULONG )Release( void )
{return CUnknown::Release();}

//////////////////////////////////////////////////////////////////////////////
//ppmReceive Functions (Overrides)
//////////////////////////////////////////////////////////////////////////////

#ifdef REBUILD_EXBITSTREAM
//////////////////////////////////////////////////////////////////////////////////////////
//SetSession: Argument type is actually H26XPPMSESSPARAM_T
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHOD(SetSession)(THIS_ PPMSESSPARAM_T *pSessparam);

//////////////////////////////////////////////////////////////////////////////
//   IPPMReceiveSession Functions (Overrides)
STDMETHOD(GetResiliency)(THIS_ LPBOOL			lpbResiliency);
STDMETHOD(SetResiliency)(THIS_ BOOL			pbResiliency);
#else
//Default to ppmReceive::SetSession() and ppmReceive::<IPPMReceiveSession> fns
#endif

//////////////////////////////////////////////////////////////////////////////////////////
//TimeToProcessMessages:
//////////////////////////////////////////////////////////////////////////////////////////
virtual BOOL TimeToProcessMessages(FragDescriptor *pFragDescrip, MsgHeader *pMsgHdr);
 
//////////////////////////////////////////////////////////////////////////////////////////
//CheckMessageComplete: 
//////////////////////////////////////////////////////////////////////////////////////////
virtual BOOL CheckMessageComplete(MsgHeader *pMsgHdr); 

//////////////////////////////////////////////////////////////////////////////////////////
//PrepMessage: Sets H261 global variables, calls base PrepMessage
//////////////////////////////////////////////////////////////////////////////////////////
virtual HRESULT PrepMessage(BOOL); 

//////////////////////////////////////////////////////////////////////////////////////////
//DataCopy: Copies data fragments into client's buffer 
//////////////////////////////////////////////////////////////////////////////////////////
virtual HRESULT DataCopy(MsgHeader *const pMsgHdr);    

//////////////////////////////////////////////////////////////////////////////////////////
//PartialMessageHandler: deals with partial messages
//////////////////////////////////////////////////////////////////////////////////////////
virtual HRESULT PartialMessageHandler(MsgHeader *pMsgHdr);
//////////////////////////////////////////////////////////////////////////////////////////

//InitProfileHeader: Given a buffer as type void, sets up a profile header.  
//////////////////////////////////////////////////////////////////////////////////////////
virtual void *InitProfileHeader(void *pBuffer);

//////////////////////////////////////////////////////////////////////////////////////////
//FreeProfileHeader: Given a buffer as type void, frees up a profile header.  
//////////////////////////////////////////////////////////////////////////////////////////
virtual void FreeProfileHeader(void *pBuffer);


};  // Parameters to ppmReceive -> H261 Payload type, size of payload header, outer arg, inner arg

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\h261snd.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: h261snd.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#ifndef H261SND_H
#define H261SND_H

#include "ppmsnd.h"
#include "ppmclsid.h"
#include "h261.h"

class H261_ppmSend : public ppmSend
{

protected:

FreeList          *m_pH261Headers;
BSINFO_TRAILER	  *m_pBSINFO_TRAILER;

////////////////////////////////////////////////////////////////////////////////////
// PPMSend Functions (Overrides)
////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
//InitFragStatus: Virtual. Initializes values needed for fragmenting.
//////////////////////////////////////////////////////////////////////////////////////////
virtual HRESULT InitFragStatus(MsgDescriptor *pMsgDescrip);

//////////////////////////////////////////////////////////////////////////////////////////
//AllocFrag: Virtual.  Allcates memory for FragDescriptor and all things it points to.
//////////////////////////////////////////////////////////////////////////////////////////
virtual FragDescriptor * AllocFrag();  

//////////////////////////////////////////////////////////////////////////////////////////
//DeleteFrag: Virtual This function does the opposite of AllocFrag, it deletes any memory allocated
//            by AllocFrag.
//lsc - virtual FreeProfileHeader is used in ppmSend's DeleteFrag, so no overriding here
//////////////////////////////////////////////////////////////////////////////////////////
//virtual void DeleteFrag(FragDescriptor *pFragDescrip, HRESULT Error);
 
//////////////////////////////////////////////////////////////////////////////////////////
//MakeFrag: Virtual. This function should get the next fragment from the buffer and fill in the
//          RTP header and payload header. 
//////////////////////////////////////////////////////////////////////////////////////////
virtual HRESULT   MakeFrag(FragDescriptor *pFragDescrip);  //fills in fields, including data of fragment class.

//////////////////////////////////////////////////////////////////////////////////////////
//FreeProfileHeader: Given a buffer as type void, frees up a profile header.  
//////////////////////////////////////////////////////////////////////////////////////////
virtual void FreeProfileHeader(void *pBuffer);

//////////////////////////////////////////////////////////////////////////////////////////
//ReadProfileHeader: Given a buffer as type void, returns the data for a profile header.  
//					Does nothing for the Generic case.  Intended for overrides for various 
//					payloads.
//////////////////////////////////////////////////////////////////////////////////////////
virtual void *ReadProfileHeader(void *pProfileHeader);

public:
				
H261_ppmSend(IUnknown* pUnkOuter, IUnknown** ppUnkInner);
~H261_ppmSend();

DECLARE_CREATEPROC()

STDMETHODIMP_( const CLSID& ) GetCLSID( void ) const {return CLSID_H261PPMSend;}

STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{return CUnknown::QueryInterface(riid, ppvObj);}

STDMETHODIMP GetInterface( REFIID riid, LPVOID FAR* ppvObj )
{return ppmSend::GetInterface( riid, ppvObj );}

STDMETHODIMP_( ULONG )AddRef( void )
{return CUnknown::AddRef();}

STDMETHODIMP_( ULONG )Release( void )
{return CUnknown::Release();}

}; // Parameters to ppmSend -> H261 Payload type, size of payload header, frequency,  outer arg, inner arg
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\h263pld.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: h263pld.h
//  Abstract:    header file. a data structure for maintaining a pool of memory.
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
//
// Defines an inline function to return the payload type (QCIF or CIF) of an
// H.263 frame.
/////////////////////////////////////////////////////////////////////////////////

// $Header:   R:/rtp/src/ppm/H263PLD.H_V   1.3   26 Feb 1997 14:10:00   Cpearson.JF32.JF.INTEL  $

#ifndef _H263PLD_H_
#define _H263PLD_H_

#include "bitstrm.h"	// CBitstream


///////////////////////////////////////////////////////////////////////////////
// FOLLOWING VALUES ARE FROM THE VIDEO CODEC GROUP

// BIT field Constants
const int BITS_PICTURE_STARTCODE = 22;

// PSC_VALUE - 0000 0000 0000 0000 1000 00xx xxxx xxxx
const DWORD PSC_VALUE = (0x00008000 >> (32 - BITS_PICTURE_STARTCODE));

// We only want to search so far before it is considered an error
const int MAX_LOOKAHEAD_NUMBER = 256; /* number of bits */

// END VIDEO CODEC VALUES
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// H.263 utility functions


///////////////////////////////////////////////////////////////////////////////
// ContainsH263PSC(): Returns TRUE if the buffer contains a valid H.263 picture
// start code.
///////////////////////////////////////////////////////////////////////////////
inline BOOL ContainsH263PSC(const void* pBuffer)
{
	CBitstream bitstream(pBuffer);

	DWORD dwResult = bitstream.getFixedBits(BITS_PICTURE_STARTCODE);

	for (
		int iLookAhead = 0; 
		   (dwResult != PSC_VALUE)
		&& (iLookAhead <= MAX_LOOKAHEAD_NUMBER);
	   ++ iLookAhead)
	{
		bitstream.getNextBit(dwResult);
		dwResult &= GetBitsMask(BITS_PICTURE_STARTCODE);
	}

	return dwResult == PSC_VALUE;
}

#endif // _H263PLD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\h261pld.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: h261pld.h
//  Abstract:    header file. a data structure for maintaining a pool of memory.
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
//
// Defines an inline function to return the payload type (QCIF or CIF) of an
// H.261 frame.
/////////////////////////////////////////////////////////////////////////////////

// $Header:   R:/rtp/src/ppm/h261pld.h_v   1.3   27 Jan 1997 13:38:04   CPEARSON  $

#ifndef _H261PLD_H_
#define _H261PLD_H_

#include "h261.h"		// RTPh261SourceFormat
#include "bitstrm.h"	// CBitstream


///////////////////////////////////////////////////////////////////////////////
// FOLLOWING VALUES ARE FROM THE VIDEO CODEC GROUP

// BIT field Constants
const int BITS_PICTURE_STARTCODE = 20;
const int BITS_TR = 5;

// PSC_VALUE - 0000 0000 0000 0001 0000 xxxx xxxx xxxx
const DWORD PSC_VALUE = (0x00010000 >> (32 - BITS_PICTURE_STARTCODE));

// We only want to search so far before it is considered an error
const int MAX_LOOKAHEAD_NUMBER = 256; /* number of bits */

// END VIDEO CODEC VALUES
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// H.261 utility functions


///////////////////////////////////////////////////////////////////////////////
// getH261payloadType(): If successful, returns the payload type (QCIF or CIF)
// of H.261 buffer, otherwise returns unknown.
///////////////////////////////////////////////////////////////////////////////
#if 0
// Move this to h261rcv.cpp

inline
RTPh261SourceFormat getH261payloadType(const void* pBuffer)
{
	CBitstream bitstream(pBuffer);

	// PSC
	DWORD uResult = bitstream.getFixedBits(BITS_PICTURE_STARTCODE);

	for (
		int iLookAhead = 0; 
		   (uResult != PSC_VALUE)
		&& (iLookAhead <= MAX_LOOKAHEAD_NUMBER);
	   ++ iLookAhead)
	{
		bitstream.getNextBit(uResult);
		uResult &= GetBitsMask(BITS_PICTURE_STARTCODE);
	}

	if (uResult != PSC_VALUE)
	{
		return rtph261SourceFormatUnknown;
	}

	// Ignore BITS_TR (Temporal Reference)
	bitstream.getFixedBits(BITS_TR);

	// Ignore 3 bits of PTYPE (Picture Type)
	bitstream.getFixedBits(3);

	// Return source format.  Only one bit, can't be invalid, unless we run
	// out of buffer, which isn't checked for here.
	return (RTPh261SourceFormat) bitstream.getFixedBits(1);
}
#endif
#endif // _H261PLD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\h261rcv.cpp ===
/////////////////////////////////////////////////////////////////////////////
//	INTEL Corporation Proprietary Information
//	This listing is supplied under the terms of a license agreement with Intel
//	Corporation and many not be copied nor disclosed except in accordance
//	with the terms of that agreement.
//	Copyright (c) 1995,	1996 Intel Corporation.
//
//
//	Module Name: h261rcv.cpp
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////

// $Header:   J:\rtp\src\ppm\h261rcv.cpv   1.43   29 May 1997 16:42:08   lscline  $

#include "ppmerr.h"
#include "h261rcv.h"
#include "ippmcb.h"

#define H261_HDR_T int // for now

//////////////////////////////////////////////////////////////////////////////
// Private global data

#ifdef REBUILD_EXBITSTREAM

static const struct { DWORD dw[2]; } s_leadFragBitPatternQCIF =
{
	MAKELONG(MAKEWORD(0, 1), MAKEWORD(0, 0)),	// 4 bytes {0,1, 0,0}, big-endian
	MAKELONG(MAKEWORD(0, 1), MAKEWORD(16, 0))	// 4 bytes {0,1,16,0}, big-endian
};

static const struct { DWORD dw[2]; } s_leadFragBitPatternCIF =
{
	MAKELONG(MAKEWORD(0, 1), MAKEWORD(0, 40)),	// 4 bytes {0,1, 0,40}, big-endian
	MAKELONG(MAKEWORD(0, 1), MAKEWORD(16, 0))	// 4 bytes {0,1,16, 0}, big-endian
};

static const struct { char ch[4]; } s_nonLeadFragBitPattern = {0, 0, 0, 0};

#endif

/////////////////////////////////////////////////////////////////////////////
// H.261 utility function
/////////////////////////////////////////////////////////////////////////////
// getH261payloadType(): If successful, returns the payload type (QCIF or CIF)
// of H.261 buffer, otherwise returns unknown.
/////////////////////////////////////////////////////////////////////////////
// inline
RTPh261SourceFormat getH261payloadType(const void* pBuffer)
{
	CBitstream bitstream(pBuffer);

	// PSC
	DWORD uResult = bitstream.getFixedBits(BITS_PICTURE_STARTCODE);

	for (
		int iLookAhead = 0; 
		   (uResult != PSC_VALUE)
		&& (iLookAhead <= MAX_LOOKAHEAD_NUMBER);
	   ++ iLookAhead)
	{
		bitstream.getNextBit(uResult);
		uResult &= GetBitsMask(BITS_PICTURE_STARTCODE);
	}

	if (uResult != PSC_VALUE)
	{
		return rtph261SourceFormatUnknown;
	}

	// Ignore BITS_TR (Temporal Reference)
	bitstream.getFixedBits(BITS_TR);

	// Ignore 3 bits of PTYPE (Picture Type)
	bitstream.getFixedBits(3);

	// Return source format.  Only one bit, can't be invalid, unless we run
	// out of buffer, which isn't checked for here.
	return (RTPh261SourceFormat) bitstream.getFixedBits(1);
}

//////////////////////////////////////////////////////////////////////////////
// H261_ppmReceive implementation

H261_ppmReceive::H261_ppmReceive(IUnknown* pUnkOuter, IUnknown** ppUnkInner)
	: ppmReceive(H261_PT, H261_BUFFER_SIZE, sizeof(unsigned long), pUnkOuter, ppUnkInner)
{
	m_rtph261SourceFormat = rtph261SourceFormatUnknown;
	m_GlobalLastMarkerBitIn = FALSE;

#ifdef REBUILD_EXBITSTREAM
	m_ExtendedBitstream = TRUE;
#endif

	// Allocate memory for the H261 headers;
	// Note:	We do not use ReadProfileHeaderSize for this, since this header structure
	//		contains padding so it can be in a FreeList; here we use the real padded size
	HRESULT hr;
	m_pH261Headers = new FreeList(
							FREELIST_INIT_COUNT_RCV,
							sizeof(H261_Header),
							FREELIST_HIGH_WATER_MARK,
							FREELIST_INCREMENT,
							&hr); // Not really used here

	if (! m_pH261Headers)
	{
		DBG_MSG(DBG_ERROR, ("H261_ppmReceive::H261_ppmReceive: ERROR - m_pH261Headers == NULL"));
	}

	// Verify assumption made in H261_ppmReceive::BuildExtendedBitstream() wrt
	// handling of underflow.
	DWORD dwBufSize = 0;
	int nLastEbit = 0;
	ASSERT(
		(((dwBufSize - 1) * BITSPERBYTE) +
			(BITSPERBYTE - nLastEbit)) ==
		(BITSPERBYTE * dwBufSize));
}

H261_ppmReceive::~H261_ppmReceive()
{
	if (m_pH261Headers) {
		delete m_pH261Headers;
		m_pH261Headers = NULL;
	}
}

IMPLEMENT_CREATEPROC(H261_ppmReceive);


//////////////////////////////////////////////////////////////////////////////
// ppmReceive Functions (Overrides)
//////////////////////////////////////////////////////////////////////////////

#ifdef REBUILD_EXBITSTREAM
//////////////////////////////////////////////////////////////////////////////////////////
// SetSession:
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP H261_ppmReceive::SetSession(PPMSESSPARAM_T* pSessparam)
{
	// ccp - note unsafe downcast
	m_ExtendedBitstream = ((H26XPPMSESSPARAM_T*) pSessparam)->ExtendedBitstream;
	return ppmReceive::SetSession(pSessparam);
}

//////////////////////////////////////////////////////////////////////////////
// IPPMReceiveSession Functions (Overrides)
//////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////
//GetResiliency:  Gets the boolean for whether resiliency is on or off
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP H261_ppmReceive::GetResiliency(LPBOOL			lpbResiliency)
{
	if (!lpbResiliency) return E_POINTER;
	*lpbResiliency = m_ExtendedBitstream;
	return NOERROR;
}

////////////////////////////////////////////////////////////////////////////////////////
//SetResiliency:  Sets the boolean for whether resiliency is on or off
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP H261_ppmReceive::SetResiliency(BOOL			pbResiliency)
{
	m_ExtendedBitstream = pbResiliency;
	return NOERROR;
}
#endif


//////////////////////////////////////////////////////////////////////////////////////////
// TimeToProcessMessages:
//////////////////////////////////////////////////////////////////////////////////////////
BOOL H261_ppmReceive::TimeToProcessMessages(FragDescriptor* pFragDescrip, MsgHeader* pMsgHdr)
{
	return (pMsgHdr == m_pMsgHeadersHead);
}

//////////////////////////////////////////////////////////////////////////////////////////
// CheckMessageComplete:
//////////////////////////////////////////////////////////////////////////////////////////
BOOL H261_ppmReceive::CheckMessageComplete(MsgHeader* pMsgHdr)
{
	// if there is no header then return false.
	if (pMsgHdr == NULL)
	{
		DBG_MSG(DBG_ERROR, ("H261_ppmReceive::CheckMessageComplete: ERROR - pMsgHdr == NULL"));
		return FALSE;
	}


	// should there be a critical section in this function.

	// check to make sure we have the first packet in the message.
	if (pMsgHdr->m_pPrev == NULL) // if first message in list, then look at a variable
	{
        if (m_GlobalLastSeqNum != pMsgHdr->m_pFragList->FirstSeqNum()-1)
		{
			return FALSE;
		}
	}
	else
	{
		if (pMsgHdr->m_pPrev->m_pFragList->LastSeqNum() != pMsgHdr->m_pFragList->FirstSeqNum()-1)
		{
			return FALSE;
		}
	}

	// check to make sure we have the last packet in the message.
	// For IETF compliance, marker bit must be set, but in H.225, the marker bit
	// may optionally be omitted if setting it could cause additional end-to-end delay
	// Thus, we check for the marker bit, but if it is not present, we also check to
	// see if the next packet is in and has a different timestamp (ala generic).
	if (! pMsgHdr->m_MarkerBitIn)
	{
		if (pMsgHdr->m_pNext == NULL)	// if we don't have the next message,
		{								// we don't know if the current message
										// is done.
			return FALSE;
		}
		
		if (pMsgHdr->m_pNext->m_pFragList->FirstSeqNum() !=
			pMsgHdr->m_pFragList->LastSeqNum() + 1)
		{
			return FALSE;
		}
	}

	// Check for a packet missing in the middle->
	if ((int)pMsgHdr->m_pFragList->SeqNumSpan() != pMsgHdr->m_NumFragments)
	{
		return FALSE;
	}

	return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////////
// PrepMessage:	Sets H261 global variables, calls base PrepMessage. If any error
//				checks are added, you MUST make a call to LeaveCriticalSection.
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT H261_ppmReceive::PrepMessage(BOOL Complete)
{
	EnterCriticalSection(&m_CritSec);

	// Can't hurt to check although we should never get here if there is no head.
	if (m_pMsgHeadersHead == NULL)
	{
		DBG_MSG(DBG_ERROR, ("H261_ppmReceive::PrepMessage: ERROR - m_pMsgHeadersHead == NULL"));
		LeaveCriticalSection(&m_CritSec);
		return PPMERR(PPM_E_CORRUPTED);
	}

	// Save marker bit flag.
	BOOL bMarkerBitIn = m_pMsgHeadersHead->m_MarkerBitIn;

	LeaveCriticalSection(&m_CritSec);

	HRESULT hErr = ppmReceive::PrepMessage(Complete);

	// Update the H261 global variable.
	m_GlobalLastMarkerBitIn = bMarkerBitIn;

	DBG_MSG(DBG_TRACE,
		("H261_ppmReceive::PrepMessage: m_GlobalLastMarkerBitIn=%d",
		m_GlobalLastMarkerBitIn));

	return hErr;
}

#ifdef REBUILD_EXBITSTREAM
//////////////////////////////////////////////////////////////////////////////////////////
// setBSInfoTrailer(): Inline helper to build EBS trailer.
//////////////////////////////////////////////////////////////////////////////////////////
void
setH261BSInfoTrailer(
	BSINFO_TRAILER&		rBS_trailer, 
	int					iFrame, 
	DWORD				dwBufSize, 
	int					nNumFrags, 
	RTPh261SourceFormat	rtph261SourceFormat)
{
	// complete info for the trailer
	rBS_trailer.dwVersion = H261_VERSION;
	rBS_trailer.dwUniqueCode = H261_CODE;
	rBS_trailer.dwFlags = 0;
	if (iFrame)
		rBS_trailer.dwFlags |= RTP_H26X_INTRA_CODED;
	rBS_trailer.dwCompressedSize = dwBufSize;
	rBS_trailer.dwNumberOfPackets = nNumFrags;
	
	// Note: We may send unknown source format here if frame PSC was corrupt
	// or missing, but we'll let the codec deal with that.  Codec will
	// typically just toss the frame, but sending unknown might facilitate
	// more advanced error receover (i.e. attempting to deterimine source
	// format from frame content).  This would be more likely in an off-line
	// (vs. real time) decoder.  If codec doesn't support "unknown", it can
	// use source format indicated by PSC
	rBS_trailer.SourceFormat = rtph261SourceFormat;

	// For H.261, we just put zeroes in these fields
	rBS_trailer.TR = 0;
	rBS_trailer.TRB = 0;
	rBS_trailer.DBQ = 0;
}
#endif // REBUILD_EXBITSTREAM

// lsc -	Note: we are not rebuilding the extended bitstream
//		for complete frames.
//		For now I am assuming that we only rebuild the extended bitstream for frames that
//		have not received all packets (handled by PartialMessageHandler), and for complete
//		frames we hand them up as usual.  However, this routine is overridden to handle the
//		data ORing for the byte overlap between packets.

#pragma optimize ( "", off ) // BUGBUG: Work around complier bug

//////////////////////////////////////////////////////////////////////////////////////////
// DataCopy:	Copies data fragments into client's buffer.  If any error checks with returns
//			are added they MUST call LeaveCriticalSection.
//
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT H261_ppmReceive::DataCopy(MsgHeader* const pMsgHdr)
{
	if (pMsgHdr == NULL)
	{
		DBG_MSG(DBG_ERROR, ("H261_ppmReceive::DataCopy: ERROR - pMsgHdr == NULL"));
		return PPMERR(PPM_E_EMPTYQUE);
	}

	ASSERT(! pMsgHdr->m_pFragList->Is_Empty());

	MsgDescriptor* pMsgDesc = DequeueBuffer(1);	// Get a buffer to hold the message.

	if (pMsgDesc == NULL)
	{
		FreeFragList(pMsgHdr);
		FreeMsgHeader(pMsgHdr);

		DBG_MSG(DBG_ERROR, ("H261_ppmReceive::DataCopy: ERROR - Couldn't get a reassembly buffer"));

		// Make a callback into the app to let it know what happened.
		ppm::PPMNotification(PPM_E_DROPFRAME, SEVERITY_NORMAL, NULL, 0);

		m_GlobalLastFrameDropped = TRUE;
		return PPMERR(PPM_E_DROPFRAME);
	}

	EnterCriticalSection(&m_CritSec);

#ifdef GIVE_SEQNUM
	// Do this before frag list exhausted below
	pMsgDesc->m_TimeStamp = pMsgHdr->m_pFragList->LastSeqNum();
#else
	pMsgDesc->m_TimeStamp = pMsgHdr->GetMsgID();
#endif

	// Get payload type from PSC for BuildExtendedBitstream().  Do this even
	// when not currently building the extended bitstream, since that mode can
	// be toggled during the session.
	RTPh261SourceFormat currentSourceFormat =
		getH261payloadType(
			((FragDescriptor*) pMsgHdr->m_pFragList->GetFirst())->m_pData);
	if (currentSourceFormat != rtph261SourceFormatUnknown)
		// Remember valid format for use by next frame.
		m_rtph261SourceFormat = currentSourceFormat;

#ifdef REBUILD_EXBITSTREAM

	BITSTREAM_INFO_H261* pEBS = NULL;
	int nNumFrags = 0, nCurrentEBS = 0, iFrame = 0;

	// Get local copy of extended bitstream flag to protect against
	// possible change via H261_ppmReceive::SetSession() while building
	// this frame.  OK to change between frames.
	BOOL bExtendedBitstream = m_ExtendedBitstream;

	if (bExtendedBitstream)
	{
		nNumFrags = pMsgHdr->m_pFragList->SeqNumSpan();

		// allocate structures for the extended bitstream information
		pEBS = new BITSTREAM_INFO_H261[nNumFrags];

		if (pEBS == NULL)
		{
			FreeFragList(pMsgHdr);
			EnqueueBuffer(pMsgDesc);
			FreeMsgHeader(pMsgHdr);

			LeaveCriticalSection(&m_CritSec);

			DBG_MSG(DBG_ERROR,
				("H261_ppmReceive::DataCopy: ERROR - memory allocation failure"));

			// Make a callback into the app to let it know what happened.
			ppm::PPMNotification(PPM_E_OUTOFMEMORY, SEVERITY_NORMAL, NULL, 0);
			m_GlobalLastFrameDropped = TRUE;

			return PPMERR(PPM_E_DROPFRAME);
		}
		memset(pEBS, 0, nNumFrags * sizeof(*pEBS));
	}
#endif

	// Loop state variables
	LPBYTE pbCurrentOffset = (LPBYTE) pMsgDesc->m_pBuffer;	// start copying into front of buffer.
	DWORD dwBufSize = 0;
	UCHAR chLastByte = 0;
	int nLastEbit = 0;	// prior packet's ebit, for error checking

	// There are three cases to check for overlapping bytes between
	// packets:
	//   1) There is overlap between packets, and this is first packet.
	//   2) There is overlap between packets, and this is not first packet.
	//   3) There is no overlap between packets.
	// We'll check case 1 now, before getting into packet loop.
			
	if (((H261_Header*)
			(((FragDescriptor*) pMsgHdr->m_pFragList->GetFirst())->m_pProfileHeader)
		)->sbit())
	{
		// First packet overlaps prior frame (case 1).  Add a byte to hold
		// first sbits.  No need to clear byte now, since it'll be overwritten
		// by chFirstByte below.
		pbCurrentOffset++;
		dwBufSize++;
	}

	// Process all rcvd packets
	while (! pMsgHdr->m_pFragList->Is_Empty())
	{
		// get next fragment (const to prevent unintentional modification)
		FragDescriptor* const pFragDesc = (FragDescriptor*)
			pMsgHdr->m_pFragList->TakeFromList();
		m_PacketsHold--;

		// Verify that TakeFromList() didn't return NULL and that we
		// won't overrun the buffer.
		BOOL bExit;

#ifdef REBUILD_EXBITSTREAM
		if (bExtendedBitstream && (pFragDesc != NULL))
		{
			bExit =
				((dwBufSize +
				 pFragDesc->m_BytesOfData +
				 (nNumFrags * sizeof(*pEBS)) +
				 sizeof(BSINFO_TRAILER) +
				 offsetNextDword(pbCurrentOffset))
					> pMsgDesc->m_Size);
		}
		else
#endif
		{
			bExit =
				((pFragDesc == NULL) ||
				 (dwBufSize + pFragDesc->m_BytesOfData >= pMsgDesc->m_Size));
		}
		if (bExit)
		{
			FreeFragList(pMsgHdr);
			EnqueueBuffer(pMsgDesc);
			FreeMsgHeader(pMsgHdr);

#ifdef REBUILD_EXBITSTREAM
			if (bExtendedBitstream)
			{
				if (pEBS) {
					delete [] pEBS;
					pEBS = NULL;
				}
			}
#endif

			LeaveCriticalSection(&m_CritSec);

			DBG_MSG(DBG_ERROR, 
				("H261_ppmReceive::DataCopy: ERROR - null pFragDesc or buffer overrun"));

			if (pFragDesc != NULL)
			{
				// Release the CRTPSample to receive more data
				m_pSubmitCallback->SubmitComplete(pFragDesc->m_pFragCookie,
												  NOERROR);
				// Make a callback into the app to let it know what happened.
				ppm::PPMNotification(PPM_E_RECVSIZE, SEVERITY_NORMAL, NULL, 0);
				// BUGBUG We are here because
				// m_pFragList->Is_Empty() == FALSE
				// then the pFragDesc should always be != NULL
				if (pFragDesc->m_pProfileHeader)
					FreeProfileHeader(pFragDesc->m_pProfileHeader);
				FreeFragDescriptor(pFragDesc);
			}
			m_GlobalLastFrameDropped = TRUE;

			return PPMERR(PPM_E_DROPFRAME);
		}

		// Assign immutable reference to profile header
		H261_Header& rProfileHdr =
			*(H261_Header*) pFragDesc->m_pProfileHeader;

#ifdef REBUILD_EXBITSTREAM
		if (bExtendedBitstream)
		{
			// Write BS struct for current packet.  Do this _before_
			// advancing dwBufSize.
			pEBS[nCurrentEBS].dwFlags = 0;
			if (rProfileHdr.sbit())
			{
				// Adjust EBS bit offset for this packet's sbits
				pEBS[nCurrentEBS].dwBitOffset =
					  ((dwBufSize - 1) * BITSPERBYTE)
					+ rProfileHdr.sbit();
			}
			else
			{
				pEBS[nCurrentEBS].dwBitOffset = dwBufSize * BITSPERBYTE;
			}
			pEBS[nCurrentEBS].MBAP	= rProfileHdr.mbap();
			pEBS[nCurrentEBS].Quant	= rProfileHdr.quant();
			pEBS[nCurrentEBS].GOBN	= rProfileHdr.gobn();
			pEBS[nCurrentEBS].HMV	= rProfileHdr.hmvd();
			pEBS[nCurrentEBS].VMV	= rProfileHdr.vmvd();
			nCurrentEBS++;
		}
#endif /* REBUILD_EXBITSTREAM */

		if (rProfileHdr.sbit())
		{
			// This packet has missing sbits (case 1 or 2)
			UCHAR chFirstByte =
				  *((LPBYTE) pFragDesc->m_pData)
				& GetSMask(rProfileHdr.sbit());

			// Either this is first packet (thus no ebits), or the prior
			// and current packets had better overlap properly.
			if ((nLastEbit != 0)
				&& ((nLastEbit + rProfileHdr.sbit()) != BITSPERBYTE))
			{
				FreeFragList(pMsgHdr);
				EnqueueBuffer(pMsgDesc);
				FreeMsgHeader(pMsgHdr);

#ifdef REBUILD_EXBITSTREAM
				if (bExtendedBitstream)
				{
					if (pEBS) {
						delete [] pEBS;
						pEBS = NULL;
					}
				}
#endif

				LeaveCriticalSection(&m_CritSec);

				DBG_MSG(DBG_ERROR, ("H261_ppmReceive::DataCopy: ERROR - Received packets with sbit/ebit mismatch"));

				if (pFragDesc != NULL)
				{
					// Release the CRTPSample to receive more data
					m_pSubmitCallback->SubmitComplete(pFragDesc->m_pFragCookie,
													  NOERROR);
					// Make a callback into the app to let it know what happened.
					ppm::PPMNotification(PPM_E_DROPFRAME, SEVERITY_NORMAL, NULL, 0);
					// BUGBUG We are here because
					// m_pFragList->Is_Empty() == FALSE
					// then the pFragDesc should always be != NULL
					if (pFragDesc->m_pProfileHeader)
						FreeProfileHeader(pFragDesc->m_pProfileHeader);
					FreeFragDescriptor(pFragDesc);
				}
				m_GlobalLastFrameDropped = TRUE;

				return PPMERR(PPM_E_DROPFRAME);
			}

			// combine sbits with ebits from prior packet
			chFirstByte |= chLastByte;

			// Copy packet to buffer
			pbCurrentOffset[-1] = chFirstByte;
			dwBufSize +=
				copyAndAdvance(
					pbCurrentOffset,
					(LPBYTE) pFragDesc->m_pData + 1,
					pFragDesc->m_BytesOfData - 1);
		}
		else
		{
			// This packet has no missing sbits (case 3).
			if (nLastEbit != 0)
			{
				// Prior packet has missing ebits; possible encoding error.
				FreeFragList(pMsgHdr);
				EnqueueBuffer(pMsgDesc);
				FreeMsgHeader(pMsgHdr);

#ifdef REBUILD_EXBITSTREAM
				if (bExtendedBitstream)
				{
					if (pEBS) {
						delete [] pEBS;
						pEBS = NULL;
					}
				}
#endif

				LeaveCriticalSection(&m_CritSec);

				DBG_MSG(DBG_ERROR, ("H261_ppmReceive::DataCopy: ERROR - Received packets with sbit/ebit mismatch"));

				if (pFragDesc != NULL)
				{
					// Release the CRTPSample to receive more data
					m_pSubmitCallback->SubmitComplete(pFragDesc->m_pFragCookie,
													  NOERROR);
					// Make a callback into the app to let it know what happened.
					ppm::PPMNotification(PPM_E_DROPFRAME, SEVERITY_NORMAL, NULL, 0);
					// BUGBUG We are here because
					// m_pFragList->Is_Empty() == FALSE
					// then the pFragDesc should always be != NULL
					if (pFragDesc->m_pProfileHeader)
						FreeProfileHeader(pFragDesc->m_pProfileHeader);
					FreeFragDescriptor(pFragDesc);
				}
				m_GlobalLastFrameDropped = TRUE;

				return PPMERR(PPM_E_DROPFRAME);
			}

			// Copy packet to buffer
			dwBufSize +=
				copyAndAdvance(
					pbCurrentOffset,
					(LPBYTE) pFragDesc->m_pData,
					pFragDesc->m_BytesOfData);

#ifdef REBUILD_EXBITSTREAM
			if (bExtendedBitstream)
			{
				iFrame = rProfileHdr.i();
			}
#endif
		}

		// Always shift the ignored bits out of the last byte and patch it
		// back into the buffer, since there is no harm in doing so.
		chLastByte =
			  (*((LPBYTE)pFragDesc->m_pData + pFragDesc->m_BytesOfData-1))
			& GetEMask(rProfileHdr.ebit());

		// Overwrite last byte in buffer
		pbCurrentOffset[-1] = chLastByte;

		// Save for packet misalignment detection.
		nLastEbit = rProfileHdr.ebit();

		// send the frag buffer back down to receive more data and free the frag header.
		m_pSubmitCallback->SubmitComplete(pFragDesc->m_pFragCookie, NOERROR);

		if (pFragDesc->m_pProfileHeader)
			FreeProfileHeader(pFragDesc->m_pProfileHeader);
		FreeFragDescriptor(pFragDesc);

	} // End of packet processing loop

#ifdef REBUILD_EXBITSTREAM
	if (bExtendedBitstream)
	{
		{
			// Test if the buffer size is enough to avoid
			// writing past the buffer size
			unsigned char *ptr;

			ptr = pbCurrentOffset +
				offsetNextDword(pbCurrentOffset) +
				nNumFrags * sizeof(*pEBS) +
				sizeof(BSINFO_TRAILER);

			if (ptr > ((unsigned char *)(pMsgDesc->m_pBuffer) +
					   pMsgDesc->m_Size) ) {

				// Make a callback into the app to let it know what happened.
				ppm::PPMNotification(PPM_E_RECVSIZE, SEVERITY_NORMAL, NULL, 0);
#if DEBUG_FREELIST > 2
				char str[128];
				wsprintf(str,"DataCopy[0x%X]: "
						 "About to corrupt buffer "
						 "at: 0x%X size=%d, drop frame\n",
						 pMsgDesc->m_pBuffer, ptr-1, pMsgDesc->m_Size);
				OutputDebugString(str);
#endif
				if (pEBS)
					delete [] pEBS;

				// Drop frame
				FreeFragList(pMsgHdr);
				EnqueueBuffer(pMsgDesc);
				FreeMsgHeader(pMsgHdr);
				
				LeaveCriticalSection(&m_CritSec);
				
				m_GlobalLastFrameDropped = TRUE;
				
				return PPMERR(PPM_E_DROPFRAME);
			}
		}
		
		// Note that we don't increment dwBufSize here, since it doesn't include EBS or trailer.

		// pad with zeros to next dword boundary
		static const DWORD dwZero = 0;
		copyAndAdvance(pbCurrentOffset, &dwZero, offsetNextDword(pbCurrentOffset));

		// copy the extended bitstream structures into the buffer
		copyAndAdvance(pbCurrentOffset, pEBS, nNumFrags * sizeof(*pEBS));

		// Delete now to prevent erroneous late update
		delete [] pEBS;
		pEBS = NULL;

		setH261BSInfoTrailer(
			*(BSINFO_TRAILER*) pbCurrentOffset,
			iFrame,
			dwBufSize,
			nNumFrags,
			currentSourceFormat);
		pbCurrentOffset += sizeof(BSINFO_TRAILER);
	}
#endif /* REBUILD_EXBITSTREAM */

	LeaveCriticalSection(&m_CritSec);

	// When we are done. Call Client's submit with full Message
	WSABUF tmpWSABUF[2];
	tmpWSABUF[0].buf = (char*) pMsgDesc->m_pBuffer;
#ifdef REBUILD_EXBITSTREAM
	if (bExtendedBitstream)
	{
		// we report the size including the extended bitstream + trailer + padding
		tmpWSABUF[0].len = (ULONG) (pbCurrentOffset -
									(LPBYTE) pMsgDesc->m_pBuffer);
	}
	else
#endif
	{
		tmpWSABUF[0].len = dwBufSize;
	}
	tmpWSABUF[1].buf = (char*) &(pMsgDesc->m_TimeStamp);
	tmpWSABUF[1].len = sizeof(pMsgDesc->m_TimeStamp);

	FreeMsgHeader(pMsgHdr);

	HRESULT status =
		m_pSubmit->Submit(
			tmpWSABUF,
			2,
			pMsgDesc,
			m_GlobalLastFrameDropped ? PPMERR(PPM_E_DROPFRAME) : NOERROR);

	m_GlobalLastFrameDropped = FALSE;

	if (FAILED(status))
	{
#if DEBUG_FREELIST > 2
		char str[128];
		wsprintf(str,"DataCopy: Submit failed %d (0x%X)\n", status, status);
		OutputDebugString(str);
#endif
		
		// no SubmitComplete should be called, so take care of resources now
		//pMsgDesc->m_Size = m_MaxBufferSize;	// reset the data buffer size
		//EnqueueBuffer(pMsgDesc);
		DBG_MSG(DBG_ERROR, ("H261_ppmReceive::DataCopy: ERROR - Client Submit failed"));
		status = PPMERR(PPM_E_CLIENTERR);

		// Make a callback into the app to let it know what happened.
		ppm::PPMNotification(PPM_E_CLIENTERR, SEVERITY_NORMAL, NULL, 0);
		m_GlobalLastFrameDropped = TRUE;
	}

	return status;
}

#pragma optimize ( "", on ) // BUGBUG: Work around complier bug

#ifdef REBUILD_EXBITSTREAM


//////////////////////////////////////////////////////////////////////////////////////////
// initBitstreamInfoH261: Prepares bitstream info vector element.  This function assumes
// that bitstream info vector was zero-filed on allocation, and that elements are never
// reused.  If this turns out to be dangerous, this function should memset BS_info to zero.
//////////////////////////////////////////////////////////////////////////////////////////
inline void
initBitstreamInfoH261(BITSTREAM_INFO_H261& BS_info, DWORD dwBitOffset = 0)
{
	BS_info.dwFlags = RTP_H26X_PACKET_LOST;
	BS_info.dwBitOffset = dwBitOffset;
}

//////////////////////////////////////////////////////////////////////////////////////////
// BuildExtendedBitstream: build extended bitstream
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT H261_ppmReceive::BuildExtendedBitstream(MsgHeader* const pMsgHdr)
{
	MsgDescriptor* pMsgDesc = DequeueBuffer(1);	// Get a buffer to hold the message.
	if (pMsgDesc == NULL)
	{
		FreeFragList(pMsgHdr);
		FreeMsgHeader(pMsgHdr);

		DBG_MSG(DBG_ERROR, ("H261_ppmReceive::BuildExtendedBitstream: ERROR - Couldn't get a reassembly buffer"));

		// Make a callback into the app to let it know what happened.
		ppm::PPMNotification(PPM_E_DROPFRAME, SEVERITY_NORMAL, NULL, 0);
		m_GlobalLastFrameDropped = TRUE;
		return PPMERR(PPM_E_DROPFRAME);
	}

	EnterCriticalSection(&m_CritSec);

#ifdef GIVE_SEQNUM
	// Do this before frag list exhausted below
	pMsgDesc->m_TimeStamp = pMsgHdr->m_pFragList->LastSeqNum();
#else
	pMsgDesc->m_TimeStamp = pMsgHdr->GetMsgID();
#endif

	int nExtraFrags = 0;

	// Use presence/absence of valid picture start code to determine whether
	// or not first fragment has been rcvd.
	RTPh261SourceFormat currentSourceFormat =
		getH261payloadType(
			((FragDescriptor*) pMsgHdr->m_pFragList->GetFirst())->m_pData);

	if (currentSourceFormat == rtph261SourceFormatUnknown)
	{
		nExtraFrags++;
	}
	else
	{
		// Remember valid format for use by next frame
		m_rtph261SourceFormat = currentSourceFormat;
	}

	// Check for last packet missing; if so, add 1 to nNumFrags.
	if (! pMsgHdr->m_MarkerBitIn)
	{
		nExtraFrags++;
	}

	// Compute frame fragment count (const for safety)
	const int nNumFrags =
		pMsgHdr->m_pFragList->SeqNumSpan() + nExtraFrags;

	DBG_MSG(DBG_TRACE,
		("H261_ppmReceive::BuildExtendedBitstream: "
			"m_GlobalLastMarkerBitIn=%d, "
			"m_GlobalLastSeqNum=%d",
		m_GlobalLastMarkerBitIn,
		m_GlobalLastSeqNum));
	DBG_MSG(DBG_TRACE,
		("H261_ppmReceive::BuildExtendedBitstream: "
			"MsgHeader*=0x%08lx, FirstSeqNum()=%d",
		pMsgHdr,
		pMsgHdr->m_pFragList->FirstSeqNum()));
	DBG_MSG(DBG_TRACE,
		("    LastSeqNum()=%d, nNumFrags=%d",
		pMsgHdr->m_pFragList->LastSeqNum(),
		nNumFrags));

	// allocate structures for the extended bitstream information
	BITSTREAM_INFO_H261* pEBS = new BITSTREAM_INFO_H261[nNumFrags];

	if (pEBS == NULL)
	{
		FreeFragList(pMsgHdr);
		EnqueueBuffer(pMsgDesc);
		FreeMsgHeader(pMsgHdr);

		LeaveCriticalSection(&m_CritSec);

		DBG_MSG(DBG_ERROR,
			("H261_ppmReceive::BuildExtendedBitstream: ERROR - memory allocation failure"));

		// Make a callback into the app to let it know what happened.
		ppm::PPMNotification(PPM_E_OUTOFMEMORY, SEVERITY_NORMAL, NULL, 0);
		m_GlobalLastFrameDropped = TRUE;
		return PPMERR(PPM_E_DROPFRAME);
	}
	memset(pEBS, 0, nNumFrags * sizeof(*pEBS));

	LPBYTE pbCurrentOffset = (LPBYTE) pMsgDesc->m_pBuffer;	// start copying into front of buffer.
	DWORD dwBufSize = 0;
	int nCurrentEBS = 0;	// EBS vector index

	if (currentSourceFormat == rtph261SourceFormatUnknown)
	{
		// Source format is unknown, assume first packet is missing.
		
		// Add EBS info for the lost first packet
		initBitstreamInfoH261(pEBS[nCurrentEBS ++]);

		// Add new padding values for lost first packet.  Use PSC which
		// corresponds to source format of last seen valid PSC.
		if (m_rtph261SourceFormat == rtph261SourceFormatCIF)
		{
			dwBufSize +=
				copyAndAdvance(
					pbCurrentOffset,
					&s_leadFragBitPatternCIF,
					sizeof(s_leadFragBitPatternCIF));
		}
		else
		{
			// Either QCIF or unknown
			dwBufSize +=
				copyAndAdvance(
					pbCurrentOffset,
					&s_leadFragBitPatternQCIF,
					sizeof(s_leadFragBitPatternQCIF));
		}
	}

	// Loop state variables
	UCHAR chLastByte = 0;
	int iFrame = 0, nLastEbit = 0;

	int nCurrentSeqNum = pMsgHdr->m_pFragList->FirstSeqNum();

	// Process all rcvd packets
	while (! pMsgHdr->m_pFragList->Is_Empty())
	{
		// get next fragment (const to prevent unintentional modification)
		FragDescriptor* const pFragDesc = (FragDescriptor*)
			pMsgHdr->m_pFragList->TakeFromList();
		m_PacketsHold--;

		// Note: remember that m_pFragList will be empty after the last
		// iteration of this loop, so LList::methods which expect a
		// non-empty list should not be called below.

		// check to see if TakeFromList() returned NULL.  Also, make sure
		// we won't overrun the buffer (including extended bitstream,
		// the trailer and any dword alignment bits that need to be added).
		if ((pFragDesc == NULL) ||
			((dwBufSize +
			pFragDesc->m_BytesOfData +
			(nNumFrags * sizeof(*pEBS)) +
			sizeof(BSINFO_TRAILER) +
			offsetNextDword(pbCurrentOffset))
				> pMsgDesc->m_Size))
		{
			FreeFragList(pMsgHdr);
			EnqueueBuffer(pMsgDesc);
			FreeMsgHeader(pMsgHdr);

			if (pEBS) {
				delete [] pEBS;
				pEBS = NULL;
			}

			LeaveCriticalSection(&m_CritSec);
			DBG_MSG(DBG_ERROR, ("H261_ppmReceive::BuildExtendedBitstream: ERROR - null pFragDesc or buffer overrun"));
			if (pFragDesc != NULL)
			{
				// Make a callback into the app to let it know what happened.
				ppm::PPMNotification(PPM_E_RECVSIZE, SEVERITY_NORMAL, NULL, 0);
				// BUGBUG We are here because
				// m_pFragList->Is_Empty() == FALSE
				// then the pFragDesc should always be != NULL
				if (pFragDesc->m_pProfileHeader)
					FreeProfileHeader(pFragDesc->m_pProfileHeader);
				FreeFragDescriptor(pFragDesc);
			}
			m_GlobalLastFrameDropped = TRUE;
			return PPMERR(PPM_E_DROPFRAME);
		}

		DBG_MSG(DBG_TRACE,
			("H261_ppmReceive::BuildExtendedBitstream: "
				"FragDescriptor*=0x%08lx, "
				"seq=%d, "
				"ts=%lu, "
				"frag[0-3]=%1X%1X%1X%1X",
			pFragDesc,
			pFragDesc->m_pRTPHeader->seq(),
			pFragDesc->m_pRTPHeader->ts(),
			((char*) pFragDesc->m_pData)[0],
			((char*) pFragDesc->m_pData)[1],
			((char*) pFragDesc->m_pData)[2],
			((char*) pFragDesc->m_pData)[3]));

		// see if packets are skipped; if so, put padding into buffer and add BS struct
#ifdef RTP_CLASS
		for (; nCurrentSeqNum < pFragDesc->m_pRTPHeader->seq(); nCurrentSeqNum++)
#else
		for (; nCurrentSeqNum < ntohs(pFragDesc->m_pRTPHeader->seq); nCurrentSeqNum++)
#endif
		{

			if (nCurrentEBS >= nNumFrags) {  //ERROR, bail out
				FreeFragList(pMsgHdr);
				EnqueueBuffer(pMsgDesc);
				FreeMsgHeader(pMsgHdr);

				if (pEBS) {
					delete [] pEBS;
					pEBS = NULL;
				}

				LeaveCriticalSection(&m_CritSec);
				DBG_MSG(DBG_ERROR, ("H263_ppmReceive::BuildExtendedBitstream: ERROR - buffer overrun"));
				if (pFragDesc != NULL)
				{
					// Make a callback into the app to let it know what happened.
					ppm::PPMNotification(PPM_E_RECVSIZE, SEVERITY_NORMAL, NULL, 0);
					// BUGBUG We are here because
					// m_pFragList->Is_Empty() == FALSE
					// then the pFragDesc should always be != NULL
					if (pFragDesc->m_pProfileHeader)
						FreeProfileHeader(pFragDesc->m_pProfileHeader);
					FreeFragDescriptor(pFragDesc);
				}
				m_GlobalLastFrameDropped = TRUE;
				return PPMERR(PPM_E_DROPFRAME);
			}

			// If prior rcvd packet had missing ebits, adjust bit
			// offset accordingly.  The missing bits are added to the
			// tail of the padding (by forcing bit offset of _next_
			// segment to be byte-aligned).  If there was no prior rcvd
			// packet, or prior packet had no missing ebits, nLastEbit ==
			// 0, so that the bit offset expression is equivalent to
			// (dwBufSize * BITSPERBYTE).
			initBitstreamInfoH261(
				pEBS[nCurrentEBS++],
				((dwBufSize - 1) * BITSPERBYTE)
					+ (BITSPERBYTE - nLastEbit));

			// we just consumed the last ebits (if any), and are now back
			// to byte alignment.
			nLastEbit = 0;
			chLastByte = 0;

			// for packets other than the first of the frame, we pad with 4
			// bytes of zeroes
			dwBufSize +=
				copyAndAdvance(
					pbCurrentOffset,
					&s_nonLeadFragBitPattern,
					sizeof(s_nonLeadFragBitPattern));
		}

		// Assign immutable reference to profile header
		H261_Header& rProfileHdr =
			*(H261_Header*) pFragDesc->m_pProfileHeader;

		// Handle overlapping (shared byte) between current and prior
		// between packets.  There are three cases to deal with:
		// 1)	Current packet overlaps the prior packet, and the prior
		//		packet was received.
		// 2)	Current packet overlaps the prior packet, and this is first
		//		packet or prior packet was lost (there are no pending ebits).
		// 3)	Current packet doesn't overlap the prior packet.
		if (rProfileHdr.sbit())
		{
			// This packet had missing sbits (case 1 or 2).

			// Mask off missing sbits and combin with ebits from prior packet.
			const UCHAR chFirstByte =
				(*(LPBYTE) pFragDesc->m_pData
					& GetSMask(rProfileHdr.sbit()))
				| chLastByte;

			if (nLastEbit == 0)
			{
				// Case 2: There are no pending ebits, so we need an
				// extra byte into which to stuff the current packet's
				// sbits.  No need to clear the byte, since it'll be
				// overwritten by chFirstByte below.
				pbCurrentOffset++;
				dwBufSize++;
			}
			else if (nLastEbit + rProfileHdr.sbit() != BITSPERBYTE)
			{
				// The prior and current packets don't overlap properly.
				FreeFragList(pMsgHdr);
				EnqueueBuffer(pMsgDesc);
				FreeMsgHeader(pMsgHdr);

				if (pEBS) {
					delete [] pEBS;
					pEBS = NULL;
				}

				LeaveCriticalSection(&m_CritSec);

				DBG_MSG(DBG_ERROR, ("H261_ppmReceive::BuildExtendedBitstream: ERROR - Received packets with sbit/ebit mismatch"));

				if (pFragDesc != NULL)
				{
					// Make a callback into the app to let it know what happened.
					ppm::PPMNotification(PPM_E_DROPFRAME, SEVERITY_NORMAL, NULL, 0);
					// BUGBUG We are here because
					// m_pFragList->Is_Empty() == FALSE
					// then the pFragDesc should always be != NULL
					if (pFragDesc->m_pProfileHeader)
						FreeProfileHeader(pFragDesc->m_pProfileHeader);
					FreeFragDescriptor(pFragDesc);
				}
				m_GlobalLastFrameDropped = TRUE;

				return PPMERR(PPM_E_DROPFRAME);
			}

			pEBS[nCurrentEBS].dwBitOffset =
				  ((dwBufSize - 1) * BITSPERBYTE)
				+ rProfileHdr.sbit();

			// Copy the packet to the frame buffer.
			pbCurrentOffset[-1] = chFirstByte;
			dwBufSize +=
				copyAndAdvance(
					pbCurrentOffset,
					(LPBYTE) pFragDesc->m_pData + 1,
					pFragDesc->m_BytesOfData - 1);

			// dwBufSize now points to _next_ packet slot
		}
		else
		{
			// This packet doesn't overlap prior packet (case 3).
			if (nLastEbit != 0)
			{
				// Prior packet has missing ebits; possible encoding error.
				FreeFragList(pMsgHdr);
				EnqueueBuffer(pMsgDesc);
				FreeMsgHeader(pMsgHdr);

				if (pEBS) {
					delete [] pEBS;
					pEBS = NULL;
				}

				LeaveCriticalSection(&m_CritSec);

				DBG_MSG(DBG_ERROR, ("H261_ppmReceive::BuildExtendedBitstream: ERROR - Received packets with sbit/ebit mismatch"));

				if (pFragDesc != NULL)
				{
					// Make a callback into the app to let it know what happened.
					ppm::PPMNotification(PPM_E_DROPFRAME, SEVERITY_NORMAL, NULL, 0);
					// BUGBUG We are here because
					// m_pFragList->Is_Empty() == FALSE
					// then the pFragDesc should always be != NULL
					if (pFragDesc->m_pProfileHeader)
						FreeProfileHeader(pFragDesc->m_pProfileHeader);
					FreeFragDescriptor(pFragDesc);
				}
				m_GlobalLastFrameDropped = TRUE;

				return PPMERR(PPM_E_DROPFRAME);
			}

			pEBS[nCurrentEBS].dwBitOffset = dwBufSize * BITSPERBYTE;

			// Copy the packet to the frame buffer.
			dwBufSize +=
				copyAndAdvance(
					pbCurrentOffset,
					pFragDesc->m_pData,
					pFragDesc->m_BytesOfData);

			// dwBufSize now points to _next_ packet slot

			iFrame = rProfileHdr.i();
		}

		// We need to store the ebit for the last received packet to give the
		// dwBitOffset for the last real packet if lost.
		nLastEbit = rProfileHdr.ebit();

		// Always shift the ignored bits out of the last byte and patch it
		// back into the buffer, since there is no harm in doing so.
		chLastByte =
			  (*((LPBYTE)pFragDesc->m_pData + pFragDesc->m_BytesOfData - 1))
			& GetEMask(nLastEbit);

		// Overwrite last byte to clear missing bits
		pbCurrentOffset[-1] = chLastByte;

		// Update BS struct for current packet and save off values for
		// next lost packet
		pEBS[nCurrentEBS].dwFlags	= 0;
		pEBS[nCurrentEBS].MBAP		= rProfileHdr.mbap();
		pEBS[nCurrentEBS].Quant		= rProfileHdr.quant();
		pEBS[nCurrentEBS].GOBN		= rProfileHdr.gobn();
		pEBS[nCurrentEBS].HMV		= rProfileHdr.hmvd();
		pEBS[nCurrentEBS].VMV		= rProfileHdr.vmvd();
		nCurrentEBS++;
		nCurrentSeqNum++;

		// Send the frag buffer back down to receive more data and free
		// the frag header. always pass zero because we never allocated
		// the buffers and therefore have no idea how big the buffers
		// are.
		m_pSubmitCallback->SubmitComplete(pFragDesc->m_pFragCookie, NOERROR);

		if (pFragDesc->m_pProfileHeader)
			FreeProfileHeader(pFragDesc->m_pProfileHeader);
		FreeFragDescriptor(pFragDesc);

	} // End of packet processing loop

	{
		// Test if the buffer size is enough to avoid
		// writing past the buffer size
		unsigned char *ptr;

		ptr = pbCurrentOffset +
			offsetNextDword(pbCurrentOffset) +
			nNumFrags * sizeof(*pEBS) +
			sizeof(BSINFO_TRAILER);
		
		if (!pMsgHdr->m_MarkerBitIn)
			ptr += sizeof(s_nonLeadFragBitPattern);
		
		if ( ptr >
			 ((unsigned char *)(pMsgDesc->m_pBuffer) + pMsgDesc->m_Size) ) {

			// Make a callback into the app to let it know what happened.
			ppm::PPMNotification(PPM_E_DROPFRAME, SEVERITY_NORMAL, NULL, 0);

#if DEBUG_FREELIST > 2
			char str[128];
			wsprintf(str,"BuildExtendedBitstream[0x%X]: "
					 "About to corrupt buffer "
					 "at: 0x%X size=%d, drop frame\n",
					 pMsgDesc->m_pBuffer, ptr-1, pMsgDesc->m_Size);
			OutputDebugString(str);
#endif
		
			if (pEBS)
				delete [] pEBS;

			// Drop frame
			FreeFragList(pMsgHdr);
			EnqueueBuffer(pMsgDesc);
			FreeMsgHeader(pMsgHdr);

			LeaveCriticalSection(&m_CritSec);
			
			m_GlobalLastFrameDropped = TRUE;
		
			return PPMERR(PPM_E_DROPFRAME);
		}
	}
	
	// check and handling for last packet if missing
	if (! pMsgHdr->m_MarkerBitIn)
	{
		// Yes, it's last packet, but increment nCurrentEBS to trap
		// unintentional reference later.
		initBitstreamInfoH261(
			pEBS[nCurrentEBS ++],
			((dwBufSize - 1) * BITSPERBYTE) + (BITSPERBYTE - nLastEbit));

		// for packets other than the first of the frame, we pad with
		// 4 bytes of zeroes
		dwBufSize +=
			copyAndAdvance(
				pbCurrentOffset,
				&s_nonLeadFragBitPattern,
				sizeof(s_nonLeadFragBitPattern));
	}

	// pad with zeros to next dword boundary
	static const DWORD dwZero = 0;
	copyAndAdvance(pbCurrentOffset, &dwZero, offsetNextDword(pbCurrentOffset));

	// copy the extended bitstream structures into the buffer
	copyAndAdvance(pbCurrentOffset, pEBS, nNumFrags * sizeof(*pEBS));

	// Delete now to prevent erroneous late update
	delete [] pEBS;
	pEBS = NULL;

	// Note that dwBufSize doesn't include the extended bitstream or the trailer.
	setH261BSInfoTrailer(
		*(BSINFO_TRAILER*) pbCurrentOffset, 
		iFrame, 
		dwBufSize, 
		nNumFrags, 
		m_rtph261SourceFormat);
	pbCurrentOffset += sizeof(BSINFO_TRAILER);

	LeaveCriticalSection(&m_CritSec);

	// When we are done. Call Client's submit with full Message

	// we report the size including the extended bitstream + trailer + padding
	WSABUF tmpWSABUF[2];
	tmpWSABUF[0].buf = (char*) pMsgDesc->m_pBuffer;
	tmpWSABUF[0].len = (DWORD)(pbCurrentOffset - (LPBYTE) pMsgDesc->m_pBuffer);
	tmpWSABUF[1].buf = (char*) &(pMsgDesc->m_TimeStamp);
	tmpWSABUF[1].len = sizeof(pMsgDesc->m_TimeStamp);

	// Make a callback into the app to let it know about this partial frame
	// We also pass the timestamp of the frame
	ppm::PPMNotification(
			PPM_E_PARTIALFRAME,
			SEVERITY_NORMAL,
			(LPBYTE) tmpWSABUF[1].buf,
			tmpWSABUF[1].len);

	FreeMsgHeader(pMsgHdr);

	HRESULT status =
		m_pSubmit->Submit(tmpWSABUF, 2, pMsgDesc, PPMERR(PPM_E_PARTIALFRAME));
	m_GlobalLastFrameDropped = FALSE;

	if (FAILED(status))
	{
		// no SubmitComplete should be called, so take care of resources now
		//pMsgDesc->m_Size = m_MaxBufferSize;	// reset the data buffer size
		//EnqueueBuffer(pMsgDesc);
		DBG_MSG(DBG_ERROR, ("H261_ppmReceive::BuildExtendedBitstream: ERROR - Client Submit failed"));
		status = PPMERR(PPM_E_CLIENTERR);

		// Make a callback into the app to let it know what happened.
		ppm::PPMNotification(PPM_E_CLIENTERR, SEVERITY_NORMAL, NULL, 0);
		m_GlobalLastFrameDropped = TRUE;
	}

	return status;
}
#endif // REBUILD_EXBITSTREAM

//////////////////////////////////////////////////////////////////////////////////////////
// PartialMessageHandler: deals with partial messages
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT H261_ppmReceive::PartialMessageHandler(MsgHeader* pMsgHdr)
{
	if (pMsgHdr == NULL)
	{
		DBG_MSG(DBG_ERROR, ("H261_ppmReceive::PartialMessageHandler: ERROR - pMsgHdr == NULL"));
		return PPMERR(PPM_E_EMPTYQUE);
	}

	ASSERT(! pMsgHdr->m_pFragList->Is_Empty());

#ifdef REBUILD_EXBITSTREAM
	if (m_ExtendedBitstream)
	{
		return BuildExtendedBitstream(pMsgHdr);
	}
	else
#endif /* REBUILD_EXBITSTREAM */
	{
		// Make a callback into the app to let it know about this dropped frame
		// We also pass the timestamp of the frame
		DWORD tmpTS = pMsgHdr->GetMsgID();
		ppm::PPMNotification(
				PPM_E_DROPFRAME,
				SEVERITY_NORMAL,
				(LPBYTE) &tmpTS,
				sizeof(tmpTS));
		m_GlobalLastFrameDropped = TRUE;

		FreeFragList(pMsgHdr);
		FreeMsgHeader(pMsgHdr);
		return NOERROR;
	}
}

//////////////////////////////////////////////////////////////////////////////////////////
// InitProfileHeader: Given a buffer as type void, sets up a profile header.  Does nothing
// for the Generic case.  Intended for overrides for various payloads.
// Companion member function FreeProfileHeader provided so that if payload
// header memory is allocated in this function, it can be freed there.
//////////////////////////////////////////////////////////////////////////////////////////
void* H261_ppmReceive::InitProfileHeader(void* pBuffer)
{
	// return new H261_Header ( (char*) pBuffer );
	return new ( m_pH261Headers )H261_Header ( (char*) pBuffer );
}

//////////////////////////////////////////////////////////////////////////////////////////
// FreeProfileHeader: Given a buffer as type void, frees up a profile header.  Does nothing
// for the Generic case.  Intended for overrides for various payloads.
// Companion member function InitProfileHeader may allocate memory for
// payload header which needs to be freed here. No return value.
//////////////////////////////////////////////////////////////////////////////////////////
void H261_ppmReceive::FreeProfileHeader(void* pBuffer)
{
	// delete (H261_Header*)pBuffer;
	m_pH261Headers->Free( pBuffer );
	return;
}

// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\h261snd.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: h261snd.cpp
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#include "h261snd.h"
#include "ppmerr.h"
#include "ippmcb.h"

H261_ppmSend::H261_ppmSend(IUnknown* pUnkOuter, IUnknown** ppUnkInner) : ppmSend(H261_PT, sizeof(unsigned long), 90000, pUnkOuter, ppUnkInner)
{
   m_pH261Headers     = NULL;
   m_pBSINFO_TRAILER  = NULL;

  //Allocate memory for the H261 headers; ReadNumFragBufs and ReadProfileHeaderSize 
  //are initialized by InitPPM, which is called by ppmSend::ppmSend()
  //m_pH261Headers = new FreeList(ReadNumFragBufs(), ReadProfileHeaderSize());
	//Note: We do not use ReadProfileHeaderSize for this, since this header structure
   //      contains padding so it can be in a FreeList; here we use the real padded size
   HRESULT hr;
   m_pH261Headers = new FreeList(FREELIST_INIT_COUNT_SND,
								 sizeof(H261_Header),
								 FREELIST_HIGH_WATER_MARK,
								 FREELIST_INCREMENT,
								 &hr); // Not really used here
  
  if (!m_pH261Headers) {
	  DBG_MSG(DBG_ERROR, ("H261_ppmSend::H261_ppmSend: ERROR - m_pH261Headers == NULL"));
  }

}

H261_ppmSend::~H261_ppmSend()
{
   if (m_pH261Headers) delete m_pH261Headers;

}


IMPLEMENT_CREATEPROC(H261_ppmSend);

#ifdef FILEPRINT
#include <stdio.h>
#endif
static void dumpEBS(BSINFO_TRAILER *pTrailer) {
#ifdef FILEPRINT
	BITSTREAM_INFO_H261 *pBSinfo;
	FILE *stream;

	stream = fopen("h261snd.txt", "a");

	fprintf(stream,"H261_ppmSend::dumpEBS - Trailer has:\n\tVersion %lu\n\tFlags %lu\n\tUniqueCode %lu\n\tCompressed Size %lu\n\tPackets %lu\n\tSrc Format %u\n\tTR %u\n\tTRB %u\n\tDBQ %u\n",
		pTrailer->dwVersion,pTrailer->dwFlags,pTrailer->dwUniqueCode,pTrailer->dwCompressedSize,
		pTrailer->dwNumberOfPackets,pTrailer->SourceFormat,pTrailer->TR,
		pTrailer->TRB,pTrailer->DBQ);

	pBSinfo = (BITSTREAM_INFO_H261 *) ((BYTE *)pTrailer - (sizeof(BITSTREAM_INFO_H261) *
		pTrailer->dwNumberOfPackets));

	for (int i = 0; i < (long) pTrailer->dwNumberOfPackets; i++) {
		fprintf(stream,"\nH261_ppmSend::dumpEBS - BSinfo struct %d has:\n\tFlags %lu\n\tbitoffset %lu\n\tMBAP %u\n\tQuant %u\n\tGOBN %u\n\tHMV %c\n\tVMV %c\n",
			i,pBSinfo[i].dwFlags,pBSinfo[i].dwBitOffset,pBSinfo[i].MBAP,pBSinfo[i].Quant,pBSinfo[i].GOBN,
			pBSinfo[i].HMV,pBSinfo[i].VMV);
	}

	fclose(stream);
#else
	char debug_string[256];
	BITSTREAM_INFO_H261 *pBSinfo;

	wsprintf(debug_string,"H261_ppmSend::dumpEBS - Trailer has:\n\tVersion %lu\n\tFlags %lu\n\tUniqueCode %lu\n\tCompressed Size %lu\n\tPackets %lu\n\tSrc Format %u\n\tTR %u\n\tTRB %u\n\tDBQ %u\n",
		pTrailer->dwVersion,pTrailer->dwFlags,pTrailer->dwUniqueCode,pTrailer->dwCompressedSize,
		pTrailer->dwNumberOfPackets,pTrailer->SourceFormat,pTrailer->TR,
		pTrailer->TRB,pTrailer->DBQ);
	OutputDebugString(debug_string);

	pBSinfo = (BITSTREAM_INFO_H261 *) ((BYTE *)pTrailer - (sizeof(BITSTREAM_INFO_H261) *
		pTrailer->dwNumberOfPackets));

	for (int i = 0; i < (long) pTrailer->dwNumberOfPackets; i++) {
		wsprintf(debug_string,"\nH261_ppmSend::dumpEBS - BSinfo struct %d has:\n\tFlags %lu\n\tbitoffset %lu\n\tMBAP %u\n\tQuant %u\n\tGOBN %u\n\tHMV %c\n\tVMV %c\n",
			i,pBSinfo[i].dwFlags,pBSinfo[i].dwBitOffset,pBSinfo[i].MBAP,pBSinfo[i].Quant,pBSinfo[i].GOBN,
			pBSinfo[i].HMV,pBSinfo[i].VMV);
		OutputDebugString(debug_string);
	}
#endif

	return;
}

//////////////////////////////////////
//Internal H261Send PPMSend Function Overrides

/////////////////////////////////////////////////////////////////////////////////////////
//InitFragStatus: This function initializes values needed to fragment a message.
//				  It locates the H261 extended bitstream header information at the
//			 	  end of the extended bitstream and validates the header.
//                It sets up the global m_pCurrentBuffer and the size of the frame data.
//                It also sets the NumFrags field of the Msg Descriptor
//                passed in.  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT H261_ppmSend::InitFragStatus(MsgDescriptor *pMsgDescrip)
{  

//lsc Need to get and use packet boundaries from the bitstream
//		1) Set buffer
//		2) Set fields of a BSINFO_TRAILER to point to the last 3 dwords of the
//		   extended bitstream (where m_Size currently indicates)
//		3) Check the unique code stored in the header
//		4) Set m_NumFrags
//		5) Reset m_Size to the size of the compressed bitstream only (this will
//		   also double as the location of the extended bitstream)

   //set global variable
   m_pCurrentBuffer = pMsgDescrip;
   
   //get the bitstream info header at the end of the extended bitstream
   m_pBSINFO_TRAILER = (BSINFO_TRAILER *) ((BYTE *)m_pCurrentBuffer->m_pBuffer + m_pCurrentBuffer->m_Size
   			- sizeof(BSINFO_TRAILER));
   			
   //Check the validity of the bitstream info header
   if (m_pBSINFO_TRAILER->dwUniqueCode != H261_CODE) {
	   DBG_MSG(DBG_ERROR, ("H261_ppmSend::InitFragStatus: ERROR - m_pBSINFO_TRAILER->dwUniqueCode != H261_CODE"));
	   return PPMERR(PPM_E_FAIL);
   }

   if (m_pBSINFO_TRAILER->dwVersion != H261_VERSION) {
	   DBG_MSG(DBG_ERROR, ("H261_ppmSend::InitFragStatus: ERROR - m_pBSINFO_TRAILER->dwVersion != H261_VERSION"));
	   return PPMERR(PPM_E_FAIL);
   }

#ifdef _DEBUG
//dumpEBS(m_pBSINFO_TRAILER);
#endif


   //May want this check too - 2 different ways to get the start of extended bitstream
   //assert (((BYTE *)m_pCurrentBuffer->m_pBuffer + m_pBSINFO_TRAILER->dwCompressedSize) ==
   //	  ((BYTE *)m_pCurrentBuffer->m_pBuffer + (m_pCurrentBuffer->m_Size - (
   //	  m_pBSINFO_TRAILER->dwNumberOfPackets * sizeof(BITSTREAM_INFO_H261)) - sizeof(BSINFO_TRAILER))));           

   //determine size of packets for this frame - for H261 it varies by packet, so
   //we set this to NULL
   m_CurrentFragSize = NULL;

   m_pCurrentBuffer->m_NumFrags = m_pBSINFO_TRAILER->dwNumberOfPackets; //used to free buffer later.
   m_pCurrentBuffer->m_NumFragSubmits = 0; 		 //used during error detection

   //Reset m_Size to not include the extended bitstream; we don't need the size of the
   //composite buffer anymore, and this gives us a way to get the start of extended BS later
   m_pCurrentBuffer->m_Size = m_pBSINFO_TRAILER->dwCompressedSize;
   return NO_ERROR;
}

//////////////////////////////////////////////////////////////////////////////////////////
//AllocFrag: This function allocates the profile header portion of the frag descriptor,
//			 after using ppmSend::AllocFrag() to get the rest of the frag descriptor.
//////////////////////////////////////////////////////////////////////////////////////////
FragDescriptor * H261_ppmSend::AllocFrag()
{
   FragDescriptor *pFragDescrip;

   //get descriptor	using parent AllocFrag()
   pFragDescrip = ppmSend::AllocFrag();
   
   if (pFragDescrip == NULL)						       
   {
      return NULL;
   }

   //get H261 header
   if (!(pFragDescrip->m_pProfileHeader = (void *) new (m_pH261Headers) H261_Header)) 
   {
      FreeFragDescriptor(pFragDescrip);
      return NULL;
   }
   
   return pFragDescrip;
}

//////////////////////////////////////////////////////////////////////////////////////////
//FreeProfileHeader: Given a buffer as type void, frees up a profile header.  Does nothing
//					for the Generic case.  Intended for overrides for various payloads.
//					No return value.
//////////////////////////////////////////////////////////////////////////////////////////
void H261_ppmSend::FreeProfileHeader(void *pBuffer)
{

	m_pH261Headers->Free( pBuffer );
	return;
}

/////////////////////////////////////////////////////////////////////////////////////////
//MakeFrag: This function sets the Data field of the frag descriptor to point to somewhere
//          in the message buffer.  i.e. we are using scatter/gather to fragment the 
//          message buffers. This means we send pointers to an offset in the message 
//          buffer down to the network layers, instead of copying the data out of the 
//          buffer, thus saving several memcopys.   This function also sets the RTP
//          header fields.  It sets the size of the packet, which will vary by packet
//          and whether the current packet is the last packet or not.
//			The H261 header fields are set.	The extended bitstream information is
//			accessed to get all of the correct data for the fields and the data size
//			and location for the current packet.  An offset is used to walk the structures
//			in the extended bitstream (one structure per packet).  This is incremented
//			for each packet.  If the current packet is the last one in the frame, the
//			offset is cleared and the current buffer is cleared.
////////////////////////////////////////////////////////////////////////////////////////
HRESULT H261_ppmSend::MakeFrag(FragDescriptor *pFragDescrip)
{
BITSTREAM_INFO_H261 *pBS_info;
BOOL lastFrag = FALSE;
long tmpOffset = 1, byteCount = 0, overlapCount = 0;

//lsc 
//Instead of m_CurrentOffset being used to point to the next frag start in
//  the buffer, it is the index of the next packet info structure in the extended bitstream
//	0) get the bitstream info structure for this fragment
//	1) point frag desc data pointer to right spot in buffer
//	2) fill in the RTP Header
//	3) fill in the H261 Header
//	4) set size, check for last packet and set marker bit, reset if end

   //Get the bitstream info structure for this fragment
   //pBS_info = &((BITSTREAM_INFO_H261 *)m_pCurrentBuffer->m_pBuffer +
   //		m_pCurrentBuffer->m_Size)[m_CurrentOffset];
   pBS_info = (BITSTREAM_INFO_H261 *) ((BYTE *) m_pBSINFO_TRAILER - 
	   ((m_pBSINFO_TRAILER->dwNumberOfPackets -	m_CurrentOffset) * 
	   sizeof(BITSTREAM_INFO_H261)));

   //point data field of frag descriptor to data in buffer.
   //Note, I assume that pBS_info->dwBitOffset is from the start of the frame
   pFragDescrip->m_pData = (void *)&((BYTE *)m_pCurrentBuffer->m_pBuffer)[
   		pBS_info->dwBitOffset/BITSPERBYTE];

   //fill in RTP Header
#ifdef RTP_CLASS
   pFragDescrip->m_pRTPHeader->set_pt(ReadPayloadType());
   pFragDescrip->m_pRTPHeader->set_x(0);
   pFragDescrip->m_pRTPHeader->set_p(0);
   pFragDescrip->m_pRTPHeader->set_seq(m_SequenceNum);
   pFragDescrip->m_pRTPHeader->set_ts(m_pCurrentBuffer->m_TimeStamp);
#else
   pFragDescrip->m_pRTPHeader->pt = ReadPayloadType();
   pFragDescrip->m_pRTPHeader->x = 0;
   pFragDescrip->m_pRTPHeader->p = 0;
   pFragDescrip->m_pRTPHeader->seq = htons(m_SequenceNum);
   pFragDescrip->m_pRTPHeader->ts = htonl(m_pCurrentBuffer->m_TimeStamp);
#endif

   if ( m_pBSINFO_TRAILER->dwCompressedSize <= (unsigned long) m_MaxDataSize ) {	 
		lastFrag = TRUE;
		EnterCriticalSection(&m_CritSec);
		m_pCurrentBuffer->m_NumFrags = 1;
		LeaveCriticalSection(&m_CritSec);
   } else {
		//Aggregate as many CODEC pBSinfo pieces as will fit in a packet
		while ((m_CurrentOffset+tmpOffset) < m_pBSINFO_TRAILER->dwNumberOfPackets) {
			byteCount = (long) (((BYTE *)m_pCurrentBuffer->m_pBuffer) + 
				((pBS_info+tmpOffset)->dwBitOffset)/BITSPERBYTE 
				- (BYTE*)pFragDescrip->m_pData);
			if ((pBS_info+tmpOffset)->dwBitOffset%BITSPERBYTE) 
				overlapCount = 1;
			else
				overlapCount = 0;
#ifdef _DEBUG
			unsigned long tmpval2 = byteCount + overlapCount;
#endif
			if ( (byteCount + overlapCount) <= m_MaxDataSize) {
#ifdef _DEBUG
				DBG_MSG(DBG_TRACE,  ("H261_ppmSend::MakeFrag: cur %d tmp %d bitoffset %d byteCount %d less than MTU %d, keep on going",
					m_CurrentOffset, tmpOffset, (pBS_info+tmpOffset)->dwBitOffset, tmpval2, m_MaxDataSize));
#endif
				tmpOffset++;
			} else {
#ifdef _DEBUG
				DBG_MSG(DBG_TRACE,  ("H261_ppmSend::MakeFrag: cur %d tmp %d bitoffset %d byteCount %d bigger than MTU %d, bail out",
					m_CurrentOffset, tmpOffset, (pBS_info+tmpOffset)->dwBitOffset, tmpval2, m_MaxDataSize));
#endif
				break;
			}
		}

		//Check to see if we are going to overrun the MTU, even with first fragment
		unsigned long tmpval = 0;
		if ((m_CurrentOffset+tmpOffset) >= m_pBSINFO_TRAILER->dwNumberOfPackets) {
			//I'm either here because I'm at the last fragment and everything fits
			//or I'm at the last fragment and it's too much
			tmpval = (unsigned long)
				((BYTE *)m_pCurrentBuffer->m_pBuffer + 
				 m_pCurrentBuffer->m_Size -
				 (BYTE *)pFragDescrip->m_pData);
			lastFrag = TRUE;
			if (tmpval > (unsigned long) m_MaxDataSize) {
                // rajeevb - if tmpOffset is 1, there is nothing we can do and
                // the check for tmpval > m_MaxDataSize below will discard the
                // entire frame
                if (tmpOffset > 1) {
                    tmpOffset--;
				    //redo the overlap count
				    if ((pBS_info+tmpOffset)->dwBitOffset%BITSPERBYTE) 
					    overlapCount = 1;
				    else
					    overlapCount = 0;

				    tmpval = (unsigned long)
						(((BYTE *)m_pCurrentBuffer->m_pBuffer) +
						 ((pBS_info+tmpOffset)->dwBitOffset)/BITSPERBYTE -
						 (BYTE*)pFragDescrip->m_pData + overlapCount);
				    lastFrag = FALSE;
                }
			}
		} else if (tmpOffset > 1) {
			tmpOffset--;
			//redo the overlap count
			if ((pBS_info+tmpOffset)->dwBitOffset%BITSPERBYTE) 
				overlapCount = 1;
			else
				overlapCount = 0;

			tmpval = (unsigned long)
				(((BYTE *)m_pCurrentBuffer->m_pBuffer) +
				 ((pBS_info+tmpOffset)->dwBitOffset)/BITSPERBYTE -
				 (BYTE*)pFragDescrip->m_pData + overlapCount);
		}

		if ( tmpval > 
			(unsigned long) m_MaxDataSize ) { //whoa, the frags are > MTU!
			DBG_MSG(DBG_ERROR,  ("H261_ppmSend::MakeFrag: ERROR - Fragment size %d too large to be sent for MTU %d",
				tmpval, m_MaxDataSize));
             // Make a callback into the app to let it know what happened.
             ppm::PPMNotification(PPM_E_DROPFRAME, SEVERITY_NORMAL, NULL, 0);
			return PPMERR(PPM_E_DROPFRAME);
		}

		if (tmpOffset > 0) {
			EnterCriticalSection(&m_CritSec);
			m_pCurrentBuffer->m_NumFrags -= (tmpOffset-1);
			LeaveCriticalSection(&m_CritSec);
		}
   }

#ifdef _DEBUG
	DBG_MSG(DBG_TRACE,  ("H261PPMSend::MakeFrag Thread %ld - numfrags is %d \n",
		GetCurrentThreadId(),	m_pCurrentBuffer->m_NumFrags));
#endif

   //fill in H261 Header
   ((H261_Header *)pFragDescrip->m_pProfileHeader)->set_sbit(pBS_info->dwBitOffset%BITSPERBYTE);
   //always assume there may or may not be INTRA-frame coded blocks
   ((H261_Header *)pFragDescrip->m_pProfileHeader)->set_i(0);
   //assume there could be motion vectors used
   ((H261_Header *)pFragDescrip->m_pProfileHeader)->set_v(1);
//lsc - Need to check these values and whether they fit in the fields
//lsc - Need to see if these would be different if the whole frame fits into the packet
   ((H261_Header *)pFragDescrip->m_pProfileHeader)->set_gobn(pBS_info->GOBN);
   ((H261_Header *)pFragDescrip->m_pProfileHeader)->set_mbap(pBS_info->MBAP);
   ((H261_Header *)pFragDescrip->m_pProfileHeader)->set_quant(pBS_info->Quant);
   ((H261_Header *)pFragDescrip->m_pProfileHeader)->set_hmvd(pBS_info->HMV);
   ((H261_Header *)pFragDescrip->m_pProfileHeader)->set_vmvd(pBS_info->VMV);


   m_SequenceNum++;         

   //if this is NOT the last packet.
   if (!lastFrag)
   {
	   
		//to get the EBIT, we look at the bitstream info structure for the next packet in line
		//and check out that dwBitOffset
		((H261_Header *)pFragDescrip->m_pProfileHeader)->set_ebit(BITSPERBYTE - 
   			(((BITSTREAM_INFO_H261 *)pBS_info+tmpOffset)->dwBitOffset%BITSPERBYTE));
		//set size field
		pFragDescrip->m_BytesOfData = (long)
			(((BYTE *)m_pCurrentBuffer->m_pBuffer) +
			 ((pBS_info+tmpOffset)->dwBitOffset)/BITSPERBYTE -
			 (BYTE*)pFragDescrip->m_pData);
		if ((pBS_info+tmpOffset)->dwBitOffset%BITSPERBYTE) 
			pFragDescrip->m_BytesOfData++;

      //set new offset, set marker bit.
#ifdef RTP_CLASS
	  pFragDescrip->m_pRTPHeader->set_m(SetMarkerBit(FALSE));
#else
	  pFragDescrip->m_pRTPHeader->m = SetMarkerBit(FALSE);
#endif
      m_CurrentOffset+=tmpOffset;
   }
   else  //if this IS the last packet.
   {
		((H261_Header *)pFragDescrip->m_pProfileHeader)->set_ebit(0);

       //set size field
		pFragDescrip->m_BytesOfData = (long)
			(((BYTE *)m_pCurrentBuffer->m_pBuffer + 
			  m_pCurrentBuffer->m_Size) -
			 (BYTE *)pFragDescrip->m_pData);

	  //set new offset, set marker bit.
      m_CurrentOffset = 0;
#ifdef RTP_CLASS
	  pFragDescrip->m_pRTPHeader->set_m(SetMarkerBit(TRUE));
#else
	  pFragDescrip->m_pRTPHeader->m = SetMarkerBit(TRUE);
#endif
      
      //reset Current Buffer.
      m_pCurrentBuffer = NULL;
   }  

   return NOERROR;
}

//////////////////////////////////////////////////////////////////////////////////////////
//ReadProfileHeader: Given a buffer as type void, returns the data for a profile header.  
//					Does nothing for the Generic case.  Intended for overrides for various 
//					payloads.
//////////////////////////////////////////////////////////////////////////////////////////
void *H261_ppmSend::ReadProfileHeader(void *pProfileHeader)
{
	return (void *) &((H261_Header *)pProfileHeader)->byte0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\h263.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: h263.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////

// Note: Payload header data generated by PPM are in network order

#ifndef H263_H
#define H263_H

#include <mmsystem.h>

#define H263_PT   34    //assigned RTP payload number for H.263

// These are used in T_BSINFO_HEADER.dwUniqueCode
#define	H263_CODE		mmioFOURCC('H','2','6','3')
#define H263_VERSION	0

// Per Extended Bitstream document
#define RTP_H26X_PACKET_LOST	0x00000001
#define RTP_H26X_INTRA_CODED	0x00000001

// Per Extended Bitstream document - for H.263 only
#define RTP_H263_PB_FRAME		0x00000002
#define RTP_H263_AP				0x00000004
#define RTP_H263_SAC			0x00000008
#define RTP_H263_MODE_A			0x00000010

#define BITSPERBYTE	8

// The H263 standard payload headers
class H263_Header {
public:

	unsigned char byte0, byte1, byte2, byte3;
    unsigned char h1;
    unsigned char v1;
    unsigned char h2;
    unsigned char v2;
	unsigned char byte8,byte9;
	unsigned char byte10,byte11;

		H263_Header () : byte0(0),byte1(0),byte2(0),byte3(0),
			h1(0),v1(0),h2(0),v2(0),byte8(0),byte9(0),byte10(0),byte11(0) {}

		virtual int header_size() const = 0;
 		virtual void *header_data() const = 0;

        virtual int f() const = 0;
        virtual void set_f(int f) = 0;
        
        virtual int p() const = 0;
        virtual void set_p(int p) = 0;
        
        virtual int sbit() const = 0;
        virtual void set_sbit(int sbit) = 0;
        
        virtual int ebit() const = 0;
        virtual void set_ebit(int ebit) = 0;
        
        virtual unsigned char src() const = 0;
        virtual void set_src(int src) = 0;
        
        virtual int r() const = 0;
        virtual void set_r(int r) = 0;
        
        virtual int i() const = 0;
        virtual void set_i(int i) = 0;
        
        virtual int a() const = 0;
        virtual void set_a(int a) = 0;
        
        virtual int s() const = 0;
        virtual void set_s(int s) = 0;
        
        virtual unsigned char dbq() const = 0;
        virtual void set_dbq(int dbq) = 0;
        
        virtual unsigned char trb() const = 0;
        virtual void set_trb(int trb) = 0;
        
        virtual unsigned char tr() const = 0;
        virtual void set_tr(int tr) = 0;
                
        virtual unsigned char quant() const = 0;
        virtual void set_quant(int quant) = 0;
        
        virtual unsigned char gobn() const = 0;
        virtual void set_gobn(int gobn) = 0;
        
        virtual unsigned char mba() const = 0;
        virtual void set_mba(int mba) = 0;
                
        virtual char  hmv1() const = 0;
        virtual void set_hmv1(int h1) = 0;
                
        virtual char vmv1() const = 0;
        virtual void set_vmv1(int v1) = 0;
                
        virtual char hmv2() const = 0;
        virtual void set_hmv2(int h2) = 0;
                
        virtual char vmv2() const = 0;
        virtual void set_vmv2(int v2) = 0;

};

class H263_HeaderA : public H263_Header {

public:

	H263_HeaderA () {}

		H263_HeaderA (char *pBuffer) { 
			byte0 = *((unsigned char *) pBuffer);
			byte1 = *((unsigned char *) pBuffer +1);
			byte2 = *((unsigned char *) pBuffer +2);
			byte3 = *((unsigned char *) pBuffer +3);
		}

		virtual int header_size() const { return 4; }
		virtual void *header_data() const { return (void *) &byte0; }

        virtual int f() const { return (byte0 >> 7) & 1; }
        virtual void set_f(int f) { byte0 = (byte0 & 0x7f) | ((f & 1) << 7); }
        
        virtual int p() const { return (byte0 >> 6) & 1; }
        virtual void set_p(int p) { byte0 = (byte0 & 0xbf) | ((p & 1) << 6); }
        
        virtual int sbit() const { return (byte0 >> 3) & 7; }
        virtual void set_sbit(int sbit) { byte0 = (byte0 & 0xc7) | ((sbit & 7) << 3); }
        
        virtual int ebit() const { return (byte0 & 7); }
        virtual void set_ebit(int ebit) { byte0 = (byte0 & 0xf8) | (ebit & 7); }
        
        virtual unsigned char src() const { return (byte1 >> 5) & 7; }
        virtual void set_src(int src) { byte1 = (byte1 & 0x1f) | ((src & 7) << 5); }
        
        virtual int r() const { return (byte1 & 0x1f); }
        virtual void set_r(int r) { byte1 = (byte1 & 0xe0) | (r & 0x1f); }
        
        virtual int i() const { return (byte2 >> 7) & 1; }
        virtual void set_i(int i) { byte2 = (byte2 & 0x7f) | ((i & 1) << 7); }
        
        virtual int a() const { return (byte2 >> 6) & 1; }
        virtual void set_a(int a) { byte2 = (byte2 & 0xbf) | ((a & 1) << 6); }
        
        virtual int s() const { return (byte2 >> 5) & 1; }
        virtual void set_s(int s) { byte2 = (byte2 & 0xdf) | ((s & 1) << 5); }
        
        virtual unsigned char dbq() const { return (byte2 >> 3) & 3; }
        virtual void set_dbq(int dbq) { byte2 = (byte2 & 0xe7) | ((dbq & 3) << 3); }
        
        virtual unsigned char trb() const { return (byte2 & 7); }
        virtual void set_trb(int trb) { byte2 = (byte2 & 0xf8) | (trb & 7); }
        
        virtual unsigned char tr() const { return byte3; }
        virtual void set_tr(int tr) { byte3 = (BYTE)tr; }

        virtual unsigned char quant() const {return 0;}
        virtual void set_quant(int quant){}
        
        virtual unsigned char gobn() const {return 0;}
        virtual void set_gobn(int gobn){}
        
        virtual unsigned char mba() const {return 0;}
        virtual void set_mba(int mba){}
                
        virtual char hmv1() const {return 0;}
        virtual void set_hmv1(int h1){}
                
        virtual char vmv1() const {return 0;}
        virtual void set_vmv1(int v1){}
                
        virtual char hmv2() const {return 0;}
        virtual void set_hmv2(int h2){}
                
        virtual char vmv2() const {return 0;}
        virtual void set_vmv2(int v2){}

};

class H263_HeaderB : public H263_Header {

public:
		H263_HeaderB () {}

		H263_HeaderB (char *pBuffer) { 
			byte0 = *((unsigned char *) pBuffer);
			byte1 = *((unsigned char *) pBuffer +1);
			byte2 = *((unsigned char *) pBuffer +2);
			byte3 = *((unsigned char *) pBuffer +3);
			h1 = *(((unsigned char*)pBuffer)+4); 
			v1 = *(((unsigned char*)pBuffer)+5); 
			h2 = *(((unsigned char*)pBuffer)+6); 
			v2 = *(((unsigned char*)pBuffer)+7); 
		}

		virtual int header_size() const { return 8; }
 		virtual void *header_data() const { return (void *) &byte0; }

        virtual int f() const { return (byte0 >> 7) & 1; }
        virtual void set_f(int f) { byte0 = (byte0 & 0x7f) | ((f & 1) << 7); }
        
        virtual int p() const { return (byte0 >> 6) & 1; }
        virtual void set_p(int p) { byte0 = (byte0 & 0xbf) | ((p & 1) << 6); }
        
        virtual int sbit() const { return (byte0 >> 3) & 7; }
        virtual void set_sbit(int sbit) { byte0 = (byte0 & 0xc7) | ((sbit & 7) << 3); }
        
        virtual int ebit() const { return (byte0 & 7); }
        virtual void set_ebit(int ebit) { byte0 = (byte0 & 0xf8) | (ebit & 7); }
        
        virtual unsigned char src() const { return (byte1 >> 5) & 7; }
        virtual void set_src(int src) { byte1 = (byte1 & 0x1f) | ((src & 7) << 5); }
        
        virtual unsigned char quant() const { return (byte1 & 0x1f); }
        virtual void set_quant(int quant) { byte1 = (byte1 & 0xe0) | (quant & 0x1f); }
        
        virtual int i() const { return (byte2 >> 7) & 1; }
        virtual void set_i(int i) { byte2 = (byte2 & 0x7f) | ((i & 1) << 7); }
        
        virtual int a() const { return (byte2 >> 6) & 1; }
        virtual void set_a(int a) { byte2 = (byte2 & 0xbf) | ((a & 1) << 6); }
        
        virtual int s() const { return (byte2 >> 5) & 1; }
        virtual void set_s(int s) { byte2 = (byte2 & 0xdf) | ((s & 1) << 5); }
        
        virtual unsigned char gobn() const { return (byte2 & 0x1f); }
        virtual void set_gobn(int gobn) { byte2 = (byte2 & 0xe0) | (gobn & 0x1f); }
        
        virtual unsigned char mba() const { return byte3; }
        virtual void set_mba(int mba) { byte3 = (unsigned char)mba; }
                
        virtual char hmv1() const { return h1; }
        virtual void set_hmv1(int h) { h1 = (unsigned char)h; }
                
        virtual char vmv1() const { return v1; }
        virtual void set_vmv1(int v) { v1 = (unsigned char)v; }
                
        virtual char hmv2() const { return h2; }
        virtual void set_hmv2(int h) { h2 = (unsigned char)h; }
                
        virtual char vmv2() const { return v2; }
        virtual void set_vmv2(int v) { v2 = (unsigned char)v; }

        virtual int r() const { return 0; }
        virtual void set_r(int r) {}
        
        virtual unsigned char dbq() const { return 0; }
        virtual void set_dbq(int dbq) {}

        virtual unsigned char trb() const { return 0; }
        virtual void set_trb(int trb) {}

        virtual unsigned char tr() const { return 0; }
        virtual void set_tr(int tr) {}
                
};

class H263_HeaderC : public H263_Header {

public:

		H263_HeaderC () {}

		H263_HeaderC (char *pBuffer) { 
			byte0 = *((unsigned char *) pBuffer);
			byte1 = *((unsigned char *) pBuffer +1);
			byte2 = *((unsigned char *) pBuffer +2);
			byte3 = *((unsigned char *) pBuffer +3);
			h1 = *(((unsigned char*)pBuffer)+4); 
			v1 = *(((unsigned char*)pBuffer)+5); 
			h2 = *(((unsigned char*)pBuffer)+6); 
			v2 = *(((unsigned char*)pBuffer)+7);
			byte8 = *((unsigned char *) pBuffer +8);
			byte9 = *((unsigned char *) pBuffer +9);
		}

		virtual int header_size() const { return 12; }
		virtual void *header_data() const { return (void *) &byte0; }

        virtual int f() const { return (byte0 >> 7) & 1; }
        virtual void set_f(int f) { byte0 = (byte0 & 0x7f) | ((f & 1) << 7); }
        
        virtual int p() const { return (byte0 >> 6) & 1; }
        virtual void set_p(int p) { byte0 = (byte0 & 0xbf) | ((p & 1) << 6); }
        
        virtual int sbit() const { return (byte0 >> 3) & 7; }
        virtual void set_sbit(int sbit) { byte0 = (byte0 & 0xc7) | ((sbit & 7) << 3); }
        
        virtual int ebit() const { return (byte0 & 7); }
        virtual void set_ebit(int ebit) { byte0 = (byte0 & 0xf8) | (ebit & 7); }
        
        virtual unsigned char src() const { return (byte1 >> 5) & 7; }
        virtual void set_src(int src) { byte1 = (byte1 & 0x1f) | ((src & 7) << 5); }
        
        virtual unsigned char quant() const { return (byte1 & 0x1f); }
        virtual void set_quant(int quant) { byte1 = (byte1 & 0xe0) | (quant & 0x1f); }
        
        virtual int i() const { return (byte2 >> 7) & 1; }
        virtual void set_i(int i) { byte2 = (byte2 & 0x7f) | ((i & 1) << 7); }
        
        virtual int a() const { return (byte2 >> 6) & 1; }
        virtual void set_a(int a) { byte2 = (byte2 & 0xbf) | ((a & 1) << 6); }
        
        virtual int s() const { return (byte2 >> 5) & 1; }
        virtual void set_s(int s) { byte2 = (byte2 & 0xdf) | ((s & 1) << 5); }
        
        virtual unsigned char gobn() const { return (byte2 & 0x1f); }
        virtual void set_gobn(int gobn) { byte2 = (byte2 & 0xe0) | (gobn & 0x1f); }
        
        virtual unsigned char mba() const { return (byte3); }
        virtual void set_mba(int mba) { byte3 = (unsigned char ) mba; }
                
        virtual char hmv1() const { return h1; }
        virtual void set_hmv1(int h) { h1 = (unsigned char ) h; }
                
        virtual char vmv1() const { return v1; }
        virtual void set_vmv1(int v) { v1 = (unsigned char ) v; }
                
        virtual char hmv2() const { return h2; }
        virtual void set_hmv2(int h) { h2 = (unsigned char ) h; }
                
        virtual char vmv2() const { return v2; }
        virtual void set_vmv2(int v) { v2 = (unsigned char ) v; }
                               
        virtual unsigned char tr() const { return byte8; }
        virtual void set_tr(int tr) { byte8 = (unsigned char ) tr; }
        
        virtual unsigned char dbq() const { return (byte9 >> 6) & 3; }
        virtual void set_dbq(int dbq) { byte9 = (byte9 & 0x3f) | ((dbq & 3) << 6); }
        
        virtual unsigned char trb() const { return (byte9 >> 3) & 7; }
        virtual void set_trb(int trb) { byte9 = (byte9 & 0xc7) | ((trb & 7) << 3); }
        
        virtual int r() const { return (byte10 & 0x7); }
        virtual void set_r(int r) { byte10 = (byte10 & 0xf8) | (r & 0x7); }
                
};


// The extended H263 bitstream is composed of an array of structures
// of these
typedef struct _BITSTREAM_INFO_H263 {
	unsigned long	dwFlags;
	unsigned long	dwBitOffset;
	unsigned char	MBA;
	unsigned char	Quant;
	unsigned char	GOBN;
	char			HMV1;
	char			VMV1;
	char			HMV2;
	char			VMV2;
	char			padding;
} BITSTREAM_INFO_H263;

#ifndef _BSINFO_TRAILER_DEFINED
#define _BSINFO_TRAILER_DEFINED
// This is used to locate bitstream info before accessing the extended
// bitstream
typedef struct _T_BSINFO_TRAILER {
	unsigned long	dwVersion;
	unsigned long	dwFlags;
	unsigned long	dwUniqueCode;
	unsigned long	dwCompressedSize;
	unsigned long	dwNumberOfPackets;
	unsigned char	SourceFormat;
	unsigned char	TR;
	unsigned char	TRB;
	unsigned char	DBQ;
} BSINFO_TRAILER;

#endif /* _BSINFO_TRAILER_DEFINED */


#endif /* H263_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\h263rcv.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: h263rcv.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////

// $Header:   J:\rtp\src\ppm\h263rcv.h_v   1.12   04 Mar 1997 19:54:54   lscline  $

#ifndef H263RCV_H
#define H263RCV_H

#include "ppmrcv.h"
#include "ppmclsid.h"
#include "h263.h"
#include "freelist.h"

//lsc - need to adjust size?
#define H263_BUFFER_SIZE 20000

class H263_ppmReceive : public ppmReceive
{

unsigned char	m_lastMBAP;
unsigned char	m_lastQuant;
unsigned char	m_lastGOBN; 
char			m_lastVMV;
char			m_lastHMV;
BOOL			m_GlobalLastMarkerBitIn;

#ifdef REBUILD_EXBITSTREAM
BOOL            m_ExtendedBitstream;
HRESULT			BuildExtendedBitstream(MsgHeader* const pMsgHdr);
#endif

FreeList        *m_pH263Headers;

public:

H263_ppmReceive(IUnknown* pUnkOuter, IUnknown** ppUnkInner);
~H263_ppmReceive();

DECLARE_CREATEPROC()

STDMETHODIMP_( const CLSID& ) GetCLSID( void ) const {return CLSID_H263PPMReceive;}

STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{return CUnknown::QueryInterface(riid, ppvObj);}

STDMETHODIMP GetInterface( REFIID riid, LPVOID FAR* ppvObj )
{return ppmReceive::GetInterface( riid, ppvObj );}

STDMETHODIMP_( ULONG )AddRef( void )
{return CUnknown::AddRef();}

STDMETHODIMP_( ULONG )Release( void )
{return CUnknown::Release();}

//////////////////////////////////////////////////////////////////////////////
//ppmReceive Functions (Overrides)
//////////////////////////////////////////////////////////////////////////////

#ifdef REBUILD_EXBITSTREAM
//////////////////////////////////////////////////////////////////////////////////////////
//SetSession: Argument type is actually H26XPPMSESSPARAM_T
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHOD(SetSession)(THIS_ PPMSESSPARAM_T *pSessparam);

//////////////////////////////////////////////////////////////////////////////
//   IPPMReceiveSession Functions (Overrides)
STDMETHOD(GetResiliency)(THIS_ LPBOOL			lpbResiliency);
STDMETHOD(SetResiliency)(THIS_ BOOL			pbResiliency);
#else
//Default to ppmReceive::SetSession() and ppmReceive::<IPPMReceiveSession> fns
#endif

//////////////////////////////////////////////////////////////////////////////////////////
//TimeToProcessMessages:
//////////////////////////////////////////////////////////////////////////////////////////
virtual BOOL TimeToProcessMessages(FragDescriptor *pFragDescrip, MsgHeader *pMsgHdr);
 
//////////////////////////////////////////////////////////////////////////////////////////
//CheckMessageComplete: 
//////////////////////////////////////////////////////////////////////////////////////////
virtual BOOL CheckMessageComplete(MsgHeader *pMsgHdr); 

//////////////////////////////////////////////////////////////////////////////////////////
//PrepMessage: Sets H263 global variables, calls base PrepMessage
//////////////////////////////////////////////////////////////////////////////////////////
virtual HRESULT PrepMessage(BOOL); 

//////////////////////////////////////////////////////////////////////////////////////////
//DataCopy: Copies data fragments into client's buffer 
//////////////////////////////////////////////////////////////////////////////////////////
virtual HRESULT DataCopy(MsgHeader * const pMsgHdr);    

//////////////////////////////////////////////////////////////////////////////////////////
//PartialMessageHandler: deals with partial messages
//////////////////////////////////////////////////////////////////////////////////////////
virtual HRESULT PartialMessageHandler(MsgHeader *pMsgHdr);
//////////////////////////////////////////////////////////////////////////////////////////

//InitProfileHeader: Given a buffer as type void, sets up a profile header.  
//////////////////////////////////////////////////////////////////////////////////////////
virtual void *InitProfileHeader(void *pBuffer);

//////////////////////////////////////////////////////////////////////////////////////////
//FreeProfileHeader: Given a buffer as type void, frees up a profile header.  
//////////////////////////////////////////////////////////////////////////////////////////
virtual void FreeProfileHeader(void *pBuffer);

////////////////////////////////////////////////////////////////////////////////////
// PPM Functions (Overrides)
////////////////////////////////////////////////////////////////////////////////////
virtual int ReadProfileHeaderSize(void *pProfileHeader = NULL);


};  // Parameters to ppmReceive -> H263 Payload type, size of payload header, outer arg, inner arg

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\imcrcv.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: g723rcv.cpp
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#include "ppmerr.h"
#include "IMCrcv.h"

IMC_ppmReceive::IMC_ppmReceive(IUnknown* pUnkOuter, 
								 IUnknown** ppUnkInner)
	: ppmReceive(IMC_PT, IMC_BUFFER_SIZE, 0, pUnkOuter, ppUnkInner)
{
}

IMC_ppmReceive::~IMC_ppmReceive()
{
}

IMPLEMENT_CREATEPROC(IMC_ppmReceive);

//////////////////////////////////////////////////////////////////////////////////////////
//TimeToProcessMessages: Any time a packet comes in, it's time to process messages
//////////////////////////////////////////////////////////////////////////////////////////
BOOL IMC_ppmReceive::TimeToProcessMessages(FragDescriptor *pFragDescrip, MsgHeader *pMsgHdr)
{
   return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////////
//CheckMessageComplete: 
//////////////////////////////////////////////////////////////////////////////////////////
BOOL IMC_ppmReceive::CheckMessageComplete(MsgHeader *pMsgHdr) 
{
   //if there is no header then return false.
	if (pMsgHdr  == NULL) {
		DBG_MSG(DBG_ERROR, ("IMC_ppmReceive::CheckMessageComplete: ERROR - pMsgHdr == NULL"));
	   return FALSE;
   }

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\imc.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: g723.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#ifndef IMC_H
#define IMC_H

#define IMC_PT   -1    // An RTP payload type in the dynamic range must be selected
                        // at runtime until a fixed paylod type is assigned

#endif // IMC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\h263rcv.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation.
//
//
//  Module Name: h263rcv.cpp
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////

// $Header:   J:\rtp\src\ppm\h263rcv.cpv   1.36   29 May 1997 16:38:50   lscline  $

#include "ppmerr.h"
#include "h263rcv.h"
#include "freelist.h"
#include "ippmcb.h"
#include "h263pld.h"	// ContainsH263PSC()

#define H263_HDR_T	int		// for now

//////////////////////////////////////////////////////////////////////////////
// Private global data

#ifdef REBUILD_EXBITSTREAM

static const struct { DWORD dw; } s_leadFragBitPattern =
{
	MAKELONG(0, MAKEWORD(128, 3))	// 4 bytes {0,0,128,3}, big-endian
};

static const struct { char ch[4]; } s_nonLeadFragBitPattern = {0, 0, 0, 0};

#endif

H263_ppmReceive::H263_ppmReceive(IUnknown* pUnkOuter, IUnknown** ppUnkInner)
	: ppmReceive(H263_PT, H263_BUFFER_SIZE, sizeof(H263_Header), pUnkOuter, ppUnkInner)
{
	m_lastMBAP = 0;
	m_lastQuant = 0;
	m_lastGOBN = 0;
	m_lastVMV = 0;
	m_lastHMV = 0;
	m_GlobalLastMarkerBitIn = FALSE;

#ifdef REBUILD_EXBITSTREAM
	m_ExtendedBitstream = TRUE;
#endif

	// Allocate memory for the H263 headers
	HRESULT hr;
	m_pH263Headers = new FreeList(FREELIST_INIT_COUNT_RCV,
								  sizeof(H263_HeaderC),
								  FREELIST_HIGH_WATER_MARK,
								  FREELIST_INCREMENT,
								  &hr); // Not really used here

	if (! m_pH263Headers)
	{
		DBG_MSG(DBG_ERROR, ("H263_ppmReceive::H263_ppmReceive: ERROR - m_pH263Headers == NULL"));
	}

	// Verify assumption made in H263_ppmReceive::BuildExtendedBitstream() wrt
	// handling of underflow.
	DWORD dwBufSize = 0;
	int nLastEbit = 0;
	ASSERT(
		(((dwBufSize - 1) * BITSPERBYTE) +
			(BITSPERBYTE - nLastEbit)) ==
		(BITSPERBYTE * dwBufSize));
}

H263_ppmReceive::~H263_ppmReceive()
{
	if (m_pH263Headers) {
		delete m_pH263Headers;	// delete NULL ok
		m_pH263Headers = NULL;
	}
}

IMPLEMENT_CREATEPROC(H263_ppmReceive);

#ifdef FILEPRINT
#include <stdio.h>
#endif
static void dumpEBS(BSINFO_TRAILER* pTrailer) {
#ifdef FILEPRINT
	BITSTREAM_INFO_H263* pBSinfo;
	FILE* stream;

	stream = fopen("h263rcv.txt", "a");

	fprintf(stream,"H263_ppmReceive::dumpEBS - Trailer has:\n\tVersion %lu\n\tFlags %lu\n\tUniqueCode %lu\n\tCompressed Size %lu\n\tPackets %lu\n\tSrc Format %u\n\tTR %u\n\tTRB %u\n\tDBQ %u\n",
		pTrailer->dwVersion,pTrailer->dwFlags,pTrailer->dwUniqueCode,pTrailer->dwCompressedSize,
		pTrailer->dwNumberOfPackets,pTrailer->SourceFormat,pTrailer->TR,
		pTrailer->TRB,pTrailer->DBQ);

	pBSinfo = (BITSTREAM_INFO_H263*) pTrailer - pTrailer->dwNumberOfPackets;

	for (int i = 0; i < (long) pTrailer->dwNumberOfPackets; i++)
	{
		fprintf(stream,"\nH263_ppmReceive::dumpEBS - BSinfo struct %d has:\n\tFlags %lu\n\tbitoffset %lu\n\tMBA %u\n\tQuant %u\n\tGOBN %u\n\tHMV1 %c\n\tVMV1 %c\n\tHMV2 %c\n\tVMV2 %c\n",
			i,pBSinfo[i].dwFlags,pBSinfo[i].dwBitOffset,pBSinfo[i].MBA,pBSinfo[i].Quant,pBSinfo[i].GOBN,
			pBSinfo[i].HMV1,pBSinfo[i].VMV1,pBSinfo[i].HMV2,pBSinfo[i].VMV2);
	}

	fclose(stream);
#else
	BITSTREAM_INFO_H263 *pBSinfo;

	DBG_MSG(DBG_TRACE,("H263_ppmReceive::dumpEBS - Trailer has:\n\tVersion %lu\n\tFlags %lu\n\tUniqueCode %lu\n\tCompressed Size %lu\n\tPackets %lu\n\tSrc Format %u\n\tTR %u\n\tTRB %u\n\tDBQ %u\n",
		pTrailer->dwVersion,pTrailer->dwFlags,pTrailer->dwUniqueCode,pTrailer->dwCompressedSize,
		pTrailer->dwNumberOfPackets,pTrailer->SourceFormat,pTrailer->TR,
		pTrailer->TRB,pTrailer->DBQ));

	pBSinfo = (BITSTREAM_INFO_H263*) pTrailer - pTrailer->dwNumberOfPackets;

	for (int i = 0; i < (long) pTrailer->dwNumberOfPackets; i++)
	{
		DBG_MSG(DBG_TRACE,  ("\nH263_ppmReceive::dumpEBS - BSinfo struct %d has:\n\tFlags %lu\n\tbitoffset %lu\n\tMBA %u\n\tQuant %u\n\tGOBN %u\n\tHMV1 %c\n\tVMV1 %c\n\tHMV2 %c\n\tVMV2 %c\n",
			i,pBSinfo[i].dwFlags,pBSinfo[i].dwBitOffset,pBSinfo[i].MBA,pBSinfo[i].Quant,pBSinfo[i].GOBN,
			pBSinfo[i].HMV1,pBSinfo[i].VMV1,pBSinfo[i].HMV2,pBSinfo[i].VMV2));
	}
#endif

	return;
}

//////////////////////////////////////////////////////////////////////////////
// ppmReceive Functions (Overrides)
//////////////////////////////////////////////////////////////////////////////

#ifdef REBUILD_EXBITSTREAM
//////////////////////////////////////////////////////////////////////////////////////////
// SetSession:
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP H263_ppmReceive::SetSession(PPMSESSPARAM_T* pSessparam)
{
	// ccp - note unsafe downcast
	m_ExtendedBitstream = ((H26XPPMSESSPARAM_T*) pSessparam)->ExtendedBitstream;
	return ppmReceive::SetSession(pSessparam);
}

void
setH263BSInfoTrailer(BSINFO_TRAILER& bsTrailer, const FragDescriptor* pFragDesc)
{
	// Assign immutable reference to profile header of first packet
	H263_Header& rProfileHdr =
		*(H263_Header*) pFragDesc->m_pProfileHeader;

	if (rProfileHdr.p())
	{
		bsTrailer.dwFlags	= RTP_H263_PB_FRAME;
		bsTrailer.DBQ		= rProfileHdr.dbq();
		bsTrailer.TRB		= rProfileHdr.trb();
		bsTrailer.TR		= rProfileHdr.tr();
	}
	if (rProfileHdr.a())
		bsTrailer.dwFlags |= RTP_H263_AP;
	if (rProfileHdr.s())
		bsTrailer.dwFlags |= RTP_H263_SAC;
	if (rProfileHdr.i())
		bsTrailer.dwFlags |= RTP_H26X_INTRA_CODED;
	bsTrailer.SourceFormat	= rProfileHdr.src();

	bsTrailer.dwVersion		= H263_VERSION;
	bsTrailer.dwUniqueCode	= H263_CODE;
}
//////////////////////////////////////////////////////////////////////////////
// IPPMReceiveSession Functions (Overrides)
//////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////
//GetResiliency:  Gets the boolean for whether resiliency is on or off
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP H263_ppmReceive::GetResiliency(LPBOOL			lpbResiliency)
{
	if (!lpbResiliency) return E_POINTER;
	*lpbResiliency = m_ExtendedBitstream;
	return NOERROR;
}

////////////////////////////////////////////////////////////////////////////////////////
//SetResiliency:  Sets the boolean for whether resiliency is on or off
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP H263_ppmReceive::SetResiliency(BOOL			pbResiliency)
{
	m_ExtendedBitstream = pbResiliency;
	return NOERROR;
}
#endif

//////////////////////////////////////////////////////////////////////////////////////////
// TimeToProcessMessages:
//////////////////////////////////////////////////////////////////////////////////////////
BOOL H263_ppmReceive::TimeToProcessMessages(FragDescriptor* pFragDescrip, MsgHeader* pMsgHdr)
{
	return (pMsgHdr == m_pMsgHeadersHead);
}

//////////////////////////////////////////////////////////////////////////////////////////
// CheckMessageComplete:
//////////////////////////////////////////////////////////////////////////////////////////
BOOL H263_ppmReceive::CheckMessageComplete(MsgHeader* pMsgHdr)
{
	// if there is no header then return false.
	if (pMsgHdr == NULL)
	{
		DBG_MSG(DBG_ERROR, ("H263_ppmReceive::CheckMessageComplete: ERROR - pMsgHdr == NULL"));
		return FALSE;
	}

	// should there be a critical section in this function.

	// check to make sure we have the first packet in the message.
	if (pMsgHdr->m_pPrev == NULL) // if first message in list, then look at a variable
	{
		if (m_GlobalLastSeqNum != pMsgHdr->m_pFragList->FirstSeqNum()-1)
		{
			return FALSE;
		}
	}
	else
	{
		if (pMsgHdr->m_pPrev->m_pFragList->LastSeqNum() != pMsgHdr->m_pFragList->FirstSeqNum()-1)
		{
			return FALSE;
		}
	}

	// check to make sure we have the last packet in the message.
	// For IETF compliance, marker bit must be set, but in H.225, the marker bit
	// may optionally be omitted if setting it could cause additional end-to-end delay
	// Thus, we check for the marker bit, but if it is not present, we also check to
	// see if the next packet is in and has a different timestamp (ala generic).
	if (! pMsgHdr->m_MarkerBitIn)
	{
		if (pMsgHdr->m_pNext == NULL)	// if we don't have the next message,
		{								// we don't know if the current message
										// is done.
			return FALSE;
		}

		if (pMsgHdr->m_pNext->m_pFragList->FirstSeqNum() !=
			pMsgHdr->m_pFragList->LastSeqNum() + 1)
		{
			return FALSE;
		}
	}

	// Check for a packet missing in the middle->
	if ((int)pMsgHdr->m_pFragList->SeqNumSpan() != pMsgHdr->m_NumFragments)
	{
		return FALSE;
	}

	return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////////
// PrepMessage: Sets H263 global variables, calls base PrepMessage.  If any error
//             checks are added, you MUST make a call to LeaveCriticalSection.
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT H263_ppmReceive::PrepMessage(BOOL Complete)
{

	EnterCriticalSection(&m_CritSec);

	// Can't hurt to check although we should never get here if there is no head.
	if (m_pMsgHeadersHead == NULL)
	{
		DBG_MSG(DBG_ERROR, ("H263_ppmReceive::PrepMessage: ERROR - m_pMsgHeadersHead == NULL"));
		LeaveCriticalSection(&m_CritSec);
		return PPMERR(PPM_E_CORRUPTED);
	}

	// Save marker bit flag.
	BOOL bMarkerBitIn = m_pMsgHeadersHead->m_MarkerBitIn;

	LeaveCriticalSection(&m_CritSec);

	// Update the H263 global variables _after_ processing msg.
	HRESULT hErr = ppmReceive::PrepMessage(Complete);

	// Update the H263 global variable.
	m_GlobalLastMarkerBitIn = bMarkerBitIn;

	DBG_MSG(DBG_TRACE,
		("H263_ppmReceive::PrepMessage: m_GlobalLastMarkerBitIn=%d",
		m_GlobalLastMarkerBitIn));

	return hErr;
}

#ifndef DYN_ALLOC_EBS
	#define MAXFRAGS_PER_FRAME 396
#endif

// lsc - Note: we are not rebuilding the extended bitstream
//		for complete frames.
//		For now I am assuming that we only rebuild the extended bitstream for frames that
//		have not received all packets (handled by PartialMessageHandler), and for complete
//		frames we hand them up as usual.  However, this routine is overridden to handle the
//		data ORing for the byte overlap	between packets.
//////////////////////////////////////////////////////////////////////////////////////////
// DataCopy: Copies data fragments into client's buffer.  If any error checks with returns
//          are added they MUST call LeaveCriticalSection.
//
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT H263_ppmReceive::DataCopy(MsgHeader* const pMsgHdr)
{
#ifndef DYN_ALLOC_EBS
	static BITSTREAM_INFO_H263 pEBS[MAXFRAGS_PER_FRAME];
#endif

	if (pMsgHdr == NULL)
	{
		DBG_MSG(DBG_ERROR, ("H263_ppmReceive::DataCopy: ERROR - pMsgHdr == NULL"));
		return PPMERR(PPM_E_EMPTYQUE);
	}

#ifdef _DEBUG
#ifdef CHECKSUM
	unsigned char sum = '\0';
#endif
	int l = 0, m = 0;
#endif

	MsgDescriptor* pMsgDesc = DequeueBuffer(1);	// Get a buffer to hold the message.

	if (pMsgDesc == NULL)
	{
		FreeFragList(pMsgHdr);
		FreeMsgHeader(pMsgHdr);

		DBG_MSG(DBG_ERROR, ("H263_ppmReceive::DataCopy: ERROR - Couldn't get a reassembly buffer"));

		// Make a callback into the app to let it know what happened.
		ppm::PPMNotification(PPM_E_DROPFRAME, SEVERITY_NORMAL, NULL, 0);

		m_GlobalLastFrameDropped = TRUE;
		return PPMERR(PPM_E_DROPFRAME);
	}

	EnterCriticalSection(&m_CritSec);

#ifdef GIVE_SEQNUM
	// Do this before frag list exhausted below
	pMsgDesc->m_TimeStamp = pMsgHdr->m_pFragList->LastSeqNum();
#else
	pMsgDesc->m_TimeStamp = pMsgHdr->GetMsgID();
#endif

	if (! ContainsH263PSC(((FragDescriptor*) pMsgHdr->m_pFragList->GetFirst())->m_pData))
	{
		FreeFragList(pMsgHdr);
		EnqueueBuffer(pMsgDesc);
		FreeMsgHeader(pMsgHdr);

		LeaveCriticalSection(&m_CritSec);

		DBG_MSG(DBG_ERROR, ("H263_ppmReceive::DataCopy: ERROR - Couldn't find PSC"));

		// Make a callback into the app to let it know what happened.
		ppm::PPMNotification(PPM_E_DROPFRAME, SEVERITY_NORMAL, NULL, 0);
		m_GlobalLastFrameDropped = TRUE;

		return PPMERR(PPM_E_DROPFRAME);
	}

#ifdef REBUILD_EXBITSTREAM

#ifdef DYN_ALLOC_EBS
	BITSTREAM_INFO_H263* pEBS = NULL;
#else
#endif
	int nNumFrags = 0, nCurrentEBS = 0;

	// Get local copy of extended bitstream flag to protect against
	// possible change via H263_ppmReceive::SetSession() while building
	// this frame.  OK to change between frames.
	BOOL bExtendedBitstream = m_ExtendedBitstream;

	if (bExtendedBitstream)
	{
		nNumFrags = pMsgHdr->m_pFragList->SeqNumSpan();

		// allocate structures for the extended bitstream information
#ifdef DYN_ALLOC_EBS
		pEBS = new BITSTREAM_INFO_H263[nNumFrags];

		if (pEBS == NULL)
		{
			FreeFragList(pMsgHdr);
			EnqueueBuffer(pMsgDesc);
			FreeMsgHeader(pMsgHdr);

			LeaveCriticalSection(&m_CritSec);

			DBG_MSG(DBG_ERROR,
				("H263_ppmReceive::DataCopy: ERERROR - memory allocation failure"));

			// Make a callback into the app to let it know what happened.
			ppm::PPMNotification(PPM_E_OUTOFMEMORY, SEVERITY_NORMAL, NULL, 0);
			m_GlobalLastFrameDropped = TRUE;

			return PPMERR(PPM_E_DROPFRAME);
		}
#else
	if (nNumFrags > MAXFRAGS_PER_FRAME)
	{
		FreeFragList(pMsgHdr);
		EnqueueBuffer(pMsgDesc);
		FreeMsgHeader(pMsgHdr);

		LeaveCriticalSection(&m_CritSec);
		DBG_MSG(DBG_ERROR, ("H263_ppmReceive::DataCopy: ERROR - too many packets for EBS structure"));

		// Make a callback into the app to let it know what happened.
		ppm::PPMNotification(PPM_E_OUTOFMEMORY, SEVERITY_NORMAL, NULL, 0);
		m_GlobalLastFrameDropped = TRUE;
		return PPMERR(PPM_E_DROPFRAME);
	}
#endif
		memset(pEBS, 0, nNumFrags * sizeof(*pEBS));
	}

	BSINFO_TRAILER bsTrailer = {0};	// zero fill
	if (bExtendedBitstream)
	{
		// Complete some of the info for the trailer.  We can take this info
		// from any one packet, so let's use the first.
		setH263BSInfoTrailer(
			bsTrailer,
			(FragDescriptor*) pMsgHdr->m_pFragList->GetFirst());
	}
#endif /* REBUILD_EXBITSTREAM */

	// Loop state variables
	LPBYTE pbCurrentOffset = (LPBYTE) pMsgDesc->m_pBuffer;	// start copying into front of buffer.
	DWORD dwBufSize = 0;
	UCHAR chLastByte = 0;
	int nLastEbit = 0;	// prior packet's ebit, for error checking

#ifdef _DEBUG
	m = pMsgHdr->m_pFragList->SeqNumSpan();
#endif

	// There are three cases to check for overlapping bytes between
	// packets:
	//   1) There is overlap between packets, and this is first packet.
	//   2) There is overlap between packets, and this is not first packet.
	//   3) There is no overlap between packets.
	// We'll check case 1 now, before getting into packet loop.
			
	if (((H263_Header*)
			(((FragDescriptor*) pMsgHdr->m_pFragList->GetFirst())->m_pProfileHeader)
		)->sbit())
	{
		// First packet overlaps prior frame (case 1).  Add a byte to hold
		// first sbits.  No need to clear byte now, since it'll be overwritten
		// by chFirstByte below.
		pbCurrentOffset++;
		dwBufSize++;
	}

	// Process all rcvd packets
	while (! pMsgHdr->m_pFragList->Is_Empty())
	{
		// get next fragment (const to prevent unintentional modification)
		FragDescriptor* const pFragDesc = (FragDescriptor*)
			pMsgHdr->m_pFragList->TakeFromList();
		m_PacketsHold--;

		// check to see if TakeFromList() returned NULL or
		// check to make sure we won't overrun the buffer.
		BOOL bExit;

#ifdef REBUILD_EXBITSTREAM
		if (bExtendedBitstream && (pFragDesc != NULL))
		{
			bExit =
				((dwBufSize +
				 pFragDesc->m_BytesOfData +
				 (nNumFrags * sizeof(*pEBS)) +
				 sizeof(BSINFO_TRAILER) +
				 offsetNextDword(pbCurrentOffset))
					> pMsgDesc->m_Size);
		}
		else
#endif
		{
			bExit =
				((pFragDesc == NULL) ||
				 (dwBufSize + pFragDesc->m_BytesOfData >= pMsgDesc->m_Size));
		}
		if (bExit)
		{
			FreeFragList(pMsgHdr);
			EnqueueBuffer(pMsgDesc);
			FreeMsgHeader(pMsgHdr);

#ifdef REBUILD_EXBITSTREAM
			if (bExtendedBitstream)
			{
#ifdef DYN_ALLOC_EBS
				if (pEBS) {
					delete [] pEBS;
					pEBS = NULL;
				}
#endif
			}
#endif

			LeaveCriticalSection(&m_CritSec);

			DBG_MSG(DBG_ERROR, ("H263_ppmReceive::DataCopy: ERROR - null pFragDesc or buffer overrun"));

			if (pFragDesc != NULL)
			{
				// Release the CRTPSample to receive more data
				m_pSubmitCallback->SubmitComplete(pFragDesc->m_pFragCookie,
												  NOERROR);
				// Make a callback into the app to let it know what happened.
				ppm::PPMNotification(PPM_E_RECVSIZE, SEVERITY_NORMAL, NULL, 0);
				// BUGBUG We are here because
				// m_pFragList->Is_Empty() == FALSE
				// then the pFragDesc should always be != NULL
				if (pFragDesc->m_pProfileHeader)
					FreeProfileHeader(pFragDesc->m_pProfileHeader);
				FreeFragDescriptor(pFragDesc);
			}
			m_GlobalLastFrameDropped = TRUE;

			return PPMERR(PPM_E_DROPFRAME);
		}

#ifdef _DEBUG
#ifdef CHECKSUM
		for (int i = 0; i < pFragDesc->m_BytesOfData; i++)
		{
			sum += ((LPBYTE)pFragDesc->m_pData)[i];
		}
		DBG_MSG(DBG_TRACE, ("H263PPMReceive::DataCopy Thread %ld - processing fragment %d of %d, size %d, checksum %x\n",
			GetCurrentThreadId(), l++, m, pFragDesc->m_BytesOfData, sum));
		sum = '\0';
#else
		DBG_MSG(DBG_TRACE,
			("H263PPMReceive::DataCopy Thread %ld - processing fragment %d of %d, size %d\n",
			GetCurrentThreadId(),
			l++,
			m,
			pFragDesc->m_BytesOfData));
#endif
#endif

		// Assign immutable reference to profile header
		H263_Header& rProfileHdr = *(H263_Header*)
			pFragDesc->m_pProfileHeader;

#ifdef REBUILD_EXBITSTREAM
		if (bExtendedBitstream)
		{
			// write BS struct for current packet and save off values for next lost packet
			// (for the next partial frame)
			pEBS[nCurrentEBS].dwFlags = 0;
			if (rProfileHdr.sbit())
			{
				// Adjust EBS bit offset for this packet's sbits
				pEBS[nCurrentEBS].dwBitOffset =
					  ((dwBufSize - 1) * BITSPERBYTE)
					+ rProfileHdr.sbit();
			}
			else
			{
				pEBS[nCurrentEBS].dwBitOffset = dwBufSize * BITSPERBYTE;
			}
			pEBS[nCurrentEBS].MBA	= rProfileHdr.mba();
			pEBS[nCurrentEBS].Quant	= rProfileHdr.quant();
			pEBS[nCurrentEBS].GOBN	= rProfileHdr.gobn();
			pEBS[nCurrentEBS].HMV1	= rProfileHdr.hmv1();
			pEBS[nCurrentEBS].VMV1	= rProfileHdr.vmv1();
			pEBS[nCurrentEBS].HMV2	= rProfileHdr.hmv2();
			pEBS[nCurrentEBS].VMV2	= rProfileHdr.vmv2();
			if (! rProfileHdr.f())
				pEBS[nCurrentEBS].dwFlags |= RTP_H263_MODE_A;
			nCurrentEBS++;
		}
#endif /* REBUILD_EXBITSTREAM */

		if (rProfileHdr.sbit())
		{
			// This packet has missing sbits (case 1 or 2)

			// Mask off missing sbits and combine with ebits from prior packet.
			const UCHAR chFirstByte =
				(*(LPBYTE) pFragDesc->m_pData
					& GetSMask(rProfileHdr.sbit()))
				| chLastByte;

			// Either this is first packet (thus no ebits), or the prior
			// and current packets had better overlap properly.
			if ((nLastEbit != 0)
				&& ((nLastEbit + rProfileHdr.sbit()) != BITSPERBYTE))
			{
				FreeFragList(pMsgHdr);
				EnqueueBuffer(pMsgDesc);
				FreeMsgHeader(pMsgHdr);

#ifdef REBUILD_EXBITSTREAM
				if (bExtendedBitstream)
				{
#ifdef DYN_ALLOC_EBS
					if (pEBS) {
						delete [] pEBS;
						pEBS = NULL;
					}
#endif
				}
#endif

				LeaveCriticalSection(&m_CritSec);

				DBG_MSG(DBG_ERROR, ("H263_ppmReceive::DataCopy: ERROR - Received packets with sbit/ebit mismatch"));

				if (pFragDesc != NULL)
				{
					// Release the CRTPSample to receive more data
					m_pSubmitCallback->SubmitComplete(pFragDesc->m_pFragCookie,
													  NOERROR);
					
					// Make a callback into the app to let it know what happened.
					ppm::PPMNotification(PPM_E_DROPFRAME, SEVERITY_NORMAL, NULL, 0);
					// BUGBUG We are here because
					// m_pFragList->Is_Empty() == FALSE
					// then the pFragDesc should always be != NULL
					if (pFragDesc->m_pProfileHeader)
						FreeProfileHeader(pFragDesc->m_pProfileHeader);
					FreeFragDescriptor(pFragDesc);
				}
				m_GlobalLastFrameDropped = TRUE;

				return PPMERR(PPM_E_DROPFRAME);
			}

			// Copy packet to buffer
			pbCurrentOffset[-1] = chFirstByte;
			dwBufSize +=
				copyAndAdvance(
					pbCurrentOffset,
					(LPBYTE) pFragDesc->m_pData + 1,
					pFragDesc->m_BytesOfData - 1);
		}
		else
		{
			// This packet has no missing sbits (case 3).
			if (nLastEbit != 0)
			{
				// Prior packet has missing ebits; possible encoding error.
				FreeFragList(pMsgHdr);
				EnqueueBuffer(pMsgDesc);
				FreeMsgHeader(pMsgHdr);

#ifdef REBUILD_EXBITSTREAM
				if (bExtendedBitstream)
				{
#ifdef DYN_ALLOC_EBS
					if (pEBS) {
						delete [] pEBS;
						pEBS = NULL;
					}
#endif
				}
#endif

				LeaveCriticalSection(&m_CritSec);

				DBG_MSG(DBG_ERROR, ("H263_ppmReceive::DataCopy: ERROR - Received packets with sbit/ebit mismatch"));

				if (pFragDesc != NULL)
				{

					// Release the CRTPSample to receive more data
					m_pSubmitCallback->SubmitComplete(pFragDesc->m_pFragCookie,
													  NOERROR);
					// Make a callback into the app to let it know what happened.
					ppm::PPMNotification(PPM_E_DROPFRAME, SEVERITY_NORMAL, NULL, 0);
					// BUGBUG We are here because
					// m_pFragList->Is_Empty() == FALSE
					// then the pFragDesc should always be != NULL
					if (pFragDesc->m_pProfileHeader)
						FreeProfileHeader(pFragDesc->m_pProfileHeader);
					FreeFragDescriptor(pFragDesc);
				}
				m_GlobalLastFrameDropped = TRUE;

				return PPMERR(PPM_E_DROPFRAME);
			}

			// Copy packet to buffer
			dwBufSize +=
				copyAndAdvance(
					pbCurrentOffset,
					(LPBYTE) pFragDesc->m_pData,
					pFragDesc->m_BytesOfData);
		}

		// Always shift the ignored bits out of the last byte and patch it
		// back into the buffer, since there is no harm in doing so.
		chLastByte =
			  (*((LPBYTE)pFragDesc->m_pData + pFragDesc->m_BytesOfData-1))
			& GetEMask(rProfileHdr.ebit());

		// Overwrite last byte in buffer
		pbCurrentOffset[-1] = chLastByte;

		// Save for packet misalignment detection.
		nLastEbit = rProfileHdr.ebit();

		// send the frag buffer back down to receive more data and free the frag header.
		m_pSubmitCallback->SubmitComplete(pFragDesc->m_pFragCookie, NOERROR);

		if (pFragDesc->m_pProfileHeader)
			FreeProfileHeader(pFragDesc->m_pProfileHeader);
		FreeFragDescriptor(pFragDesc);

	} // End of packet processing loop

#ifdef REBUILD_EXBITSTREAM
	if (bExtendedBitstream)
	{
		// Note that we don't increment dwBufSize here, since it doesn't include EBS or trailer.

		// pad with zeros to next dword boundary
		static const DWORD dwZero = 0;
		copyAndAdvance(pbCurrentOffset, &dwZero, offsetNextDword(pbCurrentOffset));

		// copy the extended bitstream structures into the buffer
		copyAndAdvance(pbCurrentOffset, pEBS, nNumFrags * sizeof(*pEBS));

#ifdef DYN_ALLOC_EBS
		// Delete now to prevent erroneous late update
		delete [] pEBS;
		pEBS = NULL;
#endif

		// Complete some of the info for the trailer.
		bsTrailer.dwCompressedSize	= dwBufSize;
		bsTrailer.dwNumberOfPackets	= nNumFrags;

		// copy the trailer in
		copyAndAdvance(pbCurrentOffset, &bsTrailer, sizeof(bsTrailer));
	}
#endif /* REBUILD_EXBITSTREAM */

	ASSERT(ContainsH263PSC(pMsgDesc->m_pBuffer));

	LeaveCriticalSection(&m_CritSec);

	// When we are done. Call Client's submit with full Message
	WSABUF tmpWSABUF[2];
	tmpWSABUF[0].buf = (char*) pMsgDesc->m_pBuffer;
#ifdef REBUILD_EXBITSTREAM
	if (bExtendedBitstream)
	{
		// we report the size including the extended bitstream + trailer + padding
		tmpWSABUF[0].len = (ULONG) (pbCurrentOffset -
									(LPBYTE) pMsgDesc->m_pBuffer);
	}
	else
#endif /* !REBUILD_EXBITSTREAM */
	{
		tmpWSABUF[0].len = dwBufSize;
	}
	tmpWSABUF[1].buf = (char*) &(pMsgDesc->m_TimeStamp);
	tmpWSABUF[1].len = sizeof(pMsgDesc->m_TimeStamp);

#ifdef _DEBUG
#ifdef CHECKSUM
	for (int i = 0; i < (int) dwBufSize-1; i++)
	{
		sum += ((char*)pMsgDesc->m_pBuffer)[i];
	}
	DBG_MSG(DBG_TRACE, ("H263PPMReceive::DataCopy Thread %ld -  giving buffer %x to Client, data size %d, checksum %x, second char %x\n",
		GetCurrentThreadId(), pMsgDesc->m_pBuffer, dwBufSize, sum,tmpWSABUF[0].buf[1]));
#else
	DBG_MSG(DBG_TRACE, ("H263PPMReceive::DataCopy Thread %ld -  giving buffer %x to Client, data size %d, second char %x\n",
		GetCurrentThreadId(), pMsgDesc->m_pBuffer, dwBufSize,tmpWSABUF[0].buf[1]));
#endif
#endif
#ifdef REBUILD_EXBITSTREAM
#ifdef PDEBUG
	if (bExtendedBitstream)
	{
		dumpEBS((BSINFO_TRAILER*)((LPBYTE)tmpWSABUF[0].buf + tmpWSABUF[0].len - sizeof(BSINFO_TRAILER)));
	}
#endif
#endif /* REBUILD_EXBITSTREAM */

	FreeMsgHeader(pMsgHdr);

	HRESULT	status =
		m_pSubmit->Submit(
			tmpWSABUF,
			2,
			pMsgDesc,
			m_GlobalLastFrameDropped ? PPMERR(PPM_E_DROPFRAME) : NOERROR);

	m_GlobalLastFrameDropped = FALSE;

	if (FAILED(status))
	{
		// no SubmitComplete should be called, so take care of resources now
		//pMsgDesc->m_Size = m_MaxBufferSize;	// reset the data buffer size
		//EnqueueBuffer(pMsgDesc);
		DBG_MSG(DBG_ERROR, ("H263_ppmReceive::DataCopy: ERROR - Client Submit failed"));
		status = PPMERR(PPM_E_CLIENTERR);

		// Make a callback into the app to let it know what happened.
		ppm::PPMNotification(PPM_E_CLIENTERR, SEVERITY_NORMAL, NULL, 0);
		m_GlobalLastFrameDropped = TRUE;
	}

	return status;
}

#ifdef REBUILD_EXBITSTREAM

//////////////////////////////////////////////////////////////////////////////////////////
// initBitstreamInfoH263: Prepares bitstream info vector element.  This function assumes
// that bitstream info vector was zero-filed on allocation, and that elements are never
// reused.  If this turns out to be dangerous, this function should memset BS_info to zero.
//////////////////////////////////////////////////////////////////////////////////////////
static inline void
initBitstreamInfoH263(BITSTREAM_INFO_H263& BS_info, DWORD dwBitOffset = 0)
{
	BS_info.dwFlags = RTP_H26X_PACKET_LOST;
	BS_info.dwBitOffset = dwBitOffset;
}

#ifdef _DEBUG
//////////////////////////////////////////////////////////////////////////////////////////
// ValidateEBS(): Debugging function to test that EBS is correctly constructed.
// ??? Need to test other fields.
//////////////////////////////////////////////////////////////////////////////////////////
static void
ValidateEBS(const BITSTREAM_INFO_H263* const pEBS, int nNumFrags)
{
	DWORD dwPrevBitOffset = pEBS[0].dwBitOffset;
	ASSERT(dwPrevBitOffset < 8); // 1st packet should start in 1st byte

	for (int nIx = 1; nIx < nNumFrags; ++ nIx)
	{
		// Be sure packets assembled in correct order
		ASSERT(pEBS[nIx].dwBitOffset > dwPrevBitOffset);
		dwPrevBitOffset = pEBS[nIx].dwBitOffset;
	}
}
#endif // _DEBUG


//////////////////////////////////////////////////////////////////////////////////////////
// ExtendedBitStream: build extended bitstream
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT H263_ppmReceive::BuildExtendedBitstream(MsgHeader* const pMsgHdr)
{
#ifndef DYN_ALLOC_EBS
	static BITSTREAM_INFO_H263 pEBS[MAXFRAGS_PER_FRAME];
#endif

	MsgDescriptor* pMsgDesc = DequeueBuffer(1);	// Get a buffer to hold the message.
	if (pMsgDesc == NULL)
	{
		FreeFragList(pMsgHdr);
		FreeMsgHeader(pMsgHdr);

		DBG_MSG(DBG_ERROR, ("H263_ppmReceive::BuildExtendedBitstream: ERROR - Couldn't get a reassembly buffer"));

		// Make a callback into the app to let it know what happened.
		ppm::PPMNotification(PPM_E_DROPFRAME, SEVERITY_NORMAL, NULL, 0);
		m_GlobalLastFrameDropped = TRUE;
		return PPMERR(PPM_E_DROPFRAME);
	}

	EnterCriticalSection(&m_CritSec);

#ifdef GIVE_SEQNUM
	// Do this before frag list exhausted below
	pMsgDesc->m_TimeStamp = pMsgHdr->m_pFragList->LastSeqNum();
#else
	pMsgDesc->m_TimeStamp = pMsgHdr->GetMsgID();
#endif

	// Complete some of the info for the trailer.  We can take this info
	// from any one packet, so let's use the first.
	BSINFO_TRAILER bsTrailer = {0};	// zero fill
	setH263BSInfoTrailer(
		bsTrailer,
		(FragDescriptor*) pMsgHdr->m_pFragList->GetFirst());

	DWORD nExtraFrags = 0;

	// Use presence/absence of valid picture start code to determine whether
	// or not first fragment has been rcvd.
	BOOL bFoundPSC =
		ContainsH263PSC(
			((FragDescriptor*) pMsgHdr->m_pFragList->GetFirst())->m_pData);

	if (! bFoundPSC)
	{
		nExtraFrags++;
	}

	// Check for last packet missing; if so, add 1 to nNumFrags.
	if (! pMsgHdr->m_MarkerBitIn)
	{
		nExtraFrags++;
	}

	// Compute frame fragment count (const for safety)
	const DWORD nNumFrags =
		  pMsgHdr->m_pFragList->SeqNumSpan() + nExtraFrags;

	DBG_MSG(DBG_TRACE,
		("H263_ppmReceive::BuildExtendedBitstream: "
			"m_GlobalLastMarkerBitIn=%d, "
			"m_GlobalLastSeqNum=%d",
		m_GlobalLastMarkerBitIn,
		m_GlobalLastSeqNum));
	DBG_MSG(DBG_TRACE,
		("H263_ppmReceive::BuildExtendedBitstream: "
			"MsgHeader*=0x%08lx, FirstSeqNum()=%d",
		pMsgHdr,
		pMsgHdr->m_pFragList->FirstSeqNum()));
	DBG_MSG(DBG_TRACE,
		("    LastSeqNum()=%d, nNumFrags=%d",
		pMsgHdr->m_pFragList->LastSeqNum(),
		nNumFrags));

#ifdef DYN_ALLOC_EBS
	// allocate structures for the extended bitstream information
	BITSTREAM_INFO_H263* pEBS = new BITSTREAM_INFO_H263[nNumFrags];
	if (pEBS == NULL)
	{
		FreeFragList(pMsgHdr);
		EnqueueBuffer(pMsgDesc);
		FreeMsgHeader(pMsgHdr);

		LeaveCriticalSection(&m_CritSec);
		DBG_MSG(DBG_ERROR, ("H263_ppmReceive::BuildExtendedBitstream: ERROR - memory allocation failure"));

		// Make a callback into the app to let it know what happened.
		ppm::PPMNotification(PPM_E_OUTOFMEMORY, SEVERITY_NORMAL, NULL, 0);
		m_GlobalLastFrameDropped = TRUE;
		return PPMERR(PPM_E_DROPFRAME);
	}
#else
	if (nNumFrags > MAXFRAGS_PER_FRAME)
	{
		FreeFragList(pMsgHdr);
		EnqueueBuffer(pMsgDesc);
		FreeMsgHeader(pMsgHdr);

		LeaveCriticalSection(&m_CritSec);
		DBG_MSG(DBG_ERROR, ("H263_ppmReceive::BuildExtendedBitstream: ERROR - too many packets for EBS structure"));

		// Make a callback into the app to let it know what happened.
		ppm::PPMNotification(PPM_E_OUTOFMEMORY, SEVERITY_NORMAL, NULL, 0);
		m_GlobalLastFrameDropped = TRUE;
		return PPMERR(PPM_E_DROPFRAME);
	}
#endif
	memset(pEBS, 0, nNumFrags * sizeof(*pEBS));

	LPBYTE pbCurrentOffset = (LPBYTE) pMsgDesc->m_pBuffer;	// start copying into front of buffer.
	DWORD dwBufSize = 0;
	DWORD nCurrentEBS = 0;	// EBS vector index

	if (! bFoundPSC)
	{
		// PSC not found, assume first packet is missing.

		// add EBS info for the lost first packet
		initBitstreamInfoH263(pEBS[nCurrentEBS ++]);

		// add new padding values for lost first packet
		dwBufSize +=
			copyAndAdvance(
				pbCurrentOffset,
				&s_leadFragBitPattern,
				sizeof(s_leadFragBitPattern));
	}

	// Loop state variables
	UCHAR chLastByte = 0;
	int nLastEbit = 0;

	int nCurrentSeqNum = pMsgHdr->m_pFragList->FirstSeqNum();

	// Process all rcvd packets
	while (! pMsgHdr->m_pFragList->Is_Empty())
	{
		// get next fragment (const to prevent unintentional modification)
		FragDescriptor* const pFragDesc = (FragDescriptor*)
			pMsgHdr->m_pFragList->TakeFromList();
		m_PacketsHold--;

		// Note: remember that m_pFragList will be empty after the last
		// iteration of this loop, so LList::methods which expect a
		// non-empty list should not be called below.

		// check to see if TakeFromList() returned NULL.  Also, make sure
		// we won't overrun the buffer (including extended bitstream,
		// the trailer and any dword alignment bits that need to be added).
		if ((pFragDesc == NULL) ||
			((dwBufSize +
			pFragDesc->m_BytesOfData +
			(nNumFrags * sizeof(*pEBS)) +
			sizeof(BSINFO_TRAILER) +
			offsetNextDword(pbCurrentOffset))
				> pMsgDesc->m_Size))
		{
			FreeFragList(pMsgHdr);
			EnqueueBuffer(pMsgDesc);
			FreeMsgHeader(pMsgHdr);

#ifdef DYN_ALLOC_EBS
			if (pEBS) {
				delete [] pEBS;
				pEBS = NULL;
			}
#endif

			LeaveCriticalSection(&m_CritSec);
			DBG_MSG(DBG_ERROR, ("H263_ppmReceive::BuildExtendedBitstream: ERROR - null pFragDesc or buffer overrun"));
			if (pFragDesc != NULL)
			{
				// Release the CRTPSample to receive more data
				m_pSubmitCallback->SubmitComplete(pFragDesc->m_pFragCookie,
												  NOERROR);
				// Make a callback into the app to let it know what happened.
				ppm::PPMNotification(PPM_E_RECVSIZE, SEVERITY_NORMAL, NULL, 0);
				// BUGBUG We are here because
				// m_pFragList->Is_Empty() == FALSE
				// then the pFragDesc should always be != NULL
				if (pFragDesc->m_pProfileHeader)
					FreeProfileHeader(pFragDesc->m_pProfileHeader);
				FreeFragDescriptor(pFragDesc);
			}
			m_GlobalLastFrameDropped = TRUE;
			return PPMERR(PPM_E_DROPFRAME);
		}

		DBG_MSG(DBG_TRACE,
			("H263_ppmReceive::BuildExtendedBitstream: "
				"FragDescriptor*=0x%08lx, "
				"seq=%d, "
				"ts=%lu, "
				"frag[0-3]=%1X%1X%1X%1X",
			pFragDesc,
			pFragDesc->m_pRTPHeader->seq(),
			pFragDesc->m_pRTPHeader->ts(),
			((char*) pFragDesc->m_pData)[0],
			((char*) pFragDesc->m_pData)[1],
			((char*) pFragDesc->m_pData)[2],
			((char*) pFragDesc->m_pData)[3]));

		// see if packets are skipped; if so, put padding into buffer and add BS struct
#ifdef RTP_CLASS
		for (; nCurrentSeqNum < pFragDesc->m_pRTPHeader->seq(); nCurrentSeqNum++)
#else
		for (; nCurrentSeqNum < ntohs(pFragDesc->m_pRTPHeader->seq); nCurrentSeqNum++)
#endif
		{

			if (nCurrentEBS >= nNumFrags) {  //ERROR, bail out
				FreeFragList(pMsgHdr);
				EnqueueBuffer(pMsgDesc);
				FreeMsgHeader(pMsgHdr);

	#ifdef DYN_ALLOC_EBS
				if (pEBS) {
					delete [] pEBS;
					pEBS = NULL;
				}
	#endif

				LeaveCriticalSection(&m_CritSec);
				DBG_MSG(DBG_ERROR, ("H263_ppmReceive::BuildExtendedBitstream: ERROR - buffer overrun"));
				if (pFragDesc != NULL)
				{
					// Release the CRTPSample to receive more data
					m_pSubmitCallback->SubmitComplete(pFragDesc->m_pFragCookie,
													  NOERROR);
					// Make a callback into the app to let it know what happened.
					ppm::PPMNotification(PPM_E_RECVSIZE, SEVERITY_NORMAL, NULL, 0);
					// BUGBUG We are here because
					// m_pFragList->Is_Empty() == FALSE
					// then the pFragDesc should always be != NULL
					if (pFragDesc->m_pProfileHeader)
						FreeProfileHeader(pFragDesc->m_pProfileHeader);
					FreeFragDescriptor(pFragDesc);
				}
				m_GlobalLastFrameDropped = TRUE;
				return PPMERR(PPM_E_DROPFRAME);
			}

			// If prior rcvd packet had missing ebits, adjust bit
			// offset accordingly.  The missing bits are added to the
			// tail of the padding (by forcing bit offset of _next_
			// segment to be byte-aligned).  If there was no prior rcvd
			// packet, or prior packet had no missing ebits, nLastEbit ==
			// 0, so that the bit offset expression is equivalent to
			// (dwBufSize * BITSPERBYTE).
			initBitstreamInfoH263(
				pEBS[nCurrentEBS++],
				((dwBufSize - 1) * BITSPERBYTE)
					+ (BITSPERBYTE - nLastEbit));

			// we just consumed the last ebits (if any), and are now back
			// to byte alignment.
			nLastEbit = 0;
			chLastByte = 0;

			// for packets other than the first of the frame, we pad with 4
			// bytes of zeroes
			dwBufSize +=
				copyAndAdvance(
					pbCurrentOffset,
					&s_nonLeadFragBitPattern,
					sizeof(s_nonLeadFragBitPattern));
		}

		// Assign immutable reference to profile header
		H263_Header& rProfileHdr =
			*(H263_Header*) pFragDesc->m_pProfileHeader;

		// Handle overlapping (shared byte) between current and prior
		// between packets.  There are three cases to deal with:
		// 1)	Current packet overlaps the prior packet, and the prior
		//		packet was received.
		// 2)	Current packet overlaps the prior packet, and this is first
		//		packet or prior packet was lost (there are no pending ebits).
		// 3)	Current packet doesn't overlap the prior packet.
		if (rProfileHdr.sbit())
		{
			// This packet had missing sbits (case 1 or 2).

			// Mask off missing sbits and combine with ebits from prior packet.
			const UCHAR chFirstByte =
				(*(LPBYTE) pFragDesc->m_pData
					& GetSMask(rProfileHdr.sbit()))
				| chLastByte;

			if (nLastEbit == 0)
			{
				// Case 2: There are no pending ebits, so we need an
				// extra byte into which to stuff the current packet's
				// sbits.  No need to clear the byte, since it'll be
				// overwritten by chFirstByte below.
				pbCurrentOffset++;
				dwBufSize++;
			}
			else if (nLastEbit + rProfileHdr.sbit() != BITSPERBYTE)
			{
				// Prior and current packets don't overlap properly.
				FreeFragList(pMsgHdr);
				EnqueueBuffer(pMsgDesc);
				FreeMsgHeader(pMsgHdr);

#ifdef DYN_ALLOC_EBS
				if (pEBS) {
					delete [] pEBS;
					pEBS = NULL;
				}
#endif

				LeaveCriticalSection(&m_CritSec);

				DBG_MSG(DBG_ERROR, ("H263_ppmReceive::BuildExtendedBitstream: ERROR - Received packets with sbit/ebit mismatch"));

				if (pFragDesc != NULL)
				{
					// Release the CRTPSample to receive more data
					m_pSubmitCallback->SubmitComplete(pFragDesc->m_pFragCookie,
													  NOERROR);
					// Make a callback into the app to let it know what happened.
					ppm::PPMNotification(PPM_E_DROPFRAME, SEVERITY_NORMAL, NULL, 0);
					// BUGBUG We are here because
					// m_pFragList->Is_Empty() == FALSE
					// then the pFragDesc should always be != NULL
					if (pFragDesc->m_pProfileHeader)
						FreeProfileHeader(pFragDesc->m_pProfileHeader);
					FreeFragDescriptor(pFragDesc);
				}
				m_GlobalLastFrameDropped = TRUE;

				return PPMERR(PPM_E_DROPFRAME);
			}

			pEBS[nCurrentEBS].dwBitOffset =
				  ((dwBufSize - 1) * BITSPERBYTE)
				+ rProfileHdr.sbit();

			// Copy the packet to the frame buffer.
			pbCurrentOffset[-1] = chFirstByte;
			dwBufSize +=
				copyAndAdvance(
					pbCurrentOffset,
					(LPBYTE) pFragDesc->m_pData + 1,
					pFragDesc->m_BytesOfData - 1);

			// dwBufSize now points to _next_ packet slot
		}
		else
		{
			// This packet doesn't overlap prior packet (case 3).
			if (nLastEbit != 0)
			{
				// Prior packet has missing ebits; possible encoding error.
				FreeFragList(pMsgHdr);
				EnqueueBuffer(pMsgDesc);
				FreeMsgHeader(pMsgHdr);

#ifdef DYN_ALLOC_EBS
				if (pEBS) {
					delete [] pEBS;
					pEBS = NULL;
				}
#endif

				LeaveCriticalSection(&m_CritSec);

				DBG_MSG(DBG_ERROR, ("H263_ppmReceive::BuildExtendedBitstream: ERROR - Received packets with sbit/ebit mismatch"));

				if (pFragDesc != NULL)
				{
					// Release the CRTPSample to receive more data
					m_pSubmitCallback->SubmitComplete(pFragDesc->m_pFragCookie,
													  NOERROR);
					// Make a callback into the app to let it know what happened.
					ppm::PPMNotification(PPM_E_DROPFRAME, SEVERITY_NORMAL, NULL, 0);
					// BUGBUG We are here because
					// m_pFragList->Is_Empty() == FALSE
					// then the pFragDesc should always be != NULL
					if (pFragDesc->m_pProfileHeader)
						FreeProfileHeader(pFragDesc->m_pProfileHeader);
					FreeFragDescriptor(pFragDesc);
				}
				m_GlobalLastFrameDropped = TRUE;

				return PPMERR(PPM_E_DROPFRAME);
			}

			pEBS[nCurrentEBS].dwBitOffset = dwBufSize * BITSPERBYTE;

			// Copy the packet to the frame buffer.
			dwBufSize +=
				copyAndAdvance(
					pbCurrentOffset,
					pFragDesc->m_pData,
					pFragDesc->m_BytesOfData);

			// dwBufSize now points to _next_ packet slot
		}

		// We need to store the ebit for the last received packet to give the
		// dwBitOffset for the last real packet if lost.
		nLastEbit = rProfileHdr.ebit();

		// always shift the ignored bits out of the last byte and patch it back into
		// the buffer, since there is no harm in doing so.
		chLastByte =
			  (*((LPBYTE) pFragDesc->m_pData + pFragDesc->m_BytesOfData - 1))
			& GetEMask(nLastEbit);

		// Overwrite last byte to clear missing bits
		pbCurrentOffset[-1] = chLastByte;

		// Update BS struct for current packet and save off values for
		// next lost packet
		pEBS[nCurrentEBS].dwFlags	= 0;
		pEBS[nCurrentEBS].MBA		= rProfileHdr.mba();
		pEBS[nCurrentEBS].Quant		= rProfileHdr.quant();
		pEBS[nCurrentEBS].GOBN		= rProfileHdr.gobn();
		pEBS[nCurrentEBS].HMV1		= rProfileHdr.hmv1();
		pEBS[nCurrentEBS].VMV1		= rProfileHdr.vmv1();
		pEBS[nCurrentEBS].HMV2		= rProfileHdr.hmv2();
		pEBS[nCurrentEBS].VMV2		= rProfileHdr.vmv2();
		nCurrentEBS++;
		nCurrentSeqNum++;

		// send the frag buffer back down to receive more data and free the frag header.
		// always pass zero because we never allocated the buffers and therefore
		// have no idea how big the buffers are.
		m_pSubmitCallback->SubmitComplete(pFragDesc->m_pFragCookie, NOERROR);

		if (pFragDesc->m_pProfileHeader)
			FreeProfileHeader(pFragDesc->m_pProfileHeader);
		FreeFragDescriptor(pFragDesc);

	} // End of packet processing loop

	// check and handling for last packet if missing
	if (! pMsgHdr->m_MarkerBitIn)
	{
		// Yes, it's last packet, but increment nCurrentEBS to trap
		// unintentional reference later.
		initBitstreamInfoH263(
			pEBS[nCurrentEBS ++],
			((dwBufSize - 1) * BITSPERBYTE) + (BITSPERBYTE - nLastEbit));

		// for packets other than the first of the frame, we pad with
		// 4 bytes of zeroes
		dwBufSize +=
			copyAndAdvance(
				pbCurrentOffset,
				&s_nonLeadFragBitPattern,
				sizeof(s_nonLeadFragBitPattern));
	}

	// pad with zeros to next dword boundary
	static const DWORD dwZero = 0;
	copyAndAdvance(pbCurrentOffset, &dwZero, offsetNextDword(pbCurrentOffset));

	#ifdef _DEBUG
		ValidateEBS(pEBS, nNumFrags);
	#endif

	// copy the extended bitstream structures into the buffer
	copyAndAdvance(pbCurrentOffset, pEBS, nNumFrags * sizeof(*pEBS));

#ifdef DYN_ALLOC_EBS
	// Delete now to prevent erroneous late update
	delete [] pEBS;
	pEBS = NULL;
#endif

	// Complete rest of the info for the trailer.  Note that dwBufSize doesn't
	// include the extended bitstream or the trailer.
	bsTrailer.dwCompressedSize	= dwBufSize;
	bsTrailer.dwNumberOfPackets	= nNumFrags;

	// copy the trailer in
	copyAndAdvance(pbCurrentOffset, &bsTrailer, sizeof(bsTrailer));

	ASSERT(ContainsH263PSC(pMsgDesc->m_pBuffer));

	LeaveCriticalSection(&m_CritSec);

	// When we are done. Call Client's submit with full Message

	// we report the size including the extended bitstream + trailer + padding
	WSABUF tmpWSABUF[2];
	tmpWSABUF[0].buf = (char*) pMsgDesc->m_pBuffer;
	tmpWSABUF[0].len = (DWORD)(pbCurrentOffset - (LPBYTE) pMsgDesc->m_pBuffer);
	tmpWSABUF[1].buf = (char*) &(pMsgDesc->m_TimeStamp);
	tmpWSABUF[1].len = sizeof(pMsgDesc->m_TimeStamp);

#ifdef PDEBUG
	dumpEBS((BSINFO_TRAILER*)((LPBYTE)tmpWSABUF[0].buf + tmpWSABUF[0].len - sizeof(BSINFO_TRAILER)));
#endif

	// Make a callback into the app to let it know about this partial frame
	// We also pass the timestamp of the frame
	ppm::PPMNotification(
			PPM_E_PARTIALFRAME,
			SEVERITY_NORMAL,
			(LPBYTE) tmpWSABUF[1].buf,
			tmpWSABUF[1].len);

	FreeMsgHeader(pMsgHdr);

	HRESULT	status =
		m_pSubmit->Submit(tmpWSABUF, 2,  pMsgDesc, PPMERR(PPM_E_PARTIALFRAME));
	m_GlobalLastFrameDropped = FALSE;

	if (FAILED(status))
	{
		// no SubmitComplete should be called, so take care of resources now
		//pMsgDesc->m_Size = m_MaxBufferSize;	// reset the data buffer size
		//EnqueueBuffer(pMsgDesc);
		DBG_MSG(DBG_ERROR, ("H263_ppmReceive::BuildExtendedBitstream: ERROR - Client Submit failed"));
		status = PPMERR(PPM_E_CLIENTERR);

		// Make a callback into the app to let it know what happened.
		ppm::PPMNotification(PPM_E_CLIENTERR, SEVERITY_NORMAL, NULL, 0);
		m_GlobalLastFrameDropped = TRUE;
	}

	// for debugging, use this line instead of submit
	//	SubmitComplete(pMsgDesc,NOERROR);

	return status;
}
#endif // REBUILD_EXBITSTREAM

//////////////////////////////////////////////////////////////////////////////////////////
// PartialMessageHandler: deals with partial messages
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT H263_ppmReceive::PartialMessageHandler(MsgHeader* pMsgHdr)
{
	if (pMsgHdr == NULL)
	{
		DBG_MSG(DBG_ERROR, ("H263_ppmReceive::PartialMessageHandler: ERROR - pMsgHdr == NULL"));
		return PPMERR(PPM_E_EMPTYQUE);
	}

#ifdef REBUILD_EXBITSTREAM
	if (m_ExtendedBitstream)
	{
		return BuildExtendedBitstream(pMsgHdr);
	}
	else
#endif /* REBUILD_EXBITSTREAM */
	{
		// Make a callback into the app to let it know about this dropped frame.
		// We also pass the timestamp of the frame
		DWORD tmpTS = pMsgHdr->GetMsgID();
		ppm::PPMNotification(
				PPM_E_DROPFRAME,
				SEVERITY_NORMAL,
				(LPBYTE) &tmpTS,
				sizeof(tmpTS));
		m_GlobalLastFrameDropped = TRUE;

		FreeFragList(pMsgHdr);
		FreeMsgHeader(pMsgHdr);
		return NOERROR;
	}
}

//////////////////////////////////////////////////////////////////////////////////////////
// InitProfileHeader: Given a buffer as type void, sets up a profile header.  Does nothing
//					for the Generic case.  Intended for overrides for various payloads.
//					Companion member function FreeProfileHeader provided so that if payload
//					header memory is allocated in this function, it can be freed there.
//////////////////////////////////////////////////////////////////////////////////////////
void* H263_ppmReceive::InitProfileHeader(void* pBuffer)
{
/*	if (*(LPBYTE)pBuffer	& 0x80) { // flag bit set for Mode B or C
		if (*(LPBYTE)pBuffer & 0x40) // PB frame bit identifies Mode C (if not A)
			return new H263_HeaderC ( (char*) pBuffer );
		else
			return new H263_HeaderB ( (char*) pBuffer );
	}
	return new H263_HeaderA ( (char*) pBuffer );
*/
	if (*(LPBYTE)pBuffer	& 0x80) { // flag bit set for Mode B or C
		if (*(LPBYTE)pBuffer & 0x40) // PB frame bit identifies Mode C (if not A)
			return new (m_pH263Headers) H263_HeaderC ( (char*) pBuffer );
		else
			return new (m_pH263Headers) H263_HeaderB ( (char*) pBuffer );
	}
	return new (m_pH263Headers) H263_HeaderA ( (char*) pBuffer );

}

//////////////////////////////////////////////////////////////////////////////////////////
// FreeProfileHeader: Given a buffer as type void, frees up a profile header.  Does nothing
//					for the Generic case.  Intended for overrides for various payloads.
//					Companion member function InitProfileHeader may allocate memory for
//					payload header which needs to be freed here. No return value.
//////////////////////////////////////////////////////////////////////////////////////////
void H263_ppmReceive::FreeProfileHeader(void* pBuffer)
{
	// lsc??
	// delete pBuffer;

	m_pH263Headers->Free( pBuffer );
	return;
}

//////////////////////////////////////////////////////////////////////////////////////////
// ReadProfileHeaderSize: Given a pointer to a prof header, returns the size for that header.
//					Intended for overrides for various payloads. If the pointer is not
//					provided (as used for initialization, etc) m_ProfileHeaderSize is returned,
//					which, for H.263 is the size of the large profile header (Mode C).
//					Otherwise, the exact size of the header for that mode is returned,
//					since the header pointer is used to retrieve the size for itself.
//////////////////////////////////////////////////////////////////////////////////////////
int H263_ppmReceive::ReadProfileHeaderSize(void* pProfileHeader)
{
	H263_Header* pBaseHeader;

	if (! pProfileHeader)
		return ppm::ReadProfileHeaderSize();
	pBaseHeader = (H263_Header*) pProfileHeader;
	return pBaseHeader->header_size();
};

// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\h263snd.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: h263snd.cpp
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#include "h263snd.h"
#include "ppmerr.h"
#include "ippmcb.h"

H263_ppmSend::H263_ppmSend(IUnknown* pUnkOuter, IUnknown** ppUnkInner) : ppmSend(H263_PT, sizeof(H263_HeaderC), 90000, pUnkOuter, ppUnkInner)
{
   m_pBSINFO_TRAILER  = NULL;
   //Allocate memory for the H263 headers
   HRESULT hr;
   m_pH263Headers = new FreeList(FREELIST_INIT_COUNT_SND,
								 sizeof(H263_HeaderC),
								 FREELIST_HIGH_WATER_MARK,
								 FREELIST_INCREMENT,
								 &hr);

   if (!m_pH263Headers) {
	  DBG_MSG(DBG_ERROR, ("H263_ppmSend::H263_ppmSend: ERROR - m_pH263Headers == NULL"));
  }
}

H263_ppmSend::~H263_ppmSend()
{ 
	if (m_pH263Headers) 
		delete  m_pH263Headers;
}


IMPLEMENT_CREATEPROC(H263_ppmSend);

#ifdef FILEPRINT
#include <stdio.h>
#endif
static void dumpEBS(BSINFO_TRAILER *pTrailer) {
#ifdef FILEPRINT
	BITSTREAM_INFO_H263 *pBSinfo;
	FILE *stream;

	stream = fopen("h263snd.txt", "a");

	fprintf(stream,"H263_ppmSend::dumpEBS - Trailer has:\n\tVersion %lu\n\tFlags %lu\n\tUniqueCode %lu\n\tCompressed Size %lu\n\tPackets %lu\n\tSrc Format %u\n\tTR %u\n\tTRB %u\n\tDBQ %u\n",
		pTrailer->dwVersion,pTrailer->dwFlags,pTrailer->dwUniqueCode,pTrailer->dwCompressedSize,
		pTrailer->dwNumberOfPackets,pTrailer->SourceFormat,pTrailer->TR,
		pTrailer->TRB,pTrailer->DBQ);

	pBSinfo = (BITSTREAM_INFO_H263 *) ((BYTE *)pTrailer - (sizeof(BITSTREAM_INFO_H263) *
		pTrailer->dwNumberOfPackets));

	for (int i = 0; i < (long) pTrailer->dwNumberOfPackets; i++) {
		fprintf(stream,"\nH263_ppmSend::dumpEBS - BSinfo struct %d has:\n\tFlags %lu\n\tbitoffset %lu\n\tMBA %u\n\tQuant %u\n\tGOBN %u\n\tHMV1 %c\n\tVMV1 %c\n\tHMV2 %c\n\tVMV2 %c\n",
			i,pBSinfo[i].dwFlags,pBSinfo[i].dwBitOffset,pBSinfo[i].MBA,pBSinfo[i].Quant,pBSinfo[i].GOBN,
			pBSinfo[i].HMV1,pBSinfo[i].VMV1,pBSinfo[i].HMV2,pBSinfo[i].VMV2);
	}

	fclose(stream);
#else
	char debug_string[256];
	BITSTREAM_INFO_H263 *pBSinfo;

	wsprintf(debug_string,"H263_ppmSend::dumpEBS - Trailer has:\n\tVersion %lu\n\tFlags %lu\n\tUniqueCode %lu\n\tCompressed Size %lu\n\tPackets %lu\n\tSrc Format %u\n\tTR %u\n\tTRB %u\n\tDBQ %u\n",
		pTrailer->dwVersion,pTrailer->dwFlags,pTrailer->dwUniqueCode,pTrailer->dwCompressedSize,
		pTrailer->dwNumberOfPackets,pTrailer->SourceFormat,pTrailer->TR,
		pTrailer->TRB,pTrailer->DBQ);
	OutputDebugString(debug_string);

	pBSinfo = (BITSTREAM_INFO_H263 *) ((BYTE *)pTrailer - (sizeof(BITSTREAM_INFO_H263) *
		pTrailer->dwNumberOfPackets));

	for (int i = 0; i < (long) pTrailer->dwNumberOfPackets; i++) {
		wsprintf(debug_string,"\nH263_ppmSend::dumpEBS - BSinfo struct %d has:\n\tFlags %lu\n\tbitoffset %lu\n\tMBA %u\n\tQuant %u\n\tGOBN %u\n\tHMV1 %c\n\tVMV1 %c\n\tHMV2 %c\n\tVMV2 %c\n",
			i,pBSinfo[i].dwFlags,pBSinfo[i].dwBitOffset,pBSinfo[i].MBA,pBSinfo[i].Quant,pBSinfo[i].GOBN,
			pBSinfo[i].HMV1,pBSinfo[i].VMV1,pBSinfo[i].HMV2,pBSinfo[i].VMV2);
		OutputDebugString(debug_string);
	}
#endif

	return;
}

//////////////////////////////////////
//Internal H263Send PPMSend Function Overrides

/////////////////////////////////////////////////////////////////////////////////////////
//InitFragStatus: This function initializes values needed to fragment a message.
//				  It locates the H263 extended bitstream header information at the
//			 	  end of the extended bitstream and validates the header.
//                It sets up the global m_pCurrentBuffer and the size of the frame data.
//                It also sets the NumFrags field of the Msg Descriptor
//                passed in.  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT H263_ppmSend::InitFragStatus(MsgDescriptor *pMsgDescrip)
{
	
#ifdef _DEBUG
#ifdef CHECKSUM
	 unsigned char sum = '\0';
#endif
#endif

//lsc Need to get and use packet boundaries from the bitstream
//		1) Set buffer
//		2) Set fields of a BSINFO_TRAILER to point to the last 3 dwords of the
//		   extended bitstream (where m_Size currently indicates)
//		3) Check the unique code stored in the header
//		4) Set m_NumFrags
//		5) Reset m_Size to the size of the compressed bitstream only (this will
//		   also double as the location of the extended bitstream

   //set global variable
   m_pCurrentBuffer = pMsgDescrip;
   
   //get the bitstream info header at the end of the extended bitstream
   m_pBSINFO_TRAILER = (BSINFO_TRAILER *) ((BYTE *)m_pCurrentBuffer->m_pBuffer + 
	   m_pCurrentBuffer->m_Size	- sizeof(BSINFO_TRAILER));
   			
   //Check the validity of the bitstream info header
   if (m_pBSINFO_TRAILER->dwUniqueCode != H263_CODE) {
	   DBG_MSG(DBG_ERROR, ("H263_ppmSend::InitFragStatus: ERROR - m_pBSINFO_TRAILER->dwUniqueCode != H263_CODE"));
	   return PPMERR(PPM_E_FAIL);
   }

   if (m_pBSINFO_TRAILER->dwVersion != H263_VERSION) {
	   DBG_MSG(DBG_ERROR, ("H263_ppmSend::InitFragStatus: ERROR - m_pBSINFO_TRAILER->dwVersion != H263_VERSION"));
	   return PPMERR(PPM_E_FAIL);
   }

   //May want this check too - 2 different ways to get the start of extended bitstream
   //assert (((BYTE *)m_pCurrentBuffer->m_pBuffer + m_pBSINFO_TRAILER->dwCompressedSize) ==
   //	  ((BYTE *)m_pCurrentBuffer->m_pBuffer + (m_pCurrentBuffer->m_Size - (
   //	  m_pBSINFO_TRAILER->dwNumberOfPackets * sizeof(BITSTREAM_INFO_H263)) - sizeof(BSINFO_TRAILER))));           

   //determine size of packets for this frame - for H263 it varies by packet, so
   //we set this to NULL
   m_CurrentFragSize = NULL;

   EnterCriticalSection(&m_CritSec);
   m_pCurrentBuffer->m_NumFrags = m_pBSINFO_TRAILER->dwNumberOfPackets; //used to free buffer later.
   m_pCurrentBuffer->m_NumFragSubmits = 0; 		 //used during error detection
   LeaveCriticalSection(&m_CritSec);

   //Reset m_Size to not include the extended bitstream; we don't need the size of the
   //composite buffer anymore, and this gives us a way to get the start of extended BS later
   m_pCurrentBuffer->m_Size = m_pBSINFO_TRAILER->dwCompressedSize;

#ifdef _DEBUG
#ifdef CHECKSUM
   	 for (int i = 0; i < (int) m_pCurrentBuffer->m_Size-1; i++)	{
		 sum += ((char *)m_pCurrentBuffer->m_pBuffer)[i];
	 }
	  DBG_MSG(DBG_TRACE, ("H263PPMSend::InitFragStatus Thread %ld -  for buf %x, number of packets %d, data size %d, checksum %x, second char %x\n",
		 GetCurrentThreadId(), m_pCurrentBuffer->m_pBuffer,m_pBSINFO_TRAILER->dwNumberOfPackets,
		 m_pBSINFO_TRAILER->dwCompressedSize,sum,((char *)m_pCurrentBuffer->m_pBuffer)[1]));
#else
	  DBG_MSG(DBG_TRACE, ("H263PPMSend::InitFragStatus Thread %ld -  for buf %x, number of packets %d, data size %d, second char %x\n",
		 GetCurrentThreadId(), m_pCurrentBuffer->m_pBuffer,m_pBSINFO_TRAILER->dwNumberOfPackets,
		 m_pBSINFO_TRAILER->dwCompressedSize,((char *)m_pCurrentBuffer->m_pBuffer)[1]));
#endif

//	 dumpEBS(m_pBSINFO_TRAILER);
#endif

#ifdef REBUILD_EXBITSTREAM
#ifdef PDEBUG
	 dumpEBS(m_pBSINFO_TRAILER);  
#endif
#endif /* REBUILD_EXBITSTREAM */
	 return NO_ERROR;

}

//////////////////////////////////////////////////////////////////////////////////////////
//FreeProfileHeader: Given a buffer as type void, frees up a profile header.  Does nothing
//					for the Generic case.  Intended for overrides for various payloads.
//					No return value.
//////////////////////////////////////////////////////////////////////////////////////////
void H263_ppmSend::FreeProfileHeader(void *pBuffer)
{

	m_pH263Headers->Free( pBuffer );
	return;
}

/////////////////////////////////////////////////////////////////////////////////////////
//MakeFrag: This function sets the Data field of the frag descriptor to point to somewhere
//          in the message buffer.  i.e. we are using scatter/gather to fragment the 
//          message buffers. This means we send pointers to an offset in the message 
//          buffer down to the network layers, instead of copying the data out of the 
//          buffer, thus saving several memcopys.   This function also sets the RTP
//          header fields.  It sets the size of the packet, which will vary by packet
//          and whether the current packet is the last packet or not.
//			The H263 header fields are set.	The extended bitstream information is
//			accessed to get all of the correct data for the fields and the data size
//			and location for the current packet.  An offset is used to walk the structures
//			in the extended bitstream (one structure per packet).  This is incremented
//			for each packet.  If the current packet is the last one in the frame, the
//			offset is cleared and the current buffer is cleared.
////////////////////////////////////////////////////////////////////////////////////////
HRESULT H263_ppmSend::MakeFrag(FragDescriptor *pFragDescrip)
{
BITSTREAM_INFO_H263 *pBS_info;
H263_Header *pProfHeader;
BOOL lastFrag = FALSE;
long tmpOffset = 1, byteCount = 0, overlapCount = 0;

#ifdef _DEBUG
#ifdef CHECKSUM
	 UCHAR sum = '\0';
#endif
#endif

//lsc 
//Instead of m_CurrentOffset being used to point to the next frag start in
//  the buffer, it is the index of the next packet info structure in the extended bitstream
//	0) get the bitstream info structure for this fragment
//	1) point frag desc data pointer to right spot in buffer
//	2) fill in the RTP Header
//	3) fill in the H263 Header
//	4) set size, check for last packet and set marker bit, reset if end

   //Get the bitstream info structure for this fragment
   pBS_info = (BITSTREAM_INFO_H263 *) ((BYTE *) m_pBSINFO_TRAILER - 
	   ((m_pBSINFO_TRAILER->dwNumberOfPackets -	m_CurrentOffset) * 
	   sizeof(BITSTREAM_INFO_H263)));

   //point data field of frag descriptor to data in buffer.
   //Note, I assume that pBS_info->dwBitOffset is from the start of the frame
   pFragDescrip->m_pData = (void *)&((BYTE *)m_pCurrentBuffer->m_pBuffer)[
   		pBS_info->dwBitOffset/BITSPERBYTE];

   //fill in RTP Header
#ifdef RTP_CLASS
   pFragDescrip->m_pRTPHeader->set_pt(ReadPayloadType());
   pFragDescrip->m_pRTPHeader->set_x(0);
   pFragDescrip->m_pRTPHeader->set_p(0);
   pFragDescrip->m_pRTPHeader->set_seq(m_SequenceNum);
   pFragDescrip->m_pRTPHeader->set_ts(m_pCurrentBuffer->m_TimeStamp);
#else
   pFragDescrip->m_pRTPHeader->pt = ReadPayloadType();
   pFragDescrip->m_pRTPHeader->x = 0;
   pFragDescrip->m_pRTPHeader->p = 0;
   pFragDescrip->m_pRTPHeader->seq = htons(m_SequenceNum);
   pFragDescrip->m_pRTPHeader->ts = htonl(m_pCurrentBuffer->m_TimeStamp);
#endif

   if ( m_pBSINFO_TRAILER->dwCompressedSize <= (unsigned long) m_MaxDataSize + 8 ) {	 
								 //Note that m_MaxDataSize is determined using a
								 //profile header size of Mode C, so we add 8 bytes
								 //here since we'll use Mode A, which is smaller
		//pFragDescrip->m_pProfileHeader = (void *) new H263_HeaderA;
	    
	    pFragDescrip->m_pProfileHeader = (void *) new (m_pH263Headers)H263_HeaderA;
		pProfHeader = (H263_Header *)pFragDescrip->m_pProfileHeader;
		//flag for mode A
		pProfHeader->set_f( 0 );
		
		EnterCriticalSection(&m_CritSec);
		m_pCurrentBuffer->m_NumFrags = 1;
		LeaveCriticalSection(&m_CritSec);
		lastFrag = TRUE;
   } else {
		//fill in H263 Header
		if (pBS_info->dwFlags & RTP_H263_MODE_A) 
		{  // Mode A
			//pFragDescrip->m_pProfileHeader = (void *) new H263_HeaderA;
			pFragDescrip->m_pProfileHeader = (void *) new (m_pH263Headers)H263_HeaderA;
		} else if (m_pBSINFO_TRAILER->dwFlags & RTP_H263_PB_FRAME) {  // Mode C
			//pFragDescrip->m_pProfileHeader = (void *) new H263_HeaderC;
			pFragDescrip->m_pProfileHeader = (void *) new (m_pH263Headers)H263_HeaderC;
		} else {	 // Mode B
			//pFragDescrip->m_pProfileHeader = (void *) new H263_HeaderB;
			pFragDescrip->m_pProfileHeader = (void *) new (m_pH263Headers)H263_HeaderB;
		}

		pProfHeader = (H263_Header *)pFragDescrip->m_pProfileHeader;
		//flag for mode A or not
		pProfHeader->set_f( (pBS_info->dwFlags & RTP_H263_MODE_A) == 0 );


		//Aggregate as many CODEC pBSinfo pieces as will fit in a packet
		while ((m_CurrentOffset+tmpOffset) < m_pBSINFO_TRAILER->dwNumberOfPackets) {
			byteCount = (long) (((BYTE *)m_pCurrentBuffer->m_pBuffer) + 
				((pBS_info+tmpOffset)->dwBitOffset)/BITSPERBYTE 
				- (BYTE*)pFragDescrip->m_pData);
			if ((pBS_info+tmpOffset)->dwBitOffset%BITSPERBYTE) 
				overlapCount = 1;
			else
				overlapCount = 0;
			if ( (byteCount + overlapCount) <= m_MaxDataSize) {
				DBG_MSG(DBG_TRACE,  ("H263_ppmSend::MakeFrag: cur %d tmp %d bitoffset %d byteCount %d less than MTU %d, keep on going",
					m_CurrentOffset, tmpOffset, (pBS_info+tmpOffset)->dwBitOffset, byteCount + overlapCount, m_MaxDataSize));
				tmpOffset++;
			} else {
				DBG_MSG(DBG_TRACE,  ("H263_ppmSend::MakeFrag: cur %d tmp %d bitoffset %d byteCount %d bigger than MTU %d, bail out",
					m_CurrentOffset, tmpOffset, (pBS_info+tmpOffset)->dwBitOffset, byteCount + overlapCount, m_MaxDataSize));
				break;
			}
		}

		//Check to see if we are going to overrun the MTU, even with first fragment
		unsigned long tmpval = 0;
		if ((m_CurrentOffset+tmpOffset) >= m_pBSINFO_TRAILER->dwNumberOfPackets) {
			//I'm either here because I'm at the last fragment and everything fits
			//or I'm at the last fragment and it's too much
			tmpval = (unsigned long) ((BYTE *)m_pCurrentBuffer->m_pBuffer + 
				m_pCurrentBuffer->m_Size - (BYTE *)pFragDescrip->m_pData);
			lastFrag = TRUE;
			if (tmpval > (unsigned long) m_MaxDataSize) {
                // rajeevb - if tmpOffset is 1, there is nothing we can do and 
                // the check for tmpval > m_MaxDataSize below will discard the 
                // entire frame
                if (tmpOffset > 1) {
				    tmpOffset--;
				    //redo the overlapCount
				    if ((pBS_info+tmpOffset)->dwBitOffset%BITSPERBYTE) 
					    overlapCount = 1;
				    else
					    overlapCount = 0;
				    tmpval = (unsigned long)
						(((BYTE *)m_pCurrentBuffer->m_pBuffer) + ((pBS_info+tmpOffset)
					    ->dwBitOffset)/BITSPERBYTE - (BYTE*)pFragDescrip->m_pData + overlapCount);
				    lastFrag = FALSE;
                }
			}
		} else if (tmpOffset > 1) {
			tmpOffset--;
			//redo the overlapCount
			if ((pBS_info+tmpOffset)->dwBitOffset%BITSPERBYTE) 
				overlapCount = 1;
			else
				overlapCount = 0;
			tmpval = (unsigned long)
				(((BYTE *)m_pCurrentBuffer->m_pBuffer) + ((pBS_info+tmpOffset)
				->dwBitOffset)/BITSPERBYTE - (BYTE*)pFragDescrip->m_pData + overlapCount);
		}

		if ( tmpval > 
			(unsigned long) m_MaxDataSize ) { //whoa, the frags are > MTU!
			DBG_MSG(DBG_ERROR,  ("H263_ppmSend::MakeFrag: ERROR - Fragment size %d too large to be sent for MTU %d",
				tmpval, m_MaxDataSize));
             // Make a callback into the app to let it know what happened.
             ppm::PPMNotification(PPM_E_DROPFRAME, SEVERITY_NORMAL, NULL, 0);
			return PPMERR(PPM_E_DROPFRAME);
		}

		if (tmpOffset > 0) {
			EnterCriticalSection(&m_CritSec);
			m_pCurrentBuffer->m_NumFrags -= (tmpOffset-1);
			LeaveCriticalSection(&m_CritSec);
		}
   }

#ifdef _DEBUG
	DBG_MSG(DBG_TRACE,  ("H263PPMSend::MakeFrag Thread %ld - numfrags is %d \n",
		GetCurrentThreadId(),	m_pCurrentBuffer->m_NumFrags));
#endif

   //pb_frame
   pProfHeader->set_p( (m_pBSINFO_TRAILER->dwFlags & RTP_H263_PB_FRAME) != 0 );
   //start bits to ignore
   pProfHeader->set_sbit(pBS_info->dwBitOffset%BITSPERBYTE);

   //Source format
   pProfHeader->set_src(m_pBSINFO_TRAILER->SourceFormat);
   //clear reserved bits
   pProfHeader->set_r(0);
   //INTRA-frame coding
   pProfHeader->set_i( (m_pBSINFO_TRAILER->dwFlags & RTP_H26X_INTRA_CODED) != 0 );
   //SAC
   pProfHeader->set_s( (m_pBSINFO_TRAILER->dwFlags & RTP_H263_SAC) != 0 );
   //GOB number
   pProfHeader->set_gobn(pBS_info->GOBN);
   //macroblock address
   pProfHeader->set_mba(pBS_info->MBA);
   //quantization
   pProfHeader->set_quant(pBS_info->Quant);
   //advanced prediction mode
   pProfHeader->set_a( (m_pBSINFO_TRAILER->dwFlags & RTP_H263_AP) != 0 );
   //diff quant param
   pProfHeader->set_dbq(m_pBSINFO_TRAILER->DBQ);
   //temporal ref for B frame
   pProfHeader->set_trb(m_pBSINFO_TRAILER->TRB);
   //temporal ref for P frame
   pProfHeader->set_tr(m_pBSINFO_TRAILER->TR);
   //horiz motion vector 1
   pProfHeader->set_hmv1(pBS_info->HMV1);
   //vert motion vector 1
   pProfHeader->set_vmv1(pBS_info->VMV1);
   //horiz motion vector 2
   pProfHeader->set_hmv2(pBS_info->HMV2);
   //vert motion vector 2
   pProfHeader->set_vmv2(pBS_info->VMV2);

   m_SequenceNum++;         

   //if this is NOT the last packet.
   if (!lastFrag)
   {
	   
	//to get the EBIT, we look at the bitstream info structure for the next packet in line
	//and check out that dwBitOffset
	pProfHeader->set_ebit(BITSPERBYTE - (((BITSTREAM_INFO_H263 *)pBS_info+tmpOffset)
							->dwBitOffset%BITSPERBYTE));

	//set size field
	pFragDescrip->m_BytesOfData = (long)
			(((BYTE *)m_pCurrentBuffer->m_pBuffer) + ((pBS_info+tmpOffset)
			->dwBitOffset)/BITSPERBYTE - (BYTE*)pFragDescrip->m_pData);
	if ((pBS_info+tmpOffset)->dwBitOffset%BITSPERBYTE) 
			pFragDescrip->m_BytesOfData++;

      //set new offset, set marker bit.
#ifdef RTP_CLASS
	  pFragDescrip->m_pRTPHeader->set_m(SetMarkerBit(FALSE));
#else
	  pFragDescrip->m_pRTPHeader->m = SetMarkerBit(FALSE);
#endif
      m_CurrentOffset+=tmpOffset;

#ifdef _DEBUG
	  short seq =
#ifdef RTP_CLASS
		pFragDescrip->m_pRTPHeader->seq();
#else
		ntohs(pFragDescrip->m_pRTPHeader->seq);
#endif
	  DBG_MSG(DBG_TRACE, ("H263PPMSend::MakeFrag Thread %ld -  sending frag %d @ %x, data size %d, bitofset %d, start boundary byte is %x, end boundary byte is %x\n",
		 GetCurrentThreadId(), ntohs(seq), pFragDescrip->m_pData,
		 pFragDescrip->m_BytesOfData, pBS_info->dwBitOffset,*(BYTE *)pFragDescrip->m_pData,
		 *((BYTE *)pFragDescrip->m_pData + pFragDescrip->m_BytesOfData -1)));
#ifdef CHECKSUM
	 for (int i = 0; i < pFragDescrip->m_BytesOfData; i++)
		 sum = sum + ((BYTE*)pFragDescrip->m_pData)[i];
	  DBG_MSG(DBG_TRACE, ("H263PPMSend::MakeFrag Thread %ld -  frag %d, checksum %x\n",
		  GetCurrentThreadId(), ntohs(seq), sum));
	  sum = '\0';
#endif
#endif

   }
   else  //if this IS the last packet.
   {
	   	pProfHeader->set_ebit(0);

       //set size field
		pFragDescrip->m_BytesOfData = (long)
			(((BYTE *)m_pCurrentBuffer->m_pBuffer + 
			m_pCurrentBuffer->m_Size) - (BYTE *)pFragDescrip->m_pData);

	  //set new offset, set marker bit.
      m_CurrentOffset = 0;
	  short seq;

#ifdef RTP_CLASS
	  pFragDescrip->m_pRTPHeader->set_m(SetMarkerBit(TRUE));
	  seq = pFragDescrip->m_pRTPHeader->seq();
#else
	  pFragDescrip->m_pRTPHeader->m = SetMarkerBit(TRUE);
	  seq = ntohs(pFragDescrip->m_pRTPHeader->seq);
#endif
      
      //reset Current Buffer.
      m_pCurrentBuffer = NULL;

#ifdef _DEBUG
	  DBG_MSG(DBG_TRACE, ("H263PPMSend::MakeFrag Thread %ld -  sending LAST frag %d @ %x, data size %d, bitofset %d\n",
			GetCurrentThreadId(), ntohs(seq),pFragDescrip->m_pData,
			pFragDescrip->m_BytesOfData, pBS_info->dwBitOffset));
#ifdef CHECKSUM
	 for (int i = 1; i < pFragDescrip->m_BytesOfData -1; i++)
		 sum = sum + (BYTE*)pFragDescrip->m_BytesOfData[i];
	  DBG_MSG(DBG_TRACE, ("H263PPMSend::MakeFrag Thread %ld -  frag %d @ %x, checksum %x\n",
		  GetCurrentThreadId(), ntohs(seq), sum));
	  sum = '\0';
#endif
#endif

   }  

   return NOERROR;
}

//////////////////////////////////////////////////////////////////////////////////////////
//ReadProfileHeader: Given a buffer as type void, returns the data for a profile header.  
//					Does nothing for the Generic case.  Intended for overrides for various 
//					payloads.
//////////////////////////////////////////////////////////////////////////////////////////
void *H263_ppmSend::ReadProfileHeader(void *pProfileHeader)
{
	H263_Header *pBaseHeader;
	pBaseHeader = (H263_Header *) pProfileHeader;

	return pBaseHeader->header_data();
}

//////////////////////////////////////////////////////////////////////////////////////////
//ReadProfileHeaderSize: Given a pointer to a prof header, returns the size for that header.  
//					Intended for overrides for various payloads. If the pointer is not 
//					provided (as used for initialization, etc) m_ProfileHeaderSize is returned,
//					which, for H.263 is the size of the large profile header (Mode C).
//					Otherwise, the exact size of the header for that mode is returned,
//					since the header pointer is used to retrieve the size for itself.
//////////////////////////////////////////////////////////////////////////////////////////
int H263_ppmSend::ReadProfileHeaderSize(void *pProfileHeader) 
{
	H263_Header *pBaseHeader;

	if (!pProfileHeader)
		return ppm::ReadProfileHeaderSize();
	pBaseHeader = (H263_Header *) pProfileHeader;
	return pBaseHeader->header_size();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\imcrcv.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: g723rcv.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#ifndef IMCRCV_H
#define IMCRCV_H

#include "ppmrcv.h"
#include "ppmclsid.h"
#include "IMC.h"

#define IMC_BUFFER_SIZE 5000

class IMC_ppmReceive : public ppmReceive
{

public:

IMC_ppmReceive(IUnknown* pUnkOuter, 
				IUnknown** ppUnkInner);
~IMC_ppmReceive();

DECLARE_CREATEPROC()

STDMETHODIMP_( const CLSID& ) GetCLSID( void ) const {return CLSID_IMCPPMReceive;}

STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{return CUnknown::QueryInterface(riid, ppvObj);}

STDMETHODIMP GetInterface( REFIID riid, LPVOID FAR* ppvObj )
{return ppmReceive::GetInterface( riid, ppvObj );}

STDMETHODIMP_( ULONG )AddRef( void )
{return CUnknown::AddRef();}

STDMETHODIMP_( ULONG )Release( void )
{return CUnknown::Release();}

//////////////////////////////////////////////////////////////////////////////////////////
//TimeToProcessMessages:
//////////////////////////////////////////////////////////////////////////////////////////
virtual BOOL TimeToProcessMessages(FragDescriptor *pFragDescrip, MsgHeader *pMsgHdr);
 
//////////////////////////////////////////////////////////////////////////////////////////
//CheckMessageComplete: 
//////////////////////////////////////////////////////////////////////////////////////////
virtual BOOL CheckMessageComplete(MsgHeader *pMsgHdr); 
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\h263snd.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: h263snd.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#ifndef H263SND_H
#define H263SND_H

#include "ppmsnd.h"
#include "ppmclsid.h"
#include "h263.h"

class H263_ppmSend : public ppmSend
{
private:
FreeList        *m_pH263Headers;

protected:

BSINFO_TRAILER	  *m_pBSINFO_TRAILER;

////////////////////////////////////////////////////////////////////////////////////
// PPMSend Functions (Overrides)
////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
//InitFragStatus: Virtual. Initializes values needed for fragmenting.
//////////////////////////////////////////////////////////////////////////////////////////
virtual HRESULT InitFragStatus(MsgDescriptor *pMsgDescrip);

//////////////////////////////////////////////////////////////////////////////////////////
//AllocFrag: Virtual.  Allcates memory for FragDescriptor and all things it points to.
//////////////////////////////////////////////////////////////////////////////////////////
//lsc - Memory for the profile headers for H.263 is not done here, but when the header
// mode is known, in MakeFrag... So there is no overriden AllocFrag for H.263 PPM
//virtual FragDescriptor * AllocFrag();  

//////////////////////////////////////////////////////////////////////////////////////////
//DeleteFrag: Virtual This function does the opposite of AllocFrag, it deletes any memory allocated
//            by AllocFrag.
//lsc - virtual FreeProfileHeader is used in ppmSend's DeleteFrag, so no overriding here either
//////////////////////////////////////////////////////////////////////////////////////////
//virtual void DeleteFrag(FragDescriptor *pFragDescrip, HRESULT Error);
 
//////////////////////////////////////////////////////////////////////////////////////////
//MakeFrag: Virtual. This function should get the next fragment from the buffer and fill in the
//          RTP header and payload header. 
//////////////////////////////////////////////////////////////////////////////////////////
virtual HRESULT   MakeFrag(FragDescriptor *pFragDescrip);  //fills in fields, including data of fragment class.

//////////////////////////////////////////////////////////////////////////////////////////
//FreeProfileHeader: Given a buffer as type void, frees up a profile header.  
//////////////////////////////////////////////////////////////////////////////////////////
virtual void FreeProfileHeader(void *pBuffer);

//////////////////////////////////////////////////////////////////////////////////////////
//ReadProfileHeader: Given a buffer as type void, returns the data for a profile header.  
//					Does nothing for the Generic case.  Intended for overrides for various 
//					payloads.
//////////////////////////////////////////////////////////////////////////////////////////
virtual void *ReadProfileHeader(void *pProfileHeader);

////////////////////////////////////////////////////////////////////////////////////
// PPM Functions (Overrides)
////////////////////////////////////////////////////////////////////////////////////
virtual int ReadProfileHeaderSize(void *pProfileHeader = NULL);

public:
				
H263_ppmSend(IUnknown* pUnkOuter, IUnknown** ppUnkInner);
~H263_ppmSend();

DECLARE_CREATEPROC()

STDMETHODIMP_( const CLSID& ) GetCLSID( void ) const {return CLSID_H263PPMSend;}

STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{return CUnknown::QueryInterface(riid, ppvObj);}

STDMETHODIMP GetInterface( REFIID riid, LPVOID FAR* ppvObj )
{return ppmSend::GetInterface( riid, ppvObj );}

STDMETHODIMP_( ULONG )AddRef( void )
{return CUnknown::AddRef();}

STDMETHODIMP_( ULONG )Release( void )
{return CUnknown::Release();}

}; // Parameters to ppmSend -> H263 Payload type, size of payload header, frequency,  outer arg, inner arg
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\lh.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: lh.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#ifndef LH_H
#define LH_H

#ifdef __cplusplus

typedef struct : public PPMSESSPARAM_T
{
	DWORD msec;
} LHSESSPARAM_T;

#else /* __cplusplus */

typedef struct {
    PPMSESSPARAM_T ppmSessParam;
	DWORD msec;
} LHSESSPARAM_T;

#endif /* __cplusplus */

#endif // LH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\imcsnd.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: g723snd.cpp
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#include "IMCsnd.h"

IMC_ppmSend::IMC_ppmSend(IUnknown* pUnkOuter, 
						   IUnknown** ppUnkInner) : 
		ppmSend(IMC_PT, 0, 
				8000, pUnkOuter, ppUnkInner),
        
        m_dwLastTimeStamp(0)
{
}

IMC_ppmSend::~IMC_ppmSend()
{
}

IMPLEMENT_CREATEPROC(IMC_ppmSend);

//////////////////////////////////////////////////////////////////////////////////////////
//SetMarkerBit: Determines whether to set the marker bit or not.  lastPacket is TRUE if
//				this is the last packet of the frame; FALSE if not.	 With audio, we don't
//				don't care about fragmentation, just the start of a talkspurt.
//////////////////////////////////////////////////////////////////////////////////////////
BOOL IMC_ppmSend::SetMarkerBit(BOOL lastPacket)
{
	return m_markTalkSpurt;
}

//////////////////////////////////////////////////////////////////////////////////////////
//MakeTimeStamp: Generate a time stamp based on the frequency specified in the Profile Spec.
//////////////////////////////////////////////////////////////////////////////////////////
DWORD IMC_ppmSend::MakeTimeStamp(MsgDescriptor* pMsgDescrip, 
								BOOL bStartStream,
								BOOL bUseInputTime)
{

#ifndef TIMESTAMP_OFF 

       DWORD ThisTimeStamp;
       DWORD CurTime = timeGetTime();
	   DWORD delta;
       DWORD epsilon;

    
    if (bUseInputTime) CurTime = pMsgDescrip->m_TimeStamp;

    // calculate the time span encoded in this packet
    delta = 240 * CountFrames((char *) pMsgDescrip->m_pBuffer, pMsgDescrip->m_Size) / (m_Frequency/1000);
    epsilon = delta/2;

    // init, do it here so it is set when we get the first packet
    // not at init time, they may be significantly different
	// Generate our first time stamp based on the current time.
    if (m_dwStartTime == 0)
    {
		// if the first packet we receive is a drop or silence then the delta will
		// be zero.  We just won't do anything until we receive valid data.
		if (delta != 0)
		{
			m_dwStartTime = CurTime;
			m_dwLastTime = m_dwStartTime -  delta;
			ThisTimeStamp = (((CurTime - m_dwStartTime) + (epsilon)) / delta) * delta * (m_Frequency/1000);
		}
	}
    else
	if (bStartStream)
	{
		// bStartStream will be set if this is the first packet after a break in a 
		// data stream.  We need to get our time stamps back on track, so we'll generate a time
		// based on the current time.  This case can happen if for some reason the capture device
		// gets starved or we are in half duplex and we are switching to talk mode.
		if (delta != 0)
		{
			ThisTimeStamp = (((CurTime - m_dwStartTime) + (epsilon)) / delta) * delta * (m_Frequency/1000);
		}
		else
		{
			// we don't have a valid delta, so we'll make do with the previous delta
			ThisTimeStamp = (((CurTime - m_dwStartTime) + (epsilon)) / m_dwLastDelta) * m_dwLastDelta * (m_Frequency/1000);
			ThisTimeStamp -= m_dwLastDelta * (m_Frequency/1000);
		}
    }
	else
	{
	    // if we are in a continuous audio data stream, then we just want to increment our timestamp
		// for this data packet.  We don't want to use the current time because we don't know how long
		// it took from the time the data was acutally captured to the time we got it.  We have to rely
		// on the person feeding us data to let us know more information about the data stream.
		ThisTimeStamp = m_dwLastTimeStamp + 240 * CountFrames((char *) pMsgDescrip->m_pBuffer, pMsgDescrip->m_Size);
	}

	m_dwLastTimeStamp = ThisTimeStamp;
	m_dwLastTime = CurTime;
	if (delta != 0)
	{
		m_dwLastDelta = delta;
	}
    return ThisTimeStamp;
#else
//I changed this because the times I was getting were widely spaced.  When I was in debugging
//mode.
static DWORD CurTime = 0;
CurTime++;
#endif 

return CurTime;
}


int IMC_ppmSend::CountFrames(char *ipBuffer, int len)
{
    int Count = 0;
    int Delta = 0;
    int Length = len;
    LPBYTE pBuffer = (LPBYTE) ipBuffer;

    while(Length >= 4)
    {
        if (pBuffer[0] & 2)  // silence frame
        {
            if (Length < 4)  // invalid frame
            {
                break;
            }
            Delta = 4;
			//TTDBG(ghISRInst, TT_NOTIFY, "Dejitter::CountFrames - found silence frame");

        } 

        else               // 64 byte frame (8kHz)
        { 
            if (Length < 64) // invalid frame
            {
                break;
            }
            Delta = 24;
        }

        Count++;
        pBuffer += Delta;
        Length -= Delta;
   }
   return Count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\iv41rcv.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: iv41rcv.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#include "iv41rcv.h"

IV41_ppmReceive::IV41_ppmReceive(IUnknown* pUnkOuter, IUnknown** ppUnkInner)
	: ppmReceive(-1, IV41_BUFFER_SIZE, 0, pUnkOuter, ppUnkInner)
{
   //m_reg_NumFragDescriptors = 3000;	 Commented as base class high water mark is set pretty high HK
}

IV41_ppmReceive::~IV41_ppmReceive()
{
}

IMPLEMENT_CREATEPROC(IV41_ppmReceive);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\imcsnd.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: g723snd.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#ifndef IMCSND_H
#define IMCSND_H

#include "ppmsnd.h"
#include "ppmclsid.h"
#include "IMC.h"

class IMC_ppmSend : public ppmSend
{
    DWORD m_dwLastTimeStamp;
    DWORD m_dwStartTime;
    DWORD m_dwLastTime;
    DWORD m_dwLastDelta;
protected:
//////////////////////////////////////////////////////////////////////////////////////////
//CountFrames: Determine how many frames are in the buffer
//////////////////////////////////////////////////////////////////////////////////////////
int CountFrames(char *pBuffer, int len);

////////////////////////////////////////////////////////////////////////////////////
// PPMSend Functions (Overrides)
////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
//SetMarkerBit: Determines whether to set the marker bit or not.  lastPacket is TRUE if
//				this is the last packet of the frame; FALSE if not.
//////////////////////////////////////////////////////////////////////////////////////////
virtual BOOL SetMarkerBit(BOOL lastPacket);

//////////////////////////////////////////////////////////////////////////////////////////
//MakeTimeStamp: Generate a time stamp
//////////////////////////////////////////////////////////////////////////////////////////
virtual DWORD MakeTimeStamp(MsgDescriptor* pMsgDescrip, BOOL bStartStream, BOOL bUseInputTime);

public:
				
IMC_ppmSend(IUnknown* pUnkOuter, IUnknown** ppUnkInner);
~IMC_ppmSend();

DECLARE_CREATEPROC()

STDMETHODIMP_( const CLSID& ) GetCLSID( void ) const {return CLSID_IMCPPMSend;}

STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{return CUnknown::QueryInterface(riid, ppvObj);}

STDMETHODIMP GetInterface( REFIID riid, LPVOID FAR* ppvObj )
{return ppmSend::GetInterface( riid, ppvObj );}

STDMETHODIMP_( ULONG )AddRef( void )
{return CUnknown::AddRef();}

STDMETHODIMP_( ULONG )Release( void )
{return CUnknown::Release();}

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\iv41rcv.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: iv41rcv.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#ifndef IV41RCV_H
#define IV41RCV_H

#include "ppmrcv.h"
#include "ppmclsid.h"

//#define IV41_BUFFER_SIZE 231000
#define IV41_BUFFER_SIZE 87000

class IV41_ppmReceive : public ppmReceive
{

public:

IV41_ppmReceive(IUnknown* pUnkOuter, IUnknown** ppUnkInner);
~IV41_ppmReceive();

DECLARE_CREATEPROC()

STDMETHODIMP_( const CLSID& ) GetCLSID( void ) const {return CLSID_IV41PPMReceive;}

STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{return CUnknown::QueryInterface(riid, ppvObj);}

STDMETHODIMP GetInterface( REFIID riid, LPVOID FAR* ppvObj )
{return ppmReceive::GetInterface( riid, ppvObj );}

STDMETHODIMP_( ULONG )AddRef( void )
{return CUnknown::AddRef();}

STDMETHODIMP_( ULONG )Release( void )
{return CUnknown::Release();}

};  // Parameters to ppmReceive -> IV41 Payload type, size of payload header, outer arg, inner arg
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\iv41snd.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: iv41snd.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#include "iv41snd.h"


IV41_ppmSend::IV41_ppmSend(IUnknown* pUnkOuter, IUnknown** ppUnkInner)
    : ppmSend(-1, 0, 8000, pUnkOuter, ppUnkInner)
{
   //m_reg_NumFragDescriptors = 150; Commented as base class high water mark is set pretty high HK
}

IV41_ppmSend::~IV41_ppmSend()
{
}


IMPLEMENT_CREATEPROC(IV41_ppmSend);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\iv41snd.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: iv41snd.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#ifndef IV41SND_H
#define IV41SND_H

#include "ppmsnd.h"
#include "ppmclsid.h"

class IV41_ppmSend : public ppmSend
{

public:

IV41_ppmSend(IUnknown* pUnkOuter, IUnknown** ppUnkInner);
~IV41_ppmSend();

DECLARE_CREATEPROC()

STDMETHODIMP_( const CLSID& ) GetCLSID( void ) const {return CLSID_IV41PPMSend;}

STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{return CUnknown::QueryInterface(riid, ppvObj);}

STDMETHODIMP GetInterface( REFIID riid, LPVOID FAR* ppvObj )
{return ppmSend::GetInterface( riid, ppvObj );}

STDMETHODIMP_( ULONG )AddRef( void )
{return CUnknown::AddRef();}

STDMETHODIMP_( ULONG )Release( void )
{return CUnknown::Release();}

}; // Parameters to ppmSend -> IV41 Payload type, size of payload header, frequency,  outer arg, inner arg
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\lhsnd.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: lhsnd.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#ifndef LHSND_H
#define LHSND_H

#include "ppmsnd.h"
#include "ppmclsid.h"
#include "lh.h"

class LH_ppmSend : public ppmSend
{
    DWORD m_dwLastTimeStamp;
    DWORD m_dwStartTime;
    DWORD m_dwLastTime;
protected:
	DWORD m_delta;				   // how many milliseconds of data in each buffer

//////////////////////////////////////////////////////////////////////////////
//   IPPMSend Functions (Overrides)
//////////////////////////////////////////////////////////////////////////////

STDMETHOD(SetSession)(THIS_ PPMSESSPARAM_T *pSessparam);

////////////////////////////////////////////////////////////////////////////////////
// PPMSend Functions (Overrides)
////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
//SetMarkerBit: Determines whether to set the marker bit or not.  lastPacket is TRUE if
//				this is the last packet of the frame; FALSE if not.
//////////////////////////////////////////////////////////////////////////////////////////
virtual BOOL SetMarkerBit(BOOL lastPacket);

//////////////////////////////////////////////////////////////////////////////////////////
//MakeTimeStamp: Generate a time stamp
//////////////////////////////////////////////////////////////////////////////////////////
virtual DWORD MakeTimeStamp(MsgDescriptor* pMsgDescrip, BOOL bStartStream, BOOL bUseInputTime);

public:
				
LH_ppmSend(IUnknown* pUnkOuter, IUnknown** ppUnkInner);
~LH_ppmSend();

DECLARE_CREATEPROC()

STDMETHODIMP_( const CLSID& ) GetCLSID( void ) const {return CLSID_LHPPMSend;}

STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{return CUnknown::QueryInterface(riid, ppvObj);}

STDMETHODIMP GetInterface( REFIID riid, LPVOID FAR* ppvObj )
{return ppmSend::GetInterface( riid, ppvObj );}

STDMETHODIMP_( ULONG )AddRef( void )
{return CUnknown::AddRef();}

STDMETHODIMP_( ULONG )Release( void )
{return CUnknown::Release();}

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\llist.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation.
//
//
//  Module Name: llist.cpp
//  Abstract:    Implementation of thread-safe, ordered , doubly-linked list.
//				 Checks for wrap in sequence number, per RTP requirements.
//
//	Implementation:
//				 Uses head and tail sentinals (preallocated list items) to
//				 eliminate empty-list case in insertion and removal logic
//				 (because every non-sentinal item is guaranteed to have a
//				 prev/next item).
//
//	Environment: MSVC 4.0
/////////////////////////////////////////////////////////////////////////////////

// $Header:   R:/rtp/src/ppm/llist.CPv   1.10   31 Jan 1997 23:32:38   CPEARSON  $

#include <limits.h>	// ULONG_MAX
#include "llist.h"
#include "ppmerr.h"
#include "wrap.h"


/////////////////////////////////////////////////////////////
// Constructor: Link head and tail sentinals such that list
// is cyclically terminated in either direction.  We
// recognize sentinals by these self-references.
LList::LList() :
	m_headSentinal(&m_tailSentinal, &m_headSentinal, 0),
	m_tailSentinal(&m_tailSentinal, &m_headSentinal, ULONG_MAX)
{;}


/////////////////////////////////////////////////////////////
// AddToList: Adds an item to the list in the correct spot.
// Starts search from the end of list.
HRESULT LList::AddToList(LListItem* pNew, DWORD dwSeqNum)
{
	THREADSAFEENTRY();

	if (! pNew)
	{
		// Invalid parameter.
		return PPMERR(PPM_E_INVALID_PARAM);
	}
	
	ASSERT(pNew->IsUnlinked());

	// Set item sequence number
	pNew->SetSeqNum(dwSeqNum);

	#ifdef _DEBUG
		if (! IsValid())
		{
			// corrupt list
			return PPMERR(PPM_E_CORRUPTED);
		}
	#endif

	LListItem* pPrev;

	// Search from end of list to find an item which is not greater
	// then new item.  Found item _may_ be equal to new item, or it may
	// be the head sentinal.  We depend on head sentinal having zero
	// sequence number to terminate loop.
	for (	pPrev = GetLastItem_();
			LongWrapGt(pPrev->GetSeqNum(), pNew->GetSeqNum());
			pPrev = pPrev->GetPrev())
	{;}

	if (   (pNew->GetSeqNum() == pPrev->GetSeqNum())
		&& ! pPrev->IsHeadSentinal())
	{
		// Item is not head, and is a duplicate; return error.  Must allow
		// client to duplicate head sentinal sequence number (zero).
		return PPMERR(PPM_E_DUPLICATE);
	}

	// Insert new item after previous, which may be head sentinal
	pNew->LinkAfter(pPrev);

	return NOERROR;
}


/////////////////////////////////////////////////////////////
// TakeFromList: Removes the item with the lowest sequence
// number (so removes from the head).
void* LList::TakeFromList()
{
	THREADSAFEENTRY();

	#ifdef _DEBUG
		if (! IsValid())
		{
			// corrupt list
			return NULL;
		}
	#endif

	LListItem* pItem = GetFirstItem_();
	
	if (pItem->IsTailSentinal())
	{
		// empty list
		return NULL;
	}
	
	pItem->Unlink();

	return pItem;
}

// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\lhrcv.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: lhrcv.cpp
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#include "ppmerr.h"
#include "lhrcv.h"
#include "debug.h"


LH_ppmReceive::LH_ppmReceive(IUnknown* pUnkOuter, 
								 IUnknown** ppUnkInner)
	: ppmReceive(-1, LH_BUFFER_SIZE, 0, pUnkOuter, ppUnkInner)
{
	m_FirstAudioChunk = TRUE;
	m_reg_DeltaTime          = 0;    //in miliseconds time to determine a packet is stale
}

LH_ppmReceive::~LH_ppmReceive()
{
}

IMPLEMENT_CREATEPROC(LH_ppmReceive);

//////////////////////////////////////////////////////////////////////////////////////////
//TimeToProcessMessages: Any time a packet comes in, it's time to process messages
//////////////////////////////////////////////////////////////////////////////////////////
BOOL LH_ppmReceive::TimeToProcessMessages(FragDescriptor *pFragDescrip, MsgHeader *pMsgHdr)
{
   return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////////
//ProcessMessages: 
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT LH_ppmReceive::ProcessMessages(void)
{

	HRESULT rval;
	int retVal;

	EnterCriticalSection(&m_CritSec);

	while(m_pMsgHeadersHead != NULL)
    {
		retVal = CheckMessageComplete(m_pMsgHeadersHead);
		switch( retVal )
		{
		  case TRUE:
		  {
			
			if FAILED(rval = PrepMessage(TRUE)) 
			{
				DBG_MSG(DBG_ERROR, ("LH_ppmReceive::ProcessMessages: ERROR - PrepMessage failed"));
				LeaveCriticalSection(&m_CritSec);
				return rval;
		    }
			else
				break;
          }
		  case FALSE:
		  {
			
			if FAILED(rval = PrepMessage(FALSE)) 
			{
				DBG_MSG(DBG_ERROR, ("LH_ppmReceive::ProcessMessages: ERROR - PrepMessage failed"));
				LeaveCriticalSection(&m_CritSec);
				return rval;
			}
			else
				break;
		  }
		  case DO_NOT_PROCESS:
		  {
                DBG_MSG(DBG_TRACE, ("G711A_ppmReceive::ProcessMessages: CheckMessageComplete returned DO_NOT_PROCESS"));
	            LeaveCriticalSection(&m_CritSec);
                return NOERROR;
		  }
		  default:
		  {
                DBG_MSG(DBG_TRACE, ("G711A_ppmReceive::ProcessMessages: CheckMessageComplete returned unknown"));
	            LeaveCriticalSection(&m_CritSec);
				return NOERROR;
		  }
	    }
    }
   //List is empty
   LeaveCriticalSection(&m_CritSec);
   return NOERROR;
}
          
//////////////////////////////////////////////////////////////////////////////////////////
//LH_ppmReceive::CheckMessageComplete: //return value is int
//////////////////////////////////////////////////////////////////////////////////////////
int LH_ppmReceive::CheckMessageComplete(MsgHeader *pMsgHdr) 
{
	//if there is no header then return false.
    if (pMsgHdr  == NULL)
    {
        DBG_MSG(DBG_ERROR, ("LH_ppmReceive::CheckMessageComplete: ERROR - pMsgHdr == NULL"));
        return FALSE;
    }
     
    //should there be a critical section in this function.  What about wraps?
     
     
    if(m_FirstAudioChunk)                      // handle very first chunk 
    {
         m_FirstAudioChunk = FALSE;            //Send it up, no matter what
     
         return TRUE;
    }
     
    if (m_GlobalLastSeqNum+1 == pMsgHdr->m_pFragList->FirstSeqNum())
	// Is this message in order ?
    {
          return TRUE;
    }
     
    if( CheckMessageStale(pMsgHdr) ||    // Check if we timed out
		m_PacketsHold >= 8) /* BUGBUG this 8 should be dynamic
							   but right now I know that I can have
							   only 8 buffers per RPH in the RTP
							   source filter, and if we keep 8 here
							   we get into a deadlock.
							   This is different from video because
							   in video the messages are already
							   in a queue, and here we are about
							   to request one */
    {
         return TRUE;                              // Send it up as we have waited long enough
    }
     
    return DO_NOT_PROCESS;                    // Continue and wait for next iteration
     
}



//////////////////////////////////////////////////////////////////////////////////////////
// PartialMessageHandler: deals with partial messages
// This overriden version is used by FlushData from ppmrcv.cpp
// Unlike partial message handlers for video, this function sends up all the
// pending data in the audio queues
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT LH_ppmReceive::PartialMessageHandler(MsgHeader *pMsgHdr)
{
	return (DataCopy( pMsgHdr ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\lhrcv.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: lhrcv.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#ifndef LHRCV_H
#define LHRCV_H

#include "ppmrcv.h"
#include "ppmclsid.h"
#include "lh.h"

#define LH_BUFFER_SIZE 5000
#define DO_NOT_PROCESS		5

class LH_ppmReceive : public ppmReceive
{
private:
	BOOL m_FirstAudioChunk;

public:

LH_ppmReceive(IUnknown* pUnkOuter, 
				IUnknown** ppUnkInner);
~LH_ppmReceive();

DECLARE_CREATEPROC()

STDMETHODIMP_( const CLSID& ) GetCLSID( void ) const {return CLSID_LHPPMReceive;}

STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{return CUnknown::QueryInterface(riid, ppvObj);}

STDMETHODIMP GetInterface( REFIID riid, LPVOID FAR* ppvObj )
{return ppmReceive::GetInterface( riid, ppvObj );}

STDMETHODIMP_( ULONG )AddRef( void )
{return CUnknown::AddRef();}

STDMETHODIMP_( ULONG )Release( void )
{return CUnknown::Release();}

//////////////////////////////////////////////////////////////////////////////////////////
//TimeToProcessMessages:
//////////////////////////////////////////////////////////////////////////////////////////
virtual BOOL TimeToProcessMessages(FragDescriptor *pFragDescrip, MsgHeader *pMsgHdr);
 
//////////////////////////////////////////////////////////////////////////////////////////
//CheckMessageComplete: 
//////////////////////////////////////////////////////////////////////////////////////////
virtual BOOL CheckMessageComplete(MsgHeader *pMsgHdr); 

//////////////////////////////////////////////////////////////////////////////////////////
//ProcessMessages: 
//////////////////////////////////////////////////////////////////////////////////////////
virtual HRESULT ProcessMessages(void);

//////////////////////////////////////////////////////////////////////////////////////////
//PartialMessageHandler: deals with partial messages
//////////////////////////////////////////////////////////////////////////////////////////
virtual HRESULT PartialMessageHandler(MsgHeader *pMsgHdr);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\llist.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation.
//
//
//  Module Name: llist.h
//  Abstract:    Header file to define ordered doubly-linked linked list,
//				 with test for sequence number wrap.
//	Environment: MSVC 4.0
/////////////////////////////////////////////////////////////////////////////////

// $Header:   R:/rtp/src/ppm/llist.h_v   1.13   07 Feb 1997 17:27:48   CPEARSON  $

/////////////////////////////////////////////////////////////////////////////////
//NOTE: Defines a general purpose, thread-safe list class.  To use, derive a
//		class from LListItem to hold the objects you intended to collect.
//		Instantiate an LList object, then call LList::AddToList and
//		LList::TakeFromList to add and remove list items.  There is no limit
//		on the size of the list.
/////////////////////////////////////////////////////////////////////////////////

#ifndef _LLIST_H_
#define _LLIST_H_

#include <wtypes.h>		// HRESULT
#include "thrdsafe.h"	// CThreadSafe
#include "debug.h"		// ASSERT

////////////////////////////////////////////////////////////////////////
// class LListItem: base class from which to derive classes to be
// contained by class LList.
class LListItem
{
	friend class LList;

	// private members
	LListItem*		m_pNext;
	LListItem*		m_pPrev;
	DWORD			m_dwSeqNum;

public:
	LListItem() :
	  m_pNext(NULL), m_pPrev(NULL), m_dwSeqNum(0) {;}

	void SetSeqNum(DWORD dwSeqNum)
		{ m_dwSeqNum = dwSeqNum; }

	DWORD GetSeqNum() const
		{ return m_dwSeqNum; }

protected:

	LListItem(LListItem* pNext, LListItem* pPrev, DWORD dwSeqNum) :
		m_pNext(pNext), m_pPrev(pPrev), m_dwSeqNum(dwSeqNum) {;}

	// Non-virtual dtors are dangerous, because derived class dtors aren't
	// called, so only make this one visible to derived classes.  This also
	// ensures that LList implementation doesn't delete queue entries.
	LListItem::~LListItem() {;}

	LListItem* GetNext() const
		{ return m_pNext; }

	LListItem* GetPrev() const
		{ return m_pPrev; }

	void LinkAfter(LListItem* const pPrev)
	{
		m_pNext = pPrev->m_pNext;
		m_pNext->m_pPrev = this;
		m_pPrev = pPrev;
		pPrev->m_pNext = this;
	}

	void Unlink()
	{
		m_pNext->m_pPrev = m_pPrev;
		m_pPrev->m_pNext = m_pNext;
		m_pNext = NULL;
		m_pPrev = NULL;
	}

	BOOL IsUnlinked() const
		{ return ! m_pNext && ! m_pPrev; }

	BOOL IsHeadSentinal() const
		{ return m_pPrev == this; }

	BOOL IsTailSentinal() const
		{ return m_pNext == this; }
};


////////////////////////////////////////////////////////////////////////
// class LList: Defines a thread-safe, doubly-linked, ordered list of
// pointers to LListItem objects.
class LList : public CThreadSafe
{
	// private members
	LListItem	m_headSentinal;
	LListItem	m_tailSentinal;

	LList(const LList&); // hide unsupported copy ctor

protected:

	// protected methods all assume list is locked
	LListItem* GetFirstItem_() const
		{ return m_headSentinal.GetNext(); }

	LListItem* GetLastItem_() const
		{ return m_tailSentinal.GetPrev(); }

	BOOL IsValid_() const
	{
		return
		       (m_headSentinal.IsHeadSentinal())
			&& (m_tailSentinal.IsTailSentinal())
			&& (
					  ((GetFirstItem_()->IsTailSentinal())
					&& (GetLastItem_()->IsHeadSentinal()))
				||
					  ((! GetFirstItem_()->IsTailSentinal())
					&& (! GetLastItem_()->IsHeadSentinal()))
				);
	}

public:

	// Constructor
	LList();

	// Virtual destructor to ensure correct destruction of derivatives.
	virtual ~LList() {;}

	// Insert item into list in ascending sequence on dwSeqNum.  Returns
	// E_DUPLICATE and does not insert the item if an item with
	// dwSeqNum is already in the list.  Insertion search is from
	// end of list.
	HRESULT AddToList(LListItem* pItem, DWORD dwSeqNum);

	// Remove head item from list, returning NULL on failure.
	void* TakeFromList();

	// Returns TRUE if list is not corrupt
	BOOL IsValid() const
		{ THREADSAFEENTRY(); return IsValid_();	}

	// Returns TRUE if list is empty
	BOOL Is_Empty() const
		{ return GetFirstItem_()->IsTailSentinal(); }

	// Returns pointer to first item in list.  Caller should Lock() the
	// list while using pointer, unless sure that the list can't be updated.
	void* GetFirst() const
		{ THREADSAFEENTRY(); return Is_Empty() ? NULL : GetFirstItem_(); }

	LListItem* NextItem(const LListItem* pItem) const
	{
		THREADSAFEENTRY();

		if ((! IsValid_()) || Is_Empty())
		{
			return NULL;
		}

		return pItem ? pItem->GetNext() : GetFirstItem_();
	}

	// Returns sequence number of first item in list.
	DWORD FirstSeqNum() const
	{
		THREADSAFEENTRY();
		ASSERT(! Is_Empty());
		return GetFirstItem_()->GetSeqNum();
	}

	// Returns sequence number of last item in list.
	DWORD LastSeqNum() const
	{
		THREADSAFEENTRY();
		ASSERT(! Is_Empty());
		return GetLastItem_()->GetSeqNum();
	}

	// Returns inclusive span between sequence numbers of last and first
	// items in list.
	DWORD SeqNumSpan() const
	{
                // bug fix: didn't account for wrapping of sequence numbers
                // DWORD is an unsigned long so max dword is ULONG_MAX
		THREADSAFEENTRY();
                DWORD LastNum = LastSeqNum();
                DWORD FirstNum = FirstSeqNum();
                return (LastNum > FirstNum) ? 
                            (LastNum - FirstNum + 1) : 
                            (ULONG_MAX - LastNum + FirstNum + 2);
	}
};

#endif	// _LLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\lhsnd.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: lhsnd.cpp
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#include "lhsnd.h"
#include "ppmerr.h"
#include "debug.h"

LH_ppmSend::LH_ppmSend(IUnknown* pUnkOuter, IUnknown** ppUnkInner) : 
		ppmSend(-1, 0, 8000, pUnkOuter, ppUnkInner), m_delta(120),
        
        m_dwLastTimeStamp(0)
{
}

LH_ppmSend::~LH_ppmSend()
{
}

IMPLEMENT_CREATEPROC(LH_ppmSend);

//////////////////////////////////////////////////////////////////////////////
//   IPPMSend Functions (Overrides)
//////////////////////////////////////////////////////////////////////////////

HRESULT LH_ppmSend::SetSession(PPMSESSPARAM_T *pSessparam)
{
    HRESULT hr = ppmSend::SetSession(pSessparam);

    LHSESSPARAM_T *pLHSessparam = (LHSESSPARAM_T *)pSessparam;

	if (pLHSessparam != NULL && pLHSessparam->msec > 0)
		m_delta = pLHSessparam->msec;
	else  {
		DBG_MSG(DBG_ERROR, ("LH_ppmSend::SetSession: ERROR - invalid session parameters"));
		return PPMERR(PPM_E_INVALID_PARAM);
	}

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//   PPMSend Functions (Overrides)
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
//SetMarkerBit: Determines whether to set the marker bit or not.  lastPacket is TRUE if
//				this is the last packet of the frame; FALSE if not.	 With audio, we don't
//				don't care about fragmentation, just the start of a talkspurt.
//////////////////////////////////////////////////////////////////////////////////////////
BOOL LH_ppmSend::SetMarkerBit(BOOL lastPacket)
{
	return m_markTalkSpurt;
}

//////////////////////////////////////////////////////////////////////////////////////////
//MakeTimeStamp: Generate a time stamp based on the frequency specified in the Profile Spec.
//////////////////////////////////////////////////////////////////////////////////////////
DWORD LH_ppmSend::MakeTimeStamp(MsgDescriptor* pMsgDescrip, 
								BOOL bStartStream,
								BOOL bUseInputTime)
{

#ifndef TIMESTAMP_OFF 

       DWORD ThisTimeStamp;
       DWORD CurTime = timeGetTime();
       DWORD epsilon;

    if (bUseInputTime) CurTime = pMsgDescrip->m_TimeStamp;

    // calculate the time span encoded in this packet
    epsilon = m_delta/2;

    // init, do it here so it is set when we get the first packet
    // not at init time, they may be significantly different
	// Generate our first time stamp based on the current time.
    if (m_dwStartTime == 0)
    {
        m_dwStartTime = CurTime;
        m_dwLastTime = m_dwStartTime -  m_delta;
        ThisTimeStamp = (((CurTime - m_dwStartTime) + (epsilon)) / m_delta) * m_delta * (m_Frequency/1000);
	}
    else
	if (bStartStream)
	{
		// bStartStream will be set if this is the first packet after a break in a 
		// data stream.  We need to get our time stamps back on track, so we'll generate a time
		// based on the current time.  This case can happen if for some reason the capture device
		// gets starved or we are in half duplex and we are switching to talk mode.
        ThisTimeStamp = (((CurTime - m_dwStartTime) + (epsilon)) / m_delta) * m_delta * (m_Frequency/1000);
    }
	else
	{
	    // if we are in a continuous audio data stream, then we just want to increment our timestamp
		// for this data packet.  We don't want to use the current time because we don't know how long
		// it took from the time the data was acutally captured to the time we got it.  We have to rely
		// on the person feeding us data to let us know more information about the data stream.
		ThisTimeStamp = m_dwLastTimeStamp + m_delta * (m_Frequency/1000);
	}

	m_dwLastTimeStamp = ThisTimeStamp;
    m_dwLastTime = CurTime;
    return ThisTimeStamp;
#else
//I changed this because the times I was getting were widely spaced.  When I was in debugging
//mode.
static DWORD CurTime = 0;
CurTime++;
#endif 

return CurTime;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\ppm.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: PPM.cpp
//  Abstract:    Source file for PPM base class.
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////

#include <winsock2.h>
#include "freelist.h"
#include "ppm.h"
#include "ppmerr.h"
#include "descrip.h"
#include "debug.h"

#include "IPPMCB.h"

// Uncomment next line to have some extra debug information
// (also in free builds)
// set to 1 for checking but no messages (in fact equivalent to 0)
// set to 2 for error messages
// set to 3 for the max available and DebugBreak
// DEBUG_PPM_BUFFER is defined in sources

#if DEBUG_PPM_BUFFER > 2
#define DEBUGBREAK() DebugBreak()
#else
#define DEBUGBREAK()
#endif

#if DEBUG_FREELIST > 0
extern long lFreeListEnqueueTwice;
#endif


//Implementation

////////////////////////////////////////////////////////////////////////////////////////
//ppm:  See header file description. (Constructor)
////////////////////////////////////////////////////////////////////////////////////////
ppm::ppm(int PayloadTypeArg, int ProfileHdrSizeArg) : 
  m_PayloadType(PayloadTypeArg), m_ProfileHeaderSize(ProfileHdrSizeArg),
  m_dwCookie(0)
{
  m_InvalidPPM		   =   FALSE;
  m_LimitBuffers	   =   TRUE;

  m_pMsgBufDescrip     =   NULL;
  m_pFragBufDescrip    =   NULL;

  InitializeCriticalSection(&m_CritSec);

  m_pcErrorConnectionPoint = new CConnectionPoint((CConnectionPointContainer *) NULL, 
                                                  IID_IPPMError);
  m_pcNotificationConnectionPoint = new CConnectionPoint((CConnectionPointContainer *) NULL, 
                                                         IID_IPPMNotification);
  m_pcErrorConnectionPoint->SetContainer(&m_cConnPointContainer);
  m_pcNotificationConnectionPoint->SetContainer(&m_cConnPointContainer);
  // Now that our conn pt container is initialized, add our
  // connection points to it by telling them that they belong to it.
}


/*F*
//  Name    : PPM::PPMError
//  Purpose : Relay a PPM error to all registered connections.
//  Context : Called when a PPM error occurs. This includes such
//            things as low memory conditions, broken data structures, etc.
//  Returns : Nothing.
//  Params  :
//      hError      Error code indicating what occurred.
//      dwSeverity  SEVERITY_FATAL or SEVERITY_NORMAL, depending upon
//                  whether PPM processing can continue.
//      pData       Pointer to a block of memory describing the error.
//                  This is optional.
//      iDataLen    Length of the memory block indicated by pData.
//  Notes   : This is a leaf function, and may be called fully qualified. 
*F*/
void 
ppm::PPMError(
     HRESULT        hError,
     DWORD          dwSeverity,
     BYTE           *pData,
     unsigned int   iDataLen)
{
    HRESULT hErr;
    IEnumConnections *pConnPtEnumerator = NULL;

    hErr = m_pcErrorConnectionPoint->EnumConnections(&pConnPtEnumerator);
    if (FAILED(hErr)) {
        // Unable to get enumerator. Abort.
        return;
    } /* if */

    CONNECTDATA cd;
    while (NOERROR == pConnPtEnumerator->Next(1, &cd, NULL)) {
        IPPMError *pIPPMError = NULL;
        if (SUCCEEDED(cd.pUnk->QueryInterface(IID_IPPMError,
                                              (PVOID *) &pIPPMError))) {
            pIPPMError->PPMError(hError, dwSeverity, m_dwCookie, pData, iDataLen);
            pIPPMError->Release();
        } /* if */
    } /* while */

    pConnPtEnumerator->Release();

    return;
} /* PPM::PPMError() */


/*F*
//  Name    : PPM::PPMNotification
//  Purpose : Relay a PPM event to all registered connections.
//  Context : Called when a significant event occurs. This includes
//            such things as lost packets, out of order packets, etc.
//  Returns : Nothing.
//  Params  :
//      hError      Event code indicating what occurred.
//      dwSeverity  SEVERITY_FATAL or SEVERITY_NORMAL, depending upon
//                  whether PPM processing can continue.
//      pData       Pointer to a block of memory describing the error.
//                  This is optional.
//      iDataLen    Length of the memory block indicated by pData.
//  Notes   : This is a leaf function, and may be called fully qualified. 
*F*/
void 
ppm::PPMNotification(
     HRESULT        hError,
     DWORD          dwSeverity,
     BYTE           *pData,
     unsigned int   iDataLen)
{
    HRESULT hErr;
    IEnumConnections *pConnPtEnumerator = NULL;

    hErr = m_pcNotificationConnectionPoint->EnumConnections(&pConnPtEnumerator);
    if (FAILED(hErr)) {
        // Unable to get enumerator. Abort.
        return;
    } /* if */

    CONNECTDATA cd;
    while (NOERROR == pConnPtEnumerator->Next(1, &cd, NULL)) {
        IPPMNotification *pIPPMNotification = NULL;
        if (SUCCEEDED(cd.pUnk->QueryInterface(IID_IPPMNotification,
                                              (PVOID *) &pIPPMNotification))) {
            pIPPMNotification->PPMNotification(hError, dwSeverity, m_dwCookie, pData, iDataLen);
            pIPPMNotification->Release();
        } /* if */
    } /* while */

    pConnPtEnumerator->Release();

    return;
} /* PPM::PPMNotification() */


//NOTE:  SetSession is also a virtual function in the IPPMReceive and IPPMSend 
//		interfaces, implemented in the PPMReceive and PPMSend classes that derive
//		from those interfaces as well as this ppm base class.  Those functions need 
//		to call this one to set the private payload type member in the ppm base class.
HRESULT ppm::SetSession(PPMSESSPARAM_T *pSessparam)
{
	if (m_InvalidPPM) {
	   	DBG_MSG(DBG_ERROR, ("ppm::SetSession: ERROR - m_InvalidPPM == TRUE"));
		return PPMERR(PPM_E_FAIL);
	}

   	if (pSessparam == NULL)	{
	   	DBG_MSG(DBG_ERROR, ("ppm::SetSession: ERROR - pSessparam == NULL"));
		return PPMERR(PPM_E_INVALID_PARAM);
	}

    if ((m_PayloadType == -1) && (pSessparam->payload_type != -1))
        m_PayloadType = pSessparam->payload_type;

    return NOERROR;
}

////////////////////////////////////////////////////////////////////////////////////////
//Initppm:  See header file description. 
////////////////////////////////////////////////////////////////////////////////////////

HRESULT ppm::Initppm(int NumFragBufs, int NumMsgBufs)
{
	HRESULT hr1, hr2;
	
	if (m_LimitBuffers) {
		m_pMsgBufDescrip     =   new FreeList(NumMsgBufs,
											  (sizeof(MsgDescriptor)),
											  &hr1); 
		m_pFragBufDescrip    =   new FreeList(NumFragBufs,
											  (sizeof(FragDescriptor)),
											  &hr2);
       
	} else {
		m_pMsgBufDescrip     =   new FreeList(NumMsgBufs,
											  (sizeof(MsgDescriptor)),
											  FREELIST_HIGH_WATER_MARK,
											  FREELIST_INCREMENT,
											  &hr1); 
		m_pFragBufDescrip    =   new FreeList(NumFragBufs,
											  (sizeof(FragDescriptor)), 
											  FREELIST_HIGH_WATER_MARK,
											  FREELIST_INCREMENT,
											  &hr2);
	}
  
	if (!m_pMsgBufDescrip || !m_pFragBufDescrip ||
		FAILED(hr1) || FAILED(hr2)) {

		m_InvalidPPM = TRUE;
		ppm::PPMError(E_FAIL, SEVERITY_FATAL, NULL, 0);
		DBG_MSG(DBG_ERROR, ("ppm::Initppm: ERROR - Out of memory"));

		if (m_pMsgBufDescrip) {
			delete m_pMsgBufDescrip;
			m_pMsgBufDescrip = NULL;
		}

		if (m_pFragBufDescrip) {
			delete m_pFragBufDescrip;
			m_pFragBufDescrip = NULL;
		}
	  
		return PPMERR(PPM_E_OUTOFMEMORY);
	}

  return NOERROR;

}

class incr {
    CRITICAL_SECTION cs;
    int i;
public:
    incr(int init = 0);
    ~incr();
    int operator ++(int);
};

incr::incr(int init)
{
    InitializeCriticalSection(&cs);
    i = init;
}

incr::~incr()
{
    DeleteCriticalSection(&cs);
}

int incr::operator ++(int)
{
    int v;
    EnterCriticalSection(&cs);
    v = i++;
    LeaveCriticalSection(&cs);
    return v;
}

static incr NextPayloadType(96);

int ppm::ReadPayloadType()
{
    if (m_PayloadType == -1)
        m_PayloadType = NextPayloadType++;
    
    return m_PayloadType;
}

///////////////////////////////////////////////////////////////////////////
//~ppm:  See header file description. (Destructor)
///////////////////////////////////////////////////////////////////////////

ppm::~ppm()
{
   if (m_pMsgBufDescrip)   delete m_pMsgBufDescrip;
   if (m_pFragBufDescrip)  delete m_pFragBufDescrip;

   DeleteCriticalSection(&m_CritSec);

}


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
/// This used to be in ppm.h
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

MsgDescriptor* ppm::GetMsgDescriptor()
{
	return new(m_pMsgBufDescrip) MsgDescriptor;
}

DWORD ppm::FreeMsgDescriptor(MsgDescriptor* pMsgDescrip)
{
	return (m_pMsgBufDescrip->Free((void *)pMsgDescrip));
}

MsgDescriptor* ppm::DequeueBuffer(int flag)
{
	MsgDescriptor *MsgDesc = (MsgDescriptor*)m_MsgBufs.DequeueHead();

	if (MsgDesc) {
#if DEBUG_PPM_BUFFER > 2
		char str[128];
		wsprintf(str, "0x%X ++= 0x%X\n", this, MsgDesc);
		OutputDebugString(str);
#endif			
		MsgDesc->m_IsFree = 0;
	}
#if DEBUG_FREELIST > 1
	else if (flag) {
		char str[128];
		wsprintf(str, "0x%X ++= 0x%X m_MsgBufs is empty\n", this, MsgDesc);
		OutputDebugString(str);
		DEBUGBREAK();
	}
#endif
	return (MsgDesc);
}

DWORD ppm::EnqueueBuffer(MsgDescriptor* pMsgDescrip)
{
	if  (pMsgDescrip->m_IsFree) {
#if DEBUG_FREELIST > 0
		InterlockedIncrement(&lFreeListEnqueueTwice);
#endif
#if DEBUG_PPM_BUFFER > 1
		char str[128];
		wsprintf(str, "0x%X --= 0x%X Is being enqueued twice "
				 "in EnqueueBuffer\n",
				 this, pMsgDescrip);
		OutputDebugString(str);
		DEBUGBREAK();
#endif
		return(NOERROR);
	} else {
#if DEBUG_PPM_BUFFER > 2
		char str[128];
		wsprintf(str, "0x%X --= 0x%X\n", this, pMsgDescrip);
		OutputDebugString(str);
#endif			
		pMsgDescrip->m_IsFree = 1;
		return (m_MsgBufs.EnqueueHead(pMsgDescrip));
	}
}

DWORD ppm::EnqueueBufferTail(MsgDescriptor* pMsgDescrip)
{
	if  (pMsgDescrip->m_IsFree) {
#if DEBUG_FREELIST > 0
		InterlockedIncrement(&lFreeListEnqueueTwice);
#endif
#if DEBUG_PPM_BUFFER > 1
		char str[128];
		wsprintf(str, "0x%X --= 0x%X Is being enqueued twice "
				 "in EnqueueBufferTail\n",
				 this, pMsgDescrip);
		OutputDebugString(str);
		DEBUGBREAK();
#endif			
		return(NOERROR);
	} else {
#if DEBUG_PPM_BUFFER > 2
		char str[128];
		wsprintf(str, "0x%X --= 0x%X\n", this, pMsgDescrip);
		OutputDebugString(str);
#endif			
		pMsgDescrip->m_IsFree = 1;
		return (m_MsgBufs.EnqueueTail(pMsgDescrip));
	}
}

FragDescriptor* ppm::GetFragDescriptor()
{
	return new(m_pFragBufDescrip) FragDescriptor;
}

//The class that allocates any memory that any pointers in this class points to, that class must 
//override this function to delete that memory.
HRESULT ppm::FreeFragDescriptor(FragDescriptor* pFragDescrip)
{
	return (m_pFragBufDescrip->Free((void *)pFragDescrip));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\main.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: main.cpp
//  Abstract:    Define entry points to dll, define INITGUID, so the
//               GUID stuff works.  Setup the class registry for all the 
//               classes in the dll.
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////


#include <winsock2.h> 

#if !defined(PPM_IN_DXMRTP)
#include <initguid.h>
#define INITGUID
#endif
#include "ippm.h"
#include "isubmit.h"
#include "ppmclsid.h"

#include "core.h"

#ifdef _DEBUG
#include "debug.h"
#endif

#include "gensnd.h"
#include "genrcv.h"
#include "h261snd.h"
#include "h261rcv.h"
#include "h263snd.h"
#include "h263rcv.h"
#include "g711snd.h"
#include "g711rcv.h"
#include "g711asnd.h"
#include "g711arcv.h"
#include "g723snd.h"
#include "g723rcv.h"
#include "iv41snd.h"
#include "iv41rcv.h"
#include "lhsnd.h"
#include "lhrcv.h"
#include "imcsnd.h"
#include "imcrcv.h"
#include "gen_asnd.h"
#include "gen_arcv.h"


//***************************************************************************
// Component Object Model DLL entry points (copied from PSAPP.CPP)
//
//#if defined( _AFXDLL ) || defined( _USRDLL )

/////////////////////////////////////////////////////////////////////////////
// main driving api;  called by compboj.dll
//
#if defined(PPM_IN_DXMRTP)
STDAPI
PPMDllGetClassObject( REFCLSID rclsid, REFIID riid, LPVOID FAR* ppvObj )
#else
__declspec(dllexport) STDAPI
DllGetClassObject( REFCLSID rclsid, REFIID riid, LPVOID FAR* ppvObj )
#endif
{
	DBG_REGISTERMODULE("PPM", "Payload Preparation Module");

    return CClassFactory::GetClassObject( rclsid, riid, ppvObj );
}

/////////////////////////////////////////////////////////////////////////////
// can we unload?;  called by compobj.dll

#if defined(PPM_IN_DXMRTP)
STDAPI
PPMDllCanUnloadNow( void )
#else
__declspec(dllexport) STDAPI
DllCanUnloadNow( void )
#endif
{
    return CClassFactory::CanUnloadNow();
}

struct clsid_info {
		char *clsid_num;
		char *clsid_name;
};

#ifndef USE_OLD_CLSIDS

static clsid_info	clsid_array[] = {
		{"CLSID\\{4AFBBA8C-FE10-11d0-B607-00C04FB6E866}", "Generic PPM Send"},
		{"CLSID\\{4AFBBA8D-FE10-11d0-B607-00C04FB6E866}", "Generic PPM Receive"},
		{"CLSID\\{4AFBBA8E-FE10-11d0-B607-00C04FB6E866}", "H.261 PPM Send"},
		{"CLSID\\{4AFBBA8F-FE10-11d0-B607-00C04FB6E866}", "H.261 PPM Receive"},
		{"CLSID\\{4AFBBA90-FE10-11d0-B607-00C04FB6E866}", "H.263 PPM Send"},
		{"CLSID\\{4AFBBA91-FE10-11d0-B607-00C04FB6E866}", "H.263 PPM Receive"},
		{"CLSID\\{4AFBBA92-FE10-11d0-B607-00C04FB6E866}", "G.711 PPM Send"},
		{"CLSID\\{4AFBBA93-FE10-11d0-B607-00C04FB6E866}", "G.711 PPM Receive"},
		{"CLSID\\{4AFBBA94-FE10-11d0-B607-00C04FB6E866}", "G.723 PPM Send"},
		{"CLSID\\{4AFBBA95-FE10-11d0-B607-00C04FB6E866}", "G.723 PPM Receive"},
		{"CLSID\\{4AFBBA96-FE10-11d0-B607-00C04FB6E866}", "IV 4.1 PPM Send"},
		{"CLSID\\{4AFBBA97-FE10-11d0-B607-00C04FB6E866}", "IV 4.1 PPM Receive"},
		{"CLSID\\{4AFBBA98-FE10-11d0-B607-00C04FB6E866}", "G.711A PPM Send"},
		{"CLSID\\{4AFBBA99-FE10-11d0-B607-00C04FB6E866}", "G.711A PPM Receive"},
		{"CLSID\\{4AFBBA9A-FE10-11d0-B607-00C04FB6E866}", "LH PPM Send"},
		{"CLSID\\{4AFBBA9B-FE10-11d0-B607-00C04FB6E866}", "LH PPM Receive"},
		{"CLSID\\{4AFBBA9C-FE10-11d0-B607-00C04FB6E866}", "IMC PPM Send"},
		{"CLSID\\{4AFBBA9D-FE10-11d0-B607-00C04FB6E866}", "IMC PPM Receive"},
		{"CLSID\\{4AFBBA9E-FE10-11d0-B607-00C04FB6E866}", "Generic Audio Send"},
		{"CLSID\\{4AFBBA9F-FE10-11d0-B607-00C04FB6E866}", "Generic Audio Receive"},
};

#else // #ifndef USE_OLD_CLSIDS

static clsid_info	clsid_array[] = {
		{"CLSID\\{1df95360-f1fe-11cf-ba07-00aa003419d3}", "Generic PPM Send"},
		{"CLSID\\{1df95361-f1fe-11cf-ba07-00aa003419d3}", "Generic PPM Receive"},
		{"CLSID\\{1df95362-f1fe-11cf-ba07-00aa003419d3}", "H.261 PPM Send"},
		{"CLSID\\{1df95363-f1fe-11cf-ba07-00aa003419d3}", "H.261 PPM Receive"},
		{"CLSID\\{1df95364-f1fe-11cf-ba07-00aa003419d3}", "H.263 PPM Send"},
		{"CLSID\\{1df95365-f1fe-11cf-ba07-00aa003419d3}", "H.263 PPM Receive"},
		{"CLSID\\{1df95366-f1fe-11cf-ba07-00aa003419d3}", "G.711 PPM Send"},
		{"CLSID\\{1df95367-f1fe-11cf-ba07-00aa003419d3}", "G.711 PPM Receive"},
		{"CLSID\\{1df95368-f1fe-11cf-ba07-00aa003419d3}", "G.723 PPM Send"},
		{"CLSID\\{1df95369-f1fe-11cf-ba07-00aa003419d3}", "G.723 PPM Receive"},
		{"CLSID\\{1df9536a-f1fe-11cf-ba07-00aa003419d3}", "IV 4.1 PPM Send"},
		{"CLSID\\{1df9536b-f1fe-11cf-ba07-00aa003419d3}", "IV 4.1 PPM Receive"},
		{"CLSID\\{1df9536c-f1fe-11cf-ba07-00aa003419d3}", "G.711A PPM Send"},
		{"CLSID\\{1df9536d-f1fe-11cf-ba07-00aa003419d3}", "G.711A PPM Receive"},
		{"CLSID\\{1df9536e-f1fe-11cf-ba07-00aa003419d3}", "LH PPM Send"},
		{"CLSID\\{1df9536f-f1fe-11cf-ba07-00aa003419d3}", "LH PPM Receive"},
		{"CLSID\\{E7FD6DC1-7383-11d0-BA07-00AA003419D3}", "IMC PPM Send"},
		{"CLSID\\{E7FD6DC2-7383-11d0-BA07-00AA003419D3}", "IMC PPM Receive"},
		{"CLSID\\{0DE58B60-8E66-11d0-BA07-00AA003419D3}", "Generic Audio Send"},
		{"CLSID\\{0DE58B61-8E66-11d0-BA07-00AA003419D3}", "Generic Audio Receive"},

};

#endif // #ifndef USE_OLD_CLSIDS

//#define NUM_CLSIDS 20  //Increment this whenever a new clsid is added!
#define NUM_CLSIDS (sizeof(clsid_array)/sizeof(clsid_array[0]))

/////////////////////////////////////////////////////////////////////////////
// Register this COM server in the registry
//   called by an install program or regsvr32.exe to register this DLL
#if defined(PPM_IN_DXMRTP)
//__declspec(dllexport) STDAPI
//PPMDllRegisterServer( void )
STDAPI
PPMDllRegisterServer( void )
#else
__declspec(dllexport) STDAPI
DllRegisterServer( void )
#endif
{
	HKEY hKeyCLSID, hKeyInproc32;
	DWORD dwDisposition;

#if defined(PPM_IN_DXMRTP)
	HMODULE hModule=GetModuleHandle("dxmrtp.dll");
#else
	HMODULE hModule=GetModuleHandle("PPM.DLL");
#endif
	if (!hModule) {
		return E_UNEXPECTED;
	} /* if */
	TCHAR szName[MAX_PATH+1];
	if (GetModuleFileName(hModule, szName, sizeof(szName))==0) {
		return E_UNEXPECTED;
	} /* if */

	for (int i = 0; i < NUM_CLSIDS; i++) {

		if (RegCreateKeyEx(HKEY_CLASSES_ROOT, 
				clsid_array[i].clsid_num, 
				NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, 
				&hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
			return E_UNEXPECTED;
		} /* if */

		if (RegSetValueEx(hKeyCLSID, "", NULL, REG_SZ, (BYTE*) clsid_array[i].clsid_name, sizeof(clsid_array[i].clsid_name))!=ERROR_SUCCESS) {
			RegCloseKey(hKeyCLSID);
			return E_UNEXPECTED;
		} /* if */

		if (RegCreateKeyEx(hKeyCLSID, 
				"InprocServer32", 
				NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, 
				&hKeyInproc32, &dwDisposition)!=ERROR_SUCCESS) {
			RegCloseKey(hKeyCLSID);
			return E_UNEXPECTED;
		} /* if */

		if (RegSetValueEx(hKeyInproc32, "", NULL, REG_SZ, (BYTE*) szName, sizeof(TCHAR)*(lstrlen(szName)+1))!=ERROR_SUCCESS) {
			RegCloseKey(hKeyInproc32);
			RegCloseKey(hKeyCLSID);
			return E_UNEXPECTED;
		} /* if */
		if (RegSetValueEx(hKeyInproc32, "ThreadingModel", NULL, REG_SZ, (BYTE*) "Both", sizeof(TCHAR)*(lstrlen("Apartment")+1))!=ERROR_SUCCESS) {
			RegCloseKey(hKeyInproc32);
			RegCloseKey(hKeyCLSID);
			return E_UNEXPECTED;
		} /* if */
		RegCloseKey(hKeyInproc32);
		RegCloseKey(hKeyCLSID);

	} /* if */
	return NOERROR;

}


/////////////////////////////////////////////////////////////////////////////
// Unregister this COM server in the registry
//   called by an install program or regsvr32.exe to unregister this DLL
#if defined(PPM_IN_DXMRTP)
STDAPI
PPMDllUnregisterServer( void )
#else
__declspec(dllexport) STDAPI
DllUnregisterServer( void )
#endif
{
	char pServerName[256];

	for (int i = 0; i < NUM_CLSIDS; i++ ) {

		strcpy( pServerName, clsid_array[i].clsid_num );
		strcat( pServerName, "\\InprocServer32" );

		if (RegDeleteKey(HKEY_CLASSES_ROOT,	pServerName)!=ERROR_SUCCESS) {
			return E_UNEXPECTED;
		} /* Generic PPM Send */
		if (RegDeleteKey(HKEY_CLASSES_ROOT,	clsid_array[i].clsid_num)!=ERROR_SUCCESS) {
			return E_UNEXPECTED;
		} /* Generic PPM Send */
	} /* for */


	return NOERROR;
}

//#endif // defined( _AFXDLL ) || defined( _USRDLL )

 /////////////////////////////////////////////////////////////////////////////
// CClassFactory registry
//
BEGIN_CLASS_REGISTRY()
   REGISTER_CLASS( CLSID_GenPPMReceive,			Generic_ppmReceive,		REGCLS_MULTIPLEUSE )
   REGISTER_CLASS( CLSID_GenPPMSend,			Generic_ppmSend,		REGCLS_MULTIPLEUSE )
   REGISTER_CLASS( CLSID_H261PPMReceive,		H261_ppmReceive,		REGCLS_MULTIPLEUSE )
   REGISTER_CLASS( CLSID_H261PPMSend,			H261_ppmSend,			REGCLS_MULTIPLEUSE )
   REGISTER_CLASS( CLSID_H263PPMReceive,		H263_ppmReceive,		REGCLS_MULTIPLEUSE )
   REGISTER_CLASS( CLSID_H263PPMSend,			H263_ppmSend,			REGCLS_MULTIPLEUSE )
   REGISTER_CLASS( CLSID_G711PPMReceive,		G711_ppmReceive,		REGCLS_MULTIPLEUSE )
   REGISTER_CLASS( CLSID_G711PPMSend,			G711_ppmSend,			REGCLS_MULTIPLEUSE )
   REGISTER_CLASS( CLSID_G723PPMReceive,		G723_ppmReceive,		REGCLS_MULTIPLEUSE )
   REGISTER_CLASS( CLSID_G723PPMSend,			G723_ppmSend,			REGCLS_MULTIPLEUSE )
   REGISTER_CLASS( CLSID_IV41PPMReceive,		IV41_ppmReceive,		REGCLS_MULTIPLEUSE )
   REGISTER_CLASS( CLSID_IV41PPMSend,			IV41_ppmSend,			REGCLS_MULTIPLEUSE )
   REGISTER_CLASS( CLSID_G711APPMReceive,		G711A_ppmReceive,		REGCLS_MULTIPLEUSE )
   REGISTER_CLASS( CLSID_G711APPMSend,			G711A_ppmSend,			REGCLS_MULTIPLEUSE )
   REGISTER_CLASS( CLSID_LHPPMReceive,			LH_ppmReceive,			REGCLS_MULTIPLEUSE )
   REGISTER_CLASS( CLSID_LHPPMSend,				LH_ppmSend,				REGCLS_MULTIPLEUSE )
   REGISTER_CLASS( CLSID_IMCPPMReceive,			IMC_ppmReceive,			REGCLS_MULTIPLEUSE )
   REGISTER_CLASS( CLSID_IMCPPMSend,			IMC_ppmSend,			REGCLS_MULTIPLEUSE )
   REGISTER_CLASS( CLSID_GEN_A_PPMReceive,		Generic_a_ppmReceive,	REGCLS_MULTIPLEUSE )
   REGISTER_CLASS( CLSID_GEN_A_PPMSend	,		Generic_a_ppmSend	,	REGCLS_MULTIPLEUSE )

END_CLASS_REGISTRY()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\ppm.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: ppm.h
//  Abstract:    header file. Base class of the PPMSend and PPMReceive objects.
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////

// $Header:   J:\rtp\src\ppm\ppm.h_v   1.28   04 Mar 1997 19:54:50   lscline  $


#ifndef PPM_H
#define PPM_H

#include "connect.h"
#include "que.h"
#include "freelist.h"
#ifdef RTP_CLASS
#include "rtpclass.h"
#else
#include "rtp.h"
#endif
#include "llist.h"
#include "descrip.h"
#include "ippm.h"

////////////////////////////////////////////////////////////////////////////////////////
// Definitions for use with Freelist. The commonly used high water mark value
// and the increment is defined here as symbols. Modify for specific usage
////////////////////////////////////////////////////////////////////////////////////////
#define FREELIST_HIGH_WATER_MARK	5000
#define FREELIST_INCREMENT			1 // HUGEMEMORY 20->1
#define FREELIST_INIT_COUNT_SND		4 // HUGEMEMORY 20->4
#define FREELIST_INIT_COUNT_RCV		9 // HUGEMEMORY 20->9

//#define DEFAULT_MSG_COUNT   FREELIST_INIT_COUNT
#define DEFAULT_MSG_COUNT_SND 4 // HUGEMEMORY 40->4
#define DEFAULT_MSG_COUNT_RCV 9 // HUGEMEMORY 40->9
//#define DEFAULT_FRAG_COUNT  10 * FREELIST_INIT_COUNT
#define DEFAULT_FRAG_COUNT  10 // HUGEMEMORY 2400->10

////////////////////////////////////////////////////////////////////////////////////////
//ppm: Base class from which SendPPM and Receive PPM are derived.
////////////////////////////////////////////////////////////////////////////////////////
class ppm {

private:

//Private Members
const int   m_ProfileHeaderSize;

FreeList   *m_pFragBufDescrip;
FreeList   *m_pMsgBufDescrip;
Queue       m_MsgBufs;

CConnectionPoint            *m_pcErrorConnectionPoint;
CConnectionPoint            *m_pcNotificationConnectionPoint;

protected:

//Protected Members
int							m_PayloadType;   
CRITICAL_SECTION            m_CritSec; //this is protected so derived classes can just use it.
BOOL	                    m_InvalidPPM;
CConnectionPointContainer   m_cConnPointContainer;
DWORD                       m_dwCookie;
BOOL						m_LimitBuffers;

//Protected Member Functions

ppm(int PayloadTypeArg, int ProfileHdrSizeArg);
~ppm();

/* leaf */ void PPMError(
             HRESULT        hError,
             DWORD          dwSeverity,
             BYTE           *pData,
             unsigned int   iDataLen);
/* leaf */ void PPMNotification(
             HRESULT        hError,
             DWORD          dwSeverity,
             BYTE           *pData,
             unsigned int   iDataLen);

//NOTE:  SetSession is also a virtual function in the IPPMReceive and IPPMSend 
//		interfaces, implemented in the PPMReceive and PPMSend classes that derive
//		from those interfaces as well as this ppm base class.  Those functions need 
//		to call this one to set the private payload type member in the ppm base class.
HRESULT SetSession(PPMSESSPARAM_T *pSessparam);

//initialize some common data structures and members
HRESULT Initppm(int NumFragBufs, int NumMsgBufs);

int  ReadPayloadType();

virtual int  ReadProfileHeaderSize(void *pProfileHeader = NULL) {return m_ProfileHeaderSize;};

MsgDescriptor* GetMsgDescriptor();

DWORD FreeMsgDescriptor(MsgDescriptor* pMsgDescrip);

MsgDescriptor* DequeueBuffer(int flag);

DWORD EnqueueBuffer(MsgDescriptor* pMsgDescrip);

DWORD EnqueueBufferTail(MsgDescriptor* pMsgDescrip);

FragDescriptor* GetFragDescriptor();

//The class that allocates any memory that any pointers in this class points to, that class must 
//override this function to delete that memory.
virtual HRESULT FreeFragDescriptor(FragDescriptor* pFragDescrip);

u_long htonl(u_long);
u_short htons(u_short);
u_long ntohl(u_long);
u_short ntohs(u_short);

}; //end class ppm

inline u_long ppm::htonl(u_long hostlong)
{
#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
    return _byteswap_ulong((ULONG)hostlong)
#else
    u_long netlong;
    unsigned char *p = (unsigned char *)&netlong;
    p[0] = (unsigned char)(hostlong >> 24);
    p[1] = (unsigned char)(hostlong >> 16);
    p[2] = (unsigned char)(hostlong >> 8);
    p[3] = (unsigned char)hostlong;
    return netlong;
#endif
}

inline u_short ppm::htons(u_short hostshort)
{
#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
    return _byteswap_ushort((USHORT)hostshort)
#else
    u_short netshort;
    unsigned char *p = (unsigned char *)&netshort;
    p[0] = (unsigned char)(hostshort >> 8);
    p[1] = (unsigned char)hostshort;
    return netshort;
#endif
}

inline u_long ppm::ntohl(u_long netlong)
{
#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
    return _byteswap_ulong((ULONG)netlong)
#else
    unsigned char *p = (unsigned char *)&netlong;
    return ((u_long)p[0] << 24) | ((u_long)p[1] << 16) | ((u_long)p[2] << 8) | (u_long)p[3];
#endif
}

inline u_short ppm::ntohs(u_short netshort)
{
#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
    return _byteswap_ushort((USHORT)netshort)
#else
    unsigned char *p = (unsigned char *)&netshort;
    return ((u_short)p[0] << 8) | (u_short)p[1];
#endif
}

//////////////////////////////////////////////////////////////////////////////
//Some local helpers for pointer calcs (we should move these to a util header).
//////////////////////////////////////////////////////////////////////////////

// nextDword(): return pointer aligned to next dword
inline void* nextDword(const void* lpv)
{
	return (void*) (((ULONG_PTR) lpv + 3) & ~3);
}

// offsetNextDword(): return distance to next dword
inline SIZE_T offsetNextDword(const void* lpv)
{
	return ((char *)nextDword(lpv) - (char *)lpv);
}

// copyAndAdvance(): copy cbSource bytes from lpSource to lpDest, advancing
// lpDest by cbSource, returning cbSource.  Useful for building buffers.
// Caller may use return value to increment buffer length. 

#if defined(_MSC_VER) && (_MSC_VER >= 800)
	// Use intrinsic memcpy() if available.
	#pragma intrinsic(memcpy)
#endif

inline DWORD
copyAndAdvance(unsigned char*& lpDest, const void* lpSource, SIZE_T cbSource)
{
	memcpy(lpDest, lpSource, (DWORD)cbSource);
	lpDest += cbSource;
	return (DWORD)cbSource;
}

#if defined(_MSC_VER) && (_MSC_VER >= 800)
	#pragma function(memcpy)
#endif


#endif // PPM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\ppmrcv.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: PPMReceive.cpp
//  Abstract:    Source file for PPM Receive COM Object
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////

#include "ppmrcv.h"
#include "isubmit.h"
#include "ippm.h"
#include "ippmcb.h"
#include "ppm.h"
#include "freelist.h"
#include "ppmerr.h"
#include "llist.h"
#include "wrap.h"
#include "debug.h"
#include <mmsystem.h>

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//External PPMReceive Functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
//    PPMReceive Constructor
ppmReceive::ppmReceive(int PayloadTypeArg, int MaxBufferSizeArg, int ProfileHdrSizeArg, IUnknown* pUnkOuter, IUnknown** ppUnkInner) : 
  ppm(PayloadTypeArg,ProfileHdrSizeArg), CUnknown(pUnkOuter, ppUnkInner), m_MaxBufferSize( MaxBufferSizeArg )
{
   m_pSubmitCallback        = NULL;
   m_pSubmit		        = NULL;
   
   m_pBufPool               = NULL;
   
   m_pMsgHeaderPool         = NULL;
   m_pMsgHeadersHead        = NULL;
   m_pMsgHeadersTail        = NULL;

   m_GlobalLastSeqNum       = 0;      
   m_GlobalLastMsgID        = 0;
   m_GlobalLastSSRC         = 0;

   m_TimerID                = NULL;
   m_reg_TimerInterval      = 30;    // in miliseconds, interval in which the timer goes off.
   m_reg_TimerResolution    = 10;    //We want ten or the lowest value the OS can provide
   m_reg_DeltaTime          = 200;    //in miliseconds time to determine a packet is stale

   m_FirstPacket            = TRUE;  //this will stay true until I get the first packet.
   m_inFlushMode			= FALSE;
   m_GlobalLastFrameDropped = FALSE;
   m_OutstandingDataPtr		= NULL;
   m_DataOutstanding		= FALSE;
   m_OutstandingMsgCount	= 0;
   m_PacketsHold            = 0;

   if FAILED ( CoGetMalloc(MEMCTX_TASK, &m_pIMalloc)) {
	  DBG_MSG(DBG_ERROR, ("ppmReceive::ppmReceive: ERROR - Could not get default IMalloc"));
	   m_pIMalloc = NULL;
   }

   // Tell the connection point container to delegate IUnknown calls
   // to the IUnknown we implement in this object via inheritance
   // from our CUnknown base class.
   m_cConnPointContainer.SetUnknown((IUnknown *) (CUnknown *) this);
}


/////////////////////////////////////////////////////////////////////////////////
//    PPMReceive Destructor

ppmReceive::~ppmReceive()
{
    MsgDescriptor *BD;

    while ( (BD = DequeueBuffer(0)) != NULL ) {
        m_pBufPool->Free(BD->m_pBuffer);
        FreeMsgDescriptor(BD);
    } /* while */

    //lsc - Want to look at this and get rid of pending frags too
    if (m_pMsgHeaderPool) {
        delete  m_pMsgHeaderPool;
    } /* if */

    if (m_pBufPool) {
        delete  m_pBufPool;
    } /* if */

    if (m_TimerID) {
        timeKillEvent(m_TimerID);
    } /* if */

    if (m_pSubmit) {
        m_pSubmit->Release();
    } /* if */

    if (m_pIMalloc) {
        m_pIMalloc->Release();
    } /* if */

    if (m_pSubmitCallback) {
        m_pSubmitCallback->Release(); 
    } /* if */
	if (m_OutstandingDataPtr) {
		delete [] m_OutstandingDataPtr;
	}
} /* ppmReceive::~ppmReceive() */

//////////////////////////////////////////////////////////////////////////////
//   IPPMReceive Functions (Overrides)

HRESULT ppmReceive::InitPPMReceive(int      MaxBufferSize, 
                                   int      iBuffers,
                                   int      iPackets,
                                   DWORD    dwCookie)
{
   MsgDescriptor *tmpBuf;
 
   // Store the cookie passed in to us for use in callbacks.
   // Shouldn't there be state checking here to ensure that this
   // isn't called twice? What about a lock to avoid race conditions?
   m_dwCookie = dwCookie;
   m_PacketsHold = 0;
   
   if (m_InvalidPPM)
   {
	  DBG_MSG(DBG_ERROR, ("ppmReceive::InitPPMReceive: ERROR - m_InvalidPPM"));
      return PPMERR(PPM_E_FAIL);
   }

   #ifndef TIMER_OFF
   //Setup the Timer.
   m_TimerID = SetupTimer();
   
   if (m_TimerID == NULL) //We couldn't get a timer.
   {
	   m_InvalidPPM = TRUE;
       ppm::PPMError(PPM_E_TIMER, SEVERITY_FATAL, NULL, 0);
	  DBG_MSG(DBG_ERROR, ("ppmReceive::InitPPMReceive: ERROR - m_TimerID == NULL"));
     return PPMERR(PPM_E_FAIL);
   }
   #endif

   if (MaxBufferSize > 0) {
	   m_MaxBufferSize = MaxBufferSize;
   }

   // Initialize the base class. This will allocate a bunch of
   // message descriptors and fragment descriptors.
   HRESULT hErr;
   hErr = ppm::Initppm(iPackets, iBuffers);
   if (FAILED(hErr)) { 
	   m_InvalidPPM = TRUE;  
       char *pErrorDescription = "PPM Failed to successfully initialize";
       ppm::PPMError(E_FAIL, SEVERITY_FATAL, (BYTE *) pErrorDescription, 
                     strlen(pErrorDescription));
       return hErr;
   } /* if */

   //Make a pool of Msg headers and Msg buffers.
   HRESULT hr1, hr2;
   if (m_LimitBuffers) {
		m_pMsgHeaderPool = new  FreeList(iBuffers, sizeof(MsgHeader), &hr1);
		m_pBufPool = new  FreeList(iBuffers ,m_MaxBufferSize, &hr2);
   } else {
		m_pMsgHeaderPool = new  FreeList(iBuffers,sizeof(MsgHeader), 
			FREELIST_HIGH_WATER_MARK, FREELIST_INCREMENT, &hr1);
		m_pBufPool = new  FreeList(iBuffers,m_MaxBufferSize, 
			FREELIST_HIGH_WATER_MARK, FREELIST_INCREMENT, &hr2);
   }

   if ((m_pMsgHeaderPool == NULL) || (m_pBufPool == NULL) ||
	   FAILED(hr1) || FAILED(hr2)) {

	   m_InvalidPPM = TRUE;
	   ppm::PPMError(E_FAIL, SEVERITY_FATAL, NULL, 0);
	   DBG_MSG(DBG_ERROR, ("ppmReceive::InitPPMReceive: "
						   "ERROR - Out of memory"));
	   if (m_pMsgHeaderPool) {
		   delete m_pMsgHeaderPool;
		   m_pMsgHeaderPool = NULL;
	   }

	   if (m_pBufPool) {
		   delete m_pBufPool;
		   m_pBufPool = NULL;
	   }
	   
       return PPMERR(PPM_E_OUTOFMEMORY);
   }

   for (int i = 0; i < iBuffers; i++) {
	   tmpBuf = GetMsgDescriptor();
	   if (tmpBuf == NULL) {
		   m_InvalidPPM = TRUE;
           ppm::PPMError(E_OUTOFMEMORY, SEVERITY_FATAL, NULL, 0);
		   DBG_MSG(DBG_ERROR, ("ppmReceive::InitPPMReceive: ERROR - tmpBuf == NULL"));
		   return PPMERR(PPM_E_FAIL);
	   }
	   tmpBuf->m_Size = m_MaxBufferSize;
	   tmpBuf->m_pBuffer = m_pBufPool->Get();
	   if (!tmpBuf->m_pBuffer) {
		   tmpBuf->m_Size = 0;
		   FreeMsgDescriptor(tmpBuf);
		   tmpBuf = NULL;
           ppm::PPMError(E_OUTOFMEMORY, SEVERITY_FATAL, NULL, 0);
		   DBG_MSG(DBG_ERROR, ("ppmReceive::InitPPMReceive: ERROR - "
							   "tmpBuf->m_pBuffer == NULL"));
		   return PPMERR(PPM_E_FAIL);
	   }

	   if (FAILED (EnqueueBufferTail(tmpBuf))) {
		   m_InvalidPPM = TRUE;
           ppm::PPMError(E_FAIL, SEVERITY_FATAL, NULL, 0);
		   DBG_MSG(DBG_ERROR, ("ppmReceive::InitPPMReceive: ERROR - FAILED (EnqueueBuffer(tmpBuf)"));
		   return PPMERR(PPM_E_FAIL);
	   }
   }

   return NOERROR;
}

STDMETHODIMP ppmReceive::SetSession(PPMSESSPARAM_T *pSessparam)
{
	if (m_InvalidPPM)
	{
	  DBG_MSG(DBG_ERROR, ("ppmReceive::SetSession: ERROR - m_InvalidPPM"));
      return PPMERR(PPM_E_FAIL);
	}

	if (pSessparam == NULL)	
	{

	   	DBG_MSG(DBG_ERROR, ("ppmReceive::SetSession: ERROR - pSessparam == NULL"));
		return PPMERR(PPM_E_INVALID_PARAM);
	}

	if(pSessparam->delta_time > 0)
	{
		m_reg_DeltaTime = pSessparam->delta_time; 
	}

	return ppm::SetSession(pSessparam);
}

STDMETHODIMP ppmReceive::SetAlloc(IMalloc *pIMalloc)
{
   if (!pIMalloc)
   {
	  DBG_MSG(DBG_ERROR, ("ppmReceive::SetAlloc: ERROR - Invalid allocator pointer"));
      return PPMERR(PPM_E_INVALID_PARAM);
   }
   m_pIMalloc->Release();

   m_pIMalloc = pIMalloc;

   m_pIMalloc->AddRef();
	
   return NOERROR;
}

//////////////////////////////////////////////////////////////////////////////
//   IPPMReceiveSession Functions (Overrides)

////////////////////////////////////////////////////////////////////////////////////////
//GetPayloadType:  Gets the current payload type
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP ppmReceive::GetPayloadType(LPBYTE			lpcPayloadType)
{
	if (!lpcPayloadType) return E_POINTER;
	*lpcPayloadType = (BYTE)m_PayloadType;
	return NOERROR;
}

////////////////////////////////////////////////////////////////////////////////////////
//SetPayloadType:  Sets the current payload type
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP ppmReceive::SetPayloadType(BYTE			cPayloadType)
{
    if (cPayloadType != -1)
        m_PayloadType = cPayloadType;

    return NOERROR;
}

////////////////////////////////////////////////////////////////////////////////////////
//GetTimeoutDuration:  Gets the time to wait for lost or out of order packets
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP ppmReceive::GetTimeoutDuration(LPDWORD    lpdwLostPacketTime)
{
	if (!lpdwLostPacketTime) return E_POINTER;
	*lpdwLostPacketTime = m_reg_DeltaTime;
	return NOERROR;
}

////////////////////////////////////////////////////////////////////////////////////////
//SetTimeoutDuration:  Sets the time to wait for lost or out of order packets
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP ppmReceive::SetTimeoutDuration(DWORD      dwLostPacketTime)
{
	m_reg_DeltaTime = dwLostPacketTime;
	return NOERROR;
}

////////////////////////////////////////////////////////////////////////////////////////
//GetResiliency:  Gets the boolean for whether resiliency is on or off
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP ppmReceive::GetResiliency(LPBOOL			lpbResiliency)
{
	if (!lpbResiliency) return E_POINTER;
	*lpbResiliency = FALSE;
	return NOERROR;
}

////////////////////////////////////////////////////////////////////////////////////////
//SetResiliency:  Sets the boolean for whether resiliency is on or off
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP ppmReceive::SetResiliency(BOOL			pbResiliency)
{
	return E_UNEXPECTED;
}


//////////////////////////////////////////////////////////////////////////////
//   ISubmit Functions (Overrides)

HRESULT ppmReceive::InitSubmit(ISubmitCallback *pSubmitCallback)
{  
   if (m_InvalidPPM)
   {
	  DBG_MSG(DBG_ERROR, ("ppmReceive::InitSubmit: ERROR - m_InvalidPPM"));
      return PPMERR(PPM_E_FAIL);
   }

  //if InitPPMReceive wasn't called or I was given a null pointer then fail)
   if ((m_pSubmit == NULL) || (pSubmitCallback == NULL))
   {
	  DBG_MSG(DBG_ERROR, ("ppmReceive::InitSubmit: ERROR - null m_pSubmit or pSubmitCallback"));
      return PPMERR(PPM_E_FAIL);
   }
  
   m_pSubmitCallback = pSubmitCallback;
   m_pSubmitCallback->AddRef(); 
    
   //call the Init function of the service layer below me.
   //Pass him my interface so he can let me know when there is data ready for me.
   return  m_pSubmit->InitSubmit( (ISubmitCallback *)this);
  
}

////////////////////////////////////////////////////////////////////////////////////////
//Flush:  See header file description.
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP ppmReceive::Flush()
{
   HRESULT         Status = NOERROR;
   MsgHeader *pMsgHdr = NULL;
   FragDescriptor *tmpFragHeader = NULL;

   if (m_InvalidPPM)
   {
	  DBG_MSG(DBG_ERROR, ("ppmReceive::Flush: ERROR - m_InvalidPPM"));
      return PPMERR(PPM_E_FAIL);
   }

    EnterCriticalSection(&m_CritSec);
	m_inFlushMode	 = TRUE;
    LeaveCriticalSection(&m_CritSec);
	Status = m_pSubmit->Flush(); //get all the data buffers that we sent up through Submit.

	//hand back all the fragment buffers that we have queued
	while (m_pMsgHeadersHead) {
		//Start pulling queues of fragments off the list to hand back
		
		pMsgHdr = TakeMsgHeader();
		if (!pMsgHdr) {
			DBG_MSG(DBG_ERROR, ("ppmReceive::Flush: ERROR - Empty Queue"));
			Status = PPMERR(PPM_E_EMPTYQUE);
			break;
		}
		FreeFragList(pMsgHdr);
		FreeMsgHeader(pMsgHdr);
	}

	//reset state
    m_GlobalLastSeqNum       = 0;      
    m_GlobalLastMsgID        = 0;

    m_FirstPacket            = TRUE;  //this will stay true until I get the first packet.

    EnterCriticalSection(&m_CritSec);
	m_inFlushMode	  = FALSE;
    LeaveCriticalSection(&m_CritSec);

	return Status;
}

//////////////////////////////////////////////////////////////////////////////
//   ISubmitCallback Functions (Overrides)

void ppmReceive::SubmitComplete(void *pUserToken,
								HRESULT Error)
//was ppmReceive::Receive(void *Buffer, DWORD BytesReceived, HRESULT Error)
{
//lsc - Note this is a function that is called by the media
//  manager side to give us back a message buffer belonging to us that is no 
//  longer needed.

   if (pUserToken == NULL) {
	   	DBG_MSG(DBG_ERROR, ("ppmReceive::SubmitComplete: ERROR - pUserToken == NULL"));
		return;
   }

   MsgDescriptor* tmpBuf = (MsgDescriptor *) pUserToken;

   //reset Size field of MsgDescriptor
   tmpBuf->m_Size  = m_MaxBufferSize;

#ifdef _DEBUG
	 DBG_MSG(DBG_TRACE,  ("PPMReceive::SubmitComplete Thread %ld - is enqueueing Message descriptor %x for reuse\n",
		 GetCurrentThreadId(), tmpBuf));
#endif

   EnqueueBuffer(tmpBuf);

   return;
     
   //Will I ever starve for App Buffers?? If so what do I do?
}
   
//////////////////////////////////////////////////////////////////////////////
//ppmReceive:
//////////////////////////////////////////////////////////////////////////////

HRESULT ppmReceive::Submit(WSABUF *pWSABuffer, DWORD BufferCount, 
						   void *pUserToken, HRESULT Error)
//was ReceiveComplete(void *pBuffer, DWORD BufferLength)
{
//lsc - This is a function that is called
//  from the network side to give PPM a fragment.
//Need to make changes to accomodate multiple buffers, Also need to allocate more 
// memory if we're out of frags.

  FragDescriptor *TmpFrag;
  HRESULT rval;
   
   if (m_InvalidPPM)
   {
	  DBG_MSG(DBG_ERROR, ("ppmReceive::Submit: ERROR - m_InvalidPPM"));
      return PPMERR(PPM_E_FAIL);
   }

   if ((pWSABuffer  == NULL) || (pUserToken == NULL)) {
		DBG_MSG(DBG_ERROR, ("ppmReceive::Submit: ERROR - NULL pWSABuffer or pUserToken"));
	   return PPMERR(PPM_E_INVALID_PARAM);
   }

   TmpFrag = GetFragDescriptor();

   //consider allocating more memory
   if (TmpFrag == NULL) {
		DBG_MSG(DBG_ERROR, ("ppmReceive::Submit: ERROR - Could not allocate frag"));
	   return PPMERR(PPM_E_OUTOFMEMORY);
   }
   
   //set fields in Fragment header
   VoidToFragment(pWSABuffer, BufferCount, TmpFrag, pUserToken); 

   if FAILED (rval = EnqueByMessage(TmpFrag)) {
		DBG_MSG(DBG_ERROR, ("ppmReceive::Submit: ERROR - EnqueByMessage failed"));
		if ((rval == PPMERR(PPM_E_DROPFRAME)) || (rval == PPMERR(PPM_E_CLIENTERR))) {
			ppm::PPMNotification(PPM_E_DROPFRAME, SEVERITY_NORMAL, NULL, 0);
		} else if (rval == PPMERR(PPM_E_DROPFRAG)) {
			ppm::PPMNotification(PPM_E_DROPFRAG, SEVERITY_NORMAL, NULL, 0);
		} else {
			m_InvalidPPM = TRUE;
			ppm::PPMError(E_FAIL, SEVERITY_FATAL, NULL, 0);
		}
		if (TmpFrag->m_pProfileHeader)
			FreeProfileHeader(TmpFrag->m_pProfileHeader);
		FreeFragDescriptor(TmpFrag);
		return rval;
   }
   return NOERROR;
}

//////////////////////////////////////////////////////////////////////////////
//   ISubmitUser Functions (Overrides)
////////////////////////////////////////////////////////////////////////////////////////
//SetOutput:  See header file description.
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP ppmReceive::SetOutput(IUnknown *pSubmit)
{
   if (m_InvalidPPM)
   {
	  DBG_MSG(DBG_ERROR, ("ppmReceive::SetOutput: ERROR - m_InvalidPPM"));
      return PPMERR(PPM_E_FAIL);
   }

   if (pSubmit == NULL) {
      // Whether we have had a submitter set previously or not,
      // we want to go invalid.
      m_InvalidPPM = TRUE;
      if (m_pSubmit == NULL) {
          // Bogus pSubmit passed in, as we expect a valid one
          // when we haven't had m_pSubmit set yet.
          char *pErrorDescription = "SetOutput passed a NULL IUnknown *";
          ppm::PPMError(E_INVALIDARG, SEVERITY_FATAL, (BYTE *) pErrorDescription, 
                       strlen(pErrorDescription));
          DBG_MSG(DBG_ERROR, ("ppmReceive::SetOutput: ERROR - pSubmit == NULL"));
          return PPMERR(PPM_E_FAIL);
      } else {
          // Passing in a NULL pSubmit when m_pSubmit is non-NULL
          // means that the PPM should release the submit
          // interface it holds. This is basically a "shut up"
          // command to the PPM.
          m_pSubmit->Release();
          m_pSubmit = (ISubmit *) NULL;
          return NOERROR;
      } /* if */
   } /* if */

   //Set Member
   pSubmit->QueryInterface (IID_ISubmit, (void **)&m_pSubmit);

   if (m_pSubmit == NULL)
   {
	  m_InvalidPPM = TRUE;
      char *pErrorDescription = "SetOutput unable to query ISubmit on indicated IUnknown *";
      ppm::PPMError(E_INVALIDARG, SEVERITY_FATAL, (BYTE *) pErrorDescription, 
                    strlen(pErrorDescription));
	  DBG_MSG(DBG_ERROR, ("ppmReceive::SetOutput: ERROR - Invalid ISubmit argument"));
      return PPMERR(PPM_E_FAIL);
   }

   return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Internal PPMReceive Functions
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//   CUnknown Function (Overrides)

HRESULT ppmReceive::GetInterface( REFIID riid, LPVOID FAR* ppvObj )
{
  //Check for the interfaces I derived from directly
  //if it is one of them then return and Cunknown will 
  //add ref it.     
  if   ( riid == IID_IPPMReceive )
  {
     *ppvObj = (IPPMReceive *)(this);
  }
  else if( riid == IID_IPPMReceiveExperimental )
  {
     *ppvObj = (IPPMReceiveExperimental *)(this);
  }
  else if( riid == IID_IPPMReceiveSession )
  {
     *ppvObj = (IPPMReceiveSession *)(this);
  }
  else if( riid == IID_ISubmit )
  {
     *ppvObj = (ISubmit *)(this);
  }
  else if( riid == IID_ISubmitCallback)
  {
     *ppvObj = (ISubmitCallback *)(this);
  }
  else if( riid == IID_ISubmitUser)
  {
     *ppvObj = (ISubmitUser *)(this);
  }
  else if( riid == IID_IConnectionPointContainer)
  {
      *ppvObj = (IConnectionPointContainer *) &m_cConnPointContainer;
  }
  else if( riid == IID_IPPMData)
  {
      *ppvObj = (IPPMData *)(this);
  }
  else 
  {
	 DBG_MSG(DBG_ERROR, ("ppmReceive::GetInterface: ERROR - Do not support requested interface"));
     return E_NOINTERFACE;
  }
  
  return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// ppmReceive Functions
//

/////////////////////////////////////////////////////////////////////////////
//GetMsgHeader: This function just hides the implementation of the free list of 
//              MsgHeaders.
/////////////////////////////////////////////////////////////////////////////
inline MsgHeader * ppmReceive::GetMsgHeader()     
{
return new (m_pMsgHeaderPool) MsgHeader;
}

//////////////////////////////////////////////////////////////////////////////////////////
//InitProfileHeader: Given a buffer as type void, sets up a profile header.  Does nothing
//					for the Generic case.  Intended for overrides for various payloads.
//					Companion member function FreeProfileHeader provided so that if payload
//					header memory is allocated in this function, it can be freed there.
//////////////////////////////////////////////////////////////////////////////////////////
void *ppmReceive::InitProfileHeader(void *pBuffer)
{
	return pBuffer;
}

//////////////////////////////////////////////////////////////////////////////////////////
//FreeProfileHeader: Given a buffer as type void, frees up a profile header.  Does nothing
//					for the Generic case.  Intended for overrides for various payloads.
//					Companion member function InitProfileHeader may allocate memory for
//					payload header which needs to be freed here. No return value.
//////////////////////////////////////////////////////////////////////////////////////////
void ppmReceive::FreeProfileHeader(void *pBuffer)
{
	return;
}

//////////////////////////////////////////////////////////////////////////////////////////
//VoidToFragment: Given a buffer as type void, and a Frag Descriptor.
//                Set the fields in the frag descriptor to point to the various structures
//                contained in the buffer. These structures are, the RTP header, the profile
//                header and the data.  For a derived class to access any members of 
//                the Profile Header he will have to typecast the m_pProfileHeader 
//                member of the Frag Descriptor every time he wants to use it. 
//////////////////////////////////////////////////////////////////////////////////////////
void ppmReceive::VoidToFragment(WSABUF *pWSABuffer, DWORD BufferCount, 
								FragDescriptor *pFragDescrip, void *pUserToken)
{
   if ((pWSABuffer == NULL) || (pFragDescrip == NULL) || (BufferCount == 0)) {
		DBG_MSG(DBG_ERROR, ("ppmReceive::VoidToFragment: ERROR - NULL pWSABuffer, pFragDescrip or BufferCount"));
	   return;
   }
   
   //set void star buffer and cookie
   pFragDescrip->m_pRecBuffer = (void *) pWSABuffer[BufferCount-1].buf;
   pFragDescrip->m_pFragCookie = pUserToken;


   //Set RTPHeader pointer
#ifdef RTP_CLASS
   pFragDescrip->m_pRTPHeader = (RTP_Header *) pWSABuffer[0].buf;
#else
   pFragDescrip->m_pRTPHeader = (RTP_HDR_T*) pWSABuffer[0].buf;
#endif
   
   //Don't set the profile header pointer if there is no Profile header.
   if (ReadProfileHeaderSize() != 0)
   {
	   if (BufferCount > 1) { //Profile header will be in 2nd WSABUF
			pFragDescrip->m_pProfileHeader = InitProfileHeader((void *) 
				pWSABuffer[1].buf);
	   } else {
#ifdef RTP_CLASS
		pFragDescrip->m_pProfileHeader = InitProfileHeader((void *) 
			((BYTE*)pFragDescrip->m_pRecBuffer + 
			pFragDescrip->m_pRTPHeader->header_size()));
#else
			pFragDescrip->m_pProfileHeader = InitProfileHeader((void *) 
				((BYTE*)pFragDescrip->m_pRecBuffer + sizeof(RTP_HDR_T)));
#endif
	   }
   }
   
   //Set Data Pointer.
	if (BufferCount > 1) { //data will be in last WSABUF
		pFragDescrip->m_pData = (void *) pWSABuffer[BufferCount-1].buf; 
	} else {
#ifdef RTP_CLASS
		pFragDescrip->m_pData = (void *) ((BYTE*) pFragDescrip->m_pRecBuffer + 
			(pFragDescrip->m_pRTPHeader->header_size() + 
			ReadProfileHeaderSize(pFragDescrip->m_pProfileHeader)));
#else
		pFragDescrip->m_pData = (void *) ((BYTE*) pFragDescrip->m_pRecBuffer + 
			(sizeof(RTP_HDR_T) + ReadProfileHeaderSize(pFragDescrip->m_pProfileHeader)));
#endif
	}

   //number of bytes in packet.
   pFragDescrip->m_BytesInPacket  =  pWSABuffer[BufferCount-1].len;
   
   //Number of bytes in packet minus the headers
   if (BufferCount == 1) {
#ifdef RTP_CLASS
	pFragDescrip->m_BytesOfData    =  pFragDescrip->m_BytesInPacket  - 
		(pFragDescrip->m_pRTPHeader->header_size() + 
		ReadProfileHeaderSize(pFragDescrip->m_pProfileHeader));
#else
	pFragDescrip->m_BytesOfData    =  pFragDescrip->m_BytesInPacket  - 
		(sizeof(RTP_HDR_T) + 
		ReadProfileHeaderSize(pFragDescrip->m_pProfileHeader));
#endif
   } else {
   	pFragDescrip->m_BytesOfData    =  pFragDescrip->m_BytesInPacket;
   }
#ifdef _DEBUG
#ifdef RTP_CLASS
	 DBG_MSG(DBG_TRACE, ("PPMReceive::VoidtoFragment Thread %ld - just processed fragment %d, data size %d\n",
		 GetCurrentThreadId(), pFragDescrip->m_pRTPHeader->seq(), pFragDescrip->m_BytesOfData));
#else
	 DBG_MSG(DBG_TRACE, ("PPMReceive::VoidtoFragment Thread %ld - just processed fragment %d, data size %d\n",
		 GetCurrentThreadId(), ntohs(pFragDescrip->m_pRTPHeader->seq),pFragDescrip->m_BytesOfData));
#endif
#endif

}


//////////////////////////////////////////////////////////////////////////////////////////
//SetupTimer: Sets up Timer and returns a Timer ID. If null is returned function failed
//            to initialize a timer.
//////////////////////////////////////////////////////////////////////////////////////////
MMRESULT ppmReceive::SetupTimer()
{
   TIMECAPS tc;
   MMRESULT ID;

   //Get system information about timers, i.e. resolution, if it fails, something is wrong.
   if (timeGetDevCaps(&tc, sizeof(TIMECAPS)) != TIMERR_NOERROR)
   {
	  DBG_MSG(DBG_ERROR, ("ppmReceive::SetupTimer: ERROR - invalid Timer info"));
      return NULL;
   }
   
   //if the minimum the system can offer is greater than ten then use the system
   //minimum.  If the system minimum is less than ten, then use the value of ten.
   if (m_reg_TimerResolution < tc.wPeriodMin)
   {
      m_reg_TimerResolution	= tc.wPeriodMin;
   }

   //Setup the timer. The zero is for User supplied callback data.
   ID = timeSetEvent(m_reg_TimerInterval,
					 m_reg_TimerResolution,
					 PPM_Timer,
					 (DWORD_PTR)this,
					 TIME_PERIODIC);
   
   //if timeSetEvent fails then NULL is passed back.
   return ID;
}

//////////////////////////////////////////////////////////////////////////////////////////
//EnqueByMessage: Finds the MsgHeader and calls EnqueueByFrag.
//////////////////////////////////////////////////////////////////////////////////////////

int test_counter = 0;

HRESULT ppmReceive::EnqueByMessage(FragDescriptor *pFragDescrip)
{
  
   MsgHeader *pMsgHdr;
   HRESULT rval;
      
      
   if (pFragDescrip == NULL) {
		DBG_MSG(DBG_ERROR, ("ppmReceive::EnqueByMessage: ERROR - pFragDescrip == NULL"));
	   return PPMERR(PPM_E_INVALID_PARAM);
   }
    
   if (m_GlobalLastSSRC != pFragDescrip->m_pRTPHeader->ssrc())
   {
       DWORD oldSSRC = m_GlobalLastSSRC;
       m_GlobalLastSSRC = pFragDescrip->m_pRTPHeader->ssrc();

       if (oldSSRC != 0)
       {
           Flush();
       }
   }

   //this sets the global variables so we know what the beginning of the first
   //packet.
   if (m_FirstPacket)
   {
#ifdef RTP_CLASS
     m_GlobalLastMsgID  = pFragDescrip->m_pRTPHeader->ts()  - 1;
     m_GlobalLastSeqNum = pFragDescrip->m_pRTPHeader->seq() - 1;
#else
     m_GlobalLastMsgID  = ntohl(pFragDescrip->m_pRTPHeader->ts)  - 1;
     m_GlobalLastSeqNum = ntohs(pFragDescrip->m_pRTPHeader->seq) - 1;
#endif
     m_FirstPacket = FALSE;
	 DBG_MSG(DBG_TRACE, ("ppmReceive::EnqueByMessage: first packet, m_GlobalLastSeqNum=%d", m_GlobalLastSeqNum));
   } 

   //if this is a packet from a frame already sent, toss packet.
#ifdef RTP_CLASS
   if (LongWrapGt(m_GlobalLastMsgID, pFragDescrip->m_pRTPHeader->ts()))
   {  
      if (ShortWrapGt(pFragDescrip->m_pRTPHeader->seq(), m_GlobalLastSeqNum))
      {
         m_GlobalLastSeqNum = pFragDescrip->m_pRTPHeader->seq();
		 DBG_MSG(DBG_TRACE, ("ppmReceive::EnqueByMessage: stale packet, m_GlobalLastSeqNum=%d", m_GlobalLastSeqNum));
      }
#else
   if (LongWrapGt(m_GlobalLastMsgID, ntohl(pFragDescrip->m_pRTPHeader->ts)))
   {  
      if (ShortWrapGt(ntohs(pFragDescrip->m_pRTPHeader->seq), m_GlobalLastSeqNum))
      {
         m_GlobalLastSeqNum = ntohs(pFragDescrip->m_pRTPHeader->seq);
      }
#endif

	  m_pSubmitCallback->SubmitComplete((void *)pFragDescrip->m_pFragCookie, NOERROR);

	  if (pFragDescrip->m_pProfileHeader)
		  FreeProfileHeader(pFragDescrip->m_pProfileHeader);
      FreeFragDescriptor(pFragDescrip);
      return NOERROR;
   }
   
   //Get message header this fragment belongs to.
#ifdef RTP_CLASS
   pMsgHdr  = FindMsgHeader(pFragDescrip->m_pRTPHeader->ts());  //is critical sectioned.
#else
   pMsgHdr  = FindMsgHeader(ntohl(pFragDescrip->m_pRTPHeader->ts));  //is critical sectioned.
#endif
   if (pMsgHdr == NULL) {
		DBG_MSG(DBG_ERROR, ("ppmReceive::EnqueByMessage: ERROR - FindMsgHeader failed"));
	   return PPMERR(PPM_E_DROPFRAG);
   }

   if FAILED (rval = EnqueueByFrag(pFragDescrip,pMsgHdr)) {       //is critical sectioned.
		DBG_MSG(DBG_ERROR, ("ppmReceive::EnqueByMessage: ERROR - EnqueueByFrag failed"));
	   return rval;
   }

   return NOERROR;
}  


//////////////////////////////////////////////////////////////////////////////////////////
//EnqueueByFrag: Enqueues frag, calls ProcessMessages if appropriate.  If any error 
//               conditions are added, you MUST call LeaveCriticalSection. (it is critical)
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT ppmReceive::EnqueueByFrag(FragDescriptor *pFragDescrip, MsgHeader *pMsgHdr) 
{ 
   HRESULT Status;

   EnterCriticalSection(&m_CritSec);

   if (pMsgHdr  == NULL || pMsgHdr->m_pFragList == NULL) {
	   DBG_MSG(DBG_ERROR, ("ppmReceive::EnqueueByFrag: ERROR - pMsgHdr == NULL"));
	   LeaveCriticalSection(&m_CritSec);
	   return PPMERR(PPM_E_EMPTYQUE);
   }

   if (pFragDescrip == NULL) {
	   	DBG_MSG(DBG_ERROR, ("ppmReceive::EnqueueByFrag: ERROR - pFragDescrip == NULL"));
	   LeaveCriticalSection(&m_CritSec);
	   return PPMERR(PPM_E_INVALID_PARAM);
   }

#ifdef RTP_CLASS
   Status = pMsgHdr->m_pFragList->AddToList(pFragDescrip, pFragDescrip->m_pRTPHeader->seq());
   DBG_MSG(DBG_TRACE,
	   ("ppmReceive::EnqueueByFrag: FragDescriptor*=0x%08lx, seq=%d, ts=%ld",
	   pFragDescrip,
	   pFragDescrip->m_pRTPHeader->seq(),
	   pFragDescrip->m_pRTPHeader->ts()));
#else
   Status = pMsgHdr->m_pFragList->AddToList(pFragDescrip, ntohs(pFragDescrip->m_pRTPHeader->seq));
#endif

   //The Enqueue function checks for duplicate packets and does something smart.
   if (FAILED(Status)) {
	   if  (Status == PPMERR(PPM_E_DUPLICATE))
	   {
		  m_pSubmitCallback->SubmitComplete(pFragDescrip->m_pFragCookie, NOERROR);

		  if (pFragDescrip->m_pProfileHeader) FreeProfileHeader(pFragDescrip->m_pProfileHeader);
		  FreeFragDescriptor(pFragDescrip);
      
		  LeaveCriticalSection(&m_CritSec);
		  return NOERROR; 
	   } else {
		  DBG_MSG(DBG_ERROR, ("ppmReceive::EnqueueByFrag: ERROR - Could not enqueue the frag"));
          // I'm prety shure we also need to SubmitComplete here
		  m_pSubmitCallback->SubmitComplete(pFragDescrip->m_pFragCookie, NOERROR);
		  if (pFragDescrip->m_pProfileHeader) FreeProfileHeader(pFragDescrip->m_pProfileHeader);
		  FreeFragDescriptor(pFragDescrip);
      
		  LeaveCriticalSection(&m_CritSec);
		  return PPMERR(PPM_E_FAIL); 
	   }
   }

   // Increase the number of packets (CRTPSample) we retain (have AddRef'ed)
   m_PacketsHold++;
   
   //set flag if marker bit has come in
#ifdef RTP_CLASS
   if (pFragDescrip->m_pRTPHeader->m() == 1) 
#else
   if (pFragDescrip->m_pRTPHeader->m == 1) 
#endif
	   pMsgHdr->m_MarkerBitIn = TRUE;
     
   pMsgHdr->m_NumFragments += 1;
   pMsgHdr->m_TimeOfLastPacket = timeGetTime();

   //Note: we no longer propogate errors from ProcessMessages or TimeOut, because after
   //  the last submitted fragment has been enqueued, the errors may be out of contect
   //  for return from Submit()
   if (TimeToProcessMessages(pFragDescrip, pMsgHdr))
   {
      ProcessMessages();
   }

   else 
   {
      TimeOut(); //TimeOut routine calls ProcessMessages after checking for stalenes			  
   }

   LeaveCriticalSection(&m_CritSec);
   return NOERROR;
}

//////////////////////////////////////////////////////////////////////////////////////////
//TimeToProcessMessages: 
//////////////////////////////////////////////////////////////////////////////////////////
BOOL ppmReceive::TimeToProcessMessages(FragDescriptor *pFragDescrip, MsgHeader *pMsgHdr)
{
   //It's time to process messages only for cases where it goes in first msg or start of 
   //2nd msg. Three cases because you have to check to see if the head's next is null.
   return ((m_pMsgHeadersHead->m_pNext == NULL) || (pMsgHdr == m_pMsgHeadersHead) || 
#ifdef RTP_CLASS
       (pFragDescrip->m_pRTPHeader->seq() == 
	   m_pMsgHeadersHead->m_pNext->m_pFragList->FirstSeqNum()));
#else
       (ntohs(pFragDescrip->m_pRTPHeader->seq) == 
	   m_pMsgHeadersHead->m_pNext->m_pFragList->FirstSeqNum()));
#endif
}

//////////////////////////////////////////////////////////////////////////////////////////
//ProcessMessages: 
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT ppmReceive::ProcessMessages(void)
{
	HRESULT rval;

	EnterCriticalSection(&m_CritSec);

   while(m_pMsgHeadersHead != NULL)
    {
       if (CheckMessageComplete(m_pMsgHeadersHead))
       {
          if FAILED(rval = PrepMessage(TRUE)) {
			  DBG_MSG(DBG_ERROR, ("ppmReceive::ProcessMessages: ERROR - PrepMessage failed"));
			  LeaveCriticalSection(&m_CritSec);
			  return rval;
		  }
       }

#ifndef TOSS_STALE_OFF

	   else if (CheckMessageStale(m_pMsgHeadersHead) ||
				m_PacketsHold >= 8) /* BUGBUG this 8 should be dynamic
									   but right now I know that I can have
									   only 8 buffers per RPH in the RTP
									   source filter, and if we keep 4 here
									   we get into a deadlock. */
       {
          if FAILED(rval = PrepMessage(FALSE)) {
			  DBG_MSG(DBG_ERROR, ("ppmReceive::ProcessMessages: ERROR - PrepMessage failed"));
			  LeaveCriticalSection(&m_CritSec);
			  return rval;
		  }
       }
#endif
       
       else //no more stale or complete messages in list.
       {
		  LeaveCriticalSection(&m_CritSec);
          return NOERROR;
       }
    }
   //List is empty
   LeaveCriticalSection(&m_CritSec);
   return NOERROR;
}
          
//////////////////////////////////////////////////////////////////////////////////////////
//CheckMessageComplete: 
//////////////////////////////////////////////////////////////////////////////////////////
BOOL ppmReceive::CheckMessageComplete(MsgHeader *pMsgHdr) 
{
   //if there is no header then return false.
	if (pMsgHdr  == NULL) {
		DBG_MSG(DBG_ERROR, ("ppmReceive::CheckMessageComplete: ERROR - pMsgHdr == NULL"));
	   return FALSE;
   }

   //should there be a critical section in this function.  What about wraps?

   //check to make sure we have the first packet in the message.
   if (pMsgHdr->m_pPrev == NULL) // if first message in list, then look at a variable
   {
      if (m_GlobalLastSeqNum != pMsgHdr->m_pFragList->FirstSeqNum()-1)
      {
         return FALSE; 
      }
   }
   
   else 
   {
      if (pMsgHdr->m_pPrev->m_pFragList->LastSeqNum() != pMsgHdr->m_pFragList->FirstSeqNum()-1)
      {
         return FALSE;
      }
   }

   //check to make sure we have the last packet in the message. 
   if (pMsgHdr->m_pNext == NULL)     //if we don't have the next message,
   {                              //we don't know if the current message is done.
      return FALSE;          
   }
      
   
   if (pMsgHdr->m_pNext->m_pFragList->FirstSeqNum() != pMsgHdr->m_pFragList->LastSeqNum()+1)
   {
      return FALSE;
   }

   //Check for a packet missing in the middle->
   if ((pMsgHdr->m_pFragList->LastSeqNum() - pMsgHdr->m_pFragList->FirstSeqNum() + 1) !=
                                                                 (DWORD)pMsgHdr->m_NumFragments)
   {
      return FALSE;
   }

   return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////////
//CheckMessageStale: 
//////////////////////////////////////////////////////////////////////////////////////////
BOOL ppmReceive::CheckMessageStale   (MsgHeader *pMsgHdr)
{  
   //if there is no header then return false.
	if (pMsgHdr  == NULL) {
		DBG_MSG(DBG_ERROR, ("ppmReceive::CheckMessageStale: ERROR - pMsgHdr == NULL"));
	   return FALSE;
   }
  
   //if the time span between the current time and the last time a packet came in on this 
   //message is greater than than a given delta time then this message is stale.
   //Use wrap function to make sure we don't get a negative number on wrap.
   return (BOOL)  (LongWrapDelta(timeGetTime(),pMsgHdr->m_TimeOfLastPacket) > m_reg_DeltaTime); 
  
}

//////////////////////////////////////////////////////////////////////////////////////////
//TakeMsgHeader: 
//////////////////////////////////////////////////////////////////////////////////////////
MsgHeader *ppmReceive::TakeMsgHeader()
{
   EnterCriticalSection(&m_CritSec);
   //List Maintenance.
   //Can't hurt to check although we should never get here if there is no head.
   if (!m_pMsgHeadersHead) {	   
		DBG_MSG(DBG_ERROR, ("ppmReceive::TakeMsgHeader: ERROR - m_pMsgHeadersHead == NULL"));
	   LeaveCriticalSection(&m_CritSec);
	   return NULL;
   }

   //Take the first thing off the list.
   MsgHeader *pMsgHdr = m_pMsgHeadersHead;
   
   //Set the new head of the list.
   m_pMsgHeadersHead = m_pMsgHeadersHead->m_pNext;	 

   //Set the new head's previous to Null so it can't access the message being processed.
   if (m_pMsgHeadersHead != NULL)
   {
      m_pMsgHeadersHead->m_pPrev = NULL;
   }

   //Set the next and prev of the msg to be processed to null, so it can't touch the list.
   pMsgHdr->m_pNext = NULL;
   pMsgHdr->m_pPrev = NULL;

   //if the head is null then make sure the tail doesn't point to anything.
   if  (m_pMsgHeadersHead == NULL)					 
   {
      m_pMsgHeadersTail = NULL;
   }
   
   LeaveCriticalSection(&m_CritSec);

   return pMsgHdr;
}

//////////////////////////////////////////////////////////////////////////////////////////
//PrepMessage: Sets global variables, calls DataCopy.  If any error checks are added, 
//             you MUST make a call to LeaveCriticalSection.
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT ppmReceive::PrepMessage(BOOL Complete) 
{
   HRESULT Status;

   EnterCriticalSection(&m_CritSec);

   MsgHeader *pMsgHdr = TakeMsgHeader();

   if (!pMsgHdr) {	   
		DBG_MSG(DBG_ERROR, ("ppmReceive::PrepMessage: ERROR - pMsgHdr == NULL"));
	   LeaveCriticalSection(&m_CritSec);
	   return PPMERR(PPM_E_CORRUPTED);
   }

   DWORD dwLastSeqNum   = pMsgHdr->m_pFragList->LastSeqNum();
   DWORD dwLastMsgID    = pMsgHdr->GetMsgID();

   //Handle the frame.
   if  (Complete)
   {
      Status = DataCopy(pMsgHdr);
   }
   else
   {
      Status = PartialMessageHandler(pMsgHdr);
   }

   // Update the global variables _after_ PartialMessageHandler(),
   // which needs previous state.
   m_GlobalLastSeqNum = dwLastSeqNum;
   m_GlobalLastMsgID  = dwLastMsgID;
   
   DBG_MSG(DBG_TRACE, ("ppmReceive::PrepMessage: m_GlobalLastSeqNum=%d", m_GlobalLastSeqNum));
      
   LeaveCriticalSection(&m_CritSec);
   return Status;
}

//////////////////////////////////////////////////////////////////////////////////////////
//DataCopy: Copies data fragments into client's buffer.  If any error checks with returns
//          are added they MUST call LeaveCriticalSection.
//           
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT ppmReceive::DataCopy(MsgHeader *const pMsgHdr)    
{
  	 FragDescriptor *tmpFragHeader;
	 WSABUF tmpWSABUF[2];

	 DWORD          BufSize       = 0;
	 MsgDescriptor *BD            = DequeueBuffer(1); //Get a buffer to hold the message.
     void          *CurrentOffset;   //where to copy into buffer.
	 HRESULT		Status		  = NOERROR;

	if (pMsgHdr  == NULL) {
		DBG_MSG(DBG_ERROR, ("ppmReceive::DataCopy: ERROR - pMsgHdr == NULL"));
	   return PPMERR(PPM_E_EMPTYQUE);
   }

	if (BD  == NULL) {
		FreeFragList(pMsgHdr);
  	   	FreeMsgHeader(pMsgHdr);

		DBG_MSG(DBG_ERROR, ("ppmReceive::DataCopy: ERROR - Couldn't get a reassembly buffer"));

        // Make a callback into the app to let it know what happened.
        ppm::PPMNotification(PPM_E_DROPFRAME, SEVERITY_NORMAL, NULL, 0);
        m_GlobalLastFrameDropped = TRUE;

	    return PPMERR(PPM_E_DROPFRAME);
   }
   
	CurrentOffset = BD->m_pBuffer;   //start copying into front of buffer.


	EnterCriticalSection(&m_CritSec);

     while (!pMsgHdr->m_pFragList->Is_Empty())
     {
		//get next fragment	
        tmpFragHeader = (FragDescriptor *)pMsgHdr->m_pFragList->TakeFromList();

		// Decrease the count of packets (CRTPSample) hold
		m_PacketsHold--;
		
		//check to see if tmpFragHeader returned NULL OR
		//check to make sure we won't overrun the buffer.
		if ((tmpFragHeader == NULL) ||
		   (BufSize + tmpFragHeader->m_BytesOfData > BD->m_Size))
		{
		   FreeFragList(pMsgHdr);
           EnqueueBuffer(BD);
  	   	   FreeMsgHeader(pMsgHdr);

           LeaveCriticalSection(&m_CritSec);
		   DBG_MSG(DBG_ERROR, ("ppmReceive::DataCopy: ERROR - null tmpFragHeader or buffer overrun"));
           if (tmpFragHeader != NULL) {
			   // Release the CRTPSample to receive more data
			   m_pSubmitCallback->SubmitComplete(tmpFragHeader->m_pFragCookie,
												  NOERROR);
               // Make a callback into the app to let it know what happened.
               ppm::PPMNotification(PPM_E_RECVSIZE, SEVERITY_NORMAL, NULL, 0);
           } /* if */
           m_GlobalLastFrameDropped = TRUE;

		   return PPMERR(PPM_E_DROPFRAME);
		}

		//do the copy.
        memcpy(CurrentOffset, (void *)tmpFragHeader->m_pData, tmpFragHeader->m_BytesOfData );
        CurrentOffset = (BYTE *)CurrentOffset + tmpFragHeader->m_BytesOfData;
		BufSize += tmpFragHeader->m_BytesOfData;

		//send the frag buffer back down to receive more data and free the frag header.
		m_pSubmitCallback->SubmitComplete((void *)tmpFragHeader->m_pFragCookie, NOERROR);

        if (tmpFragHeader->m_pProfileHeader) FreeProfileHeader(tmpFragHeader->m_pProfileHeader);
        FreeFragDescriptor(tmpFragHeader);
     }
     
#ifdef GIVE_SEQNUM
		BD->m_TimeStamp = pMsgHdr->m_pFragList->LastSeqNum();
#else
		BD->m_TimeStamp = pMsgHdr->GetMsgID();
#endif

     LeaveCriticalSection(&m_CritSec);

     //When we are done. Call Client's submit with full Message
	 tmpWSABUF[0].buf = (char *) BD->m_pBuffer;
	 tmpWSABUF[0].len = BufSize;
	 tmpWSABUF[1].buf = (char *) &(BD->m_TimeStamp);
	 tmpWSABUF[1].len = sizeof(BD->m_TimeStamp);

#ifdef _DEBUG
	 DBG_MSG(DBG_TRACE,  ("PPMReceive::DataCopy Thread %ld - is giving client app Msg descriptor %x, buf ptr %x, size %d\n",
		 GetCurrentThreadId(), BD,BD->m_pBuffer,BufSize));
#endif

     FreeMsgHeader(pMsgHdr);

	 if (m_GlobalLastFrameDropped)
		Status = m_pSubmit->Submit(tmpWSABUF, 2, (void *) BD, PPMERR(PPM_E_DROPFRAME));
	else
		Status = m_pSubmit->Submit(tmpWSABUF, 2, (void *) BD, NOERROR);

     EnterCriticalSection(&m_CritSec);
	 m_GlobalLastFrameDropped = FALSE;
     LeaveCriticalSection(&m_CritSec);

     if (FAILED(Status))
     {
		 //no SubmitComplete should be called, so take care of resources now
		 //BD->m_Size = m_MaxBufferSize;  //reset the data buffer size
		 //EnqueueBuffer(BD);
		 DBG_MSG(DBG_ERROR, ("ppmReceive::DataCopy: ERROR - Client Submit failed"));
		 Status = PPMERR(PPM_E_CLIENTERR);
         // Make a callback into the app to let it know what happened.
         ppm::PPMNotification(PPM_E_CLIENTERR, SEVERITY_NORMAL, NULL, 0);
		 EnterCriticalSection(&m_CritSec);
	     m_GlobalLastFrameDropped = TRUE;
		 LeaveCriticalSection(&m_CritSec);
     }

     return Status;
}

//////////////////////////////////////////////////////////////////////////////////////////
//PartialMessageHandler: deals with partial messages
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT ppmReceive::PartialMessageHandler(MsgHeader *pMsgHdr)
{
DWORD tmpTS;

   if (pMsgHdr  == NULL) {
		DBG_MSG(DBG_ERROR, ("ppmReceive::PartialMessageHandler: ERROR - pMsgHdr == NULL"));
	   return PPMERR(PPM_E_EMPTYQUE);
   }
         
   // Make a callback into the app to let it know about this dropped frame
   // We also pass the timestamp of the frame
   tmpTS = pMsgHdr->GetMsgID();
   ppm::PPMNotification(PPM_E_DROPFRAME, SEVERITY_NORMAL, (UCHAR *) &tmpTS, 
      sizeof(tmpTS));
   EnterCriticalSection(&m_CritSec);
   m_GlobalLastFrameDropped = TRUE;
   LeaveCriticalSection(&m_CritSec);

   FreeFragList(pMsgHdr); 
   FreeMsgHeader(pMsgHdr);

   return NOERROR;
}

//////////////////////////////////////////////////////////////////////////////////////////
//FreeFragList:  Re-posts fragment buffers and frees header memory.
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT ppmReceive::FreeFragList(MsgHeader *pMsgHdr)
{
   FragDescriptor *pFragDescrip;

   if (pMsgHdr  == NULL) {
		DBG_MSG(DBG_ERROR, ("ppmReceive::FreeFragList: ERROR - pMsgHdr == NULL"));
	   return PPMERR(PPM_E_EMPTYQUE);
   }

   while(pMsgHdr->m_pFragList->Is_Empty() == FALSE)
   {
      //get next fragment
      pFragDescrip = (FragDescriptor *)pMsgHdr->m_pFragList->TakeFromList(); 
	  m_PacketsHold--;
	  
	  //always pass zero because we never allocated the buffers and therefore
	  //have no idea how big the buffers are and therefore the guy I am sending them
	  //to must have allocated them and will know how big they are.
	  m_pSubmitCallback->SubmitComplete(pFragDescrip->m_pFragCookie, NOERROR);

      if (pFragDescrip->m_pProfileHeader) FreeProfileHeader(pFragDescrip->m_pProfileHeader);
      FreeFragDescriptor(pFragDescrip);
   }

   return NOERROR;
}


//////////////////////////////////////////////////////////////////////////////////////////
//TimeOut: Calls Staleness check then calls process msgs.
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT ppmReceive::TimeOut(void)                    
{
   
   
   if ( (m_pMsgHeadersHead != NULL) &&
		( CheckMessageStale(m_pMsgHeadersHead) || m_PacketsHold >= 4) )
   {
         PrepMessage(FALSE);
         ProcessMessages();
   }
   return NOERROR;
}


///////////////////////////////////////////////////////////////////////////////////////////
//FindMsgHeader: Walks the list of MsgHeaders. If it finds MsgHeader it wants then it 
//              a pointer to it. If one is not found, one is created and put in place. 
//              List is walked in ascending order. This is slightly less efficient, but
//              a lot easier to code.             
//////////////////////////////////////////////////////////////////////////////////////////
MsgHeader* ppmReceive::FindMsgHeader(DWORD MessageID)
{
  MsgHeader *pMsgHdr;
  MsgHeader *pTmp;

  EnterCriticalSection(&m_CritSec);
 
  //corrupt list
   if (!( (!m_pMsgHeadersHead && !m_pMsgHeadersTail) ||  //both are NULL
           ( m_pMsgHeadersHead &&  m_pMsgHeadersTail) )) {   //or both are NOT NULL
		DBG_MSG(DBG_ERROR, ("ppmReceive::FindMsgHeader: MsgHeader list is corrupt"));
       LeaveCriticalSection(&m_CritSec);
	   return NULL;
   }
   pTmp = m_pMsgHeadersHead;

   while (pTmp != NULL)
   {
        if (pTmp->GetMsgID() == MessageID)
        {
          LeaveCriticalSection(&m_CritSec);
 	      return pTmp;
        }
   
        if (LongWrapGt(pTmp->GetMsgID(),MessageID))
	    {
	       pMsgHdr = GetMsgHeader();
       
           if (pMsgHdr == NULL)
	       {   
			  DBG_MSG(DBG_ERROR, ("ppmReceive::FindMsgHeader: Could not allocate a msg header"));
              LeaveCriticalSection(&m_CritSec);
   	          return NULL;
	       }

 		   pMsgHdr->m_pNext = pTmp;             //set pMsgHdr pointer to the current
           pMsgHdr->m_pPrev = pTmp->m_pPrev;    //set pMsgHdr pointer to the current's previous
           
           pTmp->m_pPrev = pMsgHdr;
           
           if (pMsgHdr->m_pPrev == NULL)        //if at head of list.
           {  
              m_pMsgHeadersHead = pMsgHdr;
           }
          
           else                              //if NOT at head of list, reset head pointer.
           { 
              pMsgHdr->m_pPrev->m_pNext = pMsgHdr;
           }
          
           pMsgHdr->m_MessageID = MessageID;
           LeaveCriticalSection(&m_CritSec);
	       return  pMsgHdr;
	    }
	  
        pTmp = pTmp->m_pNext;
   }
   //else it goes on the end of the list.(the list might be NULL)
   pMsgHdr = GetMsgHeader();

   if (pMsgHdr == NULL)
   {   
	   DBG_MSG(DBG_ERROR, ("ppmReceive::FindMsgHeader: Could not allocate a msg header"));
       LeaveCriticalSection(&m_CritSec);
       return NULL;
   }

   if (m_pMsgHeadersHead == NULL)   //if list is empty then set the head to the new Hdr.
   {
      m_pMsgHeadersHead = pMsgHdr;  //set the Hdr as the Head of the list.
      pMsgHdr->m_pPrev = NULL;      //it it is the head, it's has nothing before it.
   }
   else                             //List is NOT empty and attatch new hdr on tail.
   {           
      m_pMsgHeadersTail->m_pNext = pMsgHdr; 
   }

   pMsgHdr->m_pPrev = m_pMsgHeadersTail; //attatching new hdr to tail.
   m_pMsgHeadersTail = pMsgHdr;			 //make new msg the new tail.
   pMsgHdr->m_pNext = NULL;              //if it is the tail it has nothing after it.
        
   pMsgHdr->m_MessageID = MessageID;
   LeaveCriticalSection(&m_CritSec);
   return pMsgHdr;

}
//////////////////////////////////////////////////////////////////////////////////////////
//PPM_MMTimer: timer callback
//////////////////////////////////////////////////////////////////////////////////////////
void CALLBACK PPM_Timer(UINT uID, UINT uMsg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2)
{
   
   ((ppmReceive *)dwUser)->TimeOut();
   UNREFERENCED_PARAMETER(uID);
   UNREFERENCED_PARAMETER(uMsg);
   UNREFERENCED_PARAMETER(dw1); 
   UNREFERENCED_PARAMETER(dw2); 
}

////////////////////////////////////////////////////////////////////////////////////////
// ReportOutstandingData: Walks through the message and fragment lists and reports back
// to caller via callback
// Returns TRUE if data is valid
// returns FALSE if an error occurred - values in formal parameters will be invalid
////////////////////////////////////////////////////////////////////////////////////////
//
//	 Ptr and count of MsgHdr's   <-------- Data being delivered via callback
//	 |
//	 V
//
//	|MsgId |
//	|Count |     _____________________________
//	|pFrag |---->| frag_seq_no | frag_seq_no | ....
//	|----- |     -----------------------------
//	|MsgId |
//	|Count |
//	|pFrag |
//
//
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP ppmReceive::ReportOutstandingData( DWORD** pDataHdr, DWORD* DataCount)
{
	
	OutstandingDataHdr *pMsg, *pMsgSav;

	MsgHeader *pTmp;
	int msg_count = 0;
	int i, j, k;
	

	if (m_InvalidPPM)
	{
	  DBG_MSG(DBG_ERROR, ("ppmReceive::ReportOutstandingData: ERROR - m_InvalidPPM"));
      return PPMERR(PPM_E_FAIL);;
	}

	if (m_DataOutstanding)
	{
	  DBG_MSG(DBG_ERROR, ("ppmReceive::ReportOutstandingData: Prev Memory not freed!"));
      return PPMERR(PPM_E_FAIL);;
	}

	EnterCriticalSection(&m_CritSec);
	
	if(m_pMsgHeadersHead == NULL)
	{
		DBG_MSG(DBG_ERROR, ("ppmReceive::ReportOutstandingData: MsgHeader list is Empty"));
		LeaveCriticalSection(&m_CritSec);
		return PPMERR(PPM_E_EMPTYQUE);;
	}
	
	//corrupt list
	if (!( (!m_pMsgHeadersHead && !m_pMsgHeadersTail) || //both are NULL
           ( m_pMsgHeadersHead &&  m_pMsgHeadersTail) )) //or both are NOT NULL
	{
		DBG_MSG(DBG_ERROR, ("ppmReceive::ReportOutstandingData: MsgHeader list is corrupt"));
		LeaveCriticalSection(&m_CritSec);
		return PPMERR(PPM_E_CORRUPTED);
	}
	
	// First determine how many Messages there are
	pTmp = m_pMsgHeadersHead;
	
	while (pTmp != NULL)
	{
		++msg_count;
		pTmp = pTmp->m_pNext;
	}	

	// Allocate memory for all Message headers
	if( msg_count > 0 )
	{
		pMsg = (OutstandingDataHdr *)new DWORD [sizeof(OutstandingDataHdr) * msg_count];
	}
	else
	{
		DBG_MSG(DBG_ERROR, ("ppmReceive::ReportOutstandingData: No messages to report"));
		LeaveCriticalSection(&m_CritSec);
		return PPMERR(PPM_E_EMPTYQUE);
	}
	
	// Could not allocate memory
	if (pMsg == NULL)
	{
		DBG_MSG(DBG_ERROR, ("ppmReceive::ReportOutstandingData: Unable to allocate memory OutstandingDataHdr"));
		LeaveCriticalSection(&m_CritSec);
		return PPMERR(PPM_E_OUTOFMEMORY);
	}


	// Start the loop again 
	pTmp = m_pMsgHeadersHead;
	pMsgSav = pMsg;
	
	// For every message
	for(i = 0; i < msg_count; ++i)
	{
		// Allocate space for number of fragments
		pMsg->pFrag = new DWORD [ pTmp->m_NumFragments ];
		if( pMsg->pFrag == NULL )
		{
			//Cleanup
			for(j = i - 1; j > 0; --j)
			{
				if( j >= 0)
				{
					--pMsg;
					if (pMsg->pFrag) {
						delete [] pMsg->pFrag;
					}
				}
			}

			DBG_MSG(DBG_ERROR, ("ppmReceive::ReportOutstandingData: Unable to allocate memory FragHdr"));
			LeaveCriticalSection(&m_CritSec);
			return PPMERR(PPM_E_OUTOFMEMORY);

		}
		
		pMsg->FragCount = pTmp->m_NumFragments ;
		pMsg->MsgId = pTmp->GetMsgID();



		DWORD *pTmpFrag = (DWORD *)pMsg->pFrag;

		// Walk through the fragments list and collect the sequence numbers
		for( k = 0; k < pTmp->m_NumFragments; k++ )
		{
			FragDescriptor* pItem;

			if( k == 0 )
			{
				//Establish first element
				pItem = (FragDescriptor*)pTmp->m_pFragList->NextItem( NULL );
				//Check if pItem is NULL and bail out - this should not happen		
			}
			else
			{
				// Get next element
				pItem = (FragDescriptor*)pTmp->m_pFragList->NextItem( pItem );
				//Check if pItem is NULL and bail out - this should not happen		
			}
			
			*pTmpFrag++ = pItem->m_pRTPHeader->seq();

		}

		pTmp = pTmp->m_pNext;
		pMsg++;

	}

	*pDataHdr = (DWORD *)pMsgSav;
	*DataCount = msg_count;
	m_OutstandingDataPtr = pMsgSav;
	m_OutstandingMsgCount = msg_count;
	m_DataOutstanding = TRUE;

	LeaveCriticalSection(&m_CritSec);

	return NOERROR;
}
////////////////////////////////////////////////////////////////////////////////////////
// 	ReleaseOutstandingDataBuffer - will release the buffer given to the caller
//  during a previous ReportOutstandingData call
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP ppmReceive::ReleaseOutstandingDataBuffer( DWORD *pData )
{
	OutstandingDataHdr *pMsg;
	int i;

	if (!pData) {
		return E_POINTER;
	}

	EnterCriticalSection(&m_CritSec);
	
	if( (!m_DataOutstanding) || (m_OutstandingDataPtr != (OutstandingDataHdr*)pData ) )
	{
		LeaveCriticalSection(&m_CritSec);
		return PPMERR(PPM_E_FAIL);
	}
	
	pMsg = (OutstandingDataHdr*)pData;
		
	for(i = 0; i < m_OutstandingMsgCount; ++i)
	{
		// free memory for fragments
		if (pMsg->pFrag)
			delete [] pMsg->pFrag;
		pMsg++;
	}

	// Free memory for Message headers
    delete [] pData;
	m_OutstandingDataPtr = NULL;
	m_DataOutstanding = FALSE;
	m_OutstandingMsgCount = 0;


	LeaveCriticalSection(&m_CritSec);
	return NOERROR;
}	
//////////////////////////////////////////////////////////////////////////////////////////
// FlushData: This function sends up all queued data on the receive side.
//           In case of generic since data may not be coherent, we drop it down.
//           In case of H261 and H263 which can reconstruct dropped fragments, attempt
//           is made to send up as much useful data as possible.
//           No handling is done currently for IMC or Indeo 4.1 - data is dropped
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP ppmReceive::FlushData(void)
{
	HRESULT Status;
	MsgHeader *pMsgHdr;

	EnterCriticalSection(&m_CritSec);

	while(m_pMsgHeadersHead != NULL)
    {
        pMsgHdr = TakeMsgHeader();

		if (!pMsgHdr) 
		{	   
			DBG_MSG(DBG_ERROR, ("ppmReceive::FlushData: ERROR - pMsgHdr == NULL"));
			LeaveCriticalSection(&m_CritSec);
			return PPMERR(PPM_E_CORRUPTED);
		}

		DWORD dwLastSeqNum	= pMsgHdr->m_pFragList->LastSeqNum();
		DWORD dwLastMsgID	= pMsgHdr->GetMsgID();


		// For generic PPM's the data will be tossed
		// For audio PPM's overridden PartialMessagehandler will
		// call DataCopy so all data gets sent up
		//
		// For video - H261 and H263 respective overridden PartialMessageHandlers
		// play their role
		// 
		// Doesnt handle Indeo 4.1 case
		
		Status = PartialMessageHandler(pMsgHdr);


		// Update the global variables _after_ PartialMessageHandler(),
		// which needs previous state.
		m_GlobalLastSeqNum = dwLastSeqNum;
		m_GlobalLastMsgID  = dwLastMsgID;
   
		DBG_MSG(DBG_TRACE, ("ppmReceive::FlushData: m_GlobalLastSeqNum=%d", m_GlobalLastSeqNum));

    }
	//List is empty
	LeaveCriticalSection(&m_CritSec);
	return NOERROR;
}

//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//MsgHeader Functions:
//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
//GetMsgID: reaches into the first packet on the header and gets its time stamp
//////////////////////////////////////////////////////////////////////////////////////////
DWORD  MsgHeader::GetMsgID()
{
return this->m_MessageID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\ppmrcv.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: PPMRcv.h
//  Abstract:    Header file for PPM Receive COM Object
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
//  NOTES:
//
//  The three functions that are members of the IUnknown interface need to be
//  implemented in the most derived class. (Generally the class derived from
//  this one.)  This is done because if one of your super classes 
//  is derived from more than one interface, each of which derive from IUnknown,
//  the compiler will be confused as to which implementation of the IUnknown
//  interface to use. So, by requiring that only the most derived class implement
//  these functions then you will never run into this problem.  
//
//  
///////////////////////////////////////////////////////////////////////////////
//  //This code goes into your class declaration, it defines three functions 
//  //IUnknown Functions (Overrides)
// 
//  STDMETHODIMP GetInterface( REFIID riid, LPVOID FAR* ppvObj );                      
//  STDMETHODIMP_( ULONG )AddRef( void );                      
//  STDMETHODIMP_( ULONG )Release( void );
//
///////////////////////////////////////////////////////////////////////////////
//   This code is the implementation of 
//   CUnknown Functions (Overrides)
//
//  //Three Cases:
//  //
//  //1. If you multiply derive from ppmReceive and another interface you would have to
//  //write your own QueryInterface and call CUnknown::QueryInterface AND handle
//  //the interface you derived from. As well as having the GetInterface function
//  //as shown below.
//
//  //2. If you derive from another object and ppmReceive you would need to write your
//  //own QueryInterface to call CUnknown::QueryInterface and 
//  //OtherObject::QueryInterface. As well as having the GetInterface function shown
//  //below.
//
//  //3. If you are only derived from ppmReceive then all you need is the code below.
//
//  STDMETHODIMP GetInterface( void REFIID riid, LPVOID FAR* ppvObj )
//  {
//     return ppmReceive::GetInterface( riid, ppvObj );
//  }
//
//	STDMETHODIMP_( ULONG )AddRef( void )
//  {
//     return CUnknown::AddRef();
//  }
//
//  STDMETHODIMP_( ULONG )Release( void )
//  {
//     return CUnknown::Release();
//  }
//
/////////////////////////////////////////////////////////////////////////////

#ifndef PPMRCV_H
#define PPMRCV_H
  
#include "isubmit.h"
#include "ippm.h"
#include "ppm.h"
#include "freelist.h"
#include "core.h"
#include "llist.h"
#include "wrap.h"

////////////////////////////////////////////////////////////////////////////////////////
//MsgHeader Class 
////////////////////////////////////////////////////////////////////////////////////////

class MsgHeader 
{

public:

MsgHeader       *m_pNext;
MsgHeader       *m_pPrev;
LList			*m_pFragList;
int 			 m_NumFragments;
DWORD   		 m_TimeOfLastPacket;
DWORD            m_MessageID;
BOOL			 m_MarkerBitIn;

MsgHeader();
~MsgHeader(){ if (m_pFragList) delete m_pFragList; } //inline function
DWORD GetMsgID();
}; //end MsgHeader class

inline MsgHeader::MsgHeader() //inline function
{
    m_pNext				= NULL;
	m_pPrev             = NULL;
	m_pFragList			= new LList; 
    m_NumFragments	    =	0;
    m_TimeOfLastPacket  =	0; 
	m_MessageID         =   0;
	m_MarkerBitIn		= FALSE; 
}; 
 
////////////////////////////////////////////////////////////////////////////////////////
//PPMReceive Class:
////////////////////////////////////////////////////////////////////////////////////////
class ppmReceive : 
	public ppm, 
	public IPPMReceive, 
	public IPPMReceiveExperimental,
	public IPPMReceiveSession,
    public ISubmit, 
	public ISubmitCallback, 
	public ISubmitUser,
	public IPPMData,
	public CUnknown
{

protected:

////////////////////////////
//Members
//
//NOTE: Any member with the tag _reg_ in it, means its value comes from the registry.

ISubmitCallback *m_pSubmitCallback;
ISubmit			*m_pSubmit;
IMalloc			*m_pIMalloc;

FreeList         *m_pBufPool;			   //List of Fragment buffers if necessary.

FreeList         *m_pMsgHeaderPool;        //Points to a free list of MsgHeaders
MsgHeader        *m_pMsgHeadersHead;       //Points to the beginning of list of MsgHeaders.
MsgHeader        *m_pMsgHeadersTail;       //Points to the end of list of MsgHeaders.

int               m_MaxBufferSize;			//Max size the reassemble buffers should be
int               m_reg_NumMsgHeaders;	    //Number of MessageHeaders.

DWORD             m_GlobalLastSeqNum;      //Last Sequence Number of last Message
DWORD             m_GlobalLastMsgID;       //Last Message ID (i.e. Time Stamp)
DWORD             m_GlobalLastSSRC;        //Last Message SSRC

MMRESULT          m_TimerID;
DWORD             m_reg_TimerInterval;
DWORD             m_reg_TimerResolution;
DWORD             m_reg_DeltaTime;		   //Amount of time one should wait before tossing
                                           //a packet.
BOOL              m_FirstPacket;
BOOL			  m_inFlushMode;
BOOL			  m_GlobalLastFrameDropped; //Keeps track of frame drops for notifications

BOOL			  m_DataOutstanding;		// Is there data outstanding via 
											// ReportOutstandingData call
OutstandingDataHdr*			  
				  m_OutstandingDataPtr;		// Pointer to last chunk of data sent via
											// ReportOutstandingData call
int				  m_OutstandingMsgCount;	// Indicates count of message we had info
											// during the last ReportOutstandingData
long              m_PacketsHold; // Number of packets (CMediaSample)
                                 // we keep (i.e. AddRef)
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//External PPMReceive Functions
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

public:

//////////////////////////////////////////////////////////////////////////////
//   PPMReceive Functions (Overrides)

//constructor  
ppmReceive(int PayloadTypeArg, int MaxBufferSizeArg, int ProfileHdrSizeArg, IUnknown* pUnkOuter, IUnknown** ppUnkInner);

//destructor, 
~ppmReceive(); 



//////////////////////////////////////////////////////////////////////////////
//   IPPMReceive Functions (Overrides)

//see documentation (PHEPS.DOC)
STDMETHOD(InitPPMReceive)(THIS_ int     MaxBufferSize,
                                int     iBuffers,
                                int     iPackets,
                                DWORD   dwCookie);
STDMETHOD(InitPPMReceive)(THIS_ int MaxBufferSize, DWORD dwCookie)
		{
			m_LimitBuffers = FALSE;
			return InitPPMReceive(MaxBufferSize,
								  DEFAULT_MSG_COUNT_RCV,
								  DEFAULT_FRAG_COUNT,
								  m_dwCookie);
		}
STDMETHOD(SetSession)(THIS_ PPMSESSPARAM_T *pSessparam);
STDMETHOD(SetAlloc)(THIS_ IMalloc *pIMalloc);

//////////////////////////////////////////////////////////////////////////////
//   IPPMReceiveSession Functions (Overrides)

//see documentation (PHEPS.DOC)
STDMETHOD(GetPayloadType)(THIS_ LPBYTE			lpcPayloadType);
STDMETHOD(SetPayloadType)(THIS_ BYTE			cPayloadType);
STDMETHOD(GetTimeoutDuration)(THIS_ LPDWORD    lpdwLostPacketTime);
STDMETHOD(SetTimeoutDuration)(THIS_ DWORD      dwLostPacketTime);
STDMETHOD(GetResiliency)(THIS_ LPBOOL			lpbResiliency);
STDMETHOD(SetResiliency)(THIS_ BOOL			pbResiliency);


//////////////////////////////////////////////////////////////////////////////
//   IPPMData Functions (Overrides)

//////////////////////////////////////////////////////////////////////////////////////////
//FlushData: 
//////////////////////////////////////////////////////////////////////////////////////////
STDMETHOD(FlushData)(THIS_ void );

//////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
// ReportOutstandingData: Walks through the message and fragment lists and reports back
// to caller via callback
// Returns TRUE if data was delivered
// returns FALSE if an error occurred - values in parameters will be invalid
////////////////////////////////////////////////////////////////////////////////////////
STDMETHOD(ReportOutstandingData)(THIS_ DWORD** pDataHdr, DWORD* DataCount);

////////////////////////////////////////////////////////////////////////////////////////
// 	ReleaseOutstandingDataBuffer - will release the buffer given to the caller
//  during a previous ReportOutstandingData call
////////////////////////////////////////////////////////////////////////////////////////
STDMETHOD(ReleaseOutstandingDataBuffer)(THIS_ DWORD *pData );

//   ISubmit Functions (Overrides)

//see documentation (PHEPS.DOC)
STDMETHOD(InitSubmit)(ISubmitCallback *pSubmitCallback);
         
//see documentation (PHEPS.DOC)
STDMETHOD(Submit)(WSABUF *pWSABuffer, DWORD BufferCount, 
					void *pUserToken, HRESULT Error);

//see documentation (PHEPS.DOC)
//Stubs for now; overriding both ISubmit calls and ISubmitCallback 
//calls for ReportError
STDMETHOD_(void,ReportError)(THIS_ HRESULT Error){}
STDMETHOD(Flush)(THIS);

//////////////////////////////////////////////////////////////////////////////
//   ISubmitCallback Functions (Overrides)
        
//see documentation (PHEPS.DOC)
STDMETHOD_(void,SubmitComplete)(void *pUserToken, HRESULT Error);   
STDMETHOD_(void,ReportError)(THIS_ HRESULT Error, int=0){}

//////////////////////////////////////////////////////////////////////////////
//   ISubmitUser Functions (Overrides)
STDMETHOD(SetOutput)(THIS_ IUnknown *pSubmit);

 //////////////////////////////////////////////////////////////////////////////////////////
//TimeOut: Calls Staleness check then calls process msgs.
//////////////////////////////////////////////////////////////////////////////////////////
virtual HRESULT TimeOut(void);


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Internal PPMReceive Functions
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

protected:

/////////////////////////////////////////////////////////////////////////////
//   CUnknown Functions

/////////////////////////////////////////////////////////////////////////////
// CUnknown Functions  (Overrides)
//
// Call this method to get interface pointers supported by derived objects
// called by CInnerUnknown::QueryInterface; should return S_FALSE
// if interface is AddRef'd, S_OK if caller needs to AddRef the interface.
STDMETHOD(GetInterface)( REFIID riid, LPVOID FAR* ppvObj );

//////////////////////////
//inline functions								       
MsgHeader * GetMsgHeader();	 //gets a new MsgHeader	from the free pool
void        FreeMsgHeader(MsgHeader *pMsg);
MsgHeader * TakeMsgHeader(); //takes the first MsgHeader from the enqueued list

/////////////////////////////////////////////////////////////////////////////
// PPMReceive Functions
//
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
//VoidToFragment: Given a buffer with an RTP header and a Profile specific 
//header return pointer to data. This function should definitely be overridden by the 
//payload specific class. The overriding function would call this one and then it would
//set the profile header 
//////////////////////////////////////////////////////////////////////////////////////////
virtual void VoidToFragment(WSABUF *pWSABuffer, DWORD BufferCount, 
							FragDescriptor *pFragDescrip, void *pUserToken);


//////////////////////////////////////////////////////////////////////////////////////////
//SetupTimer: Sets up Timer and returns a Timer ID.If null is returned function failed
//            to initialize a timer.
//////////////////////////////////////////////////////////////////////////////////////////
MMRESULT SetupTimer();

//////////////////////////////////////////////////////////////////////////////////////////
//EnqueByMessage: Finds the MsgHeader and calls EnqueueByFrag.
//////////////////////////////////////////////////////////////////////////////////////////
virtual HRESULT EnqueByMessage(FragDescriptor *pFragDescrip);  


//////////////////////////////////////////////////////////////////////////////////////////
//EnqueueByFrag: Enqueues frag, calls ProcessMessages if appropriate 
//////////////////////////////////////////////////////////////////////////////////////////
virtual HRESULT EnqueueByFrag(FragDescriptor *pFragDescrip, MsgHeader *pMsgHdr); 


//////////////////////////////////////////////////////////////////////////////////////////
//TimeToProcessMessages: 
//////////////////////////////////////////////////////////////////////////////////////////
virtual BOOL TimeToProcessMessages(FragDescriptor *pFragDescrip, MsgHeader *pMsgHdr);

//////////////////////////////////////////////////////////////////////////////////////////
//ProcessMessages: 
//////////////////////////////////////////////////////////////////////////////////////////
virtual HRESULT ProcessMessages(void);

          
//////////////////////////////////////////////////////////////////////////////////////////
//CheckMessageComplete: 
//////////////////////////////////////////////////////////////////////////////////////////
virtual BOOL CheckMessageComplete(MsgHeader *pMsgHdr); 


//////////////////////////////////////////////////////////////////////////////////////////
//CheckMessageStale: 
//////////////////////////////////////////////////////////////////////////////////////////
virtual BOOL CheckMessageStale(MsgHeader *pMsgHdr);


//////////////////////////////////////////////////////////////////////////////////////////
//PrepMessage: Sets global variables, calls DataCopy
//////////////////////////////////////////////////////////////////////////////////////////
virtual HRESULT PrepMessage(BOOL); 


//////////////////////////////////////////////////////////////////////////////////////////
//DataCopy: Copies data fragments into client's buffer 
//////////////////////////////////////////////////////////////////////////////////////////
virtual HRESULT DataCopy(MsgHeader *const pMsgHdr);    


//////////////////////////////////////////////////////////////////////////////////////////
//PartialMessageHandler: deals with partial messages
//////////////////////////////////////////////////////////////////////////////////////////
virtual HRESULT PartialMessageHandler(MsgHeader *pMsgHdr);


//////////////////////////////////////////////////////////////////////////////////////////
//FreeFragList:  Re-posts fragment buffers and frees header memory.
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT FreeFragList(MsgHeader *pMsgHdr); 

//////////////////////////////////////////////////////////////////////////////////////////
//InitProfileHeader: Given a buffer as type void, sets up a profile header.  
//////////////////////////////////////////////////////////////////////////////////////////
virtual void *InitProfileHeader(void *pBuffer);

//////////////////////////////////////////////////////////////////////////////////////////
//FreeProfileHeader: Given a buffer as type void, frees up a profile header.  
//////////////////////////////////////////////////////////////////////////////////////////
virtual void FreeProfileHeader(void *pBuffer);

///////////////////////////////////////////////////////////////////////////////////////////
//FindMsgHeader: Walks the list of MsgHeaders. If it finds MsgHeader it wants then it 
//              a pointer to it. If one is not found, one is created and put in place.              
//////////////////////////////////////////////////////////////////////////////////////////

MsgHeader* FindMsgHeader(DWORD MessageID);


///////////////////////////////////////////////////////////////////////////////////////////
//Make this function a friend so that this function can access protect and private member
//functions.  The prototype of the function is after the class declaration.
//
friend void CALLBACK PPM_Timer(UINT uID, UINT uMsg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2);



}; //end of ppmReceive class


/////////////////////////////////////////////////////////////////////////////
//FreeMsgHeader: This function just hides the implementation of the free list of 
//              MsgHeaders.
/////////////////////////////////////////////////////////////////////////////
inline void ppmReceive::FreeMsgHeader(MsgHeader *pMsg)
{
	if (pMsg->m_pFragList) delete pMsg->m_pFragList;
	m_pMsgHeaderPool->Free((void *)pMsg);
}

//////////////////////////////////////////////////////////////////////////////////////////
//PPM_MMTimer: timer callback
//////////////////////////////////////////////////////////////////////////////////////////
void CALLBACK PPM_Timer(UINT uID, UINT uMsg, DWORD dwUser, DWORD dw1, DWORD dw2);


//////////////////////////////////////////////////////////////////////////////////////////
//Helpers for H.26x sbit/ebit.  These may not belong here, but too small to justify a
//seperate header.

inline unsigned char
GetSMask(int sbits)
{
	#ifdef ASSERT
		ASSERT((sbits >= 0) && (sbits <= 8));
	#endif

	// Unsigned type req'd for right shift to ensure that zero values
	// are shifted in.  Int req'd to allow shifting of more than 7 bits.
	return (unsigned int) 0xff >> sbits;
}

inline unsigned char
GetEMask(int ebits)
{
	#ifdef ASSERT
		ASSERT((ebits >= 0) && (ebits <= 8));
	#endif

	// Unsigned type req'd to ensure correct conversion to return type.
	return (unsigned int) 0xff << ebits;
}
       
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\ppmmisc.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: ppmmisc.cpp
//  Abstract:    cpp file. miscellaneous functions
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////

#if defined(ISRDBG) || defined(_DEBUG)

#include <windows.h>
#include <wtypes.h>
#include <stdarg.h>

#include "debug.h"

#ifdef ISRDBG
static WORD s_ghISRInst = NULL;
#endif

/////////////////////////////////////////////////////////////////////////////
// Function   : CDebugMsg::registerModule
// Description: Register module with ISR.
// 
// Input :      lpszShortName:	short module name
// 				lpszLongName:	long module name
//
// Return:		True if successful
/////////////////////////////////////////////////////////////////////////////
BOOL CDebugMsg::registerModule(LPCTSTR lpszShortName, LPCTSTR lpszLongName)
{
#ifndef MICROSOFT
    if (! s_ghISRInst)
	{
		// Cast away const, assuming that ISR_RegisterModule prototype is wrong
		ISRREGISTERMODULE(
			&s_ghISRInst, 
			(LPTSTR) lpszShortName, 
			(LPTSTR) lpszLongName);
	}

	return s_ghISRInst != NULL;
#else
    return TRUE;
#endif
}

/////////////////////////////////////////////////////////////////////////////
// Function   : CDebugMsg::trace
// Description: Output debug messages.  CDebugMsg object holds non-variable
//				trace info.
//
// Caveat:		On error, wvsprintf/wsprintf are supposed to return a 
//				value < strlen(lpFormat), but this fails because some
//				format-control specifications can be _shorter_ than the
//				formatted result, meaning the output string may be
//				shorter than the format string.  For this reason, we
//				currently omit error checking on these function calls.
// 
// Input :      lpszMsg:	-> to message format string
//				...:		optional variable argument list
//
// Return:		None
/////////////////////////////////////////////////////////////////////////////
void CDebugMsg::trace(LPCTSTR lpszMsg, ...) const
{
#ifndef MICROSOFT
	if (! s_ghISRInst)
		return;
#endif

	TCHAR szMsg[1024];
	LPTSTR lpszTail = szMsg;

	if ( !(m_dwFlags & DBG_DEVELOP) && !(m_dwFlags & DBG_ERROR) )
		return;
	
	if (! (m_dwFlags & DBG_NOTHREADID))
	{
		// Prepend thread ID
		lpszTail += wsprintf(lpszTail, "[%3lx] ", GetCurrentThreadId());
	}

	// Get pointer for first (optional) variable argument
	va_list vaList;
	va_start(vaList, lpszMsg);

	lpszTail += wvsprintf(lpszTail, lpszMsg, vaList);

	va_end(vaList);
	
	if (m_dwErr)
	{
		lpszTail += wsprintf(lpszTail, " Error:%d", m_dwErr);
	}
		
	if (m_lpszFile && ! (m_dwFlags & DBG_NONUM))
	{
		lpszTail += wsprintf(lpszTail, " - %s, line:%d", m_lpszFile, m_nLine);
	}

#ifdef ISRDBG

	ISR_DbgStr(s_ghISRInst, (BYTE) (m_dwFlags & ~(DBG_NONUM | DBG_NOTHREADID)), szMsg, 0);

#elif _DEBUG

	strcpy(lpszTail, "\n");
	OutputDebugString(szMsg);
	
#endif
} 

#endif // defined(ISRDBG) || defined(_DEBUG)

// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\ppmsnd.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: PPMSnd.h
//  Abstract:    Header file for PPM Send COM Object
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
//  NOTES:
//
//  The three functions that are members of the IUnknown interface need to be
//  implemented in the most derived class. (Generally the class derived from
//  this one.)  This is done because if one of your super classes 
//  is derived from more than one interface, each of which derive from IUnknown,
//  the compiler will be confused as to which implementation of the IUnknown
//  interface to use. So, by requiring that only the most derived class implement
//  these functions then you will never run into this problem.  
//
//
///////////////////////////////////////////////////////////////////////////////
//  //This code goes into your class declaration, it defines three functions 
//  //IUnknown Functions (Overrides)
// 
//  STDMETHODIMP GetInterface( REFIID riid, LPVOID FAR* ppvObj );                      
//  STDMETHODIMP_( ULONG )AddRef( void );                      
//  STDMETHODIMP_( ULONG )Release( void );
//
///////////////////////////////////////////////////////////////////////////////
//   This code is the implementation of 
//   CUnknown Functions (Overrides)
//
//  //Three Cases:
//  //
//  //1. If you multiply derive from ppmSend and another interface you would have to
//  //write your own QueryInterface and call CUnknown::QueryInterface AND handle
//  //the interface you derived from. As well as having the GetInterface function
//  //as shown below.
//
//  //2. If you derive from another object and ppmSend you would need to write your
//  //own QueryInterface to call CUnknown::QueryInterface and 
//  //OtherObject::QueryInterface. As well as having the GetInterface function shown
//  //below.
//
//  //3. If you are only derived from ppmSend then all you need is the code below.
//
//  STDMETHODIMP GetInterface( void REFIID riid, LPVOID FAR* ppvObj )
//  {
//     return ppmSend::GetInterface( riid, ppvObj );
//  }
//
//	STDMETHODIMP_( ULONG )AddRef( void )
//  {
//     return CUnknown::AddRef();
//  }
//
//  STDMETHODIMP_( ULONG )Release( void )
//  {
//     return CUnknown::Release();
//  }
//
/////////////////////////////////////////////////////////////////////////////

#ifndef PPMSEND_H
#define PPMSEND_H

#include "isubmit.h"
#include "ippm.h"
#include "ppm.h"
#include "freelist.h"
#include "core.h"
#include "que.h"


class ppmSend : public ppm, 
				public IPPMSend, 
				public IPPMSendExperimental, 
				public IPPMSendSession, 
				public ISubmit, 
				public ISubmitCallback , 
				public ISubmitUser, 
				public CUnknown 
{

protected:

///////////////////////
//Members

ISubmit			  *m_pSubmit;
ISubmitCallback   *m_pSubmitCallback;
IMalloc			  *m_pIMalloc;

FreeList          *m_pRTPHeaders;
WORD			   m_SequenceNum;

const int          m_Frequency;
int                m_MaxPacketSize; //Max size the packet should be
int 		       m_MaxDataSize; 	//Max amount of bytes of data in a packet 
							        //i.e. MaxPacketSize-Headers

int               m_reg_NumMsgDescriptors;  //Number of BufDescriptors.
int               m_reg_NumFragDescriptors; //Number of FragDescriptors.


//Things only accessed in internal functions.
BOOL			   m_inFlushMode;
BOOL               m_DropBufferFlag;
MsgDescriptor 	  *m_pCurrentBuffer;
DWORD 			   m_CurrentOffset;
DWORD              m_CurrentFragSize;
BOOL			   m_lastBufSilence;
BOOL			   m_markTalkSpurt;

    DWORD m_dwStartTime;
    DWORD m_dwBase;
    DWORD m_dwLastTime;
    DWORD m_dwFreq;

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//External PPMSend Functions
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

public:

//////////////////////////////////////////////////////////////////////////////
//   PPMSend Functions 

//constructor:  
ppmSend(int PayloadTypeArg, int ProfileHdrSizeArg, int FreqArg, IUnknown* pUnkOuter, IUnknown** ppUnkInner);
         
//destructor
~ppmSend();

//////////////////////////////////////////////////////////////////////////////
//   IPPMSend Functions (Overrides)

STDMETHOD(InitPPMSend)(THIS_ int    MaxBufferSize,
                             int    iBuffers,
                             int    iPackets,
                             DWORD  dwCookie);
STDMETHOD(InitPPMSend)(THIS_ int MaxBufferSize, DWORD dwCookie)
		{
			m_LimitBuffers = FALSE;
			return InitPPMSend(MaxBufferSize,
							   DEFAULT_MSG_COUNT_SND,
							   DEFAULT_FRAG_COUNT,
							   dwCookie);
		}
STDMETHOD(SetSession)(THIS_ PPMSESSPARAM_T *pSessparam);
STDMETHOD(SetAlloc)(THIS_ IMalloc *pIMalloc);
//see documentation (PHEPS.DOC)

//////////////////////////////////////////////////////////////////////////////
//   IPPMSendSession Functions (Overrides)

//see documentation (PHEPS.DOC)
STDMETHOD(GetPayloadType)(THIS_ LPBYTE			lpcPayloadType);
STDMETHOD(SetPayloadType)(THIS_ BYTE			cPayloadType);

//////////////////////////////////////////////////////////////////////////////
//   ISubmit Functions (Overrides)


//see documentation (PHEPS.DOC)
STDMETHOD(InitSubmit)(ISubmitCallback *pSubmitCallback);

//see documentation (PHEPS.DOC)
STDMETHOD(Submit)(WSABUF *pWSABuffer, DWORD BufferCount, 
						void *pUserToken, HRESULT Error);

//see documentation (PHEPS.DOC)
//Stubs for now; overriding both ISubmit calls and ISubmitCallback 
//calls for ReportError
STDMETHOD_(void,ReportError)(THIS_ HRESULT Error){}
STDMETHOD(Flush)(THIS);


//////////////////////////////////////////////////////////////////////////////
//   ISubmitCallback Functions (Overrides)

//see documentation (PHEPS.DOC)
STDMETHOD_(void,SubmitComplete)(void *pUserToken, HRESULT Error);
STDMETHOD_(void,ReportError)(THIS_ HRESULT Error, int=0){}

//////////////////////////////////////////////////////////////////////////////
//   ISubmitUser Functions (Overrides)
STDMETHOD(SetOutput)(THIS_ IUnknown *pSubmit);

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Internal PPMSend Functions
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

protected:

/////////////////////////////////////////////////////////////////////////////
// CUnknown Functions  (Overrides)
//
// Call this method to get interface pointers supported by derived objects
// called by CInnerUnknown::QueryInterface; should return S_FALSE
// if interface is AddRef'd, S_OK if caller needs to AddRef the interface.
STDMETHOD(GetInterface)( REFIID riid, LPVOID FAR* ppvObj );


/////////////////////////////////////////////////////////////////////////////
// ppm  Functions  (Overrides)
//
//Need to override this so we can delete memory when a frag descriptor is deleted.
//It has already been declared as virtual in ppm.h
HRESULT  FreeFragDescriptor(FragDescriptor* frag);

/////////////////////////////////////////////////////////////////////////////
// ppmSend Functions
//

//////////////////////////////////////////////////////////////////////////////////////////
//MakeFragments: Intelligently calls the rest of the internal functions.
//////////////////////////////////////////////////////////////////////////////////////////

HRESULT MakeFragments(void);

//////////////////////////////////////////////////////////////////////////////////////////
//InitFragStatus: Initializes values needed for fragmenting.
//////////////////////////////////////////////////////////////////////////////////////////
virtual HRESULT InitFragStatus(MsgDescriptor *pMsgDescrip);

//////////////////////////////////////////////////////////////////////////////////////////
//AllocFrag:  Allcates memory for FragDescriptor and all things it points to.
//////////////////////////////////////////////////////////////////////////////////////////
virtual FragDescriptor * AllocFrag();  

//////////////////////////////////////////////////////////////////////////////////////////
//DeleteFrag: Virtual This function does the opposite of AllocFrag, it deletes any memory allocated
//            by AllocFrag.
//////////////////////////////////////////////////////////////////////////////////////////
virtual void DeleteFrag(FragDescriptor *pFragDescrip, HRESULT Error);
 
//////////////////////////////////////////////////////////////////////////////////////////
//FragStatus: This funtion returns TRUE if still fragmenting, FALSE if fragmenting is done.
//////////////////////////////////////////////////////////////////////////////////////////
virtual BOOL FragStatus();

//////////////////////////////////////////////////////////////////////////////////////////
//MakeFrag: This function should get the next fragment from the buffer and fill in the
//          RTP header and payload header. 
//////////////////////////////////////////////////////////////////////////////////////////
virtual HRESULT   MakeFrag(FragDescriptor *pFragDescrip);  //fills in fields, including data of fragment class.

//////////////////////////////////////////////////////////////////////////////////////////
//SetMarkerBit: Determines whether to set the marker bit or not.  lastPacket is TRUE if
//				this is the last packet of the frame; FALSE if not.
//////////////////////////////////////////////////////////////////////////////////////////
virtual BOOL SetMarkerBit(BOOL lastPacket);

//////////////////////////////////////////////////////////////////////////////////////////
//SendFrag: Puts the pieces of the packet into a WSABUF and sends the packet to the client
//          with the callback supplied by the client. 
//////////////////////////////////////////////////////////////////////////////////////////
virtual HRESULT   SendFrag(FragDescriptor *pFragDescrip);

//////////////////////////////////////////////////////////////////////////////////////////
//MakeTimeStamp: Generate a time stamp
//////////////////////////////////////////////////////////////////////////////////////////
virtual DWORD MakeTimeStamp(MsgDescriptor* pMsgDescrip, BOOL bStartStream, BOOL bUseInputTime);

//////////////////////////////////////////////////////////////////////////////////////////
//FreeProfileHeader: Given a buffer as type void, frees up a profile header.  
//////////////////////////////////////////////////////////////////////////////////////////
virtual void FreeProfileHeader(void *pBuffer);

//////////////////////////////////////////////////////////////////////////////////////////
//ReadProfileHeader: Given a buffer as type void, returns the data for a profile header.  
//					Does nothing for the Generic case.  Intended for overrides for various 
//					payloads.
//////////////////////////////////////////////////////////////////////////////////////////
virtual void *ReadProfileHeader(void *pProfileHeader);

}; //end of ppmSend class

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\ppmsnd.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: PPMSend.cpp
//  Abstract:    Source file for PPM Send COM Object
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////

#include "ppmsnd.h"
#include "isubmit.h"
#include "ippm.h"
#include "ippmcb.h"
#include "ppm.h"
#include "freelist.h"
#include "ppmerr.h"
#include "que.h"
#include "debug.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//External PPMSend Functions
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
//    PPMSend Constructors & Destructor
 
////////////////////////////////////////////////////////////////////////////////////////
//ppmSend:  See header file description. (Constructor)
////////////////////////////////////////////////////////////////////////////////////////
ppmSend::ppmSend(int PayloadTypeArg, int ProfileHdrSizeArg, int FreqArg, IUnknown* pUnkOuter, IUnknown** ppUnkInner) : 
   m_Frequency(FreqArg), ppm(PayloadTypeArg, ProfileHdrSizeArg), CUnknown(pUnkOuter, ppUnkInner),
        
   m_dwStartTime(0)
{
   m_pSubmit           = NULL;
   m_pSubmitCallback   = NULL;
   m_inFlushMode	   = FALSE;
   m_DropBufferFlag    = FALSE;

   m_pRTPHeaders     = NULL;
   m_SequenceNum     = 0;   //this should be a random number, but is zero for debugging purposes.

   m_pCurrentBuffer  = NULL;
   m_CurrentOffset   = 0;
   m_CurrentFragSize = 0;

   m_lastBufSilence = TRUE;
   m_markTalkSpurt = FALSE;

   //m_reg_NumMsgDescriptors  = 20; //This should come out of an ini file.
   m_reg_NumMsgDescriptors  = FREELIST_INIT_COUNT_SND; //Test Code HK
   //m_reg_NumFragDescriptors = 50;
   m_reg_NumFragDescriptors = FREELIST_INIT_COUNT_SND;// Test Code HK

   if FAILED ( CoGetMalloc(MEMCTX_TASK, &m_pIMalloc)) {
	  DBG_MSG(DBG_ERROR, ("ppmSend::ppmSend: ERROR - Could not get default IMalloc"));
	   m_pIMalloc = NULL;
   }

   // Tell the connection point container to delegate IUnknown calls
   // to the IUnknown we implement in this object via inheritance
   // from our CUnknown base class.
   m_cConnPointContainer.SetUnknown((IUnknown *) (CUnknown *) this);
}
 
////////////////////////////////////////////////////////////////////////////////////////
//~ppmSend:  See header file description. (Destructor)
////////////////////////////////////////////////////////////////////////////////////////
ppmSend::~ppmSend()
{
	if (m_pRTPHeaders) delete m_pRTPHeaders;

    //need to figure out how to do this.
    if (m_pSubmit)              m_pSubmit->Release();
    if (m_pSubmitCallback)      m_pSubmitCallback->Release();

	if (m_pIMalloc) {
		m_pIMalloc->Release();
	}

}



//////////////////////////////////////////////////////////////////////////////
//   IPPMSend Functions (Overrides)

////////////////////////////////////////////////////////////////////////////////////////
//InitPPMSend: See header file for description
////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
ppmSend::InitPPMSend(
    int     MaxPacketSize, 
    int     iBuffers,
    int     iPackets,
    DWORD dwCookie)
{
   // Store the cookie passed in to us for use in callbacks.
   // Shouldn't there be state checking here to ensure that this
   // isn't called twice?
   m_dwCookie = dwCookie;

   if (m_InvalidPPM)
   {
	  DBG_MSG(DBG_ERROR, ("ppmSend::InitPPMSend: ERROR - m_InvalidPPM"));
      return PPMERR(PPM_E_FAIL);
   }

  m_MaxPacketSize = MaxPacketSize;

   HRESULT hErr;
   hErr = ppm::Initppm(iPackets, iBuffers);
   if (FAILED(hErr)) { 
	   m_InvalidPPM = TRUE;  
       char *pErrorDescription = "PPM Failed to successfully initialize";
       ppm::PPMError(E_FAIL, SEVERITY_FATAL, (BYTE *) pErrorDescription, 
                     strlen(pErrorDescription));
       return hErr;
   } /* if */

   HRESULT hr;
#ifdef RTP_CLASS
   m_MaxDataSize   = m_MaxPacketSize - RTP_Header::fixed_header_size - ReadProfileHeaderSize();

   //Make a pool of Msg headers and Msg buffers.  
   if (m_LimitBuffers) {
		//Allocate memory for the RTP headers.
		m_pRTPHeaders = new FreeList(iPackets, sizeof(RTP_Header), &hr);
   } else {
		m_pRTPHeaders = new FreeList(iPackets, sizeof(RTP_Header), 
			FREELIST_HIGH_WATER_MARK, FREELIST_INCREMENT, &hr);
   }

#else
   m_MaxDataSize   = m_MaxPacketSize - sizeof(RTP_HDR_T) - ReadProfileHeaderSize(); 	 

   //Make a pool of Msg headers and Msg buffers.  
   if (m_LimitBuffers) {
	    //Allocate memory for the RTP headers.
		m_pRTPHeaders = new FreeList(iPackets, (sizeof(RTP_HDR_T)), &hr);
   } else {
		m_pRTPHeaders = new FreeList(iPackets, (sizeof(RTP_HDR_T)),
			FREELIST_HIGH_WATER_MARK, FREELIST_INCREMENT, &hr);
   }
#endif
  
  if (m_pRTPHeaders == NULL || FAILED(hr))
  {
	  m_InvalidPPM = TRUE;
      ppm::PPMError(E_OUTOFMEMORY, SEVERITY_FATAL, NULL, 0);
	  DBG_MSG(DBG_ERROR, ("ppmSend::InitPPMSend: ERROR - Couldn't allocate RTPHeaders pool"));
	  if (m_pRTPHeaders) {
		  delete m_pRTPHeaders;
		  m_pRTPHeaders = NULL;
	  }
	  return PPMERR(PPM_E_OUTOFMEMORY);
  }

  return NOERROR;
}

STDMETHODIMP ppmSend::SetSession(PPMSESSPARAM_T *pSessparam)
{
   if (m_InvalidPPM)
   {
	  DBG_MSG(DBG_ERROR, ("ppmSend::SetSession: ERROR - m_InvalidPPM"));
      return PPMERR(PPM_E_FAIL);
   }

    return ppm::SetSession(pSessparam);
}

STDMETHODIMP ppmSend::SetAlloc(IMalloc *pIMalloc)
{
   if (!pIMalloc)
   {
	  DBG_MSG(DBG_ERROR, ("ppmSend::SetAlloc: ERROR - Invalid allocator pointer"));
      return PPMERR(PPM_E_INVALID_PARAM);
   }

   m_pIMalloc->Release();

   m_pIMalloc = pIMalloc;

   m_pIMalloc->AddRef();

	return NOERROR;
}

//////////////////////////////////////////////////////////////////////////////
//   IPPMSendSession Functions (Overrides)

////////////////////////////////////////////////////////////////////////////////////////
//GetPayloadType:  Gets the current payload type
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP ppmSend::GetPayloadType(LPBYTE			lpcPayloadType)
{
	if (!lpcPayloadType) return E_POINTER;
	*lpcPayloadType = (BYTE)m_PayloadType;
	return NOERROR;
}

////////////////////////////////////////////////////////////////////////////////////////
//SetPayloadType:  Sets the current payload type
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP ppmSend::SetPayloadType(BYTE			cPayloadType)
{
    if (cPayloadType != -1)
        m_PayloadType = cPayloadType;

    return NOERROR;
}


//////////////////////////////////////////////////////////////////////////////
//   ISubmit Functions (Overrides)

////////////////////////////////////////////////////////////////////////////////////////
//InitSubmit:  See header file description.
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP ppmSend::InitSubmit(ISubmitCallback *pSubmitCallback)				 
{  
   if (m_InvalidPPM)
   {
	  DBG_MSG(DBG_ERROR, ("ppmSend::InitSubmit: ERROR - m_InvalidPPM"));
      return PPMERR(PPM_E_FAIL);
   }

   //if the pointer given to me is null or InitPPM was not called then return E_FAIL
   if ( (m_pSubmit == NULL) || (pSubmitCallback == NULL) )
   {
	  DBG_MSG(DBG_ERROR, ("ppmSend::InitSubmit: ERROR - null Submit or SubmitCallback interface"));
     return PPMERR(PPM_E_FAIL);
   }

   //set callback to member
   HRESULT hErr = pSubmitCallback->QueryInterface(IID_ISubmitCallback, 
                                                  (PVOID *) &m_pSubmitCallback);
   if (FAILED(hErr)) {
       DBG_MSG(DBG_ERROR, ("ppmSend::InitSubmit: ERROR - bogus SubmitCallback interface passed in"));
       return PPMERR(PPM_E_FAIL);
   } /* if */

  //Initialize the service layer below me and hand him a callback to me.
  return m_pSubmit->InitSubmit( (ISubmitCallback*) this );
}


////////////////////////////////////////////////////////////////////////////////////////
//Submit:  See header file description.
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP ppmSend::Submit(
		WSABUF *pWSABuffer, 
		DWORD BufferCount, 
		void *pUserToken,
		HRESULT Error
		)
        
{

   MsgDescriptor* pMsgDescrip = NULL;
   DWORD Status;
   
   if (m_InvalidPPM)
   {
	  DBG_MSG(DBG_ERROR, ("ppmSend::Submit: ERROR - m_InvalidPPM"));
      return PPMERR(PPM_E_FAIL);
   }

   //if InitSend or InitPPM have not been called then return E_FAIL
   if ((m_pSubmit == NULL) || (m_pSubmitCallback == NULL))
   {
	  DBG_MSG(DBG_ERROR, ("ppmSend::Submit: ERROR - null Submit or SubmitCallback interface"));
     return PPMERR(PPM_E_FAIL);
   }

   ASSERT(pWSABuffer[0].len > 0);          //can't have a negative size.
   ASSERT(pWSABuffer[0].buf != NULL);	    //make sure we have a buffer    

   //Get a Buf descriptor
   pMsgDescrip = GetMsgDescriptor();
   
   if (pMsgDescrip == NULL)
   {
	   DBG_MSG(DBG_ERROR,  ("ppmSend::Submit: ERROR - Could not get a MsgDescriptor"));
	   // Make a callback into the app to let it know what happened.
	   ppm::PPMNotification(PPM_E_DROPFRAME, SEVERITY_NORMAL, NULL, 0);
	   return PPMERR(PPM_E_DROPFRAME);
   }

   //Set data in Buf descriptor
   pMsgDescrip->m_pBuffer    = pWSABuffer[0].buf;                               
   pMsgDescrip->m_Size       = pWSABuffer[0].len;
   pMsgDescrip->m_pMsgCookie = pUserToken;
   //If there is more than one WSABuf, we assume a timestamp is in the 2nd
   if (BufferCount > 1) 
	   pMsgDescrip->m_TimeStamp = *((DWORD *)pWSABuffer[1].buf);
   
   switch (Error) {
   case HRESULT_BUFFER_SILENCE:
	   m_lastBufSilence = TRUE;
	   m_markTalkSpurt = FALSE;
	   break;
   case HRESULT_BUFFER_START_STREAM:
	   m_lastBufSilence = FALSE;
	   m_markTalkSpurt = TRUE;
	   break;
   default:
	   if (m_lastBufSilence) {
		   m_lastBufSilence = FALSE;
		   m_markTalkSpurt = TRUE;
	   } else {
		   m_lastBufSilence = FALSE;
		   m_markTalkSpurt = FALSE;
	   }
	   break;
   }

   if (Error == HRESULT_BUFFER_DROP ||
	   Error == HRESULT_BUFFER_SILENCE)
   {
	    // data isn't to be sent.  Update time stamps for a continuous
	    // stream and call the submit complete for this buffer.
	    pMsgDescrip->m_TimeStamp  = MakeTimeStamp(pMsgDescrip, FALSE, (BufferCount > 1));
    	m_pSubmitCallback->SubmitComplete(pUserToken, NOERROR);
        FreeMsgDescriptor(pMsgDescrip);
        return NOERROR;
   }
   else 
   if (Error == HRESULT_BUFFER_START_STREAM)
   {
       // need to generate a timestamp based on current time 
	   pMsgDescrip->m_TimeStamp  = MakeTimeStamp(pMsgDescrip, TRUE, (BufferCount > 1));
   }
   else
   {
       // normal case just increment time stamp
	   pMsgDescrip->m_TimeStamp  = MakeTimeStamp(pMsgDescrip, FALSE, (BufferCount > 1));
   }

#ifdef _DEBUG
	 DBG_MSG(DBG_TRACE,  ("PPMSend::Submit Thread %ld - just received buffer %x, data size %d\n",
		 GetCurrentThreadId(), pMsgDescrip->m_pBuffer,pMsgDescrip->m_Size));
#endif

	 //enque buffer to que of buffers to fragment.
   Status = EnqueueBuffer(pMsgDescrip);
   
   if FAILED(Status)                              //this can fail but it is unlikely.
   {
      ppm::PPMError(E_FAIL, SEVERITY_FATAL, NULL, 0);
	   m_InvalidPPM = TRUE;
	   //corrupt que.
     FreeMsgDescriptor(pMsgDescrip);
	  DBG_MSG(DBG_ERROR, ("ppmSend::Submit: ERROR - EnqueueBuffer failed"));
     return PPMERR(PPM_E_CORRUPTED);         
   }

   //make fragments and send them. 
   return MakeFragments();	
}

////////////////////////////////////////////////////////////////////////////////////////
//Flush:  See header file description.
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP ppmSend::Flush()
{
   HRESULT         Status = NOERROR;
   MsgDescriptor* pMsgDescrip = NULL;

   if (m_InvalidPPM)
   {
	  DBG_MSG(DBG_ERROR, ("ppmSend::Flush: ERROR - m_InvalidPPM"));
      return PPMERR(PPM_E_FAIL);
   }

    EnterCriticalSection(&m_CritSec);
	m_inFlushMode	 = TRUE;
    LeaveCriticalSection(&m_CritSec);
	Status = m_pSubmit->Flush(); //get all the packet buffers that we sent down through Submit.

	if (Status) {
		//I didn't get all my buffer callbacks back!
	  Status = ERROR;
	  DBG_MSG(DBG_ERROR, ("ppmSend::Flush: ERROR - Didn't get all buffer callbacks"));
	}
    
	if (m_pCurrentBuffer) {
		if (m_pCurrentBuffer->m_NumFrags) {
			//I didn't get all my buffer callbacks back!
			Status = ERROR;
			DBG_MSG(DBG_ERROR, ("ppmSend::Flush: ERROR - Didn't get all buffer callbacks"));
		}

		m_pSubmitCallback->SubmitComplete(m_pCurrentBuffer->m_pMsgCookie, NOERROR);
		FreeMsgDescriptor(m_pCurrentBuffer);
	}
	
	while (pMsgDescrip = DequeueBuffer(0)) {
		m_pSubmitCallback->SubmitComplete(pMsgDescrip->m_pMsgCookie, NOERROR);
		FreeMsgDescriptor(pMsgDescrip);
	}

    EnterCriticalSection(&m_CritSec);
	//reset state
	m_SequenceNum     = 0;   //this should be a random number, but is zero for debugging purposes.

	m_pCurrentBuffer  = NULL;
	m_CurrentOffset   = 0;
	m_CurrentFragSize = 0;

	m_inFlushMode	  = FALSE;
    LeaveCriticalSection(&m_CritSec);

	return Status;
}

//////////////////////////////////////////////////////////////////////////////
//   ISubmitCallback Function (Overrides)

////////////////////////////////////////////////////////////////////////////////////////
//SubmitComplete:  See header file description.
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(void) ppmSend::SubmitComplete(void *pUserToken, HRESULT Error)
{  
   DeleteFrag((FragDescriptor *)pUserToken, Error); //Free FragDescriptor.
   EnterCriticalSection(&m_CritSec);

#ifdef __RECURSION__
   if (!m_inFlushMode) {
       LeaveCriticalSection(&m_CritSec);
	   if FAILED (MakeFragments()) {		//make fragments and send them.
		   DBG_MSG(DBG_ERROR, ("ppmSend::SubmitComplete: ERROR - MakeFragments failed"));
	   }
	   return;
   }
#endif
   LeaveCriticalSection(&m_CritSec);
} 

//////////////////////////////////////////////////////////////////////////////
//   ISubmitUser Functions (Overrides)
////////////////////////////////////////////////////////////////////////////////////////
//SetOutput:  See header file description.
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP ppmSend::SetOutput(IUnknown *pSubmit)
{
   if (m_InvalidPPM)
   {
	  DBG_MSG(DBG_ERROR, ("ppmSend::SetOutput: ERROR - m_InvalidPPM"));
      return PPMERR(PPM_E_FAIL);
   }

  //my interface to the guy below me, (i.e. service layer) 
  //this is given by the guy above me (i.e. client).
  if (pSubmit == NULL) {
      if (m_pSubmit == NULL) {
          // m_pSubmit has not been previously set. This makes
          // passing in a null pSubmit an error.
          char *pErrorDescription = "SetOutput passed a NULL IUnknown * with m_pSubmit NULL";
          ppm::PPMError(E_INVALIDARG, SEVERITY_FATAL, (BYTE *) pErrorDescription, 
                        strlen(pErrorDescription));
	      m_InvalidPPM = TRUE;
	      DBG_MSG(DBG_ERROR, ("ppmSend::SetOutput: ERROR - null Submit interface"));
          return PPMERR(PPM_E_FAIL);
      } else {
          // m_pSubmit was previously set. Passing in a null to
          // SetOutput in this case is an indication that we
          // should release the submitter we are talking to.
          // We need an external way of doing this to break
          // a reference loop.
          // Note that this currently isn't thread-safe.
          // PPM needs some sort or critical section to 
          // protect against stuff like this. In my usage
          // of PPM, this shouldn't be a problem.
          DBG_MSG(DBG_TRACE,  ("ppmSend::SetOutput: Null submit passed in - releasing m_pSubmit at 0x%08x\n",
                   m_pSubmit));
          m_pSubmit->Release();
          m_pSubmit = (ISubmit *) NULL;
          return NOERROR;
      } /* if */
  } /* if */
  
   //Set Member
   pSubmit->QueryInterface (IID_ISubmit, (void **)&m_pSubmit);

   if (m_pSubmit == NULL)
   {
	  m_InvalidPPM = TRUE;
      char *pErrorDescription = "SetOutput passed a NULL IUnknown *";
      ppm::PPMError(E_INVALIDARG, SEVERITY_FATAL, (BYTE *) pErrorDescription, 
                    strlen(pErrorDescription));
	  DBG_MSG(DBG_ERROR, ("ppmSend::SetOutput: ERROR - Invalid ISubmit argument"));
      return PPMERR(PPM_E_FAIL);
   }

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Internal PPMSend Functions
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//   CUnknown Function (Overrides)

////////////////////////////////////////////////////////////////////////////////////////
//GetInterface:  See header file description.
////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP ppmSend::GetInterface( REFIID riid, LPVOID FAR* ppvObj )
{
    //Check for the interfaces I derived from directly
    //if it is one of them then return and Cunknown will 
    //add ref it.     
    if   ( riid == IID_IPPMSend )
    {
       *ppvObj = (IPPMSend *)this;
    }
    else if( riid == IID_IPPMSendExperimental )
    {
       *ppvObj = (IPPMSendExperimental *)this;
    }
    else if( riid == IID_IPPMSendSession )
    {
       *ppvObj = (IPPMSendSession *)this;
    }
    else if( riid == IID_ISubmit )
    {
       *ppvObj = (ISubmit *)this;
    }
    else if ( riid == IID_ISubmitCallback)
    {
       *ppvObj = (ISubmitCallback *)this;
    }
    else if ( riid == IID_ISubmitUser)
    {
       *ppvObj = (ISubmitUser *)this;
    }
    else if( riid == IID_IConnectionPointContainer)
    {
        *ppvObj = (IConnectionPointContainer *) &m_cConnPointContainer;
    }
    else
    {
		DBG_MSG(DBG_ERROR, ("ppmSend::GetInterface: ERROR - Do not support requested interface"));
      return E_NOINTERFACE;
    }
    
    return NOERROR;
}
      
/////////////////////////////////////////////////////////////////////////////
// ppm  Functions  (Overrides)
//
////////////////////////////////////////////////////////////////////////////////////////
//FreeFragDescriptor:  See header file description.
////////////////////////////////////////////////////////////////////////////////////////

HRESULT ppmSend::FreeFragDescriptor(FragDescriptor* pFragDescrip)
{
m_pRTPHeaders->Free( (void*) (pFragDescrip->m_pRTPHeader));
return ppm::FreeFragDescriptor(pFragDescrip);
}

/////////////////////////////////////////////////////////////////////////////
// ppmSend Functions
//

//////////////////////////////////////////////////////////////////////////////////////////
//MakeFrag: See header file description. 
//////////////////////////////////////////////////////////////////////////////////////////

#if DEBUG_FREELIST > 2
long lppmSndstatus[] = {0, 0, 0, 0, 0};
#define INITSUBMIT() 
#define SUBMIT(n) {lppmSndstatus[n]++;lppmSndstatus[4] = n;}
#else
#define INITSUBMIT() 
#define SUBMIT(n)
#endif

HRESULT ppmSend::MakeFragments(void)
{
   MsgDescriptor  *pCurrentBuffer;
   FragDescriptor *pFragDescrip;
   HRESULT         Status;

   // To leave a trace of the places visited when the leak happens
   INITSUBMIT();
   
   EnterCriticalSection(&m_CritSec);
   while (TRUE)
   {
      //if not in middle of fragmenting, get new buffer
      if (!FragStatus())
      {
         pCurrentBuffer = DequeueBuffer(0);
           
         //if no buffers in que, nothing to do.
         if (pCurrentBuffer == NULL) 
         {
           Status = NOERROR;
           goto done;        
         }
         
         //otherwise start fragmenting.   
         Status = InitFragStatus(pCurrentBuffer); //set initial stuff
		 if (FAILED(Status)) {	//not going to use goto unless necessary

			 DBG_MSG(DBG_ERROR, ("ppmSend::MakeFragments: ERROR - Init failed"));
			 FreeMsgDescriptor(pCurrentBuffer);
			 m_pCurrentBuffer = NULL;  m_CurrentOffset = 0;
			 LeaveCriticalSection(&m_CritSec);
			 SUBMIT(0);
			 return Status;
		 }
      }
      
      //As long as there are fragments, then fragment the buffer.         
      while (FragStatus()) 
      {
         if (pFragDescrip = AllocFrag()) //if there are Fragments to Alloc, then alloc one.
         {
			 long code;
            Status = MakeFrag(pFragDescrip);
			if FAILED (Status) {
			    DBG_MSG(DBG_ERROR, ("ppmSend::MakeFragments: ERROR - Makefrag failed"));
				code = GetScode(Status);
			    if (pCurrentBuffer->m_NumFragSubmits) {
					m_SequenceNum++;  //increment the seq num so that receiver detects a prob
				    code = PPM_E_FAIL_PARTIAL;
				}
				pCurrentBuffer->m_NumFrags = pCurrentBuffer->m_NumFragSubmits;
				m_pCurrentBuffer = NULL; m_CurrentOffset = 0;
				FreeMsgDescriptor(pFragDescrip->m_pMsgBuf); //free client's buf descriptor 
				if (pFragDescrip->m_pProfileHeader) //free profile header, if any
					FreeProfileHeader(pFragDescrip->m_pProfileHeader);
				FreeFragDescriptor(pFragDescrip);
				SUBMIT(1);
			    LeaveCriticalSection(&m_CritSec);
				return PPMERR(code);
				//
			}
			Status = SendFrag(pFragDescrip); 
			if FAILED (Status) {
			    DBG_MSG(DBG_ERROR, ("ppmSend::MakeFragments: ERROR - Sendfrag failed"));
				code = GetScode(Status);
			    if (pCurrentBuffer->m_NumFragSubmits) {
					m_SequenceNum++;  //increment the seq num so that receiver detects a prob
				    code = PPM_E_FAIL_PARTIAL;
				}
				pCurrentBuffer->m_NumFrags = pCurrentBuffer->m_NumFragSubmits;
				m_pCurrentBuffer = NULL;  m_CurrentOffset = 0;
				FreeMsgDescriptor(pFragDescrip->m_pMsgBuf); //free client's buf descriptor 
				if (pFragDescrip->m_pProfileHeader) //free profile header, if any
					FreeProfileHeader(pFragDescrip->m_pProfileHeader);
				FreeFragDescriptor(pFragDescrip);
			    LeaveCriticalSection(&m_CritSec);
			    SUBMIT(2);
				return PPMERR(code);
			}
         }						 
         else  //couldn't allocate a fragment
         {
			long code = PPM_E_OUTOFMEMORY;
			if (pCurrentBuffer->m_NumFragSubmits) {
				m_SequenceNum++;  //increment the seq num so that receiver detects a prob
				code = PPM_E_OUTOFMEMORY_PARTIAL;
			}
		   pCurrentBuffer->m_NumFrags = pCurrentBuffer->m_NumFragSubmits;
           Status = PPMERR(code);
		   DBG_MSG(DBG_ERROR, ("ppmSend::MakeFragments: ERROR - AllocFrag failed"));
		   m_pCurrentBuffer = NULL;  m_CurrentOffset = 0;
		   SUBMIT(3);
           goto done;        //goto is only way to break out of a two level loop.
         }
      }
   }

done:
   LeaveCriticalSection(&m_CritSec);
   return Status;
}

/////////////////////////////////////////////////////////////////////////////////////////
//InitFragStatus: This function initializes values needed to fragment a message.
//                It determines the number of fragments for a current message.
//                It also calculates a fragment size so that all the fragments are 
//                approximately equal. It sets the NumFrags field of the Buf Descriptor
//                passed in.  
////////////////////////////////////////////////////////////////////////////////////////
HRESULT ppmSend::InitFragStatus(MsgDescriptor *pMsgDescrip)
{  
   int NumFrags;

   if (pMsgDescrip->m_Size == 0)
   {
	   //return NO_ERROR;
	   // BUGBUG returning NO_ERROR makes MakeFragments to continue
	   // in the loop without entering the place where the
	   // Msg is used, then it wil callagain DequeueBuffer and
	   // the previous buffer will be lost, hence a leak
      return PPMERR(PPM_E_FAIL);
   }

   //set global variable
   m_pCurrentBuffer = pMsgDescrip;            

   //Set the number of fragments for this frame, uses algorithm for always rounding up
   NumFrags = (m_pCurrentBuffer->m_Size + m_MaxDataSize - 1) / m_MaxDataSize;
   
   //determine size of packets for this frame
   m_CurrentFragSize = (m_pCurrentBuffer->m_Size + NumFrags - 1) / NumFrags;

   m_pCurrentBuffer->m_NumFrags = NumFrags; 	 //used to free buffer later.
   m_pCurrentBuffer->m_NumFragSubmits = 0; 		 //used during error detection
   

   return NO_ERROR;
}

//////////////////////////////////////////////////////////////////////////////////////////
//AllocFrag: This function allocates a Frag Descriptor off the free list, checking for
//           success of allocation.  Then it allocates the RTP header and sets the field 
//           in the Frag Descriptor to point to the newly allocated RTP header.  It then 
//           sets the MsgBuf field in the Frag Descriptor to point to the Buffer currently
//           being fragmented.
//////////////////////////////////////////////////////////////////////////////////////////
FragDescriptor * ppmSend::AllocFrag()
{
   FragDescriptor *pFragDescrip;

   //get descriptor
   pFragDescrip = GetFragDescriptor();
   
   if (pFragDescrip == NULL)						       
   {
      return NULL;
   }

   //get RTP header
#ifdef RTP_CLASS
   if (!(pFragDescrip->m_pRTPHeader = new (m_pRTPHeaders) RTP_Header))
#else
   if (!(pFragDescrip->m_pRTPHeader = new (m_pRTPHeaders) RTP_HDR_T)) 
#endif
   {
	  ppm::FreeFragDescriptor(pFragDescrip);
      return NULL;
   }
   
   //point to Message of origin
   pFragDescrip->m_pMsgBuf = m_pCurrentBuffer;				       
   
   return pFragDescrip;
}

//////////////////////////////////////////////////////////////////////////////////////////
//FreeProfileHeader: Given a buffer as type void, frees up a profile header.  Does nothing
//					for the Generic case.  Intended for overrides for various payloads.
//					Companion member function InitProfileHeader may allocate memory for
//					payload header which needs to be freed here. No return value.
//////////////////////////////////////////////////////////////////////////////////////////
void ppmSend::FreeProfileHeader(void *pBuffer)
{
	return;
}

//////////////////////////////////////////////////////////////////////////////////////////
//DeleteFrag: This function decrements the NumFrags counter of the MsgDescriptor from
//            where this packet came from.  It then checks to see if this is the last
//            packet in the message, if so it passes the message buffer back to the 
//            client via a callback. It then deallocates the buf Descriptor.
//            It always deallocates the RTP header and the Frag descriptor.
//////////////////////////////////////////////////////////////////////////////////////////

void ppmSend::DeleteFrag(FragDescriptor *pFragDescrip, HRESULT Error)
{
   //There is nothing we can do about the Error if we detect one, so we just
   //pass the error back up to the client.
   //It is probably to late to resend it, so just forget about it.
   DBG_MSG(DBG_TRACE,  ("ppmSend::DeleteFrag Thread %ld decrementing numfrags to %d\n",GetCurrentThreadId(),pFragDescrip->m_pMsgBuf->m_NumFrags-1));

   EnterCriticalSection(&m_CritSec);
   pFragDescrip->m_pMsgBuf->m_NumFrags--;	//Decrement each time a fragment comes back.
   pFragDescrip->m_pMsgBuf->m_NumFragSubmits--;	//Decrement each time a fragment comes back.
   
   LeaveCriticalSection(&m_CritSec);

   //if all the fragments have been sent and I am not still fragmenting this buffer.
   if ((pFragDescrip->m_pMsgBuf->m_NumFrags == 0) && pFragDescrip->m_pMsgBuf != m_pCurrentBuffer)
   {  																		
   	  //give the client his buffer back.
      m_pSubmitCallback->SubmitComplete(pFragDescrip->m_pMsgBuf->m_pMsgCookie, Error);
      
      FreeMsgDescriptor(pFragDescrip->m_pMsgBuf); //free client's buf descriptor 
   }
   
   //free profile header, if there is one
   if (pFragDescrip->m_pProfileHeader) FreeProfileHeader(pFragDescrip->m_pProfileHeader);
   FreeFragDescriptor(pFragDescrip);  		    			 //free  descriptor
}
    

/////////////////////////////////////////////////////////////////////////////////////////
//FragStatus:  See header file description.
////////////////////////////////////////////////////////////////////////////////////////
BOOL ppmSend::FragStatus()
{
return (BOOL)(m_pCurrentBuffer != NULL);
}

/////////////////////////////////////////////////////////////////////////////////////////
//MakeFrag: This function sets the Data field of the frag descriptor to point to somewhere
//          in the message buffer.  i.e. we are using scatter/gather to fragment the 
//          message buffers. This means we send pointers to an offset in the message 
//          buffer down to the network layers, instead of copying the data out of the 
//          buffer, thus saving several memcopys.   This function also sets the RTP
//          header fields.  It then sets the size of the packet, which will vary 
//          depending on the message and whether the current packet is the last packet
//          or not.  It then sets the offset to the next packet (zero if this is the 
//          last packet in a message.).
////////////////////////////////////////////////////////////////////////////////////////
HRESULT ppmSend::MakeFrag(FragDescriptor *pFragDescrip)
{
   //point data field of frag descriptor to data in buffer.
   pFragDescrip->m_pData = (void *)&((BYTE *)m_pCurrentBuffer->m_pBuffer)[m_CurrentOffset];

   //fill in RTP Header	
#ifdef RTP_CLASS
   pFragDescrip->m_pRTPHeader->set_pt(ReadPayloadType());
   pFragDescrip->m_pRTPHeader->set_x(0);
   pFragDescrip->m_pRTPHeader->set_p(0);
   pFragDescrip->m_pRTPHeader->set_seq(m_SequenceNum);
   pFragDescrip->m_pRTPHeader->set_ts(
		   (m_pCurrentBuffer->m_TimeStamp + m_CurrentOffset));
   pFragDescrip->m_pRTPHeader->set_cc(0);
#else
   pFragDescrip->m_pRTPHeader->pt = ReadPayloadType();
   pFragDescrip->m_pRTPHeader->x = 0;
   pFragDescrip->m_pRTPHeader->p = 0;
   pFragDescrip->m_pRTPHeader->seq = htons(m_SequenceNum);
   pFragDescrip->m_pRTPHeader->ts = htonl(m_pCurrentBuffer->m_TimeStamp);
   pFragDescrip->m_pRTPHeader->cc = 0;
#endif

   m_SequenceNum++;         

   //if this is NOT the last packet.
   if ((m_pCurrentBuffer->m_Size - m_CurrentOffset) > m_CurrentFragSize)
   { 
      //set size field, set new offset, set marker bit.
      pFragDescrip->m_BytesOfData = m_CurrentFragSize;
      m_CurrentOffset = m_CurrentOffset + m_CurrentFragSize;
#ifdef RTP_CLASS
	  pFragDescrip->m_pRTPHeader->set_m(SetMarkerBit(FALSE));
#else
	  pFragDescrip->m_pRTPHeader->m = SetMarkerBit(FALSE);
#endif
   }
   else  //if this IS the last packet.
   {
      //set size field, set new offset, set marker bit.
      pFragDescrip->m_BytesOfData =  m_pCurrentBuffer->m_Size - m_CurrentOffset;
      m_CurrentOffset = 0;
#ifdef RTP_CLASS
	  pFragDescrip->m_pRTPHeader->set_m(SetMarkerBit(TRUE));
#else
	  pFragDescrip->m_pRTPHeader->m = SetMarkerBit(TRUE);
#endif
      
      //reset Current Buffer.
      m_pCurrentBuffer = NULL;
   }  

   return NOERROR;
}

//////////////////////////////////////////////////////////////////////////////////////////
//SetMarkerBit: Determines whether to set the marker bit or not.  lastPacket is TRUE if
//				this is the last packet of the frame; FALSE if not.
//////////////////////////////////////////////////////////////////////////////////////////
BOOL ppmSend::SetMarkerBit(BOOL lastPacket)
{
	return lastPacket;
}

//////////////////////////////////////////////////////////////////////////////////////////
//ReadProfileHeader: Given a buffer as type void, returns the data for a profile header.  
//					Does nothing for the Generic case.  Intended for overrides for various 
//					payloads.
//////////////////////////////////////////////////////////////////////////////////////////
void *ppmSend::ReadProfileHeader(void *pProfileHeader)
{
	return pProfileHeader;
}

/////////////////////////////////////////////////////////////////////////////////////////
//SendFrag: Puts the pieces of the packet into a WSABUF and sends the packet to the
//          service layer with the callback supplied in the interface given at 
//          the initialization of the PPM. 
////////////////////////////////////////////////////////////////////////////////////////
HRESULT ppmSend::SendFrag(FragDescriptor *pFragDescrip)
{  
   HRESULT Status;
   
   int NumWSABufs =  0;
   WSABUF pWSABuffer[3];	 //We might waste a WSABUF, doesn't matter cause it is on the stack.

   //RTP header goes in first WSABuf 
#ifdef RTP_CLASS
   // Right now we can't generate anything other than the fixed header,
   // so if the size doesn't match, something is broken.
   if (pFragDescrip->m_pRTPHeader->header_size() != RTP_Header::fixed_header_size) {
       ppm::PPMError(E_FAIL, SEVERITY_FATAL, NULL, 0);
	   m_InvalidPPM = TRUE;
		DBG_MSG(DBG_ERROR, ("ppmSend::SendFrag: ERROR - RTP header size discrepancy"));
	   return PPMERR(PPM_E_FAIL);
   }
   pWSABuffer[NumWSABufs].buf = (char *) pFragDescrip->m_pRTPHeader;
   pWSABuffer[NumWSABufs].len = RTP_Header::fixed_header_size;
#else
   pWSABuffer[NumWSABufs].buf = (char *) pFragDescrip->m_pRTPHeader;
   pWSABuffer[NumWSABufs].len = sizeof(RTP_HDR_T);
#endif
   NumWSABufs++;
//lsc
#ifdef _DEBUG
struct mine {
	DWORD	ebit:3;
	DWORD	sbit:3;
	DWORD	p:1;
	DWORD	f:1;

	DWORD	quant:5;
	DWORD	src:3;

	DWORD	gobn:5;
	DWORD	s:1;
	DWORD	a:1;
	DWORD	i:1;

	DWORD	mba:8;
} *myhdr;
#endif

   //if there is no profile header, don't try to send one.
   if (pFragDescrip->m_pProfileHeader != NULL)
   {
      //Payload Specific header goes in next buffer.
      pWSABuffer[NumWSABufs].buf = (char *) ReadProfileHeader(pFragDescrip->m_pProfileHeader); 	
      pWSABuffer[NumWSABufs].len = ReadProfileHeaderSize(pFragDescrip->m_pProfileHeader);
	  NumWSABufs++;
   }
#ifdef _DEBUG
   myhdr = (mine *) pWSABuffer[1].buf;
#endif
      	
   //Data goes in last buffer.
   pWSABuffer[NumWSABufs].buf = (char *)pFragDescrip->m_pData;
   pWSABuffer[NumWSABufs].len = pFragDescrip->m_BytesOfData;
   NumWSABufs++;

#ifdef _DEBUG
   if (NumWSABufs == 3)
	 DBG_MSG(DBG_TRACE, ("PPMSend::Sendfrag Thread %ld - sending 3 WSABUFs, data size %d\n",
		 GetCurrentThreadId(), (pWSABuffer[0].len)+(pWSABuffer[1].len)+(pWSABuffer[2].len)));
   else
	 DBG_MSG(DBG_TRACE,  ("PPMSend::Sendfrag Thread %ld - sending 2 WSABUFs, data size %d\n",
		 GetCurrentThreadId(), (pWSABuffer[0].len)+(pWSABuffer[1].len)));
#endif

   Status = m_pSubmit->Submit(pWSABuffer, NumWSABufs, (void *)pFragDescrip, NOERROR);

   pFragDescrip->m_pMsgBuf->m_NumFragSubmits++;
        
   if (FAILED(Status))
   {
	   DBG_MSG(DBG_ERROR, ("ppmSend::SendFrag: ERROR - Client Submit failed", Status));
	   // DeleteFrag was already called in m_pSubmit->Submit() no
	   // matter if the Submit() failed
	   //DeleteFrag(pFragDescrip, Status); //Free FragDescriptor.
   }

   return NOERROR;
}

//////////////////////////////////////////////////////////////////////////////////////////
//MakeTimeStamp: Generate a time stamp based on the frequency specified in the Profile Spec.
//////////////////////////////////////////////////////////////////////////////////////////
DWORD ppmSend::MakeTimeStamp(MsgDescriptor* pMsgDescrip, 
							 BOOL bStartStream, 
							 BOOL bUseInputTime)
{
//Note: pMsgDescrip not used in generic PPM
#ifndef TIMESTAMP_OFF 
//I mod the base with 100 so that they are small and I can debug easier.

    DWORD CurTime;
     DWORD GetTime = timeGetTime();

    if (!m_dwStartTime) {
        m_dwStartTime = GetTime;
        m_dwBase = GetTime % 100;
        m_dwLastTime = 0;
        m_dwFreq = m_Frequency/1000;
    }
       
if (bUseInputTime) GetTime = pMsgDescrip->m_TimeStamp;
//need to convert Frequency from seconds to milliseconds, so divide by 1000 after
//the multiplication.
#if 0
CurTime = ((GetTime - m_dwStartTime) * m_dwFreq) + m_dwBase;
#else
CurTime = GetTime*m_dwFreq;
#endif

if (CurTime == m_dwLastTime)
{
  CurTime = CurTime + 1;
}

m_dwLastTime = CurTime;

#ifdef _DEBUG
DBG_MSG(DBG_TRACE,  ("PPMSend::MakeTimeStamp timestamp %ld from current time %ld * %d\n",
		 CurTime, timeGetTime(), m_dwFreq));
#endif

#else
//I changed this because the times I was getting were widely spaced.  When I was in debugging
//mode.
static DWORD CurTime = 0;
CurTime++;
#endif 

return CurTime;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\que.cpp ===
/////////////////////////////////////////////////////////////////////////////
//	INTEL Corporation Proprietary Information
//	This listing is supplied under the terms of a license agreement with Intel
//	Corporation and many not be copied nor disclosed except in accordance
//	with the terms of that agreement.
//	Copyright (c) 1995, 1996 Intel Corporation.
//
//
//	Module Name: que.cpp
//	Abstract:    source file. Generic queing data structure.
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////

#include "que.h"
#include "ppmerr.h"
#include "debug.h"

#if DEBUG_FREELIST > 2
#define DEBUGBREAK() DebugBreak()
#else
#define DEBUGBREAK()
#endif

// Constructor
Queue::Queue()
{
	m_pHead = NULL;
	m_pTail = NULL;
	m_NumItems = 0;
};


// Queue::Enqueue(): Add a new item at tail of queue, returning NOERROR if
//  successful, appropriate error otherwise.
HRESULT Queue::EnqueueTail(QueueItem* pItem)
{
	if (pItem == NULL)
	{
	 	// Corrupt item
		DBG_MSG(DBG_ERROR,
				("Queue::Enqueue(pItem=0x%08lx): null item", pItem));
#if DEBUG_FREELIST > 1
		{
			char msg[128];
			wsprintf(msg,"Queue::EnqueueTail: null item\n");
			OutputDebugString(msg);
			DEBUGBREAK();
		}
#endif	
		return PPMERR(PPM_E_INVALID_PARAM);
	}
	
	THREADSAFEENTRY();

	if (! ((m_pHead && m_pTail) || (! m_pHead && ! m_pTail)))
	{
		// Corrupt queue
		DBG_MSG(DBG_ERROR,
			("Queue::Enqueue(pItem=0x%08lx): corrupt queue", pItem));
#if DEBUG_FREELIST > 1
		{
			char msg[128];
			wsprintf(msg,"Queue::EnqueueTail: corrupt queue\n");
			OutputDebugString(msg);
			DEBUGBREAK();
		}
#endif	
		return PPMERR(PPM_E_CORRUPTED);
	}

	if (m_pHead == NULL)
	{
		// Queue was empty, new item goes at head.
		m_pHead = pItem;
		pItem->m_pPrev = NULL;
	}
	else
	{
		// Add item to end of queue.
		m_pTail->m_pNext = pItem;
		pItem->m_pPrev = m_pTail;
	}

	m_pTail = pItem;
	pItem->m_pNext = NULL;

	m_NumItems++;
	
	return NOERROR;
}

// Queue::Enqueue(): Add a new item at head of queue, returning NOERROR if
//  successful, appropriate error otherwise.
HRESULT Queue::EnqueueHead(QueueItem* pItem)
{
	if (pItem == NULL)
	{
	 	// Corrupt item
		DBG_MSG(DBG_ERROR,
			("Queue::Enqueue(pItem=0x%08lx): null item", pItem));
#if DEBUG_FREELIST > 1
		{
			char msg[128];
			wsprintf(msg,"Queue::EnqueueHead: null item\n");
			OutputDebugString(msg);
			DEBUGBREAK();
		}
#endif	
		return PPMERR(PPM_E_INVALID_PARAM);
	}
	
	THREADSAFEENTRY();

	if (! ((m_pHead && m_pTail) || (! m_pHead && ! m_pTail)))
	{
		// Corrupt queue
		DBG_MSG(DBG_ERROR,
			("Queue::Enqueue(pItem=0x%08lx): corrupt queue", pItem));
#if DEBUG_FREELIST > 1
		{
			char msg[128];
			wsprintf(msg,"Queue::EnqueueHead: corrupt queue\n");
			OutputDebugString(msg);
			DEBUGBREAK();
		}
#endif	
		return PPMERR(PPM_E_CORRUPTED);
	}

	if (m_pTail == NULL)
	{
		// Queue was empty, new item goes at head.
		m_pTail = pItem;
		pItem->m_pNext = NULL;
	}
	else
	{
		// Add item to beginning of queue.
		m_pHead->m_pPrev = pItem;
		pItem->m_pNext = m_pHead;
	}

	m_pHead = pItem;
	pItem->m_pPrev = NULL;

	m_NumItems++;
	
	return NOERROR;
}

// Queue::Dequeue(): Remove least-recently enqueued (head) item from queue,
// returning pointer to item if successful, NULL otherwise.
QueueItem* Queue::DequeueHead()
{
	THREADSAFEENTRY();

	if (! (( m_pHead &&  m_pTail) || (! m_pHead && ! m_pTail)))
	{
		// Corrupt queue
		DBG_MSG(DBG_ERROR, ("Queue::Dequeue: corrupt queue"));
#if DEBUG_FREELIST > 1
		{
			char msg[128];
			wsprintf(msg,"Queue::DequeueHead: corrupt queue\n");
			OutputDebugString(msg);
			DEBUGBREAK();
		}
#endif	
		return NULL;
	}
	
	QueueItem* pItem = NULL;

	// If not empty queue
	if (m_pHead != NULL)
	{
		// Take item off beginning of list,
		pItem = m_pHead;

		// Set head to next item, might be null
		m_pHead = m_pHead->m_pNext;

		if (m_pHead == NULL)
		{
			// Queue is empty
			m_pTail = NULL;
		}
		else
		{
			// Point head to next item
			m_pHead->m_pPrev = NULL;
		}

		// Not necessary but safe.
		pItem->m_pNext = NULL;
		pItem->m_pPrev = NULL;

		m_NumItems--;
	}
	
	return pItem;
}

// Queue::Dequeue(): Remove most-recently enqueued (tail) item from queue,
// returning pointer to item if successful, NULL otherwise.
QueueItem* Queue::DequeueTail()
{
	THREADSAFEENTRY();

	if (! (( m_pHead &&  m_pTail) || (! m_pHead && ! m_pTail)))
	{
		// Corrupt queue
		DBG_MSG(DBG_ERROR, ("Queue::Dequeue: corrupt queue"));
#if DEBUG_FREELIST > 1
		{
			char msg[128];
			wsprintf(msg,"Queue::DequeueTail: corrupt queue\n");
			OutputDebugString(msg);
			DEBUGBREAK();
		}
#endif	
		return NULL;
	}
	
	QueueItem* pItem = NULL;

	// If not empty queue
	if (m_pTail != NULL)
	{
		// Take item off end of list,
		pItem = m_pTail;

		// Set tail to prev item, might be null
		m_pTail = m_pTail->m_pPrev;

		if (m_pTail == NULL)
		{
			// Queue is empty
			m_pHead = NULL;
		}
		else
		{
			// Point item at tail to NULL
			m_pTail->m_pNext = NULL;
		}

		// Not necessary but safe.
		pItem->m_pNext = NULL;
		pItem->m_pPrev = NULL;

		m_NumItems--;
	}
	
	return pItem;
}

// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\que.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: que.h
//  Abstract:    header file. Generic queing class.
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////

// $Header:   R:/rtp/src/ppm/QUE.H_v   1.11   22 Jan 1997 20:59:44   CPEARSON  $

/////////////////////////////////////////////////////////////////////////////////
//NOTE: Defines a general purpose, thread-safe queue class.  To use, derive a
//		class from QueueItem to hold the objects you intended to enqueue.
//		Instantiate a Queue object, then call Queue::Enqueue and Queue::Dequeue
//		to add and remove queue items.  There is no limit on the size of the queue.
/////////////////////////////////////////////////////////////////////////////////

#ifndef __QUE_H__
#define __QUE_H__

#include <wtypes.h>		// HRESULT
#include "thrdsafe.h"	// CThreadSafe


////////////////////////////////////////////////////////////////////////
// class QueueItem: base class from which to derive classes to be
// contained by class Queue.

class QueueItem
{
	friend class Queue; 

	QueueItem*	m_pNext;
	QueueItem*	m_pPrev;

public:
	QueueItem::QueueItem()
		{ m_pNext = NULL; m_pPrev= NULL; }

protected:
	// Non-virtual dtors are dangerous, because derived class dtors aren't
	// called, so only make this one visible to derived classes.  This also
	// ensures that Queue implementation doesn't delete queue entries.
	QueueItem::~QueueItem() {}
};


////////////////////////////////////////////////////////////////////////
// class Queue: Defines a thread-safe, FIFO accessed list of pointers
// to QueueItem objects.

class Queue : protected CThreadSafe
{
	QueueItem*			m_pHead;
	QueueItem*			m_pTail;
	int					m_NumItems;
	
public:
	
	// Constructor
	Queue(); 
	
	// Virtual destructor to ensure correct destruction of derivatives.
	virtual ~Queue() {;}
	
	// Enqueue an item at Head
	// Returns NOERROR for success, E_FAIL for a corrupt queue.
	HRESULT EnqueueHead(QueueItem* pItem);

	// Enqueue an item at Tail
	// Returns NOERROR for success, E_FAIL for a corrupt queue.
	HRESULT EnqueueTail(QueueItem* pItem);

	// Default old behavior
	//inline
	//HRESULT Enqueue(QueueItem* pItem) {return(EnqueueTail(pItem));}
	
	// Dequeue an item from Head
	// Returns NULL if empty queue.
	QueueItem* DequeueHead();

	// Dequeue an item from Tail
	// Returns NULL if empty queue.
	QueueItem* DequeueTail();

	// Default old behavior
	//inline
	//QueueItem* Dequeue() {return(DequeueHead());}
	
	// Return TRUE if queue is empty
	BOOL Is_Empty() const
		{ THREADSAFEENTRY(); return (m_pHead == NULL); }
	
	// Return number of items in queue
	int NumItems() const
		{ THREADSAFEENTRY(); return m_NumItems; };
};

#endif	// __QUE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by verstmp.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\common\rmemry.cpp ===
/*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
//  Filename: RMemry.cpp
//  Purpose : Implementation file for the RPH memory allocator.
//  Contents:
*M*/

#include <ISubmit.h>

#include <streams.h> 
#include <initguid.h>
#include <olectl.h>

#include "RMemry.h"


/*F*
//  Name    : CRMediaSample::CRMediaSample()
//  Purpose : Constructor. Sets member variables to known state.
//  Context : Called upon construction.
//  Returns : Nothing. Errors are returned by parent class in phr.
//  Params  : See parent class.
//  Notes   : We redo the constructor initializers and function
//            body in order to override m_pAllocator.
*F*/
CRMediaSample::CRMediaSample(
    TCHAR *pName,
    CRMemAllocator *pAllocator,
    HRESULT *phr,
    LPBYTE pBuffer,
    LONG length) 
    : m_pvCookie(NULL),
      CMediaSample(pName, pAllocator, phr, pBuffer, length)
{
    m_pAllocator = pAllocator;

    DbgLog((LOG_TRACE, 2, 
            TEXT("CRMediaSample::CRMediaSample: Constructed at 0x%08x with allocator 0x%08x"),
            this, m_pAllocator));

    if (pAllocator == static_cast<CRMemAllocator *>(NULL)) {
    	*phr = VFW_E_NEED_OWNER;
    } /* if */
} /* CRMediaSample::CRMediaSample() */


/*F*
//  Name    : CRMediaSample::~CRMediaSample()
//  Purpose : Destructor
//  Notes   : None
*F*/
CRMediaSample::~CRMediaSample()
{
    DbgLog((LOG_TRACE, 2, 
            TEXT("CRMediaSample::~CRMediaSample: Instance 0x%08x destructor called"),
            this));
} /* CRMediaSample::~CRMediaSample() */


/*F*
//  Name    : CRMediaSample::SetPointer()
//  Purpose : Sets the pointed for the buffer that this media
//            sample encapsulates. Also stores a cookie that
//            is related to this buffer.
//  Context : Called each time the PPM submits a buffer to
//            the RPH filters for rendering.
//  Returns : See parent class.
//  Params  : 
//      ptr, CBytes:    See Parent Class
//      pvCookie        Cookie to store to associate with this buffer.
//  Notes   : None
*F*/
HRESULT 
CRMediaSample::SetPointer(
    BYTE     *ptr, 
    LONG     cBytes, 
    void     *pvCookie)
{
    m_pvCookie = pvCookie;
    return CMediaSample::SetPointer(ptr, cBytes);
} /* CRMediaSample::SetPointer() */



/*F*
//  Name    : CRMemAllocator::CRMemAllocator()
//  Purpose : Constructor. Initializes member variables to known values.
//  Context : Called upon construction.
//  Returns : Base class returns status in phr.
//  Params  : See base class.
//  Notes   : Used to initialize m_pISubmitCB to NULL.
*F*/
CRMemAllocator::CRMemAllocator(
    TCHAR       *pName,
    LPUNKNOWN   pUnk,
    HRESULT     *phr)
: CMemAllocator(pName, pUnk, phr),
  m_pISubmitCB(NULL)
{
    DbgLog((LOG_TRACE, 2, 
            TEXT("CRMemAllocator::CRMemAllocator: Constructed at 0x%08x"),
            this));
} /* CRMemAllocator::CRMemAllocator() */


/*F*
//  Name    : CRMemAllocator::~CRMemAllocator()
//  Purpose : Destructor. Releases the ISubmitCallback we are using.
//  Context : Called upon destruction.
//  Returns : Nothing.
//  Params  : None.
//  Notes   : m_pISubmutCallback is set in SetCallback().
*F*/
CRMemAllocator::~CRMemAllocator()
{
    DbgLog((LOG_TRACE, 3, TEXT("CRMemAllocator::~CRMemAllocator: Destructor called at 0x%08x"),
            this));
    if (m_pISubmitCB != static_cast<ISubmitCallback *>(NULL)) {
        DbgLog((LOG_TRACE, 2, TEXT("CRMemAllocator::~CRMemAllocator: Releasing ISubmitCallback at 0x%08x"),
                m_pISubmitCB));
        m_pISubmitCB->Release();
    } /* if */
} /* CRMemAllocator::~CRMemAllocator() */

  
/*F*
//  Name    : CRMemAllocator::Alloc()
//  Purpose : 
//  Context : 
//  Returns : NOERROR.
//  Params  : None.
//  Notes   : 
*F*/
HRESULT
CRMemAllocator::Alloc(void)
{
    CAutoLock lck(this);

    /* Check he has called SetProperties */
    HRESULT hr = CBaseAllocator::Alloc();
    if (FAILED(hr)) {
    	return hr;
    } /* if */

    /* If the requirements haven't changed then don't reallocate */
    if (hr == S_FALSE) {
    	return NOERROR;
    } /* if */
    ASSERT(hr == S_OK); // we use this fact in the loop below

    /* Free the old resources */
    if (m_pBuffer) {
    	ReallyFree();
    } /* if */

    CMediaSample *pSample;
    ASSERT(m_lAllocated == 0);
    // Create the new samples 
    for (; m_lAllocated < m_lCount; m_lAllocated++) {
	    pSample = new CRMediaSample(NAME("Buffered source media sample"),
            			            this,
                                    &hr,
                                    NULL,       // No internal storage
                                    m_lSize);   // not including prefix

	    if (FAILED(hr) || pSample == static_cast<CMediaSample *>(NULL)) {
            DbgLog((LOG_ERROR, 3, TEXT("CRMemAllocator::Alloc: Unable to allocate media sample!")));
	        delete pSample;
	        return E_OUTOFMEMORY;
	    } /* if */

        // This CANNOT fail
	    m_lFree.Add(pSample);
    } /* if */

    m_bChanged = FALSE;
    return NOERROR;
} /* CRMemAllocator::Alloc() */


/*F*
//  Name    : CRMemAllocator::GetBuffer()
//  Purpose : 
//  Context : 
//  Returns : 
//  Params  :
//  Notes   :
*F*/
HRESULT 
CRMemAllocator::GetBuffer(
    CRMediaSample **ppBuffer,
    REFERENCE_TIME *pStartTime,
    REFERENCE_TIME *pEndTime,
    DWORD dwFlags)
{
    UNREFERENCED_PARAMETER(pStartTime);
    UNREFERENCED_PARAMETER(pEndTime);
    UNREFERENCED_PARAMETER(dwFlags);
    CRMediaSample *pSample;

    *ppBuffer = NULL;
    for (;;)
	{
		{  //scope for lock
			CAutoLock cObjectLock(this);

			/* Check we are committed */
			if (!m_bCommitted) {
	    		return VFW_E_NOT_COMMITTED;
			}
			pSample = static_cast<CRMediaSample *>(m_lFree.RemoveHead());
			if (pSample == static_cast<CRMediaSample *>(NULL)) {
				SetWaiting();
			} /* if */
		} /* lock */
        /* If we didn't get a sample then wait for the list to signal */

        if (pSample) {
            break;
        }
        ASSERT(m_hSem != NULL);
        WaitForSingleObject(m_hSem, INFINITE);
	}

    DbgLog((LOG_TRACE, 4, TEXT("CRMemAllocator::GetBuffer: Retrieved a sample at 0x%08x"),
            pSample));

    /* Addref the buffer up to one. On release
       back to zero instead of being deleted, it will requeue itself by
       calling the ReleaseBuffer member function. NOTE the owner of a
       media sample must always be derived from CBaseAllocator */


    ASSERT(pSample->m_cRef == 0);
    pSample->m_cRef = 1;
    *ppBuffer = pSample;

    return NOERROR;

} /* CRMemAllocator::GetBuffer() */


/*F*
//  Name    : CRMemAllocator::ReleaseBuffer()
//  Purpose : Handle release of a buffer by a filter graph.
//  Context : Called by a media sample when the last reference
//            on it is released. This signals us to hand the
//            buffer encapsulated in the sample in question
//            back to the PPM which created it.
//  Returns : NOERROR.
//  Params  :
//      pSample Pointer to the media sample being released.
//  Notes   : 
//      We accept a CMediaSample here instead of an IMediaSample
//      as defined in the parent class because we need to
//      manipulate the media sample directly.
*F*/
STDMETHODIMP
CRMemAllocator::ReleaseBuffer(
    IMediaSample *pSample)
{
    DbgLog((LOG_TRACE, 4, TEXT("CRMemAllocator::ReleaseBuffer: Given back buffer at 0x%08x"),
            pSample));

    CheckPointer(pSample,E_POINTER);
    ValidateReadPtr(pSample,sizeof(IMediaSample));
    BOOL bRelease = FALSE;
    {
        CAutoLock cal(this);

        CRMediaSample *pCBSample = static_cast<CRMediaSample *>(pSample);
        if ((m_pISubmitCB != static_cast<ISubmitCallback *>(NULL)) && (pCBSample->m_pvCookie != NULL)) {
            // This sample needs to be handed back to the PPM.
            m_pISubmitCB->SubmitComplete((PVOID) pCBSample->m_pvCookie, NOERROR);
            // Zero out to indicate that this has been given back to the PPM.
            pCBSample->m_pvCookie = NULL; 
        } /* if */

        /* Put back on the free list */
        m_lFree.Add(static_cast<CMediaSample *>(pSample));
        if (m_lWaiting != 0) {
            NotifySample();
        }


        // if there is a pending Decommit, then we need to complete it by
        // calling Free() when the last buffer is placed on the free list

    	LONG l1 = m_lFree.GetCount();
    	if (m_bDecommitInProgress && (l1 == m_lAllocated)) {
    	    Free();
    	    m_bDecommitInProgress = FALSE;
            bRelease = TRUE;
    	}
    }

    if (m_pNotify) {

        ASSERT(m_fEnableReleaseCallback);

        //
        // Note that this is not synchronized with setting up a notification
        // method.
        //
        m_pNotify->NotifyRelease();
    }

    /* For each buffer there is one AddRef, made in GetBuffer and released
       here. This may cause the allocator and all samples to be deleted */

    if (bRelease) {
        Release();
    }

    return NOERROR;
} /* CRMemAllocator::ReleaseBuffer() */


/*F*
//  Name    : CRMemAllocator::SetCallback()
//  Purpose : Set the ISubmitCallback that we use to return buffers
//            that were in media samples.
//  Context : Called when the buffered source filter is first
//            connected to a PPM.
//  Returns : 
//      NOERROR         Successfully stored callback.
//      E_NOINTERFACE   Passed IUnknown doesn't support the
//                      ISubmitCallback interface we want.
//      E_POINTER       Bogus pIUnknown parameter.
//      E_UNEXPECTED    We already had our ISubmitCallback interface set.
//  Params  :
//      pIUnknown   Pointer to an IUnknown to query for our desired interface.
//  Notes   : 
*F*/
STDMETHODIMP
CRMemAllocator::SetCallback(
    IUnknown    *pIUnknown)
{
    if (pIUnknown == static_cast<IUnknown *>(NULL)) {
        DbgLog((LOG_ERROR, 2, TEXT("CRMemAllocator::SetCallback: Bogus (NULL) IUnknown passed in.")));
        return E_POINTER;
    } /* if */

    if (m_pISubmitCB != static_cast<ISubmitCallback *>(NULL)) {
        DbgLog((LOG_ERROR, 2, TEXT("CRMemAllocator::SetCallback: ISubmitCallback already set!")));
        return E_UNEXPECTED;
    } /* if */

    HRESULT hErr = pIUnknown->QueryInterface(IID_ISubmitCallback,
                                             reinterpret_cast<PVOID *>(&m_pISubmitCB));
    if (FAILED(hErr)) {
        DbgLog((LOG_ERROR, 2, TEXT("CRMemAllocator::SetCallback: Error 0x%08x querying for ISubmitCallback!"),
                hErr));
        return hErr;
    } /* if */

    DbgLog((LOG_TRACE, 2, TEXT("CRMemAllocator::SetCallback: ISubmitCallback set to 0x%08x"),
            m_pISubmitCB));
    return NOERROR;
} /* CRMemAllocator::SetCallback() */

STDMETHODIMP 
CRMemAllocator::ResetCallback()
{
    if (m_pISubmitCB != NULL)
    {
        m_pISubmitCB->Release();
        m_pISubmitCB = NULL;
        DbgLog((LOG_TRACE, 2, TEXT("CRMemAllocator::ResetCallback: ISubmitCallback set to NULL")));
    }
    return NOERROR;
}


STDMETHODIMP
CRMemAllocator::SetProperties(
    ALLOCATOR_PROPERTIES* pRequest,
    ALLOCATOR_PROPERTIES* pActual)
{
    CheckPointer(pActual,E_POINTER);
    ValidateReadWritePtr(pActual,sizeof(ALLOCATOR_PROPERTIES));
    CAutoLock cObjectLock(this);

    ZeroMemory(pActual, sizeof(ALLOCATOR_PROPERTIES));

    SYSTEM_INFO SysInfo;
    GetSystemInfo(&SysInfo);

    /*  Check the alignment request is a power of 2 */
    if ((-pRequest->cbAlign & pRequest->cbAlign) != pRequest->cbAlign) {
	DbgLog((LOG_ERROR, 1, TEXT("Alignment requested 0x%x not a power of 2!"),
	       pRequest->cbAlign));
    }
    /*  Check the alignment requested */
    if (pRequest->cbAlign == 0 ||
	((SysInfo.dwAllocationGranularity & (pRequest->cbAlign - 1)) != 0)) {
	DbgLog((LOG_ERROR, 1, TEXT("Invalid alignment 0x%x requested - granularity = 0x%x"),
	       pRequest->cbAlign, SysInfo.dwAllocationGranularity));
	return VFW_E_BADALIGN;
    }

    /* Can't do this if already committed, there is an argument that says we
       should not reject the SetProperties call if there are buffers still
       active. However this is called by the source filter, which is the same
       person who is holding the samples. Therefore it is not unreasonable
       for them to free all their samples before changing the requirements */

    if (m_bCommitted == TRUE) {
	return VFW_E_ALREADY_COMMITTED;
    }

    /* Must be no outstanding buffers */

    if (m_lFree.GetCount() < m_lAllocated) {
	return VFW_E_BUFFERS_OUTSTANDING;
    }

    /* There isn't any real need to check the parameters as they
       will just be rejected when the user finally calls Commit */

    // round length up to alignment - remember that prefix is included in
    // the alignment
    LONG lSize = pRequest->cbBuffer + pRequest->cbPrefix;
    LONG lRemainder = lSize % pRequest->cbAlign;
    if (lRemainder != 0) {
	lSize = lSize - lRemainder + pRequest->cbAlign;
    }
    pActual->cbBuffer = m_lSize = (lSize - pRequest->cbPrefix);

    pActual->cBuffers = m_lCount = pRequest->cBuffers;
    pActual->cbAlign = m_lAlignment = pRequest->cbAlign;
    pActual->cbPrefix = m_lPrefix = pRequest->cbPrefix;

    m_bChanged = TRUE;
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\wrap.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: wrap.h
//  Abstract:    header file. inline functions that perform greater than operations
//               accounting for wrap.
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////

#ifndef WRAP_H
#define WRAP_H

#include <windows.h>

#define BIG_DELTA    0xffff
#define LITTLE_DELTA 0xff 

//////////////////////////////////////////////////////////////////////////////////////////
//ShortWrapGt: This returns true when A is greater than  B, and the difference is less
//             LITTLE_DELTA. 
//             A is always the most recent number in terms of time
//////////////////////////////////////////////////////////////////////////////////////////
inline BOOL ShortWrapGt(const DWORD A,const DWORD B){return ( (A != B) && ( (A - B) < LITTLE_DELTA ) );};

//////////////////////////////////////////////////////////////////////////////////////////
//LongWrapGt: This returns true when A is greater than  B, and the difference is less
//            BIG_DELTA. 
//            A is always the most recent number in terms of time
//////////////////////////////////////////////////////////////////////////////////////////
inline BOOL LongWrapGt(const DWORD A,const DWORD B){return ( (A != B) && ( (A - B) < BIG_DELTA ) );}

//////////////////////////////////////////////////////////////////////////////////////////
//ShortWrapDelta:A is always the most recent number in terms of time.
//               This function exists because when you are dealing 
//               with wrap the two statements ARE !!NOT!! equivalent. 
//               1.) A - B > 0    
//               2.) A > B
//
//               So if this function is used the statement looks 
//               like the following:
//               ShortWrapDelta(A,B) > 0;
//               Thus, a user is unlikely to make changes without reading this comment.
//               
//////////////////////////////////////////////////////////////////////////////////////////
inline WORD ShortWrapDelta(const WORD A,const WORD B){return (A - B);}

//////////////////////////////////////////////////////////////////////////////////////////
//LongWrapDelta: A is always the most recent number in terms of time
//               This function exists because when you are dealing 
//               with wrap the two statements ARE !!NOT!! equivalent.
//               1.) A - B > 0    
//               2.) A > B
//
//               So if this function is used the statement looks 
//               like the following:
//               ShortWrapDelta(A,B) > 0;
//               Thus, a user is unlikely to make changes without reading this comment.
//               
//////////////////////////////////////////////////////////////////////////////////////////
inline DWORD LongWrapDelta(const DWORD A,const DWORD B){ return (A - B);}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\common\rmemry.h ===
/*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
//  Filename: RMemry.h
//  Purpose : Header file for the RPH memory allocator.
//  Contents:
//      class CRMediaSample     RPH media sample.
//                              Differs from generic media samples
//                              in that it keeps track of a cookie
//                              used for handing the buffer it encapsulates
//                              back to a PPM once it has been rendered.    
//      class CRMemAllocator    Memory allocator which does no allocation
//                              of the buffers encapsulated in media samples. 
//                              Instead, it simply accepts allocated buffers
//                              from the PPM and plugs them in its own buffers.
*M*/

#ifndef _RMEMRY_H_
#define _RMEMRY_H_

// Predeclaration because of usage in CRMediaSample
class CRMemAllocator;

/*C*
//  Name    : CRMediaSample
//  Purpose : Implementation of the RPH filters' custom
//            media samples. Differs from generic media samples
//            in that it keeps track of a cookie
//            used for handing the buffer it encapsulates
//            back to a PPM once it has been rendered.
//  Context : Instantiated by the CRMemAllocator (see below).
*C*/
class 
CRMediaSample : 
    public CMediaSample
{
    friend CRMemAllocator;

    protected:
        // Cookie used to pass us back to the PPM.
        void                *m_pvCookie;

        CRMemAllocator      *m_pAllocator;  /* The allocator who owns us */

    public:
        // set the buffer pointer,length, and our cookie. Used by the
        // CRMemAllocator to put a PPM buffer into this media sample.
        HRESULT SetPointer(BYTE     *ptr, 
                           LONG     cBytes, 
                           void    *pvCookie);

        void *GetCookie(void) {return m_pvCookie;}

        CRMediaSample(
            TCHAR                   *pName,
            CRMemAllocator          *pAllocator,
            HRESULT                 *phr,
            LPBYTE                  pBuffer = NULL,
            LONG                    length = 0);

        ~CRMediaSample();
}; /* class CRMediaSample */


class CRPHBase;

/*C*
//  Name    : CRMemAllocator
//  Purpose : Implementation of the buffered source filter's custom
//            memory allocator.  Differs from the basic CMemAllocator
//            in the it instantiates media samples
//  Context : Instantiated by the CRMemAllocator (see below).
*C*/
class
CRMemAllocator :
    public CMemAllocator
{
    private:
        friend CRPHBase;
    
        HRESULT Alloc(void);

        ISubmitCallback     *m_pISubmitCB;

    public:
        // IMemAllocator Interfaces, overridden from CMemAllocator/CBaseAllocator
        STDMETHODIMP SetProperties(
		    ALLOCATOR_PROPERTIES* pRequest,
		    ALLOCATOR_PROPERTIES* pActual);

        STDMETHODIMP GetBuffer(
            CRMediaSample   **ppBuffer,
            REFERENCE_TIME  *pStartTime,
            REFERENCE_TIME  *pEndTime,
            DWORD           dwFlags);

        STDMETHODIMP ReleaseBuffer(IMediaSample *pBuffer);

        // Private interface, used by CBufferedSourceFilter to setup the
        // ISubmitCallback we use to return buffers to the PPM.
        STDMETHODIMP SetCallback(IUnknown *pIUnknown);
        STDMETHODIMP ResetCallback();

        // Implementation
        CRMemAllocator(TCHAR *, LPUNKNOWN, HRESULT *);
        ~CRMemAllocator();
}; /* class CRMemAllocator */


#endif _RMEMRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\ppm\thrdsafe.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation.
//
//
//  Module Name: thrdsafe.h
//  Abstract:    Defines thread-safety utility classes and macros.
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////

// $Header:   R:/rtp/src/ppm/THRDSAFE.H_v   1.4   31 Jan 1997 23:32:36   CPEARSON  $

#ifndef __THRDSAFE_H__
#define __THRDSAFE_H__

#include <winbase.h> // CRITICAL_SECTION



////////////////////////////////////////////////////////////////////////
// Helper macros for using class CSerialBlockGuard.  On entry to a
// serialized statement block, code:
//
//		SERIALIZEDBLOCKENTRY(myCriticalSection);
//
// The macro will return only after ownership of the myCriticalSection is
// obtained.  The CSerialBlockGuard destructor will exit the critical
// section when control leaves the block.  Because it declares an automatic
// variable, you can only use SERIALIZEDBLOCKENTRY() once in a block.
//
// In cases where you wish to exit the critical section while still in
// the block, code:
//
//		SERIALIZEDBLOCKEARLYEXIT();
//
// If you need to exit and re-enter the critical section in the same
// block, then these macros won't buy you anything -- just manipulate
// the critical section directly.

#define SERIALIZEDBLOCKENTRY(CS)	CSerialBlockGuard serialBlockGuard(&(CS))
#define SERIALIZEDBLOCKEARLYEXIT()	serialBlockGuard.EarlyExit()


////////////////////////////////////////////////////////////////////////
// class CSerialBlockGuard: Helper class to manage critical section
// on entry/exit of serialized code blocks (typically functions).
// On construction, objects of this class block the given critical
// section, and release the c.s. on destruction, ensuring proper cleanup
// for all exit routes.

class CSerialBlockGuard
{
	LPCRITICAL_SECTION	m_pCritSect;

public:

	CSerialBlockGuard(CRITICAL_SECTION* pCritSect) :
		m_pCritSect(pCritSect)
		{ EnterCriticalSection(m_pCritSect); }

	CSerialBlockGuard(const CSerialBlockGuard& rOriginal) :
		m_pCritSect(rOriginal.m_pCritSect) {;}

	void EarlyExit()
		{ if (m_pCritSect) LeaveCriticalSection(m_pCritSect); m_pCritSect = NULL; }

	~CSerialBlockGuard()
		{ if (m_pCritSect) LeaveCriticalSection(m_pCritSect); }
};


////////////////////////////////////////////////////////////////////////
// Helper macros for coding class CThreadSafe serialized methods.  To
// ensure that entry to a method is serialized across threads, code:
//
//		THREADSAFEENTRY();
//
// before accessing shared member variables.  The macro will return
// only after ownership of this->m_critSect is obtained.
//
// In cases where you wish to exit the critical section while still in
// the method, code:
//
//		THREADSAFEEARLYEXIT();
//
// If you need to exit and re-enter the critical section in the same
// method, then use the CThreadSafe::Lock() and CThreadSafe::Unlock()
// methods instead.

#define THREADSAFEENTRY()		SERIALIZEDBLOCKENTRY(*getCritSect())
#define THREADSAFEEARLYEXIT()	SERIALIZEDBLOCKEARLYEXIT()


////////////////////////////////////////////////////////////////////////
// class CThreadSafe: A minimal base class from which to derive
// thread-safe classes.  These classes serialize entry to methods using
// the THREADSAFEENTRY() macro.  Derived class should declare this a
// protected base to hide serialization methods. For derived classes
// with multiple base classes, if serialization is needed during
// construction (unusual), this should be first base class, and should
// be constructed with bInitialLock == TRUE;

class CThreadSafe
{
	CRITICAL_SECTION	m_critSect;

	// Hide assignment operator, forcing compiler to use copy ctor.
	CThreadSafe& operator=(const CThreadSafe&);

public:

	CThreadSafe(BOOL bInitialLock = FALSE)
		{ InitializeCriticalSection(&m_critSect); if (bInitialLock) Lock(); }

	// Copy ctor creates a new critical section, but doesn't lock, on
	// assumption that new object can't yet be visible to another thread.
	CThreadSafe(const CThreadSafe& rOriginal)
		{ InitializeCriticalSection(&m_critSect); }

	~CThreadSafe()
		{ DeleteCriticalSection(&m_critSect); }

	// Castaway const in following methods, so that const methods can
	// access members in a thread-safe manner.
	void Lock() const
		{ EnterCriticalSection((LPCRITICAL_SECTION) &m_critSect); }

	void Unlock() const
		{ LeaveCriticalSection((LPCRITICAL_SECTION) &m_critSect); }
		
protected:

	LPCRITICAL_SECTION getCritSect() const
		{ return (LPCRITICAL_SECTION) &m_critSect; }
};

#endif	// __THRDSAFE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\common\fxqueue.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    queue.h

Abstract:

    Simple fixed size queue

--*/

template <class T>
class CFixedSizeQueue
{
public:
    typedef T dataClass;
    CFixedSizeQueue(DWORD dwDepth)
            : m_dwDepth(dwDepth)
    {
        ASSERT(m_dwDepth != 0);
        m_dwCount = m_dwTail = 0;
        m_dwHead = 0;
        m_pData = new T[m_dwDepth];
    }
    //
    // CFixedSizeQueue::~CFixedSizeQueue - delete allocated memory
    //
    ~CFixedSizeQueue()
    {
        Flush();
        ASSERT(m_dwCount == 0);
        delete [] m_pData;
    }

    bool EnQ(const T &refData);
    bool DeQ(T *pData);
    bool Find(const T &refData);
    bool IsEmpty() { return m_dwCount == 0; }
    //
    // DeQueue a buffer
    //
    void Flush()
    {
        T data;
        while (DeQ(&data))
            /*void*/;
    }

private:
    //
    // Buffer Storage Management data
    //
    T        *m_pData;
    DWORD            m_dwDepth;
    DWORD            m_dwCount;
    DWORD            m_dwHead;
    DWORD            m_dwTail;
};

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
//  Implementation section

//
// EnQueue a buffer
//
template <class T>
bool CFixedSizeQueue<T>::EnQ(const T &refData)
{
    //
    // m_pData == NULL implies the constructor failed
    //
    if (m_pData == NULL) { return false; }

    //
    // Put the data in the queue.  Assignment operation assumed safe for the
    //  data type.
    //
    m_pData[m_dwTail] = refData;

    //
    // Adjust internal data
    //
    m_dwTail++;
    if (m_dwTail == m_dwDepth)
    {
        m_dwTail = 0;
    }
    m_dwCount++;

    //
    // Head follows the tail if the Q is full
    //
    if (m_dwCount >= m_dwDepth)
    {
        m_dwCount = m_dwDepth;
        m_dwHead++;
        if (m_dwHead == m_dwDepth)
            m_dwHead = 0;
    }

    return true;
}

//
// DeQueue a buffer
//
template <class T>
bool CFixedSizeQueue<T>::DeQ(T *pData)
{
    // User beware
    ASSERT(pData != NULL);

    //
    // m_pData == NULL implies the constructor failed
    //
    if (m_pData == NULL) { return false; }

    if (m_dwCount == 0)
    {
        //ASSERT(m_dwHead == m_dwTail);
        return false;
    }

    //
    // Remove Buffer
    //
    *pData = m_pData[m_dwHead];
    
    //
    // Adjust internal data
    //
    m_dwCount--;
    m_dwHead++;
    if (m_dwHead == m_dwDepth)
    {
        m_dwHead = 0;
    }

    return true;
}

//
// Walk the queue and look for a match.
//
template <class T>
bool CFixedSizeQueue<T>::Find(const T &refData)
{
    //
    // m_pData == NULL implies the constructor failed
    //
    if (m_pData == NULL) { return false; }

    if (m_dwCount == 0)
    {
        // ASSERT(m_dwHead == m_dwTail);
        return false;
    }

    DWORD dwPeek = m_dwHead;
    while (dwPeek != m_dwTail)
    {
        if (m_pData[dwPeek] == refData)
        {
            return true;
        }
        dwPeek++;
        if (dwPeek == m_dwDepth)
        {
            dwPeek = 0;
        }
    }
    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\common\main.cpp ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : main.cpp
// Purpose  : RTP RPH filter entry points.
// Contents : 
//*M*/

#if !defined(RPH_IN_DXMRTP)

#include <streams.h>

#include <initguid.h>

#include <olectl.h>


/*F*
// Name     : DllRegisterServer
// Purpose  : exported entry points for registration.
// Context  : Called by regsvr32.exe
// Returns  : None.
// Params   : None.
// Notes    : In this case we call through to default implmentations
*F*/
HRESULT 
DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );
} /* DllRegisterServer() */


/*F*
// Name     : DllUnregisterServer
// Purpose  : exported entry points for registration.
// Context  : Called by regsvr32.exe
// Returns  : None.
// Params   : None.
// Notes    : In this case we call through to default implmentations
*F*/
HRESULT 
DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );
} /* DllUnregisterServer() */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\common\rph.h ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : rph.h
// Purpose  : Define the base class that implements the RTP RPH filters.
// Contents : 
//*M*/


#ifndef _RPH_H_
#define _RPH_H_

#include <list.h>
#include <stack.h>
#include <irtprph.h>
#include <isubmit.h>
#include <icbtimer.h>
#include <ippmcb.h>
#include "fxqueue.h"

#define DEFAULT_LATENCY 20

typedef struct CtimeoutSample {
    DWORD timeout;
    void *ptr;
    CtimeoutSample(){ timeout = 0; ptr = 0; }
    CtimeoutSample(unsigned long t, void *p){timeout = t; ptr = p;}
} CtimeoutSample;

class CRPHBase : public CTransformFilter,
          public IRTPRPHFilter,
          public ISubmit,
          public ISubmitCallback,
          public ICBCallback,
          public IPPMError,
          public IPPMNotification,
          public CPersistStream,
          public ISpecifyPropertyPages
{

    DWORD m_cPropertyPageClsids;
    const CLSID **m_pPropertyPageClsids;
    
public:

    // Reveals IRTPRPHFilter
    virtual STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    DECLARE_IUNKNOWN;

    virtual HRESULT Receive(IMediaSample *pSample);
    virtual HRESULT CheckInputType(const CMediaType *mtIn) = 0;
    virtual HRESULT CheckTransform(const CMediaType *mtIn,const CMediaType *mtOut) = 0;
    virtual HRESULT GetMediaType(int iPosition, CMediaType *pMediaType) = 0;
    virtual HRESULT GetInputMediaType(int iPosition, CMediaType *pMediaType) = 0;
    virtual HRESULT DecideBufferSize(IMemAllocator *pAlloc,
                             ALLOCATOR_PROPERTIES *pProperties);
    virtual HRESULT StartStreaming();
    virtual HRESULT StopStreaming();
    virtual HRESULT CompleteConnect(PIN_DIRECTION dir,IPin *pPin) = 0;
    virtual STDMETHODIMP Pause();
    virtual CBasePin *GetPin(int n);

    // IRTPRPHFilter methods

    virtual STDMETHODIMP OverridePayloadType(BYTE bPayloadType);
        
    virtual STDMETHODIMP GetPayloadType(BYTE __RPC_FAR *lpbPayloadType);
        
    virtual STDMETHODIMP SetMediaBufferSize(DWORD dwMaxMediaBufferSize);
        
    virtual STDMETHODIMP GetMediaBufferSize(LPDWORD lpdwMaxMediaBufferSize);
        
    virtual STDMETHODIMP SetOutputPinMediaType(AM_MEDIA_TYPE *lpMediaPinType);
    
    virtual STDMETHODIMP GetOutputPinMediaType(AM_MEDIA_TYPE **ppMediaPinType);
    
#ifdef LIMITQUEUE
    virtual STDMETHODIMP SetQueueLimit(DWORD dwSampleLimit);
        
    virtual STDMETHODIMP GetQueueLimit(LPDWORD lpdwSampleLimit);
#endif

    virtual STDMETHODIMP SetTimeoutDuration(DWORD dwDejitterTime, DWORD dwLostPacketTime);
        
    virtual STDMETHODIMP GetTimeoutDuration(LPDWORD lpdwDejitterTime, 
        LPDWORD lpdwLostPacketTime);
        
    // ISubmit methods for PPM
    STDMETHOD(InitSubmit)(THIS_ ISubmitCallback *pSubmitCallback);
    STDMETHOD(Submit)(THIS_ WSABUF *pWSABuffer, DWORD BufferCount, 
                            void *pUserToken, HRESULT Error);
    STDMETHOD_(void,ReportError)(THIS_ HRESULT Error);
    STDMETHOD(Flush)(THIS);

    // ISubmitCallback methods for PPM
    STDMETHOD_(void,SubmitComplete)(THIS_ void *pUserToken, HRESULT Error);    
    STDMETHOD_(void,ReportError)(THIS_ HRESULT Error, int DEFAULT_PARAM_ZERO);

    // ICBCallback methods for the callback timer
    virtual STDMETHODIMP Callback(THIS_
								  DWORD *pdwObjectContext,
								  DWORD *pdwCallbackContext);

    // IPPMCallback methods for PPM Connection points
    virtual STDMETHODIMP PPMError(THIS_ HRESULT hError, DWORD dwSeverity, DWORD dwCookie,
                                        unsigned char pData[], unsigned int iDataLen);
    virtual STDMETHODIMP PPMNotification(THIS_ HRESULT hStatus, DWORD dwSeverity, DWORD dwCookie,
                                            unsigned char pData[], unsigned int iDataLen);

    // ISpecifyPropertyPages Methods
    virtual STDMETHODIMP GetPages(CAUUID *pcauuid);

    // CPersistStream methods
    virtual HRESULT ReadFromStream(IStream *pStream);
    virtual HRESULT WriteToStream(IStream *pStream);
    virtual int SizeMax(void);
    virtual HRESULT _stdcall GetClassID(CLSID *pCLSID) = 0;
    virtual DWORD GetSoftwareVersion(void) = 0;

    // Setup helper
    LPAMOVIESETUP_FILTER GetSetupData() = 0;

    //provide this on a derived filter basis, as our input pin is overridden to call this
    virtual HRESULT GetAllocatorRequirements(ALLOCATOR_PROPERTIES *pProps) = 0;


protected:

    // Constructor
    CRPHBase(TCHAR *tszName,LPUNKNOWN punk,HRESULT *phr, CLSID clsid,
             DWORD dwPacketNum,
             DWORD dwPacketSize,
             DWORD dwQueueTimeout, 
             DWORD dwStaleTimeout,
             DWORD dwClock,
             BOOL bAudio, 
             DWORD dwFramesPerSecond,
             DWORD cPropPageClsids,
             const CLSID **pPropPageClsids);
    ~CRPHBase();

    virtual HRESULT GetTSNormalizer(DWORD dwNTPts, DWORD dwRTPts, DWORD *dwOffset, DWORD dwclock);

    virtual HRESULT SetPPMSession();

    virtual HRESULT GetPPMConnPt();

    virtual HRESULT FlushQueue();

    // The number of buffers to request on the output allocator
    long m_lBufferRequest;

    //Interface pointers to PPM and Callback Timer interfaces
    IPPMReceive *m_pPPMReceive;
    ISubmit *m_pPPM;
    ISubmitCallback *m_pPPMCB;
    ISubmitUser *m_pPPMSU;
    ICBTimer *m_pCBTimer;
    IPPMData *m_pPPMData;
    IPPMReceiveSession *m_pPPMSession;

    GUID m_PPMCLSIDType;
    DWORD m_dwMaxMediaBufferSize;
    int m_PayloadType;
    IMediaSample *m_pIInputSample;
    DWORD m_dwPayloadClock;
    BOOL m_bRTPCodec;
    DWORD m_dwDejitterTime;
    DWORD m_dwLostPacketTime;
#ifdef LIMITQUEUE
    DWORD m_dwSampleLimit;
#endif
    DWORD m_dwLastRTCPtimestamp;
    DWORD m_dwLastRTCPNTPts;
    DWORD m_dwRTPTimestampOffset;        //RTP to NTP offset in milliseconds
    DWORD m_dwClockStartTime;
    DWORD m_dwStreamStartTime;
    DWORD m_dwGraphLatency;                // in msecs
    DWORD m_dwFramesPerSecond;            // used to calculate media buffers needed
    queue< list<CtimeoutSample *> > m_TimeoutQueue;
    BOOL m_bCallbackRegistered;
    DWORD *m_pdwCallbackID;
    DWORD *m_pdwCallbackToken;
    BOOL m_bPTSet;
    BOOL m_bAudio;
    BOOL m_bPaused;
    
    IConnectionPoint    *m_pIPPMErrorCP;
    IConnectionPoint    *m_pIPPMNotificationCP;
    
    DWORD m_dwPPMErrCookie;
    DWORD m_dwPPMNotCookie;

    // Non interface locking critical sections
    CCritSec m_TimeoutQueueLock;
   CCritSec m_cStateLock;

    // Keep a queue of recent sequence numbers so we can at least do gross checks.
    CFixedSizeQueue<DWORD> m_SequenceQ;

}; // CRPHBase

#endif // _RPH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\common\rph.cpp ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : rph.cpp
// Purpose  : RTP RPH base class filter implementation.
// Contents : 
//*M*/

#include <winsock2.h>
#include <streams.h>
#include <list.h>
#include <stack.h>
#include <rtpclass.h>
#include <ippm.h>
#include <amrtpuid.h>
#include "rph.h"
#include "rphipin.h"

#ifndef COPYOPT_OFF
#include "rphopin.h"
#endif

#include <ppmclsid.h>
#include <ppmerr.h>
#include <memory.h>
#include <mmsystem.h>

// serializes access to Start and Stop stream
CCritSec g_cStartStopStream;

// I used rph_status to leave a trace of all the sections of code
// visited in CRPHBase::Submit() when a buffer was released twice
// when Deliver() failed. The error code returned made DataCopy in
// h261rcv.cpp to call EnqueueBuffer which released the buffer a
// second time.
#if 0
DWORD rph_status = 0;
#define RPHSET(n)    (rph_status |= (1<<(n)))
#define RPHSETINIT() (rph_status = 0)
#else
#define RPHSET(n)
#define RPHSETINIT()
#endif

#ifdef DBG
inline LPCTSTR LogPPMNotification(DWORD dwCode)
{
    switch(dwCode)
    {
    case PPM_E_FAIL:
        return ">>> PPM_E_FAIL";
    case PPM_E_CORRUPTED:
        return ">>> PPM_E_CORRUPTED";
    case PPM_E_EMPTYQUE:
        return ">>> PPM_E_EMPTYQUE:";
    case PPM_E_OUTOFMEMORY:
        return ">>> PPM_E_OUTOFMEMORY";
    case PPM_E_NOTIMPL:
        return ">>> PPM_E_NOTIMPL";
    case PPM_E_DUPLICATE:
        return ">>> PPM_E_DUPLICATE";
    case PPM_E_INVALID_PARAM:
        return ">>> PPM_E_INVALID_PARAM";
    case PPM_E_DROPFRAME:
        return ">>> PPM_E_DROPFRAME";
    case PPM_E_PARTIALFRAME:
        return ">>> PPM_E_PARTIALFRAME";
    case PPM_E_DROPFRAG:
        return ">>> PPM_E_DROPFRAG";
    case PPM_E_CLIENTERR:
        return ">>> PPM_E_CLIENTERR";
    case PPM_E_FAIL_PARTIAL:
        return ">>> PPM_E_FAIL_PARTIAL";
    case PPM_E_OUTOFMEMORY_PARTIAL:
        return ">>> PPM_E_OUTOFMEMORY_PARTIAL";
    }
    ASSERT("Unknown Notification");
    return "";
}
#else
#define LogPPMNotification(dwCode) ""
#endif

//
// Constructor
//
CRPHBase::CRPHBase(TCHAR *tszName,LPUNKNOWN punk,HRESULT *phr, CLSID clsid,
                   DWORD dwPacketNum,
                   DWORD dwPacketSize,
                   DWORD dwQueueTimeout, 
                   DWORD dwStaleTimeout,
                   DWORD dwClock,
                   BOOL bAudio,
                   DWORD dwFramesPerSecond,
                   DWORD cPropPageClsids,
                   const CLSID **pPropPageClsids) :
    CTransformFilter(tszName, punk, clsid),
    CPersistStream(punk, phr),
    m_lBufferRequest(dwPacketNum),
    m_dwMaxMediaBufferSize(dwPacketSize),
    m_dwDejitterTime(dwQueueTimeout),
    m_dwLostPacketTime(dwStaleTimeout),
    m_dwPayloadClock(dwClock),
    m_bAudio(bAudio),
    m_dwFramesPerSecond(dwFramesPerSecond),
    m_cPropertyPageClsids(cPropPageClsids),
    m_pPropertyPageClsids(pPropPageClsids),
    m_SequenceQ(20)                             // 20 packets ought to be enough for a gross check!
{
    DbgLog((LOG_TRACE,4,TEXT("CRPHBase::CRPHBase")));

    ASSERT(tszName);
    ASSERT(phr);

    m_pPPMReceive = NULL;
    m_pPPM = NULL;
    m_pPPMCB = NULL;
    m_pPPMSU = NULL;
    m_pCBTimer = NULL;
    m_pPPMData = NULL;
    m_pPPMSession = NULL;
    m_PayloadType = -1;
    m_bRTPCodec = FALSE;
    m_dwLastRTCPtimestamp = 0;
    m_dwLastRTCPNTPts = 0;
    m_dwRTPTimestampOffset = 0;
    m_dwClockStartTime = 0;
    m_dwStreamStartTime = 0;
    m_bCallbackRegistered = FALSE;
    m_pdwCallbackID = (DWORD *) this;
    m_pdwCallbackToken = (DWORD *) this;
    m_pIPPMErrorCP = NULL;    
    m_pIPPMNotificationCP = NULL;
    m_dwPPMErrCookie = 0;
    m_dwPPMNotCookie = 0;
    // CoInitialize(NULL);
    m_bPTSet = FALSE;
#ifdef LIMITQUEUE
    m_dwSampleLimit = 10;
#endif
    m_bPaused = FALSE;
    m_dwGraphLatency = DEFAULT_LATENCY;

} // CRPHBase

CRPHBase::~CRPHBase()
{
    //release and unload PPM
    if (m_pPPM) m_pPPM->Flush();
    if (m_pPPM) {m_pPPM->Release(); m_pPPM = NULL; }
    if (m_pPPMCB) {m_pPPMCB->Release(); m_pPPMCB = NULL; }
    if (m_pPPMReceive) {m_pPPMReceive->Release(); m_pPPMReceive = NULL; }
    if (m_pCBTimer) {m_pCBTimer->Release(); m_pCBTimer = NULL; }
    if (m_pPPMData) {m_pPPMData->Release(); m_pPPMData = NULL; }
    if (m_pPPMSession) {m_pPPMSession->Release(); m_pPPMSession = NULL; }
    if (m_dwPPMErrCookie) {m_pIPPMErrorCP->Unadvise(m_dwPPMErrCookie); m_dwPPMErrCookie = 0; }
    if (m_dwPPMNotCookie) {m_pIPPMNotificationCP->Unadvise(m_dwPPMNotCookie); m_dwPPMNotCookie = 0; }
    if (m_pIPPMErrorCP) {m_pIPPMErrorCP->Release(); m_pIPPMErrorCP = NULL; }
    if (m_pIPPMNotificationCP) {m_pIPPMNotificationCP->Release(); m_pIPPMNotificationCP = NULL; }

    // CoUninitialize();
}

//
// NonDelegatingQueryInterface
//
// Reveals IRTPRPHFilter and other custom inherited interfaces
//
STDMETHODIMP CRPHBase::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    CheckPointer(ppv,E_POINTER);

    if (riid == IID_IRTPRPHFilter) {
        return GetInterface((IRTPRPHFilter *) this, ppv);
    } else if (riid == IID_ISubmit) {
        return GetInterface((ISubmit *) this, ppv);
    } else if (riid == IID_ISubmitCallback) {
        return GetInterface((ISubmitCallback *) this, ppv);
    } else if (riid == IID_ICBCallback) {
        return GetInterface((ICBCallback *) this, ppv);
    } else if (riid == IID_IPPMError) {
        return GetInterface((IPPMError *) this, ppv);
    } else if (riid == IID_IPPMNotification) {
        return GetInterface((IPPMNotification *) this, ppv);
    } else if (riid == IID_IPersistStream) {
        return GetInterface((IPersistStream *) this, ppv);
     } else if (riid == IID_ISpecifyPropertyPages) {
        return GetInterface((ISpecifyPropertyPages *) this, ppv);   
    } else {
        return CTransformFilter::NonDelegatingQueryInterface(riid, ppv);
    }

} // NonDelegatingQueryInterface

// Notes from CTransformFilter::GetPin:
// return a non-addrefed CBasePin * for the user to addref if he holds onto it
// for longer than his pointer to us. We create the pins dynamically when they
// are asked for rather than in the constructor. This is because we want to
// give the derived class an oppportunity to return different pin objects

// We return the objects as and when they are needed. If either of these fails
// then we return NULL, the assumption being that the caller will realise the
// whole deal is off and destroy us - which in turn will delete everything.

CBasePin *
CRPHBase::GetPin(int n)
{
    HRESULT hr = S_OK;

    // Create an input pin if necessary

    if (m_pInput == NULL) {

        m_pInput = new CRPHIPin(NAME("Transform input pin"),
                                          this,              // Owner filter
                                          &hr,               // Result code
                                          L"XForm In");      // Pin name


        //  Can't fail
        ASSERT(SUCCEEDED(hr));
        if (m_pInput == NULL) {
            return NULL;
        }
#ifdef COPYOPT_OFF
        m_pOutput = (CTransformOutputPin *) new CTransformOutputPin(NAME("Transform output pin"),
#else
        m_pOutput = new CRPHOPin(NAME("Transform output pin"),
#endif
                                            this,            // Owner filter
                                            &hr,             // Result code
                                            L"XForm Out");   // Pin name


        // Can't fail
        ASSERT(SUCCEEDED(hr));
        if (m_pOutput == NULL) {
            delete m_pInput;
            m_pInput = NULL;
        }
    }

    // Return the appropriate pin

    if (n == 0) {
        return m_pInput;
    } else
    if (n == 1) {
        return m_pOutput;
    } else {
        return NULL;
    }
}


//
// Receive
// Override from CTransformFilter because Transform() is only 1-1; we need many-1
// This is the transform work engine along with Submit
//
HRESULT CRPHBase::Receive(IMediaSample *pSample)
{
    DbgLog((LOG_TRACE,4,TEXT("CRPHBase::Receive")));

    HRESULT hr;
    ASSERT(pSample);
    WSABUF pWSABuffer[1];
    static BOOL bFirstPacket = TRUE;



    // If no output to deliver to then no point sending us data

    ASSERT (m_pOutput != NULL) ;

    pSample->AddRef();  //need to addref this since we'll be keeping it till later

    //Make sure I have a PPM to talk to, or else
    if (m_pPPM == NULL) { pSample->Release(); return E_FAIL; }

    //Build the WSABUFs for PPM
    //Data
    hr = pSample->GetPointer ((BYTE**)&(pWSABuffer[0].buf));
    if (FAILED(hr)) {
        pSample->Release();
        return VFW_E_SAMPLE_REJECTED;
    }

    DbgLog((LOG_TRACE,3,TEXT("CRPHBase::Receive New Data length %d"), 
        pSample->GetActualDataLength()));

    //check if RTCP report
#if 0 //disable this until timestamp issues are cleared up
    if (((RTCPSR_Header *) pWSABuffer[0].buf)->pt() == 200) {
        //This is my RTCP Sender's report
        //save off RTP timestamp and NTP timestamp
        m_dwLastRTCPtimestamp = ((RTCPSR_Header *) pWSABuffer[0].buf)->ts();
        m_dwLastRTCPNTPts = ((RTCPSR_Header *) pWSABuffer[0].buf)->ntp_mid();
        //store the offset
        hr = GetTSNormalizer(m_dwLastRTCPNTPts, m_dwLastRTCPtimestamp, 
            &m_dwRTPTimestampOffset, m_dwPayloadClock);
        //We don't pass on this sample or need it any longer
        pSample->Release();
        return NOERROR;
    } else 
#endif

#if 0 // disable the checking on the payload type.
    if (((RTP_Header *) pWSABuffer[0].buf)->pt() != m_PayloadType) { // this packet is not the right PT
        pSample->Release();
        return VFW_E_SAMPLE_REJECTED;
    }
#endif

    //
    // Check to see if we've seen this sequence number recently and if so
    //  disgard the packet assuming it's a duplicate.  Note that occationally
    //  we may loose packets at the beginning of a talk spurt depending on
    //  the queue size.  This should be fixed in the future.
    //
    if (!m_SequenceQ.Find(((RTP_Header *) pWSABuffer[0].buf)->seq()))
    {
        //
        // We didn't find it so insert stick it in our queue.
        //
        if (!m_SequenceQ.EnQ(((RTP_Header *) pWSABuffer[0].buf)->seq()))
        {
            //
            // If that failed we must be out of memory.
            //
            pSample->Release();
            return E_OUTOFMEMORY;
        }
    } 
    else
    {
        //
        // We've already see this packet.
        //
        pSample->Release();
        return VFW_E_SAMPLE_REJECTED;
    }

    if (bFirstPacket) {
        CRefTime tStart;
        hr = StreamTime(tStart);
        m_dwStreamStartTime = tStart.Millisecs();
        m_dwClockStartTime = timeGetTime();
        bFirstPacket = FALSE;
        m_dwRTPTimestampOffset = m_dwClockStartTime - ((((RTP_Header *) 
            pWSABuffer[0].buf)->ts())/(m_dwPayloadClock/1000));
    }
    
    pWSABuffer[0].len = pSample->GetActualDataLength();

    hr = m_pPPM->Submit(pWSABuffer, 1, pSample, NOERROR);

    if (FAILED(hr)) {
        hr = VFW_E_RUNTIME_ERROR;
    }

    return NOERROR;
}


// Submit
// Some code from CTransformFilter because Transform() is only 1-1; we need many-1
// This is the transform work engine, along with Receive
// This function is called from PPM to hand us the media buffers
//
 
STDMETHODIMP CRPHBase::Submit(WSABUF *pWSABuffer, DWORD BufferCount, 
                            void *pUserToken, HRESULT Error)
{
    DbgLog((LOG_TRACE,4,TEXT("CRPHBase::Submit")));

	RPHSETINIT();
	
    HRESULT hr;
#ifdef COPYOPT_OFF
    IMediaSample *pOutSample;
#else
    CRMediaSample *pOutSample;
#endif
    char *pSampleData = NULL;
    DWORD dwOffset = 0;
    static DWORD dwNetLatency = 0;
    DWORD sampleNTPTime = 0;
    BOOL bPaused = FALSE;

    //If I don't have a PPM to talk to, I can't do anything
    if (m_pPPMCB == NULL) {	RPHSET(0);return E_FAIL;}

#ifdef LIMITQUEUE
    //If the sample limit has been set, we check it
    if (m_dwSampleLimit != 0) {
		RPHSET(1);
        DWORD dwCheckSize = (m_dwSampleLimit > (DWORD)m_lBufferRequest) ?
            m_lBufferRequest : m_dwSampleLimit;
        if (m_TimeoutQueue.size() == dwCheckSize) {
            //We skip this sample, as we've been told to limit our dejitter queue

            //Release PPM's packet buffer
            m_pPPMCB->SubmitComplete(pUserToken, NOERROR);

			RPHSET(2);
            return NOERROR;
        }
    }
#endif

#if 0 //debug junk
    if (m_State != State_Running) {
//        DbgLog((LOG_TRACE,3,TEXT("CRPHBase::Submit not in State_Running")));
        DbgLog((LOG_LOCKING,2,TEXT("CRPHBase::Submit not in State_Running")));
    }
#endif
    //If the queue is full, we push one out so that GetDeliveryBuffer doesn't block
    {  //scope the lock
        CAutoLock cObjectLock(&m_TimeoutQueueLock);
        CtimeoutSample *tSample;
		
		RPHSET(3);
        if (m_TimeoutQueue.size() == (DWORD)m_lBufferRequest) {
            DbgLog((LOG_LOCKING,4,TEXT("CRPHBase::Submit Bumping one out of the queue")));
            tSample = m_TimeoutQueue.front();
            m_TimeoutQueue.pop();
            //unlock deliver release and lock
            m_TimeoutQueueLock.Unlock();
            hr = m_pOutput->Deliver((IMediaSample*)tSample->ptr);
            // release the output buffer. If the connected pin still needs it,
            // it will have addrefed it itself.
            ((IMediaSample*)tSample->ptr)->Release();
            m_TimeoutQueueLock.Lock();
			RPHSET(4);
        }
    }


#ifdef COPYOPT_OFF
    // this may block for an indeterminate amount of time
    hr = m_pOutput->GetDeliveryBuffer( &pOutSample
                             , NULL
                             , NULL
                             , NULL
//                             , (Error == PPM_E_DROPFRAME)
                                     );
    if (FAILED(hr)) {
		RPHSET(5);
        return hr;
    }
#else
    ASSERT(static_cast<CRPHOPin *>(m_pOutput)->m_CRMemAllocator);
    hr = static_cast<CRPHOPin *>(m_pOutput)->m_CRMemAllocator->GetBuffer(&pOutSample,
        NULL,
        NULL,
        (Error == PPM_E_DROPFRAME) ? AM_GBF_PREVFRAMESKIPPED : 0);

    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 3, 
                TEXT("CRPHBase::Submit: Error 0x%08x retrieving buffer from memory allocator"),
                hr));
		RPHSET(6);
        return E_OUTOFMEMORY;
    } /* if */

    pOutSample->SetPointer((unsigned char *) pWSABuffer[0].buf, pWSABuffer[0].len, pUserToken);
#endif

    DbgLog((LOG_TRACE,3,TEXT("CRPHBase::Submit got delivery buffer")));

    ASSERT(pOutSample);
    CRefTime tStart,tStop;

    if (m_dwLastRTCPNTPts != 0) {
        //Calculate NTP time for this image
        sampleNTPTime = (*((DWORD *)((pWSABuffer+1)->buf))/(m_dwPayloadClock/1000)) - 
            m_dwRTPTimestampOffset;
        //Convert to stream time in milliseconds
        DWORD tmpTime = sampleNTPTime - (m_dwStreamStartTime-m_dwClockStartTime);
        tStart = CRefTime((long)tmpTime);
        tStop = CRefTime((long)(tmpTime+1));
		RPHSET(7);
    } else {  //set it to now so that it renders immediately (queue notwithstanding)
        hr = StreamTime(tStart);
        hr = StreamTime(tStop);
		RPHSET(8);
    }
 
#if 1
    tStart = CRefTime((long)0);
    tStop = CRefTime((long)(1));
#endif
#if 0
    tStart = CRefTime((long)(tStop.Millisecs() +25));
    tStop = CRefTime((long)(tStart.Millisecs() +125));
#endif
#if 0
    tStop = CRefTime((long)(m_tStart.Millisecs() +1));
#endif
    CRefTime tStreamTime;
    hr = StreamTime(tStreamTime);

    if (FAILED(hr)){
        DbgLog((LOG_ERROR,1,TEXT("CRPHBase::Submit StreamTime returned error!")));
		RPHSET(9);
    }

    pOutSample->SetTime((REFERENCE_TIME*)&tStart, (REFERENCE_TIME*)&tStop);
//    pOutSample->SetTime((REFERENCE_TIME*)&m_tStart, (REFERENCE_TIME*)&tStop);

    DbgLog((LOG_TIMING,2,TEXT("CRPHBase::Submit pOutSample timestamps are start %ld stop %ld"),
        (DWORD)m_tStart.Millisecs(),
        (DWORD)tStop.Millisecs()));
    DbgLog((LOG_TIMING,2,TEXT("CRPHBase::Submit m_tStart is %ld, StreamTime is %ld"),
        (DWORD)m_tStart.Millisecs(),(DWORD)tStreamTime.Millisecs()));

#if 0
    //Set this if a frame has been dropped
    if (Error == PPM_E_DROPFRAME) {
        pOutSample->SetDiscontinuity(TRUE);
    } else {
        pOutSample->SetDiscontinuity(FALSE);
    }
#endif

#if 0  //I don't believe I need to do this
    if (pOutSample->IsPreroll())
        pOutSample->SetPreroll(FALSE);

    pOutSample->SetSyncPoint(FALSE);
#endif

    m_bSampleSkipped = FALSE;


    // Start timing the transform (if PERF is defined)
    MSR_START(m_idTransform);

    // have the derived class transform the data

    //We don't do this because the work is done in Submit and Receive
    //hr = Transform(pSample, pOutSample);

#ifdef COPYOPT_OFF
    //do copy to sample here
    BYTE *DataPtr = NULL;
    hr = pOutSample->GetPointer(&DataPtr);
    if (FAILED(hr)) {
        pOutSample->Release();
		RPHSET(10);
        return hr;
    }

    memcpy((void *)DataPtr, 
            (const void *)pWSABuffer[0].buf, 
            pWSABuffer[0].len);

    pOutSample->SetActualDataLength(pWSABuffer[0].len);
#endif

#if 0
    DWORD checksum = 0;
    for (int i = 0; i < pOutSample->GetActualDataLength(); i++) {
        checksum += (short) *((BYTE*)pWSABuffer[0].buf+i);
    }

    DbgLog((LOG_TRACE,3,TEXT("CRPHBase::Submit sending Data checksum %ld, length %d"), 
        checksum,pOutSample->GetActualDataLength()));
#endif

    // Stop the clock and log it (if PERF is defined)
    MSR_STOP(m_idTransform);


    {  //scope the lock
        CAutoLock cObjectLock(&m_TimeoutQueueLock);
        if (m_bPaused) {
            bPaused = TRUE;
            DbgLog((LOG_LOCKING,4,TEXT("CRPHBase::Submit We're Paused!")));
            FlushQueue();
			RPHSET(11);
        }
    }

    //  Check queue timeout and either queue or deliver
    if ((m_dwDejitterTime == 0) || (!m_pCBTimer) || bPaused) {
    
        DbgLog((LOG_TRACE,3,TEXT("CRPHBase::Submit delivering pOutSample, length %d"),
            pOutSample->GetActualDataLength()));

        hr = m_pOutput->Deliver(pOutSample);
        // release the output buffer. If the connected pin still needs it,
        // it will have addrefed it itself.
        
        DbgLog((LOG_TRACE,3,TEXT("CRPHBase::Submit releasing pOutSample")));

        pOutSample->Release();
		RPHSET(12);
    } else {

        if (m_dwLastRTCPNTPts != 0) {  //We use NTP to determine time to age this packet
			RPHSET(13);
            if (dwNetLatency == 0) {
                DWORD dwNow = timeGetTime();
                dwNetLatency = dwNow - sampleNTPTime;
            }
            //check and ensure that our target time has not passed
            DWORD dwTargetTime = sampleNTPTime + m_dwDejitterTime + dwNetLatency;
            //if the target time is within 100ms, we go ahead and send it
            if (dwTargetTime < (timeGetTime() + 100)) {
                //cancel the callback
                {
                    CAutoLock cObjectLock(&m_TimeoutQueueLock);
                    if (m_bCallbackRegistered) {
                        m_pCBTimer->CancelCallback(m_pdwCallbackID);
                        m_bCallbackRegistered = FALSE;
                    }
                }
				RPHSET(14);
                //empty the queue
                FlushQueue();
                //send the sample
                   hr = m_pOutput->Deliver(pOutSample);
                // release the output buffer. If the connected pin still needs it,
                // it will have addrefed it itself.
                pOutSample->Release();
            } else {
				RPHSET(15);
                //timeout = sampleNTPTime + dejitterTime + dwNetLatency
                CtimeoutSample *tSample = new CtimeoutSample(dwTargetTime, (void *)pOutSample);

                CAutoLock cObjectLock(&m_TimeoutQueueLock);
                DbgLog((LOG_LOCKING,4,TEXT("CRPHBase::Submit pushing sample %x, now is %ld, target time %ld"),tSample,timeGetTime(),dwTargetTime));
                if (m_bCallbackRegistered) {
                    DbgLog((LOG_LOCKING,4,TEXT("CRPHBase::Submit m_bCallbackRegistered is TRUE")));
					RPHSET(16);
                } else {
                    DbgLog((LOG_LOCKING,4,TEXT("CRPHBase::Submit m_bCallbackRegistered is FALSE")));
					RPHSET(17);
                }
                m_TimeoutQueue.push(tSample);

                //set timer callback
                if (!m_bCallbackRegistered) {
                    hr = m_pCBTimer->RequestCallback(dwTargetTime - timeGetTime(),
                        m_pdwCallbackToken, &m_pdwCallbackID);
					RPHSET(18);
                    if (FAILED(hr)) {
                        //cancel the callback
                        if (m_bCallbackRegistered) {
                            m_pCBTimer->CancelCallback(m_pdwCallbackID);
                            m_bCallbackRegistered = FALSE;
                        }
                        m_TimeoutQueueLock.Unlock();

                        //empty the queue
                        FlushQueue();

                        m_TimeoutQueueLock.Lock();

						RPHSET(19);
                    } else {
                        m_bCallbackRegistered = TRUE;
                    }
                }
            }
        } else {  //We use timeGetTime to determine time to age the packet
            DWORD dwTargetTime = (*((DWORD *)((pWSABuffer+1)->buf))/(m_dwPayloadClock/1000))
                + m_dwRTPTimestampOffset + m_dwDejitterTime;
            DbgLog((LOG_LOCKING,4,TEXT("CRPHBase::Submit now is %ld, target time: RTP_ts %ld / g711clock/1000 %ld + offset %ld + dejitter %ld = %ld"),
                timeGetTime(),*((DWORD *)((pWSABuffer+1)->buf)),
                (m_dwPayloadClock/1000),m_dwRTPTimestampOffset,m_dwDejitterTime,dwTargetTime));
			RPHSET(20);
            if (dwTargetTime < (timeGetTime() + 100)) {  //if within 100 ms, we process it
				RPHSET(21);
                //cancel the callback
                {
                    CAutoLock cObjectLock(&m_TimeoutQueueLock);
                    if (m_bCallbackRegistered) {
                        m_pCBTimer->CancelCallback(m_pdwCallbackID);
                        m_bCallbackRegistered = FALSE;
                    }
                }
                //empty the queue
                FlushQueue();
                //send the sample
                   hr = m_pOutput->Deliver(pOutSample);
                // release the output buffer. If the connected pin still needs it,
                // it will have addrefed it itself.
                pOutSample->Release();
            } else {
				RPHSET(22);
                CtimeoutSample *tSample = new CtimeoutSample(dwTargetTime, (void *)pOutSample);
                //put into queue
                CAutoLock cObjectLock(&m_TimeoutQueueLock);
                DbgLog((LOG_LOCKING,4,TEXT("CRPHBase::Submit 2 pushing sample %x length %d, now is %ld, target time %ld"),tSample,((IMediaSample*)tSample->ptr)->GetActualDataLength(),timeGetTime(),dwTargetTime));
                if (m_bCallbackRegistered) {
                    DbgLog((LOG_LOCKING,4,TEXT("CRPHBase::Submit m_bCallbackRegistered is TRUE")));
					RPHSET(23);
                } else {
                    DbgLog((LOG_LOCKING,4,TEXT("CRPHBase::Submit m_bCallbackRegistered is FALSE")));
					RPHSET(24);
                }
                m_TimeoutQueue.push(tSample);
                //set timer callback
                if (!m_bCallbackRegistered) {
                    hr = m_pCBTimer->RequestCallback(dwTargetTime - timeGetTime(),
                        m_pdwCallbackToken, &m_pdwCallbackID);
					RPHSET(25);
                    if (FAILED(hr)) {
						RPHSET(26);
                        //cancel the callback
                        if (m_bCallbackRegistered) {
                            m_pCBTimer->CancelCallback(m_pdwCallbackID);
                            m_bCallbackRegistered = FALSE;
                        }
                        m_TimeoutQueueLock.Unlock();
                        //empty the queue
                        FlushQueue();
                        m_TimeoutQueueLock.Lock();
                    } else {
						RPHSET(27);
                        m_bCallbackRegistered = TRUE;
                    }
                }
            }
        }
    }


#ifdef COPYOPT_OFF
    //Release PPM's packet buffer
    m_pPPMCB->SubmitComplete(pUserToken, hr);
#endif

	RPHSET(28);
    return hr;
}


//
// DecideBufferSize
//
// Tell the output pin's allocator what size buffers we
// require. Can only do this when the input is connected
//
HRESULT CRPHBase::DecideBufferSize(IMemAllocator *pAlloc,ALLOCATOR_PROPERTIES *pProperties)
{
    DbgLog((LOG_TRACE,4,TEXT("CRPHBase::DecideBufferSize")));

    // Is the input pin connected

    if (m_pInput->IsConnected() == FALSE) {
        return E_UNEXPECTED;
    }

    ASSERT(pAlloc);
    ASSERT(pProperties);
    HRESULT hr = NOERROR;

    //(1000/(frames/sec) divided by (1000msec/(dejitterqueuemsec + latency))
    if ((m_dwDejitterTime + m_dwGraphLatency) > 0) {
        DOUBLE dDj = m_dwDejitterTime;
        DOUBLE dGl = m_dwGraphLatency;
        DOUBLE dFps = m_dwFramesPerSecond;

        m_lBufferRequest += (LONG)((dDj + dGl)/dFps);

//        m_lBufferRequest = m_dwFramesPerSecond/(1000/(m_dwDejitterTime + m_dwGraphLatency));
    } 

    pProperties->cBuffers = m_lBufferRequest;

    //Set the size of the buffers to media size
    pProperties->cbBuffer = m_dwMaxMediaBufferSize;

    // Ask the allocator to reserve us some sample memory, NOTE the function
    // can succeed (that is return NOERROR) but still not have allocated the
    // memory that we requested, so we must check we got whatever we wanted

    ALLOCATOR_PROPERTIES Actual;
    hr = pAlloc->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
        return hr;
    }

    if (pProperties->cBuffers > Actual.cBuffers ||
            pProperties->cbBuffer > Actual.cbBuffer) {
                return E_FAIL;
    }
    return NOERROR;

} // DecideBufferSize


// override these two functions if you want to inform something
// about entry to or exit from streaming state.

// StartStreaming
// This function is where PPM initialization occurs
//
HRESULT
CRPHBase::StartStreaming()
{
    
    DbgLog((LOG_TRACE,4,TEXT("CRPHBase::StartStreaming")));

	CAutoLock StartStopLock(&g_cStartStopStream);

    ISubmitUser *pPPMSU = NULL;
    HRESULT hr;

    //Create and init PPM
    hr = CoCreateInstance(m_PPMCLSIDType, NULL, CLSCTX_INPROC_SERVER,
						  IID_IPPMReceive,(void**) &m_pPPMReceive);
	
    if (FAILED(hr))
		return E_FAIL;
	
    hr = m_pPPMReceive->QueryInterface(IID_ISubmit,(void**)&m_pPPM);

	if (FAILED(hr)) {
		m_pPPMReceive->Release();
		m_pPPMReceive = NULL;
		return E_FAIL;
	}

	hr = m_pPPMReceive->QueryInterface(IID_ISubmitUser,(void**)&pPPMSU);

	if (FAILED(hr)) {
        m_pPPMReceive->Release(); m_pPPMReceive = NULL;
        m_pPPM->Release(); m_pPPM = NULL;
        return E_FAIL;
    }

	hr = m_pPPMReceive->InitPPMReceive(m_dwMaxMediaBufferSize, NULL);

	if (FAILED(hr)) {
        m_pPPMReceive->Release(); m_pPPMReceive = NULL;
        m_pPPM->Release(); m_pPPM = NULL;
        pPPMSU->Release(); pPPMSU = NULL;
        return E_FAIL;
    }

    pPPMSU->SetOutput((ISubmit*)this);
    pPPMSU->Release(); pPPMSU = NULL;

    m_pPPM->InitSubmit((ISubmitCallback *)this);

    hr = m_pPPM->QueryInterface(IID_IPPMReceiveSession,(void**)&m_pPPMSession);
    if (FAILED(hr)) {
        m_pPPMSession = NULL;
    } else {
        SetPPMSession();
    }


    hr = m_pPPM->QueryInterface(IID_IPPMData,(void**)&m_pPPMData);
    if (FAILED(hr)) {
        m_pPPMData = NULL;
    }

    //Create and init the CB Timer
#if defined(_0_)
    This is commented out
    if (m_bAudio) {
        hr = CoCreateInstance(CLSID_CCBTimer, NULL, CLSCTX_INPROC_SERVER,
            IID_ICBTimer,(void**) &m_pCBTimer);
        if (FAILED(hr)) {
            m_pCBTimer = NULL;
        } else {
            hr = m_pCBTimer->RegisterObject((IUnknown*) ((ICBCallback*)(this)), (DWORD)(this));
            if (FAILED(hr)) {
                m_pCBTimer = NULL;
            }
        }
    }
#endif
    
    // Provide PPM with the Connection Point Sinks
    hr = GetPPMConnPt();
    if (FAILED(hr)) {
        // should we do something here if the Connection Points fail
        DbgLog((LOG_ERROR,1,TEXT("CRPHBase::StartStreaming - GetPPMConnPt() Failed!")));
    }

    m_SequenceQ.Flush();

    return NOERROR;
}

// SetPPMSession
// This function is where PPM::SetSession is called and may be specific to payload
//  handler.  Minimum function is to set the payload type.
HRESULT CRPHBase::SetPPMSession() 
{
    HRESULT hr;
    if (m_pPPMSession) {
        hr = m_pPPMSession->SetPayloadType((unsigned char)m_PayloadType);
        hr = m_pPPMSession->SetTimeoutDuration(m_dwLostPacketTime);
        return hr;
    } else {
        return E_FAIL;
    }
}


// StopStreaming
// This function is where PPM gets released
//
HRESULT
CRPHBase::StopStreaming()
{
    
    DbgLog((LOG_TRACE,4,TEXT("CRPHBase::StopStreaming")));

	CAutoLock StartStopLock(&g_cStartStopStream);
	
    //unregister the timer
    if (m_pCBTimer) {
        HRESULT hr = m_pCBTimer->UnRegisterObject();
    }

    // If make sure to reset the callback so that we work correctly!
#ifndef COPYOPT_OFF
    static_cast<CRPHOPin *>(m_pOutput)->m_CRMemAllocator->ResetCallback();
#endif

    //release and unload PPM
    if (m_pPPM) m_pPPM->Flush();
    if (m_pPPM) {m_pPPM->Release(); m_pPPM = NULL; }
    if (m_pPPMCB) {m_pPPMCB->Release(); m_pPPMCB = NULL; }
    if (m_pPPMReceive) {m_pPPMReceive->Release(); m_pPPMReceive = NULL; }
    if (m_pCBTimer) {m_pCBTimer->Release(); m_pCBTimer = NULL; }
    if (m_pPPMData) {m_pPPMData->Release(); m_pPPMData = NULL; }
    if (m_pPPMSession) {m_pPPMSession->Release(); m_pPPMSession = NULL; }
    if (m_dwPPMErrCookie) {m_pIPPMErrorCP->Unadvise(m_dwPPMErrCookie); m_dwPPMErrCookie = 0; }
    if (m_dwPPMNotCookie) {m_pIPPMNotificationCP->Unadvise(m_dwPPMNotCookie); m_dwPPMNotCookie = 0; }
    if (m_pIPPMErrorCP) {m_pIPPMErrorCP->Release(); m_pIPPMErrorCP = NULL; }
    if (m_pIPPMNotificationCP) {m_pIPPMNotificationCP->Release(); m_pIPPMNotificationCP = NULL; }

    return NOERROR;
}

// ISubmit methods for PPM

// InitSubmit
// This function is called from PPM to set up the callback pointer to PPM
//
HRESULT CRPHBase::InitSubmit(ISubmitCallback *pSubmitCallback)
{
    if (!pSubmitCallback) return E_POINTER;

    m_pPPMCB = pSubmitCallback;
    m_pPPMCB->AddRef();
#ifndef COPYOPT_OFF
    static_cast<CRPHOPin *>(m_pOutput)->m_CRMemAllocator->SetCallback(pSubmitCallback);
#endif

    return NOERROR;
}

void CRPHBase::ReportError(HRESULT Error){}
HRESULT CRPHBase::Flush(void){return NOERROR;}

// ISubmitCallback methods for PPM

// SubmitComplete
// This function is called from PPM to return to RPH the packet buffers
//
void CRPHBase::SubmitComplete(void *pUserToken, HRESULT Error)
{
    ((IMediaSample*) pUserToken)->Release();
    return;
}
    
void CRPHBase::ReportError(HRESULT Error, int Placeholder){}

// IRTPSPHFilter methods

// OverridePayloadType
// Overrides the payload type verified in the RTP packets
// Needs to be called before PPM initialization (StartStreaming) to be useful
//
HRESULT CRPHBase::OverridePayloadType(BYTE bPayloadType)
{
    CAutoLock l(&m_cStateLock);

    if ((bPayloadType < 0) || (bPayloadType > 127))
        return E_INVALIDARG;

    SetDirty(TRUE); // So that our state will be saved if we are in a .grf    

    m_PayloadType = (int) bPayloadType;
    m_bPTSet = TRUE;

    return NOERROR;
}

// GetPayloadType
// Gets the payload type verified in the RTP packets
// Only useful if called after pin connection; that is when
//  the type is set 
//
HRESULT CRPHBase::GetPayloadType(BYTE __RPC_FAR *lpbPayloadType)
{
    if (!lpbPayloadType) return E_POINTER;

    *lpbPayloadType = (unsigned char)m_PayloadType;
    return NOERROR;
}

// SetMediaBufferSize
// Sets the maximum buffer size for reassembly
// Needs to be called before PPM initialization (StartStreaming) to be useful
//
HRESULT CRPHBase::SetMediaBufferSize(DWORD dwMaxMediaBufferSize)
{
    CAutoLock l(&m_cStateLock);

    // ZCS bugfix 6-12-97
    if (m_State != State_Stopped)
    {
        return VFW_E_NOT_STOPPED;
    }

    if (m_pOutput && m_pOutput->IsConnected())
    {
        return VFW_E_ALREADY_CONNECTED;
    }
    
    SetDirty(TRUE); // So that our state will be saved if we are in a .grf    

    m_dwMaxMediaBufferSize = dwMaxMediaBufferSize;
    return NOERROR;
}

// GetMediaBufferSize
// Gets the maximum buffer size for reassembly
//
HRESULT CRPHBase::GetMediaBufferSize(LPDWORD lpdwMaxMediaBufferSize)
{
    CAutoLock l(&m_cStateLock);
    if (!lpdwMaxMediaBufferSize) return E_POINTER;

    *lpdwMaxMediaBufferSize = m_dwMaxMediaBufferSize;
    return NOERROR;
}

// SetOutputPinMediaType
// Sets the type of the output pin
// Needs to be called before CheckTransform and the last CheckInputType to be useful
// We don't expect to get called for this in other than the generic filters
//
HRESULT CRPHBase::SetOutputPinMediaType(AM_MEDIA_TYPE *MediaPinType)
{
    return E_UNEXPECTED;
}

// GetOutputPinMediaType
// Gets the type of the output pin.  Pointer must point to valid memory area to
// store the values into.
// We don't expect to get called for this in other than the generic filters
//lsc - or do we?
//
HRESULT CRPHBase::GetOutputPinMediaType(AM_MEDIA_TYPE **ppMediaPinType)
{
    return E_UNEXPECTED;
}

// SetTimeoutDuration
// Sets the duration of time used to queue video frames and the
//  time used to wait for lost packets before reassembling a frame
//
HRESULT CRPHBase::SetTimeoutDuration(DWORD dwDejitterTime, DWORD dwLostPacketTime)
{
    CAutoLock l(&m_cStateLock);

    if ((dwDejitterTime == 0) || ((dwDejitterTime >= dwLostPacketTime) && (dwDejitterTime >= 100))){
        SetDirty(TRUE); // So that our state will be saved if we are in a .grf    
        m_dwDejitterTime = dwDejitterTime;
        m_dwLostPacketTime = dwLostPacketTime;

    } else {
        return E_INVALIDARG;
    }
    return NOERROR;
}
        
// GetTimeoutDuration
// Gets the duration of time used to queue video frames
//  and the time used to wait for lost packets before reassembling a frame
//
HRESULT CRPHBase::GetTimeoutDuration(LPDWORD lpdwDejitterTime, LPDWORD lpdwLostPacketTime)
{
    if ((!lpdwDejitterTime) || (!lpdwLostPacketTime)) return E_POINTER;

    *lpdwDejitterTime = m_dwDejitterTime;
    *lpdwLostPacketTime = m_dwLostPacketTime;
    
    return NOERROR;
}

#ifdef LIMITQUEUE
// SetQueueLimit
// Sets the limit on the number of samples that can be queued at one time
//
HRESULT CRPHBase::SetQueueLimit(DWORD dwSampleLimit)
{
    CAutoLock l(&m_cStateLock);

    SetDirty(TRUE); // So that our state will be saved if we are in a .grf
    
    m_dwSampleLimit = dwSampleLimit;

    return NOERROR;
}

// GetQueueLimit
// Gets the limit on the number of samples that can be queued at one time
//
HRESULT CRPHBase::GetQueueLimit(LPDWORD lpdwSampleLimit)
{
    if (!lpdwSampleLimit) return E_POINTER;

    *lpdwSampleLimit = m_dwSampleLimit;

    return NOERROR;
}
#endif /* LIMITQUEUE */


// GetTSNormalizer
// Gets the offset which can be used to normalize RTP packet timestamps
//   to real time
//
HRESULT CRPHBase::GetTSNormalizer(DWORD dwNTPts, DWORD dwRTPts, DWORD *dwOffset, DWORD dwclock)
{

    DbgLog((LOG_TRACE,4,TEXT("CRPHBase::GetTSNormalizer")));


    DWORD    dwRtpInMsec;
    DWORD    dwNtpInMsec;
    
    // NTP might not be send, not required by the RFC
    if (dwNTPts == 0)
        {
        *dwOffset = 0;
        return NOERROR;
        }

    // if we don't know the stream clock, we cannot accurately
    //   get the constant between NTP and RTP
    if (dwclock == 0)
        {
        *dwOffset = 0;
        return NOERROR;
        }

    // convert RTP timestamp from sampling unit to msec
    dwRtpInMsec = dwRTPts / (dwclock / 1000);

    // convert NTP format into msec
    dwNtpInMsec = dwNTPts & 0xFFFF0000;        // number of seconds
    dwNtpInMsec >>= 16;
    dwNtpInMsec *= 1000;                    // msec

    // get the fractional part 
    if (dwNTPts & 0x00008000)
        dwNtpInMsec += 500;
    if (dwNTPts & 0x00004000)
        dwNtpInMsec += 250;
    if (dwNTPts & 0x00002000)
        dwNtpInMsec += 125;
    if (dwNTPts & 0x00001000)
        dwNtpInMsec += 62;
    if (dwNTPts & 0x00000800)
        dwNtpInMsec += 31;
    if (dwNTPts & 0x00000400)
        dwNtpInMsec += 15;
    if (dwNTPts & 0x00000200)
        dwNtpInMsec += 7;
    if (dwNTPts & 0x00000100)
        dwNtpInMsec += 3;
    if (dwNTPts & 0x00000080)                // other bits meaningless
        dwNtpInMsec += 1;

    // get offset between NTP and RTP timestamp (as unsigned)
    *dwOffset = dwRtpInMsec - dwNtpInMsec;

    // pass offset through low-pass filter
    // x = (1 - a)*x + a*b
    // b is the latest value, 0 <= a <= 1, the gain. Gain toward 1 
    //  increases the weight of the latest value, gain toward 0 
    //  increases the weight of the average, x is the smoothed value

    //  make x a member variable of the class so we keep previous state

    return NOERROR;

}

#if 1
// Pause
// 
//
HRESULT CRPHBase::Pause()
{
    DbgLog((LOG_TRACE,4,TEXT("CRPHBase::Pause")));
    //going from running to paused means that we want to flush our queue
    //and cancel our timer callback
    if (m_State == State_Running) {
        DbgLog((LOG_LOCKING,4,TEXT("CRPHBase::Pause State_Running")));
        CAutoLock cObjectLock(&m_TimeoutQueueLock);
        m_bPaused = TRUE;
        //First, cancel any timer callbacks and flush our queue 
        if (m_bCallbackRegistered) {
            m_pCBTimer->CancelCallback(m_pdwCallbackID);
            m_bCallbackRegistered = FALSE;
        }
        m_TimeoutQueueLock.Unlock();
        //empty the queue
//        FlushQueue();
        m_TimeoutQueueLock.Lock();
    } else {
        DbgLog((LOG_LOCKING,2,TEXT("CRPHBase::Pause NOT State_Running")));
        CAutoLock cObjectLock(&m_TimeoutQueueLock);
        m_bPaused = FALSE;
    }

    return CTransformFilter::Pause();
}
#endif

// Callback
// This is the callback method that will be called after we've registered 
//   with the timer object. We process the timeout queue here
//
HRESULT CRPHBase::Callback(DWORD *pdwObjectContext, DWORD *pdwCallbackContext)
{
    
    DbgLog((LOG_TRACE,4,TEXT("CRPHBase::Callback")));

    HRESULT hr;
    CAutoLock cObjectLock(&m_TimeoutQueueLock);

    CtimeoutSample *tSample;
    DWORD dwTimeNow;
    BOOL bDone = FALSE;
    
        DbgLog((LOG_LOCKING,4,TEXT("CRPHBase::Callback processing queue size %d, now is %ld"),m_TimeoutQueue.size(),timeGetTime()));

        while (!m_TimeoutQueue.empty() && !bDone) {

        tSample = m_TimeoutQueue.front();

        dwTimeNow = timeGetTime();

        //if the target time is within a 100ms, we need to process it
        //also, if the timer is gone, we need to process, or if the
        //queue has all of the delivery buffers we need to send at least one,
        //which means we may send one early, but that's better than
        //deadlocking upon pause
        if ((tSample->timeout <= dwTimeNow + 100) 
            || (m_TimeoutQueue.size() == (DWORD)m_lBufferRequest)
            || (!m_pCBTimer)) {  // it's time to send this packet on

            DbgLog((LOG_LOCKING,4,TEXT("CRPHBase::Callback popping sample %x ptr %x, target time %ld"),tSample,tSample->ptr,tSample->timeout));
    
            // remove the sample from the queue
            m_TimeoutQueue.pop();
            m_bCallbackRegistered = FALSE;

            m_TimeoutQueueLock.Unlock();

            hr = m_pOutput->Deliver((IMediaSample*)tSample->ptr);
            // release the output buffer. If the connected pin still needs it,
            // it will have addrefed it itself.
            ((IMediaSample*)tSample->ptr)->Release();

            m_TimeoutQueueLock.Lock();

            delete tSample;
        } else {  // we want to reregister with the callback timer
            m_pCBTimer->RequestCallback(tSample->timeout - dwTimeNow, 
                            m_pdwCallbackToken, &m_pdwCallbackID);
            m_bCallbackRegistered = TRUE;
            bDone = TRUE;
            DbgLog((LOG_LOCKING,4,TEXT("CRPHBase::Callback leaving sample %x ptr %x target time %ld in front of queue"),tSample,tSample->ptr,tSample->timeout));
        }
    }

    if ((!bDone) && (m_dwLostPacketTime > 0) && m_bAudio && m_pPPMData) {  
        //then we emptied the queue and probably need to flush PPM
        DWORD *lpdwDataArray = NULL;
        DWORD dwDataCount = 0;

        m_pPPMData->ReportOutstandingData(&lpdwDataArray, &dwDataCount);
        if (dwDataCount > 0) {
            m_pPPMData->ReleaseOutstandingDataBuffer(lpdwDataArray);
            m_pPPMData->FlushData();
        } else {
            m_pPPMData->ReleaseOutstandingDataBuffer(lpdwDataArray);
        }
    }

    return NOERROR;
}

// FlushQueue
// Empty our queue and send all samples. 
//
HRESULT CRPHBase::FlushQueue()
{
    
    DbgLog((LOG_TRACE,4,TEXT("CRPHBase::FlushQueue")));

    HRESULT hr;
    CAutoLock cObjectLock(&m_TimeoutQueueLock);

    CtimeoutSample *tSample;

    int size = m_TimeoutQueue.size();
    
    DbgLog((LOG_LOCKING,4,TEXT("CRPHBase::FlushQueue processing queue size %d"),size));

    while (!m_TimeoutQueue.empty()) {

        tSample = m_TimeoutQueue.front();

        // remove the sample from the queue
        DbgLog((LOG_LOCKING,4,TEXT("CRPHBase::FlushQueue popping sample %x"),tSample));
        m_TimeoutQueue.pop();

        m_TimeoutQueueLock.Unlock();

        DbgLog((LOG_LOCKING,4,TEXT("CRPHBase::FlushQueue sending sample %x ptr %x"),tSample,tSample->ptr));

        hr = m_pOutput->Deliver((IMediaSample*)tSample->ptr);
        // release the output buffer. If the connected pin still needs it,
        // it will have addrefed it itself.
        ((IMediaSample*)tSample->ptr)->Release();

        m_TimeoutQueueLock.Lock();

        delete tSample;
    }

    return NOERROR;
}

//
// PPMError Connection point interface implementation
//
HRESULT CRPHBase::PPMError( HRESULT hError,
                           DWORD dwSeverity,
                           DWORD dwCookie,
                           unsigned char pData[],
                           unsigned int iDatalen)
{
    
    DbgLog((LOG_TRACE,4,TEXT("CRPHBase::PPMError")));

    return NOERROR;
}

//
// PPMNotification Connection point interface implementation
//
HRESULT CRPHBase::PPMNotification(THIS_ HRESULT hStatus,
                                  DWORD dwSeverity,
                                  DWORD dwCookie,
                                  unsigned char pData[],
                                  unsigned int iDatalen)
{
    
    DbgLog((LOG_TRACE,4,TEXT("CRPHBase::PPMNotification")));
#if 0
    DbgLog((LOG_TRACE,4,LogPPMNotification(hStatus)));
#endif

    return NOERROR;
}

//
// Provide sinks for the IPPMError and IPPMNotification connection points
//
HRESULT CRPHBase::GetPPMConnPt( )
{
    
    DbgLog((LOG_TRACE,4,TEXT("CRPHBase::GetPPMConnPt")));
    HRESULT hErr;

    IConnectionPointContainer *pIConnectionPointContainer;
    hErr = m_pPPMReceive->QueryInterface(IID_IConnectionPointContainer, 
                                        (PVOID *) &pIConnectionPointContainer);
    if (FAILED(hErr)) {
        DbgLog((LOG_ERROR,1,TEXT("CRPHBase::GetPPMConnPt Failed to get connection point from ppm!")));
        return hErr;
    } /* if */

    hErr = pIConnectionPointContainer->FindConnectionPoint(IID_IPPMError, &m_pIPPMErrorCP);
    if (FAILED(hErr)) {
        DbgLog((LOG_ERROR,1,TEXT("CRPHBase::GetPPMConnPt Failed to get IPPMError connection point!")));
        pIConnectionPointContainer->Release();
        return hErr;
    } /* if */
    hErr = pIConnectionPointContainer->FindConnectionPoint(IID_IPPMNotification, &m_pIPPMNotificationCP);
    if (FAILED(hErr)) {
        DbgLog((LOG_ERROR,1,TEXT("CRPHBase::GetPPMConnpt Failed to get IPPMNotification connection point!")));
        pIConnectionPointContainer->Release();
        return hErr;
    } /* if */
    hErr = m_pIPPMErrorCP->Advise((IPPMError *) this, &m_dwPPMErrCookie);
    if (FAILED(hErr)) {
        DbgLog((LOG_ERROR,1,TEXT("CRPHBase::GetPPMConnpt Failed to advise IPPMError connection point!")));
        pIConnectionPointContainer->Release();
        return hErr;
    } /* if */
    hErr = m_pIPPMNotificationCP->Advise((IPPMNotification *) this, &m_dwPPMNotCookie);
    if (FAILED(hErr)) {
        DbgLog((LOG_ERROR,1,TEXT("CRPHBase::GetPPMConnpt Failed to advise IPPMNotification connection point!")));
        pIConnectionPointContainer->Release();
        return hErr;
    } /* if */

    pIConnectionPointContainer->Release();

    return NOERROR;
}

// CPersistStream methods

// ReadFromStream
// This is the call that will read persistent data from file
//
HRESULT CRPHBase::ReadFromStream(IStream *pStream) 
{
    DbgLog((LOG_TRACE, 4, TEXT("CRPHBase::ReadFromStream")));
    HRESULT hr;

    int iPayloadType;
    DWORD dwMaxMediaBufferSize;
    DWORD dwDejitterTime;
    DWORD dwLostPacketTime;
    ULONG uBytesRead;

    DbgLog((LOG_TRACE, 4, 
            TEXT("CRPHBase::ReadFromStream: Loading payload type")));
    hr = pStream->Read(&iPayloadType, sizeof(iPayloadType), &uBytesRead);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRPHBase::ReadFromStream: Error 0x%08x reading payload type"),
                hr));
        return hr;
    } else if (uBytesRead != sizeof(iPayloadType)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRPHBase::ReadFromStream: Mismatch in (%d/%d) bytes read for payload type"),
                uBytesRead, sizeof(iPayloadType)));
        return E_INVALIDARG;
    }
    if (iPayloadType != -1) {
        DbgLog((LOG_TRACE, 4, 
                TEXT("CRPHBase::ReadFromStream: Restoring payload type")));
        hr = OverridePayloadType((unsigned char)iPayloadType);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 2, 
                    TEXT("CRPHBase::ReadFromStream: Error 0x%08x restoring payload type"),
                    hr));
        }
    }

    DbgLog((LOG_TRACE, 4, 
            TEXT("CRPHBase::ReadFromStream: Loading maximum media buffer size")));
    hr = pStream->Read(&dwMaxMediaBufferSize, sizeof(dwMaxMediaBufferSize), &uBytesRead);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRPHBase::ReadFromStream: Error 0x%08x reading maximum media buffer size"),
                hr));
        return hr;
    } else if (uBytesRead != sizeof(dwMaxMediaBufferSize)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRPHBase::ReadFromStream: Mismatch in (%d/%d) bytes read for maximum media buffer size"),
                uBytesRead, sizeof(dwMaxMediaBufferSize)));
        return E_INVALIDARG;
    }
    DbgLog((LOG_TRACE, 4, 
            TEXT("CRPHBase::ReadFromStream: Restoring maximum media buffer size")));
    hr = SetMediaBufferSize(dwMaxMediaBufferSize);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRPHBase::ReadFromStream: Error 0x%08x restoring maximum media buffer size"),
                hr));
    }

    DbgLog((LOG_TRACE, 4, 
            TEXT("CRPHBase::ReadFromStream: Loading dejitter timeout duration")));
    hr = pStream->Read(&dwDejitterTime, sizeof(dwDejitterTime), &uBytesRead);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRPHBase::ReadFromStream: Error 0x%08x reading dejitter timeout duration"),
                hr));
        return hr;
    } else if (uBytesRead != sizeof(dwDejitterTime)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRPHBase::ReadFromStream: Mismatch in (%d/%d) bytes read for dejitter timeout duration"),
                uBytesRead, sizeof(dwDejitterTime)));
        return E_INVALIDARG;
    }

    DbgLog((LOG_TRACE, 4, 
            TEXT("CRPHBase::ReadFromStream: Loading lost packet timeout duration")));
    hr = pStream->Read(&dwLostPacketTime, sizeof(dwLostPacketTime), &uBytesRead);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRPHBase::ReadFromStream: Error 0x%08x reading lost packet timeout duration"),
                hr));
        return hr;
    } else if (uBytesRead != sizeof(dwLostPacketTime)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRPHBase::ReadFromStream: Mismatch in (%d/%d) bytes read for lost packet timeout duration"),
                uBytesRead, sizeof(dwLostPacketTime)));
        return E_INVALIDARG;
    }

    DbgLog((LOG_TRACE, 4, 
            TEXT("CRPHBase::ReadFromStream: Restoring dejitter and lost packet timeout duration")));
    hr = SetTimeoutDuration(dwDejitterTime, dwLostPacketTime);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRPHBase::ReadFromStream: Error 0x%08x restoring dejitter and lost packet timeout duration"),
                hr));
    }

    return NOERROR; 
}

// WriteToStream
// This is the call that will write persistent data to file
//
HRESULT CRPHBase::WriteToStream(IStream *pStream) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("CRPHBase::WriteToStream")));
    HRESULT hr;
    ULONG uBytesWritten = 0;

    DbgLog((LOG_TRACE, 4, 
            TEXT("CRPHBase::WriteToStream: Writing payload type")));
    hr = pStream->Write(&m_PayloadType, sizeof(m_PayloadType), &uBytesWritten);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRPHBase::WriteToStream: Error 0x%08x writing payload type"),
                hr));
        return hr;
    } else if (uBytesWritten != sizeof(m_PayloadType)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRPHBase::WriteToStream: Mismatch in (%d/%d) bytes written for payload type"),
                uBytesWritten, sizeof(m_PayloadType)));
        return E_INVALIDARG;
    } 

    DbgLog((LOG_TRACE, 4, 
            TEXT("CRPHBase::WriteToStream: Writing maximum media buffer size")));
    hr = pStream->Write(&m_dwMaxMediaBufferSize, sizeof(m_dwMaxMediaBufferSize), &uBytesWritten);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRPHBase::WriteToStream: Error 0x%08x writing maximum media buffer size"),
                hr));
        return hr;
    } else if (uBytesWritten != sizeof(m_dwMaxMediaBufferSize)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRPHBase::WriteToStream: Mismatch in (%d/%d) bytes written for maximum media buffer size"),
                uBytesWritten, sizeof(m_dwMaxMediaBufferSize)));
        return E_INVALIDARG;
    }

    DbgLog((LOG_TRACE, 4, 
            TEXT("CRPHBase::WriteToStream: Writing dejitter timeout duration")));
    hr = pStream->Write(&m_dwDejitterTime, sizeof(m_dwDejitterTime), &uBytesWritten);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRPHBase::WriteToStream: Error 0x%08x writing dejitter timeout duration"),
                hr));
        return hr;
    } else if (uBytesWritten != sizeof(m_dwDejitterTime)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRPHBase::WriteToStream: Mismatch in (%d/%d) bytes written for dejitter timeout duration"),
                uBytesWritten, sizeof(m_dwDejitterTime)));
        return E_INVALIDARG;
    } 

    DbgLog((LOG_TRACE, 4, 
            TEXT("CRPHBase::WriteToStream: Writing lost packet timeout duration")));
    hr = pStream->Write(&m_dwLostPacketTime, sizeof(m_dwLostPacketTime), &uBytesWritten);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRPHBase::WriteToStream: Error 0x%08x writing lost packet timeout duration"),
                hr));
        return hr;
    } else if (uBytesWritten != sizeof(m_dwLostPacketTime)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRPHBase::WriteToStream: Mismatch in (%d/%d) bytes written for lost packet timeout duration"),
                uBytesWritten, sizeof(m_dwLostPacketTime)));
        return E_INVALIDARG;
    } 

    return NOERROR; 
}

// SizeMax
// This returns the amount of storage space required for my persistent data
//
int CRPHBase::SizeMax(void) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("CRPHBase::SizeMax")));

    return sizeof(m_PayloadType)
         + sizeof(m_dwMaxMediaBufferSize)
         + sizeof(m_dwDejitterTime)
         + sizeof(m_dwLostPacketTime);
}

//  Name    : CRPHBase::GetPages()
//  Purpose : Return the CLSID of the property page we support.
//  Context : Called when the FGM wants to show our property page.
//  Returns : 
//      E_OUTOFMEMORY   Unable to allocate structure to return property pages in.
//      NOERROR         Successfully returned property pages.
//  Params  :
//      pcauuid Pointer to a structure used to return property pages.
//  Notes   : None.

HRESULT 
CRPHBase::GetPages(
    CAUUID *pcauuid) 
{
    UINT i = 0;

    DbgLog((LOG_TRACE, 3, TEXT("CRPHBase::GetPages called")));

    pcauuid->cElems = m_cPropertyPageClsids;

    pcauuid->pElems = (GUID *) CoTaskMemAlloc(m_cPropertyPageClsids * sizeof(GUID));
    if (pcauuid->pElems == NULL) {
        return E_OUTOFMEMORY;
    }

    for( i = 0; i < m_cPropertyPageClsids; i++)
    {
        pcauuid->pElems[i] = *m_pPropertyPageClsids[ i ];
    }

//        *(pcauuid->pElems) = *pPropertyPageClsids[ i ];

    return NOERROR;
} /* CRPHBase::GetPages() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\common\rphopin.h ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : rphopin.h
// Purpose  : Define the class that implements/overrides the RTP RPH output pins.
// Contents : 
//*M*/


#ifndef _RPHOPIN_H_
#define _RPHOPIN_H_

#include <rph.h>
#include <rmemry.h>

class CRPHOPin : public CTransformOutputPin
{ 
	friend CRPHBase;

public:
    CRPHOPin(
        TCHAR *pObjectName,
        CTransformFilter *pTransformFilter,
        HRESULT * phr,
        LPCWSTR pName);


	//overriden from base class so that we can provide custom allocator
	virtual HRESULT DecideAllocator(IMemInputPin * pPin, IMemAllocator ** pAlloc);

protected:
	CRMemAllocator *m_CRMemAllocator;

}; //CRPHOPin

#endif _RPHOPIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\common\rphopin.cpp ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : rphopin.cpp
// Purpose  : RTP RPH output pin implementation.
// Contents : 
//*M*/

#include <winsock2.h>
#include <streams.h>
#include <list.h>
#include <stack.h>
#include <ippm.h>
#include <rph.h>
#include <rphopin.h>

CRPHOPin::CRPHOPin(
        TCHAR *pObjectName,
        CTransformFilter *pTransformFilter,
        HRESULT * phr,
        LPCWSTR pName) : CTransformOutputPin(pObjectName,
						   pTransformFilter,
						   phr,
						   pName
						   )
{
}


//We are overriding DecideAllocator to provide a custom allocator

/* Decide on an allocator, override this if you want to use your own allocator
   Override DecideBufferSize to call SetProperties. If the input pin fails
   the GetAllocator call then this will construct a CMemAllocator and call
   DecideBufferSize on that, and if that fails then we are completely hosed.
   If the you succeed the DecideBufferSize call, we will notify the input
   pin of the selected allocator. NOTE this is called during Connect() which
   therefore looks after grabbing and locking the object's critical section */

// We query the input pin for its requested properties and pass this to
// DecideBufferSize to allow it to fulfill requests that it is happy
// with (eg most people don't care about alignment and are thus happy to
// use the downstream pin's alignment request).

HRESULT
CRPHOPin::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc)
{
    HRESULT hr = NOERROR;
    *ppAlloc = NULL;

    // get downstream prop request
    // the derived class may modify this in DecideBufferSize, but
    // we assume that he will consistently modify it the same way,
    // so we only get it once
    ALLOCATOR_PROPERTIES prop;
    ZeroMemory(&prop, sizeof(prop));

    // whatever he returns, we assume prop is either all zeros
    // or he has filled it out.
    pPin->GetAllocatorRequirements(&prop);

    // We currently only guarantee an alignment of 1, as we
    // are stuck with whatever the PPM gives us. If we can force
    // the PPM to align better, we will.
    prop.cbAlign = 1;

    if (m_pAllocator == static_cast<CRMemAllocator *>(NULL)) {
        // Only create a new allocator if we don't already have one.
        m_CRMemAllocator = new CRMemAllocator(NAME("RPH memory allocator"),
						                           NULL, &hr);
        m_pAllocator = m_CRMemAllocator;
        if (m_pAllocator ==static_cast<CRMemAllocator *>(NULL)) {
            DbgLog((LOG_ERROR, 2, 
                    TEXT("CRPHOPin::DecideAllocator failed to allocate new allocator!")));
            return E_OUTOFMEMORY;
        } /* if */
        // We keep a pointer to the CRMemAllocator internally to access the object's
        // special methods for RPH.
        hr = m_pAllocator->QueryInterface(IID_IMemAllocator,
                                              (PVOID *) ppAlloc);
    } else {
        // This is the second (or later) QI to this object.
        // We don't want to have reference leaks, so this QI
        // is balanced with a release.
        hr = m_pAllocator->QueryInterface(IID_IMemAllocator,
                                              (PVOID *) ppAlloc);
    } /* if */

    // Get an IMemAllocator interface for our own allocator
    // and propose it as the system allocator.
    if (SUCCEEDED(hr)) {
        // note - the properties passed here are in the same
        // structure as above and may have been modified by
        // the previous call to DecideBufferSize
        DbgLog((LOG_TRACE, 4, 
                TEXT("CRPHOPin::DecideAllocator queried for interface, calling DecideBufferSize")));
	    hr = DecideBufferSize(*ppAlloc, &prop);
	    if (SUCCEEDED(hr)) {
            DbgLog((LOG_TRACE, 4, 
                    TEXT("CRPHOPin::DecideAllocator decided buffersize, calling NotifyAllocator")));
	        hr = pPin->NotifyAllocator(*ppAlloc, FALSE);
	        if (SUCCEEDED(hr)) {
                DbgLog((LOG_TRACE, 4, 
                        TEXT("CRPHOPin::DecideAllocator notified allocator, returning success")));
		        return NOERROR;
	        } /* if */
	    } /* if */
    } /* if */

    DbgLog((LOG_ERROR, 2, 
            TEXT("CRPHOPin::DecideAllocator failed to get new allocator interface")));
    /* Likewise we may not have an interface to release */
    if (*ppAlloc) {
	    (*ppAlloc)->Release();
	    *ppAlloc = static_cast<IMemAllocator *>(NULL);
    } else {
        // The memory allocator failed the QI, but is still hanging around.
        m_pAllocator->AddRef();
        m_pAllocator->Release(); // This should cause it to go away.
    } /* if */
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\common\rphipin.h ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : rphipin.h
// Purpose  : Define the class that implements/overrides the RTP RPH input pins.
// Contents : 
//*M*/


#ifndef _RPHIPIN_H_
#define _RPHIPIN_H_

#include <rph.h>

class CRPHIPin : public CTransformInputPin
{ 
public:
    CRPHIPin(
        TCHAR *pObjectName,
        CTransformFilter *pTransformFilter,
        HRESULT * phr,
        LPCWSTR pName);

	STDMETHOD (GetAllocatorRequirements)(ALLOCATOR_PROPERTIES*pProps);
	HRESULT GetMediaType (int iPosition, CMediaType *pMediaType);
    

}; //CRPHIPin

#endif _RPHIPIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\common\rphprop.cpp ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : RPHPROP.cpp
// Purpose  : RTP RPH Generic Property Page.
// Contents : 
//*M*/

#include <winsock2.h>
#include <streams.h>
#include <list.h>
#include <stack.h>
#include <ippm.h>
#include <amrtpuid.h>
#include <rph.h>
#include <ppmclsid.h>
#include <memory.h>
#include <rphres.h>
#include <rphprop.h>

#define IDC_PAYLOADTYPE     (IDC_RPH_PAYLOADTYPE_IDX     + m_dwIDD_Base)
#define IDC_BUFFERSIZE      (IDC_RPH_BUFFERSIZE_IDX      + m_dwIDD_Base)
#define IDC_DEJITTER_TIME   (IDC_RPH_DEJITTER_TIME_IDX   + m_dwIDD_Base)
#define IDC_LOSTPACKET_TIME (IDC_RPH_LOSTPACKET_TIME_IDX + m_dwIDD_Base)

CUnknown * WINAPI 
CRPHGENPropPage::CreateInstance_aud(LPUNKNOWN punk, HRESULT *phr )
{
	return (CreateInstance2(punk, phr, IDS_RPHAUD_BASE));
}

CUnknown * WINAPI 
CRPHGENPropPage::CreateInstance_gena(LPUNKNOWN punk, HRESULT *phr )
{
	return (CreateInstance2(punk, phr, IDS_RPHGENA_BASE));
}

CUnknown * WINAPI 
CRPHGENPropPage::CreateInstance_genv(LPUNKNOWN punk, HRESULT *phr )
{
	return (CreateInstance2(punk, phr, IDS_RPHGENV_BASE));
}

CUnknown * WINAPI 
CRPHGENPropPage::CreateInstance_h26x(LPUNKNOWN punk, HRESULT *phr )
{
	return (CreateInstance2(punk, phr, IDS_RPHH26X_BASE));
}

#if defined(_0_)
CUnknown * WINAPI 
CRPHGENPropPage::CreateInstance( 
    LPUNKNOWN punk, 
    HRESULT *phr )
{
	return (CreateInstance2(punk, phr, IDS_RPHAUD_BASE));
}
#endif
CUnknown * WINAPI 
CRPHGENPropPage::CreateInstance2(
    LPUNKNOWN punk, 
    HRESULT *phr,
	DWORD IDD_Base)
{
    CRPHGENPropPage *pNewObject
        = new CRPHGENPropPage( punk, phr, IDD_Base);

    if( pNewObject == NULL )
        *phr = E_OUTOFMEMORY;

    return pNewObject;
} /* CRPHGENPropPage::CreateInstance() */


CRPHGENPropPage::CRPHGENPropPage( 
    LPUNKNOWN pUnk,
    HRESULT *phr,
	DWORD IDD_Base)
    : CBasePropertyPage(NAME("Intel Common RPH Controls"),pUnk,
        IDD_Base+IDD_RPHGEN_PROPPAGE_IDX, IDD_Base+IDS_RPHGEN_IDX)
    , m_pIRTPRPHFilter (NULL)
    , m_bIsInitialized(FALSE)
	, m_bPayloadScanned(FALSE)
	, m_bBufSizeScanned(FALSE)
	, m_bDejitterScanned(FALSE)
	, m_bLostPktScanned(FALSE)
	, m_dwIDD_Base(IDD_Base)
{
    DbgLog((LOG_TRACE, 3, TEXT("CRPHGENPropPage::CRPHGENPropPage: Constructed at 0x%08x"), this));
} /* CRPHGENPropPage::CRPHGENPropPage() */

void 
CRPHGENPropPage::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
    {
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
    }
} /* CRPHGENPropPage::SetDirty() */

INT_PTR 
CRPHGENPropPage::OnReceiveMessage(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    DbgLog((LOG_TRACE, 4, TEXT("CRPHGENPropPage::OnReceiveMessage: Entered")));
    switch (uMsg) {
    case WM_INITDIALOG:
		return OnInitDialog();
		break;

    case WM_COMMAND:
        if (m_bIsInitialized) {
            if (OnCommand( (int) LOWORD( wParam ), (int) HIWORD( wParam ), lParam ) == TRUE) {
                return (LRESULT) 1;
            } /* if */
        } else {
			return(LRESULT) 1;
//            return CRPHGENPropPage::OnInitDialog();
        } /* if */
        break;
    } /* switch */

    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
} /* CRPHGENPropPage::OnReceiveMessage() */


HRESULT 
CRPHGENPropPage::OnConnect(
    IUnknown    *pUnknown)
{
    DbgLog((LOG_TRACE, 4, TEXT("CRPHGENPropPage::OnConnect: Entered")));
    ASSERT(m_pIRTPRPHFilter == NULL);
    DbgLog((LOG_TRACE, 2, TEXT("CRPHGENPropPage::OnConnect: Called with IUnknown 0x%08x"), pUnknown));

	HRESULT hr = pUnknown->QueryInterface(IID_IRTPRPHFilter, (void **) &m_pIRTPRPHFilter);
	if(FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, TEXT("CRPHGENPropPage::OnConnect: Error 0x%08x getting IRTPRPHFilter interface!"), hr));
	    return hr;
    } /* if */
	ASSERT( m_pIRTPRPHFilter != NULL );
    m_bIsInitialized = FALSE;
    DbgLog((LOG_TRACE, 3, TEXT("CRPHGENPropPage::OnConnect: Got IRTPRPHFilter interface at 0x%08x"), m_pIRTPRPHFilter));

    return NOERROR;
} /* CRPHGENPropPage::OnConnect() */


HRESULT 
CRPHGENPropPage::OnDisconnect(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CRPHGENPropPage::OnDisconnect: Entered")));

    if (m_pIRTPRPHFilter == NULL)
    {
        return E_UNEXPECTED;
    }

	m_pIRTPRPHFilter->Release();
	m_pIRTPRPHFilter = NULL;
    return NOERROR;
} /* CRPHGENPropPage::OnDisconnect() */


HRESULT 
CRPHGENPropPage::OnActivate(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CRPHGENPropPage::OnActivate: Entered")));

	m_bIsInitialized = TRUE;
    return NOERROR;
} /* CRPHGENPropPage::OnActivate() */


BOOL 
CRPHGENPropPage::OnInitDialog(void)
{
	BYTE tmpByte;
	DWORD dwMaxBufferSize;
	int PayloadType;
	HRESULT hErr;

    DbgLog((LOG_TRACE, 4, TEXT("CRPHGENPropPage::OnInitDialog: Entered")));

	hErr = m_pIRTPRPHFilter->GetPayloadType(&tmpByte);

	if (tmpByte == 0xff)
		PayloadType = -1;
	else
		PayloadType = tmpByte;

	if (!FAILED(hErr) && (PayloadType != -1))
		SetDlgItemInt(m_Dlg, IDC_PAYLOADTYPE, PayloadType, TRUE);

	hErr = m_pIRTPRPHFilter->GetMediaBufferSize(&dwMaxBufferSize);

	SetDlgItemInt(m_Dlg, IDC_BUFFERSIZE, dwMaxBufferSize, TRUE);

 	hErr = m_pIRTPRPHFilter->GetTimeoutDuration(&m_dwDejitterTime,&m_dwLostPacketTime);

	SetDlgItemInt(m_Dlg, IDC_DEJITTER_TIME, m_dwDejitterTime, TRUE);

	SetDlgItemInt(m_Dlg, IDC_LOSTPACKET_TIME, m_dwLostPacketTime, TRUE);

   return (LRESULT) 1;
} /* CRPHGENPropPage::OnInitDialog() */


BOOL 
CRPHGENPropPage::OnCommand( 
    int     iButton, 
    int     iNotify,
    LPARAM  lParam)
{

    DbgLog((LOG_TRACE, 4, TEXT("CRPHGENPropPage::OnCommand: Entered")));
	switch(iButton - m_dwIDD_Base) {
	case IDC_RPH_PAYLOADTYPE_IDX:
		m_PayloadType = GetDlgItemInt(m_Dlg, IDC_PAYLOADTYPE, &m_bPayloadScanned, FALSE);
		break;
	case IDC_RPH_BUFFERSIZE_IDX:
		m_dwBufsize = GetDlgItemInt(m_Dlg, IDC_BUFFERSIZE, &m_bBufSizeScanned, FALSE);
		break;
	case IDC_RPH_DEJITTER_TIME_IDX:
		m_dwDejitterTime = GetDlgItemInt(m_Dlg, IDC_DEJITTER_TIME, &m_bDejitterScanned, FALSE);
		break;
	case IDC_RPH_LOSTPACKET_TIME_IDX:
		m_dwLostPacketTime = GetDlgItemInt(m_Dlg, IDC_LOSTPACKET_TIME, &m_bLostPktScanned, FALSE);
		break;
	default:
		break;
	} /* switch */
	
	if (m_bPayloadScanned || m_bBufSizeScanned || m_bDejitterScanned || m_bLostPktScanned)
		SetDirty();

    return (LRESULT) 1;
} /* CRPHGENPropPage::OnCommand() */


HRESULT 
CRPHGENPropPage::OnApplyChanges(void)
{
	HRESULT hErr;
	BYTE tmpByte;

    DbgLog((LOG_TRACE, 4, TEXT("CRPHGENPropPage::OnApplyChanges: Entered")));
    ASSERT( m_pIRTPRPHFilter != NULL );

	tmpByte = (m_PayloadType & 0x000000ff);
	if (m_bPayloadScanned) {
		if (m_PayloadType != -1)
			hErr = m_pIRTPRPHFilter->OverridePayloadType(tmpByte);
	}
	if (m_bBufSizeScanned) {
		hErr = m_pIRTPRPHFilter->SetMediaBufferSize(m_dwBufsize);
	}
	if (m_bDejitterScanned || m_bLostPktScanned) {
		m_dwDejitterTime = (m_dwDejitterTime/100) * 100;
		m_dwLostPacketTime = (m_dwLostPacketTime/100) * 100;
		if (((m_dwDejitterTime == 0) && (m_dwLostPacketTime > 0))
		|| (m_dwDejitterTime > m_dwLostPacketTime)){
			hErr = m_pIRTPRPHFilter->SetTimeoutDuration(m_dwDejitterTime,m_dwLostPacketTime);
		} else if ((m_dwDejitterTime != 0) && (m_dwDejitterTime < m_dwLostPacketTime)) {
 			hErr = m_pIRTPRPHFilter->GetTimeoutDuration(&m_dwDejitterTime,&m_dwLostPacketTime);
		}
		SetDlgItemInt(m_Dlg, IDC_DEJITTER_TIME, m_dwDejitterTime, TRUE);
		SetDlgItemInt(m_Dlg, IDC_LOSTPACKET_TIME, m_dwLostPacketTime, TRUE);
	}

    return(NOERROR);

} /* CRPHGENPropPage::OnApplyChanges() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\common\rphipin.cpp ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : rphipin.cpp
// Purpose  : RTP RPH input pin implementation.
// Contents : 
//*M*/

#include <winsock2.h>
#include <streams.h>
#include <list.h>
#include <stack.h>
#include <ippm.h>
#include <rph.h>
#include <rphipin.h>
#include <amrtpuid.h>

CRPHIPin::CRPHIPin(
        TCHAR *pObjectName,
        CTransformFilter *pTransformFilter,
        HRESULT * phr,
        LPCWSTR pName) : CTransformInputPin(pObjectName,
						   pTransformFilter,
						   phr,
						   pName
						   )
{
}

STDMETHODIMP CRPHIPin::GetAllocatorRequirements(ALLOCATOR_PROPERTIES*pProps)
{
	return ((CRPHBase *)m_pTransformFilter)->GetAllocatorRequirements(pProps);
}

HRESULT CRPHIPin::GetMediaType(int iPosition, CMediaType *pMediaType)
{
	return ((CRPHBase *)m_pTransformFilter)->GetInputMediaType(iPosition, pMediaType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\common\rphprop.h ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : RPHProp.h
// Purpose  : Define the class that implements the RTP RPH
//            filter property page.
// Contents : 
//      class CRPHPropertyPage
//*M*/

#ifndef _RPHPROP_H_
#define _RPHPROP_H_

class 
CRPHGENPropPage 
: public CBasePropertyPage
{
    DWORD m_dwIDD_Base;
	
	static CUnknown * WINAPI
	CreateInstance2(LPUNKNOWN punk, HRESULT *phr, DWORD IDD_Base );
public:
    static CUnknown * WINAPI
	CreateInstance_aud( LPUNKNOWN punk, HRESULT *phr );

    static CUnknown * WINAPI
	CreateInstance_gena( LPUNKNOWN punk, HRESULT *phr );

    static CUnknown * WINAPI
	CreateInstance_genv( LPUNKNOWN punk, HRESULT *phr );

    static CUnknown * WINAPI
	CreateInstance_h26x( LPUNKNOWN punk, HRESULT *phr );

#if defined(_0_)	
	static CUnknown * WINAPI CreateInstance( LPUNKNOWN punk, HRESULT *phr );
#endif
protected:
    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate () ;
    HRESULT OnApplyChanges();

    CRPHGENPropPage( LPUNKNOWN punk, HRESULT *phr, DWORD IDD_Base);

    BOOL OnInitDialog( void );
    BOOL OnCommand( int iButton, int iNotify, LPARAM lParam );

    void SetDirty();

protected:
	IRTPRPHFilter	*m_pIRTPRPHFilter;
    BOOL m_bIsInitialized;  // Will be false while we set init values in Dlg

	BOOL m_bPayloadScanned;
	BOOL m_bBufSizeScanned;
	BOOL m_bDejitterScanned;
	BOOL m_bLostPktScanned;
	int m_PayloadType;
	DWORD m_dwBufsize;
	DWORD m_dwDejitterTime;
	DWORD m_dwLostPacketTime;
};

#endif _RPHPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\rphaud\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\rphaud\rphaud.h ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : rphaud.h
// Purpose  : Define the class that implements the RTP RPH G.711 (alaw/mulaw) 
//            and G.723.1 Audio filter.
// Contents : 
//*M*/


#ifndef _RPHAUD_H_
#define _RPHAUD_H_

#include <rph.h>

#define DEFAULT_MEDIABUF_NUM_AUD 9 // HUGEMEMORY 30->9
#define DEFAULT_TIMEOUT_AUD 0
#define DEFAULT_STALE_TIMEOUT_AUD 0
#define PAYLOAD_CLOCK_AUD 8000
#define G711A_PT   8    //assigned RTP payload number for PCMA
#define G711_PT    0    //assigned RTP payload number for PCMU
#define G723_PT    4    //assigned RTP payload number for G.723.1
#define G711_MSPP  20   // # of MS per packet
#define G711_PKT_SIZE	(((8000 * G711_MSPP)/1000)+12)  // 8000 samples/sec, 20ms worth
#define G723_PKT_SIZE	(((33*24)/5)+12)  // 33 frames @ 24 bytes, 200 ms worth
#define DEFAULT_MEDIABUF_SIZE_AUD (G711_PKT_SIZE-12) // Remove rtp Header size
#define NUM_PACKETS_AUD	9 // HUGEMEMORY 16->9
#define FRAMESPERSEC_AUD 50 //Use G.711 worst case

class CRPHAUD : public CRPHBase
{

public:

    static CUnknown *CreateInstance(LPUNKNOWN punk, HRESULT *phr);

    DECLARE_IUNKNOWN;

    virtual HRESULT CheckInputType(const CMediaType *mtIn);
    virtual HRESULT CheckTransform(const CMediaType *mtIn,const CMediaType *mtOut);
    virtual HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);
    virtual HRESULT GetInputMediaType(int iPosition, CMediaType *pMediaType);
	virtual HRESULT CompleteConnect(PIN_DIRECTION dir,IPin *pPin);
	virtual HRESULT GetAllocatorRequirements(ALLOCATOR_PROPERTIES *pProps);


	// CPersistStream methods
	virtual HRESULT ReadFromStream(IStream *pStream);
	virtual HRESULT _stdcall GetClassID(CLSID *pCLSID);
	virtual DWORD GetSoftwareVersion(void);

    // Setup helper
    LPAMOVIESETUP_FILTER GetSetupData();

private:

    // Constructor
    CRPHAUD(TCHAR *tszName, LPUNKNOWN punk, HRESULT *phr);
	virtual HRESULT SetPPMSession();


}; // CRPHAUD


#endif // _RPHAUD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\common\rphres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rphprop.cpp
//
#if !defined(_RPHRES_H_)
#define      _RPHRES_H_

#define IDS_RPHAUD_BASE                         3300
#define IDS_RPHGENA_BASE                        3320
#define IDS_RPHGENV_BASE                        3340
#define IDS_RPHH26X_BASE                        3360

#define IDS_RPHGEN_IDX                          1
#define IDD_RPHGEN_PROPPAGE_IDX                 2
#define IDC_RPH_PAYLOADTYPE_IDX                 3
#define IDC_RPH_BUFFERSIZE_IDX                  4
#define IDC_RPH_DEJITTER_TIME_IDX               5
#define IDC_RPH_LOSTPACKET_TIME_IDX             6

#define IDS_RPHAUD_RPHGEN                       3301
#define IDD_RPHAUD_RPHGEN_PROPPAGE              3302
#define IDC_RPHAUD_PAYLOADTYPE                  3303
#define IDC_RPHAUD_BUFFERSIZE                   3304
#define IDC_RPHAUD_DEJITTER_TIME                3305
#define IDC_RPHAUD_LOSTPACKET_TIME              3306

#define IDS_RPHGENA_RPHGEN_AUDIO                3320
#define IDS_RPHGENA_RPHGEN                      3321
#define IDD_RPHGENA_RPHGEN_PROPPAGE             3322
#define IDC_RPHGENA_PAYLOADTYPE                 3323
#define IDC_RPHGENA_BUFFERSIZE                  3324
#define IDC_RPHGENA_DEJITTER_TIME               3325
#define IDC_RPHGENA_LOSTPACKET_TIME             3326
#define IDD_RPHGENA_RPHGENA_PROPPAGE            3327
#define IDC_RPHGENA_OUTPUTPINLIST               3328

#define IDS_RPHGENV_RPHGEN_VIDEO                3340
#define IDS_RPHGENV_RPHGEN                      3341
#define IDD_RPHGENV_RPHGEN_PROPPAGE             3342
#define IDC_RPHGENV_PAYLOADTYPE                 3343
#define IDC_RPHGENV_BUFFERSIZE                  3344
#define IDC_RPHGENV_DEJITTER_TIME               3345
#define IDC_RPHGENV_LOSTPACKET_TIME             3346
#define IDD_RPHGENV_RPHGENV_PROPPAGE            3347
#define IDC_RPHGENV_OUTPUTPINLIST               3348

#define IDS_RPHH26X_RPHH26X                     3360
#define IDS_RPHH26X_RPHGEN                      3361
#define IDD_RPHH26X_RPHGEN_PROPPAGE             3362
#define IDC_RPHH26X_PAYLOADTYPE                 3363
#define IDC_RPHH26X_BUFFERSIZE                  3364
#define IDC_RPHH26X_DEJITTER_TIME               3365
#define IDC_RPHH26X_LOSTPACKET_TIME             3366
#define IDD_RPHH26X_RPHH26X_PROPPAGE            3367

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\rphgena\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1007
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\rphaud\template.h ===
/*********************************************************************
 *
 * Copyright (c) 1997 Microsoft Corporation
 *
 * File: rph\rphaud\template.h
 *
 * Abstract:
 *     Macros to define CFactoryTemplate templates
 *
 * History:
 *     10/27/97    Created by AndresVG
 *
 **********************************************************************/
#if !defined(_RPHAUD_TEMPLATE_H_)
#define      _RPHAUD_TEMPLATE_H_

extern AMOVIESETUP_FILTER sudRPHAUD;

#define RPH_FOR_AUD       L"Intel RTP RPH for G.711/G.723.1"
#define RPH_FOR_AUD_PROP  L"Intel RTP RPH Property Page"

#define CFT_RPHAUD_FILTER \
{ \
	  RPH_FOR_AUD, \
	  &CLSID_INTEL_RPHAUD, \
	  CRPHAUD::CreateInstance, \
	  NULL, \
	  &sudRPHAUD \
	  }

#define CFT_RPHAUD_FILTER_PROP \
{ \
	  RPH_FOR_AUD_PROP, \
	  &CLSID_INTEL_RPHAUD_PROPPAGE, \
	  CRPHGENPropPage::CreateInstance_aud \
	  }

#define CFT_RPHAUD_ALL_FILTERS \
CFT_RPHAUD_FILTER, \
CFT_RPHAUD_FILTER_PROP

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\rphgena\genaprop.h ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : genaprop.h
// Purpose  : Define the class that implements the RTP RPH
//            filter property page.
// Contents : 
//      class CRPHGENAPropertyPage
//*M*/

#ifndef _RPH_GENAPROP_H_
#define _RPH_GENAPROP_H_

//----------------------------------------------------------------------------
// RTP/RTCP: Registry information under:
//				HKEY_LOCAL_MACHINE\SOFTWARE\INTEL\ActiveMovie_Filters
//----------------------------------------------------------------------------

#define szRegAMRTPKey				TEXT("SOFTWARE\\Intel\\ActiveMovie Filters")

class 
CRPHGENAPropPage 
: public CBasePropertyPage
{
	
public:
    static CUnknown * WINAPI CreateInstance( LPUNKNOWN punk, HRESULT *phr );

protected:
    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate () ;
	HRESULT	OnDeactivate ();
    HRESULT OnApplyChanges();

    CRPHGENAPropPage( LPUNKNOWN punk, HRESULT *phr);

    BOOL OnInitDialog( void );
    BOOL OnCommand( int iButton, int iNotify, LPARAM lParam );

    void SetDirty();

protected:
	IRTPRPHFilter	*m_pIRTPRPHFilter;
    BOOL			m_bIsInitialized;  // Will be false while we set init values in Dlg
	int				m_nActiveItems;
	BOOL			m_bMediaTypeScanned;
	AM_MEDIA_TYPE	*m_pMediaTypeVal;
};

#endif _GENAPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\rphaud\rphaud.cpp ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : rphaud.cpp
// Purpose  : RTP RPH G.711 (alaw/mulaw) and G.723.1 Audio filter implementation.
// Contents : 
//*M*/

#include <winsock2.h>
#include <streams.h>
#include <list.h>
#include <stack.h>
#include <rtpclass.h>
#if !defined(RPH_IN_DXMRTP)
#include <initguid.h>
#define INITGUID
#endif
#include <ippm.h>
#include <amrtpuid.h>
#include <auduids.h>
#include <uuids.h>
#include <rphaud.h>
#include <ppmclsid.h>
#include <ppmerr.h>
#include <memory.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <rphprop.h>

#include "template.h"

// setup data
EXTERN_C const CLSID CLSID_INTEL_RPHAUD;
EXTERN_C const CLSID CLSID_INTEL_RPHAUD_PROPPAGE;

static const CLSID *pPropertyPageClsids[] =
{
	&CLSID_INTEL_RPHAUD_PROPPAGE
};

#define NUMPROPERTYPAGES \
    (sizeof(pPropertyPageClsids)/sizeof(pPropertyPageClsids[0]))

static AMOVIESETUP_MEDIATYPE sudOutputPinTypes[] =
{
	{
		&MEDIATYPE_Audio,        // Major type
		&MEDIASUBTYPE_G723Audio  // Minor type
	},
	{
		&MEDIATYPE_Audio,        // Major type
		&MEDIASUBTYPE_MULAWAudio // Minor type
	},
	{
		&MEDIATYPE_Audio,        // Major type
		&MEDIASUBTYPE_ALAWAudio  // Minor type
	},
    {
		&MEDIATYPE_Audio,        // Major type
		&MEDIASUBTYPE_PCM        // Minor type
    },
    {
		&MEDIATYPE_Audio,        // Major type
		&MEDIASUBTYPE_NULL       // Minor type
	}
};

static AMOVIESETUP_MEDIATYPE sudInputPinTypes[] =
{
	{
		&MEDIATYPE_RTP_Single_Stream,       // Major type
		&MEDIASUBTYPE_RTP_Payload_G711U      // Minor type
	},
	{
		&MEDIATYPE_RTP_Single_Stream,       // Major type
		&MEDIASUBTYPE_RTP_Payload_G711A      // Minor type
	},
	{
		&MEDIATYPE_RTP_Single_Stream,       // Major type
		&MEDIASUBTYPE_RTP_Payload_G723      // Minor type
	}
};

static AMOVIESETUP_PIN psudPins[] =
{
    {
        L"Input",           // String pin name
        FALSE,              // Is it rendered
        FALSE,              // Is it an output
        FALSE,              // Allowed none
        FALSE,              // Allowed many
        &CLSID_NULL,        // Connects to filter
        L"Output",          // Connects to pin
        3,                  // Number of types
        (AMOVIESETUP_MEDIATYPE *)&sudInputPinTypes },// The pin details
      { L"Output",          // String pin name
        FALSE,              // Is it rendered
        TRUE,               // Is it an output
        FALSE,              // Allowed none
        FALSE,              // Allowed many
        &CLSID_NULL,        // Connects to filter
        L"Input",           // Connects to pin
        5,                  // Number of types
        (AMOVIESETUP_MEDIATYPE *)&sudOutputPinTypes  // The pin details
    }
};


AMOVIESETUP_FILTER sudRPHAUD =
{
    &CLSID_INTEL_RPHAUD,    // Filter CLSID
    L"Intel RTP RPH for G.711/G.723.1",             // Filter name
    MERIT_DO_NOT_USE, //MERIT_UNLIKELY,         // Its merit
    2,                      // Number of pins
    psudPins                // Pin details
};


// List of class IDs and creator functions for the class factory. This
// provides the link between the OLE entry point in the DLL and an object
// being created. The class factory will call the static CreateInstance

#if !defined(RPH_IN_DXMRTP)
CFactoryTemplate g_Templates[] = {
	CFT_RPHAUD_ALL_FILTERS
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);
#endif

//
// Constructor
//
CRPHAUD::CRPHAUD(TCHAR *tszName,LPUNKNOWN punk,HRESULT *phr) :
    CRPHBase(tszName, punk, phr, CLSID_INTEL_RPHAUD,
			 DEFAULT_MEDIABUF_NUM_AUD, 
			 DEFAULT_MEDIABUF_SIZE_AUD,
			 DEFAULT_TIMEOUT_AUD,
			 DEFAULT_STALE_TIMEOUT_AUD,
			 PAYLOAD_CLOCK_AUD,
			 TRUE,
			 FRAMESPERSEC_AUD,
			 NUMPROPERTYPAGES,
			 pPropertyPageClsids)
{
	
	DbgLog((LOG_TRACE,4,TEXT("CRPHAUD::CRPHAUD")));

    ASSERT(tszName);
    ASSERT(phr);

} // CRPHAUD


//
// CreateInstance
//
// Provide the way for COM to create a CRPHAUD object
//
CUnknown *CRPHAUD::CreateInstance(LPUNKNOWN punk, HRESULT *phr) {
	
	DbgLog((LOG_TRACE,4,TEXT("CRPHAUD::CreateInstance")));


    CRPHAUD *pNewObject = new CRPHAUD(NAME("Intel RTP Receive Payload Handler for G.711/G.723"), punk, phr);
    if (pNewObject == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return pNewObject;

} // CreateInstance


//
// GetSetupData
//
// Returns registry information for this filter
//
LPAMOVIESETUP_FILTER CRPHAUD::GetSetupData()
{
    return &sudRPHAUD;

} // GetSetupData


//
// GetInputMediaType
//
// Return the supported Media types
//
HRESULT CRPHAUD::GetInputMediaType(int iPosition, CMediaType *pMediaType)
{
	
	DbgLog((LOG_TRACE,4,TEXT("CRPHAUD::GetInputMediaType")));

	if (!m_bPTSet) 
    {
        return VFW_S_NO_MORE_ITEMS;
    }

	if (iPosition != 0) 
    {
        return VFW_S_NO_MORE_ITEMS;
    }

    pMediaType->SetType(&MEDIATYPE_RTP_Single_Stream);
    
    switch (m_PayloadType)
    {
    case G711_PT:
        pMediaType->SetSubtype(&MEDIASUBTYPE_RTP_Payload_G711U);
        break;
    
    case G711A_PT:
        pMediaType->SetSubtype(&MEDIASUBTYPE_RTP_Payload_G711A);
        break;
    
    case G723_PT:
        pMediaType->SetSubtype(&MEDIASUBTYPE_RTP_Payload_G723);
        break;

    default:
        if (m_PayloadType >= 96)
        {
            // BUGBUG, dynamic types are always G723 for now.
            pMediaType->SetSubtype(&MEDIASUBTYPE_RTP_Payload_G723);
            break;
        }
        else
            return VFW_S_NO_MORE_ITEMS;
    }
    return S_OK;
}
    
//
// CheckInputType
//
// Check the input type is OK, return an error otherwise
//
HRESULT CRPHAUD::CheckInputType(const CMediaType *mtIn)
{
	
	DbgLog((LOG_TRACE,4,TEXT("CRPHAUD::CheckInputType")));

	//Check major type first
    if (*mtIn->Type() == MEDIATYPE_RTP_Single_Stream) {
		//Check all supported minor types
		if (*mtIn->Subtype() == MEDIASUBTYPE_RTP_Payload_G723) {
			m_PPMCLSIDType = CLSID_G723PPMReceive;
			if (!m_bPTSet) m_PayloadType = G723_PT;
			return NOERROR;
		} 
		if (*mtIn->Subtype() == MEDIASUBTYPE_RTP_Payload_G711U) {
			m_PPMCLSIDType = CLSID_G711PPMReceive;
			if (!m_bPTSet) m_PayloadType = G711_PT;
			return NOERROR;
		}
		if (*mtIn->Subtype() == MEDIASUBTYPE_RTP_Payload_G711A) {
			m_PPMCLSIDType = CLSID_G711APPMReceive;
			if (!m_bPTSet) m_PayloadType = G711A_PT;
			return NOERROR;
		}
		//Otherwise, we don't support this input subtype
		return E_INVALIDARG;
	}

	//We don't support this major type
    return E_FAIL;

} // CheckInputType


//
// CheckTransform
//
// To be able to transform the formats must be compatible
//
HRESULT CRPHAUD::CheckTransform(const CMediaType *mtIn,const CMediaType *mtOut)
{
	
	DbgLog((LOG_TRACE,4,TEXT("CRPHAUD::CheckTransform")));

	//Check all supported minor types
	if ((*mtIn->Subtype() == MEDIASUBTYPE_RTP_Payload_G723) && 
		(*mtOut->Subtype() == MEDIASUBTYPE_G723Audio)) {
		return NOERROR;
	} 
	if (*mtIn->Subtype() == MEDIASUBTYPE_RTP_Payload_G711U) {
		if (*mtOut->Subtype() == MEDIASUBTYPE_MULAWAudio) 
			return NOERROR;
		if ((*mtOut->Subtype() == MEDIASUBTYPE_PCM) || 
			(*mtOut->Subtype() == MEDIASUBTYPE_NULL))  {
			//check format
			if (*mtOut->FormatType() == FORMAT_WaveFormatEx) {
				if ((void*)IsBadReadPtr(mtOut->Format(), sizeof (WAVEFORMATEX*))) return E_FAIL;
				if (mtOut->IsPartiallySpecified()) return E_FAIL;
				if (mtOut->Format() == NULL) return E_FAIL;
				if (((WAVEFORMATEX *)(mtOut->Format()))->wFormatTag ==
					WAVE_FORMAT_MULAW) {
						return NOERROR;
				} 
			}
			return E_FAIL;
		}
	} 
	if (*mtIn->Subtype() == MEDIASUBTYPE_RTP_Payload_G711A) {
		if (*mtOut->Subtype() == MEDIASUBTYPE_ALAWAudio) 
			return NOERROR;
		if ((*mtOut->Subtype() == MEDIASUBTYPE_PCM) || 
			(*mtOut->Subtype() == MEDIASUBTYPE_NULL))  {
			//check format
			if (*mtOut->FormatType() == FORMAT_WaveFormatEx) {
				if ((void*)IsBadReadPtr(mtOut->Format(), sizeof (WAVEFORMATEX*))) return E_FAIL;
				if (mtOut->IsPartiallySpecified()) return E_FAIL;
				if (mtOut->Format() == NULL) return E_FAIL;
				if (((WAVEFORMATEX *)(mtOut->Format()))->wFormatTag ==
					WAVE_FORMAT_ALAW) {
						return NOERROR;
				} 
			}
			return E_FAIL;
		}
	} 
    return E_FAIL;

} // CheckTransform

//
// GetAllocatorRequirements
//
// This is a hint to the upstream RTP source filter about the
// buffers to allocate.
//
HRESULT CRPHAUD::GetAllocatorRequirements(ALLOCATOR_PROPERTIES *pProps)
{
	if (!pProps) return E_POINTER;

	pProps->cBuffers = NUM_PACKETS_AUD +
		(m_dwLostPacketTime/(1000/FRAMESPERSEC_AUD));
	pProps->cbAlign = 0;
	pProps->cbPrefix = 0;
#if 0
	if (m_PPMCLSIDType == CLSID_G723PPMReceive) {
		pProps->cbBuffer = G723_PKT_SIZE;
	} else {
		pProps->cbBuffer = G711_PKT_SIZE;
	}
#else
	pProps->cbBuffer = m_dwMaxMediaBufferSize;
#endif
	return NOERROR;
}

//
// GetMediaType
//
// I support types based on the type set during CheckInputType
// We must be connected to support the output type
//
HRESULT CRPHAUD::GetMediaType(int iPosition, CMediaType *pMediaType)
{

	DbgLog((LOG_TRACE,4,TEXT("CRPHAUD::GetMediaType")));

	DbgLog((LOG_TRACE,4,TEXT("CRPHAUD::GetMediaType, position %d"), iPosition));


	// Is the input pin connected

    if (m_pInput->IsConnected() == FALSE) {
        return E_UNEXPECTED;
    }

    // This should never happen

    if (iPosition < 0) {
        return E_INVALIDARG;
    }

	const GUID mtguid = MEDIATYPE_Audio;

	const GUID vFormatGuid = FORMAT_WaveFormatEx;


	CMediaType mtOut(&mtguid);


    // Do we have more items to offer

	if (iPosition == 0) {
#if 1
		WAVEFORMATEX wformat;
#endif
		if (m_PPMCLSIDType == CLSID_G711PPMReceive) {
	
			DbgLog((LOG_TRACE,2,TEXT("CRPHAUD::GetMediaType - G.711 mulaw payload input")));

			const GUID vMULAWguid = MEDIASUBTYPE_MULAWAudio;
			//set output pin type
			mtOut.SetSubtype(&vMULAWguid);

#if 1
			//set format
			wformat.wFormatTag = WAVE_FORMAT_MULAW;
			wformat.nChannels = (WORD) 1;
			wformat.nSamplesPerSec = (DWORD) 8000;
			wformat.wBitsPerSample = (WORD) 8;
			wformat.cbSize = 0;
			wformat.nAvgBytesPerSec = (int) 8000;
			wformat.nBlockAlign = 1;

			mtOut.SetFormat((BYTE*)&wformat, sizeof(wformat));
			mtOut.SetFormatType(&vFormatGuid);
			mtOut.SetTemporalCompression(FALSE);
#endif
			m_pOutput->SetMediaType(&mtOut);
			*pMediaType = mtOut;
		} else if (m_PPMCLSIDType == CLSID_G711APPMReceive) {
			
			DbgLog((LOG_TRACE,2,TEXT("CRPHAUD::GetMediaType - G.711 alaw payload input")));

			const GUID vALAWguid = MEDIASUBTYPE_ALAWAudio;
			//set output pin type
			mtOut.SetSubtype(&vALAWguid);

#if 1
			//set format
			wformat.wFormatTag = WAVE_FORMAT_ALAW;
			wformat.nChannels = 1;
			wformat.nSamplesPerSec = m_dwPayloadClock;
			wformat.wBitsPerSample = 8;
			wformat.cbSize = 0;
			wformat.nAvgBytesPerSec = 8000;
			wformat.nBlockAlign = 1;
			mtOut.SetFormat((BYTE*)&wformat, sizeof(wformat));
			mtOut.SetFormatType(&vFormatGuid);
#endif
			m_pOutput->SetMediaType(&mtOut);
			*pMediaType = mtOut;
		} else { //G723
			
			DbgLog((LOG_TRACE,2,TEXT("CRPHAUD::GetMediaType - G.723 payload input")));

			const GUID vG723guid = MEDIASUBTYPE_G723Audio;
			//set output pin type
			mtOut.SetSubtype(&vG723guid);

#if 0
			//set format
			wformat.wFormatTag = WAVE_FORMAT_G723;
			wformat.nChannels = 1;
			wformat.nSamplesPerSec = 33;
			wformat.wBitsPerSample = 0;
			wformat.cbSize = 0;
			wformat.nAvgBytesPerSec = 0;
			wformat.nBlockAlign = 0;
			mtOut.SetFormat((BYTE*)&wformat, sizeof(wformat));
			mtOut.SetFormatType(&vFormatGuid);
			mtOut.SetVariableSize();
#endif
			m_pOutput->SetMediaType(&mtOut);
			*pMediaType = mtOut;
		}
	}

#if 1
	if ((iPosition == 1) || (iPosition == 2)) {
			WAVEFORMATEX wformat;
			GUID vWAVEguid;

			if (iPosition == 1)
				vWAVEguid = MEDIASUBTYPE_PCM;
			else
				vWAVEguid = MEDIASUBTYPE_NULL;
		//set output pin type
		mtOut.SetSubtype(&vWAVEguid);

		if (m_PPMCLSIDType == CLSID_G711PPMReceive) {
#ifdef _DEBUG
			OutputDebugString("GetMediaType - G.711 payload input, trying PCMAudio out\n");
#endif
			//set format
			wformat.wFormatTag = WAVE_FORMAT_MULAW;
			wformat.nChannels = 1;
			wformat.nSamplesPerSec = m_dwPayloadClock;
			wformat.wBitsPerSample = 8;
			wformat.cbSize = 0;
			wformat.nAvgBytesPerSec = 8000;
			wformat.nBlockAlign = 1;
			mtOut.SetFormat((BYTE*)&wformat, sizeof(wformat));
			mtOut.SetFormatType(&vFormatGuid);
			m_pOutput->SetMediaType(&mtOut);
			*pMediaType = mtOut;
		} else if (m_PPMCLSIDType == CLSID_G711APPMReceive) {
#ifdef _DEBUG
			OutputDebugString("GetMediaType - G.711 alaw payload input, trying PCMAudio out\n");
#endif
			//set format
			wformat.wFormatTag = WAVE_FORMAT_ALAW;
			wformat.nChannels = 1;
			wformat.nSamplesPerSec = m_dwPayloadClock;
			wformat.wBitsPerSample = 8;
			wformat.cbSize = 0;
			wformat.nAvgBytesPerSec = 8000;
			wformat.nBlockAlign = 1;
			mtOut.SetFormat((BYTE*)&wformat, sizeof(wformat));
			mtOut.SetFormatType(&vFormatGuid);
			m_pOutput->SetMediaType(&mtOut);
			*pMediaType = mtOut;
#if 0
		} else {
#ifdef _DEBUG
			OutputDebugString("GetMediaType - G.723 payload input, trying PCMAudio out\n");
#endif
			//set format
			wformat.wFormatTag = WAVE_FORMAT_G723;
			wformat.nChannels = 1;
			wformat.nSamplesPerSec = 33;
			wformat.wBitsPerSample = 0;
			wformat.cbSize = 0;
			wformat.nAvgBytesPerSec = 0;
			wformat.nBlockAlign = 0;
			mtOut.SetFormat((BYTE*)&wformat, sizeof(wformat));
			mtOut.SetFormatType(&vFormatGuid);
			mtOut.SetVariableSize();
			m_pOutput->SetMediaType(&mtOut);
			*pMediaType = mtOut;
#endif
		}
	}
#endif

    if (iPosition > 2) {
        return VFW_S_NO_MORE_ITEMS;
    }

    return NOERROR;

} // GetMediaType


// CompleteConnect
// This function is overridden so that the RTP support interface from the codec
//   can be retrieved and the extended bitstream generation turned on
//
HRESULT
CRPHAUD::CompleteConnect(PIN_DIRECTION dir,IPin *pPin)
{
//lsc - We may not need this function at all, but we then need to override to return a noerror
	DbgLog((LOG_TRACE,4,TEXT("CRPHAUD::CompleteConnect")));

#if 0 //def SETG723LICENSE
// Current implementation does not allow any other codecs to be used MIKECL
	if (dir == PINDIR_OUTPUT) {
		if (m_PPMCLSIDType == CLSID_G723PPMReceive) { //G.723.1

			PIN_INFO InputPinInfo;
			HRESULT hr;
			//get the downstream filter's input pin info structure
			hr = pPin->QueryPinInfo(&InputPinInfo);
			if (FAILED(hr)) 
				return E_FAIL;

			ICodecLicense *pLicIF = NULL;

			//query the filter interface for its license interface
			
			hr = InputPinInfo.pFilter->QueryInterface(IID_ICodecLicense, (void **) &pLicIF);
            InputPinInfo.pFilter->Release();
			if (FAILED(hr)) {
				DbgLog((LOG_ERROR,2,TEXT("CompleteConnect::Couldn't get IID_ICodecLicense"))); 
				return E_FAIL;
			}
			DWORD dword0 = G723KEY_PSword0;
			DWORD dword1 = G723KEY_PSword1;
			hr = pLicIF->put_LicenseKey(dword0,dword1);
			if (FAILED(hr)) {
				DbgLog((LOG_ERROR,2,TEXT("CompleteConnect::Couldn't set license"))); 
				if (pLicIF) pLicIF->Release(); pLicIF = NULL;
				return E_FAIL;
			}
			if (pLicIF) pLicIF->Release(); pLicIF = NULL;
		}
	}

#endif

	return NOERROR;
}


// SetPPMSession
// This function is where PPM::SetSession is called and may be specific to payload
//  handler.  Minimum function is to set the payload type.
HRESULT CRPHAUD::SetPPMSession() 
{
	HRESULT hr;
	if (m_pPPMSession) {
		hr = m_pPPMSession->SetPayloadType((unsigned char)m_PayloadType);
		hr = m_pPPMSession->SetTimeoutDuration(m_dwLostPacketTime);
		return hr;
	} else {
		return E_FAIL;
	}
}

// CPersistStream methods

// ReadFromStream
// This is the call that will read persistent data from file
//
HRESULT CRPHAUD::ReadFromStream(IStream *pStream) 
{ 
	DbgLog((LOG_TRACE, 4, 
			TEXT("CRPHAUD::ReadFromStream")));
    if (mPS_dwFileVersion != 1) {
		DbgLog((LOG_ERROR, 2, 
				TEXT("CRPHAUD::ReadFromStream: Incompatible stream format")));
		return E_FAIL;
	}
	
	return CRPHBase::ReadFromStream(pStream);

}

// GetClassID
// This function returns my CLSID  
//  
HRESULT _stdcall CRPHAUD::GetClassID(CLSID *pCLSID) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("CRPHAUD::GetClassID")));
	
	if (!pCLSID)
		return E_POINTER;
	*pCLSID = CLSID_INTEL_RPHAUD;
	return NOERROR; 
}

// GetSoftwareVersion
// This returns the version of this filter to be stored with the persistent data
//
DWORD CRPHAUD::GetSoftwareVersion(void) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("CRPHAUD::GetSoftwareVersion")));
	
	return 1; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\rphgenv\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1007
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\rphgena\genaprop.cpp ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : genaprop.cpp
// Purpose  : RTP RPH Generic Audio Property Page.
// Contents : 
//*M*/

#include <winsock2.h>
#include <streams.h>
#include <list.h>
#include <stack.h>
#include <ippm.h>
#include <amrtpuid.h>
#include <rph.h>
#include <ppmclsid.h>
#include <memory.h>
#include <resource.h>
#include <mmreg.h>
#include "rphres.h"
#include "genaprop.h"



CUnknown * WINAPI 
CRPHGENAPropPage::CreateInstance( 
    LPUNKNOWN punk, 
    HRESULT *phr )
{
    CRPHGENAPropPage *pNewObject
        = new CRPHGENAPropPage( punk, phr);

    if( pNewObject == NULL )
        *phr = E_OUTOFMEMORY;

    return pNewObject;
} /* CRPHGENAPropPage::CreateInstance() */


CRPHGENAPropPage::CRPHGENAPropPage( 
    LPUNKNOWN pUnk,
    HRESULT *phr)
    : CBasePropertyPage(NAME("Intel RPH OutputPin Controls"),pUnk,
        IDD_RPHGENA_RPHGENA_PROPPAGE, IDS_RPHGENA_RPHGEN_AUDIO)
    , m_pIRTPRPHFilter (NULL)
    , m_bIsInitialized(FALSE)
	, m_bMediaTypeScanned(FALSE)
	, m_nActiveItems(0)
{
    DbgLog((LOG_TRACE, 3, TEXT("CRPHGENAPropPage::CRPHGENAPropPage: Constructed at 0x%08x"), this));
} /* CRPHGENAPropPage::CRPHGENAPropPage() */

void 
CRPHGENAPropPage::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
    {
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
    }
} /* CRPHGENAPropPage::SetDirty() */

INT_PTR 
CRPHGENAPropPage::OnReceiveMessage(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    DbgLog((LOG_TRACE, 4, TEXT("CRPHGENAPropPage::OnReceiveMessage: Entered")));
    switch (uMsg) {
    case WM_INITDIALOG:
		return OnInitDialog();
		break;

    case WM_COMMAND:
        if (m_bIsInitialized) {
            if (OnCommand( (int) LOWORD( wParam ), (int) HIWORD( wParam ), lParam ) == TRUE) {
                return (LRESULT) 1;
            } /* if */
        } else {
			return(LRESULT) 1;
        } /* if */
        break;

	case WM_DESTROY:
		CRPHGENAPropPage::OnDeactivate();
		break;
    } /* switch */

    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
} /* CRPHGENAPropPage::OnReceiveMessage() */


HRESULT 
CRPHGENAPropPage::OnConnect(
    IUnknown    *pUnknown)
{
    DbgLog((LOG_TRACE, 4, TEXT("CRPHGENAPropPage::OnConnect: Entered")));
    ASSERT(m_pIRTPRPHFilter == NULL);
    DbgLog((LOG_TRACE, 2, TEXT("CRPHGENAPropPage::OnConnect: Called with IUnknown 0x%08x"), pUnknown));

	HRESULT hr = pUnknown->QueryInterface(IID_IRTPRPHFilter, (void **) &m_pIRTPRPHFilter);
	if(FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, TEXT("CRPHGENAPropPage::OnConnect: Error 0x%08x getting IRTPRPHFilter interface!"), hr));
	    return hr;
    } /* if */
	ASSERT( m_pIRTPRPHFilter != NULL );
    m_bIsInitialized = FALSE;
    DbgLog((LOG_TRACE, 3, TEXT("CRPHGENAPropPage::OnConnect: Got IRTPRPHFilter interface at 0x%08x"), m_pIRTPRPHFilter));

    return NOERROR;
} /* CRPHGENAPropPage::OnConnect() */


HRESULT 
CRPHGENAPropPage::OnDisconnect(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CRPHGENAPropPage::OnDisconnect: Entered")));

    if (m_pIRTPRPHFilter == NULL)
    {
        return E_UNEXPECTED;
    }

	m_pIRTPRPHFilter->Release();
	m_pIRTPRPHFilter = NULL;
    return NOERROR;
} /* CRPHGENAPropPage::OnDisconnect() */


HRESULT 
CRPHGENAPropPage::OnActivate(void)
{
	HKEY	hKey;
	HKEY	hTypeKey;
	HKEY	hSubtypeKey;
	long	lRes;
	char	keyBfr[50];
	DWORD	dwBufLen, dwIndex, nTypekeys, nTypeNameLen;
	DWORD	nSubtypekeys, nSubtypeNameLen, nMediaTypes;
	DWORD	nValueNameLen, dwData, dwValLen, nMediaTypeLen;
	DWORD	dwSubtypeIndex;
	HANDLE	hHeap;
	LPTSTR	lpTypeBuf;
	LPTSTR	lpSubtypeBuf;
	BYTE	*lpValBuf;
	HWND	hCurrentListbox;
	char	szMediaType[]="Audio";
	LRESULT	lrCurrentItem;
	int		i;
	BYTE	*lpTmpBuf;
	wchar_t	szCLSID[40];
	AM_MEDIA_TYPE *lpMediaTypeBuf;
	BYTE	*lpDataBuf;

    DbgLog((LOG_TRACE, 4, TEXT("CRPHGENAPropPage::OnActivate: Entered")));

    hCurrentListbox = GetDlgItem(m_hwnd, IDC_RPHGENA_OUTPUTPINLIST);

	// open the key
	strcpy (keyBfr, szRegAMRTPKey);
	lRes = RegOpenKeyEx (HKEY_LOCAL_MACHINE, keyBfr, 0, KEY_READ, &hKey);

	lRes = RegQueryInfoKey(hKey, NULL, NULL, NULL, &nTypekeys, &nTypeNameLen,
							NULL, NULL, NULL, NULL, NULL, NULL);
	// Allocate memory
	hHeap = GetProcessHeap();
	lpTypeBuf = (char *)HeapAlloc(hHeap, 0, ++nTypeNameLen);
	
	// Retrieve Registry values for the Media Types
	for (dwIndex = 0; dwIndex < nTypekeys; dwIndex++)
	{
		dwBufLen = nTypeNameLen;
		lRes = RegEnumKeyEx(hKey, dwIndex, lpTypeBuf, &dwBufLen, NULL, NULL, NULL, NULL);
		lRes = RegOpenKeyEx (hKey, lpTypeBuf, 0, KEY_READ, &hTypeKey);
		lRes = RegQueryInfoKey(hTypeKey, NULL, NULL, NULL, &nSubtypekeys, &nSubtypeNameLen,
								 NULL, NULL, NULL, &nValueNameLen, NULL, NULL);
		lpValBuf = (BYTE *)HeapAlloc(hHeap, 0, ++nValueNameLen);
		dwValLen = nValueNameLen;
		lRes = RegQueryValueEx(hTypeKey, "Media Type", NULL, &dwData, lpValBuf, &dwValLen);
		if(strncmp((char *)lpValBuf, szMediaType, dwValLen) == 0)
		{

			lpSubtypeBuf = (char *)HeapAlloc(hHeap,0, ++nSubtypeNameLen);
			for (dwSubtypeIndex = 0; dwSubtypeIndex < nSubtypekeys; dwSubtypeIndex++)
			{
				dwBufLen = nSubtypeNameLen;
				lRes = RegEnumKeyEx(hTypeKey, dwSubtypeIndex, lpSubtypeBuf,
										&dwBufLen, NULL, NULL, NULL, NULL);
				lRes = RegOpenKeyEx (hTypeKey, lpSubtypeBuf, 0, KEY_READ, &hSubtypeKey);
				lRes = RegQueryInfoKey(hSubtypeKey, NULL, NULL, NULL, NULL, NULL, NULL,
										&nMediaTypes, NULL, &nMediaTypeLen, NULL, NULL);
				lrCurrentItem = SendMessage(hCurrentListbox, LB_ADDSTRING, 0,
											reinterpret_cast<LPARAM>(lpSubtypeBuf));

				lpMediaTypeBuf = (AM_MEDIA_TYPE *)HeapAlloc(hHeap, 0, sizeof(AM_MEDIA_TYPE));
				memset(lpMediaTypeBuf, '\0', sizeof(AM_MEDIA_TYPE));
				lpTmpBuf = (BYTE *)HeapAlloc(hHeap, 0, ++nMediaTypeLen);
				memset(lpTmpBuf, '\0', nMediaTypeLen);
				// allocate the buffer we'll use for the PBformat
				lpDataBuf = (BYTE *)HeapAlloc(hHeap, 0, nMediaTypeLen);
				memset(lpDataBuf, '\0', nMediaTypeLen);

				dwValLen = nMediaTypeLen;
				lRes = RegQueryValueEx(hSubtypeKey, "MajorType", NULL, &dwData,
											lpTmpBuf, &dwValLen);
				if(lRes == ERROR_SUCCESS)
				{
					i = mbstowcs(szCLSID, (char *)lpTmpBuf, 40);
					CLSIDFromString(szCLSID, &(lpMediaTypeBuf->majortype));
				}

				dwValLen = nMediaTypeLen;
				lRes = RegQueryValueEx(hSubtypeKey, "MinorType", NULL, &dwData,
											lpTmpBuf, &dwValLen);
				if(lRes == ERROR_SUCCESS)
				{
					i = mbstowcs(szCLSID, (char *)lpTmpBuf, 40);
					CLSIDFromString(szCLSID, &(lpMediaTypeBuf->subtype));
				}

				dwValLen = nMediaTypeLen;
				lRes = RegQueryValueEx(hSubtypeKey, "FixedSizeSamples", NULL, &dwData,
											lpTmpBuf, &dwValLen);
				if(lRes == ERROR_SUCCESS)
				{
					lpMediaTypeBuf->bFixedSizeSamples = *(BOOL *)lpTmpBuf;
				}
				
				dwValLen = nMediaTypeLen;
				lRes = RegQueryValueEx(hSubtypeKey, "TemporalCompression", NULL, &dwData,
											lpTmpBuf, &dwValLen);
				if(lRes == ERROR_SUCCESS)
				{
					lpMediaTypeBuf->bTemporalCompression = *(BOOL *)lpTmpBuf;
				}

				dwValLen = nMediaTypeLen;
				lRes = RegQueryValueEx(hSubtypeKey, "SampleSize", NULL, &dwData,
											lpTmpBuf, &dwValLen);
				if(lRes == ERROR_SUCCESS)
				{
					lpMediaTypeBuf->lSampleSize = *(ULONG *)lpTmpBuf;
				}
				
				dwValLen = nMediaTypeLen;
				lRes = RegQueryValueEx(hSubtypeKey, "FormatType", NULL, &dwData,
											lpTmpBuf, &dwValLen);
				if(lRes == ERROR_SUCCESS)
				{
					i = mbstowcs(szCLSID, (char *)lpTmpBuf, 40);
					CLSIDFromString(szCLSID, &(lpMediaTypeBuf->formattype));
				}

				dwValLen = nMediaTypeLen;
				lRes = RegQueryValueEx(hSubtypeKey, "PBFormat", NULL, &dwData,
											lpDataBuf, &dwValLen);
				if(lRes == ERROR_SUCCESS)
				{
					lpMediaTypeBuf->pbFormat = lpDataBuf;
					lpMediaTypeBuf->cbFormat = dwValLen;
				}
				SendMessage(hCurrentListbox, LB_SETITEMDATA, lrCurrentItem,
								(LPARAM)lpMediaTypeBuf);
				// increment the number of active items in the Dialog Box
				// we'll use this to free the memory later.
				m_nActiveItems += 1;

				// ZCS fix 6-19-97: if this is the current output pin media type, make it selected.			
				AM_MEDIA_TYPE **ppMediaPinType = (AM_MEDIA_TYPE **)HeapAlloc(hHeap, 0, sizeof(AM_MEDIA_TYPE *));
				ASSERT(ppMediaPinType);
				if (SUCCEEDED(m_pIRTPRPHFilter->GetOutputPinMediaType(ppMediaPinType))
											&& ((*ppMediaPinType)->majortype == lpMediaTypeBuf->majortype)
											&& ((*ppMediaPinType)->subtype == lpMediaTypeBuf->subtype)) {
					SendMessage(hCurrentListbox, LB_SETCURSEL, lrCurrentItem, 0);
				}
				CoTaskMemFree((*ppMediaPinType)->pbFormat);
				CoTaskMemFree(*ppMediaPinType);
				HeapFree(hHeap, 0, (void *)ppMediaPinType);

				HeapFree(hHeap, 0, lpTmpBuf);
			}
			// HeapFree and RegCloseKey here
			HeapFree(hHeap, 0, lpValBuf);
			RegCloseKey(hSubtypeKey);
			RegCloseKey(hTypeKey);
		}
		else
		{
			HeapFree(hHeap, 0, lpValBuf);
			RegCloseKey(hTypeKey);
		}
	}
	
	m_bIsInitialized = TRUE;

	HeapFree(hHeap, 0, lpTypeBuf);
	RegCloseKey(hKey);

    return NOERROR;
} /* CRPHGENAPropPage::OnActivate() */


HRESULT 
CRPHGENAPropPage::OnDeactivate(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CRPHGENAPropertyPage::OnDeactivate: Entered")));
    
	HANDLE hHeap;
	AM_MEDIA_TYPE   *pMediaTypeVal;
	HWND   hCurrentListbox = GetDlgItem(m_Dlg, IDC_RPHGENA_OUTPUTPINLIST);
	int	   i;

    if (m_pIRTPRPHFilter == NULL)
    {
        return E_UNEXPECTED;
    }

	hHeap = GetProcessHeap();

	for (i=0; i < m_nActiveItems; i++)
	{
		pMediaTypeVal = reinterpret_cast<AM_MEDIA_TYPE *>(SendMessage(hCurrentListbox, LB_GETITEMDATA, i, 0));
		HeapFree(hHeap, 0, (void*)pMediaTypeVal->pbFormat);
		HeapFree(hHeap, 0, (void*)pMediaTypeVal);
	}

	// Probably don't really need to do this as its likely the object is going
	// away .. but .. better safe than sorry
	m_nActiveItems = 0;

    return NOERROR;
} /* CRPHGENAPropertyPage::OnDeactivate() */


BOOL 
CRPHGENAPropPage::OnInitDialog(void)
{

   DbgLog((LOG_TRACE, 4, TEXT("CRPHGENAPropPage::OnInitDialog: Entered")));

   return (LRESULT) 1;
} /* CRPHGENAPropPage::OnInitDialog() */


BOOL 
CRPHGENAPropPage::OnCommand( 
    int     iButton, 
    int     iNotify,
    LPARAM  lParam)
{
    DbgLog((LOG_TRACE, 4, TEXT("CRPHGENAPropPage::OnCommand: Entered")));

	HWND hCurrentListbox;
	LRESULT lrCurrentSel;

    switch( iButton ){
	case IDC_RPHGENA_OUTPUTPINLIST:
		if(iNotify == IDOK)
		{
			m_bMediaTypeScanned = TRUE;
			hCurrentListbox = GetDlgItem(m_Dlg, IDC_RPHGENA_OUTPUTPINLIST);
			lrCurrentSel = SendMessage(hCurrentListbox, LB_GETCURSEL, 0, 0);
			m_pMediaTypeVal = reinterpret_cast<AM_MEDIA_TYPE *>(SendMessage(hCurrentListbox,
																			LB_GETITEMDATA,
																			lrCurrentSel,
																			0));
			SetDirty();
		}
		break;
    default:
        break;
    } /* switch */	

    return (LRESULT) 1;
} /* CRPHGENAPropPage::OnCommand() */


HRESULT 
CRPHGENAPropPage::OnApplyChanges(void)
{
	HRESULT	hErr;

    DbgLog((LOG_TRACE, 4, TEXT("CRPHGENAPropPage::OnApplyChanges: Entered")));
    ASSERT( m_pIRTPRPHFilter != NULL );

	if (m_bMediaTypeScanned) {
		hErr = m_pIRTPRPHFilter->SetOutputPinMediaType(m_pMediaTypeVal);
        if (FAILED(hErr)) {
            DbgLog((LOG_ERROR, 1, TEXT("CRPHGENAPropPage::OnApplyChanges: SetOutputPinMediaType returned 0x%08X"),
                hErr));
        }
	}
    return(NOERROR);

} /* CRPHGENAPropPage::OnApplyChanges() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\rphgena\rphgena.cpp ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : rphgena.cpp
// Purpose  : RTP RPH Generic Audio filter implementation.
// Contents : 
//*M*/

#include <winsock2.h>
#include <streams.h>
#include <list.h>
#include <stack.h>
#include <rtpclass.h>
#if !defined(RPH_IN_DXMRTP)
#include <initguid.h>
#define INITGUID
#endif
#include <ippm.h>
#include <amrtpuid.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <rphgena.h>
#include <ppmclsid.h>
#include <ppmerr.h>
#include <memory.h>
#include <rphprop.h>
#include "genaprop.h"

#include "template.h"

// setup data

static const CLSID *pPropertyPageClsids[] =
{
        &CLSID_INTEL_RPHGENA_PROPPAGE,
		&CLSID_INTEL_RPHGENA_MEDIATYPE_PROPPAGE
};

#define NUMPROPERTYPAGES \
    (sizeof(pPropertyPageClsids)/sizeof(pPropertyPageClsids[0]))

static AMOVIESETUP_MEDIATYPE sudOutputPinTypes[] =
{
	{
		&MEDIATYPE_Audio,        // Major type
		&MEDIASUBTYPE_NULL       // Minor type
	}
};

static AMOVIESETUP_MEDIATYPE sudInputPinTypes[] =
{
	{
		&MEDIATYPE_RTP_Single_Stream,       // Major type
		&MEDIASUBTYPE_RTP_Payload_ANY       // Minor type
	}
};

static AMOVIESETUP_PIN psudPins[] =
{
    {
        L"Input",           // String pin name
        FALSE,              // Is it rendered
        FALSE,              // Is it an output
        FALSE,              // Allowed none
        FALSE,              // Allowed many
        &CLSID_NULL,        // Connects to filter
        L"Output",          // Connects to pin
        1,                  // Number of types
        (AMOVIESETUP_MEDIATYPE *)&sudInputPinTypes },// The pin details
      { L"Output",          // String pin name
        FALSE,              // Is it rendered
        TRUE,               // Is it an output
        FALSE,              // Allowed none
        FALSE,              // Allowed many
        &CLSID_NULL,        // Connects to filter
        L"Input",           // Connects to pin
        1,                  // Number of types
        (AMOVIESETUP_MEDIATYPE *)&sudOutputPinTypes  // The pin details
    }
};


AMOVIESETUP_FILTER sudRPHGENA =
{
    &CLSID_INTEL_RPHGENA,   // Filter CLSID
    L"Intel RTP RPH for Generic Audio", // Filter name
    MERIT_DO_NOT_USE,       // Its merit
    2,                      // Number of pins
    psudPins                // Pin details
};


// List of class IDs and creator functions for the class factory. This
// provides the link between the OLE entry point in the DLL and an object
// being created. The class factory will call the static CreateInstance

#if !defined(RPH_IN_DXMRTP)
CFactoryTemplate g_Templates[] = {
	CFT_RPHGENA_ALL_FILTERS
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);
#endif

//
// Constructor
//
CRPHGENA::CRPHGENA(TCHAR *tszName,LPUNKNOWN punk,HRESULT *phr) :
    CRPHBase(tszName, punk, phr, CLSID_INTEL_RPHGENA,
			 DEFAULT_MEDIABUF_NUM_GENA, 
			 DEFAULT_MEDIABUF_SIZE_GENA,
			 DEFAULT_TIMEOUT_GENA,
			 DEFAULT_STALE_TIMEOUT_GENA,
			 PAYLOAD_CLOCK_GENA,
			 TRUE,
			 FRAMESPERSEC_GENA,
			 NUMPROPERTYPAGES,
			 pPropertyPageClsids)
{
	
	DbgLog((LOG_TRACE,4,TEXT("CRPHGENA::CRPHGENA")));

    ASSERT(tszName);
    ASSERT(phr);

	//Setup our AM_MEDIATYPE structure
	m_MediaPinType.majortype = MEDIATYPE_Audio;
	m_MediaPinType.subtype = MEDIASUBTYPE_NULL;
	m_MediaPinType.bFixedSizeSamples = FALSE;
	m_MediaPinType.bTemporalCompression = FALSE;
	m_MediaPinType.lSampleSize = 0;
	m_MediaPinType.formattype = FORMAT_WaveFormatEx;
//	m_MediaPinType.pUnk = (IUnknown *)this;
	m_MediaPinType.cbFormat = 0;
	m_MediaPinType.pbFormat = NULL;
	m_PPMCLSIDType = CLSID_GEN_A_PPMReceive;


} // CRPHGENA


/*F*
//  Name    : CRPHGENA::~CRPHGENA()
//  Purpose : Destructor. Clean up a chunk of heap memory that may be lying around.
//  Context : Called when we are being deleted from memory.
//  Returns : Nothing.
//  Params  : None.
//  Notes   : The chunk of memory being deleted is allocated in SetOutputPinMediaType.
*F*/
CRPHGENA::~CRPHGENA() {
	DbgLog((LOG_TRACE,4,TEXT("CRPHGENA::~CRPHGENA")));

    if (m_MediaPinType.pbFormat != NULL) {
        // We are about to overwrite this, so free this memory if
        // it was previously allocated.
        delete[] m_MediaPinType.pbFormat;
        m_MediaPinType.pbFormat = NULL;
    } /* if */
} /* CRPHGENA::~CRPHGENA() */

//
// CreateInstance
//
// Provide the way for COM to create a CRPHGENA object
//
CUnknown *CRPHGENA::CreateInstance(LPUNKNOWN punk, HRESULT *phr) {
	
	DbgLog((LOG_TRACE,4,TEXT("CRPHGENA::CreateInstance")));


    CRPHGENA *pNewObject = new CRPHGENA(NAME("Intel RTP Receive Payload Handler for Generic Audio"), punk, phr);
    if (pNewObject == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return pNewObject;

} // CreateInstance


//
// GetSetupData
//
// Returns registry information for this filter
//
LPAMOVIESETUP_FILTER CRPHGENA::GetSetupData()
{
    return &sudRPHGENA;

} // GetSetupData


//
// GetInputMediaType
//
// Return the supported Media types
//
HRESULT CRPHGENA::GetInputMediaType(int iPosition, CMediaType *pMediaType)
{
	
	DbgLog((LOG_TRACE,4,TEXT("CRPHAUD::GetInputMediaType")));

	if (iPosition != 0) 
    {
        return VFW_S_NO_MORE_ITEMS;
    }

    pMediaType->SetType(&MEDIATYPE_RTP_Single_Stream);
    
    return S_OK;
}

//
// CheckInputType
//
// Check the input type is OK, return an error otherwise
//
HRESULT CRPHGENA::CheckInputType(const CMediaType *mtIn)
{
	
	DbgLog((LOG_TRACE,4,TEXT("CRPHGENA::CheckInputType")));

	//Check major type first
    if (*mtIn->Type() == MEDIATYPE_RTP_Single_Stream) {
		return NOERROR;
	}

	//We don't support this major type
    return E_FAIL;

} // CheckInputType


//
// CheckTransform
//
// To be able to transform the formats must be compatical
//
HRESULT CRPHGENA::CheckTransform(const CMediaType *mtIn,const CMediaType *mtOut)
{
	
	DbgLog((LOG_TRACE,4,TEXT("CRPHGENA::CheckTransform")));

	//Check all supported minor types
	if ((*mtIn->Type() == MEDIATYPE_RTP_Single_Stream) && 
		(*mtOut->Subtype() == m_MediaPinType.subtype)) {
		return NOERROR;
	} 
    return E_FAIL;

} // CheckTransform


//
// GetAllocatorRequirements
//
// This is a hint to the upstream RTP source filter about the
// buffers to allocate.
//
HRESULT CRPHGENA::GetAllocatorRequirements(ALLOCATOR_PROPERTIES *pProps)
{
	if (!pProps) return E_POINTER;

	pProps->cBuffers = NUM_PACKETS_GENA +
		(m_dwLostPacketTime/(1000/FRAMESPERSEC_GENA));
	pProps->cbAlign = 0;
	pProps->cbPrefix = 0;
	pProps->cbBuffer = AUDIO_PKT_SIZE;

	return NOERROR;
}

//
// GetMediaType
//
// I support one type, based on the type set during SetOutputPinMediaType
// We must be connected to support the single output type
//
HRESULT CRPHGENA::GetMediaType(int iPosition, CMediaType *pMediaType)
{

	DbgLog((LOG_TRACE,4,TEXT("CRPHGENA::GetMediaType")));

    // Is the input pin connected

    if (m_pInput->IsConnected() == FALSE) {
        return E_UNEXPECTED;
    }

    // This should never happen

    if (iPosition < 0) {
        return E_INVALIDARG;
    }

    // Do we have more items to offer

    if (iPosition > 0) {
        return VFW_S_NO_MORE_ITEMS;
    }

    *pMediaType = m_MediaPinType; // m_pOutput->CurrentMediaType();
    return NOERROR;


} // GetMediaType


// CompleteConnect
// 
//
HRESULT
CRPHGENA::CompleteConnect(PIN_DIRECTION dir,IPin *pPin)
{
//lsc - We may not need this function at all, but we then need to override to return a noerror
	DbgLog((LOG_TRACE,4,TEXT("CRPHGENA::CompleteConnect")));

	return NOERROR;
}

// SetPPMSession
// This function is where PPM::SetSession is called and may be specific to payload
//  handler.  Minimum function is to set the payload type.
HRESULT CRPHGENA::SetPPMSession() 
{
	HRESULT hr;
	if (m_pPPMSession) {
		hr = m_pPPMSession->SetPayloadType((unsigned char)m_PayloadType);
		hr = m_pPPMSession->SetTimeoutDuration(m_dwLostPacketTime);
		return hr;
	} else {
		return E_FAIL;
	}
}

// GetOutputPinMediaType
// Gets the type of the output pin
// We don't expect to get called for this in other than the generic filters
//
HRESULT CRPHGENA::GetOutputPinMediaType(AM_MEDIA_TYPE **ppMediaPinType)
{
	AM_MEDIA_TYPE *pMediaPinType = NULL;
	DbgLog((LOG_TRACE,4,TEXT("CRPHGENA::GetOutputPinMediaType")));

	if (!ppMediaPinType) return E_POINTER;

	if (!(pMediaPinType = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE)))) 
		return E_OUTOFMEMORY;

	CopyMemory((void*)pMediaPinType, (void*)&m_MediaPinType,
		sizeof(AM_MEDIA_TYPE));
	
	if (!(pMediaPinType->pbFormat = (UCHAR *)CoTaskMemAlloc(m_MediaPinType.cbFormat))) {
		CoTaskMemFree(pMediaPinType);
		return E_OUTOFMEMORY;
	}

	CopyMemory((void*)pMediaPinType->pbFormat, (void*)m_MediaPinType.pbFormat,
		m_MediaPinType.cbFormat);

	*ppMediaPinType = pMediaPinType;
	return NOERROR;
}

// SetOutputPinMediaType
// Sets the type of the output pin
// Needs to be called before CheckTransform and the last CheckInputType to be useful
// We don't expect to get called for this in other than the generic filters
//
HRESULT CRPHGENA::SetOutputPinMediaType(AM_MEDIA_TYPE *pMediaPinType)
{
	DbgLog((LOG_TRACE,4,TEXT("CRPHGENA::SetOutputPinMediaType")));
    CAutoLock l(&m_cStateLock);

	if (!m_pOutput) return E_FAIL;
    if (!m_pInput->CurrentMediaType().IsValid()) return E_FAIL;

    if (m_pOutput->IsConnected() == TRUE) {
        return VFW_E_ALREADY_CONNECTED;
    }

#if 0
	if (!((pMediaPinType->subtype == ??) ||
	(pMediaPinType->subtype == ??) ||
	(pMediaPinType->subtype == ??))) {
		return VFW_E_INVALIDSUBTYPE;
	}
#endif

    SetDirty(TRUE); // So that our state will be saved if we are in a .grf    

	m_MediaPinType.majortype = pMediaPinType->majortype;
	m_MediaPinType.subtype = pMediaPinType->subtype;
	m_MediaPinType.bFixedSizeSamples = pMediaPinType->bFixedSizeSamples;
	m_MediaPinType.bTemporalCompression = pMediaPinType->bTemporalCompression;
	m_MediaPinType.lSampleSize = pMediaPinType->lSampleSize;
	m_MediaPinType.formattype = pMediaPinType->formattype;
	m_MediaPinType.pUnk = static_cast<IUnknown *>(NULL);
    if (m_MediaPinType.pbFormat != NULL) {
        // We are about to overwrite this, so free this memory if
        // it was previously allocated.
        delete[] m_MediaPinType.pbFormat;
        m_MediaPinType.pbFormat = NULL;
    } /* if */
	if (pMediaPinType->cbFormat > 0) {
        // Whatever the structure is here, copy it in.
		m_MediaPinType.cbFormat = pMediaPinType->cbFormat;
        m_MediaPinType.pbFormat = new BYTE[pMediaPinType->cbFormat];
        if (m_MediaPinType.pbFormat == NULL) {
            DbgLog((LOG_ERROR, 2, 
                    TEXT("CRPHGENA::SetOutputPinMediaType: Unable to allocate pbFormat block!")));
            return E_OUTOFMEMORY;
        } /* if */
		CopyMemory (static_cast<void *>(m_MediaPinType.pbFormat),
			        static_cast<void *>(pMediaPinType->pbFormat), 
                    pMediaPinType->cbFormat);
	} else {
		m_MediaPinType.pbFormat = NULL;
		m_MediaPinType.cbFormat = 0;
	}
	

	//We're going to set our own output pin media type
	//lsc check this return value
	m_pOutput->SetMediaType(static_cast<CMediaType *>(&m_MediaPinType));

	return NOERROR;
}


// CPersistStream methods

/*F*
//  Name    : CRPHGENA::ReadFromStream()
//  Purpose : Read the persistence data for this filter from a file.
//  Context : Called when this filter is being loaded as a part of a filter
//            graph from a persistence file.
//  Returns : 
//      E_FAIL          Unknown persistence file version.
//      E_INVALIDARG    Persistence file is corrupt.
//      E_OUTOFMEMORY   Unable to allocate memory for pbFormat block.
//      Also returns other HRESULTs from IStream->Read().
//  Params  :
//      pStream Pointer to an IStream containing our persistence info.
//              This stream is assumed to have CRPHBase persistence info
//              in it preceeding our CRPHGENA persistence info. The CRPHBase
//              persistence info is assumed to be versionless.
//  Notes   : 
//      Version 1 had a slightly buggy persistence format which assumed
//          that the pbFormat was always a WaveFormatEx.
//      Version 2 fixes this problem by writing the cbFormat parameter,
//          followed by whatever length the pbFormat is.
*F*/
HRESULT 
CRPHGENA::ReadFromStream(IStream *pStream) 
{ 
	DbgLog((LOG_TRACE, 4, 
			TEXT("CRPHGENA::ReadFromStream")));
    switch(mPS_dwFileVersion) {
    case 1:
	    DbgLog((LOG_TRACE, 5, 
			    TEXT("CRPHGENA::ReadFromStream saw stream format 1")));
        break;
    case 2:
	    DbgLog((LOG_TRACE, 5, 
			    TEXT("CRPHGENA::ReadFromStream saw stream format 2")));
        break;
    default:
		DbgLog((LOG_ERROR, 2, 
				TEXT("CRPHGENA::ReadFromStream: Incompatible stream format %d!"),
                mPS_dwFileVersion));
		return E_FAIL;
        break;
    } /* switch */

	HRESULT hr;
	ULONG uBytesRead;

	hr = CRPHBase::ReadFromStream(pStream);
	if (FAILED(hr)) return hr;

    DbgLog((LOG_TRACE, 4, 
            TEXT("CRPHGENA::ReadFromStream: Loading media type")));

    AM_MEDIA_TYPE mt;
    hr = pStream->Read(&mt, sizeof(AM_MEDIA_TYPE), &uBytesRead);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRPHGENA::ReadFromStream: Error 0x%08x reading media type"),
                hr));
        return hr;
    } else if (uBytesRead != sizeof(AM_MEDIA_TYPE)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRPHGENA::ReadFromStream: Mismatch in (%d/%d) bytes read for media type"),
                uBytesRead, sizeof(AM_MEDIA_TYPE)));
        return E_INVALIDARG;
    } 

    if (mPS_dwFileVersion == 2) {
        hr = pStream->Read(&mt.cbFormat, sizeof(mt.cbFormat), &uBytesRead);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 2, 
                    TEXT("CRPHGENA::ReadFromStream: Error 0x%08x reading cbFormat length"),
                    hr));
            return hr;
        } else if (uBytesRead != sizeof(mt.cbFormat)) {
            DbgLog((LOG_ERROR, 2, 
                    TEXT("CRPHGENA::ReadFromStream: Mismatch in (%d/%d) bytes read for media type"),
                    uBytesRead, sizeof(mt.cbFormat)));
            return E_INVALIDARG;
        } /* if */
    } else {
        // Version 1 stream assumes default size to mt.cbFormat.
        ASSERT(mPS_dwFileVersion == 1);
    	mt.cbFormat = sizeof(WAVEFORMATEX);
    } /* if */

    if (mt.cbFormat > 0) {
        // pbFormat is variable sized in version 2.
        mt.pbFormat = new BYTE[mt.cbFormat];
        if (mt.pbFormat == NULL) {
            DbgLog((LOG_ERROR, 2, 
                    TEXT("CRPHGENA::ReadFromStream: Unable to allocate memory for pbFormat block!")));
            return E_OUTOFMEMORY;
        } /* if */
        hr = pStream->Read(mt.pbFormat, mt.cbFormat, &uBytesRead);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 2, 
                    TEXT("CRPHGENA::ReadFromStream: Error 0x%08x reading media format buffer"),
                    hr));
            return hr;
        } else if (uBytesRead != mt.cbFormat) {
            DbgLog((LOG_ERROR, 2, 
                    TEXT("CRPHGENA::ReadFromStream: Mismatch in (%d/%d) bytes read for media format buffer"),
                    uBytesRead, mt.cbFormat));
            return E_INVALIDARG;
        } 
    } else {
        // Size 0 is allowed in version 2.
        mt.pbFormat = NULL;
    } /* if */

	// ZCS 6-30-97: My surgery in this section is all intended to allow the output
	// pin media type to be set when the graph is loaded from a file. None of this
	// should be attempted if the output pin type is GUID_NULL, because the code
	// below assumes that the filter will later be connected as part of the load-
	// from-file procedure. A non-GUID_NULL value can only occur if the filter
	// was connected when it was saved.

	if (mt.majortype != GUID_NULL)
	{
	    DbgLog((LOG_TRACE, 3, 
				TEXT("CRPHGENA::ReadFromStream: Restoring media type")));

		// ZCS 6-30-97: at this point we don't have any pins, so we can't set the output pin media type
		// just yet. Must first call GetPin(). Subsequent calls to GetPin() will be ok because it
		// doesn't allocate more pins as long as the original input and output pins are still there.
		EXECUTE_ASSERT(GetPin(0) != NULL);
	
		// ZCS 6-30-97:
		// In order for SetOutputPinMediaType() to succeed, the input pin must
		// have a major type that isn't GUID_NULL. This is a bit of subterfuge
		// to pretend we have an input pin major type -- the type doesn't matter as
		// long as it isn't GUID_NULL. We'll undo this shortly.
	
		GUID gTemp = MEDIATYPE_RTP_Single_Stream;
		m_pInput->CurrentMediaType().SetType(&gTemp);
	
		hr = SetOutputPinMediaType(&mt);

		// ZCS: we don't really have an input major type, so undo what we did...
		gTemp = GUID_NULL;
		m_pInput->CurrentMediaType().SetType(&gTemp);
		
		// now check the SetOutputPinMediaType call...
	    if (FAILED(hr)) {
	        DbgLog((LOG_ERROR, 2, 
	                TEXT("CRPHGENA::ReadFromStream: Error 0x%08x setting media type"),
	                hr));
		
			if (mt.pbFormat != NULL) {
			    // We allocated something on the heap. Clean it up.
			    delete[] mt.pbFormat;
			} /* if */

			return hr;
	    } 

	}

	if (mt.pbFormat != NULL) {
	    // We allocated something on the heap. Clean it up.
	    delete[] mt.pbFormat;
	} /* if */

	return NOERROR; 
} /* CRPHGENA::ReadFromStream() */


/*F*
//  Name    : CRPHGENA::WriteToStream()
//  Purpose : Write the persistence data for this filter to a file.
//  Context : Called when this filter is being saved as a part of a filter
//            graph from a persistence file.
//  Returns : 
//      E_INVALIDARG    Persistence file is corrupt.
//      Also returns other HRESULTs from IStream->Write().
//  Params  :
//      pStream Pointer to an IStream to which we should write our
//              persistence information.
//  Notes   : 
*F*/
HRESULT 
CRPHGENA::WriteToStream(IStream *pStream) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("CRPHGENA::WriteToStream")));
	
	HRESULT hr;
    ULONG uBytesWritten = 0;

	hr = CRPHBase::WriteToStream(pStream);
	if (FAILED(hr)) return hr;

    DbgLog((LOG_TRACE, 4, 
            TEXT("CRPHGENA::WriteToStream: Writing media type")));

	hr = pStream->Write(&m_MediaPinType, sizeof(AM_MEDIA_TYPE), &uBytesWritten);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRPHGENA::WriteToStream: Error 0x%08x reading media type"),
                hr));
        return hr;
    } else if (uBytesWritten != sizeof(AM_MEDIA_TYPE)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRPHGENA::WriteToStream: Mismatch in (%d/%d) bytes read for media type"),
                uBytesWritten, sizeof(AM_MEDIA_TYPE)));
        return E_INVALIDARG;
    } 

    hr = pStream->Write(&m_MediaPinType.cbFormat, sizeof(m_MediaPinType.cbFormat), &uBytesWritten);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRPHGENA::WriteToStream: Error 0x%08x writing media format size"),
                hr));
        return hr;
    } else if (uBytesWritten != sizeof(m_MediaPinType.cbFormat)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRPHGENA::WriteToStream: Mismatch in (%d/%d) bytes written for media format size"),
                uBytesWritten, sizeof(m_MediaPinType.cbFormat)));
        return E_INVALIDARG;
    } /* if */

    if (m_MediaPinType.cbFormat > 0) {
        // Only write the pbFormat if the length is > 0.
        hr = pStream->Write(m_MediaPinType.pbFormat, m_MediaPinType.cbFormat, &uBytesWritten);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 2, 
                    TEXT("CRPHGENA::WriteToStream: Error 0x%08x writing media format buffer"),
                    hr));
            return hr;
        } else if (uBytesWritten != m_MediaPinType.cbFormat) {
            DbgLog((LOG_ERROR, 2, 
                    TEXT("CRPHGENA::WriteToStream: Mismatch in (%d/%d) bytes written for media format buffer"),
                    uBytesWritten, m_MediaPinType.cbFormat));
            return E_INVALIDARG;
        } 
    } /* if */

	return NOERROR; 
} /* CRPHGENA::WriteToStream() */


// SizeMax
// This returns the amount of storage space required for my persistent data
//
int CRPHGENA::SizeMax(void) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("CRPHGENA::SizeMax")));
	
	return CRPHBase::SizeMax()
        + sizeof(AM_MEDIA_TYPE)
		+ sizeof(WAVEFORMATEX); 
}

// GetClassID
// This function returns my CLSID  
//  
HRESULT _stdcall CRPHGENA::GetClassID(CLSID *pCLSID) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("CRPHGENA::GetClassID")));
	
	if (!pCLSID)
		return E_POINTER;
	*pCLSID = CLSID_INTEL_RPHGENA;
	return NOERROR; 
}

/*F*
//  Name    : CRPHGENA::GetSoftwareVersion()
//  Purpose : Return the version of this filter. What this really
//            corresponds to is the format version of its persistence file.
//  Context : Called when this filter is being loaded as a part of a filter
//            graph from a persistence file.
//  Returns : DWORD indicating the software version.
//  Params  : None.
//  Notes   : 
//      Version 1 had a slightly buggy persistence format which assumed
//          that the pbFormat was always a WaveFormatEx.
//      Version 2 fixes this problem by writing the cbFormat parameter,
//          followed by whatever length the pbFormat is.
*F*/
DWORD 
CRPHGENA::GetSoftwareVersion(void) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("CRPHGENA::GetSoftwareVersion")));
	
	return 2; 
} /* CRPHGENA::GetSoftwareVersion() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\rphgena\rphgena.h ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : rphgena.h
// Purpose  : Define the class that implements the RTP RPH Generic Audio filter.
// Contents : 
//*M*/


#ifndef _RPHGENA_H_
#define _RPHGENA_H_

#include <rph.h>

#define DEFAULT_MEDIABUF_NUM_GENA 9 // HUGEMEMORY 30->9
#define DEFAULT_TIMEOUT_GENA 0
#define DEFAULT_STALE_TIMEOUT_GENA 0
#define PAYLOAD_CLOCK_GENA 8000
#define AUDIO_PKT_SIZE 3500
#define DEFAULT_MEDIABUF_SIZE_GENA AUDIO_PKT_SIZE
#define NUM_PACKETS_GENA	9 // HUGEMEMORY 16->9
#define FRAMESPERSEC_GENA 50 //Use G.711 worst case as example

class CRPHGENA : public CRPHBase
{

public:

    static CUnknown *CreateInstance(LPUNKNOWN punk, HRESULT *phr);

    DECLARE_IUNKNOWN;

    virtual HRESULT CheckInputType(const CMediaType *mtIn);
    virtual HRESULT CheckTransform(const CMediaType *mtIn,const CMediaType *mtOut);
    virtual HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);
    virtual HRESULT GetInputMediaType(int iPosition, CMediaType *pMediaType);
	virtual HRESULT CompleteConnect(PIN_DIRECTION dir,IPin *pPin);
	virtual HRESULT GetAllocatorRequirements(ALLOCATOR_PROPERTIES *pProps);

    //IRTPRPHFilter methods
	virtual STDMETHODIMP SetOutputPinMediaType(AM_MEDIA_TYPE *pMediaPinType);
	virtual STDMETHODIMP GetOutputPinMediaType(AM_MEDIA_TYPE **ppMediaPinType);

	// CPersistStream methods
	virtual HRESULT ReadFromStream(IStream *pStream);
	virtual HRESULT WriteToStream(IStream *pStream);
	virtual int SizeMax(void);
	virtual HRESULT _stdcall GetClassID(CLSID *pCLSID);
	virtual DWORD GetSoftwareVersion(void);

    // Setup helper
    LPAMOVIESETUP_FILTER GetSetupData();

private:

    // Constructor
    CRPHGENA(TCHAR *tszName, LPUNKNOWN punk, HRESULT *phr);

    // Destructor
    ~CRPHGENA();

	virtual HRESULT SetPPMSession();

	AM_MEDIA_TYPE m_MediaPinType;

}; // CRPHGENA


#endif // _RPHGENA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\rphgenv\genvprop.h ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : genvprop.h
// Purpose  : Define the class that implements the RTP RPH
//            filter property page.
// Contents : 
//      class CRPHGENVPropertyPage
//*M*/

#ifndef _RPH_GENVPROP_H_
#define _RPH_GENVPROP_H_

//----------------------------------------------------------------------------
// RTP/RTCP: Registry information under:
//				HKEY_LOCAL_MACHINE\SOFTWARE\INTEL\ActiveMovie_Filters
//----------------------------------------------------------------------------

#define szRegAMRTPKey				TEXT("SOFTWARE\\Intel\\ActiveMovie Filters")

class 
CRPHGENVPropPage 
: public CBasePropertyPage
{
	
public:
    static CUnknown * WINAPI CreateInstance( LPUNKNOWN punk, HRESULT *phr );

protected:
    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate () ;
	HRESULT	OnDeactivate ();
    HRESULT OnApplyChanges();

    CRPHGENVPropPage( LPUNKNOWN punk, HRESULT *phr);

    BOOL OnInitDialog( void );
    BOOL OnCommand( int iButton, int iNotify, LPARAM lParam );

    void SetDirty();

protected:
	IRTPRPHFilter	*m_pIRTPRPHFilter;
    BOOL m_bIsInitialized;  // Will be false while we set init values in Dlg
	int				m_nActiveItems;
	BOOL			m_bMinorTypeScanned;
	AM_MEDIA_TYPE	*m_pMediaTypeVal;
};

#endif _GENVPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\rphgena\template.h ===
/*********************************************************************
 *
 * Copyright (c) 1997 Microsoft Corporation
 *
 * File: rph\rphgena\template.h
 *
 * Abstract:
 *     Macros to define CFactoryTemplate templates
 *
 * History:
 *     10/27/97    Created by AndresVG
 *
 **********************************************************************/
#if !defined(_RPHGENA_TEMPLATE_H_)
#define      _RPHGENA_TEMPLATE_H_

extern AMOVIESETUP_FILTER sudRPHGENA;
EXTERN_C const CLSID CLSID_INTEL_RPHGENA;
EXTERN_C const CLSID CLSID_INTEL_RPHGENA_PROPPAGE;
EXTERN_C const CLSID CLSID_INTEL_RPHGENA_MEDIATYPE_PROPPAGE;

#define RPH_FOR_GENA            L"Intel RTP RPH for Generic Audio"
#define RPH_FOR_GENA_PROP       L"Intel RTP RPH Property Page"
#define RPH_FOR_GENA_PROP_PAGE  L"Intel RTP RPH Generic Audio Property Page"

#define CFT_RPH_GENA_FILTER \
{ \
	  RPH_FOR_GENA, \
	  &CLSID_INTEL_RPHGENA, \
	  CRPHGENA::CreateInstance, \
	  NULL, \
	  &sudRPHGENA \
	  }

#define CFT_RPH_GENA_PROP \
{ \
	  RPH_FOR_GENA_PROP, \
	  &CLSID_INTEL_RPHGENA_PROPPAGE, \
	  CRPHGENPropPage::CreateInstance_gena \
	  }

#define CFT_RPH_GENA_PROP_PAGE \
{ \
	  RPH_FOR_GENA_PROP_PAGE, \
	  &CLSID_INTEL_RPHGENA_MEDIATYPE_PROPPAGE, \
	  CRPHGENAPropPage::CreateInstance \
	  }

#define CFT_RPHGENA_ALL_FILTERS \
CFT_RPH_GENA_FILTER, \
CFT_RPH_GENA_PROP, \
CFT_RPH_GENA_PROP_PAGE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\rphgenv\genvprop.cpp ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : genvprop.cpp
// Purpose  : RTP RPH Generic Video Property Page.
// Contents : 
//*M*/

#if !defined(NO_GENERIC_VIDEO)
#include <winsock2.h>
#include <streams.h>
#include <list.h>
#include <stack.h>
#include <ippm.h>
#include <amrtpuid.h>
#include <rph.h>
#include <ppmclsid.h>
#include <memory.h>
#include <resource.h>
#include <mmreg.h>
#include "genvprop.h"
#include "rphres.h"


CUnknown * WINAPI 
CRPHGENVPropPage::CreateInstance( 
    LPUNKNOWN punk, 
    HRESULT *phr )
{
    CRPHGENVPropPage *pNewObject
        = new CRPHGENVPropPage( punk, phr);

    if( pNewObject == NULL )
        *phr = E_OUTOFMEMORY;

    return pNewObject;
} /* CRPHGENVPropPage::CreateInstance() */


CRPHGENVPropPage::CRPHGENVPropPage( 
    LPUNKNOWN pUnk,
    HRESULT *phr)
    : CBasePropertyPage(NAME("Intel RPH OutputPin Controls"),pUnk,
        IDD_RPHGENV_RPHGENV_PROPPAGE, IDS_RPHGENV_RPHGEN_VIDEO)
    , m_pIRTPRPHFilter (NULL)
    , m_bIsInitialized(FALSE)
	, m_bMinorTypeScanned(FALSE)
	, m_nActiveItems(0)
{
    DbgLog((LOG_TRACE, 3, TEXT("CRPHGENVPropPage::CRPHGENVPropPage: Constructed at 0x%08x"), this));
} /* CRPHGENVPropPage::CRPHGENVPropPage() */

void 
CRPHGENVPropPage::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
    {
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
    }
} /* CRPHGENVPropPage::SetDirty() */

INT_PTR 
CRPHGENVPropPage::OnReceiveMessage(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    DbgLog((LOG_TRACE, 4, TEXT("CRPHGENVPropPage::OnReceiveMessage: Entered")));
    switch (uMsg) {
    case WM_INITDIALOG:
		return OnInitDialog();
		break;

    case WM_COMMAND:
        if (m_bIsInitialized) {
            if (OnCommand( (int) LOWORD( wParam ), (int) HIWORD( wParam ), lParam ) == TRUE) {
                return (LRESULT) 1;
            } /* if */
        } else {
			return(LRESULT) 1;
        } /* if */
        break;

	case WM_DESTROY:
		CRPHGENVPropPage::OnDeactivate();
		break;
    } /* switch */

    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
} /* CRPHGENVPropPage::OnReceiveMessage() */


HRESULT 
CRPHGENVPropPage::OnConnect(
    IUnknown    *pUnknown)
{
    DbgLog((LOG_TRACE, 4, TEXT("CRPHGENVPropPage::OnConnect: Entered")));
    ASSERT(m_pIRTPRPHFilter == NULL);
    DbgLog((LOG_TRACE, 2, TEXT("CRPHGENVPropPage::OnConnect: Called with IUnknown 0x%08x"), pUnknown));

	HRESULT hr = pUnknown->QueryInterface(IID_IRTPRPHFilter, (void **) &m_pIRTPRPHFilter);
	if(FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, TEXT("CRPHGENVPropPage::OnConnect: Error 0x%08x getting IRTPRPHFilter interface!"), hr));
	    return hr;
    } /* if */
	ASSERT( m_pIRTPRPHFilter != NULL );
    m_bIsInitialized = FALSE;
    DbgLog((LOG_TRACE, 3, TEXT("CRPHGENVPropPage::OnConnect: Got IRTPRPHFilter interface at 0x%08x"), m_pIRTPRPHFilter));

    return NOERROR;
} /* CRPHGENVPropPage::OnConnect() */


HRESULT 
CRPHGENVPropPage::OnDisconnect(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CRPHGENVPropPage::OnDisconnect: Entered")));

    if (m_pIRTPRPHFilter == NULL)
    {
        return E_UNEXPECTED;
    }

	m_pIRTPRPHFilter->Release();
	m_pIRTPRPHFilter = NULL;
    return NOERROR;
} /* CRPHGENVPropPage::OnDisconnect() */


HRESULT 
CRPHGENVPropPage::OnActivate(void)
{
	HKEY	hKey;
	HKEY	hTypeKey;
	HKEY	hSubtypeKey;
	long	lRes;
	char	keyBfr[50];
	DWORD	dwBufLen, dwIndex, nTypekeys, nTypeNameLen;
	DWORD	nSubtypekeys, nSubtypeNameLen, nMediaTypes;
	DWORD	nValueNameLen, dwData, dwValLen, nMediaTypeLen;
	DWORD	dwSubtypeIndex;
	HANDLE	hHeap;
	LPTSTR	lpTypeBuf;
	LPTSTR	lpSubtypeBuf;
	BYTE	*lpValBuf;
	HWND	hCurrentListbox;
	char	szMediaType[]="Video";
	int		iCurrentItem;
	int		i;
	BYTE	*lpTmpBuf;
	wchar_t	szCLSID[40];
	AM_MEDIA_TYPE *lpMediaTypeBuf;
	BYTE	*lpDataBuf;

    DbgLog((LOG_TRACE, 4, TEXT("CRPHGENVPropPage::OnActivate: Entered")));

    hCurrentListbox = GetDlgItem(m_hwnd, IDC_RPHGENV_OUTPUTPINLIST);

	// open the key
	strcpy (keyBfr, szRegAMRTPKey);
	lRes = RegOpenKeyEx (HKEY_LOCAL_MACHINE, keyBfr, 0, KEY_READ, &hKey);

	lRes = RegQueryInfoKey(hKey, NULL, NULL, NULL, &nTypekeys, &nTypeNameLen,
							NULL, NULL, NULL, NULL, NULL, NULL);
	// Allocate memory
	hHeap = GetProcessHeap();
	lpTypeBuf = (char *)HeapAlloc(hHeap, 0, ++nTypeNameLen);
	
	// Retrieve Registry values for the Media Types
	for (dwIndex = 0; dwIndex < nTypekeys; dwIndex++)
	{
		dwBufLen = nTypeNameLen;
		lRes = RegEnumKeyEx(hKey, dwIndex, lpTypeBuf, &dwBufLen, NULL, NULL, NULL, NULL);
		lRes = RegOpenKeyEx (hKey, lpTypeBuf, 0, KEY_READ, &hTypeKey);
		lRes = RegQueryInfoKey(hTypeKey, NULL, NULL, NULL, &nSubtypekeys, &nSubtypeNameLen,
								 NULL, NULL, NULL, &nValueNameLen, NULL, NULL);
		lpValBuf = (BYTE *)HeapAlloc(hHeap, 0, ++nValueNameLen);
		dwValLen = nValueNameLen;
		lRes = RegQueryValueEx(hTypeKey, "Media Type", NULL, &dwData, lpValBuf, &dwValLen);
		if(strncmp((char *)lpValBuf, szMediaType, dwValLen) == 0)
		{

			lpSubtypeBuf = (char *)HeapAlloc(hHeap,0, ++nSubtypeNameLen);
			for (dwSubtypeIndex = 0; dwSubtypeIndex < nSubtypekeys; dwSubtypeIndex++)
			{
				dwBufLen = nSubtypeNameLen;
				lRes = RegEnumKeyEx(hTypeKey, dwSubtypeIndex, lpSubtypeBuf,
										&dwBufLen, NULL, NULL, NULL, NULL);
				lRes = RegOpenKeyEx (hTypeKey, lpSubtypeBuf, 0, KEY_READ, &hSubtypeKey);
				lRes = RegQueryInfoKey(hSubtypeKey, NULL, NULL, NULL, NULL, NULL, NULL,
										&nMediaTypes, NULL, &nMediaTypeLen, NULL, NULL);
				iCurrentItem = SendMessage(hCurrentListbox, LB_ADDSTRING, 0,
											reinterpret_cast<LPARAM>(lpSubtypeBuf));

				lpMediaTypeBuf = (AM_MEDIA_TYPE *)HeapAlloc(hHeap, 0, sizeof(AM_MEDIA_TYPE));
				memset((void *)lpMediaTypeBuf, '\0', sizeof(AM_MEDIA_TYPE));
				lpTmpBuf = (BYTE *)HeapAlloc(hHeap, 0, ++nMediaTypeLen);
				memset(lpTmpBuf, '\0', nMediaTypeLen);
				// allocate a buffer for the PBFormat
				lpDataBuf = (BYTE *)HeapAlloc(hHeap, 0, nMediaTypeLen);
				memset(lpDataBuf, '\0', nMediaTypeLen);

				dwValLen = nMediaTypeLen;
				lRes = RegQueryValueEx(hSubtypeKey, "MajorType", NULL, &dwData,
											lpTmpBuf, &dwValLen);
				if(lRes == ERROR_SUCCESS)
				{
					i = mbstowcs(szCLSID, (char *)lpTmpBuf, 40);
					CLSIDFromString(szCLSID, &(lpMediaTypeBuf->majortype));
				}

				dwValLen = nMediaTypeLen;
				lRes = RegQueryValueEx(hSubtypeKey, "MinorType", NULL, &dwData,
											lpTmpBuf, &dwValLen);
				if(lRes == ERROR_SUCCESS)
				{
					i = mbstowcs(szCLSID, (char *)lpTmpBuf, 40);
					CLSIDFromString(szCLSID, &(lpMediaTypeBuf->subtype));
				}

				dwValLen = nMediaTypeLen;
				lRes = RegQueryValueEx(hSubtypeKey, "FixedSizeSamples", NULL, &dwData,
											lpTmpBuf, &dwValLen);
				if(lRes == ERROR_SUCCESS)
				{
					lpMediaTypeBuf->bFixedSizeSamples = *(BOOL *)lpTmpBuf;
				}
				
				dwValLen = nMediaTypeLen;
				lRes = RegQueryValueEx(hSubtypeKey, "TemporalCompression", NULL, &dwData,
											lpTmpBuf, &dwValLen);
				if(lRes == ERROR_SUCCESS)
				{
					lpMediaTypeBuf->bTemporalCompression = *(BOOL *)lpTmpBuf;
				}

				dwValLen = nMediaTypeLen;
				lRes = RegQueryValueEx(hSubtypeKey, "SampleSize", NULL, &dwData,
											lpTmpBuf, &dwValLen);
				if(lRes == ERROR_SUCCESS)
				{
					lpMediaTypeBuf->lSampleSize = *(ULONG *)lpTmpBuf;
				}
				
				dwValLen = nMediaTypeLen;
				lRes = RegQueryValueEx(hSubtypeKey, "FormatType", NULL, &dwData,
											lpTmpBuf, &dwValLen);
				if(lRes == ERROR_SUCCESS)
				{
					i = mbstowcs(szCLSID, (char *)lpTmpBuf, 40);
					CLSIDFromString(szCLSID, &(lpMediaTypeBuf->formattype));
				}

				dwValLen = nMediaTypeLen;
				lRes = RegQueryValueEx(hSubtypeKey, "PBFormat", NULL, &dwData,
											lpDataBuf, &dwValLen);
				if(lRes == ERROR_SUCCESS)
				{
					lpMediaTypeBuf->pbFormat = lpDataBuf;
					lpMediaTypeBuf->cbFormat = dwValLen;
				}
				SendMessage(hCurrentListbox, LB_SETITEMDATA, iCurrentItem,
								(LPARAM)lpMediaTypeBuf);
				// increment the number of active items in the Dialog Box
				// we'll use this to free the memory later.
				m_nActiveItems += 1;

				// ZCS fix 6-19-97: if this is the current output pin media type, make it selected.			
				AM_MEDIA_TYPE **ppMediaPinType = (AM_MEDIA_TYPE **)HeapAlloc(hHeap, 0, sizeof(AM_MEDIA_TYPE *));
				ASSERT(ppMediaPinType);
				if (SUCCEEDED(m_pIRTPRPHFilter->GetOutputPinMediaType(ppMediaPinType))
											&& ((*ppMediaPinType)->majortype == lpMediaTypeBuf->majortype)
											&& ((*ppMediaPinType)->subtype == lpMediaTypeBuf->subtype)) {
					SendMessage(hCurrentListbox, LB_SETCURSEL, iCurrentItem, 0);
				}
				CoTaskMemFree((*ppMediaPinType)->pbFormat);
				CoTaskMemFree(*ppMediaPinType);
				HeapFree(hHeap, 0, (void *)ppMediaPinType);

				HeapFree(hHeap, 0, lpTmpBuf);
			}
			// HeapFree and RegCloseKey here
			HeapFree(hHeap, 0, lpValBuf);
			RegCloseKey(hSubtypeKey);
			RegCloseKey(hTypeKey);
		}
		else
		{
			HeapFree(hHeap, 0, lpValBuf);
			RegCloseKey(hTypeKey);
		}
	}
	
	m_bIsInitialized = TRUE;

	HeapFree(hHeap, 0, lpTypeBuf);
	RegCloseKey(hKey);

    return NOERROR;
} /* CRPHGENVPropPage::OnActivate() */


HRESULT 
CRPHGENVPropPage::OnDeactivate(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CRPHGENVPropertyPage::OnDeactivate: Entered")));
    

	HANDLE hHeap;
	AM_MEDIA_TYPE   *pMediaTypeVal;
	HWND   hCurrentListbox = GetDlgItem(m_Dlg, IDC_RPHGENV_OUTPUTPINLIST);
	int	   i;

    if (m_pIRTPRPHFilter == NULL)
    {
        return E_UNEXPECTED;
    }

	hHeap = GetProcessHeap();

	for (i=0; i < m_nActiveItems; i++)
	{
		pMediaTypeVal = reinterpret_cast<AM_MEDIA_TYPE *>(SendMessage(hCurrentListbox, LB_GETITEMDATA, i, 0));
		HeapFree(hHeap, 0, (void*)pMediaTypeVal->pbFormat);
		HeapFree(hHeap, 0, (void*)pMediaTypeVal);
	}

	// Probably don't really need to do this as its likely the object is going
	// away .. but .. better safe than sorry
	m_nActiveItems = 0;

    return NOERROR;
} /* CRPHGENVPropertyPage::OnDeactivate() */


BOOL 
CRPHGENVPropPage::OnInitDialog(void)
{

   DbgLog((LOG_TRACE, 4, TEXT("CRPHGENVPropPage::OnInitDialog: Entered")));

   return (LRESULT) 1;
} /* CRPHGENVPropPage::OnInitDialog() */


BOOL 
CRPHGENVPropPage::OnCommand( 
    int     iButton, 
    int     iNotify,
    LPARAM  lParam)
{

    DbgLog((LOG_TRACE, 4, TEXT("CRPHGENVPropPage::OnCommand: Entered")));

	HWND hCurrentListbox;
	int iCurrentSel;

    switch( iButton ){
	case IDC_RPHGENV_OUTPUTPINLIST:
		if(iNotify == IDOK)
		{
			m_bMinorTypeScanned = TRUE;
			hCurrentListbox = GetDlgItem(m_Dlg, IDC_RPHGENV_OUTPUTPINLIST);
			iCurrentSel = SendMessage(hCurrentListbox, LB_GETCURSEL, 0, 0);
			m_pMediaTypeVal = reinterpret_cast<AM_MEDIA_TYPE *>(SendMessage(hCurrentListbox,
																			LB_GETITEMDATA,
																			iCurrentSel,
																			0));
			SetDirty();
		}
		break;
    default:
        break;
    } /* switch */	

    return (LRESULT) 1;
} /* CRPHGENVPropPage::OnCommand() */


HRESULT 
CRPHGENVPropPage::OnApplyChanges(void)
{
	HRESULT	hErr;

    DbgLog((LOG_TRACE, 4, TEXT("CRPHGENVPropPage::OnApplyChanges: Entered")));
    ASSERT( m_pIRTPRPHFilter != NULL );

    if (m_bMinorTypeScanned) {
		hErr = m_pIRTPRPHFilter->SetOutputPinMediaType(m_pMediaTypeVal);
        if (FAILED(hErr)) {
            DbgLog((LOG_ERROR, 1, TEXT("CRPHGENVPropPage::OnApplyChanges: SetOutputPinMediaType returned 0x%08X"),
                hErr));
        }
	}
	return(NOERROR);

} /* CRPHGENVPropPage::OnApplyChanges() */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\rphgenv\rphgenv.cpp ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : rphgenv.cpp
// Purpose  : RTP RPH Generic Video filter implementation.
// Contents : 
//*M*/
#if !defined(NO_GENERIC_VIDEO)
#include <winsock2.h>
#include <streams.h>
#include <list.h>
#include <stack.h>
#include <rtpclass.h>
#if !defined(RPH_IN_DXMRTP)
#include <initguid.h>
#define INITGUID
#endif
#include <ippm.h>
#include <amrtpuid.h>
#include <rphgenv.h>
#include <ppmclsid.h>
#include <ppmerr.h>
#include <memory.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <rphprop.h>
#include "genvprop.h"

#include "template.h"

// setup data

static const CLSID *pPropertyPageClsids[] =
{
        &CLSID_INTEL_RPHGENV_PROPPAGE,
		&CLSID_INTEL_RPHGENV_MEDIATYPE_PROPPAGE
};

#define NUMPROPERTYPAGES \
    (sizeof(pPropertyPageClsids)/sizeof(pPropertyPageClsids[0]))
 
static AMOVIESETUP_MEDIATYPE sudOutputPinTypes[] =
{
	{
		&MEDIATYPE_Video,        // Major type
		&MEDIASUBTYPE_NULL       // Minor type
	}
};

static AMOVIESETUP_MEDIATYPE sudInputPinTypes[] =
{
	{
		&MEDIATYPE_RTP_Single_Stream,       // Major type
		&MEDIASUBTYPE_RTP_Payload_ANY       // Minor type
	}
};

static AMOVIESETUP_PIN psudPins_genv[] =
{
    {
        L"Input",           // String pin name
        FALSE,              // Is it rendered
        FALSE,              // Is it an output
        FALSE,              // Allowed none
        FALSE,              // Allowed many
        &CLSID_NULL,        // Connects to filter
        L"Output",          // Connects to pin
        1,                  // Number of types
        (AMOVIESETUP_MEDIATYPE *)&sudInputPinTypes },// The pin details
      { L"Output",          // String pin name
        FALSE,              // Is it rendered
        TRUE,               // Is it an output
        FALSE,              // Allowed none
        FALSE,              // Allowed many
        &CLSID_NULL,        // Connects to filter
        L"Input",           // Connects to pin
        1,                  // Number of types
        (AMOVIESETUP_MEDIATYPE *)&sudOutputPinTypes  // The pin details
    }
};


AMOVIESETUP_FILTER sudRPHGENV =
{
    &CLSID_INTEL_RPHGENV,   // Filter CLSID
    L"Intel RTP RPH for Generic Video", // Filter name
    MERIT_DO_NOT_USE,       // Its merit
    2,                      // Number of pins
    psudPins_genv           // Pin details
};


// List of class IDs and creator functions for the class factory. This
// provides the link between the OLE entry point in the DLL and an object
// being created. The class factory will call the static CreateInstance

#if !defined(RPH_IN_DXMRTP)
CFactoryTemplate g_Templates[] = {
	CFT_RPHGENV_ALL_FILTERS
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);
#endif

//
// Constructor
//
CRPHGENV::CRPHGENV(TCHAR *tszName,LPUNKNOWN punk,HRESULT *phr) :
    CRPHBase(tszName, punk, phr, CLSID_INTEL_RPHGENV,
			 DEFAULT_MEDIABUF_NUM_GENV, 
			 DEFAULT_MEDIABUF_SIZE_GENV,
			 DEFAULT_TIMEOUT_GENV,
			 DEFAULT_STALE_TIMEOUT_GENV,
			 PAYLOAD_CLOCK_GENV,
			 FALSE,
			 FRAMESPERSEC_GENV,
			 NUMPROPERTYPAGES,
			 pPropertyPageClsids)
{
	
	DbgLog((LOG_TRACE,4,TEXT("CRPHGENV::CRPHGENV")));

    ASSERT(tszName);
    ASSERT(phr);

	//Setup our AM_MEDIATYPE structure
#if 1
	m_MediaPinType.majortype = MEDIATYPE_Video;
#else
    m_MediaPinType.majortype = MEDIATYPE_NULL;
#endif
	m_MediaPinType.subtype = MEDIASUBTYPE_NULL;
	m_MediaPinType.bFixedSizeSamples = FALSE;
	m_MediaPinType.bTemporalCompression = FALSE;
	m_MediaPinType.lSampleSize = 0;
	m_MediaPinType.formattype = FORMAT_VideoInfo;
//	m_MediaPinType.pUnk = (IUnknown *)this;
	m_MediaPinType.cbFormat = 0;
	m_MediaPinType.pbFormat = NULL;
	ZeroMemory(&m_Videoinfo, sizeof(VIDEOINFO));
	m_PPMCLSIDType = CLSID_GenPPMReceive;

} // CRPHGENV


//
// CreateInstance
//
// Provide the way for COM to create a CRPHGENV object
//
CUnknown *CRPHGENV::CreateInstance(LPUNKNOWN punk, HRESULT *phr) {
	
	DbgLog((LOG_TRACE,4,TEXT("CRPHGENV::CreateInstance")));


    CRPHGENV *pNewObject = new CRPHGENV(NAME("Intel RTP Receive Payload Handler for Generic Video"), punk, phr);
    if (pNewObject == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return pNewObject;

} // CreateInstance


//
// GetSetupData
//
// Returns registry information for this filter
//
LPAMOVIESETUP_FILTER CRPHGENV::GetSetupData()
{
    return &sudRPHGENV;

} // GetSetupData


//
// GetInputMediaType
//
// Return the supported Media types
//
HRESULT CRPHGENV::GetInputMediaType(int iPosition, CMediaType *pMediaType)
{
	
	DbgLog((LOG_TRACE,4,TEXT("CRPHAUD::GetInputMediaType")));

	if (iPosition != 0) 
    {
        return VFW_S_NO_MORE_ITEMS;
    }

    pMediaType->SetType(&MEDIATYPE_RTP_Single_Stream);
    
    return S_OK;
}

//
// CheckInputType
//
// Check the input type is OK, return an error otherwise
//
HRESULT CRPHGENV::CheckInputType(const CMediaType *mtIn)
{
	
	DbgLog((LOG_TRACE,4,TEXT("CRPHGENV::CheckInputType")));

	//Check major type first
    if (*mtIn->Type() == MEDIATYPE_RTP_Single_Stream) {
		return NOERROR;
	}

	//We don't support this major type
    return E_FAIL;

} // CheckInputType


//
// CheckTransform
//
// To be able to transform the formats must be compatical
//
HRESULT CRPHGENV::CheckTransform(const CMediaType *mtIn,const CMediaType *mtOut)
{
	
	DbgLog((LOG_TRACE,4,TEXT("CRPHGENV::CheckTransform")));

	//Check all supported minor types
	if ((*mtIn->Type() == MEDIATYPE_RTP_Single_Stream) && 
		(*mtOut->Subtype() == m_MediaPinType.subtype)) {
		return NOERROR;
	} 
    return E_FAIL;

} // CheckTransform


//
// GetAllocatorRequirements
//
// This is a hint to the upstream RTP source filter about the
// buffers to allocate.
//
HRESULT CRPHGENV::GetAllocatorRequirements(ALLOCATOR_PROPERTIES *pProps)
{
	if (!pProps) return E_POINTER;

	pProps->cBuffers = max(max((m_dwLostPacketTime/(1000/FRAMESPERSEC_GENV)),
							   NUM_PACKETS_GENV), 1); // HUGEMEMORY
	pProps->cbAlign = 0;
	pProps->cbPrefix = 0;
	pProps->cbBuffer = VIDEO_PKT_SIZE;

	return NOERROR;
}

//
// GetMediaType
//
// I support one type, based on the type set during SetOutputPinMediaType
// We must be connected to support the single output type
//
HRESULT CRPHGENV::GetMediaType(int iPosition, CMediaType *pMediaType)
{

	DbgLog((LOG_TRACE,4,TEXT("CRPHGENV::GetMediaType")));

    // Is the input pin connected

    if (m_pInput->IsConnected() == FALSE) {
        return E_UNEXPECTED;
    }

    // This should never happen

    if (iPosition < 0) {
        return E_INVALIDARG;
    }

    // Do we have more items to offer

    if (iPosition > 0) {
        return VFW_S_NO_MORE_ITEMS;
    }

    *pMediaType = m_pOutput->CurrentMediaType();
    return NOERROR;


} // GetMediaType


// CompleteConnect
// 
//
HRESULT
CRPHGENV::CompleteConnect(PIN_DIRECTION dir,IPin *pPin)
{
//lsc - We may not need this function at all, but we then need to override to return a noerror
	DbgLog((LOG_TRACE,4,TEXT("CRPHGENV::CompleteConnect")));

	return NOERROR;
}

// SetPPMSession
// This function is where PPM::SetSession is called and may be specific to payload
//  handler.  Minimum function is to set the payload type.
HRESULT CRPHGENV::SetPPMSession() 
{
	HRESULT hr;
	if (m_pPPMSession) {
		hr = m_pPPMSession->SetPayloadType(m_PayloadType);
		hr = m_pPPMSession->SetTimeoutDuration(m_dwLostPacketTime);
		return hr;
	} else {
		return E_FAIL;
	}
}

// GetOutputPinMediaType
// Gets the type of the output pin
// We don't expect to get called for this in other than the generic filters
//
HRESULT CRPHGENV::GetOutputPinMediaType(AM_MEDIA_TYPE **ppMediaPinType)
{
	AM_MEDIA_TYPE *pMediaPinType = NULL;
	DbgLog((LOG_TRACE,4,TEXT("CRPHGENV::GetOutputPinMediaType")));

	if (!ppMediaPinType) return E_POINTER;

	if (!(pMediaPinType = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE)))) 
		return E_OUTOFMEMORY;

	CopyMemory((void*)pMediaPinType, (void*)&m_MediaPinType,
		sizeof(AM_MEDIA_TYPE));
	
	if (!(pMediaPinType->pbFormat = (UCHAR *)CoTaskMemAlloc(m_MediaPinType.cbFormat))) {
		CoTaskMemFree(pMediaPinType);
		return E_OUTOFMEMORY;
	}

	CopyMemory((void*)pMediaPinType->pbFormat, (void*)m_MediaPinType.pbFormat,
		m_MediaPinType.cbFormat);

	*ppMediaPinType = pMediaPinType;
	return NOERROR;
}

// SetOutputPinMediaType
// Sets the type of the output pin
// Needs to be called before CheckTransform and the last CheckInputType to be useful
// We don't expect to get called for this in other than the generic filters
//
HRESULT CRPHGENV::SetOutputPinMediaType(AM_MEDIA_TYPE *pMediaPinType)
{
	DbgLog((LOG_TRACE,4,TEXT("CRPHGENV::SetOutputPinMediaType")));
    CAutoLock l(&m_cStateLock);

	if (!m_pOutput) return E_FAIL;
    if (!m_pInput->CurrentMediaType().IsValid()) return E_FAIL;

	if (m_pOutput->IsConnected() == TRUE) {
		return VFW_E_ALREADY_CONNECTED;
	}

#if 0
	if (!((pMediaPinType->subtype == ??) ||
	(pMediaPinType->subtype == ??) ||
	(pMediaPinType->subtype == ??))) {
		return VFW_E_INVALIDSUBTYPE;
	}
#endif

    SetDirty(TRUE); // So that our state will be saved if we are in a .grf    

	m_MediaPinType.majortype = pMediaPinType->majortype;
	m_MediaPinType.subtype = pMediaPinType->subtype;
	m_MediaPinType.bFixedSizeSamples = pMediaPinType->bFixedSizeSamples;
	m_MediaPinType.bTemporalCompression = pMediaPinType->bTemporalCompression;
	m_MediaPinType.lSampleSize = pMediaPinType->lSampleSize;
	m_MediaPinType.formattype = pMediaPinType->formattype;
//	m_MediaPinType.pUnk = (IUnknown *)this;
	if (pMediaPinType->formattype == FORMAT_VideoInfo) {
		m_MediaPinType.cbFormat = sizeof(VIDEOINFO);
		m_MediaPinType.pbFormat = (BYTE *)&m_Videoinfo;
		CopyMemory ((void*)m_MediaPinType.pbFormat,
			(void *)pMediaPinType->pbFormat, pMediaPinType->cbFormat);
	} else { //lsc may want to allocate the memory and copy this in, trusting...
		m_MediaPinType.pbFormat = NULL;
		m_MediaPinType.cbFormat = 0;
	}
	

	//We're going to set our own output pin media type

	m_pOutput->SetMediaType((CMediaType *)pMediaPinType);

	return NOERROR;
}


// CPersistStream methods

// ReadFromStream
// This is the call that will read persistent data from file
//
HRESULT CRPHGENV::ReadFromStream(IStream *pStream) 
{ 
	DbgLog((LOG_TRACE, 4, 
			TEXT("CRPHGENV::ReadFromStream")));
    if (mPS_dwFileVersion != 1) {
		DbgLog((LOG_ERROR, 2, 
				TEXT("CRPHGENV::ReadFromStream: Incompatible stream format")));
		return E_FAIL;
	}
	HRESULT hr;
	
	ULONG uBytesRead;

	hr = CRPHBase::ReadFromStream(pStream);
	if (FAILED(hr)) return hr;

    DbgLog((LOG_TRACE, 4, 
            TEXT("CRPHGENV::ReadFromStream: Loading media type")));

    AM_MEDIA_TYPE mt;
	VIDEOINFO format;

    hr = pStream->Read(&mt, sizeof(AM_MEDIA_TYPE), &uBytesRead);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRPHGENV::ReadFromStream: Error 0x%08x reading media type"),
                hr));
        return hr;
    } else if (uBytesRead != sizeof(AM_MEDIA_TYPE)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRPHGENV::ReadFromStream: Mismatch in (%d/%d) bytes read for media type"),
                uBytesRead, sizeof(AM_MEDIA_TYPE)));
        return E_INVALIDARG;
    } 

    mt.pbFormat = (UCHAR *) &format;
	mt.cbFormat = sizeof(format);

    // Read flag that indicates whether or not the media type has been set.
    BOOL fSet;
    hr = pStream->Read(&fSet, sizeof(BOOL), &uBytesRead);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRPHGENV::ReadFromStream: Error 0x%08x reading format flag"),
                hr));
        return hr;
    } else if (uBytesRead != sizeof(BOOL)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRPHGENV::ReadFromStream: Mismatch in (%d/%d) bytes read for format flag"),
                uBytesRead, sizeof(BOOL)));
        return E_INVALIDARG;
    } 

	// ZCS 6-30-97: My surgery in this section is all intended to allow the output
	// pin media type to be set when the graph is loaded from a file. None of this
	// should be attempted if the output pin type is GUID_NULL, because the code
	// below assumes that the filter will later be connected as part of the load-
	// from-file procedure. A non-GUID_NULL value can only occur if the filter
	// was connected when it was saved.

	if (fSet)
	{
        // MRC: Extended if clause to contain the pbFormat Block & corrected condition
        hr = pStream->Read(mt.pbFormat, mt.cbFormat, &uBytesRead);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 2, 
                    TEXT("CRPHGENV::ReadFromStream: Error 0x%08x reading media format buffer"),
                    hr));
            return hr;
        } else if (uBytesRead != mt.cbFormat) {
            DbgLog((LOG_ERROR, 2, 
                    TEXT("CRPHGENV::ReadFromStream: Mismatch in (%d/%d) bytes read for media format buffer"),
                    uBytesRead, mt.cbFormat));
            return E_INVALIDARG;
        } 

	    DbgLog((LOG_TRACE, 3, 
				TEXT("CRPHGENV::ReadFromStream: Restoring media type")));

		// ZCS 6-30-97: at this point we don't have any pins, so we can't set the output pin media type
		// just yet. Must first call GetPin(). Subsequent calls to GetPin() will be ok because it
		// doesn't allocate more pins as long as the original input and output pins are still there.
		EXECUTE_ASSERT(GetPin(0) != NULL);
	
		// ZCS 6-30-97:
		// In order for SetOutputPinMediaType() to succeed, the input pin must
		// have a major type that isn't GUID_NULL. This is a bit of subterfuge
		// to pretend we have an input pin major type -- the type doesn't matter as
		// long as it isn't GUID_NULL. We'll undo this shortly.
	
		GUID gTemp = MEDIATYPE_RTP_Single_Stream;
		m_pInput->CurrentMediaType().SetType(&gTemp);
	
        // At this point we can be pretty sure that mt.pUnk was valid.
        mt.pUnk = NULL;
		hr = SetOutputPinMediaType(&mt);

		// ZCS: we don't really have an input major type, so undo what we did...
		gTemp = GUID_NULL;
		m_pInput->CurrentMediaType().SetType(&gTemp);

		// now check if SetOutputPinMediaType failed...
	    if (FAILED(hr)) {
	        DbgLog((LOG_ERROR, 2, 
	                TEXT("CRPHGENV::ReadFromStream: Error 0x%08x setting media type"),
	                hr));
		
			return hr;
	    }  /* if */
	} /* if */

	return NOERROR; 
}

// WriteToStream
// This is the call that will write persistent data to file
//
HRESULT CRPHGENV::WriteToStream(IStream *pStream) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("CRPHGENV::WriteToStream")));
	
	HRESULT hr;
    ULONG uBytesWritten = 0;

	hr = CRPHBase::WriteToStream(pStream);
	if (FAILED(hr)) return hr;

    DbgLog((LOG_TRACE, 4, 
            TEXT("CRPHGENV::WriteToStream: Writing media type")));

	hr = pStream->Write(&m_MediaPinType, sizeof(AM_MEDIA_TYPE), &uBytesWritten);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRPHGENV::WriteToStream: Error 0x%08x reading media type"),
                hr));
        return hr;
    } else if (uBytesWritten != sizeof(AM_MEDIA_TYPE)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRPHGENV::WriteToStream: Mismatch in (%d/%d) bytes read for media type"),
                uBytesWritten, sizeof(AM_MEDIA_TYPE)));
        return E_INVALIDARG;
    }

    BOOL fSet;
    if (m_MediaPinType.pbFormat != NULL)
    {
        // Write a flag to indicate whether or not the media type has been set.
        fSet = TRUE;
        hr = pStream->Write(&fSet, sizeof(BOOL), &uBytesWritten);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 2,
                    TEXT("CRPHGENV::WriteToStream: Error 0x%08x writing format flag"),
                    hr));
            return hr;
        } else if (uBytesWritten != sizeof(BOOL)) {
            DbgLog((LOG_ERROR, 2, 
                    TEXT("CRPHGENV::WriteToStream: Mismatch in (%d/%d) bytes written for format flag"),
                    uBytesWritten, sizeof(BOOL)));
            return E_INVALIDARG;
        }

        // Now write the media format
        hr = pStream->Write(m_MediaPinType.pbFormat, m_MediaPinType.cbFormat, &uBytesWritten);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 2, 
                    TEXT("CRPHGENV::WriteToStream: Error 0x%08x writing media format buffer"),
                    hr));
            return hr;
        } else if (uBytesWritten != m_MediaPinType.cbFormat) {
            DbgLog((LOG_ERROR, 2, 
                    TEXT("CRPHGENV::WriteToStream: Mismatch in (%d/%d) bytes written for media format buffer"),
                    uBytesWritten, m_MediaPinType.cbFormat));
            return E_INVALIDARG;
        } 
    }
    else
    {
        // Write a flag to indicate whether or not the media type has been set.
        fSet = FALSE;
        hr = pStream->Write(&fSet, sizeof(BOOL), &uBytesWritten);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 2,
                    TEXT("CRPHGENV::WriteToStream: Error 0x%08x writing format flag"),
                    hr));
            return hr;
        } else if (uBytesWritten != sizeof(BOOL)) {
            DbgLog((LOG_ERROR, 2, 
                    TEXT("CRPHGENV::WriteToStream: Mismatch in (%d/%d) bytes written for format flag"),
                    uBytesWritten, sizeof(BOOL)));
            return E_INVALIDARG;
        }
    }

	return NOERROR; 
}

// SizeMax
// This returns the amount of storage space required for my persistent data
//
int CRPHGENV::SizeMax(void) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("CRPHGENV::SizeMax")));
	
	return CRPHBase::SizeMax()
        + sizeof(AM_MEDIA_TYPE)
		+ sizeof(VIDEOINFO); 
}

// GetClassID
// This function returns my CLSID  
//  
HRESULT _stdcall CRPHGENV::GetClassID(CLSID *pCLSID) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("CRPHGENV::GetClassID")));
	
	if (!pCLSID)
		return E_POINTER;
	*pCLSID = CLSID_INTEL_RPHGENV;
	return NOERROR; 
}

// GetSoftwareVersion
// This returns the version of this filter to be stored with the persistent data
//
DWORD CRPHGENV::GetSoftwareVersion(void) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("CRPHGENV::GetSoftwareVersion")));
	
	return 1; 
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\rphgenv\rphgenv.h ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : rphgenv.h
// Purpose  : Define the class that implements the RTP RPH Generic Video filter.
// Contents : 
//*M*/


#ifndef _RPHGENV_H_
#define _RPHGENV_H_

#include <rph.h>

#define DEFAULT_MEDIABUF_SIZE_GENV 33000
#define DEFAULT_MEDIABUF_NUM_GENV 9 // HUGEMEMORY 10->9
#define DEFAULT_TIMEOUT_GENV 0
#define DEFAULT_STALE_TIMEOUT_GENV 200
#define PAYLOAD_CLOCK_GENV 90000
#define VIDEO_PKT_SIZE 1500 // HUGEMEMORY 8192->1500
#define NUM_PACKETS_GENV   9 // HUGEMEMORY 128->9
#define FRAMESPERSEC_GENV 20

class CRPHGENV : public CRPHBase
{

public:

    static CUnknown *CreateInstance(LPUNKNOWN punk, HRESULT *phr);

    DECLARE_IUNKNOWN;

    virtual HRESULT CheckInputType(const CMediaType *mtIn);
    virtual HRESULT CheckTransform(const CMediaType *mtIn,const CMediaType *mtOut);
    virtual HRESULT GetInputMediaType(int iPosition, CMediaType *pMediaType);
    virtual HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);
	virtual HRESULT CompleteConnect(PIN_DIRECTION dir,IPin *pPin);
	virtual HRESULT GetAllocatorRequirements(ALLOCATOR_PROPERTIES *pProps);

    //IRTPRPHFilter methods
	virtual STDMETHODIMP SetOutputPinMediaType(AM_MEDIA_TYPE *pMediaPinType);
	virtual STDMETHODIMP GetOutputPinMediaType(AM_MEDIA_TYPE **ppMediaPinType);

	// CPersistStream methods
	virtual HRESULT ReadFromStream(IStream *pStream);
	virtual HRESULT WriteToStream(IStream *pStream);
	virtual int SizeMax(void);
	virtual HRESULT _stdcall GetClassID(CLSID *pCLSID);
	virtual DWORD GetSoftwareVersion(void);

    // Setup helper
    LPAMOVIESETUP_FILTER GetSetupData();

private:

    // Constructor
    CRPHGENV(TCHAR *tszName, LPUNKNOWN punk, HRESULT *phr);
	virtual HRESULT SetPPMSession();

	AM_MEDIA_TYPE m_MediaPinType;
	VIDEOINFO m_Videoinfo;

}; // CRPHGENV


#endif // _RPHGENV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\rphgenv\template.h ===
/*********************************************************************
 *
 * Copyright (c) 1997 Microsoft Corporation
 *
 * File: rph\rphgenv\template.h
 *
 * Abstract:
 *     Macros to define CFactoryTemplate templates
 *
 * History:
 *     10/27/97    Created by AndresVG
 *
 **********************************************************************/
#if !defined(_RPHGENV_TEMPLATE_H_)
#define      _RPHGENV_TEMPLATE_H_

extern AMOVIESETUP_FILTER sudRPHGENV;
EXTERN_C const CLSID CLSID_INTEL_RPHGENV;
EXTERN_C const CLSID CLSID_INTEL_RPHGENV_PROPPAGE;
EXTERN_C const CLSID CLSID_INTEL_RPHGENV_MEDIATYPE_PROPPAGE;

#define RPH_FOR_GENV               L"Intel RTP RPH for Generic Video"
#define RPH_FOR_GENV_PROP          L"Intel RTP RPH Property Page"
#define RPH_FOR_GENV_PROP_PAGE     L"Intel RTP RPH Generic Video Property Page"

#define CFT_RPHGENV_FILTER \
{ \
	  RPH_FOR_GENV, \
	  &CLSID_INTEL_RPHGENV, \
	  CRPHGENV::CreateInstance, \
	  NULL, \
	  &sudRPHGENV \
	  }

#define CFT_RPHGENV_PROP \
{ \
	  RPH_FOR_GENV_PROP, \
	  &CLSID_INTEL_RPHGENV_PROPPAGE, \
	  CRPHGENPropPage::CreateInstance_genv \
	  }

#define CFT_RPHGENV_PROP_PAGE \
{ \
	  RPH_FOR_GENV_PROP_PAGE, \
	  &CLSID_INTEL_RPHGENV_MEDIATYPE_PROPPAGE, \
	  CRPHGENVPropPage::CreateInstance \
	  }

#define CFT_RPHGENV_ALL_FILTERS \
CFT_RPHGENV_FILTER, \
CFT_RPHGENV_PROP, \
CFT_RPHGENV_PROP_PAGE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\rphh26x\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_RPHH26X                     3
#define IDC_H26XCIF                     1004
#define IDC_H26XQCIF                    1005
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\rphh26x\rphh26x.cpp ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : rphh26x.cpp
// Purpose  : RTP RPH H.26x Video filter implementation.
// Contents : 
//*M*/

#include <winsock2.h>
#include <streams.h>
#include <list.h>
#include <stack.h>
#include <rtpclass.h>
#if !defined(RPH_IN_DXMRTP)
#include <initguid.h>
#define INITGUID
#endif
#include <ippm.h>
#include <amrtpuid.h>
#include <rphh26x.h>
#include <ih26xcd.h>
#include <ppmclsid.h>
#include <ppmerr.h>
#include <memory.h>
#include <mmsystem.h>
#include <rphprop.h>
#include <rphprop2.h>

#include "template.h"

// setup data
EXTERN_C const CLSID CLSID_INTEL_RPHH26X;
EXTERN_C const CLSID CLSID_INTEL_RPHH26X_PROPPAGE;
EXTERN_C const CLSID CLSID_INTEL_RPHH26X1_PROPPAGE;

static const CLSID *pPropertyPageClsids[] =
{
	&CLSID_INTEL_RPHH26X_PROPPAGE,
    &CLSID_INTEL_RPHH26X1_PROPPAGE
};

#define NUMPROPERTYPAGES \
    (sizeof(pPropertyPageClsids)/sizeof(pPropertyPageClsids[0]))

static AMOVIESETUP_MEDIATYPE sudOutputPinTypes[] =
{
	{
		&MEDIATYPE_Video,       // Major type
		&MEDIASUBTYPE_H263EX    // Minor type
	},
	{
		&MEDIATYPE_Video,       // Major type
		&MEDIASUBTYPE_H261EX    // Minor type
	},
	{
		&MEDIATYPE_Video,       // Major type
		&MEDIASUBTYPE_H263      // Minor type
	},
	{
		&MEDIATYPE_Video,       // Major type
		&MEDIASUBTYPE_H261      // Minor type
	}
};

static AMOVIESETUP_MEDIATYPE sudInputPinTypes[] =
{
	{
		&MEDIATYPE_RTP_Single_Stream,       // Major type
		&MEDIASUBTYPE_RTP_Payload_H263      // Minor type
	},
	{
		&MEDIATYPE_RTP_Single_Stream,       // Major type
		&MEDIASUBTYPE_RTP_Payload_H261      // Minor type
	}
};

static AMOVIESETUP_PIN psudPins[] =
{
    {
        L"Input",           // String pin name
        FALSE,              // Is it rendered
        FALSE,              // Is it an output
        FALSE,              // Allowed none
        FALSE,              // Allowed many
        &CLSID_NULL,        // Connects to filter
        L"Output",          // Connects to pin
        2,                  // Number of types
        (AMOVIESETUP_MEDIATYPE *)&sudInputPinTypes },// The pin details
      { L"Output",          // String pin name
        FALSE,              // Is it rendered
        TRUE,               // Is it an output
        FALSE,              // Allowed none
        FALSE,              // Allowed many
        &CLSID_NULL,        // Connects to filter
        L"Input",           // Connects to pin
        4,                  // Number of types
        (AMOVIESETUP_MEDIATYPE *)&sudOutputPinTypes  // The pin details
    }
};


AMOVIESETUP_FILTER sudRPHH26X =
{
    &CLSID_INTEL_RPHH26X,   // Filter CLSID
    L"Intel RTP RPH for H.263/H.261", // Filter name
    MERIT_DO_NOT_USE, //MERIT_UNLIKELY,         // Its merit
    2,                      // Number of pins
    psudPins                // Pin details
};


// List of class IDs and creator functions for the class factory. This
// provides the link between the OLE entry point in the DLL and an object
// being created. The class factory will call the static CreateInstance

#if !defined(RPH_IN_DXMRTP)
CFactoryTemplate g_Templates[] = {
	CFT_RPHH26X_ALL_FILTERS
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);
#endif

//
// Constructor
//
CRPHH26X::CRPHH26X(TCHAR *tszName,LPUNKNOWN punk,HRESULT *phr) :
    CRPHBase(tszName, punk, phr, CLSID_INTEL_RPHH26X,
			 DEFAULT_MEDIABUF_NUM_H26X, 
			 DEFAULT_MEDIABUF_SIZE_H26X,
			 DEFAULT_TIMEOUT_H26X,
			 DEFAULT_STALE_TIMEOUT_H26X,
			 PAYLOAD_CLOCK_H26X,
			 FALSE,
			 FRAMESPERSEC_H26X,
			 NUMPROPERTYPAGES,
			 pPropertyPageClsids)
{
	DbgLog((LOG_TRACE,4,TEXT("CRPHH26X::CRPHH26X")));

    ASSERT(tszName);
    ASSERT(phr);
	m_bCIF = TRUE;

} // SPHH26X


//
// NonDelegatingQueryInterface
//
// Reveals IRPHH26XSettings
//
STDMETHODIMP CRPHH26X::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    CheckPointer(ppv,E_POINTER);

    if (riid == IID_IRPHH26XSettings) {
        return GetInterface((IRPHH26XSettings *) this, ppv);
    } else {
        return CRPHBase::NonDelegatingQueryInterface(riid, ppv);
    }

} // NonDelegatingQueryInterface


//
// CreateInstance
//
// Provide the way for COM to create a CRPHH26X object
//
CUnknown *CRPHH26X::CreateInstance(LPUNKNOWN punk, HRESULT *phr) {
	
	DbgLog((LOG_TRACE,4,TEXT("CRPHH26X::CreateInstance")));


    CRPHH26X *pNewObject = new CRPHH26X(NAME("Intel RTP Receive Payload Handler for H26X"), punk, phr);
    if (pNewObject == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return pNewObject;

} // CreateInstance


//
// GetSetupData
//
// Returns registry information for this filter
//
LPAMOVIESETUP_FILTER CRPHH26X::GetSetupData()
{
    return &sudRPHH26X;

} // GetSetupData


//
// GetInputMediaType
//
// Return the supported Media types
//
HRESULT CRPHH26X::GetInputMediaType(int iPosition, CMediaType *pMediaType)
{
	
	DbgLog((LOG_TRACE,4,TEXT("CRPHAUD::GetInputMediaType")));

	if (!m_bPTSet) 
    {
        return VFW_S_NO_MORE_ITEMS;
    }

	if (iPosition != 0) 
    {
        return VFW_S_NO_MORE_ITEMS;
    }

    pMediaType->SetType(&MEDIATYPE_RTP_Single_Stream);
    
    switch (m_PayloadType)
    {
    case H263_PT:
        pMediaType->SetSubtype(&MEDIASUBTYPE_RTP_Payload_H263);
        break;
    
    case H261_PT:
        pMediaType->SetSubtype(&MEDIASUBTYPE_RTP_Payload_H261);
        break;
    
    default:
        return VFW_S_NO_MORE_ITEMS;
    }
    return S_OK;
}

//
// CheckInputType
//
// Check the input type is OK, return an error otherwise
//
HRESULT CRPHH26X::CheckInputType(const CMediaType *mtIn)
{

	DbgLog((LOG_TRACE,4,TEXT("CRPHH26X::CheckInputType")));

	//Check major type first
    if (*mtIn->Type() == MEDIATYPE_RTP_Single_Stream) {
		//Check all supported minor types
		if (*mtIn->Subtype() == MEDIASUBTYPE_RTP_Payload_H263) {
			m_PPMCLSIDType = CLSID_H263PPMReceive;
			if (!m_bPTSet) m_PayloadType = H263_PT;
			return NOERROR;
		} 
		if (*mtIn->Subtype() == MEDIASUBTYPE_RTP_Payload_H261) {
			m_PPMCLSIDType = CLSID_H261PPMReceive;
			if (!m_bPTSet) m_PayloadType = H261_PT;
			return NOERROR;
		}
		//Otherwise, we don't support this input subtype
		return E_INVALIDARG;
	}

	//We don't support this major type
    return E_FAIL;

} // CheckInputType


//
// CheckTransform
//
// To be able to transform the formats must be identical
//
HRESULT CRPHH26X::CheckTransform(const CMediaType *mtIn,const CMediaType *mtOut)
{

	DbgLog((LOG_TRACE,4,TEXT("CRPHH26X::CheckTransform")));

	if ((*mtIn->Subtype() == MEDIASUBTYPE_RTP_Payload_H263)) {
		DbgLog((LOG_TRACE,2,TEXT("CRPHH26X::CheckTransform gets input type of h263 payload")));
	}
	if ((*mtOut->Subtype() == MEDIASUBTYPE_H263)) {
		DbgLog((LOG_TRACE,2,TEXT("CRPHH26X::CheckTransform gets output type of h263")));
	}
	if ((*mtOut->Subtype() == MEDIASUBTYPE_H263EX)) {
		DbgLog((LOG_TRACE,2,TEXT("CRPHH26X::CheckTransform gets output type of h263ex")));
	}

	//Check all supported minor types
	if ((*mtIn->Subtype() == MEDIASUBTYPE_RTP_Payload_H263) && 
		((*mtOut->Subtype() == MEDIASUBTYPE_H263EX) ||
		(*mtOut->Subtype() == MEDIASUBTYPE_H263))) {
		return NOERROR;
	} 
	if ((*mtIn->Subtype() == MEDIASUBTYPE_RTP_Payload_H261) && 
		((*mtOut->Subtype() == MEDIASUBTYPE_H261EX) ||
		(*mtOut->Subtype() == MEDIASUBTYPE_H261))) {
		return NOERROR;
	} 
    return E_FAIL;

} // CheckTransform


//
// GetAllocatorRequirements
//
// This is a hint to the upstream RTP source filter about the
// buffers to allocate.
//
HRESULT CRPHH26X::GetAllocatorRequirements(ALLOCATOR_PROPERTIES *pProps)
{
	if (!pProps) return E_POINTER;

	pProps->cBuffers = max(max((m_dwLostPacketTime/(1000/FRAMESPERSEC_H26X)),
							   NUM_PACKETS_H26X), 1); // HUGEMEMORY
	pProps->cbAlign = 0;
	pProps->cbPrefix = 0;
	pProps->cbBuffer = H26X_PKT_SIZE;

	return NOERROR;

}

//
// GetMediaType
//
// I support two types, based on the type of the input pin
// We must be connected to support the single output type
//
HRESULT CRPHH26X::GetMediaType(int iPosition, CMediaType *pMediaType)
{

	DbgLog((LOG_TRACE,4,TEXT("CRPHH26X::GetMediaType")));
	DbgLog((LOG_TRACE,4,TEXT("CRPHH26X::GetMediaType, position %d"), iPosition));

	
	// Is the input pin connected

    if (m_pInput->IsConnected() == FALSE) {
        return E_UNEXPECTED;
    }

    // This should never happen

    if (iPosition < 0) {
        return E_INVALIDARG;
    }

	const GUID mtguid = MEDIATYPE_Video;
	const GUID vFormatGuid = FORMAT_VideoInfo;

	CMediaType mtOut(&mtguid);
	VIDEOINFO vformat;

	ZeroMemory(&vformat, sizeof(VIDEOINFO));
    mtOut.SetVariableSize();
	mtOut.SetFormatType(&vFormatGuid);
	if (m_bCIF) {
		SetRect(&vformat.rcSource, 0, 0, 352, 288);
		SetRect(&vformat.rcTarget, 0, 0, 352, 288);
		vformat.bmiHeader.biWidth = 352;
		vformat.bmiHeader.biHeight = 288;
	} else {
		SetRect(&vformat.rcSource, 0, 0, 176, 144);
		SetRect(&vformat.rcTarget, 0, 0, 176, 144);
		vformat.bmiHeader.biWidth = 176;
		vformat.bmiHeader.biHeight = 144;
	}
	vformat.dwBitRate = 0;
	vformat.dwBitErrorRate = 0L;
	vformat.AvgTimePerFrame = 0;
	vformat.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
	vformat.bmiHeader.biPlanes = 1;

    // Do we have more items to offer

	if (iPosition == 0) {
		if (m_PPMCLSIDType == CLSID_H263PPMReceive) {  //H263 first choice

			DbgLog((LOG_TRACE,2,TEXT("CRPHH26X::GetMediaType - H.263 payload input, trying H263EX out")));

			const GUID v263guid = MEDIASUBTYPE_H263EX;
			//set output pin type
			mtOut.SetSubtype(&v263guid);
			mtOut.SetTemporalCompression(TRUE);
			vformat.bmiHeader.biBitCount = 24;
			vformat.bmiHeader.biCompression = 0x33363248;  //H263
			vformat.bmiHeader.biSizeImage = 304128;
			mtOut.SetFormat((BYTE*)&vformat, sizeof(vformat));
			m_pOutput->SetMediaType(&mtOut);
			*pMediaType = mtOut;
		} else { //H261 first choice
			const GUID v261guid = MEDIASUBTYPE_H261EX;
			//set output pin type
			mtOut.SetSubtype(&v261guid);
			mtOut.SetTemporalCompression(FALSE);
			vformat.bmiHeader.biBitCount = 16;
			vformat.bmiHeader.biCompression = 0x31363248;  //H261
			vformat.bmiHeader.biSizeImage = 36864;
			mtOut.SetFormat((BYTE*)&vformat, sizeof(vformat));
			m_pOutput->SetMediaType(&mtOut);
			*pMediaType = mtOut;
		}
	}

	if (iPosition == 1) {
		if (m_PPMCLSIDType == CLSID_H263PPMReceive) {  //H263 second choice

			DbgLog((LOG_TRACE,2,TEXT("CRPHH26X::GetMediaType - H.263 payload input, trying H263 out")));

			const GUID v263guid = MEDIASUBTYPE_H263;
			//set output pin type
			mtOut.SetSubtype(&v263guid);
			mtOut.SetTemporalCompression(TRUE);
			vformat.bmiHeader.biBitCount = 24;
			vformat.bmiHeader.biCompression = 0x33363248;  //H263
			vformat.bmiHeader.biSizeImage = 304128;
			mtOut.SetFormat((BYTE*)&vformat, sizeof(vformat));
			m_pOutput->SetMediaType(&mtOut);
			*pMediaType = mtOut;
		} else { //H261 second choice
			const GUID v261guid = MEDIASUBTYPE_H261;
			//set output pin type
			mtOut.SetSubtype(&v261guid);
			mtOut.SetTemporalCompression(FALSE);
			vformat.bmiHeader.biBitCount = 16;
			vformat.bmiHeader.biCompression = 0x31363248;  //H261
			vformat.bmiHeader.biSizeImage = 36864;
			mtOut.SetFormat((BYTE*)&vformat, sizeof(vformat));
			m_pOutput->SetMediaType(&mtOut);
			*pMediaType = mtOut;
		}
	}

    if (iPosition > 1) {
        return VFW_S_NO_MORE_ITEMS;
    }

    return NOERROR;

} // GetMediaType


// CompleteConnect
// This function is overridden so that the RTP support interface from the codec
//   can be retrieved and the extended bitstream generation turned on
//
HRESULT
CRPHH26X::CompleteConnect(PIN_DIRECTION dir,IPin *pPin)
{

	DbgLog((LOG_TRACE,4,TEXT("CRPHH26X::CompleteConnect")));

	if (dir == PINDIR_OUTPUT) {
		PIN_INFO InputPinInfo;
		HRESULT hr;

		CMediaType mtOut = m_pOutput->CurrentMediaType();
		if(!((*mtOut.Subtype() == MEDIASUBTYPE_H263EX) || 
			(*mtOut.Subtype() == MEDIASUBTYPE_H261EX))) {

			IH26XRTPControl *pRTPif;

			//get the info structure for the output pin of the decoder
			hr = pPin->QueryPinInfo(&InputPinInfo);
			if (FAILED(hr)) return E_FAIL;
			//query the filter interface for its RTP interface
			hr = InputPinInfo.pFilter->QueryInterface(IID_IH26XVideoEffects, (void **) &pRTPif);
            InputPinInfo.pFilter->Release();
			if (FAILED(hr)) {

				DbgLog((LOG_TRACE,5,TEXT("CRPHH26X::CompleteConnect QueryInterface for IID_IH26XVideoEffects failed")));

				m_bRTPCodec = FALSE;
			} else {
				m_bRTPCodec = TRUE;
				if (pRTPif) pRTPif->Release();
			}
		}

	} 
	return NOERROR;
}

// SetPPMSession
// This function is where PPM::SetSession is called and may be specific to payload
//  handler.  Minimum function is to set the payload type.
HRESULT CRPHH26X::SetPPMSession() 
{
	HRESULT hr;
	if (m_pPPMSession) {
		if (m_bRTPCodec) {  // set resiliency (partial frames) on or off in PPM
			hr = m_pPPMSession->SetResiliency(TRUE);
		} else {
			hr = m_pPPMSession->SetResiliency(FALSE);
		}
		hr = m_pPPMSession->SetPayloadType((unsigned char)m_PayloadType);
		hr = m_pPPMSession->SetTimeoutDuration(m_dwLostPacketTime);
		return hr;
	} else {
		return E_FAIL;
	}
}


//IRPHH26XSettings functions
// SetCIF
// This function is where CIF or QCIF format boolean is set.  
//  The boolean is used in GetMediaType.
HRESULT CRPHH26X::SetCIF(BOOL bCIF)
{
    CAutoLock l(&m_cStateLock);
    SetDirty(TRUE); // So that our state will be saved if we are in a .grf    

	m_bCIF = bCIF;
	return NOERROR;
}

// GetCIF
// This function retrieves the boolean which indicates TRUE = CIF (352x288) or FALSE = QCIF (176x144) format 
// for the picture size.
HRESULT CRPHH26X::GetCIF(BOOL *lpbCIF)
{
    CAutoLock l(&m_cStateLock);

	if (!lpbCIF) return E_POINTER;

	*lpbCIF = m_bCIF;
	return NOERROR;
}

// CPersistStream methods

// ReadFromStream
// This is the call that will read persistent data from file
//
HRESULT CRPHH26X::ReadFromStream(IStream *pStream) 
{ 
	DbgLog((LOG_TRACE, 4, TEXT("CRPHH26X::ReadFromStream")));
    if (mPS_dwFileVersion != 1) {
		DbgLog((LOG_ERROR, 2, 
				TEXT("CRPHH26X::ReadFromStream: Incompatible stream format")));
		return E_FAIL;
	}
	HRESULT hr;
	
	BOOL bCIF;
	ULONG uBytesRead;

	hr = CRPHBase::ReadFromStream(pStream);
	if (FAILED(hr)) return hr;

	DbgLog((LOG_TRACE, 4, 
			TEXT("CRPHH26X::ReadFromStream: Loading format type")));
	hr = pStream->Read(&bCIF, sizeof(bCIF), &uBytesRead);
	if (FAILED(hr)) {
		DbgLog((LOG_ERROR, 2, 
				TEXT("CRPHH26X::ReadFromStream: Error 0x%08x reading format type"),
				hr));
		return hr;
	} else if (uBytesRead != sizeof(int)) {
		DbgLog((LOG_ERROR, 2, 
				TEXT("CRPHH26X::ReadFromStream: Mismatch in (%d/%d) bytes read for format type"),
				uBytesRead, sizeof(int)));
		return E_INVALIDARG;
	}
	DbgLog((LOG_TRACE, 4, 
			TEXT("CRPHH26X::ReadFromStream: Restoring format type")));
	hr = SetCIF(bCIF);
	if (FAILED(hr)) {
		DbgLog((LOG_ERROR, 2, 
				TEXT("CRPHH26X::ReadFromStream: Error 0x%08x restoring format type"),
				hr));
	}

	return NOERROR; 
}

// WriteToStream
// This is the call that will write persistent data to file
//
HRESULT CRPHH26X::WriteToStream(IStream *pStream) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("CRPHH26X::WriteToStream")));
	
	HRESULT hr;
    ULONG uBytesWritten = 0;

	hr = CRPHBase::WriteToStream(pStream);
	if (FAILED(hr)) return hr;

    DbgLog((LOG_TRACE, 4, 
            TEXT("CRPHH26X::WriteToStream: Writing format type")));
    hr = pStream->Write(&m_bCIF, sizeof(m_bCIF), &uBytesWritten);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRPHH26X::WriteToStream: Error 0x%08x writing format type"),
                hr));
        return hr;
    } else if (uBytesWritten != sizeof(m_bCIF)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRPHH26X::WriteToStream: Mismatch in (%d/%d) bytes written for format type"),
                uBytesWritten, sizeof(m_bCIF)));
        return E_INVALIDARG;
    } /* if */

	return NOERROR; 
}

// SizeMax
// This returns the amount of storage space required for my persistent data
//
int CRPHH26X::SizeMax(void) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("CRPHH26X::SizeMax")));
	
	return CRPHBase::SizeMax()
		+ sizeof(m_bCIF); 
}

// GetClassID
// This function returns my CLSID  
//  
HRESULT _stdcall CRPHH26X::GetClassID(CLSID *pCLSID) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("CRPHH26X::GetClassID")));
	
	if (!pCLSID)
		return E_POINTER;
	*pCLSID = CLSID_INTEL_RPHH26X;
	return NOERROR; 
}

// GetSoftwareVersion
// This returns the version of this filter to be stored with the persistent data
//
DWORD CRPHH26X::GetSoftwareVersion(void) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("CRPHH26X::GetSoftwareVersion")));
	
	return 1; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\rphh26x\rphprop2.h ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : RPHProp2.h
// Purpose  : Define the class that implements the RTP RPH H26x
//            filter additional property page.
// Contents : 
//      class CRPHH26XPropPage
//*M*/

#ifndef _RPHPROP2_H_
#define _RPHPROP2_H_

class 
CRPHH26XPropPage 
: public CBasePropertyPage
{
	
public:
    static CUnknown * WINAPI CreateInstance( LPUNKNOWN punk, HRESULT *phr );

protected:
    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate () ;
    HRESULT OnApplyChanges();

    CRPHH26XPropPage( LPUNKNOWN punk, HRESULT *phr);

    BOOL OnInitDialog( void );
    BOOL OnCommand( int iButton, int iNotify, LPARAM lParam );

    void SetDirty();

protected:
//	IRTPRPHFilter		*m_pIRTPRPHFilter;
	IRPHH26XSettings	*m_pIRTPH26XSettings;
	BOOL m_bCIF;
    BOOL m_bIsInitialized;  // Will be false while we set init values in Dlg

};

#endif _RPHPROP2_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\rphh26x\rphh26x.h ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : rphh26x.h
// Purpose  : Define the class that implements the RTP RPH H26x Video filter.
// Contents : 
//*M*/


#ifndef _RPHH26X_H_
#define _RPHH26X_H_

#include <rph.h>

#define DEFAULT_MEDIABUF_SIZE_H26X 33000
#define DEFAULT_MEDIABUF_NUM_H26X 9 // HUGEMEMORY 10->4
#define DEFAULT_TIMEOUT_H26X 0
#define DEFAULT_STALE_TIMEOUT_H26X 200
#define PAYLOAD_CLOCK_H26X 90000
#define H261_PT   31    //assigned RTP payload number for H.261
#define H263_PT   34    //assigned RTP payload number for H.263
#define H26X_PKT_SIZE	1500 // HUGEMEMORY 8192->1500
#define NUM_PACKETS_H26X	9 // HUGEMEMORY 128->9
#define FRAMESPERSEC_H26X 20 //Use high data rate case

class CRPHH26X : public CRPHBase,
				public IRPHH26XSettings
{

public:

    static CUnknown *CreateInstance(LPUNKNOWN punk, HRESULT *phr);
    // Reveals IRPHH26XSettings
    virtual STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    DECLARE_IUNKNOWN;

    virtual HRESULT CheckInputType(const CMediaType *mtIn);
    virtual HRESULT CheckTransform(const CMediaType *mtIn,const CMediaType *mtOut);
    virtual HRESULT GetInputMediaType(int iPosition, CMediaType *pMediaType);
    virtual HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);
	virtual HRESULT CompleteConnect(PIN_DIRECTION dir,IPin *pPin);
	virtual HRESULT GetAllocatorRequirements(ALLOCATOR_PROPERTIES *pProps);

	//IRPHH26XSettings functions
	virtual STDMETHODIMP SetCIF(BOOL bCIF);
	virtual STDMETHODIMP GetCIF(BOOL *lpbCIF);

	// CPersistStream methods
	virtual HRESULT ReadFromStream(IStream *pStream);
	virtual HRESULT WriteToStream(IStream *pStream);
	virtual int SizeMax(void);
	virtual HRESULT _stdcall GetClassID(CLSID *pCLSID);
	virtual DWORD GetSoftwareVersion(void);

    // Setup helper
    LPAMOVIESETUP_FILTER GetSetupData();

private:

    // Constructor
    CRPHH26X(TCHAR *tszName, LPUNKNOWN punk, HRESULT *phr);
	virtual HRESULT SetPPMSession();

	BOOL m_bCIF;


}; // CRPHH26X


#endif // _RPHH26X_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rrcm\common.inc ===
INCLUDES=$(INCLUDES);\
    ..\..\intldbg

!if 0
!if !$(FREEBUILD)
# Uncomment the following line to allow debug information in RRCM
#C_DEFINES=$(C_DEFINES) -DDEBUG_RRCM
DEBUG_CRTS=1
TARGETLIBS=$(TARGETLIBS) \
    ..\..\lib\*\intldbg.lib
!endif
!endif

# uncomment the following line to simulate losses in RTPSendTo
#C_DEFINES=$(C_DEFINES) -DSIMULATE_RTP_LOSS

# Set RRCM_IS_DLL to 1 to generate winrtp.dll, or
# set RRCM_IS_DLL to 0 to generate rtp.lib + rtcp.lib + md5.lib
# to be linked together with amrtpnet.ax

# !!! This is also defined in filters\filters.mk !!!
#     both have to be the same
RRCM_IS_DLL=0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\rphh26x\template.h ===
/*********************************************************************
 *
 * Copyright (c) 1997 Microsoft Corporation
 *
 * File: rph\rphh26x\template.h
 *
 * Abstract:
 *     Macros to define CFactoryTemplate templates
 *
 * History:
 *     10/27/97    Created by AndresVG
 *
 **********************************************************************/
#if !defined(_RPHH26X_TEMPLATE_H_)
#define      _RPHH26X_TEMPLATE_H_

extern AMOVIESETUP_FILTER sudRPHH26X;

#define RPH_FOR_H26X              L"Intel RTP RPH for H.263/H.261"
#define RPH_FOR_H26X_COMCONTROL   L"Intel Common RPH Controls"
#define RPH_FOR_H26X_CONTROLS     L"Intel H26X RPH Controls"

#define CFT_RPHH26X_FILTER \
{ \
	  RPH_FOR_H26X, \
	  &CLSID_INTEL_RPHH26X, \
	  CRPHH26X::CreateInstance, \
	  NULL, \
	  &sudRPHH26X \
	  }

#define CFT_RPHH26X_COMCONTROL \
{ \
	  RPH_FOR_H26X_COMCONTROL, \
	  &CLSID_INTEL_RPHH26X_PROPPAGE, \
	  CRPHGENPropPage::CreateInstance_h26x \
	  }

#define CFT_RPHH26X_CONTROLS \
{ \
	  RPH_FOR_H26X_CONTROLS, \
	  &CLSID_INTEL_RPHH26X1_PROPPAGE, \
	  CRPHH26XPropPage::CreateInstance \
	  }

#define CFT_RPHH26X_ALL_FILTERS \
CFT_RPHH26X_FILTER, \
CFT_RPHH26X_COMCONTROL, \
CFT_RPHH26X_CONTROLS

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rrcm\md5\global.h ===
/* GLOBAL.H - RSAREF types and constants
 */

/* PROTOTYPES should be set to one if and only if the compiler supports
  function argument prototyping.
The following makes PROTOTYPES default to 0 if it has not already
  been defined with C compiler flags.
 */
#ifndef PROTOTYPES
#define PROTOTYPES 0
#endif

/* POINTER defines a generic pointer type */
typedef unsigned char *POINTER;

/* UINT2 defines a two byte word */
typedef unsigned short int UINT2;

/* UINT4 defines a four byte word */
#if defined(__alpha)
typedef unsigned int UINT4;
#else
typedef unsigned long int UINT4;
#endif

/* PROTO_LIST is defined depending on how PROTOTYPES is defined above.
If using PROTOTYPES, then PROTO_LIST returns the list, otherwise it
  returns an empty list.
 */
#if PROTOTYPES
#define PROTO_LIST(list) list
#else
#define PROTO_LIST(list) ()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rph\rphh26x\rphprop2.cpp ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : RPHPROP2.cpp
// Purpose  : RTP RPH H26X Specific Property Page.
// Contents : 
//*M*/

#include <winsock2.h>
#include <streams.h>
#include <list.h>
#include <stack.h>
#include <ippm.h>
#include <amrtpuid.h>
#include <rph.h>
#include <ih26xcd.h>
#include <ppmclsid.h>
#include <memory.h>
#include <resource.h>
#include <rphprop2.h>
#include <rphres.h>


CUnknown * WINAPI 
CRPHH26XPropPage::CreateInstance( 
    LPUNKNOWN punk, 
    HRESULT *phr )
{
    CRPHH26XPropPage *pNewObject
        = new CRPHH26XPropPage( punk, phr);

    if( pNewObject == NULL )
        *phr = E_OUTOFMEMORY;

    return pNewObject;
} /* CRPHH26XPropPage::CreateInstance() */


CRPHH26XPropPage::CRPHH26XPropPage( 
    LPUNKNOWN pUnk,
    HRESULT *phr)
    : CBasePropertyPage(NAME("Intel H26X RPH Controls"),pUnk,
        IDD_RPHH26X_RPHH26X_PROPPAGE, IDS_RPHH26X_RPHH26X)
    , m_pIRTPH26XSettings (NULL)
    , m_bIsInitialized(FALSE)
	, m_bCIF(TRUE)

{
    DbgLog((LOG_TRACE, 3, TEXT("CRPHH26XPropPage::CRPHH26XPropPage: Constructed at 0x%08x"), this));
} /* CRPHH26XPropPage::CRPHH26XPropPage() */

void 
CRPHH26XPropPage::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
    {
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
    }
} /* CRPHH26XPropPage::SetDirty() */

INT_PTR 
CRPHH26XPropPage::OnReceiveMessage(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    DbgLog((LOG_TRACE, 4, TEXT("CRPHH26XPropPage::OnReceiveMessage: Entered")));
    switch (uMsg) {
    case WM_INITDIALOG:
		return OnInitDialog();
		break;

    case WM_COMMAND:
        if (m_bIsInitialized) {
            if (OnCommand( (int) LOWORD( wParam ), (int) HIWORD( wParam ), lParam ) == TRUE) {
                return (LRESULT) 1;
            } /* if */
        } else {
			return(LRESULT) 1;
//            return CRPHH26XPropPage::OnInitDialog();
        } /* if */
        break;
    } /* switch */

    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
} /* CRPHH26XPropPage::OnReceiveMessage() */


HRESULT 
CRPHH26XPropPage::OnConnect(
    IUnknown    *pUnknown)
{
    DbgLog((LOG_TRACE, 4, TEXT("CRPHH26XPropPage::OnConnect: Entered")));
    ASSERT(m_pIRTPH26XSettings == NULL);
	HRESULT hr = pUnknown->QueryInterface(IID_IRPHH26XSettings, (void **) &m_pIRTPH26XSettings);
	if(FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, TEXT("CRPHH26XPropPage::OnConnect: Error 0x%08x getting IRPHH26XSettings interface!"), hr));
	    return hr;
    } /* if */
	ASSERT( m_pIRTPH26XSettings != NULL );
    DbgLog((LOG_TRACE, 3, TEXT("CRPHH26XPropPage::OnConnect: Got IRPHH26XSettings interface at 0x%08x"), m_pIRTPH26XSettings));
    m_bIsInitialized = FALSE;

    return NOERROR;
} /* CRPHH26XPropPage::OnConnect() */


HRESULT 
CRPHH26XPropPage::OnDisconnect(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CRPHH26XPropPage::OnDisconnect: Entered")));

    if (m_pIRTPH26XSettings == NULL)
    {
        return E_UNEXPECTED;
    }
	m_pIRTPH26XSettings->Release();
	m_pIRTPH26XSettings = NULL;
    return NOERROR;
} /* CRPHH26XPropPage::OnDisconnect() */


HRESULT 
CRPHH26XPropPage::OnActivate(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CRPHH26XPropPage::OnActivate: Entered")));

	m_bIsInitialized = TRUE;
    return NOERROR;
} /* CRPHH26XPropPage::OnActivate() */


BOOL 
CRPHH26XPropPage::OnInitDialog(void)
{
	HRESULT hErr;

    DbgLog((LOG_TRACE, 4, TEXT("CRPHH26XPropPage::OnInitDialog: Entered")));

	hErr = m_pIRTPH26XSettings->GetCIF(&m_bCIF);

	if (m_bCIF)
		CheckRadioButton(m_Dlg, IDC_H26XCIF, IDC_H26XQCIF, IDC_H26XCIF);
	else
		CheckRadioButton(m_Dlg, IDC_H26XCIF, IDC_H26XQCIF, IDC_H26XQCIF);

    return (LRESULT) 1;
} /* CRPHH26XPropPage::OnInitDialog() */


BOOL 
CRPHH26XPropPage::OnCommand( 
    int     iButton, 
    int     iNotify,
    LPARAM  lParam)
{
	BOOL bChanged = FALSE;

    DbgLog((LOG_TRACE, 4, TEXT("CRPHH26XPropPage::OnCommand: Entered")));
	switch(iButton) {
	case IDC_H26XCIF:
		m_bCIF = TRUE;
		bChanged = TRUE;
		break;
	case IDC_H26XQCIF:
		m_bCIF = FALSE;
		bChanged = TRUE;
		break;
	default:
		break;
	} /* switch */
	
	if (bChanged)
		SetDirty();

    return (LRESULT) 1;
} /* CRPHH26XPropPage::OnCommand() */


HRESULT 
CRPHH26XPropPage::OnApplyChanges(void)
{
	HRESULT hErr;

    DbgLog((LOG_TRACE, 4, TEXT("CRPHH26XPropPage::OnApplyChanges: Entered")));
    ASSERT( m_pIRTPH26XSettings != NULL );

	hErr = m_pIRTPH26XSettings->SetCIF(m_bCIF);

    return(NOERROR);

} /* CRPHH26XPropPage::OnApplyChanges() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rrcm\md5\md5.h ===
/* MD5.H - header file for MD5C.C
 */

/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
rights reserved.

License to copy and use this software is granted provided that it
is identified as the "RSA Data Security, Inc. MD5 Message-Digest
Algorithm" in all material mentioning or referencing this software
or this function.

License is also granted to make and use derivative works provided
that such works are identified as "derived from the RSA Data
Security, Inc. MD5 Message-Digest Algorithm" in all material
mentioning or referencing the derived work.

RSA Data Security, Inc. makes no representations concerning either
the merchantability of this software or the suitability of this
software for any particular purpose. It is provided "as is"
without express or implied warranty of any kind.

These notices must be retained in any copies of any part of this
documentation and/or software.
 */

/* MD5 context. */

typedef struct {
  unsigned int state[4];        /* state (ABCD) */
  unsigned int count[2];        /* number of bits, modulo 2^64 (lsb first) */
  unsigned char buffer[64];     /* input buffer */
} MD5_CTX;


#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)

void MD5Init (MD5_CTX *);
void MD5Update (MD5_CTX *, unsigned char *, unsigned int);
void MD5Final (unsigned char [16], MD5_CTX *);

#if defined(__cplusplus)
}
#endif  // (__cplusplus)

// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rrcm\md5\md5c.c ===
/* MD5C.C - RSA Data Security, Inc., MD5 message-digest algorithm
 */

/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
rights reserved.

License to copy and use this software is granted provided that it
is identified as the "RSA Data Security, Inc. MD5 Message-Digest
Algorithm" in all material mentioning or referencing this software
or this function.

License is also granted to make and use derivative works provided
that such works are identified as "derived from the RSA Data
Security, Inc. MD5 Message-Digest Algorithm" in all material
mentioning or referencing the derived work.

RSA Data Security, Inc. makes no representations concerning either
the merchantability of this software or the suitability of this
software for any particular purpose. It is provided "as is"
without express or implied warranty of any kind.

These notices must be retained in any copies of any part of this
documentation and/or software.
 */

#include "global.h"
#include "md5.h"

#include <memory.h>


/* Constants for MD5Transform routine.
 */
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21


#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)

static void MD5Transform PROTO_LIST ((UINT4 [4], unsigned char [64]));
static void Encode PROTO_LIST
  ((unsigned char *, UINT4 *, unsigned int));
static void Decode PROTO_LIST
  ((UINT4 *, unsigned char *, unsigned int));
static void MD5_memcpy PROTO_LIST ((POINTER, POINTER, unsigned int));
static void MD5_memset PROTO_LIST ((POINTER, int, unsigned int));

#if defined(__cplusplus)
}
#endif  // (__cplusplus)



static unsigned char PADDING[64] = {
  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

/* F, G, H and I are basic MD5 functions.
 */
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z)))

/* ROTATE_LEFT rotates x left n bits.
 */
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))

/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
Rotation is separate from addition to prevent recomputation.
 */
#define FF(a, b, c, d, x, s, ac) { \
 (a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define GG(a, b, c, d, x, s, ac) { \
 (a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define HH(a, b, c, d, x, s, ac) { \
 (a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define II(a, b, c, d, x, s, ac) { \
 (a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }

/* MD5 initialization. Begins an MD5 operation, writing a new context.
 */
void MD5Init (context)
MD5_CTX *context;                                        /* context */
{
  context->count[0] = context->count[1] = 0;
  /* Load magic initialization constants.
*/
  context->state[0] = 0x67452301;
  context->state[1] = 0xefcdab89;
  context->state[2] = 0x98badcfe;
  context->state[3] = 0x10325476;
}

/* MD5 block update operation. Continues an MD5 message-digest
  operation, processing another message block, and updating the
  context.
 */
void MD5Update (context, input, inputLen)
MD5_CTX *context;                                        /* context */
unsigned char *input;                                /* input block */
unsigned int inputLen;                     /* length of input block */
{
  unsigned int i, index, partLen;

  /* Compute number of bytes mod 64 */
  index = (unsigned int)((context->count[0] >> 3) & 0x3F);

  /* Update number of bits */
  if ((context->count[0] += ((UINT4)inputLen << 3))
   < ((UINT4)inputLen << 3))
 context->count[1]++;
  context->count[1] += ((UINT4)inputLen >> 29);

  partLen = 64 - index;

  /* Transform as many times as possible.
*/
  if (inputLen >= partLen) {
 MD5_memcpy
   ((POINTER)&context->buffer[index], (POINTER)input, partLen);
 MD5Transform (context->state, context->buffer);

 for (i = partLen; i + 63 < inputLen; i += 64)
   MD5Transform (context->state, &input[i]);

 index = 0;
  }
  else
 i = 0;

  /* Buffer remaining input */
  MD5_memcpy
 ((POINTER)&context->buffer[index], (POINTER)&input[i],
  inputLen-i);
}

/* MD5 finalization. Ends an MD5 message-digest operation, writing the
  the message digest and zeroizing the context.
 */
void MD5Final (digest, context)
unsigned char digest[16];                         /* message digest */
MD5_CTX *context;                                       /* context */
{
  unsigned char bits[8];
  unsigned int index, padLen;

  /* Save number of bits */
  Encode (bits, context->count, 8);

  /* Pad out to 56 mod 64.
*/
  index = (unsigned int)((context->count[0] >> 3) & 0x3f);
  padLen = (index < 56) ? (56 - index) : (120 - index);
  MD5Update (context, PADDING, padLen);

  /* Append length (before padding) */
  MD5Update (context, bits, 8);
  /* Store state in digest */
  Encode (digest, context->state, 16);

  /* Zeroize sensitive information.
*/
  MD5_memset ((POINTER)context, 0, sizeof (*context));
}

/* MD5 basic transformation. Transforms state based on block.
 */
static void MD5Transform (state, block)
UINT4 state[4];
unsigned char block[64];
{
  UINT4 a = state[0], b = state[1], c = state[2], d = state[3], x[16];

  Decode (x, block, 64);

  /* Round 1 */
  FF (a, b, c, d, x[ 0], S11, 0xd76aa478); /* 1 */
  FF (d, a, b, c, x[ 1], S12, 0xe8c7b756); /* 2 */
  FF (c, d, a, b, x[ 2], S13, 0x242070db); /* 3 */
  FF (b, c, d, a, x[ 3], S14, 0xc1bdceee); /* 4 */
  FF (a, b, c, d, x[ 4], S11, 0xf57c0faf); /* 5 */
  FF (d, a, b, c, x[ 5], S12, 0x4787c62a); /* 6 */
  FF (c, d, a, b, x[ 6], S13, 0xa8304613); /* 7 */
  FF (b, c, d, a, x[ 7], S14, 0xfd469501); /* 8 */
  FF (a, b, c, d, x[ 8], S11, 0x698098d8); /* 9 */
  FF (d, a, b, c, x[ 9], S12, 0x8b44f7af); /* 10 */
  FF (c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */
  FF (b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */
  FF (a, b, c, d, x[12], S11, 0x6b901122); /* 13 */
  FF (d, a, b, c, x[13], S12, 0xfd987193); /* 14 */
  FF (c, d, a, b, x[14], S13, 0xa679438e); /* 15 */
  FF (b, c, d, a, x[15], S14, 0x49b40821); /* 16 */

 /* Round 2 */
  GG (a, b, c, d, x[ 1], S21, 0xf61e2562); /* 17 */
  GG (d, a, b, c, x[ 6], S22, 0xc040b340); /* 18 */
  GG (c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */
  GG (b, c, d, a, x[ 0], S24, 0xe9b6c7aa); /* 20 */
  GG (a, b, c, d, x[ 5], S21, 0xd62f105d); /* 21 */
  GG (d, a, b, c, x[10], S22,  0x2441453); /* 22 */
  GG (c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */
  GG (b, c, d, a, x[ 4], S24, 0xe7d3fbc8); /* 24 */
  GG (a, b, c, d, x[ 9], S21, 0x21e1cde6); /* 25 */
  GG (d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */
  GG (c, d, a, b, x[ 3], S23, 0xf4d50d87); /* 27 */
  GG (b, c, d, a, x[ 8], S24, 0x455a14ed); /* 28 */
  GG (a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
  GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */
  GG (c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */
  GG (b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */

  /* Round 3 */
  HH (a, b, c, d, x[ 5], S31, 0xfffa3942); /* 33 */
  HH (d, a, b, c, x[ 8], S32, 0x8771f681); /* 34 */
  HH (c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */
  HH (b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */
  HH (a, b, c, d, x[ 1], S31, 0xa4beea44); /* 37 */
  HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */
  HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */
  HH (b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
  HH (a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
  HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */
  HH (c, d, a, b, x[ 3], S33, 0xd4ef3085); /* 43 */
  HH (b, c, d, a, x[ 6], S34,  0x4881d05); /* 44 */
  HH (a, b, c, d, x[ 9], S31, 0xd9d4d039); /* 45 */
  HH (d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */
  HH (c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */
  HH (b, c, d, a, x[ 2], S34, 0xc4ac5665); /* 48 */

  /* Round 4 */
  II (a, b, c, d, x[ 0], S41, 0xf4292244); /* 49 */
  II (d, a, b, c, x[ 7], S42, 0x432aff97); /* 50 */
  II (c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */
  II (b, c, d, a, x[ 5], S44, 0xfc93a039); /* 52 */
  II (a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */
  II (d, a, b, c, x[ 3], S42, 0x8f0ccc92); /* 54 */
  II (c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */
  II (b, c, d, a, x[ 1], S44, 0x85845dd1); /* 56 */
  II (a, b, c, d, x[ 8], S41, 0x6fa87e4f); /* 57 */
  II (d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */
  II (c, d, a, b, x[ 6], S43, 0xa3014314); /* 59 */
  II (b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */
  II (a, b, c, d, x[ 4], S41, 0xf7537e82); /* 61 */
  II (d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */
  II (c, d, a, b, x[ 2], S43, 0x2ad7d2bb); /* 63 */
  II (b, c, d, a, x[ 9], S44, 0xeb86d391); /* 64 */

  state[0] += a;
  state[1] += b;
  state[2] += c;
  state[3] += d;

  /* Zeroize sensitive information.
*/
  MD5_memset ((POINTER)x, 0, sizeof (x));
}

/* Encodes input (UINT4) into output (unsigned char). Assumes len is
  a multiple of 4.
 */
static void Encode (output, input, len)
unsigned char *output;
UINT4 *input;
unsigned int len;
{
  unsigned int i, j;

  for (i = 0, j = 0; j < len; i++, j += 4) {
 output[j] = (unsigned char)(input[i] & 0xff);
 output[j+1] = (unsigned char)((input[i] >> 8) & 0xff);
 output[j+2] = (unsigned char)((input[i] >> 16) & 0xff);
 output[j+3] = (unsigned char)((input[i] >> 24) & 0xff);
  }
}

/* Decodes input (unsigned char) into output (UINT4). Assumes len is
  a multiple of 4.
 */
static void Decode (output, input, len)
UINT4 *output;
unsigned char *input;
unsigned int len;
{
  unsigned int i, j;

  for (i = 0, j = 0; j < len; i++, j += 4)
 output[i] = ((UINT4)input[j]) | (((UINT4)input[j+1]) << 8) |
   (((UINT4)input[j+2]) << 16) | (((UINT4)input[j+3]) << 24);
}

/* Note: Replace "for loop" with standard memcpy if possible.
 */

static void MD5_memcpy (output, input, len)
POINTER output;
POINTER input;
unsigned int len;
{
/*
  unsigned int i;

  for (i = 0; i < len; i++)
 output[i] = input[i];
*/
  memcpy(output,input,len);
}

/* Note: Replace "for loop" with standard memset if possible.
 */
static void MD5_memset (output, value, len)
POINTER output;
int value;
unsigned int len;
{
/*
  unsigned int i;

  for (i = 0; i < len; i++)
 ((char *)output)[i] = (char)value;
*/
  memset(output,value,len);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rrcm\rtcp\rtcpmem.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTCPMEM.C
 * Product:     RTP/RTCP implementation
 * Description: Provides memory operations functions for RTCP.
 *
 * $Workfile:   RTCPMEM.CPP  $
 * $Author:   CMACIOCC  $
 * $Date:   13 Feb 1997 14:47:44  $
 * $Revision:   1.3  $
 * $Archive:   R:\rtp\src\rrcm\rtcp\rtcpmem.cpv  $
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/

		
#include "rrcm.h"                                    
                                       

/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/            


/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/                                       
extern PRTP_CONTEXT	pRTPContext;
#ifdef _DEBUG
extern char		debug_string[];
#endif


/*----------------------------------------------------------------------------
 * Function   : allocateRTCPContextHeaps
 * Description: Allocates RTCP context heaps
 * 
 * Input :      pRTCPcntxt:	-> to the RTCP context information
 *
 * Return:		OK: RRCM_NoError
 *				!0: Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
 DWORD allocateRTCPContextHeaps (PRTCP_CONTEXT pRTCPcntxt)
	{
	IN_OUT_STR ("RTCP: Enter allocateRTCPContextHeaps()\n");

	pRTCPcntxt->hHeapRTCPSes = HeapCreate (
			0, 
			(pRTPContext->registry.NumSessions*sizeof(RTCP_SESSION)),
			0);
	if (pRTCPcntxt->hHeapRTCPSes == NULL)
		{
		IN_OUT_STR ("RTCP: Exit allocateRTCPContextHeaps()\n");
		return (RRCMError_RTCPResources);
		}

	pRTCPcntxt->hHeapRRCMStat = HeapCreate (
			0, 
			pRTCPcntxt->dwInitNumFreeRRCMStat*sizeof(SSRC_ENTRY), 
			0);
	if (pRTCPcntxt->hHeapRRCMStat == NULL)
		{
		IN_OUT_STR ("RTCP: Exit allocateRTCPContextHeaps()\n");
		return (RRCMError_RTCPResources);
		}

	IN_OUT_STR ("RTCP: Exit allocateRTCPContextHeaps()\n");
	return (RRCM_NoError);
	}

/*----------------------------------------------------------------------------
 * Function   : allocateRTCPSessionHeaps
 * Description: Allocates RTCP session heaps
 * 
 * Input :      *pRTCPses:		->(->) to the RTCP session's information
 *
 * Return:		OK: RRCM_NoError
 *				!0:	Erro code (see RRCM.H)
 ---------------------------------------------------------------------------*/
 DWORD allocateRTCPSessionHeaps (PRTCP_SESSION *pRTCPses)
	{
	DWORD	heapSize;
	DWORD	dwStatus = RRCM_NoError;

	IN_OUT_STR ("RTCP: Enter allocateRTCPSessionHeaps()\n");

	heapSize = NUM_FREE_RCV_BFR*pRTPContext->registry.RTCPrcvBfrSize;
	(*pRTCPses)->hHeapRcvBfr = HeapCreate (0, 
										   heapSize, 
										   0);
	if ((*pRTCPses)->hHeapRcvBfr == NULL)
		dwStatus = RRCMError_RTCPResources;

	if (dwStatus == RRCM_NoError)
		{
		(*pRTCPses)->hHeapRcvBfrList = HeapCreate (0, 
												   RCV_BFR_LIST_HEAP_SIZE, 
												   0);
		if ((*pRTCPses)->hHeapRcvBfrList == NULL)
			dwStatus = RRCMError_RTCPResources;
		}

	if (dwStatus == RRCM_NoError)
		{
		heapSize = NUM_FREE_XMT_BFR*RRCM_XMT_BFR_SIZE;
		(*pRTCPses)->hHeapXmtBfr = HeapCreate (0, 
											   heapSize, 
											   0);
		if ((*pRTCPses)->hHeapXmtBfr == NULL)
			dwStatus = RRCMError_RTCPResources;
		}

	if (dwStatus == RRCM_NoError)
		{
		(*pRTCPses)->hHeapXmtBfrList = HeapCreate (0, 
												   XMT_BFR_LIST_HEAP_SIZE, 
												   0);
		if ((*pRTCPses)->hHeapXmtBfrList == NULL)
			dwStatus = RRCMError_RTCPResources;
		}

	if (dwStatus != RRCM_NoError)
		{
		// destroy allocated heaps
		if ((*pRTCPses)->hHeapRcvBfr)
			{
			HeapDestroy ((*pRTCPses)->hHeapRcvBfr);
			(*pRTCPses)->hHeapRcvBfr = NULL;
			}
		if ((*pRTCPses)->hHeapRcvBfrList)
			{
			HeapDestroy ((*pRTCPses)->hHeapRcvBfrList);
			(*pRTCPses)->hHeapRcvBfrList = NULL;
			}
		if ((*pRTCPses)->hHeapXmtBfr)
			{
			HeapDestroy ((*pRTCPses)->hHeapXmtBfr);
			(*pRTCPses)->hHeapXmtBfr = NULL;
			}
		if ((*pRTCPses)->hHeapXmtBfrList)
			{
			HeapDestroy ((*pRTCPses)->hHeapXmtBfrList);
			(*pRTCPses)->hHeapXmtBfrList = NULL;
			}
		}

	IN_OUT_STR ("RTCP: Exit allocateRTCPSessionHeaps()\n");
	return (dwStatus);
	}


/*----------------------------------------------------------------------------
 * Function   : allocateRTCPBfrList
 * Description: Allocates link list of buffers for RTCP (xmit/rcv/...).
 * 
 * Input :      ptr:		-> to the link list to add buffer to
 *				hHeapList:	Handle to the heap list
 *				hHeapBfr:	Handle to the heap buffer
 *				*numBfr:	-> to the number of buffers to allocate
 *				bfrSize:	Individual buffer size
 *
 * Return:		OK: RRCM_NoError
 *				!0: Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
 DWORD allocateRTCPBfrList (PLINK_LIST ptr, 
							HANDLE hHeapList, 
							HANDLE hHeapBfr,
 							DWORD *numBfr, 
							DWORD bfrSize,
							CRITICAL_SECTION *pCritSect)
	{
	PRTCP_BFR_LIST	bfrPtr;
	PLINK_LIST		tmpPtr;
	
#ifdef IN_OUT_CHK
	OutputDebugString ("RTCP: Enter allocateRTCPBfrList()\n");
#endif

	ASSERT (ptr);
	ASSERT (hHeapList);
	ASSERT (hHeapBfr);

	// make sure at least one buffer is requested 
	if (*numBfr == 0)
		return (RRCMError_RTCPInvalidRequest);

	// allocate link list on the data structure's heap 
	if (allocateLinkedList (ptr, hHeapList, numBfr, 
							sizeof(RTCP_BFR_LIST), pCritSect))
		return (RRCMError_RTCPResources);

	// allocate buffer pool resources starting from the tail 
	tmpPtr = ptr->prev;
    while (tmpPtr != NULL)
    	{
		// points to buffer structure 
		bfrPtr = (PRTCP_BFR_LIST)tmpPtr;
		ASSERT (bfrPtr);

    	// initialize the WSABUF structure on its own heap 
    	bfrPtr->bfr.buf = (char *)HeapAlloc (hHeapBfr, 
											 HEAP_ZERO_MEMORY, 
											 bfrSize);
		if (bfrPtr->bfr.buf == NULL) {

			RRCM_DBG_MSG ("RTCP: Error - Cannot Allocate Xmt/Rcv Bfr", 
							0, __FILE__, __LINE__, DBG_ERROR);

			// close the list
			// update head/tail pointers 
			if (tmpPtr->prev) {
				tmpPtr->prev->next = NULL;
				ptr->next = tmpPtr->prev;
			} else {
				// list will be left empty;
				ptr->prev = ptr->next = NULL;
			}

			// delete remaining cells until end of list
			do {
				PLINK_LIST tmpPtr2 = tmpPtr->next;
				
				HeapFree(hHeapList, 0, tmpPtr);
				tmpPtr = tmpPtr2;
				
			} while(tmpPtr);
			
			break;
		}

		// buffer length 
		bfrPtr->bfr.len = bfrSize;

		// buffer attributes 
		bfrPtr->dwBufferCount = 1;

		// new head pointer 
		tmpPtr = bfrPtr->bfrList.next;
    	}
    
#ifdef IN_OUT_CHK
	OutputDebugString ("RTCP: Exit allocateRTCPBfrList()\n");
#endif
	return (RRCM_NoError);
	}


// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rrcm\md5\mddriver.c ===
/* MDDRIVER.C - test driver for MD2, MD4 and MD5
 */

/* Copyright (C) 1990-2, RSA Data Security, Inc. Created 1990. All
rights reserved.

RSA Data Security, Inc. makes no representations concerning either
the merchantability of this software or the suitability of this
software for any particular purpose. It is provided "as is"
without express or implied warranty of any kind.

These notices must be retained in any copies of any part of this
documentation and/or software.
 */

/* The following makes MD default to MD5 if it has not already been
  defined with C compiler flags.
 */
#ifndef MD
#define MD MD5
#endif

#include <stdio.h>
#include <string.h>
#include <sys/time.h>
#include <sys/resource.h>
#include "global.h"
#if MD == 2
#include "md2.h"
#endif
#if MD == 4
#include "md4.h"
#endif
#if MD == 5
#include "md5.h"
#endif

/* Length of test block, number of test blocks.
 */
#define TEST_BLOCK_LEN 1000
#define TEST_BLOCK_COUNT 1000

extern char *calloc();
long test_block_len = TEST_BLOCK_LEN;
long test_block_count = TEST_BLOCK_COUNT;
int skip_init = 0;
int random_init = 0;
int double_block = 0;

static void MDString PROTO_LIST ((char *));
static void MDTimeTrial PROTO_LIST ((void));
static void MDTestSuite PROTO_LIST ((void));
static void MDFile PROTO_LIST ((char *));
static void MDFilter PROTO_LIST ((void));
static void MDPrint PROTO_LIST ((unsigned char [16]));

#if MD == 2
#define MD_CTX MD2_CTX
#define MDInit MD2Init
#define MDUpdate MD2Update
#define MDFinal MD2Final
#endif
#if MD == 4
#define MD_CTX MD4_CTX
#define MDInit MD4Init
#define MDUpdate MD4Update
#define MDFinal MD4Final
#endif
#if MD == 5
#define MD_CTX MD5_CTX
#define MDInit MD5Init
#define MDUpdate MD5Update
#define MDFinal MD5Final
#endif

/* Main driver.

Arguments (may be any combination):
  -sstring - digests string
  -t       - runs time trial
  -x       - runs test script
  filename - digests file
  (none)   - digests standard input

Used with -t:
  -l       - test block length
  -c       - test block count
  -s       - skip test init
  -r       - randomized (pseudo) test initialization
  -d       - double-buffer the block 
		(split in half - OK to use with -c; doesn't have cache effects)
 */
int main (argc, argv)
int argc;
char *argv[];
{
  int i;

  if (argc > 1)
 for (i = 1; i < argc; i++)
   if (argv[i][0] == '-' && argv[i][1] == 's')
     MDString (argv[i] + 2);
   else if (strcmp (argv[i], "-c") == 0)
       test_block_count = atol(argv[++i]);
   else if (strcmp (argv[i], "-l") == 0)
       test_block_len = atol(argv[++i]);
   else if (strcmp (argv[i], "-s") == 0)
       skip_init = 1;
   else if (strcmp (argv[i], "-r") == 0)
       random_init = 1;
   else if (strcmp (argv[i], "-d") == 0)
       double_block = 1;
   else if (strcmp (argv[i], "-t") == 0)
     MDTimeTrial ();
   else if (strcmp (argv[i], "-x") == 0)
     MDTestSuite ();
   else
     MDFile (argv[i]);
  else
 MDFilter ();

  return (0);
}

/* Digests a string and prints the result.
 */
static void MDString (string)
char *string;
{
  MD_CTX context;
  unsigned char digest[16];
  unsigned int len = strlen (string);

  MDInit (&context);
  MDUpdate (&context, string, len);
  MDFinal (digest, &context);

  printf ("MD%d (\"%s\") = ", MD, string);
  MDPrint (digest);
  printf ("\n");
}

/* Measures the time to digest TEST_BLOCK_COUNT TEST_BLOCK_LEN-byte
  blocks.
 */
static void MDTimeTrial ()
{
  MD_CTX context;
  unsigned char *block, digest[16];
  unsigned char *block2;
  unsigned int count;
  unsigned int i;
  struct timeval randtime;
#if (defined(hpux))
  struct timeval starttime;
  struct timeval stoptime;
#else
  struct rusage starttime;
  struct rusage stoptime;
#endif
  double usecs,ssecs,tsecs;

  block = (unsigned char *)malloc(test_block_len);
  block2 = (unsigned char *)malloc(test_block_len);

  printf
 ("MD%d time trial. Digesting %d %d-byte blocks ...", MD,
  test_block_count, test_block_len);

  /* Initialize block */
  if (!skip_init) {
    if (random_init) {
      gettimeofday(&randtime,(char *)0);
      count = (unsigned int)(randtime.tv_usec);
    } else
      count = 0;
    for (i = 0; i < test_block_len; i++,count++)
      block[i] = block2[i] = (unsigned char)(count & 0xff);
  }
      
  /* Start timer */
#if (defined(hpux))
  gettimeofday(&starttime,(char *)0);
#else
  getrusage(RUSAGE_SELF,&starttime);
#endif

  /* Digest blocks */
  MDInit (&context);
  if (double_block)
  for (i = 0; i < test_block_count/2; i++) {
    MDUpdate (&context, block, test_block_len);
    MDUpdate (&context, block2, test_block_len);
  }
  else {
  for (i = 0; i < test_block_count; i++)
 MDUpdate (&context, block, test_block_len);
  }
  MDFinal (digest, &context);

  /* Stop timer */
#if (defined(hpux))
  gettimeofday(&stoptime,(char *)0);
  tsecs = stoptime.tv_sec - starttime.tv_sec;
  tsecs += (stoptime.tv_usec - starttime.tv_usec) * 1e-6;
  usecs = 0;
  ssecs = 0;
#else
  getrusage(RUSAGE_SELF,&stoptime);
  usecs = stoptime.ru_utime.tv_sec - starttime.ru_utime.tv_sec;
  usecs += (stoptime.ru_utime.tv_usec - starttime.ru_utime.tv_usec) * 1e-6;
  ssecs = stoptime.ru_stime.tv_sec - starttime.ru_stime.tv_sec;
  ssecs += (stoptime.ru_stime.tv_usec - starttime.ru_stime.tv_usec) * 1e-6;
  tsecs = usecs + ssecs;
#endif

  printf (" done\n");
  printf ("Digest = ");
  MDPrint (digest);
  printf ("\nTime = %g U : %g S :: %g seconds\n", usecs,ssecs,tsecs);
  /*
   * Be careful that endTime-startTime is not zero.
   * (Bug fix from Ric Anderson, ric@Artisoft.COM.)
   */
  printf
 ("Speed = %g bytes/second,     %g bits/sec\n",
  (long)test_block_len * (long)test_block_count/((tsecs != 0) ? tsecs : 1),
  8 * (long)test_block_len * (long)test_block_count/((tsecs != 0) ? tsecs : 1));
  printf("minflt %d    majflt %d    nswap %d    nvcsw %d    nivcsw %d\n",
#if (!defined(hpux))
	 stoptime.ru_minflt - starttime.ru_minflt,
	 stoptime.ru_majflt - starttime.ru_majflt,
	 stoptime.ru_nswap - starttime.ru_nswap,
	 stoptime.ru_nvcsw - starttime.ru_nvcsw,
	 stoptime.ru_nivcsw - starttime.ru_nivcsw
#else
	 -1,-1,-1,-1,-1
#endif
	 );

}

/* Digests a reference suite of strings and prints the results.
 */
static void MDTestSuite ()
{
  printf ("MD%d test suite:\n", MD);

  MDString ("");
  MDString ("a");
  MDString ("abc");
  MDString ("message digest");
  MDString ("abcdefghijklmnopqrstuvwxyz");
  MDString
 ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789");
  MDString
 ("1234567890123456789012345678901234567890\
1234567890123456789012345678901234567890");
}

/* Digests a file and prints the result.
 */
static void MDFile (filename)
char *filename;
{
  FILE *file;
  MD_CTX context;
  int len;
  unsigned char buffer[1024], digest[16];

  if ((file = fopen (filename, "rb")) == NULL)
 printf ("%s can't be opened\n", filename);

  else {
 MDInit (&context);
 while (len = fread (buffer, 1, 1024, file))
   MDUpdate (&context, buffer, len);
 MDFinal (digest, &context);

 fclose (file);

 printf ("MD%d (%s) = ", MD, filename);
 MDPrint (digest);
 printf ("\n");
  }
}

/* Digests the standard input and prints the result.
 */
static void MDFilter ()
{
  MD_CTX context;
  int len;
  unsigned char buffer[16], digest[16];

  MDInit (&context);
  while (len = fread (buffer, 1, 16, stdin))
 MDUpdate (&context, buffer, len);
  MDFinal (digest, &context);

  MDPrint (digest);
  printf ("\n");
}

/* Prints a message digest in hexadecimal.
 */
static void MDPrint (digest)
unsigned char digest[16];
{
  unsigned int i;

  for (i = 0; i < 16; i++)
 printf ("%02x", digest[i]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rrcm\rtcp\rrcmqueu.cpp ===
/*----------------------------------------------------------------------------
 * File:        RRCMQUEU.C
 * Product:     RTP/RTCP implementation.
 * Description: Provides queue management function for RRCM.
 *
 * $Workfile:   RRCMQUEU.CPP  $
 * $Author:   CMACIOCC  $
 * $Date:   13 Feb 1997 14:47:34  $
 * $Revision:   1.2  $
 * $Archive:   R:\rtp\src\rrcm\rtcp\rrcmqueu.cpv  $
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/


#include "rrcm.h"                                    


 
/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/

                                                                     
                                                                             
/*---------------------------------------------------------------------------
 * Function   : allocateLinkedList
 * Description: Allocates all the necessary memory resource and link the 
 *              cells to the link list.
 * 
 * Input :      *listPtr		: Address of head pointer.
 *				hHeap			: Heap to allocate the data from.
 *              *numCells		: -> to the number of cells to allocate.
 *				elementSize		: Element size.
 *				pCritSect		: -> to critical section
 *
 * Return: 		TRUE  = Error Code, no queues allocated and linked
 *         		FALSE = OK
 --------------------------------------------------------------------------*/
DWORD allocateLinkedList (PLINK_LIST pList, 
 						   HANDLE hHeap,
 						   DWORD *numCells,
						   DWORD elementSize,
						   CRITICAL_SECTION *pCritSect)
	{
	DWORD		cellsAllocated = *numCells;
	PLINK_LIST	pHead;                            
	PLINK_LIST	pTmp;

	IN_OUT_STR ("RTCP: Enter allocateLinkedList()\n");
	
	// allocate first cell 
	pHead = (PLINK_LIST)HeapAlloc (hHeap, HEAP_ZERO_MEMORY, elementSize);
	if (pHead == NULL)
		{
		RRCM_DBG_MSG ("RTCP: ERROR - Resource allocation failed", 0, 
					  __FILE__, __LINE__, DBG_CRITICAL);

		IN_OUT_STR ("RTCP: Exit allocateLinkedList()\n");
		return (RRCMError_RTCPResources);
		}

	// protect the pointers
	if (pCritSect)
		EnterCriticalSection (pCritSect);
	
	// initialize list tail pointer 
	pList->prev = pHead;
	
	// update number of cells allocated 
	cellsAllocated--;

	while (cellsAllocated)	
		{

		pHead->next = (PLINK_LIST)HeapAlloc (hHeap, HEAP_ZERO_MEMORY, 
											 elementSize);
		if (pHead->next == NULL)
			break;
    
		cellsAllocated--;
		
    	// save head pointer 
    	pTmp = pHead;
    	
		// update head ptr 
		pHead = pHead->next;
		pHead->prev = pTmp;
		}                            
		
	// set number of cells allocated 
	*numCells -= cellsAllocated;
	
	// set head/tail pointers 
	pList->next = pHead;

	// unprotect the pointers
	if (pCritSect)
		LeaveCriticalSection (pCritSect);

	IN_OUT_STR ("RTCP: Exit allocateLinkedList()\n");	

	return (RRCM_NoError);
	} 

  
/*--------------------------------------------------------------------------
** Function   : addToHeadOfList
** Description: Add a new cell to the specified queue. The queue acts as a
**              FIFO (cells enqueud on the next pointer and dequeued by the
**              starting address of the queue).
**
** Input :		pHead		= Address of head pointer of queue.
**				pNew		= Cell address to be added to the linked list.
**				pCritSect	= -> to critical section object.
**
** Return: None.
--------------------------------------------------------------------------*/
void addToHeadOfList (PLINK_LIST pHead,
				 	  PLINK_LIST pNew,
					  CRITICAL_SECTION *pCritSect)
	{
	ASSERT (pHead);
	ASSERT (pNew);

	IN_OUT_STR ("RTCP: Enter addToHeadOfList()\n");	

	// safe access to pointers
	if (pCritSect)
		EnterCriticalSection (pCritSect);
		
	if (pHead->next == NULL) 
		{
		// head is NULL for the first cell. Assign the address of 
		// the free cell
		pHead->next = pHead->prev = pNew;
		pNew->next  = pNew->prev  = NULL;
		}
	else
		// head ptr points to something 
		{
		pNew->prev    = pHead->next;
		(pHead->next)->next = pNew;
		pNew->next    = NULL;

		// update the head pointer now 
		pHead->next = pNew;
		}

	// unlock pointer access 
	if (pCritSect)
		LeaveCriticalSection (pCritSect);

	IN_OUT_STR ("RTCP: Exit addToHeadOfList()\n");	
	}


/*--------------------------------------------------------------------------
** Function   : addToTailOfList
** Description: Add a new cell to the specified queue. The queue acts as a
**              FIFO (cells enqueud on the next pointer and dequeued by the
**              starting address of the queue).
**
** Input :		pTail	= Address of tail pointer to enqueue in.
**				pNew	= New cell address to be added to the linked list.
**
** Return: None.
--------------------------------------------------------------------------*/
void addToTailOfList (PLINK_LIST pTail,
				 	  PLINK_LIST pNew,
  					  CRITICAL_SECTION *pCritSect)
	{
	ASSERT (pTail);
	ASSERT (pNew);

	IN_OUT_STR ("RTCP: Enter addToTailOfList()\n");	

	// safe access to pointers
	if (pCritSect)
		EnterCriticalSection (pCritSect);
		
	if (pTail->prev == NULL) 
		{
		// head is NULL for the first cell. Assign the address of 
		// the free cell
		pTail->next = pTail->prev = pNew;
		pNew->next  = pNew->prev  = NULL;
		}
	else
		// tail ptr points to something 
		{
		pNew->next    = pTail->prev;
		(pTail->prev)->prev = pNew;
		pNew->prev    = NULL;

		// update the parent tail pointer now 
		pTail->prev = pNew;
		}

	// unlock pointer access 
	if (pCritSect)
		LeaveCriticalSection (pCritSect);

	IN_OUT_STR ("RTCP: Exit addToTailOfList()\n");	
	}


/*--------------------------------------------------------------------------
** Function   : removePcktFromHead
** Description: Remove a cell from front of the specified queue.
**
** Input :		pQueue:	-> to the list to remove the packet from
**
** Return: NULL 			==> Empty queue.
**         Buffer Address 	==> OK, cell removed
--------------------------------------------------------------------------*/
PLINK_LIST removePcktFromHead (PLINK_LIST pQueue,
							   CRITICAL_SECTION *pCritSect)
	{
	PLINK_LIST	pReturnQ;

	IN_OUT_STR ("RTCP: Enter removePcktFromHead()\n");	

	// safe access to pointers
	if (pCritSect)
		EnterCriticalSection (pCritSect);
		
	if ((pReturnQ = pQueue->next) != NULL) 
		{
		// We have a buffer.  If this is the last buffer in the queue,
		//	mark it empty.	    
	    if (pReturnQ->prev == NULL) 
			{
	    	pQueue->prev = NULL;
	    	pQueue->next = NULL;
			}
	    else 
			{
	    	// Have the new head buffer point to NULL
		    (pReturnQ->prev)->next = NULL;
		    // Have the queue head point to the new head buffer
	    	pQueue->next = pReturnQ->prev;
			}
        pReturnQ->next = pReturnQ->prev = NULL;
		}

	// unlock pointer access 
	if (pCritSect)
		LeaveCriticalSection (pCritSect);

	IN_OUT_STR ("RTCP: Exit removePcktFromHead()\n");	

	return (pReturnQ);
	}


/*--------------------------------------------------------------------------
** Function   : removePcktFromTail
** Description: Remove a cell from end of the specified queue.
**
** Input :		pQueue:		-> to the list to remove the packet from
**
** Return:		NULL 			==> Empty queue.
**				Buffer Address 	==> OK, cell removed
--------------------------------------------------------------------------*/
PLINK_LIST removePcktFromTail (PLINK_LIST pQueue,
							   CRITICAL_SECTION *pCritSect)
	{
	PLINK_LIST	pReturnQ;

	IN_OUT_STR ("RTCP: Enter removePcktFromTail()\n");	

	// safe access to pointers
	if (pCritSect)
		EnterCriticalSection (pCritSect);
	
	if ((pReturnQ = pQueue->prev) != NULL) 
		{
		// We have a buffer.  If this is the last buffer in the queue,
		//	mark it empty.	    
	    if (pReturnQ->next == NULL) 
			{
	    	pQueue->prev = NULL;
	    	pQueue->next = NULL;
			}
	    else 
			{
		    // In any event, the new prev pointer is NULL: end of list
		    (pReturnQ->next)->prev = NULL;
	    	// have the queue prev pointer point to the new 'last' element
	    	pQueue->prev = pReturnQ->next;
			}
        pReturnQ->next = pReturnQ->prev = NULL;
		}

	// unlock pointer access 
	if (pCritSect)
		LeaveCriticalSection (pCritSect);
	
	IN_OUT_STR ("RTCP: Enter removePcktFromTail()\n");	

	return (pReturnQ);
	}

PLINK_LIST removePcktFromQueue(PLINK_LIST pQueue,
							   PLINK_LIST pRemoveQ,
							   CRITICAL_SECTION *pCritSect)
{
	PLINK_LIST NextQ, PrevQ;

	if (!pRemoveQ)
		return(pRemoveQ);
	
	// safe access to pointers
	if (pCritSect)
		EnterCriticalSection (pCritSect);

	NextQ = pRemoveQ->next;
	PrevQ = pRemoveQ->prev;
	
	if (pQueue->prev == pRemoveQ) // Last packet
		pQueue->prev = NextQ;

	if (pQueue->next == pRemoveQ) // First packet
		pQueue->next = PrevQ;

	if (NextQ)
		NextQ->prev = PrevQ;

	if (PrevQ)
		PrevQ->next = NextQ;

	pRemoveQ->next = pRemoveQ->prev = NULL;
		
	// unlock pointer access 
	if (pCritSect)
		LeaveCriticalSection (pCritSect);

	return(pRemoveQ);
}

// Move item RemoveQ from FromQueue to the head of ToQueue
PLINK_LIST movePcktFromQueue(PLINK_LIST pToQueue, PLINK_LIST pFromQueue,
							 PLINK_LIST pRemoveQ,
							 CRITICAL_SECTION *pCritSect)
{
	PLINK_LIST NextQ, PrevQ;

	if (!pRemoveQ)
		return(pRemoveQ);
	
	// safe access to pointers
	if (pCritSect)
		EnterCriticalSection (pCritSect);

	// Remove from FromQueue
	NextQ = pRemoveQ->next;
	PrevQ = pRemoveQ->prev;
	
	if (pFromQueue->prev == pRemoveQ) // Last packet
		pFromQueue->prev = NextQ;

	if (pFromQueue->next == pRemoveQ) // First packet
		pFromQueue->next = PrevQ;

	if (NextQ)
		NextQ->prev = PrevQ;

	if (PrevQ)
		PrevQ->next = NextQ;

	// Add to head of ToQueue
	if (pToQueue->next == NULL) {
		// ToQueue is NULL for the first cell. Assign the address of 
		// the free cell
		pToQueue->next = pToQueue->prev = pRemoveQ;
		pRemoveQ->next  = pRemoveQ->prev  = NULL;
	} else {
		//  ToQueue points to something 
		pRemoveQ->prev    = pToQueue->next;
		(pToQueue->next)->next = pRemoveQ;
		pRemoveQ->next    = NULL;

		// update the head pointer now 
		pToQueue->next = pRemoveQ;
	}
	
	// unlock pointer access 
	if (pCritSect)
		LeaveCriticalSection (pCritSect);

	return(pRemoveQ);
}

// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rrcm\md5\md5c_opt.c ===
/* MD5C.C - RSA Data Security, Inc., MD5 message-digest algorithm
 */

/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
rights reserved.

License to copy and use this software is granted provided that it
is identified as the "RSA Data Security, Inc. MD5 Message-Digest
Algorithm" in all material mentioning or referencing this software
or this function.

License is also granted to make and use derivative works provided
that such works are identified as "derived from the RSA Data
Security, Inc. MD5 Message-Digest Algorithm" in all material
mentioning or referencing the derived work.

RSA Data Security, Inc. makes no representations concerning either
the merchantability of this software or the suitability of this
software for any particular purpose. It is provided "as is"
without express or implied warranty of any kind.

These notices must be retained in any copies of any part of this
documentation and/or software.
 */

#include "global.h"
#include "md5.h"

#include <memory.h>

/* Constants for MD5Transform routine.
 */
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21

static void MD5Transform PROTO_LIST ((UINT4 [4], unsigned char [64]));
static void Encode PROTO_LIST
  ((unsigned char *, UINT4 *, unsigned int));
static void Decode PROTO_LIST
  ((UINT4 *, unsigned char *, unsigned int));
static void MD5_memcpy PROTO_LIST ((POINTER, POINTER, unsigned int));
static void MD5_memset PROTO_LIST ((POINTER, int, unsigned int));

static unsigned char PADDING[64] = {
  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

/* F, G, H and I are basic MD5 functions.
 */
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z)))

/* ROTATE_LEFT rotates x left n bits.
 */
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))

/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
Rotation is separate from addition to prevent recomputation.
 */
#define FF(a, b, c, d, x, s, ac) { \
 (a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define GG(a, b, c, d, x, s, ac) { \
 (a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define HH(a, b, c, d, x, s, ac) { \
 (a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define II(a, b, c, d, x, s, ac) { \
 (a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }

/* MD5 initialization. Begins an MD5 operation, writing a new context.
 */
void MD5Init (context)
MD5_CTX *context;                                        /* context */
{
  context->count[0] = context->count[1] = 0;
  /* Load magic initialization constants.
*/
  context->state[0] = 0x67452301;
  context->state[1] = 0xefcdab89;
  context->state[2] = 0x98badcfe;
  context->state[3] = 0x10325476;
}

/* MD5 block update operation. Continues an MD5 message-digest
  operation, processing another message block, and updating the
  context.
 */
void MD5Update (context, input, inputLen)
MD5_CTX *context;                                        /* context */
unsigned char *input;                                /* input block */
unsigned int inputLen;                     /* length of input block */
{
  unsigned int i, index, partLen;

  /* Compute number of bytes mod 64 */
  index = (unsigned int)((context->count[0] >> 3) & 0x3F);

  /* Update number of bits */
  if ((context->count[0] += ((UINT4)inputLen << 3))
   < ((UINT4)inputLen << 3))
 context->count[1]++;
  context->count[1] += ((UINT4)inputLen >> 29);

  partLen = 64 - index;

  /* Transform as many times as possible.
*/
  if (inputLen >= partLen) {
 MD5_memcpy
   ((POINTER)&context->buffer[index], (POINTER)input, partLen);
 MD5Transform (context->state, context->buffer);

 for (i = partLen; i + 63 < inputLen; i += 64)
   MD5Transform (context->state, &input[i]);

 index = 0;
  }
  else
 i = 0;

  /* Buffer remaining input */
  MD5_memcpy
 ((POINTER)&context->buffer[index], (POINTER)&input[i],
  inputLen-i);
}

/* MD5 finalization. Ends an MD5 message-digest operation, writing the
  the message digest and zeroizing the context.
 */
void MD5Final (digest, context)
unsigned char digest[16];                         /* message digest */
MD5_CTX *context;                                       /* context */
{
  unsigned char bits[8];
  unsigned int index, padLen;

  /* Save number of bits */
  Encode (bits, context->count, 8);

  /* Pad out to 56 mod 64.
*/
  index = (unsigned int)((context->count[0] >> 3) & 0x3f);
  padLen = (index < 56) ? (56 - index) : (120 - index);
  MD5Update (context, PADDING, padLen);

  /* Append length (before padding) */
  MD5Update (context, bits, 8);
  /* Store state in digest */
  Encode (digest, context->state, 16);

  /* Zeroize sensitive information.
*/
  MD5_memset ((POINTER)context, 0, sizeof (*context));
}

/* MD5 basic transformation. Transforms state based on block.
 */
static void MD5Transform (state, block)
UINT4 state[4];
unsigned char block[64];
{
  register UINT4 a = state[0], b = state[1], c = state[2], d = state[3];
  UINT4 x[16];

#if !(defined(i386) | defined(__alpha))
  Decode (x, block, 64);

  /* Round 1 */
  FF (a, b, c, d, x[ 0], S11, 0xd76aa478); /* 1 */
  FF (d, a, b, c, x[ 1], S12, 0xe8c7b756); /* 2 */
  FF (c, d, a, b, x[ 2], S13, 0x242070db); /* 3 */
  FF (b, c, d, a, x[ 3], S14, 0xc1bdceee); /* 4 */
  FF (a, b, c, d, x[ 4], S11, 0xf57c0faf); /* 5 */
  FF (d, a, b, c, x[ 5], S12, 0x4787c62a); /* 6 */
  FF (c, d, a, b, x[ 6], S13, 0xa8304613); /* 7 */
  FF (b, c, d, a, x[ 7], S14, 0xfd469501); /* 8 */
  FF (a, b, c, d, x[ 8], S11, 0x698098d8); /* 9 */
  FF (d, a, b, c, x[ 9], S12, 0x8b44f7af); /* 10 */
  FF (c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */
  FF (b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */
  FF (a, b, c, d, x[12], S11, 0x6b901122); /* 13 */
  FF (d, a, b, c, x[13], S12, 0xfd987193); /* 14 */
  FF (c, d, a, b, x[14], S13, 0xa679438e); /* 15 */
  FF (b, c, d, a, x[15], S14, 0x49b40821); /* 16 */

 /* Round 2 */
  GG (a, b, c, d, x[ 1], S21, 0xf61e2562); /* 17 */
  GG (d, a, b, c, x[ 6], S22, 0xc040b340); /* 18 */
  GG (c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */
  GG (b, c, d, a, x[ 0], S24, 0xe9b6c7aa); /* 20 */
  GG (a, b, c, d, x[ 5], S21, 0xd62f105d); /* 21 */
  GG (d, a, b, c, x[10], S22,  0x2441453); /* 22 */
  GG (c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */
  GG (b, c, d, a, x[ 4], S24, 0xe7d3fbc8); /* 24 */
  GG (a, b, c, d, x[ 9], S21, 0x21e1cde6); /* 25 */
  GG (d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */
  GG (c, d, a, b, x[ 3], S23, 0xf4d50d87); /* 27 */
  GG (b, c, d, a, x[ 8], S24, 0x455a14ed); /* 28 */
  GG (a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
  GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */
  GG (c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */
  GG (b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */

  /* Round 3 */
  HH (a, b, c, d, x[ 5], S31, 0xfffa3942); /* 33 */
  HH (d, a, b, c, x[ 8], S32, 0x8771f681); /* 34 */
  HH (c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */
  HH (b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */
  HH (a, b, c, d, x[ 1], S31, 0xa4beea44); /* 37 */
  HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */
  HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */
  HH (b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
  HH (a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
  HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */
  HH (c, d, a, b, x[ 3], S33, 0xd4ef3085); /* 43 */
  HH (b, c, d, a, x[ 6], S34,  0x4881d05); /* 44 */
  HH (a, b, c, d, x[ 9], S31, 0xd9d4d039); /* 45 */
  HH (d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */
  HH (c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */
  HH (b, c, d, a, x[ 2], S34, 0xc4ac5665); /* 48 */

  /* Round 4 */
  II (a, b, c, d, x[ 0], S41, 0xf4292244); /* 49 */
  II (d, a, b, c, x[ 7], S42, 0x432aff97); /* 50 */
  II (c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */
  II (b, c, d, a, x[ 5], S44, 0xfc93a039); /* 52 */
  II (a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */
  II (d, a, b, c, x[ 3], S42, 0x8f0ccc92); /* 54 */
  II (c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */
  II (b, c, d, a, x[ 1], S44, 0x85845dd1); /* 56 */
  II (a, b, c, d, x[ 8], S41, 0x6fa87e4f); /* 57 */
  II (d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */
  II (c, d, a, b, x[ 6], S43, 0xa3014314); /* 59 */
  II (b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */
  II (a, b, c, d, x[ 4], S41, 0xf7537e82); /* 61 */
  II (d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */
  II (c, d, a, b, x[ 2], S43, 0x2ad7d2bb); /* 63 */
  II (b, c, d, a, x[ 9], S44, 0xeb86d391); /* 64 */
#else
  /* Round 1 */
  FF (a, b, c, d, ((UINT4 *)block)[ 0], S11, 0xd76aa478); /* 1 */
  FF (d, a, b, c, ((UINT4 *)block)[ 1], S12, 0xe8c7b756); /* 2 */
  FF (c, d, a, b, ((UINT4 *)block)[ 2], S13, 0x242070db); /* 3 */
  FF (b, c, d, a, ((UINT4 *)block)[ 3], S14, 0xc1bdceee); /* 4 */
  FF (a, b, c, d, ((UINT4 *)block)[ 4], S11, 0xf57c0faf); /* 5 */
  FF (d, a, b, c, ((UINT4 *)block)[ 5], S12, 0x4787c62a); /* 6 */
  FF (c, d, a, b, ((UINT4 *)block)[ 6], S13, 0xa8304613); /* 7 */
  FF (b, c, d, a, ((UINT4 *)block)[ 7], S14, 0xfd469501); /* 8 */
  FF (a, b, c, d, ((UINT4 *)block)[ 8], S11, 0x698098d8); /* 9 */
  FF (d, a, b, c, ((UINT4 *)block)[ 9], S12, 0x8b44f7af); /* 10 */
  FF (c, d, a, b, ((UINT4 *)block)[10], S13, 0xffff5bb1); /* 11 */
  FF (b, c, d, a, ((UINT4 *)block)[11], S14, 0x895cd7be); /* 12 */
  FF (a, b, c, d, ((UINT4 *)block)[12], S11, 0x6b901122); /* 13 */
  FF (d, a, b, c, ((UINT4 *)block)[13], S12, 0xfd987193); /* 14 */
  FF (c, d, a, b, ((UINT4 *)block)[14], S13, 0xa679438e); /* 15 */
  FF (b, c, d, a, ((UINT4 *)block)[15], S14, 0x49b40821); /* 16 */

 /* Round 2 */
  GG (a, b, c, d, ((UINT4 *)block)[ 1], S21, 0xf61e2562); /* 17 */
  GG (d, a, b, c, ((UINT4 *)block)[ 6], S22, 0xc040b340); /* 18 */
  GG (c, d, a, b, ((UINT4 *)block)[11], S23, 0x265e5a51); /* 19 */
  GG (b, c, d, a, ((UINT4 *)block)[ 0], S24, 0xe9b6c7aa); /* 20 */
  GG (a, b, c, d, ((UINT4 *)block)[ 5], S21, 0xd62f105d); /* 21 */
  GG (d, a, b, c, ((UINT4 *)block)[10], S22,  0x2441453); /* 22 */
  GG (c, d, a, b, ((UINT4 *)block)[15], S23, 0xd8a1e681); /* 23 */
  GG (b, c, d, a, ((UINT4 *)block)[ 4], S24, 0xe7d3fbc8); /* 24 */
  GG (a, b, c, d, ((UINT4 *)block)[ 9], S21, 0x21e1cde6); /* 25 */
  GG (d, a, b, c, ((UINT4 *)block)[14], S22, 0xc33707d6); /* 26 */
  GG (c, d, a, b, ((UINT4 *)block)[ 3], S23, 0xf4d50d87); /* 27 */
  GG (b, c, d, a, ((UINT4 *)block)[ 8], S24, 0x455a14ed); /* 28 */
  GG (a, b, c, d, ((UINT4 *)block)[13], S21, 0xa9e3e905); /* 29 */
  GG (d, a, b, c, ((UINT4 *)block)[ 2], S22, 0xfcefa3f8); /* 30 */
  GG (c, d, a, b, ((UINT4 *)block)[ 7], S23, 0x676f02d9); /* 31 */
  GG (b, c, d, a, ((UINT4 *)block)[12], S24, 0x8d2a4c8a); /* 32 */

  /* Round 3 */
  HH (a, b, c, d, ((UINT4 *)block)[ 5], S31, 0xfffa3942); /* 33 */
  HH (d, a, b, c, ((UINT4 *)block)[ 8], S32, 0x8771f681); /* 34 */
  HH (c, d, a, b, ((UINT4 *)block)[11], S33, 0x6d9d6122); /* 35 */
  HH (b, c, d, a, ((UINT4 *)block)[14], S34, 0xfde5380c); /* 36 */
  HH (a, b, c, d, ((UINT4 *)block)[ 1], S31, 0xa4beea44); /* 37 */
  HH (d, a, b, c, ((UINT4 *)block)[ 4], S32, 0x4bdecfa9); /* 38 */
  HH (c, d, a, b, ((UINT4 *)block)[ 7], S33, 0xf6bb4b60); /* 39 */
  HH (b, c, d, a, ((UINT4 *)block)[10], S34, 0xbebfbc70); /* 40 */
  HH (a, b, c, d, ((UINT4 *)block)[13], S31, 0x289b7ec6); /* 41 */
  HH (d, a, b, c, ((UINT4 *)block)[ 0], S32, 0xeaa127fa); /* 42 */
  HH (c, d, a, b, ((UINT4 *)block)[ 3], S33, 0xd4ef3085); /* 43 */
  HH (b, c, d, a, ((UINT4 *)block)[ 6], S34,  0x4881d05); /* 44 */
  HH (a, b, c, d, ((UINT4 *)block)[ 9], S31, 0xd9d4d039); /* 45 */
  HH (d, a, b, c, ((UINT4 *)block)[12], S32, 0xe6db99e5); /* 46 */
  HH (c, d, a, b, ((UINT4 *)block)[15], S33, 0x1fa27cf8); /* 47 */
  HH (b, c, d, a, ((UINT4 *)block)[ 2], S34, 0xc4ac5665); /* 48 */

  /* Round 4 */
  II (a, b, c, d, ((UINT4 *)block)[ 0], S41, 0xf4292244); /* 49 */
  II (d, a, b, c, ((UINT4 *)block)[ 7], S42, 0x432aff97); /* 50 */
  II (c, d, a, b, ((UINT4 *)block)[14], S43, 0xab9423a7); /* 51 */
  II (b, c, d, a, ((UINT4 *)block)[ 5], S44, 0xfc93a039); /* 52 */
  II (a, b, c, d, ((UINT4 *)block)[12], S41, 0x655b59c3); /* 53 */
  II (d, a, b, c, ((UINT4 *)block)[ 3], S42, 0x8f0ccc92); /* 54 */
  II (c, d, a, b, ((UINT4 *)block)[10], S43, 0xffeff47d); /* 55 */
  II (b, c, d, a, ((UINT4 *)block)[ 1], S44, 0x85845dd1); /* 56 */
  II (a, b, c, d, ((UINT4 *)block)[ 8], S41, 0x6fa87e4f); /* 57 */
  II (d, a, b, c, ((UINT4 *)block)[15], S42, 0xfe2ce6e0); /* 58 */
  II (c, d, a, b, ((UINT4 *)block)[ 6], S43, 0xa3014314); /* 59 */
  II (b, c, d, a, ((UINT4 *)block)[13], S44, 0x4e0811a1); /* 60 */
  II (a, b, c, d, ((UINT4 *)block)[ 4], S41, 0xf7537e82); /* 61 */
  II (d, a, b, c, ((UINT4 *)block)[11], S42, 0xbd3af235); /* 62 */
  II (c, d, a, b, ((UINT4 *)block)[ 2], S43, 0x2ad7d2bb); /* 63 */
  II (b, c, d, a, ((UINT4 *)block)[ 9], S44, 0xeb86d391); /* 64 */
#endif

  state[0] += a;
  state[1] += b;
  state[2] += c;
  state[3] += d;

  /* Zeroize sensitive information.
*/
#if !(defined(i386) | defined(__alpha))
  MD5_memset ((POINTER)x, 0, sizeof (x));
#endif
}

/* Encodes input (UINT4) into output (unsigned char). Assumes len is
  a multiple of 4.
 */
static void Encode (output, input, len)
unsigned char *output;
UINT4 *input;
unsigned int len;
{
  unsigned int i, j;

  for (i = 0, j = 0; j < len; i++, j += 4) {
 output[j] = (unsigned char)(input[i] & 0xff);
 output[j+1] = (unsigned char)((input[i] >> 8) & 0xff);
 output[j+2] = (unsigned char)((input[i] >> 16) & 0xff);
 output[j+3] = (unsigned char)((input[i] >> 24) & 0xff);
  }
}

/* Decodes input (unsigned char) into output (UINT4). Assumes len is
  a multiple of 4.
 */
static void Decode (output, input, len)
UINT4 *output;
unsigned char *input;
unsigned int len;
{
  unsigned int i, j;
  register UINT4 out,other;

/*
  for (i = 0, j = 0; j < len; i++, j += 4)
 output[i] = ((UINT4)input[j]) | (((UINT4)input[j+1]) << 8) |
   (((UINT4)input[j+2]) << 16) | (((UINT4)input[j+3]) << 24);
*/
#if (!defined(hpux))
#define swapbyte(src,dst) { \
     out = ROTATE_LEFT((src),16); \
     other = out >> 8; \
     other &= 0x00ff00ff; \
     out &= 0x00ff00ff; \
     out <<= 8; \
     (dst) = out | other; \
     }
#else
#define swapbyte(src,dst) { \
     (dst) = (ROTATE_LEFT((src),8) & 0x00ff00ff) | ROTATE_LEFT((src) & 0x00ff00ff,24); \
     }
#endif

swapbyte(((UINT4 *)input)[0],output[0]);
swapbyte(((UINT4 *)input)[1],output[1]);
swapbyte(((UINT4 *)input)[2],output[2]);
swapbyte(((UINT4 *)input)[3],output[3]);
swapbyte(((UINT4 *)input)[4],output[4]);
swapbyte(((UINT4 *)input)[5],output[5]);
swapbyte(((UINT4 *)input)[6],output[6]);
swapbyte(((UINT4 *)input)[7],output[7]);
swapbyte(((UINT4 *)input)[8],output[8]);
swapbyte(((UINT4 *)input)[9],output[9]);
swapbyte(((UINT4 *)input)[10],output[10]);
swapbyte(((UINT4 *)input)[11],output[11]);
swapbyte(((UINT4 *)input)[12],output[12]);
swapbyte(((UINT4 *)input)[13],output[13]);
swapbyte(((UINT4 *)input)[14],output[14]);
swapbyte(((UINT4 *)input)[15],output[15]);

}

/* Note: Replace "for loop" with standard memcpy if possible.
 */

static void MD5_memcpy (output, input, len)
POINTER output;
POINTER input;
unsigned int len;
{
/*
  unsigned int i;

  for (i = 0; i < len; i++)
 output[i] = input[i];
*/
  memcpy(output,input,len);
}

/* Note: Replace "for loop" with standard memset if possible.
 */
static void MD5_memset (output, value, len)
POINTER output;
int value;
unsigned int len;
{
/*
  unsigned int i;

  for (i = 0; i < len; i++)
 ((char *)output)[i] = (char)value;
*/
  memset(output,value,len);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rrcm\rtcp\rtcprept.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTCPREPT.C
 * Product:     RTP/RTCP implementation
 * Description: Provides report functions for the RRCM implementation.
 *
 * $Workfile:   rtcprept.cpp  $
 * $Author:   CMACIOCC  $
 * $Date:   20 May 1997 09:18:06  $
 * $Revision:   1.14  $
 * $Archive:   R:\rtp\src\rrcm\rtcp\rtcprept.cpv  $
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/

		
#include "rrcm.h"                                    

#define	ENABLE_RPT_TRACE	0
     
/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/            


/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/     
extern PRTCP_CONTEXT	pRTCPContext;
extern RRCM_WS			RRCMws;
#ifdef _DEBUG
extern char				debug_string[];
#endif




/*----------------------------------------------------------------------------
 * Function   : RTCPReportRequest
 * Description: The application request a report for a particular RTCP 
 *				session, identified by the socket descriptor.
 * 
 * Input :		RTCPsd:				RTCP socket descriptor
 *				offset:				Offset to start from in the list
 *				*status:			-> to the report status information
 *				*moreEntries:		-> to a flag
 *				numEntriesInBfr:	Number of entries in buffer
 *				pReportBfr:			-> to report buffer
 *				iFilterFlags		Bit flags specifying filter to apply
 *				pFilterPattern		-> to value of filter pattern to use
 *				dwFltrPtrnLen		Filter pattern length
 *
 * Return:		OK: RRCM_NoError
 *				!0: Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
#if 0
RRCMSTDAPI RTCPReportRequest (SOCKET RTCPsd, 
							  DWORD offset, 
							  DWORD *status,
							  DWORD *moreEntries, 
							  DWORD numEntriesInBfr, 
							  PRTCP_REPORT pReportBfr,
							  DWORD dwFilterFlags,
							  LPVOID pFilterPattern,
							  DWORD dwFltrPtrnLen)
	{    
	PLINK_LIST	pTmp;
	PSSRC_ENTRY pRRCM;
	DWORD		dwStatus = RRCM_NoError;
	DWORD		numEntryWritten = 0;
	DWORD		index;
	DWORD		dwLost;
	DWORD		dwTmp;
	BOOL		matched;
	
	IN_OUT_STR ("RTCP: Enter RTCPReportRequest()\n");

	ASSERT (pReportBfr);
	ASSERT (numEntriesInBfr);

	// look for the RTCP session 
	pTmp  = pRTCPContext->RTCPSession.prev;
	if (pTmp == NULL)
		{
		RRCM_DBG_MSG ("RTCP: ERROR - Invalid RTCP session", 0, 
					  __FILE__, __LINE__, DBG_ERROR);
		IN_OUT_STR ("RTCP: Exit RTCPReportRequest()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTCPInvalidSession));
		}

	pRRCM = (PSSRC_ENTRY)((PRTCP_SESSION)pTmp)->XmtSSRCList.prev;
	if (pRRCM == NULL)
		{
		RRCM_DBG_MSG ("RCTP : ERROR - No RTCP Xmt list", 0, 
					  __FILE__, __LINE__, DBG_ERROR);
		IN_OUT_STR ("RTCP: Exit RTCPReportRequest()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTCPNoXmtList));
		}

	while (pTmp)
		{
		if (pRRCM->RTCPsd == RTCPsd)
			break;
		else
			{
			pTmp  = pTmp->next;

			if (pTmp)
				{
				pRRCM = (PSSRC_ENTRY)((PRTCP_SESSION)pTmp)->XmtSSRCList.prev;
				}

			continue;
			}
		}

	if (pTmp == NULL)
		{
		RRCM_DBG_MSG ("RTCP: ERROR - Invalid RTCP session", 0, 
					  __FILE__, __LINE__, DBG_ERROR);
		IN_OUT_STR ("RTCP: Exit RTCPReportRequest()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTCPInvalidSession));
		}

	if (dwFilterFlags && (pFilterPattern == NULL))
		{
		RRCM_DBG_MSG ("RTCP: ERROR - Invalid RTCP FilterPattern is NULL", 0, 
					  __FILE__, __LINE__, DBG_ERROR);
		IN_OUT_STR ("RTCP: Exit RTCPReportRequest()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTCPInvalidRequest));
		}

#ifdef _DEBUG
#if ENABLE_RPT_TRACE
	wsprintf(debug_string, 
			"RTCP: Report - Num. entries requested: %d, from offset: %d", 
			numEntriesInBfr, offset);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif
#endif

	// go through the list of transmitters for this RTCP session 
	pRRCM = (PSSRC_ENTRY)((PRTCP_SESSION)pTmp)->XmtSSRCList.prev;

	index = 0;
	while (pRRCM && numEntriesInBfr)
		{
		// go to the desired offset 
		if (offset)
			{
			offset--;
			pRRCM = (PSSRC_ENTRY)pRRCM->SSRCList.next;
			continue;
			}

		if (dwFilterFlags)
			{
			matched = FALSE;
			switch (dwFilterFlags)
				{
				case FLTR_SSRC:
					if(pRRCM->SSRC == *((DWORD *)pFilterPattern))
						matched=TRUE;
					break;
				case FLTR_CNAME:
					if((memcmp ((char *)pFilterPattern, 
								pRRCM->sdesItem[SDES_INDEX(RTCP_SDES_CNAME)].sdesBfr, 
								dwFltrPtrnLen)) == 0)
						matched = TRUE;
					break;
				default:
					RRCM_DBG_MSG ("RTCP: ERROR - Invalid FilterFlag", 0, 
								  __FILE__, __LINE__, DBG_ERROR);
					IN_OUT_STR ("RTCP: Exit RTCPReportRequest()\n");

					return (MAKE_RRCM_ERROR(RRCMError_RTCPNotImpl));
				}

			if (!matched)
				{
				pRRCM = (PSSRC_ENTRY)pRRCM->SSRCList.next;
				continue;
				}
			else
				numEntriesInBfr--;
			}
		else
			numEntriesInBfr--;

		// fill in the our active Sender report information
		pReportBfr[index].status  = LOCAL_SSRC_RPT;
		pReportBfr[index].ssrc    = pRRCM->SSRC;

#ifdef _DEBUG
#if ENABLE_RPT_TRACE
		wsprintf(debug_string, "RTCP: Report - SSRC:%08X - Status:%04X", 
					pRRCM->SSRC, pReportBfr[index].status);
		RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif
#endif

		// lock-out bytes update
		EnterCriticalSection (&pRRCM->critSect);

		pReportBfr[index].dwSrcNumPcktRealTime = pRRCM->xmtInfo.dwNumPcktSent;
		pReportBfr[index].dwSrcNumByteRealTime = pRRCM->xmtInfo.dwNumBytesSent;

		// release lock
		LeaveCriticalSection (&pRRCM->critSect);

		// a source - It's supposed to know it's own payload type
		pReportBfr[index].PayLoadType  = UNKNOWN_PAYLOAD_TYPE;

		// our own sampling frequency
		pReportBfr[index].dwStreamClock = pRRCM->dwStreamClock;

		if (pRRCM->sdesItem[SDES_INDEX(RTCP_SDES_CNAME)].dwSdesLength)
			{
			CopyMemory(pReportBfr[index].cname, 
                       pRRCM->sdesItem[SDES_INDEX(RTCP_SDES_CNAME)].sdesBfr, 
                       pRRCM->sdesItem[SDES_INDEX(RTCP_SDES_CNAME)].dwSdesLength);

			pReportBfr[index].dwCnameLen =
				pRRCM->sdesItem[SDES_INDEX(RTCP_SDES_CNAME)].dwSdesLength;
			}
		else
			{
			pReportBfr[index].dwCnameLen = 0;
			}

		if (pRRCM->sdesItem[SDES_INDEX(RTCP_SDES_NAME)].dwSdesLength)
			{
			CopyMemory(pReportBfr[index].name, 
                       pRRCM->sdesItem[SDES_INDEX(RTCP_SDES_NAME)].sdesBfr, 
                       pRRCM->sdesItem[SDES_INDEX(RTCP_SDES_NAME)].dwSdesLength);

			pReportBfr[index].dwNameLen =
				pRRCM->sdesItem[SDES_INDEX(RTCP_SDES_NAME)].dwSdesLength;
			}
		else
			{
			pReportBfr[index].dwNameLen = 0;
			}

		if (pRRCM->fromLen)
			{
			CopyMemory(&pReportBfr[index].fromAddr, 
                       &pRRCM->from, 
                       pRRCM->fromLen);

			pReportBfr[index].dwFromLen = pRRCM->fromLen;
			}
		else
			{
			pReportBfr[index].dwFromLen = 0;
			}

		numEntryWritten++;
		index++;

		// go to next entry 
		pRRCM = (PSSRC_ENTRY)pRRCM->SSRCList.next;
		}

	// go through the list of receivers for this RTCP session 
	pRRCM = (PSSRC_ENTRY)((PRTCP_SESSION)pTmp)->RcvSSRCList.prev;

	while (pRRCM && numEntriesInBfr)
		{
		// go to the desired offset 
		if (offset)
			{
			offset--;
			pRRCM = (PSSRC_ENTRY)pRRCM->SSRCList.next;
			continue;
			}

		if (dwFilterFlags)
			{
			matched = FALSE;
			switch (dwFilterFlags)
				{
				case FLTR_SSRC:
					if(pRRCM->SSRC == *((DWORD *)pFilterPattern))
						matched=TRUE;
					break;
				case FLTR_CNAME:
					if((memcmp ((char *)pFilterPattern, 
								pRRCM->sdesItem[SDES_INDEX(RTCP_SDES_CNAME)].sdesBfr, 
								dwFltrPtrnLen)) == 0)
						matched = TRUE;
					break;
				default:
					RRCM_DBG_MSG ("RTCP: ERROR - Invalid FilterFlag", 0, 
								  __FILE__, __LINE__, DBG_ERROR);
					IN_OUT_STR ("RTCP: Exit RTCPReportRequest()\n");

					return (MAKE_RRCM_ERROR(RRCMError_RTCPNotImpl));
				}

			if (!matched)
				{
				pRRCM = (PSSRC_ENTRY)pRRCM->SSRCList.next;
				continue;
				}
			else
				numEntriesInBfr--;
			}
		else
			numEntriesInBfr--;

		// fill in the Receiver report information
		pReportBfr[index].ssrc   = pRRCM->SSRC;
		pReportBfr[index].status = REMOTE_SSRC_RPT;

		// lock-out counters update
		EnterCriticalSection (&pRRCM->critSect);

#ifdef ENABLE_FLOATING_POINT
		pReportBfr[index].SrcJitter     = pRRCM->rcvInfo.interJitter;
#else
		// Check RFC for details of the round off
		pReportBfr[index].SrcJitter     = pRRCM->rcvInfo.interJitter >> 4;
#endif
		pReportBfr[index].dwSrcXtndNum  = 
			pRRCM->rcvInfo.XtendedSeqNum.seq_union.dwXtndedHighSeqNumRcvd;

		// real time receive information
		pReportBfr[index].dwSrcNumPcktRealTime  = pRRCM->rcvInfo.dwNumPcktRcvd;
		pReportBfr[index].dwSrcNumByteRealTime  = pRRCM->rcvInfo.dwNumBytesRcvd;

		// get sender information from Sender's RTCP report
		pReportBfr[index].dwSrcNumPckt  = pRRCM->xmtInfo.dwNumPcktSent;
		pReportBfr[index].dwSrcNumByte  = pRRCM->xmtInfo.dwNumBytesSent;
		pReportBfr[index].dwSrcLsr      = pRRCM->xmtInfo.dwLastSR;
		pReportBfr[index].dwSrcNtpMsw   = pRRCM->xmtInfo.dwNTPmsw;
		pReportBfr[index].dwSrcNtpLsw   = pRRCM->xmtInfo.dwNTPlsw;
		pReportBfr[index].dwSrcRtpTs    = pRRCM->xmtInfo.dwRTPts;

		dwLost = getSSRCpcktLoss (pRRCM, FALSE);

		// release lock
		LeaveCriticalSection (&pRRCM->critSect);

		// the last payload seen on this RTP stream
		pReportBfr[index].PayLoadType  = pRRCM->PayLoadType;

		// last report received time
		pReportBfr[index].dwLastReportRcvdTime  = pRRCM->dwLastReportRcvdTime;

		// fraction lost is in network byte order
		pReportBfr[index].SrcFraction = (dwLost & 0xFF);

		// cumulative lost is a 24 bits value in network byte order
		RRCMws.ntohl (pRRCM->RTPsd, dwLost, &dwTmp);
		dwTmp &= 0x00FFFFFF;
		pReportBfr[index].SrcNumLost = dwTmp;

		// get feedback information 
		if (pRRCM->rrFeedback.SSRC)
			{
			pReportBfr[index].status |= FEEDBACK_FOR_LOCAL_SSRC_PRESENT;
			CopyMemory(&pReportBfr[index].feedback, &pRRCM->rrFeedback,
                       sizeof(RTCP_FEEDBACK));
			}
		else
			{
			ZeroMemory(&pReportBfr[index].feedback, sizeof(RTCP_FEEDBACK));
			}

#ifdef _DEBUG
#if ENABLE_RPT_TRACE
		wsprintf(debug_string, "RTCP: Report - SSRC:%08X - Status:%04X", 
					pRRCM->SSRC, pReportBfr[index].status);
		RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);

		if (pRRCM->rrFeedback.SSRC)
			{
			wsprintf(debug_string, 
					 "RTCP: Report - Fdbk SSRC:%08X - Frac.:%d - Cum Loss:%d",
					 pRRCM->rrFeedback.SSRC, 
					 pRRCM->rrFeedback.fractionLost,
					 pRRCM->rrFeedback.cumNumPcktLost);
			RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
			}
#endif
#endif

		if (pRRCM->sdesItem[SDES_INDEX(RTCP_SDES_CNAME)].dwSdesLength)
			{
			CopyMemory(pReportBfr[index].cname, 
                       pRRCM->sdesItem[SDES_INDEX(RTCP_SDES_CNAME)].sdesBfr, 
                       pRRCM->sdesItem[SDES_INDEX(RTCP_SDES_CNAME)].dwSdesLength);

			pReportBfr[index].dwCnameLen = pRRCM->sdesItem[SDES_INDEX(RTCP_SDES_CNAME)].dwSdesLength;
			}
		else
			{
			pReportBfr[index].dwCnameLen = 0;
			}

		if (pRRCM->sdesItem[SDES_INDEX(RTCP_SDES_NAME)].dwSdesLength)
			{
			CopyMemory(pReportBfr[index].name, 
                       pRRCM->sdesItem[SDES_INDEX(RTCP_SDES_NAME)].sdesBfr, 
                       pRRCM->sdesItem[SDES_INDEX(RTCP_SDES_NAME)].dwSdesLength);

			pReportBfr[index].dwNameLen =
				pRRCM->sdesItem[SDES_INDEX(RTCP_SDES_NAME)].dwSdesLength;
			}
		else
			{
			pReportBfr[index].dwNameLen = 0;
			}

		if (pRRCM->fromLen)
			{
			CopyMemory(&pReportBfr[index].fromAddr, 
                       &pRRCM->from, 
                       pRRCM->fromLen);

			pReportBfr[index].dwFromLen = pRRCM->fromLen;
			}
		else
			{
			pReportBfr[index].dwFromLen = 0;
			}

		numEntryWritten++;
		index++;

		// go to next entry 
		pRRCM = (PSSRC_ENTRY)pRRCM->SSRCList.next;
		}

	// check to see if there are additional entries 
	if (pRRCM != NULL)
		*moreEntries = TRUE;

	*status = numEntryWritten;

	IN_OUT_STR ("RTCP: Exit RTCPReportRequest()\n");
	return (dwStatus);	
	}

#endif

/*----------------------------------------------------------------------------
 * Function   : getRtcpSessionList
 * Description: Get a list of current RTCP session.
 * 
 * Input :		pSockBfr:		-> to a socket buffer
 *				pNumEntries:	-> to number of allocated entries in buffers.
 *				pNumUpdated:	-> number of entries updated
 *
 * Return:		OK: RRCM_NoError
 *				!0: Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
#if 0
RRCMSTDAPI getRtcpSessionList (PDWORD pSockBfr, 
							   DWORD dwNumEntries,
							   PDWORD pNumUpdated)
	{
	DWORD			dwStatus = RRCM_NoError;
	PRTCP_SESSION	pRTCP;
	PSSRC_ENTRY		pSSRC;

	IN_OUT_STR ("RTCP: Enter getRtpSessionList()\n");

	// lock out session's access
	EnterCriticalSection (&pRTCPContext->critSect);

	*pNumUpdated = 0;

	// look for the RTCP session 
	pRTCP  = (PRTCP_SESSION)pRTCPContext->RTCPSession.prev;
	if (pRTCP == NULL)
		{
		// Unlock out session's access
		LeaveCriticalSection (&pRTCPContext->critSect);

		IN_OUT_STR ("RTCP: Exit getRtpSessionList()\n");

		return (MAKE_RRCM_ERROR (RRCMError_RTPNoSession));
		}

	// loop through the session's list
	while (pRTCP)
		{
		pSSRC = (PSSRC_ENTRY)pRTCP->XmtSSRCList.prev;
		if (pSSRC == NULL)
			{
			// Unlock out session's access
			LeaveCriticalSection (&pRTCPContext->critSect);

			RRCM_DBG_MSG ("RCTP : ERROR - No RTCP Xmt list", 0, 
						  __FILE__, __LINE__, DBG_ERROR);

			IN_OUT_STR ("RTCP: Exit getRtpSessionList()\n");

			return (MAKE_RRCM_ERROR (RRCMError_RTCPNoXmtList));
			}

		if (dwNumEntries)
			{
			pSockBfr[*pNumUpdated] = pSSRC->RTCPsd;

			*pNumUpdated += 1;
			dwNumEntries --;
			}

		if (dwNumEntries == 0)
			{
			break;
			}

		// next entry
		pRTCP = (PRTCP_SESSION)(pRTCP->RTCPList.next);
		}

	// Unlock out session's access
	LeaveCriticalSection (&pRTCPContext->critSect);

	IN_OUT_STR ("RTCP: Exit getRtpSessionList()\n");

	return dwStatus;
	}
#endif
// [EOF]


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rrcm\rtcp\rtcpinit.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTCPINIT.C
 * Product:     RTP/RTCP implementation
 * Description: Provides RTCP initialization functions.
 *
 * $Workfile:   RTCPINIT.CPP  $
 * $Author:   CMACIOCC  $
 * $Date:   13 Feb 1997 14:47:42  $
 * $Revision:   1.1  $
 * $Archive:   R:\rtp\src\rrcm\rtcp\rtcpinit.cpv  $
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/

		
#include "rrcm.h"                                    


/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/            
PRTCP_CONTEXT	pRTCPContext = NULL;
PRTCP_CONTEXT	pRTCPContext2 = NULL; // debugging purposes



/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/
extern PRTP_CONTEXT	pRTPContext;


/*----------------------------------------------------------------------------
 * Function   : initRTCP
 * Description: RTCP initialization procedures. Creates the initial RTCP 
 *				session and allocates all initial memory resources.
 * 
 * Input :      None.
 *
 * Return: 		OK: RRCM_NoError
 *         		!0: Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
 DWORD initRTCP (void)
	{
	DWORD		dwStatus = RRCM_NoError;  

	IN_OUT_STR ("RTCP: Enter initRTCP()\n");

	// If RTCP has already been initialized, exit and report the error 
	if (pRTCPContext != NULL) 
		{
		RRCM_DBG_MSG ("RTCP: ERROR - Multiple RTCP Instances", 0, 
					  __FILE__, __LINE__, DBG_CRITICAL);

		IN_OUT_STR ("RTCP: Exit initRTCP()\n");
		return (RRCMError_RTCPReInit);
		}

	// Obtain RTCP context 
	pRTCPContext = (PRTCP_CONTEXT)GlobalAlloc (GMEM_FIXED | GMEM_ZEROINIT, 
											   sizeof(RTCP_CONTEXT));
	
	if (pRTCPContext == NULL) 
		{
		RRCM_DBG_MSG ("RTCP: ERROR - Resource allocation failed", 0, 
					  __FILE__, __LINE__, DBG_CRITICAL);

		IN_OUT_STR ("RTCP: Exit initRTCP()\n");

		return RRCMError_RTCPResources;
		}

	// initialize the context critical section 
	InitializeCriticalSection(&pRTCPContext->critSect);
	InitializeCriticalSection(&pRTCPContext->HeapCritSect);
	InitializeCriticalSection(&pRTCPContext->CreateThreadCritSect);

	// Initialize number of desired free cells 
	pRTCPContext->dwInitNumFreeRRCMStat = pRTPContext->registry.NumFreeSSRC;

	// allocate heaps 
	dwStatus = allocateRTCPContextHeaps (pRTCPContext);
 	if (dwStatus == RRCM_NoError)
		{
		// allocate free list of SSRCs statistic entries 
 		dwStatus = allocateLinkedList (&pRTCPContext->RRCMFreeStat,
									   pRTCPContext->hHeapRRCMStat,
 						 	 		   &pRTCPContext->dwInitNumFreeRRCMStat,
 						 	 		   sizeof(SSRC_ENTRY),
									   &pRTCPContext->HeapCritSect);
		}

	// initialize the pseudo-random number generator, for later MD5 use
	RRCMsrand ((unsigned int)timeGetTime());

	// If initialation failed return all resourses allocated 
	if (dwStatus != RRCM_NoError) 
		deleteRTCP ();

	IN_OUT_STR ("RTCP: Exit initRTCP()\n");

	return (dwStatus); 		
	}

                                                                              
                                                                              
/*----------------------------------------------------------------------------
 * Function   : deleteRTCP
 * Description: RTCP delete procedures. All RTCP sessions have been deleted 
 *				at this point, so just delete what's needed.
 * 
 * Input :      None.
 *
 * Return: 		FALSE	: OK.
 *         		TRUE  	: Error code. RTCP couldn't be initialized.
 ---------------------------------------------------------------------------*/
 DWORD deleteRTCP (void)
	{   
	IN_OUT_STR ("RTCP: Enter deleteRTCP()\n");

	ASSERT (pRTCPContext);

	// protect everything from the top 
	EnterCriticalSection (&pRTCPContext->critSect);

	// delete all heaps 
	if (pRTCPContext->hHeapRRCMStat) 
		{
		if (HeapDestroy (pRTCPContext->hHeapRRCMStat) == FALSE)
			{
			RRCM_DBG_MSG ("RTCP: ERROR - HeapDestroy", GetLastError(),
						  __FILE__, __LINE__, DBG_ERROR);
			}
		}

	if (pRTCPContext->hHeapRTCPSes) 
		{
		if (HeapDestroy (pRTCPContext->hHeapRTCPSes) == FALSE)
			{
			RRCM_DBG_MSG ("RTCP: ERROR - HeapDestroy", GetLastError(),
						  __FILE__, __LINE__, DBG_ERROR);
			}
		}

	// protect everything from the top 
	LeaveCriticalSection (&pRTCPContext->critSect);

	DeleteCriticalSection (&pRTCPContext->critSect);
	DeleteCriticalSection (&pRTCPContext->HeapCritSect);
	DeleteCriticalSection (&pRTCPContext->CreateThreadCritSect);

	// Clean up our context resources 
	GlobalFree (pRTCPContext);
	pRTCPContext2 = pRTCPContext;
	pRTCPContext = NULL;

	IN_OUT_STR ("RTCP: Exit deleteRTCP()\n");
	return (TRUE);
	}


// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rrcm\rtcp\rtcpsend.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTCPIO.C
 * Product:     RTP/RTCP implementation
 * Description: Provides the RTCP network I/O.
 *
 * $Workfile:   rtcpsend.cpp  $
 * $Author:   CMACIOCC  $
 * $Date:   18 Feb 1997 13:24:08  $
 * $Revision:   1.14  $
 * $Archive:   R:\rtp\src\rrcm\rtcp\rtcpsend.cpv  $
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/


#include "rrcm.h"                                    


/*---------------------------------------------------------------------------
/                           Global Variables
/--------------------------------------------------------------------------*/            
#define DBG_CUM_FRACT_LOSS  0
#define FRACTION_ENTRIES    10
#define FRACTION_SHIFT_MAX  32
long    microSecondFrac [FRACTION_ENTRIES] = {500000,
                                              250000,
                                              125000,
                                               62500,
                                               31250,
                                               15625,
                                                7812,   // some precision lost
                                                3906,   // some precision lost
                                                1953,   // some precision lost
                                                 976};  // ~ 1 milli second



/*---------------------------------------------------------------------------
/                           External Variables
/--------------------------------------------------------------------------*/                                       
extern PRTCP_CONTEXT    pRTCPContext;
extern RRCM_WS          RRCMws;

#ifdef ENABLE_ISDM2
extern ISDM2            Isdm2;
#endif

#ifdef _DEBUG
extern char     debug_string[];
#endif

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
extern LPInteropLogger RTPLogger;
#endif



/*----------------------------------------------------------------------------
 * Function   : xmtRTCPreport
 * Description: RTCP report generator
 * 
 * Input :      pSSRC   : -> to the SSRC entry
 *
 * Return:      None.
 ---------------------------------------------------------------------------*/
PRTCP_BFR_LIST FormatRTCPReport (PRTCP_SESSION pRTCP, 
                                 PSSRC_ENTRY pSSRC, 
                                 DWORD curTime)
    {
    PRTCP_BFR_LIST      pXmtStruct;
    PLINK_LIST          pTmp;
    RTCP_COMMON_T       *pRTCPhdr;
    RTCP_RR_T           *pRTCPrr;
    RECEIVER_RPT        *pRTCPrecvr;
    SENDER_RPT          *pRTCPsr;
    DWORD               numRcvRpt;
    DWORD               numSrc;
    SOCKET              sd;
    DWORD               dwTotalRtpBW = 0;
    PDWORD              pLastWord;
    SDES_DATA           SdesData[MAX_NUM_SDES];
    PCHAR               pData;
    long                pcktLen;
    int                 weSent = FALSE;

#ifdef _DEBUG
    DWORD               timeDiff;
#endif

#ifdef ENABLE_ISDM2
    // update ISDM
    if (Isdm2.hISDMdll && pSSRC->hISDM) 
        updateISDMstat (pSSRC, &Isdm2, XMITR, TRUE);
#endif

    // get a free RTCP buffer for a transmit operation 
    pXmtStruct = (PRTCP_BFR_LIST)removePcktFromTail(&pRTCP->RTCPxmtBfrList,
                                                    &pRTCP->BfrCritSect);

    // check buffer 
    if (pXmtStruct == NULL)
        {
        RRCM_DBG_MSG ("RTCP: ERROR - No Xmt Bfr Available", 0, 
                      __FILE__, __LINE__, DBG_ERROR);

        return NULL;
        }

    // clear SDES buffer
    ZeroMemory (SdesData, sizeof(SdesData));

    // lock out access to the SSRC entry 
    EnterCriticalSection (&pSSRC->critSect);

    // SSRC entry address 
    pXmtStruct->pSSRC = pSSRC;

    // target address 
    CopyMemory(&pXmtStruct->addr, &pRTCP->toAddr, pRTCP->toAddrLen);

    // target address length 
    pXmtStruct->addrLen = pRTCP->toAddrLen;

    // use hEvent to recover the buffer's address 
    pXmtStruct->overlapped.hEvent = (WSAEVENT)pXmtStruct;

    // socket descriptor 
    sd = pSSRC->pRTPses->pSocket[SOCK_RTCP];

    // RTCP common header 
    pRTCPhdr = (RTCP_COMMON_T *)pXmtStruct->bfr.buf;

    // RTP protocol version 
    pRTCPhdr->type = RTP_TYPE;

    // reset the flag
    weSent = 0;

    // SR or RR ? Check our Xmt list entry to know if we've sent data 
    if (pSSRC->xmtInfo.dwCurXmtSeqNum != pSSRC->xmtInfo.dwPrvXmtSeqNum)
        {
        // set flag for Bw calculation 
        weSent = TRUE;

        // update packet count 
        pSSRC->xmtInfo.dwPrvXmtSeqNum = pSSRC->xmtInfo.dwCurXmtSeqNum;

        // build SR
        RTCPbuildSenderRpt (pSSRC, pRTCPhdr, &pRTCPsr, sd);

        // set the receiver report pointer 
        pData = (PCHAR)(pRTCPsr + 1);

        // adjust for the additional structure defined in the SENDER_RPT
        pData -= sizeof (RTCP_RR_T);

        pRTCPrr = (RTCP_RR_T *)pData;

#ifdef DYNAMIC_RTCP_BW
        // calculate the RTP bandwidth used by this transmitter
        dwTotalRtpBW = updateRtpXmtBW (pSSRC);
#endif
        }
    else
        {
        // payload type, RR 
        pRTCPhdr->pt = RTCP_RR;

        // set the receiver report pointer 
        pRTCPrecvr = (RECEIVER_RPT *)(pRTCPhdr + 1);

        // set our SSRC as the originator of this report
        RRCMws.htonl (sd, pSSRC->SSRC, &pRTCPrecvr->ssrc);

        pRTCPrr = pRTCPrecvr->rr;
        }

    // build receiver report list 
    numRcvRpt = 0;
    numSrc    = 0;

    // go through the received SSRCs list, lock the list
    EnterCriticalSection(&pRTCP->SSRCListCritSect);
    pTmp = pRTCP->RcvSSRCList.prev;
    while (pTmp)
        {
        // increment the number of sources for later time-out calculation 
        numSrc++;

        // check to see if this entry is an active sender 
        if (((PSSRC_ENTRY)pTmp)->rcvInfo.dwNumPcktRcvd == 
            ((PSSRC_ENTRY)pTmp)->rcvInfo.dwPrvNumPcktRcvd)
            {
            // not an active source, don't include it in the RR 
            pTmp = pTmp->next;
                    
            // next entry in SSRC list 
            continue;
            }

        // build RR
        RTCPbuildReceiverRpt ((PSSRC_ENTRY)pTmp, pRTCPrr, sd);

#ifdef DYNAMIC_RTCP_BW
        // calculate the RTP bandwidth used by this remote stream
        dwTotalRtpBW += updateRtpRcvBW ((PSSRC_ENTRY)pTmp);
#endif

        // next entry in receiver report 
        pRTCPrr++;

        // next entry in SSRC list 
        pTmp = pTmp->next;

        if (++numRcvRpt >= MAX_RR_ENTRIES)
// !!! TODO !!!
// When over 31 sources, generate a second packet or go round robin
            break;
        }
    LeaveCriticalSection(&pRTCP->SSRCListCritSect);
    
    // check to see if any Receiver Report. If not, still send an empty RR, 
    // that will be followed by an SDES CNAME, for case like initialization 
    // time, or when no stream received yet
    if ((numRcvRpt == 0) && (weSent == TRUE))
        {
        // adjust to the right place
        pRTCPrr = (RTCP_RR_T *)pData;
        }

    // report count 
    pRTCPhdr->count = (WORD)numRcvRpt;

    // packet length for the previous SR/RR 
    pcktLen = (long)((char *)pRTCPrr - pXmtStruct->bfr.buf);
    pRTCPhdr->length = htons((WORD)((pcktLen >> 2) - 1));

    // check which SDES needs to be send
    if (RTCPcheckSDEStoXmit (pSSRC, SdesData, pRTCP->dwSdesMask) > 0) {

        // build the SDES information
        pLastWord = RTCPbuildSDES ((RTCP_COMMON_T *)pRTCPrr, pSSRC, sd, 
                                   pXmtStruct->bfr.buf, SdesData);
    } else {
        pLastWord = (PDWORD)pRTCPrr;
    }
    
    // calculate total RTCP packet length to xmit 
    pXmtStruct->bfr.len = (ULONG)((char *)pLastWord - pXmtStruct->bfr.buf);

    if ( ! (pSSRC->dwSSRCStatus & RTCP_XMT_USER_CTRL))
        {
#ifdef DYNAMIC_RTCP_BW
        // get 5% of the total RTP bandwidth
        dwTotalRtpBW = (dwTotalRtpBW * 5) / 100;

        // calculate the next interval based upon RTCP parameters 
        if (dwTotalRtpBW < pSSRC->xmtInfo.dwRtcpStreamMinBW)
            {
            dwTotalRtpBW = pSSRC->xmtInfo.dwRtcpStreamMinBW;
            }

#ifdef _DEBUG
        wsprintf(debug_string, "RTCP: RTCP BW (Bytes/sec) = %ld", dwTotalRtpBW);
        RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

#else
        dwTotalRtpBW = pSSRC->xmtInfo.dwRtcpStreamMinBW;
#endif

        pSSRC->dwNextReportSendTime = curTime + RTCPxmitInterval (numSrc + 1,
                                        numRcvRpt, 
                                        dwTotalRtpBW,
                                        weSent, 
                                        (int)(pXmtStruct->bfr.len + NTWRK_HDR_SIZE),
                                        &pRTCP->avgRTCPpktSizeRcvd,
                                        0);
        }
    else
        {
        // user's control of the RTCP timeout interval
        if (pSSRC->dwUserXmtTimeoutCtrl != RTCP_XMT_OFF)
            {
            pSSRC->dwNextReportSendTime = 
                timeGetTime() + pSSRC->dwUserXmtTimeoutCtrl;
            }
        else
            {
            pSSRC->dwNextReportSendTime = RTCP_XMT_OFF;
            }
        }

#ifdef _DEBUG
    timeDiff = curTime - pSSRC->dwPrvTime;
    pSSRC->dwPrvTime = curTime;

    wsprintf(debug_string, 
             "RTCP: Sent report #%ld for SSRC x%lX after %5ld msec - (%s) w/ %d RR",
             pSSRC->dwNumRptSent, 
             pSSRC->SSRC, 
             timeDiff,
             (weSent==TRUE) ? "SR": "RR",
             numRcvRpt);
    RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif
    // unlock pointer access 
    LeaveCriticalSection (&pSSRC->critSect);    

    return pXmtStruct;
    }


/*----------------------------------------------------------------------------
 * Function   : RTCPxmtCallback
 * Description: Transmit callback routine from Winsock2.  
 *
 * Input :  dwError:        I/O completion code
 *          cbTransferred:  Number of bytes transferred
 *          lpOverlapped:   -> overlapped I/O structure
 *          dwFlags:        Flags
 *
 *
 * Return: None
 ---------------------------------------------------------------------------*/
void CALLBACK RTCPxmtCallback (DWORD dwError,
                               DWORD cbTransferred,
                               LPWSAOVERLAPPED pOverlapped,
                               DWORD dwFlags)
{
    // I'm not testing against WSAEFAULT intentionally because
    // this safety exit can hide other bugs. I should leave this code
    // for final release though.
    //if (dwError == WSAEFAULT)
    //  return;
    
    PRTCP_BFR_LIST  pXmtStruct;
    PSSRC_ENTRY     pSSRC;
#if IO_CHECK
    DWORD           initTime = timeGetTime();
#endif

    IN_OUT_STR ("RTCP: Enter RTCPxmtCallback()\n");

    if (dwError)
        {
        RRCM_DBG_MSG ("RTCP: RTCP Xmt Callback Error", dwError, 
                      __FILE__, __LINE__, DBG_ERROR);
        }

    // hEvent in the WSAOVERLAPPED struct points to our buffer's information 
    pXmtStruct = (PRTCP_BFR_LIST)pOverlapped->hEvent;

    // get SSRC entry address 
    pSSRC = pXmtStruct->pSSRC;

    // Return the buffer to the free queue 
    addToHeadOfList (&pSSRC->pRTCPses->RTCPxmtBfrList, 
                     (PLINK_LIST)pXmtStruct,
                     &pSSRC->pRTCPses->BfrCritSect);

    InterlockedDecrement ((long *)&pSSRC->dwNumXmtIoPending); 

#if IO_CHECK
    wsprintf(debug_string, "RTCP: Leaving XMT Callback after: %ld msec\n", 
             timeGetTime() - initTime);
    RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif
    IN_OUT_STR ("RTCP: Exit RTCPxmtCallback()\n");
    }


/*----------------------------------------------------------------------------
 * Function   : getSSRCpcktLoss
 * Description: Calculate the packet loss fraction and cumulative number.
 *
 * Input :  pSSRC:  -> to SSRC entry
 *          update: Flag. Update the number received, or just calculate the 
 *                  number of packet lost w/o updating the counters.
 *
 *
 * Return: Fraction Lost: Number of packet lost (8:24)
 ---------------------------------------------------------------------------*/
 DWORD getSSRCpcktLoss (PSSRC_ENTRY pSSRC, 
                        DWORD update)
    {
    DWORD   expected;
    DWORD   expectedInterval;
    DWORD   rcvdInterval;
    int     lostInterval;
    DWORD   fraction;
    DWORD   cumLost;

    IN_OUT_STR ("RTCP: Enter getSSRCpcktLoss()\n");

    // if nothing has been received, there is no loss 
    if (pSSRC->rcvInfo.dwNumPcktRcvd == 0)
        {
        IN_OUT_STR ("RTCP: Exit getSSRCpcktLoss()\n");

        return 0;
        }

    // as per the RFC, but always one packet off when doing it ??? 
    expected = pSSRC->rcvInfo.XtendedSeqNum.seq_union.dwXtndedHighSeqNumRcvd - 
                pSSRC->rcvInfo.dwBaseRcvSeqNum + 1;

    cumLost = expected - pSSRC->rcvInfo.dwNumPcktRcvd;

    // 24 bits value 
    cumLost &= 0x00FFFFFF;  

#if DBG_CUM_FRACT_LOSS
    wsprintf(debug_string, "RTCP : High Seq. #: %ld - Base: %ld",
        pSSRC->rcvInfo.XtendedSeqNum.seq_union.dwXtndedHighSeqNumRcvd,
        pSSRC->rcvInfo.dwBaseRcvSeqNum + 1);
    RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);

    wsprintf(debug_string, "RTCP : Expected: %ld - CumLost: %ld",
                    expected,
                    cumLost);
    RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

    // Network byte order the lost number (will be or'ed with the fraction)
    cumLost = htonl(cumLost);

    // fraction lost (per RFC) 
    expectedInterval = expected - pSSRC->rcvInfo.dwExpectedPrior;
    rcvdInterval     = 
        pSSRC->rcvInfo.dwNumPcktRcvd - pSSRC->rcvInfo.dwPrvNumPcktRcvd;

#if DBG_CUM_FRACT_LOSS
    wsprintf(debug_string, "RTCP : Exp. interval: %ld - Rcv interval: %ld",
        expectedInterval,
        rcvdInterval);
    RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

    // check if need to update the data, or just calculate the loss 
    if (update)
        {
        pSSRC->rcvInfo.dwExpectedPrior = expected;
        pSSRC->rcvInfo.dwPrvNumPcktRcvd = pSSRC->rcvInfo.dwNumPcktRcvd;
        }

    lostInterval = expectedInterval - rcvdInterval;

    if (expectedInterval == 0 || lostInterval <= 0)
        fraction = 0;
    else
        {
        fraction = (lostInterval << 8) / expectedInterval;

        // 8 bits value
        if (fraction > 0x000000FF)
            // 100 % loss
            fraction = 0x000000FF;

        fraction &= 0x000000FF;
        }

#if DBG_CUM_FRACT_LOSS
    wsprintf(debug_string, "RTCP : Lost interval: %ld - Fraction: %ld", 
                        lostInterval,
                        fraction);
    RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

    // get the 32 bits fraction/number 
    cumLost |= fraction;

    IN_OUT_STR ("RTCP: Exit getSSRCpcktLoss()\n");

    return cumLost;
    }


/*----------------------------------------------------------------------------
 * Function   : RTCPcheckSDEStoXmit
 * Description: Check which SDES needs to be transmitted with this report.
 *              SDES frequency varies for each type and is defined by the 
 *              application.
 *
 * Input :      pSSRC:      -> to the SSRC entry
 *              pSdes:      -> to SDES buffer to initialize
 *
 * Return:      None
 ---------------------------------------------------------------------------*/
DWORD RTCPcheckSDEStoXmit (PSSRC_ENTRY pSSRC, PSDES_DATA pSdes,
                          DWORD dwSdesMask)
{
    PSDES_DATA  pTmpSdes = pSdes;

    IN_OUT_STR ("RTCP: Enter RTCPcheckSDEStoXmit()\n");

    if (!dwSdesMask)
        return(0);
    
    int idx;
    
    for(idx = SDES_INDEX(RTCP_SDES_FIRST+1);
        idx < SDES_INDEX(RTCP_SDES_LAST); idx++) {
        
        if ( ((1 << (idx+1)) & dwSdesMask) &&
             pSSRC->sdesItem[idx].dwSdesFrequency
            ) {
            if ( (pSSRC->dwNumRptSent % pSSRC->sdesItem[idx].dwSdesFrequency)
                 == 0) {
                pTmpSdes->dwSdesType   = idx + 1;
                pTmpSdes->dwSdesLength = pSSRC->sdesItem[idx].dwSdesLength;
                CopyMemory(pTmpSdes->sdesBfr, pSSRC->sdesItem[idx].sdesBfr, 
                           pSSRC->sdesItem[idx].dwSdesLength);
                pTmpSdes++;
            }
        }
    }
    
    pTmpSdes->dwSdesLength = 0;

    IN_OUT_STR ("RTCP: Exit RTCPcheckSDEStoXmit()\n");

    return((DWORD) (((char*)pTmpSdes - (char*)pSdes)/sizeof(*pTmpSdes)) );
}


/*----------------------------------------------------------------------------
 * Function   : RTCPbuildSDES
 * Description: Build the SDES report
 *
 * Input :      pRTCPhdr:   -> to the RTCP packet header
 *              pSSRC:      -> to the SSRC entry
 *              sd:         Socket descriptor
 *              startAddr:  -> to the packet start address
 *              pSdes:      -> to the SDES information to build
 *
 * Return:      pLastWord:  Address of the packet last Dword
 ---------------------------------------------------------------------------*/
 PDWORD RTCPbuildSDES (RTCP_COMMON_T *pRTCPhdr, 
                       PSSRC_ENTRY pSSRC, 
                       SOCKET sd, 
                       PCHAR startAddr, 
                       PSDES_DATA pSdes)
    {
    RTCP_SDES_T         *pRTCPsdes;
    RTCP_SDES_ITEM_T    *pRTCPitem;
    long                pad = 0;
    PCHAR               ptr;
    long                pcktLen;

    IN_OUT_STR ("RTCP: Enter RTCPbuildSDES()\n");

    // setup header
    pRTCPhdr->type  = RTP_TYPE;
    pRTCPhdr->pt    = RTCP_SDES;
    pRTCPhdr->p     = 0;
    pRTCPhdr->count = 1;

    // SDES specific header
    pRTCPsdes = (RTCP_SDES_T *)(pRTCPhdr + 1);

    // Get the SSRC 
    RRCMws.htonl (sd, pSSRC->SSRC, &pRTCPsdes->src);

    // SDES item
    pRTCPitem = (RTCP_SDES_ITEM_T *)pRTCPsdes->item;

    while (pSdes->dwSdesLength)
        {
        // set SDES item characteristics
        pRTCPitem->dwSdesType   = (char)pSdes->dwSdesType;

        // make sure we don't go too far
        if (pSdes->dwSdesLength > MAX_SDES_LEN)
            pSdes->dwSdesLength = MAX_SDES_LEN;

        pRTCPitem->dwSdesLength = (unsigned char)(pSdes->dwSdesLength);

        CopyMemory(pRTCPitem->sdesData, pSdes->sdesBfr, pSdes->dwSdesLength);

        // packet length
        pcktLen = (long)
            ( (char *)(pRTCPitem->sdesData + pRTCPitem->dwSdesLength) -
              (char *)pRTCPsdes );

        pRTCPitem = (RTCP_SDES_ITEM_T *)((char *)pRTCPsdes + pcktLen);

        pSdes->dwSdesLength = 0; // setting this to zero will clear this entry

        // next SDES
        pSdes++;
        }

    // total SDES packet length 
    pcktLen = (long) ( (char *)pRTCPitem - (char *)pRTCPhdr );

    // Zero the last word of the SDES item chunk, and padd to the 
    // 32 bits boundary. If we landed exactly on the boundary then 
    // have a whole null word to terminate the sdes, as is needed.
    pad = 4 - (pcktLen & 3);
    pcktLen += pad;

    ptr = (PCHAR)pRTCPitem;
    while (pad--)
        *ptr++ = 0x00;

    // update packet length in header field
    RRCMws.htons (sd, (WORD)((pcktLen >> 2) - 1), &pRTCPhdr->length);

    IN_OUT_STR ("RTCP: Exit RTCPbuildSDES()\n");

    return ((PDWORD)ptr);
    }


/*----------------------------------------------------------------------------
 * Function   : RTCPbuildSenderRpt
 * Description: Build the RTCP Sender Report
 *
 * Input :      pSSRC:      -> to the SSRC entry
 *              pRTCPhdr:   -> to the RTCP packet header
 *              pRTCPsr:    -> to the Sender Report header
 *              sd:         Socket descriptor
 *
 * Return:      None
 ---------------------------------------------------------------------------*/
 void   RTCPbuildSenderRpt (PSSRC_ENTRY pSSRC, 
                            RTCP_COMMON_T *pRTCPhdr, 
                            SENDER_RPT  **pRTCPsr,
                            SOCKET  sd)
    {
    DWORD   dwTmp;
    DWORD   NTPtime;
    DWORD   RTPtime;
    DWORD   RTPtimeStamp = 0;

    IN_OUT_STR ("RTCP: Enter RTCPbuildSenderRpt()\n");

    // payload type, SR 
    pRTCPhdr->pt = RTCP_SR;

    // padding 
    pRTCPhdr->p  = 0;

    // sender report header 
    *pRTCPsr = (SENDER_RPT *)(pRTCPhdr + 1);

    // fill in sender report packet 
    RRCMws.htonl (sd, pSSRC->SSRC, &((*pRTCPsr)->ssrc));

    RRCMws.htonl (sd, pSSRC->xmtInfo.dwNumPcktSent, &((*pRTCPsr)->psent));

    RRCMws.htonl (sd, pSSRC->xmtInfo.dwNumBytesSent, &((*pRTCPsr)->osent));

    // NTP timestamp

    NTPtime = RTPtime = timeGetTime ();

    // get the number of seconds (integer calculation)
    dwTmp = NTPtime/1000;

    // NTP Msw
    RRCMws.htonl (sd, (NTPtime/1000), &((*pRTCPsr)->ntp_sec));

    // convert back dwTmp from second to millisecond 
    dwTmp *= 1000;

    // get the remaining number of millisecond for the LSW
    NTPtime -= dwTmp;

    // NTP Lsw
    RRCMws.htonl (sd, usec2ntpFrac ((long)NTPtime*1000), 
                  &((*pRTCPsr)->ntp_frac));

    // calculate the RTP timestamp offset which correspond to this NTP
    // time and convert it to stream samples
    if (pSSRC->dwStreamClock)
        {
        RTPtimeStamp = 
            pSSRC->xmtInfo.dwLastSendRTPTimeStamp +
             ((RTPtime - pSSRC->xmtInfo.dwLastSendRTPSystemTime) * 
              (pSSRC->dwStreamClock / 1000));
        }

    RRCMws.htonl (sd, RTPtimeStamp, &((*pRTCPsr)->rtp_ts));

    IN_OUT_STR ("RTCP: Exit RTCPbuildSenderRpt()\n");
    }


/*----------------------------------------------------------------------------
 * Function   : usec2ntp
 * Description: Convert microsecond to fraction of second for NTP
 *              As per VIC.
 *              Convert micro-second to fraction of second * 2^32. This 
 *              routine uses the factorization:
 *              2^32/10^6 = 4096 + 256 - 1825/32
 *              which results in a max conversion error of 3*10^-7 and an
 *              average error of half that
 *
 * Input :      usec:   Micro second
 *
 * Return:      Fraction of second in NTP format
 ---------------------------------------------------------------------------*/
 DWORD usec2ntp (DWORD usec)
    {
    DWORD tmp = (usec * 1825) >>5;
    return ((usec << 12) + (usec << 8) - tmp);
    }


/*----------------------------------------------------------------------------
 * Function   : usec2ntpFrac
 * Description: Convert microsecond to fraction of second for NTP.
 *              Just uses an array of microsecond and set the corresponding
 *              bit.
 *
 * Input :      usec:   Micro second
 *
 * Return:      Fraction of second
 ---------------------------------------------------------------------------*/
 DWORD usec2ntpFrac (long usec)
    {
    DWORD   idx;
    DWORD   fraction = 0;
    DWORD   tmpFraction = 0;
    long    tmpVal;
    DWORD   shift;

    for (idx=0, shift=FRACTION_SHIFT_MAX-1; 
         idx < FRACTION_ENTRIES; 
         idx++, shift--)
        {
        tmpVal = usec;
        if ((tmpVal - microSecondFrac[idx]) > 0)
            {
            usec -= microSecondFrac[idx];
            tmpFraction = (1 << shift);
            fraction |= tmpFraction;
            }
        else if ((tmpVal - microSecondFrac[idx]) == 0)
            {
            tmpFraction = (1 << shift);
            fraction |= tmpFraction;
            break;
            }
        }

    return fraction;
    }


/*----------------------------------------------------------------------------
 * Function   : RTCPbuildReceiverRpt
 * Description: Build the RTCP Receiver Report
 *
 * Input :      pSSRC:      -> to the SSRC entry
 *              pRTCPsr:    -> to the Receiver Report header
 *              sd:         Socket descriptor
 *
 * Return:      None
 ---------------------------------------------------------------------------*/
 void   RTCPbuildReceiverRpt (PSSRC_ENTRY pSSRC, 
                              RTCP_RR_T *pRTCPrr,
                              SOCKET    sd)
    {
    DWORD   dwDlsr;

    IN_OUT_STR ("RTCP: Enter RTCPbuildReceiverRpt()\n");

    // get the SSRC 
    RRCMws.htonl (sd, pSSRC->SSRC, &pRTCPrr->ssrc);

    // get fraction and cumulative number of packet lost (per RFC) 
    pRTCPrr->received = getSSRCpcktLoss (pSSRC, TRUE);
    
    RRCMnotification(RRCM_LOSS_RATE_LOCAL_EVENT, pSSRC, 
                     (DWORD) ( ((double) (pRTCPrr->received & 0xff)) *
                               100.0/256.0 ),
                     pSSRC->SSRC);
  
    // extended highest sequence number received 
    RRCMws.htonl (sd, 
        pSSRC->rcvInfo.XtendedSeqNum.seq_union.dwXtndedHighSeqNumRcvd, 
        &pRTCPrr->expected);

    // interrarival jitter 
#ifdef ENABLE_FLOATING_POINT
    RRCMws.htonl (sd, pSSRC->rcvInfo.interJitter, &pRTCPrr->jitter);
#else
    // Check RFC for details of the round off
    RRCMws.htonl (sd, (pSSRC->rcvInfo.interJitter >> 4), &pRTCPrr->jitter);
#endif

    // last SR 
    RRCMws.htonl (sd, pSSRC->xmtInfo.dwLastSR, &pRTCPrr->lsr);

    // delay since last SR (only if an SR has been received from 
    // this source, otherwise 0) 
    if (pRTCPrr->lsr)
        {
        // get the DLSR
        dwDlsr = getDLSR (pSSRC);

        RRCMws.htonl (sd, dwDlsr, &pRTCPrr->dlsr);
        }
    else
        pRTCPrr->dlsr = 0;

    IN_OUT_STR ("RTCP: Exit RTCPbuildReceiverRpt()\n");
    }

/*----------------------------------------------------------------------------
 * Function   : getDLSR
 * Description: Get a DLSR packet
 *
 * Input :      pSSRC:      -> to the SSRC entry
 *
 * Return:      DLSR in seconds:fraction format
 ---------------------------------------------------------------------------*/
 DWORD getDLSR (PSSRC_ENTRY pSSRC)
    {
    DWORD   dwDlsr;
    DWORD   dwTime;
    DWORD   dwTmp;

    // DLSR in millisecond
    dwTime = timeGetTime() - pSSRC->xmtInfo.dwLastSRLocalTime; 

    // get the number of seconds (integer calculation)
    dwTmp = dwTime/1000;

    // set the DLSR upper 16 bits (seconds)
    dwDlsr = dwTmp << 16;

    // convert back dwTmp from second to millisecond 
    dwTmp *= 1000;

    // get the remaining number of millisecond for the LSW
    dwTime -= dwTmp;

    // convert microseconds to fraction of seconds
    dwTmp = usec2ntpFrac ((long)dwTime*1000);

    // get only the upper 16 bits
    dwTmp >>= 16;
    dwTmp &= 0x0000FFFF;

    // set the DLSR lower 16 bits (fraction of seconds)
    dwDlsr |= dwTmp;

    return dwDlsr;
    }


/*----------------------------------------------------------------------------
 * Function   : RTCPsendBYE
 * Description: Send an RTCP BYE packet
 *
 * Input :      pRTCP:      -> to the RTCP session
 *              pSSRC:      -> to the SSRC entry
 *              byeReason:  -> to the Bye reason, eg, "camera malfunction"...
 *
 * Return:      None
 ---------------------------------------------------------------------------*/
 void RTCPsendBYE (PSSRC_ENTRY pSSRC, 
                   PCHAR pByeReason)
    {
    PRTCP_SESSION       pRTCP;
    PRTCP_BFR_LIST      pXmtStruct;
    RTCP_COMMON_T       *pRTCPhdr;
    RTCP_RR_T           *pRTCPrr;
    RECEIVER_RPT        *pRTCPrecvr;
    BYE_PCKT            *pBye;
    DWORD               *pLastWord;
    DWORD               dwStatus;
    DWORD               offset;
    DWORD               byeLen;
    long                pcktLen;
    PCHAR               pBfr;

    IN_OUT_STR ("RTCP: Enter RTCPsendBYE()\n");

    // get the RTCP session
    pRTCP = pSSRC->pRTCPses;

    // check to see if under H.323 conference control. Don't send BYE in 
    // this case
    if (pRTCP->dwSessionStatus & H323_CONFERENCE)
        return;

    // make sure the destination address is known
    if (!(pRTCP->dwSessionStatus & RTCP_DEST_LEARNED))
        {
        IN_OUT_STR ("RTCP: Exit RTCPsendBYE()\n");
        return;
        }

    // get a free RTCP buffer for a transmit operation 
    pXmtStruct = (PRTCP_BFR_LIST)removePcktFromTail(&pRTCP->RTCPxmtBfrList,
                                                    &pRTCP->BfrCritSect);

    // check buffer 
    if (pXmtStruct == NULL)
        {
        RRCM_DBG_MSG ("RTCP: ERROR - No Xmt Bfr Available", 0, 
                      __FILE__, __LINE__, DBG_ERROR);

        IN_OUT_STR ("RTCP: Exit RTCPsendBYE()\n");

        return;
        }

    // use hEvent to recover the buffer's address
    char event_name[32];
    wsprintf(event_name, "RTCP[0x%X] Send BYE", pRTCP);
    pXmtStruct->overlapped.hEvent = CreateEvent (NULL, FALSE, FALSE,
                                                 event_name);
    if (pXmtStruct->overlapped.hEvent == NULL)
        {
        RRCM_DBG_MSG ("RTCP: ERROR - WSACreateEvent()", GetLastError(), 
                      __FILE__, __LINE__, DBG_ERROR);

        // Return the buffer to the free queue 
        addToHeadOfList (&pRTCP->RTCPxmtBfrList, 
                         (PLINK_LIST)pXmtStruct,
                         &pRTCP->BfrCritSect);

        return;
        }

    // target address 
    CopyMemory(&pXmtStruct->addr, &pRTCP->toAddr, pRTCP->toAddrLen);

    // target address length 
    pXmtStruct->addrLen = pRTCP->toAddrLen;

    // RTCP common header 
    pRTCPhdr = (RTCP_COMMON_T *)pXmtStruct->bfr.buf;

    // RTP protocol version 
    pRTCPhdr->type = RTP_TYPE;

    // empty RR
    pRTCPhdr->pt = RTCP_RR;

    // padding
    pRTCPhdr->p = 0;

    // report count
    pRTCPhdr->count = 0; // Zero report blocks follow !!!

    // set the receiver report pointer 
    pRTCPrecvr = (RECEIVER_RPT *)(pRTCPhdr + 1);

    // get our SSRC 
    pRTCPrecvr->ssrc = htonl(pSSRC->SSRC);

    // packet length for the previous RR 
    pcktLen = sizeof(*pRTCPhdr) + sizeof(pRTCPrecvr->ssrc);
    pRTCPhdr->length =htons ( (WORD) ((pcktLen >> 2) - 1) );

    // BYE packet
    pRTCPhdr = (RTCP_COMMON_T *) ((char *)pRTCPhdr + pcktLen);
    pRTCPhdr->type  = RTP_TYPE;
    pRTCPhdr->pt    = RTCP_BYE;
    pRTCPhdr->count = 1;

    pBye = (BYE_PCKT *)(pRTCPhdr + 1);
    *((DWORD *)pBye->src) = htonl (pSSRC->SSRC);

    pBye++;

    // set the reason
    pBfr = (PCHAR)pBye;

    if (!pByeReason)
        pByeReason = "Session Terminated";

    byeLen = strlen(pByeReason) + 1;
    if (byeLen > MAX_SDES_LEN)
        byeLen = MAX_SDES_LEN;
    
    // Copy bye reason to buffer
    CopyMemory(pBfr+1, pByeReason, byeLen);
    *pBfr = (unsigned char)byeLen;

    pBfr += byeLen + 1;

    // pad to a 32bits boundary
    long pad;

    pad = (long)((ULONG_PTR)pBfr & 0x3);
    if (pad) {
        pad = 4 - pad;
        for(; pad; pad--, pBfr++)
            *pBfr = 0;
    }

    pcktLen = (long) (pBfr - (char *)pRTCPhdr);
    pRTCPhdr->length = htons ( (WORD) ((pcktLen >> 2) - 1) );

    // calculate total RTCP packet length to xmit 
    pXmtStruct->bfr.len = (ULONG) (pBfr - pXmtStruct->bfr.buf);

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
    if (RTPLogger)
        {
        //INTEROP
        InteropOutput (RTPLogger,
                       (BYTE FAR*)(pXmtStruct->bfr.buf),
                       (int)pXmtStruct->bfr.len,
                       RTPLOG_SENT_PDU | RTCP_PDU);
        }
#endif

    // send the packet
    dwStatus = RRCMws.sendTo (pSSRC->pRTPses->pSocket[SOCK_RTCP],
                              &pXmtStruct->bfr,
                              pXmtStruct->dwBufferCount,
                              &pXmtStruct->dwNumBytesXfr, 
                              pXmtStruct->dwFlags,
                              &pXmtStruct->addr,
                              pXmtStruct->addrLen,
                              (LPWSAOVERLAPPED)&pXmtStruct->overlapped, 
                              NULL);

    // check SendTo status 
    if (dwStatus == SOCKET_ERROR) { 
        // If serious error, undo all our work 
        dwStatus = WSAGetLastError();

        if (dwStatus != WSA_IO_PENDING) 
            {
            RRCM_DBG_MSG ("RTCP: ERROR - WSASendTo()", dwStatus, 
                          __FILE__, __LINE__, DBG_ERROR);

            // release the event
            CloseHandle (pXmtStruct->overlapped.hEvent);

            // return resources to the free queue 
            addToHeadOfList (&pRTCP->RTCPxmtBfrList, 
                             (PLINK_LIST)pXmtStruct,
                             &pRTCP->BfrCritSect);

            return;
            }
        }

    // wait for the event
    do {
        dwStatus = WaitForSingleObjectEx(pXmtStruct->overlapped.hEvent, 
                                         1000, 
                                         TRUE);
        if (dwStatus == WAIT_OBJECT_0)
            ;
        else if (dwStatus == WAIT_IO_COMPLETION)
            ;
        else if (dwStatus == WAIT_TIMEOUT)
        {
            RRCM_DBG_MSG ("RTCP: Wait timed out", 0, 
                          __FILE__, __LINE__, DBG_ERROR);
        }
        else if (dwStatus == WAIT_FAILED)
        {
            RRCM_DBG_MSG ("RTCP: Wait failed", GetLastError(), 
                          __FILE__, __LINE__, DBG_ERROR);
        }
    } while(dwStatus != WAIT_OBJECT_0 && dwStatus != WAIT_ABANDONED);

    // release the event
    CloseHandle (pXmtStruct->overlapped.hEvent);

    // return resources to the free queue 
    addToHeadOfList (&pRTCP->RTCPxmtBfrList, 
                     (PLINK_LIST)pXmtStruct, 
                     &pRTCP->BfrCritSect);

    IN_OUT_STR ("RTCP: Exit RTCPsendBYE()\n");
    }



/*----------------------------------------------------------------------------
 * Function   : updateRtpXmtBW
 * Description: Calculate a sending stream bandwidth during the last report
 *              interval.
 *
 * Input :      pSSRC:      -> to the SSRC entry
 *
 * Return:      Bandwith used by transmitter in bytes/sec
 ---------------------------------------------------------------------------*/

#ifdef DYNAMIC_RTCP_BW

DWORD updateRtpXmtBW (PSSRC_ENTRY pSSRC)
    {
    DWORD   dwBW = 0;
    DWORD   dwTimeInterval;
    DWORD   dwByteInterval;
    DWORD   dwTimeNow = timeGetTime();

    IN_OUT_STR ("RTCP: Enter updateRtpXmtBW()\n");

    if (pSSRC->xmtInfo.dwLastTimeBwCalculated == 0)
        {
        pSSRC->xmtInfo.dwLastTimeBwCalculated = dwTimeNow;
        pSSRC->xmtInfo.dwLastTimeNumBytesSent = pSSRC->xmtInfo.dwNumBytesSent;
        pSSRC->xmtInfo.dwLastTimeNumPcktSent  = pSSRC->xmtInfo.dwNumPcktSent;
        }
    else
        {
        dwTimeInterval = dwTimeNow - pSSRC->xmtInfo.dwLastTimeBwCalculated;
        pSSRC->xmtInfo.dwLastTimeBwCalculated = dwTimeNow;

        // get the interval in second (we loose the fractional part)
        dwTimeInterval = dwTimeInterval / 1000;

        dwByteInterval = 
         pSSRC->xmtInfo.dwNumBytesSent - pSSRC->xmtInfo.dwLastTimeNumBytesSent;

        dwBW = dwByteInterval / dwTimeInterval;

        pSSRC->xmtInfo.dwLastTimeNumBytesSent = pSSRC->xmtInfo.dwNumBytesSent;
        pSSRC->xmtInfo.dwLastTimeNumPcktSent  = pSSRC->xmtInfo.dwNumPcktSent;
        }

    IN_OUT_STR ("RTCP: Exit updateRtpXmtBW()\n");

    return dwBW;
    }
#endif // #ifdef DYNAMIC_RTCP_BW


/*----------------------------------------------------------------------------
 * Function   : updateRtpRcvBW
 * Description: Calculate a remote stream RTP bandwidth during the last 
 *              report interval.
 *
 * Input :      pSSRC:      -> to the SSRC entry
 *
 * Return:      Bandwith used by the remote stream in bytes/sec
 ---------------------------------------------------------------------------*/

#ifdef DYNAMIC_RTCP_BW

DWORD updateRtpRcvBW (PSSRC_ENTRY pSSRC)
    {
    DWORD   dwBW = 0;
    DWORD   dwTimeInterval;
    DWORD   dwByteInterval;
    DWORD   dwTimeNow = timeGetTime();

    IN_OUT_STR ("RTCP: Enter updateRtpRcvBW()\n");

    if (pSSRC->rcvInfo.dwLastTimeBwCalculated == 0)
        {
        pSSRC->rcvInfo.dwLastTimeBwCalculated = dwTimeNow;
        pSSRC->rcvInfo.dwLastTimeNumBytesRcvd = pSSRC->rcvInfo.dwNumPcktRcvd;
        pSSRC->rcvInfo.dwLastTimeNumPcktRcvd  = pSSRC->rcvInfo.dwNumBytesRcvd;
        }
    else
        {
        dwTimeInterval = dwTimeNow - pSSRC->rcvInfo.dwLastTimeBwCalculated;
        pSSRC->rcvInfo.dwLastTimeBwCalculated = dwTimeNow;

        // get the interval in second (we loose the fractional part)
        dwTimeInterval = dwTimeInterval / 1000;

        dwByteInterval = 
         pSSRC->rcvInfo.dwNumBytesRcvd - pSSRC->rcvInfo.dwLastTimeNumBytesRcvd;

        dwBW = dwByteInterval / dwTimeInterval;

        pSSRC->rcvInfo.dwLastTimeNumBytesRcvd = pSSRC->rcvInfo.dwNumPcktRcvd;
        pSSRC->rcvInfo.dwLastTimeNumPcktRcvd  = pSSRC->rcvInfo.dwNumBytesRcvd;
        }

    IN_OUT_STR ("RTCP: Exit updateRtpXmtBW()\n");

    return dwBW;
    }
#endif // #ifdef DYNAMIC_RTCP_BW



// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rrcm\rtcp\rtcprecv.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTCPRECV.C
 * Product:     RTP/RTCP implementation
 * Description: Provides the RTCP receive network I/O.
 *
 * $Workfile:   rtcprecv.cpp  $
 * $Author:   CMACIOCC  $
 * $Date:   16 May 1997 09:26:10  $
 * $Revision:   1.11  $
 * $Archive:   R:\rtp\src\rrcm\rtcp\rtcprecv.cpv  $
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/


#include "rrcm.h"                                    


#define     MIN(a, b)       ((a < b) ? a : b)
#define     RTCP_SR_SIZE    24


/*---------------------------------------------------------------------------
/                           Global Variables
/--------------------------------------------------------------------------*/            


/*---------------------------------------------------------------------------
/                           External Variables
/--------------------------------------------------------------------------*/                                       
extern PRTCP_CONTEXT    pRTCPContext;
extern PRTP_CONTEXT     pRTPContext;
extern RRCM_WS          RRCMws;

#ifdef ENABLE_ISDM2
extern ISDM2            Isdm2;
#endif

#ifdef _DEBUG
extern char     debug_string[];
#endif

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
extern LPInteropLogger RTPLogger;
#endif



/*----------------------------------------------------------------------------
 * Function   : RTCPrcvInit
 * Description: RTCP receive initialisation. 
 * 
 * Input :      pRTCP   : Pointer to the RTCP session information
 *
 * Return:      TRUE/FALSE
 ---------------------------------------------------------------------------*/
DWORD RTCPrcvInit (PSSRC_ENTRY pSSRC)
    {
    PRTCP_BFR_LIST  pRTCPBfrList;
    PRTCP_SESSION   pRTCP;
    int             dwStatus;
    int             dwError;
    int             errorCnt = 0;
    int             bfrErrorCnt = 0;
    DWORD           idx;
    int             wsockSuccess = FALSE;

    // save a pointer to the corresponding RTCP session
    pRTCP = pSSRC->pRTCPses;

    // Post receive buffers for WS-2. As these buffers are posted per receive 
    // thread, few of them should be plenty enough for RTCP.
    for (idx = 0; idx < pRTPContext->registry.NumRTCPPostedBfr; idx++)
        {
        // get a free RTCP buffer for a receive operation
        EnterCriticalSection(&pRTCP->BfrCritSect);
        pRTCPBfrList = 
            (PRTCP_BFR_LIST)removePcktFromTail(&pRTCP->RTCPrcvBfrList,
                                               NULL);

        // check buffer 
        if (pRTCPBfrList == NULL)
            {
            RRCM_DBG_MSG ("RTCP: ERROR - Rcv Bfr Allocation Error", 0, 
                          __FILE__, __LINE__, DBG_ERROR);

            // make sure we have at least one buffer
            LeaveCriticalSection(&pRTCP->BfrCritSect);
            ASSERT (idx || pRTCPBfrList);
            break;
            }

        // Put buffer list item in used list
        addToTailOfList((PLINK_LIST)&pRTCP->RTCPrcvBfrListUsed,
                        &pRTCPBfrList->bfrList,
                        NULL);

        pRTCPBfrList->overlapped.Internal = 0;
        
        LeaveCriticalSection(&pRTCP->BfrCritSect);
        
        // SSRC entry address of our own session 
        pRTCPBfrList->pSSRC = pSSRC;

        // received address length reset by the receive routine 
        pRTCPBfrList->addrLen = sizeof(SOCKADDR);

        // use hEvent to recover the buffer's address
        
        pRTCPBfrList->overlapped.hEvent = (WSAEVENT)pRTCPBfrList;

        // post the receive buffer for this thread
        if (RTCPpostRecvBfr(pSSRC, pRTCPBfrList))
            wsockSuccess = TRUE;
        
        }

    // make sure we posted at least some buffers 
    if (wsockSuccess == FALSE)
        {
        // release all resources and kill the receive thread 
#ifdef _DEBUG
        wsprintf(debug_string, 
            "RTCP: ERROR - Exit RCV init %s: Line:%d", __FILE__, __LINE__);
        RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif
        return(FALSE);
        }
    return (TRUE);
    }

void DecrementIOPendingCount(
    IN PRTCP_SESSION   pRTCPses
    )
{
    HANDLE  tmpHandle = NULL;
    BOOL    bDuplicated = FALSE;

    if (pRTCPses->hLastPendingRecv)
    {
        bDuplicated = DuplicateHandle(
					GetCurrentProcess(),
					pRTCPses->hLastPendingRecv,
					GetCurrentProcess(),
					&tmpHandle,
					0,						// ignored
					TRUE,
					DUPLICATE_SAME_ACCESS 
					);
    }
    
    // decrementing the refcount here might trigger the other thread to release
    // the session.
    long i = InterlockedDecrement(&(pRTCPses->lNumRcvIoPending));

    if (i <= 0) {
        // Signal last pending I/O has completed
        if (bDuplicated && tmpHandle) {
            SetEvent(tmpHandle);
        }
    }

    if (bDuplicated && tmpHandle)
    {
        CloseHandle(tmpHandle);
    }
}

/*----------------------------------------------------------------------------
 * Function   : RTCPrcvCallback
 * Description: Receive callback routine from Winsock2.  
 *
 * Input :  dwError:        I/O completion status
 *          cbTransferred:  Number of bytes received
 *          lpOverlapped:   -> to overlapped structure
 *          dwFlags:        Flags
 *
 *
 * Return: None
 ---------------------------------------------------------------------------*/
void CALLBACK RTCPrcvCallback (DWORD dwError,
                               DWORD cbTransferred,
                               LPWSAOVERLAPPED lpOverlapped,
                               DWORD dwFlags)
    {
    PRTCP_BFR_LIST  pRTCPBfrList;
    RTCP_T          *pRTCPpckt;
    PRTCP_SESSION   pRTCPses;
    PSSRC_ENTRY     pSSRC;
    PAPP_RTCP_BFR   pAppBfr;
    DWORD           dwStatus = 0;
    DWORD           i;
    DWORD           pcktLen;
    DWORD           dwSSRC;
    USHORT          wHost;
    SOCKET          RTCPsd;
    unsigned char   *pEndPckt;
    unsigned char   *pEndBlock;
    int             tmpSize;

#if IO_CHECK
    DWORD           initTime = timeGetTime();
#endif

    IN_OUT_STR ("RTCP: Enter RTCPrcvCallback\n");

    // hEvent in the WSAOVERLAPPED struct points to our buffer's information 
    pRTCPBfrList = (PRTCP_BFR_LIST)lpOverlapped->hEvent;

    // SSRC entry pointer 
    pSSRC = pRTCPBfrList->pSSRC;

    if ( (pSSRC->pRTCPses->dwSessionStatus & SHUTDOWN_IN_PROGRESS) ||
         (pRTCPBfrList->dwKind & RTCP_KIND_BIT(RTCP_KIND_SHUTDOWN)) ||
         (dwError && (dwError == WSA_OPERATION_ABORTED ||
                      dwError == WSAEINTR)) ) {
        // Don't process buffer if shuting down
        RRCMDbgLog((
                LOG_TRACE,
                LOG_DEVELOP,
                "RTCP[0x%X] : Recv flushed: "
                "Socket:%d, Pending:%d "
                "ShutDn:%d, dwError:%d (0x%X)",
                pSSRC->pRTCPses,
                pSSRC->pRTPses->pSocket[SOCK_RTCP],
                pSSRC->pRTCPses->lNumRcvIoPending-1,
                (pRTCPBfrList->dwKind >> RTCP_KIND_SHUTDOWN) & 1,
                dwError, dwError
            ));

        RTCPpostRecvBfr (pSSRC, pRTCPBfrList);

        DecrementIOPendingCount(pSSRC->pRTCPses);

        return;
    }

    if (cbTransferred <= sizeof(RTCP_COMMON_T)) {
        if (dwError == WSAECONNRESET) {
            // No one listens, and the host has received an ICMP
            // message of destination. We may want to pass this up
            // to the application, or prevent ourselves from sending
            // data, but HOW do we know when someone is listening to
            // start again sending data?
        }

#if defined(_DEBUG) && defined(DEBUG_RRCM)
        char str[128];
        wsprintf(str,"RTCP : Recv packet too short: "
                 "Session:0x%X, len:%d, Err:%d",
                 pSSRC->pRTCPses, cbTransferred, dwError);
        RRCM_DBG_MSG (str, 0, __FILE__, __LINE__, DBG_NOTIFY);
#endif

        // packet too short, repost
        RTCPpostRecvBfr (pSSRC, pRTCPBfrList);

        DecrementIOPendingCount(pSSRC->pRTCPses);

        return;
    }
    
    // check Winsock callback error status
    if (dwError)
        {
            RRCM_DBG_MSG ("RTCP: ERROR - Rcv Callback", dwError, 
                          __FILE__, __LINE__, DBG_ERROR);
        
        // invalid RTCP packet header, re-queue the buffer 
        RTCPpostRecvBfr (pSSRC, pRTCPBfrList);

        DecrementIOPendingCount(pSSRC->pRTCPses);

        IN_OUT_STR ("RTCP: Exit RTCPrcvCallback\n");
        return;
        }
#if defined(_DEBUG)
    else {
        char str[128];
        sprintf(str,"RTCP: RTCPrcvCallback %d bytes, socket %d",
                cbTransferred, pSSRC->pRTPses->pSocket[SOCK_RTCP]);
        RRCM_DBG_MSG (str, 0, __FILE__, __LINE__, DBG_NOTIFY);
    }
#endif

    // read the RTCP packet 
    pRTCPpckt = (RTCP_T *)pRTCPBfrList->bfr.buf;

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
   //INTEROP
    if (RTPLogger)
        {
        InteropOutput (RTPLogger,
                       (BYTE FAR*)(pRTCPBfrList->bfr.buf),
                       cbTransferred,
                       RTPLOG_RECEIVED_PDU | RTCP_PDU);
        }
#endif

    // get the RTCP session ptr 
    pRTCPses = pSSRC->pRTCPses;

    // Check RTCP header validity of first packet in report.
    // Filter out junk. First thing in RTCP packet must be
    // either SR, RR or BYE
    if ((pRTCPpckt->common.type != RTP_TYPE) ||
        ((pRTCPpckt->common.pt != RTCP_SR) &&
         (pRTCPpckt->common.pt != RTCP_RR) &&
         (pRTCPpckt->common.pt != RTCP_BYE)))
        {
#ifdef MONITOR_STATS
        pRTCPses->dwNumRTCPhdrErr++;
#endif

#ifdef _DEBUG
        wsprintf(debug_string, 
                 "RTCP: ERROR - Pckt Header Error. Type:%d / Payload:%d",
                 pRTCPpckt->common.type, pRTCPpckt->common.pt);
        RRCM_DEV_MSG (debug_string, 0, __FILE__, __LINE__, DBG_TRACE);
#endif
        // invalid RTCP packet header, re-queue the buffer 
        RTCPpostRecvBfr (pSSRC, pRTCPBfrList);

        DecrementIOPendingCount(pSSRC->pRTCPses);

        IN_OUT_STR ("RTCP: Exit RTCPrcvCallback\n");
        return;
        }

    // get the socket descriptor 
    RTCPsd = pSSRC->pRTPses->pSocket[SOCK_RTCP];

    // get the sender's SSRC
    RRCMws.ntohl (RTCPsd, pRTCPpckt->r.sr.ssrc, &dwSSRC);

    // Rather allow loop-back and leave up to WS2 to enable/disable
    // multicast loop-back
#if 0   
    // skip our own loopback if we receive it
    if (ownLoopback (RTCPsd, dwSSRC, pRTCPses))
        {
        RTCPpostRecvBfr (pSSRC, pRTCPBfrList);

        DecrementIOPendingCount(pSSRC->pRTCPses);

        return;
        }
#endif

    // This code only to track the multicast packets that are not
    // correctly filterd by WS2 when mcast loopback is disabled
#if 0 && defined(_DEBUG)
    {
        PSSRC_ENTRY pSSRC;
        unsigned char *addr;
        char str[40];

        // don't create an entry if received our own xmit back 
        pSSRC = searchforSSRCatTail((PSSRC_ENTRY)pRTCPses->XmtSSRCList.prev,
                                    dwSSRC,
                                    &pRTCPses->SSRCListCritSect);
        if (pSSRC) {
            // This SSRC is ours
            addr = (unsigned char *)
                &(((PSOCKADDR_IN)&pRTCPBfrList->addr)->sin_addr);
            
            sprintf(str, "RTCP loopback from: %d.%d.%d.%d",
                    addr[0],addr[1],addr[2],addr[3]);
            
            DebugBreak();
        }
    }
#endif
    
    // at this point we think the RTCP packet's valid. Get the sender's 
    //  address, if not already known
    if (!(pRTCPses->dwSessionStatus & RTCP_DEST_LEARNED))
        {
        pRTCPses->dwSessionStatus |= RTCP_DEST_LEARNED;
        pRTCPses->toAddrLen = pRTCPBfrList->addrLen;
        CopyMemory(&pRTCPses->toAddr, &pRTCPBfrList->addr,
                   pRTCPBfrList->addrLen);

#ifdef ENABLE_ISDM2
        // register our Xmt SSRC - Rcvd one will be found later
        if (Isdm2.hISDMdll)
            registerSessionToISDM (pSSRC, pRTCPses, &Isdm2);
#endif
        }
    
    // Update our RTCP average packet size estimator
    EnterCriticalSection (&pRTCPses->BfrCritSect);
    tmpSize = (cbTransferred + NTWRK_HDR_SIZE) - pRTCPses->avgRTCPpktSizeRcvd;

#ifdef ENABLE_FLOATING_POINT
    // As per RFC
    tmpSize = (int)(tmpSize * RTCP_SIZE_GAIN);
#else
    // Need to remove floating point operation
    tmpSize = tmpSize / 16;
#endif

    pRTCPses->avgRTCPpktSizeRcvd += tmpSize;
    LeaveCriticalSection (&pRTCPses->BfrCritSect);

    // check if the raw RTCP packet needs to be copied into an application 
    //  buffer - Mainly used by ActiveMovieRTP to propagate the reports up
    //  the filter graph to the Receive Payload Handler
    pAppBfr = (PAPP_RTCP_BFR)removePcktFromHead (&(pRTCPses->appRtcpBfrList), 
                                                 &pRTCPses->BfrCritSect);
    if (pAppBfr && !(pAppBfr->dwBfrStatus & RTCP_SR_ONLY))
        {
        // copy the full RTCP packet
        CopyMemory(pAppBfr->bfr, 
                   pRTCPpckt, 
                   MIN(pAppBfr->dwBfrLen, cbTransferred));

        // number of bytes received
        pAppBfr->dwBytesRcvd = MIN(pAppBfr->dwBfrLen, cbTransferred);

        // set the event associated with this buffer
        SetEvent (pAppBfr->hBfrEvent);
        }

    // end of the received packet 
    pEndPckt = (unsigned char *)pRTCPpckt + cbTransferred;

    int index = -1;
    while ((unsigned char *)pRTCPpckt < pEndPckt)
    {
        index++;
        // get the length 
        dwStatus = RRCMws.ntohs (RTCPsd, pRTCPpckt->common.length, &wHost);
        if (dwStatus)
        {
            char str[128];
            sprintf(str,"RTCP: ERROR - %d:WSANtohs()",index);
            RRCM_DBG_MSG (str, GetLastError(), 
                          __FILE__, __LINE__, DBG_ERROR);
            }

        // get this report block length 
        pcktLen   = (wHost + 1) << 2;
        pEndBlock = (unsigned char *)pRTCPpckt + pcktLen;

        // sanity check 
        if (pEndBlock > pEndPckt)
            {
            RRCM_DBG_MSG ("RTCP: ERROR - Rcv packet length error", 0, 
                          __FILE__, __LINE__, DBG_ERROR);

#ifdef MONITOR_STATS
            pRTCPses->dwNumRTCPlenErr++;
#endif
            break;
            }

        // make sure the version is correct for all packets 
        if (pRTCPpckt->common.type != RTP_TYPE)
            {
#ifdef MONITOR_STATS
            pRTCPses->dwNumRTCPhdrErr++;
#endif
            // invalid RTCP packet header, packet will be re-queued 
            break;
            }

        switch (pRTCPpckt->common.pt)
            {
            case RTCP_SR:
                // check if only the SR needs to be propagated up to the app
                if (pAppBfr && (pAppBfr->dwBfrStatus & RTCP_SR_ONLY))
                    {
                    // copy the RTCP SR
                    CopyMemory(pAppBfr->bfr, 
                               pRTCPpckt, 
                               MIN(pAppBfr->dwBfrLen, RTCP_SR_SIZE));

                    // number of bytes received
                    pAppBfr->dwBytesRcvd = MIN(pAppBfr->dwBfrLen, RTCP_SR_SIZE);

                    // set the event associated with this buffer
                    SetEvent (pAppBfr->hBfrEvent);
                    }

                // get the sender's SSRC
                RRCMws.ntohl (RTCPsd, pRTCPpckt->r.sr.ssrc, &dwSSRC);

                // parse the sender report 
                parseRTCPsr (RTCPsd, pRTCPpckt, pRTCPses, pRTCPBfrList);

                // parse additional receiver reports if any 
                for (i = 0; i < pRTCPpckt->common.count; i++)
                    {
                    parseRTCPrr (RTCPsd, &pRTCPpckt->r.sr.rr[i], 
                                 pRTCPses, pRTCPBfrList,
                                 dwSSRC);
                    }

                // notify application if interested
                RRCMnotification (RRCM_RECV_RTCP_SNDR_REPORT_EVENT, pSSRC, 
                                  dwSSRC,
                                  (DWORD)pSSRC->pRTPses->pSocket[SOCK_RTCP]);
                break;

            case RTCP_RR:
                // get the sender's SSRC
                RRCMws.ntohl (RTCPsd, pRTCPpckt->r.rr.ssrc, &dwSSRC);

                if (pRTCPpckt->common.count == 0)
                    {
                    // reset the feedback information that might have
                    //   previously be send by this SSRC if we did send data
                    //   but we now stopped. 
                    // An RTCP RR with no feedback will be most likely an 
                    // empty RR, i.e. the count will be 0
                    clearFeedbackStatus (pRTCPses, dwSSRC);
                    }
                else
                    {
                    // parse receiver reports 
                    for (i = 0; i < pRTCPpckt->common.count; i++)
                        {
                        parseRTCPrr (RTCPsd, &pRTCPpckt->r.rr.rr[i], 
                                     pRTCPses, pRTCPBfrList, 
                                     dwSSRC);
                        }
                    }

                // notify application if interested
                RRCMnotification (RRCM_RECV_RTCP_RECV_REPORT_EVENT, pSSRC, 
                                  dwSSRC,
                                  (DWORD)pSSRC->pRTPses->pSocket[SOCK_RTCP]);
                break;

            case RTCP_SDES:
                {
                PCHAR   buf;

                buf = (PCHAR)&pRTCPpckt->r.sdes;

                for (i = 0; i < pRTCPpckt->common.count; i++)
                    {
                    buf = parseRTCPsdes (RTCPsd, buf, pRTCPses, pRTCPBfrList);
                    if (buf == NULL)
                        break;
                    }
                }
                break;

            case RTCP_BYE:
                for (i = 0; i < pRTCPpckt->common.count; i++) 
                    parseRTCPbye (RTCPsd, pRTCPpckt->r.bye.src[i], 
                                  pRTCPses, pRTCPBfrList);
                break;

            default:
                break;
            }

        // go to next report block 
        pRTCPpckt = (RTCP_T *)(pEndBlock);
        }

    // post back the buffer to WS-2 
    RTCPpostRecvBfr (pSSRC, pRTCPBfrList);

    DecrementIOPendingCount(pSSRC->pRTCPses);

#if IO_CHECK
    wsprintf(debug_string, 
        "RTCP: Leaving Rcv Callback after: %ld msec\n", 
         timeGetTime() - initTime);
    RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

    IN_OUT_STR ("RTCP: Exit RTCPrcvCallback\n");
    }



/*----------------------------------------------------------------------------
 * Function   : parseRTCPsr
 * Description: Parse an RTCP sender reports and update the corresponding
 *              statistics.
 * 
 * Input :      sd:         RTCP Socket descriptor
 *              pRTCPpckt:  -> to the RTCP packet
 *              pRTCPses:   -> to the RTCP session information
 *              pRTCPBfrList:   -> to the receive structure information
 *
 * Return:      OK: RRCM_NoError
 *              !0: Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
DWORD parseRTCPsr (SOCKET sd, 
                   RTCP_T *pRTCPpckt, 
                   PRTCP_SESSION pRTCPses, 
                   PRTCP_BFR_LIST pRTCPBfrList)
    {
    PSSRC_ENTRY pSSRC;
    DWORD       dwSSRC;

    IN_OUT_STR ("RTCP: Enter parseRTCPsr\n");

    // get the sender's SSRC 
    RRCMws.ntohl (sd, pRTCPpckt->r.sr.ssrc, &dwSSRC);

#ifdef _DEBUG
    wsprintf(debug_string, "RTCP: Receive SR from SSRC:x%lX", dwSSRC);
    RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

    // look for the SSRC entry in the list for this RTCP session 
    pSSRC = searchforSSRCatTail((PSSRC_ENTRY)pRTCPses->RcvSSRCList.prev,
                                dwSSRC,
                                &pRTCPses->SSRCListCritSect);

    DWORD fNewSource = 0;
    
    if (pSSRC == NULL) 
        {
        // new SSRC, create an entry in this RTCP session 
        pSSRC = createSSRCEntry(dwSSRC,
                                pRTCPses,
                                &pRTCPBfrList->addr,
                                (DWORD)pRTCPBfrList->addrLen,
                                UPDATE_RTCP_ADDR,
                                FALSE);

        if (pSSRC == NULL)
            {
            // cannot create a new entry, out of resources 
            RRCM_DBG_MSG ("RTCP: ERROR - Resource allocation", 0, 
                          __FILE__, __LINE__, DBG_ERROR);

            IN_OUT_STR ("RTCP: Exit parseRTCPsr\n");

            return (RRCMError_RTCPResources);
            }

        fNewSource = 1;
        }

    // get the RTP timestamp 
    RRCMws.ntohl (sd, pRTCPpckt->r.sr.rtp_ts, &pSSRC->xmtInfo.dwRTPts);

    // number of packets send 
    RRCMws.ntohl (sd, pRTCPpckt->r.sr.psent, &pSSRC->xmtInfo.dwNumPcktSent);

    // number of bytes sent 
    RRCMws.ntohl (sd, pRTCPpckt->r.sr.osent, &pSSRC->xmtInfo.dwNumBytesSent);

    // get the NTP most significant word 
    RRCMws.ntohl (sd, pRTCPpckt->r.sr.ntp_sec, &pSSRC->xmtInfo.dwNTPmsw);

    // get the NTP least significant word 
    RRCMws.ntohl (sd, pRTCPpckt->r.sr.ntp_frac, &pSSRC->xmtInfo.dwNTPlsw);

    // last SR timestamp (middle 32 bits of the NTP timestamp)
    pSSRC->xmtInfo.dwLastSR = ((pSSRC->xmtInfo.dwNTPmsw & 0x0000FFFF) << 16);
    pSSRC->xmtInfo.dwLastSR |= ((pSSRC->xmtInfo.dwNTPlsw & 0xFFFF0000) >> 16);
    
    // last time this SSRC's heard
    pSSRC->dwLastReportRcvdTime = pSSRC->xmtInfo.dwLastSRLocalTime = 
        timeGetTime();
    if (pSSRC->dwSSRCStatus & RTCP_INACTIVE_EVENT) {
        // reset to active again
        pSSRC->dwSSRCStatus &= ~RTCP_INACTIVE_EVENT;
        // post event if was inactive
        RRCMnotification(RRCM_ACTIVE_EVENT, pSSRC, pSSRC->SSRC, 0);
    }

    // get the source address information 
    if (!(pSSRC->dwSSRCStatus & NETWK_RTCPADDR_UPDATED))
        {
        saveNetworkAddress(pSSRC,
                           &pRTCPBfrList->addr,
                           pRTCPBfrList->addrLen,
                           UPDATE_RTCP_ADDR);
        }

    // notify application if it was a new source
    if (fNewSource)
        RRCMnotification (RRCM_NEW_SOURCE_EVENT, pSSRC, dwSSRC, 
                          UNKNOWN_PAYLOAD_TYPE);
    
    // increment the number of report received from this SSRC
    InterlockedIncrement ((long *)&pSSRC->dwNumRptRcvd);

#ifdef ENABLE_ISDM2
    // update ISDM
    if (Isdm2.hISDMdll && pRTCPses->hSessKey)
        {
        if (pSSRC->hISDM) 
            updateISDMstat (pSSRC, &Isdm2, RECVR, FALSE);
        else
            registerSessionToISDM (pSSRC, pRTCPses, &Isdm2);
        }
#endif

    IN_OUT_STR ("RTCP: Exit parseRTCPsr\n");

    return (RRCM_NoError);
    }



/*----------------------------------------------------------------------------
 * Function   : parseRTCPrr
 * Description: Parse an RTCP receiver reports and update the corresponding
 *              statistics.
 * 
 * Input :      sd:         RTCP socket descriptor
 *              pRR:        -> to receiver report buffer
 *              pRTCPses:   -> to the RTCP session information
 *              pRTCPBfrList:   -> to the receive structure information
 *              senderSSRC: Sender's SSRC
 *
 * Return:      OK: RRCM_NoError
 *              !0: Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
 DWORD parseRTCPrr (SOCKET sd, 
                    RTCP_RR_T *pRR,
                    PRTCP_SESSION pRTCPses, 
                    PRTCP_BFR_LIST pRTCPBfrList,
                    DWORD senderSSRC)
    {
    PSSRC_ENTRY pSSRC;
    DWORD       dwSSRC;
    void       *vpGetFeedback = NULL;

    IN_OUT_STR ("RTCP: Enter parseRTCPrr\n");

#ifdef _DEBUG
    wsprintf(debug_string, 
        "RTCP: Receive RR from sender SSRC:x%lX", senderSSRC);
    RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

    // get the receiver report SSRC 
    RRCMws.ntohl (sd, pRR->ssrc, &dwSSRC);

#ifdef _DEBUG
    wsprintf(debug_string, "RTCP: RR for SSRC:x%lX", dwSSRC);
    RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

    // 
    // NOTE:
    // For now we just keep track of feedback information about ourselve. Later
    // the link list can be used to keep track about everybody feedback 
    // information.
    //
    // Check to see if we're interested in this report, ie, does this SSRC report
    // information about one of our active sender.
    vpGetFeedback = 
        searchforSSRCatTail((PSSRC_ENTRY)pRTCPses->XmtSSRCList.prev,
                            dwSSRC,
                            &pRTCPses->SSRCListCritSect);

    // look for the sender SSRC entry in the list for this RTCP session 
    pSSRC = 
        searchforSSRCatTail((PSSRC_ENTRY)pRTCPses->RcvSSRCList.prev, 
                            senderSSRC,
                            &pRTCPses->SSRCListCritSect);

    DWORD fNewSource = 0;
    
    if (pSSRC == NULL) 
        {
        // new SSRC, create an entry in this RTCP session 
        pSSRC = createSSRCEntry(senderSSRC,
                                pRTCPses,
                                &pRTCPBfrList->addr,
                                (DWORD)pRTCPBfrList->addrLen,
                                UPDATE_RTCP_ADDR,
                                FALSE);

        if (pSSRC == NULL)
            {
            // cannot create a new entry, out of resources 
            RRCM_DBG_MSG ("RTCP: ERROR - Resource allocation", 0, 
                          __FILE__, __LINE__, DBG_ERROR);

            IN_OUT_STR ("RTCP: Exit parseRTCPrr\n");
            return (RRCMError_RTCPResources);
            }

        fNewSource = 1;
        }

    // update RR feedback information 
    if (vpGetFeedback)
        {
        updateRRfeedback (sd, senderSSRC, dwSSRC, pRR, pSSRC);
        }
    else
        {
        // clear feedback SSRC - Used as a flag in the RTCP report API
        //  to instruct the application that feedback is present or not
        pSSRC->rrFeedback.SSRC = 0;
        }

    // last time this SSRC's heard
    pSSRC->dwLastReportRcvdTime = timeGetTime();
    if (pSSRC->dwSSRCStatus & RTCP_INACTIVE_EVENT) {
        // reset to active again
        pSSRC->dwSSRCStatus &= ~RTCP_INACTIVE_EVENT;
        // post event if was inactive
        RRCMnotification(RRCM_ACTIVE_EVENT, pSSRC, pSSRC->SSRC, 0);
    }

    // get the source address information 
    if (!(pSSRC->dwSSRCStatus & NETWK_RTCPADDR_UPDATED))
        {
        saveNetworkAddress(pSSRC,
                           &pRTCPBfrList->addr,
                           pRTCPBfrList->addrLen,
                           UPDATE_RTCP_ADDR);
        }

    // notify application if it desired so (it it was a new source)
    if (fNewSource)
        RRCMnotification (RRCM_NEW_SOURCE_EVENT, pSSRC, senderSSRC,
                          UNKNOWN_PAYLOAD_TYPE);
    
    // increment the number of report received from this SSRC
    InterlockedIncrement ((long *)&pSSRC->dwNumRptRcvd);

#ifdef ENABLE_ISDM2
    // update ISDM
    if (Isdm2.hISDMdll && pRTCPses->hSessKey)
        {
        if (pSSRC->hISDM) 
            updateISDMstat (pSSRC, &Isdm2, RECVR, TRUE);
        else
            registerSessionToISDM (pSSRC, pRTCPses, &Isdm2);
        }
#endif

    IN_OUT_STR ("RTCP: Exit parseRTCPrr\n");

    return (RRCM_NoError);
    }



/*----------------------------------------------------------------------------
 * Function   : parseRTCPsdes
 * Description: Parse an RTCP SDES packet
 * 
 * Input :      sd:         RTCP socket descriptor
 *              bfr:        -> to SDES buffer
 *              pRTCPses:   -> to the RTCP session information
 *              pRTCPBfrList:   -> to the receive structure information
 *
 * Return:      OK: RRCM_NoError
 *              !0: Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
PCHAR parseRTCPsdes (SOCKET sd, 
                     PCHAR bfr, 
                     PRTCP_SESSION pRTCPses, 
                     PRTCP_BFR_LIST pRTCPBfrList)
    {
    DWORD               dwHost;
    DWORD               ssrc = *(DWORD *)bfr;
    RTCP_SDES_ITEM_T    *pSdes;
    PSSRC_ENTRY         pSSRC;

    IN_OUT_STR ("RTCP: Enter parseRTCPsdes\n");

    // get the SSRC 
    RRCMws.ntohl (sd, ssrc, &dwHost);

#ifdef _DEBUG
    wsprintf(debug_string, "RTCP: Receive SDES from SSRC: x%lX", dwHost);
    RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

    // look for the SSRC entry in the list for this RTCP session 
    pSSRC = searchforSSRCatTail ((PSSRC_ENTRY)pRTCPses->RcvSSRCList.prev, 
                                 dwHost,
                                 &pRTCPses->SSRCListCritSect);

    DWORD fNewSource = 0;
    
    if (pSSRC == NULL) 
        {
#ifdef _DEBUG
        wsprintf(debug_string, 
             "RTCP: SDES and SSRC (x%lX) not found for session (Addr x%lX)",
             dwHost, pRTCPses);
        RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

        // new SSRC, create an entry in this RTCP session 
        pSSRC = createSSRCEntry(dwHost,
                                pRTCPses,
                                &pRTCPBfrList->addr,
                                (DWORD)pRTCPBfrList->addrLen,
                                UPDATE_RTCP_ADDR,
                                FALSE);

        if (pSSRC == NULL)
            {
            // cannot create a new entry, out of resources 
            RRCM_DBG_MSG ("RTCP: ERROR - Resource allocation", 0, 
                          __FILE__, __LINE__, DBG_ERROR);

            IN_OUT_STR ("RTCP: Exit parseRTCPsdes\n");

            return (NULL);
            }

        fNewSource = 1;
        }

    // read the SDES chunk 
    pSdes = (RTCP_SDES_ITEM_T *)(bfr + sizeof(DWORD));

#if defined(_DEBUG)
    if (pSdes->dwSdesType == RTCP_SDES_END) {
        char msg[256];
        wsprintf(msg, 
             "RTCP: SSRC: x%lX SDES packet with only SDES END",
              pSSRC->SSRC);
        RRCM_DBG_MSG (msg, 0, NULL, 0, DBG_TRACE);
        
    }
#endif
    
    // go through until a 'type = 0' is found
    for (; pSdes->dwSdesType; 
         pSdes = (RTCP_SDES_ITEM_T *)((char *)pSdes + pSdes->dwSdesLength + 2))
    {
        if (pSdes->dwSdesType > RTCP_SDES_FIRST &&
            pSdes->dwSdesType < RTCP_SDES_LAST) {

            int update = 0;
            int sdesIndex = SDES_INDEX(pSdes->dwSdesType);
            
            if (pSdes->dwSdesType == RTCP_SDES_CNAME) {
                if (pSSRC->sdesItem[sdesIndex].dwSdesLength == 0)
                {
                    update = 1;
                } else {
                    // check to see for a loop/collision of the SSRC
                    if (memcmp (pSdes->sdesData,
                                pSSRC->sdesItem[sdesIndex].sdesBfr, 
                                min(pSdes->dwSdesLength, MAX_SDES_LEN-1)) != 0)
                        {
                        // loop/collision of a third-party detected
                        pSSRC->dwSSRCStatus |= THIRD_PARTY_COLLISION;

                        // notify application if interested
                        RRCMnotification (RRCM_REMOTE_COLLISION_EVENT, pSSRC,
                                          pSSRC->SSRC, 0);

                        // RTP & RTCP packet from this SSRC will be rejected
                        //  until the senders resolve the collision

                        IN_OUT_STR ("RTCP: Exit parseRTCPsdes\n");

                        return NULL;
                        }
                }
            } else if (pSdes->dwSdesType == RTCP_SDES_NAME) {
                // the name can change, not like the Cname, so update it
                // every time.
                update = 1;
            }

            if (update || pSSRC->sdesItem[sdesIndex].dwSdesLength == 0) {
                pSSRC->sdesItem[sdesIndex].dwSdesType = pSdes->dwSdesType;
                pSSRC->sdesItem[sdesIndex].dwSdesLength = pSdes->dwSdesLength;

                CopyMemory(pSSRC->sdesItem[sdesIndex].sdesBfr,
                           pSdes->sdesData, 
                           min(pSdes->dwSdesLength, MAX_SDES_LEN-1));
            }

#if defined(_DEBUG)
            char *sdes_name[]={"  END","CNAME"," NAME","EMAIL","PHONE",
                               "  LOC"," TOOL","  TXT"," PRIV"};
            char msg[256];
            wsprintf(msg, "RTCP: SDES %s(%2u): [%08X]<%s>",
                     sdes_name[pSdes->dwSdesType],
                     pSdes->dwSdesLength,
                     pSSRC->SSRC,
                     pSdes->sdesData);
            RRCM_DBG_MSG (msg, 0, NULL, 0, DBG_TRACE);
#endif
        }
    }

    // last time this SSRC's heard
    pSSRC->dwLastReportRcvdTime = timeGetTime();
    if (pSSRC->dwSSRCStatus & RTCP_INACTIVE_EVENT) {
        // reset to active again
        pSSRC->dwSSRCStatus &= ~RTCP_INACTIVE_EVENT;
        // post event if was inactive
        RRCMnotification(RRCM_ACTIVE_EVENT, pSSRC, pSSRC->SSRC, 0);
    }

    // get the source address information 
    if (!(pSSRC->dwSSRCStatus & NETWK_RTCPADDR_UPDATED))
        {
        saveNetworkAddress(pSSRC,
                           &pRTCPBfrList->addr,
                           pRTCPBfrList->addrLen,
                           UPDATE_RTCP_ADDR);
        }

    // notify application if it desired so (if it was a new source)
    if (fNewSource)
        RRCMnotification (RRCM_NEW_SOURCE_EVENT, pSSRC, dwHost,
                          UNKNOWN_PAYLOAD_TYPE);
    
    // adjust pointer 
    bfr = (char *)pSdes;

    IN_OUT_STR ("RTCP: Exit parseRTCPsdes\n");

    // go the next 32 bits boundary 
    return bfr + ((4 - ((ULONG_PTR)bfr & 0x3)) & 0x3);
    }




/*----------------------------------------------------------------------------
 * Function   : parseRTCPbye
 * Description: Parse an RTCP BYE packet
 * 
 * Input :      sd:         RTCP socket descriptor
 *              ssrc:       SSRC
 *              pRTCPses:   -> to the RTCP session information
 *              pRTCPBfrList:   -> to the receive structure
 *
 * Return:      OK: RRCM_NoError
 *              !0: Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
DWORD parseRTCPbye (SOCKET sd, 
                    DWORD ssrc, 
                    PRTCP_SESSION pRTCPses,
                    PRTCP_BFR_LIST pRTCPBfrList) 
    {
    DWORD       dwStatus;
    DWORD       dwHost;
    PSSRC_ENTRY pSSRC;
    DWORD       *pdwSrc;
    DWORD       *pdwDst;

    IN_OUT_STR ("RTCP: Enter parseRTCPbye\n");

    RRCMws.ntohl (sd, ssrc, &dwHost);

#ifdef _DEBUG
    RRCMDbgLog((
            LOG_TRACE,
            LOG_DEVELOP,
            "RTCP: BYE from SSRC: 0x%lX",
            dwHost
        ));
#endif

    // find the SSRC entry
    pSSRC = searchforSSRCatTail((PSSRC_ENTRY)pRTCPses->RcvSSRCList.prev,
                                dwHost,
                                &pRTCPses->SSRCListCritSect);
    if (pSSRC == NULL) 
        {
#ifdef _DEBUG
            RRCMDbgLog((
                    LOG_TRACE,
                    LOG_DEVELOP,
                    "RTCP: SSRC: x%lX not found in session: x%lX",
                    dwHost, pRTCPses
                ));

        IN_OUT_STR ("RTCP: Exit parseRTCPbye\n");
#endif
        // Anyway call delete function to add SSRC to BYE list
        deleteSSRCEntry(dwHost, pRTCPses);
        return (RRCM_NoError);
        }

    // Make sure the BYE is coming from the expected source and not intruder
    // Just check the IP address and not the port number, as we might have
    // learned the address from RTP
    pdwSrc = (DWORD *) &((SOCKADDR_IN *)&pRTCPBfrList->addr)->sin_addr;
    pdwDst = (DWORD *) &((SOCKADDR_IN *)&pSSRC->fromRTCP)->sin_addr;

    if (!*pdwDst) {
        /* RTCP address not available yet,use RTP address */
        pdwDst = (DWORD *) &((SOCKADDR_IN *)&pSSRC->fromRTP)->sin_addr;
    }
    
    if (*pdwDst && (*pdwSrc != *pdwDst)) {

        RRCMDbgLog((
                LOG_TRACE,
                LOG_DEVELOP,
                "RTCP: BYE ignored, different address Src:0x%X Dst:0x%X",
                *pdwSrc, *pdwDst
            ));
       
        return (RRCM_NoError);
    }

    // notify application if interested
    RRCMnotification (RRCM_BYE_EVENT, pSSRC, dwHost,
                      ((SOCKADDR_IN *)&pSSRC->fromRTCP)->sin_addr.s_addr );

    // delete this SSRC from the list 
    dwStatus = deleteSSRCEntry (dwHost, pRTCPses);
#ifdef _DEBUG
    if (dwStatus == FALSE)
        {
        wsprintf(debug_string, 
             "RTCP: SSRC: x%lX not found in session: x%lX",
              dwHost, pRTCPses);
        RRCM_DBG_MSG (debug_string, 0, __FILE__, __LINE__, DBG_TRACE);
        }
#endif

    IN_OUT_STR ("RTCP: Exit parseRTCPbye\n");
    return (RRCM_NoError);
    }



/*----------------------------------------------------------------------------
 * Function   : ownLoopback
 * Description: Determine if we receive our own loopback. We don't want to 
 *              create an entry for ourselve, as we're already in the list.
 * 
 * Input :      sd:         RTCP socket descriptor
 *              ssrc:       SSRC
 *              pRTCPses:   -> to the RTCP session's information
 *
 * Return:      TRUE:   Our loopback
 *              FALSE:  No loopback
 ---------------------------------------------------------------------------*/
#if 0
DWORD ownLoopback (SOCKET sd, 
                    DWORD ssrc, 
                    PRTCP_SESSION pRTCPses) 
    {
    PSSRC_ENTRY pSSRC;

    IN_OUT_STR ("RTCP: Enter ownLoopback\n");

    // don't create an entry if received our own xmit back 
    pSSRC = searchforSSRCatTail((PSSRC_ENTRY)pRTCPses->XmtSSRCList.prev,
                                ssrc,
                                &pRTCPses->SSRCListCritSect);

    IN_OUT_STR ("RTCP: Exit ownLoopback\n");

    if (pSSRC)
        return TRUE;
    else
        return FALSE;
    }

#endif

/*----------------------------------------------------------------------------
 * Function   : updateRRfeedback
 * Description: Update the Receiver Report feedback for an active source
 * 
 * Input :      sd:         RTCP socket descriptor
 *              dwSndSSRC:  Sender's SSRC
 *              pRR:        -> to receiver report entry
 *              pSSRC:      -> to the SSRC entry
 *
 * Return:      TRUE
 ---------------------------------------------------------------------------*/
 DWORD  updateRRfeedback (SOCKET sd, 
                          DWORD dwSndSSRC, 
                          DWORD dwSSRCfedback,
                          RTCP_RR_T *pRR,
                          PSSRC_ENTRY pSSRC)
    {
    DWORD   dwHost;

    IN_OUT_STR ("RTCP: Enter updateRRfeedback\n");

    // Note when we last heard from the receiver
    pSSRC->rrFeedback.dwLastRcvRpt = timeGetTime();
    
    // SSRC who's feedback is for (ourselve for now) 
    pSSRC->rrFeedback.SSRC = dwSSRCfedback;

    // get delay since last SR 
    RRCMws.ntohl (sd, pRR->dlsr, &pSSRC->rrFeedback.dwDelaySinceLastSR);

    // get last SR 
    RRCMws.ntohl (sd, pRR->lsr, &pSSRC->rrFeedback.dwLastSR);

    // get the jitter 
    RRCMws.ntohl (sd, pRR->jitter, &pSSRC->rrFeedback.dwInterJitter);

    // highest sequence number received 
    RRCMws.ntohl (sd, pRR->expected, 
        &pSSRC->rrFeedback.XtendedSeqNum.seq_union.dwXtndedHighSeqNumRcvd);

    // fraction lost 
    pSSRC->rrFeedback.fractionLost = (pRR->received & 0xFF);

    // post an event
    RRCMnotification(RRCM_LOSS_RATE_RR_EVENT, pSSRC, 
                     (DWORD) ( ((double)(pRR->received & 0xFF)) *
                               100.0/256.0 ),
                     dwSndSSRC);
    
    // cumulative number of packet lost 
    RRCMws.ntohl (sd, pRR->received, &dwHost);
    dwHost &= 0x00FFFFFF;
    pSSRC->rrFeedback.cumNumPcktLost = dwHost;

    IN_OUT_STR ("RTCP: Exit updateRRfeedback\n");

    return TRUE;
    }



/*----------------------------------------------------------------------------
 * Function   : RTCPpostRecvBfr
 * Description: RTCP post a receive buffer to Winsock-2
 * 
 * Input :      sd:         RTCP socket descriptor
 *              pSSRC:      -> to the SSRC entry
 *
 * Return:      Number of buffer posted (0|1)
 ---------------------------------------------------------------------------*/
DWORD RTCPpostRecvBfr (PSSRC_ENTRY pSSRC, 
                       PRTCP_BFR_LIST pRTCPBfrList)
    {
    DWORD   dwStatus;
    DWORD   dwError;

    IN_OUT_STR ("RTCP: Enter RTCPpostRecvBfr\n");

    int max_count = 4;
    
    for(int count = 0; count < max_count; count++) {

        // clear number of bytes transferred
        pRTCPBfrList->dwNumBytesXfr = 0;

        // don't repost any buffer if within the shutdown procedure
        if (pRTCPBfrList->dwKind & RTCP_KIND_BIT(RTCP_KIND_SHUTDOWN)) {
            
            break;
        }

        pRTCPBfrList->overlapped.Internal = 0;

        pSSRC->pRTCPses->dwLastRecvTime = GetTickCount();
        
        dwStatus = RRCMws.recvFrom (pSSRC->pRTPses->pSocket[SOCK_RTCP],
                                    &pRTCPBfrList->bfr,
                                    pRTCPBfrList->dwBufferCount,
                                    &pRTCPBfrList->dwNumBytesXfr, 
                                    &pRTCPBfrList->dwFlags,
                                    &pRTCPBfrList->addr,
                                    &pRTCPBfrList->addrLen,
                                    (LPWSAOVERLAPPED)&pRTCPBfrList->overlapped,
                                    RTCPrcvCallback);
        
        // Check Winsock status
        if (!dwStatus) {
            // we already have valid data but we
            // defer the processing to the callback function

            InterlockedIncrement(&pSSRC->pRTCPses->lNumRcvIoPending);
            return(1);
        } else {

            dwError = WSAGetLastError();
            
            if (dwError == WSA_IO_PENDING) {
                
                InterlockedIncrement(&pSSRC->pRTCPses->lNumRcvIoPending);
                return(1);

            } else if (dwError == WSA_OPERATION_ABORTED ||
                       dwError == WSAEINTR ||
                       dwError == WSAESHUTDOWN) {
                // Socket was closed. Don't repost.
                break;
            } else {
                // dwError == WSAEMSGSIZE
                // dwError == any_other
              
                // Packet to large, repost same buffer.
                // after we pass the max count, we
                // consider this as a real error.

                RRCM_DEV_MSG ("RTCP: ERROR - WSARecvFrom()", dwError, 
                              __FILE__, __LINE__, DBG_ERROR);

                // notify application if interested
                RRCMnotification (RRCM_RTCP_WS_RCV_ERROR, pSSRC, 
                                  pSSRC->SSRC, dwError);
            }
        }
    }

    // Return the buffer to the free queue 
    removePcktFromQueue(&pSSRC->pRTCPses->RTCPrcvBfrListUsed,
                        (PLINK_LIST)pRTCPBfrList,
                        &pSSRC->pRTCPses->BfrCritSect);

    pRTCPBfrList->overlapped.Internal |= 0xfeee0000;
    
    addToHeadOfList (&pSSRC->pRTCPses->RTCPrcvBfrList,
                     (PLINK_LIST)pRTCPBfrList,
                     &pSSRC->pRTCPses->BfrCritSect);

    return(0);

    IN_OUT_STR ("RTCP: Exit RTCPpostRecvBfr\n");
    }


/*----------------------------------------------------------------------------
 * Function   : addApplicationRtcpBfr
 * Description: Add an application provided buffer for RTCP to copy the 
 *              raw received reports to be used by the application if it
 *              desired so.
 * 
 * Input :      RTPsession: Handle to the RTP session
 *              pAppBfr:    -> an application buffer data structure
 *
 * Return:      TRUE
 ---------------------------------------------------------------------------*/
RRCMSTDAPI addApplicationRtcpBfr (DWORD RTPsession, PAPP_RTCP_BFR pAppBfr)
    {
    IN_OUT_STR ("RTCP : Enter addApplicationRtcpBfr()\n");

    PRTP_SESSION    pSession = (PRTP_SESSION)RTPsession;
    PRTCP_SESSION   pRTCPSess;

    if (pSession == NULL) 
        {
        RRCM_DBG_MSG ("RTCP : ERROR - Invalid RTP session", 0, 
                      __FILE__, __LINE__, DBG_ERROR);

        IN_OUT_STR ("RTCP : Exit addApplicationRtcpBfr()\n");

        return (MAKE_RRCM_ERROR(RRCMError_RTPSessResources));
        }

    pRTCPSess = (PRTCP_SESSION)pSession->pRTCPSession;
    if (pRTCPSess == NULL) 
        {
        RRCM_DBG_MSG ("RTCP : ERROR - Invalid RTCP session", 0, 
                      __FILE__, __LINE__, DBG_ERROR);

        IN_OUT_STR ("RTCP : Exit addApplicationRtcpBfr()\n");

        return (MAKE_RRCM_ERROR(RRCMError_RTCPInvalidSession));
        }

    // Let's add this buffer to our list
    addToTailOfList(&(pRTCPSess->appRtcpBfrList), 
                    (PLINK_LIST)pAppBfr,
                    &pRTCPSess->BfrCritSect);

    IN_OUT_STR ("RTCP : Exit addApplicationRtcpBfr()\n");

    return NOERROR;
    }


/*----------------------------------------------------------------------------
 * Function   : removeApplicationRtcpBfr
 * Description: Remove an application provided buffer to this RTCP session.
 * 
 * Input :      RTPsession: RTP session handle
 *
 * Return:      Application buffer address / NULL
 ---------------------------------------------------------------------------*/
#if defined(_0_)
 RRCMAPI PAPP_RTCP_BFR __cdecl removeApplicationRtcpBfr (DWORD RTPsession)
    {
    PRTP_SESSION    pSession = (PRTP_SESSION)RTPsession;
    PRTCP_SESSION   pRTCPSess;
    PAPP_RTCP_BFR   pAppBfr;

    IN_OUT_STR ("RTCP : Enter removeApplicationRtcpBfr()\n");

    if (pSession == NULL) 
        {
        RRCM_DBG_MSG ("RTCP : ERROR - Invalid RTP session", 0, 
                      __FILE__, __LINE__, DBG_ERROR);

        IN_OUT_STR ("RTCP : Exit removeApplicationRtcpBfr()\n");

        return NULL;
        }

    pRTCPSess = (PRTCP_SESSION)pSession->pRTCPSession;
    if (pRTCPSess == NULL) 
        {
        RRCM_DBG_MSG ("RTCP : ERROR - Invalid RTCP session", 0, 
                      __FILE__, __LINE__, DBG_ERROR);

        IN_OUT_STR ("RTCP : Exit removeApplicationRtcpBfr()\n");

        return NULL;
        }

    pAppBfr = (PAPP_RTCP_BFR)removePcktFromHead (&(pRTCPSess->appRtcpBfrList), 
                                                 &pRTCPSess->BfrCritSect);

    IN_OUT_STR ("RTCP : Exit removeApplicationRtcpBfr()\n");

    return pAppBfr;
    }
#endif

/*----------------------------------------------------------------------------
 * Function   : clearFeedbackStatus
 * Description: Clear any feedback status that might have been previously set
 *              by this SSRC if we were sending data and we now stopped.
 *              Just clear the status here. We don't have to create an SSRC
 *              entry if it doesn't exist, as it will be created when decoding
 *              the SDES which should follow this RTCP message.
 * 
 * Input :      pRTCPses    : -> to the RTCP session
 *              dwSSRC      : Sender's SSRC
 *
 * Return:      Success / Failure
 ---------------------------------------------------------------------------*/
DWORD clearFeedbackStatus (PRTCP_SESSION pRTCPses, 
                           DWORD dwSSRC)
    {
    DWORD       dwStatus = NOERROR;
    PSSRC_ENTRY pSSRC;

    IN_OUT_STR ("RTCP : Enter clearFeedbackStatus()\n");

    // look for the sender SSRC entry in the list for this RTCP session 
    pSSRC = 
        searchforSSRCatTail((PSSRC_ENTRY)pRTCPses->RcvSSRCList.prev,
                            dwSSRC,
                            &pRTCPses->SSRCListCritSect);
    if (pSSRC == NULL) 
        {
        return NOERROR;
        }

    // clear feedback SSRC - Used as a flag in the RTCP report API
    //  to instruct the application that feedback is present or not
    pSSRC->rrFeedback.SSRC = 0;

    // last time this SSRC's heard
    pSSRC->dwLastReportRcvdTime = timeGetTime();

    // increment the number of report received from this SSRC
    InterlockedIncrement ((long *)&pSSRC->dwNumRptRcvd);

    IN_OUT_STR ("RTCP : Exit clearFeedbackStatus()\n");

    return dwStatus;
    }



// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rrcm\rtp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by verstmp.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rrcm\rtcp\rtcpthrd.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTCPIO.C
 * Product:     RTP/RTCP implementation
 * Description: Provides the RTCP network I/O.
 *
 * $Workfile:   rtcpthrd.cpp  $
 * $Author:   CMACIOCC  $
 * $Date:   16 May 1997 09:25:38  $
 * $Revision:   1.9  $
 * $Archive:   R:\rtp\src\rrcm\rtcp\rtcpthrd.cpv  $
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/

#include "rrcm.h"                                    



/*---------------------------------------------------------------------------
/                           External Variables
/--------------------------------------------------------------------------*/                                       
extern PRTCP_CONTEXT    pRTCPContext;
extern RRCM_WS          RRCMws;

#ifdef _DEBUG
extern char     debug_string[];
#endif

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
extern LPInteropLogger RTPLogger;
#endif

// This variables are used to maintain the
// QOS notifications buffers
// this defined in rtcpsess.cpp
extern HEAD_TAIL    RtcpQOSFreeBfrList;     // free buffers head/tail ptrs
extern HEAD_TAIL    RtcpQOSStartBfrList;    // start buffers head/tail ptrs
extern HEAD_TAIL    RtcpQOSStopBfrList;     // stop buffers head/tail ptrs  
extern HANDLE       hHeapRtcpQOSBfrList;    // Heap handle to QOS bfrs list 
extern CRITICAL_SECTION RtcpQOSCritSect;    // critical section 

// used to check for QOS notify structure leaks
long g_lNumRtcpQOSNotify = 0;


void processStartStopQOS(void);
HRESULT StartAsyncQOSNotification(RTP_QOSNOTIFY *pRtpQOSNotify);

/*----------------------------------------------------------------------------
 * Function   : RTCPThread
 * Description: RTCP thread
 * 
 * Input :      pRTCPctxt:  -> to RTCP context
 *
 * Return:      None.
 ---------------------------------------------------------------------------*/
void RTCPThread (PRTCP_CONTEXT pRTCPContext)
    {
    PSSRC_ENTRY         pSSRC;
    PSSRC_ENTRY         pRecvSSRC;
    PRTCP_SESSION       pRTCP;
    long                timerPeriod;
    long                intervalTime;
    long                minTimeInterval;
    long                prvTimeoutChkTime = 0;
    DWORD               updateChkTime = 0;
    DWORD               initTime;
    long                deltaTime;
    int                 dwStatus;
    DWORD               curTime;
    PRTCP_BFR_LIST      pXmtStruct;
    HANDLE              bfrHandle[3];
    DWORD               dwHandleCnt;
    
    RRCM_DEV_MSG ("RTCP: RTCP thread running ...", 0, NULL, 0, DBG_NOTIFY);

    // setup buffer Events
    bfrHandle[0] = pRTCPContext->hTerminateRtcpEvent;
    bfrHandle[1] = pRTCPContext->hRtcpRptRequestEvent;
    bfrHandle[2] = pRTCPContext->hRtcpQOSControlEvent;
    dwHandleCnt  = 3;

    DWORD dwExitID = 0x1000f00d;

    // loop as long as there are sessions in the RTCP session list
    // 
    while (!(pRTCPContext->dwStatus & (1<<STAT_RTCP_SHUTDOWN)))
        {
        //LOOK: Claim global critical section?
        // walk through the RTCP session list from the tail and check which 
        //  SSRC entry timed out if any
        curTime = timeGetTime();
        minTimeInterval = TIMEOUT_CHK_FREQ;

#if 0
        // This code only to see how the critical sections are used
        //
        // lock out access to the list - Make sure it's not being deleted
        EnterCriticalSection (&pRTCPContext->critSect);
        {
            // Get the session's list head
            pRTCP = (PRTCP_SESSION)pRTCPContext->RTCPSession.prev;

            while(pRTCP) {
                EnterCriticalSection (&pRTCP->critSect);
                //LeaveCriticalSection (&pRTCPContext->critSect);

                if (pRTCP->dwSessionStatus & RTCP_ON) {
                    // Don't test SHUTDOWN_IN_PROGRESS
                    // because if the session is in shut down,
                    // it will not be in the list
                    
                    /////////
                    // Do job
                    /////////
                    if (???) {
                        //EnterCriticalSection (&pRTCPContext->critSect);
                        break;
                    }
                }
                    
                PRTCP_SESSION pRTCPaux =
                    (PRTCP_SESSION)(pRTCP->RTCPList.next);
                
                LeaveCriticalSection (&pRTCP->critSect);
                //EnterCriticalSection (&pRTCPContext->critSect);
                
                pRTCP = pRTCPaux;
            }
        }
        LeaveCriticalSection (&pRTCPContext->critSect);

        if (pRTCP) {
            // Do something
            if () {
                // ...
                if () {
                    LeaveCriticalSection (&pRTCP->critSect);
                    continue; // go to while(1) above
                }
            }
            LeaveCriticalSection (&pRTCP->critSect);
        }
#endif
        // lock out access to the list - Make sure it's not being deleted
        EnterCriticalSection (&pRTCPContext->critSect);
        {
        // Get the session's list head
        pRTCP = (PRTCP_SESSION)pRTCPContext->RTCPSession.prev;

        while(pRTCP) {

            // NOTE:
            // The order below in the critical sections is intended,
            // it is a way of artificially extending the scope
            // of the pRTCPContext->critSect into pRTCP->critSect
            // by getting pRTCP->critSect before pRTCPContext->critSect
            // is released. 
            EnterCriticalSection (&pRTCP->critSect);
            //LeaveCriticalSection (&pRTCPContext->critSect);

            // if RTCP shutdown is in progress, ignore
            // this session and move on.
            if (pRTCP->dwSessionStatus & RTCP_ON) {

            // NOTE: this assumes only one SSRC in the transmit list but
            // that assumption has been made elsewhere too
            pSSRC = (PSSRC_ENTRY)pRTCP->XmtSSRCList.prev;

            // if its a new session, post RECVs
            if (pRTCP->dwSessionStatus & NEW_RTCP_SESSION) 
                {
                // post RTCP receive buffers
                dwStatus = RTCPrcvInit(pSSRC);
#ifdef _DEBUG
                if (dwStatus == FALSE)
                    {
                    RRCM_DBG_MSG ("RTCP: Couldn't initialize RTCP receive", 0, 
                                  __FILE__, __LINE__, DBG_TRACE);
                    }
#endif
                // get initial transmit time 
                timerPeriod = RTCPxmitInterval (1, 0, 
                                      pSSRC->xmtInfo.dwRtcpStreamMinBW, 
                                      0, 100, 
                                      &pRTCP->avgRTCPpktSizeRcvd,
                                      1);

                intervalTime = timerPeriod;
                if (intervalTime < 5*1000)
                    intervalTime = 5*1000;
                
                pSSRC->dwNextReportSendTime = curTime + timerPeriod;
                pRTCP->dwSessionStatus &= ~NEW_RTCP_SESSION;
                }

            // check if it has any expired SSRCs
            if ((curTime - prvTimeoutChkTime) > TIMEOUT_CHK_FREQ) {

                updateChkTime = 1;

                // check the colliding entries table and clear it if needed
                RRCMTimeOutCollisionTable (pRTCP);

                long elapsed;

                do {
                    
                    EnterCriticalSection(&pRTCP->SSRCListCritSect);
                    pRecvSSRC = (PSSRC_ENTRY)pRTCP->RcvSSRCList.prev;
                
                    // Find first one with time out
                    while (pRecvSSRC) {
                        // elapsed time since last report received
                        elapsed = curTime - pRecvSSRC->dwLastReportRcvdTime;
                        

                        if ( ((elapsed > (3*intervalTime)) &&
                              !(pRecvSSRC->dwSSRCStatus & RTCP_INACTIVE_EVENT))
                             ||
                             (elapsed >= RTCP_TIME_OUT) ) {

                            RRCMDbgLog((
                                    LOG_TRACE,
                                    LOG_DEVELOP,
                                    "Elapsed: %d, interval time: %d",
                                    elapsed, intervalTime
                                ));
                            break;
                        }
                        
                        pRecvSSRC = (PSSRC_ENTRY)pRecvSSRC->SSRCList.next;
                    }
                    
                    LeaveCriticalSection(&pRTCP->SSRCListCritSect);

                    if (pRecvSSRC) {
                        // one time out happened
                        
                        if (elapsed > RTCP_TIME_OUT) {

                            // notify application if interested
                            // NOTE: may be do this outside the loop?
                            if (pRecvSSRC->rcvInfo.dwNumPcktRcvd == 0 ||
                                pRecvSSRC->rcvInfo.dwNumPcktRcvd >= 4) {

                                // Post event if the SSRC is valid,
                                // i.e. either hasn't sent any packet
                                // at all, or, if has sent RTP
                                // packets, the count is at least 4

                                RRCMnotification(RRCM_TIMEOUT_EVENT,
                                                 pRecvSSRC, 
                                                 pRecvSSRC->SSRC,
                                                 0);
                            }
                        
                            // remove this entry from the list
                            deleteSSRCEntry (pRecvSSRC->SSRC, pRTCP);
                        } else {
                            // check for inactivity (short timeout)
                            // post an event if not done yet

                            pRecvSSRC->dwSSRCStatus |= RTCP_INACTIVE_EVENT;

                            if (pRecvSSRC->rcvInfo.dwNumPcktRcvd == 0 ||
                                pRecvSSRC->rcvInfo.dwNumPcktRcvd > 4) {
                                
                                // Post event if the SSRC is valid,
                                // i.e. either hasn't sent any packet
                                // at all, or, if has sent RTP
                                // packets, the count is at least 4
                                
                                RRCMnotification(RRCM_INACTIVE_EVENT,
                                                 pRecvSSRC, 
                                                 pRecvSSRC->SSRC,
                                                 0);
                            }
                        }
                    }
                } while(pRecvSSRC);

            }
            
            if ( ! (pRTCP->dwSessionStatus & RTCP_DEST_LEARNED))
                {
                // cant send yet because we dont know who to
                // send to. Delay for 3 seconds
                pSSRC->dwNextReportSendTime = curTime + 3000;
                }

            //  if its time to send RTCP reports on this session
            //  then break out of the loop and send it  (cannot
            //  send with the global critsect held)
            //  
            timerPeriod = (pSSRC->dwNextReportSendTime - curTime);
            if (timerPeriod <= RTCP_TIMEOUT_WITHIN_RANGE) 
                {
                    //EnterCriticalSection (&pRTCPContext->critSect);
                    break;
                }

            // if not then check how long before the next scheduled
            // transmission and save the minimum. We will sleep
            // for this much time and then start again.
            if (minTimeInterval > timerPeriod)
                minTimeInterval = timerPeriod;
            }
            
            PRTCP_SESSION pRTCPaux =
                (PRTCP_SESSION)(pRTCP->RTCPList.next);
            
            LeaveCriticalSection (&pRTCP->critSect);
            //EnterCriticalSection (&pRTCPContext->critSect);
                
            pRTCP = pRTCPaux;
        }
        }
        LeaveCriticalSection (&pRTCPContext->critSect);
            
        if (pRTCP) 
            {
            // found a session which needs to send a report
            // session critical section is still held
            pXmtStruct = FormatRTCPReport(pRTCP, pSSRC, curTime);

            // Can not release as I need to prevent the
            // RTCP session from been destroyed (deleteRTCPSession)
            // LeaveCriticalSection(&pRTCP->critSect);
            
            if (pXmtStruct)
                {
#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
                if (RTPLogger)
                    {
                   //INTEROP
                    InteropOutput (RTPLogger,
                                   (BYTE FAR*)(pXmtStruct->bfr.buf),
                                   (int)pXmtStruct->bfr.len,
                                   RTPLOG_SENT_PDU | RTCP_PDU);
                    }
#endif

                // post the receive buffer for this thread 
                dwStatus = RRCMws.sendTo (pSSRC->pRTPses->pSocket[SOCK_RTCP],
                                          &pXmtStruct->bfr,
                                          pXmtStruct->dwBufferCount,
                                          &pXmtStruct->dwNumBytesXfr, 
                                          pXmtStruct->dwFlags,
                                          &pXmtStruct->addr,
                                          pXmtStruct->addrLen,
                                          (LPWSAOVERLAPPED)&pXmtStruct->overlapped,
                                          RTCPxmtCallback);

                // check SendTo status 
                if ((dwStatus == SOCKET_ERROR) && 
                    (dwStatus=GetLastError()) != WSA_IO_PENDING) 
                    {
                    RRCM_DBG_MSG ("RTCP: ERROR - WSASendTo()", dwStatus, 
                                  __FILE__, __LINE__, DBG_ERROR);

                    // notify application if interested
                    RRCMnotification (RRCM_RTCP_WS_XMT_ERROR, pSSRC,
                                      pSSRC->SSRC, dwStatus);

                    // return resources to the free queue 
                    addToHeadOfList (&pRTCP->RTCPxmtBfrList, 
                                     (PLINK_LIST)pXmtStruct,
                                     &pRTCP->BfrCritSect);

                    // WS is busy or another error occured
                    SleepEx (250, TRUE);
                    LeaveCriticalSection(&pRTCP->critSect);
                    continue;
                    }
                else
                    {
                    InterlockedIncrement ((long *)&pSSRC->dwNumRptSent); 
                    InterlockedIncrement ((long *)&pSSRC->dwNumXmtIoPending); 
                    }

                // run through the session list again
                LeaveCriticalSection(&pRTCP->critSect);
                continue;
                }
            LeaveCriticalSection(&pRTCP->critSect);
            }
        
        if (updateChkTime) {
            prvTimeoutChkTime = curTime;
            updateChkTime = 0;
        }
        
        // grab an initial timestamp so we can reset WaitForSingleObjectEx
        initTime = timeGetTime();

        // now we've gone through all the RTCP sessions and
        // verified that none have pending reports to be sent
        // We also know the earliest scheduled timeout so
        // lets sleep till then.
        while (1)
            {
            dwStatus = WaitForMultipleObjectsEx (dwHandleCnt,
                                                 bfrHandle,
                                                 FALSE,
                                                 minTimeInterval, 
                                                 TRUE);
            if (dwStatus == WAIT_OBJECT_0)
                {
                // Exit event was signalled
#ifdef _DEBUG
                wsprintf(debug_string, 
                    "RTCP: Exit RTCP thread - Handle: x%lX - ID: x%lX",
                     pRTCPContext->hRtcpThread, pRTCPContext->dwRtcpThreadID);
                RRCM_DEV_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif
                // If it is not me who signals the event,
                // remember the thread exit here
                dwExitID = 0x0000f00d;
                goto exit_rtcp_thread;
                }
            else if (dwStatus == WAIT_OBJECT_0+1)
                {
                // the application requested a non-periodic control
                //   of the RTCP report frequency
                break;
                }
            else if (dwStatus == WAIT_OBJECT_0+2) {
                // start/stop QOS notifications
                processStartStopQOS();
            } else if (dwStatus == WAIT_IO_COMPLETION)
                {
                // decrement the timerPeriod so the WaitForSingleObjectEx 
                // can continue but if we're less than 250 milliseconds from 
                // the original timeout go ahead and call it close enough.
                curTime = timeGetTime();
                deltaTime = curTime - initTime;
                if (deltaTime < 0) 
                    break;
                else
                    {
                    if (minTimeInterval >
                        (deltaTime + (RTCP_TIMEOUT_WITHIN_RANGE * 2)))
                        {
                        minTimeInterval -= deltaTime;
                        }
                    else
                        break;
                    }
                }
            else if (dwStatus == WAIT_TIMEOUT)
                {
                // the expected completion status
                break;
                }
            else if (dwStatus == WAIT_FAILED)
                {
                RRCM_DBG_MSG ("RTCP: Wait() Error", GetLastError(), 
                              __FILE__, __LINE__, DBG_ERROR);

                break;
                }
            }
        }

    exit_rtcp_thread:

    pRTCPContext->dwRtcpThreadID = dwExitID;
    }


/*----------------------------------------------------------------------------
 * Function   : RTCPThreadCtrl
 * Description: RTCP thread ON / OFF
 * 
 * Input :      dwState:    ON / OFF
 *
 * Return:      0 (success) / 0xFFFFFFFF (failure)
 ---------------------------------------------------------------------------*/
RRCMTHREAD RTCPThreadCtrl (DWORD dwState)
    {
    IN_OUT_STR ("RTCP : Enter RTCPThreadCtrl()\n");

    DWORD   dwStatus = RRCM_NoError;
    DWORD   dwSuspendCnt;
    DWORD   idx;

    if (pRTCPContext->hRtcpThread == 0)
        {
        IN_OUT_STR ("RTCP : Exit RTCPThreadCtrl()\n");

        return dwStatus;
        }

    if (dwState == RTCP_ON)
        {
        idx = MAXIMUM_SUSPEND_COUNT;

        while (idx--)
            {
            dwSuspendCnt = ResumeThread (pRTCPContext->hRtcpThread);

            if (dwSuspendCnt <= 1)
                {
                break;
                }
            else if (dwSuspendCnt == 0xFFFFFFFF) 
                {
                dwStatus = RRCM_NoError;
                break;
                }
            }
        }
    else if (dwState == RTCP_OFF)
        {
        if (SuspendThread (pRTCPContext->hRtcpThread) == 0xFFFFFFFF)
            {
            RRCM_DBG_MSG ("RTCP: SuspendThread() Error", GetLastError(), 
                          __FILE__, __LINE__, DBG_ERROR);
            }
        }

    IN_OUT_STR ("RTCP : Exit RTCPThreadCtrl()\n");

    return dwStatus;
    }


/*----------------------------------------------------------------------------
 * Function   : RTCPSendSessionCtrl
 * Description: Gives RTCP control to the application if the application 
 *              desire to do so. The application is now responsible to comply
 *              with the RTP specification.
 * 
 * Input :      hRtpSession:    Handle of the RTP session
 *              dwTimeout:      RTCP send message timeout
 *                                      0x0         -> RRCM control
 *                                      0x7FFFFFFF  -> RTCP xmt disabled
 *                                      value       -> selected timeout
 *                                                      (periodic or not)
 *
 * Return:      0 (success) / 0xFFFFFFFF (failure)
 ---------------------------------------------------------------------------*/
RRCMSTDAPI RTCPSendSessionCtrl (void *pvRTPSession, DWORD dwTimeOut)
    {
    IN_OUT_STR ("RTCP : Enter RTCPSendSessionCtrl()\n");

    RTP_SESSION    *pSession;
    PSSRC_ENTRY     pSSRC;
    DWORD           dwStatus = RRCM_NoError;

    // Cast Session ID to obtain the session pointer.
    pSession = (RTP_SESSION *)pvRTPSession;
    if (pSession == NULL) 
        {
        RRCM_DBG_MSG ("RTCP : ERROR - Invalid RTP session", 0, 
                      __FILE__, __LINE__, DBG_ERROR);

        IN_OUT_STR ("RTP : Exit RTCPSendSessionCtrl()\n");

        return (MAKE_RRCM_ERROR (RRCMError_RTPSessResources));
        }

    // Get this RTP session's transmit SSRC
    pSSRC = (PSSRC_ENTRY)pSession->pRTCPSession->XmtSSRCList.prev;
    if (pSSRC == NULL)
        {
        RRCM_DBG_MSG ("RTP : ERROR - No SSRC entry on the Xmt list", 0, 
                      __FILE__, __LINE__, DBG_ERROR);

        IN_OUT_STR ("RTCP : Exit RTCPSendSessionCtrl()\n");

        return (MAKE_RRCM_ERROR (RRCMError_RTCPInvalidSSRCentry));
        }

    // set the new RTCP control timeout value
    if (dwTimeOut == RRCM_CTRL_RTCP)
        pSSRC->dwSSRCStatus &= ~RTCP_XMT_USER_CTRL;
    else if (dwTimeOut & RTCP_ONE_SEND_ONLY)
        {
        pSSRC->dwNextReportSendTime = RTCP_TIMEOUT_WITHIN_RANGE;

        // report are then turned off
        pSSRC->dwUserXmtTimeoutCtrl = RTCP_XMT_OFF;

        // signal the thread to terminate
        SetEvent (pRTCPContext->hRtcpRptRequestEvent);
        }
    else
        {
        if (dwTimeOut < RTCP_XMT_MINTIME)
            dwTimeOut = RTCP_XMT_MINTIME;

        pSSRC->dwUserXmtTimeoutCtrl = dwTimeOut;

        pSSRC->dwSSRCStatus |= RTCP_XMT_USER_CTRL;
        }

    IN_OUT_STR ("RTCP : Exit RTCPSendSessionCtrl()\n");

    return dwStatus;
    }

/*----------------------------------------------------------------------------
 * QOS asynchronous notifications
 ----------------------------------------------------------------------------*/
#if defined(_DEBUG)
const
char *sRTCPQOSEventString[] = {"NOQOS",
                               "RECEIVERS",
                               "SENDERS",
                               "NO_SENDERS",
                               "NO_RECEIVERS",
                               "REQUEST_CONFIRMED",
                               "ADMISSION_FAILURE",
                               "POLICY_FAILURE",
                               "BAD_STYLE",
                               "BAD_OBJECT",
                               "TRAFFIC_CTRL_ERROR",
                               "GENERIC_ERROR",
                               "NOT_ALLOWEDTOSEND",
                               "ALLOWEDTOSEND",
                               "????"};
#endif

/* Buffer is not enough big, obtain one big enough, return TRUE if
 * buffer is available, FALSE otherwise */
BOOL ReallocateQOSBuffer(RTP_QOSNOTIFY *pRtpQOSNotify)
{
    DWORD dwNewSize;
    
    dwNewSize = 0;
                
    // Buffer not enough big
    if (pRtpQOSNotify->pBuffer) {
        dwNewSize = *(DWORD *)pRtpQOSNotify->pBuffer;

        RRCMDbgLog((
                LOG_TRACE,
                LOG_DEVELOP,
                "ReallocateQOSBuffer[0x%X]: "
                "Buffer not enough big, requested: %u",
                pRtpQOSNotify, dwNewSize
            ));
    }
                
    if (dwNewSize < QOS_BUFFER_SIZE) {
        dwNewSize = QOS_BUFFER_SIZE;
    }
                
    if (dwNewSize > QOS_MAX_BUFFER_SIZE) {
        dwNewSize = QOS_MAX_BUFFER_SIZE;
    }
                
    if (dwNewSize > pRtpQOSNotify->dwBufferLen) {
                    
        /* Free old buffer */
        if (pRtpQOSNotify->pBuffer) {
            HeapFree(hHeapRtcpQOSBfrList,
                     0,
                     pRtpQOSNotify->pBuffer);
            
            pRtpQOSNotify->dwBufferLen = 0;
        }
                    
        /* Allocate new buffer */
        pRtpQOSNotify->pBuffer = (char *)
            HeapAlloc(hHeapRtcpQOSBfrList, HEAP_ZERO_MEMORY, dwNewSize);
                    
        if (pRtpQOSNotify->pBuffer) {
            pRtpQOSNotify->dwBufferLen = dwNewSize;
            return(TRUE);
        }
    }

    return(FALSE);
}

//
// Callback function for the asynchronous QOS notifications,
// called on the RTCP thread context
//
void CALLBACK RTCPQOSNotifyCallback(DWORD dwError,
                                    DWORD cbTransferred,
                                    LPWSAOVERLAPPED pOverlapped,
                                    DWORD dwFlags)
{
    RTP_QOSNOTIFY *pRtpQOSNotify = (RTP_QOSNOTIFY *)pOverlapped->hEvent;

    RRCMDbgLog((
            LOG_TRACE,
            LOG_DEVELOP,
            "RTCPQOSNotifyCallback: "
            "dwError:%d (0x%X), "
            "cbTransfered:%d "
            "dwFlag:0x%X",
            dwError, dwError, cbTransferred, dwFlags
        ));

    if (dwError >= WSA_QOS_RECEIVERS &&
        dwError <= WSA_QOS_GENERIC_ERROR) {

        // WSA_QOS_* code

        if (pRtpQOSNotify) {

            EnterCriticalSection(&RtcpQOSCritSect);
            
            pRtpQOSNotify->m_lPending = 0;

            if (pRtpQOSNotify->m_lStarted) {
                pRtpQOSNotify->m_dwBytesReturned = cbTransferred;

                // normalize error code to DXMRTP codes
                dwError -= WSA_QOS_RECEIVERS;
                dwError += DXMRTP_QOSEVENT_RECEIVERS;

                RRCMDbgLog((
                        LOG_TRACE,
                        LOG_DEVELOP,
                        "RTCPQOSNotifyCallback[0x%X]: "
                        "Post event(%s) to filters",
                        pRtpQOSNotify, sRTCPQOSEventString[dwError]
                    ));
                
                // post event to filter(s)
                for(DWORD i = 0; i < 2; i++) {
                    if ( (pRtpQOSNotify->m_dwQOSEventMask[i] & (1<<dwError)) &&
                         pRtpQOSNotify->m_pvCRtpSession[i] &&
                         pRtpQOSNotify->m_pCRtpSessionQOSNotify ) {

                        pRtpQOSNotify->m_pCRtpSessionQOSNotify(
                                dwError,
                                pRtpQOSNotify->m_pvCRtpSession[i],
                                (QOS *)pRtpQOSNotify->pBuffer);
                    }
                }
                
                // Prepare again for a new notification
                StartAsyncQOSNotification(pRtpQOSNotify);
            }

            LeaveCriticalSection(&RtcpQOSCritSect);

        } else {
            // Log error, should never happen !!!
            RRCMDbgLog((
                    LOG_ERROR,
                    LOG_DEVELOP,
                    "RTCPQOSNotifyCallback: Should never happen: "
                    "pRtpQOSNotify == NULL"
                ));
        }
    } else {

        EnterCriticalSection(&RtcpQOSCritSect);
            
        pRtpQOSNotify->m_lPending = 0;
        
        LeaveCriticalSection(&RtcpQOSCritSect);

        if (dwError == WSAENOBUFS) {

            EnterCriticalSection(&RtcpQOSCritSect);
            
            // reallocate a bigger buffer
            ReallocateQOSBuffer(pRtpQOSNotify);
            
            // Prepare again for the notification
            StartAsyncQOSNotification(pRtpQOSNotify);

            LeaveCriticalSection(&RtcpQOSCritSect);
            
        } else if (dwError == ERROR_CANCELLED ||
                   dwError == WSA_OPERATION_ABORTED ||
                   dwError == WSAEINTR) {
            // Do nothing, the socket has been closed
            RRCMDbgLog((
                    LOG_ERROR,
                    LOG_DEVELOP,
                    "RTCPQOSNotifyCallback: "
                    "Socket has been closed: %d (0x%X)",
                    dwError, dwError
                ));
        } else {
            // Log error, don't know when this may happen
            //
            // !!! WARNING !!!
            //
            // I may notify about this
            //

            RRCMDbgLog((
                    LOG_ERROR,
                    LOG_DEVELOP,
                    "RTCPQOSNotifyCallback: "
                    "Notifications will stop: "
                    "unknown Error: %d (0x%X)",
                    dwError, dwError
                ));
        }

        // signal the RTCP thread to take care of items that
        // may need to bemoved from stop to free list
        if (pRTCPContext && pRTCPContext->hRtcpQOSControlEvent)
            SetEvent(pRTCPContext->hRtcpQOSControlEvent);
    }
}

//
// Initiate an asynchronous QOS notification
//
HRESULT StartAsyncQOSNotification(RTP_QOSNOTIFY *pRtpQOSNotify)
{
    DWORD dwMaxTry;
    DWORD dwStatus;
    DWORD dwError = 0;

    HRESULT hr = NOERROR;
    
    // initialize some fields for the async I/O
    pRtpQOSNotify->m_Overlapped.hEvent = (WSAEVENT)pRtpQOSNotify;

    RRCMDbgLog((
            LOG_TRACE,
            LOG_DEVELOP,
            "StartAsyncQOSNotification[0x%X]",
            pRtpQOSNotify
        ));

    for(dwError = WSAENOBUFS, dwMaxTry = 3;
        (dwError == WSAENOBUFS) && dwMaxTry;
        dwMaxTry--) {

        RRCMDbgLog((
            LOG_TRACE,
            LOG_DEVELOP,
            "StartAsyncQOSNotification[0x%X]: [0x%X]pBuffer, Size: %u",
            pRtpQOSNotify,
            pRtpQOSNotify->pBuffer,
            pRtpQOSNotify->dwBufferLen
        ));

        if (pRtpQOSNotify->pBuffer) {

            // post request for async QOS notification
            dwStatus = WSAIoctl(pRtpQOSNotify->m_Socket,
                                SIO_GET_QOS,
                                NULL, 0,  // No input buffer
                                pRtpQOSNotify->pBuffer,
                                pRtpQOSNotify->dwBufferLen,
                                &pRtpQOSNotify->m_dwBytesReturned,
                                &pRtpQOSNotify->m_Overlapped,
                                RTCPQOSNotifyCallback);
        } else {
            // no buffer yet, allocate one
            ReallocateQOSBuffer(pRtpQOSNotify);
            continue;
        }
        
        pRtpQOSNotify->m_lPending = 0;
        
        if (!dwStatus) {
            // Operation succeeded,
            // I/O will complete later
            dwError = 0;
            pRtpQOSNotify->m_lPending = 1;
        } else {
            
            dwError = WSAGetLastError();
            
            RRCMDbgLog((
                    LOG_TRACE,
                    LOG_DEVELOP,
                    "StartAsyncQOSNotification[0x%X]: "
                    "Status: %u (0x%X), Error: %u (0x%X)",
                    pRtpQOSNotify,
                    dwStatus, dwStatus, dwError, dwError
                ));
            
            if (dwError == WSA_IO_PENDING) {
                // I/O will complete later
                pRtpQOSNotify->m_lPending = 1;
            } else if (dwError == WSAENOBUFS) {

                /* Reallocate a bigger buffer */
                RRCMDbgLog((
                        LOG_ERROR,
                        LOG_DEVELOP,
                        "StartAsyncQOSNotification[0x%X]: "
                        "Buffer too small",
                        pRtpQOSNotify
                    ));

                ReallocateQOSBuffer(pRtpQOSNotify);

            } else {
                hr = E_FAIL;
                //
                // !!! WARNING !!!
                //
                // Unexpected error, notification requests will stop,
                // next time any notification is start/stop we will retry
                // to start again notifications in this socket.
                //
                // May notify about this.
                //
            }
        }

    }

#if defined(_DEBUG)
    // log either pending I/O or error
    if (!dwStatus || dwError == WSA_IO_PENDING) {
        RRCMDbgLog((
                LOG_ERROR,
                LOG_DEVELOP,
                "StartAsyncQOSNotification[0x%X]: "
                "WSAIoctl(SIO_GET_QOS) succeeded",
                pRtpQOSNotify
            ));
    } else {
        RRCMDbgLog((
                LOG_ERROR,
                LOG_DEVELOP,
                "StartAsyncQOSNotification[0x%X]: "
                "WSAIoctl(SIO_GET_QOS) failed: %d (0x%X)",
                pRtpQOSNotify, dwError, dwError
            ));
    }
#endif
    
    return(hr);
}

// WARNING!!!
// This function MUST be called with the critical section
// RtcpQOSCritSect held
//
RTP_QOSNOTIFY *LookupRtpQOSNotify(SOCKET sock, DWORD  *pfCreate)
{
    RTP_QOSNOTIFY *pRtpQOSNotify;
    DWORD fCreate = *pfCreate;
    
    *pfCreate = 0; // default is no new item created

    // look up in the start list
    for(pRtpQOSNotify = (RTP_QOSNOTIFY *)RtcpQOSStartBfrList.next;

        pRtpQOSNotify && (pRtpQOSNotify->m_Socket != sock);
                        
        pRtpQOSNotify = (RTP_QOSNOTIFY *)
            pRtpQOSNotify->RTPQOSBufferLink.prev) {
        ; // nothing in for() loop body
    }
        
    if (!pRtpQOSNotify && fCreate) {

        // take a free structure from free list
        pRtpQOSNotify = (RTP_QOSNOTIFY *)
            removePcktFromHead(&RtcpQOSFreeBfrList, NULL);

        // ... or if empty create a new one
        if (!pRtpQOSNotify) {

            DWORD numCells = 1;
                
            allocateLinkedList(
                    &RtcpQOSFreeBfrList,
                    hHeapRtcpQOSBfrList,
                    &numCells,
                    sizeof(RTP_QOSNOTIFY),
                    NULL);

            g_lNumRtcpQOSNotify += numCells;
            
            pRtpQOSNotify = (RTP_QOSNOTIFY *)
                removePcktFromHead(&RtcpQOSFreeBfrList, NULL);
        }
            
        if (pRtpQOSNotify) {

            /* Zero the structure but preserve LAST 2 fields, pBuffer
               and dwBufLen. The buffer may be just reused from the
               Free list */
            ZeroMemory(pRtpQOSNotify,
                       sizeof(*pRtpQOSNotify) -
                       sizeof(pRtpQOSNotify->dwBufferLen) -
                       sizeof(pRtpQOSNotify->pBuffer));

            if (!pRtpQOSNotify->pBuffer) {
            
                pRtpQOSNotify->pBuffer = (char *)
                    HeapAlloc(hHeapRtcpQOSBfrList,
                          HEAP_ZERO_MEMORY,
                              QOS_BUFFER_SIZE);

                if (pRtpQOSNotify->pBuffer) {
                    pRtpQOSNotify->dwBufferLen = QOS_BUFFER_SIZE;
                } else {
                    pRtpQOSNotify->dwBufferLen = 0;
                }
            }

            // move to start list regardless pBuffer is NULL or not,
            // if NULL, memory will be allocated later
            pRtpQOSNotify->m_Socket = sock;
            
            *pfCreate = 1; // new item has been created
            
            addToTailOfList(&RtcpQOSStartBfrList,
                            &pRtpQOSNotify->RTPQOSBufferLink,
                            NULL);
        }
    }

    return(pRtpQOSNotify);
}

// This function is called from the RTCP thread, it executes
// in exclusive mode against the RTCPQOSNotifyCallback() callback
// function which executes only when the RTCP thread is waiting in
// alertable mode
void processStartStopQOS(void)
{
    RTP_QOSNOTIFY *pRtpQOSNotify;
    
    if (hHeapRtcpQOSBfrList) {
        RRCMDbgLog((
                LOG_TRACE,
                LOG_DEVELOP,
                "processStartStopQOS from RTCP thread\n"
            ));

        EnterCriticalSection(&RtcpQOSCritSect);
        
        // scan the stop list to see if any items
        // need to be moved to the free list
        for(pRtpQOSNotify = (RTP_QOSNOTIFY *)RtcpQOSStopBfrList.next;

            pRtpQOSNotify;
            ) {

            RTP_QOSNOTIFY *pRtpQOSNotify2 = pRtpQOSNotify;

            pRtpQOSNotify = (RTP_QOSNOTIFY *)
                pRtpQOSNotify->RTPQOSBufferLink.prev;

            if (!pRtpQOSNotify2->m_lPending) {

                /* save buffer keeping pBuffer */

                movePcktFromQueue(
                        &RtcpQOSFreeBfrList,
                        &RtcpQOSStopBfrList,
                        &pRtpQOSNotify2->RTPQOSBufferLink,
                        NULL);
            }
        }

        // scan the start list to see if new async QOS notifications
        // need to be started
        for(pRtpQOSNotify = (RTP_QOSNOTIFY *)RtcpQOSStartBfrList.next;

            pRtpQOSNotify;

            pRtpQOSNotify = (RTP_QOSNOTIFY *)
                pRtpQOSNotify->RTPQOSBufferLink.prev) {

            if (!pRtpQOSNotify->m_lPending) {
                // start async QOS notification
                StartAsyncQOSNotification(pRtpQOSNotify);
            }
        }

        LeaveCriticalSection(&RtcpQOSCritSect);
    } else {
        // log, unexpected condition
    }
}

//
// Start an asynchronous QOS notification.
// No really started here, but signals the RTCP thread to do it
// 
RRCMSTDAPI
RTCPStartQOSNotify(SOCKET sock,
                   void  *pvCRtpSession,
                   DWORD  dwRecvSend,     // 0 == receiver; other == sender
                   DWORD  dwQOSEventMask, // QOS event mask
                   PCRTPSESSION_QOS_NOTIFY_FUNCTION  pCRtpSessionQOSNotify)
{
    HRESULT dwError = E_FAIL;
    RTP_QOSNOTIFY *pRtpQOSNotify;
    
    if (hHeapRtcpQOSBfrList) {

        if (dwRecvSend)
            dwRecvSend = 1;
        else
            dwRecvSend = 0;
        
        EnterCriticalSection(&RtcpQOSCritSect);

        // find out if notifications have already been started
        DWORD fCreate = 1; // create if not found
        
        pRtpQOSNotify = LookupRtpQOSNotify(sock, &fCreate);

        if (pRtpQOSNotify) {
            // log item found/created
            RRCMDbgLog((
                    LOG_TRACE,
                    LOG_DEVELOP,
                    "RTCPStartQOSNotify[0x%X]: Item %s",
                    pRtpQOSNotify, fCreate? "created":"found"
                ));

            if (fCreate) {
                
                // new item was created
                
                pRtpQOSNotify->m_pCRtpSessionQOSNotify =
                    pCRtpSessionQOSNotify;
                pRtpQOSNotify->m_pvCRtpSession[dwRecvSend] =
                    pvCRtpSession;

                // remember who created
                pRtpQOSNotify->m_dwThreadID[dwRecvSend] =
                    pRtpQOSNotify->m_dwThreadID2[dwRecvSend] =
                    GetCurrentThreadId();
                
                // mark as ready to post async I/O
                pRtpQOSNotify->m_lStarted++;
            } else {
                
                // item already existed
                
                if (pRtpQOSNotify->m_pvCRtpSession[dwRecvSend]) {

                    // remember who last started
                    pRtpQOSNotify->m_dwThreadID2[dwRecvSend] =
                        GetCurrentThreadId();

                    // already exist
#if defined(_DEBUG)
                    // just test for consistency
                    if ( (pRtpQOSNotify->m_pCRtpSessionQOSNotify !=
                          pCRtpSessionQOSNotify) ||
                         (pRtpQOSNotify->m_pvCRtpSession[dwRecvSend] !=
                          pvCRtpSession) ) {

                        // log, incosistency detected
                        RRCMDbgLog((
                                LOG_TRACE,
                                LOG_DEVELOP,
                                "RTCPStartQOSNotify[0x%X]: "
                                "Inconsistency detected",
                                pRtpQOSNotify
                            ));
                        
                        ASSERT( (pRtpQOSNotify->m_pCRtpSessionQOSNotify !=
                                 pCRtpSessionQOSNotify) ||
                                (pRtpQOSNotify->m_pvCRtpSession[dwRecvSend] !=
                                 pvCRtpSession) );
                    }
#endif
                } else {
                    pRtpQOSNotify->m_pvCRtpSession[dwRecvSend] =
                        pvCRtpSession;

                    // remember who created
                    pRtpQOSNotify->m_dwThreadID[dwRecvSend] =
                        pRtpQOSNotify->m_dwThreadID2[dwRecvSend] =
                        GetCurrentThreadId();
                
                    // mark as ready to post async I/O
                    pRtpQOSNotify->m_lStarted++;
                }
            }
            
            // update event mask
            pRtpQOSNotify->m_dwQOSEventMask[dwRecvSend] = dwQOSEventMask;

            if (pRTCPContext && pRTCPContext->hRtcpQOSControlEvent) {
                // signal thread about the new request
                // so it can start doing async I/O
                SetEvent(pRTCPContext->hRtcpQOSControlEvent);
                // log if SetEvent fails
                dwError = NOERROR;
            } else {
                // log, unexpected condition
                RRCMDbgLog((
                        LOG_TRACE,
                        LOG_DEVELOP,
                        "RTCPStartQOSNotify[0x%X]: "
                        "Unexpected condition\n",
                        pRtpQOSNotify
                    ));
            }
        } else {
            // log, no resources
            RRCMDbgLog((
                    LOG_TRACE,
                    LOG_DEVELOP,
                    "RTCPStartQOSNotify[0x0]: "
                    "Out of memory"
                ));
        }
        
        LeaveCriticalSection(&RtcpQOSCritSect);
    } else {
        // log if doing nothing, unexpected condition
        RRCMDbgLog((
                LOG_TRACE,
                LOG_DEVELOP,
                "RTCPStartQOSNotify: "
                "Unexpected hHeapRtcpQOSBfrList is NULL"
            ));
    }
    
    return(dwError);
}

//
// Stops an aysnchronous QOS notification.
// Not really done here, but prepare information so the
// aysnchronous notifications will stop for the current item
//
RRCMSTDAPI
RTCPStopQOSNotify(SOCKET sock,
                  void  *pvCRtpSession,
                  DWORD  dwRecvSend)     // 0 == receiver; other == sender
{
    HRESULT dwError = E_FAIL;
    RTP_QOSNOTIFY *pRtpQOSNotify;
    
    if (hHeapRtcpQOSBfrList) {

        if (dwRecvSend)
            dwRecvSend = 1;
        else
            dwRecvSend = 0;

        EnterCriticalSection(&RtcpQOSCritSect);

        // find out if notifications have already been started,
        // if so then the item must be in the start list
        
        DWORD fCreate = 0; // just look up, do not create if not found
        
        pRtpQOSNotify = LookupRtpQOSNotify(sock, &fCreate);

        if (pRtpQOSNotify) {

            // item found in start list

            // log, item found
            RRCMDbgLog((
                    LOG_TRACE,
                    LOG_DEVELOP,
                    "RTCPStopQOSNotify[0x%X]: Item found",
                    pRtpQOSNotify
                ));

            if (!pRtpQOSNotify->m_pvCRtpSession[dwRecvSend]) {
                // we haven't started notifications for receiver/sender
                ASSERT(pRtpQOSNotify->m_lStarted == 1);
                ASSERT(pRtpQOSNotify->m_pvCRtpSession[1 - dwRecvSend]);
            } else {
#if defined(_DEBUG)
                // check for consistency
                if (pRtpQOSNotify->m_pvCRtpSession[dwRecvSend] !=
                    pvCRtpSession) {

                    RRCMDbgLog((
                            LOG_ERROR,
                            LOG_DEVELOP,
                            "RTCPStopQOSNotify[0x%X]: "
                            "Inconsistency detected",
                            pRtpQOSNotify
                        ));
    
                    ASSERT(pRtpQOSNotify->m_pvCRtpSession[dwRecvSend] !=
                           pvCRtpSession);
                }
#endif
                // stop notifications either for the receiver or the sender
                pRtpQOSNotify->m_dwQOSEventMask[dwRecvSend] = 0;
                pRtpQOSNotify->m_pvCRtpSession[dwRecvSend] = NULL;
            
                pRtpQOSNotify->m_lStarted--;

                if (!pRtpQOSNotify->m_lStarted) {

                    // no one else active,
                    // move to stop list
                    
                    movePcktFromQueue(
                            &RtcpQOSStopBfrList,
                            &RtcpQOSStartBfrList,
                            &pRtpQOSNotify->RTPQOSBufferLink,
                            NULL);

                    if (pRTCPContext && pRTCPContext->hRtcpQOSControlEvent) {
                        // signal thread about the recent stop
                        // so it can move item to free list
                        SetEvent(pRTCPContext->hRtcpQOSControlEvent);
                        // log if SetEvent fails
                    } else {
                        // log, unexpected condition
                    }
                }

                // set NOERROR regardless of SetEvent result
                dwError = NOERROR;
            }
        } else {
            // log, item not found
            RRCMDbgLog((
                    LOG_TRACE,
                    LOG_DEVELOP,
                    "RTCPStopQOSNotify[0x0]: Item NOT found"
                ));
        }

        LeaveCriticalSection(&RtcpQOSCritSect);

    } else {
        // log if doing nothing, unexpected condition

        RRCMDbgLog((
                LOG_TRACE,
                LOG_DEVELOP,
                "RTCPStopQOSNotify: "
                "Unexpected hHeapRtcpQOSBfrList is NULL\n"
            ));
    }

    return(dwError);
}
    
RRCMSTDAPI
RTCPSetQOSEventMask(SOCKET sock,
                    void  *pvCRtpSession,
                    DWORD  dwRecvSend,     // 0 == receiver; other == sender
                    DWORD  dwQOSEventMask) // new mask
{
    HRESULT dwError = E_FAIL;
    RTP_QOSNOTIFY *pRtpQOSNotify;
    
    if (hHeapRtcpQOSBfrList) {

        if (dwRecvSend)
            dwRecvSend = 1;
        else
            dwRecvSend = 0;
        
        EnterCriticalSection(&RtcpQOSCritSect);

        DWORD fCreate = 0; // just look up, do not create if not found

        // find out if notifications have already been started
        pRtpQOSNotify = LookupRtpQOSNotify(sock, &fCreate);

        if (pRtpQOSNotify) {

            // remember who last stoped
            pRtpQOSNotify->m_dwThreadID2[dwRecvSend] =
                GetCurrentThreadId();
            
            // check for consistency
            if ( (pRtpQOSNotify->m_pvCRtpSession[dwRecvSend] ==
                  pvCRtpSession) ) {

                // update event mask
                pRtpQOSNotify->m_dwQOSEventMask[dwRecvSend] = dwQOSEventMask;
                
                dwError = NOERROR;
            } else {
                // log, inconsistency found
                ASSERT(pRtpQOSNotify->m_pvCRtpSession[dwRecvSend] ==
                       pvCRtpSession);
            }
        } else {
            // log, unexpected condition
        }

        LeaveCriticalSection(&RtcpQOSCritSect);
    } else {        
        // log if doing nothing, unexpected condition
    }

    return(dwError);
}


// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rrcm\rtcp\rtcpssrc.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTCPSSRC.C
 * Product:     RTP/RTCP implementation
 * Description: Provides SSRC related function.
 *
 * $Workfile:   RTCPSSRC.CPP  $
 * $Author:   CMACIOCC  $
 * $Date:   13 Feb 1997 14:47:50  $
 * $Revision:   1.5  $
 * $Archive:   R:\rtp\src\rrcm\rtcp\rtcpssrc.cpv  $
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/


#include "rrcm.h"
#include "md5.h"



/*---------------------------------------------------------------------------
/                           Global Variables
/--------------------------------------------------------------------------*/            


/*---------------------------------------------------------------------------
/                           External Variables
/--------------------------------------------------------------------------*/                                       
extern PRTCP_CONTEXT    pRTCPContext;

#ifdef ENABLE_ISDM2
extern KEY_HANDLE       hRRCMRootKey;
extern ISDM2            Isdm2;
#endif

#ifdef _DEBUG
extern char     debug_string[];
#endif
    


/*----------------------------------------------------------------------------
 * Function   : getOneSSRCentry
 * Description: Get an SSRC entry from the free list of entries.
 * 
 * Input :      pList       : -> to the list to get the entry from
 *              hHeap       : Handle to the heap where the data resides
 *              *pNum       : -> to the number of initial free entry in the list
 *              *pCritSect  : -> to the critical section
 *
 * Return:      OK:     -> to SSRC entry
 *              Error:  NULL
 ---------------------------------------------------------------------------*/
PSSRC_ENTRY getOneSSRCentry (PLINK_LIST pList, 
                             HANDLE hHeap, 
                             DWORD *pNum,
                             CRITICAL_SECTION *pCritSect)
    {     
    PSSRC_ENTRY pSSRC = NULL;

    IN_OUT_STR ("RTCP: Enter getOneSSRCentry()\n");

    // get an entry from the free list
    pSSRC = (PSSRC_ENTRY)removePcktFromHead (pList, pCritSect);
    if (pSSRC == NULL)
        {
        // try to reallocate some free cells
        if (allocateLinkedList (pList, hHeap, pNum, 
                                sizeof(SSRC_ENTRY),
                                pCritSect) == RRCM_NoError)
            {                               
            // get a free cell if some have been reallocated
            pSSRC = (PSSRC_ENTRY)removePcktFromHead (pList, pCritSect);
            }
        }

    if (pSSRC)
        {
        clearSSRCEntry (pSSRC);

        // initialize the critical section
        InitializeCriticalSection(&pSSRC->critSect);
        }

    IN_OUT_STR ("RTCP: Exit getOneSSRCentry()\n");
        
    return (pSSRC);
    }                                                                                                                                                                   
    
                                                                                  
/*----------------------------------------------------------------------------
 * Function   : getSSRC
 * Description: Get a unique 32 bits SSRC
 * 
 * Input :      RcvSSRCList: Session's receive SSRC list address
 *              XmtSSRCList: Session's transmit SSRC list address
 *
 * Return:      Unique 32 bits SSRC
 ---------------------------------------------------------------------------*/
DWORD getSSRC (LINK_LIST RcvSSRCList, 
               LINK_LIST XmtSSRCList)
    {               
    DWORD       SSRCnum = 0;
    DWORD       dwStatus;
    PSSRC_ENTRY pSSRC;
    MD5_CTX     context;
    DWORD       i;
    union {
        unsigned char   c[16];
        DWORD           x[4];
        }digest;

    struct {
        DWORD       pid;
        DWORD       time;
        FILETIME    createTime;
        FILETIME    exitTime;
        FILETIME    kernelTime;
        FILETIME    userTime;
        } md5Input;

    IN_OUT_STR ("RTCP: Enter getSSRC()\n");

    // go through all SSRCs of this RTP/RTCP session
    while (SSRCnum == 0)
        {
        // get MD5 inputs
        md5Input.pid  = GetCurrentThreadId();
        md5Input.time = timeGetTime();

        dwStatus = GetProcessTimes (GetCurrentProcess(),
                                    &md5Input.createTime, 
                                    &md5Input.exitTime, 
                                    &md5Input.kernelTime, 
                                    &md5Input.userTime);
        if (dwStatus == FALSE)
            {
            RRCM_DBG_MSG ("RTCP: GetProcessTimes() failed", GetLastError(),
                          __FILE__, __LINE__, DBG_NOTIFY);
            }

        // Implementation suggested by draft 08, Appendix 6
        MD5Init (&context);
        MD5Update (&context, (unsigned char *)&md5Input, sizeof (md5Input));
        MD5Final ((unsigned char *)&digest, &context);
        SSRCnum = 0;
        for (i=0; i < 3; i++)
            SSRCnum ^= digest.x[i];

        // look through all transmitter for this session
        pSSRC = (PSSRC_ENTRY)XmtSSRCList.prev;
        if (isSSRCunique (pSSRC, &SSRCnum) == TRUE)
            {
            // look through all received SSRC for this session
            pSSRC = (PSSRC_ENTRY)RcvSSRCList.prev;
            isSSRCunique (pSSRC, &SSRCnum);
            }
        }

    IN_OUT_STR ("RTCP: Exit getSSRC()\n");

    return (SSRCnum);
    }


 /*----------------------------------------------------------------------------
 * Function   : getAnSSRC
 * Description: Build an SSRC according to the RFC, but does not check for 
 *              collision. Mainly used by H.323 to get a 32 bits number.
 * 
 * Input :      None
 *
 * Return:      32 bits SSRC
 ---------------------------------------------------------------------------*/
RRCMSTDAPI getAnSSRC (void)
    {               
    DWORD       SSRCnum = 0;
    DWORD       dwStatus;
    MD5_CTX     context;
    DWORD       i;
    union {
        unsigned char   c[16];
        DWORD           x[4];
        }digest;

    struct {
        DWORD       pid;
        DWORD       time;
        FILETIME    createTime;
        FILETIME    exitTime;
        FILETIME    kernelTime;
        FILETIME    userTime;
        } md5Input;

    IN_OUT_STR ("RTCP: Enter getAnSSRC()\n");

    // get MD5 inputs
    md5Input.pid  = GetCurrentThreadId();
    md5Input.time = timeGetTime();

    dwStatus = GetProcessTimes (GetCurrentProcess(),
                                &md5Input.createTime, 
                                &md5Input.exitTime, 
                                &md5Input.kernelTime, 
                                &md5Input.userTime);
    if (dwStatus == FALSE)
        {
        RRCM_DBG_MSG ("RTCP: GetProcessTimes() failed", GetLastError(),
                      __FILE__, __LINE__, DBG_NOTIFY);
        }

    // Implementation suggested by draft 08, Appendix 6
    MD5Init (&context);
    MD5Update (&context, (unsigned char *)&md5Input, sizeof (md5Input));
    MD5Final ((unsigned char *)&digest, &context);
    SSRCnum = 0;
    for (i=0; i < 3; i++)
        SSRCnum ^= digest.x[i];

    IN_OUT_STR ("RTCP: Exit getAnSSRC()\n");

    return (SSRCnum);
    }


/*----------------------------------------------------------------------------
 * Function   : isSSRCunique
 * Description: Check to see the SSRC already exist
 * 
 * Input :      pSSRC       :   -> to an SSRC list
 *              *SSRCnum    :   -> to the SSRC to check
 *
 * Return:      0: SSRC already exist
 *              1: SSRC is unique
 ---------------------------------------------------------------------------*/
DWORD isSSRCunique (PSSRC_ENTRY pSSRC, 
                    DWORD *SSRCnum)
    {
    IN_OUT_STR ("RTCP: Enter isSSRCunique()\n");

    // make sure SSRC is unique for this session 
    while (pSSRC)
        {
        if (pSSRC->SSRC == *SSRCnum)
            {
            // SSRC already in use, get a new one 
            *SSRCnum = 0;
            return FALSE;
            }
                             
        // get next RTCP session 
        pSSRC = (PSSRC_ENTRY)pSSRC->SSRCList.next;
        }

    IN_OUT_STR ("RTCP: Exit isSSRCunique()\n");

    return TRUE;
    }                                                                                     
                                                                              
                                                                              
/*----------------------------------------------------------------------------
 * Function   : createSSRCEntry
 * Description: Create an SSRC entry, for a particular RTP/RTCP session
 * 
 * Input :      SSRCnum     : SSRC number
 *              pRTCP       : -> to the RTCP session
 *              fromAddr    : From address
 *              fromLen     : From length
 *              headOfList  : Put the new entry at the head of the list
 *
 * Return:      Address of the SSRC entry data structure.
 ---------------------------------------------------------------------------*/
PSSRC_ENTRY createSSRCEntry (DWORD SSRCnum, 
                             PRTCP_SESSION pRTCP,
                             PSOCKADDR fromAddr, 
                             DWORD fromLen,
                             int   rtp_rtcp,
                             DWORD headOfList)
    {               
    PSSRC_ENTRY     pSSRCentry;
    PSSRC_ENTRY     pSSRCtmp;
    PLINK_LIST      pTmp;
    DWORD           i;
    DWORD           dwCurTime;
    BOOL            entryAdded = FALSE;

    IN_OUT_STR ("RTCP: Enter createSSRCEntry()\n");

    dwCurTime = timeGetTime();
    
    // Check first if this is not an old SSRC
    EnterCriticalSection(&pRTCP->SSRCListCritSect);
    for(i = 0; i < NUM_COLLISION_ENTRIES; i++) {
        
        if (pRTCP->byessrc[i].SSRC == SSRCnum) {
            
            if ((dwCurTime - pRTCP->byessrc[i].dwDeleteTime) <
                OLD_SSRC_TIME) {
                // do not create a new SSRC for an already deleted
                // SSRC
                LeaveCriticalSection(&pRTCP->SSRCListCritSect);
                RRCMDbgLog((
                        LOG_TRACE,
                        LOG_DEVELOP,
                        "createSSRCEntry: SSRC:0x%X is in BYE list, "
                        "don't create new one",
                        SSRCnum
                    ));
                return((SSRC_ENTRY *)NULL);
            } else {
                // Clear this entry and allow same SSRC to be created
                pRTCP->byessrc[i].SSRC = 0;
            }
            break;
        }
    }
    LeaveCriticalSection(&pRTCP->SSRCListCritSect);

    // get an SSRC cell from the free list 
    pSSRCentry = getOneSSRCentry (&pRTCPContext->RRCMFreeStat, 
                                  pRTCPContext->hHeapRRCMStat,
                                  &pRTCPContext->dwInitNumFreeRRCMStat,
                                  &pRTCPContext->HeapCritSect);
    if (pSSRCentry == NULL)
        return NULL;

    // save the remote source address
    if (saveNetworkAddress(pSSRCentry,
                           fromAddr,
                           fromLen,
                           rtp_rtcp) != RRCM_NoError)
        {

        DeleteCriticalSection(&pSSRCentry->critSect);
            
        addToHeadOfList (&pRTCPContext->RRCMFreeStat, 
                         (PLINK_LIST)pSSRCentry,
                         &pRTCPContext->HeapCritSect);
        return (NULL);
        }

    pSSRCentry->SSRC = SSRCnum;
    pSSRCentry->rcvInfo.dwProbation = MIN_SEQUENTIAL;

    // set this SSRC entry's RTCP session
    pSSRCentry->pRTCPses  = pRTCP;
    pSSRCentry->pRTPses   = (RTP_SESSION *)pRTCP->pvRTPSession;

    // initialize 'dwLastReportRcvdTime' to now
    pSSRCentry->dwLastReportRcvdTime = timeGetTime();

#ifdef _DEBUG
    wsprintf (debug_string, 
      "RTCP: Create SSRC entry (Addr:x%lX, SSRC=x%lX) for session: (Addr:x%lX)",
      pSSRCentry, pSSRCentry->SSRC, pRTCP);
    RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

#ifdef ENABLE_ISDM2
    // register to ISDM
    if (Isdm2.hISDMdll && (pRTCP->dwSessionStatus & RTCP_DEST_LEARNED))
        registerSessionToISDM (pSSRCentry, pRTCP, &Isdm2);
#endif

    // check to see if it's our entry that needs to be put at the head of 
    //  the SSRC list. If it's not our entry, will find a place for it in the
    //  ordered list
    if (headOfList)
        {
        // Attach the SSRC to the RTCP session list entry head 
        addToHeadOfList (&pRTCP->XmtSSRCList, 
                         (PLINK_LIST)pSSRCentry,
                         &pRTCP->SSRCListCritSect);

        // number of SSRC entry for the RTCP session 
        InterlockedIncrement ((long *)&pRTCP->dwCurNumSSRCperSes);

#ifdef MONITOR_STATS
        // high number of SSRC entry for the RTCP session
        InterlockedIncrement ((long *)&pRTCP->dwHiNumSSRCperSes)
#endif

        return (pSSRCentry);
        }

    // put it on the receive list of SSRCs

    // We walk/change the SSRC list, lock access to it
    EnterCriticalSection(&pRTCP->SSRCListCritSect);
    
    pTmp = (PLINK_LIST)pRTCP->RcvSSRCList.prev;

    // check if it's the first one
    if (pTmp == NULL)
        {
        // Attach the SSRC to the RTCP session list entry head 
        addToHeadOfList (&pRTCP->RcvSSRCList, 
                         (PLINK_LIST)pSSRCentry,
                         NULL);

        // number of SSRC entry for the RTCP session 
        InterlockedIncrement ((long *)&pRTCP->dwCurNumSSRCperSes);

#ifdef MONITOR_STATS
        // high number of SSRC entry for the RTCP session 
        InterlockedIncrement ((long *)&pRTCP->dwHiNumSSRCperSes)
#endif

        LeaveCriticalSection(&pRTCP->SSRCListCritSect);
        return (pSSRCentry);
        }

    while (!entryAdded)
        {
        if (pTmp != NULL)
            {
            pSSRCtmp = (PSSRC_ENTRY)pTmp;
            if (pSSRCtmp->SSRC < SSRCnum)
                pTmp = pTmp->next;
            else
                {
                if ((pTmp->next == NULL) && (pSSRCtmp->SSRC < SSRCnum))
                    {
                    // attach the SSRC to the RTCP session list entry head 
                    // This SSRC is bigger than all other ones
                    addToHeadOfList (&pRTCP->RcvSSRCList, 
                                     (PLINK_LIST)pSSRCentry,
                                     NULL);
                    }
                else if (pTmp->prev == NULL)
                    {
                    // attach the SSRC to the RTCP session list entry tail 
                    // This SSRC is smaller than all other ones
                    addToTailOfList (&pRTCP->RcvSSRCList, 
                                     (PLINK_LIST)pSSRCentry,
                                     NULL);
                    }
                else
                    {               
                    // this SSRC is in between other SSRCs
                    
                    (pTmp->prev)->next = (PLINK_LIST)pSSRCentry;

                    // don't need to lock out pSSRCentry pointers
                    pSSRCentry->SSRCList.next = pTmp;
                    pSSRCentry->SSRCList.prev = pTmp->prev;

                    pTmp->prev = (PLINK_LIST)pSSRCentry;

                    }

                // set loop flag 
                entryAdded = TRUE;
                }
            }
        else
            {
            // attach the SSRC to the RTCP session list entry head 
            addToHeadOfList (&pRTCP->RcvSSRCList, 
                             (PLINK_LIST)pSSRCentry,
                             NULL);

            // set loop flag 
            entryAdded = TRUE;
            }
        }

    LeaveCriticalSection(&pRTCP->SSRCListCritSect);

    // number of SSRC entry for the RTCP session 
    InterlockedIncrement ((long *)&pRTCP->dwCurNumSSRCperSes);

#ifdef MONITOR_STATS
    // high number of SSRC entry for the RTCP session 
    InterlockedIncrement ((long *)&pRTCP->dwHiNumSSRCperSes)
#endif

    IN_OUT_STR ("RTCP: Exit createSSRCEntry()\n");

    return (pSSRCentry);
    }
                                                                                                                                                            
                                                                              
                                                                              
/*----------------------------------------------------------------------------
 * Function   : deleteSSRCEntry
 * Description: Delete an SSRC entry (for a particular RTP/RTCP session).
 * 
 * Input :      SSRCnum     : SSRC number to delete from the list
 *              pRTCP       : -> to the RTCP session
 *
 * Return:      TRUE:   Deleted
 *              FALSE:  Entry not found
 ---------------------------------------------------------------------------*/
DWORD deleteSSRCEntry (DWORD SSRCnum, 
                       PRTCP_SESSION pRTCP)
    {               
    PSSRC_ENTRY pSSRCtmp = NULL;
    PLINK_LIST  pTmp;
    DWORD       i;
    DWORD       dwOldest;
    DWORD       dwStatus = FALSE;

    IN_OUT_STR ("RTCP: Enter deleteSSRCEntry()\n");

    // walk through the list from the tail
    EnterCriticalSection(&pRTCP->SSRCListCritSect);

    pTmp = (PLINK_LIST)pRTCP->RcvSSRCList.prev;

    while (pTmp)
        {
        // lock access to this entry 
        EnterCriticalSection (&((PSSRC_ENTRY)pTmp)->critSect);

        if (((PSSRC_ENTRY)pTmp)->SSRC == SSRCnum)
            {
#ifdef _DEBUG
            wsprintf (debug_string, 
                      "RTCP: Delete SSRC=x%lX from session: (Addr:x%lX)",
                      SSRCnum, pRTCP);
            RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

#ifdef ENABLE_ISDM2
            // unregister ISDM session
            if (Isdm2.hISDMdll && ((PSSRC_ENTRY)pTmp)->hISDM)
                Isdm2.ISDMEntry.ISD_DeleteValue(hRRCMRootKey, 
                                                ((PSSRC_ENTRY)pTmp)->hISDM, NULL);
#endif

            // remove the entry from the list 
            if (pTmp->next == NULL)
                {
                removePcktFromHead (&pRTCP->RcvSSRCList,
                                    NULL);
                }
            else if (pTmp->prev == NULL)
                {
                removePcktFromTail (&pRTCP->RcvSSRCList,
                                    NULL);
                }
            else
                {
                // in between, relink around 
                EnterCriticalSection (&((PSSRC_ENTRY)pTmp->prev)->critSect);
                (pTmp->prev)->next = pTmp->next;
                LeaveCriticalSection (&((PSSRC_ENTRY)pTmp->prev)->critSect);

                EnterCriticalSection (&((PSSRC_ENTRY)pTmp->next)->critSect);
                (pTmp->next)->prev = pTmp->prev;
                LeaveCriticalSection (&((PSSRC_ENTRY)pTmp->next)->critSect);
                }

            // number of SSRC entry for the RTCP session 
            InterlockedDecrement ((long *)&pRTCP->dwCurNumSSRCperSes);

            // unlock access to this entry 
            LeaveCriticalSection (&((PSSRC_ENTRY)pTmp)->critSect);

            DeleteCriticalSection(&((PSSRC_ENTRY)pTmp)->critSect);
            
            // return entry to the free list 
            addToHeadOfList (&pRTCPContext->RRCMFreeStat, 
                             pTmp,
                             &pRTCPContext->HeapCritSect);

            dwStatus = TRUE;
            break;
            }

        // unlock access to this entry 
        LeaveCriticalSection (&((PSSRC_ENTRY)pTmp)->critSect);

        pTmp = pTmp->next;
        }

    // Now Add this SSRC to the BYE list
    for(i = 0, dwOldest = 0; i < NUM_COLLISION_ENTRIES; i++) {
        if (!pRTCP->byessrc[i].SSRC) {
            break;
        } else if (pRTCP->byessrc[i].dwDeleteTime <
                   pRTCP->byessrc[dwOldest].dwDeleteTime) {
            dwOldest = i;
        }
    }

    if (i >= NUM_COLLISION_ENTRIES) {
        // there is no free entry, override the oldest
        i = dwOldest;
    }
    
    // update entry
    pRTCP->byessrc[i].SSRC = SSRCnum;
    pRTCP->byessrc[i].dwDeleteTime = timeGetTime();
    
    LeaveCriticalSection(&pRTCP->SSRCListCritSect);

    RRCMDbgLog((
            LOG_TRACE,
            LOG_DEVELOP,
            "deleteSSRCEntry: SSRC:0x%X added to BYE list",
            SSRCnum
        ));

    IN_OUT_STR ("RTCP: Exit deleteSSRCEntry()\n");  

    return (dwStatus);
    }

 
/*----------------------------------------------------------------------------
 * Function   : deleteSSRClist
 * Description: Delete the SSRC list of an RTP/RTCP session.
 * 
 * Input :      pRTCP     : -> to RTCP session
 *              pFreeList : -> to the free list of SSRCs
 *              pOwner    : -> to the free list owner
 *
 * Return:      None
 ---------------------------------------------------------------------------*/
void deleteSSRClist (PRTCP_SESSION pRTCP, 
                     PLINK_LIST pFreeList, 
                     PRTCP_CONTEXT pRTCPContext)
    {               
    PLINK_LIST  pSSRC;

    IN_OUT_STR ("RTCP: Enter deleteSSRClist()\n");

    ASSERT (pFreeList);
    ASSERT (pRTCP);

    // lock access to the full SSRC list
    EnterCriticalSection (&pRTCP->SSRCListCritSect);

    // go through the list of transmit SSRCs for this RTCP session 
    while (pRTCP->XmtSSRCList.next != NULL)
        {
        // get packet from the list tail 
        pSSRC = removePcktFromTail ((PLINK_LIST)&pRTCP->XmtSSRCList,
                                    NULL);
        if (pSSRC != NULL)
            {
#ifdef _DEBUG
            wsprintf(debug_string, 
                     "RTCP: Delete SSRC entry (x%lX) from session (x%lX)",
                     ((PSSRC_ENTRY)pSSRC)->SSRC, pRTCP);
            RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif                  

#ifdef ENABLE_ISDM2
            // unregister ISDM session
            if (Isdm2.hISDMdll && ((PSSRC_ENTRY)pSSRC)->hISDM)
                Isdm2.ISDMEntry.ISD_DeleteValue (hRRCMRootKey, 
                                        ((PSSRC_ENTRY)pSSRC)->hISDM, NULL);
#endif

            // Set the parent session pointer to an invalid value
            // so we know this SSRC entry was freed
            ((PSSRC_ENTRY)pSSRC)->pRTCPses = (PRTCP_SESSION)0x0000feee;
            
            // release the critical section
            DeleteCriticalSection (&((PSSRC_ENTRY)pSSRC)->critSect);

            // put it back to the free list 
            addToHeadOfList (pFreeList, pSSRC, &pRTCPContext->HeapCritSect);
            }
        }

    // go through the list of SSRCs for this RTP/RTCP session 
    while (pRTCP->RcvSSRCList.next != NULL)
        {
        // get packet from the list tail 
        pSSRC = removePcktFromTail ((PLINK_LIST)&pRTCP->RcvSSRCList,
                                    NULL);
        if (pSSRC != NULL)
            {
#ifdef _DEBUG
            wsprintf(debug_string, 
                     "RTCP: Delete SSRC entry (x%lX) from session (x%lX)",
                     ((PSSRC_ENTRY)pSSRC)->SSRC, pRTCP);
            RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif                  

#ifdef ENABLE_ISDM2
            // unregister ISDM session
            if (Isdm2.hISDMdll && ((PSSRC_ENTRY)pSSRC)->hISDM)
                Isdm2.ISDMEntry.ISD_DeleteValue (hRRCMRootKey, 
                                ((PSSRC_ENTRY)pSSRC)->hISDM, NULL);
#endif

            // release the critical section
            DeleteCriticalSection (&((PSSRC_ENTRY)pSSRC)->critSect);

            // put it back to the free list 
            addToHeadOfList (pFreeList, pSSRC, &pRTCPContext->HeapCritSect);
            }
        }

    // unlock access to the full SSRC list
    LeaveCriticalSection (&pRTCP->SSRCListCritSect);

    IN_OUT_STR ("RTCP: Exit deleteSSRClist()\n");               
    }


/*----------------------------------------------------------------------------
 * Function   : SSRCTimeoutCheck
 * Description: Check if an rcv SSRC needs to be timed out
 *              Since there may be multiple RCV SSRCs, repeat calling
 *              this function until it returns NULL
 * 
 * Input :      pRTCC   : -> to the RTCP session
 *              curTime : Current time
 *
 * Return:      NULL  : No action needed
 *              PSSRC : -> to the SSRC entry that should be deleted
 ---------------------------------------------------------------------------*/
#if 0
PSSRC_ENTRY SSRCTimeoutCheck(PRTCP_SESSION pRTCP, DWORD curTime) 
    {
    PSSRC_ENTRY pSSRC;

    // check the colliding entries table and clear it if needed
    RRCMTimeOutCollisionTable (pRTCP);

    // get the right session to close
    EnterCriticalSection(&pRTCP->SSRCListCritSect);
    pSSRC = (PSSRC_ENTRY)pRTCP->RcvSSRCList.prev;
    while (pSSRC)
        {
        // check if this SSRC timed-out
        if (((curTime - pSSRC->dwLastReportRcvd)) > RTCP_TIME_OUT)
            {
                break;
            }

        pSSRC = (PSSRC_ENTRY)pSSRC->SSRCList.next;
        }
    LeaveCriticalSection(&pRTCP->SSRCListCritSect);
    return pSSRC;
    }
#endif

/*---------------------------------------------------------------------------
 * Function   : RRCMChkCollisionTable
 * Description: Check the collision table to try to find a match 
 * 
 * Input :  pRCVStruct  :   -> to receive data structure
 *          pSSRC       :   -> to the SSRC entry
 *
 * Return:  TRUE:   Match found
 *          FALSE:  No match found
 --------------------------------------------------------------------------*/
DWORD RRCMChkCollisionTable (PRTP_BFR_LIST  pRCVStruct,
                             PSSRC_ENTRY pSSRC)
    {
    DWORD           idx;
    DWORD           dwStatus = FALSE;
    PRTCP_SESSION   pRTCP = pSSRC->pRTCPses;

    IN_OUT_STR ("RRCM: Enter RRCMChkCollisionTable()\n");           

    // entry w/ time == 0 are empty
    for (idx = 0; idx < NUM_COLLISION_ENTRIES; idx++)
        {
        if (pRTCP->collInfo[idx].dwCollideTime != 0)
            {
            if (memcmp (&pRTCP->collInfo[idx].collideAddr,
                        pRCVStruct->pFrom, 
                        *pRCVStruct->pFromlen) == 0)
                {
                // update the time of last collision received
                pRTCP->collInfo[idx].dwCollideTime = timeGetTime();

                dwStatus = TRUE;
                break;
                }
            }
        }

    IN_OUT_STR ("RRCM: Exit RRCMChkCollisionTable()\n");            

    return dwStatus;
    }


/*---------------------------------------------------------------------------
 * Function   : RRCMAddEntryToCollisionTable
 * Description: Add an entry into the collision table.
 * 
 * Input :  pRCVStruct  :   -> to receive data structure
 *          pSSRC       :   -> to the SSRC entry
 *
 * Return:  TRUE:   Entry added
 *          FALSE:  Table full
 --------------------------------------------------------------------------*/
DWORD RRCMAddEntryToCollisionTable (PRTP_BFR_LIST pRCVStruct, 
                                    PSSRC_ENTRY pSSRC)
    {
    DWORD           idx;
    DWORD           dwStatus = FALSE;
    PRTCP_SESSION   pRTCP = pSSRC->pRTCPses;

    IN_OUT_STR ("RRCM: Enter RRCMAddEntryToCollisionTable()\n");
    
    // entry w/ time == 0 are empty
    for (idx = 0; idx < NUM_COLLISION_ENTRIES; idx++)
        {
        if (pRTCP->collInfo[idx].dwCollideTime == 0)
            {
            CopyMemory(&pRTCP->collInfo[idx].collideAddr,
                       pRCVStruct->pFrom, 
                       *pRCVStruct->pFromlen);

            pRTCP->collInfo[idx].addrLen = *pRCVStruct->pFromlen;
            pRTCP->collInfo[idx].dwCollideTime = timeGetTime();
            pRTCP->collInfo[idx].dwCurRecvRTCPrptNumber = pSSRC->dwNumRptRcvd;

            pRTCP->collInfo[idx].SSRC = pSSRC->SSRC;

            dwStatus = TRUE;
            break;
            }
        }

    
    IN_OUT_STR ("RRCM: Exit RRCMAddEntryToCollisionTable()\n");      

    return dwStatus;
    }



/*---------------------------------------------------------------------------
 * Function   : RRCMTimeOutInCollisionTable
 * Description: Check if an entry in the collision table must be timed-out
 * 
 * Input :  pRTCP   :   -> to the RTCP session
 *
 * Return:  None
 --------------------------------------------------------------------------*/
 void RRCMTimeOutCollisionTable (PRTCP_SESSION pRTCP)
    {
    DWORD   idx;
    DWORD   i;
    DWORD   currTime = timeGetTime();
    DWORD   diffTime;

    IN_OUT_STR ("RTCP: Enter RRCMTimeOutCollisionTable()\n");
    
    // entry w/ time == 0 are empty
    for (idx = 0; idx < NUM_COLLISION_ENTRIES; idx++)
        {
        // valid entries have the time set
        if (pRTCP->collInfo[idx].dwCollideTime)
            {
            // remove the entry from this table if 10 RTCP report intervals
            // have occured without a collision

            // clear the entry if over 5'
// !!! TODO !!!
// !!! using the right interval !!!
            diffTime = currTime - pRTCP->collInfo[idx].dwCollideTime;
            diffTime /= 1000;
            if (diffTime > 300)
                {
                pRTCP->collInfo[idx].dwCollideTime = 0;

                // the SSRC entry in the receive list will be deleted by
                // the timeout thread
                }
            }
        }

    EnterCriticalSection(&pRTCP->SSRCListCritSect);
    // clear old SSRCs used to prevent admission of packets from
    // participants that left
    for(i = 0; i < NUM_COLLISION_ENTRIES; i++) {
        if (pRTCP->byessrc[i].SSRC &&
            (currTime - pRTCP->byessrc[i].dwDeleteTime) >= OLD_SSRC_TIME) {

            RRCMDbgLog((
                    LOG_TRACE,
                    LOG_DEVELOP,
                    "RRCMTimeOutCollisionTable: SSRC:0x%X removed "
                    "from BYE list",
                    pRTCP->byessrc[i].SSRC
                ));

            // clear entry
            pRTCP->byessrc[i].SSRC = 0;
        }
    }
    LeaveCriticalSection(&pRTCP->SSRCListCritSect);

    IN_OUT_STR ("RTCP: Exit RRCMTimeOutCollisionTable()\n");         
    }


/*----------------------------------------------------------------------------
 * Function   : clearSSRCEntry
 * Description: Clears what needs to be cleared in an SSRC entry
 * 
 * Input :      pSSRC       : -> to the SSRC entry
 *
 * Return:      None
 ---------------------------------------------------------------------------*/
 void clearSSRCEntry (PSSRC_ENTRY pSSRC)
    {
    IN_OUT_STR ("RTCP: Enter clearSSRCEntry()\n");              

    ZeroMemory (&pSSRC->xmtInfo, sizeof(XMIT_INFO));
    ZeroMemory (&pSSRC->rcvInfo, sizeof(RECV_INFO));
    ZeroMemory (&pSSRC->rrFeedback, sizeof (RTCP_FEEDBACK));
    ZeroMemory (&pSSRC->sdesItem[0],      // CNAME tru PRIV
            sizeof(SDES_DATA) * (RTCP_SDES_LAST - RTCP_SDES_FIRST - 1) );
    ZeroMemory (&pSSRC->fromRTP,  sizeof(SOCKADDR));
    ZeroMemory (&pSSRC->fromRTCP, sizeof(SOCKADDR));

    pSSRC->SSRC                 = 0;            
    pSSRC->dwSSRCStatus         = 0;
    pSSRC->dwStreamClock        = 0;
    pSSRC->fromRTPLen           = 0;
    pSSRC->fromRTCPLen          = 0;
    pSSRC->dwLastReportRcvdTime = 0;
    pSSRC->dwUserXmtTimeoutCtrl = 0;
    pSSRC->pRTPses              = NULL;
    pSSRC->pRTCPses             = NULL;
    pSSRC->dwNumRptSent         = 0;
    pSSRC->dwNumRptRcvd         = 0;
    pSSRC->dwTimeStampOffset    = 0xffffffff;

#ifdef ENABLE_ISDM2
    pSSRC->hISDM                = 0;
#endif

#ifdef _DEBUG
    pSSRC->dwPrvTime            = 0;    
#endif

    IN_OUT_STR ("RTCP: Exit clearSSRCEntry()\n");               
    }

                                                                              
// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rrcm\rtp\rrcmcrt.cpp ===
/*----------------------------------------------------------------------------
 * File:        RRCMCRT.C
 * Product:     RTP/RTCP implementation.
 * Description: Provides Microsoft 'C' run-time support
 *
 * $Workfile:   RRCMCRT.CPP  $
 * $Author:   CMACIOCC  $
 * $Date:   13 Feb 1997 14:45:58  $
 * $Revision:   1.1  $
 * $Archive:   R:\rtp\src\rrcm\rtp\rrcmcrt.cpv  $
 * 
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/


#include "rrcm.h"

 
/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/
#ifdef _DEBUG
extern char		debug_string[];
#endif


/*--------------------------------------------------------------------------
 * Function   : RRCMsrand
 * Description: Seeds the random number generator with the int given.  
 *				Adapted from the BASIC random number generator.
 *
 * WARNING:		There is no per thread seed. All threads of the process are
 *				using the same seed.
 *
 * Input :	seed:	Seed
 *			
 *
 * Return: None
 --------------------------------------------------------------------------*/

static long holdrand = 1L;

void RRCMsrand (unsigned int seed)
	{
	holdrand = (long)seed;
	}
 

/*--------------------------------------------------------------------------
 * Function   : RRCMrand
 * Description: Returns a pseudo-random number 0 through 32767.
 *
 * WARNING:		There is no per thread number. All threads of the process 
 *				share the random number
 *
 * Input :	None
 *			
 * Return:	Pseudo-random number 0 through 32767.
 --------------------------------------------------------------------------*/
int RRCMrand (void)
	{
	return(((holdrand = holdrand * 214013L + 2531011L) >> 16) & 0x7fff);
	}



/***
*char *_itoa, *_ltoa, *_ultoa(val, buf, radix) - convert binary int to ASCII
*       string
*
*Purpose:
*       Converts an int to a character string.
*
*Entry:
*       val - number to be converted (int, long or unsigned long)
*       int radix - base to convert into
*       char *buf - ptr to buffer to place result
*
*Exit:
*       fills in space pointed to by buf with string result
*       returns a pointer to this buffer
*
*Exceptions:
*
*******************************************************************************/

/* helper routine that does the main job. */

static void RRCMxtoa (unsigned long val,
					  char *buf,
					  unsigned radix,
					  int is_neg)
	{
	char		*p;                /* pointer to traverse string */
	char		*firstdig;         /* pointer to first digit */
	char		temp;              /* temp char */
	unsigned	digval;        /* value of digit */

	p = buf;

	if (is_neg) {
		/* negative, so output '-' and negate */
		*p++ = '-';
		val = (unsigned long)(-(long)val);
	}

	firstdig = p;           /* save pointer to first digit */

	do {
		digval = (unsigned) (val % radix);
		val /= radix;   /* get next digit */

		/* convert to ascii and store */
		if (digval > 9)
			*p++ = (char) (digval - 10 + 'a');      /* a letter */
		else
			*p++ = (char) (digval + '0');           /* a digit */
		} while (val > 0);

	/* We now have the digit of the number in the buffer, but in reverse
	   order. Thus we reverse them now. */

	*p-- = '\0';            /* terminate string; p points to last digit */

	do {
		temp = *p;
		*p = *firstdig;
		*firstdig = temp;       /* swap *p and *firstdig */
		--p;
		++firstdig;             /* advance to next two digits */
		} while (firstdig < p); /* repeat until halfway */
	}


/* Actual functions just call conversion helper with neg flag set correctly,
   and return pointer to buffer. */

char *RRCMitoa (int val, char *buf, int radix)
	{
	if (radix == 10 && val < 0)
		RRCMxtoa((unsigned long)val, buf, radix, 1);
	else
		RRCMxtoa((unsigned long)(unsigned int)val, buf, radix, 0);
	return buf;
	}


char *RRCMltoa (long val, char *buf, int radix)
	{
	RRCMxtoa((unsigned long)val, buf, radix, (radix == 10 && val < 0));
	return buf;
	}


char *RRCMultoa (unsigned long val, char *buf, int radix)
	{
	RRCMxtoa(val, buf, radix, 0);
	return buf;
	}



// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rrcm\rtp\rrcmmain.cpp ===
//---------------------------------------------------------------------------
//  File:  RRCMMAIN.C
//
//  This file contains the DLL's entry and exit points.
//
// $Workfile:   RRCMMAIN.CPP  $
// $Author:   CMACIOCC  $
// $Date:   13 Feb 1997 14:46:04  $
// $Revision:   1.1  $
// $Archive:   R:\rtp\src\rrcm\rtp\rrcmmain.cpv  $
//
// INTEL Corporation Proprietary Information
// This listing is supplied under the terms of a license agreement with 
// Intel Corporation and may not be copied nor disclosed except in 
// accordance with the terms of that agreement.
// Copyright (c) 1995 Intel Corporation. 
//---------------------------------------------------------------------------
#if !defined(RRCMLIB)
#define STRICT
#include "windows.h"

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
#include "interop.h"
#include "rtpplog.h"
#endif

#ifdef ISRDBG
#include "isrg.h"
WORD    ghISRInst = 0;
#endif

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
LPInteropLogger            RTPLogger = NULL;
#endif


#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)

extern DWORD deleteRTP (HINSTANCE);
extern DWORD initRTP (HINSTANCE);

#if defined(__cplusplus)
}
#endif  // (__cplusplus)



//---------------------------------------------------------------------------
// Function: dllmain
//
// Description: DLL entry/exit points.
//
//	Inputs:
//    			hInstDll	: DLL instance.
//    			fdwReason	: Reason the main function is called.
//    			lpReserved	: Reserved.
//
//	Return: 	TRUE		: OK
//				FALSE		: Error, DLL won't load
//---------------------------------------------------------------------------
BOOL WINAPI DllMain (HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpvReserved)
{
BOOL	status = TRUE;

switch (fdwReason)
	{
	case DLL_PROCESS_ATTACH:
		// The DLL is being loaded for the first time by a given process.
		// Perform per-process initialization here.  If the initialization
		// is successful, return TRUE; if unsuccessful, return FALSE.

#ifdef ISRDBG
		ISRREGISTERMODULE(&ghISRInst, "RRCM", "RTP/RTCP");
#endif

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
		RTPLogger = InteropLoad(RTPLOG_PROTOCOL);
#endif

		// initialize RTP/RTCP
		status = (initRTP (hInstDll) == FALSE) ? TRUE:FALSE;
		break;

	case DLL_PROCESS_DETACH:
		// The DLL is being unloaded by a given process.  Do any
		// per-process clean up here.The return value is ignored.
		// delete RTP resource
		deleteRTP (hInstDll);

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
		if (RTPLogger)
			InteropUnload(RTPLogger);
#endif
		break;

    case DLL_THREAD_ATTACH:
		// A thread is being created in a process that has already loaded
		// this DLL.  Perform any per-thread initialization here.
		break;

    case DLL_THREAD_DETACH:
		// A thread is exiting cleanly in a process that has already
		// loaded this DLL.  Perform any per-thread clean up here.
		break;
	}

return (status);  
}
#endif // !defined(RRCMLIB)

// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rrcm\rtcp\rtcpsess.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTCPSESS.C
 * Product:     RTP/RTCP implementation
 * Description: Provides RTCP session management.
 *
 * $Workfile:   rtcpsess.cpp  $
 * $Author:   CMACIOCC  $
 * $Date:   16 May 1997 09:26:34  $
 * $Revision:   1.16  $
 * $Archive:   R:\rtp\src\rrcm\rtcp\rtcpsess.cpv  $
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/

    
#include "rrcm.h"                                    


/*---------------------------------------------------------------------------
/                           Global Variables
/--------------------------------------------------------------------------*/            




/*---------------------------------------------------------------------------
/                           External Variables
/--------------------------------------------------------------------------*/
extern PRTCP_CONTEXT    pRTCPContext;
extern PRTP_CONTEXT     pRTPContext;
extern RRCM_WS          RRCMws;

#ifdef _DEBUG
long   RTCPCount = 0;
#endif
long   RTCPThreadUsers = 0;

DWORD g_dwRTCPTimeToWaitIo = 500;

// This variables are used to maintain the
// QOS notifications buffers
HEAD_TAIL   RtcpQOSFreeBfrList;         // free buffers head/tail ptrs
HEAD_TAIL   RtcpQOSStartBfrList;        // start buffers head/tail ptrs
HEAD_TAIL   RtcpQOSStopBfrList;         // stop buffers head/tail ptrs  
HANDLE      hHeapRtcpQOSBfrList = NULL; // Heap handle to QOS bfrs list 
CRITICAL_SECTION RtcpQOSCritSect;       // critical section 


#ifdef ENABLE_ISDM2
extern ISDM2            Isdm2;
#endif

#ifdef _DEBUG
extern char debug_string[];
#endif

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
extern LPInteropLogger     RTPLogger;
#endif

extern long g_lNumRtcpQOSNotify;

long g_lRTCP_ID = 0;


/*----------------------------------------------------------------------------
 * Function   : CreateRTCPSession
 * Description: Creates an RTCP session.
 * 
 * Input :      pSocket         : RTP recv, send, and RTCP socket descriptors
 *              lpTo            : To address
 *              toLen           : To address length
 *              pSdesInfo       : -> to SDES information
 *              dwStreamClock   : Stream clocking frequency
 *              pEncryptInfo    : -> to encryption information
 *              ssrc            : If set, user selected SSRC
 *              pSSRCcallback   : Callback for user's selected SSRC
 *              dwCallbackInfo  : User callback information
 *              miscInfo        : Miscelleanous information:
 *                                      H.323Conf:      0x00000002
 *                                      Encrypt SR/RR:  0x00000004
 *                                      RTCPon:         0x00000008
 *              dwRtpSessionBw  : RTP session bandwidth used for RTCP BW
 *              *pRTCPStatus    : -> to status information
 *
 * Return:      NULL        : Couldn't create RTCP session
 *              !0          : RTCP session's address
 ---------------------------------------------------------------------------*/
HRESULT CreateRTCPSession (void *pvRTPSession,
                           SOCKET *pSocket, 
                           LPVOID lpTo, 
                           DWORD toLen,
                           PSDES_DATA pSdesInfo,
                           DWORD dwStreamClock,
                           PENCRYPT_INFO pEncryptInfo,
                           DWORD ssrc, 
                           PRRCM_EVENT_CALLBACK pRRCMcallback,
                           void *pvCallbackInfo,
                           DWORD miscInfo, 
                           DWORD dwRtpSessionBw)
{     
    PRTCP_SESSION       &pRTCPses  = (((RTP_SESSION *)pvRTPSession)->
                                      pRTCPSession);
    PSSRC_ENTRY         pSSRCentry = NULL;
    DWORD               dwStatus;
    char                hName[256];
    int                 tmpSize;
    struct sockaddr_in  *pSockAddr;

    pRTCPses = NULL;

    IN_OUT_STR ("RTCP: Enter CreateRTCPSession()\n");

    if (toLen > sizeof(SOCKADDR))
        return(MAKE_RRCM_ERROR(RRCMError_RTCPInvalidArg));

    // allocate all required resources for the RTCP session 
    dwStatus = allocateRTCPsessionResources (&pRTCPses, 
                                             &pSSRCentry); 
    if (dwStatus != RRCM_NoError)
        {
        RRCM_DBG_MSG ("RTCP: ERROR - Resource allocation failed", 0, 
                      __FILE__, __LINE__, DBG_CRITICAL);

        IN_OUT_STR ("RTCP: Exit CreateRTCPSession()\n");

        return (MAKE_RRCM_ERROR(dwStatus));
        }

    // save the parent RTCP session address in the SSRC entry 
    pSSRCentry->pRTCPses = pRTCPses;
    pSSRCentry->pRTPses = (RTP_SESSION *)pvRTPSession;

    // network destination address 
    if (toLen)
        {
        pRTCPses->dwSessionStatus = RTCP_DEST_LEARNED;
        pRTCPses->toAddrLen = toLen;
        CopyMemory(&pRTCPses->toAddr, lpTo, toLen);
        }
    
    // mark the session as new for the benefit of the RTCP thread
    pRTCPses->dwSessionStatus |= NEW_RTCP_SESSION;

#ifdef ENABLE_ISDM2
    // initialize the session key in case ISDM is used
    pRTCPses->hSessKey = NULL;
#endif

    // number of SSRC for this RTCP session 
    pRTCPses->dwCurNumSSRCperSes = 1;
#ifdef MONITOR_STATS
    pRTCPses->dwHiNumSSRCperSes  = 1;
#endif

    // get our own transport address - 
    // will be used for collision resolution when using multicast
    tmpSize = sizeof (SOCKADDR);
    dwStatus = RRCMws.getsockname (pSocket[SOCK_RTCP],
                                   &pSSRCentry->fromRTCP,
                                   &tmpSize);

    // only process when no error is reported. If the socket is not bound
    // it won't cause any problem for unicast or multicast if the sender
    // has not join the mcast group. If the sender joins the mcast group
    // it's socket should be bound by now as specified in the EPS
    if (dwStatus == 0)
        {
        // if bound to INADDR_ANY, address will be 0
        pSockAddr = (PSOCKADDR_IN)&pSSRCentry->fromRTCP;
        if (pSockAddr->sin_addr.s_addr == 0)
            {
            // get the host name (to get the local IP address)
            if ( ! RRCMws.gethostname (hName, sizeof(hName))) 
                {
                LPHOSTENT   lpHEnt;

                // get the host by name infor
                if ((lpHEnt = RRCMws.gethostbyname (hName)) != NULL) 
                    {
                    // get the local IP address
                    pSockAddr->sin_addr.s_addr = 
                        *((u_long *)lpHEnt->h_addr_list[0]);
                    }
                }
            }
        }

    // build session's SDES information
    buildSDESinfo (pSSRCentry, pSdesInfo);

    // link the SSRC to the RTCP session list of Xmt SSRCs entries 
    addToHeadOfList (&(pRTCPses->XmtSSRCList), 
                     (PLINK_LIST)pSSRCentry,
                     &pRTCPses->SSRCListCritSect);

    // initialize the number of stream for this session
    pRTCPses->dwNumStreamPerSes = 1;

    // get a unique SSRC for this session 
    if (ssrc)
        pSSRCentry->SSRC = ssrc;
    else {
        // We are going to walk those lists, lock access to them
        EnterCriticalSection(&pRTCPses->SSRCListCritSect);
        pSSRCentry->SSRC = getSSRC (pRTCPses->XmtSSRCList, 
                                    pRTCPses->RcvSSRCList);
        LeaveCriticalSection(&pRTCPses->SSRCListCritSect);
    }

    // RRCM callback notification
    pRTCPses->pRRCMcallback      = pRRCMcallback;
    pRTCPses->dwSdesMask         = -1; // All SDES enabled
    pRTCPses->lRTCP_ID           = InterlockedIncrement(&g_lRTCP_ID) - 1;

    // set operation flag
    if (miscInfo & H323_CONFERENCE)
        pRTCPses->dwSessionStatus |= H323_CONFERENCE;
    if (miscInfo & ENCRYPT_SR_RR)
        pRTCPses->dwSessionStatus |= ENCRYPT_SR_RR;

    // estimate the initial session bandwidth 
    if (dwRtpSessionBw == 0)
        {
        pSSRCentry->xmtInfo.dwRtcpStreamMinBW  = INITIAL_RTCP_BANDWIDTH;
        }
    else
        {
        // RTCP bandwidth is 5% of the RTP bandwidth
        pSSRCentry->xmtInfo.dwRtcpStreamMinBW  = (dwRtpSessionBw * 5) / 100;
        }

    // the stream clocking frequency
    pSSRCentry->dwStreamClock = dwStreamClock;

    // initialize 'dwLastReportRcvdTime' to now
    pSSRCentry->dwLastReportRcvdTime = timeGetTime();

#ifdef _DEBUG
    wsprintf(debug_string, 
        "RTCP: Add new RTCP session: Addr:x%lX", pRTCPses);
    RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);

    wsprintf(debug_string, 
        "RTCP: Add SSRC entry (Addr:x%lX, SSRC=x%lX) to session (Addr:x%lX)", 
        pSSRCentry, pSSRCentry->SSRC, pRTCPses);
    RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);

    pSSRCentry->dwPrvTime = timeGetTime();
#endif

    // turn on RTCP or not 
    if (miscInfo & RTCP_ON)
        {
        // this session sends and receives RTCP reports
        pRTCPses->dwSessionStatus |= RTCP_ON;
        }

    // link the RTCP session to the head of the list of RTCP sessions 
    addToHeadOfList (&(pRTCPContext->RTCPSession), 
                     (PLINK_LIST)pRTCPses,
                     &pRTCPContext->critSect);

#ifdef ENABLE_ISDM2
    // register to ISDM only if destination address is known
    if (Isdm2.hISDMdll && (pRTCPses->dwSessionStatus & RTCP_DEST_LEARNED))
        registerSessionToISDM (pSSRCentry, pRTCPses, &Isdm2);
#endif

#if defined(_DEBUG)
    {
        char str[80];
        wsprintf(str, "RTCP[0x%X] : CreateRTCPSession(%d) %s",
                pRTCPses, InterlockedIncrement(&RTCPCount),
                pRTCPContext->hRtcpThread? "" : "START RTCP");
        RRCM_DEV_MSG (str, 0, __FILE__, __LINE__, DBG_NOTIFY);
    }
#endif

    // create the RTCP thread if needed
    EnterCriticalSection(&pRTCPContext->CreateThreadCritSect);
    RTCPThreadUsers++;
    if (!pRTCPContext->hRtcpThread) {

        // No RTCP thread if this fail
        dwStatus = CreateRTCPthread ();
        if (dwStatus != RRCM_NoError)
            {

            RTCPThreadUsers--;
                
            RRCM_DBG_MSG ("RTCP: ERROR - Cannot create RTCP thread", 0, 
                          __FILE__, __LINE__, DBG_CRITICAL);

            IN_OUT_STR ("RTCP: Exit CreateRTCPSession()\n");

            LeaveCriticalSection(&pRTCPContext->CreateThreadCritSect);
            return (MAKE_RRCM_ERROR(dwStatus));
            }
    }
    LeaveCriticalSection(&pRTCPContext->CreateThreadCritSect);

    IN_OUT_STR ("RTCP: Exit CreateRTCPSession()\n");

    return (RRCM_NoError);
    }


/*----------------------------------------------------------------------------
 * Function   : allocateRTCPsessionResources
 * Description: Allocate all required resources for an RTCP session.
 * 
 * Input :      *pRTCPses:      ->(->) to the RTCP session's information
 *              *pSSRCentry:    ->(->) to the SSRC's entry
 *
 * Return:      OK: RRCM_NoError
 *              !0: Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
DWORD allocateRTCPsessionResources (RTCP_SESSION **ppRTCPses, 
                                    PSSRC_ENTRY *pSSRCentry)
    {
    DWORD dwStatus = RRCM_NoError;

    IN_OUT_STR ("RTCP: Enter allocateRTCPsessionResources()\n");

    // get an RTCP session 
    *ppRTCPses = (PRTCP_SESSION)HeapAlloc (pRTCPContext->hHeapRTCPSes, 
                                          HEAP_ZERO_MEMORY,
                                          sizeof(RTCP_SESSION));
    if (*ppRTCPses == NULL)
        dwStatus = RRCMError_RTCPResources;

    // 'defined' RTCP resources 
    if (dwStatus == RRCM_NoError)
        {                   
        (*ppRTCPses)->dwInitNumFreeRcvBfr= NUM_FREE_RCV_BFR;
        (*ppRTCPses)->dwRcvBfrSize       = pRTPContext->registry.RTCPrcvBfrSize;
        (*ppRTCPses)->dwInitNumFreeXmtBfr= NUM_FREE_XMT_BFR;
        (*ppRTCPses)->dwXmtBfrSize       = RRCM_XMT_BFR_SIZE;

        // allocate the RTCP session's Rcv/Xmt heaps and Rcv/Xmt buffers 
        dwStatus = allocateRTCPSessionHeaps (ppRTCPses);
        }

    DWORD critSectionsInitialized = 0;
    
    if (dwStatus == RRCM_NoError)
        {                   
        // initialize this session's critical section 
        InitializeCriticalSection (&(*ppRTCPses)->critSect);
        InitializeCriticalSection (&(*ppRTCPses)->SSRCListCritSect);
        InitializeCriticalSection (&(*ppRTCPses)->BfrCritSect);
        critSectionsInitialized = 1;
        
        // allocate free list of RTCP receive buffers 
        dwStatus = allocateRTCPBfrList (&(*ppRTCPses)->RTCPrcvBfrList,
                                        (*ppRTCPses)->hHeapRcvBfrList,
                                        (*ppRTCPses)->hHeapRcvBfr,
                                        &(*ppRTCPses)->dwInitNumFreeRcvBfr,
                                        (*ppRTCPses)->dwRcvBfrSize,
                                        &(*ppRTCPses)->BfrCritSect);
        }

    if (dwStatus == RRCM_NoError)
        {            
        // allocate free list of RTCP Xmit buffers 
        dwStatus = allocateRTCPBfrList (&(*ppRTCPses)->RTCPxmtBfrList,
                                        (*ppRTCPses)->hHeapXmtBfrList,
                                        (*ppRTCPses)->hHeapXmtBfr,
                                        &(*ppRTCPses)->dwInitNumFreeXmtBfr,
                                        (*ppRTCPses)->dwXmtBfrSize,
                                        &(*ppRTCPses)->BfrCritSect);
        }

    if (dwStatus == RRCM_NoError)
        {
        // get an SSRC entry 
        *pSSRCentry = getOneSSRCentry (&pRTCPContext->RRCMFreeStat, 
                                       pRTCPContext->hHeapRRCMStat,
                                       &pRTCPContext->dwInitNumFreeRRCMStat,
                                       &pRTCPContext->HeapCritSect);
        if (*pSSRCentry == NULL)
            dwStatus = RRCMError_RTCPResources;
        }

	if (dwStatus == RRCM_NoError)
		{
        // event that will be used to signal the completion of the
        // last overlapped RTCP reception 
        char event_name[32];
            
        sprintf(event_name,"RTCP[0x%p] Shutdown", *ppRTCPses);
        
        (*ppRTCPses)->hLastPendingRecv =
            CreateEvent(NULL, FALSE, FALSE, event_name);

        if ((*ppRTCPses)->hLastPendingRecv == NULL)
            {
            dwStatus = RRCMError_RTCPResources;

            RRCM_DEV_MSG ("RTCP: ERROR - CreateEvent()", GetLastError(), 
                          __FILE__, __LINE__, DBG_ERROR);
            }
        }
    

    // any resource allocation problem ? 
    if (dwStatus != RRCM_NoError) {
        
        if (*pSSRCentry) {

            DeleteCriticalSection(&(*pSSRCentry)->critSect);
            
            addToHeadOfList (&pRTCPContext->RRCMFreeStat, 
                             (PLINK_LIST)*pSSRCentry,
                             &pRTCPContext->HeapCritSect);

            if ((*pSSRCentry)->hXmtThread)
            {
                if (TerminateThread ((*pSSRCentry)->hXmtThread, 
                                     (*pSSRCentry)->dwXmtThreadID) == FALSE)
                {
                    RRCM_DBG_MSG ("RTCP: ERROR - TerminateThread()", 
                                  GetLastError(),
                                  __FILE__, __LINE__, DBG_ERROR);
                }
            }
        }

        if (*ppRTCPses) {

            // destroy allocated heaps
            if ((*ppRTCPses)->hHeapRcvBfr)
            {
                HeapDestroy ((*ppRTCPses)->hHeapRcvBfr);
                (*ppRTCPses)->hHeapRcvBfr = NULL;
            }
            if ((*ppRTCPses)->hHeapRcvBfrList)
            {
                HeapDestroy ((*ppRTCPses)->hHeapRcvBfrList);
                (*ppRTCPses)->hHeapRcvBfrList = NULL;
            }
            if ((*ppRTCPses)->hHeapXmtBfr)
            {
                HeapDestroy ((*ppRTCPses)->hHeapXmtBfr);
                (*ppRTCPses)->hHeapXmtBfr = NULL;
            }
            if ((*ppRTCPses)->hHeapXmtBfrList)
            {
                HeapDestroy ((*ppRTCPses)->hHeapXmtBfrList);
                (*ppRTCPses)->hHeapXmtBfrList = NULL;
            }

            if (critSectionsInitialized) {
                DeleteCriticalSection (&(*ppRTCPses)->critSect);
                DeleteCriticalSection (&(*ppRTCPses)->SSRCListCritSect);
                DeleteCriticalSection (&(*ppRTCPses)->BfrCritSect);
            }
            
            if (HeapFree (pRTCPContext->hHeapRTCPSes, 0, *ppRTCPses) == FALSE)
            {
                RRCM_DBG_MSG ("RTCP: ERROR - HeapFree()", GetLastError(), 
                              __FILE__, __LINE__, DBG_ERROR);
            }

            *ppRTCPses = NULL;
        }
    }

    IN_OUT_STR ("RTCP: Exit allocateRTCPsessionResources()\n");

    return dwStatus;
    }


/*----------------------------------------------------------------------------
 * Function   : buildSDESinfo
 * Description: Build the session's SDES information
 * 
 * Input :      pRTCPses:   -> to session's 
 *              pSdesInfo:  -> to SDES information
 *
 * Return:      OK: RRCM_NoError
 *              !0: Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
DWORD buildSDESinfo (PSSRC_ENTRY pSSRCentry, 
                      PSDES_DATA pSdesInfo)
{   
    PSDES_DATA  pTmpSdes;
    DWORD       CnameOK = FALSE;

    IN_OUT_STR ("RTCP: Enter buildSDESinfo()\n");

    pTmpSdes = pSdesInfo;

    int idx;
    
    while (pTmpSdes->dwSdesType) {

        if (pTmpSdes->dwSdesType > RTCP_SDES_FIRST &&
            pTmpSdes->dwSdesType < RTCP_SDES_LAST &&
            pTmpSdes->dwSdesLength > 1) {

            idx = SDES_INDEX(pTmpSdes->dwSdesType);

            pSSRCentry->sdesItem[idx].dwSdesType = pTmpSdes->dwSdesType;
            pSSRCentry->sdesItem[idx].dwSdesLength = pTmpSdes->dwSdesLength;
            CopyMemory(pSSRCentry->sdesItem[idx].sdesBfr,
                       pTmpSdes->sdesBfr, 
                       pTmpSdes->dwSdesLength);

            pSSRCentry->sdesItem[idx].dwSdesFrequency = 
                pTmpSdes->dwSdesFrequency;
            pSSRCentry->sdesItem[idx].dwSdesEncrypted =
                pTmpSdes->dwSdesEncrypted;

            if (pTmpSdes->dwSdesType == RTCP_SDES_CNAME)
                CnameOK = TRUE;
        }
        pTmpSdes++;
    }

    // default CNAME if none provided
    if (CnameOK == FALSE) {
        idx = SDES_INDEX(RTCP_SDES_CNAME);
        
        pSSRCentry->sdesItem[idx].dwSdesLength = sizeof(szDfltCname);
        CopyMemory(pSSRCentry->sdesItem[idx].sdesBfr, szDfltCname, 
                   sizeof(szDfltCname));

        pSSRCentry->sdesItem[idx].dwSdesFrequency = 1;
        pSSRCentry->sdesItem[idx].dwSdesEncrypted = 0;
    }

    IN_OUT_STR ("RTCP: Exit buildSDESinfo()\n");
    return (RRCM_NoError);
}


RRCMSTDAPI
updateSDESinfo(void *pvRTCPSession,
               DWORD  dwSDESItem,
               LPBYTE psSDESData,
               DWORD  dwSDESLen)
{
    if (!pvRTCPSession || !psSDESData)
        return(MAKE_RRCM_ERROR(RRCMError_InvalidPointer));

    if (dwSDESLen > MAX_SDES_LEN-1)
        return(MAKE_RRCM_ERROR(RRCMError_RTCPInvalidArg));
        
    int idx = SDES_INDEX(dwSDESItem);
        
    if (idx < SDES_INDEX(RTCP_SDES_FIRST + 1) ||
        idx > SDES_INDEX(RTCP_SDES_LAST -1 ))
        return(MAKE_RRCM_ERROR(RRCMError_RTCPInvalidArg));

    // Actually update SDES item
    LINK_LIST *pLink;
    SSRC_ENTRY *pSSRCEntry;
    EnterCriticalSection(&(((PRTCP_SESSION)pvRTCPSession)->SSRCListCritSect));
    for(pLink = ((PRTCP_SESSION)pvRTCPSession)->XmtSSRCList.prev;
        pLink;
        pLink = pLink->next) {
        
        pSSRCEntry = (SSRC_ENTRY *)pLink;
        InterlockedExchange((long *)
                            &(pSSRCEntry->sdesItem[idx].dwSdesLength), 0);
        CopyMemory(pSSRCEntry->sdesItem[idx].sdesBfr, psSDESData, dwSDESLen);
        pSSRCEntry->sdesItem[idx].dwSdesLength = dwSDESLen;
    }
    LeaveCriticalSection(&(((PRTCP_SESSION)pvRTCPSession)->SSRCListCritSect));

    return(RRCM_NoError);
}
/*----------------------------------------------------------------------------
 * Function   : frequencyToPckt
 * Description: Transform the required frequency to a number of packet. (To
 *              be used by a modulo function)
 * 
 * Input :      freq:   Desired frequency from 0 to 100
 *
 * Return:      X: Packet to skip, ie, one out of X
 ---------------------------------------------------------------------------*/
#if defined(_0_)
DWORD frequencyToPckt (DWORD freq)
    {   
    if (freq <= 10)
        return 9;
    else if (freq <= 20)
        return 5;
    else if (freq <= 25)
        return 4;
    else if (freq <= 33)
        return 3;
    else if (freq <= 50)
        return 2;
    else 
        return 1;
    }
#endif

DWORD ShutdownRTCPSession(PRTCP_SESSION pRTCPSession)
{
    PRTCP_BFR_LIST pBfrList;

#if defined(_DEBUG)
    char msg[128];
    int count = 0;
#endif  
    
    // Mark all receive/sender structures as invalid
    EnterCriticalSection(&pRTCPSession->BfrCritSect);

    for(pBfrList = (PRTCP_BFR_LIST)
            pRTCPSession->RTCPrcvBfrList.next;
        pBfrList;
        pBfrList = (PRTCP_BFR_LIST) pBfrList->bfrList.prev) {
        pBfrList->dwKind |= RTCP_KIND_BIT(RTCP_KIND_SHUTDOWN);
    }
    
    for(pBfrList = (PRTCP_BFR_LIST)
            pRTCPSession->RTCPrcvBfrListUsed.next;
        pBfrList;
        pBfrList = (PRTCP_BFR_LIST) pBfrList->bfrList.prev) {
#if defined(_DEBUG)
        count++;
#endif      
        pBfrList->dwKind |= RTCP_KIND_BIT(RTCP_KIND_SHUTDOWN);
    }
    
    LeaveCriticalSection(&pRTCPSession->BfrCritSect);

    RRCMDbgLog((
            LOG_TRACE,
            LOG_DEVELOP,
            "RTCP[0x%X] : ShutdownRTCPSession: count: %d",
            pRTCPSession, count
        ));

    return(RRCM_NoError);
}

/*----------------------------------------------------------------------------
 * Function   : deleteRTCPSession (with ZCS changes 7-31-97)
 * Description: Closes an RTCP session.
 * 
 * Input :      RTCPsd          : RTCP socket descriptor
 *              pRTCP           : pointer to the RTCP session (we knew it already)
 *              closeRTCPSocket : FALSE means don't close any sockets
 *                                TRUE means close the socket
 *                                (This parameter is here because I intended to
 *                                 prevent it from closing a socket that was
 *                                 still in use, but Mike says Winsock handles
 *                                 that.)
 *
 * Return:      OK: RRCM_NoError
 *              !0: Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
DWORD deleteRTCPSession (SOCKET RTCPsd, 
                         PRTCP_SESSION  pRTCP,
                         DWORD closeRTCPSocket)
    {     
    PLINK_LIST      pTmp;
    PLINK_LIST      pTmpFound;
    PSSRC_ENTRY     pSSRCTemp;
    PSSRC_ENTRY     pSSRC;
    DWORD           dwStatus = RRCM_NoError;
    DWORD           sessionFound = FALSE;

    IN_OUT_STR ("RTCP: Enter deleteRTCPSession()\n");

#ifdef _DEBUG
    wsprintf(debug_string, 
        "RTCP: Deleting RTCP session: (Addr:x%lX) ...", pRTCP);
    RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

    // We are about to modify a list from the RTCPContext
    // lock access to it
    EnterCriticalSection(&pRTCPContext->critSect);

    // walk through the list from the tail 
    pTmp = pRTCPContext->RTCPSession.prev;

    while (pTmp)
    {
        // get the right session to close by walking the transmit list
        // lock access to the SSRC list
        EnterCriticalSection(&pRTCP->SSRCListCritSect);
        pSSRCTemp = (PSSRC_ENTRY)((PRTCP_SESSION)pTmp)->XmtSSRCList.prev;
        if (pSSRCTemp->pRTCPses == pRTCP) // ZCS fix
        {
            // ZCS: moved the actual processing after the while loop
            // so that we can detect if there are multiple sessions on the
            // same socket. With statement inside the following "else if"
            // commented out, you can also put a "break" at the end of this
            // block if you want to save a small amount of work.
            sessionFound = TRUE;
            pSSRC = pSSRCTemp;
            pTmpFound = pTmp;

            pRTCP->dwSessionStatus |= SHUTDOWN_IN_PROGRESS;

            // remove the entry from the list of RTCP session 
            if (pTmpFound->next == NULL)
                removePcktFromHead (&pRTCPContext->RTCPSession,
                                    NULL);
            else if (pTmpFound->prev == NULL)
                removePcktFromTail (&pRTCPContext->RTCPSession,
                                    NULL);
            else
            {
                // in between, relink around 
                (pTmpFound->prev)->next = pTmpFound->next;
                (pTmpFound->next)->prev = pTmpFound->prev;
            }
        }
        else if (pSSRCTemp->pRTPses->pSocket[SOCK_RTCP] == RTCPsd)
        {
            // ZCS: This means more than one session has the same socket descriptor.
            // Therefore, we won't close the socket. (Correction: Mike says WinSock
            // handles it. Uncommenting this causes AVs.)
            // closeRTCPSocket = FALSE;
        }

        pTmp = pTmp->next;
        LeaveCriticalSection(&pRTCP->SSRCListCritSect);
    }   
    LeaveCriticalSection(&pRTCPContext->critSect);
    
    if (sessionFound == TRUE)
    {
        // lock out access to this RTCP session 
        EnterCriticalSection(&pRTCP->critSect);
        
        // ZCS
        if (closeRTCPSocket)        
            pSSRC->dwSSRCStatus |= CLOSE_RTCP_SOCKET; // reset the close socket flag


        // flush out any outstanding I/O
        RTCPflushIO (pSSRC);

        // if this is the only RTCP session left, terminate the RTCP 
        // timeout thread, so it doesn't access the session when it expires
#if defined(_DEBUG)

        char str[80];
        wsprintf(str, "RTCP[0x%X] : deleteRTCPSession(%d) %s",
                 pRTCP, InterlockedDecrement(&RTCPCount),
                 (pRTCPContext->RTCPSession.prev == NULL)?
                 "STOP RTCP" : "");
        RRCM_DEV_MSG (str, 0, __FILE__, __LINE__, DBG_NOTIFY);
#endif

        EnterCriticalSection(&pRTCPContext->CreateThreadCritSect);
        RTCPThreadUsers--;
        if (!RTCPThreadUsers)
            terminateRtcpThread ();
        LeaveCriticalSection(&pRTCPContext->CreateThreadCritSect);

        // free all Rcv & Xmt SSRC entries used by this session 
        deleteSSRClist (pRTCP, 
                        &pRTCPContext->RRCMFreeStat,
                        pRTCPContext);

#ifdef ENABLE_ISDM2
        if (Isdm2.hISDMdll && pRTCP->hSessKey)
            Isdm2.ISDMEntry.ISD_DeleteKey(pRTCP->hSessKey);
#endif

        // release the RTCP session's heap
        if (pRTCP->hHeapRcvBfrList) 
            {
            if (HeapDestroy (pRTCP->hHeapRcvBfrList) == FALSE)
                {
                RRCM_DBG_MSG ("RTCP: ERROR - HeapDestroy()", 
                              GetLastError(), __FILE__, __LINE__, 
                              DBG_ERROR);
                }
            }

        if (pRTCP->hHeapXmtBfrList) 
            {
            if (HeapDestroy (pRTCP->hHeapXmtBfrList) == FALSE)
                {
                RRCM_DBG_MSG ("RTCP: ERROR - HeapDestroy()", 
                              GetLastError(), __FILE__, __LINE__,
                              DBG_ERROR);
                }
            }
    
        if (pRTCP->hHeapRcvBfr) 
            {
            if (HeapDestroy (pRTCP->hHeapRcvBfr) == FALSE)
                {
                RRCM_DBG_MSG ("RTCP: ERROR - HeapDestroy()", 
                              GetLastError(), __FILE__, __LINE__,
                              DBG_ERROR);
                }
            }

        if (pRTCP->hHeapXmtBfr) 
            {
            if (HeapDestroy (pRTCP->hHeapXmtBfr) == FALSE)
                {
                RRCM_DBG_MSG ("RTCP: ERROR - HeapDestroy()", 
                              GetLastError(), __FILE__, __LINE__,
                              DBG_ERROR);
                }
            }

        if (pRTCP->hLastPendingRecv) {
            CloseHandle(pRTCP->hLastPendingRecv);
            pRTCP->hLastPendingRecv = NULL;
        }
        
        DeleteCriticalSection (&pRTCP->SSRCListCritSect);
        DeleteCriticalSection (&pRTCP->BfrCritSect);

        // release the critical section
        LeaveCriticalSection (&pRTCP->critSect);
        DeleteCriticalSection (&pRTCP->critSect);

        // put the RTCP session back on its heap
        if (HeapFree (pRTCPContext->hHeapRTCPSes, 
                      0, 
                      pRTCP) == FALSE)
            {
            RRCM_DBG_MSG ("RTCP: ERROR - HeapFree()", 
                          GetLastError(), __FILE__, __LINE__,
                          DBG_ERROR);
            }
        }
    else // sessionFound == FALSE
        dwStatus = RRCMError_RTCPInvalidSession;

    IN_OUT_STR ("RTCP: Exit deleteRTCPSession()\n");

    return (dwStatus);
    }

/*----------------------------------------------------------------------------
 * Function   : CreateRTCPthread 
 * Description: Create the RTCP thread / timeout thread depending on
 *              compilation flag.
 * 
 * Input :      None.
 *
 * Return:      None
 ---------------------------------------------------------------------------*/
DWORD CreateRTCPthread (void)
    {   
    DWORD dwStatus = RRCM_NoError;

    IN_OUT_STR ("RTCP: Enter CreateRTCPthread()\n");

    char event_name[128];

    wsprintf(event_name, "%d:TerminateRtcpEvent",GetCurrentProcessId());
    pRTCPContext->hTerminateRtcpEvent = CreateEvent (NULL, FALSE, FALSE,
                                                     event_name);
    if (pRTCPContext->hTerminateRtcpEvent == NULL)
        {
        dwStatus = RRCMError_RTCPResources;

        RRCM_DBG_MSG ("RTCP: ERROR - CreateEvent()", GetLastError(), 
                      __FILE__, __LINE__, DBG_ERROR);
        }


    if (dwStatus == RRCM_NoError) {
        wsprintf(event_name, "%d:RtcpRptRequestEvent", GetCurrentProcessId());
        pRTCPContext->hRtcpRptRequestEvent = CreateEvent (NULL, FALSE, FALSE,
                                                      event_name);
        if (pRTCPContext->hRtcpRptRequestEvent == NULL) {
            dwStatus = RRCMError_RTCPResources;

            RRCM_DBG_MSG ("RTCP: ERROR - CreateEvent()", GetLastError(), 
                          __FILE__, __LINE__, DBG_ERROR);
        }
    }
    
    if (dwStatus == RRCM_NoError) {
        wsprintf(event_name, "%d:RtcpQOSControlEvent", GetCurrentProcessId());
        pRTCPContext->hRtcpQOSControlEvent = CreateEvent (NULL, FALSE, FALSE,
                                                      event_name);
        if (pRTCPContext->hRtcpQOSControlEvent == NULL) {
            dwStatus = RRCMError_RTCPResources;

            RRCM_DBG_MSG ("RTCP: ERROR - CreateEvent()", GetLastError(), 
                          __FILE__, __LINE__, DBG_ERROR);
        }
    }
    
    // create QOS buffers heap and critical section
    if (dwStatus == RRCM_NoError) {
        if (!hHeapRtcpQOSBfrList) {
            hHeapRtcpQOSBfrList = HeapCreate(0, 
                                             QOS_BFR_LIST_HEAP_SIZE, 
                                             0);
            if (hHeapRtcpQOSBfrList)
                InitializeCriticalSection(&RtcpQOSCritSect);
        }
        if (hHeapRtcpQOSBfrList == NULL) {
            dwStatus = RRCMError_RTCPResources;

            RRCM_DBG_MSG ("RTCP: ERROR - HeapCreate()", GetLastError(), 
                          __FILE__, __LINE__, DBG_ERROR);
        }
    }

    // initialize list headers
    if (dwStatus == RRCM_NoError) {
        ZeroMemory(&RtcpQOSFreeBfrList, sizeof(HEAD_TAIL));
        ZeroMemory(&RtcpQOSStartBfrList, sizeof(HEAD_TAIL));
        ZeroMemory(&RtcpQOSStopBfrList, sizeof(HEAD_TAIL));

        // make sure the shutdown flag is not set
        pRTCPContext->dwStatus &= ~(1<<STAT_RTCP_SHUTDOWN);
        
        // create RTCP thread 
        pRTCPContext->hRtcpThread = CreateThread (
                NULL,
                0,
                (LPTHREAD_START_ROUTINE)RTCPThread,
                pRTCPContext,
                0,
                &pRTCPContext->dwRtcpThreadID);

        g_lNumRtcpQOSNotify = 0;

        if (pRTCPContext->hRtcpThread == NULL)  {
            dwStatus = RRCMError_RTCPThreadCreation;
            
            RRCM_DBG_MSG ("RTCP: ERROR - CreateThread()", GetLastError(), 
                          __FILE__, __LINE__, DBG_ERROR);
        }
#ifdef _DEBUG
        else
        {
            RRCMDbgLog((
                    LOG_ERROR,
                    LOG_DEVELOP,
                    "RTCP: Create RTCP thread. Handle: x%lX - ID: x%lX",
                    pRTCPContext->hRtcpThread, 
                    pRTCPContext->dwRtcpThreadID
                ));
        }
#endif
    }

    if (dwStatus != RRCM_NoError) {
        // clean up
        if (pRTCPContext->hTerminateRtcpEvent) {
            CloseHandle(pRTCPContext->hTerminateRtcpEvent);
            pRTCPContext->hTerminateRtcpEvent = NULL;
        }
        if (pRTCPContext->hRtcpRptRequestEvent) {
            CloseHandle(pRTCPContext->hRtcpRptRequestEvent);
            pRTCPContext->hRtcpRptRequestEvent = NULL;
        }
        if (pRTCPContext->hRtcpQOSControlEvent) {
            CloseHandle(pRTCPContext->hRtcpQOSControlEvent);
            pRTCPContext->hRtcpQOSControlEvent = NULL;
        }
        if (hHeapRtcpQOSBfrList) {
            HeapDestroy(hHeapRtcpQOSBfrList);
            hHeapRtcpQOSBfrList = NULL;
            DeleteCriticalSection(&RtcpQOSCritSect);
        }
    }
    
    IN_OUT_STR ("RTCP: Exit CreateRTCPthread()\n");

    return dwStatus;
    }


/*----------------------------------------------------------------------------
 * Function   : terminateRtcpThread
 * Description: Terminate the RTCP thread.
 * 
 * Input :      None.
 *
 * Return:      None
 ---------------------------------------------------------------------------*/
void terminateRtcpThread (void)
{   
    DWORD dwStatus;

    IN_OUT_STR ("RTCP: Enter terminateRtcpThread()\n");

    if (pRTCPContext->hRtcpThread) {

        // say the thread it is about to start shuting down
        pRTCPContext->dwStatus |= (1 << STAT_RTCP_SHUTDOWN);
        
        // signal the thread to terminate
        SetEvent (pRTCPContext->hTerminateRtcpEvent);

        // make sure the RTCP thread is running
        RTCPThreadCtrl (RTCP_ON);

        // wait for the RTCP thread to be signaled
        dwStatus = WaitForSingleObject(pRTCPContext->hRtcpThread, INFINITE);
        if (dwStatus == WAIT_OBJECT_0)
            ;
        else 
            {
            if (dwStatus == WAIT_TIMEOUT)
                {
                RRCM_DBG_MSG ("RTCP: Wait timed-out", GetLastError(), 
                              __FILE__, __LINE__, DBG_ERROR);
                }
            else
                {
                RRCM_DBG_MSG ("RTCP: Wait failed", GetLastError(), 
                              __FILE__, __LINE__, DBG_ERROR);
                }

            // Force ungraceful thread termination
            dwStatus = TerminateThread (pRTCPContext->hRtcpThread, 1);
            if (dwStatus == FALSE)
                {
                RRCM_DEV_MSG ("RTCP: ERROR - TerminateThread ()", 
                                GetLastError(), __FILE__, __LINE__,
                                DBG_ERROR);
                }
            }

        // close the thread handle
        dwStatus = CloseHandle (pRTCPContext->hRtcpThread);
        if (dwStatus == TRUE) { 
            pRTCPContext->hRtcpThread = 0;
            pRTCPContext->dwRtcpThreadID = -1;
            pRTCPContext->dwStatus &= ~(1<<(STAT_RTCPTHREAD+8));
        } else {
            pRTCPContext->dwRtcpThreadID = 0xfffffbad;
            pRTCPContext->dwStatus |= (1 << (STAT_RTCPTHREAD+8));
            RRCM_DBG_MSG ("RTCP: ERROR - CloseHandle()", GetLastError(), 
                          __FILE__, __LINE__, DBG_ERROR);
        }

        // close the event handle
        dwStatus = CloseHandle (pRTCPContext->hTerminateRtcpEvent);
        if (dwStatus == TRUE) {
            pRTCPContext->hTerminateRtcpEvent = 0;
            pRTCPContext->dwStatus &= ~(1<<(STAT_TERMRTCPEVENT+8));
        } else {
            pRTCPContext->dwStatus |= (1 << (STAT_TERMRTCPEVENT+8));
            RRCM_DBG_MSG ("RTCP: ERROR - CloseHandle()", GetLastError(), 
                          __FILE__, __LINE__, DBG_ERROR);
        }

        // close the request handle
        dwStatus = CloseHandle (pRTCPContext->hRtcpRptRequestEvent);
        if (dwStatus == TRUE) {
            pRTCPContext->hRtcpRptRequestEvent = 0;
            pRTCPContext->dwStatus &= ~(1<<(STAT_RTCPRQEVENT+8));
        } else {
            pRTCPContext->dwStatus |= (1 << (STAT_RTCPRQEVENT+8));
            RRCM_DBG_MSG ("RTCP: ERROR - CloseHandle()", GetLastError(), 
                          __FILE__, __LINE__, DBG_ERROR);
        }

        // close the QOS control handle
        dwStatus = CloseHandle (pRTCPContext->hRtcpQOSControlEvent);
        if (dwStatus == TRUE) {
            pRTCPContext->hRtcpQOSControlEvent = 0;
            pRTCPContext->dwStatus &= ~(1<<(STAT_RTCPQOSEVENT+8));
        } else {
            pRTCPContext->dwStatus |= (1 << (STAT_RTCPQOSEVENT+8));
            RRCM_DBG_MSG ("RTCP: ERROR - CloseHandle()", GetLastError(), 
                          __FILE__, __LINE__, DBG_ERROR);
        }

        // delete QOS buffers heap and critical section
        if (hHeapRtcpQOSBfrList) {
            dwStatus = HeapDestroy(hHeapRtcpQOSBfrList);
            hHeapRtcpQOSBfrList = NULL;
            DeleteCriticalSection(&RtcpQOSCritSect);
        }
    }
    
    IN_OUT_STR ("RTCP: Exit terminateRtcpThread()\n");
}


/*----------------------------------------------------------------------------
 * Function   : RTCPflushIO
 * Description: Flush the receive queue.
 * 
 * Input :      pSSRC:  -> to the SSRC entry
 *
 * Return:      None
 ---------------------------------------------------------------------------*/
DWORD RTCPflushIO (PSSRC_ENTRY pSSRC)
    {   
    DWORD   dwStatus = RRCM_NoError;
    int     IoToFlush;
    int     waitForXmtTrials;

    IN_OUT_STR ("RTCP: Enter RTCPflushIO()\n");

    IoToFlush = flushIO(pSSRC);
    
    // check if need to close the socket
    if (pSSRC->dwSSRCStatus & CLOSE_RTCP_SOCKET)
        {
            dwStatus = RRCMws.closesocket (pSSRC->pRTPses->pSocket[SOCK_RTCP]);
            if (dwStatus != 0)
            {
                RRCM_DBG_MSG ("RTCP: ERROR - closesocket ()", GetLastError(), 
                              __FILE__, __LINE__, DBG_ERROR);
            }
        }

    // make sure there is no buffers in transit on the transmit side
    //waitForXmtTrials = 3;

    // We can not just continue after a few trials, if the callback
    // is posted we will have AV (it has happened)
    while (pSSRC->dwNumXmtIoPending > 0) {

        RRCM_DBG_MSG ("RTCP: Xmt I/O Pending - Waiting", 
                        0, NULL, 0, DBG_TRACE);

        // wait in an alertable wait-state
        SleepEx (500, TRUE);
    }
    
    IN_OUT_STR ("RTCP: Exit RTCPflushIO()\n");

    return (dwStatus);
    }


/*----------------------------------------------------------------------------
 * Function   : flushIO
 * Description: Flush the receive queue.
 * 
 * Input :      pSSRC:  -> to the SSRC entry
 *
 * Return:      None
 ---------------------------------------------------------------------------*/
DWORD flushIO(PSSRC_ENTRY pSSRC)
{
    PRTCP_SESSION pRTCPSession = pSSRC->pRTCPses;

    DWORD dwStatus = 0;
    DWORD awaiting = 0;

    DWORD timeToWait = g_dwRTCPTimeToWaitIo;
    
    while(InterlockedCompareExchange(&pRTCPSession->lNumRcvIoPending,0,0) > 0
          && awaiting < 5*60*1000) {
        
        dwStatus = WaitForSingleObjectEx(pRTCPSession->hLastPendingRecv,
                                         timeToWait,
                                         TRUE);
        
        if (!dwStatus)
            awaiting += timeToWait;

        if (timeToWait < 10*1000)
            timeToWait += g_dwRTCPTimeToWaitIo;
        
#if defined(_DEBUG)
        char str[256];

        if (dwStatus == WAIT_OBJECT_0) {
            wsprintf(str, "RTCP[0x%X] : Flush Wait Event signaled",
                     pRTCPSession);
        } else if (dwStatus == WAIT_IO_COMPLETION) {
            wsprintf(str, "RTCP[0x%X] : Flush Wait IO_COMPLETION",
                     pRTCPSession);
        } else {
            wsprintf(str, "RTCP[0x%X] : Flush Wait timed-out",
                     pRTCPSession);
        }

        RRCM_DEV_MSG (str, 0, NULL, 0, DBG_TRACE);
#endif
    }
    
    return(dwStatus);
}

/*----------------------------------------------------------------------------
 * Function   : RTCPflushCallback
 * Description: Flush callback routine
 *
 * Input :  dwError:        I/O completion status
 *          cbTransferred:  Number of bytes received
 *          lpOverlapped:   -> to overlapped structure
 *          dwFlags:        Flags
 *
 *
 * Return: None
 ---------------------------------------------------------------------------*/
void CALLBACK RTCPflushCallback (DWORD dwError,
                                 DWORD cbTransferred,
                                 LPWSAOVERLAPPED lpOverlapped,
                                 DWORD dwFlags)
    {
    IN_OUT_STR ("RTCP: Enter RTCPflushCallback\n");

    // check Winsock callback error status
    if (dwError)
        {
        RRCM_DBG_MSG ("RTCP: ERROR - Rcv Callback", dwError, 
                      __FILE__, __LINE__, DBG_ERROR);

        IN_OUT_STR ("RTCP: Exit RTCPflushCallback\n");
        return;
        }

    IN_OUT_STR ("RTCP: Exit RTCPflushCallback\n");
    }




// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rrcm\rtp\rtpio.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTPIO.C
 * Product:     RTP/RTCP implementation
 * Description: Provides Session Creation/Deletion Functionality.
 *
 * $Workfile:   rtpio.cpp  $
 * $Author:   CMACIOCC  $
 * $Date:   14 Feb 1997 12:01:22  $
 * $Revision:   1.9  $
 * $Archive:   R:\rtp\src\rrcm\rtp\rtpio.cpv  $
 *
 * This listing is supplied under the terms 
 * of a license agreement with Intel Corporation and
 * many not be copied nor disclosed except in accordance
 * with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/

#include "rrcm.h"
        

/*---------------------------------------------------------------------------
/                           Global Variables
/--------------------------------------------------------------------------*/            


/*---------------------------------------------------------------------------
/                           External Variables
/--------------------------------------------------------------------------*/
extern PRTP_CONTEXT pRTPContext;

#ifdef _DEBUG
extern char   debug_string[];
DWORD g_dwRTPTimeToWaitIo = 1*1000;
#else
DWORD g_dwRTPTimeToWaitIo = 10*1000;
#endif

extern RRCM_WS          RRCMws;
DWORD RTPFlushRecv(RTP_SESSION *pRTPSession);

/*----------------------------------------------------------------------------
 * Function   : CreateRTPSession
 * Description: Creates an RTP (and RTCP) session for a new stream.
 * 
 * Input :      RTPSession      : 
 *              RTPsocket       : RTP socket descriptor
 *              RTCPsd          : RTCP socket descriptor
 *              pRTCPTo         : RTCP destination address
 *              toRTCPLen       : RTCP destination address length
 *              pSdesInfo       : -> to SDES information
 *              dwStreamClock   : Stream clocking frequency
 *              ssrc            : If set, user selected SSRC
 *              pRRCMcallback   : RRCM notification
 *              dwCallbackInfo  : User callback info
 *              miscInfo        : Miscelleanous information:
 *                                      H.323Conf:      0x00000002
 *                                      Encrypt SR/RR:  0x00000004
 *                                      RTCPon:         0x00000008
 *              dwRtpSessionBw  : RTP session bandwidth used for RTCP BW
 *              *pStatus        : -> to status information
 *
 * Return: RRCM_NoError     = OK.
 *         Otherwise(!=0)   = Initialization Error (see RRCM.H)
 ---------------------------------------------------------------------------*/
RRCMSTDAPI CreateRTPSession (void **ppvRTPSession,
                             SOCKET *pSocket,
                             LPVOID pRTCPTo, 
                             DWORD toRTCPLen,
                             PSDES_DATA pSdesInfo,
                             DWORD dwStreamClock,
                             PENCRYPT_INFO pEncryptInfo,
                             DWORD ssrc,
                             PRRCM_EVENT_CALLBACK pRRCMcallback,
                             void *pvCallbackInfo,
                             DWORD miscInfo,
                             DWORD dwRtpSessionBw,
                             DWORD dwKind,
                             long  *MaxShare)
{
    DWORD           numCells = NUM_FREE_CONTEXT_CELLS;
    HRESULT         hr; 
    DWORD           dwStatus;
    DWORD           dwRTCPstatus;
    PSSRC_ENTRY     pSSRC;

    PRTP_SESSION    &pRTPSession = *(RTP_SESSION **)ppvRTPSession;

    pRTPSession = NULL;
    
    IN_OUT_STR ("RTP : Enter CreateRTPSession()\n");

    // set status code
    hr = dwStatus = RRCM_NoError;
    dwKind &= RTP_KIND_MASK;
    
    // If RTP context doesn't exist, report error and return.
    if (pRTPContext == NULL) 
        {
        RRCM_DBG_MSG ("RTP : ERROR - No RTP Instance", 
                      0, __FILE__, __LINE__, DBG_CRITICAL);
        IN_OUT_STR ("RTP : Exit CreateRTPSession()\n");

        hr = MAKE_RRCM_ERROR(RRCMError_RTPNoContext);

        return hr;
        }

    EnterCriticalSection(&pRTPContext->critSect);
    
    // look for an existing session - Sender/Receiver for the same session
    // will be on two different graph under ActiveMovie
    // ... but will share the RTP/RTCP session
    if ( (pRTPSession = findSessionID(pSocket, NULL)) ) {
        RRCM_DBG_MSG ("RTP : Session already created", 0,
                      __FILE__, __LINE__, DBG_TRACE);

        DWORD k;
        
        for(k = RTP_KIND_FIRST; k < RTP_KIND_LAST; k++) {
            if ( (dwKind & (1<<k) & pRTPSession->dwKind) &&
                 pRTPSession->RefCount[k] >= MaxShare[k] ) {
                // No more shares availables for this socket

                RRCMDbgLog((
                        LOG_TRACE,
                        LOG_DEVELOP,
                        "CreateRTPSession: Full Session:%d,%d,%d Kind:%d/%d "
                        "Share(%d,%d)/(%d,%d)",
                        pRTPSession->pSocket[SOCK_RECV],
                        pRTPSession->pSocket[SOCK_SEND],
                        pRTPSession->pSocket[SOCK_RTCP],
                        dwKind, pRTPSession->dwKind,
                        MaxShare[0], MaxShare[1],
                        pRTPSession->RefCount[0],
                        pRTPSession->RefCount[1]
                    ));

                pRTPSession = NULL;
                LeaveCriticalSection(&pRTPContext->critSect);
                return(MAKE_RRCM_ERROR(RRCMError_RTPInvalidSession));
            }
        }

        // Add ref the existing RTP session
        for(k = RTP_KIND_FIRST; k < RTP_KIND_LAST; k++) {
            if ( dwKind & (1<<k) ) {
                InterlockedIncrement(&pRTPSession->RefCount[k]);
                pRTPSession->dwKind |= (1<<k);

                // disable all events
                pRTPSession->pRTCPSession->dwEventMask[k] = 0;
                pRTPSession->pRTCPSession->pvCallbackUserInfo[k] =
                    pvCallbackInfo;
            }
        }

        // update the wildcards, if there was any (a 0 value)
        for (k = SOCK_RECV; k <= SOCK_RTCP; k++) {
            if (!pRTPSession->pSocket[k])
                pRTPSession->pSocket[k] = pSocket[k];
        }
        
        if (dwKind & RTP_KIND_BIT(RTP_KIND_RECV)) {
            // Check if there are old outstanding
            // async I/Os from a previous receiver
            if (pRTPSession->lNumRecvIoPending > 0) {

                RTP_BFR_LIST *pRTPBfrList = (PRTP_BFR_LIST)
                    removePcktFromTail((PLINK_LIST)&pRTPSession->
                                       pRTPUsedListRecv,
                                       &pRTPSession->critSect);

                while(pRTPBfrList) {
                    addToHeadOfList((PLINK_LIST)&pRTPSession->pRTPFreeList,
                                    &pRTPBfrList->RTPBufferLink,
                                    &pRTPSession->critSect);

                    InterlockedDecrement(&pRTPSession->lNumRecvIoPending);

                    pRTPBfrList = (PRTP_BFR_LIST)
                        removePcktFromTail((PLINK_LIST)&pRTPSession->
                                           pRTPUsedListRecv,
                                           &pRTPSession->critSect);
                }
            }
        }
        
        // return the unique RTP session ID
        LeaveCriticalSection(&pRTPContext->critSect);
        return (hr);
    }

    // Allocate a new session pointer.
    pRTPSession = (PRTP_SESSION)GlobalAlloc (GMEM_FIXED | GMEM_ZEROINIT,
                                          sizeof(RTP_SESSION));
        
    // Report error if could not allocate context
    if (pRTPSession == NULL) 
        {
        RRCM_DBG_MSG ("RTP : ERROR - Resource allocation failed", 0,
                      __FILE__, __LINE__, DBG_CRITICAL);
        IN_OUT_STR ("RTP : Exit CreateRTPSession()\n");

        hr = MAKE_RRCM_ERROR(RRCMError_RTPSessResources);

        LeaveCriticalSection(&pRTPContext->critSect);
        return hr;
        }

    for(DWORD s = SOCK_RECV; s <= SOCK_RTCP; s++)
        pRTPSession->pSocket[s] = pSocket[s];
    
    pRTPSession->hHeapFreeList = 
        HeapCreate (0,
                    (NUM_FREE_CONTEXT_CELLS * sizeof(RTP_BFR_LIST)),
                    0);
    if (pRTPSession->hHeapFreeList == NULL) 
        {
        GlobalFree (pRTPSession);
        pRTPSession = NULL;

        RRCM_DBG_MSG ("RTP : ERROR - Heap allocation failed", 0, 
                      __FILE__, __LINE__, DBG_CRITICAL);
        IN_OUT_STR ("RTP : Exit CreateRTPSession()\n");

        hr = MAKE_RRCM_ERROR(RRCMError_RTCPResources);

        LeaveCriticalSection(&pRTPContext->critSect);
        return hr;
        }

    // Initialize the RTP session's critical section
    InitializeCriticalSection(&pRTPSession->critSect);

    {
        char name[128];
        wsprintf(name, "RTP[0x%08X] Sync SendTo", pRTPSession);
        pRTPSession->hSendTo = CreateEvent(NULL, FALSE, FALSE, name);

        if (!pRTPSession->hSendTo) {
            
            dwStatus = WSAGetLastError();
#if defined(_DEBUG)         
            wsprintf(name,
                     "RTP : ERROR - CreateEvent for "
                     "RTP[0x%08X] shutdown sync/SendTo failed",
                     pRTPSession);
            RRCM_DEV_MSG(name, dwStatus, __FILE__, __LINE__, DBG_CRITICAL);
#endif
            DeleteCriticalSection(&pRTPSession->critSect);
            
            // Return heap
            HeapDestroy(pRTPSession->hHeapFreeList);
            pRTPSession->hHeapFreeList = NULL;

            GlobalFree (pRTPSession);
            pRTPSession = NULL;

            LeaveCriticalSection(&pRTPContext->critSect);
            return(MAKE_RRCM_ERROR(dwStatus));
        }
    }
    
    // Get a link of buffers used for associating
    //  completion routines to a socket/buffer
    dwStatus = allocateLinkedList (&pRTPSession->pRTPFreeList, 
                                   pRTPSession->hHeapFreeList,
                                   &numCells,
                                   sizeof(RTP_BFR_LIST),
                                   NULL);

    if (dwStatus != RRCM_NoError) 
        {
        HeapDestroy(pRTPSession->hHeapFreeList);
        pRTPSession->hHeapFreeList = NULL;

        DeleteCriticalSection(&pRTPSession->critSect);

        if (pRTPSession->hSendTo) {
            CloseHandle(pRTPSession->hSendTo);
            pRTPSession->hSendTo = NULL;
        }

        GlobalFree (pRTPSession);
        pRTPSession = NULL;

        RRCM_DBG_MSG ("RTP : ERROR - Resource allocation failed", 0, 
                      __FILE__, __LINE__, DBG_CRITICAL);
        IN_OUT_STR ("RTP : Exit CreateRTPSession()\n");

        hr = MAKE_RRCM_ERROR(dwStatus);

        LeaveCriticalSection(&pRTPContext->critSect);
        return hr;
        }

    // All seems OK, initialize RTCP for this session
    hr = CreateRTCPSession(
            *ppvRTPSession,
            pSocket, 
            pRTCPTo, 
            toRTCPLen,
            pSdesInfo,
            dwStreamClock,
            pEncryptInfo,
            ssrc,
            pRRCMcallback,
            pvCallbackInfo,
            miscInfo,
            dwRtpSessionBw);

    if (FAILED(hr)) {
        // Return heap
        HeapDestroy(pRTPSession->hHeapFreeList);
        pRTPSession->hHeapFreeList = NULL;

        // Delete critical section
        DeleteCriticalSection(&pRTPSession->critSect);

        if (pRTPSession->hSendTo) {
            CloseHandle(pRTPSession->hSendTo);
            pRTPSession->hSendTo = NULL;
        }
    
        // Can't proceed, return session pointer
        GlobalFree (pRTPSession);
        pRTPSession = NULL;

    } else {

        for(DWORD i = 0; i < 2; i++) {
            if (dwKind & (1<<i)) {
                // set event context and event mask disabled
                pRTPSession->pRTCPSession->pvCallbackUserInfo[i] =
                    pvCallbackInfo;
                pRTPSession->pRTCPSession->dwEventMask[i] = 0;
            }
        }
        
        pRTPSession->pRTCPSession->pvRTPSession = (void *)pRTPSession;
        // Associate the socket with the Session address
        dwStatus = createHashEntry (pRTPSession);

        if (dwStatus == RRCM_NoError) {
            pSSRC = 
                (PSSRC_ENTRY)pRTPSession->pRTCPSession->XmtSSRCList.prev;

            if (pSSRC == NULL) {
                // This never happens, otherwise
                // CreateRTCPSession would have failed
                RRCM_DBG_MSG ("RTP : ERROR - No RTCP Xmt list", 0, 
                          __FILE__, __LINE__, DBG_CRITICAL);

                dwStatus = RRCMError_RTCPNoXmtList;
            } else {
                // Let's add this to our context
                addToHeadOfList(&(pRTPContext->pRTPSession), 
                            (PLINK_LIST)pRTPSession,
                            NULL);
#ifdef _DEBUG
                wsprintf(debug_string,
                         "RTP : Adding RTP Session. (Addr:0x%X)",
                         pRTPSession);
                RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif
                // Add ref the new RTP session
                for(DWORD k = RTP_KIND_FIRST; k < RTP_KIND_LAST; k++) {
                    if ( dwKind & (1<<k) ) {
                        InterlockedIncrement(&pRTPSession->RefCount[k]);
                        pRTPSession->dwKind |= (1<<k);
                    }
                }
            }
        } else {
            // Destroy everything and fail

            if (pRTPSession->pRTCPSession) {
                deleteRTCPSession(pSocket[SOCK_RTCP],
                                  pRTPSession->pRTCPSession,
                                  0);
                pRTPSession->pRTCPSession = (PRTCP_SESSION)0;
            }
            
            // Return heap
            HeapDestroy(pRTPSession->hHeapFreeList);
            pRTPSession->hHeapFreeList = NULL;

            // Delete critical section
            DeleteCriticalSection(&pRTPSession->critSect);

            if (pRTPSession->hSendTo) {
                CloseHandle(pRTPSession->hSendTo);
                pRTPSession->hSendTo = NULL;
            }

            // Can't proceed, return session pointer
            GlobalFree (pRTPSession);
            pRTPSession = NULL;
        }
    }

    LeaveCriticalSection(&pRTPContext->critSect);
    
    // set status code
    if (dwStatus != RRCM_NoError)
        hr = MAKE_RRCM_ERROR(dwStatus);

    IN_OUT_STR ("RTP : Exit CreateRTPSession()\n");

    // return the unique RTP session ID
    return (hr);
    }

RRCMSTDAPI ShutdownRTPSession(void *pvRTPSession,
                              char *byeReason,
                              DWORD dwKind)
{
    RTP_SESSION *pRTPSession = (RTP_SESSION *)pvRTPSession;
    PRTP_BFR_LIST pBfrList;

#if defined(_DEBUG)
    char msg[128];
    int count = 0;
#endif  
    // Mark all receive/sender structures as invalid
    EnterCriticalSection(&pRTPSession->critSect);

    for(pBfrList = (PRTP_BFR_LIST)
            pRTPSession->pRTPFreeList.next;
        pBfrList;
        pBfrList = (PRTP_BFR_LIST) pBfrList->RTPBufferLink.prev) {
        if (dwKind & pBfrList->dwKind) {
            pBfrList->dwKind |= RTP_KIND_BIT(RTP_KIND_SHUTDOWN);
        }
    }
    
    for(pBfrList = (PRTP_BFR_LIST)
            pRTPSession->pRTPUsedListRecv.next;
        pBfrList;
        pBfrList = (PRTP_BFR_LIST) pBfrList->RTPBufferLink.prev) {
        if (dwKind & pBfrList->dwKind) {
#if defined(_DEBUG)
            count++;
#endif
            pBfrList->dwKind |= RTP_KIND_BIT(RTP_KIND_SHUTDOWN);
        }
    }

    PSSRC_ENTRY pSSRC = (PSSRC_ENTRY)
        pRTPSession->pRTCPSession->XmtSSRCList.prev;

    long lRefCount;

    lRefCount = pRTPSession->RefCount[0] + pRTPSession->RefCount[1];
    
    LeaveCriticalSection(&pRTPSession->critSect);

    RRCMDbgLog((
            LOG_TRACE,
            LOG_DEVELOP,
            "RTP[0x%X] : ShutdownRTPSession: count: %d",
            pRTPSession, count
        ));

    if (lRefCount < 2) {
        // RTCP send BYE packet for this active stream if this
        // is the last share
        RTCPsendBYE(pSSRC, byeReason);
        ShutdownRTCPSession(pRTPSession->pRTCPSession);
    }
    
    return(RRCM_NoError);
}

/*----------------------------------------------------------------------------
 * Function   : CloseRTPSession
 * Description: Terminates a local stream session.
 * 
 * Input : RTPSession       = RTP session ID 
 *         byeReason        = -> to BYE reason
 *         closeRTCPSocket  = TRUE/FALSE. RTCP will close or not the socket
 *
 * Return: RRCM_NoError     = OK.
 *         Otherwise(!=0)   = Error (see RRCM.H)
 ---------------------------------------------------------------------------*/
RRCMSTDAPI CloseRTPSession(void *pvRTPSession, 
                           DWORD closeRTCPSocket,
                           DWORD dwKind)
{
    RTP_SESSION    *pRTPSession = (RTP_SESSION *)pvRTPSession;
    PSSRC_ENTRY     pSSRCList;
    PSSRC_ENTRY     pSSRC;
    DWORD           dwStatus;

    IN_OUT_STR ("RTP : Enter CloseRTPSession()\n");

    // If RTP context doesn't exist, report error and return.
    if (pRTPContext == NULL) 
        {
        RRCM_DBG_MSG ("RTP : ERROR - No RTP Instance", 0, 
                        __FILE__, __LINE__, DBG_ERROR);
        IN_OUT_STR ("RTP : Exit CloseRTPSession()\n");

        return (MAKE_RRCM_ERROR(RRCMError_RTPNoContext));
        }

    if (pRTPSession == NULL) 
        {
        RRCM_DBG_MSG ("RTP : ERROR - Invalid RTP session", 0, 
                      __FILE__, __LINE__, DBG_ERROR);
        IN_OUT_STR ("RTP : Exit CloseRTPSession()\n");

        return (MAKE_RRCM_ERROR(RRCMError_RTPInvalidSession));
        }

    long RefCount = 0;
    long numXmt = 0;
    
    EnterCriticalSection(&pRTPContext->critSect);

    // Ref release
    for(DWORD k = RTP_KIND_FIRST; k < RTP_KIND_LAST; k++) {
        if (dwKind & (1<<k)) {
            if (!InterlockedDecrement(&pRTPSession->RefCount[k])) {
                pRTPSession->dwKind &= ~(1<<k);
                // disable events for this client (CRtpSession)
                pRTPSession->pRTCPSession->dwEventMask[k] = 0;
                pRTPSession->pSocket[k] = 0;
            }
        }
    }

    if ((pRTPSession->RefCount[0] + pRTPSession->RefCount[1]) > 0) {
        LeaveCriticalSection(&pRTPContext->critSect);
        return(RRCM_NoError);
    }

    //////////////////////////////////////////////////////
    // Now we know this RTP/RTCP session has to be deleted
    //////////////////////////////////////////////////////
    
    /////////////////////////////////
    // Really close RTP/RTCP sessions
    /////////////////////////////////

    // clean up the Hash table for any stream still left in the Session
    EnterCriticalSection(&(pRTPSession->pRTCPSession->SSRCListCritSect));
    for (pSSRCList = (PSSRC_ENTRY)pRTPSession->pRTCPSession->XmtSSRCList.prev;
         pSSRCList != NULL;
         pSSRCList = (PSSRC_ENTRY)pSSRCList->SSRCList.next) 
    {
        numXmt++;
        ASSERT(!(numXmt > 1)); // I'm assuming only one sender per session
        deleteHashEntry(pRTPSession);
    }
    LeaveCriticalSection(&(pRTPSession->pRTCPSession->SSRCListCritSect));


    // Flush and close flush handle
    if (dwKind & RTP_KIND_BIT(RTP_KIND_RECV)) {
        pRTPSession->dwKind |= RTP_KIND_BIT(RTP_KIND_SHUTDOWN);
        // Do this only if the last one (sender, receiver) to close
        // the session is a receiver, otherwise, i.e.  if it is a sender,
        // then the receiver, if existed, has already gone, so the
        // outstanding I/O have been completed but as the receiving
        // thread is gone, no callbacks will be posted.
        RTPFlushRecv(pRTPSession);
    }

    CloseHandle(pRTPSession->hSendTo);

    // Remove the session from the linked list of sessions
    dwStatus = deleteRTPSession (pRTPContext, pRTPSession);
    if (dwStatus != RRCM_NoError)
        {
#ifdef _DEBUG
        wsprintf(debug_string, 
                 "RTP : ERROR - RTP session (Addr:0x%lX) not found",
                 pRTPSession);

        RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_ERROR);
#endif
        LeaveCriticalSection(&pRTPContext->critSect);
        return (MAKE_RRCM_ERROR(dwStatus));
        }

    // block out the session - it's on a free list now
    EnterCriticalSection (&pRTPSession->critSect);

            
    // All seems OK, close RTCP for each stream still open
    pSSRC = (PSSRC_ENTRY)pRTPSession->pRTCPSession->XmtSSRCList.prev;
    if (pSSRC == NULL)
        {
        RRCM_DBG_MSG ("RTP : ERROR - No SSRC entry on the Xmt list", 0, 
                      __FILE__, __LINE__, DBG_ERROR);
        IN_OUT_STR ("RTP : Exit CloseRTPSession()\n");

        LeaveCriticalSection (&pRTPSession->critSect);
        LeaveCriticalSection (&pRTPContext->critSect);
        return (MAKE_RRCM_ERROR(RRCMError_RTCPInvalidSSRCentry));
        }

    // ZCS fix: new version of this function takes RTCP session pointer in addition
    // to socket descriptor -- avoids problems with multiple concurrent sessions
    // on the same address/port pair. It also closes the RTCP socket depending on
    // whether there's more than one RTCP session using the same socket.
    dwStatus = deleteRTCPSession (pRTPSession->pSocket[SOCK_RTCP],
                                  pRTPSession->pRTCPSession,
                                  closeRTCPSocket);
    // OLD: dwStatus = deleteRTCPSession (pSSRC->RTCPsd, byeReason);
#ifdef _DEBUG
    if (dwStatus != RRCM_NoError) 
        {
        wsprintf(debug_string, 
                 "RTP : ERROR - RTCP delete Session (Addr: 0x%X) error:%d",
                 pRTPSession, dwStatus);
        RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
        }
#endif
    
    // Clean up our Heap 
#ifdef _DEBUG
    wsprintf(debug_string,
             "RTP : Deleting Heap 0x%X for Session 0x%X",
             pRTPSession->hHeapFreeList, pRTPSession);
    RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

    if (pRTPSession->hHeapFreeList)
        {
        HeapDestroy (pRTPSession->hHeapFreeList);
        pRTPSession->hHeapFreeList = NULL;
        }

#ifdef _DEBUG
    wsprintf(debug_string, "RTP : Deleting Session x%X", pRTPSession);
    RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

    // lock out the session - it's on a free list now
    LeaveCriticalSection (&pRTPSession->critSect);
    DeleteCriticalSection (&pRTPSession->critSect);

    GlobalFree (pRTPSession);
    pRTPSession = NULL;

    LeaveCriticalSection(&pRTPContext->critSect);

    IN_OUT_STR ("RTP : Exit CloseRTPSession()\n");

    if (dwStatus != RRCM_NoError)
        dwStatus = MAKE_RRCM_ERROR(dwStatus);

    return (dwStatus);
    }


/*--------------------------------------------------------------------------
** Function   : deleteRTPSession
** Description: Remove from RTP session queue and restore links for other 
**              sessions.
**
** Input :      pRTPContext:    -> to the RTP context
**              pSession:       -> to the RTP session
**
** Return:      OK: RRCM_NoError
**              !0: Error code (see RRCM.H)
--------------------------------------------------------------------------*/
DWORD deleteRTPSession(PRTP_CONTEXT pRTPContext,
                       PRTP_SESSION pRTPSession)
    {
    PLINK_LIST  pTmp;

    IN_OUT_STR ("RTP : Enter deleteRTPSession()\n");

    // make sure the session exist
    pTmp = pRTPContext->pRTPSession.prev;
    while (pTmp)
        {
        if (pTmp == (PLINK_LIST)pRTPSession)
            break;

        pTmp = pTmp->next;
        }

    if (pTmp == NULL)
        {
        RRCM_DBG_MSG ("RTP : ERROR - Invalid RTP session", 0, 
                      __FILE__, __LINE__, DBG_ERROR);

        IN_OUT_STR ("RTP : Exit deleteRTPSession()\n");

        return (MAKE_RRCM_ERROR(RRCMError_RTPInvalidSession));
        }

    // lock out queue access
    EnterCriticalSection (&pRTPSession->critSect);

    if (pRTPSession->RTPList.prev == NULL)
        // this was the first entry in the queue
        pRTPContext->pRTPSession.prev = pRTPSession->RTPList.next;
    else
        (pRTPSession->RTPList.prev)->next = pRTPSession->RTPList.next;

    if (pRTPSession->RTPList.next == NULL) 
        // this was the last entry in the queue
        pRTPContext->pRTPSession.next = pRTPSession->RTPList.prev;
    else
        (pRTPSession->RTPList.next)->prev = pRTPSession->RTPList.prev;

    // For debugging (instead of NULL)
    *((DWORD *) &pRTPSession->RTPList.next) |= 0xf0000000;
    *((DWORD *) &pRTPSession->RTPList.prev) |= 0xf0000000;

    // unlock out queue access
    LeaveCriticalSection (&pRTPSession->critSect);

    IN_OUT_STR ("RTP : Exit deleteRTPSession()\n");

    return (RRCM_NoError);
    }


static void CALLBACK RTPflushCallback (DWORD dwError,
                                 DWORD cbTransferred,
                                 LPWSAOVERLAPPED lpOverlapped,
                                 DWORD dwFlags)
{
    return;
}


// Waits the asynchronous I/O pendings to complete
DWORD RTPFlushRecv(RTP_SESSION *pRTPSession)
{
    DWORD dwStatus = 0;
    DWORD awaiting = 0;
    
    while(InterlockedCompareExchange(&pRTPSession->lNumRecvIoPending,0,0) > 0
          && awaiting < 90*1000) {
        
        dwStatus = SleepEx(g_dwRTPTimeToWaitIo, TRUE);
        
        if (!dwStatus)
            awaiting += g_dwRTPTimeToWaitIo;

#if defined(_DEBUG)
        char str[256];

        if (dwStatus == WAIT_IO_COMPLETION) {
            wsprintf(str, "RTP[0x%X] : Flush Wait IO_COMPLETION",
                     pRTPSession);
        } else {
            wsprintf(str, "RTP[0x%X] : Flush Wait timed-out",
                     pRTPSession);
        }

        RRCM_DEV_MSG (str, 0, NULL, 0, DBG_TRACE);
#endif
    }
    
    return(dwStatus);
}

// [EOF] 


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rrcm\rtcp\rtcptime.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTCPTIME.C
 * Product:     RTP/RTCP implementation
 * Description: Provides timers related functions for RTCP.
 *
 * $Workfile:   rtcptime.cpp  $
 * $Author:   CMACIOCC  $
 * $Date:   14 Feb 1997 12:02:00  $
 * $Revision:   1.3  $
 * $Archive:   R:\rtp\src\rrcm\rtcp\rtcptime.cpv  $
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/


#include "rrcm.h"                                    


/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/            


/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/  
extern PRTCP_CONTEXT	pRTCPContext;
#ifdef _DEBUG
extern char	debug_string[];
#endif




/*----------------------------------------------------------------------------
 * Function   : RTCPxmitInterval
 * Description: Calculate the RTCP transmission interval
 * 
 * Input :	members:	Estimated number of session members including 
 *						ourselves. On the initial call, should be 1.
 *
 *			senders:	Number of active senders since last report, known from
 *						construction of receiver reports for this packet. 
 *						Includes ourselves if we sent.
 *
 *			rtcpBw:		The target RTCP bandwidth, ie, the total Bw that will 
 *						be used by RTCP by all members of this session, in 
 *						bytes per seconds. Should be 5% of the session Bw.
 *
 *			weSent:		True if we've sent data during the last two RTCP 
 *						intervals. If TRUE, the compound RTCP packet just
 *						sent contained an SR packet.
 *
 *			packetSize:	Size of the RTCP packet just sent, in bytes, including
 *						network encapsulation, eg 28 bytes for UDP over IP.
 *
 *			*avgRtcpSize: Estimator to RTCP packet size, initialized and 
 *						 updated by this function for the packet just sent.
 *
 *			initial:	Initial transmission flag.
 *
 * Return: 		Interval time before the next transmission in msec.
 ---------------------------------------------------------------------------*/
DWORD RTCPxmitInterval (DWORD members, 
					    DWORD senders, 
						DWORD rtcpBw,
						DWORD weSent, 
						DWORD packetSize, 
						int *avgRtcpSize,
						DWORD initial)
	{
#ifdef ENABLE_FLOATING_POINT
//	// Minimum time between RTCP packets from this site in seconds. This time
//	// prevents the reports from clumping when sessions are small and the law
//	// of large numbers isn't helping to smooth out the traffic. It also keeps
//	// the report intervals from becoming ridiculously small during transient
//	// outages like a network partition.
//	double const RTCP_MinTime = 5.;
//
//	// Fraction of the RTCP bandwidth to be shared among active senders. This 
//	// fraction was chosen so that in a typical session with one or two active 
//	// senders, the computed report time would be roughly equal to the minimum
//	// report time so that we don't unnecessarily slow down receiver reports. 
//	// The receiver fraction must be 1 - the sender fraction.
//	double const RTCP_SenderBwFraction = 0.25;
//	double const RTCP_RcvrBwFraction   = (1 - RTCP_SenderBwFraction);
//
//	// Gain (smoothing constant) for the low-pass filter that estimates the 
//	// average RTCP packet size.
//	double const RTCP_sizeGain = RTCP_SIZE_GAIN;
//
//	// Interval 
//	double	t = 0;
//	double	rtcp_min_time = RTCP_MinTime;
//
//	// Number of member for computation 
//	unsigned int 	n;
//	int				tmpSize;
//
//	// Random number 
//	double	randNum;
//
//	// Very first call at application start-up uses half the min delay for 
//	// quicker notification while still allowing some time before reporting
//	// for randomization and to learn about other sources so the report
//	// interval will converge to the correct interval more quickly. The
//	// average RTCP size is initialized to 128 octects which is conservative.
//	// It assumes everyone else is generating SRs instead of RRs:
//	// 		20 IP + 8 UDP + 52 SR + 48 SDES CNAME
//	if (initial)
//		{
//		rtcp_min_time /= 2;
//		*avgRtcpSize = 128;
//		}
//
//	// If there were active senders, give them at least a minimum share of the 
//	// RTCP bandwidth. Otherwise all participants share the RTCP Bw equally.
//	n = members;
//	if (senders > 0 && (senders < (members * RTCP_SenderBwFraction)))
//		{
//		if (weSent)
//			{
//			rtcpBw *= RTCP_SenderBwFraction;
//			n = senders;
//			}
//		else
//			{
//			rtcpBw *= RTCP_RcvrBwFraction;
//			n -= senders;
//			}
//		}
//
//	// Update the average size estimate by the size of the report packet we 
//	// just sent out.
//	tmpSize = packetSize - *avgRtcpSize;
//	tmpSize = (int)(tmpSize * RTCP_sizeGain);
//	*avgRtcpSize += tmpSize;
//
//	// The effective number of sites times the average packet size is the 
//	// total number of octets sent when each site sends a report. Dividing 
//	// this by the effective bandwidth gives the time interval over which 
//	// those packets must be sent in order to meet the bandwidth target, 
//	// with a minimum enforced. In that time interval we send one report so
//	// this time is also our average time between reports.
//	t = (*avgRtcpSize) * n / rtcpBw;
//
//	if (t < rtcp_min_time)
//		t = rtcp_min_time;
//
//	// To avoid traffic burst from unintended synchronization with other sites
//	// we then pick our actual next report interval as a random number 
//	// uniformely distributed between 0.5*t and 1.5*t.
//
//	// Get a random number between 0 and 1
//	//  rand() gives a number between 0-32767. 
//	randNum = RRCMrand() % 32767;
//	randNum /= 32767.0;
//
//  // return timeout in msec
//	return (t * (randNum + 0.5) * 1000);
#else
	// Minimum time between RTCP packets from this site in Msec. This time
	// prevents the reports from clumping when sessions are small and the law
	// of large numbers isn't helping to smooth out the traffic. It also keeps
	// the report intervals from becoming ridiculously small during transient
	// outages like a network partition.
	int RTCP_MinTime = 5000;

	// Interval 
	int				t = 0;
	int				rtcp_min_time = RTCP_MinTime;

	// Number of member for computation 
	unsigned int 	n;
	int				tmpSize;

	// Random number 
	int				randNum;

	// Very first call at application start-up uses half the min delay for 
	// quicker notification while still allowing some time before reporting
	// for randomization and to learn about other sources so the report
	// interval will converge to the correct interval more quickly. The
	// average RTCP size is initialized to 128 octects which is conservative.
	// It assumes everyone else is generating SRs instead of RRs:
	// 		20 IP + 8 UDP + 52 SR + 48 SDES CNAME
	if (initial)
		{
		rtcp_min_time /= 2;
		*avgRtcpSize = 128;
		}

	// If there were active senders, give them at least a minimum share of the 
	// RTCP bandwidth. Otherwise all participants share the RTCP Bw equally.
	n = members;

	// Only a quart of the bandwidth (=> /4). Check above with floatting point
	if (senders > 0 && (senders < (members / 4)))
		{
		if (weSent)
			{
			// Only a quart of the bandwidth for the sender
			rtcpBw /= 4;
			n = senders;
			}
		else
			{
			// 3/4 of the bandwidth for the receiver
			rtcpBw = (3*rtcpBw)/4;
			n -= senders;
			}
		}

	// Update the average size estimate by the size of the report packet we 
	// just sent out.
	tmpSize = packetSize - *avgRtcpSize;
	tmpSize = (tmpSize+8) / 16;
	*avgRtcpSize += tmpSize;

	// The effective number of sites times the average packet size is the 
	// total number of octets sent when each site sends a report. Dividing 
	// this by the effective bandwidth gives the time interval over which 
	// those packets must be sent in order to meet the bandwidth target, 
	// with a minimum enforced. In that time interval we send one report so
	// this time is also our average time between reports.
	if (rtcpBw)
		t = (*avgRtcpSize) * n / rtcpBw;

	if (t < rtcp_min_time)
		t = rtcp_min_time;

	// To avoid traffic burst from unintended synchronization with other sites
	// we then pick our actual next report interval as a random number 
	// uniformely distributed between 0.5*t and 1.5*t.

	// Get a random number between 0 and 1
	// In order to avoid floating point operation, get a number between 
	// 0 and 1000, i.e. converted in Msec already. Add 500 Msec instead of 
	// 0.5 to the random number
	randNum = RRCMrand() % 1000;

	return ((t * (randNum + 500))/1000);
#endif
	}




// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rrcm\rtp\rtpinit.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTPINIT.C
 * Product:     RTP/RTCP implementation
 * Description: Provides initialization functions.
 *
 * $Workfile:   rtpinit.cpp  $
 * $Author:   CMACIOCC  $
 * $Date:   18 Feb 1997 13:24:24  $
 * $Revision:   1.7  $
 * $Archive:   R:\rtp\src\rrcm\rtp\rtpinit.cpv  $
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/

		
#include "rrcm.h"


/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/            
PRTP_CONTEXT	 pRTPContext = NULL;
PRTP_CONTEXT	 pRTPContext2 = NULL; // debugging purposes
CRITICAL_SECTION RTPCritSec;
long             RTPCritSecInit = 0;
RRCM_WS			 RRCMws;				

#ifdef ENABLE_ISDM2
KEY_HANDLE		hRRCMRootKey;
ISDM2			Isdm2;
#endif

#ifdef _DEBUG
char			debug_string[DBG_STRING_LEN];
#if !defined(RRCMLIB)
DWORD           dwRRCMRefTime = 0;
#endif
#endif

#if defined(RRCMLIB)
long RRCMCount = 0;

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
LPInteropLogger            RTPLogger = NULL;
#endif

#endif

const char *RTPDate = "01/27/1999 10:53";

/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/





/*----------------------------------------------------------------------------
 * Function   : initRTP
 * Description: Initializes the RTP task.
 * 
 * Input : hInst:	Handle to the DLL instance
 *
 * Return: RRCM_NoError		= OK.
 *         Otherwise(!=0)	= Initialization Error (see RRCM.H).
 ---------------------------------------------------------------------------*/

DWORD initRTP(
#if !defined(RRCMLIB)
		HINSTANCE hInst
#endif
	)
{
	// first find out is this instace has to initialize RTPCritSec
	// may change to a class and do this in the constructor
	long state = InterlockedCompareExchange(&RTPCritSecInit, 1, 0);

	if (state < 2) {
		if (state == 0) {
			// initialize here
			InitializeCriticalSection(&RTPCritSec);
			// RTPCritSecInit++ says initialization is completed
			InterlockedIncrement(&RTPCritSecInit);
#if defined(_DEBUG) && !defined(RRCMLIB)
			dwRRCMRefTime = timeGetTime();
#endif
		} else {
			// initialization not completed yet...
			// wait until completed by someone else
			// (shouldn't take long,every body uses this same mechanism)
			while(InterlockedCompareExchange(&RTPCritSecInit, 2, 2) != 2)
				SleepEx(500, TRUE);
		}
	}

	EnterCriticalSection(&RTPCritSec);

	RRCMCount++;

	RRCMDbgLog((
			LOG_TRACE,
			LOG_DEVELOP,
			"RTP : initRTP(%d)",
			RRCMCount
		));
	
	if (RRCMCount > 1) {
		LeaveCriticalSection(&RTPCritSec);
		return(RRCM_NoError);
	}

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
	// We are not using this logging mechanism, but
	// it will produce AV if the CPLS.DLL used doesn't
	// match the prototypes with which we have compiled
	// this code.
	// So to avoid this problem, I disable its loading.

	//RTPLogger = InteropLoad(RTPLOG_PROTOCOL);
#endif

#if defined(RRCMLIB)
	HINSTANCE hInst = NULL;
#endif
	
	DWORD	dwStatus;
	DWORD	hashTableEntries = NUM_RTP_HASH_SESS;

	RRCM_DBG_MSG ("RTP : Enter initRTP()", 0, __FILE__, __LINE__, DBG_TRACE);
	IN_OUT_STR ("RTP : Enter initRTP()\n");

	// If RTP has already been initialized, stop, report the error and return
	if (pRTPContext != NULL) 
		{
		RRCM_DBG_MSG ("RTP : ERROR - Multiple RTP Instances", 0, 
				      __FILE__, __LINE__, DBG_CRITICAL);
		IN_OUT_STR ("RTP : Exit initRTP()\n");

		RRCMCount--;
		LeaveCriticalSection(&RTPCritSec);
		return (MAKE_RRCM_ERROR(RRCMError_RTPReInit));
		}

	// Obtain our context
	pRTPContext = (PRTP_CONTEXT)GlobalAlloc (GMEM_FIXED | GMEM_ZEROINIT,
											 sizeof(RTP_CONTEXT));

	
	// if no resources, exit with appropriate error
	if (pRTPContext == NULL) 
		{
		RRCM_DBG_MSG ("RTP : ERROR - Resource allocation failed", 0, 
					  __FILE__, __LINE__, DBG_CRITICAL);
		IN_OUT_STR ("RTP : Exit initRTP()\n");

		RRCMCount--;
		LeaveCriticalSection(&RTPCritSec);
		return (MAKE_RRCM_ERROR(RRCMError_RTPResources));
		}

	// Get information from the registry if any present
	RRCMreadRegistry (pRTPContext);

	// Perform dynamic linking of what we need
	if ((dwStatus = RRCMgetDynamicLink ()) != RRCM_NoError)
		{
		GlobalFree(pRTPContext);
		pRTPContext = NULL;

		RRCM_DBG_MSG ("RTP : ERROR - Winsock library not found", 0, 
					  __FILE__, __LINE__, DBG_CRITICAL);
		IN_OUT_STR ("RTP : Exit initRTP()\n");

		RRCMCount--;
		LeaveCriticalSection(&RTPCritSec);
		return MAKE_RRCM_ERROR(dwStatus);
		}

	// Initialize RTP context critical section
	InitializeCriticalSection(&pRTPContext->critSect);

	// Create RTCP and look at return value.  If error, don't proceed 
	// any further.  Pass this error to the calling function
	if ((dwStatus = initRTCP()) == RRCM_NoError) 
	{
		// RTCP is up.  We need to initialize our context
		pRTPContext->hInst = hInst;
		pRTPContext->pRTPSession.next = NULL;
		pRTPContext->pRTPSession.prev = NULL;

		// Allocate a heap for the hash table used to keep the 
		// association betweenthe sockets (streams) and the sessions
		pRTPContext->hHashFreeList = 
			HeapCreate (0,
						(NUM_RTP_HASH_SESS * sizeof(RTP_HASH_LIST)),
						0);
		if (pRTPContext->hHashFreeList == NULL) 
			dwStatus = RRCMError_RTPResources;
		else 
		{
			// Get a fixed (for now) link of buffers used for 
			// associating completion routines to a socket/buffer
			dwStatus = allocateLinkedList (&pRTPContext->pRTPHashList, 
										   pRTPContext->hHashFreeList,
										   &hashTableEntries,
										   sizeof(RTP_HASH_LIST),
										   &pRTPContext->critSect);
		}
	} else {
		// if any part of initialation did not succeed,
		// declare it all a failure
		// and return all resourses allocated
		if (pRTPContext) 
			{
			if (pRTPContext->hHashFreeList) 
				HeapDestroy(pRTPContext->hHashFreeList);
	
			GlobalFree(pRTPContext);
			pRTPContext = NULL;
			}
		RRCMCount--;
	}

	LeaveCriticalSection(&RTPCritSec);
	
	IN_OUT_STR ("RTP : Exit initRTP()\n");

	if (dwStatus != RRCM_NoError)
		dwStatus = MAKE_RRCM_ERROR(dwStatus);

	return (dwStatus);
	}


/*----------------------------------------------------------------------------
 * Function   : deleteRTP
 * Description: Deletes RTP. Closes all RTP and RTCP sessions and releases all
 *				resources.
 * 
 * Input : hInst:	 Handle to the DLL instance.
 *
 * Return: RRCM_NoError		= OK.
 *         Otherwise(!=0)	= Initialization Error (see RRCM.H).
 ---------------------------------------------------------------------------*/
DWORD deleteRTP (
#if !defined(RRCMLIB)
		HINSTANCE hInst
#endif
	)
{

	// first find out is this instace has to initialize RTPCritSec
	// may change to a class and do this in the constructor
	long state = InterlockedCompareExchange(&RTPCritSecInit, 1, 0);

	if (state < 2) {
		if (state == 0) {
			// initialize here
			InitializeCriticalSection(&RTPCritSec);
			// RTPCritSecInit++ says initialization is completed
			InterlockedIncrement(&RTPCritSecInit);
#if defined(_DEBUG) && !defined(RRCMLIB)
			dwRRCMRefTime = timeGetTime();
#endif
		} else {
			// initialization not completed yet...
			// wait until completed by someone else
			// (shouldn't take long,every body uses this same mechanism)
			while(InterlockedCompareExchange(&RTPCritSecInit, 2, 2) != 2)
				SleepEx(500, TRUE);
		}
	}

	EnterCriticalSection(&RTPCritSec);

	RRCMCount--;

	RRCMDbgLog((
			LOG_TRACE,
			LOG_DEVELOP,
			"RTP : deleteRTP(%d)",
			RRCMCount
		));
	
	if (RRCMCount > 0) {
		LeaveCriticalSection(&RTPCritSec);
		return(RRCM_NoError);
	}

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
	if (RTPLogger) {
		InteropUnload(RTPLogger);
		RTPLogger = NULL;
	}
#endif
	
#if defined(RRCMLIB)
	HINSTANCE hInst = NULL;
#endif
	DWORD			dwStatus;
	PRTP_SESSION	pDeleteSession;

#ifdef ENABLE_ISDM2
	HRESULT			hError;
#endif

	RRCM_DBG_MSG ("RTP : Enter deleteRTP()", 0, __FILE__, __LINE__, DBG_TRACE);
	IN_OUT_STR ("RTP : Enter deleteRTP()\n");

	// If RTP context doesn't exist, report error and return.
	if (pRTPContext == NULL) 
		{
		RRCM_DBG_MSG ("RTP : ERROR - No RTP instance", 0, 
						__FILE__, __LINE__, DBG_ERROR);
		IN_OUT_STR ("RTP : Exit deleteRTP()\n");

		LeaveCriticalSection(&RTPCritSec);
		return (MAKE_RRCM_ERROR(RRCMError_RTPInvalidDelete));
		}

	if (pRTPContext->hInst != hInst) 
		{
		RRCM_DBG_MSG ("RTP : ERROR - Invalid DLL instance handle", 0, 
					  __FILE__, __LINE__, DBG_ERROR);
		IN_OUT_STR ("RTP : Exit deleteRTP()\n");

		LeaveCriticalSection(&RTPCritSec);
		return (MAKE_RRCM_ERROR(RRCMError_RTPNoContext));
		}

	// If we still have sessions open, clean them up
	while ((pDeleteSession = 
			(PRTP_SESSION)pRTPContext->pRTPSession.prev) != NULL) 
		{
		//Close all open sessions
		CloseRTPSession ((PDWORD)pDeleteSession, FALSE, 3);
		}

	// Call RTCP to terminate and cleanup
	dwStatus = deleteRTCP();
		
	if (pRTPContext->hHashFreeList) 
		HeapDestroy(pRTPContext->hHashFreeList);

#ifdef ENABLE_ISDM2
	// Query ISDM key
	if (Isdm2.hISDMdll)
		{
		DWORD dwKeys = 0;
		DWORD dwValues = 0;

		if (SUCCEEDED (Isdm2.ISDMEntry.ISD_QueryInfoKey (hRRCMRootKey, 
														 NULL, NULL, 
														 &dwKeys, &dwValues)))
			{
			if (!dwKeys && !dwValues)
				{
				hError = Isdm2.ISDMEntry.ISD_DeleteKey(hRRCMRootKey);
				if(FAILED(hError))
					RRCM_DBG_MSG ("RTP: ISD_DeleteKey failed", 0,
									NULL, 0, DBG_NOTIFY);
				}
			}

		DeleteCriticalSection (&Isdm2.critSect);

		if (FreeLibrary (Isdm2.hISDMdll) == FALSE)
			{
			RRCM_DBG_MSG ("RTP : ERROR - Freeing WS Lib", GetLastError(), 
						  __FILE__, __LINE__, DBG_ERROR);
			}
		}
#endif

	// unload the WS library
	if (RRCMws.hWSdll)
		{
		if (FreeLibrary (RRCMws.hWSdll) == FALSE)
			{
			RRCM_DBG_MSG ("RTP : ERROR - Freeing WS Lib", GetLastError(), 
						  __FILE__, __LINE__, DBG_ERROR);
			}
		}

	// delete RTP context critical section
	DeleteCriticalSection(&pRTPContext->critSect);

	// delete RTP context
	pRTPContext2 = pRTPContext;
	GlobalFree(pRTPContext);
	pRTPContext = NULL;

	LeaveCriticalSection(&RTPCritSec);
	
	IN_OUT_STR ("RTP : Exit deleteRTP()\n");

	if (dwStatus != RRCM_NoError)
		dwStatus = MAKE_RRCM_ERROR(dwStatus);

	return (dwStatus);
	}


/*----------------------------------------------------------------------------
 * Function   : RRCMreadRegistry
 * Description: Access the registry
 * 
 * Input : pCtxt:	-> to the RTP context
 *
 * Return: None
 ---------------------------------------------------------------------------*/
void RRCMreadRegistry (PRTP_CONTEXT	pCtxt)
	{
	HKEY	hKey;
	long	lRes;
	char	keyBfr[50];

	// open the key
	strcpy (keyBfr, szRegRRCMKey);

	// INTEL key vs MICROSOFT KEY
#ifndef INTEL
	strcat (keyBfr, szRegRRCMSubKey);
#else
	strcat (keyBfr, szRegRRCMSubKeyIntel);
#endif
	lRes = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
						 keyBfr,	
						 0, 
						 KEY_READ,
						 &hKey);
	if (lRes || !hKey)
		{
		// key not found, setup default values
		pCtxt->registry.NumSessions      = NUM_RRCM_SESS;
		pCtxt->registry.NumFreeSSRC      = NUM_FREE_SSRC;
		pCtxt->registry.NumRTCPPostedBfr = NUM_RCV_BFR_POSTED;
		pCtxt->registry.RTCPrcvBfrSize   = RRCM_RCV_BFR_SIZE;
		return;
		}

	// get the number of RRCM sessions
	RRCMgetRegistryValue (hKey, szRegRRCMNumSessions, 
				          &pCtxt->registry.NumSessions, 
						  REG_DWORD, sizeof(DWORD));
	// check range
	if (pCtxt->registry.NumSessions < MIN_NUM_RRCM_SESS)
		pCtxt->registry.NumSessions = MIN_NUM_RRCM_SESS;
	else if (pCtxt->registry.NumSessions > MAX_NUM_RRCM_SESS)
		pCtxt->registry.NumSessions = MAX_NUM_RRCM_SESS;

	// get the number of initial free SSRC
	RRCMgetRegistryValue (hKey, szRegRRCMNumFreeSSRC,
					      &pCtxt->registry.NumFreeSSRC, 
						  REG_DWORD, sizeof(DWORD));

	// check range
	if (pCtxt->registry.NumFreeSSRC < MIN_NUM_FREE_SSRC)
		pCtxt->registry.NumFreeSSRC = MIN_NUM_FREE_SSRC;
	else if (pCtxt->registry.NumFreeSSRC > MAX_NUM_FREE_SSRC)
		pCtxt->registry.NumFreeSSRC = MAX_NUM_FREE_SSRC;

	// get the number of RTCP rcv buffers to be posted
	RRCMgetRegistryValue (hKey, szRegRRCMNumRTCPPostedBfr,
					      &pCtxt->registry.NumRTCPPostedBfr, 
						  REG_DWORD, sizeof(DWORD));

	// check range
	if (pCtxt->registry.NumRTCPPostedBfr < MIN_NUM_RCV_BFR_POSTED)
		pCtxt->registry.NumRTCPPostedBfr = MIN_NUM_RCV_BFR_POSTED;
	else if (pCtxt->registry.NumRTCPPostedBfr > MAX_NUM_RCV_BFR_POSTED)
		pCtxt->registry.NumRTCPPostedBfr = MAX_NUM_RCV_BFR_POSTED;

	// get the RTCP rcv buffer size
	RRCMgetRegistryValue (hKey, szRegRRCMRTCPrcvBfrSize,
					      &pCtxt->registry.RTCPrcvBfrSize, 
						  REG_DWORD, sizeof(DWORD));

	// check range
	if (pCtxt->registry.RTCPrcvBfrSize < MIN_RRCM_RCV_BFR_SIZE)
		pCtxt->registry.RTCPrcvBfrSize = MIN_RRCM_RCV_BFR_SIZE;
	else if (pCtxt->registry.RTCPrcvBfrSize > MAX_RRCM_RCV_BFR_SIZE)
		pCtxt->registry.RTCPrcvBfrSize = MAX_RRCM_RCV_BFR_SIZE;

	// get the dynamic DLL name
	RRCMgetRegistryValue (hKey, szRegRRCMWsLib,
					      (PDWORD)pCtxt->registry.WSdll, 
						  REG_SZ, FILENAME_LENGTH);

	// close the key
	RegCloseKey (hKey);
	}


/*----------------------------------------------------------------------------
 * Function   : RRCMgetRegistryValue
 * Description: Read a value from the registry
 * 
 * Input :		hKey	: Key handle
 *				pValStr	: -> to string value
 *				pKeyVal : -> to value
 *				type	: Type to read
 *				len		: Receiving buffer length
 *
 * Return:		None
 ---------------------------------------------------------------------------*/
void RRCMgetRegistryValue (HKEY hKey, LPTSTR pValStr, 
					       PDWORD pKeyVal, DWORD type, DWORD len)
	{
	DWORD	dwType = type;
	DWORD	retSize = len;

	// query the value
	RegQueryValueEx (hKey,
				     pValStr,
					 NULL,
					 &dwType,
					 (BYTE *)pKeyVal,
					 &retSize);
	}


/*----------------------------------------------------------------------------
 * Function   : RRCMgetDynamicLink
 * Description: Get all dynamic linked DLL entries
 * 
 * Input :		None
 *
 * Return:		None
 ---------------------------------------------------------------------------*/
DWORD RRCMgetDynamicLink (void)
	{
	HINSTANCE		hWSdll;

#ifdef ENABLE_ISDM2
	HRESULT			hError;

	Isdm2.hISDMdll = LoadLibrary(szISDMdll);

	// make sure the LoadLibrary call did not fail
	if (Isdm2.hISDMdll)
		{
		RRCM_DBG_MSG ("RTP: ISDM2 LoadLibrary worked", 0, NULL, 0, DBG_NOTIFY);
		// get the ISDM entry points used by RRCM
		Isdm2.ISDMEntry.ISD_CreateKey = 
			(ISD_CREATEKEY) GetProcAddress (Isdm2.hISDMdll, 
												   "ISD_CreateKey");

		Isdm2.ISDMEntry.ISD_CreateValue = 
			(ISD_CREATEVALUE) GetProcAddress (Isdm2.hISDMdll, "ISD_CreateValue");

		Isdm2.ISDMEntry.ISD_SetValue = 
			(ISD_SETVALUE) GetProcAddress (Isdm2.hISDMdll, "ISD_SetValue");

		Isdm2.ISDMEntry.ISD_DeleteValue = 
			(ISD_DELETEVALUE) GetProcAddress (Isdm2.hISDMdll, "ISD_DeleteValue");

		Isdm2.ISDMEntry.ISD_DeleteKey = 
			(ISD_DELETEKEY) GetProcAddress (Isdm2.hISDMdll, "ISD_DeleteKey");

		Isdm2.ISDMEntry.ISD_QueryInfoKey = 
			(ISD_QUERYINFOKEY) GetProcAddress (Isdm2.hISDMdll, "ISD_QueryInfoKey");

		// initialize critical section
		InitializeCriticalSection (&Isdm2.critSect);

		// make sure we have all of them
		if (Isdm2.ISDMEntry.ISD_CreateKey == NULL ||
			Isdm2.ISDMEntry.ISD_CreateValue == NULL ||
			Isdm2.ISDMEntry.ISD_SetValue == NULL ||
			Isdm2.ISDMEntry.ISD_DeleteValue == NULL ||
			Isdm2.ISDMEntry.ISD_DeleteKey == NULL ||
			Isdm2.ISDMEntry.ISD_QueryInfoKey == NULL )
			{
			Isdm2.hISDMdll = 0;
			RRCM_DBG_MSG ("RTP: Failed to load all ISDM2 functions",
							0, NULL, 0, DBG_NOTIFY);
			// delete critical section
			DeleteCriticalSection (&Isdm2.critSect);
			}
		else
			{
			hError = Isdm2.ISDMEntry.ISD_CreateKey(MAIN_ROOT_KEY, szRRCMISDM, &hRRCMRootKey);
			if(FAILED(hError))
				{
				RRCM_DBG_MSG ("RTP: ISD_CreateKey Failed",0, NULL, 0, DBG_NOTIFY);
				hRRCMRootKey = 0;
				}
			}
		}
#endif

	// load the DLL specified in the registry
	hWSdll = LoadLibrary(pRTPContext->registry.WSdll);

	// make sure the LoadLibrary call did not fail
	if (hWSdll)
		{
		RRCMws.hWSdll = hWSdll;

		RRCMws.sendTo = (LPFN_WSASENDTO)GetProcAddress (hWSdll, "WSWSendTo");
		RRCMws.recvFrom = (LPFN_WSARECVFROM)GetProcAddress (hWSdll, 
															"WSWRecvFrom");
		RRCMws.send = (LPFN_WSASEND)GetProcAddress (hWSdll, "WSWSend");
		RRCMws.recv = (LPFN_WSARECV)GetProcAddress (hWSdll, "WSWRecv");
		RRCMws.getsockname = (LPFN_GETSOCKNAME)GetProcAddress (hWSdll, 
															"WSWgetsockname");
		RRCMws.gethostname = (LPFN_GETHOSTNAME)GetProcAddress (hWSdll, 
															"WSWgethostname");
		RRCMws.gethostbyname = (LPFN_GETHOSTBYNAME)GetProcAddress (hWSdll, 
															"WSWgethostbyname");
		RRCMws.closesocket = (LPFN_CLOSESOCKET)GetProcAddress (hWSdll, 
															"WSWclosesocket");
		RRCMws.ntohl = (LPFN_WSANTOHL)GetProcAddress (hWSdll, "WSWNtohl");
		RRCMws.ntohs = (LPFN_WSANTOHS)GetProcAddress (hWSdll, "WSWNtohs");
		RRCMws.htonl = (LPFN_WSAHTONL)GetProcAddress (hWSdll, "WSWHtonl");
		RRCMws.htons = (LPFN_WSAHTONS)GetProcAddress (hWSdll, "WSWHtons");
		}
	else
		{
		// load Winsock2 if present
		hWSdll = LoadLibrary(szRRCMdefaultLib);

		if (hWSdll)
			{
			RRCMws.hWSdll = hWSdll;

			RRCMws.sendTo = (LPFN_WSASENDTO)GetProcAddress (hWSdll, 
															  "WSASendTo");
			RRCMws.recvFrom = (LPFN_WSARECVFROM)GetProcAddress (hWSdll, 
															"WSARecvFrom");
			RRCMws.send = (LPFN_WSASEND)GetProcAddress (hWSdll, "WSASend");
			RRCMws.recv = (LPFN_WSARECV)GetProcAddress (hWSdll, "WSARecv");
			RRCMws.getsockname = (LPFN_GETSOCKNAME)GetProcAddress (hWSdll, 
															"getsockname");
			RRCMws.gethostname = (LPFN_GETHOSTNAME)GetProcAddress (hWSdll, 
															"gethostname");
			RRCMws.gethostbyname = (LPFN_GETHOSTBYNAME)GetProcAddress (hWSdll, 
															"gethostbyname");
			RRCMws.closesocket = (LPFN_CLOSESOCKET)GetProcAddress (hWSdll, 
																"closesocket");
			RRCMws.ntohl = (LPFN_WSANTOHL)GetProcAddress (hWSdll, "WSANtohl");
			RRCMws.ntohs = (LPFN_WSANTOHS)GetProcAddress (hWSdll, "WSANtohs");
			RRCMws.htonl = (LPFN_WSAHTONL)GetProcAddress (hWSdll, "WSAHtonl");
			RRCMws.htons = (LPFN_WSAHTONS)GetProcAddress (hWSdll, "WSAHtons");
			}
		}

	// make sure we have the Xmt/Recv functionality
	if (RRCMws.sendTo == NULL || 
		RRCMws.recvFrom == NULL ||
		RRCMws.send == NULL || 
		RRCMws.recv == NULL ||
		RRCMws.getsockname == NULL ||
		RRCMws.ntohl == NULL ||
		RRCMws.ntohs == NULL ||
		RRCMws.htonl == NULL ||
		RRCMws.htons == NULL ||
		RRCMws.gethostname == NULL ||
		RRCMws.gethostbyname == NULL ||
		RRCMws.closesocket == NULL ||
		RRCMws.hWSdll == 0)
		{
		RRCM_DBG_MSG ("RTP : ERROR - Invalid Winsock DLL", 0, 
		 		      __FILE__, __LINE__, DBG_CRITICAL);

		return RRCMError_WinsockLibNotFound;
		}
	else
		return RRCM_NoError;
	}


// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rrcm\rtp\verstmp.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996, 1997 Intel Corporation.
//
//
//  Module Name: verstmp.h
//  Abstract:    Defines version resource information for this component
//				 (aka file).  May override definitions from the product
//				 level.  This file is automatically updated by the build
//				 system.
//  Notes:       This component may be distributed seperately, so product
//				 name is overridden.
//	Environment: MSVC 4.0
/////////////////////////////////////////////////////////////////////////////////

// $Header:   R:/rtp/src/rrcm/rtp/verstmp.h_v   1.0   28 Feb 1997 02:02:50   CPEARSON  $

#ifndef __VERSTMP_H__
#define __VERSTMP_H__

#include "verprod.h" // produce-level defaults

#define VER_FILETYPE				VFT_DLL

#define VER_FILESUBTYPE				0
#define VER_FILEDESCRIPTION_STR		"Intel\256 RTP/RTCP Core Module\0"
#define VER_INTERNALNAME_STR		"RRCM\0"
#define VER_ORIGINALFILENAME_STR	"RRCM.DLL\0"
#define VER_SYSTEMNAME_STR			"Intel\256 Real Time Protocol\0"

// This component may be distributed separately, so override product
// name
#undef  VER_PRODUCTNAME_STR
#define VER_PRODUCTNAME_STR			"RRCM.DLL\0"

#define VER_LEGALTRADEMARKS_STR		"RRCM is a trademark of Intel Corporation.\0"

#endif // __VERSTMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rrcm\rtp\rtpsend.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTPSEND.C
 * Product:     RTP/RTCP implementation
 * Description: Provides WSA Send functions.
 *
 * $Workfile:   RTPSEND.CPP  $
 * $Author:   CMACIOCC  $
 * $Date:   13 Feb 1997 14:46:08  $
 * $Revision:   1.6  $
 * $Archive:   R:\rtp\src\rrcm\rtp\rtpsend.cpv  $
 *
 * This listing is supplied under the terms 
 * of a license agreement with Intel Corporation and
 * many not be copied nor disclosed except in accordance
 * with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/


#include "rrcm.h"

#define DBG_DWKIND 1
/*---------------------------------------------------------------------------
/                           Global Variables
/--------------------------------------------------------------------------*/            



/*---------------------------------------------------------------------------
/                           External Variables
/--------------------------------------------------------------------------*/
extern PRTP_CONTEXT     pRTPContext;
extern RRCM_WS          RRCMws;


#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
extern LPInteropLogger RTPLogger;
#endif


#if defined(SIMULATE_RTP_LOSS) && defined(_DEBUG)
DWORD g_SendCredit = -1;
DWORD g_targetByteRate = 16000; // 128 kbits/s
DWORD g_dwLastTime;
DWORD g_packetsDropped = 0;
DWORD g_LastTimeDropped = 0;
#define BUCKET_SIZE 6000 // bytes
#endif

/*----------------------------------------------------------------------------
 * Function   : RTPSendTo
 * Description: Intercepts sendto requests from the application.  
 *              Handles any statistical processing required for RTCP.  
 *              Copies completion routine from app and substitutes its own.  
 *              Apps completion routine will be called after RTP's completion 
 *              routine gets called by Winsock2.
 * 
 * Input :  RTPsocket:          RTP socket descriptor
 *          pBufs:              -> to WSAbuf structure
 *          dwBufCount:         Buffer count in WSAbuf structure
 *          pNumBytesSent:      -> to number of bytes sent
 *          socketFlags:        Flags
 *          pTo:                -> to the destination address
 *          toLen:              Destination address length
 *          pOverlapped:        -> to overlapped I/O structure
 *          pCompletionRoutine: -> to completion routine
 *
 * Return: RRCM_NoError     = OK.
 *         Otherwise(!=0)   = Check RRCM.h file for references.
 ---------------------------------------------------------------------------*/
RRCMSTDAPI RTPSendTo (SOCKET *pSocket,
                      LPWSABUF pBufs,
                      DWORD  dwBufCount,
                      LPDWORD pNumBytesSent, 
                      int socketFlags,
                      LPVOID pTo,
                      int toLen,
                      LPWSAOVERLAPPED pOverlapped, 
                      LPWSAOVERLAPPED_COMPLETION_ROUTINE pCompletionRoutine)
    {
    int             dwStatus;
    int             dwErrorStatus;
    PRTP_SESSION    pRTPSession;
    RTP_HDR_T       *pRTPHeader;
    PSSRC_ENTRY     pSSRC;
    PRTP_BFR_LIST   pXMTStruct;

    IN_OUT_STR ("RTP : Enter RTPSendTo()\n");

    // If RTP context doesn't exist, report error and return.
    if (pRTPContext == NULL) 
        {
        RRCM_DBG_MSG ("RTP : ERROR - No RTP Instance", 0, 
                      __FILE__, __LINE__, DBG_CRITICAL);
        IN_OUT_STR ("RTP : Exit RTPSendTo()\n");

        return (MAKE_RRCM_ERROR(RRCMError_RTPInvalid));
        }

    // Search for the proper session based on incoming socket
    pRTPSession = findSessionID2(pSocket, &pRTPContext->critSect);
    if (pRTPSession == NULL)
        {
        RRCM_DBG_MSG ("RTP : ERROR - Invalid RTP session", 0, 
                      __FILE__, __LINE__, DBG_CRITICAL);
        IN_OUT_STR ("RTP : Exit RTPSendTo()\n");

        return (MAKE_RRCM_ERROR(RRCMError_RTPInvalidSession));
        }

    // Complete filling in header.  First cast a pointer
    // of type RTP_HDR_T to ease accessing
    pRTPHeader = (RTP_HDR_T *)pBufs->buf;
    ASSERT (pRTPHeader);
            
    // Now setup some of the RTP header fields
    pRTPHeader->type = RTP_TYPE;    // RTP Version 2

    // Get pointer to our entry in SSRC table for this session
    EnterCriticalSection(&pRTPSession->pRTCPSession->SSRCListCritSect);
    pSSRC = searchForMySSRC (
        (PSSRC_ENTRY)pRTPSession->pRTCPSession->XmtSSRCList.prev,
        pRTPSession->pSocket[SOCK_RTCP]);
    LeaveCriticalSection(&pRTPSession->pRTCPSession->SSRCListCritSect);
    ASSERT (pSSRC);

    // lock out access to this RTCP session variable 
    EnterCriticalSection (&pSSRC->critSect);

    DWORD timeStamp = ntohl(pRTPHeader->ts); // this has already net order
    
    if (pSSRC->dwTimeStampOffset == 0xffffffff) {
        // initialize offset, add some degree of randomness in less
        // significant 12 bits. Don't do this in whole 32 bits because
        // of some dumb receivers that doesn't know how to deal with
        // timestamp wrap arounds. Doing this the timestamp will start
        // at a reasonable low value enough to have a wrap around
        // after 11 hours sending 25 frames per second and yet still
        // be random.

        pSSRC->dwTimeStampOffset = timeStamp - (getAnSSRC() & 0xfff);
    }

    timeStamp -= pSSRC->dwTimeStampOffset;

    pRTPHeader->ts = htonl(timeStamp);
    
    // save the RTP timestamp
    pSSRC->xmtInfo.dwLastSendRTPTimeStamp = timeStamp;

    // save the last transmit time
    pSSRC->xmtInfo.dwLastSendRTPSystemTime = timeGetTime ();

    // copy over sequence number sent
    pSSRC->xmtInfo.dwCurXmtSeqNum = ntohs(pRTPHeader->seq);

    // SSRC
    pRTPHeader->ssrc = htonl(pSSRC->SSRC);

    // Update initial XmtSeqNum so RTCP knows the baseline
    if ((pSSRC->dwSSRCStatus & SEQ_NUM_UPDATED) == 0) 
        {
        pSSRC->xmtInfo.dwPrvXmtSeqNum = pSSRC->xmtInfo.dwCurXmtSeqNum;
        pSSRC->dwSSRCStatus |= SEQ_NUM_UPDATED;
        }

    // update the payload type for this SSRC_ENTRY
    pSSRC->PayLoadType = pRTPHeader->pt;

    // unlock pointer access 
    LeaveCriticalSection (&pSSRC->critSect);

    // We need to associate a completionRoutine's lpOverlapped with a 
    // session. We look at each buffer and associate a socket so when 
    // the completion routine is called, we can pull out the socket.
    if ((dwStatus = saveWinsockContext(pOverlapped,
                                       pCompletionRoutine,
                                       pRTPSession)) == RRCM_NoError)
        {
        // Forward to winsock, substituting our completion routine for the
        //  one handed to us.
#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
        if (RTPLogger)
            {
            //INTEROP
            InteropOutput (RTPLogger,
                           (BYTE FAR*)(pBufs->buf),
                           (int)pBufs->len,
                           RTPLOG_SENT_PDU | RTP_PDU);
            }
#endif

#if defined(DBG_DWKIND)
        pRTPSession->dwKind |= (1<<17); // WSASendTo
#endif

#if defined(SIMULATE_RTP_LOSS) && defined(_DEBUG)
        // used only to test, final reatail/debug don't use any of
        // this

        DWORD tLen = 0;

        for(DWORD i = 0; i < dwBufCount; i++)
            tLen += pBufs[i].len;

        tLen += 8+20; // UDP+IP headers
        
        if (g_SendCredit == -1) {
            // first packet is sent
            g_SendCredit = BUCKET_SIZE - tLen;
            g_dwLastTime = GetTickCount(); 
        } else {

            DWORD curTime = GetTickCount();
            DWORD delta;
        
            if (curTime > g_dwLastTime)
                delta = curTime - g_dwLastTime;
            else
                delta = curTime + ((DWORD)-1 - g_dwLastTime) + 1;

            g_SendCredit += ((delta * g_targetByteRate) / 1000);
            
            g_dwLastTime = curTime;

            if (g_SendCredit > BUCKET_SIZE)
                g_SendCredit = BUCKET_SIZE; // bucket size
        
            if (g_SendCredit < tLen) {
                // drop packet (loss because taking too much bandwidth)
                dwStatus = WSAESOCKTNOSUPPORT;

                g_packetsDropped++;

                if ((curTime - g_LastTimeDropped) >= 3000) {

                    g_LastTimeDropped = curTime;
                    
                    RRCMDbgLog((
                            LOG_TRACE,
                            LOG_DEVELOP,
                            "RTP : WSASendTo() - Packet dropped %u",
                            g_packetsDropped
                        ));
                }
                // Reinstate the Apps WSAEVENT
                pXMTStruct = (PRTP_BFR_LIST)pOverlapped->hEvent;
                pOverlapped->hEvent = pXMTStruct->hEvent;
                
                // Return the struct to the free queue
                addToHeadOfList (&pRTPSession->pRTPFreeList,
                                 (PLINK_LIST)pXMTStruct,
                                 &pRTPSession->critSect);
                goto skipSend;
            } else {
                // send packet
                g_SendCredit -= tLen;
            }
        }
#endif
        dwStatus = RRCMws.sendTo (pSocket[SOCK_SEND],
                                  pBufs,
                                  dwBufCount,
                                  pNumBytesSent, 
                                  socketFlags,
                                  (PSOCKADDR)pTo,
                                  toLen,
                                  pOverlapped, 
                                  RTPTransmitCallback);

        // Check return code for the SendTo.  If an error, return 
        // lpOverlapped to original case and return the context 
        // association buffer
        if (dwStatus == SOCKET_ERROR) 
            {
            // WS2 did not complete immediately
            dwErrorStatus = WSAGetLastError();
#if defined(DBG_DWKIND)
            pRTPSession->dwKind |= (1<<18); // SOCKET_ERROR

            pRTPSession->dwKind |= (1<<19); // IO_PENDING
#endif

            if (dwErrorStatus != WSA_IO_PENDING) 
                {
#if defined(DBG_DWKIND)
                pRTPSession->dwKind &= ~(1<<19); // No IO_PENDING
#endif

                if (dwErrorStatus == WSAEWOULDBLOCK)
                    {
                    RRCM_DBG_MSG ("RTP : WSASendTo() - WSAEWOULDBLOCK",
                              dwErrorStatus, __FILE__, __LINE__, DBG_NOTIFY);
                    }
                else
                    {
                    RRCM_DBG_MSG ("RTP : WSASendTo()", dwErrorStatus, 
                                  __FILE__, __LINE__, DBG_NOTIFY);
                    }

                // Reinstate the Apps WSAEVENT
                pXMTStruct = (PRTP_BFR_LIST)pOverlapped->hEvent;
                pOverlapped->hEvent = pXMTStruct->hEvent;

                // Return the struct to the free queue
                addToHeadOfList (&pRTPSession->pRTPFreeList,
                                 (PLINK_LIST)pXMTStruct,
                                 &pRTPSession->critSect);
                }
            }
        
#if defined(SIMULATE_RTP_LOSS) && defined(_DEBUG)
        skipSend:
        ;
#endif
        }

    IN_OUT_STR ("RTP : Exit RTPSendTo()\n");

#if defined(DBG_DWKIND)
    pRTPSession->dwKind |= (1<<20); // End SendTo
#endif
    return (dwStatus);
    }


/*----------------------------------------------------------------------------
 * Function   : RTPTransmitCallback
 * Description: Callback routine from Winsock2  Handles any statistical
 *              processing required for RTCP.  Copies completion routine 
 *              from the application and substitutes its own.  
 *              Application's completion routine will be called after RTP's 
 *              completion routine gets called.
 * 
 * Input :  dwError:        I/O operation status. (Winsock-2 error code)
 *          cbTransferred:  Number of bytes transferred
 *          pOverlapped:    -> to overlapped structure
 *          dwFlags:        Flags
 *
 * Return: None
 ---------------------------------------------------------------------------*/
void CALLBACK RTPTransmitCallback (DWORD dwError,
                                   DWORD cbTransferred,
                                   LPWSAOVERLAPPED pOverlapped,
                                   DWORD dwFlags)
    {
    PRTP_SESSION    pRTPSession;
    PRTP_BFR_LIST   pXMTStruct;
    PSSRC_ENTRY     pSSRC;

    IN_OUT_STR ("RTP : Enter RTPTransmitCallback()\n");
    
    // The returning hEvent in the LPWSAOVERLAPPED struct contains the 
    // information mapping the session and the buffer.
    pXMTStruct = (PRTP_BFR_LIST)pOverlapped->hEvent;

    pRTPSession = (PRTP_SESSION)pXMTStruct->pSession;   

#if defined(DBG_DWKIND)
    pRTPSession->dwKind |= (1<<21); // SendCallback
#endif
    // Check return error
    if (dwError == 0) 
        {
        // Get pointer to 1st (our) entry in SSRC table for this session
        EnterCriticalSection(&pRTPSession->pRTCPSession->SSRCListCritSect);
        pSSRC = searchForMySSRC (
            (PSSRC_ENTRY)pRTPSession->pRTCPSession->XmtSSRCList.prev,
            pXMTStruct->pSession->pSocket[SOCK_RTCP]);
        LeaveCriticalSection(&pRTPSession->pRTCPSession->SSRCListCritSect);
        ASSERT (pSSRC);
                
        /* lock out access to this RTCP session variable */
        EnterCriticalSection (&pSSRC->critSect);

        // calculate statistics (-DWORD) for the CRSC entry defined 
        // in the RTP header (but we should remove it from the data structure)
        pSSRC->xmtInfo.dwNumBytesSent += (cbTransferred -
                                    (sizeof(RTP_HDR_T) - sizeof(DWORD)));

        pSSRC->xmtInfo.dwNumPcktSent++;
                
        /* unlock access */
        LeaveCriticalSection (&pSSRC->critSect);
        }
    else 
        {
#if defined(DBG_DWKIND)
        pRTPSession->dwKind |= (1<<22); // dwError != 0
#endif

        RRCM_DBG_MSG ("RTP : RTP Xmt Callback Error", dwError, 
                      __FILE__, __LINE__, DBG_ERROR);
        }

    // Reinstate the Apps WSAEVENT
    pOverlapped->hEvent = pXMTStruct->hEvent;
        
#if defined(DBG_DWKIND)
    pRTPSession->dwKind |= (1<<23); // Notification
#endif
    // And call the apps completion routine
    pXMTStruct->pfnCompletionNotification (dwError,
                                           cbTransferred,
                                           pOverlapped,
                                           dwFlags);

    // Return the struct to the free queue
    addToHeadOfList (&pRTPSession->pRTPFreeList,
                     (PLINK_LIST)pXMTStruct,
                     &pRTPSession->critSect);

#if defined(DBG_DWKIND)
    pRTPSession->dwKind |= (1<<24); // SetEvent
#endif
    // Signal completion
#if defined(DBG_DWKIND)
    if (!SetEvent(pRTPSession->hSendTo))
        pRTPSession->dwKind |= (1<<25); // SetEvent failed
#else
    SetEvent(pRTPSession->hSendTo);
#endif
    IN_OUT_STR ("RTP : Exit RTPTransmitCallback()\n");
#if defined(DBG_DWKIND)
    pRTPSession->dwKind |= (1<<26); // End callback
#endif
    }


/*----------------------------------------------------------------------------
 * Function   : saveWinsockContext
 * Description: Saves context for this buffer so that when a completion 
 *              routine returns with a handle, we know exactly what 
 *              buffer/stream this refers to.
 * 
 * Input :  pOverlapped:        -> to overlapped structure
 *          pFunc:              -> to completion function
 *          pSession:           -> to session
 *          RTPsocket:          RTP socket descriptor
 *
 * Return: RRCM_NoError     = OK.
 *         Otherwise(!=0)   = Check RRCM.h file for references.
 ---------------------------------------------------------------------------*/
DWORD CALLBACK saveWinsockContext(LPWSAOVERLAPPED pOverlapped,
                                  LPWSAOVERLAPPED_COMPLETION_ROUTINE pFunc, 
                                  PRTP_SESSION pSession)
    {
    DWORD           dwStatus = RRCM_NoError;
    PRTP_BFR_LIST   pNewCell;
    DWORD           numCells = NUM_FREE_CONTEXT_CELLS;

    IN_OUT_STR ("RTP : Enter saveWinsockContext()\n");

    // Get a buffer from the free list
    pNewCell = (PRTP_BFR_LIST)removePcktFromTail (
                                (PLINK_LIST)&pSession->pRTPFreeList,
                                &pSession->critSect);
    if (pNewCell == NULL)
        {
        // try to reallocate some free cells
        if (pSession->dwNumTimesFreeListAllocated <= MAXNUM_CONTEXT_CELLS_REALLOC)
            {
            // increment the number of reallocated times even if the realloc
            //   fails next. Will avoid trying to realloc of a realloc problem
            pSession->dwNumTimesFreeListAllocated++;

            if (allocateLinkedList (&pSession->pRTPFreeList, 
                                    pSession->hHeapFreeList,
                                    &numCells,
                                    sizeof(RTP_BFR_LIST),
                                    &pSession->critSect) == RRCM_NoError)
                {                               
                pNewCell = (PRTP_BFR_LIST)removePcktFromTail (
                                            (PLINK_LIST)&pSession->pRTPFreeList,
                                            &pSession->critSect);
                }
            }
        }

    if (pNewCell != NULL) {
        // Initialize the params
        // clear the overlapped structure
        ZeroMemory(pOverlapped, sizeof(*pOverlapped));
        //pNewCell->hEvent = pOverlapped->hEvent;
        pNewCell->pfnCompletionNotification = pFunc;
        pNewCell->pSession = pSession;
        
        // Overwrite the hEvent handed down from app.  
        // Will return the real one when the completion routine is called
        pOverlapped->hEvent = (HANDLE)pNewCell;
        }
    else
        dwStatus = RRCMError_RTPResources;

    IN_OUT_STR ("RTP : Exit saveWinsockContext()\n");
    
    return (dwStatus);
    }


/*----------------------------------------------------------------------------
 * Function   : updateNtpRtpTimeStampOffset
 * Description: Update the NTP to RTP timestamp offset. This offset will be 
 *              send by the next RTCP Sender Report packet.
 * 
 * Input :  pRTPhdr:        -> to RTP header
 *          pSSRC:          -> to SSRC
 *
 * Return:  None
 ---------------------------------------------------------------------------*/
#if 0
void updateNtpRtpTimeStampOffset (RTP_HDR_T *pRTPHeader,
                                  PSSRC_ENTRY pSSRC)
    {
    DWORD   dwHost;
    DWORD   dwTime = 0;

    IN_OUT_STR ("RTP : Enter updateNtpRtpTimeStampOffset()\n");

    // get the current time & convert it in samples according to stream freq.
    if (pSSRC->dwStreamClock)
        dwTime = timeGetTime () * (pSSRC->dwStreamClock / 1000);

    // get the RTP timestamp
    RRCMws.ntohl (pSSRC->RTPsd, pRTPHeader->ts, &dwHost);

    // get the offset between RTP timestamp & the current time
    pSSRC->xmtInfo.dwRTPtimeStampOffset = dwTime - dwHost;

    IN_OUT_STR ("RTP : Exit updateNtpRtpTimeStampOffset()\n");
    }
#endif



// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\setup\makefile.inc ===
.SUFFIXES: .reg

.reg{$(TARGETPATH)\$(TARGET_DIRECTORY)}.reg:
    copy /v $< $@

$(TARGETPATH)\$(TARGET_DIRECTORY)\dxmrtp.reg : dxmrtp.reg
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rrcm\rtp\rtp_hash.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTP_HASH.C
 * Product:     RTP/RTCP implementation
 * Description: Associate sockets/streams with their RTP Session in a hash table
 *
 * $Workfile:   RTP_HASH.CPP  $
 * $Author:   CMACIOCC  $
 * $Date:   13 Feb 1997 14:46:10  $
 * $Revision:   1.3  $
 * $Archive:   R:\rtp\src\rrcm\rtp\rtp_hash.cpv  $
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/

    
#include "rrcm.h"


/*---------------------------------------------------------------------------
/                           Global Variables
/--------------------------------------------------------------------------*/            
extern PRTP_CONTEXT pRTPContext;


/*---------------------------------------------------------------------------
/                           External Variables
/--------------------------------------------------------------------------*/





/*----------------------------------------------------------------------------
 * Function   : createHashEntry
 * Description: Adds stream unique socket ID to hash table.  
 * 
 * Input :  pSession    :  RTP Session containing the stream
 *
 * Return: RRCM_NoError     = OK.
 *         Otherwise(!=0)   = Initialization Error.
 * NOTE: critSect removed as this is called from within the same critSect
 ---------------------------------------------------------------------------*/
DWORD createHashEntry (PRTP_SESSION pSession)
    {
    PRTP_HASH_LIST  pNewCell;
    DWORD           hashEntry;
    DWORD           dwStatus = RRCM_NoError;
    DWORD           hashTableEntries = NUM_RTP_HASH_SESS;

    IN_OUT_STR ("RTP : Enter createHashEntry()\n");
    
    // Get a PRTP Buffer from the free list and assign the values
    pNewCell = (PRTP_HASH_LIST)removePcktFromTail(
                    (PLINK_LIST)&pRTPContext->pRTPHashList,
                    NULL);

    if (pNewCell == NULL)
        {

        if ( allocateLinkedList (&pRTPContext->pRTPHashList, 
                                 pRTPContext->hHashFreeList,
                                 &hashTableEntries,
                                 sizeof(RTP_HASH_LIST),
                                 NULL) == RRCM_NoError)
    
        {                               
            pNewCell = (PRTP_HASH_LIST)removePcktFromTail (
                                        (PLINK_LIST)&pRTPContext->pRTPHashList,
                                        NULL);
            }
        }

    if (pNewCell != NULL)
        {
        pNewCell->pSession  = pSession;

        // Get entry in table
        hashEntry = (DWORD)(pSession->pSocket[SOCK_RTCP] & HASH_MODULO);

        // Just insert the entry at the head of list
        addToHeadOfList (
            (PLINK_LIST)&pRTPContext->RTPHashTable[hashEntry].RTPHashLink,
            (PLINK_LIST)pNewCell,
            NULL);
        }
    else
        dwStatus = RRCMError_RTPResources;

    IN_OUT_STR ("RTP : Exit createHashEntry()\n");
    
    return (dwStatus);
    }


/*----------------------------------------------------------------------------
 * Function   : deleteHashEntry
 * Description: Searches hash table based on unique socket.  Deletes
 *              session from hash table and returns buffer to free list
 * 
 * Input : pSession : RTP session
 *
 *
 * Return: RRCM_NoError     = OK.
 *         Otherwise(!=0)   = Deletion Error.
 * NOTE: critSect removed as this is called from within the same critSect
 ---------------------------------------------------------------------------*/
DWORD deleteHashEntry (PRTP_SESSION pSession)
    {
    PRTP_HASH_LIST  pNewCell;
    DWORD           hashEntry;
    DWORD           dwStatus = RRCMError_RTPStreamNotFound;

    IN_OUT_STR ("RTP : Enter deleteHashEntry()\n");
    
    // Get entry in table
    SOCKET RTCPsocket = pSession->pSocket[SOCK_RTCP];
    hashEntry = (DWORD)(RTCPsocket & HASH_MODULO);

    // Search for entry in table.  if found, remove from RTPHashTable and insert
    //  back in free list
    for (pNewCell = (PRTP_HASH_LIST)pRTPContext->
             RTPHashTable[hashEntry].RTPHashLink.prev;
         pNewCell != NULL;
         pNewCell = (PRTP_HASH_LIST)pNewCell->RTPHashLink.next) 
        {
        if (pNewCell->pSession->pSocket[SOCK_RTCP] == RTCPsocket) {

            if (pNewCell->RTPHashLink.prev == NULL) 
                {
                // first entry in the queue - update the tail pointer
                pRTPContext->RTPHashTable[hashEntry].RTPHashLink.prev = 
                    pNewCell->RTPHashLink.next;

                // check if only one entry in the list 
                if (pNewCell->RTPHashLink.next == NULL)
                    pRTPContext->RTPHashTable[hashEntry].RTPHashLink.next = NULL;
                else
                    (pNewCell->RTPHashLink.next)->prev = NULL;
                }
            else if (pNewCell->RTPHashLink.next == NULL) 
                {
                // last entry in the queue - update the head pointer
                // this was the last entry in the queue
                pRTPContext->RTPHashTable[hashEntry].RTPHashLink.next = 
                    pNewCell->RTPHashLink.prev;

                (pNewCell->RTPHashLink.prev)->next = NULL;
                }
            else
                {
                // in the middle of the list - link around it
                (pNewCell->RTPHashLink.prev)->next = pNewCell->RTPHashLink.next;
                (pNewCell->RTPHashLink.next)->prev = pNewCell->RTPHashLink.prev;
                }
    

            addToHeadOfList ((PLINK_LIST)&pRTPContext->pRTPHashList,
                             (PLINK_LIST)pNewCell,
                             NULL);
            
            dwStatus = RRCM_NoError;
            
            break;
            }
        }

    if (dwStatus != RRCM_NoError) 
        {
        RRCM_DBG_MSG ("RTP : ERROR - DeleteHashEntry()", 0, 
                      __FILE__, __LINE__, DBG_ERROR);
        }

    IN_OUT_STR ("RTP : Exit deleteHashEntry()\n");
    
    return (dwStatus);
    }


/*----------------------------------------------------------------------------
 * Function   : findSessionID
 * Description: Searches hash table based on unique socket to identify session ID
 * 
 * Input : socket: unique socket ID for stream
 *
 *
 * Return: Session ptr  = OK.
 *         NULL         = Search Error.
 ---------------------------------------------------------------------------*/
PRTP_SESSION findSessionID(SOCKET *pSocket, PCRITICAL_SECTION pCritSect)
{
    PRTP_HASH_LIST  pNewCell;
    DWORD           hashEntry;
    PRTP_SESSION    pSession = NULL;

    IN_OUT_STR ("RTP : Enter findSessionID()\n");
    
    // Get entry in tablert, use the RTCP socket becasue the recv or
    // send RTP socket may in some cases be 0
    hashEntry = (DWORD)(pSocket[SOCK_RTCP] & HASH_MODULO);

    if (pCritSect)
        EnterCriticalSection(pCritSect);
    // Search for entry in table.  
    // If found, remove from RTPHashTable and insert back in free list
    for (pNewCell = (PRTP_HASH_LIST)pRTPContext->
             RTPHashTable[hashEntry].RTPHashLink.prev;
         pNewCell != NULL;
         pNewCell =  (PRTP_HASH_LIST)pNewCell->RTPHashLink.next) {

        PRTP_SESSION pSessionAux = pNewCell->pSession;
        DWORD match = 0;
        DWORD match_bit = 0x1;
        
        for(DWORD s = SOCK_RECV; s <= SOCK_RTCP; s++) {

            if (!pSessionAux->pSocket[s] || !pSocket[s])
                match |= match_bit;
            else if (pSessionAux->pSocket[s] == pSocket[s])
                match |= match_bit;
            else
                break; // they don't match
            
            match_bit <<= 1;
        }

        if (match == 0x7) {
            // Session already exists
            pSession = pSessionAux;
            break;
        }
    }
    
#if defined(_DEBUG) 
    if (!pSession) {
        char str[128];
        
        RRCMDbgLog((
                LOG_TRACE,
                LOG_DEVELOP,
                "findSessionID(%d,%d,%d): not found",
                pSocket[SOCK_RECV],
                pSocket[SOCK_SEND],
                pSocket[SOCK_RTCP]
            ));

        for (DWORD i=0; i < 256; i++) {
            for (pNewCell = (PRTP_HASH_LIST)pRTPContext->
                     RTPHashTable[i].RTPHashLink.prev;
                 pNewCell != NULL;
                 pNewCell =  (PRTP_HASH_LIST)pNewCell->RTPHashLink.next) {

                RRCMDbgLog((
                        LOG_TRACE,
                        LOG_DEVELOP,
                        "{[%d,0x%X]: %d, %d, %d, 0x%08X}",
                        i, i,
                        pNewCell->pSession->pSocket[SOCK_RECV],
                        pNewCell->pSession->pSocket[SOCK_SEND],
                        pNewCell->pSession->pSocket[SOCK_RTCP],
                        pNewCell->pSession
                    ));
            }
        }
    }
#endif
    
    if (pCritSect)
        LeaveCriticalSection(pCritSect);

    IN_OUT_STR ("RTP : Exit findSessionID()\n");
    
    return (pSession); 
}

PRTP_SESSION findSessionID2(SOCKET *pSocket, PCRITICAL_SECTION pCritSect)
{
    PRTP_HASH_LIST  pNewCell;
    DWORD           hashEntry;
    PRTP_SESSION    pSession = NULL;

    IN_OUT_STR ("RTP : Enter findSessionID()\n");
    
    // Get entry in tablert, use the RTCP socket becasue the recv or
    // send RTP socket may in some cases be 0
    hashEntry = (DWORD)(pSocket[SOCK_RTCP] & HASH_MODULO);

    if (pCritSect)
        EnterCriticalSection(pCritSect);
    // Search for entry in table.  
    // If found, remove from RTPHashTable and insert back in free list
    for (pNewCell = (PRTP_HASH_LIST)pRTPContext->
             RTPHashTable[hashEntry].RTPHashLink.prev;
         pNewCell != NULL;
         pNewCell =  (PRTP_HASH_LIST)pNewCell->RTPHashLink.next) {

        PRTP_SESSION pSessionAux = pNewCell->pSession;
        DWORD match = 0;
        DWORD match_bit = 0x1;
        
        for(DWORD s = SOCK_RECV; s <= SOCK_RTCP; s++) {

            if (!pSessionAux->pSocket[s] || !pSocket[s])
                match |= match_bit;
            else if (pSessionAux->pSocket[s] == pSocket[s])
                match |= match_bit;
            else
                break; // they don't match
            
            match_bit <<= 1;
        }

        if (match == 0x7) {
            // Session already exists
            pSession = pSessionAux;
            break;
        }
    }
    
    if (pCritSect)
        LeaveCriticalSection(pCritSect);

    IN_OUT_STR ("RTP : Exit findSessionID()\n");
    
    return (pSession); 
}

#if 0
PRTP_SESSION addRefSessionID(SOCKET socket, DWORD dwKind, long *MaxShare)
{
    PRTP_HASH_LIST  pNewCell;
    DWORD           hashEntry;
    PRTP_SESSION    pSession = NULL;

    // Get entry in tablert
    hashEntry = socket & HASH_MODULO;

    // Search for entry in table.  
    // If found, remove from RTPHashTable and insert back in free list
    for (pNewCell = (PRTP_HASH_LIST)pRTPContext->
             RTPHashTable[hashEntry].RTPHashLink.prev;
         pNewCell != NULL;
         pNewCell =  (PRTP_HASH_LIST)pNewCell->RTPHashLink.next) {

        if (pNewCell->RTPsocket == socket) {
            // Session already exists
            DWORD k;
            
            for(k = RTP_KIND_FIRST; k < RTP_KIND_LAST; k++) {
                if ( (dwKind & (1<<k) & pNewCell->dwKind) &&
                     pNewCell->RefCount[k] >= MaxShare[k] ) {
                    // No more shares availables for this socket
#if defined(_DEBUG)                 
                    char Str[256];
                    sprintf(Str,
                            "RTP Error: Socket:%d Kind:%d/%d "
                            "Share(%d,%d)/(%d,%d)",
                            pNewCell->RTPsocket, dwKind, pNewCell->dwKind,
                            MaxShare[0], MaxShare[1],
                            pNewCell->RefCount[0], pNewCell->RefCount[1]);
                    RRCM_DEV_MSG(Str, 0, __FILE__, __LINE__, DBG_NOTIFY);
#endif                  
                    return(pSession); // NULL
                }
            }

            for(k = RTP_KIND_FIRST; k < RTP_KIND_LAST; k++) {
                if ( dwKind & (1<<k) ) {
                    InterlockedIncrement(&pNewCell->RefCount[k]);
                    pNewCell->dwKind |= (1<<k);
                    pNewCell->pSession->dwKind |= (1<<k);
                    return(pNewCell->pSession);
                }
            }
            
            break;
        }
    }

    return (pSession);
}
#endif

// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rrcm\rtp\rtprecv.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTPRECV.C
 * Product:     RTP/RTCP implementation
 * Description: Provides Receive Data Functionality.
 *
 * $Workfile:   rtprecv.cpp  $
 * $Author:   dputzolu  $
 * $Date:   Jun 17 1997 14:16:40  $
 * $Revision:   1.7  $
 * $Archive:   R:/rtp/src/rrcm/rtp/rtprecv.cpv  $
 *
 * This listing is supplied under the terms 
 * of a license agreement with Intel Corporation and
 * many not be copied nor disclosed except in accordance
 * with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/


#include "rrcm.h"


/*---------------------------------------------------------------------------
/                           Global Variables
/--------------------------------------------------------------------------*/            



/*---------------------------------------------------------------------------
/                           External Variables
/--------------------------------------------------------------------------*/
extern PRTP_CONTEXT     pRTPContext;
extern RRCM_WS          RRCMws;

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
extern LPInteropLogger RTPLogger;
#endif


/*----------------------------------------------------------------------------
 * Function   : RTPRecvFrom
 * Description: Intercepts receive requests from app.  Handles any statistical
 *              processing required for RTCP.  Copies completion routine 
 *              from app and substitutes its own.  Apps completion routine
 *              will be called after RTP's completion routine gets called.
 * 
 * Input :  pSocket:            RTP/RTCP socket descriptors
 *          pBuffers:           -> to WSAbuf structure
 *          dwBufferCount:      Buffer count in WSAbuf structure
 *          pNumBytesRecvd:     -> to number of bytes received
 *          pFlags:             -> to flags
 *          pFrom:              -> to the source address
 *          pFromLen:           -> to source address length
 *          pOverlapped:        -> to overlapped I/O structure
 *          pCompletionRoutine: -> to completion routine
 *
 * Return: RRCM_NoError     = OK.
 *         Otherwise(!=0)   = Check RRCM.h file for references.
 ---------------------------------------------------------------------------*/
RRCMSTDAPI RTPRecvFrom (SOCKET *pSocket,
                        LPWSABUF pBuffers,
                        DWORD  dwBufferCount,
                        LPDWORD pNumBytesRecvd, 
                        LPDWORD pFlags,
                        PSOCKADDR pFrom,
                        LPINT pFromlen,
                        LPWSAOVERLAPPED pOverlapped, 
                        LPWSAOVERLAPPED_COMPLETION_ROUTINE pCompletionRoutine)
    {
    int                 dwStatus = RRCM_NoError;
    int                 dwError;
    PRTP_SESSION        pRTPSession;
    RTP_BFR_LIST       *pNewRTPBfrList;

    IN_OUT_STR ("RTP : Enter RTPRecvFrom()\n");

    // If RTP context doesn't exist, report error and return.
    if (pRTPContext == NULL) 
        {
        RRCM_DEV_MSG ("RTP : ERROR - No RTP Instance", 0, 
                        __FILE__, __LINE__, DBG_CRITICAL);
        IN_OUT_STR ("RTP : Exit RTPRecvFrom()\n");

        return (MAKE_RRCM_ERROR(RRCMError_RTPInvalid));
        }

    // Search for the proper session based on incoming socket
    pRTPSession = findSessionID2(pSocket, &pRTPContext->critSect);

    if (pRTPSession == NULL)
        {
#if defined(_DEBUG)
        char msg[128];
        wsprintf(msg, "RTP : ERROR - Invalid RTP session: socket:%d",
                 pSocket[SOCK_RECV]);
        RRCM_DEV_MSG (msg, 0, __FILE__, __LINE__, DBG_CRITICAL);
        IN_OUT_STR ("RTP : Exit RTPRecvFrom()\n");
#endif
        return (MAKE_RRCM_ERROR(RRCMError_RTPInvalidSession));
        }

    // We need to associate a completionRoutine's lpOverlapped with a 
    // session. We look at each buffer and associate a socket so when 
    // the completion routine is called, we can pull out the socket.
    pNewRTPBfrList = (PRTP_BFR_LIST)
        removePcktFromTail((PLINK_LIST)&pRTPSession->pRTPFreeList,
                           &pRTPSession->critSect);

    if (!pNewRTPBfrList) {
        if ( !(pNewRTPBfrList = getNewRTPBfrList(pRTPSession)) ) {
            
            RRCM_DBG_MSG ("RTP : ERROR - Out of resources...", 0, 
                          __FILE__, __LINE__, DBG_NOTIFY);
            IN_OUT_STR ("RTP : Exit RTPRecvFrom()\n");
            
            return(MAKE_RRCM_ERROR(RRCMError_RTPResources));
        }
    }

    //++++++++++
    // Initialize the params
    pNewRTPBfrList->hEvent        = pOverlapped->hEvent;
    pNewRTPBfrList->pBuffer       = pBuffers;
    pNewRTPBfrList->pSession      = pRTPSession;
    pNewRTPBfrList->pFlags        = pFlags;
    pNewRTPBfrList->pFrom           = pFrom;
    pNewRTPBfrList->pFromlen        = pFromlen;
    pNewRTPBfrList->dwBufferCount   = dwBufferCount;
    pNewRTPBfrList->pNumBytesRecvd  = pNumBytesRecvd;
    pNewRTPBfrList->pfnCompletionNotification = pCompletionRoutine;

    // save user's overlapped pointer (we are going to use our own struct)
    pNewRTPBfrList->pOverlapped = pOverlapped;
    
    // Overwrite the hEvent handed down from app.  
    // Will return the real one when the completion routine is called
    pNewRTPBfrList->Overlapped.hEvent = (WSAEVENT)pNewRTPBfrList;
    pNewRTPBfrList->dwKind = RTP_KIND_BIT(RTP_KIND_RECV);

    // Put buffer list item in used list
    addToTailOfList(&pRTPSession->pRTPUsedListRecv,
                    &pNewRTPBfrList->RTPBufferLink,
                    &pRTPSession->critSect);

    //++++++++++

    // Forward to winsock, substituting our completion routine for the
    //  one handed to us.
    
    do {
        pNewRTPBfrList->Overlapped.Internal = 0;

        dwStatus = RRCMws.recvFrom (pSocket[SOCK_RECV],
                                    pBuffers,
                                    dwBufferCount,
                                    pNumBytesRecvd, 
                                    pFlags,
                                    pFrom,
                                    pFromlen,
                                    &pNewRTPBfrList->Overlapped,
                                    RTPReceiveCallback);
        // Ugly hack to avoid the WSAECONNRESET received whenever
        // a packet is sent to a PEER and there is no socket
        // listening us (local sender).
        
        // Don't care to do anything with void packets received resulting
        // of the WSAECONNRESET (nobody listening to us) or
        // a large packet not fiting into the buffer we passed.
        //
        // The upper layer could/should? be informed about this.
    } while(dwStatus != 0 &&
            ( ((dwError = WSAGetLastError()) == WSAECONNRESET) ||
              (dwError == WSAEMSGSIZE) )   );
    
    // Check if Winsock Call succeeded
    if (dwStatus == 0) {
        InterlockedIncrement(&pRTPSession->lNumRecvIoPending);
    } else {
        // If serious error, the receive request won't proceed so
        //  we must undo all our work

        if (dwError == WSA_IO_PENDING) {
            InterlockedIncrement(&pRTPSession->lNumRecvIoPending);
        } else {
            // Reinstate the Apps WSAEVENT
            // pOverlapped->hEvent = pNewRTPBfrList->hEvent;

            RRCM_DBG_MSG ("RTP : ERROR - WSARecvFrom()", dwError, 
                          __FILE__, __LINE__, DBG_ERROR);

            // Move from used list into free list
            movePcktFromQueue(&pRTPSession->pRTPFreeList,
                              &pRTPSession->pRTPUsedListRecv,
                              (PLINK_LIST)pNewRTPBfrList,
                              &pRTPSession->critSect);
            
            pNewRTPBfrList->Overlapped.Internal |= 0xfeee0000;
        }
    }
    
    IN_OUT_STR ("RTP : Exit RTPRecvFrom()\n");

    return (dwStatus);
    }


/*----------------------------------------------------------------------------
 * Function   : RTPReceiveCallback
 * Description: Callback routine from Winsock2  Handles any statistical
 *              processing required for RTCP.  Copies completion routine 
 *              from app and substitutes its own.  Apps completion routine
 *              will be called after RTP's completion routine gets called.
 * 
 * Input :      dwError:        I/O completion error code
 *              cbTransferred:  Number of bytes transferred
 *              pOverlapped:    -> to overlapped I/O structure
 *              dwFlags:        Flags
 *
 * !!! IMPORTANT NOTE !!!
 *   Currently assumes CSRC = 0
 * !!! IMPORTANT NOTE !!!
 *
 * Return: None
 ---------------------------------------------------------------------------*/
void CALLBACK RTPReceiveCallback (DWORD dwError,
                                  DWORD cbTransferred,
                                  LPWSAOVERLAPPED pOverlapped,
                                  DWORD dwFlags)
    {
    PRTP_SESSION        pRTPSession;
    RTP_HDR_T           *pRTPHeader;
    PRTP_BFR_LIST       pRTPBfrList;
    PSSRC_ENTRY         pSSRC = NULL;
    DWORD               dwSSRC;
    DWORD               oldSSRC;
    PSSRC_ENTRY         pMySSRC;
    DWORD               dwRequeue = 0;
    struct sockaddr_in  *pSSRCadr;

    IN_OUT_STR ("RTP : Enter RTPReceiveCallback()\n");

    // The returning hEvent in the LPWSAOVERLAPPED struct contains the 
    // information mapping the session and the buffer.
    pRTPBfrList = (PRTP_BFR_LIST)pOverlapped->hEvent;
    pRTPSession = pRTPBfrList->pSession;
    
    if ( (pRTPSession->dwKind & RTP_KIND_BIT(RTP_KIND_SHUTDOWN)) ||
         (pRTPBfrList->dwKind & RTP_KIND_BIT(RTP_KIND_SHUTDOWN)) ||
         (dwError && (dwError == WSA_OPERATION_ABORTED ||
                      dwError == WSAEINTR)) ) {
        // Shuting down the session
        // do nothing
#if defined(_DEBUG)         
        RRCMDbgLog((
                LOG_TRACE,
                LOG_DEVELOP,
                "RTP[0x%X] : Recv flushed: Socket:%d, Pending:%d",
                pRTPSession,
                pRTPSession->pSocket[SOCK_RECV],
                pRTPSession->lNumRecvIoPending-1
            ));
#endif
        
        // Return the struct to the free queue
        movePcktFromQueue(&pRTPSession->pRTPFreeList,
                          &pRTPSession->pRTPUsedListRecv,
                          (PLINK_LIST)pRTPBfrList,
                          &pRTPSession->critSect);

        pRTPBfrList->Overlapped.Internal |= 0xfeee0000;

        InterlockedDecrement(&pRTPSession->lNumRecvIoPending);
        
        return;
    }
    
    // Search for the proper session based on incoming socket
    pRTPSession = (PRTP_SESSION)pRTPBfrList->pSession;
    ASSERT (pRTPSession);

    // Packet too short
    if (cbTransferred < sizeof(RTP_HDR_T)) {

        if (dwError == WSAECONNRESET) {
            // No one listens, and the host has received an ICMP
            // message of destination. We may want to pass this up
            // to the application, or prevent ourselves from sending
            // data, but HOW do we know when someone is listening to
            // start again sending data?
        }

#if defined(_DEBUG) && defined(DEBUG_RRCM)
        char str[128];
        wsprintf(str,"RTP[0x%X] : Recv packet too short: "
                 "len:%d, Err:%d",
                 pRTPSession, cbTransferred, dwError);
        RRCM_DBG_MSG (str, 0, __FILE__, __LINE__, DBG_NOTIFY);
#endif
        RTPpostRecvBfr(dwError, cbTransferred, pOverlapped, dwFlags);
        return;
    }

    // If any error, repost the user's receive buffer
    if (dwError && (dwError != WSAEMSGSIZE))
        {
        // don't report closeSocket() as an error when the application
        //  have some pending buffers remaining
        if (dwError != 65534)
            {
            RRCM_DEV_MSG ("RTP : RCV Callback", dwError, 
                          __FILE__, __LINE__, DBG_ERROR);
            }

        // notify the user if an error occured, so he can free up 
        // its receive resources. The byte count is set to 0

        // Reinstate the AppSs WSAEVENT
        // pOverlapped->hEvent = pRTPBfrList->hEvent;
            
        // And call the apps completion routine
        pRTPBfrList->pfnCompletionNotification (dwError,
                                               cbTransferred,
                                               pRTPBfrList->pOverlapped,
                                               dwFlags);

        // Return the struct to the free queue
        movePcktFromQueue(&pRTPSession->pRTPFreeList,
                          &pRTPSession->pRTPUsedListRecv,
                          (PLINK_LIST)pRTPBfrList,
                          &pRTPSession->critSect);

        pRTPBfrList->Overlapped.Internal |= 0xfeee0000;

        IN_OUT_STR ("RTP : Exit RTPReceiveCallback()\n");
        InterlockedDecrement(&pRTPSession->lNumRecvIoPending);
        return;
        }

    // Perform validity checking
    pRTPHeader = (RTP_HDR_T *)pRTPBfrList->pBuffer->buf;
    ASSERT (pRTPHeader);

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
    if (RTPLogger)
        {
        //INTEROP
        InteropOutput (RTPLogger,
                       (BYTE FAR*)(pRTPBfrList->pBuffer->buf),
                       (int)cbTransferred,
                       RTPLOG_RECEIVED_PDU | RTP_PDU);
        }
#endif

    // Check RTP Headers for validity.  If not valid, then repost buffers 
    // to the network layer for a new receive.
    if ((dwError == 0) && validateRTPHeader (pRTPHeader)) 
        {
        // Get pointer to SSRC entry table for this session
        // If SSRC in packet is > 1/2 MAX_RANGE of DWORD, start search from
        //  tail of SSRC list, otherwise, start from front
        dwSSRC = ntohl(pRTPHeader->ssrc);
                        
        EnterCriticalSection(&pRTPSession->pRTCPSession->SSRCListCritSect);
        if (dwSSRC > MAX_DWORD/2) 
            {
            pSSRC = searchforSSRCatTail (
                (PSSRC_ENTRY)pRTPSession->pRTCPSession->RcvSSRCList.prev,
                dwSSRC,
                NULL);
            }
        else 
            {
            pSSRC = searchforSSRCatHead (
                (PSSRC_ENTRY)pRTPSession->pRTCPSession->RcvSSRCList.next,
                dwSSRC,
                NULL);
            }

        // get my own SSRC used for this stream
        pMySSRC = searchForMySSRC (
            (PSSRC_ENTRY)pRTPSession->pRTCPSession->XmtSSRCList.prev,
            pRTPBfrList->pSession->pSocket[SOCK_RTCP]);
        LeaveCriticalSection(&pRTPSession->pRTCPSession->SSRCListCritSect);

        ASSERT (pMySSRC);

        DWORD fNewSource = 0;


        // This code only to track the multicast packets that are not
        // correctly filterd by WS2 when mcast loopback is disabled
#if 0 && defined(_DEBUG)
        if (pMySSRC->SSRC == dwSSRC) {
            unsigned char *addr;
            char str[40];

            addr = (unsigned char *)
                &(((PSOCKADDR_IN)pRTPBfrList->pFrom)->sin_addr);
            
            sprintf(str, "RTP loopback from: %d.%d.%d.%d",
                    addr[0],addr[1],addr[2],addr[3]);
            
            DebugBreak();
        }
#endif

        // is this SSRC already known on the receive list ?
        if (pSSRC == NULL) 
        {
            // Rather allow loop-back and leave up to WS2 to enable/disable
            // multicast loop-back
#if 0           
            // don't create an entry for my own packet looping back on 
            // a mcast group where loopback has not been turned off
            if (pMySSRC->SSRC != dwSSRC)
            {
#endif              
                // new party heard from. Create an entry for it
                pSSRC = createSSRCEntry (dwSSRC,
                                         pRTPSession->pRTCPSession,
                                         pRTPBfrList->pFrom,
                                         (DWORD)*pRTPBfrList->pFromlen,
                                         UPDATE_RTP_ADDR,
                                         FALSE);

                // notify the application if it's not coming from the 
                //  local loopback address 127.0.0.1
                if (pSSRC) {
                    pSSRCadr = (PSOCKADDR_IN)pRTPBfrList->pFrom;
                    if (pSSRCadr->sin_addr.s_addr != 0x0100007F)
                    {
                        fNewSource = 1;
                    }
                } else {
                    // could not create entry, either low in resources
                    // or SSRC is in the BYE list
                    dwRequeue = 1;
                }
#if 0               
            }
            else
                {
                // my own SSRC received back

                // A collision occurs if the SSRC in the rcvd packet is 
                // equal to mine, and the network transport address is
                // different from mine.
                // A loop occurs if after a collision has been resolved the
                // SSRC collides again from the same source transport address

                pSSRCadr = (PSOCKADDR_IN)&pMySSRC->from;
                if (((PSOCKADDR_IN)pRTPBfrList->pFrom)->sin_addr.S_un.S_addr !=
                      pSSRCadr->sin_addr.S_un.S_addr)
                {

                    // check if the source address is already in the 
                    // conflicting table. This identifes that somebody out 
                    // there is looping pckts back to me
                    if (RRCMChkCollisionTable (pRTPBfrList, pMySSRC))
                        {
                        RRCM_DBG_MSG ("RTP : Loop Detected ...", 0, NULL, 0,
                                        DBG_NOTIFY);

                        // loop already known
                        dwRequeue |= SSRC_LOOP_DETECTED;
                        }
                    else
                        {
                        RRCM_DBG_MSG ("RTP : Collision Detected ...", 0, NULL, 0,
                                        DBG_NOTIFY);

                        // create new entry in conflicting address table 
                        RRCMAddEntryToCollisionTable (pRTPBfrList, pMySSRC);

                        // send RTCP BYE packet w/ old SSRC 
                        RTCPsendBYE (pMySSRC, "Loop/collision detected");

                        // select new SSRC
                        oldSSRC = pMySSRC->SSRC;
                        EnterCriticalSection(&pMySSRC->pRTCPses->
                                             SSRCListCritSect);
                        dwSSRC  = getSSRC (pMySSRC->pRTCPses->RcvSSRCList, 
                                           pMySSRC->pRTCPses->XmtSSRCList);
                        LeaveCriticalSection(&pMySSRC->pRTCPses->
                                             SSRCListCritSect);

                        EnterCriticalSection (&pMySSRC->critSect);
                        pMySSRC->SSRC = dwSSRC;
                        LeaveCriticalSection (&pMySSRC->critSect);

                        // create new entry w/ old SSRC plus actual source
                        // transport address in our receive list side, so the 
                        // packet actually en-route will be dealt with
                        createSSRCEntry (oldSSRC,
                                         pRTPSession->pRTCPSession,
                                         (PSOCKADDR)pRTPBfrList->pFrom,
                                         (DWORD)*pRTPBfrList->pFromlen,
                                         FALSE);

                        // notify application if interested
                        RRCMnotification (RRCM_LOCAL_COLLISION_EVENT, 
                                          pMySSRC, oldSSRC, pMySSRC->SSRC);

                        // copy back to dwSSRC the SSRC from the
                        // recently SSRC entry created
                        dwSSRC = oldSSRC;
                        
                        // loop already known
                        dwRequeue |= SSRC_COLLISION_DETECTED;
                        }

                }
                else
                    {
                    // own packet looped back because the sender joined the
                    // multicast group and loopback is not turned off
                    dwRequeue |= MCAST_LOOPBACK_NOT_OFF;
                    }

                }
#endif          
            }
        else if (pSSRC->dwSSRCStatus & THIRD_PARTY_COLLISION)
            {
            // this SSRC is marked as colliding. Reject the data
            dwRequeue = THIRD_PARTY_COLLISION;
            }

        if ((pSSRC != NULL)  && (dwRequeue == 0))
            {
            if (!(pSSRC->dwSSRCStatus & NETWK_RTPADDR_UPDATED))
                saveNetworkAddress(pSSRC,
                                   pRTPBfrList->pFrom,
                                   *(pRTPBfrList->pFromlen),
                                   UPDATE_RTP_ADDR);
            
            // notify application if interested
            if (fNewSource)
                RRCMnotification (RRCM_NEW_SOURCE_EVENT, pSSRC, dwSSRC, 
                                  pRTPHeader->pt);

            // do all the statistical updating stuff
            updateRTPStats (pRTPHeader, pSSRC, cbTransferred);

            // update the payload type for this SSRC
            pSSRC->PayLoadType = pRTPHeader->pt;

            // Reinstate the AppSs WSAEVENT
            // pOverlapped->hEvent = pRTPBfrList->hEvent;
            
            // And call the apps completion routine
            pRTPBfrList->pfnCompletionNotification (dwError,
                                                   cbTransferred,
                                                   pRTPBfrList->pOverlapped,
                                                   dwFlags);

            // Return the struct to the free queue
            movePcktFromQueue(&pRTPSession->pRTPFreeList,
                              &pRTPSession->pRTPUsedListRecv,
                              (PLINK_LIST)pRTPBfrList,
                              &pRTPSession->critSect);

            pRTPBfrList->Overlapped.Internal |= 0xfeee0000;

            }   // SSRCList != NULL
        }       // valid RTP Header
    else 
        {
        dwRequeue |= INVALID_RTP_HEADER;
        }

    if (dwRequeue) {
        // The RTP packet was invalid for some reason
        RTPpostRecvBfr (dwError, cbTransferred, pOverlapped, dwFlags);
    } else  {
        InterlockedDecrement(&pRTPSession->lNumRecvIoPending);
    }
    
    IN_OUT_STR ("RTP : Exit RTPReceiveCallback()\n");
    }


RTP_BFR_LIST *getNewRTPBfrList(RTP_SESSION *pSession)
{
    // Get a PRTP Buffer from the free list
    RTP_BFR_LIST *pNewCell = (PRTP_BFR_LIST)
        removePcktFromTail((PLINK_LIST)&pSession->pRTPFreeList,
                           &pSession->critSect);

    if (pNewCell == NULL) {
        // try to reallocate some free cells
        if (pSession->dwNumTimesFreeListAllocated <=
            MAXNUM_CONTEXT_CELLS_REALLOC) {
            // increment the number of reallocated times even if the realloc
            //   fails next. Will avoid trying to realloc of a realloc problem
            pSession->dwNumTimesFreeListAllocated++;

            DWORD  numCells = NUM_FREE_CONTEXT_CELLS;
            
            if (allocateLinkedList(&pSession->pRTPFreeList, 
                                   pSession->hHeapFreeList,
                                   &numCells,
                                   sizeof(RTP_BFR_LIST),
                                   &pSession->critSect) == RRCM_NoError) {                              
                pNewCell = (PRTP_BFR_LIST)
                    removePcktFromTail((PLINK_LIST)&pSession->pRTPFreeList,
                                       &pSession->critSect);
            }
        }
    }

    return(pNewCell);
}


/*----------------------------------------------------------------------------
 * Function   : validateRTPHeader
 * Description: Performs basic checking of RTP Header (e.g., version number 
 *              and payload type range).
 * 
 * Input : pRTPHeader:  -> to an RTP header
 *
 * Return: TRUE, RTP Packet Header is valid
 *         FALSE: Header is invalid
 ---------------------------------------------------------------------------*/
 BOOL validateRTPHeader(RTP_HDR_T *pRTPHeader)
    {   
    BOOL    bStatus = TRUE;

    IN_OUT_STR ("RTP : Enter validateRTPHeader()\n");

    if (! pRTPHeader)
        return FALSE;

    // Check version number is correct
    if (pRTPHeader->type != RTP_TYPE) 
        bStatus = FALSE;
                                      
    // Next check that the Packet types look somewhat reasonable, 
    // at least out of the RTCP range
    if (pRTPHeader->pt >= RTCP_SR)
        bStatus = FALSE;

    IN_OUT_STR ("RTP : Exit validateRTPHeader()\n");
    
    return bStatus;
    }


/*----------------------------------------------------------------------------
 * Function   : RTPpostRecvBfr
 * Description: RTP post a receive buffer to Winsock
 * 
 * Input :      dwError         : Error code
 *              cbTransferred   : Bytes transferred
 *              pOverlapped     : -> to overlapped structure
 *              dwFlags         : Flags
 *
 * Return:      None
 ---------------------------------------------------------------------------*/
 void RTPpostRecvBfr (DWORD dwError,
                      DWORD cbTransferred,
                      LPWSAOVERLAPPED pOverlapped,
                      DWORD dwFlags)
    {
    DWORD           dwStatus;
    PRTP_BFR_LIST   pRTPBfrList;
    PRTP_SESSION    pRTPSession;

    IN_OUT_STR ("RTP : Enter RTPpostRecvBfr\n");

    // Reuse the packet with another receive
    pRTPBfrList = (PRTP_BFR_LIST)pOverlapped->hEvent;

    // Corresponding RTP session
    pRTPSession = (PRTP_SESSION)pRTPBfrList->pSession;

    pRTPBfrList->Overlapped.Internal = 0;

    dwStatus = RRCMws.recvFrom (pRTPBfrList->pSession->pSocket[SOCK_RECV],
                                pRTPBfrList->pBuffer,
                                pRTPBfrList->dwBufferCount,
                                pRTPBfrList->pNumBytesRecvd, 
                                pRTPBfrList->pFlags,
                                (PSOCKADDR)pRTPBfrList->pFrom,
                                pRTPBfrList->pFromlen,
                                &pRTPBfrList->Overlapped, 
                                RTPReceiveCallback); 

    // Check if Winsock Call succeeded
    if (dwStatus == SOCKET_ERROR) 
        {
        // If serious error, the receive request won't proceed
        dwStatus = GetLastError();
        if (dwStatus != WSA_IO_PENDING) 
            {
            RRCM_DBG_MSG ("RTP : ERROR - WSARecvFrom()", dwError, 
                          __FILE__, __LINE__, DBG_ERROR);

            // notify the user if an error occured, so he can free up 
            // its receive resources. The byte count is set to 0

            // Reinstate the AppSs WSAEVENT
            // pOverlapped->hEvent = pRTPBfrList->hEvent;
            
            // And call the apps completion routine
            pRTPBfrList->pfnCompletionNotification (dwStatus,
                                                   0,
                                                   pRTPBfrList->pOverlapped,
                                                   dwFlags);

            // Return the receive structure to the free list
            movePcktFromQueue(&pRTPSession->pRTPFreeList,
                              &pRTPSession->pRTPUsedListRecv,
                              (PLINK_LIST)pRTPBfrList,
                              &pRTPSession->critSect);

            pRTPBfrList->Overlapped.Internal |= 0xfeee0000;

            // No outstanding packet (callback to be fired), decrement count
            InterlockedDecrement(&pRTPSession->lNumRecvIoPending);
            }
        }

    IN_OUT_STR ("RTP : Exit RTPpostRecvBfr\n");
    }


// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rrcm\rtp\rtp_stat.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTP_STAT.C
 * Product:     RTP/RTCP implementation
 * Description: Provides statistical calculations for RTP packets
 *
 * $Workfile:   RTP_STAT.CPP  $
 * $Author:   CMACIOCC  $
 * $Date:   13 Feb 1997 14:46:10  $
 * $Revision:   1.3  $
 * $Archive:   R:\rtp\src\rrcm\rtp\rtp_stat.cpv  $
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/

        
#include "rrcm.h"


#define DBG_JITTER_ENABLE   0


/*---------------------------------------------------------------------------
/                           Global Variables
/--------------------------------------------------------------------------*/            


/*---------------------------------------------------------------------------
/                           External Variables
/--------------------------------------------------------------------------*/
extern PRTP_CONTEXT pRTPContext;
extern RRCM_WS      RRCMws;             

#ifdef _DEBUG
extern char debug_string[];
#endif





/*----------------------------------------------------------------------------
 * Function   : calculateJitter
 * Description: Determines jitter between current and last received packet.
 * 
 * Input :      pRTPHeader  : -> to the RTP header
 *              pSSRC       : -> to the session's SSRC list
 *
 * Note: Implementataion adapted from IETF RFC1889
 *
 * Return: RRCM_NoError     = OK.
 *         Otherwise(!=0)   = Error.
 ---------------------------------------------------------------------------*/
DWORD calculateJitter (RTP_HDR_T *pRTPHeader, 
                       PSSRC_ENTRY pSSRC)
    {
    DWORD       dwStatus = RRCM_NoError;
    DWORD       streamClk;
    DWORD       dwTmp;
    int         dwPropagationTime;  // packet's transmit time
    int         dwIASourceTime;     // Packet's timestamp for IA
    int         delta;              // of 2 consec. packets

    IN_OUT_STR ("RTP : Enter calculateJitter()\n");

    // Convert the RTP timestamp to host order
    dwIASourceTime = ntohl(pRTPHeader->ts);

    // lock access
    EnterCriticalSection (&pSSRC->critSect);

    // Take the difference, after having adjusted the clock to the payload
    // type frequency
    streamClk = 
        ((PSSRC_ENTRY)pSSRC->pRTCPses->XmtSSRCList.prev)->dwStreamClock;
    if (streamClk) 
        {
        dwTmp = streamClk / 1000;

        // update the time to be in unit of the source clock
        dwPropagationTime = (timeGetTime() * dwTmp) - dwIASourceTime;
        }
    else
        dwPropagationTime = timeGetTime() - dwIASourceTime;

    // initialize for the first valid packet, otherwise jitter will be off
    if (pSSRC->rcvInfo.dwPropagationTime == 0)
        {
        pSSRC->rcvInfo.dwPropagationTime = dwPropagationTime;

        LeaveCriticalSection (&pSSRC->critSect);

        IN_OUT_STR ("RTP : Exit calculateJitter()\n");  
        return (dwStatus);
        }

#if DBG_JITTER_ENABLE
    wsprintf(debug_string, "RTP : Time: %ld - Src Timestamp: %ld",
                            timeGetTime(), 
                            dwIASourceTime);
    RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);

    wsprintf(debug_string, "RTP : Propagation (Src unit): %ld",
                            dwPropagationTime);
    RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);

    wsprintf(debug_string, "RTP : Previous Propagation (Src unit): %ld",
                            pSSRC->rcvInfo.dwPropagationTime);
    RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

    // Determine the difference in the transit times and save the latest
    delta = dwPropagationTime - pSSRC->rcvInfo.dwPropagationTime;
    if (delta < 0)
        delta = -delta;

    // check for a wrap-around, which is always possible, and avoid sending
    // the jitter through the roof - It will take a long time thereafter to 
    // go back down to a reasonable level 
    // Check against arbitrary large number
    if (delta > 20000)
        {
        pSSRC->rcvInfo.dwPropagationTime = dwPropagationTime;

        LeaveCriticalSection (&pSSRC->critSect);

        IN_OUT_STR ("RTP : Exit calculateJitter()\n");  
        return (dwStatus);
        }

#if DBG_JITTER_ENABLE
    wsprintf(debug_string, "RTP : Delta (Src unit): %ld", delta);
    RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

    pSSRC->rcvInfo.dwPropagationTime = dwPropagationTime;

#ifdef ENABLE_FLOATING_POINT
    // This is the RFC way to do it
    pSSRC->rcvInfo.interJitter += 
        ((1./16.) * ((double)delta - pSSRC->rcvInfo.interJitter));
#else
    // and this is when we need to remove floating point operation
    pSSRC->rcvInfo.interJitter += 
        (delta - (((long)pSSRC->rcvInfo.interJitter + 8) >> 4));
#endif

    LeaveCriticalSection (&pSSRC->critSect);

#if DBG_JITTER_ENABLE
    if (streamClk)
        {
        wsprintf(debug_string, "RTP : iJitter: %ld - iJitter (msec): %ld",
                                pSSRC->rcvInfo.interJitter,
                                (pSSRC->rcvInfo.interJitter / (streamClk / 1000)));
        }
    else
        {
        wsprintf(debug_string, "RTP : iJitter: %ld - Delta: %ld",
                                pSSRC->rcvInfo.interJitter,
                                delta);
        }
    RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);

    wsprintf(debug_string, "RTP : Next RTCP RR iJitter: %ld",
                            (pSSRC->rcvInfo.interJitter >> 4));
    RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif
    
    IN_OUT_STR ("RTP : Exit calculateJitter()\n");  

    return (dwStatus);
    }


/*----------------------------------------------------------------------------
 * Function   : initRTPStats
 * Description: initializes statistics table for newly recieved SSRC
 * 
 * Input : RTPSequence  : Sequence number received in the packet.
 *                        NB: Must be in LittleEndian(IA) format
 *         pSSRC        : -> to SSRC table entry for this terminal
 *
 * Note: Implementataion adapted from draftspec 08, Appendix A.1
 *
 * Return: None.
 ---------------------------------------------------------------------------*/
void initRTPStats (WORD RTPSequence, 
                   PSSRC_ENTRY pSSRC)
    {
    IN_OUT_STR ("RTP : Enter initRTPStats()\n");

    pSSRC->rcvInfo.dwNumPcktRcvd    = 0;    
    pSSRC->rcvInfo.dwPrvNumPcktRcvd = 0;
    pSSRC->rcvInfo.dwExpectedPrior  = 0;
    pSSRC->rcvInfo.dwNumBytesRcvd   = 0;                
    pSSRC->rcvInfo.dwBadSeqNum      = RTP_SEQ_MOD + 1;      // Out of range
    pSSRC->rcvInfo.XtendedSeqNum.seq_union.RTPSequence.wSequenceNum = 
        RTPSequence;
    pSSRC->rcvInfo.XtendedSeqNum.seq_union.RTPSequence.wCycle = 0;

#if 0
    // as per the RFC, but always 1 packet off by doing this ???
    pSSRC->rcvInfo.dwBaseRcvSeqNum  = RTPSequence - 1;
#else
    pSSRC->rcvInfo.dwBaseRcvSeqNum  = RTPSequence;
#endif

    IN_OUT_STR ("RTP : Exit initRTPStats()\n");
    }


/*----------------------------------------------------------------------------
 * Function   : sequenceCheck
 * Description: Determines whether received packet sequence number is in a
 *              valid range to include for statistical tracking purposes.
 * 
 * Input : RTPSequence  :   Sequence number received in the packet.
 *                          NB: Must be in LittleEndian(IA) format
 *         pSSRC        :   -> to SSRC table entry for this terminal
 *
 * Note: Implementataion adapted from draftspec 08, Appendix A.1
 *
 * Return: TRUE     = OK.
 *         FALSE    = Stale or invalid data.
 ---------------------------------------------------------------------------*/
#if 1
BOOL sequenceCheck (WORD RTPSequence, 
                    PSSRC_ENTRY pSSRC)
    {
    WORD delta = RTPSequence - 
        pSSRC->rcvInfo.XtendedSeqNum.seq_union.RTPSequence.wSequenceNum;
        
    IN_OUT_STR ("RTP : Enter sequenceCheck()\n");

    // Have we received enough consecutive sequence numbered pckts in order 
    // to valide ?
    if (pSSRC->rcvInfo.dwProbation) 
        {
        // Is the sequence received the expected one ?
        if (RTPSequence == 
            (pSSRC->rcvInfo.XtendedSeqNum.seq_union.RTPSequence.wSequenceNum + 1)) 
            {
            // Decrement the number of consecutive packets we need before we
            //  consider statistics to be valid
            pSSRC->rcvInfo.dwProbation--;
            pSSRC->rcvInfo.XtendedSeqNum.seq_union.RTPSequence.wSequenceNum = 
                RTPSequence;

            if (pSSRC->rcvInfo.dwProbation == 0) 
                {
                initRTPStats(RTPSequence, pSSRC);

                IN_OUT_STR ("RTP : Exit sequenceCheck()\n");

                return TRUE;
                }
            }
        else 
            {
            pSSRC->rcvInfo.dwProbation = MIN_SEQUENTIAL - 1;
            pSSRC->rcvInfo.XtendedSeqNum.seq_union.RTPSequence.wSequenceNum = 
                RTPSequence;
            }

        IN_OUT_STR ("RTP : Exit sequenceCheck()\n");

        return FALSE;
        }
    else if (delta < MAX_DROPOUT)
        {
        // In order with permissible gap
        if (RTPSequence < pSSRC->rcvInfo.XtendedSeqNum.seq_union.RTPSequence.wSequenceNum)
            // sequence number wrapped - count another 64K cycle
            pSSRC->rcvInfo.XtendedSeqNum.seq_union.RTPSequence.wCycle += 1;

        pSSRC->rcvInfo.XtendedSeqNum.seq_union.RTPSequence.wSequenceNum = RTPSequence;
        }
    else if (delta <= RTP_SEQ_MOD - MAX_MISORDER)
        {
        // the sequence number made a very large jump
        if (RTPSequence == pSSRC->rcvInfo.dwBadSeqNum)
            // two sequential packet. Assume the other side restarted w/o telling
            // us, so just re-sync, i.e., pretend this was the first packet
            initRTPStats(RTPSequence, pSSRC);   
        else
            {
            pSSRC->rcvInfo.dwBadSeqNum = (RTPSequence + 1) & (RTP_SEQ_MOD - 1);

            IN_OUT_STR ("RTP : Exit sequenceCheck()\n");

            return FALSE;
            }
        }
    else
        {
        // duplicate or reordered packet
        }

    IN_OUT_STR ("RTP : Exit sequenceCheck()\n");

    return (TRUE);
    }

#else
//BOOL sequenceCheck (WORD RTPSequence, 
//                  PSSRC_ENTRY lpSSRCList)
//{
//  BOOL            bStatus;
//  WORD            delta;
//      
//#ifdef IN_OUT_CHK
//  OutputDebugString ("\nEnter sequenceCheck()");
//#endif
//
//  // Have we received a couple of consecutive sequence numbered packets for
//  //  validation?
//  if (lpSSRCList->probation) {
//
//      // Default status is don't include since the source hasn't been validated yet
//      bStatus = FALSE;
//
//      // Is the sequence received the expected one?
//      if (RTPSequence == (lpSSRCList->XtendedSeqNum.seq_union.RTPSequence.wSequenceNum + 1)) {
//          // Decrement the number of consecutive packets we need before we
//          //  consider statistics to be valid
//          lpSSRCList->probation--;
//          lpSSRCList->XtendedSeqNum.seq_union.RTPSequence.wSequenceNum = RTPSequence;
//          if (lpSSRCList->probation == 0) {
//              initRTPStats(RTPSequence, lpSSRCList);
//              bStatus = TRUE;
//          }
//      }
//      else {
//          lpSSRCList->probation = MIN_SEQUENTIAL - 1;
//          lpSSRCList->XtendedSeqNum.seq_union.RTPSequence.wSequenceNum = RTPSequence;
//      }
//  }
//  else {
//      // Default status is include since the source has been validated
//      bStatus = TRUE;
//      
//      // First consider the case where delta is positive (or a duplicate packet)
//      if (RTPSequence >= lpSSRCList->XtendedSeqNum.seq_union.RTPSequence.wSequenceNum)    {
//
//          delta = RTPSequence - lpSSRCList->XtendedSeqNum.seq_union.RTPSequence.wSequenceNum;
//
//          if (delta < MAX_DROPOUT) {
//              // packets may be missing, but not too many so as to be deemed restarted
//              lpSSRCList->XtendedSeqNum.seq_union.RTPSequence.wSequenceNum = RTPSequence;
//          }
//          else if (delta  > (RTP_SEQ_MOD - MAX_MISORDER)) {
//              // There has been a recent wraparound, and this is just a recent old packet
//              //  Nothing to do but include for statistical processing
//          }
//          else {
//              // there was a very large jump in sequence numbers
//              if (RTPSequence == lpSSRCList->badSeqNum ) {
//                  // Two sequential packets after what was thought was a bad packet or
//                  //  (assume a very large jump and proceed as if the sender restarted
//                  //  without telling us) or a new terminal is in the session.
//                  initRTPStats(RTPSequence, lpSSRCList);
//              }
//              else {
//                  lpSSRCList->badSeqNum = (RTPSequence + 1) & (RTP_SEQ_MOD - 1);
//                  bStatus = FALSE;
//              }
//          }
//      }
//      else {
//          // sequence number is less than the last we received.  Could be either
//          //  a recent late packet, a very late packet, a wraparound or a restartup 
//          //  of a new session for an SSRC from which we hadn't received a BYE
//
//          delta = lpSSRCList->XtendedSeqNum.seq_union.RTPSequence.wSequenceNum - RTPSequence;
//
//          if (delta < MAX_MISORDER) {
//              // Packet arrived a little bit late, it's still OK
//              // do nothing here, will be counted in stat routines
//          }
//          else if (delta > (RTP_SEQ_MOD - MAX_DROPOUT)) {
//              // wrap around, adjust cycle number and sequence number
//              lpSSRCList->XtendedSeqNum.seq_union.RTPSequence.cycle++;
//              lpSSRCList->XtendedSeqNum.seq_union.RTPSequence.wSequenceNum = RTPSequence;
//          }
//          else {
//              // there was a very large jump in sequence numbers
//              if (RTPSequence == lpSSRCList->badSeqNum) {
//                  // Two sequential packets after what was thought was a bad packet.
//                  //  Assume a very large jump and proceed as if the sender restarted
//                  //  without telling us
//                  initRTPStats(RTPSequence, lpSSRCList);
//              }
//              else {
//                  lpSSRCList->badSeqNum = (RTPSequence + 1) & (RTP_SEQ_MOD - 1);
//                  bStatus = FALSE;
//              }
//          }
//      }
//  }
//
//#ifdef IN_OUT_CHK
//  OutputDebugString ("\nExit sequenceCheck()");
//#endif
//
//  return (bStatus);
//}
#endif


/*----------------------------------------------------------------------------
 * Function   : updateRTPStats
 * Description: Updates statistics for RTP packets received from net
 * 
 * Input :  pRTPHeader      : -> to packet's RTP header field
 *          pSSRC           : -> to remote source's statistics table
 *          cbTransferred   : Number of bytes transferred
 *
 *
 * Return: RRCM_NoError     = OK.
 *         Otherwise(!=0)   = Initialization Error.
 ---------------------------------------------------------------------------*/
DWORD updateRTPStats (RTP_HDR_T *pRTPHeader, 
                      PSSRC_ENTRY pSSRC,
                      DWORD cbTransferred)
    {
    WORD    RTPSequenceNum;

    IN_OUT_STR ("RTP : Enter updateRTPStats()\n");

    // Update statistics only if the data looks good.  Check the sequence number
    //  to ensure it is within an appropriate range.  First, we must convert the
    //  sequence number to IA (little Endian) format
    RTPSequenceNum = ntohs(pRTPHeader->seq);

    if (sequenceCheck (RTPSequenceNum, pSSRC)) 
        {
        // lock access to data
        EnterCriticalSection (&pSSRC->critSect);

        // update number of packet received
        pSSRC->rcvInfo.dwNumPcktRcvd++;         

        // Number octets received (exclusive of header) depends on whether
        //  a mixer (CSRC != 0) was involved
        if (pRTPHeader->cc == 0) 
            {
            pSSRC->rcvInfo.dwNumBytesRcvd += 
                (cbTransferred - (sizeof(RTP_HDR_T) - sizeof(pRTPHeader->csrc[0])));
            }
        else 
            {
            pSSRC->rcvInfo.dwNumBytesRcvd += 
                (cbTransferred - sizeof(RTP_HDR_T) +
                    ((pRTPHeader->cc - 1) * sizeof(pRTPHeader->csrc[0])));
            }

        // Packet received sequentially in order (difference 
        // of 1, or -1 if wraparound) save new current 
        //  sequence number
        pSSRC->xmtInfo.dwCurXmtSeqNum = ntohs(pRTPHeader->seq);

        //  Calculate JITTER
        calculateJitter (pRTPHeader, pSSRC);

        // This time is used to decide on INACTIVE/TIMEOUT event,
        // update also with RTP packets received
        pSSRC->dwLastReportRcvdTime = timeGetTime();
        
        // unlock access to data
        LeaveCriticalSection (&pSSRC->critSect);
        }

    IN_OUT_STR ("RTP : Exit updateRTPStats()\n");

    return (RRCM_NoError);
    }


// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\rrcm\rtp\rtpmisc.cpp ===
/*----------------------------------------------------------------------------
 * File:        RRCMMISC.C
 * Product:     RTP/RTCP implementation.
 * Description: Provides common RTP/RTCP support functionality.
 *
 * $Workfile:   rtpmisc.cpp  $
 * $Author:   CMACIOCC  $
 * $Date:   02 Apr 1997 17:03:42  $
 * $Revision:   1.9  $
 * $Archive:   R:\rtp\src\rrcm\rtp\rtpmisc.cpv  $
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/


#include "rrcm.h"                                    

extern PRTP_CONTEXT pRTPContext;

/*---------------------------------------------------------------------------
/                           Global Variables
/--------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------
/                           External Variables
/--------------------------------------------------------------------------*/
#ifdef ENABLE_ISDM2
extern KEY_HANDLE hRRCMRootKey;
extern ISDM2      Isdm2;
#endif

extern RRCM_WS  RRCMws;             

#ifdef _DEBUG
extern char     debug_string[];
#if defined(RRCMLIB)
extern DWORD    dwTimeOffset; // from DShow base classes
#else
extern DWORD    dwRRCMRefTime;
#endif
#endif

#ifdef ISRDBG
extern WORD     ghISRInst;
#endif


/*--------------------------------------------------------------------------
 * Function   : searchForMySSRC
 * Description: Find the SSRC for this stream.
 *
 * Input :  pSSRC       :   -> to the SSRC entry
 *          RTPSocket   :   RTP socket descriptor
 *
 * Return: NULL             ==> Session not found.
 *         Buffer Address   ==> OK, Session ptr returned
 --------------------------------------------------------------------------*/
PSSRC_ENTRY searchForMySSRC(PSSRC_ENTRY pSSRC,
                            SOCKET RTCPsocket)
    {
    PSSRC_ENTRY pRRCMSession;

    IN_OUT_STR ("RTP : Enter searchForMySSRC()\n");

    for (pRRCMSession = NULL;
         (pSSRC != NULL);
         pSSRC = (PSSRC_ENTRY)pSSRC->SSRCList.prev) 
        {
        if (pSSRC->pRTPses->pSocket[SOCK_RTCP] == RTCPsocket) 
            {
            pRRCMSession = pSSRC;
            break;
            }
        }

    IN_OUT_STR ("RTP : Exit searchForMySSRC()\n");       

    return (pRRCMSession);
    }


/*--------------------------------------------------------------------------
 * Function   : searchforSSRCatHead
 * Description: Search through linked list of RTCP entries starting at the
 *                  head of the list.  
 *
 * Input :  pSSRC   :   -> to the SSRC entry
 *          ssrc    :   ssrc to look for
 *
 * Return: NULL             ==> Session not found.
 *         Non-NULL         ==> OK, SSRC entry found
 --------------------------------------------------------------------------*/
PSSRC_ENTRY searchforSSRCatHead(PSSRC_ENTRY pSSRC,
                                DWORD ssrc,
                                PCRITICAL_SECTION pCritSect)                    
    {
    PSSRC_ENTRY pRRCMSession = NULL;

    IN_OUT_STR ("RTP : Enter searchForMySSRCatHead()\n");        

    if (pCritSect)
        EnterCriticalSection(pCritSect);

    for (pRRCMSession = NULL;
         (pSSRC != NULL) && 
         (pRRCMSession == NULL) && (ssrc <= pSSRC->SSRC);
         pSSRC = (PSSRC_ENTRY)pSSRC->SSRCList.prev) 
        {
        if (pSSRC->SSRC == ssrc) 
            {
            pRRCMSession = pSSRC;
            }
        }

    if (pCritSect)
        LeaveCriticalSection(pCritSect);

    IN_OUT_STR ("RTP : Exit searchForMySSRCatHead()\n");                 

    return (pRRCMSession);
    }


/*--------------------------------------------------------------------------
 * Function   : searchforSSRCatTail
 * Description: Search through linked list of RTCP entries starting at the
 *                  tail of the list.  
 *
 * Input :  pSSRC   :   -> to the SSRC entry
 *          ssrc    :   SSRC to look for
 *
 * Return: NULL             ==> Session not found.
 *         Non-NULL         ==> OK, SSRC entry found
 --------------------------------------------------------------------------*/
PSSRC_ENTRY searchforSSRCatTail(PSSRC_ENTRY pSSRC,
                                DWORD ssrc,
                                PCRITICAL_SECTION pCritSect)
    {
    PSSRC_ENTRY pRRCMSession = NULL;

    IN_OUT_STR ("RTP : Enter searchForMySSRCatTail()\n");        
    
    if (pCritSect)
        EnterCriticalSection(pCritSect);

    for (pRRCMSession = NULL;
         (pSSRC != NULL) && 
         (pRRCMSession == NULL) && (ssrc >= pSSRC->SSRC);
         pSSRC = (PSSRC_ENTRY)pSSRC->SSRCList.next) 
        {
        if (pSSRC->SSRC == ssrc) 
            {
            pRRCMSession = pSSRC;
            }
        }

    if (pCritSect)
        LeaveCriticalSection(pCritSect);

    IN_OUT_STR ("RTP : Exit searchForMySSRCatTail()\n");         
    
    return (pRRCMSession);
    }

/*********************************************************************
 * getSSRCinSession
 * Goes trough the list of SSRCs (the participants) and eithr find out
 * how many participants currently are or copy as many SSRCs to the
 * caller.
 *********************************************************************/
RRCMSTDAPI
getSSRCinSession(void *pvRTCPSession,
                 PDWORD pdwSSRC,
                 PDWORD pdwNum)
{
    if (!pvRTCPSession)
        return(MAKE_RRCM_ERROR(RRCMError_InvalidPointer));

    if (!pdwNum)
        return(MAKE_RRCM_ERROR(RRCMError_InvalidPointer));

    DWORD dwNum = *pdwNum;
    *pdwNum = 0;

    if (dwNum && !pdwSSRC)
        return(MAKE_RRCM_ERROR(RRCMError_InvalidPointer));
        
    PRTCP_SESSION pRTCPSession = (PRTCP_SESSION)pvRTCPSession;
    PSSRC_ENTRY pSSRCEntry;
    DWORD dwCount;

    EnterCriticalSection(&pRTCPSession->SSRCListCritSect);
    if (dwNum) {
        // put in SSRCBuf the min(Len, total SSRCs in session)
        for(dwCount=0,
                pSSRCEntry = (PSSRC_ENTRY)pRTCPSession->RcvSSRCList.prev;
            (pSSRCEntry != NULL) && (dwCount < dwNum);
            pSSRCEntry = (PSSRC_ENTRY)pSSRCEntry->SSRCList.next, dwCount++)
            pdwSSRC[dwCount] = pSSRCEntry->SSRC;
        *pdwNum = dwCount;
    } else {
        // just get a count of the number of SSRCs in session
        for(pSSRCEntry = (PSSRC_ENTRY)pRTCPSession->RcvSSRCList.prev;
            pSSRCEntry != NULL;
            pSSRCEntry = (PSSRC_ENTRY)pSSRCEntry->SSRCList.next, dwNum++);
        *pdwNum = dwNum;
    }
    LeaveCriticalSection(&pRTCPSession->SSRCListCritSect);

    return(RRCM_NoError);
}

/*********************************************************************
 * getSSRCSDESItem
 * Retrieves the SDES item specified from a given SSRC (participant).
 * The Len returned includes the NULL ending character if included.
 *********************************************************************/
RRCMSTDAPI
getSSRCSDESItem(void  *pvRTCPSession,
                DWORD  dwSSRC,
                DWORD  dwSDESItem,
                PCHAR  psSDESData,
                PDWORD pdwLen)
{
    
    if (!pvRTCPSession)
        return(MAKE_RRCM_ERROR(RRCMError_InvalidPointer));

    PRTCP_SESSION pRTCPSession = (PRTCP_SESSION)pvRTCPSession;

    if (!pdwLen)
        return(MAKE_RRCM_ERROR(RRCMError_InvalidPointer));

    DWORD dwLen = *pdwLen;
    *pdwLen = 0; // Set the safe value

    if (!dwLen)
        return(MAKE_RRCM_ERROR(RRCMError_RTCPResources));

    int idx = SDES_INDEX(dwSDESItem); // (dwSDESItem-1)
    
    if (idx < SDES_INDEX(RTCP_SDES_FIRST+1) ||
        idx >= SDES_INDEX(RTCP_SDES_LAST-1))
        return(MAKE_RRCM_ERROR(RRCMError_RTCPInvalidArg));

    PSSRC_ENTRY pSSRCEntry =
        searchforSSRCatTail((PSSRC_ENTRY)pRTCPSession->RcvSSRCList.prev,
                            dwSSRC,
                            &pRTCPSession->SSRCListCritSect);
    
    if (!pSSRCEntry)
        return(MAKE_RRCM_ERROR(RRCMError_RTPSSRCNotFound));

    if (dwLen < pSSRCEntry->sdesItem[idx].dwSdesLength)
        return(MAKE_RRCM_ERROR(RRCMError_RTCPResources));

    *pdwLen = pSSRCEntry->sdesItem[idx].dwSdesLength;
    CopyMemory(psSDESData, pSSRCEntry->sdesItem[idx].sdesBfr, *pdwLen);

    return(RRCM_NoError);
}

RRCMSTDAPI
getSSRCSDESAll(void      *pvRTCPSession,
               DWORD      dwSSRC,
               PSDES_DATA pSdes,
               DWORD      dwNum)
{
    if (!pvRTCPSession)
        return(MAKE_RRCM_ERROR(RRCMError_InvalidPointer));

    if (!pSdes)
        return(MAKE_RRCM_ERROR(RRCMError_InvalidPointer));

    PRTCP_SESSION pRTCPSession = (PRTCP_SESSION)pvRTCPSession;

    if (!dwNum)
        return(MAKE_RRCM_ERROR(RRCMError_RTCPInvalidArg));

    PSSRC_ENTRY pSSRCEntry = 
        searchforSSRCatTail((PSSRC_ENTRY)pRTCPSession->RcvSSRCList.prev,
                            dwSSRC,
                            &pRTCPSession->SSRCListCritSect);
    
    if (!pSSRCEntry)
        return(MAKE_RRCM_ERROR(RRCMError_RTPSSRCNotFound));


    DWORD item;
        
    for( ;dwNum > 0; dwNum--, pSdes++) {
        if (!pSdes->dwSdesType)
            item = SDES_INDEX(RTCP_SDES_CNAME);
        else if (pSdes->dwSdesType < RTCP_SDES_FIRST+1 ||
                 pSdes->dwSdesType >= RTCP_SDES_LAST)
            item = SDES_INDEX(RTCP_SDES_CNAME);
        else
            item = SDES_INDEX(pSdes->dwSdesType);

        CopyMemory(pSdes, &pSSRCEntry->sdesItem[item], sizeof(SDES_DATA));
    }

    return(RRCM_NoError);

}

// rtp_rtcp values:
// 0 = RTP
// 1 = RTCP
// 2 = whatever available, looking first at RTP
// ? = RTP, but if not available, fake address from RTCP if available
RRCMSTDAPI
getSSRCAddress(void  *pvRTCPSession,
               DWORD  dwSSRC,
               LPBYTE pbAddr,
               int    *piAddrLen,
               int    rtp_rtcp)
{
    if (!pvRTCPSession || !pbAddr || !piAddrLen)
        return(MAKE_RRCM_ERROR(RRCMError_InvalidPointer));

    PRTCP_SESSION pRTCPSession = (PRTCP_SESSION)pvRTCPSession;
    
    PSSRC_ENTRY pSSRC = 
        searchforSSRCatTail((PSSRC_ENTRY)pRTCPSession->RcvSSRCList.prev,
                            dwSSRC,
                            &pRTCPSession->SSRCListCritSect);

    if (!pSSRC) {
        return(MAKE_RRCM_ERROR(RRCMError_RTPSSRCNotFound));
    } else {
        ZeroMemory(pbAddr, *piAddrLen);
        int iAddrLen = *piAddrLen;
        *piAddrLen = 0;

        SOCKADDR *psaddr = (SOCKADDR *)NULL;
        int *psaddrLen;
        
        if (rtp_rtcp == UPDATE_RTP_ADDR) {
            if (pSSRC->dwSSRCStatus & NETWK_RTPADDR_UPDATED) {
                psaddrLen = &pSSRC->fromRTPLen;
                psaddr = &pSSRC->fromRTP;
            }
        } else if (rtp_rtcp == UPDATE_RTCP_ADDR) {
            if (pSSRC->dwSSRCStatus & NETWK_RTCPADDR_UPDATED) {
                psaddrLen = &pSSRC->fromRTCPLen;
                psaddr = &pSSRC->fromRTCP;
            }
        } else if (rtp_rtcp == 2) {
            // Get the address first from RTP, if not available
            // try that from RTCP
            if (pSSRC->dwSSRCStatus & NETWK_RTPADDR_UPDATED) {
                psaddrLen = &pSSRC->fromRTPLen;
                psaddr = &pSSRC->fromRTP;
            } else if (pSSRC->dwSSRCStatus & NETWK_RTCPADDR_UPDATED) {
                psaddrLen = &pSSRC->fromRTCPLen;
                psaddr = &pSSRC->fromRTCP;
            } else
                return(MAKE_RRCM_ERROR(RRCMError_RTCPInvalidArg));
        } else {
            // Get the address first from RTP, if not available
            // fake it from the RTCP address/port
            // I PUT THIS FOR DEBUGGING PURPOSSES
            if (pSSRC->dwSSRCStatus & NETWK_RTPADDR_UPDATED) {
                psaddrLen = &pSSRC->fromRTPLen;
                psaddr = &pSSRC->fromRTP;
            } else if (pSSRC->dwSSRCStatus & NETWK_RTCPADDR_UPDATED) {
                // Fake the RTP address from RTCP, the real RTP
                // address will be updated when packets arrive
                CopyMemory(&pSSRC->fromRTP, &pSSRC->fromRTCP, pSSRC->fromRTCPLen);
                ((PSOCKADDR_IN)&pSSRC->fromRTP)->sin_port =
                    htons(ntohs(((PSOCKADDR_IN)&pSSRC->fromRTP)->sin_port)
                          - 1);
                psaddrLen = &pSSRC->fromRTCPLen;
                psaddr = &pSSRC->fromRTP;
            } else
                return(MAKE_RRCM_ERROR(RRCMError_RTCPInvalidArg));
        }
        
        if (psaddr) {
            if (iAddrLen < *psaddrLen)
                return(MAKE_RRCM_ERROR(RRCMError_RTCPInvalidArg));
            
            CopyMemory(pbAddr, psaddr, *psaddrLen);
            *piAddrLen = *psaddrLen;
        }
        
        return(RRCM_NoError);
    }
}

/*---------------------------------------------------------------------------
 * Function   : saveNetworkAddress
 * Description: Saves the received or local network Address in the local
 *                  context.
 * 
 * Input :  pSSRCEntry  :   -> to the SSRC entry
 *          pNetAddr    :   -> to the network address
 *          addrLen     :   Address length
 *
 * Return:  OK: RRCM_NoError
 --------------------------------------------------------------------------*/
DWORD saveNetworkAddress (PSSRC_ENTRY pSSRC, 
                          PSOCKADDR pNetAddr,
                          int addrLen,
                          int rtp_rtcp)
    {
    IN_OUT_STR ("RTP : Enter saveNetworkAddress()\n");       

    if (rtp_rtcp == UPDATE_RTP_ADDR) {

        pSSRC->fromRTPLen = addrLen;
        CopyMemory(&pSSRC->fromRTP, pNetAddr, addrLen);
        pSSRC->dwSSRCStatus |= NETWK_RTPADDR_UPDATED;

    } else if (rtp_rtcp == UPDATE_RTCP_ADDR) {

        pSSRC->fromRTCPLen = addrLen;
        CopyMemory(&pSSRC->fromRTCP, pNetAddr, addrLen);
        pSSRC->dwSSRCStatus |= NETWK_RTCPADDR_UPDATED;
    }
        
    IN_OUT_STR ("RTP : Exit saveNetworkAddress()\n");

    return RRCM_NoError;            
    } 


/*---------------------------------------------------------------------------
 * Function   : updateRTCPDestinationAddress
 * Description: The applicatino updates the RTCP destination address
 *              
 * Input :  RTPsd       :   RTP socket descriptor
 *          pAddr       :   -> to address structure of RTCP information
 *          addrLen     :   Address length
 *
 * Return: RRCM_NoError     = OK.
 *         Otherwise(!=0)   = Check RRCM.h file for references.
 --------------------------------------------------------------------------*/
#if 0
RRCMSTDAPI updateRTCPDestinationAddress (SOCKET RTPsd,
                                         PSOCKADDR pRtcpAddr,
                                         int addrLen)   
    {
    PRTP_SESSION    pRTPSession;
    PRTCP_SESSION   pRTCPses;

#ifdef ENABLE_ISDM2
    PSSRC_ENTRY     pSSRC;
#endif
    
    IN_OUT_STR ("RTP : Enter updateRTCPDestinationAddress()\n");

    // Search for the proper session based on incoming socket
    pRTPSession = findSessionID (RTPsd, &pRTPContext->critSect);
    if (pRTPSession == NULL)
        {
        RRCM_DBG_MSG ("RTP : ERROR - Invalid RTP session", 0, 
                      __FILE__, __LINE__, DBG_CRITICAL);
        IN_OUT_STR ("RTP : Exit updateRTCPDestinationAddress()\n");

        return (MAKE_RRCM_ERROR(RRCMError_RTPInvalidSession));
        }

    // get the RTCP session
    pRTCPses = pRTPSession->pRTCPSession;
    if (pRTCPses == NULL)
        {
        RRCM_DBG_MSG ("RTP : ERROR - Invalid RTCP session", 0, 
                      __FILE__, __LINE__, DBG_CRITICAL);
        IN_OUT_STR ("RTP : Exit updateRTCPDestinationAddress()\n");

        return (MAKE_RRCM_ERROR(RRCMError_RTCPInvalidSession));
        }

    if (!(pRTCPses->dwSessionStatus & RTCP_DEST_LEARNED))
        {
        pRTCPses->dwSessionStatus |= RTCP_DEST_LEARNED;
        pRTCPses->toAddrLen = addrLen;
        CopyMemory(&pRTCPses->toAddr, pRtcpAddr, addrLen);

        // register our Xmt SSRC - Rcvd one will be found later
#ifdef ENABLE_ISDM2
        if (Isdm2.hISDMdll)
            {
            pSSRC = (PSSRC_ENTRY)pRTCPses->XmtSSRCList.prev;
            if (pSSRC != NULL)
                registerSessionToISDM (pSSRC, pRTCPses, &Isdm2);
            }
#endif
        }

    IN_OUT_STR ("RTP : Exit updateRTCPDestinationAddress()\n");

    return RRCM_NoError;
    }
#endif

/*---------------------------------------------------------------------------
 * Function   : updateSSRCentry
 * Description: The application updates some of the SSRC information
 *              
 * Input :  RTPsd       :   RTP socket descriptor
 *          updateType  :   Type of update desired
 *          updateInfo  :   Update information 
 *          misc        :   Miscelleanous information
 *
 * Return: RRCM_NoError     = OK.
 *         Otherwise(!=0)   = Check RRCM.h file for references.
 --------------------------------------------------------------------------*/
#if 0
RRCMSTDAPI updateSSRCentry (SOCKET RTPsd,
                            DWORD updateType,
                            DWORD updateInfo,
                            DWORD misc) 
    {
    PRTP_SESSION    pRTPSession;
    PRTCP_SESSION   pRTCPses;
    PSSRC_ENTRY     pSSRC;
    PLINK_LIST      pTmp;
    PSDES_DATA      pSdes;
    DWORD           idx;
    
    IN_OUT_STR ("RTP : Enter updateRTCPSdes ()\n");

    // Search for the proper session based on incoming socket
    pRTPSession = findSessionID (RTPsd, &pRTPContext->critSect);
    if (pRTPSession == NULL)
        {
        RRCM_DBG_MSG ("RTP : ERROR - Invalid RTP session", 0, 
                      __FILE__, __LINE__, DBG_CRITICAL);
        IN_OUT_STR ("RTP : Exit updateRTCPSdes ()\n");

        return (MAKE_RRCM_ERROR(RRCMError_RTPInvalidSession));
        }

    // get the RTCP session
    pRTCPses = pRTPSession->pRTCPSession;
    if (pRTCPses == NULL)
        {
        RRCM_DBG_MSG ("RTP : ERROR - Invalid RTCP session", 0, 
                      __FILE__, __LINE__, DBG_CRITICAL);
        IN_OUT_STR ("RTP : Exit updateRTCPSdes ()\n");

        return (MAKE_RRCM_ERROR(RRCMError_RTCPInvalidSession));
        }

    // search for the socket descriptor (unique per session)
    // walk through the list from the tail 
    pTmp = (PLINK_LIST)pRTCPses->XmtSSRCList.prev;

    while (pTmp)
        {
        if (((PSSRC_ENTRY)pTmp)->RTPsd == RTPsd)
            {
            // lock access to this entry 
            EnterCriticalSection (&((PSSRC_ENTRY)pTmp)->critSect);

            pSSRC = (PSSRC_ENTRY)pTmp;

            switch (updateType)
                {
                case RRCM_UPDATE_SDES:
                    // update the SDES
                    pSdes = (PSDES_DATA)updateInfo;

                    if (pSdes->dwSdesType > RTCP_SDES_FIRST &&
                        pSdes->dwSdesType < RTCP_SDES_LAST) {

                        idx = SDES_INDEX(pSdes->dwSdesType);
                        
                        pSSRC->sdesItem[idx].dwSdesType =
                            pSdes->dwSdesType;
                        pSSRC->sdesItem[idx].dwSdesLength =
                            pSdes->dwSdesLength;
                        CopyMemory(pSSRC->sdesItem[idx].sdesBfr,
                                   pSdes->sdesBfr, 
                                   pSdes->dwSdesLength);

                        pSSRC->sdesItem[idx].dwSdesFrequency = 
                            pSdes->dwSdesFrequency;
                        pSSRC->sdesItem[idx].dwSdesEncrypted =
                            pSdes->dwSdesEncrypted;
                    }
                    break;
                    
                case RRCM_UPDATE_STREAM_FREQUENCY:
                    // upate the stream clocking frequency
                    pSSRC->dwStreamClock = updateInfo;
                    break;

                case RRCM_UPDATE_RTCP_STREAM_MIN_BW:
                    // upate the stream clocking frequency
                    pSSRC->xmtInfo.dwRtcpStreamMinBW = updateInfo;
                    break;

                case RRCM_UPDATE_CALLBACK:
                    // update the callback information
                    EnterCriticalSection (&pRTCPses->critSect);
                    pRTCPses->pRRCMcallback      = (PRRCM_EVENT_CALLBACK)updateInfo;
                    pRTCPses->dwCallbackUserInfo = misc;
                    LeaveCriticalSection (&pRTCPses->critSect);
                    break;
                }

            // unlock access to this entry 
            LeaveCriticalSection (&((PSSRC_ENTRY)pTmp)->critSect);
            }

        pTmp = pTmp->next;
        }   


    IN_OUT_STR ("RTP : Exit updateRTCPSdes ()\n");

    return RRCM_NoError;
    }
#endif


/*---------------------------------------------------------------------------
 * Function   : RRCMnotification
 * Description: Notify the application that one of the RTP/RTCP events that
 *              we keep track of has occured.
 * 
 * Input :  RRCMevent   :   RRCM event to report
 *          pSSRC       :   -> to the SSRC entry
 *          ssrc        :   SSRC which generated the event
 *          misc        :   Miscelleanous value
 *
 * Return:  OK: RRCM_NoError
 --------------------------------------------------------------------------*/
 void RRCMnotification (DXMRTP_EVENT_T RRCMevent,
                        PSSRC_ENTRY pSSRC,
                        DWORD dwSSRC,
                        DWORD misc)
{
    IN_OUT_STR ("RRCM: Enter RRCMnotification()\n");         

    // check to see if the application is interested by the RRCM event
    if (pSSRC->pRTCPses->pRRCMcallback == NULL)             
        return;

    if (RRCMevent == RRCM_NO_EVENT || RRCMevent >= RRCM_LAST_EVENT)
        return; // Invalid event

    for(DWORD i = 0; i < 2; i++) {
        if (pSSRC->pRTCPses->dwEventMask[i] & (1<<RRCMevent))
            pSSRC->pRTCPses->pRRCMcallback (RRCMevent,
                                            dwSSRC,
                                            misc,
                                            pSSRC->pRTCPses->
                                            pvCallbackUserInfo[i]);
    }
    
    IN_OUT_STR ("RRCM: Exit RRCMnotification()\n");
} 

/*----------------------------------------------------------------------------
 * Function   : registerSessionToISDM
 * Description: Register an RTP/RTCP session with ISDM
 * 
 * Input :      pSSRC   :   -> to the SSRC's entry
 *              pRTCP   :   -> to the RTCP session's information
 *              pIsdm   :   -> to the ISDM information
 *
 * Return:      None
 ---------------------------------------------------------------------------*/
#ifdef ENABLE_ISDM2

#define SESSION_BFR_SIZE    30
void registerSessionToISDM (PSSRC_ENTRY pSSRC, 
                            PRTCP_SESSION pRTCPses, 
                            PISDM2 pIsdm2)
    {
    struct sockaddr_in  *pSSRCadr;
    unsigned short      port;
    unsigned long       netAddr;
    CHAR                SsrcBfr[20];
    CHAR                sessionBfr[SESSION_BFR_SIZE];
    unsigned char       *ptr;
    int                 num;
    HRESULT             hError;
    ISDM2_ENTRY         Isdm2Stat;
    PSSRC_ENTRY         pLocalSSRC;

    // get the destination address as the session identifier
    pSSRCadr = (struct sockaddr_in *)&pRTCPses->toBfr;
    RRCMws.htons (pSSRC->RTPsd, pSSRCadr->sin_port, &port);
    netAddr  = pSSRCadr->sin_addr.S_un.S_addr; 

    ptr = (unsigned char *)&netAddr;
    ZeroMemory (sessionBfr, SESSION_BFR_SIZE);

    num = (int)*ptr++;
    RRCMitoa (num, sessionBfr, 10);
    strcat (sessionBfr, ".");
    num = (int)*ptr++;
    RRCMitoa (num, (sessionBfr + strlen(sessionBfr)), 10);
    strcat (sessionBfr, ".");
    num = (int)*ptr++;
    RRCMitoa (num, (sessionBfr + strlen(sessionBfr)), 10);
    strcat (sessionBfr, ".");
    num = (int)*ptr;
    RRCMitoa (num, (sessionBfr + strlen(sessionBfr)), 10);
    strcat (sessionBfr, ".");
    RRCMitoa (port, (sessionBfr + strlen(sessionBfr)), 10);

    // get the SSRC
    RRCMultoa (pSSRC->SSRC, SsrcBfr, 16);
    strcat (SsrcBfr, ":");

    // Get the local SSRC
    pLocalSSRC = (PSSRC_ENTRY)pSSRC->pRTCPses->XmtSSRCList.prev;

    RRCMultoa (pLocalSSRC->SSRC, SsrcBfr + strlen (SsrcBfr), 16);

    // register the session
    if (pRTCPses->hSessKey == NULL)
        {
        hError = Isdm2.ISDMEntry.ISD_CreateKey (hRRCMRootKey,
                                                sessionBfr,
                                                &pRTCPses->hSessKey);
        if(FAILED(hError))
            RRCM_DBG_MSG ("RTP: ISD_CreateKey Failed",0, NULL, 0, DBG_NOTIFY);
            
        }

    ZeroMemory(&Isdm2Stat, sizeof(ISDM2_ENTRY));

    hError = Isdm2.ISDMEntry.ISD_CreateValue (pRTCPses->hSessKey,
                                              SsrcBfr,
                                              BINARY_VALUE,
                                              (BYTE *)&Isdm2Stat,
                                              sizeof(ISDM2_ENTRY),
                                              &pSSRC->hISDM);
    if(FAILED(hError))
        RRCM_DBG_MSG ("RTP: ISD_CreateValue Failed",0, NULL, 0, DBG_NOTIFY);                
    }


/*----------------------------------------------------------------------------
 * Function   : udpateISDMsta
 * Description: Update an ISDM data structure
 * 
 * Input :      pSSRC   :   -> to the SSRC's entry
 *              pIsdm   :   -> to the ISDM entry
 *              flag    :   Sender/Receive flag
 *              LocalFB :   do or dont't update the local feedback
 *
 * Return:      None
 ---------------------------------------------------------------------------*/
void updateISDMstat (PSSRC_ENTRY pSSRC, 
                     PISDM2 pIsdm2,
                     DWORD flag,
                     BOOL LocalFB)
    {
    DWORD           curTime = timeGetTime();
    DWORD           dwTmp;
    DWORD           dwValue;
    ISDM2_ENTRY     Isdm2Stat;
    HRESULT         hError;

    unsigned short  idx = 0;
    
    EnterCriticalSection (&pIsdm2->critSect);
    
    Isdm2Stat.SSRC = pSSRC->SSRC;
    Isdm2Stat.PayLoadType = pSSRC->PayLoadType;

    if (flag == RECVR)
        {
        Isdm2Stat.dwSSRCStatus = RECVR;
        Isdm2Stat.rcvInfo.dwNumPcktRcvd = pSSRC->rcvInfo.dwNumPcktRcvd;
        Isdm2Stat.rcvInfo.dwPrvNumPcktRcvd = pSSRC->rcvInfo.dwPrvNumPcktRcvd;
        Isdm2Stat.rcvInfo.dwExpectedPrior  = pSSRC->rcvInfo.dwExpectedPrior;
        Isdm2Stat.rcvInfo.dwNumBytesRcvd   = pSSRC->rcvInfo.dwNumBytesRcvd;
        Isdm2Stat.rcvInfo.dwBaseRcvSeqNum  = pSSRC->rcvInfo.dwBaseRcvSeqNum;
        Isdm2Stat.rcvInfo.dwBadSeqNum      = pSSRC->rcvInfo.dwBadSeqNum;
        Isdm2Stat.rcvInfo.dwProbation      = pSSRC->rcvInfo.dwProbation;
        Isdm2Stat.rcvInfo.dwPropagationTime= pSSRC->rcvInfo.dwPropagationTime;
        Isdm2Stat.rcvInfo.interJitter      = pSSRC->rcvInfo.interJitter;
        Isdm2Stat.rcvInfo.XtendedSeqNum.seq_union.dwXtndedHighSeqNumRcvd = 
            pSSRC->rcvInfo.XtendedSeqNum.seq_union.dwXtndedHighSeqNumRcvd;
        }
    else // (flag == ISDM_UPDATE_XMTSTAT)
        {
        Isdm2Stat.dwSSRCStatus = XMITR;

        Isdm2Stat.xmitinfo.dwNumPcktSent  = pSSRC->xmtInfo.dwNumPcktSent;
        Isdm2Stat.xmitinfo.dwNumBytesSent = pSSRC->xmtInfo.dwNumBytesSent;
        Isdm2Stat.xmitinfo.dwNTPmsw       = pSSRC->xmtInfo.dwNTPmsw;
        Isdm2Stat.xmitinfo.dwNTPlsw       = pSSRC->xmtInfo.dwNTPlsw;
        Isdm2Stat.xmitinfo.dwRTPts        = pSSRC->xmtInfo.dwRTPts;
        Isdm2Stat.xmitinfo.dwCurXmtSeqNum = pSSRC->xmtInfo.dwCurXmtSeqNum;
        Isdm2Stat.xmitinfo.dwPrvXmtSeqNum = pSSRC->xmtInfo.dwPrvXmtSeqNum;
        Isdm2Stat.xmitinfo.sessionBW      = pSSRC->xmtInfo.dwRtcpStreamMinBW;
        Isdm2Stat.xmitinfo.dwLastSR       = pSSRC->xmtInfo.dwLastSR;
        Isdm2Stat.xmitinfo.dwLastSRLocalTime = 
            pSSRC->xmtInfo.dwLastSRLocalTime;
        Isdm2Stat.xmitinfo.dwLastSendRTPSystemTime = 
            pSSRC->xmtInfo.dwLastSendRTPSystemTime;
        Isdm2Stat.xmitinfo.dwLastSendRTPTimeStamp = 
            pSSRC->xmtInfo.dwLastSendRTPTimeStamp;
        }

    if(LocalFB)
        {
        CopyMemory(&Isdm2Stat.rrFeedback, &pSSRC->rrFeedback, sizeof(RTCP_FEEDBACK));
        }
    else
        {
        Isdm2Stat.rrFeedback.SSRC = pSSRC->rrFeedback.SSRC;
#ifdef ENABLE_FLOATING_POINT
        Isdm2Stat.rrFeedback.dwInterJitter = pSSRC->rcvInfo.interJitter;
#else
        // Check RFC for details of the round off
        Isdm2Stat.rrFeedback.dwInterJitter = pSSRC->rcvInfo.interJitter >> 4;
#endif
        Isdm2Stat.rrFeedback.XtendedSeqNum.seq_union.dwXtndedHighSeqNumRcvd = 
            pSSRC->rcvInfo.XtendedSeqNum.seq_union.dwXtndedHighSeqNumRcvd;

        // fraction/cumulative number lost are in network order
        dwTmp = getSSRCpcktLoss (pSSRC, FALSE);
        Isdm2Stat.rrFeedback.fractionLost = (dwTmp & 0xFF);
        RRCMws.ntohl (pSSRC->RTPsd, dwTmp, &dwValue);
        Isdm2Stat.rrFeedback.cumNumPcktLost = (dwValue & 0x00FFFFFF);
        
        Isdm2Stat.rrFeedback.dwLastRcvRpt = pSSRC->rrFeedback.dwLastRcvRpt;
        Isdm2Stat.rrFeedback.dwLastSR = pSSRC->xmtInfo.dwLastSR;
        Isdm2Stat.rrFeedback.dwDelaySinceLastSR = getDLSR (pSSRC);
        }

    Isdm2Stat.dwLastReportRcvdTime = pSSRC->dwLastReportRcvdTime;

    CopyMemory(&Isdm2Stat.cnameInfo, &pSSRC->cnameInfo, sizeof(SDES_DATA));
    CopyMemory(&Isdm2Stat.nameInfo, &pSSRC->nameInfo, sizeof(SDES_DATA));
    CopyMemory(&Isdm2Stat.from, &pSSRC->from, sizeof(SOCKADDR));

    Isdm2Stat.fromLen = pSSRC->fromLen;
    Isdm2Stat.dwNumRptSent = pSSRC->dwNumRptSent;
    Isdm2Stat.dwNumRptRcvd = pSSRC->dwNumRptRcvd;
    Isdm2Stat.dwNumXmtIoPending = pSSRC->dwNumXmtIoPending;
    Isdm2Stat.dwStreamClock = pSSRC->dwStreamClock;

    hError = Isdm2.ISDMEntry.ISD_SetValue (NULL,
                                           pSSRC->hISDM,
                                           NULL,
                                           BINARY_VALUE,
                                           (BYTE *)&Isdm2Stat,
                                           sizeof(ISDM2_ENTRY));
    
    if(FAILED(hError))
        RRCM_DBG_MSG ("RTP: ISD_SetValue Failed",0, NULL, 0, DBG_NOTIFY);               

    LeaveCriticalSection (&pIsdm2->critSect);

    }
#endif // #ifdef ENABLE_ISDM2


/*---------------------------------------------------------------------------
 * Function   : RRCMdebugMsg
 * Description: Output RRCM debug messages
 * 
 * Input :      pMsg:       -> to message
 *              err:        Error code
 *              pFile:      -> to file where the error occured
 *              line:       Line number where the error occured
 *
 * Return:      None
 --------------------------------------------------------------------------*/
 void RRCMdebugMsg (PCHAR pMsg, 
                    DWORD err, 
                    PCHAR pFile, 
                    DWORD line,
                    DWORD type)
    {
#ifdef ISRDBG
    wsprintf (debug_string, "%s", pMsg);
    if (err)
        wsprintf (debug_string+strlen(debug_string), " Error:%d", err);
    if (pFile != NULL)
        wsprintf (debug_string+strlen(debug_string), " - %s, line:%d", 
                    pFile, line);
    switch (type)
        {
        case DBG_NOTIFY:
            ISRNOTIFY(ghISRInst, debug_string, 0);
            break;
        case DBG_TRACE:
            ISRTRACE(ghISRInst, debug_string, 0);
            break;
        case DBG_ERROR:
            ISRERROR(ghISRInst, debug_string, 0);
            break;
        case DBG_WARNING:
            ISRWARNING(ghISRInst, debug_string, 0);
            break;
        case DBG_TEMP:
            ISRTEMP(ghISRInst, debug_string, 0);
            break;
        case DBG_CRITICAL:
            ISRCRITICAL(ghISRInst, debug_string, 0);
            break;
        default:
            break;
        }
#elif _DEBUG
    OutputDebugString (pMsg);

    if (err)
        {
        wsprintf (debug_string, " Error:%d", err);
        OutputDebugString (debug_string);
        }

    if (pFile != NULL)
        {
        wsprintf (debug_string, " - %s, line:%d", pFile, line);
        OutputDebugString (debug_string);
        }

    OutputDebugString ("\n");
#endif
    } 

//
// This needs to be improved, but I needed quickly
// a way to sent formated log output.
//
#if  defined(_DEBUG)
void RRCMDebugLogInfo(DWORD Type, DWORD Level, const char *pFormat,...)
{
    char szInfo[1024];

    /* Format the variable length parameter list */
    va_list va;
    va_start(va, pFormat);

    wsprintf(szInfo, "DXMRTP.DLL(tid %x) %8d : ",
             GetCurrentThreadId(), timeGetTime() -
#if defined(RRCMLIB)
             dwTimeOffset  // from DShow base classes
#else
             dwRRCMRefTime // locally defined
#endif
        );

    wvsprintf(szInfo + strlen(szInfo), pFormat, va);
    strcat(szInfo, "\n");

    OutputDebugString(szInfo);

    va_end(va);
}
#endif
// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\sph\common\main.cpp ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : main.cpp
// Purpose  : RTP SPH filter entry points.
// Contents : 
//*M*/

#if !defined(SPH_IN_DXMRTP)

#include <streams.h>

#include <olectl.h>

/*F*
// Name     : DllRegisterServer
// Purpose  : exported entry points for registration.
// Context  : Called by regsvr32.exe
// Returns  : None.
// Params   : None.
// Notes    : In this case we call through to default implmentations
*F*/
HRESULT 
DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );
} /* DllRegisterServer() */


/*F*
// Name     : DllUnregisterServer
// Purpose  : exported entry points for registration.
// Context  : Called by regsvr32.exe
// Returns  : None.
// Params   : None.
// Notes    : In this case we call through to default implmentations
*F*/
HRESULT 
DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );
} /* DllUnregisterServer() */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\sph\sphaud\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\sph\common\sph.h ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : SPH.h
// Purpose  : Define the base class that implements the RTP SPH filters.
// Contents : 
//*M*/


#ifndef _SPH_H_
#define _SPH_H_

#include <irtpsph.h>
#include <isubmit.h>
#include <ippmcb.h>

class CSPHBase : public CTransformFilter,
		  public IRTPSPHFilter,
		  public ISubmit,
		  public ISubmitCallback,
		  public IPPMError,
		  public IPPMNotification,
		  public CPersistStream,
		  public ISpecifyPropertyPages
{

	DWORD m_cPropertyPageClsids;
	const CLSID **m_pPropertyPageClsids;
	
public:

    // Reveals IRTPRPHFilter
    virtual STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    DECLARE_IUNKNOWN;

    virtual HRESULT Receive(IMediaSample *pSample);
    virtual HRESULT CheckInputType(const CMediaType *mtIn) = 0;
    virtual HRESULT CheckTransform(const CMediaType *mtIn,const CMediaType *mtOut) = 0;
    virtual HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);
    virtual HRESULT DecideBufferSize(IMemAllocator *pAlloc,
                             ALLOCATOR_PROPERTIES *pProperties);
	virtual HRESULT StartStreaming();
	virtual HRESULT StopStreaming();
	virtual HRESULT CompleteConnect(PIN_DIRECTION dir,IPin *pPin) = 0;
    virtual STDMETHODIMP Pause();
	virtual CBasePin *GetPin(int n);


    // IRTPSPHFilter methods
	virtual STDMETHODIMP OverridePayloadType(BYTE bPayloadType);
    virtual STDMETHODIMP GetPayloadType(BYTE __RPC_FAR *lpbPayloadType);
    virtual STDMETHODIMP SetMaxPacketSize(DWORD dwMaxPacketSize);
    virtual STDMETHODIMP GetMaxPacketSize(LPDWORD lpdwMaxPacketSize);
    virtual STDMETHODIMP SetOutputPinMinorType(GUID gMinorType);
    virtual STDMETHODIMP GetOutputPinMinorType(GUID *lpgMinorType);
    virtual STDMETHODIMP SetInputPinMediaType(AM_MEDIA_TYPE *lpMediaPinType);
    virtual STDMETHODIMP GetInputPinMediaType(AM_MEDIA_TYPE **ppMediaPinType);
       
	// ISubmit methods for PPM
	STDMETHOD(InitSubmit)(THIS_ ISubmitCallback *pSubmitCallback);
	STDMETHOD(Submit)(THIS_ WSABUF *pWSABuffer, DWORD BufferCount, 
							void *pUserToken, HRESULT Error);
	STDMETHOD_(void,ReportError)(THIS_ HRESULT Error);
	STDMETHOD(Flush)(THIS);

	// ISubmitCallback methods for PPM
    STDMETHOD_(void,SubmitComplete)(THIS_ void *pUserToken, HRESULT Error);	
    STDMETHOD_(void,ReportError)(THIS_ HRESULT Error, int DEFAULT_PARAM_ZERO);

	// IPPMCallback methods for PPM Connection points
	virtual STDMETHODIMP PPMError(THIS_ HRESULT hError, DWORD dwSeverity, DWORD dwCookie,
										unsigned char pData[], unsigned int iDataLen);
	virtual STDMETHODIMP PPMNotification(THIS_ HRESULT hStatus, DWORD dwSeverity, DWORD dwCookie,
											unsigned char pData[], unsigned int iDataLen);
    
	// ISpecifyPropertyPages Methods
	virtual STDMETHODIMP GetPages(CAUUID *pcauuid);

   	// CPersistStream methods
	virtual HRESULT ReadFromStream(IStream *pStream);
	virtual HRESULT WriteToStream(IStream *pStream);
	virtual int SizeMax(void);
	virtual HRESULT _stdcall GetClassID(CLSID *pCLSID) = 0;
	virtual DWORD GetSoftwareVersion(void) = 0;

    // Setup helper
    virtual LPAMOVIESETUP_FILTER GetSetupData() = 0;
	virtual STDMETHODIMP GetInputPinMediaType(int iPosition, CMediaType *pMediaType);

protected:

    // Constructor
    CSPHBase(TCHAR *tszName, LPUNKNOWN punk, HRESULT *phr, CLSID clsid,
			 DWORD dwPacketNum,
			 DWORD dwPacketSize,
			 DWORD cPropPageClsids,
			 const CLSID **pPropPageClsids);
    ~CSPHBase();

	virtual HRESULT SetPPMSession();

	virtual HRESULT GetPPMConnPt();

    // The number and size of buffers to request on the output allocator
    const long m_lBufferRequest;
	DWORD m_dwBufferSize;

	//Interface pointers to PPM interfaces
	IPPMSend *m_pPPMSend;
	IPPMSendSession *m_pPPMSession;
	ISubmit *m_pPPM;
	ISubmitCallback *m_pPPMCB;
	ISubmitUser *m_pPPMSU;

	GUID m_PPMCLSIDType;
	DWORD m_dwMaxPacketSize;
	IMediaSample *m_pIInputSample;
	int m_PayloadType;
	BOOL m_bPaused;
	BOOL m_bPTSet;

	IConnectionPoint	*m_pIPPMErrorCP;
	IConnectionPoint	*m_pIPPMNotificationCP;
	
	DWORD m_dwPPMErrCookie;
	DWORD m_dwPPMNotCookie;

    // Non interface locking critical section
    CCritSec m_Lock;
	CCritSec m_cStateLock;

}; // CSPHBase


#endif // _SPH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\sph\common\sphprop.h ===
